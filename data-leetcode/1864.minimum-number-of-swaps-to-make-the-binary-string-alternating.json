[
    {
        "title": "Stream of Characters",
        "question_content": "Design an algorithm that accepts a stream of characters and checks if a suffix of these characters is a string of a given array of strings words.\nFor example, if words = [\"abc\", \"xyz\"]&nbsp;and the stream added the four characters (one by one) 'a', 'x', 'y', and 'z', your algorithm should detect that the suffix \"xyz\" of the characters \"axyz\" matches \"xyz\" from words.\nImplement the StreamChecker class:\n\n\tStreamChecker(String[] words) Initializes the object with the strings array words.\n\tboolean query(char letter) Accepts a new character from the stream and returns true if any non-empty suffix from the stream forms a word that is in words.\n\n&nbsp;\nExample 1:\n\nInput\n[\"StreamChecker\", \"query\", \"query\", \"query\", \"query\", \"query\", \"query\", \"query\", \"query\", \"query\", \"query\", \"query\", \"query\"]\n[[[\"cd\", \"f\", \"kl\"]], [\"a\"], [\"b\"], [\"c\"], [\"d\"], [\"e\"], [\"f\"], [\"g\"], [\"h\"], [\"i\"], [\"j\"], [\"k\"], [\"l\"]]\nOutput\n[null, false, false, false, true, false, true, false, false, false, false, false, true]\nExplanation\nStreamChecker streamChecker = new StreamChecker([\"cd\", \"f\", \"kl\"]);\nstreamChecker.query(\"a\"); // return False\nstreamChecker.query(\"b\"); // return False\nstreamChecker.query(\"c\"); // return False\nstreamChecker.query(\"d\"); // return True, because 'cd' is in the wordlist\nstreamChecker.query(\"e\"); // return False\nstreamChecker.query(\"f\"); // return True, because 'f' is in the wordlist\nstreamChecker.query(\"g\"); // return False\nstreamChecker.query(\"h\"); // return False\nstreamChecker.query(\"i\"); // return False\nstreamChecker.query(\"j\"); // return False\nstreamChecker.query(\"k\"); // return False\nstreamChecker.query(\"l\"); // return True, because 'kl' is in the wordlist\n\n&nbsp;\nConstraints:\n\n\t1 <= words.length <= 2000\n\t1 <= words[i].length <= 200\n\twords[i] consists of lowercase English letters.\n\tletter is a lowercase English letter.\n\tAt most 4 * 104 calls will be made to query.",
        "solutions": [
            {
                "id": 278769,
                "title": "java-trie-solution",
                "content": "Store the words in the trie with reverse order, and check the query string from the end\\n```\\nclass StreamChecker {\\n    \\n    class TrieNode {\\n        boolean isWord;\\n        TrieNode[] next = new TrieNode[26];\\n    }\\n\\n    TrieNode root = new TrieNode();\\n    StringBuilder sb = new StringBuilder();\\n\\n    public StreamChecker(String[] words) {\\n        createTrie(words);\\n    }\\n\\n    public boolean query(char letter) {\\n        sb.append(letter);\\n        TrieNode node = root;\\n        for (int i = sb.length() - 1; i >= 0 && node != null; i--) {\\n            char c = sb.charAt(i);\\n            node = node.next[c - \\'a\\'];\\n            if (node != null && node.isWord) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private void createTrie(String[] words) {\\n        for (String s : words) {\\n            TrieNode node = root;\\n            int len = s.length();\\n            for (int i = len - 1; i >= 0; i--) {\\n                char c = s.charAt(i);\\n                if (node.next[c - \\'a\\'] == null) {\\n                    node.next[c - \\'a\\'] = new TrieNode();\\n                }\\n                node = node.next[c - \\'a\\'];\\n            }\\n            node.isWord = true;\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "Store the words in the trie with reverse order, and check the query string from the end\\n```\\nclass StreamChecker {\\n    \\n    class TrieNode {\\n        boolean isWord;\\n        TrieNode[] next = new TrieNode[26];\\n    }\\n\\n    TrieNode root = new TrieNode();\\n    StringBuilder sb = new StringBuilder();\\n\\n    public StreamChecker(String[] words) {\\n        createTrie(words);\\n    }\\n\\n    public boolean query(char letter) {\\n        sb.append(letter);\\n        TrieNode node = root;\\n        for (int i = sb.length() - 1; i >= 0 && node != null; i--) {\\n            char c = sb.charAt(i);\\n            node = node.next[c - \\'a\\'];\\n            if (node != null && node.isWord) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private void createTrie(String[] words) {\\n        for (String s : words) {\\n            TrieNode node = root;\\n            int len = s.length();\\n            for (int i = len - 1; i >= 0; i--) {\\n                char c = s.charAt(i);\\n                if (node.next[c - \\'a\\'] == null) {\\n                    node.next[c - \\'a\\'] = new TrieNode();\\n                }\\n                node = node.next[c - \\'a\\'];\\n            }\\n            node.isWord = true;\\n        }\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 278250,
                "title": "python-trie-solution-with-explanation",
                "content": "# **We say**\\n`W = max(words.length)`,the maximum length of all words.\\n`N = words.size`, the number of words\\n`Q`, the number of calls of function `query`\\n<br>\\n\\n# **Solution 1: Check all words (TLE)**\\nIf we save the whole input character stream and compare with `words` one by one,\\nThe time complexity for each `query` will be `O(NW)`,\\ndepending on the size of `words`.\\n<br>\\n\\n# **Solution 2: Check Query Suffixes (Maybe AC, Maybe TLE)**\\n\\nWhile the `words.size` can be really big,\\nthe number of the suffixes of query stream is bounded.\\n\\nFor example, if the query stream is `\"abcd\"`,\\nthe suffix can be `\"abcd\"`, `\"bcd\"`, `\"cd\"`, `\"d\"`.\\n\\nWe can save all hashed words to a set.\\nFor each query, we check query stream\\'s all suffixes.\\nThe maximum length of words is `W`, we need to check `W` suffixes.\\n\\nThe time complexity for each `query` will be `O(W)` if we take the set search as `O(1)`.\\nThe overall time is `O(WQ)`.\\n<br>\\n\\n# **Solution 3: Trie (Accepted)**\\nOnly a part of suffixes can be the prefix of a word,\\nwaiting for characters coming to form a complete word.\\nInstead of checking all `W` suffixes in each query,\\nwe can just save those possible waiting prefixes in a `waiting` list.\\n\\n**Explanation**\\nInitialization:\\n1. Construct a trie\\n2. declare a global waiting list.\\n\\nQuery:\\n1. for each node in the `waiting` list,\\ncheck if there is child node for the new character.\\nIf so, add it to the new waiting list.\\n2. return true if any node in the `waiting`list is the end of a word.\\n\\n**Time Complexity**:\\n`waiting.size <= W`, where `W` is the maximum length of words.\\nSo that `O(query) = O(waiting.size) = O(W)`\\nWe will make `Q` queries, the overall time complexity is `O(QW)`\\n\\nNote that it has same complexity in the worst case as solution 2 (like \"aaaaaaaa\" for words and query),\\nIn general cases, it saves time checking all suffixes, and also the set search in a big set.\\n\\n**Space Complexity**:\\n\\n`waiting.size <= W`, where `W` is the maximum length of words.\\n`waiting` list will take `O(W)`\\n\\nAssume we have initially `N` words, at most `N` leaves in the `trie`.\\nThe size of trie is `O(NW)`.\\n\\n**Python:**\\nTime: 6000+ms\\n```py\\nclass StreamChecker(object):\\n\\n    def __init__(self, words):\\n        T = lambda: collections.defaultdict(T)\\n        self.trie = T()\\n        for w in words: reduce(dict.__getitem__, w, self.trie)[\\'#\\'] = True\\n        self.waiting = []\\n\\n    def query(self, letter):\\n        self.waiting = [node[letter] for node in self.waiting + [self.trie] if letter in node]\\n        return any(\"#\" in node for node in self.waiting)\\n```\\n<br>\\n\\n# Solution 4: Construct Trie with Reversed Words\\n\\nTime: 600 ~ 700ms\\nTime complexity: `O(WQ)`\\n\\n**Python**\\n```py\\n    def __init__(self, words):\\n        T = lambda: collections.defaultdict(T)\\n        self.trie = T()\\n        for w in words: reduce(dict.__getitem__, w[::-1], self.trie)[\\'#\\'] = True\\n        self.S = \"\"\\n        self.W = max(map(len, words))\\n\\n    def query(self, letter):\\n        self.S = (letter + self.S)[:self.W]\\n        cur = self.trie\\n        for c in self.S:\\n            if c in cur:\\n                cur = cur[c]\\n                if cur[\\'#\\'] == True:\\n                    return True\\n            else:\\n                break\\n        return False\\n```\\n",
                "solutionTags": [],
                "code": "```py\\nclass StreamChecker(object):\\n\\n    def __init__(self, words):\\n        T = lambda: collections.defaultdict(T)\\n        self.trie = T()\\n        for w in words: reduce(dict.__getitem__, w, self.trie)[\\'#\\'] = True\\n        self.waiting = []\\n\\n    def query(self, letter):\\n        self.waiting = [node[letter] for node in self.waiting + [self.trie] if letter in node]\\n        return any(\"#\" in node for node in self.waiting)\\n```\n```py\\n    def __init__(self, words):\\n        T = lambda: collections.defaultdict(T)\\n        self.trie = T()\\n        for w in words: reduce(dict.__getitem__, w[::-1], self.trie)[\\'#\\'] = True\\n        self.S = \"\"\\n        self.W = max(map(len, words))\\n\\n    def query(self, letter):\\n        self.S = (letter + self.S)[:self.W]\\n        cur = self.trie\\n        for c in self.S:\\n            if c in cur:\\n                cur = cur[c]\\n                if cur[\\'#\\'] == True:\\n                    return True\\n            else:\\n                break\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 320837,
                "title": "easily-implemented-python-trie-solution",
                "content": "Please see and vote for my solutions for\\n[208. Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree/discuss/320224/Simple-Python-solution)\\n[1233. Remove Sub-Folders from the Filesystem](https://leetcode.com/problems/remove-sub-folders-from-the-filesystem/discuss/409075/standard-python-prefix-tree-solution)\\n[1032. Stream of Characters](https://leetcode.com/problems/stream-of-characters/discuss/320837/Standard-Python-Trie-Solution)\\n[211. Add and Search Word - Data structure design](https://leetcode.com/problems/add-and-search-word-data-structure-design/discuss/319361/Simple-Python-solution)\\n[676. Implement Magic Dictionary](https://leetcode.com/problems/implement-magic-dictionary/discuss/320197/Simple-Python-solution)\\n[677. Map Sum Pairs](https://leetcode.com/problems/map-sum-pairs/discuss/320237/Simple-Python-solution)\\n[745. Prefix and Suffix Search](https://leetcode.com/problems/prefix-and-suffix-search/discuss/320712/Different-Python-solutions-with-thinking-process)\\n[425. Word Squares](https://leetcode.com/problems/word-squares/discuss/320916/Easily-implemented-Python-solution%3A-Backtrack-%2B-Trie)\\n[472. Concatenated Words](https://leetcode.com/problems/concatenated-words/discuss/322444/Python-solutions%3A-top-down-DP-Trie)\\n[212. Word Search II](https://leetcode.com/problems/word-search-ii/discuss/319071/Standard-Python-solution-with-Trie-%2B-Backtrack)\\n[336. Palindrome Pairs](https://leetcode.com/problems/palindrome-pairs/discuss/316960/Different-Python-solutions%3A-brute-force-dictionary-Trie)\\n\\n```\\nclass TrieNode():\\n    def __init__(self):\\n        self.children = {}\\n        self.isEnd = False\\n\\nclass Trie():\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def insert(self, word):\\n        node = self.root\\n        for char in word:\\n            if char not in node.children:\\n                node.children[char] = TrieNode()\\n            node = node.children[char]\\n        node.isEnd = True\\n\\nclass StreamChecker:\\n    def __init__(self, words: List[str]):\\n        self.letters = []\\n        self.trie = Trie()\\n        for w in words:\\n            self.trie.insert(w[::-1])\\n        \\n    def query(self, letter: str) -> bool:\\n        self.letters.append(letter)\\n        i = len(self.letters) - 1\\n        node = self.trie.root\\n        while i >= 0:\\n            if node.isEnd:\\n                return True\\n            if self.letters[i] not in node.children:\\n                return False\\n            node = node.children[self.letters[i]]\\n            i -= 1\\n        return node.isEnd\\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode():\\n    def __init__(self):\\n        self.children = {}\\n        self.isEnd = False\\n\\nclass Trie():\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def insert(self, word):\\n        node = self.root\\n        for char in word:\\n            if char not in node.children:\\n                node.children[char] = TrieNode()\\n            node = node.children[char]\\n        node.isEnd = True\\n\\nclass StreamChecker:\\n    def __init__(self, words: List[str]):\\n        self.letters = []\\n        self.trie = Trie()\\n        for w in words:\\n            self.trie.insert(w[::-1])\\n        \\n    def query(self, letter: str) -> bool:\\n        self.letters.append(letter)\\n        i = len(self.letters) - 1\\n        node = self.trie.root\\n        while i >= 0:\\n            if node.isEnd:\\n                return True\\n            if self.letters[i] not in node.children:\\n                return False\\n            node = node.children[self.letters[i]]\\n            i -= 1\\n        return node.isEnd\\n```",
                "codeTag": "Java"
            },
            {
                "id": 807429,
                "title": "c-trie-solution-simple-and-clean-explained",
                "content": "**Like it? please upvote...**\\n```\\nclass StreamChecker {\\npublic:\\n    StreamChecker(vector<string>& words) {\\n        // insert reversed word into trie and keep track of the length of longest word\\n        for (auto& word: words) \\n        {\\n            trie.insert_reversed(word);\\n            if (word.length() > longest_word)\\n                longest_word = word.length();\\n        }\\n    }\\n    \\n    bool query(char letter) {\\n        queries.insert(queries.begin(), letter);\\n        // keep in queries only the \"longest word\" last queries, because we don\\'t need the other ones anymore\\n        if (queries.size() > longest_word)\\n            queries.pop_back();\\n        Trie* cur = &trie;\\n        for (auto it = queries.begin(); it!=queries.end();++it)\\n        {\\n            if (cur->is_leaf) return true;\\n            if (cur->children[*it -\\'a\\'] == NULL) return false;\\n            cur = cur->children[*it-\\'a\\'];\\n        }\\n        return cur->is_leaf;\\n    }\\nprivate:\\n    \\n    class Trie {\\n    public:\\n        Trie() {\\n            this->is_leaf = false;\\n            for(int i=0;i<26;i++)\\n                this->children[i] = NULL;\\n        }\\n        \\n        void insert_reversed(string word) {\\n            reverse(word.begin(), word.end());\\n            Trie* root = this;\\n            for(int i=0;i<word.length();i++)\\n            {\\n                int index = word[i] - \\'a\\';\\n                if (root->children[index] == NULL)\\n                    root->children[index] = new Trie();\\n                root = root->children[index];\\n            }\\n            root->is_leaf = true;\\n        }\\n        \\n    bool is_leaf;\\n    Trie* children[26];\\n    };\\n    \\n    Trie trie;\\n    vector<char> queries;\\n    int longest_word=0;\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass StreamChecker {\\npublic:\\n    StreamChecker(vector<string>& words) {\\n        // insert reversed word into trie and keep track of the length of longest word\\n        for (auto& word: words) \\n        {\\n            trie.insert_reversed(word);\\n            if (word.length() > longest_word)\\n                longest_word = word.length();\\n        }\\n    }\\n    \\n    bool query(char letter) {\\n        queries.insert(queries.begin(), letter);\\n        // keep in queries only the \"longest word\" last queries, because we don\\'t need the other ones anymore\\n        if (queries.size() > longest_word)\\n            queries.pop_back();\\n        Trie* cur = &trie;\\n        for (auto it = queries.begin(); it!=queries.end();++it)\\n        {\\n            if (cur->is_leaf) return true;\\n            if (cur->children[*it -\\'a\\'] == NULL) return false;\\n            cur = cur->children[*it-\\'a\\'];\\n        }\\n        return cur->is_leaf;\\n    }\\nprivate:\\n    \\n    class Trie {\\n    public:\\n        Trie() {\\n            this->is_leaf = false;\\n            for(int i=0;i<26;i++)\\n                this->children[i] = NULL;\\n        }\\n        \\n        void insert_reversed(string word) {\\n            reverse(word.begin(), word.end());\\n            Trie* root = this;\\n            for(int i=0;i<word.length();i++)\\n            {\\n                int index = word[i] - \\'a\\';\\n                if (root->children[index] == NULL)\\n                    root->children[index] = new Trie();\\n                root = root->children[index];\\n            }\\n            root->is_leaf = true;\\n        }\\n        \\n    bool is_leaf;\\n    Trie* children[26];\\n    };\\n    \\n    Trie trie;\\n    vector<char> queries;\\n    int longest_word=0;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 713356,
                "title": "explaining-by-examples-what-constitutes-an-expected-solution-for-future-readers",
                "content": "The Description section of this problem lacks good examples, and thus implementing a solution for this problem is probably accompanied by a feeling of \"I hope that *that\\'s* what is expected as a solution\", or even: \"Well, this is kind of an easy question, why would one need to use a Trie\"?\\n\\nI come to the rescue of future readers by giving a better example of an expected output.\\n\\nConsider the following words input:\\n```[\"baa\",\"aa\",\"aaaa\",\"abbbb\",\"aba\"]```\\n\\nWith the following queries input:\\n```[\\'a\\'],[\\'a\\'],[\\'a\\'],[\\'b\\'],[\\'a\\'],[\\'b\\'],[\\'a\\']```\\n\\nThe expected output is:\\n```false,true,true,false,true,false,true```\\n\\nLet\\'s focus on the reason behind each ```true``` result: \\n1. The first ```true``` is expected because the first query and the second query spell the given word ```aa```. \\n2. The second ```true``` is expected because the second query and the third query spell the given word ```aa```. \\n3. The third ```true``` is expected because the 3rd, 4th and 5th queries spell the given word ```aba```. \\n4. The fourth ```true``` is expected because the 5th, 6th and 7th queries spell the given word ```aba```. \\n\\nHopefully, this makes things harder for you :)\\n",
                "solutionTags": [],
                "code": "```[\"baa\",\"aa\",\"aaaa\",\"abbbb\",\"aba\"]```\n```[\\'a\\'],[\\'a\\'],[\\'a\\'],[\\'b\\'],[\\'a\\'],[\\'b\\'],[\\'a\\']```\n```false,true,true,false,true,false,true```\n```true```\n```true```\n```aa```\n```true```\n```aa```\n```true```\n```aba```\n```true```\n```aba```",
                "codeTag": "Unknown"
            },
            {
                "id": 1610834,
                "title": "c-python-3-simple-solution-w-explanation-hashset-trie-rolling-hash",
                "content": "We are given an array of words - `words` and then a stream of letters `c`. For each query, we need to find if any suffix string of query stream formed till now is found in `words` or not.\\n\\n---\\n\\n\\u274C ***Solution - I (Hashset)***\\n\\nWe can insert all the words into hashset and then check if any suffix of query stream exists in hashset or not. For efficiency, we need to insert the words in hashset in reverse order. That\\'s because in the `query` function we will be forming reverse suffix strings starting from the last word in query stream till the 1st word.\\n\\nAlso, since the query stream length can get much longer, we can optimize by only checking for suffix functions which are less than or equal to `L` in length (`L = length of longest word in words`).\\n\\n**C++**\\n```cpp\\nclass StreamChecker {\\n    unordered_set<string> st;\\n    string queryStream = \"\";\\n    int L = 0;\\npublic:\\n    StreamChecker(vector<string>& words) { \\n        for(auto& w : words) {\\n            reverse(begin(w), end(w));\\n            st.insert(w);\\n            L = max(L, (int)size(w));\\n        }\\n    }\\n    \\n    bool query(char c) {\\n        queryStream += c;\\n        string suff = \"\";\\n        for(int i = size(queryStream)-1; i >= max(0, (int)size(queryStream)-L); i--) {\\n            suff += queryStream[i];\\n            if(st.count(suff)) return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass StreamChecker:\\n    def __init__(self, words):\\n        self.st, self.L, self.qs = {w[::-1] for w in words}, len(max(words, key=len)), \"\"\\n\\n    def query(self, c):\\n        self.qs += c\\n        return any(self.qs[i:][::-1] in self.st for i in range(len(self.qs), max(-1, len(self.qs)-1-self.L), -1))\\n```\\n\\n***Time Complexity :*** \\n1. **`StreamChecker`** : `O(NL)`, where `N` is the number of elements in `words` and `L` is the maximum length of word.\\n2. **`query`** : <code>O(L<sup>2</sup>)</code>, we check for `L` different suffix strings of `queryStream` if each of them exists in hashset or not. It takes `O(L)` time for every string to be checked for existence in hashset\\n\\n\\tThus, the overall time complexity can be written as **<code>O(NL + QL<sup>2</sup>)</code>**, where `Q` is the number of queries\\n\\n***Space Complexity :*** `O(NL + Q)`, for maintaining hashset and query stream. Can be optmized down to `O(NL)` by maintaining query stream only upto length `L`.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Trie on Reversed Words)***\\n\\nWe need to check if any suffix of query is found in `words`. In the previous approach, we were checking every reverse suffix string of query stream after a new letter was added in the stream. But we were doing this for many redundant cases as well. \\nFor eg. Consider `words = [\"hello\", \"world\"]` and current query stream is `\"abcsidhbfvdefg\"`. In this case, we were unnecessarily checking for all suffixes such as `\"g\", \"gf\", \"gfe\", \"gfed\", ...` (we were checking suffixes in reverse order) when we know that none of these suffix would match any word in `words` since they dont start from `h` or `w`. This can be generalized to cases where 1st letter matches but 2nd didnt match to any word, and so on...\\n\\nWe need a way to terminate earlier when we find that none of  suffix strings formed further from the current query stream would be found in `words`. This can be achieved by using a Trie. We will firstly insert all the word from `words` into Trie in reversed order. Note that reverse would be more efficient as that allows us to iteratively check existence of reverse suffix string from current query stream by adding one character after another till we either find the word in Trie or terminate when current suffix isnt found. While in the case of storing words without reversing would require us to form every possible suffix of current query stream and check existence in Trie for each one-by-one which would be similar to previous approach.\\n\\nSo, once we form the Trie by inserting reversed words, we keep adding new letters to current query stream and check if the suffix of this stream was present in `words`. \\n* We search in the Trie starting from the last word in current query stream. \\n* If a letter-link from current trie node to next node is found, we move to that node. \\n* This is done iteratively by taking next character from query stream and checking if letter-link for that character exists in Trie. \\n* If at any point we find a word ending at this node (denoted by `endsHere`), we return true as we found a suffix in the Trie.\\n* If we reach end of query stream or we dont find letter-link for next character from stream, then we return false as no suffix was found in Trie.\\n\\n\\n**C++**\\n```cpp\\nclass Trie {\\n    Trie* chars[26]{};\\n    bool endsHere = false;\\npublic:    \\n    void insert(string& s) {                              // inserts a string in Trie\\n        auto cur = this;\\n        for(int i = size(s)-1; ~i; i--) {                 // insert in reverse order\\n            if(!cur -> chars[s[i]-\\'a\\'])\\n                cur -> chars[s[i]-\\'a\\'] = new Trie();      // add new node for current character\\n            cur = cur -> chars[s[i]-\\'a\\'];                 // move to that character\\'s node\\n        }\\n        cur -> endsHere = true;                           // mark that a word ends at this node\\n    }\\n    bool search(string& s) {                              // searches for a suffix of string\\n        auto cur = this;\\n        for(int i = size(s)-1; ~i; i--) {\\n            if(!cur -> chars[s[i]-\\'a\\']) return false;     // no letter-link to next character exists\\n            cur = cur -> chars[s[i]-\\'a\\'];\\n            if(cur -> endsHere) return true;              // found a  word ending at this node => suffix of s found in Trie\\n        }\\n        return false;\\n    }\\n};\\nclass StreamChecker {\\n    Trie *T = new Trie();\\n    string queryStream = \"\";\\npublic:\\n    StreamChecker(vector<string>& words) {\\n        for(auto& w : words) T -> insert(w);\\n    }\\n    \\n    bool query(char c) {\\n        queryStream += c;                                  // add new character to query stream\\n        return T -> search(queryStream);                   // and search for any suffix in Trie\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Trie:\\n    def __init__(self):\\n        self.chars, self.ends_here = defaultdict(Trie), False\\n    def insert(self, s):\\n        cur = self\\n        for c in reversed(s):\\n            cur = cur.chars[c]\\n        cur.ends_here = True\\n    def search(self, s):\\n        cur = self\\n        for c in s:\\n            if c not in cur.chars: return False\\n            cur = cur.chars[c]\\n            if cur.ends_here: return True\\n    \\nclass StreamChecker:\\n    def __init__(self, words):\\n        self.T, self.query_stream = Trie(), deque()\\n        for w in words:\\n            self.T.insert(w)\\n    def query(self, c):\\n        self.query_stream.appendleft(c)\\n        return self.T.search(self.query_stream)\\n```\\n\\n***Time Complexity :*** \\n1. **`StreamChecker`** : `O(NL)`, where `N` is the number of elements in `words` and `L` is the maximum length of word.\\n2. **`query`** : `O(L)`\\n\\n\\tThus, the overall time complexity can be written as **<code>O(NL + QL)</code>**.\\n\\n***Space Complexity :*** `O(NL + Q)`, for maintaining Trie and query stream. The space complexity can be brought down to `O(NL)` by only maintaining queryStream upto length `L` as follows - \\n\\n<blockquote>\\n<details>\\n<summary><b>Slightly Space-Optimized Version</b></summary>\\n\\n```cpp\\nclass Trie {\\n    Trie* chars[26]{};\\n    int endsHere = false;\\npublic:    \\n    void insert(string& s) {\\n        auto cur = this;\\n        for(int i = size(s)-1; ~i; i--) {\\n            if(!cur -> chars[s[i]-\\'a\\'])\\n                cur -> chars[s[i]-\\'a\\'] = new Trie();\\n            cur = cur -> chars[s[i]-\\'a\\'];\\n        }\\n        cur -> endsHere = true;\\n    }\\n    bool query(deque<char>& dq) {\\n        auto cur = this;\\n        for(auto c : dq) {\\n            if(!cur -> chars[c-\\'a\\']) return false;\\n            cur = cur -> chars[c-\\'a\\'];\\n            if(cur -> endsHere) return true;\\n        }\\n        return false;\\n    }\\n};\\nclass StreamChecker {\\n    Trie *T = new Trie();\\n    deque<char> queryStream;\\n    int L = 0;\\npublic:\\n    StreamChecker(vector<string>& words) {\\n        for(auto& w : words) \\n            T -> insert(w),\\n            L = max(L, int(size(w)));\\n    }\\n    \\n    bool query(char c) {\\n        queryStream.push_front(c);\\n        if(size(dq) > L) queryStream.pop_back();\\n        return T -> query(queryStream);\\n    }\\n};\\n```\\n\\n***Time Complexity :*** \\n1. **`StreamChecker`** : `O(NL)`\\n2. **`query`** : `O(L)`\\n\\n\\tThus, the overall time complexity can be written as **<code>O(NL + QL)</code>**.\\n\\n***Space Complexity :*** `O(NL)`, for maintaining Trie\\n\\n</details>\\n</blockquote>\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Hashset of Rolling Hashes of Suffix)***\\n\\nAs we have seen, the 1st approach failed due to begin unable to terminate early in redundant cases. To optimize this, we can use a custom/rolling hash function and store all suffix hashes of all words in a hashset: `suffixHash`. Finally, we will store the final hash of complete word as well in another hashset: `wordHash`.\\n\\nSimilarly, while checking for existence of suffix in `queryStream`, we will calculate the same rolling hash of suffix of query stream and if at any point the rolling hash is not found in `suffixHash`, we can terminate furter search here itself. If we find a hash that exists in `suffixHash`, then we will check if that hash exists in `wordHash` as well. If we find it there, we can return true since this denotes that we found suffix with same hash as that of an word from `words`.\\n\\nFor calculating rolling hash, we need a good function that gives unique hash to different strings and minimizes the collision. I have used a common hash function used for hashing strings (**[referred from here](https://cp-algorithms.com/string/string-hashing.html)**).\\n\\n**C++**\\n```cpp\\nclass StreamChecker {\\n    unordered_set<int> suffixHash, wordHash;\\n    string queryStream = \"\";\\n\\t// returns rolling hash after adding a new character c\\n    int rollingHash(long& hash, long& p_pow, char c, int mod = 1e9+7) {\\n        p_pow = (p_pow * 31) % mod;\\n        return hash = (hash + (c-\\'a\\'+1) * p_pow) % mod;\\n    }\\npublic:    \\n    StreamChecker(vector<string>& words) { \\n        for(auto& w : words) {\\n            long hash = 0, p_pow = 1;\\n            for(int i = size(w)-1; ~i; i--) \\n                suffixHash.insert(rollingHash(hash, p_pow, w[i]));                          // insert all suffix hashes of each word\\n            wordHash.insert(hash);                                                          // complete word hash\\n        }\\n    }\\n    bool query(char c) {\\n        queryStream += c;\\n        for(long i = size(queryStream)-1, hash = 0, p_pow = 1; ~i; i--)             \\n            if(!suffixHash.count(rollingHash(hash, p_pow, queryStream[i]))) return false;   // check if same suffix hash exists in suffixHash set.\\n            else if(wordHash.count(hash)) return true;                                      // check if there\\'s a word with same hash\\n        \\n        return false;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass StreamChecker:\\n    def rollingHash(self, Hash, p_pow, c, mod = 1e9+7):\\n        return ((Hash + ord(c) * p_pow) % mod, (p_pow * 31) % mod)\\n\\t\\t\\n    def __init__(self, words):\\n        self.suffix_hash, self.word_hash, self.query_stream = set(), set(), deque()\\n        for w in words:\\n            Hash, p_pow = 0, 1\\n            for c in w[::-1]:\\n                Hash, p_pow = self.rollingHash(Hash, p_pow, c)\\n                self.suffix_hash.add(Hash)\\n            self.word_hash.add(Hash)\\n            \\n    def query(self, c):\\n        self.query_stream.appendleft(c)\\n        Hash, p_pow = 0, 1\\n        for c in self.query_stream:\\n            Hash, p_pow = self.rollingHash(Hash, p_pow, c)\\n            if Hash not in self.suffix_hash: return False\\n            elif Hash in self.word_hash: return True\\n```\\n\\n***Time Complexity :*** \\n1. **`StreamChecker`** : `O(NL)`\\n2. **`query`** : `O(L)`\\n\\n\\tThus, the overall time complexity can be written as **<code>O(NL + QL)</code>**.\\n\\n***Space Complexity :*** `O(NL + Q)`, for maintaining `suffixHash`, `wordHash` & `queryStream`. Can be reduced to `O(NL)` in same way as above.\\n\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---\\n",
                "solutionTags": [],
                "code": "```cpp\\nclass StreamChecker {\\n    unordered_set<string> st;\\n    string queryStream = \"\";\\n    int L = 0;\\npublic:\\n    StreamChecker(vector<string>& words) { \\n        for(auto& w : words) {\\n            reverse(begin(w), end(w));\\n            st.insert(w);\\n            L = max(L, (int)size(w));\\n        }\\n    }\\n    \\n    bool query(char c) {\\n        queryStream += c;\\n        string suff = \"\";\\n        for(int i = size(queryStream)-1; i >= max(0, (int)size(queryStream)-L); i--) {\\n            suff += queryStream[i];\\n            if(st.count(suff)) return true;\\n        }\\n        return false;\\n    }\\n};\\n```\n```python\\nclass StreamChecker:\\n    def __init__(self, words):\\n        self.st, self.L, self.qs = {w[::-1] for w in words}, len(max(words, key=len)), \"\"\\n\\n    def query(self, c):\\n        self.qs += c\\n        return any(self.qs[i:][::-1] in self.st for i in range(len(self.qs), max(-1, len(self.qs)-1-self.L), -1))\\n```\n```cpp\\nclass Trie {\\n    Trie* chars[26]{};\\n    bool endsHere = false;\\npublic:    \\n    void insert(string& s) {                              // inserts a string in Trie\\n        auto cur = this;\\n        for(int i = size(s)-1; ~i; i--) {                 // insert in reverse order\\n            if(!cur -> chars[s[i]-\\'a\\'])\\n                cur -> chars[s[i]-\\'a\\'] = new Trie();      // add new node for current character\\n            cur = cur -> chars[s[i]-\\'a\\'];                 // move to that character\\'s node\\n        }\\n        cur -> endsHere = true;                           // mark that a word ends at this node\\n    }\\n    bool search(string& s) {                              // searches for a suffix of string\\n        auto cur = this;\\n        for(int i = size(s)-1; ~i; i--) {\\n            if(!cur -> chars[s[i]-\\'a\\']) return false;     // no letter-link to next character exists\\n            cur = cur -> chars[s[i]-\\'a\\'];\\n            if(cur -> endsHere) return true;              // found a  word ending at this node => suffix of s found in Trie\\n        }\\n        return false;\\n    }\\n};\\nclass StreamChecker {\\n    Trie *T = new Trie();\\n    string queryStream = \"\";\\npublic:\\n    StreamChecker(vector<string>& words) {\\n        for(auto& w : words) T -> insert(w);\\n    }\\n    \\n    bool query(char c) {\\n        queryStream += c;                                  // add new character to query stream\\n        return T -> search(queryStream);                   // and search for any suffix in Trie\\n    }\\n};\\n```\n```python\\nclass Trie:\\n    def __init__(self):\\n        self.chars, self.ends_here = defaultdict(Trie), False\\n    def insert(self, s):\\n        cur = self\\n        for c in reversed(s):\\n            cur = cur.chars[c]\\n        cur.ends_here = True\\n    def search(self, s):\\n        cur = self\\n        for c in s:\\n            if c not in cur.chars: return False\\n            cur = cur.chars[c]\\n            if cur.ends_here: return True\\n    \\nclass StreamChecker:\\n    def __init__(self, words):\\n        self.T, self.query_stream = Trie(), deque()\\n        for w in words:\\n            self.T.insert(w)\\n    def query(self, c):\\n        self.query_stream.appendleft(c)\\n        return self.T.search(self.query_stream)\\n```\n```cpp\\nclass Trie {\\n    Trie* chars[26]{};\\n    int endsHere = false;\\npublic:    \\n    void insert(string& s) {\\n        auto cur = this;\\n        for(int i = size(s)-1; ~i; i--) {\\n            if(!cur -> chars[s[i]-\\'a\\'])\\n                cur -> chars[s[i]-\\'a\\'] = new Trie();\\n            cur = cur -> chars[s[i]-\\'a\\'];\\n        }\\n        cur -> endsHere = true;\\n    }\\n    bool query(deque<char>& dq) {\\n        auto cur = this;\\n        for(auto c : dq) {\\n            if(!cur -> chars[c-\\'a\\']) return false;\\n            cur = cur -> chars[c-\\'a\\'];\\n            if(cur -> endsHere) return true;\\n        }\\n        return false;\\n    }\\n};\\nclass StreamChecker {\\n    Trie *T = new Trie();\\n    deque<char> queryStream;\\n    int L = 0;\\npublic:\\n    StreamChecker(vector<string>& words) {\\n        for(auto& w : words) \\n            T -> insert(w),\\n            L = max(L, int(size(w)));\\n    }\\n    \\n    bool query(char c) {\\n        queryStream.push_front(c);\\n        if(size(dq) > L) queryStream.pop_back();\\n        return T -> query(queryStream);\\n    }\\n};\\n```\n```cpp\\nclass StreamChecker {\\n    unordered_set<int> suffixHash, wordHash;\\n    string queryStream = \"\";\\n\\t// returns rolling hash after adding a new character c\\n    int rollingHash(long& hash, long& p_pow, char c, int mod = 1e9+7) {\\n        p_pow = (p_pow * 31) % mod;\\n        return hash = (hash + (c-\\'a\\'+1) * p_pow) % mod;\\n    }\\npublic:    \\n    StreamChecker(vector<string>& words) { \\n        for(auto& w : words) {\\n            long hash = 0, p_pow = 1;\\n            for(int i = size(w)-1; ~i; i--) \\n                suffixHash.insert(rollingHash(hash, p_pow, w[i]));                          // insert all suffix hashes of each word\\n            wordHash.insert(hash);                                                          // complete word hash\\n        }\\n    }\\n    bool query(char c) {\\n        queryStream += c;\\n        for(long i = size(queryStream)-1, hash = 0, p_pow = 1; ~i; i--)             \\n            if(!suffixHash.count(rollingHash(hash, p_pow, queryStream[i]))) return false;   // check if same suffix hash exists in suffixHash set.\\n            else if(wordHash.count(hash)) return true;                                      // check if there\\'s a word with same hash\\n        \\n        return false;\\n    }\\n};\\n```\n```python\\nclass StreamChecker:\\n    def rollingHash(self, Hash, p_pow, c, mod = 1e9+7):\\n        return ((Hash + ord(c) * p_pow) % mod, (p_pow * 31) % mod)\\n\\t\\t\\n    def __init__(self, words):\\n        self.suffix_hash, self.word_hash, self.query_stream = set(), set(), deque()\\n        for w in words:\\n            Hash, p_pow = 0, 1\\n            for c in w[::-1]:\\n                Hash, p_pow = self.rollingHash(Hash, p_pow, c)\\n                self.suffix_hash.add(Hash)\\n            self.word_hash.add(Hash)\\n            \\n    def query(self, c):\\n        self.query_stream.appendleft(c)\\n        Hash, p_pow = 0, 1\\n        for c in self.query_stream:\\n            Hash, p_pow = self.rollingHash(Hash, p_pow, c)\\n            if Hash not in self.suffix_hash: return False\\n            elif Hash in self.word_hash: return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1610403,
                "title": "java-simple-solution-trie-detailed-explanation-using-image",
                "content": "**Intution:** We gonna use trie data structure to store the given words for easy searching. So firstly store all the given words in Trie but the catch here is that store every word in **reverse order** because you have to search for prefix every time so u don\\'t have to search full trie from starting to just find last few characters.\\nAfter filling trie now using query function read the next coming letter and append it to your StringBuilder and check for the current String/stream if it is present in trie or not.\\n** One more important thing here is that Don\\'t just keep adding letters in your StringBuilder....find the **maxLength** from given words array and don\\'t let the size of StringBuider increase more than that...otherwise it will give you TLE due to memory out of space problem as StringBuilder will keep growing otherwise.\\n\\n![image](https://assets.leetcode.com/users/images/1a4384df-5692-4ecb-9499-25ad65143da4_1638581642.2779667.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/479a1cef-6bab-4c16-9b9f-5422bc9f9144_1638581652.3289752.jpeg)\\n\\n\\n```\\nclass StreamChecker {\\n\\n    class TrieNode{\\n        boolean isWord;\\n        TrieNode children[] = new TrieNode[26];\\n    }\\n    \\n    TrieNode root = new TrieNode();\\n    int maxSize;\\n    StringBuilder sb = new StringBuilder();\\n    \\n    public StreamChecker(String[] words) {\\n        insert(words);\\n    }\\n    \\n    public boolean query(char letter) {\\n        if(sb.length()>=maxSize){\\n            sb.deleteCharAt(0);\\n        }\\n        sb.append(letter);\\n        TrieNode curr = root;\\n        \\n        for(int i=sb.length()-1;i>=0;i--){\\n            char ch = sb.charAt(i);\\n            \\n            if(curr!=null) curr = curr.children[ch-\\'a\\'];\\n            \\n            if(curr!=null && curr.isWord) return true;\\n        }\\n        return false;\\n    }\\n    \\n    public void insert(String[] words){\\n        \\n        for(String s : words){\\n            maxSize = Math.max(maxSize,s.length());\\n            TrieNode curr = root;\\n            for(int i = s.length()-1;i>=0;i--){\\n                char ch = s.charAt(i);\\n                if(curr.children[ch-\\'a\\']==null){\\n                    curr.children[ch-\\'a\\'] = new TrieNode();\\n                }\\n                curr = curr.children[ch-\\'a\\'];\\n            }\\n            curr.isWord = true;\\n        }\\n    }\\n}\\n```\\n\\nI hope this helped u in uderstanding this question...Thanks!!",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass StreamChecker {\\n\\n    class TrieNode{\\n        boolean isWord;\\n        TrieNode children[] = new TrieNode[26];\\n    }\\n    \\n    TrieNode root = new TrieNode();\\n    int maxSize;\\n    StringBuilder sb = new StringBuilder();\\n    \\n    public StreamChecker(String[] words) {\\n        insert(words);\\n    }\\n    \\n    public boolean query(char letter) {\\n        if(sb.length()>=maxSize){\\n            sb.deleteCharAt(0);\\n        }\\n        sb.append(letter);\\n        TrieNode curr = root;\\n        \\n        for(int i=sb.length()-1;i>=0;i--){\\n            char ch = sb.charAt(i);\\n            \\n            if(curr!=null) curr = curr.children[ch-\\'a\\'];\\n            \\n            if(curr!=null && curr.isWord) return true;\\n        }\\n        return false;\\n    }\\n    \\n    public void insert(String[] words){\\n        \\n        for(String s : words){\\n            maxSize = Math.max(maxSize,s.length());\\n            TrieNode curr = root;\\n            for(int i = s.length()-1;i>=0;i--){\\n                char ch = s.charAt(i);\\n                if(curr.children[ch-\\'a\\']==null){\\n                    curr.children[ch-\\'a\\'] = new TrieNode();\\n                }\\n                curr = curr.children[ch-\\'a\\'];\\n            }\\n            curr.isWord = true;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 278928,
                "title": "screencast-of-leetcode-weekly-contest-133-face-jk",
                "content": "https://www.youtube.com/watch?v=sv028Ula0Ng",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=sv028Ula0Ng",
                "codeTag": "Unknown"
            },
            {
                "id": 807541,
                "title": "python-trie-with-reversed-words-explained",
                "content": "It is pretty straightforward to use Tries for these type of problems, however it is not obvious how. My first solution was as it is given in the hint of this problem: create Trie of all given words and keep also set of all possible nodes in our trie for suffixes of our stream. However it was working very slow, >10000ms initialy and 7000-9000ms after optimizations. \\n\\nSo, alternative idea is to put all our words to Trie in reversed order. Why it can be a good idea? Imagine we have a current stream `abcdefghij` and we have dictionary `[hij, xyz, abc, hijk]` Then what we need to check if some suffix of this word in our dictinonary. It means that `jihgfedcba` should have `jih` as prefix. If we add one letter to strim, so we have `abcdefghijk`, we need to find prefixes in `kjihgfedcba` and so on.\\n\\nSo, what we have in my code?\\n\\n1. `Trie` class with initialization and `insert` function. Each node has children and flag `.end_node`, which says if some word ends with this node.\\n2. Put all reversed words to our Trie\\n3. For each new element of stream, we keep it in `deque`, so we can easily add it to the left of our reversed stream. Then we traverse our `Trie` and look if we reached some end node.\\n\\n**Complexity**: Let `m` be the longest length of word and `n` be number of words. Also let `w` be number of `query(letter)`. Then space complexity is `O(mn + w)` to keep our tree. In fact we can cut our `deque` if it has length more than `m`, because we never reach nodes which are far in our deque. Time complexity is `O(wm)`, because for each of `w` queries we need to  traverse at most `m` letters in our trie.\\n\\nNote that other method complexity I mentioned in the beginning in theory is also `O(wm)`, but in practise it works like `10` times slower. The problem is with tests like `aaaaaa...aaab`.\\n\\n\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children, self.end_node = {}, 0\\n         \\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n\\n    def insert(self, word):\\n        root = self.root\\n        for symbol in word:\\n            root = root.children.setdefault(symbol, TrieNode())\\n        root.end_node = 1\\n\\nclass StreamChecker:\\n    def __init__(self, words):\\n        self.trie = Trie()\\n        self.Stream = deque()\\n        for word in words: self.trie.insert(word[::-1])\\n         \\n    def query(self, letter):\\n        self.Stream.appendleft(letter)\\n        cur = self.trie.root\\n        for c in self.Stream:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                if cur.end_node: return True\\n            else: break\\n        return False\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children, self.end_node = {}, 0\\n         \\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n\\n    def insert(self, word):\\n        root = self.root\\n        for symbol in word:\\n            root = root.children.setdefault(symbol, TrieNode())\\n        root.end_node = 1\\n\\nclass StreamChecker:\\n    def __init__(self, words):\\n        self.trie = Trie()\\n        self.Stream = deque()\\n        for word in words: self.trie.insert(word[::-1])\\n         \\n    def query(self, letter):\\n        self.Stream.appendleft(letter)\\n        cur = self.trie.root\\n        for c in self.Stream:\\n            if c in cur.children:\\n                cur = cur.children[c]\\n                if cur.end_node: return True\\n            else: break\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 807322,
                "title": "python-by-search-in-trie-w-visualization",
                "content": "Python by search in Trie\\n\\n---\\n\\n**Hint**:\\n\\nBecause [description](https://leetcode.com/problems/stream-of-characters/) asks us to search from tail, the **last k characters** queried, where k >= 1,\\nwe build a trie and search word in **reversed order** to satisfy the requirement.\\n\\n---\\n\\n**Visualization**\\n\\n![image](https://assets.leetcode.com/users/images/59b20265-1fb8-4207-8a1e-6b53b706089c_1598183327.0370915.png)\\n\\n![image](https://assets.leetcode.com/users/images/7ed60434-2301-4828-ac1a-15718fa06152_1598183418.2371585.png)\\n\\n![image](https://assets.leetcode.com/users/images/d5474a12-a01d-46c9-9732-4ec109ae73ce_1598183427.5589814.png)\\n\\n![image](https://assets.leetcode.com/users/images/0689b1dc-f22f-448c-a7c1-7df0110b3a53_1598183437.320374.png)\\n\\n![image](https://assets.leetcode.com/users/images/852bb69c-d2df-4dee-882a-6ba68f6f708b_1598183447.3071404.png)\\n\\n---\\n\\n**Implementation**:\\n\\n```\\nfrom collections import defaultdict\\n\\nclass TrieNode:\\n    \\n    def __init__(self):\\n        \\n        self.dict = defaultdict(TrieNode)\\n        self.is_word = False\\n\\n\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        \\'\\'\\'\\n        Build a trie for each word in reversed order\\n        \\'\\'\\'\\n\\t\\t\\n        # for user query record, init as empty string\\n        self.prefix = \\'\\'\\n        \\n        # for root node of trie, init as empty Trie\\n        self.trie = TrieNode()\\n        \\n        for word in words:\\n            \\n            cur_node = self.trie\\n            \\n\\t\\t\\t# make word in reverse order\\n            word = word[::-1]\\n            \\n            for char in word:                \\n                cur_node = cur_node.dict[ char ]\\n            \\n\\t\\t\\t# mark this trie path as a valid word\\n            cur_node.is_word = True\\n            \\n            \\n            \\n    def query(self, letter: str) -> bool:\\n        \\'\\'\\'\\n        Search user input in trie with reversed order\\n        \\'\\'\\'\\n\\t\\t\\n        self.prefix += letter\\n        \\n        cur_node = self.trie\\n        for char in reversed(self.prefix):\\n            \\n            if char not in cur_node.dict:\\n                # current char not in Trie, impossible to match words\\n                break\\n            \\n            cur_node = cur_node.dict[char]\\n        \\n            if cur_node.is_word:\\n                # user input match a word in Trie\\n                return True\\n        \\n        # No match\\n        return False\\n```\\n\\n---\\n\\nReference:\\n\\n[1] [Wiki: Trie](https://en.wikipedia.org/wiki/Trie)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Trie"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass TrieNode:\\n    \\n    def __init__(self):\\n        \\n        self.dict = defaultdict(TrieNode)\\n        self.is_word = False\\n\\n\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        \\'\\'\\'\\n        Build a trie for each word in reversed order\\n        \\'\\'\\'\\n\\t\\t\\n        # for user query record, init as empty string\\n        self.prefix = \\'\\'\\n        \\n        # for root node of trie, init as empty Trie\\n        self.trie = TrieNode()\\n        \\n        for word in words:\\n            \\n            cur_node = self.trie\\n            \\n\\t\\t\\t# make word in reverse order\\n            word = word[::-1]\\n            \\n            for char in word:                \\n                cur_node = cur_node.dict[ char ]\\n            \\n\\t\\t\\t# mark this trie path as a valid word\\n            cur_node.is_word = True\\n            \\n            \\n            \\n    def query(self, letter: str) -> bool:\\n        \\'\\'\\'\\n        Search user input in trie with reversed order\\n        \\'\\'\\'\\n\\t\\t\\n        self.prefix += letter\\n        \\n        cur_node = self.trie\\n        for char in reversed(self.prefix):\\n            \\n            if char not in cur_node.dict:\\n                # current char not in Trie, impossible to match words\\n                break\\n            \\n            cur_node = cur_node.dict[char]\\n        \\n            if cur_node.is_word:\\n                # user input match a word in Trie\\n                return True\\n        \\n        # No match\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 278738,
                "title": "python-ac-concise-straightforward",
                "content": "```\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.s = \\'\\'\\n        self.dic = collections.defaultdict(set)\\n        for w in words:\\n            self.dic[w[-1]].add(w)\\n                \\n\\n    def query(self, letter: str) -> bool:\\n        self.s += letter\\n        return any(self.s.endswith(w) for w in self.dic[letter])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.s = \\'\\'\\n        self.dic = collections.defaultdict(set)\\n        for w in words:\\n            self.dic[w[-1]].add(w)\\n                \\n\\n    def query(self, letter: str) -> bool:\\n        self.s += letter\\n        return any(self.s.endswith(w) for w in self.dic[letter])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 278893,
                "title": "trie-reverse-check-and-track-pointers",
                "content": "# Reverse Check Solution\\nWe reverse our strings and populate Trie. Then, we accumulate the query string and search in Trie in the reverse order.\\n```\\nclass Trie {\\npublic:\\n  Trie *arr[26] = {};\\n  bool end = false;\\n  void insert(string &word, int pos = 0) {\\n    if (pos == word.size()) end = true;\\n    else {\\n      auto idx = word[pos] - \\'a\\';\\n      if (arr[idx] == nullptr) arr[idx] = new Trie();\\n      arr[idx]->insert(word, pos + 1);\\n    }\\n  }\\n  bool reverse_check(string &word, int pos) {\\n    if (end || pos == -1) return end;\\n    auto idx = word[pos] - \\'a\\';\\n    if (arr[idx] == nullptr) return false;\\n    else return arr[idx]->reverse_check(word, pos - 1);\\n  }\\n};\\nTrie root;\\nstring word;\\nStreamChecker(vector<string>& words) {\\n  for (auto w : words) {\\n    reverse(begin(w), end(w));\\n    root.insert(w);\\n  }\\n}\\nbool query(char letter) {\\n  word += letter;\\n  return root.reverse_check(word, word.size() - 1);\\n}\\n```\\n# Track Pointers Solution\\nInstead of accumulating the query, we can just track Trie pointers and advance them when we receive a query. This solution is accepted, but the runtime is much higher than for the first one. I think, however, that for some inputs, this solution could be more efficient.\\n```\\nclass Trie {\\npublic:\\n  Trie *arr[26] = {};\\n  bool end = false;\\n  void insert(string &word, int pos = 0) {\\n    if (pos == word.size()) end = true;\\n    else {\\n      auto idx = word[pos] - \\'a\\';\\n      if (arr[idx] == nullptr) arr[idx] = new Trie();\\n      arr[idx]->insert(word, pos + 1);\\n    }\\n  }\\n};\\nTrie root;\\nvector<Trie*> pts = { &root };\\nStreamChecker(vector<string>& words) {\\n  for (auto &w : words) root.insert(w);\\n}\\nbool query(char letter, bool res = false) {\\n  vector<Trie*> next_pts = { &root };\\n  for (auto t : pts) {\\n    auto n_t = t->arr[letter - \\'a\\'];\\n    if (n_t != nullptr) {\\n      if (n_t->end) res = true;\\n      next_pts.push_back(n_t);\\n    }\\n  }\\n  swap(pts, next_pts);\\n  return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Trie {\\npublic:\\n  Trie *arr[26] = {};\\n  bool end = false;\\n  void insert(string &word, int pos = 0) {\\n    if (pos == word.size()) end = true;\\n    else {\\n      auto idx = word[pos] - \\'a\\';\\n      if (arr[idx] == nullptr) arr[idx] = new Trie();\\n      arr[idx]->insert(word, pos + 1);\\n    }\\n  }\\n  bool reverse_check(string &word, int pos) {\\n    if (end || pos == -1) return end;\\n    auto idx = word[pos] - \\'a\\';\\n    if (arr[idx] == nullptr) return false;\\n    else return arr[idx]->reverse_check(word, pos - 1);\\n  }\\n};\\nTrie root;\\nstring word;\\nStreamChecker(vector<string>& words) {\\n  for (auto w : words) {\\n    reverse(begin(w), end(w));\\n    root.insert(w);\\n  }\\n}\\nbool query(char letter) {\\n  word += letter;\\n  return root.reverse_check(word, word.size() - 1);\\n}\\n```\n```\\nclass Trie {\\npublic:\\n  Trie *arr[26] = {};\\n  bool end = false;\\n  void insert(string &word, int pos = 0) {\\n    if (pos == word.size()) end = true;\\n    else {\\n      auto idx = word[pos] - \\'a\\';\\n      if (arr[idx] == nullptr) arr[idx] = new Trie();\\n      arr[idx]->insert(word, pos + 1);\\n    }\\n  }\\n};\\nTrie root;\\nvector<Trie*> pts = { &root };\\nStreamChecker(vector<string>& words) {\\n  for (auto &w : words) root.insert(w);\\n}\\nbool query(char letter, bool res = false) {\\n  vector<Trie*> next_pts = { &root };\\n  for (auto t : pts) {\\n    auto n_t = t->arr[letter - \\'a\\'];\\n    if (n_t != nullptr) {\\n      if (n_t->end) res = true;\\n      next_pts.push_back(n_t);\\n    }\\n  }\\n  swap(pts, next_pts);\\n  return res;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 278842,
                "title": "c-ac-automaton-solution-amortized-time-complexity-o-1",
                "content": "https://www.wikiwand.com/en/Aho%E2%80%93Corasick_algorithm\\nThink KMP as a special linear case of AC automaton.\\n\\nAmortized time complexity for each query is O(1)\\n\\n\\n```\\nclass StreamChecker {\\npublic:\\n    vector<unordered_map<char, int>> trie;\\n    vector<bool> term;\\n    vector<int> fail;\\n    int curPos;\\n\\n    StreamChecker(vector<string>& words) {\\n\\t    // Build the Trie\\n        int total = 0;\\n        unordered_map<char, int> root;\\n        this->trie.push_back(root);\\n        this->term.push_back(false);\\n        this->fail.push_back(0);\\n        for (string word : words) {\\n            int cur = 0;\\n            for (char c : word) {\\n                if (this->trie[cur].find(c) != this->trie[cur].end()) {\\n                    cur = this->trie[cur][c];\\n                } else {\\n                    unordered_map<char, int> newNode;\\n                    this->trie.push_back(newNode);\\n                    this->term.push_back(false);\\n                    total++;\\n                    this->trie[cur][c] = total;\\n                    cur = total;\\n                }\\n            }\\n            this->term[cur] = true;\\n        }\\n\\n        // Maintain fail pointer, so each time when an attempting further match fail,\\n\\t\\t// jump to the position where the longest suffix of current path is a prefix in the Trie.\\n        for (int i = 0; i < this->trie.size(); i++) {\\n            this->fail.push_back(0);\\n        }\\n\\t\\t// Need follow BFS order to create failing pointers so that upper level nodes\\n\\t\\t// should  have their correct failing jumping positions when processing a lower node in Trie.\\n        queue<pair<int, unordered_map<char, int>>> nodes;\\n        for (auto kv: this->trie[0]) {\\n            auto o = make_pair(kv.second, this->trie[kv.second]);\\n            nodes.push(o);   \\n        }\\n        while (!nodes.empty()) {\\n            auto p = nodes.front();\\n            nodes.pop();\\n            auto i = p.first;\\n            auto node = p.second;\\n            for (auto kv : node) {\\n                auto pp = make_pair(kv.second, this->trie[kv.second]);\\n                nodes.push(pp);\\n            }\\n            for (auto kv : node) {\\n                char child = kv.first;\\n                int pos = kv.second;\\n                int f = this->fail[i];\\n\\t\\t\\t\\t// Very similar with KMP algorithm to find the failing position, but here the jumping can\\n\\t\\t\\t\\t// be anywhere on the Trie.\\n                while (f != 0 && this->trie[f].find(child) == trie[f].end()) {\\n                    f = this->fail[f];\\n                }\\n                if (this->trie[f].find(child) != trie[f].end()) {\\n                    f = this->trie[f][child];\\n                }\\n                this->fail[pos] = f;\\n\\t\\t\\t\\t// Here we inherit the termination flag from failing position, so that if any node in the failing\\n\\t\\t\\t\\t// chain is a valid word, the current position will yield a true answer.\\n                if (this->term[this->fail[pos]]) {\\n                    this->term[pos] = true;\\n                }\\n            }\\n        }\\n        this->curPos = 0;\\n    }\\n\\n    \\n    bool query(char letter) {\\n\\t    // Find the matching position on Trie.\\n        while (this->curPos > 0 && this->trie[this->curPos].find(letter) == this->trie[this->curPos].end()) {\\n            this->curPos = this->fail[this->curPos];\\n        }\\n        if (this->trie[this->curPos].find(letter) != this->trie[this->curPos].end()) {\\n            this->curPos = this->trie[this->curPos][letter];\\n        }\\n\\t\\t\\n        return this->term[this->curPos];\\n    }\\n};\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker* obj = new StreamChecker(words);\\n * bool param_1 = obj->query(letter);\\n */\\n ```\\n",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker {\\npublic:\\n    vector<unordered_map<char, int>> trie;\\n    vector<bool> term;\\n    vector<int> fail;\\n    int curPos;\\n\\n    StreamChecker(vector<string>& words) {\\n\\t    // Build the Trie\\n        int total = 0;\\n        unordered_map<char, int> root;\\n        this->trie.push_back(root);\\n        this->term.push_back(false);\\n        this->fail.push_back(0);\\n        for (string word : words) {\\n            int cur = 0;\\n            for (char c : word) {\\n                if (this->trie[cur].find(c) != this->trie[cur].end()) {\\n                    cur = this->trie[cur][c];\\n                } else {\\n                    unordered_map<char, int> newNode;\\n                    this->trie.push_back(newNode);\\n                    this->term.push_back(false);\\n                    total++;\\n                    this->trie[cur][c] = total;\\n                    cur = total;\\n                }\\n            }\\n            this->term[cur] = true;\\n        }\\n\\n        // Maintain fail pointer, so each time when an attempting further match fail,\\n\\t\\t// jump to the position where the longest suffix of current path is a prefix in the Trie.\\n        for (int i = 0; i < this->trie.size(); i++) {\\n            this->fail.push_back(0);\\n        }\\n\\t\\t// Need follow BFS order to create failing pointers so that upper level nodes\\n\\t\\t// should  have their correct failing jumping positions when processing a lower node in Trie.\\n        queue<pair<int, unordered_map<char, int>>> nodes;\\n        for (auto kv: this->trie[0]) {\\n            auto o = make_pair(kv.second, this->trie[kv.second]);\\n            nodes.push(o);   \\n        }\\n        while (!nodes.empty()) {\\n            auto p = nodes.front();\\n            nodes.pop();\\n            auto i = p.first;\\n            auto node = p.second;\\n            for (auto kv : node) {\\n                auto pp = make_pair(kv.second, this->trie[kv.second]);\\n                nodes.push(pp);\\n            }\\n            for (auto kv : node) {\\n                char child = kv.first;\\n                int pos = kv.second;\\n                int f = this->fail[i];\\n\\t\\t\\t\\t// Very similar with KMP algorithm to find the failing position, but here the jumping can\\n\\t\\t\\t\\t// be anywhere on the Trie.\\n                while (f != 0 && this->trie[f].find(child) == trie[f].end()) {\\n                    f = this->fail[f];\\n                }\\n                if (this->trie[f].find(child) != trie[f].end()) {\\n                    f = this->trie[f][child];\\n                }\\n                this->fail[pos] = f;\\n\\t\\t\\t\\t// Here we inherit the termination flag from failing position, so that if any node in the failing\\n\\t\\t\\t\\t// chain is a valid word, the current position will yield a true answer.\\n                if (this->term[this->fail[pos]]) {\\n                    this->term[pos] = true;\\n                }\\n            }\\n        }\\n        this->curPos = 0;\\n    }\\n\\n    \\n    bool query(char letter) {\\n\\t    // Find the matching position on Trie.\\n        while (this->curPos > 0 && this->trie[this->curPos].find(letter) == this->trie[this->curPos].end()) {\\n            this->curPos = this->fail[this->curPos];\\n        }\\n        if (this->trie[this->curPos].find(letter) != this->trie[this->curPos].end()) {\\n            this->curPos = this->trie[this->curPos][letter];\\n        }\\n\\t\\t\\n        return this->term[this->curPos];\\n    }\\n};\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker* obj = new StreamChecker(words);\\n * bool param_1 = obj->query(letter);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 278753,
                "title": "c-using-trie-reverse-dictionary-words-with-pruning-stream-data",
                "content": "\\tclass Trie {\\n\\t\\tunordered_map<char, Trie *> char_map;\\n\\t\\tbool word_ends;\\n\\tpublic:\\n\\t\\tTrie() {\\n\\t\\t\\tword_ends = false;\\n\\t\\t}\\n\\n\\t\\tvoid insert(string word) {\\n\\t\\t\\tif(word.length() == 0)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tTrie *temp = this;\\n\\t\\t\\tfor(auto ch : word) {\\n\\t\\t\\t\\tif(temp->char_map.find(ch) != temp->char_map.end()) {\\n\\t\\t\\t\\t\\ttemp = temp->char_map[ch];\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\ttemp->char_map[ch] = new Trie();\\n\\t\\t\\t\\t\\ttemp = temp->char_map[ch];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\ttemp->word_ends = true;\\n\\t\\t}\\n\\n\\t\\tbool search(string word) {\\n\\t\\t\\tif(word.length() == 0)\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\tTrie *temp = this;\\n\\t\\t\\tfor(auto ch : word) {\\n\\t\\t\\t\\tif(temp->char_map.find(ch) == temp->char_map.end())\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\ttemp = temp->char_map[ch];\\n\\t\\t\\t\\tif(temp->word_ends)\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\treturn temp->word_ends;\\n\\t\\t}\\n\\t};\\n\\n\\tclass StreamChecker {\\n\\t\\tTrie my_trie;\\n\\t\\tstring str = \"\";\\n\\t\\tint w_len = 0;\\n\\tpublic:\\n\\t\\tStreamChecker(vector<string>& words) {\\n\\t\\t\\tfor(auto w : words) {\\n\\t\\t\\t\\treverse(w.begin(), w.end());\\n\\t\\t\\t\\tw_len = max(w_len, (int)w.length());\\n\\t\\t\\t\\tmy_trie.insert(w);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tbool query(char letter) {\\n\\t\\t\\tstr = letter + str;\\n\\n\\t\\t\\tif(str.length() > w_len)\\n\\t\\t\\t\\tstr.pop_back();\\n\\n\\t\\t\\treturn my_trie.search(str);\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "\\tclass Trie {\\n\\t\\tunordered_map<char, Trie *> char_map;\\n\\t\\tbool word_ends;\\n\\tpublic:\\n\\t\\tTrie() {\\n\\t\\t\\tword_ends = false;\\n\\t\\t}\\n\\n\\t\\tvoid insert(string word) {\\n\\t\\t\\tif(word.length() == 0)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tTrie *temp = this;\\n\\t\\t\\tfor(auto ch : word) {\\n\\t\\t\\t\\tif(temp->char_map.find(ch) != temp->char_map.end()) {\\n\\t\\t\\t\\t\\ttemp = temp->char_map[ch];\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\ttemp->char_map[ch] = new Trie();\\n\\t\\t\\t\\t\\ttemp = temp->char_map[ch];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\ttemp->word_ends = true;\\n\\t\\t}\\n\\n\\t\\tbool search(string word) {\\n\\t\\t\\tif(word.length() == 0)\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\tTrie *temp = this;\\n\\t\\t\\tfor(auto ch : word) {\\n\\t\\t\\t\\tif(temp->char_map.find(ch) == temp->char_map.end())\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\ttemp = temp->char_map[ch];\\n\\t\\t\\t\\tif(temp->word_ends)\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\treturn temp->word_ends;\\n\\t\\t}\\n\\t};\\n\\n\\tclass StreamChecker {\\n\\t\\tTrie my_trie;\\n\\t\\tstring str = \"\";\\n\\t\\tint w_len = 0;\\n\\tpublic:\\n\\t\\tStreamChecker(vector<string>& words) {\\n\\t\\t\\tfor(auto w : words) {\\n\\t\\t\\t\\treverse(w.begin(), w.end());\\n\\t\\t\\t\\tw_len = max(w_len, (int)w.length());\\n\\t\\t\\t\\tmy_trie.insert(w);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tbool query(char letter) {\\n\\t\\t\\tstr = letter + str;\\n\\n\\t\\t\\tif(str.length() > w_len)\\n\\t\\t\\t\\tstr.pop_back();\\n\\n\\t\\t\\treturn my_trie.search(str);\\n\\t\\t}\\n\\t};",
                "codeTag": "Java"
            },
            {
                "id": 407851,
                "title": "c-java-python-trie-with-reverse-words-clean-code-easy-to-understand",
                "content": "<iframe src=\"https://leetcode.com/playground/6dJbCPhF/shared\" frameBorder=\"0\" width=\"100%\" height=\"800\"></iframe>\\n\\nComplexity:\\n- Time: `O(N * W + Q * W)`, where `N <= 2000` is number of words, `W <= 200` is length of a word, `Q <= 4*10^4` is number of quies.\\n- Space: `O(N * W)`",
                "solutionTags": [
                    "Trie"
                ],
                "code": "<iframe src=\"https://leetcode.com/playground/6dJbCPhF/shared\" frameBorder=\"0\" width=\"100%\" height=\"800\"></iframe>\\n\\nComplexity:\\n- Time: `O(N * W + Q * W)`, where `N <= 2000` is number of words, `W <= 200` is length of a word, `Q <= 4*10^4` is number of quies.\\n- Space: `O(N * W)`",
                "codeTag": "Unknown"
            },
            {
                "id": 1610378,
                "title": "c-simple-solution-trie-approach-faster-than-97-74",
                "content": "Firstly, thanks for refering to my solution, in advance :)\\n\\n* The idea is to store the words in reverse order in the Trie, so that finding suffix from stream of characters will be easy.\\n* We store the characters from the input stream in a string and start seraching the words from the end of the string.\\n* If a character is not found, we return false.\\n* If a character is found we move to the next character.\\n* When we reach the end of a word (We use a bool variable ```flag```, and set it to true if we reach the end of a word) we return true because a suffix of these characters is a string of a given array of strings \"words\".\\n\\n**Time Complexity :**  O(N*x*M + M*x*Q) ; where -> N = no. of words in ```words``` and M = length of each word and Q = no. of queries from cin\\n\\n**Space Complexity :** O(N*x*M)\\n\\n**Code :**\\n```\\nclass Node{\\n    Node *arr[26];\\n    bool flag = false;\\npublic:\\n    \\n    bool contains(char ch){ return arr[ch-\\'a\\'] != NULL; }\\n    \\n    void put(char ch, Node *newNode){ arr[ch - \\'a\\'] = newNode;}\\n    \\n    Node *getNext(char ch){return arr[ch-\\'a\\'];}\\n    \\n    bool getFlag(){ return flag;}\\n    \\n    void setFlag(){ flag = true;} \\n\\t\\n};\\nclass StreamChecker {\\npublic:\\n    string streamString = \"\";\\n    Node *root;\\n    \\n    void insert(string s){\\n        Node *temp = root;\\n        for(int i=s.size()-1;i>=0;i--){  //insert in reverse order\\n            if(!temp->contains(s[i])) temp->put(s[i], new Node());\\n            temp = temp->getNext(s[i]);\\n        }\\n        temp->setFlag();//set flag if you reach end of the string\\n    }\\n    \\n    StreamChecker(vector<string>& words) {\\n        root = new Node();\\n        for(auto word : words) insert(word);\\n        \\n    }\\n    \\n    bool query(char letter) {\\n        streamString += letter;\\n        Node *temp = root;\\n        //search from the end of the string\\n        for(int i=streamString.size()-1;i>=0&&temp;i--){\\n            if(!temp && !temp->contains(streamString[i])) return false;\\n            \\n            temp = temp->getNext(streamString[i]);\\n            if(temp && temp->getFlag()) return true; //return true if you\\'ve reached the end\\n        }\\n        return false;    \\n    }\\n};\\n```\\n\\nIf you like my solution, please upvote!! It keeps me motivated to post solutions everyday!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Trie"
                ],
                "code": "```flag```\n```words```\n```\\nclass Node{\\n    Node *arr[26];\\n    bool flag = false;\\npublic:\\n    \\n    bool contains(char ch){ return arr[ch-\\'a\\'] != NULL; }\\n    \\n    void put(char ch, Node *newNode){ arr[ch - \\'a\\'] = newNode;}\\n    \\n    Node *getNext(char ch){return arr[ch-\\'a\\'];}\\n    \\n    bool getFlag(){ return flag;}\\n    \\n    void setFlag(){ flag = true;} \\n\\t\\n};\\nclass StreamChecker {\\npublic:\\n    string streamString = \"\";\\n    Node *root;\\n    \\n    void insert(string s){\\n        Node *temp = root;\\n        for(int i=s.size()-1;i>=0;i--){  //insert in reverse order\\n            if(!temp->contains(s[i])) temp->put(s[i], new Node());\\n            temp = temp->getNext(s[i]);\\n        }\\n        temp->setFlag();//set flag if you reach end of the string\\n    }\\n    \\n    StreamChecker(vector<string>& words) {\\n        root = new Node();\\n        for(auto word : words) insert(word);\\n        \\n    }\\n    \\n    bool query(char letter) {\\n        streamString += letter;\\n        Node *temp = root;\\n        //search from the end of the string\\n        for(int i=streamString.size()-1;i>=0&&temp;i--){\\n            if(!temp && !temp->contains(streamString[i])) return false;\\n            \\n            temp = temp->getNext(streamString[i]);\\n            if(temp && temp->getFlag()) return true; //return true if you\\'ve reached the end\\n        }\\n        return false;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 513463,
                "title": "c-trie-approach-with-explanation",
                "content": "The idea is to hang all the words up side down (reversely) in a tree, and the smart part is **not to use the char as the key to reference each letter**, instead use the offset value from letter `a` as index so you can nicely use a `TreeNode[26] ` to represent `a-z` and it will be super easy to query each letter later.\\n\\nFor example, for input words [\"hello\", \"my\", \"weird\", \"world\"] we can have a TreeNode as below (of cause the letter will be replaced by integer index). If you ask why up side down? Because this question requires searching from the end of the query string.\\n```\\n                                     root\\n\\t\\t\\t\\t\\t\\t\\t    o     y     d\\n\\t\\t\\t\\t\\t\\t       l      m     r  l\\n\\t\\t\\t\\t\\t\\t      l             i    r\\n\\t\\t\\t\\t\\t\\t\\t e              e      o\\n\\t\\t\\t\\t\\t\\t\\th               w        w\\n```\\n\\nIt is easy to see the effeciency of this structure, consider you have 26 words, each ends by different letter from a to z, then by storing the last char of the words into a array of `TreeNode[26]` when you read the last query letter and convert it to index by using `letter - \\'a\\'` you automatically filtered out all 25 other words that are not end by the letter.  \\n\\n```\\npublic class StreamChecker{\\n    readonly TreeNode root = new TreeNode();\\n    readonly IList<char> _query = new List<char>();\\n\\n    public StreamChecker(string[] words) {\\n        foreach (var s in words) {\\n            TreeNode cur = root;\\n            for (int j = s.Length - 1; j >= 0; j--) {  // save word in reverse by converting each letter a index\\n                int i = s[j] - \\'a\\';                   \\n                if (cur.Children[i] == null) cur.Children[i] = new TreeNode();\\n                cur = cur.Children[i];\\n            }\\n            cur.EndOfWord = true;                      // at the first letter of each word set this flag to true\\n                                                       // and later use it to determine matching a word or not\\n        }\\n    }\\n\\n    public bool Query(char letter) {\\n        _query.Add(letter);\\n        TreeNode cur = root;\\n        for (int i = _query.Count - 1; i >= 0; i--) {\\n            int j = _query[i] - \\'a\\';\\n            if (cur.Children[j] == null) return false;\\n            cur = cur.Children[j];\\n            if (cur.EndOfWord) return true;\\n        }\\n        return false;\\n    }\\n\\n    class TreeNode {\\n        public TreeNode[] Children = new TreeNode[26]; // we will only have letter a to z and we are going to converting\\n                                                       // letter to index by using letter - \\'a\\' \\n        public bool EndOfWord = false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n                                     root\\n\\t\\t\\t\\t\\t\\t\\t    o     y     d\\n\\t\\t\\t\\t\\t\\t       l      m     r  l\\n\\t\\t\\t\\t\\t\\t      l             i    r\\n\\t\\t\\t\\t\\t\\t\\t e              e      o\\n\\t\\t\\t\\t\\t\\t\\th               w        w\\n```\n```\\npublic class StreamChecker{\\n    readonly TreeNode root = new TreeNode();\\n    readonly IList<char> _query = new List<char>();\\n\\n    public StreamChecker(string[] words) {\\n        foreach (var s in words) {\\n            TreeNode cur = root;\\n            for (int j = s.Length - 1; j >= 0; j--) {  // save word in reverse by converting each letter a index\\n                int i = s[j] - \\'a\\';                   \\n                if (cur.Children[i] == null) cur.Children[i] = new TreeNode();\\n                cur = cur.Children[i];\\n            }\\n            cur.EndOfWord = true;                      // at the first letter of each word set this flag to true\\n                                                       // and later use it to determine matching a word or not\\n        }\\n    }\\n\\n    public bool Query(char letter) {\\n        _query.Add(letter);\\n        TreeNode cur = root;\\n        for (int i = _query.Count - 1; i >= 0; i--) {\\n            int j = _query[i] - \\'a\\';\\n            if (cur.Children[j] == null) return false;\\n            cur = cur.Children[j];\\n            if (cur.EndOfWord) return true;\\n        }\\n        return false;\\n    }\\n\\n    class TreeNode {\\n        public TreeNode[] Children = new TreeNode[26]; // we will only have letter a to z and we are going to converting\\n                                                       // letter to index by using letter - \\'a\\' \\n        public bool EndOfWord = false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1610535,
                "title": "python-trie-tree-data-structure-explanation",
                "content": "We can use build a Trie tree to solve this problem https://en.wikipedia.org/wiki/Trie\\n```python\\n# Implement Trie tree use Hashtable\\nclass TrieTree:\\n    def __init__(self):\\n        self.root = {}\\n    def insert(self, word: str) -> None:\\n        node = self.root\\n        i = 0\\n        while i < len(word):\\n            if word[i] in node:\\n                node = node[word[i]]\\n                i += 1\\n                continue\\n            break        \\n        while i < len(word):\\n            node[word[i]] = {}\\n            node = node[word[i]]\\n            i+=1\\n\\t\\t# mark it as the last character of a word\\n        node[\"$\"]={}\\n        return\\n     # Check whether the stream suffix existed on tree or not\\n\\t # Can reverse suffix, so we check it like prefix\\n    def isPrefix(self, word: str) -> bool:\\n        node = self.root\\n        for c in word:\\n            if c not in node:\\n                return False\\n            if \"$\" in node[c]:\\n                return True\\n            node = node[c]\\n        return False\\n        \\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.stream = \"\"\\n        self.trie = TrieTree()\\n        for w in words:\\n\\t\\t\\t# because we need to check suffix, so reversing the word\\n            self.trie.insert(w[::-1])\\n\\n    def query(self, letter: str) -> bool:\\n        self.stream += letter\\n        return self.trie.isPrefix(self.stream[::-1])",
                "solutionTags": [],
                "code": "We can use build a Trie tree to solve this problem https://en.wikipedia.org/wiki/Trie\\n```python\\n# Implement Trie tree use Hashtable\\nclass TrieTree:\\n    def __init__(self):\\n        self.root = {}\\n    def insert(self, word: str) -> None:\\n        node = self.root\\n        i = 0\\n        while i < len(word):\\n            if word[i] in node:\\n                node = node[word[i]]\\n                i += 1\\n                continue\\n            break        \\n        while i < len(word):\\n            node[word[i]] = {}\\n            node = node[word[i]]\\n            i+=1\\n\\t\\t# mark it as the last character of a word\\n        node[\"$\"]={}\\n        return\\n     # Check whether the stream suffix existed on tree or not\\n\\t # Can reverse suffix, so we check it like prefix\\n    def isPrefix(self, word: str) -> bool:\\n        node = self.root\\n        for c in word:\\n            if c not in node:\\n                return False\\n            if \"$\" in node[c]:\\n                return True\\n            node = node[c]\\n        return False\\n        \\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.stream = \"\"\\n        self.trie = TrieTree()\\n        for w in words:\\n\\t\\t\\t# because we need to check suffix, so reversing the word\\n            self.trie.insert(w[::-1])\\n\\n    def query(self, letter: str) -> bool:\\n        self.stream += letter\\n        return self.trie.isPrefix(self.stream[::-1])",
                "codeTag": "Java"
            },
            {
                "id": 807643,
                "title": "c-6-solutions-studied-4-variants-of-lc-hint-tle-2-variants-of-reversed-words-pass-dumb",
                "content": "**EDIT: Original post title:** *Leetcode hint misleading? Is there any C++ solution with Trie and set of ptrs that does not TLE?*\\n\\nLeetcode hint says : *Put the words into a trie, and manage a set of pointers within that trie.*\\n\\nok Leetcode, I did that but this TLE because of the dumb test case 17.\\n\\nOn the discussion, the non TLE C++ solutions I have seen are:\\n- trie of reversed words + complete lookup on the word formed by the the stream of chars (capped by max(words size)), not very elegant, this suffer from compete word lookup at each character\\n- Aho - Corasick algorithm, quite complex and with ridiculously long and complex implementations\\n\\nSo my question is : **Is there a solution that uses trie AND manage a set of pointers in the trie that DOES NOT TLE ???**\\n\\n**EDIT: Here is the list of solutions I tried (and the answer to my question seems to be NO)** \\n\\n1 - trie (using unique_ptr for nodes) of words + deque of pointers -> TLE on test 16\\n2 - trie (using raw ptr for nodes) + vector of pointers & additional tmp vector of pointers -> TLE on test  16\\n3 - trie (using raw ptr for nodes) + circular queue (ring buffer) of pointers -> TLE on test 16 or 17\\n4 - trie (using raw ptr for nodes, preallocated in a vector of Trie) + circular queue (ring buffer) of pointers -> TLE on test 17 or all tests pass but TLE on overall execution\\n5 - trie (using raw ptr for nodes) of reversed words + deque<char> as stream buffer -> Accepted ~900ms\\n6 - trie (using raw ptr for nodes, preallocated in a vector of Trie) of reversed words + deque as stream buffer  -> Accepted 496 ms, 80.56% best try\\n\\n**Conclusion:**  \\nThis problem is rubbish, I will downvote it.\\nThe leetcode hint is always TLE.\\nThe solution that uses reversed words is idiotic since it only improves the situations for special cases like:\\n- `word = \"aaaa...repeat until bored...aaaab\"`\\n- `strm = \"aaaa...repeat until bored...aaaac\"`\\n\\nBut reversed word approach would **TLE miserably as well** for test case such as:\\n- `word = \"aaaa...repeat like hell...aaaa\"`\\n- `strm = \"aaaa...repeat like hell...aaa\"`\\n \\n**-> Thank you leetcode** for the **low quality of your test cases** that lead to produce bad solution that work ok for specific corner cases!!\\n\\n**Detailled code of all studied solutions:**\\n\\n**1 - trie (using unique_ptr for nodes) of words + deque of pointers -> TLE on test 16**\\n\\nThis is my original solution:\\n- just implement a Trie made of an array of `unique_ptr<Trie>`\\n- use a deque to manage pointer to Trie nodes\\n```\\nclass StreamChecker {\\n    struct Trie{\\n        array<unique_ptr<Trie>, 26> letters;\\n        bool is_word;\\n        bool is_leaf;\\n        \\n        Trie():letters{}, is_word(false), is_leaf(true){}\\n        \\n        void insert(const string& word, int pos=0){\\n            if(pos == word.size()){\\n                is_word = true;\\n                return;\\n            }\\n            is_leaf = false;\\n            char c = word[pos];\\n            auto &ptr_ref = letters[c - \\'a\\'];\\n            if(!ptr_ref)\\n                ptr_ref = make_unique<Trie>();\\n            ptr_ref->insert(word, pos+1);\\n        }\\n        \\n        Trie *find(char c){\\n            return letters[c-\\'a\\'].get();\\n        }\\n    };\\n    \\n    Trie trie_;\\n    deque<Trie *> nodes_;\\npublic:\\n    StreamChecker(vector<string>& words) {\\n        for(const auto& w: words)\\n            trie_.insert(w);\\n        nodes_.emplace_back(&trie_);\\n    }\\n    \\n    bool query(char letter) {\\n        bool result = false;\\n        for(int i = 0, size = nodes_.size(); i != size; ++i){\\n            auto n = nodes_.front();\\n            nodes_.pop_front();\\n            if(auto node = n->find(letter); node != nullptr){\\n                result |= node->is_word;\\n                if(!node->is_leaf)\\n                    nodes_.emplace_back(node);\\n            }\\n        }\\n        nodes_.emplace_back(&trie_);\\n        return result;\\n    }\\n};\\n```\\n**2 - trie (using raw ptr for nodes) + vector of pointers & additional tmp vector of pointers -> TLE on test  16**\\n\\nOk, here were my thoughts to improve the performances of 1:\\n- let\\'s not use convenient unique_ptr and manage deallocation myself\\n- push and pop in deque result of popping a node when dequeing and possibly reinserting after (for the same char in the stream), so lets use more memory efficient container: vector<Trie*> + a temporary one\\n- reserve the size of temporary vector to minimize the cost of re-allocations (when the vector reaches its internal capacity)\\n- after building the temporary vector, move it to the main one\\n\\n```\\nclass StreamChecker {\\n    struct Trie{\\n        array<Trie *, 26> letters;\\n        bool is_word;\\n        bool is_leaf;\\n        \\n        Trie():letters{}, is_word(false), is_leaf(true){}\\n        ~Trie(){for(auto ptr: letters) if(ptr) delete ptr;}\\n        \\n        void insert(const string& word, int pos=0){\\n            if(pos == word.size()){\\n                is_word = true;\\n                return;\\n            }\\n            is_leaf = false;\\n            char c = word[pos];\\n            auto &ptr_ref = letters[c - \\'a\\'];\\n            if(!ptr_ref) ptr_ref = new Trie();\\n            ptr_ref->insert(word, pos+1);\\n        }\\n    };\\n    \\n    Trie trie_;\\n    vector<Trie *> nodes_;\\npublic:\\n    StreamChecker(vector<string>& words) {\\n        for(const auto& w: words)\\n            trie_.insert(w);\\n        nodes_.emplace_back(&trie_);\\n    }\\n    \\n    bool query(char letter) {\\n        bool result = false;\\n        vector<Trie *> new_nodes;\\n        new_nodes.reserve(nodes_.size()+1);\\n        for(int i = 0, size = nodes_.size(); i != size; ++i){\\n            auto n = nodes_[i];\\n            if(auto node = n->letters[letter-\\'a\\']; node != nullptr){\\n                result |= node->is_word;\\n                if(!node->is_leaf) new_nodes.emplace_back(node);\\n            }\\n        }\\n        new_nodes.emplace_back(&trie_);\\n        nodes_ = move(new_nodes);\\n        return result;\\n    }\\n};\\n```\\n**3 - trie (using raw ptr for nodes) + circular queue (ring buffer) of pointers -> TLE on test 16 or 17**\\n\\nI thought that both in 1 & 2, there are a lot of allocations / deallocations happening so:\\n- let\\'s use a circular queue to kill any dynamic allocation when processing the stream\\n- intialise the circular queue to the maximum possible size (max words sizes +1))\\n```\\ntemplate <typename T>\\nclass MyCircularQueue {\\n    int k_;\\n    vector<T> buffer_;\\n    typename vector<T>::iterator front_;\\n    typename vector<T>::iterator back_;\\n    int size_;\\npublic:\\n    MyCircularQueue(int k):\\n        k_(k),buffer_(k_), front_(buffer_.begin()), back_(buffer_.begin()),size_(0){}\\n    MyCircularQueue(){}\\n\\n    void resize(int k){\\n        k_ = k;\\n        buffer_.resize(k_);\\n        front_ = buffer_.begin();\\n        back_ = buffer_.begin();\\n        size_= 0;\\n    }\\n    \\n    void push_back(T value) {\\n        back_ = (size_ && ++back_ == buffer_.end())?buffer_.begin():back_;\\n        *back_ = value;\\n        ++size_;\\n    }\\n    \\n    T pop_front() {\\n        auto tmp = *front_;\\n        front_ = (front_ != back_ && ++front_ == buffer_.end())?buffer_.begin():front_;\\n        --size_;\\n        return tmp;\\n    }\\n    \\n    T& front() {return *front_;}\\n    T& back() {return *back_;}\\n    int size() {return size_;}\\n};\\n\\nclass StreamChecker {\\n    struct Trie{\\n        array<Trie *, 26> letters;\\n        bool is_word;\\n        bool is_leaf;\\n        \\n        Trie():letters{}, is_word(false), is_leaf(true){}\\n        ~Trie(){for(auto ptr: letters) if(ptr) delete ptr;}\\n        \\n        void insert(const string& word, int pos=0){\\n            if(pos == word.size()){\\n                is_word = true;\\n                return;\\n            }\\n            is_leaf = false;\\n            char c = word[pos];\\n            auto &ptr_ref = letters[c - \\'a\\'];\\n            if(!ptr_ref)\\n                ptr_ref = new Trie();\\n            ptr_ref->insert(word, pos+1);\\n        }\\n    };\\n\\n    Trie trie_;\\n    MyCircularQueue<Trie *> queue_;\\n    size_t maxwordsize_;\\npublic:\\n    StreamChecker(vector<string>& words):maxwordsize_(0) {\\n        for(const auto& w: words){\\n            trie_.insert(w);\\n            maxwordsize_ = max(maxwordsize_, w.size());\\n        }\\n        queue_.resize(maxwordsize_+1);\\n        queue_.push_back(&trie_);\\n    }\\n    \\n    bool query(char letter) {\\n        bool result = false;\\n        for(int i = 0, size=queue_.size(); i!= size; ++i){\\n            auto n = queue_.pop_front();\\n            if(auto node = n->letters[letter-\\'a\\']; node){\\n                result |= node->is_word;\\n                if(!node->is_leaf) queue_.push_back(node);\\n            }\\n        }\\n        queue_.push_back(&trie_);\\n        return result;\\n    }\\n};\\n```\\n\\n**4 - trie (using raw ptr for nodes, preallocated in a vector of Trie) + circular queue (ring buffer) of pointers -> TLE on test 17 or all tests pass but TLE on overall execution**\\n\\nOk, I was already pretty pissed with that problem at that stage but I thought that the word sizes in test 16 & 17 were pretty long and then building the Trie woud lead to a good number of allocations for all the Trie nodes. so I did this:\\n- compute the maximum possible number of tries nodes : sum( words sizes +1 )\\n- create a vector of Tries `trie_nodes_pool_` and reserve the necessary space in memory\\n- replace `ptr = new Trie()` per \\'trie_nodes_pool_.emplace(); ptr = &trie_nodes_pool_.back();`\\n```\\ntemplate <typename T>\\nclass MyCircularQueue {\\n    int k_;\\n    vector<T> buffer_;\\n    typename vector<T>::iterator front_;\\n    typename vector<T>::iterator back_;\\n    int size_;\\npublic:\\n    MyCircularQueue(int k):\\n        k_(k),buffer_(k_), front_(buffer_.begin()), back_(buffer_.begin()),size_(0){}\\n    MyCircularQueue(){}\\n\\n    void resize(int k){\\n        k_ = k;\\n        buffer_.resize(k_);\\n        front_ = buffer_.begin();\\n        back_ = buffer_.begin();\\n        size_= 0;\\n    }\\n    \\n    void push_back(T value) {\\n        back_ = (size_ && ++back_ == buffer_.end())?buffer_.begin():back_;\\n        *back_ = value;\\n        ++size_;\\n    }\\n    \\n    T pop_front() {\\n        auto tmp = *front_;\\n        front_ = (front_ != back_ && ++front_ == buffer_.end())?buffer_.begin():front_;\\n        --size_;\\n        return tmp;\\n    }\\n    \\n    T& front() {return *front_;}\\n    T& back() {return *back_;}\\n    int size() {return size_;}\\n};\\n\\nclass StreamChecker {\\n    struct Trie{\\n        array<Trie *, 26> letters;\\n        bool is_word;\\n        bool is_leaf;\\n        \\n        Trie():letters{}, is_word(false), is_leaf(true){}\\n        void insert(const string& word, vector<Trie>& pool, int pos=0){\\n            if(pos == word.size()){\\n                is_word = true;\\n                return;\\n            }\\n            is_leaf = false;\\n            char c = word[pos];\\n            auto &ptr_ref = letters[c - \\'a\\'];\\n            if(!ptr_ref){\\n                pool.emplace_back();\\n                ptr_ref = &pool.back();\\n            }\\n            ptr_ref->insert(word, pool, pos+1);\\n        }\\n    };\\n\\n    Trie trie_;\\n    vector<Trie> trie_nodes_pool_;\\n    MyCircularQueue<Trie *> queue_;\\npublic:\\n    StreamChecker(vector<string>& words){\\n        size_t total_size = 1;\\n        size_t maxwordsize = 0;\\n        for(const auto& w: words){\\n            maxwordsize = max(maxwordsize, w.size());\\n            total_size += w.size()+1;\\n        }\\n        trie_nodes_pool_.reserve(total_size);\\n        for(const auto& w: words)\\n            trie_.insert(w, trie_nodes_pool_);\\n        queue_.resize(maxwordsize+1);\\n        queue_.push_back(&trie_);\\n    }\\n    \\n    bool query(char letter) {\\n        bool result = false;\\n        for(int i = 0, size=queue_.size(); i!= size; ++i){\\n            auto n = queue_.pop_front();\\n            if(auto node = n->letters[letter-\\'a\\']; node){\\n                result |= node->is_word;\\n                if(!node->is_leaf) queue_.push_back(node);\\n            }\\n        }\\n        queue_.push_back(&trie_);\\n        return result;\\n    }\\n};\\n```\\n\\n**5 - trie (using raw ptr for nodes) of reversed words + deque as stream buffer -> Accepted ~900ms**\\n\\nOk, at this point I was really thinking this hint from leetcode just made me waste my time as well as the \\nsolution using trie of reversed word was rubbish, but still I wanted to implelented it...\\n```\\nclass StreamChecker {\\n    struct Trie{\\n        array<Trie *, 26> letters;\\n        bool is_word;\\n        bool is_leaf;\\n        \\n        Trie():letters{}, is_word(false), is_leaf(true){}\\n        ~Trie(){for(auto n: letters) if(n) delete(n);}\\n        \\n        void insert(const string& word, int pos=0){\\n            if(pos == word.size()){\\n                is_word = true;\\n                return;\\n            }\\n            is_leaf = false;\\n            char c = word[pos];\\n            auto &ptr_ref = letters[c - \\'a\\'];\\n            if(!ptr_ref) ptr_ref = new Trie();\\n            ptr_ref->insert(word, pos+1);\\n        }\\n        \\n        template<typename Iterator>\\n        bool lookup(Iterator it, Iterator end){\\n            if(is_word || it == end) return is_word;\\n            if(auto node = letters[*it-\\'a\\']; node)\\n                return node->lookup(++it, end);\\n            return false;\\n        }\\n    };\\n\\n    Trie trie_;\\n    deque<char> stream_buf_;\\n    size_t maxwordsize_ = 0;\\npublic:\\n    StreamChecker(vector<string>& words):maxwordsize_(0){\\n        for(auto& w: words){\\n            maxwordsize_ = max(maxwordsize_, w.size());\\n            reverse(w.begin(), w.end());\\n            trie_.insert(w);\\n        }\\n    }\\n    \\n    bool query(char letter) {\\n        stream_buf_.push_front(letter);\\n        if(stream_buf_.size() > maxwordsize_)\\n            stream_buf_.pop_back();\\n        return trie_.lookup(stream_buf_.cbegin(), stream_buf_.cend());\\n    }\\n};\\n```\\n\\n**6 - trie (using raw ptr for nodes, preallocated in a vector of Trie) of reversed words + deque as stream buffer  -> Accepted 496 ms, 80.56% best try**\\n\\nSince I went that, far I decided to see if the preallocation of trie nodes optimisation would have an effect on the performance of this [bad but accepted] solution:\\n```\\nclass StreamChecker {\\n    struct Trie{\\n        array<Trie *, 26> letters;\\n        bool is_word;\\n        bool is_leaf;\\n        \\n        Trie():letters{}, is_word(false), is_leaf(true){}\\n        \\n        void insert(const string& word, vector<Trie>& pool, int pos=0){\\n            if(pos == word.size()){\\n                is_word = true;\\n                return;\\n            }\\n            is_leaf = false;\\n            char c = word[pos];\\n            auto &ptr_ref = letters[c - \\'a\\'];\\n            if(!ptr_ref){\\n                pool.emplace_back();\\n                ptr_ref = &pool.back();\\n            }\\n            ptr_ref->insert(word, pool, pos+1);\\n        }\\n        \\n        template<typename Iterator>\\n        bool lookup(Iterator it, Iterator end){\\n            if(is_word || it == end) return is_word;\\n            if(auto node = letters[*it-\\'a\\']; node)\\n                return node->lookup(++it, end);\\n            return false;\\n        }\\n    };\\n\\n    Trie trie_;\\n    vector<Trie> trie_nodes_pool_;\\n    deque<char> stream_buf_;\\n    size_t maxwordsize_ = 0;\\npublic:\\n    StreamChecker(vector<string>& words):maxwordsize_(0){\\n        size_t total_size = 0;\\n        for(auto& w: words){\\n            maxwordsize_ = max(maxwordsize_, w.size());\\n            total_size += w.size()+1;\\n            reverse(w.begin(), w.end());\\n        }\\n        trie_nodes_pool_.reserve(total_size);\\n        for(const auto& w: words)\\n            trie_.insert(w, trie_nodes_pool_);\\n    }\\n    \\n    bool query(char letter) {\\n        stream_buf_.push_front(letter);\\n        if(stream_buf_.size() > maxwordsize_)\\n            stream_buf_.pop_back();\\n        return trie_.lookup(stream_buf_.cbegin(), stream_buf_.cend());\\n    }\\n};\\n```\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker {\\n    struct Trie{\\n        array<unique_ptr<Trie>, 26> letters;\\n        bool is_word;\\n        bool is_leaf;\\n        \\n        Trie():letters{}, is_word(false), is_leaf(true){}\\n        \\n        void insert(const string& word, int pos=0){\\n            if(pos == word.size()){\\n                is_word = true;\\n                return;\\n            }\\n            is_leaf = false;\\n            char c = word[pos];\\n            auto &ptr_ref = letters[c - \\'a\\'];\\n            if(!ptr_ref)\\n                ptr_ref = make_unique<Trie>();\\n            ptr_ref->insert(word, pos+1);\\n        }\\n        \\n        Trie *find(char c){\\n            return letters[c-\\'a\\'].get();\\n        }\\n    };\\n    \\n    Trie trie_;\\n    deque<Trie *> nodes_;\\npublic:\\n    StreamChecker(vector<string>& words) {\\n        for(const auto& w: words)\\n            trie_.insert(w);\\n        nodes_.emplace_back(&trie_);\\n    }\\n    \\n    bool query(char letter) {\\n        bool result = false;\\n        for(int i = 0, size = nodes_.size(); i != size; ++i){\\n            auto n = nodes_.front();\\n            nodes_.pop_front();\\n            if(auto node = n->find(letter); node != nullptr){\\n                result |= node->is_word;\\n                if(!node->is_leaf)\\n                    nodes_.emplace_back(node);\\n            }\\n        }\\n        nodes_.emplace_back(&trie_);\\n        return result;\\n    }\\n};\\n```\n```\\nclass StreamChecker {\\n    struct Trie{\\n        array<Trie *, 26> letters;\\n        bool is_word;\\n        bool is_leaf;\\n        \\n        Trie():letters{}, is_word(false), is_leaf(true){}\\n        ~Trie(){for(auto ptr: letters) if(ptr) delete ptr;}\\n        \\n        void insert(const string& word, int pos=0){\\n            if(pos == word.size()){\\n                is_word = true;\\n                return;\\n            }\\n            is_leaf = false;\\n            char c = word[pos];\\n            auto &ptr_ref = letters[c - \\'a\\'];\\n            if(!ptr_ref) ptr_ref = new Trie();\\n            ptr_ref->insert(word, pos+1);\\n        }\\n    };\\n    \\n    Trie trie_;\\n    vector<Trie *> nodes_;\\npublic:\\n    StreamChecker(vector<string>& words) {\\n        for(const auto& w: words)\\n            trie_.insert(w);\\n        nodes_.emplace_back(&trie_);\\n    }\\n    \\n    bool query(char letter) {\\n        bool result = false;\\n        vector<Trie *> new_nodes;\\n        new_nodes.reserve(nodes_.size()+1);\\n        for(int i = 0, size = nodes_.size(); i != size; ++i){\\n            auto n = nodes_[i];\\n            if(auto node = n->letters[letter-\\'a\\']; node != nullptr){\\n                result |= node->is_word;\\n                if(!node->is_leaf) new_nodes.emplace_back(node);\\n            }\\n        }\\n        new_nodes.emplace_back(&trie_);\\n        nodes_ = move(new_nodes);\\n        return result;\\n    }\\n};\\n```\n```\\ntemplate <typename T>\\nclass MyCircularQueue {\\n    int k_;\\n    vector<T> buffer_;\\n    typename vector<T>::iterator front_;\\n    typename vector<T>::iterator back_;\\n    int size_;\\npublic:\\n    MyCircularQueue(int k):\\n        k_(k),buffer_(k_), front_(buffer_.begin()), back_(buffer_.begin()),size_(0){}\\n    MyCircularQueue(){}\\n\\n    void resize(int k){\\n        k_ = k;\\n        buffer_.resize(k_);\\n        front_ = buffer_.begin();\\n        back_ = buffer_.begin();\\n        size_= 0;\\n    }\\n    \\n    void push_back(T value) {\\n        back_ = (size_ && ++back_ == buffer_.end())?buffer_.begin():back_;\\n        *back_ = value;\\n        ++size_;\\n    }\\n    \\n    T pop_front() {\\n        auto tmp = *front_;\\n        front_ = (front_ != back_ && ++front_ == buffer_.end())?buffer_.begin():front_;\\n        --size_;\\n        return tmp;\\n    }\\n    \\n    T& front() {return *front_;}\\n    T& back() {return *back_;}\\n    int size() {return size_;}\\n};\\n\\nclass StreamChecker {\\n    struct Trie{\\n        array<Trie *, 26> letters;\\n        bool is_word;\\n        bool is_leaf;\\n        \\n        Trie():letters{}, is_word(false), is_leaf(true){}\\n        ~Trie(){for(auto ptr: letters) if(ptr) delete ptr;}\\n        \\n        void insert(const string& word, int pos=0){\\n            if(pos == word.size()){\\n                is_word = true;\\n                return;\\n            }\\n            is_leaf = false;\\n            char c = word[pos];\\n            auto &ptr_ref = letters[c - \\'a\\'];\\n            if(!ptr_ref)\\n                ptr_ref = new Trie();\\n            ptr_ref->insert(word, pos+1);\\n        }\\n    };\\n\\n    Trie trie_;\\n    MyCircularQueue<Trie *> queue_;\\n    size_t maxwordsize_;\\npublic:\\n    StreamChecker(vector<string>& words):maxwordsize_(0) {\\n        for(const auto& w: words){\\n            trie_.insert(w);\\n            maxwordsize_ = max(maxwordsize_, w.size());\\n        }\\n        queue_.resize(maxwordsize_+1);\\n        queue_.push_back(&trie_);\\n    }\\n    \\n    bool query(char letter) {\\n        bool result = false;\\n        for(int i = 0, size=queue_.size(); i!= size; ++i){\\n            auto n = queue_.pop_front();\\n            if(auto node = n->letters[letter-\\'a\\']; node){\\n                result |= node->is_word;\\n                if(!node->is_leaf) queue_.push_back(node);\\n            }\\n        }\\n        queue_.push_back(&trie_);\\n        return result;\\n    }\\n};\\n```\n```\\ntemplate <typename T>\\nclass MyCircularQueue {\\n    int k_;\\n    vector<T> buffer_;\\n    typename vector<T>::iterator front_;\\n    typename vector<T>::iterator back_;\\n    int size_;\\npublic:\\n    MyCircularQueue(int k):\\n        k_(k),buffer_(k_), front_(buffer_.begin()), back_(buffer_.begin()),size_(0){}\\n    MyCircularQueue(){}\\n\\n    void resize(int k){\\n        k_ = k;\\n        buffer_.resize(k_);\\n        front_ = buffer_.begin();\\n        back_ = buffer_.begin();\\n        size_= 0;\\n    }\\n    \\n    void push_back(T value) {\\n        back_ = (size_ && ++back_ == buffer_.end())?buffer_.begin():back_;\\n        *back_ = value;\\n        ++size_;\\n    }\\n    \\n    T pop_front() {\\n        auto tmp = *front_;\\n        front_ = (front_ != back_ && ++front_ == buffer_.end())?buffer_.begin():front_;\\n        --size_;\\n        return tmp;\\n    }\\n    \\n    T& front() {return *front_;}\\n    T& back() {return *back_;}\\n    int size() {return size_;}\\n};\\n\\nclass StreamChecker {\\n    struct Trie{\\n        array<Trie *, 26> letters;\\n        bool is_word;\\n        bool is_leaf;\\n        \\n        Trie():letters{}, is_word(false), is_leaf(true){}\\n        void insert(const string& word, vector<Trie>& pool, int pos=0){\\n            if(pos == word.size()){\\n                is_word = true;\\n                return;\\n            }\\n            is_leaf = false;\\n            char c = word[pos];\\n            auto &ptr_ref = letters[c - \\'a\\'];\\n            if(!ptr_ref){\\n                pool.emplace_back();\\n                ptr_ref = &pool.back();\\n            }\\n            ptr_ref->insert(word, pool, pos+1);\\n        }\\n    };\\n\\n    Trie trie_;\\n    vector<Trie> trie_nodes_pool_;\\n    MyCircularQueue<Trie *> queue_;\\npublic:\\n    StreamChecker(vector<string>& words){\\n        size_t total_size = 1;\\n        size_t maxwordsize = 0;\\n        for(const auto& w: words){\\n            maxwordsize = max(maxwordsize, w.size());\\n            total_size += w.size()+1;\\n        }\\n        trie_nodes_pool_.reserve(total_size);\\n        for(const auto& w: words)\\n            trie_.insert(w, trie_nodes_pool_);\\n        queue_.resize(maxwordsize+1);\\n        queue_.push_back(&trie_);\\n    }\\n    \\n    bool query(char letter) {\\n        bool result = false;\\n        for(int i = 0, size=queue_.size(); i!= size; ++i){\\n            auto n = queue_.pop_front();\\n            if(auto node = n->letters[letter-\\'a\\']; node){\\n                result |= node->is_word;\\n                if(!node->is_leaf) queue_.push_back(node);\\n            }\\n        }\\n        queue_.push_back(&trie_);\\n        return result;\\n    }\\n};\\n```\n```\\nclass StreamChecker {\\n    struct Trie{\\n        array<Trie *, 26> letters;\\n        bool is_word;\\n        bool is_leaf;\\n        \\n        Trie():letters{}, is_word(false), is_leaf(true){}\\n        ~Trie(){for(auto n: letters) if(n) delete(n);}\\n        \\n        void insert(const string& word, int pos=0){\\n            if(pos == word.size()){\\n                is_word = true;\\n                return;\\n            }\\n            is_leaf = false;\\n            char c = word[pos];\\n            auto &ptr_ref = letters[c - \\'a\\'];\\n            if(!ptr_ref) ptr_ref = new Trie();\\n            ptr_ref->insert(word, pos+1);\\n        }\\n        \\n        template<typename Iterator>\\n        bool lookup(Iterator it, Iterator end){\\n            if(is_word || it == end) return is_word;\\n            if(auto node = letters[*it-\\'a\\']; node)\\n                return node->lookup(++it, end);\\n            return false;\\n        }\\n    };\\n\\n    Trie trie_;\\n    deque<char> stream_buf_;\\n    size_t maxwordsize_ = 0;\\npublic:\\n    StreamChecker(vector<string>& words):maxwordsize_(0){\\n        for(auto& w: words){\\n            maxwordsize_ = max(maxwordsize_, w.size());\\n            reverse(w.begin(), w.end());\\n            trie_.insert(w);\\n        }\\n    }\\n    \\n    bool query(char letter) {\\n        stream_buf_.push_front(letter);\\n        if(stream_buf_.size() > maxwordsize_)\\n            stream_buf_.pop_back();\\n        return trie_.lookup(stream_buf_.cbegin(), stream_buf_.cend());\\n    }\\n};\\n```\n```\\nclass StreamChecker {\\n    struct Trie{\\n        array<Trie *, 26> letters;\\n        bool is_word;\\n        bool is_leaf;\\n        \\n        Trie():letters{}, is_word(false), is_leaf(true){}\\n        \\n        void insert(const string& word, vector<Trie>& pool, int pos=0){\\n            if(pos == word.size()){\\n                is_word = true;\\n                return;\\n            }\\n            is_leaf = false;\\n            char c = word[pos];\\n            auto &ptr_ref = letters[c - \\'a\\'];\\n            if(!ptr_ref){\\n                pool.emplace_back();\\n                ptr_ref = &pool.back();\\n            }\\n            ptr_ref->insert(word, pool, pos+1);\\n        }\\n        \\n        template<typename Iterator>\\n        bool lookup(Iterator it, Iterator end){\\n            if(is_word || it == end) return is_word;\\n            if(auto node = letters[*it-\\'a\\']; node)\\n                return node->lookup(++it, end);\\n            return false;\\n        }\\n    };\\n\\n    Trie trie_;\\n    vector<Trie> trie_nodes_pool_;\\n    deque<char> stream_buf_;\\n    size_t maxwordsize_ = 0;\\npublic:\\n    StreamChecker(vector<string>& words):maxwordsize_(0){\\n        size_t total_size = 0;\\n        for(auto& w: words){\\n            maxwordsize_ = max(maxwordsize_, w.size());\\n            total_size += w.size()+1;\\n            reverse(w.begin(), w.end());\\n        }\\n        trie_nodes_pool_.reserve(total_size);\\n        for(const auto& w: words)\\n            trie_.insert(w, trie_nodes_pool_);\\n    }\\n    \\n    bool query(char letter) {\\n        stream_buf_.push_front(letter);\\n        if(stream_buf_.size() > maxwordsize_)\\n            stream_buf_.pop_back();\\n        return trie_.lookup(stream_buf_.cbegin(), stream_buf_.cend());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 279084,
                "title": "simple-implementation-of-aho-corasick-algorithm",
                "content": "This algorithm is called Aho Corasick algorithm, you can search it on Google.\\nThe idea behind this algorithm is totally similar to KMP, it\\'s an extension of KMP to search more than one patterns at the same time. If the automaton is built, that query method will seem very simple.\\nBasic steps of this algorithm:\\n1. build a trie;\\n2. usd a bfs to build our dictionary automaton(in China, we call it AC automaton mostly), here it is almost the same with KMP, isn\\'t it?\\n3. go, just use it.\\n\\n```\\n#include <vector>\\n#include <iostream>\\n#include <string>\\n#include <algorithm>\\n#include <queue>\\n\\nusing namespace std;\\n\\nclass StreamChecker {\\npublic:\\n    StreamChecker(const vector<string>& words) {\\n        initialize_trie(words);\\n        build_dictionary_automaton();\\n\\n    }\\n\\n    bool query(char letter) {\\n        current = nodes[current].next[letter - \\'a\\'];\\n        return nodes[current].terminal;\\n    }\\n\\nprivate:\\n\\n    int current;\\n\\n    void build_dictionary_automaton()\\n    {\\n        queue<pair<int, int>> Q;\\n        for (int i = 0; i < ALPHABET_SIZE; ++i)\\n        {\\n            if (nodes[root].next[i] == -1)\\n            {\\n                nodes[root].next[i] = root;\\n            }\\n            else\\n            {\\n                Q.push(make_pair(root, nodes[root].next[i]));\\n            }\\n        }\\n        while (!Q.empty())\\n        {\\n            auto p = Q.front();\\n            Q.pop();\\n\\n            if (nodes[p.first].terminal)\\n            {\\n                nodes[p.second].terminal = true;\\n            }\\n            for (int i = 0; i < ALPHABET_SIZE; ++i)\\n            {\\n                int x = nodes[p.first].next[i];\\n                int y = nodes[p.second].next[i];\\n                if (y == -1)\\n                {\\n                    nodes[p.second].next[i] = x;\\n                }\\n                else\\n                {\\n                    Q.push(make_pair(x, y));\\n                }\\n            }\\n        }\\n        current = 0;\\n    }\\n\\n    void initialize_trie(const vector<string>& words)\\n    {\\n        root = 0;\\n        nodes.push_back(TrieNode());\\n        for (auto& word : words)\\n        {\\n            auto current = root;\\n            for (char c : word)\\n            {\\n                int offset = c - \\'a\\';\\n                if (nodes[current].next[offset] == -1)\\n                {\\n                    nodes[current].next[offset] = nodes.size();\\n                    nodes.push_back(TrieNode());\\n                }\\n                current = nodes[current].next[offset];\\n            }\\n            nodes[current].terminal = true;\\n        }\\n    }\\n\\n    static const int ALPHABET_SIZE = 26;\\n\\n    struct TrieNode\\n    {\\n        int next[ALPHABET_SIZE];\\n        bool terminal;\\n        TrieNode()\\n        {\\n            fill(next, next + ALPHABET_SIZE, -1);\\n            terminal = false;\\n        }\\n    };\\n\\n    vector<TrieNode> nodes;\\n    int root;\\n\\n};\\n\\nstatic const int accelerate = []() {  \\n  ios::sync_with_stdio(false);\\n  cin.tie(nullptr);\\n  return 0;\\n}();\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker* obj = new StreamChecker(words);\\n * bool param_1 = obj->query(letter);\\n */\\n\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n#include <vector>\\n#include <iostream>\\n#include <string>\\n#include <algorithm>\\n#include <queue>\\n\\nusing namespace std;\\n\\nclass StreamChecker {\\npublic:\\n    StreamChecker(const vector<string>& words) {\\n        initialize_trie(words);\\n        build_dictionary_automaton();\\n\\n    }\\n\\n    bool query(char letter) {\\n        current = nodes[current].next[letter - \\'a\\'];\\n        return nodes[current].terminal;\\n    }\\n\\nprivate:\\n\\n    int current;\\n\\n    void build_dictionary_automaton()\\n    {\\n        queue<pair<int, int>> Q;\\n        for (int i = 0; i < ALPHABET_SIZE; ++i)\\n        {\\n            if (nodes[root].next[i] == -1)\\n            {\\n                nodes[root].next[i] = root;\\n            }\\n            else\\n            {\\n                Q.push(make_pair(root, nodes[root].next[i]));\\n            }\\n        }\\n        while (!Q.empty())\\n        {\\n            auto p = Q.front();\\n            Q.pop();\\n\\n            if (nodes[p.first].terminal)\\n            {\\n                nodes[p.second].terminal = true;\\n            }\\n            for (int i = 0; i < ALPHABET_SIZE; ++i)\\n            {\\n                int x = nodes[p.first].next[i];\\n                int y = nodes[p.second].next[i];\\n                if (y == -1)\\n                {\\n                    nodes[p.second].next[i] = x;\\n                }\\n                else\\n                {\\n                    Q.push(make_pair(x, y));\\n                }\\n            }\\n        }\\n        current = 0;\\n    }\\n\\n    void initialize_trie(const vector<string>& words)\\n    {\\n        root = 0;\\n        nodes.push_back(TrieNode());\\n        for (auto& word : words)\\n        {\\n            auto current = root;\\n            for (char c : word)\\n            {\\n                int offset = c - \\'a\\';\\n                if (nodes[current].next[offset] == -1)\\n                {\\n                    nodes[current].next[offset] = nodes.size();\\n                    nodes.push_back(TrieNode());\\n                }\\n                current = nodes[current].next[offset];\\n            }\\n            nodes[current].terminal = true;\\n        }\\n    }\\n\\n    static const int ALPHABET_SIZE = 26;\\n\\n    struct TrieNode\\n    {\\n        int next[ALPHABET_SIZE];\\n        bool terminal;\\n        TrieNode()\\n        {\\n            fill(next, next + ALPHABET_SIZE, -1);\\n            terminal = false;\\n        }\\n    };\\n\\n    vector<TrieNode> nodes;\\n    int root;\\n\\n};\\n\\nstatic const int accelerate = []() {  \\n  ios::sync_with_stdio(false);\\n  cin.tie(nullptr);\\n  return 0;\\n}();\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker* obj = new StreamChecker(words);\\n * bool param_1 = obj->query(letter);\\n */\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1611044,
                "title": "get-the-explanation-and-commented-code-here-fastest",
                "content": "**Idea?**\\n* We need to search that if there exists a word in the words[] which is a suffix of the current characters in a stream?\\n* Now, since we\\'ve to work on the suffix, we would insert strings in the Trie in a reversed manner Why? SInce, searching becomes easy.\\n* *Insert All the strings in words[] in Trie in reversed manne*r also, find the maximum length of string present in words[] (this will reduce the searching complexity).\\n* For suppose, we need to find answer for a query so we will search in the trie , the current stream string in a reversed manner(since we have inserted string in reversed way).\\n* Also, while searching, take care that searching strings having length > max length is useless so break after that.\\n* Worst Case Number of Iterations ~ 10^7\\n\\n```\\n// Worst Case Iterations ~ 10^7\\n\\nclass TrieNode{\\npublic:\\n    bool isEnd; // checks whether any words ends at this node?\\n    vector<TrieNode*> child; // child nodes of the current node\\n    TrieNode(){ // assign default values\\n        isEnd = false;\\n        child.assign(26,nullptr);\\n    }\\n};\\n\\nclass StreamChecker {\\npublic:\\n    string stream = \"\"; // used to store stream of characters\\n    TrieNode* root; // root of the Trie\\n    int max_len = 0; // stores the maximum length of the word present\\n    \\n    // insert the string in the Trie in reverse manner\\n    void insert(string s){\\n        TrieNode* curr = root;\\n        for(int i=s.length()-1;i>=0;i--){\\n            if(!curr->child[s[i]-\\'a\\'])\\n                curr->child[s[i]-\\'a\\'] = new TrieNode();\\n            curr = curr->child[s[i]-\\'a\\'];\\n        }\\n        curr->isEnd = true; // marks true since a word ends here\\n    }\\n    \\n    StreamChecker(vector<string>& words) {\\n        root = new TrieNode(); // root of Trie initialized\\n        for(auto s:words){\\n            insert(s); // insert the string into trie\\n            if(s.length()>max_len) // finds the maximum length\\n                max_len = s.length();\\n        }\\n    }\\n    \\n    bool query(char letter) {\\n        stream.push_back(letter); // store stream of characters\\n        TrieNode* curr = root;int curr_len = max_len;\\n        // find if there is an end of word for the suffix of the stream of characters using Trie\\n        for(int i=stream.length()-1;i>=0 and curr_len;i--,curr_len--){\\n            if(!curr->child[stream[i]-\\'a\\'])\\n                return false;\\n            curr = curr->child[stream[i]-\\'a\\'];\\n            if(curr->isEnd)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n```\\n\\n**Don\\'t Forget to Upvote!**",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\n// Worst Case Iterations ~ 10^7\\n\\nclass TrieNode{\\npublic:\\n    bool isEnd; // checks whether any words ends at this node?\\n    vector<TrieNode*> child; // child nodes of the current node\\n    TrieNode(){ // assign default values\\n        isEnd = false;\\n        child.assign(26,nullptr);\\n    }\\n};\\n\\nclass StreamChecker {\\npublic:\\n    string stream = \"\"; // used to store stream of characters\\n    TrieNode* root; // root of the Trie\\n    int max_len = 0; // stores the maximum length of the word present\\n    \\n    // insert the string in the Trie in reverse manner\\n    void insert(string s){\\n        TrieNode* curr = root;\\n        for(int i=s.length()-1;i>=0;i--){\\n            if(!curr->child[s[i]-\\'a\\'])\\n                curr->child[s[i]-\\'a\\'] = new TrieNode();\\n            curr = curr->child[s[i]-\\'a\\'];\\n        }\\n        curr->isEnd = true; // marks true since a word ends here\\n    }\\n    \\n    StreamChecker(vector<string>& words) {\\n        root = new TrieNode(); // root of Trie initialized\\n        for(auto s:words){\\n            insert(s); // insert the string into trie\\n            if(s.length()>max_len) // finds the maximum length\\n                max_len = s.length();\\n        }\\n    }\\n    \\n    bool query(char letter) {\\n        stream.push_back(letter); // store stream of characters\\n        TrieNode* curr = root;int curr_len = max_len;\\n        // find if there is an end of word for the suffix of the stream of characters using Trie\\n        for(int i=stream.length()-1;i>=0 and curr_len;i--,curr_len--){\\n            if(!curr->child[stream[i]-\\'a\\'])\\n                return false;\\n            curr = curr->child[stream[i]-\\'a\\'];\\n            if(curr->isEnd)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 807594,
                "title": "python-no-trie",
                "content": "```\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.dic = {}\\n        for word in words:\\n            if word[-1] not in self.dic:\\n                self.dic[word[-1]] = [word[:-1]]\\n            else:\\n                self.dic[word[-1]].append(word[:-1])\\n        \\n        self.string = \"\"\\n\\n    def query(self, letter: str) -> bool:\\n        self.string += letter\\n        if letter in self.dic:\\n            for word in self.dic[letter]:\\n                length = len(word) + 1\\n                complete_word = word + letter\\n                if len(self.string) >= length and complete_word == self.string[- length:]:\\n                    return True\\n            return False\\n        else:\\n            return False\\n```\\n\\nThe idea is set up a dictionary for the last char for all words in words\\nthen add up string and if we see a letter in the dic and the length of string is greater than the word, reverse query the string and see if it matches the words",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.dic = {}\\n        for word in words:\\n            if word[-1] not in self.dic:\\n                self.dic[word[-1]] = [word[:-1]]\\n            else:\\n                self.dic[word[-1]].append(word[:-1])\\n        \\n        self.string = \"\"\\n\\n    def query(self, letter: str) -> bool:\\n        self.string += letter\\n        if letter in self.dic:\\n            for word in self.dic[letter]:\\n                length = len(word) + 1\\n                complete_word = word + letter\\n                if len(self.string) >= length and complete_word == self.string[- length:]:\\n                    return True\\n            return False\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 309674,
                "title": "java-trie-solution-using-queue-no-reverse",
                "content": "```\\nclass StreamChecker {\\n    \\n    class Node {\\n        boolean isValid;\\n        char val;\\n        Node[] children = new Node[26];\\n        Node(char c) {\\n            this.val = c;\\n            this.isValid = false;\\n        }\\n    }\\n    \\n    Node root;\\n    Queue<Node> q; // valid query status ending up with Node.\\n\\n    public StreamChecker(String[] words) {\\n        root = new Node(\\'X\\');\\n        for(String word : words) {\\n            Node node = root;\\n            for(int i = 0; i < word.length(); i++) {\\n                char c = word.charAt(i);\\n                if(node.children[c - \\'a\\'] == null) {\\n                    node.children[c - \\'a\\'] = new Node(c);\\n                }\\n                node = node.children[c - \\'a\\'];\\n                if(i == word.length() - 1) {\\n                    node.isValid = true;\\n                    System.out.println(node.val);\\n                }\\n            }\\n        }\\n        q = new LinkedList<>();\\n        q.add(root);\\n    }\\n    \\n    public boolean query(char letter) {\\n        boolean res = false;\\n        int n = q.size();\\n        for(int i = 0; i < n; i++) {\\n            Node node = q.poll();\\n            if(node.children[letter - \\'a\\'] != null) {\\n                q.add(node.children[letter - \\'a\\']);\\n                if(node.children[letter - \\'a\\'].isValid) {\\n                    res = true;\\n                }\\n            }\\n            if(node == root) {\\n                q.add(root);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker {\\n    \\n    class Node {\\n        boolean isValid;\\n        char val;\\n        Node[] children = new Node[26];\\n        Node(char c) {\\n            this.val = c;\\n            this.isValid = false;\\n        }\\n    }\\n    \\n    Node root;\\n    Queue<Node> q; // valid query status ending up with Node.\\n\\n    public StreamChecker(String[] words) {\\n        root = new Node(\\'X\\');\\n        for(String word : words) {\\n            Node node = root;\\n            for(int i = 0; i < word.length(); i++) {\\n                char c = word.charAt(i);\\n                if(node.children[c - \\'a\\'] == null) {\\n                    node.children[c - \\'a\\'] = new Node(c);\\n                }\\n                node = node.children[c - \\'a\\'];\\n                if(i == word.length() - 1) {\\n                    node.isValid = true;\\n                    System.out.println(node.val);\\n                }\\n            }\\n        }\\n        q = new LinkedList<>();\\n        q.add(root);\\n    }\\n    \\n    public boolean query(char letter) {\\n        boolean res = false;\\n        int n = q.size();\\n        for(int i = 0; i < n; i++) {\\n            Node node = q.poll();\\n            if(node.children[letter - \\'a\\'] != null) {\\n                q.add(node.children[letter - \\'a\\']);\\n                if(node.children[letter - \\'a\\'].isValid) {\\n                    res = true;\\n                }\\n            }\\n            if(node == root) {\\n                q.add(root);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 807449,
                "title": "c-trie-based-solution-explained-75-time-50-space",
                "content": "We have 2 things to implement properly here:\\n* a proper `Trie` struct/class to store all the words provided when we call `StreamChecker` constructor;\\n* an efficient way to return boolean results for our `query` method.\\n\\nSo, for the first point, while se can do it inside `StreamChecker`, I would strongly advise keeping it separate: it will save memory to just expand an object with bare minimum functionalities (basically just a constructor and an `add` function) and, both in interview and production settings, it just shows cleaner, more modular and maintainable code at the cost of a few extra lines.\\n\\nEach instance of our `Trie` class (or struct, as I preferred in this case) will just have an array of `26` `children` - one for each lowercase letter - and a boolean value `eow` to denote the end of a word.\\n\\nIts `add` method will take a string and loop through its characters to build a tree, turning them into values in the `0 - 25` range just subtracting `\\'a\\'` to then, generating new linked `Trie` pointers and linking them in the matching `children` slot and finally assigning the value of `true` to the `eow` flag of the last node/character in the trie.\\n\\nNow, `StreamChecker` time!\\n\\nThe first part is relatively straightforward and built on what we just did with `Trie`: we declare a few class variables, all `Trie`-related: `trie` and `curr`, both pointers to that data structure and `queries`, a vector of pointers to them; in the constructor, we just have to feed `trie` all the strings we were provided and we are good to go for this part.\\n\\n`query` is definitely a bit more of a pickle: first of all, we start initialising our usual `res` variable, set to `false`; then we clean up `tmp` from possible previous runs and normalise again `c` to be in our familiar `0 - 25` range; also, we have to append `trie` to `queries` to be sure to capture new paths starting from this query.\\n\\nAfter that, we start checking for all the \"open\" (more on this later) queries we have, starting from the bottom (I found this approach to be significantly faster and it makes sense, since the bottom tends to have the shortest single-character queries attached): we then check query by query if we have at least one of them matching the final character of a word (ie: `eow == true`), in which case we update `res`.\\n\\nBut we do not stop here: we proceed looping in order to cut out all the unnecessary queries for the next runs and move the still valid ones to `tmp`; we have to do this, otherwise we will keep wasting resources on dead paths.\\n\\nThink for example if you were passed in the constructor `[\"voo\", \"voog\", \"voov\", \"vv\"]` (slight nod to fellow ETF-investors here!): if your queries were `\\'v\\'`, `\\'o\\'`, `\\'v\\'`, `\\'v\\'`, `o\\'`, `\\'o\\'`, `\\'v\\'`, `\\'p\\'`, you would have to discard the previous `\\'v\\'->\\'o\\'` and `\\'v\\'->\\'o\\'->\\'o\\'` paths after the second `\\'v\\'` and the first `\\'p\\'` respectively, since no path leads there, but `\\'v\\'->\\'v\\'` would still be a valid match.\\n\\nI know, it takes a bit of time to visualise and digest it, but try to use my code and print some examples if that helps you :)\\n\\nAfter the loop we update `queries` to match it and finally return `res` :)\\n\\nThe code:\\n\\n```cpp\\nstruct Trie {\\n    Trie *children[26];\\n    bool eow = false;\\n    Trie() {\\n        // initialising all children to NULL\\n        for (Trie *&e: children) e = NULL;\\n    }\\n    void add(string s) {\\n        // adding new paths to the current Trie, char by char\\n\\t\\tTrie *curr = this;\\n        for (char c: s) {\\n            // turning c into a 0 - 25 value\\n\\t\\t\\tc -= \\'a\\';\\n            if (!curr->children[c]) curr->children[c] = new Trie();\\n            curr = curr->children[c];\\n        }\\n\\t\\t// marking the end of a word on the node associated with the last character\\n        curr->eow = true;\\n    }\\n};\\n\\nclass StreamChecker {\\npublic:\\n    Trie *trie = new Trie(), *curr;\\n    vector<Trie*> queries, tmp;\\n    StreamChecker(vector<string>& words) {\\n        // populating our trie with all the provided words\\n\\t\\tfor (string w: words) trie->add(w);\\n    }\\n    \\n    bool query(char c) {\\n        // mandatory variable initialisation/clean up\\n\\t\\tbool res = false;\\n        tmp.clear();\\n        c -= \\'a\\';\\n\\t\\t// updating queries with to catch also the very last one\\n        queries.push_back(trie);\\n        for (int i = queries.size() - 1; i > -1; i--) {\\n            curr = queries[i];\\n            if (curr && curr->children[c]) {\\n                // marking res as true if we find a matching path\\n\\t\\t\\t\\tres |= curr->children[c]->eow;\\n\\t\\t\\t\\t// updating tmp for the next run\\n                tmp.push_back(curr->children[c]);\\n            }\\n        }\\n\\t\\t// updating queries to remove dead paths\\n        queries = tmp;\\n        return res;\\n    }\\n};\\n```\\n\\nI have an idea on how to refactor `queries` for better performances - might be working on it later!\\n\\nEdit, done; I will not repeat the `Trie` part here, showing only `StreamChecker` with my latest changes; it takes less than half time (now I am down to 550ms), not too shabby. Notice that despite having a nominal upper bound of `40000` queries, you hardly need to store a fraction of them, the current ones, so I experimented a bit and saw that you only need to store like `1500` or so of them to pass a tricky test case; minor saving in memory, but still worth it:\\n\\n```cpp\\nclass StreamChecker {\\npublic:\\n    Trie *trie = new Trie(), *curr;\\n    Trie* queries[20000];\\n    int nextAvailable = 0;\\n    StreamChecker(vector<string>& words) {\\n        // populating our trie with all the provided words\\n\\t\\tfor (string w: words) trie->add(w);\\n    }\\n    \\n    bool query(char c) {\\n        // mandatory variable initialisation/clean up\\n\\t\\tbool res = false;\\n        c -= \\'a\\';\\n\\t\\t// updating queries with to catch also the very last one\\n        queries[nextAvailable++] = trie;\\n        for (int i = nextAvailable - 1; i > -1; i--) {\\n            curr = queries[i];\\n            if (curr->children[c]) {\\n                // marking res as true if we find a matching path\\n\\t\\t\\t\\tres |= curr->children[c]->eow;\\n                // updating queries\\n                queries[i] = curr->children[c];\\n            }\\n            // otherwise moving the last available query here\\n            // and leaving the ith element for overwriting\\n            else swap(queries[--nextAvailable], queries[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```cpp\\nstruct Trie {\\n    Trie *children[26];\\n    bool eow = false;\\n    Trie() {\\n        // initialising all children to NULL\\n        for (Trie *&e: children) e = NULL;\\n    }\\n    void add(string s) {\\n        // adding new paths to the current Trie, char by char\\n\\t\\tTrie *curr = this;\\n        for (char c: s) {\\n            // turning c into a 0 - 25 value\\n\\t\\t\\tc -= \\'a\\';\\n            if (!curr->children[c]) curr->children[c] = new Trie();\\n            curr = curr->children[c];\\n        }\\n\\t\\t// marking the end of a word on the node associated with the last character\\n        curr->eow = true;\\n    }\\n};\\n\\nclass StreamChecker {\\npublic:\\n    Trie *trie = new Trie(), *curr;\\n    vector<Trie*> queries, tmp;\\n    StreamChecker(vector<string>& words) {\\n        // populating our trie with all the provided words\\n\\t\\tfor (string w: words) trie->add(w);\\n    }\\n    \\n    bool query(char c) {\\n        // mandatory variable initialisation/clean up\\n\\t\\tbool res = false;\\n        tmp.clear();\\n        c -= \\'a\\';\\n\\t\\t// updating queries with to catch also the very last one\\n        queries.push_back(trie);\\n        for (int i = queries.size() - 1; i > -1; i--) {\\n            curr = queries[i];\\n            if (curr && curr->children[c]) {\\n                // marking res as true if we find a matching path\\n\\t\\t\\t\\tres |= curr->children[c]->eow;\\n\\t\\t\\t\\t// updating tmp for the next run\\n                tmp.push_back(curr->children[c]);\\n            }\\n        }\\n\\t\\t// updating queries to remove dead paths\\n        queries = tmp;\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass StreamChecker {\\npublic:\\n    Trie *trie = new Trie(), *curr;\\n    Trie* queries[20000];\\n    int nextAvailable = 0;\\n    StreamChecker(vector<string>& words) {\\n        // populating our trie with all the provided words\\n\\t\\tfor (string w: words) trie->add(w);\\n    }\\n    \\n    bool query(char c) {\\n        // mandatory variable initialisation/clean up\\n\\t\\tbool res = false;\\n        c -= \\'a\\';\\n\\t\\t// updating queries with to catch also the very last one\\n        queries[nextAvailable++] = trie;\\n        for (int i = nextAvailable - 1; i > -1; i--) {\\n            curr = queries[i];\\n            if (curr->children[c]) {\\n                // marking res as true if we find a matching path\\n\\t\\t\\t\\tres |= curr->children[c]->eow;\\n                // updating queries\\n                queries[i] = curr->children[c];\\n            }\\n            // otherwise moving the last available query here\\n            // and leaving the ith element for overwriting\\n            else swap(queries[--nextAvailable], queries[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 807732,
                "title": "c-trie-based-solution-using-reversed-words",
                "content": "Insert the words in reverse order, and search the stream in reverse order.\\n```\\nstruct TrieNode {\\n    struct TrieNode* children[26];\\n    bool wordEnd;\\n};\\nstruct TrieNode *getNewNode() { \\n    struct TrieNode *pNode =  new TrieNode; \\n    pNode->wordEnd = false; \\n    for (int i = 0; i < 26; i++) \\n        pNode->children[i] = NULL; \\n    return pNode; \\n} \\nclass StreamChecker {\\npublic:\\n    TrieNode *root = new TrieNode();\\n    string s = \"\";\\n    StreamChecker(vector<string>& words) {\\n        for(string word: words) {\\n            TrieNode* tmp = root;\\n            reverse(word.begin(), word.end());\\n            for(char c : word) {\\n                int ind = c - \\'a\\';\\n                if(!tmp->children[ind]) {\\n                    tmp->children[ind] = getNewNode();\\n                }\\n                tmp = tmp->children[ind];\\n            }\\n            tmp->wordEnd = true;\\n        }\\n    }\\n    \\n    bool query(char letter) {\\n        s += letter;\\n        TrieNode *tmp = root; \\n        for(int i = s.size() - 1; i >= 0; i--) {\\n            int index = s[i] - \\'a\\'; \\n            tmp = tmp->children[index]; \\n            if( tmp != NULL && tmp->wordEnd) return true;\\n            if( tmp == NULL) return false;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct TrieNode {\\n    struct TrieNode* children[26];\\n    bool wordEnd;\\n};\\nstruct TrieNode *getNewNode() { \\n    struct TrieNode *pNode =  new TrieNode; \\n    pNode->wordEnd = false; \\n    for (int i = 0; i < 26; i++) \\n        pNode->children[i] = NULL; \\n    return pNode; \\n} \\nclass StreamChecker {\\npublic:\\n    TrieNode *root = new TrieNode();\\n    string s = \"\";\\n    StreamChecker(vector<string>& words) {\\n        for(string word: words) {\\n            TrieNode* tmp = root;\\n            reverse(word.begin(), word.end());\\n            for(char c : word) {\\n                int ind = c - \\'a\\';\\n                if(!tmp->children[ind]) {\\n                    tmp->children[ind] = getNewNode();\\n                }\\n                tmp = tmp->children[ind];\\n            }\\n            tmp->wordEnd = true;\\n        }\\n    }\\n    \\n    bool query(char letter) {\\n        s += letter;\\n        TrieNode *tmp = root; \\n        for(int i = s.size() - 1; i >= 0; i--) {\\n            int index = s[i] - \\'a\\'; \\n            tmp = tmp->children[index]; \\n            if( tmp != NULL && tmp->wordEnd) return true;\\n            if( tmp == NULL) return false;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 807725,
                "title": "javascript-python3-c-trie-solutions",
                "content": "**Synopsis:**\\n\\nCreate a trie populated with words in `A`.  For each query `c`, track candidate trie nodes and return `true` if and only if a candidate has reached the end of a word.\\n\\n**Note:** these solutions are *not* efficient, only the JS solution is AC.  Both Python3 and C++ result in TLE.\\n\\n---\\n\\n*Javascript*\\n```\\nclass TrieNode {\\n    constructor() {\\n        this.children = {};\\n        this.isEnd = false;\\n    }\\n}\\nclass StreamChecker {\\n    constructor(A) {\\n        this.A = A;\\n        this.root = new TrieNode();\\n        this.cand = [];\\n        for (let word of A) {\\n            let cur = this.root;\\n            for (let c of word)\\n                cur = cur.children[c] ? cur.children[c] : cur.children[c] = new TrieNode();\\n            cur.isEnd = true;\\n        }\\n    }\\n    query(c) {\\n        this.cand = this.cand.filter(node => node.children[c]);  // \\uD83D\\uDEAB remove candidate nodes which do not have child c\\n        for (let i = 0; i < this.cand.length; ++i)\\n            this.cand[i] = this.cand[i].children[c];\\n        if (this.root.children[c])\\n            this.cand.push(this.root.children[c]);\\n        return this.cand.some(node => node.isEnd);\\n    }\\n}\\n```\\n\\n*Python3*\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.isEnd = False\\nclass StreamChecker:\\n    def __init__(self, A: List[str]):\\n        self.A = A\\n        self.root = TrieNode()\\n        self.cand = []\\n        for word in A:\\n            cur = self.root\\n            for c in word:\\n                if c not in cur.children:\\n                    cur.children[c] = TrieNode()\\n                cur = cur.children[c]\\n            cur.isEnd = True\\n    def query(self, c: str) -> bool:\\n        self.cand[:] = [node for node in self.cand if c in node.children]  # \\uD83D\\uDEAB remove candidate nodes which do not have child c\\n        for i in range(len(self.cand)):\\n            self.cand[i] = self.cand[i].children[c]\\n        if c in self.root.children:\\n            self.cand.append(self.root.children[c])\\n        return any(node.isEnd for node in self.cand)\\n```\\n\\n*C++*\\n```\\nclass StreamChecker {\\n    struct TrieNode;\\n    using Map = unordered_map<char, shared_ptr<TrieNode>>;\\n    struct TrieNode {\\n        Map children;\\n        bool isEnd{ false };\\n    };\\n    shared_ptr<TrieNode> root;\\n    vector<shared_ptr<TrieNode>> cand;\\npublic:\\n    using VS = vector<string>;\\n    StreamChecker(VS& A) : root{ make_shared<TrieNode>() } {\\n        for (auto& word: A) {\\n            auto cur{ root };\\n            for (auto c: word)\\n                cur = cur->children.find(c) != cur->children.end() ? cur->children[c] : cur->children[c] = make_shared<TrieNode>();\\n            cur->isEnd = true;\\n        }\\n    }\\n    bool query(char c) {\\n        cand.erase(  // \\uD83D\\uDEAB remove candidate nodes which do not have child c\\n            remove_if(cand.begin(), cand.end(), [=](auto node) {\\n                return node->children.find(c) == node->children.end();\\n            }), cand.end());\\n        for (auto& node: cand)\\n            node = node->children[c];\\n        if (root->children.find(c) != root->children.end())\\n            cand.push_back(root->children[c]);\\n        return any_of(cand.begin(), cand.end(), [](auto node) { return node->isEnd; });\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode {\\n    constructor() {\\n        this.children = {};\\n        this.isEnd = false;\\n    }\\n}\\nclass StreamChecker {\\n    constructor(A) {\\n        this.A = A;\\n        this.root = new TrieNode();\\n        this.cand = [];\\n        for (let word of A) {\\n            let cur = this.root;\\n            for (let c of word)\\n                cur = cur.children[c] ? cur.children[c] : cur.children[c] = new TrieNode();\\n            cur.isEnd = true;\\n        }\\n    }\\n    query(c) {\\n        this.cand = this.cand.filter(node => node.children[c]);  // \\uD83D\\uDEAB remove candidate nodes which do not have child c\\n        for (let i = 0; i < this.cand.length; ++i)\\n            this.cand[i] = this.cand[i].children[c];\\n        if (this.root.children[c])\\n            this.cand.push(this.root.children[c]);\\n        return this.cand.some(node => node.isEnd);\\n    }\\n}\\n```\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.isEnd = False\\nclass StreamChecker:\\n    def __init__(self, A: List[str]):\\n        self.A = A\\n        self.root = TrieNode()\\n        self.cand = []\\n        for word in A:\\n            cur = self.root\\n            for c in word:\\n                if c not in cur.children:\\n                    cur.children[c] = TrieNode()\\n                cur = cur.children[c]\\n            cur.isEnd = True\\n    def query(self, c: str) -> bool:\\n        self.cand[:] = [node for node in self.cand if c in node.children]  # \\uD83D\\uDEAB remove candidate nodes which do not have child c\\n        for i in range(len(self.cand)):\\n            self.cand[i] = self.cand[i].children[c]\\n        if c in self.root.children:\\n            self.cand.append(self.root.children[c])\\n        return any(node.isEnd for node in self.cand)\\n```\n```\\nclass StreamChecker {\\n    struct TrieNode;\\n    using Map = unordered_map<char, shared_ptr<TrieNode>>;\\n    struct TrieNode {\\n        Map children;\\n        bool isEnd{ false };\\n    };\\n    shared_ptr<TrieNode> root;\\n    vector<shared_ptr<TrieNode>> cand;\\npublic:\\n    using VS = vector<string>;\\n    StreamChecker(VS& A) : root{ make_shared<TrieNode>() } {\\n        for (auto& word: A) {\\n            auto cur{ root };\\n            for (auto c: word)\\n                cur = cur->children.find(c) != cur->children.end() ? cur->children[c] : cur->children[c] = make_shared<TrieNode>();\\n            cur->isEnd = true;\\n        }\\n    }\\n    bool query(char c) {\\n        cand.erase(  // \\uD83D\\uDEAB remove candidate nodes which do not have child c\\n            remove_if(cand.begin(), cand.end(), [=](auto node) {\\n                return node->children.find(c) == node->children.end();\\n            }), cand.end());\\n        for (auto& node: cand)\\n            node = node->children[c];\\n        if (root->children.find(c) != root->children.end())\\n            cand.push_back(root->children[c]);\\n        return any_of(cand.begin(), cand.end(), [](auto node) { return node->isEnd; });\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 807590,
                "title": "javascript-super-short-and-simple-trie-solution",
                "content": "```\\n/**\\n * @param {string[]} words\\n */\\nvar StreamChecker = function(words) {\\n    this.root = {};\\n    for (let w of words) {\\n      w = w.split(\\'\\').reverse().join(\\'\\');  \\n      let node = this.root;\\n      for (let c of w) {\\n        if (!node[c]) node[c] = {};\\n        node = node[c];\\n      }\\n      node.word = w;\\n    }\\n    this.letters = [];\\n};\\n\\n/** \\n * @param {character} letter\\n * @return {boolean}\\n */\\nStreamChecker.prototype.query = function(letter) {\\n    this.letters.push(letter);\\n    let lookingIn = this.root;\\n    for(let i = this.letters.length-1; i >=0; i--) {\\n        if(lookingIn[this.letters[i]]) {\\n            lookingIn = lookingIn[this.letters[i]];\\n            if(lookingIn.word) return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n    return false\\n};\\n\\n/** \\n * Your StreamChecker object will be instantiated and called as such:\\n * var obj = new StreamChecker(words)\\n * var param_1 = obj.query(letter)\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Trie"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n */\\nvar StreamChecker = function(words) {\\n    this.root = {};\\n    for (let w of words) {\\n      w = w.split(\\'\\').reverse().join(\\'\\');  \\n      let node = this.root;\\n      for (let c of w) {\\n        if (!node[c]) node[c] = {};\\n        node = node[c];\\n      }\\n      node.word = w;\\n    }\\n    this.letters = [];\\n};\\n\\n/** \\n * @param {character} letter\\n * @return {boolean}\\n */\\nStreamChecker.prototype.query = function(letter) {\\n    this.letters.push(letter);\\n    let lookingIn = this.root;\\n    for(let i = this.letters.length-1; i >=0; i--) {\\n        if(lookingIn[this.letters[i]]) {\\n            lookingIn = lookingIn[this.letters[i]];\\n            if(lookingIn.word) return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n    return false\\n};\\n\\n/** \\n * Your StreamChecker object will be instantiated and called as such:\\n * var obj = new StreamChecker(words)\\n * var param_1 = obj.query(letter)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 396285,
                "title": "java-solution-with-trie-beats-97-8-easy-to-understand",
                "content": "Approach: first build a Trie but store words in reverse direction\\nsay we have ```words = [ \"abc, ad, fd\"] ```\\nThe Trie will be like this \\n```\\n           a                        d \\n\\t\\t/                        /     \\\\ \\n\\tb                         a(*)    f(*)\\n  / \\nc(*)\\n```\\nwhere the ```* ``` marks the end of the word. \\nThen just do regular trie search. \\n\\n```\\nclass StreamChecker {    \\n \\n    final static int ALPHABET_LENGTH = 26;\\n    TrieNode root;\\n    List<Character> history;\\n        \\n    class TrieNode {\\n        boolean isWord;\\n        TrieNode[] next;\\n\\n        TrieNode() {\\n            isWord = false;\\n            next = new TrieNode[ALPHABET_LENGTH];\\n        }\\n    }\\n  \\n    public StreamChecker(String[] words) {\\n        root = new TrieNode();\\n        buildTrie(words);\\n        history = new ArrayList<>();\\n    }\\n    \\n    void buildTrie(String[] words) {\\n        for (String s: words) {\\n            insert(s);\\n        }\\n    }\\n    \\n    void insert(String s) {\\n        TrieNode p = root;\\n\\t\\t//build trie but in reversed order for each word  \\n        for (int i=s.length()-1; i>=0; i--) {\\n            char c = s.charAt(i);\\n            if (p.next[c-\\'a\\'] == null) {\\n                p.next[c-\\'a\\'] = new TrieNode();\\n            }\\n            p = p.next[c-\\'a\\'];\\n        }\\n        p.isWord = true;\\n    }\\n\\n    public boolean query(char letter) {\\n        history.add(letter);\\n        TrieNode p = root;\\n        for (int i = history.size()-1; i >=0; i--) {\\n            char c = history.get(i);\\n\\t\\t\\t//return false immediately when we can\\'t find c in Trie\\n            if (p.next[c-\\'a\\'] == null) return false;\\n\\t\\t\\t//find a word  \\n            if (p.next[c-\\'a\\'].isWord) return true;\\n            p = p.next[c-\\'a\\'];\\n        }\\n        return false;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```words = [ \"abc, ad, fd\"] ```\n```\\n           a                        d \\n\\t\\t/                        /     \\\\ \\n\\tb                         a(*)    f(*)\\n  / \\nc(*)\\n```\n```* ```\n```\\nclass StreamChecker {    \\n \\n    final static int ALPHABET_LENGTH = 26;\\n    TrieNode root;\\n    List<Character> history;\\n        \\n    class TrieNode {\\n        boolean isWord;\\n        TrieNode[] next;\\n\\n        TrieNode() {\\n            isWord = false;\\n            next = new TrieNode[ALPHABET_LENGTH];\\n        }\\n    }\\n  \\n    public StreamChecker(String[] words) {\\n        root = new TrieNode();\\n        buildTrie(words);\\n        history = new ArrayList<>();\\n    }\\n    \\n    void buildTrie(String[] words) {\\n        for (String s: words) {\\n            insert(s);\\n        }\\n    }\\n    \\n    void insert(String s) {\\n        TrieNode p = root;\\n\\t\\t//build trie but in reversed order for each word  \\n        for (int i=s.length()-1; i>=0; i--) {\\n            char c = s.charAt(i);\\n            if (p.next[c-\\'a\\'] == null) {\\n                p.next[c-\\'a\\'] = new TrieNode();\\n            }\\n            p = p.next[c-\\'a\\'];\\n        }\\n        p.isWord = true;\\n    }\\n\\n    public boolean query(char letter) {\\n        history.add(letter);\\n        TrieNode p = root;\\n        for (int i = history.size()-1; i >=0; i--) {\\n            char c = history.get(i);\\n\\t\\t\\t//return false immediately when we can\\'t find c in Trie\\n            if (p.next[c-\\'a\\'] == null) return false;\\n\\t\\t\\t//find a word  \\n            if (p.next[c-\\'a\\'].isWord) return true;\\n            p = p.next[c-\\'a\\'];\\n        }\\n        return false;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 278820,
                "title": "python-standard-trie-solution",
                "content": "1. Build a trie using the reversed words. \\n2. Keep track of the queried letters.\\n3. Check if the reverse of the queried string is in the trie.\\n```\\nfrom collections import defaultdict\\nclass Trie:\\n    def __init__(self):\\n        self.children = defaultdict(Trie)\\n        self.flag = False\\n    \\nclass StreamChecker:\\n    def __init__(self, words: List[str]):\\n        self.trie = Trie()\\n        self.history = []\\n        for word in words:\\n            node = self.trie\\n            for char in word[::-1]:\\n                node = node.children[char]\\n            node.flag = True\\n\\n    def query(self, letter: str) -> bool:\\n        self.history.append(letter)\\n        node = self.trie\\n        for i in reversed(range(len(self.history))):\\n            if self.history[i] in node.children:\\n                node = node.children[self.history[i]]\\n                if node.flag: return True\\n            else: \\n                return False\\n        return False                \\n```",
                "solutionTags": [
                    "Python",
                    "Trie"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Trie:\\n    def __init__(self):\\n        self.children = defaultdict(Trie)\\n        self.flag = False\\n    \\nclass StreamChecker:\\n    def __init__(self, words: List[str]):\\n        self.trie = Trie()\\n        self.history = []\\n        for word in words:\\n            node = self.trie\\n            for char in word[::-1]:\\n                node = node.children[char]\\n            node.flag = True\\n\\n    def query(self, letter: str) -> bool:\\n        self.history.append(letter)\\n        node = self.trie\\n        for i in reversed(range(len(self.history))):\\n            if self.history[i] in node.children:\\n                node = node.children[self.history[i]]\\n                if node.flag: return True\\n            else: \\n                return False\\n        return False                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1610593,
                "title": "java-using-trie-faster-than-90",
                "content": "```\\nclass Node {\\n    Node[] child;\\n    boolean isLeaf;\\n    Node() {\\n        child = new Node[26];\\n        isLeaf = false;\\n    }\\n}\\nclass StreamChecker {\\n\\n    String[] words;\\n    Node root;\\n    StringBuilder sb;\\n    \\n    public StreamChecker(String[] words) {\\n        root = new Node();\\n        this.words = words;\\n        sb = new StringBuilder();\\n        for(String s : words) {\\n            Node r = root;\\n            for(int i = s.length()-1; i > -1; i--) {\\n                if(r.child[s.charAt(i)-\\'a\\'] == null) r.child[s.charAt(i)-\\'a\\'] = new Node();\\n                r = r.child[s.charAt(i)-\\'a\\'];\\n            }\\n            r.isLeaf = true;\\n        }\\n    }\\n    \\n    public boolean query(char letter) {\\n        sb.append(letter);\\n        Node r = root;\\n        for(int i = sb.length()-1; i > -1; i--) {\\n            r = r.child[sb.charAt(i)-\\'a\\'];\\n            if(r == null) break;\\n            if(r.isLeaf) return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker obj = new StreamChecker(words);\\n * boolean param_1 = obj.query(letter);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass Node {\\n    Node[] child;\\n    boolean isLeaf;\\n    Node() {\\n        child = new Node[26];\\n        isLeaf = false;\\n    }\\n}\\nclass StreamChecker {\\n\\n    String[] words;\\n    Node root;\\n    StringBuilder sb;\\n    \\n    public StreamChecker(String[] words) {\\n        root = new Node();\\n        this.words = words;\\n        sb = new StringBuilder();\\n        for(String s : words) {\\n            Node r = root;\\n            for(int i = s.length()-1; i > -1; i--) {\\n                if(r.child[s.charAt(i)-\\'a\\'] == null) r.child[s.charAt(i)-\\'a\\'] = new Node();\\n                r = r.child[s.charAt(i)-\\'a\\'];\\n            }\\n            r.isLeaf = true;\\n        }\\n    }\\n    \\n    public boolean query(char letter) {\\n        sb.append(letter);\\n        Node r = root;\\n        for(int i = sb.length()-1; i > -1; i--) {\\n            r = r.child[sb.charAt(i)-\\'a\\'];\\n            if(r == null) break;\\n            if(r.isLeaf) return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker obj = new StreamChecker(words);\\n * boolean param_1 = obj.query(letter);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 807600,
                "title": "c-simple-trie-87-time-w-explanation",
                "content": "For easily searching a word in O(k), use trie for that. We search for k last queried characters, in order of oldest to newest. So, if we reverse the order of words before inserting, the query order would be from newest to oldest.\\n\\nIf you do it like that, instead of O(k) time when we change k, we can simply have O(1) time for searching the new word, because the newly added character should have a prefix of all characters queried so far, so we only have to look only one level down from where we have searched till now.\\n```\\nclass StreamChecker {\\npublic:\\n    struct trie\\n    {\\n        bool eof;\\n        struct trie *children[26];\\n    };\\n    trie* createNode()\\n    {\\n        trie* ret=(trie*)malloc(sizeof(trie));\\n        ret->eof=false;\\n        for(int i=0;i<26;++i)\\n            ret->children[i]=NULL;\\n        return ret;\\n    }\\n    void insert(trie* root,string key)\\n    {\\n        trie* temp=root;\\n        for(char x:key)\\n        {\\n            if(temp->children[x-\\'a\\']==NULL)\\n                temp->children[x-\\'a\\']=createNode();\\n            temp=temp->children[x-\\'a\\'];\\n        }\\n        temp->eof=true;\\n    }\\n    trie* root;\\n    string temp;\\n    StreamChecker(vector<string>& words) \\n    {\\n        root=createNode();\\n        for(string x:words)\\n        {\\n            reverse(x.begin(),x.end());\\n            insert(root,x);\\n        }\\n    }\\n    \\n    bool query(char letter) \\n    {\\n        temp.push_back(letter);\\n        trie* t=root;\\n        for(int i=temp.size()-1;i>=0;--i)\\n        {\\n            t=t->children[temp[i]-\\'a\\'];\\n            if(t==NULL)\\n                return false;\\n            else if(t->eof)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass StreamChecker {\\npublic:\\n    struct trie\\n    {\\n        bool eof;\\n        struct trie *children[26];\\n    };\\n    trie* createNode()\\n    {\\n        trie* ret=(trie*)malloc(sizeof(trie));\\n        ret->eof=false;\\n        for(int i=0;i<26;++i)\\n            ret->children[i]=NULL;\\n        return ret;\\n    }\\n    void insert(trie* root,string key)\\n    {\\n        trie* temp=root;\\n        for(char x:key)\\n        {\\n            if(temp->children[x-\\'a\\']==NULL)\\n                temp->children[x-\\'a\\']=createNode();\\n            temp=temp->children[x-\\'a\\'];\\n        }\\n        temp->eof=true;\\n    }\\n    trie* root;\\n    string temp;\\n    StreamChecker(vector<string>& words) \\n    {\\n        root=createNode();\\n        for(string x:words)\\n        {\\n            reverse(x.begin(),x.end());\\n            insert(root,x);\\n        }\\n    }\\n    \\n    bool query(char letter) \\n    {\\n        temp.push_back(letter);\\n        trie* t=root;\\n        for(int i=temp.size()-1;i>=0;--i)\\n        {\\n            t=t->children[temp[i]-\\'a\\'];\\n            if(t==NULL)\\n                return false;\\n            else if(t->eof)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 573172,
                "title": "javascript-with-trie",
                "content": "Implemented a Trie with a hasWord() method that:\\n* Returns true if the word is in the trie\\n* Returs false if the word is not in the trie\\n* Returns lastNode if the word is partially in the trie, so we can keep trying.\\n\\n\\n```JS\\n\\nclass TrieNode {\\n    constructor(value){\\n        this.value = value;\\n        this.children = {};\\n        this.end = false;\\n    }\\n}\\n\\nclass Trie {\\n    constructor(){\\n        this.root = new TrieNode(\"*\");\\n    }\\n\\n    addWord(word){\\n\\n        let lastNode = this.root;\\n\\n        for(let i=0; i < word.length; i++){\\n            let char = word[i];\\n            if(lastNode.children[char] === undefined){\\n                lastNode.children[char] = new TrieNode(char);\\n            }\\n            lastNode = lastNode.children[char];\\n            if(i == word.length - 1) lastNode.end = true;\\n\\n        }\\n    }\\n\\n    hasWord(word){ \\n        let lastNode = this.root;\\n        for(let i = 0; i < word.length; i++){\\n            let char = word[i];\\n            if(lastNode.children[char] === undefined){\\n                return false //returns false if the word is not in the trie\\n            }\\n            else{\\n                lastNode = lastNode.children[char];\\n            }\\n            \\n            if(i == word.length - 1 && lastNode.end){ //true if has the word\\n                return true;\\n            }\\n            else if (i == word.length - 1){ //return lastNode if a word matches partially\\n                return lastNode\\n            }\\n        }\\n        \\n        return false;\\n\\n    }\\n}\\n\\nclass StreamChecker{\\n    constructor(words){\\n        this.trie = new Trie();\\n        this.letters = [];\\n        \\n        for(let word of words){\\n            let reversedWord = word.split(\\'\\').reverse().join(\\'\\')\\n            this.trie.addWord(reversedWord);\\n        }\\n    }\\n    \\n    query(letter){\\n        this.letters.unshift(letter);\\n        let possibleWord = \"\"\\n        for(let letter of this.letters){\\n            possibleWord = possibleWord + letter;\\n            let trieWord = this.trie.hasWord(possibleWord);\\n            if(trieWord === true) return true;\\n            if(trieWord === false) return false;\\n        }\\n\\t\\t\\n        return false;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Trie"
                ],
                "code": "```JS\\n\\nclass TrieNode {\\n    constructor(value){\\n        this.value = value;\\n        this.children = {};\\n        this.end = false;\\n    }\\n}\\n\\nclass Trie {\\n    constructor(){\\n        this.root = new TrieNode(\"*\");\\n    }\\n\\n    addWord(word){\\n\\n        let lastNode = this.root;\\n\\n        for(let i=0; i < word.length; i++){\\n            let char = word[i];\\n            if(lastNode.children[char] === undefined){\\n                lastNode.children[char] = new TrieNode(char);\\n            }\\n            lastNode = lastNode.children[char];\\n            if(i == word.length - 1) lastNode.end = true;\\n\\n        }\\n    }\\n\\n    hasWord(word){ \\n        let lastNode = this.root;\\n        for(let i = 0; i < word.length; i++){\\n            let char = word[i];\\n            if(lastNode.children[char] === undefined){\\n                return false //returns false if the word is not in the trie\\n            }\\n            else{\\n                lastNode = lastNode.children[char];\\n            }\\n            \\n            if(i == word.length - 1 && lastNode.end){ //true if has the word\\n                return true;\\n            }\\n            else if (i == word.length - 1){ //return lastNode if a word matches partially\\n                return lastNode\\n            }\\n        }\\n        \\n        return false;\\n\\n    }\\n}\\n\\nclass StreamChecker{\\n    constructor(words){\\n        this.trie = new Trie();\\n        this.letters = [];\\n        \\n        for(let word of words){\\n            let reversedWord = word.split(\\'\\').reverse().join(\\'\\')\\n            this.trie.addWord(reversedWord);\\n        }\\n    }\\n    \\n    query(letter){\\n        this.letters.unshift(letter);\\n        let possibleWord = \"\"\\n        for(let letter of this.letters){\\n            possibleWord = possibleWord + letter;\\n            let trieWord = this.trie.hasWord(possibleWord);\\n            if(trieWord === true) return true;\\n            if(trieWord === false) return false;\\n        }\\n\\t\\t\\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 282698,
                "title": "my-python-trie-solution-reverse-the-word-first-then-insert-into-trie",
                "content": "```\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.trie = Trie()\\n        for word in words:\\n            self.trie.insert(word[::-1])\\n        self.buff = []\\n\\n    def query(self, letter: str) -> bool:\\n        self.buff.append(letter)\\n        n = len(self.buff)\\n        s = \"\"\\n        for i in range(n - 1, max(n - 2000, -1), -1):\\n            s += self.buff[i]\\n            if not self.trie.startsWith(s):\\n                return False\\n            if self.trie.contains(s):\\n                return True\\n        return False\\n            \\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode(\"\")\\n        \\n    def insert(self, word):\\n        current = self.root\\n        for c in word:\\n            if current.child[ord(c) - ord(\\'a\\')] == None:\\n                current.child[ord(c) - ord(\\'a\\')] = TrieNode(c)\\n            current = current.child[ord(c) - ord(\\'a\\')]\\n        current.isEnd = True\\n        \\n    def contains(self, word):\\n        current = self.root\\n        for c in word:\\n            if current.child[ord(c) - ord(\\'a\\')] == None:\\n                return False\\n            current = current.child[ord(c) - ord(\\'a\\')]\\n        return current.isEnd\\n    \\n    def startsWith(self, word):\\n        current = self.root\\n        for c in word:\\n            if current.child[ord(c) - ord(\\'a\\')] == None:\\n                return False\\n            current = current.child[ord(c) - ord(\\'a\\')]\\n        return True\\n        \\n        \\n        \\n        \\nclass TrieNode:\\n    def __init__(self, char):\\n        self.val = char\\n        self.isEnd = False\\n        self.child = [None for i in range(27)]\\n\\n# Your StreamChecker object will be instantiated and called as such:\\n# obj = StreamChecker(words)\\n# param_1 = obj.query(letter)\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.trie = Trie()\\n        for word in words:\\n            self.trie.insert(word[::-1])\\n        self.buff = []\\n\\n    def query(self, letter: str) -> bool:\\n        self.buff.append(letter)\\n        n = len(self.buff)\\n        s = \"\"\\n        for i in range(n - 1, max(n - 2000, -1), -1):\\n            s += self.buff[i]\\n            if not self.trie.startsWith(s):\\n                return False\\n            if self.trie.contains(s):\\n                return True\\n        return False\\n            \\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode(\"\")\\n        \\n    def insert(self, word):\\n        current = self.root\\n        for c in word:\\n            if current.child[ord(c) - ord(\\'a\\')] == None:\\n                current.child[ord(c) - ord(\\'a\\')] = TrieNode(c)\\n            current = current.child[ord(c) - ord(\\'a\\')]\\n        current.isEnd = True\\n        \\n    def contains(self, word):\\n        current = self.root\\n        for c in word:\\n            if current.child[ord(c) - ord(\\'a\\')] == None:\\n                return False\\n            current = current.child[ord(c) - ord(\\'a\\')]\\n        return current.isEnd\\n    \\n    def startsWith(self, word):\\n        current = self.root\\n        for c in word:\\n            if current.child[ord(c) - ord(\\'a\\')] == None:\\n                return False\\n            current = current.child[ord(c) - ord(\\'a\\')]\\n        return True\\n        \\n        \\n        \\n        \\nclass TrieNode:\\n    def __init__(self, char):\\n        self.val = char\\n        self.isEnd = False\\n        self.child = [None for i in range(27)]\\n\\n# Your StreamChecker object will be instantiated and called as such:\\n# obj = StreamChecker(words)\\n# param_1 = obj.query(letter)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1610912,
                "title": "c-aho-corasick-algorithm-o-1-queries",
                "content": "```\\nclass StreamChecker {\\npublic:\\n    const static int K = 26;\\n    int node = 0;\\n\\n    struct Vertex {\\n        int next[K];\\n        bool leaf = false;\\n        int p = -1;\\n        char pch;\\n        int link = -1;\\n        int go[K];\\n        bool seen = false;\\n\\n        Vertex(int p=-1, char ch=\\'$\\') : p(p), pch(ch) {\\n            fill(begin(next), end(next), -1);\\n            fill(begin(go), end(go), -1);\\n        }\\n    };\\n\\n    vector<Vertex> t;\\n\\n    void add_string(string const& s) {\\n        int v = 0;\\n        for (char ch : s) {\\n            int c = ch - \\'a\\';\\n            if (t[v].next[c] == -1) {\\n                t[v].next[c] = t.size();\\n                t.emplace_back(v, ch);\\n            }\\n            v = t[v].next[c];\\n        }\\n        t[v].leaf = true;\\n    }\\n\\n    int get_link(int v) {\\n        if (t[v].link == -1) {\\n            if (v == 0 || t[v].p == 0)\\n                t[v].link = 0;\\n            else\\n                t[v].link = go(get_link(t[v].p), t[v].pch);\\n        }\\n        return t[v].link;\\n    }\\n\\n    int go(int v, char ch) {\\n        int c = ch - \\'a\\';\\n        if (t[v].go[c] == -1) {\\n            if (t[v].next[c] != -1)\\n                t[v].go[c] = t[v].next[c];\\n            else\\n                t[v].go[c] = v == 0 ? 0 : go(get_link(v), ch);\\n        }\\n        return t[v].go[c];\\n    }\\n\\n    bool DFS(const int u) {\\n        if (t[u].seen)\\n            return t[u].leaf;\\n        t[u].seen = true;\\n        if (!t[u].leaf)\\n            t[u].leaf = DFS(get_link(u));\\n        for (int i = 0; i < 26; i++) {\\n            if (t[u].next[i] != -1)\\n                DFS(t[u].next[i]);\\n        }\\n        return t[u].leaf;\\n    }\\n    \\n    StreamChecker(vector<string>& words) {\\n        t.push_back(Vertex());\\n        for (auto& w : words)\\n            add_string(w);\\n        DFS(0);\\n    }\\n    \\n    bool query(char letter) {\\n        node = go(node, letter);\\n        return t[node].leaf;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker {\\npublic:\\n    const static int K = 26;\\n    int node = 0;\\n\\n    struct Vertex {\\n        int next[K];\\n        bool leaf = false;\\n        int p = -1;\\n        char pch;\\n        int link = -1;\\n        int go[K];\\n        bool seen = false;\\n\\n        Vertex(int p=-1, char ch=\\'$\\') : p(p), pch(ch) {\\n            fill(begin(next), end(next), -1);\\n            fill(begin(go), end(go), -1);\\n        }\\n    };\\n\\n    vector<Vertex> t;\\n\\n    void add_string(string const& s) {\\n        int v = 0;\\n        for (char ch : s) {\\n            int c = ch - \\'a\\';\\n            if (t[v].next[c] == -1) {\\n                t[v].next[c] = t.size();\\n                t.emplace_back(v, ch);\\n            }\\n            v = t[v].next[c];\\n        }\\n        t[v].leaf = true;\\n    }\\n\\n    int get_link(int v) {\\n        if (t[v].link == -1) {\\n            if (v == 0 || t[v].p == 0)\\n                t[v].link = 0;\\n            else\\n                t[v].link = go(get_link(t[v].p), t[v].pch);\\n        }\\n        return t[v].link;\\n    }\\n\\n    int go(int v, char ch) {\\n        int c = ch - \\'a\\';\\n        if (t[v].go[c] == -1) {\\n            if (t[v].next[c] != -1)\\n                t[v].go[c] = t[v].next[c];\\n            else\\n                t[v].go[c] = v == 0 ? 0 : go(get_link(v), ch);\\n        }\\n        return t[v].go[c];\\n    }\\n\\n    bool DFS(const int u) {\\n        if (t[u].seen)\\n            return t[u].leaf;\\n        t[u].seen = true;\\n        if (!t[u].leaf)\\n            t[u].leaf = DFS(get_link(u));\\n        for (int i = 0; i < 26; i++) {\\n            if (t[u].next[i] != -1)\\n                DFS(t[u].next[i]);\\n        }\\n        return t[u].leaf;\\n    }\\n    \\n    StreamChecker(vector<string>& words) {\\n        t.push_back(Vertex());\\n        for (auto& w : words)\\n            add_string(w);\\n        DFS(0);\\n    }\\n    \\n    bool query(char letter) {\\n        node = go(node, letter);\\n        return t[node].leaf;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1610735,
                "title": "swift-stream-of-characters-24-9-mb-100-test-case",
                "content": "```swift\\nclass StreamChecker {\\n    \\n    private final class TrieNode {\\n        var children: [Character:TrieNode]\\n        var word: Bool\\n        init(children: [Character:TrieNode] = [:], word: Bool = false) {\\n            self.children = children\\n            self.word = word\\n        }\\n    }\\n    \\n    private let trie: TrieNode\\n    private var stream: [Character]\\n    private let longWord: Int\\n    \\n    init(_ words: [String]) {\\n        trie = TrieNode()\\n        stream = [Character]()\\n        var lw = 0\\n        \\n        for word in words {\\n            lw = max(lw, word.count)\\n            \\n            var node = trie\\n            for ch in word.reversed() {\\n                if node.children[ch] == nil {\\n                    node.children[ch] = TrieNode()\\n                }\\n                if let child = node.children[ch] {\\n                    node = child\\n                }\\n            }\\n            node.word = true\\n        }\\n        self.longWord = lw\\n    }\\n    \\n    func query(_ letter: Character) -> Bool {\\n        stream.insert(letter, at: 0)\\n        \\n        if stream.count > longWord {\\n            stream.removeLast()\\n        }\\n        \\n        var node = trie\\n        for ch in stream {\\n            guard !node.word else { return true }\\n            if let child = node.children[ch] {\\n                node = child\\n            } else {\\n                return false\\n            }\\n        }\\n        return node.word\\n    }\\n}\\n```\\n\\n```swift\\n// Result: Executed 1 test, with 0 failures (0 unexpected) in 0.041 (0.043) seconds\\n\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    func test0() {\\n        let sc = StreamChecker([\"cd\",\"f\",\"kl\"])\\n        XCTAssertFalse(sc.query(\"a\")) // false\\n        XCTAssertFalse(sc.query(\"b\")) // false\\n        XCTAssertFalse(sc.query(\"c\")) // false\\n        XCTAssertTrue(sc.query(\"d\"))  // true, because \\'cd\\' is in the wordlist\\n        XCTAssertFalse(sc.query(\"e\")) // false\\n        XCTAssertTrue(sc.query(\"f\"))  // true, because \\'f\\' is in the wordlist\\n        XCTAssertFalse(sc.query(\"g\")) // false\\n        XCTAssertFalse(sc.query(\"h\")) // false\\n        XCTAssertFalse(sc.query(\"i\")) // false\\n        XCTAssertFalse(sc.query(\"j\")) // false\\n        XCTAssertFalse(sc.query(\"k\")) // false\\n        XCTAssertTrue(sc.query(\"l\"))  // true, because \\'kl\\' is in the wordlist\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass StreamChecker {\\n    \\n    private final class TrieNode {\\n        var children: [Character:TrieNode]\\n        var word: Bool\\n        init(children: [Character:TrieNode] = [:], word: Bool = false) {\\n            self.children = children\\n            self.word = word\\n        }\\n    }\\n    \\n    private let trie: TrieNode\\n    private var stream: [Character]\\n    private let longWord: Int\\n    \\n    init(_ words: [String]) {\\n        trie = TrieNode()\\n        stream = [Character]()\\n        var lw = 0\\n        \\n        for word in words {\\n            lw = max(lw, word.count)\\n            \\n            var node = trie\\n            for ch in word.reversed() {\\n                if node.children[ch] == nil {\\n                    node.children[ch] = TrieNode()\\n                }\\n                if let child = node.children[ch] {\\n                    node = child\\n                }\\n            }\\n            node.word = true\\n        }\\n        self.longWord = lw\\n    }\\n    \\n    func query(_ letter: Character) -> Bool {\\n        stream.insert(letter, at: 0)\\n        \\n        if stream.count > longWord {\\n            stream.removeLast()\\n        }\\n        \\n        var node = trie\\n        for ch in stream {\\n            guard !node.word else { return true }\\n            if let child = node.children[ch] {\\n                node = child\\n            } else {\\n                return false\\n            }\\n        }\\n        return node.word\\n    }\\n}\\n```\n```swift\\n// Result: Executed 1 test, with 0 failures (0 unexpected) in 0.041 (0.043) seconds\\n\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    func test0() {\\n        let sc = StreamChecker([\"cd\",\"f\",\"kl\"])\\n        XCTAssertFalse(sc.query(\"a\")) // false\\n        XCTAssertFalse(sc.query(\"b\")) // false\\n        XCTAssertFalse(sc.query(\"c\")) // false\\n        XCTAssertTrue(sc.query(\"d\"))  // true, because \\'cd\\' is in the wordlist\\n        XCTAssertFalse(sc.query(\"e\")) // false\\n        XCTAssertTrue(sc.query(\"f\"))  // true, because \\'f\\' is in the wordlist\\n        XCTAssertFalse(sc.query(\"g\")) // false\\n        XCTAssertFalse(sc.query(\"h\")) // false\\n        XCTAssertFalse(sc.query(\"i\")) // false\\n        XCTAssertFalse(sc.query(\"j\")) // false\\n        XCTAssertFalse(sc.query(\"k\")) // false\\n        XCTAssertTrue(sc.query(\"l\"))  // true, because \\'kl\\' is in the wordlist\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1610475,
                "title": "c-trie-suffix-search",
                "content": "```\\nclass StreamChecker {\\npublic:\\n    class Trie{\\n        public:\\n        Trie *child[26];\\n        bool isEnd = false;\\n    };\\n    \\n    void insert(string &s, Trie *root){\\n        Trie *cur = root;\\n        int n=s.size();\\n        for(int i=n-1; i>=0; --i){\\n            char ch = s[i];\\n            if(!cur->child[ch-\\'a\\']) cur->child[ch-\\'a\\'] = new Trie();\\n            cur=cur->child[ch-\\'a\\'];\\n        }\\n        cur->isEnd = true;\\n    }\\n    \\n    bool search(string &s, Trie *root){\\n        Trie *cur = root;\\n        int n=s.size();\\n        for(int i=n-1; i>=0; --i){\\n            char ch = s[i];\\n            if(!cur->child[ch-\\'a\\']) return false;\\n            cur=cur->child[ch-\\'a\\'];\\n            if(cur->isEnd) return true;\\n        }\\n        return false;\\n    }\\n    \\n    Trie *root;\\n    string str =\"\";\\n    StreamChecker(vector<string>& words) {\\n        root = new Trie();\\n        for(auto &w : words) insert(w,root);\\n    }\\n    \\n    bool query(char letter) {\\n        str.push_back(letter);\\n        return search(str,root);\\n    }\\n};\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker* obj = new StreamChecker(words);\\n * bool param_1 = obj->query(letter);\\n */\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass StreamChecker {\\npublic:\\n    class Trie{\\n        public:\\n        Trie *child[26];\\n        bool isEnd = false;\\n    };\\n    \\n    void insert(string &s, Trie *root){\\n        Trie *cur = root;\\n        int n=s.size();\\n        for(int i=n-1; i>=0; --i){\\n            char ch = s[i];\\n            if(!cur->child[ch-\\'a\\']) cur->child[ch-\\'a\\'] = new Trie();\\n            cur=cur->child[ch-\\'a\\'];\\n        }\\n        cur->isEnd = true;\\n    }\\n    \\n    bool search(string &s, Trie *root){\\n        Trie *cur = root;\\n        int n=s.size();\\n        for(int i=n-1; i>=0; --i){\\n            char ch = s[i];\\n            if(!cur->child[ch-\\'a\\']) return false;\\n            cur=cur->child[ch-\\'a\\'];\\n            if(cur->isEnd) return true;\\n        }\\n        return false;\\n    }\\n    \\n    Trie *root;\\n    string str =\"\";\\n    StreamChecker(vector<string>& words) {\\n        root = new Trie();\\n        for(auto &w : words) insert(w,root);\\n    }\\n    \\n    bool query(char letter) {\\n        str.push_back(letter);\\n        return search(str,root);\\n    }\\n};\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker* obj = new StreamChecker(words);\\n * bool param_1 = obj->query(letter);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1501438,
                "title": "intuition-explained-trie-approach-clean-code-in-c",
                "content": "**Intuition:**\\n\\nMain Idea in this problem is to store words in **reverse order** in our Trie, so that to find suffix from *stream of characters* will become easy and efficient. \\n\\n\\tEx : \"xyz\" will be store as \"z -> y -> x (end)\" in Trie\\n\\t\\n* Now, once we build (store words) in Trie, we can easily search suffixes in stream of characters. We store all incoming characters from stream into a string, and start searching for words from end of `streamString`. \\n\\n\\t\\tEx: streamString = \"axyz\" , \\n\\t\\t-> now we need to query so start searching from end i.e character \\'z\\'\\n\\t\\t-> Trie has word \"zyx\" stored \\n\\n\\t\\ti. \"z\" , present so move to next character i.e \\'y\\'\\n\\t\\tii. \"z -> y\" , Present so move to next character i.e \\'x\\'\\n\\t\\tiii. \"z -> y -> x (end)\" , Present so move to next character, but this is end of word. \\n\\n\\t\\tSince we found a suffix word, return True.\\n\\t\\n\\n* Whenever we encounter a character that is not present in the Trie or Trie Node reaches NULL we return false. \\nAnd whenever we each a word end with `flag=True`, return true.\\n\\nRemaining Code is self-explainatory.\\n# Code:\\n\\n```\\nstruct Node {\\n    Node* arr[26];\\n    bool flag = false;\\n    \\n    bool contains(char ch) {\\n        return arr[ch-\\'a\\'] != NULL;\\n    }\\n    \\n    void put(char ch, Node* newNode) {\\n        arr[ch-\\'a\\'] = newNode;\\n    }\\n    \\n    Node* getNext(char ch) {\\n        return arr[ch-\\'a\\'];\\n    }\\n    \\n    bool getFlag() {\\n        return flag;\\n    }\\n    \\n    void setFlag() {\\n        flag = true;\\n    }\\n        \\n};\\n\\nclass StreamChecker {\\n    string streamString = \"\";\\n    Node* root;\\npublic:\\n    \\n\\t// Insert string in reverse order into Trie.\\n    void insert(string s) {\\n        Node* temp = root;\\n        for(int i=s.size()-1; i>=0; i--) {\\n            if(!temp->contains(s[i])) {\\n                temp->put(s[i], new Node());\\n            }\\n            temp = temp->getNext(s[i]);\\n        }\\n        temp->setFlag();  // End of string \\n    }\\n    \\n    StreamChecker(vector<string>& words) {\\n        root = new Node();\\n        \\n        for(auto& word : words) {\\n            insert(word);\\n        }\\n    }\\n    // Seach for string from end of streamString \\n\\t// Character by character \\n    bool query(char letter) {\\n        streamString += letter;\\n        Node* temp = root;\\n        for(int i=streamString.size()-1; i>=0 && temp; i--) {\\n\\t\\t\\t// Return false If char if not present or Trie Node is NULL \\n            if(!temp || !temp->contains(streamString[i])) return false; \\n\\t\\t\\t\\n\\t\\t\\t// Move to next character if present\\n            temp = temp->getNext(streamString[i]);\\n            if(temp->getFlag()) return true;  // Reached the end of a word , so return true\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n**Time : O(N * W + W * Q) ,**\\n* N -> No. of words \\n* W -> Length of Words\\n* Q -> No. of queries\\n\\n**Space : O(N * W)**\\n\\n***If this solution helped you, please give upvote :)***",
                "solutionTags": [
                    "C",
                    "String",
                    "Trie"
                ],
                "code": "```\\nstruct Node {\\n    Node* arr[26];\\n    bool flag = false;\\n    \\n    bool contains(char ch) {\\n        return arr[ch-\\'a\\'] != NULL;\\n    }\\n    \\n    void put(char ch, Node* newNode) {\\n        arr[ch-\\'a\\'] = newNode;\\n    }\\n    \\n    Node* getNext(char ch) {\\n        return arr[ch-\\'a\\'];\\n    }\\n    \\n    bool getFlag() {\\n        return flag;\\n    }\\n    \\n    void setFlag() {\\n        flag = true;\\n    }\\n        \\n};\\n\\nclass StreamChecker {\\n    string streamString = \"\";\\n    Node* root;\\npublic:\\n    \\n\\t// Insert string in reverse order into Trie.\\n    void insert(string s) {\\n        Node* temp = root;\\n        for(int i=s.size()-1; i>=0; i--) {\\n            if(!temp->contains(s[i])) {\\n                temp->put(s[i], new Node());\\n            }\\n            temp = temp->getNext(s[i]);\\n        }\\n        temp->setFlag();  // End of string \\n    }\\n    \\n    StreamChecker(vector<string>& words) {\\n        root = new Node();\\n        \\n        for(auto& word : words) {\\n            insert(word);\\n        }\\n    }\\n    // Seach for string from end of streamString \\n\\t// Character by character \\n    bool query(char letter) {\\n        streamString += letter;\\n        Node* temp = root;\\n        for(int i=streamString.size()-1; i>=0 && temp; i--) {\\n\\t\\t\\t// Return false If char if not present or Trie Node is NULL \\n            if(!temp || !temp->contains(streamString[i])) return false; \\n\\t\\t\\t\\n\\t\\t\\t// Move to next character if present\\n            temp = temp->getNext(streamString[i]);\\n            if(temp->getFlag()) return true;  // Reached the end of a word , so return true\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1064819,
                "title": "java-trie-beats-99-56-77ms-query-o-query-length",
                "content": "\\n\\n\\tpublic class Trie {\\n\\n\\t\\tprivate class Node {\\n\\n\\t\\t\\tchar data;\\n\\t\\t\\tNode[] children;\\n\\t\\t\\tboolean isTerminal;\\n\\n\\t\\t\\tpublic Node(char data, boolean isTerminal) {\\n\\t\\t\\t\\tthis.data = data;\\n\\t\\t\\t\\tthis.isTerminal = isTerminal;\\n\\t\\t\\t\\tthis.children = new Node[26];\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tprivate Node root;\\n\\n\\t\\t// O(1)\\n\\t\\tpublic Trie() {\\n\\t\\t\\tthis.root = new Node(\\'\\\\0\\', false);\\n\\t\\t}\\n\\n\\t\\t// O(word.length)\\n\\t\\tpublic void addWord(String word) {\\n\\t\\t\\tNode curr = root;\\n\\t\\t\\tfor (int i = word.length() - 1; i >= 0; i--) {\\n\\t\\t\\t\\tchar ch = word.charAt(i);\\n\\t\\t\\t\\tNode temp = curr.children[ch - \\'a\\'];\\n\\t\\t\\t\\tif (temp == null) {\\n\\t\\t\\t\\t\\ttemp = new Node(ch, false);\\n\\t\\t\\t\\t\\tcurr.children[ch - \\'a\\'] = temp;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcurr = temp;\\n\\t\\t\\t}\\n\\t\\t\\tcurr.isTerminal = true;\\n\\t\\t}\\n\\n\\t\\t// O(word.length)\\n\\t\\tpublic boolean searchWord(StringBuilder sb) {\\n\\t\\t\\tNode curr = root;\\n\\t\\t\\tfor (int i = sb.length() - 1; i >= 0; i--) {\\n\\t\\t\\t\\tchar ch = sb.charAt(i);\\n\\t\\t\\t\\tNode temp = curr.children[ch - \\'a\\'];\\n\\t\\t\\t\\tif (temp == null)\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\tcurr = temp;\\n\\t\\t\\t\\tif (curr.isTerminal)\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t}\\n\\n\\tclass StreamChecker {\\n\\n\\t\\tTrie trie;\\n\\t\\tStringBuilder sb;\\n\\n\\t\\t// O(words.length*words[i].length)\\n\\t\\tpublic StreamChecker(String[] words) {\\n\\t\\t\\ttrie = new Trie();\\n\\t\\t\\tsb = new StringBuilder();\\n\\t\\t\\tfor (String word : words)\\n\\t\\t\\t\\ttrie.addWord(word);\\n\\t\\t}\\n\\n\\t\\t// O(query.length)\\n\\t\\tpublic boolean query(char letter) {\\n\\t\\t\\tsb.append(letter);\\n\\t\\t\\treturn trie.searchWord(sb);\\n\\t\\t}\\n\\t}\\n",
                "solutionTags": [],
                "code": "\\n\\n\\tpublic class Trie {\\n\\n\\t\\tprivate class Node {\\n\\n\\t\\t\\tchar data;\\n\\t\\t\\tNode[] children;\\n\\t\\t\\tboolean isTerminal;\\n\\n\\t\\t\\tpublic Node(char data, boolean isTerminal) {\\n\\t\\t\\t\\tthis.data = data;\\n\\t\\t\\t\\tthis.isTerminal = isTerminal;\\n\\t\\t\\t\\tthis.children = new Node[26];\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tprivate Node root;\\n\\n\\t\\t// O(1)\\n\\t\\tpublic Trie() {\\n\\t\\t\\tthis.root = new Node(\\'\\\\0\\', false);\\n\\t\\t}\\n\\n\\t\\t// O(word.length)\\n\\t\\tpublic void addWord(String word) {\\n\\t\\t\\tNode curr = root;\\n\\t\\t\\tfor (int i = word.length() - 1; i >= 0; i--) {\\n\\t\\t\\t\\tchar ch = word.charAt(i);\\n\\t\\t\\t\\tNode temp = curr.children[ch - \\'a\\'];\\n\\t\\t\\t\\tif (temp == null) {\\n\\t\\t\\t\\t\\ttemp = new Node(ch, false);\\n\\t\\t\\t\\t\\tcurr.children[ch - \\'a\\'] = temp;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcurr = temp;\\n\\t\\t\\t}\\n\\t\\t\\tcurr.isTerminal = true;\\n\\t\\t}\\n\\n\\t\\t// O(word.length)\\n\\t\\tpublic boolean searchWord(StringBuilder sb) {\\n\\t\\t\\tNode curr = root;\\n\\t\\t\\tfor (int i = sb.length() - 1; i >= 0; i--) {\\n\\t\\t\\t\\tchar ch = sb.charAt(i);\\n\\t\\t\\t\\tNode temp = curr.children[ch - \\'a\\'];\\n\\t\\t\\t\\tif (temp == null)\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\tcurr = temp;\\n\\t\\t\\t\\tif (curr.isTerminal)\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t}\\n\\n\\tclass StreamChecker {\\n\\n\\t\\tTrie trie;\\n\\t\\tStringBuilder sb;\\n\\n\\t\\t// O(words.length*words[i].length)\\n\\t\\tpublic StreamChecker(String[] words) {\\n\\t\\t\\ttrie = new Trie();\\n\\t\\t\\tsb = new StringBuilder();\\n\\t\\t\\tfor (String word : words)\\n\\t\\t\\t\\ttrie.addWord(word);\\n\\t\\t}\\n\\n\\t\\t// O(query.length)\\n\\t\\tpublic boolean query(char letter) {\\n\\t\\t\\tsb.append(letter);\\n\\t\\t\\treturn trie.searchWord(sb);\\n\\t\\t}\\n\\t}\\n",
                "codeTag": "Java"
            },
            {
                "id": 1059320,
                "title": "fast-and-simple-c-180ms-beats-100",
                "content": "```\\nclass StreamChecker {\\npublic:\\n    struct Trie\\n    {    \\n        Trie *child[26];\\n        bool isEnd;\\n        Trie()\\n        {\\n            isEnd=false;\\n            for(int i=0;i<26;i++)\\n            {\\n                child[i]=NULL;\\n            }\\n        }\\n    };\\n    Trie *root=new Trie();\\n    string s;\\n    void insert(string s)\\n    {\\n        Trie *node=root;\\n        for(int i=s.length()-1;i>=0;i--)\\n        {\\n            if(node->child[s[i]-\\'a\\']==NULL)\\n            {\\n                node->child[s[i]-\\'a\\']=new Trie();;\\n            }\\n            node=node->child[s[i]-\\'a\\'];\\n        }\\n        node->isEnd=true;\\n    }\\n    StreamChecker(vector<string>& words) {\\n        for(int i=0;i<words.size();i++)\\n        {\\n            insert(words[i]);\\n        }\\n    }\\n    bool check()\\n    {\\n        Trie *node=root;\\n        for(int i=s.length()-1;i>=0;i--)\\n        {\\n            if(node->child[s[i]-\\'a\\']==NULL)\\n                return false;\\n            if(node->child[s[i]-\\'a\\']->isEnd==true)\\n                return true;\\n            node=node->child[s[i]-\\'a\\'];\\n        }\\n        return false;\\n    }\\n    bool query(char letter) {\\n        s.push_back(letter);\\n        return check();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker {\\npublic:\\n    struct Trie\\n    {    \\n        Trie *child[26];\\n        bool isEnd;\\n        Trie()\\n        {\\n            isEnd=false;\\n            for(int i=0;i<26;i++)\\n            {\\n                child[i]=NULL;\\n            }\\n        }\\n    };\\n    Trie *root=new Trie();\\n    string s;\\n    void insert(string s)\\n    {\\n        Trie *node=root;\\n        for(int i=s.length()-1;i>=0;i--)\\n        {\\n            if(node->child[s[i]-\\'a\\']==NULL)\\n            {\\n                node->child[s[i]-\\'a\\']=new Trie();;\\n            }\\n            node=node->child[s[i]-\\'a\\'];\\n        }\\n        node->isEnd=true;\\n    }\\n    StreamChecker(vector<string>& words) {\\n        for(int i=0;i<words.size();i++)\\n        {\\n            insert(words[i]);\\n        }\\n    }\\n    bool check()\\n    {\\n        Trie *node=root;\\n        for(int i=s.length()-1;i>=0;i--)\\n        {\\n            if(node->child[s[i]-\\'a\\']==NULL)\\n                return false;\\n            if(node->child[s[i]-\\'a\\']->isEnd==true)\\n                return true;\\n            node=node->child[s[i]-\\'a\\'];\\n        }\\n        return false;\\n    }\\n    bool query(char letter) {\\n        s.push_back(letter);\\n        return check();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 807514,
                "title": "python-stream-of-characters-simple",
                "content": "Idea is to construct a trie by inserting each word in reverse order. \\nWe can use a non-alpha char \\'#\\' to signify the end of a word.\\n\\nWhen querying, we simply iterate over the history (in reverse order) and traverse the trie at the same time and checking if we see our \\'end word\\' symbol\\n\\n```\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.history = \"\"\\n        self.map = {}\\n        \\n        for word in words:\\n            curr_node = self.map\\n            for letter in word[::-1]:\\n                if letter not in curr_node:\\n                    curr_node[letter] = {}\\n                curr_node = curr_node[letter]\\n            curr_node[\\'#\\'] = {}\\n\\n    def query(self, letter: str) -> bool:\\n        self.history += letter\\n\\n        curr_node = self.map\\n        for l in self.history[::-1]:\\n\\n            if l not in curr_node:\\n                return False\\n                    \\n            curr_node = curr_node[l]\\n        \\n            if \\'#\\' in curr_node:\\n                return True\\n        \\n        return False",
                "solutionTags": [
                    "Python3",
                    "Trie"
                ],
                "code": "Idea is to construct a trie by inserting each word in reverse order. \\nWe can use a non-alpha char \\'#\\' to signify the end of a word.\\n\\nWhen querying, we simply iterate over the history (in reverse order) and traverse the trie at the same time and checking if we see our \\'end word\\' symbol\\n\\n```\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.history = \"\"\\n        self.map = {}\\n        \\n        for word in words:\\n            curr_node = self.map\\n            for letter in word[::-1]:\\n                if letter not in curr_node:\\n                    curr_node[letter] = {}\\n                curr_node = curr_node[letter]\\n            curr_node[\\'#\\'] = {}\\n\\n    def query(self, letter: str) -> bool:\\n        self.history += letter\\n\\n        curr_node = self.map\\n        for l in self.history[::-1]:\\n\\n            if l not in curr_node:\\n                return False\\n                    \\n            curr_node = curr_node[l]\\n        \\n            if \\'#\\' in curr_node:\\n                return True\\n        \\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 514248,
                "title": "java-99-time-100-memory",
                "content": "Inspired by [link](https://leetcode.com/problems/stream-of-characters/discuss/396285/Java-solution-with-Trie-beats-97.8-easy-to-understand/) that builds the Trie tree backwards. Note that the longest word is 2000, so we can use a rotating array instead of saving the whole history.\\n```\\nclass StreamChecker {\\n\\n    class Trie {\\n        boolean word;\\n        Trie[] next;\\n        \\n        public Trie() {\\n            this.next = new Trie[26];\\n            this.word = false;\\n        }\\n    }\\n    \\n    Trie root = null;\\n    int p = 0;\\n    char[] history;\\n    \\n    public void insert(String word) {\\n        Trie curr = root;\\n        for (int i = word.length() - 1; i >=0; i--) {\\n            if (curr.next[word.charAt(i) - \\'a\\'] == null) {\\n                curr.next[word.charAt(i) - \\'a\\'] = new Trie();\\n            }\\n            curr = curr.next[word.charAt(i) - \\'a\\'];\\n        }\\n        curr.word = true;\\n    }\\n    \\n    public StreamChecker(String[] words) {\\n        this.root = new Trie();\\n        for (String word : words) {\\n            insert(word);\\n        }\\n        this.history = new char[2000];\\n    }\\n    \\n    public boolean query(char letter) {\\n        // System.out.println(\"query \" + letter);\\n        history[p % 2000] = letter;\\n        Trie curr = root;\\n        boolean match = false;\\n        for (int i = 0; i < 2000 && !match; i++) {\\n            char curChar = history[(p - i + 2000) % 2000];\\n            // System.out.println(\"look \" + curChar);\\n            if (curChar == 0) {\\n                break;\\n            }\\n            if (curr.next[curChar - \\'a\\'] != null) {\\n                curr = curr.next[curChar - \\'a\\'];\\n                if (curr.word) {\\n                    match = true;\\n                    // System.out.println(\"match \" + curChar);\\n                }\\n            } else {\\n                break;\\n            }\\n        }\\n        p++;\\n        return match;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass StreamChecker {\\n\\n    class Trie {\\n        boolean word;\\n        Trie[] next;\\n        \\n        public Trie() {\\n            this.next = new Trie[26];\\n            this.word = false;\\n        }\\n    }\\n    \\n    Trie root = null;\\n    int p = 0;\\n    char[] history;\\n    \\n    public void insert(String word) {\\n        Trie curr = root;\\n        for (int i = word.length() - 1; i >=0; i--) {\\n            if (curr.next[word.charAt(i) - \\'a\\'] == null) {\\n                curr.next[word.charAt(i) - \\'a\\'] = new Trie();\\n            }\\n            curr = curr.next[word.charAt(i) - \\'a\\'];\\n        }\\n        curr.word = true;\\n    }\\n    \\n    public StreamChecker(String[] words) {\\n        this.root = new Trie();\\n        for (String word : words) {\\n            insert(word);\\n        }\\n        this.history = new char[2000];\\n    }\\n    \\n    public boolean query(char letter) {\\n        // System.out.println(\"query \" + letter);\\n        history[p % 2000] = letter;\\n        Trie curr = root;\\n        boolean match = false;\\n        for (int i = 0; i < 2000 && !match; i++) {\\n            char curChar = history[(p - i + 2000) % 2000];\\n            // System.out.println(\"look \" + curChar);\\n            if (curChar == 0) {\\n                break;\\n            }\\n            if (curr.next[curChar - \\'a\\'] != null) {\\n                curr = curr.next[curChar - \\'a\\'];\\n                if (curr.word) {\\n                    match = true;\\n                    // System.out.println(\"match \" + curChar);\\n                }\\n            } else {\\n                break;\\n            }\\n        }\\n        p++;\\n        return match;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 513291,
                "title": "javascript-solution-using-hashmap-substring",
                "content": "```\\n/**\\n * @param {string[]} words\\n */\\nvar StreamChecker = function(words) {\\n    this.dict = {};\\n    for(let i of words){\\n        this.dict[i]=1;\\n    }\\n    this.current = \\'\\';\\n};\\n\\n/** \\n * @param {character} letter\\n * @return {boolean}\\n */\\nStreamChecker.prototype.query = function(letter) {\\n    this.current+=letter;\\n    for(let i in this.dict){\\n        if(this.current.length<i.length){\\n            continue;\\n        }\\n        if(this.current.substring(this.current.length-i.length,this.current.length)===i){\\n            return true;\\n        }\\n    }\\n    return false;\\n};\\n\\n/** \\n * Your StreamChecker object will be instantiated and called as such:\\n * var obj = new StreamChecker(words)\\n * var param_1 = obj.query(letter)\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string[]} words\\n */\\nvar StreamChecker = function(words) {\\n    this.dict = {};\\n    for(let i of words){\\n        this.dict[i]=1;\\n    }\\n    this.current = \\'\\';\\n};\\n\\n/** \\n * @param {character} letter\\n * @return {boolean}\\n */\\nStreamChecker.prototype.query = function(letter) {\\n    this.current+=letter;\\n    for(let i in this.dict){\\n        if(this.current.length<i.length){\\n            continue;\\n        }\\n        if(this.current.substring(this.current.length-i.length,this.current.length)===i){\\n            return true;\\n        }\\n    }\\n    return false;\\n};\\n\\n/** \\n * Your StreamChecker object will be instantiated and called as such:\\n * var obj = new StreamChecker(words)\\n * var param_1 = obj.query(letter)\\n */\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 512900,
                "title": "c-trie-and-keep-pointers-to-word-candidates",
                "content": "```\\nclass StreamChecker {\\npublic:\\n    class TrieNode {\\n    public:\\n        TrieNode() : children {}, leaf(false) {}\\n        bool leaf;\\n        TrieNode* children[26];\\n    };\\n    \\n    StreamChecker(std::vector<std::string>& words) {\\n        root = new TrieNode();\\n        \\n        for (auto& word : words) {\\n            TrieNode* it = root;        \\n            for (char c : word) {\\n                if (!it->children[c - \\'a\\'])\\n                    it->children[c - \\'a\\'] = new TrieNode();\\n                it = it->children[c - \\'a\\'];\\n            }\\n            it->leaf = true;\\n        }\\n    }\\n    \\n    bool query(char letter) {\\n        bool result = false;\\n        \\n        std::vector<TrieNode*> newpaths;\\n        paths.push_back(root);\\n        \\n        for (TrieNode* it : paths) {\\n            TrieNode* child = it->children[letter - \\'a\\'];\\n            if (child) {\\n                if (child->leaf)\\n                    result = true;\\n                newpaths.push_back(child);\\n            }\\n        }\\n        paths = std::move(newpaths);\\n        \\n        return result;\\n    }\\n    \\n    std::vector<TrieNode*> paths; // keeps track of all possible words that could occur with the next query() call\\n    TrieNode* root;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker {\\npublic:\\n    class TrieNode {\\n    public:\\n        TrieNode() : children {}, leaf(false) {}\\n        bool leaf;\\n        TrieNode* children[26];\\n    };\\n    \\n    StreamChecker(std::vector<std::string>& words) {\\n        root = new TrieNode();\\n        \\n        for (auto& word : words) {\\n            TrieNode* it = root;        \\n            for (char c : word) {\\n                if (!it->children[c - \\'a\\'])\\n                    it->children[c - \\'a\\'] = new TrieNode();\\n                it = it->children[c - \\'a\\'];\\n            }\\n            it->leaf = true;\\n        }\\n    }\\n    \\n    bool query(char letter) {\\n        bool result = false;\\n        \\n        std::vector<TrieNode*> newpaths;\\n        paths.push_back(root);\\n        \\n        for (TrieNode* it : paths) {\\n            TrieNode* child = it->children[letter - \\'a\\'];\\n            if (child) {\\n                if (child->leaf)\\n                    result = true;\\n                newpaths.push_back(child);\\n            }\\n        }\\n        paths = std::move(newpaths);\\n        \\n        return result;\\n    }\\n    \\n    std::vector<TrieNode*> paths; // keeps track of all possible words that could occur with the next query() call\\n    TrieNode* root;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 372367,
                "title": "java-aho-corasick-implement",
                "content": "```java\\nclass StreamChecker {\\n    TrieNode root = new TrieNode((char) 0);\\n    TrieNode streamNode = root;\\n    public StreamChecker(String[] words) {\\n      buildTrie(words);\\n      buildFail();\\n    }\\n    public boolean query(char letter) {\\n      TrieNode firstNode = streamNode.children[letter - \\'a\\'];\\n      TrieNode parent = streamNode;\\n      // 1. Find the matching node\\n      while (parent.fail != null && firstNode == null) {\\n        parent = parent.fail;\\n        firstNode = parent.children[letter - \\'a\\'];\\n      }\\n      // 2. Reset streamNode to matching node\\n      streamNode = firstNode != null ? firstNode : root;\\n      // 3. Check the matching node isWord attribute and find each fail node the true of isWord attribute\\n      while (firstNode != null && !firstNode.isWord) {\\n        firstNode = firstNode.fail;\\n      }\\n      return firstNode != null && firstNode.isWord;\\n    }\\n    private void buildTrie(String[] words) {\\n      for (String word : words) {\\n        if (word == null || word.length() <= 0) continue;\\n        TrieNode current = root;\\n        for (int i = 0; i < word.length(); i++) {\\n          char c = word.charAt(i);\\n          if (current.children[c - \\'a\\'] == null) {\\n            current.children[c - \\'a\\'] = new TrieNode(c);\\n          }\\n          current = current.children[c - \\'a\\'];\\n        }\\n        current.isWord = true;\\n      }\\n    }\\n    public void buildFail() {\\n      // Using BFS to traverse Trie Tree node for building fail pointer\\n      Queue<TrieNode> queue = new LinkedList<>();\\n      queue.add(root);\\n      while (!queue.isEmpty()) {\\n        TrieNode parent = queue.poll();\\n        for (TrieNode child : parent.children) {\\n          if (child != null) {\\n            TrieNode fail = parent.fail;\\n            while (fail != null) {\\n              TrieNode failChild = fail.children[child.val - \\'a\\'];\\n              if (failChild != null) {\\n                child.fail = failChild;\\n                break;\\n              }\\n              fail = fail.fail;\\n            }\\n            if (child.fail == null) child.fail = root;\\n            queue.add(child);\\n          }\\n        }\\n      }\\n    }\\n    class TrieNode {\\n      TrieNode(char val) {\\n        this.val = val;\\n      }\\n      char val;      // root val is (char) 0\\n      TrieNode fail; // root.fail is null\\n      TrieNode[] children = new TrieNode[26]; // all letters are lower case \\n      boolean isWord;\\n    }\\n}\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker obj = new StreamChecker(words);\\n * boolean param_1 = obj.query(letter);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass StreamChecker {\\n    TrieNode root = new TrieNode((char) 0);\\n    TrieNode streamNode = root;\\n    public StreamChecker(String[] words) {\\n      buildTrie(words);\\n      buildFail();\\n    }\\n    public boolean query(char letter) {\\n      TrieNode firstNode = streamNode.children[letter - \\'a\\'];\\n      TrieNode parent = streamNode;\\n      // 1. Find the matching node\\n      while (parent.fail != null && firstNode == null) {\\n        parent = parent.fail;\\n        firstNode = parent.children[letter - \\'a\\'];\\n      }\\n      // 2. Reset streamNode to matching node\\n      streamNode = firstNode != null ? firstNode : root;\\n      // 3. Check the matching node isWord attribute and find each fail node the true of isWord attribute\\n      while (firstNode != null && !firstNode.isWord) {\\n        firstNode = firstNode.fail;\\n      }\\n      return firstNode != null && firstNode.isWord;\\n    }\\n    private void buildTrie(String[] words) {\\n      for (String word : words) {\\n        if (word == null || word.length() <= 0) continue;\\n        TrieNode current = root;\\n        for (int i = 0; i < word.length(); i++) {\\n          char c = word.charAt(i);\\n          if (current.children[c - \\'a\\'] == null) {\\n            current.children[c - \\'a\\'] = new TrieNode(c);\\n          }\\n          current = current.children[c - \\'a\\'];\\n        }\\n        current.isWord = true;\\n      }\\n    }\\n    public void buildFail() {\\n      // Using BFS to traverse Trie Tree node for building fail pointer\\n      Queue<TrieNode> queue = new LinkedList<>();\\n      queue.add(root);\\n      while (!queue.isEmpty()) {\\n        TrieNode parent = queue.poll();\\n        for (TrieNode child : parent.children) {\\n          if (child != null) {\\n            TrieNode fail = parent.fail;\\n            while (fail != null) {\\n              TrieNode failChild = fail.children[child.val - \\'a\\'];\\n              if (failChild != null) {\\n                child.fail = failChild;\\n                break;\\n              }\\n              fail = fail.fail;\\n            }\\n            if (child.fail == null) child.fail = root;\\n            queue.add(child);\\n          }\\n        }\\n      }\\n    }\\n    class TrieNode {\\n      TrieNode(char val) {\\n        this.val = val;\\n      }\\n      char val;      // root val is (char) 0\\n      TrieNode fail; // root.fail is null\\n      TrieNode[] children = new TrieNode[26]; // all letters are lower case \\n      boolean isWord;\\n    }\\n}\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker obj = new StreamChecker(words);\\n * boolean param_1 = obj.query(letter);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 361626,
                "title": "python-3-aho-corasick-556ms",
                "content": "This is an implementation of Aho-Corasick.\\nhttps://en.wikipedia.org/wiki/Aho%E2%80%93Corasick_algorithm\\n\\nEach Trie node is implemented as a dictionary.\\nThe value at a character is the corresponding child node.\\nThe value at the special key \\'prefix\\' is the target of the prefix pointer,\\nand the value at \\'dictionary\\' is the target of the dictionary pointer.\\nIf the node corresponds to a word in words, the node contains the key-value pair \"word\":True. \\n```\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.root = {\\'prefix\\': None, \\'dict\\':None}\\n        \\n        #build Trie\\n        for word in words:\\n            node = self.root\\n            for char in word:\\n                if not char in node:\\n                    node[char] = {}\\n                node = node[char]\\n            node[\\'word\\'] = True\\n                    \\n        #set prefix and dictionary pointers by BFS\\n        q = collections.deque([self.root])\\n        while q:\\n            node = q.popleft()\\n            for char in node:\\n                if len(char)==1:\\n                    child = node[char]\\n                    extendNode = node[\\'prefix\\']\\n                    while extendNode and not char in extendNode:\\n                        extendNode = extendNode[\\'prefix\\']\\n                    if extendNode:\\n                        child[\\'prefix\\'] = extendNode[char]\\n                    else:\\n                        child[\\'prefix\\'] = self.root\\n                    if \\'word\\' in child[\\'prefix\\']:\\n                        child[\\'dict\\'] = child[\\'prefix\\']\\n                    else:\\n                        child[\\'dict\\'] = child[\\'prefix\\'][\\'dict\\']\\n                    q.append(child)\\n        \\n        #self.cur will traverse the Trie\\n        #while reading the stream\\n        self.cur = self.root\\n\\n    def query(self, letter: str) -> bool:\\n        extendNode = self.cur\\n        while extendNode and not letter in extendNode:\\n            extendNode = extendNode[\\'prefix\\']\\n        if extendNode:\\n            self.cur = extendNode[letter]\\n\\t\\t\\t#checks if current word is in words\\n\\t\\t\\t#or if the dictionary pointer is non-null\\n            if \\'word\\' in self.cur or self.cur[\\'dict\\']: \\n                return True\\n            else:\\n                return False\\n        else:\\n            self.cur = self.root\\n            return False\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.root = {\\'prefix\\': None, \\'dict\\':None}\\n        \\n        #build Trie\\n        for word in words:\\n            node = self.root\\n            for char in word:\\n                if not char in node:\\n                    node[char] = {}\\n                node = node[char]\\n            node[\\'word\\'] = True\\n                    \\n        #set prefix and dictionary pointers by BFS\\n        q = collections.deque([self.root])\\n        while q:\\n            node = q.popleft()\\n            for char in node:\\n                if len(char)==1:\\n                    child = node[char]\\n                    extendNode = node[\\'prefix\\']\\n                    while extendNode and not char in extendNode:\\n                        extendNode = extendNode[\\'prefix\\']\\n                    if extendNode:\\n                        child[\\'prefix\\'] = extendNode[char]\\n                    else:\\n                        child[\\'prefix\\'] = self.root\\n                    if \\'word\\' in child[\\'prefix\\']:\\n                        child[\\'dict\\'] = child[\\'prefix\\']\\n                    else:\\n                        child[\\'dict\\'] = child[\\'prefix\\'][\\'dict\\']\\n                    q.append(child)\\n        \\n        #self.cur will traverse the Trie\\n        #while reading the stream\\n        self.cur = self.root\\n\\n    def query(self, letter: str) -> bool:\\n        extendNode = self.cur\\n        while extendNode and not letter in extendNode:\\n            extendNode = extendNode[\\'prefix\\']\\n        if extendNode:\\n            self.cur = extendNode[letter]\\n\\t\\t\\t#checks if current word is in words\\n\\t\\t\\t#or if the dictionary pointer is non-null\\n            if \\'word\\' in self.cur or self.cur[\\'dict\\']: \\n                return True\\n            else:\\n                return False\\n        else:\\n            self.cur = self.root\\n            return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 283945,
                "title": "my-python-ac-auto-algorithm",
                "content": "```\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        # build trie\\n        trie = {}\\n        for w in words:\\n            p = trie\\n            for c in w:\\n                if c not in p:\\n                    p[c] = {\\'fail\\':trie}\\n                p = p[c]\\n            p[\\'#\\'] = None\\n        \\n        # rearrange fail pointer, use bfs\\n        import collections\\n        d = collections.deque()\\n        d.append(trie)\\n        while d:\\n            cur = d.popleft()\\n            if cur == trie:\\n                for c in cur:\\n                    d.append(cur[c])\\n            else:\\n                for c in cur:\\n                    if c != \\'fail\\' and c != \\'#\\':\\n                        p = cur[\\'fail\\']\\n                        while p != trie and c not in p:\\n                            p = p[\\'fail\\']\\n                        if c in p:\\n                            cur[c][\\'fail\\'] = p[c]\\n                            if \\'#\\' in p[c]:\\n                                cur[c][\\'#\\'] = None\\n                        d.append(cur[c])\\n        self.trie = trie\\n        self.p = trie\\n\\n    def query(self, letter: str) -> bool:\\n        while True:\\n            if letter in self.p:\\n                self.p = self.p[letter]\\n                break\\n            if \\'fail\\' in self.p:\\n                self.p = self.p[\\'fail\\']\\n            else:\\n                break\\n        return \\'#\\' in self.p\\n```\\n\\nI had a similar question in my interview last year. The only difference was that he asked how many words match instead of whether there is a matched word. The first time I used Trie and maintained a list of previous query letter (the cache length = max length of `words`). Then the interviewer asked me if I can improve query to O(1). I could not get this answer. :(",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        # build trie\\n        trie = {}\\n        for w in words:\\n            p = trie\\n            for c in w:\\n                if c not in p:\\n                    p[c] = {\\'fail\\':trie}\\n                p = p[c]\\n            p[\\'#\\'] = None\\n        \\n        # rearrange fail pointer, use bfs\\n        import collections\\n        d = collections.deque()\\n        d.append(trie)\\n        while d:\\n            cur = d.popleft()\\n            if cur == trie:\\n                for c in cur:\\n                    d.append(cur[c])\\n            else:\\n                for c in cur:\\n                    if c != \\'fail\\' and c != \\'#\\':\\n                        p = cur[\\'fail\\']\\n                        while p != trie and c not in p:\\n                            p = p[\\'fail\\']\\n                        if c in p:\\n                            cur[c][\\'fail\\'] = p[c]\\n                            if \\'#\\' in p[c]:\\n                                cur[c][\\'#\\'] = None\\n                        d.append(cur[c])\\n        self.trie = trie\\n        self.p = trie\\n\\n    def query(self, letter: str) -> bool:\\n        while True:\\n            if letter in self.p:\\n                self.p = self.p[letter]\\n                break\\n            if \\'fail\\' in self.p:\\n                self.p = self.p[\\'fail\\']\\n            else:\\n                break\\n        return \\'#\\' in self.p\\n```",
                "codeTag": "Java"
            },
            {
                "id": 278713,
                "title": "javascript-trie-o-nl-runtime-o-ml-space",
                "content": "At most one pointer at each layer in the trie => O(nl) runtime\\n\\nl = length of max word\\nn = items in strem\\nm = number of words\\n\\n```js\\nclass Trie extends Map {\\n  insert(str) {\\n    let curr = this\\n    \\n    for (const c of str) {\\n      if (!curr.has(c)) curr.set(c, new Trie())\\n      curr = curr.get(c)\\n    }\\n    \\n    curr.end = true\\n  }\\n}\\n\\n\\nclass StreamChecker {\\n  constructor(words) {  \\n    this.pointers = []\\n    this.trie = new Trie()\\n    for (const word of words) this.trie.insert(word)\\n  }\\n  \\n  query(letter) {\\n    this.pointers = [...this.pointers, this.trie].map(p => p.get(letter)).filter(Boolean)\\n\\n    for (const pointer of this.pointers)\\n      if (pointer.end) return true\\n\\n    return false\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```js\\nclass Trie extends Map {\\n  insert(str) {\\n    let curr = this\\n    \\n    for (const c of str) {\\n      if (!curr.has(c)) curr.set(c, new Trie())\\n      curr = curr.get(c)\\n    }\\n    \\n    curr.end = true\\n  }\\n}\\n\\n\\nclass StreamChecker {\\n  constructor(words) {  \\n    this.pointers = []\\n    this.trie = new Trie()\\n    for (const word of words) this.trie.insert(word)\\n  }\\n  \\n  query(letter) {\\n    this.pointers = [...this.pointers, this.trie].map(p => p.get(letter)).filter(Boolean)\\n\\n    for (const pointer of this.pointers)\\n      if (pointer.end) return true\\n\\n    return false\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1618981,
                "title": "aho-corasick-approach-o-mn-q-total-o-1-per-query-time-complexity",
                "content": "The following is a straightforward Aho-Corasick trie implementation. Aho-Corasick basically combines the approaches of a trie and the KMP algorithm. \\n\\nhttps://en.wikipedia.org/wiki/Aho%E2%80%93Corasick_algorithm\\n\\nGiven N words of max-length M and Q queries, the total complexity will be O(M * N + Q). The precomputation complexity for building the tree is O(M * N) and the per-query complexity is O(1)\\n\\n```\\nclass ACTrie {\\n    unordered_map<char, ACTrie*> next_map;\\n    bool green = false;\\n\\t// The prev pointer for the Aho-Corasick algorithm.\\n    ACTrie* prev;\\n\\n    friend class StreamChecker;\\n    \\n public:\\n    // Nothing special. Just adding a word to a trie.\\n    void InsertWord(const string& word) {\\n        ACTrie* current_pointer = this;\\n        for (const auto c : word) {\\n            if (current_pointer->next_map.count(c) == 0)\\n                current_pointer->next_map[c] = new ACTrie();\\n            current_pointer = current_pointer->next_map[c];\\n        }\\n        current_pointer->green = true;\\n    }\\n\\n    // Convert the trie into an Aho-Corasick trie by setting prev pointers just like in KMP. \\n    void ConvertToACTrie() {\\n\\t\\t// Use a queue since we want all the prev pointers for previous depth levels to be already calculated \\n\\t\\t// before reaching the next depth level .... i.e. BFS.\\n        queue<ACTrie*> q;\\n        for (auto iter : next_map) {\\n            iter.second->prev = this;\\n            q.push(iter.second);\\n        }\\n        \\n        while (!q.empty()) {\\n            ACTrie* current_node = q.front();\\n            q.pop();\\n            for (auto iter : current_node->next_map) {\\n                auto prev_candidate = current_node->prev;\\n                while (prev_candidate != this && prev_candidate->next_map.count(iter.first) == 0)\\n                    prev_candidate = prev_candidate->prev;\\n                iter.second->prev = prev_candidate->next_map.count(iter.first) == 0 ? prev_candidate : prev_candidate->next_map[iter.first];\\n                // Back-propagate the greens to account for one word being the substring of another.\\n                if (iter.second->prev->green)\\n                    iter.second->green = true;\\n                q.push(iter.second);\\n            }\\n        }\\n    }\\n};\\n\\nclass StreamChecker {\\n    ACTrie* current_pointer;\\n    ACTrie* trie;\\n  public:\\n    StreamChecker(vector<string>& words) {\\n        trie = new ACTrie();\\n        current_pointer = trie;\\n        for (auto& word : words) {\\n            trie->InsertWord(word);\\n        }\\n        trie->ConvertToACTrie();\\n    }\\n    \\n    bool query(char c) {\\n        while(current_pointer != trie && current_pointer->next_map.count(c) == 0)\\n            current_pointer = current_pointer->prev;\\n        if (current_pointer->next_map.count(c) != 0) {\\n            current_pointer = current_pointer->next_map[c];\\n        }\\n        return current_pointer->green;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass ACTrie {\\n    unordered_map<char, ACTrie*> next_map;\\n    bool green = false;\\n\\t// The prev pointer for the Aho-Corasick algorithm.\\n    ACTrie* prev;\\n\\n    friend class StreamChecker;\\n    \\n public:\\n    // Nothing special. Just adding a word to a trie.\\n    void InsertWord(const string& word) {\\n        ACTrie* current_pointer = this;\\n        for (const auto c : word) {\\n            if (current_pointer->next_map.count(c) == 0)\\n                current_pointer->next_map[c] = new ACTrie();\\n            current_pointer = current_pointer->next_map[c];\\n        }\\n        current_pointer->green = true;\\n    }\\n\\n    // Convert the trie into an Aho-Corasick trie by setting prev pointers just like in KMP. \\n    void ConvertToACTrie() {\\n\\t\\t// Use a queue since we want all the prev pointers for previous depth levels to be already calculated \\n\\t\\t// before reaching the next depth level .... i.e. BFS.\\n        queue<ACTrie*> q;\\n        for (auto iter : next_map) {\\n            iter.second->prev = this;\\n            q.push(iter.second);\\n        }\\n        \\n        while (!q.empty()) {\\n            ACTrie* current_node = q.front();\\n            q.pop();\\n            for (auto iter : current_node->next_map) {\\n                auto prev_candidate = current_node->prev;\\n                while (prev_candidate != this && prev_candidate->next_map.count(iter.first) == 0)\\n                    prev_candidate = prev_candidate->prev;\\n                iter.second->prev = prev_candidate->next_map.count(iter.first) == 0 ? prev_candidate : prev_candidate->next_map[iter.first];\\n                // Back-propagate the greens to account for one word being the substring of another.\\n                if (iter.second->prev->green)\\n                    iter.second->green = true;\\n                q.push(iter.second);\\n            }\\n        }\\n    }\\n};\\n\\nclass StreamChecker {\\n    ACTrie* current_pointer;\\n    ACTrie* trie;\\n  public:\\n    StreamChecker(vector<string>& words) {\\n        trie = new ACTrie();\\n        current_pointer = trie;\\n        for (auto& word : words) {\\n            trie->InsertWord(word);\\n        }\\n        trie->ConvertToACTrie();\\n    }\\n    \\n    bool query(char c) {\\n        while(current_pointer != trie && current_pointer->next_map.count(c) == 0)\\n            current_pointer = current_pointer->prev;\\n        if (current_pointer->next_map.count(c) != 0) {\\n            current_pointer = current_pointer->next_map[c];\\n        }\\n        return current_pointer->green;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1611824,
                "title": "python-simple-trie-approach-different-from-solution-article-no-reversed-trie-stream",
                "content": "This approach doesn\\'t keep a list of input stream, but instead keep a list of promosing suffixes which is updated with each new letter.\\nTime complexity of `query` is O(min(M, N)), where M is the number of letters seen, and N is the number of nodes in trie.  \\nBased on online judge, this solution is generally slower but consumes much less space.  I think this approach is still better than solution article because it doesn\\'t waste space to store input stream and in reality the number of promising suffixes at any time should be a small number compared to the size of input stream. (can\\'t approve but just an intuition)\\n\\n```python\\nclass StreamChecker:\\n    def __init__(self, words: List[str]):\\n        self.WORD = \\'#\\'\\n        # build a trie of input words\\n        self.trie = {} # nested hashmap (dictionary)\\n        for word in words:\\n            node = self.trie\\n            for c in word:\\n                node = node.setdefault(c, {})\\n            node[self.WORD] = {}\\n         # list of trie nodes to store all promising suffixes seen so far\\n        self.suffixes = [self.trie]\\n\\n    # Time: O(min(N, M)), N: number of letters seen, M: number of nodes in trie\\n    def query(self, letter: str) -> bool:\\n        new_suffixes = [self.trie]\\n        for suffix in self.suffixes:\\n            if letter in suffix:\\n                new_suffixes.append(suffix[letter])\\n        self.suffixes = new_suffixes\\n        for suffix in self.suffixes:\\n            if self.WORD in suffix:\\n                return True\\n        return False\\n    \\n    \\n# Your StreamChecker object will be instantiated and called as such:\\n# obj = StreamChecker(words)\\n# param_1 = obj.query(letter)\\n```",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```python\\nclass StreamChecker:\\n    def __init__(self, words: List[str]):\\n        self.WORD = \\'#\\'\\n        # build a trie of input words\\n        self.trie = {} # nested hashmap (dictionary)\\n        for word in words:\\n            node = self.trie\\n            for c in word:\\n                node = node.setdefault(c, {})\\n            node[self.WORD] = {}\\n         # list of trie nodes to store all promising suffixes seen so far\\n        self.suffixes = [self.trie]\\n\\n    # Time: O(min(N, M)), N: number of letters seen, M: number of nodes in trie\\n    def query(self, letter: str) -> bool:\\n        new_suffixes = [self.trie]\\n        for suffix in self.suffixes:\\n            if letter in suffix:\\n                new_suffixes.append(suffix[letter])\\n        self.suffixes = new_suffixes\\n        for suffix in self.suffixes:\\n            if self.WORD in suffix:\\n                return True\\n        return False\\n    \\n    \\n# Your StreamChecker object will be instantiated and called as such:\\n# obj = StreamChecker(words)\\n# param_1 = obj.query(letter)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1611687,
                "title": "trie-python",
                "content": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.trie = {}\\n    \\n    def add_word(self, word):\\n        curr = self.trie\\n        for char in word:\\n            if char not in curr:\\n                curr[char] = {}\\n            curr = curr[char]\\n        curr[\\'$\\'] = True\\n    \\n    def find_query(self, prefix):\\n        curr = self.trie\\n        for char in prefix:\\n            if char not in curr:\\n                return False\\n            curr = curr[char]\\n            if \\'$\\' in curr:\\n                return True\\n        return False        \\n                \\n\\nclass StreamChecker:\\n    def __init__(self, words: List[str]):\\n        self.prefix = \\'\\'\\n        #construct trie\\n        self.t = TrieNode()\\n        for word in words:\\n            self.t.add_word(word[::-1])\\n            \\n    def query(self, letter: str) -> bool:\\n        self.prefix += letter\\n        return self.t.find_query(self.prefix[::-1])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.trie = {}\\n    \\n    def add_word(self, word):\\n        curr = self.trie\\n        for char in word:\\n            if char not in curr:\\n                curr[char] = {}\\n            curr = curr[char]\\n        curr[\\'$\\'] = True\\n    \\n    def find_query(self, prefix):\\n        curr = self.trie\\n        for char in prefix:\\n            if char not in curr:\\n                return False\\n            curr = curr[char]\\n            if \\'$\\' in curr:\\n                return True\\n        return False        \\n                \\n\\nclass StreamChecker:\\n    def __init__(self, words: List[str]):\\n        self.prefix = \\'\\'\\n        #construct trie\\n        self.t = TrieNode()\\n        for word in words:\\n            self.t.add_word(word[::-1])\\n            \\n    def query(self, letter: str) -> bool:\\n        self.prefix += letter\\n        return self.t.find_query(self.prefix[::-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1610459,
                "title": "c-1032-stream-of-characters",
                "content": "\\n```\\nclass TrieNode {\\npublic: \\n    TrieNode *child[26] = {nullptr}; \\n    bool is_word = false; \\n};\\n\\n\\nclass StreamChecker {\\n    TrieNode *root = nullptr; \\n    vector<char> stream; \\npublic:\\n    StreamChecker(vector<string>& words) {\\n        root = new TrieNode(); \\n        for (auto word : words) {\\n            reverse(word.begin(), word.end()); \\n            TrieNode* node = root; \\n            for (auto& ch : word) {\\n                if (!node->child[ch - \\'a\\']) node->child[ch - \\'a\\'] = new TrieNode(); \\n                node = node->child[ch - \\'a\\']; \\n            }\\n            node->is_word = true; \\n        }\\n    }\\n    \\n    bool query(char letter) {\\n        stream.push_back(letter); \\n        TrieNode* node = root; \\n        for (int i = stream.size()-1; i >= 0; --i) {\\n            if (!node->child[stream[i] - \\'a\\']) break; \\n            node = node->child[stream[i] - \\'a\\']; \\n            if (node->is_word) return true; \\n        }\\n        return false; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass TrieNode {\\npublic: \\n    TrieNode *child[26] = {nullptr}; \\n    bool is_word = false; \\n};\\n\\n\\nclass StreamChecker {\\n    TrieNode *root = nullptr; \\n    vector<char> stream; \\npublic:\\n    StreamChecker(vector<string>& words) {\\n        root = new TrieNode(); \\n        for (auto word : words) {\\n            reverse(word.begin(), word.end()); \\n            TrieNode* node = root; \\n            for (auto& ch : word) {\\n                if (!node->child[ch - \\'a\\']) node->child[ch - \\'a\\'] = new TrieNode(); \\n                node = node->child[ch - \\'a\\']; \\n            }\\n            node->is_word = true; \\n        }\\n    }\\n    \\n    bool query(char letter) {\\n        stream.push_back(letter); \\n        TrieNode* node = root; \\n        for (int i = stream.size()-1; i >= 0; --i) {\\n            if (!node->child[stream[i] - \\'a\\']) break; \\n            node = node->child[stream[i] - \\'a\\']; \\n            if (node->is_word) return true; \\n        }\\n        return false; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1522375,
                "title": "c-trie-easy-code-280-ms",
                "content": "```\\n                         X\\n                       / \\\\  \\\\ \\n                      d   f    l\\n                     /           \\\\\\n                     c            k\\n```\\n                      \\nSteps -\\n1. Build the Trie in reverse fashion , ie., in reverse order.\\n2. Now for each query we have a letter (charachter which needs to be added in string let say \"stream\") , but wait do not use string it will cost you TLE , instead use deque of charachter bcz we can push in any of side in O(1) complexity.\\n3.  push each charachter in front of out deque , and search it in our Trie.\\n4.  At every node check whether there is a node which ends means there is a word , if yes then return true.\\n```\\n#define fastio ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\\nclass TrieNode\\n{\\n  public:\\n    vector<TrieNode*> next;\\n    bool isWord;\\n    TrieNode()\\n    {\\n        next.resize(26,NULL);\\n        isWord = false;\\n    }\\n};\\n\\nclass StreamChecker {\\npublic:\\n    deque<char>stream;\\n    TrieNode* root = new TrieNode();\\n    \\n    bool search()\\n    {\\n        TrieNode* p = root;\\n        for(char ch : stream){\\n            if(p->isWord)\\n                return true;\\n            if(p->next[ch-\\'a\\']==NULL)\\n                return false;\\n            p = p->next[ch-\\'a\\'];\\n        }\\n        return p->isWord;\\n    }\\n    \\n    void insert(string &s)\\n    {\\n        TrieNode* p = root;\\n        for(int i=s.size()-1;i>=0;i--)\\n        {\\n            if(p->next[s[i]-\\'a\\']==NULL)\\n                p->next[s[i]-\\'a\\'] = new TrieNode();\\n            p = p->next[s[i]-\\'a\\'];\\n        }\\n        p->isWord = true;\\n    }\\n    \\n    StreamChecker(vector<string>& words) {\\n        fastio\\n        for(string word : words)\\n        {\\n            insert(word);\\n        }\\n    }\\n    \\n    bool query(char letter) {\\n        stream.push_front(letter);\\n        return search();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Trie",
                    "Queue"
                ],
                "code": "```\\n                         X\\n                       / \\\\  \\\\ \\n                      d   f    l\\n                     /           \\\\\\n                     c            k\\n```\n```\\n#define fastio ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\\nclass TrieNode\\n{\\n  public:\\n    vector<TrieNode*> next;\\n    bool isWord;\\n    TrieNode()\\n    {\\n        next.resize(26,NULL);\\n        isWord = false;\\n    }\\n};\\n\\nclass StreamChecker {\\npublic:\\n    deque<char>stream;\\n    TrieNode* root = new TrieNode();\\n    \\n    bool search()\\n    {\\n        TrieNode* p = root;\\n        for(char ch : stream){\\n            if(p->isWord)\\n                return true;\\n            if(p->next[ch-\\'a\\']==NULL)\\n                return false;\\n            p = p->next[ch-\\'a\\'];\\n        }\\n        return p->isWord;\\n    }\\n    \\n    void insert(string &s)\\n    {\\n        TrieNode* p = root;\\n        for(int i=s.size()-1;i>=0;i--)\\n        {\\n            if(p->next[s[i]-\\'a\\']==NULL)\\n                p->next[s[i]-\\'a\\'] = new TrieNode();\\n            p = p->next[s[i]-\\'a\\'];\\n        }\\n        p->isWord = true;\\n    }\\n    \\n    StreamChecker(vector<string>& words) {\\n        fastio\\n        for(string word : words)\\n        {\\n            insert(word);\\n        }\\n    }\\n    \\n    bool query(char letter) {\\n        stream.push_front(letter);\\n        return search();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1383227,
                "title": "java-trie-faster-than-98",
                "content": "```\\nclass StreamChecker {\\n    class Node{\\n        Node[] children;\\n        boolean isEnd;\\n        Node(){\\n            children = new Node[26];\\n            isEnd = false;\\n        }\\n    }\\n\\n    Node root;\\n    StringBuilder sb;\\n\\n    public StreamChecker(String[] words) {\\n        root = new Node();\\n        sb = new StringBuilder();\\n        for(String word : words){\\n            Node curr = root;\\n            for(int i = word.length() - 1; i >= 0; i--){\\n                int idx = word.charAt(i) - \\'a\\';\\n                if(curr.children[idx] == null)\\n                    curr.children[idx] = new Node();\\n                curr = curr.children[idx];\\n            }\\n            curr.isEnd = true;\\n        }\\n    }\\n\\n    public boolean query(char letter) {\\n        sb.append(letter);\\n        Node curr = root;\\n        for(int i = sb.length() - 1; i >= 0; i--){\\n            int idx = sb.charAt(i) - \\'a\\';\\n            if(curr.children[idx] == null)\\n                break;\\n            curr = curr.children[idx];\\n            if(curr.isEnd)\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker obj = new StreamChecker(words);\\n * boolean param_1 = obj.query(letter);\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker {\\n    class Node{\\n        Node[] children;\\n        boolean isEnd;\\n        Node(){\\n            children = new Node[26];\\n            isEnd = false;\\n        }\\n    }\\n\\n    Node root;\\n    StringBuilder sb;\\n\\n    public StreamChecker(String[] words) {\\n        root = new Node();\\n        sb = new StringBuilder();\\n        for(String word : words){\\n            Node curr = root;\\n            for(int i = word.length() - 1; i >= 0; i--){\\n                int idx = word.charAt(i) - \\'a\\';\\n                if(curr.children[idx] == null)\\n                    curr.children[idx] = new Node();\\n                curr = curr.children[idx];\\n            }\\n            curr.isEnd = true;\\n        }\\n    }\\n\\n    public boolean query(char letter) {\\n        sb.append(letter);\\n        Node curr = root;\\n        for(int i = sb.length() - 1; i >= 0; i--){\\n            int idx = sb.charAt(i) - \\'a\\';\\n            if(curr.children[idx] == null)\\n                break;\\n            curr = curr.children[idx];\\n            if(curr.isEnd)\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker obj = new StreamChecker(words);\\n * boolean param_1 = obj.query(letter);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1261438,
                "title": "c-wa-soln-using-hash-set",
                "content": "Please note, this solution will result in a TLE on test case 13 out of total 17 test cases on the OJ but I am sharing this soln because it is a valid approach to solve this problem. Tho it is not the most optimal.\\n\\n```\\nclass StreamChecker \\n{\\npublic:\\n    \\n    string checker = \"\";\\n    unordered_set<string> list;\\n    \\n    StreamChecker(vector<string>& words) {\\n        for ( string word : words ) {\\n            list.insert(word);\\n        }\\n    }\\n    \\n    bool query(char letter) {\\n        checker += letter;\\n        string check;\\n        for ( int i=0; i<checker.size(); i++ ) {\\n            check = checker.substr(i);\\n            if ( list.find(check) != list.end() ) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass StreamChecker \\n{\\npublic:\\n    \\n    string checker = \"\";\\n    unordered_set<string> list;\\n    \\n    StreamChecker(vector<string>& words) {\\n        for ( string word : words ) {\\n            list.insert(word);\\n        }\\n    }\\n    \\n    bool query(char letter) {\\n        checker += letter;\\n        string check;\\n        for ( int i=0; i<checker.size(); i++ ) {\\n            check = checker.substr(i);\\n            if ( list.find(check) != list.end() ) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1013399,
                "title": "java-trie-reverse-string",
                "content": "```\\nclass StreamChecker {\\n    class TrieNode {\\n\\t    boolean endOfWord;\\n        Map<Character, TrieNode> children;\\n        public TrieNode() {\\n            children = new HashMap<>();\\n            endOfWord = false;\\n        }\\n    }\\n    \\n    //Insert by iteration\\n    public void insert(TrieNode root, String word) {\\n        TrieNode curr = root;\\n        word = new StringBuilder(word).reverse().toString(); //reverse the string\\n        \\n        for(char ch: word.toCharArray()) {\\n            TrieNode node = curr.children.get(ch);\\n            if(node == null) {\\n                node = new TrieNode();\\n                curr.children.put(ch, node);\\n            }\\n            curr = node;\\n        }\\n        \\n        curr.endOfWord = true;\\n    }\\n\\n    TrieNode root;\\n    StringBuilder sb;\\n    //Comparator\\n    public StreamChecker(String[] words) {\\n        root = new TrieNode();\\n        sb = new StringBuilder();\\n        for(String word: words) {\\n            insert(root, word);\\n        }\\n    }\\n    \\n    public boolean query(char letter) {\\n        sb.append(letter);\\n        TrieNode curr = root;\\n        \\n        for(int i = sb.length()-1; i >= 0; i--) {\\n            char ch = sb.charAt(i);\\n            TrieNode node = curr.children.get(ch);\\n            if(node == null) return false;\\n            if(node.endOfWord) return true;\\n            curr = node;\\n        }\\n        \\n        return false;\\n    }\\n}\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker obj = new StreamChecker(words);\\n * boolean param_1 = obj.query(letter);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass StreamChecker {\\n    class TrieNode {\\n\\t    boolean endOfWord;\\n        Map<Character, TrieNode> children;\\n        public TrieNode() {\\n            children = new HashMap<>();\\n            endOfWord = false;\\n        }\\n    }\\n    \\n    //Insert by iteration\\n    public void insert(TrieNode root, String word) {\\n        TrieNode curr = root;\\n        word = new StringBuilder(word).reverse().toString(); //reverse the string\\n        \\n        for(char ch: word.toCharArray()) {\\n            TrieNode node = curr.children.get(ch);\\n            if(node == null) {\\n                node = new TrieNode();\\n                curr.children.put(ch, node);\\n            }\\n            curr = node;\\n        }\\n        \\n        curr.endOfWord = true;\\n    }\\n\\n    TrieNode root;\\n    StringBuilder sb;\\n    //Comparator\\n    public StreamChecker(String[] words) {\\n        root = new TrieNode();\\n        sb = new StringBuilder();\\n        for(String word: words) {\\n            insert(root, word);\\n        }\\n    }\\n    \\n    public boolean query(char letter) {\\n        sb.append(letter);\\n        TrieNode curr = root;\\n        \\n        for(int i = sb.length()-1; i >= 0; i--) {\\n            char ch = sb.charAt(i);\\n            TrieNode node = curr.children.get(ch);\\n            if(node == null) return false;\\n            if(node.endOfWord) return true;\\n            curr = node;\\n        }\\n        \\n        return false;\\n    }\\n}\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker obj = new StreamChecker(words);\\n * boolean param_1 = obj.query(letter);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 854000,
                "title": "java-solution-faster-than-90-using-only-trie-with-explanation",
                "content": "The main idea is to store each of the given words in reverse order in the Trie. \\n\\nWe have kept an additional variable \\'endOfWord\\' to mark the end (beginning of the given word).\\n\\nThis way of storing enables us to make each query in the trie in O(m) time where \\'m\\' is the length of the longest word in the given set of words.\\nWe store the queried characters so far in a list \\'characterList\\' . Everytime we query a character we start at the trie root (since words are stored in the reverse order) with the given character to be queried  and continue till the beginning of \\'characterList\\'. At any point if \\'endOfWord\\' is true for a TrieNode  we return true. \\n\\n\\n```\\n class StreamChecker {\\n        List<Character> characterList;\\n        private TrieNode root;\\n\\n        private class Trie {\\n            private final TrieNode root;\\n\\n            public Trie() {\\n                root = new TrieNode();\\n            }\\n\\n            public TrieNode getRoot() {\\n                return root;\\n            }\\n        }\\n\\n        private class TrieNode {\\n            TrieNode[] children;\\n            boolean endOfWord;\\n\\n            public TrieNode() {\\n                children = new TrieNode[27];\\n                endOfWord = false;\\n            }\\n        }\\n\\n        public StreamChecker(String[] words) {\\n            characterList = new ArrayList<>();\\n            Trie trie = new Trie();\\n            root = trie.getRoot();\\n\\n            for (String s : words) insert(root, s);\\n        }\\n\\n        private void insert(TrieNode root, String word) {\\n            TrieNode cur = root;\\n            for (int i = word.length()-1; i>=0; i--) {\\n                final char ch = word.charAt(i);\\n                TrieNode node = cur.children[ch - \\'a\\'];\\n                if (node == null) cur.children[ch - \\'a\\'] = new TrieNode();\\n                cur = cur.children[ch - \\'a\\'];\\n            }\\n            cur.endOfWord = true;\\n        }\\n\\n        public boolean query(char letter) {\\n            TrieNode cur = root;\\n            characterList.add(letter);\\n            for (int i = characterList.size() - 1; i >= 0; i--) {\\n                TrieNode node = cur.children[characterList.get(i) - \\'a\\'];\\n                if(node==null) return false;\\n                if(node.endOfWord==true) return true;\\n                cur=node;\\n            }\\n            return cur.endOfWord;\\n        }\\n    }",
                "solutionTags": [],
                "code": "The main idea is to store each of the given words in reverse order in the Trie. \\n\\nWe have kept an additional variable \\'endOfWord\\' to mark the end (beginning of the given word).\\n\\nThis way of storing enables us to make each query in the trie in O(m) time where \\'m\\' is the length of the longest word in the given set of words.\\nWe store the queried characters so far in a list \\'characterList\\' . Everytime we query a character we start at the trie root (since words are stored in the reverse order) with the given character to be queried  and continue till the beginning of \\'characterList\\'. At any point if \\'endOfWord\\' is true for a TrieNode  we return true. \\n\\n\\n```\\n class StreamChecker {\\n        List<Character> characterList;\\n        private TrieNode root;\\n\\n        private class Trie {\\n            private final TrieNode root;\\n\\n            public Trie() {\\n                root = new TrieNode();\\n            }\\n\\n            public TrieNode getRoot() {\\n                return root;\\n            }\\n        }\\n\\n        private class TrieNode {\\n            TrieNode[] children;\\n            boolean endOfWord;\\n\\n            public TrieNode() {\\n                children = new TrieNode[27];\\n                endOfWord = false;\\n            }\\n        }\\n\\n        public StreamChecker(String[] words) {\\n            characterList = new ArrayList<>();\\n            Trie trie = new Trie();\\n            root = trie.getRoot();\\n\\n            for (String s : words) insert(root, s);\\n        }\\n\\n        private void insert(TrieNode root, String word) {\\n            TrieNode cur = root;\\n            for (int i = word.length()-1; i>=0; i--) {\\n                final char ch = word.charAt(i);\\n                TrieNode node = cur.children[ch - \\'a\\'];\\n                if (node == null) cur.children[ch - \\'a\\'] = new TrieNode();\\n                cur = cur.children[ch - \\'a\\'];\\n            }\\n            cur.endOfWord = true;\\n        }\\n\\n        public boolean query(char letter) {\\n            TrieNode cur = root;\\n            characterList.add(letter);\\n            for (int i = characterList.size() - 1; i >= 0; i--) {\\n                TrieNode node = cur.children[characterList.get(i) - \\'a\\'];\\n                if(node==null) return false;\\n                if(node.endOfWord==true) return true;\\n                cur=node;\\n            }\\n            return cur.endOfWord;\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 808764,
                "title": "ruby-trie-with-reversed-words-faster-than-100-submissions",
                "content": "**Runtime**: faster than 100.00% of Ruby online submissions\\n\\n```\\nclass Node \\n    attr_reader :children\\n    attr_accessor :eow\\n    \\n    def initialize()\\n        @children = {}\\n    end\\n    \\n    def add(word)\\n        curr = self\\n        word.each_char do |char|\\n            curr.children[char] ||= Node.new\\n            curr = curr.children[char]\\n        end\\n        curr.eow = true\\n    end\\n    \\nend\\n\\nclass StreamChecker\\n    def initialize(words)\\n        # hash map {\"char\" => Node}\\n        @root = Node.new\\n        words.each {|w| @root.add(w.reverse) }\\n        @letters = []\\n    end\\n\\n\\n=begin\\n    :type letter: Character\\n    :rtype: Boolean\\n=end\\n    def query(letter)        \\n        @letters << letter\\n        curr_node = @root\\n        \\n        (@letters.length - 1).downto(0) do |i|\\n            char = @letters[i]\\n            if curr_node.children[char].nil?\\n                return false\\n            elsif curr_node.children[char].eow\\n                return true\\n            else\\n                curr_node = curr_node.children[@letters[i]]\\n            end\\n        end\\n    \\n        false \\n    end\\n    \\nend\\n\\n# Your StreamChecker object will be instantiated and called as such:\\n# obj = StreamChecker.new(words)\\n# param_1 = obj.query(letter)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Node \\n    attr_reader :children\\n    attr_accessor :eow\\n    \\n    def initialize()\\n        @children = {}\\n    end\\n    \\n    def add(word)\\n        curr = self\\n        word.each_char do |char|\\n            curr.children[char] ||= Node.new\\n            curr = curr.children[char]\\n        end\\n        curr.eow = true\\n    end\\n    \\nend\\n\\nclass StreamChecker\\n    def initialize(words)\\n        # hash map {\"char\" => Node}\\n        @root = Node.new\\n        words.each {|w| @root.add(w.reverse) }\\n        @letters = []\\n    end\\n\\n\\n=begin\\n    :type letter: Character\\n    :rtype: Boolean\\n=end\\n    def query(letter)        \\n        @letters << letter\\n        curr_node = @root\\n        \\n        (@letters.length - 1).downto(0) do |i|\\n            char = @letters[i]\\n            if curr_node.children[char].nil?\\n                return false\\n            elsif curr_node.children[char].eow\\n                return true\\n            else\\n                curr_node = curr_node.children[@letters[i]]\\n            end\\n        end\\n    \\n        false \\n    end\\n    \\nend\\n\\n# Your StreamChecker object will be instantiated and called as such:\\n# obj = StreamChecker.new(words)\\n# param_1 = obj.query(letter)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 808619,
                "title": "java-trie-solution-insert-each-word-in-reverse-order",
                "content": "```\\nclass StreamChecker {\\n    class TreeNode {\\n        public boolean end = false;\\n        public TreeNode[] letters;\\n        public TreeNode () {\\n            this.letters = new TreeNode[26];\\n        }\\n    }\\n    \\n    private TreeNode root;    \\n    private StringBuilder sb;\\n    \\n    public StreamChecker(String[] words) {\\n        root = new TreeNode();\\n        sb = new StringBuilder();\\n        \\n        for (var word : words) {\\n            insert(word);\\n        }\\n    }\\n    \\n    public void insert(String word) {\\n        TreeNode currNode = root;\\n        word = new StringBuilder(word).reverse().toString(); //insert from the back\\n        \\n        for (char c : word.toCharArray()) {\\n            if (currNode.letters[c - \\'a\\'] == null) {\\n                currNode.letters[c - \\'a\\'] = new TreeNode();\\n            }\\n            currNode = currNode.letters[c - \\'a\\'];\\n        }\\n        currNode.end = true;\\n    }\\n    \\n    public boolean query(char letter) {\\n        sb.append(letter);\\n        TreeNode currNode = root;\\n        \\n        for (int i = sb.length()-1; i >= 0; i--) {\\n            if (currNode == null)\\n                break;\\n            \\n            char c = sb.charAt(i);\\n            currNode = currNode.letters[c - \\'a\\'];\\n            \\n            if (currNode != null && currNode.end)\\n                return true;\\n        }   \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass StreamChecker {\\n    class TreeNode {\\n        public boolean end = false;\\n        public TreeNode[] letters;\\n        public TreeNode () {\\n            this.letters = new TreeNode[26];\\n        }\\n    }\\n    \\n    private TreeNode root;    \\n    private StringBuilder sb;\\n    \\n    public StreamChecker(String[] words) {\\n        root = new TreeNode();\\n        sb = new StringBuilder();\\n        \\n        for (var word : words) {\\n            insert(word);\\n        }\\n    }\\n    \\n    public void insert(String word) {\\n        TreeNode currNode = root;\\n        word = new StringBuilder(word).reverse().toString(); //insert from the back\\n        \\n        for (char c : word.toCharArray()) {\\n            if (currNode.letters[c - \\'a\\'] == null) {\\n                currNode.letters[c - \\'a\\'] = new TreeNode();\\n            }\\n            currNode = currNode.letters[c - \\'a\\'];\\n        }\\n        currNode.end = true;\\n    }\\n    \\n    public boolean query(char letter) {\\n        sb.append(letter);\\n        TreeNode currNode = root;\\n        \\n        for (int i = sb.length()-1; i >= 0; i--) {\\n            if (currNode == null)\\n                break;\\n            \\n            char c = sb.charAt(i);\\n            currNode = currNode.letters[c - \\'a\\'];\\n            \\n            if (currNode != null && currNode.end)\\n                return true;\\n        }   \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 807833,
                "title": "simple-solution-using-trie-and-a-letters-buffer",
                "content": "```\\npublic class StreamChecker\\n{\\n    private TrieNode trie = new TrieNode();\\n    private LinkedList<char> charBuffer = new LinkedList<char>();\\n    \\n    public StreamChecker(string[] words)\\n    {\\n        foreach(string w in words)\\n        {\\n            TrieNode current = trie;\\n            for(int i = w.Length - 1; i >= 0; i--)\\n            {\\n                char c = w[i];\\n                if(current.children[c-\\'a\\'] is null) current.children[c-\\'a\\'] = new TrieNode();\\n                current = current.children[c-\\'a\\'];       \\n            }\\n            current.isWord = true;\\n        }\\n    }\\n    \\n    public bool Query(char letter)\\n    {\\n        charBuffer.AddLast(letter);\\n        if(charBuffer.Count > 2000) charBuffer.RemoveFirst(); // more than max word length\\n        LinkedListNode<char> llNode = charBuffer.Last;\\n        TrieNode trieNode = trie;\\n        while(llNode != null)\\n        {\\n            trieNode = trieNode.children[llNode.Value-\\'a\\'];\\n            if(trieNode is null) return false;\\n            if(trieNode.isWord) return true;\\n            llNode = llNode.Previous;\\n        }\\n        return false;\\n    }\\n    \\n    private class TrieNode\\n    {\\n        public bool isWord;\\n        public TrieNode[] children = new TrieNode[26];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Linked List",
                    "Trie"
                ],
                "code": "```\\npublic class StreamChecker\\n{\\n    private TrieNode trie = new TrieNode();\\n    private LinkedList<char> charBuffer = new LinkedList<char>();\\n    \\n    public StreamChecker(string[] words)\\n    {\\n        foreach(string w in words)\\n        {\\n            TrieNode current = trie;\\n            for(int i = w.Length - 1; i >= 0; i--)\\n            {\\n                char c = w[i];\\n                if(current.children[c-\\'a\\'] is null) current.children[c-\\'a\\'] = new TrieNode();\\n                current = current.children[c-\\'a\\'];       \\n            }\\n            current.isWord = true;\\n        }\\n    }\\n    \\n    public bool Query(char letter)\\n    {\\n        charBuffer.AddLast(letter);\\n        if(charBuffer.Count > 2000) charBuffer.RemoveFirst(); // more than max word length\\n        LinkedListNode<char> llNode = charBuffer.Last;\\n        TrieNode trieNode = trie;\\n        while(llNode != null)\\n        {\\n            trieNode = trieNode.children[llNode.Value-\\'a\\'];\\n            if(trieNode is null) return false;\\n            if(trieNode.isWord) return true;\\n            llNode = llNode.Previous;\\n        }\\n        return false;\\n    }\\n    \\n    private class TrieNode\\n    {\\n        public bool isWord;\\n        public TrieNode[] children = new TrieNode[26];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 807601,
                "title": "go-trie-queue-solution",
                "content": "Time: O(WQ) where W is the max size of word, Q is the query time.\\n\\n```go\\ntype StreamChecker struct {\\n    tire *Tire\\n    maxSize int\\n    q []byte\\n}\\n\\ntype Tire struct {\\n    next map[byte]*Tire\\n    isWord bool\\n}\\n\\nfunc Constructor(words []string) StreamChecker {\\n    maxSize := 0\\n    tire := &Tire{make(map[byte]*Tire), false}\\n    for i := 0; i < len(words); i++ {\\n        word := words[i]\\n        insert_word(word, tire)\\n        if len(word) > maxSize {\\n            maxSize = len(word)\\n        }\\n    }\\n    return StreamChecker{tire, maxSize, make([]byte, 0)}\\n}\\n\\nfunc insert_word(word string, tire *Tire) {\\n    // insert the word reversely into tire\\n    curr := tire\\n    for i := len(word)-1; i >= 0; i-- {\\n        w := word[i]\\n        if _, ok := curr.next[w]; !ok {\\n            curr.next[w] = &Tire{make(map[byte]*Tire), false}\\n        } \\n        curr = curr.next[w]\\n    }\\n    curr.isWord = true\\n}\\n\\nfunc (this *StreamChecker) search() bool {\\n    // check the char stream in the queue\\n    curr := this.tire\\n    for i:= 0; i<len(this.q);i++ {\\n        w := this.q[i]\\n        if _, ok := curr.next[w]; !ok {\\n            break\\n        }\\n        curr = curr.next[w]\\n        if curr.isWord == true {\\n            return true\\n        }\\n    }\\n    return false\\n}\\n\\nfunc (this *StreamChecker) Query(letter byte) bool {\\n    // append letter in the front of the queue\\n    this.q = append([]byte{letter}, this.q...)\\n    // if size larger than max size, pop from right\\n    if len(this.q) > this.maxSize {\\n        this.q = this.q[:len(this.q)-1]\\n    }\\n    return this.search()\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Trie",
                    "Queue"
                ],
                "code": "```go\\ntype StreamChecker struct {\\n    tire *Tire\\n    maxSize int\\n    q []byte\\n}\\n\\ntype Tire struct {\\n    next map[byte]*Tire\\n    isWord bool\\n}\\n\\nfunc Constructor(words []string) StreamChecker {\\n    maxSize := 0\\n    tire := &Tire{make(map[byte]*Tire), false}\\n    for i := 0; i < len(words); i++ {\\n        word := words[i]\\n        insert_word(word, tire)\\n        if len(word) > maxSize {\\n            maxSize = len(word)\\n        }\\n    }\\n    return StreamChecker{tire, maxSize, make([]byte, 0)}\\n}\\n\\nfunc insert_word(word string, tire *Tire) {\\n    // insert the word reversely into tire\\n    curr := tire\\n    for i := len(word)-1; i >= 0; i-- {\\n        w := word[i]\\n        if _, ok := curr.next[w]; !ok {\\n            curr.next[w] = &Tire{make(map[byte]*Tire), false}\\n        } \\n        curr = curr.next[w]\\n    }\\n    curr.isWord = true\\n}\\n\\nfunc (this *StreamChecker) search() bool {\\n    // check the char stream in the queue\\n    curr := this.tire\\n    for i:= 0; i<len(this.q);i++ {\\n        w := this.q[i]\\n        if _, ok := curr.next[w]; !ok {\\n            break\\n        }\\n        curr = curr.next[w]\\n        if curr.isWord == true {\\n            return true\\n        }\\n    }\\n    return false\\n}\\n\\nfunc (this *StreamChecker) Query(letter byte) bool {\\n    // append letter in the front of the queue\\n    this.q = append([]byte{letter}, this.q...)\\n    // if size larger than max size, pop from right\\n    if len(this.q) > this.maxSize {\\n        this.q = this.q[:len(this.q)-1]\\n    }\\n    return this.search()\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 807383,
                "title": "rust-92ms-100-38m",
                "content": "Runtime: 92 ms, faster than 100.00% of Rust online submissions for Stream of Characters.\\nMemory Usage: 38 MB, less than 25.00% of Rust online submissions for Stream of Characters.\\n```rust\\nuse std::collections::HashMap;\\n\\n#[derive(Debug, Clone)]\\nstruct Trie {\\n    is_word: bool,\\n    next: Vec<Option<Trie>>,\\n}\\n\\nimpl Trie {\\n    fn new() -> Self {\\n        Trie {\\n            is_word: false,\\n            next: vec![None; 26],\\n        }\\n    }\\n}\\n\\nstruct StreamChecker {\\n    root: Trie,\\n    s: String,\\n    max: usize,\\n}\\n\\nimpl StreamChecker {\\n    fn new(words: Vec<String>) -> Self {\\n        let mut root = Trie::new();\\n        let mut max = 0;\\n        for w in words {\\n            if w.len() > max {\\n                max = w.len()\\n            }\\n            let v = w.chars().rev().collect::<String>();\\n            let mut node = &mut root;\\n            for ch in v.chars() {\\n                if node.next[(ch as u8 - b\\'a\\') as usize].is_none() {\\n                    node.next[(ch as u8 - b\\'a\\') as usize] = Some(Trie::new())\\n                }\\n                node = node.next[(ch as u8 - b\\'a\\') as usize].as_mut().unwrap();\\n            }\\n            node.is_word = true;\\n        }\\n        let s = String::new();\\n        StreamChecker { root, s, max }\\n    }\\n\\n    fn query(&mut self, letter: char) -> bool {\\n        self.s.push(letter);\\n        let mut node = &mut self.root;\\n        let mut start = 0;\\n        if self.s.len() > self.max {\\n            start = self.s.len() - self.max;\\n        };\\n        for i in (start..self.s.len()).rev() {\\n            let ch = self.s.as_bytes()[i] as char;\\n            if let Some(n) = &mut node.next[(ch as u8 - b\\'a\\') as usize] {\\n                if n.is_word {\\n                    return true;\\n                }\\n                node = n\\n            } else {\\n                return false;\\n            }\\n        }\\n        false\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_stream_checker() {\\n        let mut sc = StreamChecker::new(vec![\"cd\".to_string(), \"f\".to_string(), \"kl\".to_string()]);\\n        assert!(!sc.query(\\'a\\')); // return false\\n        assert!(!sc.query(\\'b\\')); // return false\\n        assert!(!sc.query(\\'c\\')); // return false\\n        assert!(sc.query(\\'d\\')); // return true, because \\'cd\\' is in the wordlist\\n        assert!(!sc.query(\\'e\\')); // return false\\n        assert!(sc.query(\\'f\\')); // return true, because \\'f\\' is in the wordlist\\n        assert!(!sc.query(\\'g\\')); // return false\\n        assert!(!sc.query(\\'h\\')); // return false\\n        assert!(!sc.query(\\'i\\')); // return false\\n        assert!(!sc.query(\\'j\\')); // return false\\n        assert!(!sc.query(\\'k\\')); // return false\\n        assert!(sc.query(\\'l\\')); // return true, because \\'kl\\' is in the wordlist\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nuse std::collections::HashMap;\\n\\n#[derive(Debug, Clone)]\\nstruct Trie {\\n    is_word: bool,\\n    next: Vec<Option<Trie>>,\\n}\\n\\nimpl Trie {\\n    fn new() -> Self {\\n        Trie {\\n            is_word: false,\\n            next: vec![None; 26],\\n        }\\n    }\\n}\\n\\nstruct StreamChecker {\\n    root: Trie,\\n    s: String,\\n    max: usize,\\n}\\n\\nimpl StreamChecker {\\n    fn new(words: Vec<String>) -> Self {\\n        let mut root = Trie::new();\\n        let mut max = 0;\\n        for w in words {\\n            if w.len() > max {\\n                max = w.len()\\n            }\\n            let v = w.chars().rev().collect::<String>();\\n            let mut node = &mut root;\\n            for ch in v.chars() {\\n                if node.next[(ch as u8 - b\\'a\\') as usize].is_none() {\\n                    node.next[(ch as u8 - b\\'a\\') as usize] = Some(Trie::new())\\n                }\\n                node = node.next[(ch as u8 - b\\'a\\') as usize].as_mut().unwrap();\\n            }\\n            node.is_word = true;\\n        }\\n        let s = String::new();\\n        StreamChecker { root, s, max }\\n    }\\n\\n    fn query(&mut self, letter: char) -> bool {\\n        self.s.push(letter);\\n        let mut node = &mut self.root;\\n        let mut start = 0;\\n        if self.s.len() > self.max {\\n            start = self.s.len() - self.max;\\n        };\\n        for i in (start..self.s.len()).rev() {\\n            let ch = self.s.as_bytes()[i] as char;\\n            if let Some(n) = &mut node.next[(ch as u8 - b\\'a\\') as usize] {\\n                if n.is_word {\\n                    return true;\\n                }\\n                node = n\\n            } else {\\n                return false;\\n            }\\n        }\\n        false\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_stream_checker() {\\n        let mut sc = StreamChecker::new(vec![\"cd\".to_string(), \"f\".to_string(), \"kl\".to_string()]);\\n        assert!(!sc.query(\\'a\\')); // return false\\n        assert!(!sc.query(\\'b\\')); // return false\\n        assert!(!sc.query(\\'c\\')); // return false\\n        assert!(sc.query(\\'d\\')); // return true, because \\'cd\\' is in the wordlist\\n        assert!(!sc.query(\\'e\\')); // return false\\n        assert!(sc.query(\\'f\\')); // return true, because \\'f\\' is in the wordlist\\n        assert!(!sc.query(\\'g\\')); // return false\\n        assert!(!sc.query(\\'h\\')); // return false\\n        assert!(!sc.query(\\'i\\')); // return false\\n        assert!(!sc.query(\\'j\\')); // return false\\n        assert!(!sc.query(\\'k\\')); // return false\\n        assert!(sc.query(\\'l\\')); // return true, because \\'kl\\' is in the wordlist\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 761591,
                "title": "java-ac-automation",
                "content": "```\\nclass StreamChecker {\\n    Node root;\\n    Node cur=root;\\n    public StreamChecker(String[] words) {\\n        root=new Node();\\n        for(String w:words){\\n            insert(root,w);\\n        }\\n        cur=root;\\n        //build AC\\n        Queue<Node>q=new LinkedList<>();\\n        q.add(root);\\n        while(q.size()!=0){\\n            Node p=q.poll();\\n            for(int i=0;i<26;i++){\\n                if(p.childs[i]!=null){\\n                    Node next=p.childs[i];\\n                    if(p==root){\\n                        next.fail=root;\\n                    }else{\\n                        Node temp=p.fail;\\n                        while(temp!=null){\\n                            if(temp.childs[i]!=null){\\n                                next.fail=temp.childs[i];\\n                                break;\\n                            }\\n                            temp=temp.fail;\\n                        }\\n                        if(temp==null)next.fail=root;\\n                    }\\n                    q.add(next);\\n                }\\n            }\\n        }\\n    }\\n    \\n    public boolean query(char letter) {\\n        int index=letter-\\'a\\';\\n        boolean res=false;\\n        \\n        while(cur.childs[index]==null&&cur!=root)cur=cur.fail;\\n        \\n        cur=cur.childs[index];\\n        if(cur==null)cur=root;\\n       \\n        Node temp=cur;\\n        while(temp!=root){\\n            if(temp.is==true)res=true;\\n            temp=temp.fail;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public void insert(Node r,String w){\\n        for(int i=0;i<w.length();i++){\\n            int index=w.charAt(i)-\\'a\\';\\n            if(r.childs[index]==null)r.childs[index]=new Node();\\n            r=r.childs[index];\\n        }\\n        r.is=true;\\n        r.len=w.length();\\n    }\\n    \\n    class Node{\\n        Node childs[];\\n        Node fail=null;\\n        boolean is=false;\\n        int len=0;\\n        public Node(){\\n            childs=new Node[26];\\n        }\\n    }\\n}\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker obj = new StreamChecker(words);\\n * boolean param_1 = obj.query(letter);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker {\\n    Node root;\\n    Node cur=root;\\n    public StreamChecker(String[] words) {\\n        root=new Node();\\n        for(String w:words){\\n            insert(root,w);\\n        }\\n        cur=root;\\n        //build AC\\n        Queue<Node>q=new LinkedList<>();\\n        q.add(root);\\n        while(q.size()!=0){\\n            Node p=q.poll();\\n            for(int i=0;i<26;i++){\\n                if(p.childs[i]!=null){\\n                    Node next=p.childs[i];\\n                    if(p==root){\\n                        next.fail=root;\\n                    }else{\\n                        Node temp=p.fail;\\n                        while(temp!=null){\\n                            if(temp.childs[i]!=null){\\n                                next.fail=temp.childs[i];\\n                                break;\\n                            }\\n                            temp=temp.fail;\\n                        }\\n                        if(temp==null)next.fail=root;\\n                    }\\n                    q.add(next);\\n                }\\n            }\\n        }\\n    }\\n    \\n    public boolean query(char letter) {\\n        int index=letter-\\'a\\';\\n        boolean res=false;\\n        \\n        while(cur.childs[index]==null&&cur!=root)cur=cur.fail;\\n        \\n        cur=cur.childs[index];\\n        if(cur==null)cur=root;\\n       \\n        Node temp=cur;\\n        while(temp!=root){\\n            if(temp.is==true)res=true;\\n            temp=temp.fail;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public void insert(Node r,String w){\\n        for(int i=0;i<w.length();i++){\\n            int index=w.charAt(i)-\\'a\\';\\n            if(r.childs[index]==null)r.childs[index]=new Node();\\n            r=r.childs[index];\\n        }\\n        r.is=true;\\n        r.len=w.length();\\n    }\\n    \\n    class Node{\\n        Node childs[];\\n        Node fail=null;\\n        boolean is=false;\\n        int len=0;\\n        public Node(){\\n            childs=new Node[26];\\n        }\\n    }\\n}\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker obj = new StreamChecker(words);\\n * boolean param_1 = obj.query(letter);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 659678,
                "title": "java-reverse-trie-296-ms",
                "content": "```\\nclass TrieNode {\\n    HashMap<Character, TrieNode> children;\\n    boolean isWord;\\n    \\n    public TrieNode() {\\n        this.children = new HashMap<>();\\n    }\\n}\\n\\nclass Trie {\\n    TrieNode head;\\n    \\n    public Trie() {\\n        this.head = new TrieNode();\\n    }\\n    \\n    public void add(String s) {\\n        TrieNode node = head;\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            char c = s.charAt(i);\\n            if (node.children.containsKey(c)) {\\n                node = node.children.get(c);\\n            } else {\\n                TrieNode newnode = new TrieNode();\\n                node.children.put(c, newnode);\\n                node = newnode;\\n            }\\n        }\\n        node.isWord = true;        \\n    }\\n    \\n    public boolean check(String s) {\\n        TrieNode node = head;\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            char c = s.charAt(i);\\n            if (node.children.containsKey(c)) {\\n                node = node.children.get(c);\\n                if (node.isWord) return true;\\n            } else return false;\\n        }\\n        return false;\\n    }\\n}\\n\\nclass StreamChecker {\\n    Trie trie;\\n    StringBuilder sb;\\n    \\n    public StreamChecker(String[] words) {\\n        trie = new Trie();\\n        sb = new StringBuilder();\\n        for (String s : words) trie.add(s);\\n    }\\n    \\n    public boolean query(char letter) {\\n        sb.append(letter);\\n        return trie.check(sb.toString());\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode {\\n    HashMap<Character, TrieNode> children;\\n    boolean isWord;\\n    \\n    public TrieNode() {\\n        this.children = new HashMap<>();\\n    }\\n}\\n\\nclass Trie {\\n    TrieNode head;\\n    \\n    public Trie() {\\n        this.head = new TrieNode();\\n    }\\n    \\n    public void add(String s) {\\n        TrieNode node = head;\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            char c = s.charAt(i);\\n            if (node.children.containsKey(c)) {\\n                node = node.children.get(c);\\n            } else {\\n                TrieNode newnode = new TrieNode();\\n                node.children.put(c, newnode);\\n                node = newnode;\\n            }\\n        }\\n        node.isWord = true;        \\n    }\\n    \\n    public boolean check(String s) {\\n        TrieNode node = head;\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            char c = s.charAt(i);\\n            if (node.children.containsKey(c)) {\\n                node = node.children.get(c);\\n                if (node.isWord) return true;\\n            } else return false;\\n        }\\n        return false;\\n    }\\n}\\n\\nclass StreamChecker {\\n    Trie trie;\\n    StringBuilder sb;\\n    \\n    public StreamChecker(String[] words) {\\n        trie = new Trie();\\n        sb = new StringBuilder();\\n        for (String s : words) trie.add(s);\\n    }\\n    \\n    public boolean query(char letter) {\\n        sb.append(letter);\\n        return trie.check(sb.toString());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 589464,
                "title": "py3-deque-and-trie",
                "content": "Basic trie construction and deque to find recent queries.\\nqueue size = max(words)\\n```\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.trie = {}\\n        self.q = deque()\\n        self.maxqsize = 0\\n        for word in words: \\n            self.maxqsize = max(self.maxqsize, len(word))\\n            self.construct(word[::-1])\\n            \\n    def construct(self, word):\\n        trie = self.trie\\n        for ch in word:\\n            if ch not in trie:\\n                trie[ch] = {}\\n            trie = trie[ch]\\n        trie[\\'#\\'] = None\\n    \\n    def findifexist(self, word):\\n        trie = self.trie\\n        for ch in word:\\n            if \\'#\\' in trie: return True\\n            if ch not in trie: break;\\n            trie = trie[ch] \\n        return \\'#\\' in trie\\n\\n    def query(self, letter: str) -> bool:\\n        self.q.append(letter)\\n        if len(self.q) > self.maxqsize: self.q.popleft();\\n        if letter in self.trie:\\n            tocheck = list(self.q)\\n            tocheck.reverse()\\n            return self.findifexist(tocheck)\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.trie = {}\\n        self.q = deque()\\n        self.maxqsize = 0\\n        for word in words: \\n            self.maxqsize = max(self.maxqsize, len(word))\\n            self.construct(word[::-1])\\n            \\n    def construct(self, word):\\n        trie = self.trie\\n        for ch in word:\\n            if ch not in trie:\\n                trie[ch] = {}\\n            trie = trie[ch]\\n        trie[\\'#\\'] = None\\n    \\n    def findifexist(self, word):\\n        trie = self.trie\\n        for ch in word:\\n            if \\'#\\' in trie: return True\\n            if ch not in trie: break;\\n            trie = trie[ch] \\n        return \\'#\\' in trie\\n\\n    def query(self, letter: str) -> bool:\\n        self.q.append(letter)\\n        if len(self.q) > self.maxqsize: self.q.popleft();\\n        if letter in self.trie:\\n            tocheck = list(self.q)\\n            tocheck.reverse()\\n            return self.findifexist(tocheck)\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 417976,
                "title": "c-aho-corasick-automaton",
                "content": "```cpp\\nclass StreamChecker {\\n    struct TrieNode {\\n        bool isEnd;\\n        TrieNode* children[26];\\n        TrieNode* suffixLink;\\n        TrieNode* outputLink;\\n        TrieNode() {\\n            isEnd = false;\\n            memset(children, 0, sizeof(TrieNode*)*26);\\n            suffixLink = outputLink = NULL;\\n        }\\n    };\\n    \\n\\tTrieNode * root;\\n\\tTrieNode * state;\\n    \\n    void buildTrie(vector<string> & words) {\\n        for (auto & w: words) {\\n            TrieNode * node = root;\\n            for (auto c: w) {\\n                if (!node->children[c-\\'a\\'])\\n                    node->children[c-\\'a\\'] = new TrieNode();\\n                node = node->children[c-\\'a\\'];\\n            }\\n            node->isEnd = true;\\n        }\\n    }\\n    \\n    void buildSuffixLink() {\\n        queue<TrieNode*> bfsQ;\\n        root->suffixLink = root;\\n        bfsQ.push(root);\\n        while (!bfsQ.empty()) {\\n            TrieNode * curr = bfsQ.front(); bfsQ.pop();\\n            for (int i = 0; i < 26; i++) {\\n                if (curr->children[i]) {\\n                    TrieNode * suf = curr->suffixLink;\\n                    while (suf != root && !suf->children[i])\\n                        suf = suf->suffixLink;\\n                    if (suf->children[i] && suf != curr)\\n                        curr->children[i]->suffixLink = suf->children[i];\\n                    else\\n                        curr->children[i]->suffixLink = root;\\n                    bfsQ.push(curr->children[i]);\\n                }\\n            }\\n        }\\n    }\\n    \\n    void buildOutputLink() {\\n        queue<TrieNode*> bfsQ;\\n        root->suffixLink = root;\\n        bfsQ.push(root);\\n        while (!bfsQ.empty()) {\\n            TrieNode * curr = bfsQ.front(); bfsQ.pop();\\n            TrieNode * suf = curr->suffixLink;\\n            while (suf != root && !suf->isEnd)\\n                suf = suf->suffixLink;\\n            if (suf->isEnd && suf != curr)\\n                curr->outputLink = suf;\\n            for (int i = 0; i < 26; i++) {\\n                if (curr->children[i])\\n                    bfsQ.push(curr->children[i]);\\n            }\\n        }\\n    }\\n\\npublic:\\n    StreamChecker(vector<string>& words) {\\n        root = new TrieNode();\\n        buildTrie(words);\\n        buildSuffixLink();\\n        buildOutputLink();\\n        state = root;\\n    }\\n    \\n    bool query(char letter) {\\n        while (state != root && !state->children[letter-\\'a\\'])\\n            state = state->suffixLink;\\n        if (state->children[letter-\\'a\\'])\\n            state = state->children[letter-\\'a\\'];\\n        return state->isEnd || state->outputLink;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass StreamChecker {\\n    struct TrieNode {\\n        bool isEnd;\\n        TrieNode* children[26];\\n        TrieNode* suffixLink;\\n        TrieNode* outputLink;\\n        TrieNode() {\\n            isEnd = false;\\n            memset(children, 0, sizeof(TrieNode*)*26);\\n            suffixLink = outputLink = NULL;\\n        }\\n    };\\n    \\n\\tTrieNode * root;\\n\\tTrieNode * state;\\n    \\n    void buildTrie(vector<string> & words) {\\n        for (auto & w: words) {\\n            TrieNode * node = root;\\n            for (auto c: w) {\\n                if (!node->children[c-\\'a\\'])\\n                    node->children[c-\\'a\\'] = new TrieNode();\\n                node = node->children[c-\\'a\\'];\\n            }\\n            node->isEnd = true;\\n        }\\n    }\\n    \\n    void buildSuffixLink() {\\n        queue<TrieNode*> bfsQ;\\n        root->suffixLink = root;\\n        bfsQ.push(root);\\n        while (!bfsQ.empty()) {\\n            TrieNode * curr = bfsQ.front(); bfsQ.pop();\\n            for (int i = 0; i < 26; i++) {\\n                if (curr->children[i]) {\\n                    TrieNode * suf = curr->suffixLink;\\n                    while (suf != root && !suf->children[i])\\n                        suf = suf->suffixLink;\\n                    if (suf->children[i] && suf != curr)\\n                        curr->children[i]->suffixLink = suf->children[i];\\n                    else\\n                        curr->children[i]->suffixLink = root;\\n                    bfsQ.push(curr->children[i]);\\n                }\\n            }\\n        }\\n    }\\n    \\n    void buildOutputLink() {\\n        queue<TrieNode*> bfsQ;\\n        root->suffixLink = root;\\n        bfsQ.push(root);\\n        while (!bfsQ.empty()) {\\n            TrieNode * curr = bfsQ.front(); bfsQ.pop();\\n            TrieNode * suf = curr->suffixLink;\\n            while (suf != root && !suf->isEnd)\\n                suf = suf->suffixLink;\\n            if (suf->isEnd && suf != curr)\\n                curr->outputLink = suf;\\n            for (int i = 0; i < 26; i++) {\\n                if (curr->children[i])\\n                    bfsQ.push(curr->children[i]);\\n            }\\n        }\\n    }\\n\\npublic:\\n    StreamChecker(vector<string>& words) {\\n        root = new TrieNode();\\n        buildTrie(words);\\n        buildSuffixLink();\\n        buildOutputLink();\\n        state = root;\\n    }\\n    \\n    bool query(char letter) {\\n        while (state != root && !state->children[letter-\\'a\\'])\\n            state = state->suffixLink;\\n        if (state->children[letter-\\'a\\'])\\n            state = state->children[letter-\\'a\\'];\\n        return state->isEnd || state->outputLink;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 364037,
                "title": "c-lang-trie-solution-beat-100",
                "content": "```\\n#define MAX_SIZE 2000\\n\\ntypedef struct Node {\\n    struct Node *children[26];\\n    bool isWord;\\n} Node;\\n\\ntypedef struct {\\n    Node *root;\\n    char *str;\\n    int count;\\n} StreamChecker;\\n\\nNode *createNode() {\\n    Node *node = malloc(sizeof(Node));\\n    node->isWord = false;\\n    for (int i = 0; i < 26; i++) {\\n        node->children[i] = NULL;\\n    }\\n    return node;\\n}\\n\\nvoid addWord(Node *root, char *word) {\\n    Node *node = root;\\n    for (char *ptr = word; *ptr != \\'\\\\0\\'; ptr++) {\\n        char c = *ptr;\\n        if (!node->children[c - \\'a\\']) {\\n            node->children[c - \\'a\\'] = createNode();\\n        }\\n        node = node->children[c - \\'a\\'];\\n    }\\n    node->isWord = true;\\n}\\n\\nbool findWord(Node *root, const char *word, int start) {\\n    Node *node = root;\\n    while (start >= 0) {\\n        char c = word[start];\\n        if (!node->children[c - \\'a\\']) {\\n            return false;\\n        }\\n        node = node->children[c - \\'a\\'];\\n        if (node->isWord) {\\n            return true;\\n        }\\n        start--;\\n    }\\n    return false;\\n}\\n\\nvoid reverse(char *word) {\\n    int left = 0, right = strlen(word) - 1;\\n    while (left < right) {\\n        char tmp = word[left];\\n        word[left] = word[right];\\n        word[right] = tmp;\\n        left++;\\n        right--;\\n    }\\n}\\n\\nchar *createString() {\\n    char *str = malloc(sizeof(char) * (MAX_SIZE + 2));\\n    memset(str, 0, MAX_SIZE + 2);\\n    return str;\\n}\\n\\nStreamChecker *streamCheckerCreate(char **words, int wordsSize) {\\n    StreamChecker *checker = malloc(sizeof(StreamChecker));\\n    checker->root = createNode();\\n    checker->str = createString();\\n    checker->count = 0;\\n    for (int i = 0; i < wordsSize; i++) {\\n        reverse(words[i]);\\n        addWord(checker->root, words[i]);\\n    }\\n    return checker;\\n\\n}\\n\\nbool streamCheckerQuery(StreamChecker *obj, char letter) {\\n    if (obj->count >= MAX_SIZE) {\\n        free(obj->str);\\n        obj->count = 0;\\n        obj->str = createString();\\n    }\\n    obj->str[obj->count++] = letter;\\n    int count = obj->count;\\n    return findWord(obj->root, obj->str, count - 1);\\n}\\n\\nvoid freeTrie(Node *root) {\\n    if (root == NULL) {\\n        return;\\n    }\\n    for (int i = 0; i < 26; i++) {\\n        if (root->children[i]) {\\n            freeTrie(root->children[i]);\\n        }\\n    }\\n    free(root);\\n}\\n\\nvoid streamCheckerFree(StreamChecker *obj) {\\n    freeTrie(obj->root);\\n    free(obj->str);\\n    free(obj);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n#define MAX_SIZE 2000\\n\\ntypedef struct Node {\\n    struct Node *children[26];\\n    bool isWord;\\n} Node;\\n\\ntypedef struct {\\n    Node *root;\\n    char *str;\\n    int count;\\n} StreamChecker;\\n\\nNode *createNode() {\\n    Node *node = malloc(sizeof(Node));\\n    node->isWord = false;\\n    for (int i = 0; i < 26; i++) {\\n        node->children[i] = NULL;\\n    }\\n    return node;\\n}\\n\\nvoid addWord(Node *root, char *word) {\\n    Node *node = root;\\n    for (char *ptr = word; *ptr != \\'\\\\0\\'; ptr++) {\\n        char c = *ptr;\\n        if (!node->children[c - \\'a\\']) {\\n            node->children[c - \\'a\\'] = createNode();\\n        }\\n        node = node->children[c - \\'a\\'];\\n    }\\n    node->isWord = true;\\n}\\n\\nbool findWord(Node *root, const char *word, int start) {\\n    Node *node = root;\\n    while (start >= 0) {\\n        char c = word[start];\\n        if (!node->children[c - \\'a\\']) {\\n            return false;\\n        }\\n        node = node->children[c - \\'a\\'];\\n        if (node->isWord) {\\n            return true;\\n        }\\n        start--;\\n    }\\n    return false;\\n}\\n\\nvoid reverse(char *word) {\\n    int left = 0, right = strlen(word) - 1;\\n    while (left < right) {\\n        char tmp = word[left];\\n        word[left] = word[right];\\n        word[right] = tmp;\\n        left++;\\n        right--;\\n    }\\n}\\n\\nchar *createString() {\\n    char *str = malloc(sizeof(char) * (MAX_SIZE + 2));\\n    memset(str, 0, MAX_SIZE + 2);\\n    return str;\\n}\\n\\nStreamChecker *streamCheckerCreate(char **words, int wordsSize) {\\n    StreamChecker *checker = malloc(sizeof(StreamChecker));\\n    checker->root = createNode();\\n    checker->str = createString();\\n    checker->count = 0;\\n    for (int i = 0; i < wordsSize; i++) {\\n        reverse(words[i]);\\n        addWord(checker->root, words[i]);\\n    }\\n    return checker;\\n\\n}\\n\\nbool streamCheckerQuery(StreamChecker *obj, char letter) {\\n    if (obj->count >= MAX_SIZE) {\\n        free(obj->str);\\n        obj->count = 0;\\n        obj->str = createString();\\n    }\\n    obj->str[obj->count++] = letter;\\n    int count = obj->count;\\n    return findWord(obj->root, obj->str, count - 1);\\n}\\n\\nvoid freeTrie(Node *root) {\\n    if (root == NULL) {\\n        return;\\n    }\\n    for (int i = 0; i < 26; i++) {\\n        if (root->children[i]) {\\n            freeTrie(root->children[i]);\\n        }\\n    }\\n    free(root);\\n}\\n\\nvoid streamCheckerFree(StreamChecker *obj) {\\n    freeTrie(obj->root);\\n    free(obj->str);\\n    free(obj);\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 363039,
                "title": "java-trie-bfs-782-ms-faster-than-10-42-91-4-mb-less-than-60-00",
                "content": "```\\nclass StreamChecker {\\n    TrieNode root;\\n    Queue<TrieNode> q;\\n    \\n    public StreamChecker(String[] words) {\\n        root = new TrieNode();\\n        q = new LinkedList<>();\\n        for (String w : words) {\\n            build(root, w.toCharArray());\\n        }\\n    }\\n    \\n    public boolean query(char letter) {\\n        q.offer(root);\\n        int size = q.size();\\n        boolean res = false;\\n        int idx = letter - \\'a\\';\\n        for (int i = 0; i < size; ++i) {\\n            TrieNode p = q.poll();\\n            if (p.kids[idx] == null) {\\n                continue;\\n            }\\n            p = p.kids[idx];\\n            if (p.isWord) {\\n                res = true;\\n            }\\n            q.offer(p);\\n        }\\n        return res;\\n    }\\n    \\n    private void build(TrieNode root, char[] w) {\\n        for (int i = 0; i < w.length; ++i) {\\n            int idx = w[i] - \\'a\\';\\n            if (root.kids[idx] == null) {\\n                root.kids[idx] = new TrieNode();\\n            }\\n            root = root.kids[idx];\\n        }\\n        root.isWord = true;\\n    }\\n}\\n\\nclass TrieNode {\\n    TrieNode[] kids;\\n    boolean isWord;\\n    \\n    TrieNode() {\\n        kids = new TrieNode[26];\\n        isWord = false;\\n    }\\n}\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker obj = new StreamChecker(words);\\n * boolean param_1 = obj.query(letter);\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker {\\n    TrieNode root;\\n    Queue<TrieNode> q;\\n    \\n    public StreamChecker(String[] words) {\\n        root = new TrieNode();\\n        q = new LinkedList<>();\\n        for (String w : words) {\\n            build(root, w.toCharArray());\\n        }\\n    }\\n    \\n    public boolean query(char letter) {\\n        q.offer(root);\\n        int size = q.size();\\n        boolean res = false;\\n        int idx = letter - \\'a\\';\\n        for (int i = 0; i < size; ++i) {\\n            TrieNode p = q.poll();\\n            if (p.kids[idx] == null) {\\n                continue;\\n            }\\n            p = p.kids[idx];\\n            if (p.isWord) {\\n                res = true;\\n            }\\n            q.offer(p);\\n        }\\n        return res;\\n    }\\n    \\n    private void build(TrieNode root, char[] w) {\\n        for (int i = 0; i < w.length; ++i) {\\n            int idx = w[i] - \\'a\\';\\n            if (root.kids[idx] == null) {\\n                root.kids[idx] = new TrieNode();\\n            }\\n            root = root.kids[idx];\\n        }\\n        root.isWord = true;\\n    }\\n}\\n\\nclass TrieNode {\\n    TrieNode[] kids;\\n    boolean isWord;\\n    \\n    TrieNode() {\\n        kids = new TrieNode[26];\\n        isWord = false;\\n    }\\n}\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker obj = new StreamChecker(words);\\n * boolean param_1 = obj.query(letter);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 304621,
                "title": "python-aho-corasick-trie",
                "content": "\\n\\n```\\nclass Node:\\n    def __init__(self):\\n        self.next = {}\\n        self.fail = None\\n        self.is_word = False\\n        \\nclass Trie:\\n    def __init__(self):\\n        self.root = Node()\\n        \\n    def add(self,word):\\n        cur = self.root\\n        for ch in word:\\n            if ch not in cur.next:\\n                cur.next[ch] = Node()\\n            cur = cur.next[ch]\\n        \\n        cur.is_word = True\\n            \\n    def build_failover(self):\\n        \\n        queue = collections.deque()\\n        for ch in self.root.next:\\n            self.root.next[ch].fail = self.root\\n            queue.append(self.root.next[ch])\\n            \\n        while queue:\\n            node = queue.popleft()\\n            for ch in node.next:\\n                queue.append(node.next[ch])\\n                failover = node.fail\\n                while True:\\n                    if failover==None:\\n                        node.next[ch].fail = self.root\\n                        break\\n                        \\n                    if ch in failover.next:\\n                        node.next[ch].fail = failover.next[ch]\\n                        break\\n                    else:\\n                        failover = failover.fail\\n    \\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.trie = Trie()\\n        self.build_trie(words)\\n        self.cur = self.trie.root\\n        \\n    def build_trie(self,words):\\n        for word in words:\\n            self.trie.add(word)\\n    \\n        self.trie.build_failover()\\n        \\n    def query(self, letter: str) -> bool:\\n        result = False\\n        while True:\\n            if letter in self.cur.next:\\n            \\n                self.cur = self.cur.next[letter]\\n\\n                if self.cur.is_word:\\n                    result = True\\n\\n                if self.cur.fail!=None and self.cur.fail.is_word:\\n                    result = True\\n                break\\n            elif self.cur.fail == None:\\n                self.cur = self.trie.root\\n                break\\n            else:\\n                self.cur = self.cur.fail\\n            \\n        return result\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Node:\\n    def __init__(self):\\n        self.next = {}\\n        self.fail = None\\n        self.is_word = False\\n        \\nclass Trie:\\n    def __init__(self):\\n        self.root = Node()\\n        \\n    def add(self,word):\\n        cur = self.root\\n        for ch in word:\\n            if ch not in cur.next:\\n                cur.next[ch] = Node()\\n            cur = cur.next[ch]\\n        \\n        cur.is_word = True\\n            \\n    def build_failover(self):\\n        \\n        queue = collections.deque()\\n        for ch in self.root.next:\\n            self.root.next[ch].fail = self.root\\n            queue.append(self.root.next[ch])\\n            \\n        while queue:\\n            node = queue.popleft()\\n            for ch in node.next:\\n                queue.append(node.next[ch])\\n                failover = node.fail\\n                while True:\\n                    if failover==None:\\n                        node.next[ch].fail = self.root\\n                        break\\n                        \\n                    if ch in failover.next:\\n                        node.next[ch].fail = failover.next[ch]\\n                        break\\n                    else:\\n                        failover = failover.fail\\n    \\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.trie = Trie()\\n        self.build_trie(words)\\n        self.cur = self.trie.root\\n        \\n    def build_trie(self,words):\\n        for word in words:\\n            self.trie.add(word)\\n    \\n        self.trie.build_failover()\\n        \\n    def query(self, letter: str) -> bool:\\n        result = False\\n        while True:\\n            if letter in self.cur.next:\\n            \\n                self.cur = self.cur.next[letter]\\n\\n                if self.cur.is_word:\\n                    result = True\\n\\n                if self.cur.fail!=None and self.cur.fail.is_word:\\n                    result = True\\n                break\\n            elif self.cur.fail == None:\\n                self.cur = self.trie.root\\n                break\\n            else:\\n                self.cur = self.cur.fail\\n            \\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 282225,
                "title": "easy-understanding-python-trie-template-solution-good-for-interview",
                "content": "Build trie by reversely insert letter of each word, record stream with a stack and reversely iterate stack to find whether a initial letter of word appear(\\'#\\' appear in dictionary then return True) or letter not equal to current letter in trie along backward direction of stack(return False).\\n```\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.trie = {}\\n        self.stack = []\\n        \\n        for word in words:\\n            t = self.trie\\n            for c in reversed(word):\\n                if c not in t:\\n                    t[c] = {}\\n                t = t[c]\\n            t[\\'#\\'] = \\'#\\'\\n\\n    def query(self, letter: str) -> bool:\\n        t = self.trie\\n        self.stack.append(letter)\\n        \\n        for i in range(len(self.stack)-1, -1, -1):\\n            char = self.stack[i]\\n            if char not in t:\\n                return False\\n            else:\\n                t = t[char]\\n                if \\'#\\' in t:\\n                    return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.trie = {}\\n        self.stack = []\\n        \\n        for word in words:\\n            t = self.trie\\n            for c in reversed(word):\\n                if c not in t:\\n                    t[c] = {}\\n                t = t[c]\\n            t[\\'#\\'] = \\'#\\'\\n\\n    def query(self, letter: str) -> bool:\\n        t = self.trie\\n        self.stack.append(letter)\\n        \\n        for i in range(len(self.stack)-1, -1, -1):\\n            char = self.stack[i]\\n            if char not in t:\\n                return False\\n            else:\\n                t = t[char]\\n                if \\'#\\' in t:\\n                    return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 281608,
                "title": "easy-java-solution-build-dictionary-tree-and-query-from-tree",
                "content": "Idea is very simple:\\n1. reverse each word and build tree structure\\n2. keep appending letter to stringbuilder\\n3. everytime loop from end of stringbuilder,  search in tree structure.\\n```\\nclass StreamChecker {\\n\\n    private Node root;\\n    private StringBuilder sb;\\n    \\n    public StreamChecker(String[] words) {\\n        root = new Node();\\n        sb = new StringBuilder();\\n        build(words);\\n    }\\n    \\n    public boolean query(char letter) {\\n        sb.append(letter);\\n        return findWord();\\n    }\\n    \\n    private boolean findWord() {\\n        Node node = root;\\n        for(int i = sb.length() - 1; i >= 0; i--) {\\n            char ch = sb.charAt(i);\\n            if(node.child[ch - \\'a\\'] == null) {\\n                return false;\\n            }\\n            node = node.child[ch - \\'a\\'];\\n            if(node.end) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private void build(String[] words) {\\n        for(String word: words) {\\n            Node node = root;\\n            for(int i = word.length() - 1; i >= 0; i--) {\\n                char ch = word.charAt(i);\\n                if(node.child[ch - \\'a\\'] == null) {\\n                    node.child[ch - \\'a\\'] = new Node();\\n                }\\n                node = node.child[ch - \\'a\\'];\\n            }\\n            node.end = true;\\n        }\\n    }\\n    \\n    private class Node {\\n        Node[] child = new Node[26];\\n        boolean end = false;\\n    }\\n}\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker obj = new StreamChecker(words);\\n * boolean param_1 = obj.query(letter);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker {\\n\\n    private Node root;\\n    private StringBuilder sb;\\n    \\n    public StreamChecker(String[] words) {\\n        root = new Node();\\n        sb = new StringBuilder();\\n        build(words);\\n    }\\n    \\n    public boolean query(char letter) {\\n        sb.append(letter);\\n        return findWord();\\n    }\\n    \\n    private boolean findWord() {\\n        Node node = root;\\n        for(int i = sb.length() - 1; i >= 0; i--) {\\n            char ch = sb.charAt(i);\\n            if(node.child[ch - \\'a\\'] == null) {\\n                return false;\\n            }\\n            node = node.child[ch - \\'a\\'];\\n            if(node.end) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private void build(String[] words) {\\n        for(String word: words) {\\n            Node node = root;\\n            for(int i = word.length() - 1; i >= 0; i--) {\\n                char ch = word.charAt(i);\\n                if(node.child[ch - \\'a\\'] == null) {\\n                    node.child[ch - \\'a\\'] = new Node();\\n                }\\n                node = node.child[ch - \\'a\\'];\\n            }\\n            node.end = true;\\n        }\\n    }\\n    \\n    private class Node {\\n        Node[] child = new Node[26];\\n        boolean end = false;\\n    }\\n}\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker obj = new StreamChecker(words);\\n * boolean param_1 = obj.query(letter);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 280557,
                "title": "java-solution-with-trienode",
                "content": "normally, we build the trie by scanning from first char to last one. but as it\\'s streaming data and we store build the trie reversely - for each word, start from the last character.\\nAlso, to avoid TLE, get the maximum length of the word and delete the character in stringbuilder if the length is longer than max length\\n```\\nclass StreamChecker {\\n    StringBuilder input;\\n    TrieNode root;\\n    int maxLen;\\n    public StreamChecker(String[] words) {\\n        input = new StringBuilder();\\n        root = new TrieNode();\\n        maxLen = 0;\\n        for (String w : words) {\\n            maxLen = Math.max(maxLen, w.length());\\n            TrieNode cur = root;\\n            for (int i = w.length() - 1; i >= 0; i--) {\\n                char c = w.charAt(i);\\n                if (!cur.children.containsKey(c)) {\\n                    cur.children.put(c, new TrieNode());\\n                }\\n                cur = cur.children.get(c);\\n            }\\n            cur.isWord = true;\\n        }\\n    }\\n\\n    public boolean query(char letter) {\\n        input.append(letter);\\n        if (input.length() > maxLen) input.deleteCharAt(0);\\n        TrieNode cur = root;\\n        for (int i = input.length() - 1; i >= 0; i--) {\\n            char c = input.charAt(i);\\n            if (!cur.children.containsKey(c)) return false;\\n            cur = cur.children.get(c);\\n            if (cur.isWord) return true;\\n        }\\n        return false;\\n    }\\n\\n    class TrieNode {\\n        Map<Character, TrieNode> children;\\n        boolean isWord;\\n        public TrieNode() {\\n            children = new HashMap<>();\\n            isWord = false;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker {\\n    StringBuilder input;\\n    TrieNode root;\\n    int maxLen;\\n    public StreamChecker(String[] words) {\\n        input = new StringBuilder();\\n        root = new TrieNode();\\n        maxLen = 0;\\n        for (String w : words) {\\n            maxLen = Math.max(maxLen, w.length());\\n            TrieNode cur = root;\\n            for (int i = w.length() - 1; i >= 0; i--) {\\n                char c = w.charAt(i);\\n                if (!cur.children.containsKey(c)) {\\n                    cur.children.put(c, new TrieNode());\\n                }\\n                cur = cur.children.get(c);\\n            }\\n            cur.isWord = true;\\n        }\\n    }\\n\\n    public boolean query(char letter) {\\n        input.append(letter);\\n        if (input.length() > maxLen) input.deleteCharAt(0);\\n        TrieNode cur = root;\\n        for (int i = input.length() - 1; i >= 0; i--) {\\n            char c = input.charAt(i);\\n            if (!cur.children.containsKey(c)) return false;\\n            cur = cur.children.get(c);\\n            if (cur.isWord) return true;\\n        }\\n        return false;\\n    }\\n\\n    class TrieNode {\\n        Map<Character, TrieNode> children;\\n        boolean isWord;\\n        public TrieNode() {\\n            children = new HashMap<>();\\n            isWord = false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 278752,
                "title": "trie-solution-o-max-word-length-with-explanation",
                "content": "Idea is just to search for words from the end. \\n1) At the beginning (in the constructor), add all the words to trie starting from the end.\\n2) Maintain Stream of characters in a list\\n3) When a character arrives to the stream just start search in the trie backwards.\\n\\nTotal time complexity for each search case is O(max(word.length)) where max(word.length) is the maximum length of a word in a dictionary.\\n\\nPlease find code below.\\n```\\nclass StreamChecker {\\n    \\n    class Trie {\\n        boolean isWord;\\n        Trie [] next;\\n        \\n        public Trie () {\\n            next = new Trie[26];\\n        }\\n    \\n        \\n    }\\n    Trie root;\\n    List<Character> chars;\\n    public StreamChecker(String[] words) {\\n        root = new Trie();\\n        for(int i = 0;i<words.length;i++) {\\n           addToTrie(words[i]);\\n        }\\n        chars = new ArrayList<>();\\n    }\\n    \\n    \\n    void addToTrie(String str) {\\n        \\n        Trie node = root;\\n        for(int i = str.length()-1;i>=0;i--) {\\n            int ch = str.charAt(i) - \\'a\\';\\n            if(node.next[ch] == null)  node.next[ch] = new Trie();\\n            node = node.next[ch];\\n        }\\n        \\n        node.isWord = true;\\n        \\n    }\\n    public boolean query(char letter) {\\n        \\n        Trie node = root;\\n        \\n        chars.add(letter);\\n        int i = chars.size()-1;\\n        while(node != null && !node.isWord && i >= 0) {\\n            int ch =  chars.get(i) - \\'a\\';\\n            node = node.next[ch];\\n            --i;\\n        }\\n        \\n        return node != null && node.isWord;\\n    }\\n}\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker obj = new StreamChecker(words);\\n * boolean param_1 = obj.query(letter);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker {\\n    \\n    class Trie {\\n        boolean isWord;\\n        Trie [] next;\\n        \\n        public Trie () {\\n            next = new Trie[26];\\n        }\\n    \\n        \\n    }\\n    Trie root;\\n    List<Character> chars;\\n    public StreamChecker(String[] words) {\\n        root = new Trie();\\n        for(int i = 0;i<words.length;i++) {\\n           addToTrie(words[i]);\\n        }\\n        chars = new ArrayList<>();\\n    }\\n    \\n    \\n    void addToTrie(String str) {\\n        \\n        Trie node = root;\\n        for(int i = str.length()-1;i>=0;i--) {\\n            int ch = str.charAt(i) - \\'a\\';\\n            if(node.next[ch] == null)  node.next[ch] = new Trie();\\n            node = node.next[ch];\\n        }\\n        \\n        node.isWord = true;\\n        \\n    }\\n    public boolean query(char letter) {\\n        \\n        Trie node = root;\\n        \\n        chars.add(letter);\\n        int i = chars.size()-1;\\n        while(node != null && !node.isWord && i >= 0) {\\n            int ch =  chars.get(i) - \\'a\\';\\n            node = node.next[ch];\\n            --i;\\n        }\\n        \\n        return node != null && node.isWord;\\n    }\\n}\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker obj = new StreamChecker(words);\\n * boolean param_1 = obj.query(letter);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 278733,
                "title": "trie-queue-technique-simple-solution",
                "content": "```\\nclass StreamChecker {\\n    private Trie root = null;\\n    private Queue<Trie> queue = null;\\n    public StreamChecker(String[] words) {\\n        root = new Trie();\\n        if(words != null) {\\n           for(String word : words) {\\n               addToTrie(word, root);\\n           } \\n        }\\n        queue = new LinkedList<>();\\n        queue.offer(root);\\n    }\\n    \\n    private void addToTrie(String word, Trie base) {\\n        Trie node = base;\\n        for(char c : word.toCharArray()) {\\n            if(node.children == null)\\n                node.children = new Trie[26];\\n            if(node.children[c - \\'a\\'] == null)\\n                node.children[c - \\'a\\'] = new Trie();\\n            node = node.children[c - \\'a\\'];\\n        }\\n        node.isWord = true;\\n    }\\n    \\n    public boolean query(char letter) {\\n        boolean exists = false;\\n        int size = queue.size();\\n        for(int i=0; i<size; ++i) {\\n            Trie prev = queue.poll();\\n            if(prev.children != null) {\\n                Trie node = prev.children[letter - \\'a\\'];\\n                if(node != null) {\\n                    if(node.isWord) exists = true;\\n                    queue.offer(node);\\n                }\\n            }\\n        }\\n        queue.offer(root);\\n        return exists;\\n    }\\n}\\n\\nclass Trie {\\n    boolean isWord;\\n    Trie[] children;\\n}",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker {\\n    private Trie root = null;\\n    private Queue<Trie> queue = null;\\n    public StreamChecker(String[] words) {\\n        root = new Trie();\\n        if(words != null) {\\n           for(String word : words) {\\n               addToTrie(word, root);\\n           } \\n        }\\n        queue = new LinkedList<>();\\n        queue.offer(root);\\n    }\\n    \\n    private void addToTrie(String word, Trie base) {\\n        Trie node = base;\\n        for(char c : word.toCharArray()) {\\n            if(node.children == null)\\n                node.children = new Trie[26];\\n            if(node.children[c - \\'a\\'] == null)\\n                node.children[c - \\'a\\'] = new Trie();\\n            node = node.children[c - \\'a\\'];\\n        }\\n        node.isWord = true;\\n    }\\n    \\n    public boolean query(char letter) {\\n        boolean exists = false;\\n        int size = queue.size();\\n        for(int i=0; i<size; ++i) {\\n            Trie prev = queue.poll();\\n            if(prev.children != null) {\\n                Trie node = prev.children[letter - \\'a\\'];\\n                if(node != null) {\\n                    if(node.isWord) exists = true;\\n                    queue.offer(node);\\n                }\\n            }\\n        }\\n        queue.offer(root);\\n        return exists;\\n    }\\n}\\n\\nclass Trie {\\n    boolean isWord;\\n    Trie[] children;\\n}",
                "codeTag": "Java"
            },
            {
                "id": 278730,
                "title": "java-trie",
                "content": "http://www.noteanddata.com/leetcode-1032-Stream-of-Characters-java-solution-note.html\\n\\n```\\nclass StreamChecker {\\n    \\n    static class Node {\\n        Node[] children;\\n        boolean isWordEnd;\\n        public Node() {\\n            this.children = new Node[26];\\n            this.isWordEnd = false;\\n        }\\n    }\\n\\n    private Node root;\\n    private List<Character> queryList;\\n    \\n    public StreamChecker(String[] words) {\\n        this.root = new Node();\\n        this.queryList = new ArrayList<>();\\n        \\n        for(String word: words) {\\n            char[] arr = word.toCharArray();\\n            Node cur = root;\\n            for(int i = arr.length-1; i >= 0; --i) {\\n                char ch = arr[i];\\n                int index = (int)(ch-\\'a\\');\\n                \\n                if(null == cur.children[index]) {\\n                    cur.children[index] = new Node(); \\n                }\\n                cur = cur.children[index];\\n                if(i == 0) {\\n                    cur.isWordEnd = true;\\n                }\\n            }\\n        }\\n    }\\n    \\n    public boolean query(char letter) {\\n        queryList.add(letter);\\n        Node cur = root;\\n        for(int i = queryList.size()-1; i >= 0; --i) {\\n            int index = (int)(queryList.get(i)-\\'a\\');\\n            if(cur.children[index] == null) {\\n                //System.out.println(\"null\");\\n                return false;\\n            }\\n            cur = cur.children[index];\\n            //System.out.println(\"cur.isWordEnd=\" + cur.isWordEnd);\\n            if(cur.isWordEnd) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker obj = new StreamChecker(words);\\n * boolean param_1 = obj.query(letter);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker {\\n    \\n    static class Node {\\n        Node[] children;\\n        boolean isWordEnd;\\n        public Node() {\\n            this.children = new Node[26];\\n            this.isWordEnd = false;\\n        }\\n    }\\n\\n    private Node root;\\n    private List<Character> queryList;\\n    \\n    public StreamChecker(String[] words) {\\n        this.root = new Node();\\n        this.queryList = new ArrayList<>();\\n        \\n        for(String word: words) {\\n            char[] arr = word.toCharArray();\\n            Node cur = root;\\n            for(int i = arr.length-1; i >= 0; --i) {\\n                char ch = arr[i];\\n                int index = (int)(ch-\\'a\\');\\n                \\n                if(null == cur.children[index]) {\\n                    cur.children[index] = new Node(); \\n                }\\n                cur = cur.children[index];\\n                if(i == 0) {\\n                    cur.isWordEnd = true;\\n                }\\n            }\\n        }\\n    }\\n    \\n    public boolean query(char letter) {\\n        queryList.add(letter);\\n        Node cur = root;\\n        for(int i = queryList.size()-1; i >= 0; --i) {\\n            int index = (int)(queryList.get(i)-\\'a\\');\\n            if(cur.children[index] == null) {\\n                //System.out.println(\"null\");\\n                return false;\\n            }\\n            cur = cur.children[index];\\n            //System.out.println(\"cur.isWordEnd=\" + cur.isWordEnd);\\n            if(cur.isWordEnd) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker obj = new StreamChecker(words);\\n * boolean param_1 = obj.query(letter);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3746379,
                "title": "c-trie-solution-using-deque",
                "content": "In order to minimize the number of characters that we store in our string, I am using a deque of characters which limits the storage to the maximum length of a string from ```words``` since if present, no suffix will have a length greater than this longest string.\\n\\n```\\nclass node {\\n    public:\\n    node *next[26];\\n    bool is_end;\\n    node(bool x=false){\\n        memset(next,0,sizeof(next));\\n        is_end=x;\\n    }\\n};\\nclass Trie {\\npublic:\\n    node *root;\\n    \\n    Trie() { root=new node(); }\\n    \\n    void insert(string &word) {\\n        node *p=root;\\n        for(int i=0; i<word.length(); i++){\\n            if(p->next[word[i]-\\'a\\']==NULL){\\n                p->next[word[i]-\\'a\\']=new node();\\n            }\\n            p=p->next[word[i]-\\'a\\'];\\n        }\\n        p->is_end=true;\\n    }\\n    \\n    bool search(deque<char> &dq) {\\n        node* dummy=root;\\n        for(auto it=dq.rbegin(); it!=dq.rend(); it++){\\n            if(!dummy or !dummy->next[*it-\\'a\\']){ return false; }\\n            dummy=dummy->next[*it-\\'a\\'];\\n            if(dummy and dummy->is_end){ return true; }\\n        }\\n        return false;\\n    }\\n};\\n\\nclass StreamChecker {\\npublic:\\n    Trie *t=new Trie();\\n    string s=\"\";\\n    deque<char> dq;\\n    int mx=0;\\n    StreamChecker(vector<string>& words) {\\n        for(auto &w:words){\\n            mx=max(mx,(int)w.length());\\n            reverse(w.begin(),w.end());\\n            t->insert(w);\\n        }\\n    }\\n    \\n    bool query(char letter) {\\n        dq.push_back(letter);\\n        if(dq.size()>mx){ dq.pop_front(); }\\n        return t->search(dq);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Trie",
                    "Queue"
                ],
                "code": "```words```\n```\\nclass node {\\n    public:\\n    node *next[26];\\n    bool is_end;\\n    node(bool x=false){\\n        memset(next,0,sizeof(next));\\n        is_end=x;\\n    }\\n};\\nclass Trie {\\npublic:\\n    node *root;\\n    \\n    Trie() { root=new node(); }\\n    \\n    void insert(string &word) {\\n        node *p=root;\\n        for(int i=0; i<word.length(); i++){\\n            if(p->next[word[i]-\\'a\\']==NULL){\\n                p->next[word[i]-\\'a\\']=new node();\\n            }\\n            p=p->next[word[i]-\\'a\\'];\\n        }\\n        p->is_end=true;\\n    }\\n    \\n    bool search(deque<char> &dq) {\\n        node* dummy=root;\\n        for(auto it=dq.rbegin(); it!=dq.rend(); it++){\\n            if(!dummy or !dummy->next[*it-\\'a\\']){ return false; }\\n            dummy=dummy->next[*it-\\'a\\'];\\n            if(dummy and dummy->is_end){ return true; }\\n        }\\n        return false;\\n    }\\n};\\n\\nclass StreamChecker {\\npublic:\\n    Trie *t=new Trie();\\n    string s=\"\";\\n    deque<char> dq;\\n    int mx=0;\\n    StreamChecker(vector<string>& words) {\\n        for(auto &w:words){\\n            mx=max(mx,(int)w.length());\\n            reverse(w.begin(),w.end());\\n            t->insert(w);\\n        }\\n    }\\n    \\n    bool query(char letter) {\\n        dq.push_back(letter);\\n        if(dq.size()>mx){ dq.pop_front(); }\\n        return t->search(dq);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687241,
                "title": "a-very-different-trie-solution-that-is-o-len-words-beats-93-1-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUnlike the editorial solurion, I don\\'t reverse the strings.\\nInstead, for the query step, I store the list of non-leaf nodes in the trie that can continue search to find a match. Since the stream comes char by char, I only need to iterate over my chached candidates to see if the new char ends up with a matched word. Each search in a candidate is O(1) since there are only 26 English characters, the number of candidates is O(len(words)). My candidates are refreshed at each char.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUnlike the editorial solurion, I don\\'t reverse the strings.\\nInstead, for the query step, I store the list of non-leaf nodes in the trie that can continue search to find a match. Since the stream comes char by char, I only need to iterate over my chached candidates to see if the new char ends up with a matched word. Each search in a candidate is O(1) since there are only 26 English characters, the number of candidates is O(len(words)). My candidates are refreshed at each char.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nFor query: O(L) where L is the size of corpus, aka, len(words)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nFor query: O(L) where L is the size of corpus, aka, len(words)\\n\\n# Code\\n```\\nclass StreamChecker:\\n    def __init__(self, words: List[str]):\\n        # build a trie for the words\\n        self.trie_root = {}\\n        # a list of valid nodes that can continue from the previous search\\n        self.candidates = [] \\n\\n        # build the trie\\n        for w in words:\\n            cur = self.trie_root\\n            for c in w:\\n                if c in cur:\\n                    cur = cur[c]\\n                else:\\n                    cur[c] = {}\\n                    cur = cur[c]\\n            # mark end of word\\n            cur[\"#\"] = {}   \\n\\n    def query(self, letter: str) -> bool:\\n        new_candidates = []\\n        found_match = False\\n        # a new candidate\\n        if letter in self.trie_root:\\n            node = self.trie_root[letter]\\n            if \"#\" in node:\\n                found_match = True\\n                # it\\'s possible that the matched word is a prefix \\n                # of another word\\n                if len(node) > 1:\\n                    new_candidates.append(node)\\n            else:\\n                new_candidates.append(node)\\n\\n        # iterate over candidates to check if the candidates are still valid\\n        # or if it matches a word (can be both)\\n        for node in self.candidates:\\n            if letter in node:\\n                next_node = node[letter]\\n                if \"#\" in next_node:\\n                    found_match = True\\n                    if len(next_node) > 1:\\n                        new_candidates.append(next_node)\\n                else:\\n                    new_candidates.append(next_node)\\n        self.candidates = new_candidates\\n\\n        return found_match\\n\\n\\n# Your StreamChecker object will be instantiated and called as such:\\n# obj = StreamChecker(words)\\n# param_1 = obj.query(letter)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Trie"
                ],
                "code": "```\\nclass StreamChecker:\\n    def __init__(self, words: List[str]):\\n        # build a trie for the words\\n        self.trie_root = {}\\n        # a list of valid nodes that can continue from the previous search\\n        self.candidates = [] \\n\\n        # build the trie\\n        for w in words:\\n            cur = self.trie_root\\n            for c in w:\\n                if c in cur:\\n                    cur = cur[c]\\n                else:\\n                    cur[c] = {}\\n                    cur = cur[c]\\n            # mark end of word\\n            cur[\"#\"] = {}   \\n\\n    def query(self, letter: str) -> bool:\\n        new_candidates = []\\n        found_match = False\\n        # a new candidate\\n        if letter in self.trie_root:\\n            node = self.trie_root[letter]\\n            if \"#\" in node:\\n                found_match = True\\n                # it\\'s possible that the matched word is a prefix \\n                # of another word\\n                if len(node) > 1:\\n                    new_candidates.append(node)\\n            else:\\n                new_candidates.append(node)\\n\\n        # iterate over candidates to check if the candidates are still valid\\n        # or if it matches a word (can be both)\\n        for node in self.candidates:\\n            if letter in node:\\n                next_node = node[letter]\\n                if \"#\" in next_node:\\n                    found_match = True\\n                    if len(next_node) > 1:\\n                        new_candidates.append(next_node)\\n                else:\\n                    new_candidates.append(next_node)\\n        self.candidates = new_candidates\\n\\n        return found_match\\n\\n\\n# Your StreamChecker object will be instantiated and called as such:\\n# obj = StreamChecker(words)\\n# param_1 = obj.query(letter)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3472804,
                "title": "easy-c-trie-solution",
                "content": "\\n\\n# Code\\n```\\nclass StreamChecker {\\npublic:\\n    struct Node{\\n        Node* links[26];\\n        bool flag=false;\\n        bool isContains(char ch)\\n        {\\n            return links[ch-\\'a\\']!=NULL;\\n        }\\n        void put(char ch,Node* node)\\n        {\\n            links[ch-\\'a\\']=node;\\n        }\\n        Node* get(char ch)\\n        {\\n            return links[ch-\\'a\\'];\\n        }\\n        void setEnd()\\n        {\\n          flag=true;\\n        }\\n        bool isEnd()\\n        {\\n            return flag;\\n        }\\n    };\\n    class Trie\\n    {\\n        public:\\n        Node* root;\\n        Trie()\\n        {\\n           root=new Node();\\n        }\\n        void insert(string &str)\\n        {\\n         Node* node=root;\\n         for (int i=str.size()-1;i>=0;i--)\\n         {\\n             if (!node->isContains(str[i]))\\n             {\\n                 node->put(str[i],new Node());\\n             }\\n             node=node->get(str[i]);\\n         }\\n         node->setEnd();\\n        }\\n        bool check(string &str)\\n        {\\n            Node* node=root;\\n            for (int i=str.size()-1;i>=0;i--)\\n            {\\n              if (node->isContains(str[i]))\\n              {\\n                  node=node->get(str[i]);\\n                  if (node->isEnd()) return true;\\n              }\\n              else return false;\\n            }\\n            return false;\\n        }\\n    };\\n    Trie * trie;\\n    string str;\\n    StreamChecker(vector<string>& words) \\n    {\\n        trie=new Trie();\\n        for (int i=0;i<words.size();i++)\\n        {\\n            trie->insert(words[i]);\\n        }\\n        str=\"\";\\n    }\\n    \\n    bool query(char letter) {\\n        str+=letter;\\n        if(trie->check(str)) return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker* obj = new StreamChecker(words);\\n * bool param_1 = obj->query(letter);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Trie"
                ],
                "code": "```\\nclass StreamChecker {\\npublic:\\n    struct Node{\\n        Node* links[26];\\n        bool flag=false;\\n        bool isContains(char ch)\\n        {\\n            return links[ch-\\'a\\']!=NULL;\\n        }\\n        void put(char ch,Node* node)\\n        {\\n            links[ch-\\'a\\']=node;\\n        }\\n        Node* get(char ch)\\n        {\\n            return links[ch-\\'a\\'];\\n        }\\n        void setEnd()\\n        {\\n          flag=true;\\n        }\\n        bool isEnd()\\n        {\\n            return flag;\\n        }\\n    };\\n    class Trie\\n    {\\n        public:\\n        Node* root;\\n        Trie()\\n        {\\n           root=new Node();\\n        }\\n        void insert(string &str)\\n        {\\n         Node* node=root;\\n         for (int i=str.size()-1;i>=0;i--)\\n         {\\n             if (!node->isContains(str[i]))\\n             {\\n                 node->put(str[i],new Node());\\n             }\\n             node=node->get(str[i]);\\n         }\\n         node->setEnd();\\n        }\\n        bool check(string &str)\\n        {\\n            Node* node=root;\\n            for (int i=str.size()-1;i>=0;i--)\\n            {\\n              if (node->isContains(str[i]))\\n              {\\n                  node=node->get(str[i]);\\n                  if (node->isEnd()) return true;\\n              }\\n              else return false;\\n            }\\n            return false;\\n        }\\n    };\\n    Trie * trie;\\n    string str;\\n    StreamChecker(vector<string>& words) \\n    {\\n        trie=new Trie();\\n        for (int i=0;i<words.size();i++)\\n        {\\n            trie->insert(words[i]);\\n        }\\n        str=\"\";\\n    }\\n    \\n    bool query(char letter) {\\n        str+=letter;\\n        if(trie->check(str)) return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker* obj = new StreamChecker(words);\\n * bool param_1 = obj->query(letter);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2769013,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass StreamChecker {\\n    unordered_set<int> suffixHash, wordHash;\\n    string queryStream = \"\";\\n    int rollingHash(long& hash, long& p_pow, char c, int mod = 1e9+7) {\\n        p_pow = (p_pow * 31) % mod;\\n        return hash = (hash + (c-\\'a\\'+1) * p_pow) % mod;\\n    }\\npublic:    \\n    StreamChecker(vector<string>& words) { \\n        for(auto& w : words) {\\n            long hash = 0, p_pow = 1;\\n            for(int i = size(w)-1; ~i; i--) \\n                suffixHash.insert(rollingHash(hash, p_pow, w[i]));                         \\n            wordHash.insert(hash);                                                         \\n        }\\n    }\\n    bool query(char c) {\\n        queryStream += c;\\n        for(long i = size(queryStream)-1, hash = 0, p_pow = 1; ~i; i--)             \\n            if(!suffixHash.count(rollingHash(hash, p_pow, queryStream[i]))) return false;   \\n            else if(wordHash.count(hash)) return true;                                    \\n        \\n        return false;\\n    }\\n};\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker* obj = new StreamChecker(words);\\n * bool param_1 = obj->query(letter);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass StreamChecker {\\n    unordered_set<int> suffixHash, wordHash;\\n    string queryStream = \"\";\\n    int rollingHash(long& hash, long& p_pow, char c, int mod = 1e9+7) {\\n        p_pow = (p_pow * 31) % mod;\\n        return hash = (hash + (c-\\'a\\'+1) * p_pow) % mod;\\n    }\\npublic:    \\n    StreamChecker(vector<string>& words) { \\n        for(auto& w : words) {\\n            long hash = 0, p_pow = 1;\\n            for(int i = size(w)-1; ~i; i--) \\n                suffixHash.insert(rollingHash(hash, p_pow, w[i]));                         \\n            wordHash.insert(hash);                                                         \\n        }\\n    }\\n    bool query(char c) {\\n        queryStream += c;\\n        for(long i = size(queryStream)-1, hash = 0, p_pow = 1; ~i; i--)             \\n            if(!suffixHash.count(rollingHash(hash, p_pow, queryStream[i]))) return false;   \\n            else if(wordHash.count(hash)) return true;                                    \\n        \\n        return false;\\n    }\\n};\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker* obj = new StreamChecker(words);\\n * bool param_1 = obj->query(letter);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2300247,
                "title": "java-easy-to-understand",
                "content": "```\\nclass StreamChecker \\n{\\n    class TrieNode\\n    {\\n        TrieNode child[]=new TrieNode[26];\\n        boolean end=false;\\n    }\\n    \\n    class Trie\\n    {\\n        TrieNode root;\\n        \\n        Trie()\\n        {\\n            root=new TrieNode();\\n        }\\n        \\n        public void insert(String s)\\n        {\\n            TrieNode temp=root;\\n            \\n            for(int i=0;i<s.length();i++)\\n            {\\n                if(temp.child[s.charAt(i)-\\'a\\']==null)\\n                temp.child[s.charAt(i)-\\'a\\']=new TrieNode();\\n                \\n                temp=temp.child[s.charAt(i)-\\'a\\'];\\n            }\\n            \\n            temp.end=true;\\n        }\\n        \\n        public boolean search(String s)\\n        {\\n            TrieNode temp=root;\\n            \\n            for(int i=0;i<s.length();i++)\\n            {\\n                if(temp.child[s.charAt(i)-\\'a\\']==null)\\n                return false;\\n                \\n                if(temp.child[s.charAt(i)-\\'a\\'].end)\\n                return true;\\n                \\n                temp=temp.child[s.charAt(i)-\\'a\\'];\\n            }\\n            \\n            return false;\\n        }\\n    }\\n    \\n    Trie obj;\\n    String check;\\n    \\n    public StreamChecker(String[] words) \\n    {\\n        obj=new Trie();\\n        check=\"\";\\n        \\n        for(int i=0;i<words.length;i++)\\n        {\\n            String s=reverse(words[i]);\\n            obj.insert(s);\\n        }\\n    }\\n    \\n    public String reverse(String s)\\n    {\\n        String ans=\"\";\\n        for(int i=0;i<s.length();i++)\\n        ans=s.charAt(i)+ans;\\n        \\n        return ans;\\n    }\\n    \\n    public boolean query(char letter) \\n    {\\n        check=letter+check;\\n        \\n        return obj.search(check);\\n    }\\n}\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker obj = new StreamChecker(words);\\n * boolean param_1 = obj.query(letter);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass StreamChecker \\n{\\n    class TrieNode\\n    {\\n        TrieNode child[]=new TrieNode[26];\\n        boolean end=false;\\n    }\\n    \\n    class Trie\\n    {\\n        TrieNode root;\\n        \\n        Trie()\\n        {\\n            root=new TrieNode();\\n        }\\n        \\n        public void insert(String s)\\n        {\\n            TrieNode temp=root;\\n            \\n            for(int i=0;i<s.length();i++)\\n            {\\n                if(temp.child[s.charAt(i)-\\'a\\']==null)\\n                temp.child[s.charAt(i)-\\'a\\']=new TrieNode();\\n                \\n                temp=temp.child[s.charAt(i)-\\'a\\'];\\n            }\\n            \\n            temp.end=true;\\n        }\\n        \\n        public boolean search(String s)\\n        {\\n            TrieNode temp=root;\\n            \\n            for(int i=0;i<s.length();i++)\\n            {\\n                if(temp.child[s.charAt(i)-\\'a\\']==null)\\n                return false;\\n                \\n                if(temp.child[s.charAt(i)-\\'a\\'].end)\\n                return true;\\n                \\n                temp=temp.child[s.charAt(i)-\\'a\\'];\\n            }\\n            \\n            return false;\\n        }\\n    }\\n    \\n    Trie obj;\\n    String check;\\n    \\n    public StreamChecker(String[] words) \\n    {\\n        obj=new Trie();\\n        check=\"\";\\n        \\n        for(int i=0;i<words.length;i++)\\n        {\\n            String s=reverse(words[i]);\\n            obj.insert(s);\\n        }\\n    }\\n    \\n    public String reverse(String s)\\n    {\\n        String ans=\"\";\\n        for(int i=0;i<s.length();i++)\\n        ans=s.charAt(i)+ans;\\n        \\n        return ans;\\n    }\\n    \\n    public boolean query(char letter) \\n    {\\n        check=letter+check;\\n        \\n        return obj.search(check);\\n    }\\n}\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker obj = new StreamChecker(words);\\n * boolean param_1 = obj.query(letter);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937623,
                "title": "c-trie-solution",
                "content": "Runtime: 326 ms, faster than 85.52% of C++ online submissions for Stream of Characters.\\nMemory Usage: 123.8 MB, less than 83.13% of C++ online submissions for Stream of Characters.\\n\\n```\\n1. Store words in Trie in reverse order\\n2. Calculate Max length among all words\\n3. Build up query string by appending letter at the back\\n4. Search query string in reverse order in Trie up to Max word length and query string length\\n```\\n\\n```\\nclass StreamChecker {\\npublic:\\n    \\n    struct TrieNode\\n    {\\n        TrieNode * child[26];\\n        bool word;\\n    };\\n    \\n    TrieNode * getNode()\\n    {\\n        TrieNode * node = new TrieNode();\\n        for(int i=0;i<26;i++)node->child[i]=NULL;\\n        node->word = false;\\n        \\n        return node;\\n    }\\n    \\n    // add words in reverse order in trie\\n    void addWord(TrieNode *root, string &str)\\n    {\\n        int sl = str.length();\\n        TrieNode * node = root;\\n        int index;\\n        for(int i=sl-1;i>=0;i--)\\n        {\\n            index = str[i]-\\'a\\';\\n            if(node->child[index]==NULL)\\n                node->child[index]=getNode();\\n            \\n            node = node->child[index];\\n        }\\n        \\n        node->word = true;\\n    }\\n    \\n    // search query string in reverse order in trie up to max length words or query string\\n    bool searchWord(TrieNode *root, string &str)\\n    {\\n        int sl = str.length();\\n        TrieNode * node = root;\\n        int index;\\n        for(int i=sl-1,j=0;i>=0 && j<maxWordLength;i--,j++)\\n        {\\n            index = str[i]-\\'a\\';\\n            if(node->child[index]==NULL)return false;\\n            \\n            node = node->child[index];\\n            if(node->word)return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    TrieNode *root;\\n    string qString;\\n    int maxWordLength = INT_MIN;\\n    \\n    StreamChecker(vector<string>& words) {\\n        \\n        // build up trie with given words\\n        root = getNode();\\n        for(string &word : words)\\n        {\\n            addWord(root,word);\\n            maxWordLength = max(maxWordLength,(int)word.length());\\n        }\\n    }\\n    \\n    bool query(char letter) {\\n        \\n        // append letter in query string and search\\n        qString.push_back(letter);\\n        return searchWord(root,qString);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Trie"
                ],
                "code": "```\\n1. Store words in Trie in reverse order\\n2. Calculate Max length among all words\\n3. Build up query string by appending letter at the back\\n4. Search query string in reverse order in Trie up to Max word length and query string length\\n```\n```\\nclass StreamChecker {\\npublic:\\n    \\n    struct TrieNode\\n    {\\n        TrieNode * child[26];\\n        bool word;\\n    };\\n    \\n    TrieNode * getNode()\\n    {\\n        TrieNode * node = new TrieNode();\\n        for(int i=0;i<26;i++)node->child[i]=NULL;\\n        node->word = false;\\n        \\n        return node;\\n    }\\n    \\n    // add words in reverse order in trie\\n    void addWord(TrieNode *root, string &str)\\n    {\\n        int sl = str.length();\\n        TrieNode * node = root;\\n        int index;\\n        for(int i=sl-1;i>=0;i--)\\n        {\\n            index = str[i]-\\'a\\';\\n            if(node->child[index]==NULL)\\n                node->child[index]=getNode();\\n            \\n            node = node->child[index];\\n        }\\n        \\n        node->word = true;\\n    }\\n    \\n    // search query string in reverse order in trie up to max length words or query string\\n    bool searchWord(TrieNode *root, string &str)\\n    {\\n        int sl = str.length();\\n        TrieNode * node = root;\\n        int index;\\n        for(int i=sl-1,j=0;i>=0 && j<maxWordLength;i--,j++)\\n        {\\n            index = str[i]-\\'a\\';\\n            if(node->child[index]==NULL)return false;\\n            \\n            node = node->child[index];\\n            if(node->word)return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    TrieNode *root;\\n    string qString;\\n    int maxWordLength = INT_MIN;\\n    \\n    StreamChecker(vector<string>& words) {\\n        \\n        // build up trie with given words\\n        root = getNode();\\n        for(string &word : words)\\n        {\\n            addWord(root,word);\\n            maxWordLength = max(maxWordLength,(int)word.length());\\n        }\\n    }\\n    \\n    bool query(char letter) {\\n        \\n        // append letter in query string and search\\n        qString.push_back(letter);\\n        return searchWord(root,qString);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1732619,
                "title": "c-trie",
                "content": "```\\nclass TrieNode \\n{\\n    public:\\n    bool is_word;\\n    unordered_map<char, TrieNode*> children;\\n    TrieNode(): is_word(false)\\n    {}\\n};\\n\\nclass Trie\\n{\\n    public:\\n    TrieNode* root;\\n    Trie()\\n    {\\n        root = new TrieNode();\\n    }\\n    void insert(string str)\\n    {\\n        TrieNode* current = root;\\n        for (int i = str.size() - 1; i > -1; i--)\\n        {\\n            if (current->children.find(str[i]) == current->children.end())\\n            {\\n                current->children[str[i]] = new TrieNode();\\n            }\\n            current = current->children[str[i]];\\n        }\\n        current->is_word = true;\\n    }\\n    bool find(string s)\\n    {\\n        TrieNode* current = root;\\n        for (auto c : s)\\n        {\\n            if (current->children.find(c) == current->children.end())\\n            {\\n                return false;\\n            }\\n            if (current->children[c]->is_word)\\n            {\\n                return true;\\n            }\\n            current = current->children[c];\\n        }\\n        return false;\\n    }\\n    \\n};\\nclass StreamChecker {\\npublic:\\n    \\n    string current;\\n    Trie* tree;\\n    int max_len;\\n    StreamChecker(vector<string>& words) {\\n        \\n        current = \"\";\\n        tree = new Trie();\\n        max_len = 0;\\n        for (auto w : words)\\n        {\\n            if (w.size() > max_len)\\n            {\\n                max_len = w.size();\\n            }\\n            tree->insert(w);\\n        }\\n    }\\n    \\n    bool query(char letter) {\\n        \\n        current = letter + current;\\n        if (current.size() > max_len)\\n        {\\n            current = current.substr(0, max_len);\\n        }\\n        if (tree->find(current))\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker* obj = new StreamChecker(words);\\n * bool param_1 = obj->query(letter);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode \\n{\\n    public:\\n    bool is_word;\\n    unordered_map<char, TrieNode*> children;\\n    TrieNode(): is_word(false)\\n    {}\\n};\\n\\nclass Trie\\n{\\n    public:\\n    TrieNode* root;\\n    Trie()\\n    {\\n        root = new TrieNode();\\n    }\\n    void insert(string str)\\n    {\\n        TrieNode* current = root;\\n        for (int i = str.size() - 1; i > -1; i--)\\n        {\\n            if (current->children.find(str[i]) == current->children.end())\\n            {\\n                current->children[str[i]] = new TrieNode();\\n            }\\n            current = current->children[str[i]];\\n        }\\n        current->is_word = true;\\n    }\\n    bool find(string s)\\n    {\\n        TrieNode* current = root;\\n        for (auto c : s)\\n        {\\n            if (current->children.find(c) == current->children.end())\\n            {\\n                return false;\\n            }\\n            if (current->children[c]->is_word)\\n            {\\n                return true;\\n            }\\n            current = current->children[c];\\n        }\\n        return false;\\n    }\\n    \\n};\\nclass StreamChecker {\\npublic:\\n    \\n    string current;\\n    Trie* tree;\\n    int max_len;\\n    StreamChecker(vector<string>& words) {\\n        \\n        current = \"\";\\n        tree = new Trie();\\n        max_len = 0;\\n        for (auto w : words)\\n        {\\n            if (w.size() > max_len)\\n            {\\n                max_len = w.size();\\n            }\\n            tree->insert(w);\\n        }\\n    }\\n    \\n    bool query(char letter) {\\n        \\n        current = letter + current;\\n        if (current.size() > max_len)\\n        {\\n            current = current.substr(0, max_len);\\n        }\\n        if (tree->find(current))\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker* obj = new StreamChecker(words);\\n * bool param_1 = obj->query(letter);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1619737,
                "title": "suffix-tree-trie-easy-to-understand",
                "content": "We will keep list of words in suffix tree structure for quick search.\\n\\n```\\nfrom typing import List, Set\\n\\n\\nclass TreeNode:\\n    def __init__(self, value: str = \\'Start\\'):\\n        self.value: str = value\\n        self.children: Set[TreeNode] = set()\\n        self.is_leaf = False\\n\\n    def create_child(self, child_value: str):\\n        \"\"\"Create child with value child_value for this node and return child\\n        node. If child with child_value already exists, return him.\"\"\"\\n        existing_child: TreeNode = self.get_child(child_value)\\n        if existing_child:\\n            return existing_child\\n        new_child: TreeNode = TreeNode(child_value)\\n        self.children.add(new_child)\\n        return new_child\\n\\n    def get_child(self, value: str):\\n        \"\"\"Return child of this node if exists, else return None.\"\"\"\\n        for x in self.children:\\n            if x.value == value:\\n                return x\\n        return None\\n\\n\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.chars = \\'\\'\\n        self.root = TreeNode()\\n        \"\"\"Root of suffix tree for words.\"\"\"\\n\\n        for word in words:\\n            c_node = self.root\\n            for x in word[::-1]:\\n                c_node = c_node.create_child(x)\\n            c_node.is_leaf = True\\n\\n    def query(self, letter: str):\\n        self.chars += letter\\n        c_node = self.root\\n        for char in self.chars[::-1]:\\n            c_node = c_node.get_child(char)\\n            if not c_node:\\n                return False\\n            if c_node.is_leaf:\\n                return True\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom typing import List, Set\\n\\n\\nclass TreeNode:\\n    def __init__(self, value: str = \\'Start\\'):\\n        self.value: str = value\\n        self.children: Set[TreeNode] = set()\\n        self.is_leaf = False\\n\\n    def create_child(self, child_value: str):\\n        \"\"\"Create child with value child_value for this node and return child\\n        node. If child with child_value already exists, return him.\"\"\"\\n        existing_child: TreeNode = self.get_child(child_value)\\n        if existing_child:\\n            return existing_child\\n        new_child: TreeNode = TreeNode(child_value)\\n        self.children.add(new_child)\\n        return new_child\\n\\n    def get_child(self, value: str):\\n        \"\"\"Return child of this node if exists, else return None.\"\"\"\\n        for x in self.children:\\n            if x.value == value:\\n                return x\\n        return None\\n\\n\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.chars = \\'\\'\\n        self.root = TreeNode()\\n        \"\"\"Root of suffix tree for words.\"\"\"\\n\\n        for word in words:\\n            c_node = self.root\\n            for x in word[::-1]:\\n                c_node = c_node.create_child(x)\\n            c_node.is_leaf = True\\n\\n    def query(self, letter: str):\\n        self.chars += letter\\n        c_node = self.root\\n        for char in self.chars[::-1]:\\n            c_node = c_node.get_child(char)\\n            if not c_node:\\n                return False\\n            if c_node.is_leaf:\\n                return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1612561,
                "title": "python-trie-explained-clean-and-easy-to-understand",
                "content": "```\\n\\nclass StreamChecker(object):\\n    def __init__(self, words):\\n        # By reversing every word in the dictionary, the problem of suffix matching is transformed into prefix matching.\\n        self.trie, self.prefix = collections.defaultdict(collections.defaultdict), []\\n        for word in words:\\n            node = self.trie\\n            for c in word[::-1]:\\n                if c in node:\\n                    node = node[c]\\n                else:\\n                    node[c] = collections.defaultdict()\\n                    node = node[c]\\n            node[\\'$\\'] = None\\n\\n    def query(self, letter):\\n        self.prefix.insert(0, letter)  # Invert the character stream prefix, and then use the trie tree to match.\\n        node = self.trie\\n        for c in self.prefix:\\n            if c in node:\\n                node = node[c]\\n            else:\\n                return False\\n            if \\'$\\' in node:\\n                return True\\n        return False\\n```\\n**Please UPVOTE!**",
                "solutionTags": [
                    "Python",
                    "Trie"
                ],
                "code": "```\\n\\nclass StreamChecker(object):\\n    def __init__(self, words):\\n        # By reversing every word in the dictionary, the problem of suffix matching is transformed into prefix matching.\\n        self.trie, self.prefix = collections.defaultdict(collections.defaultdict), []\\n        for word in words:\\n            node = self.trie\\n            for c in word[::-1]:\\n                if c in node:\\n                    node = node[c]\\n                else:\\n                    node[c] = collections.defaultdict()\\n                    node = node[c]\\n            node[\\'$\\'] = None\\n\\n    def query(self, letter):\\n        self.prefix.insert(0, letter)  # Invert the character stream prefix, and then use the trie tree to match.\\n        node = self.trie\\n        for c in self.prefix:\\n            if c in node:\\n                node = node[c]\\n            else:\\n                return False\\n            if \\'$\\' in node:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1611973,
                "title": "python3-trie",
                "content": "I\\'m using Trie and do not store the whole stream in the memory as in the solution.\\n\\nRuntime: 8976 ms, faster than **5.14%** of Python3 online submissions for Stream of Characters.\\nMemory Usage: 38 MB, less than **86.38%** of Python3 online submissions for Stream of Characters.\\n\\n```\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.root = dict()\\n        self.cur = []\\n        \\n        for w in words:\\n            t = self.root\\n            \\n            for l in w:\\n                if not l in t:\\n                    t[l] = dict()\\n                    \\n                t = t[l]\\n            \\n            t[\"_\"] = True\\n            \\n    def query(self, l: str) -> bool:\\n        self.cur.append(self.root)\\n        \\n        res = False\\n        rem = []\\n        for i, c in enumerate(self.cur):\\n            if l in c:\\n                self.cur[i] = self.cur[i][l]\\n                \\n                if \"_\" in self.cur[i]:\\n                    if len(self.cur[i].keys()) == 1:\\n                        rem.append(i)\\n                    \\n                    res = True\\n            else:\\n                rem.append(i)\\n\\n        for i in reversed(rem):\\n            del self.cur[i]\\n                \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.root = dict()\\n        self.cur = []\\n        \\n        for w in words:\\n            t = self.root\\n            \\n            for l in w:\\n                if not l in t:\\n                    t[l] = dict()\\n                    \\n                t = t[l]\\n            \\n            t[\"_\"] = True\\n            \\n    def query(self, l: str) -> bool:\\n        self.cur.append(self.root)\\n        \\n        res = False\\n        rem = []\\n        for i, c in enumerate(self.cur):\\n            if l in c:\\n                self.cur[i] = self.cur[i][l]\\n                \\n                if \"_\" in self.cur[i]:\\n                    if len(self.cur[i].keys()) == 1:\\n                        rem.append(i)\\n                    \\n                    res = True\\n            else:\\n                rem.append(i)\\n\\n        for i in reversed(rem):\\n            del self.cur[i]\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1611814,
                "title": "java-solution-with-recursion-and-trie",
                "content": "Solution with entering every word in Reverse order in the Trie and then checking them if isWord or not.\\n\\nclass StreamChecker {\\n\\n    class TrieNode\\n    {\\n        Map<Character,TrieNode> child;\\n        boolean isWord;\\n            \\n        TrieNode()\\n        {\\n            child=new HashMap<>();\\n            isWord=false;\\n        }\\n    }\\n    \\n    TrieNode root;\\n    StringBuilder sb;\\n    \\n    public StreamChecker(String[] words) {\\n        root=new TrieNode();\\n        sb=new StringBuilder(\"\");\\n        \\n        TrieNode current=root;\\n        \\n        for(String s:words)\\n        {\\n            add(current,s,s.length()-1);\\n        }\\n    }\\n    \\n    public void add(TrieNode current,String s,int index)\\n    {\\n           if(index<0)\\n           {\\n               current.isWord=true;\\n               return;\\n           }\\n        \\n           if(current.child.containsKey(s.charAt(index)))\\n           {\\n               current=current.child.get(s.charAt(index));\\n               add(current,s,index-1);\\n           }else\\n           {\\n             TrieNode node=new TrieNode();\\n             current.child.put(s.charAt(index),node);\\n             current=current.child.get(s.charAt(index));\\n             add(current,s,index-1);\\n           }\\n    }\\n\\n    public boolean isWord(TrieNode current,StringBuilder s, int i)\\n    {\\n        if(i<0)\\n        {\\n            return false;\\n        }\\n        \\n        char ch=sb.charAt(i);\\n        if(current.child.containsKey(ch))\\n        {\\n            TrieNode n=current.child.get(ch);\\n            if(n.isWord)\\n            {\\n                return true;\\n            }else\\n            {\\n                current=current.child.get(ch);\\n                return isWord(current,s,i-1);\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public boolean query(char letter) {\\n        TrieNode current=root;\\n        sb.append(letter);\\n        \\n        boolean found=isWord(current,sb,sb.length()-1);\\n        \\n        return found;\\n    }\\n}\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker obj = new StreamChecker(words);\\n * boolean param_1 = obj.query(letter);\\n */",
                "solutionTags": [
                    "Trie",
                    "Recursion"
                ],
                "code": "Solution with entering every word in Reverse order in the Trie and then checking them if isWord or not.\\n\\nclass StreamChecker {\\n\\n    class TrieNode\\n    {\\n        Map<Character,TrieNode> child;\\n        boolean isWord;\\n            \\n        TrieNode()\\n        {\\n            child=new HashMap<>();\\n            isWord=false;\\n        }\\n    }\\n    \\n    TrieNode root;\\n    StringBuilder sb;\\n    \\n    public StreamChecker(String[] words) {\\n        root=new TrieNode();\\n        sb=new StringBuilder(\"\");\\n        \\n        TrieNode current=root;\\n        \\n        for(String s:words)\\n        {\\n            add(current,s,s.length()-1);\\n        }\\n    }\\n    \\n    public void add(TrieNode current,String s,int index)\\n    {\\n           if(index<0)\\n           {\\n               current.isWord=true;\\n               return;\\n           }\\n        \\n           if(current.child.containsKey(s.charAt(index)))\\n           {\\n               current=current.child.get(s.charAt(index));\\n               add(current,s,index-1);\\n           }else\\n           {\\n             TrieNode node=new TrieNode();\\n             current.child.put(s.charAt(index),node);\\n             current=current.child.get(s.charAt(index));\\n             add(current,s,index-1);\\n           }\\n    }\\n\\n    public boolean isWord(TrieNode current,StringBuilder s, int i)\\n    {\\n        if(i<0)\\n        {\\n            return false;\\n        }\\n        \\n        char ch=sb.charAt(i);\\n        if(current.child.containsKey(ch))\\n        {\\n            TrieNode n=current.child.get(ch);\\n            if(n.isWord)\\n            {\\n                return true;\\n            }else\\n            {\\n                current=current.child.get(ch);\\n                return isWord(current,s,i-1);\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public boolean query(char letter) {\\n        TrieNode current=root;\\n        sb.append(letter);\\n        \\n        boolean found=isWord(current,sb,sb.length()-1);\\n        \\n        return found;\\n    }\\n}\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker obj = new StreamChecker(words);\\n * boolean param_1 = obj.query(letter);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1611432,
                "title": "typescript-streaming-solution-with-trie-and-set",
                "content": "The LC provided solution holds onto the stream in memory, which is not how you\\'d process streams in real word scenarios for better scale. This solution doesn\\'t build the reversed-trie, hence a bit slower (33% fast, 100% better on memory), but still a good solution worth considering.\\n\\n```\\nclass StreamChecker {\\n  #trie: {[key: string]: boolean | Object} = {};\\n  #pending = new Set();\\n\\n  constructor(words: string[]) {\\n    for (const word of words) this._addWord(word);\\n  }\\n\\n  _addWord(word: string): void {\\n    if (!word.length) return;\\n    let ptr: null | boolean | {[key: string]: boolean | Object} = this.#trie;\\n    for (const char of word) {\\n      if (!ptr[char]) ptr[char] = {};\\n      ptr = ptr[char];\\n    }\\n    ptr[\\'_\\'] = true;\\n  }\\n\\n  query(letter: string): boolean {\\n    // Validate each pending first.\\n    let ret = false;\\n    const newPending = new Set();\\n    for (const ptr of this.#pending) {\\n      const newPtr = ptr[letter];\\n      if (!newPtr) continue;\\n      if (newPtr[\\'_\\']) ret = true;\\n      newPending.add(newPtr);\\n    }\\n    this.#pending = newPending;\\n\\n    // Check for words that start with this letter.\\n    if (this.#trie[letter]) {\\n      this.#pending.add(this.#trie[letter]);\\n\\n      // Single character word corner-case?\\n      if (this.#trie[letter][\\'_\\']) ret = true;\\n    }\\n    \\n    return ret;\\n  }\\n}\\n\\n/**\\n* Your StreamChecker object will be instantiated and called as such:\\n* var obj = new StreamChecker(words)\\n* var param_1 = obj.query(letter)\\n*/\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Trie"
                ],
                "code": "```\\nclass StreamChecker {\\n  #trie: {[key: string]: boolean | Object} = {};\\n  #pending = new Set();\\n\\n  constructor(words: string[]) {\\n    for (const word of words) this._addWord(word);\\n  }\\n\\n  _addWord(word: string): void {\\n    if (!word.length) return;\\n    let ptr: null | boolean | {[key: string]: boolean | Object} = this.#trie;\\n    for (const char of word) {\\n      if (!ptr[char]) ptr[char] = {};\\n      ptr = ptr[char];\\n    }\\n    ptr[\\'_\\'] = true;\\n  }\\n\\n  query(letter: string): boolean {\\n    // Validate each pending first.\\n    let ret = false;\\n    const newPending = new Set();\\n    for (const ptr of this.#pending) {\\n      const newPtr = ptr[letter];\\n      if (!newPtr) continue;\\n      if (newPtr[\\'_\\']) ret = true;\\n      newPending.add(newPtr);\\n    }\\n    this.#pending = newPending;\\n\\n    // Check for words that start with this letter.\\n    if (this.#trie[letter]) {\\n      this.#pending.add(this.#trie[letter]);\\n\\n      // Single character word corner-case?\\n      if (this.#trie[letter][\\'_\\']) ret = true;\\n    }\\n    \\n    return ret;\\n  }\\n}\\n\\n/**\\n* Your StreamChecker object will be instantiated and called as such:\\n* var obj = new StreamChecker(words)\\n* var param_1 = obj.query(letter)\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1611223,
                "title": "c-build-trie-with-o-m-n-m-words-i-length-n-the-number-of-queries",
                "content": "```\\nclass StreamChecker {\\npublic:\\n    struct node{\\n        unordered_map<char,node*> m;\\n        bool end;\\n        node(){\\n            end=false;\\n        };\\n    };\\n    void buildTrie(string& s){\\n        node* p=root;\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(p->m.count(s[i])==0){\\n                p->m[s[i]]=new node();\\n            }\\n            p=p->m[s[i]];\\n        }\\n        p->end=true;\\n    }\\n    bool checkTrie(){\\n        node* p=root;\\n        for(int i=t.size()-1;i>=0;i--){\\n            if(p->m.count(t[i])==0){\\n                return false;\\n            }\\n            p=p->m[t[i]];\\n            \\n            if(p->end==true){\\n                return true;\\n            }\\n        }\\n        return p->end==true;\\n    }\\n    node* root;\\n    StreamChecker(vector<string>& words) {\\n        /*\\n        dc\\n        f\\n        lk\\n        dcba\\n        build Trie\\n        */\\n        root=new node();\\n        for(auto& w:words){\\n            buildTrie(w);\\n        }\\n    }\\n    string t;\\n    bool query(char letter) {\\n        t+=letter;\\n        return checkTrie();\\n    }\\n};\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker* obj = new StreamChecker(words);\\n * bool param_1 = obj->query(letter);\\n */\\n```",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```\\nclass StreamChecker {\\npublic:\\n    struct node{\\n        unordered_map<char,node*> m;\\n        bool end;\\n        node(){\\n            end=false;\\n        };\\n    };\\n    void buildTrie(string& s){\\n        node* p=root;\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(p->m.count(s[i])==0){\\n                p->m[s[i]]=new node();\\n            }\\n            p=p->m[s[i]];\\n        }\\n        p->end=true;\\n    }\\n    bool checkTrie(){\\n        node* p=root;\\n        for(int i=t.size()-1;i>=0;i--){\\n            if(p->m.count(t[i])==0){\\n                return false;\\n            }\\n            p=p->m[t[i]];\\n            \\n            if(p->end==true){\\n                return true;\\n            }\\n        }\\n        return p->end==true;\\n    }\\n    node* root;\\n    StreamChecker(vector<string>& words) {\\n        /*\\n        dc\\n        f\\n        lk\\n        dcba\\n        build Trie\\n        */\\n        root=new node();\\n        for(auto& w:words){\\n            buildTrie(w);\\n        }\\n    }\\n    string t;\\n    bool query(char letter) {\\n        t+=letter;\\n        return checkTrie();\\n    }\\n};\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker* obj = new StreamChecker(words);\\n * bool param_1 = obj->query(letter);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1611094,
                "title": "java-solution-tle-on-last-case-need-help",
                "content": "**Guys pls help me.** I describe my approach for ur better underatanding...   \\n**Approach:**  \\n\\nin construtor: \\nStore the words in a hashmap, \"key = words[i], value: 0(not necessary)\" and store words length in a treemap, \"key = words[i].length, value: 0(not necessary)\". \\n\\nIn qyery :\\n\\ttraverse the treemap \\n\\t\\t\\tget the substring of that length from end.\\n\\t\\t\\tcheck in hashmap if there is any key present. if present return true.\\n\\tafter traverse if there is no such suffix return False.\\n\\n```\\nclass StreamChecker {\\n\\tHashMap <String, Integer> hashmap = new HashMap<> ();\\n\\tTreeMap <Integer, Integer> treemap = new TreeMap<> ();\\n\\n\\tString stream = \"\";\\n\\n\\tint maxLen, minLen;\\n\\tpublic StreamChecker(String[] words) {\\n\\t\\tfor(String S: words) {\\n\\t\\t\\ttreemap.put(S.length(), 0);\\n\\t\\t\\thashmap.put(S, S.length());\\n\\t\\t}\\n\\n\\t\\tmaxLen = treemap.lastKey();\\n\\t\\tminLen = treemap.firstKey();\\n\\t}\\n\\n\\tpublic boolean query(char letter) {\\n\\t\\tstream += String.valueOf(letter);\\n\\n\\t\\tif(stream.length() < minLen) return false;\\n\\n\\t\\tif(stream.length() > maxLen) stream = stream.substring(1);\\n    \\t// System.out.println(\"stream: \"+stream+\"\\\\tletter: \"+letter);\\n\\n\\t\\tfor(Map.Entry len : treemap.entrySet()) {\\n\\t\\t\\tint loc = stream.length() - (int)len.getKey();\\n\\t\\t\\tif(loc >= 0) {\\n\\t\\t\\t\\tString temp = stream.substring(loc);\\n\\n\\t\\t\\t\\tif(hashmap.containsKey(temp)) return true;\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass StreamChecker {\\n\\tHashMap <String, Integer> hashmap = new HashMap<> ();\\n\\tTreeMap <Integer, Integer> treemap = new TreeMap<> ();\\n\\n\\tString stream = \"\";\\n\\n\\tint maxLen, minLen;\\n\\tpublic StreamChecker(String[] words) {\\n\\t\\tfor(String S: words) {\\n\\t\\t\\ttreemap.put(S.length(), 0);\\n\\t\\t\\thashmap.put(S, S.length());\\n\\t\\t}\\n\\n\\t\\tmaxLen = treemap.lastKey();\\n\\t\\tminLen = treemap.firstKey();\\n\\t}\\n\\n\\tpublic boolean query(char letter) {\\n\\t\\tstream += String.valueOf(letter);\\n\\n\\t\\tif(stream.length() < minLen) return false;\\n\\n\\t\\tif(stream.length() > maxLen) stream = stream.substring(1);\\n    \\t// System.out.println(\"stream: \"+stream+\"\\\\tletter: \"+letter);\\n\\n\\t\\tfor(Map.Entry len : treemap.entrySet()) {\\n\\t\\t\\tint loc = stream.length() - (int)len.getKey();\\n\\t\\t\\tif(loc >= 0) {\\n\\t\\t\\t\\tString temp = stream.substring(loc);\\n\\n\\t\\t\\t\\tif(hashmap.containsKey(temp)) return true;\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1611052,
                "title": "simple-python-trie-solution",
                "content": "```python\\nclass StreamChecker:\\n    def __init__(self, words: List[str]):\\n\\t\"\"\"\\n\\tIn our init state, we create a trie.\\n\\tSomething like this:\\n\\t[\"tr\", \"tre\", \"q\"] => {t: {r: {\"END\": True, e: {\"END\": True}}}, q: {\"END\": True}}\\n\\t\"\"\"\\n        self.trie = {}\\n        for word in words:\\n            curr = self.trie\\n            for char in word:\\n                curr = curr.setdefault(char, {})\\n            curr[\"END\"] = True\\n        self.pointer_array = []\\n\\n    def query(self, letter: str) -> bool:\\n\\t\\t\"\"\"\\n\\t\\tNext, we just start a pointter at every new letter, venturing deeper into our trie!\\n\\t\\t\"\"\"\\n        found = False\\n        for i, p in enumerate(self.pointer_array):\\n            if letter in p:\\n                self.pointer_array[i] = p[letter]\\n                if p[letter].get(\"END\"):\\n                    found = True\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\"\"\"If we cannot venture deeper, remove this pointer\"\"\"\\n                    if len(p[letter]) == 1:\\n                        self.pointer_array[i] = None\\n            else:\\n\\t\\t\\t\\t\"\"\"If we break the suffix streak, remove this pointer\"\"\"\\n                self.pointer_array[i] = None\\n        if letter in self.trie:\\n            self.pointer_array.append(self.trie[letter])\\n            if self.trie[letter].get(\"END\"):\\n                found = True\\n                if len(self.trie[letter]) == 1:\\n                    self.pointer_array.pop()\\n\\t\\t\"\"\"Remove Nones.\"\"\"\\n        self.pointer_array = [p for p in self.pointer_array if p]\\n        return found\\n```\\n\\nIf you have any questions, please ask!! :)",
                "solutionTags": [
                    "Python",
                    "Trie"
                ],
                "code": "```python\\nclass StreamChecker:\\n    def __init__(self, words: List[str]):\\n\\t\"\"\"\\n\\tIn our init state, we create a trie.\\n\\tSomething like this:\\n\\t[\"tr\", \"tre\", \"q\"] => {t: {r: {\"END\": True, e: {\"END\": True}}}, q: {\"END\": True}}\\n\\t\"\"\"\\n        self.trie = {}\\n        for word in words:\\n            curr = self.trie\\n            for char in word:\\n                curr = curr.setdefault(char, {})\\n            curr[\"END\"] = True\\n        self.pointer_array = []\\n\\n    def query(self, letter: str) -> bool:\\n\\t\\t\"\"\"\\n\\t\\tNext, we just start a pointter at every new letter, venturing deeper into our trie!\\n\\t\\t\"\"\"\\n        found = False\\n        for i, p in enumerate(self.pointer_array):\\n            if letter in p:\\n                self.pointer_array[i] = p[letter]\\n                if p[letter].get(\"END\"):\\n                    found = True\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\"\"\"If we cannot venture deeper, remove this pointer\"\"\"\\n                    if len(p[letter]) == 1:\\n                        self.pointer_array[i] = None\\n            else:\\n\\t\\t\\t\\t\"\"\"If we break the suffix streak, remove this pointer\"\"\"\\n                self.pointer_array[i] = None\\n        if letter in self.trie:\\n            self.pointer_array.append(self.trie[letter])\\n            if self.trie[letter].get(\"END\"):\\n                found = True\\n                if len(self.trie[letter]) == 1:\\n                    self.pointer_array.pop()\\n\\t\\t\"\"\"Remove Nones.\"\"\"\\n        self.pointer_array = [p for p in self.pointer_array if p]\\n        return found\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1610774,
                "title": "c-using-trie-o-height-of-trie-time",
                "content": "```\\n#define pb push_back\\nclass Trie{  //Trie class\\npublic:\\n    bool is_word=false;\\n    Trie* children[26]={NULL};\\n};\\nclass StreamChecker {\\nprivate:\\n    Trie* root=NULL;\\n    vector<char>input_stream;\\n    \\n    void insert(string &word) {  //insert function\\n        Trie* cur = root;\\n        for(int i=word.size()-1;i>=0;i--){\\n            int k = word[i] - \\'a\\';\\n            if(cur->children[k]==NULL)\\n                cur->children[k]=new Trie;\\n            cur=cur->children[k];\\n        }\\n        cur->is_word=true;\\n    }\\n    \\n    bool find(){  //find function\\n        Trie* cur = root;\\n        for(int i=input_stream.size()-1;i>=0;i--){\\n            int k = input_stream[i] - \\'a\\';\\n            cur = cur->children[k];   \\n            if (cur == NULL)\\n                return false;\\n            if(cur->is_word)\\n                return true;\\n        }\\n        return false;\\n    }\\n    \\npublic:\\n    StreamChecker(vector<string>& words) {\\n        root=new Trie;\\n        for(auto i:words)\\n            insert(i);\\n    }\\n    \\n    bool query(char letter) {\\n        input_stream.pb(letter);\\n        return find();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\n#define pb push_back\\nclass Trie{  //Trie class\\npublic:\\n    bool is_word=false;\\n    Trie* children[26]={NULL};\\n};\\nclass StreamChecker {\\nprivate:\\n    Trie* root=NULL;\\n    vector<char>input_stream;\\n    \\n    void insert(string &word) {  //insert function\\n        Trie* cur = root;\\n        for(int i=word.size()-1;i>=0;i--){\\n            int k = word[i] - \\'a\\';\\n            if(cur->children[k]==NULL)\\n                cur->children[k]=new Trie;\\n            cur=cur->children[k];\\n        }\\n        cur->is_word=true;\\n    }\\n    \\n    bool find(){  //find function\\n        Trie* cur = root;\\n        for(int i=input_stream.size()-1;i>=0;i--){\\n            int k = input_stream[i] - \\'a\\';\\n            cur = cur->children[k];   \\n            if (cur == NULL)\\n                return false;\\n            if(cur->is_word)\\n                return true;\\n        }\\n        return false;\\n    }\\n    \\npublic:\\n    StreamChecker(vector<string>& words) {\\n        root=new Trie;\\n        for(auto i:words)\\n            insert(i);\\n    }\\n    \\n    bool query(char letter) {\\n        input_stream.pb(letter);\\n        return find();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1610755,
                "title": "very-clean-and-easy-to-understand-trie-c",
                "content": "```\\nclass Node{\\n    vector<Node*> links;\\n    bool flag;\\n    public:\\n    Node(){\\n        links.resize(26);\\n        flag=false;\\n    }\\n    bool contains(char c){\\n        return not (links[c-\\'a\\']==NULL);\\n    }\\n    void put(char c){\\n        links[c-\\'a\\']=new Node();\\n    }\\n    Node* get(char c){\\n        return links[c-\\'a\\'];\\n    }\\n    void setEnd(){\\n        flag=true;\\n    }\\n    bool End(){\\n        return flag;\\n    }\\n};\\nclass trie{\\n    Node* root;\\n    public:\\n    trie(){\\n        root=new Node();\\n    }\\n    void insert(string& s){\\n        Node* node=root;\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(not node->contains(s[i])){\\n                node->put(s[i]);\\n            }\\n            node=node->get(s[i]);\\n        }\\n        node->setEnd();\\n    }\\n    bool check(string &s){\\n        Node* node=root;\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(not node->contains(s[i])){\\n                return false;\\n            }\\n            node=node->get(s[i]);\\n            if(node->End())\\n                return true;\\n        }\\n        return node->End();\\n    }\\n};\\nclass StreamChecker {\\n    trie* root;\\n    string temp;\\npublic:\\n    StreamChecker(vector<string>& words) {\\n        root=new trie();\\n        for(auto &s:words){\\n            root->insert(s);\\n        }\\n    }\\n    \\n    bool query(char letter) {\\n        temp+=letter;\\n        return root->check(temp);\\n    }\\n};\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker* obj = new StreamChecker(words);\\n * bool param_1 = obj->query(letter);\\n */\\n```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass Node{\\n    vector<Node*> links;\\n    bool flag;\\n    public:\\n    Node(){\\n        links.resize(26);\\n        flag=false;\\n    }\\n    bool contains(char c){\\n        return not (links[c-\\'a\\']==NULL);\\n    }\\n    void put(char c){\\n        links[c-\\'a\\']=new Node();\\n    }\\n    Node* get(char c){\\n        return links[c-\\'a\\'];\\n    }\\n    void setEnd(){\\n        flag=true;\\n    }\\n    bool End(){\\n        return flag;\\n    }\\n};\\nclass trie{\\n    Node* root;\\n    public:\\n    trie(){\\n        root=new Node();\\n    }\\n    void insert(string& s){\\n        Node* node=root;\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(not node->contains(s[i])){\\n                node->put(s[i]);\\n            }\\n            node=node->get(s[i]);\\n        }\\n        node->setEnd();\\n    }\\n    bool check(string &s){\\n        Node* node=root;\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(not node->contains(s[i])){\\n                return false;\\n            }\\n            node=node->get(s[i]);\\n            if(node->End())\\n                return true;\\n        }\\n        return node->End();\\n    }\\n};\\nclass StreamChecker {\\n    trie* root;\\n    string temp;\\npublic:\\n    StreamChecker(vector<string>& words) {\\n        root=new trie();\\n        for(auto &s:words){\\n            root->insert(s);\\n        }\\n    }\\n    \\n    bool query(char letter) {\\n        temp+=letter;\\n        return root->check(temp);\\n    }\\n};\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker* obj = new StreamChecker(words);\\n * bool param_1 = obj->query(letter);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1610712,
                "title": "stream-of-characters-c-no-trie",
                "content": "```\\nclass StreamChecker {\\npublic:\\n    string s;\\n    vector<string> v;\\n    unordered_map<char, vector<int>> m;\\n    \\n    StreamChecker(vector<string>& words) {\\n        v=words;\\n        for(int i=0;i<words.size();i++) m[words[i].back()].push_back(i);\\n    }\\n    \\n    bool query(char letter) {\\n        s+=letter;\\n        for(auto& i:m[letter]){\\n            bool is=true;\\n            for(int j=v[i].size()-1, k=s.size()-1;j>=0;j--, k--) {\\n                if(k<0 || v[i][j]!=s[k]){\\n                    is=false;\\n                    break;\\n                }\\n            }\\n            if(is) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass StreamChecker {\\npublic:\\n    string s;\\n    vector<string> v;\\n    unordered_map<char, vector<int>> m;\\n    \\n    StreamChecker(vector<string>& words) {\\n        v=words;\\n        for(int i=0;i<words.size();i++) m[words[i].back()].push_back(i);\\n    }\\n    \\n    bool query(char letter) {\\n        s+=letter;\\n        for(auto& i:m[letter]){\\n            bool is=true;\\n            for(int j=v[i].size()-1, k=s.size()-1;j>=0;j--, k--) {\\n                if(k<0 || v[i][j]!=s[k]){\\n                    is=false;\\n                    break;\\n                }\\n            }\\n            if(is) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1610603,
                "title": "c-trie-sol-99-9",
                "content": "```\\nclass StreamChecker {\\n  string str=\"\";\\npublic:\\n  \\n  struct TrieNode{\\n    TrieNode* children[26];\\n    int ew;\\n    \\n  };\\n  \\n  struct TrieNode* getNode(){\\n    struct TrieNode* nNode=new TrieNode();\\n    for(int i=0;i<26;i++){\\n      nNode->children[i]=NULL;\\n    }\\n    \\n    nNode->ew=0;\\n    return nNode;\\n  }\\n  \\n  TrieNode* root;\\n  \\n    StreamChecker(vector<string>& words) {\\n      root=getNode();\\n      for(int i=0;i<words.size();i++)\\n      {\\n        insert(words[i]);\\n      }\\n    }\\n  \\n  void  insert(string str){\\n    TrieNode* temp=root;\\n    int l=str.length();\\n    for(int i=l-1;i>=0;i--){\\n      int index=str[i]-\\'a\\';\\n      if(temp->children[index]==NULL){\\n        temp->children[index]=getNode();\\n      }\\n      temp=temp->children[index];\\n    }\\n    temp->ew+=1;\\n  }\\n    \\n    bool query(char c) {\\n      str.push_back(c);\\n      return CheckSuffix();\\n    }\\n\\n  \\n    bool CheckSuffix(){\\n      TrieNode* temp=root;\\n      int l=str.length();\\n      for(int i=l-1;i>=0;i--){\\n        int index=str[i]-\\'a\\';\\n        if(temp->children[index]==NULL)\\n          return false;\\n    \\n\\t  if(temp->ew>=1)\\n\\t  return true;\\n\\t  \\n        temp=temp->children[index];\\n        if(temp->ew>=1)\\n          return true;\\n      }\\n     \\n      return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```\\nclass StreamChecker {\\n  string str=\"\";\\npublic:\\n  \\n  struct TrieNode{\\n    TrieNode* children[26];\\n    int ew;\\n    \\n  };\\n  \\n  struct TrieNode* getNode(){\\n    struct TrieNode* nNode=new TrieNode();\\n    for(int i=0;i<26;i++){\\n      nNode->children[i]=NULL;\\n    }\\n    \\n    nNode->ew=0;\\n    return nNode;\\n  }\\n  \\n  TrieNode* root;\\n  \\n    StreamChecker(vector<string>& words) {\\n      root=getNode();\\n      for(int i=0;i<words.size();i++)\\n      {\\n        insert(words[i]);\\n      }\\n    }\\n  \\n  void  insert(string str){\\n    TrieNode* temp=root;\\n    int l=str.length();\\n    for(int i=l-1;i>=0;i--){\\n      int index=str[i]-\\'a\\';\\n      if(temp->children[index]==NULL){\\n        temp->children[index]=getNode();\\n      }\\n      temp=temp->children[index];\\n    }\\n    temp->ew+=1;\\n  }\\n    \\n    bool query(char c) {\\n      str.push_back(c);\\n      return CheckSuffix();\\n    }\\n\\n  \\n    bool CheckSuffix(){\\n      TrieNode* temp=root;\\n      int l=str.length();\\n      for(int i=l-1;i>=0;i--){\\n        int index=str[i]-\\'a\\';\\n        if(temp->children[index]==NULL)\\n          return false;\\n    \\n\\t  if(temp->ew>=1)\\n\\t  return true;\\n\\t  \\n        temp=temp->children[index];\\n        if(temp->ew>=1)\\n          return true;\\n      }\\n     \\n      return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1610590,
                "title": "java-trie-based-simple-solution",
                "content": "```\\nclass StreamChecker {\\n    \\n    //inner trie class\\n    class Trie{\\n        Trie[] tries;\\n        boolean isEnding;\\n         public Trie(){\\n             tries = new Trie[26];\\n             isEnding = false;\\n         }\\n    }\\n    \\n    StringBuilder sb;\\n    Trie parent;\\n    public StreamChecker(String[] words) {\\n        sb = new StringBuilder();\\n        parent = new Trie();\\n        for(String s : words){\\n            Trie root = parent;\\n            for(int i = s.length()-1; i >= 0; i--){\\n                if(root.tries[s.charAt(i)-\\'a\\'] == null){\\n                    root.tries[s.charAt(i)-\\'a\\'] = new Trie();\\n                }\\n                root = root.tries[s.charAt(i)-\\'a\\'];\\n            }\\n            root.isEnding = true;\\n        }\\n        \\n    }\\n    \\n    public boolean query(char letter) {\\n        sb.append(letter);\\n        Trie root = parent;\\n        for(int i = sb.length()-1; i >= 0; i--){\\n            if(root.tries[sb.charAt(i)-\\'a\\'] == null) return false;\\n            if(root.tries[sb.charAt(i)-\\'a\\'].isEnding) return true;\\n            root = root.tries[sb.charAt(i)-\\'a\\'];\\n        }\\n        \\n        return false;\\n    }\\n}\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker obj = new StreamChecker(words);\\n * boolean param_1 = obj.query(letter);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass StreamChecker {\\n    \\n    //inner trie class\\n    class Trie{\\n        Trie[] tries;\\n        boolean isEnding;\\n         public Trie(){\\n             tries = new Trie[26];\\n             isEnding = false;\\n         }\\n    }\\n    \\n    StringBuilder sb;\\n    Trie parent;\\n    public StreamChecker(String[] words) {\\n        sb = new StringBuilder();\\n        parent = new Trie();\\n        for(String s : words){\\n            Trie root = parent;\\n            for(int i = s.length()-1; i >= 0; i--){\\n                if(root.tries[s.charAt(i)-\\'a\\'] == null){\\n                    root.tries[s.charAt(i)-\\'a\\'] = new Trie();\\n                }\\n                root = root.tries[s.charAt(i)-\\'a\\'];\\n            }\\n            root.isEnding = true;\\n        }\\n        \\n    }\\n    \\n    public boolean query(char letter) {\\n        sb.append(letter);\\n        Trie root = parent;\\n        for(int i = sb.length()-1; i >= 0; i--){\\n            if(root.tries[sb.charAt(i)-\\'a\\'] == null) return false;\\n            if(root.tries[sb.charAt(i)-\\'a\\'].isEnding) return true;\\n            root = root.tries[sb.charAt(i)-\\'a\\'];\\n        }\\n        \\n        return false;\\n    }\\n}\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker obj = new StreamChecker(words);\\n * boolean param_1 = obj.query(letter);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1610553,
                "title": "rust-solution",
                "content": "```\\nuse std::collections::HashSet;\\n\\nstruct StreamChecker {\\n    data: Vec<String>,\\n    last_char: HashSet<char>,\\n    word_check: String\\n}\\n\\nimpl StreamChecker {\\n    fn new(words: Vec<String>) -> Self {\\n        let mut temp: HashSet<char> = HashSet::new();\\n        for word in &words {\\n            temp.insert(word.chars().nth(word.len()-1).unwrap());\\n        }\\n        Self {\\n            data: words,\\n            last_char: temp,\\n            word_check: String::new()\\n        }\\n    }\\n    \\n    fn query(&mut self, letter: char) -> bool {\\n        self.word_check.push(letter);\\n        if self.last_char.contains(&letter) {\\n            let len_word = self.word_check.len();\\n            for word in &self.data {\\n                if word.chars().nth(word.len()-1).unwrap() == letter {\\n                    let len = word.len();\\n                    if len > len_word {\\n                        continue;\\n                    }\\n                    let temp_word: String = self.word_check[(len_word-len)..len_word].to_string();\\n                    if *word == temp_word {\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashSet;\\n\\nstruct StreamChecker {\\n    data: Vec<String>,\\n    last_char: HashSet<char>,\\n    word_check: String\\n}\\n\\nimpl StreamChecker {\\n    fn new(words: Vec<String>) -> Self {\\n        let mut temp: HashSet<char> = HashSet::new();\\n        for word in &words {\\n            temp.insert(word.chars().nth(word.len()-1).unwrap());\\n        }\\n        Self {\\n            data: words,\\n            last_char: temp,\\n            word_check: String::new()\\n        }\\n    }\\n    \\n    fn query(&mut self, letter: char) -> bool {\\n        self.word_check.push(letter);\\n        if self.last_char.contains(&letter) {\\n            let len_word = self.word_check.len();\\n            for word in &self.data {\\n                if word.chars().nth(word.len()-1).unwrap() == letter {\\n                    let len = word.len();\\n                    if len > len_word {\\n                        continue;\\n                    }\\n                    let temp_word: String = self.word_check[(len_word-len)..len_word].to_string();\\n                    if *word == temp_word {\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1610449,
                "title": "c-easy-solution",
                "content": "```\\nclass Node{\\n    public:\\n        char letter;\\n        Node *childs[26];\\n        bool isWordEnd = false; \\n        Node(char letter){\\n            this->letter = letter;\\n            for(int i=0;i<26;i++) childs[i] = NULL;\\n        }\\n};\\n\\nclass StreamChecker {\\npublic:\\n    vector<string> words;\\n    string stream;\\n    Node *root = new Node(\\'0\\');\\n    \\n    StreamChecker(vector<string>& words) {\\n        this->words = words, this->stream=\"\";\\n        root= new Node(\\'0\\');\\n        root->letter=\\'0\\';\\n        for(auto s:words)\\n            insert(s);\\n    }\\n    \\n    bool query(char letter) {\\n        \\n        Node *node = root;\\n        stream += letter;\\n        char c;\\n        for(int i=stream.length()-1;i>=0;i--){\\n            c=stream[i];\\n            \\n            if( node->childs[c-97] == NULL || node->isWordEnd) break;\\n            else node = node->childs[c-97];\\n            \\n        }\\n        return node->isWordEnd; \\n    }\\n    \\n    \\n    void insert(string &s){\\n        Node *node = root;\\n        char c;\\n        for(int i=s.length()-1;i>=0;i--){\\n            c = s[i];\\n            if( node->childs[c-97] == NULL ){\\n                Node *newNode = new Node(c);\\n                node->childs[c-97] = newNode;\\n            }\\n            node = node->childs[c-97];\\n        }\\n        node->isWordEnd = true;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "String",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Node{\\n    public:\\n        char letter;\\n        Node *childs[26];\\n        bool isWordEnd = false; \\n        Node(char letter){\\n            this->letter = letter;\\n            for(int i=0;i<26;i++) childs[i] = NULL;\\n        }\\n};\\n\\nclass StreamChecker {\\npublic:\\n    vector<string> words;\\n    string stream;\\n    Node *root = new Node(\\'0\\');\\n    \\n    StreamChecker(vector<string>& words) {\\n        this->words = words, this->stream=\"\";\\n        root= new Node(\\'0\\');\\n        root->letter=\\'0\\';\\n        for(auto s:words)\\n            insert(s);\\n    }\\n    \\n    bool query(char letter) {\\n        \\n        Node *node = root;\\n        stream += letter;\\n        char c;\\n        for(int i=stream.length()-1;i>=0;i--){\\n            c=stream[i];\\n            \\n            if( node->childs[c-97] == NULL || node->isWordEnd) break;\\n            else node = node->childs[c-97];\\n            \\n        }\\n        return node->isWordEnd; \\n    }\\n    \\n    \\n    void insert(string &s){\\n        Node *node = root;\\n        char c;\\n        for(int i=s.length()-1;i>=0;i--){\\n            c = s[i];\\n            if( node->childs[c-97] == NULL ){\\n                Node *newNode = new Node(c);\\n                node->childs[c-97] = newNode;\\n            }\\n            node = node->childs[c-97];\\n        }\\n        node->isWordEnd = true;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1610437,
                "title": "c-trie-dictionary-tree",
                "content": "Approach 1: Trie [1]\\nTime complexity:\\nbuild O(sum(len(w))\\nquery O(max(len(w))\\n\\nSpace complexity: O(sum(len(w))\\n```\\nclass StreamChecker {\\npublic:\\n    StreamChecker(vector<string>& words) {\\n        for (const string& word : words) {\\n            TrieNode *node = root;\\n            for (int i = word.size() - 1; i >= 0; --i) { //Reversed storing info in trie\\n                if (!node->next[word[i] - \\'a\\']) {\\n                    node->next[word[i] - \\'a\\'] = new TrieNode();\\n                }\\n                node = node->next[word[i] - \\'a\\'];\\n            }\\n            node->isWord = true;\\n        }\\n    }\\n    \\n    bool query(char letter) {\\n        queryStr+=letter;        \\n        TrieNode *node = root;\\n        for (int i = queryStr.size() - 1; i >= 0 && node; --i) { //Reversed searching\\n            node = node->next[queryStr[i] - \\'a\\'];\\n            if (node && node->isWord) return true;\\n        }\\n        return false;\\n    }\\n    \\nprivate:\\n    struct TrieNode {\\n        bool isWord;\\n        TrieNode *next[26];\\n    };\\n    \\n    TrieNode *root = new TrieNode();\\n    string queryStr;\\n};\\n```\\nReference:\\n[1] https://www.cnblogs.com/grandyang/p/14406525.html",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass StreamChecker {\\npublic:\\n    StreamChecker(vector<string>& words) {\\n        for (const string& word : words) {\\n            TrieNode *node = root;\\n            for (int i = word.size() - 1; i >= 0; --i) { //Reversed storing info in trie\\n                if (!node->next[word[i] - \\'a\\']) {\\n                    node->next[word[i] - \\'a\\'] = new TrieNode();\\n                }\\n                node = node->next[word[i] - \\'a\\'];\\n            }\\n            node->isWord = true;\\n        }\\n    }\\n    \\n    bool query(char letter) {\\n        queryStr+=letter;        \\n        TrieNode *node = root;\\n        for (int i = queryStr.size() - 1; i >= 0 && node; --i) { //Reversed searching\\n            node = node->next[queryStr[i] - \\'a\\'];\\n            if (node && node->isWord) return true;\\n        }\\n        return false;\\n    }\\n    \\nprivate:\\n    struct TrieNode {\\n        bool isWord;\\n        TrieNode *next[26];\\n    };\\n    \\n    TrieNode *root = new TrieNode();\\n    string queryStr;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1569715,
                "title": "2000-2",
                "content": "[\\u0421\\u0441\\u044B\\u043B\\u043A\\u0430 \\u043D\\u0430 \\u0410\\u0445\\u043E \\u041A\\u043E\\u0440\\u0430\\u0441\\u0438\\u043A \\u0430\\u043B\\u0433\\u043E\\u0440\\u0438\\u0442\\u043C](https://e-maxx.ru/algo/aho_corasick)\\n\\n\\u041F\\u0430\\u0446\\u0430\\u043D\\u044B \\u0441 \\u043B\\u0438\\u0442\\u043A\\u043E\\u0434\\u0430 \\u043F\\u0440\\u0438\\u0444\\u0438\\u0433\\u0435\\u043B\\u0438 \\u0434\\u0430\\u044E\\u0442 \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u0435 \\u0441 Trie \\u043A\\u043E\\u0433\\u0434\\u0430 \\u043E\\u0447\\u0435\\u0432\\u0438\\u0434\\u043D\\u043E \\u043E\\u043D\\u043E \\u0434\\u043E\\u043B\\u0436\\u043D\\u043E \\u0442\\u0430\\u0439\\u043C \\u043B\\u0438\\u043C\\u0438\\u0442\\u0438\\u0442\\u044C. \\u041D\\u0430\\u043F\\u0440\\u0438\\u043C\\u0435\\u0440, \\u0440\\u0430\\u0441\\u043C\\u043E\\u0442\\u0440\\u0438\\u0442\\u0435 \\u0440\\u0430\\u043D\\u0434\\u043E\\u043C\\u043D\\u0443\\u044E \\u0441\\u0442\\u0440\\u043E\\u043A\\u0443 `\\u0441\\u0442\\u04401` \\u0438\\u0437 2000 \\u0431\\u0443\\u043A\\u0432, \\u0441\\u0433\\u0435\\u043D\\u0435\\u0440\\u044C\\u0442\\u0435 \\u0438\\u0437 \\u043D\\u0435\\u0435 2000 \\u0441\\u0434\\u0432\\u0438\\u0433\\u043E\\u0432 \\u0438 \\u0441\\u043E\\u0437\\u0434\\u0430\\u0439\\u0442\\u0435 \\u0441\\u0432\\u043E\\u0439 \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432 words. \\u0422\\u0435\\u043F\\u0435\\u0440\\u044C \\u0438\\u043D\\u0441\\u0435\\u0440\\u0442\\u044F \\u043A\\u0430\\u0436\\u0434\\u0443\\u044E \\u0431\\u0443\\u043A\\u0432\\u0443 \\u0438\\u043D\\u0441\\u0435\\u0440\\u0442\\u044C\\u0442\\u0435 \\u043F\\u043E \\u043A\\u0440\\u0443\\u0433\\u043E\\u0432\\u0443\\u044E \\u0441\\u0432\\u043E\\u044E `\\u0441\\u0442\\u04401` \\u043A\\u0430\\u0436\\u0434\\u044B\\u0435 \\u043F\\u043E\\u0441\\u043B\\u0435\\u0434\\u043D\\u0438\\u0435 2000 \\u0431\\u0443\\u043A\\u0432 \\u0431\\u0443\\u0434\\u0443\\u0442 \\u0441\\u043E\\u0432\\u043F\\u0430\\u0434\\u0430\\u0442\\u044C \\u0441 \\u043A\\u0430\\u043A\\u0438\\u043C \\u0442\\u043E \\u0441\\u043B\\u043E\\u0432\\u043E\\u043C \\u0438\\u0437 \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432\\u0430 words (\\u0442\\u043A \\u043C\\u044B \\u0438\\u0445 \\u0441\\u0433\\u0435\\u043D\\u0435\\u0440\\u0438\\u043B\\u0438 \\u0441\\u0434\\u0432\\u0438\\u0433\\u0430\\u043C\\u0438, \\u0430 \\u0431\\u0443\\u043A\\u0432\\u044B \\u0438\\u043D\\u0441\\u0435\\u0440\\u0442\\u0438\\u043C \\u043F\\u043E \\u043A\\u0440\\u0443\\u0433\\u043E\\u0432\\u0443\\u044E (\\u043F\\u043E \\u043C\\u043E\\u0434\\u0443\\u043B\\u044E 2000) \\u0438\\u0437 `\\u0441\\u0442\\u04401`. \\u0422\\u0430\\u043A\\u0438\\u043C \\u043E\\u0431\\u0440\\u0430\\u0437\\u043E\\u043C \\u0438\\u043D\\u0441\\u0435\\u0440\\u0442\\u044F \\u043D\\u043E\\u0432\\u0443\\u044E \\u0431\\u0443\\u043A\\u0432\\u0443 \\u043D\\u0430 \\u0441\\u0432\\u043E\\u0435\\u043C Trie \\u043A\\u0430\\u0436\\u0434\\u044B\\u0439 \\u0440\\u0430\\u0437 2000 \\u0438\\u0442\\u0435\\u0440\\u0430\\u0446\\u0438\\u0438 \\u0431\\u0443\\u0434\\u0435\\u043C \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C. \\u0422\\u043E \\u0435\\u0441\\u0442\\u044C \\u043E\\u0447\\u0435\\u0432\\u0438\\u0434\\u043D\\u044B\\u0439 \\u0442\\u0430\\u0439\\u043C \\u043B\\u0438\\u043C\\u0438\\u0442 2000 * 4 * 10 ^ 4. \\n\\n\\u041A\\u043E\\u043D\\u0435\\u0447\\u043D\\u043E, \\u044F \\u044D\\u0442\\u043E \\u043F\\u043E\\u043D\\u044F\\u043B \\u0438 \\u0447\\u0435\\u043A\\u0430\\u043B \\u043D\\u0430 e-maxx \\u0430\\u043B\\u0433\\u043E\\u0441\\u044B \\u043A\\u043E\\u0442\\u043E\\u0440\\u044B\\u0435 \\u0441\\u043F\\u0440\\u0430\\u0432\\u043B\\u044F\\u044E\\u0442\\u0441\\u044F \\u0441 \\u0442\\u0430\\u043A\\u0438\\u043C\\u0438 \\u0437\\u0430\\u043F\\u0440\\u043E\\u0441\\u0430\\u043C\\u0438. \\u041A\\u043E\\u0440\\u043E\\u0447\\u0435 \\u0432 \\u0410\\u0445\\u043E \\u041A\\u043E\\u0440\\u0430\\u0441\\u0438\\u043A\\u0435 \\u043F\\u0440\\u0435\\u043F\\u0440\\u043E\\u0446\\u0435\\u0441\\u0441\\u0438\\u043D\\u0433 \\u0434\\u0435\\u043B\\u0430\\u0435\\u0442\\u0441\\u044F \\u0437\\u0430 2000 * 2000 \\u043E\\u043F\\u0435\\u0440\\u0430\\u0446\\u0438\\u0439. \\u0414\\u0430\\u043B\\u044C\\u0448\\u0435 \\u043A\\u0430\\u0436\\u0434\\u0430\\u044F \\u043E\\u043F\\u0435\\u0440\\u0430\\u0446\\u0438\\u044F \\u0434\\u043E\\u0431\\u0430\\u0432\\u043B\\u0435\\u043D\\u0438\\u044F \\u0431\\u0443\\u043A\\u0432\\u044B \\u043E\\u0431\\u0440\\u0430\\u0431\\u0430\\u0442\\u044B\\u0432\\u0430\\u0435\\u0442\\u0441\\u044F \\u0437\\u0430 \\u043A\\u043E\\u043D\\u0441\\u0442\\u0430\\u043D\\u0442\\u0443. \\u0410\\u0445\\u043E \\u041A\\u043E\\u0440\\u0430\\u0441\\u0438\\u043A \\u044D\\u0442\\u043E \\u043A\\u0430\\u043A \\u043E\\u043D\\u043B\\u0430\\u0439\\u043D\\u043E\\u0432\\u044B\\u0439 KMP \\u0430\\u043B\\u0433\\u043E\\u0440\\u0438\\u0442\\u043C, \\u043A\\u043E\\u0442\\u043E\\u0440\\u044B\\u0439 \\u0447\\u0435\\u043A\\u0430\\u0435\\u0442 \\u0441\\u043E\\u0432\\u043F\\u0430\\u0434\\u0430\\u0435\\u0442 \\u043B\\u0438 \\u0441\\u0443\\u0444\\u0444\\u0438\\u043A\\u0441 \\u0441 \\u043F\\u0440\\u0435\\u0444\\u0438\\u043A\\u0441\\u043E\\u043C (\\u0433\\u0434\\u0435 \\u043F\\u0440\\u0435\\u0444\\u0438\\u043A\\u0441 \\u0432\\u0430\\u0448\\u0430 \\u0441\\u0442\\u0440\\u043E\\u043A\\u0430 \\u0438\\u0437 \\u0441\\u043B\\u043E\\u0432\\u0430\\u0440\\u044F). \\u0422\\u043E\\u043B\\u044C\\u043A\\u043E \\u0438\\u0437\\u043D\\u0430\\u0447\\u0430\\u043B\\u044C\\u043D\\u044B\\u0439 \\u043F\\u0440\\u0435\\u0444\\u0438\\u043A\\u0441 \\u044D\\u0442\\u043E \\u0443 \\u0432\\u0430\\u0441 \\u043D\\u0435 \\u043E\\u0434\\u043D\\u0430 \\u0441\\u0442\\u0440\\u043E\\u043A\\u0430, \\u0430 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E \\u043F\\u043E\\u0441\\u0442\\u0440\\u043E\\u0435\\u043D\\u043D\\u043E\\u0435 \\u043D\\u0430 \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432\\u0435 \\u0441\\u0442\\u0440\\u043E\\u043A (\\u0441\\u043B\\u043E\\u0432 \\u0438\\u0437 \\u0441\\u043B\\u043E\\u0432\\u0430\\u0440\\u044F). \\u0412\\u043E\\u0442 \\u0410\\u0445\\u043E \\u041A\\u043E\\u0440\\u0430\\u0441\\u0438\\u043A \\u043F\\u0435\\u0440\\u0435\\u043F\\u0438\\u0441\\u0430\\u043D\\u043D\\u044B\\u0439 \\u043D\\u0430 \\u041F\\u0438\\u0442\\u043E\\u043D.\\n\\n```\\nclass Vertex:\\n    def __init__(self, p = -1, pch = \\'#\\'):\\n        self.next = {}\\n        self.leaf = False\\n        self.p = p\\n        self.pch = pch\\n        self.link = -1\\n        self.go = {}\\n\\n\\nclass Bor:\\n    def __init__(self):\\n        self.t = [Vertex()]\\n        self.memo_leaf = {}\\n\\n    def add_string(self, s):\\n        v = 0\\n        for ch in s:\\n            if ch not in self.t[v].next:\\n                self.t[v].next[ch] = len(self.t)\\n                self.t.append(Vertex(v, ch))\\n            v = self.t[v].next[ch]\\n        self.t[v].leaf = True\\n\\n    def go(self, v, c):\\n        if c not in self.t[v].go:\\n            if c in self.t[v].next:\\n                self.t[v].go[c] = self.t[v].next[c]\\n            else:\\n                self.t[v].go[c] = self.go(self.get_link(v), c) if v != 0 else 0\\n        return self.t[v].go[c]\\n\\n    def get_link(self, v):\\n        if self.t[v].link == -1:\\n            if v == 0 or self.t[v].p == 0:\\n                self.t[v].link = 0\\n            else:\\n                self.t[v].link = self.go(self.get_link(self.t[v].p), self.t[v].pch)\\n        return self.t[v].link\\n\\n    def is_leaf(self, v):\\n        if v not in self.memo_leaf:\\n            self.memo_leaf[v] = v != 0 and (self.t[v].leaf or self.is_leaf(self.get_link(v)))\\n        return self.memo_leaf[v]\\n\\n\\nclass StreamChecker:\\n    def __init__(self, words):\\n        self.bor = Bor()\\n        for w in words:\\n            self.bor.add_string(w)\\n        self.v = 0\\n\\n    def query(self, letter):\\n        self.v = self.bor.go(self.v, letter)\\n        return self.bor.is_leaf(self.v)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Vertex:\\n    def __init__(self, p = -1, pch = \\'#\\'):\\n        self.next = {}\\n        self.leaf = False\\n        self.p = p\\n        self.pch = pch\\n        self.link = -1\\n        self.go = {}\\n\\n\\nclass Bor:\\n    def __init__(self):\\n        self.t = [Vertex()]\\n        self.memo_leaf = {}\\n\\n    def add_string(self, s):\\n        v = 0\\n        for ch in s:\\n            if ch not in self.t[v].next:\\n                self.t[v].next[ch] = len(self.t)\\n                self.t.append(Vertex(v, ch))\\n            v = self.t[v].next[ch]\\n        self.t[v].leaf = True\\n\\n    def go(self, v, c):\\n        if c not in self.t[v].go:\\n            if c in self.t[v].next:\\n                self.t[v].go[c] = self.t[v].next[c]\\n            else:\\n                self.t[v].go[c] = self.go(self.get_link(v), c) if v != 0 else 0\\n        return self.t[v].go[c]\\n\\n    def get_link(self, v):\\n        if self.t[v].link == -1:\\n            if v == 0 or self.t[v].p == 0:\\n                self.t[v].link = 0\\n            else:\\n                self.t[v].link = self.go(self.get_link(self.t[v].p), self.t[v].pch)\\n        return self.t[v].link\\n\\n    def is_leaf(self, v):\\n        if v not in self.memo_leaf:\\n            self.memo_leaf[v] = v != 0 and (self.t[v].leaf or self.is_leaf(self.get_link(v)))\\n        return self.memo_leaf[v]\\n\\n\\nclass StreamChecker:\\n    def __init__(self, words):\\n        self.bor = Bor()\\n        for w in words:\\n            self.bor.add_string(w)\\n        self.v = 0\\n\\n    def query(self, letter):\\n        self.v = self.bor.go(self.v, letter)\\n        return self.bor.is_leaf(self.v)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1552056,
                "title": "python",
                "content": "1) Discard \"inclusive\" `words`, for example from `aaaaabc` and `abc` stay just `abc`.\\n2) Build total resulted phrase and check it each time with `endswith` for each of our words.\\n```\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        \\n        self.phrase = \\'\\'\\n        self.words = []\\n        \\n        for word in sorted(words,key = len):\\n            word_founded = False\\n            for _word in self.words:\\n                if word.endswith(_word):\\n                    word_founded = True\\n                    break\\n            if word_founded:\\n                continue\\n            self.words.append(word)\\n        \\n        \\n\\n    def query(self, letter: str) -> bool:\\n        \\n        self.phrase += letter\\n        \\n        return any([self.phrase.endswith(word) for word in self.words])\\n```",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        \\n        self.phrase = \\'\\'\\n        self.words = []\\n        \\n        for word in sorted(words,key = len):\\n            word_founded = False\\n            for _word in self.words:\\n                if word.endswith(_word):\\n                    word_founded = True\\n                    break\\n            if word_founded:\\n                continue\\n            self.words.append(word)\\n        \\n        \\n\\n    def query(self, letter: str) -> bool:\\n        \\n        self.phrase += letter\\n        \\n        return any([self.phrase.endswith(word) for word in self.words])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1377982,
                "title": "aho-corasick-implementation-with-trie",
                "content": "This problem is a typical application of aho corasick algorithm. Here, I have implemented Aho-corasick with the help of trie. \\n```\\nclass TrieNode{\\n        public:\\n  TrieNode *adj[26];\\n  TrieNode *failure;\\n    bool isEnd;\\n\\n    TrieNode() {\\n        for(int i = 0;i<26;i++){\\n            adj[i]=NULL;\\n            failure = NULL;\\n            isEnd=false;\\n        }\\n    }\\n};\\nvoid insert(TrieNode *root, string s){\\n    TrieNode *tmp = root;\\n    for(char c : s) {\\n        if(tmp->adj[c-\\'a\\']==NULL){\\n            tmp->adj[c-\\'a\\'] = new TrieNode();\\n        }\\n        tmp = tmp->adj[c-\\'a\\'];\\n    }\\n    tmp->isEnd = true;\\n}\\n\\nvoid build(TrieNode *root) {\\n    root->failure = root;\\n    queue<TrieNode*> q;\\n    for(int i = 0;i<26;i++){\\n        if(root->adj[i]!=NULL){\\n            root->adj[i]->failure = root;\\n            q.push(root->adj[i]);\\n        }else{\\n            root->adj[i] = root;\\n        }\\n    }\\n    while(!q.empty()) {\\n        TrieNode* u = q.front();\\n        q.pop();\\n        for(int i = 0;i<26;i++) {\\n            if(u->adj[i]!=NULL) {\\n                TrieNode *failure = u->failure;\\n                while(failure->adj[i]==NULL){\\n                    failure = failure->failure;\\n                }\\n                failure = failure->adj[i];\\n                u->adj[i]->failure = failure;\\n                u->adj[i]->isEnd = u->adj[i]->isEnd || failure->isEnd;\\n                q.push(u->adj[i]);\\n            }\\n        }\\n    }\\n}\\nclass StreamChecker {\\npublic:\\n    TrieNode *root;\\n    TrieNode *curr;\\n    StreamChecker(vector<string>& words) {\\n        root = new TrieNode();\\n        for(string s:words){\\n            insert(root,s);\\n        }\\n        build(root);\\n        curr = root;\\n    }\\n    \\n    bool query(char letter) {\\n        \\n        while(curr->adj[letter-\\'a\\']==NULL)\\n            curr = curr->failure;\\n        curr = curr->adj[letter-\\'a\\'];\\n        return curr->isEnd;\\n    }\\n};\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker* obj = new StreamChecker(words);\\n * bool param_1 = obj->query(letter);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode{\\n        public:\\n  TrieNode *adj[26];\\n  TrieNode *failure;\\n    bool isEnd;\\n\\n    TrieNode() {\\n        for(int i = 0;i<26;i++){\\n            adj[i]=NULL;\\n            failure = NULL;\\n            isEnd=false;\\n        }\\n    }\\n};\\nvoid insert(TrieNode *root, string s){\\n    TrieNode *tmp = root;\\n    for(char c : s) {\\n        if(tmp->adj[c-\\'a\\']==NULL){\\n            tmp->adj[c-\\'a\\'] = new TrieNode();\\n        }\\n        tmp = tmp->adj[c-\\'a\\'];\\n    }\\n    tmp->isEnd = true;\\n}\\n\\nvoid build(TrieNode *root) {\\n    root->failure = root;\\n    queue<TrieNode*> q;\\n    for(int i = 0;i<26;i++){\\n        if(root->adj[i]!=NULL){\\n            root->adj[i]->failure = root;\\n            q.push(root->adj[i]);\\n        }else{\\n            root->adj[i] = root;\\n        }\\n    }\\n    while(!q.empty()) {\\n        TrieNode* u = q.front();\\n        q.pop();\\n        for(int i = 0;i<26;i++) {\\n            if(u->adj[i]!=NULL) {\\n                TrieNode *failure = u->failure;\\n                while(failure->adj[i]==NULL){\\n                    failure = failure->failure;\\n                }\\n                failure = failure->adj[i];\\n                u->adj[i]->failure = failure;\\n                u->adj[i]->isEnd = u->adj[i]->isEnd || failure->isEnd;\\n                q.push(u->adj[i]);\\n            }\\n        }\\n    }\\n}\\nclass StreamChecker {\\npublic:\\n    TrieNode *root;\\n    TrieNode *curr;\\n    StreamChecker(vector<string>& words) {\\n        root = new TrieNode();\\n        for(string s:words){\\n            insert(root,s);\\n        }\\n        build(root);\\n        curr = root;\\n    }\\n    \\n    bool query(char letter) {\\n        \\n        while(curr->adj[letter-\\'a\\']==NULL)\\n            curr = curr->failure;\\n        curr = curr->adj[letter-\\'a\\'];\\n        return curr->isEnd;\\n    }\\n};\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker* obj = new StreamChecker(words);\\n * bool param_1 = obj->query(letter);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1313458,
                "title": "trie-c-clean-code",
                "content": "```\\nclass StreamChecker {\\npublic:\\n    \\n    struct trie{\\n        struct trie *ch[26];\\n        bool isend;\\n        trie()\\n        {\\n            memset(ch,0,sizeof(ch));\\n            isend=false;\\n        }\\n    };\\n    \\n    \\n    struct trie *root=new trie;\\n    string tm;\\n    int mx=0;\\n    \\n    void insert(string s)\\n    {\\n        struct trie *tmp=root;\\n        for(auto x:s)\\n        {\\n            int idx=x-\\'a\\';\\n            if(tmp->ch[idx]==NULL)\\n            {\\n                tmp->ch[idx]=new trie;\\n            }\\n            tmp=tmp->ch[idx];\\n        }\\n        tmp->isend=true;\\n    }\\n    \\n    bool find(string tm)\\n    {\\n        struct trie *tmp=root;\\n        for(auto x:tm)\\n        {\\n            int idx=x-\\'a\\';\\n            if(tmp->isend)\\n            {\\n                return tmp->isend;\\n            }\\n            if(tmp->ch[idx]==NULL)\\n            {\\n                return tmp->isend;\\n            }\\n            tmp=tmp->ch[idx];\\n            \\n        }\\n        return (tmp->isend);\\n    }\\n    \\n    \\n    StreamChecker(vector<string>& words) {\\n        for(auto x:words)\\n        {\\n            string y=x;\\n            reverse(y.begin(),y.end());\\n            mx=max(mx,(int)y.length());\\n            insert(y);\\n        }\\n        tm=\"\";\\n    }\\n    \\n    bool query(char letter) {\\n        tm=letter+tm;\\n        if(tm.length()>mx)\\n        {\\n            tm.pop_back();\\n        }\\n        return find(tm);\\n    }\\n};\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker* obj = new StreamChecker(words);\\n * bool param_1 = obj->query(letter);\\n */\\n```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass StreamChecker {\\npublic:\\n    \\n    struct trie{\\n        struct trie *ch[26];\\n        bool isend;\\n        trie()\\n        {\\n            memset(ch,0,sizeof(ch));\\n            isend=false;\\n        }\\n    };\\n    \\n    \\n    struct trie *root=new trie;\\n    string tm;\\n    int mx=0;\\n    \\n    void insert(string s)\\n    {\\n        struct trie *tmp=root;\\n        for(auto x:s)\\n        {\\n            int idx=x-\\'a\\';\\n            if(tmp->ch[idx]==NULL)\\n            {\\n                tmp->ch[idx]=new trie;\\n            }\\n            tmp=tmp->ch[idx];\\n        }\\n        tmp->isend=true;\\n    }\\n    \\n    bool find(string tm)\\n    {\\n        struct trie *tmp=root;\\n        for(auto x:tm)\\n        {\\n            int idx=x-\\'a\\';\\n            if(tmp->isend)\\n            {\\n                return tmp->isend;\\n            }\\n            if(tmp->ch[idx]==NULL)\\n            {\\n                return tmp->isend;\\n            }\\n            tmp=tmp->ch[idx];\\n            \\n        }\\n        return (tmp->isend);\\n    }\\n    \\n    \\n    StreamChecker(vector<string>& words) {\\n        for(auto x:words)\\n        {\\n            string y=x;\\n            reverse(y.begin(),y.end());\\n            mx=max(mx,(int)y.length());\\n            insert(y);\\n        }\\n        tm=\"\";\\n    }\\n    \\n    bool query(char letter) {\\n        tm=letter+tm;\\n        if(tm.length()>mx)\\n        {\\n            tm.pop_back();\\n        }\\n        return find(tm);\\n    }\\n};\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker* obj = new StreamChecker(words);\\n * bool param_1 = obj->query(letter);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1171602,
                "title": "java-my-solution-with-rolling-hash",
                "content": "The gist of this solution is to calculate the rolling hash of each word, and map that hash value to the set of words which share that hash value (for a good hash function, different words having the same hash shouldn\\'t happen often). In addition to this, we\\'ll calculate the rolling hash for *all* of the suffixes in the word (e.g. for `\"abc\"` we would calculate/store the hashes for `\"abc\"`, `\"bc\"`, and `\"c\"`. If we move from the end of the stream backwards, this will allow us to quickly check whether or not each given suffix might actually exist, and if not, prevent unnecessarily checking other \"substrings\" in the stream which can not possibly be contained in our set of valid words.\\n\\nAfter this initialization, whenever we call query, we will add the new character to the end of the character list, then work backwards to calculate a rolling hash while at the same time incrementally building a string. If we find a hash value that exists in our `wordHash` map, we can then check if the currently-constructed string exists in the set of words mapped to by that hash value, and if so, return true. If we reach the first character in the stream (or exceed the length of the longest word in our set) we return false. \\n\\nHere is my code:\\n\\n```\\nclass StreamChecker {\\n    static final int MOD = 100000007;\\n    int maxLen;\\n    Set<Integer> suffixes;\\n    Map<Integer, Set<String>> wordMap;\\n    List<Character> stream;\\n    public StreamChecker(String[] words) {\\n        maxLen = 0;\\n        suffixes = new HashSet<>();\\n        wordMap = new HashMap<>();\\n        for(String w : words) {\\n            addRollingHash(w);\\n            maxLen = Math.max(maxLen, w.length());\\n        }\\n        stream = new LinkedList<>();\\n    }\\n    \\n    public boolean query(char c) {\\n        stream.add(c);\\n        if(stream.size() > maxLen) {\\n            stream.remove(0);\\n        }\\n        String s = \"\";\\n        int hash = 0;\\n        for(int i = stream.size()-1; i >= 0; --i) {\\n            s = stream.get(i) + s;\\n            int v = (int) stream.get(i).charValue()-\\'a\\';\\n            hash = ((hash * 26) + v) % MOD;\\n            if(!suffixes.contains(hash)) {\\n                return false;\\n            } else if(wordMap.containsKey(hash) && wordMap.get(hash).contains(s)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private void addRollingHash(String s) {\\n        int hash = 0;\\n        for(int i = s.length()-1; i >= 0; --i) {\\n            int v = s.charAt(i)-\\'a\\';\\n            hash = ((hash * 26) + v) % MOD;\\n            suffixes.add(hash);\\n        }\\n        Set<String> set = wordMap.getOrDefault(hash, new HashSet<String>());\\n        set.add(s);\\n        wordMap.put(hash, set);\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker {\\n    static final int MOD = 100000007;\\n    int maxLen;\\n    Set<Integer> suffixes;\\n    Map<Integer, Set<String>> wordMap;\\n    List<Character> stream;\\n    public StreamChecker(String[] words) {\\n        maxLen = 0;\\n        suffixes = new HashSet<>();\\n        wordMap = new HashMap<>();\\n        for(String w : words) {\\n            addRollingHash(w);\\n            maxLen = Math.max(maxLen, w.length());\\n        }\\n        stream = new LinkedList<>();\\n    }\\n    \\n    public boolean query(char c) {\\n        stream.add(c);\\n        if(stream.size() > maxLen) {\\n            stream.remove(0);\\n        }\\n        String s = \"\";\\n        int hash = 0;\\n        for(int i = stream.size()-1; i >= 0; --i) {\\n            s = stream.get(i) + s;\\n            int v = (int) stream.get(i).charValue()-\\'a\\';\\n            hash = ((hash * 26) + v) % MOD;\\n            if(!suffixes.contains(hash)) {\\n                return false;\\n            } else if(wordMap.containsKey(hash) && wordMap.get(hash).contains(s)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private void addRollingHash(String s) {\\n        int hash = 0;\\n        for(int i = s.length()-1; i >= 0; --i) {\\n            int v = s.charAt(i)-\\'a\\';\\n            hash = ((hash * 26) + v) % MOD;\\n            suffixes.add(hash);\\n        }\\n        Set<String> set = wordMap.getOrDefault(hash, new HashSet<String>());\\n        set.add(s);\\n        wordMap.put(hash, set);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1023918,
                "title": "java-clean-and-simple-trie-stringbuilder-99-23",
                "content": "```\\nclass StreamChecker {\\n    private class Trie {\\n        private Trie[] children;\\n        private boolean isLeaf;\\n        \\n        private Trie() {\\n            children = new Trie[26];\\n        }\\n        \\n        private Trie add(char[] chars) {\\n            Trie root = this;\\n            for(int i = chars.length - 1; i >= 0; i--) {\\n                int index = chars[i] - \\'a\\';\\n                if(root.children[index] == null) {\\n                    root.children[index] = new Trie();\\n                }\\n                \\n                root = root.children[index];\\n            }\\n            \\n            root.isLeaf = true;\\n            \\n            return root;\\n        }\\n    }\\n    \\n    private Trie root;\\n    private StringBuilder query;\\n\\n    public StreamChecker(String[] words) {\\n        root = new Trie();\\n        query = new StringBuilder();\\n        \\n        for(String word : words) {\\n            root.add(word.toCharArray());\\n        }\\n    }\\n    \\n    public boolean query(char letter) {\\n        query.append(letter);\\n        \\n        Trie trie = root;\\n        for(int i = query.length() - 1; i >= 0; i--) {\\n            int index = query.charAt(i) - \\'a\\';\\n            if(trie.children[index] == null) {\\n                return false;\\n            }\\n            \\n            trie = trie.children[index];\\n            if(trie.isLeaf) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker {\\n    private class Trie {\\n        private Trie[] children;\\n        private boolean isLeaf;\\n        \\n        private Trie() {\\n            children = new Trie[26];\\n        }\\n        \\n        private Trie add(char[] chars) {\\n            Trie root = this;\\n            for(int i = chars.length - 1; i >= 0; i--) {\\n                int index = chars[i] - \\'a\\';\\n                if(root.children[index] == null) {\\n                    root.children[index] = new Trie();\\n                }\\n                \\n                root = root.children[index];\\n            }\\n            \\n            root.isLeaf = true;\\n            \\n            return root;\\n        }\\n    }\\n    \\n    private Trie root;\\n    private StringBuilder query;\\n\\n    public StreamChecker(String[] words) {\\n        root = new Trie();\\n        query = new StringBuilder();\\n        \\n        for(String word : words) {\\n            root.add(word.toCharArray());\\n        }\\n    }\\n    \\n    public boolean query(char letter) {\\n        query.append(letter);\\n        \\n        Trie trie = root;\\n        for(int i = query.length() - 1; i >= 0; i--) {\\n            int index = query.charAt(i) - \\'a\\';\\n            if(trie.children[index] == null) {\\n                return false;\\n            }\\n            \\n            trie = trie.children[index];\\n            if(trie.isLeaf) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1022447,
                "title": "python-reverse-trie-and-queue-pythonic-code",
                "content": "The idea is to use a trie to record the reversed string. During the query operations, just check the streaming queue in reverse order to match the trie nodes. The length of the queue only needs to be the max length of your words in the dictionary. Older chars will be discarded. The idea is simple and the code is straightforward.\\n\\n```python\\nclass TrieNode():\\n    def __init__(self):\\n        self.children = defaultdict(TrieNode)\\n        self.string = \\'\\'\\n\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.root = TrieNode()\\n        self.queue = deque([])\\n        self.depth = 0\\n        for w in words:\\n            self.build(w[::-1])\\n            self.depth = max(self.depth, len(w))\\n\\n    def query(self, letter: str) -> bool:\\n        self.queue.append(letter)\\n        if len(self.queue)>self.depth:\\n            self.queue.popleft()\\n        return self.find()\\n\\n    def build(self,string):\\n        node = self.root\\n        for i,c in enumerate(string):\\n            if c not in node.children:\\n                node.children[c] = TrieNode()\\n            node = node.children[c]\\n        node.string = string\\n    \\n    def find(self):\\n        j = len(self.queue)-1\\n        node = self.root\\n        while j>=0 and self.queue[j] in node.children:\\n            node = node.children[self.queue[j]]\\n            if node.string:\\n                return True\\n            j-=1\\n        return False\\n\\n```",
                "solutionTags": [],
                "code": "```python\\nclass TrieNode():\\n    def __init__(self):\\n        self.children = defaultdict(TrieNode)\\n        self.string = \\'\\'\\n\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.root = TrieNode()\\n        self.queue = deque([])\\n        self.depth = 0\\n        for w in words:\\n            self.build(w[::-1])\\n            self.depth = max(self.depth, len(w))\\n\\n    def query(self, letter: str) -> bool:\\n        self.queue.append(letter)\\n        if len(self.queue)>self.depth:\\n            self.queue.popleft()\\n        return self.find()\\n\\n    def build(self,string):\\n        node = self.root\\n        for i,c in enumerate(string):\\n            if c not in node.children:\\n                node.children[c] = TrieNode()\\n            node = node.children[c]\\n        node.string = string\\n    \\n    def find(self):\\n        j = len(self.queue)-1\\n        node = self.root\\n        while j>=0 and self.queue[j] in node.children:\\n            node = node.children[self.queue[j]]\\n            if node.string:\\n                return True\\n            j-=1\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 821038,
                "title": "python-6-lines",
                "content": "```\\nclass StreamChecker(object):\\n\\n    def __init__(self, words):\\n        self.word_map, self.len_map, self.buffer = defaultdict(set), defaultdict(set), \"\"\\n        for w in words:\\n            self.word_map[w[-1]].add(w[::-1])\\n            self.len_map[w[-1]].add(len(w))\\n        \\n\\n    def query(self, letter):\\n        self.buffer = letter + self.buffer\\n        return any(len(self.buffer) >= l and self.buffer[:l] in self.word_map[letter] for l in self.len_map[letter])\\n```",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker(object):\\n\\n    def __init__(self, words):\\n        self.word_map, self.len_map, self.buffer = defaultdict(set), defaultdict(set), \"\"\\n        for w in words:\\n            self.word_map[w[-1]].add(w[::-1])\\n            self.len_map[w[-1]].add(len(w))\\n        \\n\\n    def query(self, letter):\\n        self.buffer = letter + self.buffer\\n        return any(len(self.buffer) >= l and self.buffer[:l] in self.word_map[letter] for l in self.len_map[letter])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 809285,
                "title": "java-clean-code-trie-data-structure-with-reverse-words",
                "content": "```\\nclass Trie {\\n\\t\\n\\tTrie[] children;\\n\\tboolean isEnd;\\n\\t\\n\\tpublic Trie () {\\n\\t\\tchildren = new Trie[26];\\n\\t\\tisEnd = false;\\n\\t}\\n}\\n \\nclass StreamChecker {\\n\\t\\n\\tTrie root;\\n\\tList<Character> list;\\n\\t\\n\\tpublic StreamChecker (String[] words) {\\n\\t\\t\\n\\t\\troot = new Trie ();\\n\\t\\tlist = new LinkedList <>();\\n\\t\\t\\n\\t\\tfor (String word : words) {\\n\\t\\t\\tinsertWord (word);\\n\\t\\t}\\n\\t}\\n\\t\\n\\tpublic void insertWord (String word) {\\n\\t\\t\\n\\t\\tTrie node = root;\\n \\n\\t\\tfor (int i = word.length () - 1; i >= 0; i--) {\\n\\t\\t\\tchar letter = word.charAt (i);\\n\\t\\t\\tif (node.children[letter - \\'a\\'] == null) {\\n\\t\\t\\t\\tnode.children[letter - \\'a\\'] = new Trie ();\\n\\t\\t\\t}\\n\\t\\t\\tnode = node.children[letter - \\'a\\'];\\n\\t\\t}\\n\\t\\t\\n\\t\\tnode.isEnd = true;\\n\\t}\\n\\t\\n\\tpublic boolean query (char letter) {\\n\\t\\t\\n\\t\\tlist.add (letter);\\n\\t\\treturn searchWord ();\\n\\t}\\n\\t\\n\\tpublic boolean searchWord () {\\n\\t\\t\\n\\t\\tTrie node = root;\\n\\t\\tfor (int i = list.size () - 1; i >= 0; i--) {\\n\\t\\t\\tchar letter = list.get (i);\\n\\t\\t\\tif (node.children[letter - \\'a\\'] == null) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tnode = node.children[letter - \\'a\\'];\\n\\t\\t\\tif (node.isEnd) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn false;\\n\\t}\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**\\n",
                "solutionTags": [],
                "code": "```\\nclass Trie {\\n\\t\\n\\tTrie[] children;\\n\\tboolean isEnd;\\n\\t\\n\\tpublic Trie () {\\n\\t\\tchildren = new Trie[26];\\n\\t\\tisEnd = false;\\n\\t}\\n}\\n \\nclass StreamChecker {\\n\\t\\n\\tTrie root;\\n\\tList<Character> list;\\n\\t\\n\\tpublic StreamChecker (String[] words) {\\n\\t\\t\\n\\t\\troot = new Trie ();\\n\\t\\tlist = new LinkedList <>();\\n\\t\\t\\n\\t\\tfor (String word : words) {\\n\\t\\t\\tinsertWord (word);\\n\\t\\t}\\n\\t}\\n\\t\\n\\tpublic void insertWord (String word) {\\n\\t\\t\\n\\t\\tTrie node = root;\\n \\n\\t\\tfor (int i = word.length () - 1; i >= 0; i--) {\\n\\t\\t\\tchar letter = word.charAt (i);\\n\\t\\t\\tif (node.children[letter - \\'a\\'] == null) {\\n\\t\\t\\t\\tnode.children[letter - \\'a\\'] = new Trie ();\\n\\t\\t\\t}\\n\\t\\t\\tnode = node.children[letter - \\'a\\'];\\n\\t\\t}\\n\\t\\t\\n\\t\\tnode.isEnd = true;\\n\\t}\\n\\t\\n\\tpublic boolean query (char letter) {\\n\\t\\t\\n\\t\\tlist.add (letter);\\n\\t\\treturn searchWord ();\\n\\t}\\n\\t\\n\\tpublic boolean searchWord () {\\n\\t\\t\\n\\t\\tTrie node = root;\\n\\t\\tfor (int i = list.size () - 1; i >= 0; i--) {\\n\\t\\t\\tchar letter = list.get (i);\\n\\t\\t\\tif (node.children[letter - \\'a\\'] == null) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tnode = node.children[letter - \\'a\\'];\\n\\t\\t\\tif (node.isEnd) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn false;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 808729,
                "title": "java-trie-using-a-waiting-list-of-potenial-answers",
                "content": "Make a trie and insert all the words in order.\\nMake a waiting list, which will store all the potential answers. As soon as the potenial dissappers (not forming a word), delete that node from the waiting list.\\nAnd always check if from root, we can go to a next node, depending upon the query letter.\\n\\nConsider the trie with the words: ab, ba, aaab, abab, baa\\n\\n<img src=\"https://assets.leetcode.com/users/images/2eedfb3f-e881-49e3-a3fc-ef51a59886ca_1598248043.5687332.png\" width=30%>\\n\\nNote: The \\'X\\' is the root, and the small \\'x\\' marked beside the node, means theres a word ending there\\n\\nLet the queries be: a,a,a,a,a,b,a,b,a,b\\nThe content in the waiting list will be: (The number before the character is its corresponding number in the trie. See the diagram)\\n\\na              ```[2a]``` False\\na              ```[4a. 2a]``` False\\na              ```[7a, 4a, 2a]``` False\\na              ```[7a, 4a, 2a]``` False (the previous 7a got deleted, 4a moved to 7a, 2a moved to 4a and 2a added from the root)\\na              ```[7a, 4a, 2a]``` False (same as above)\\nb              ```[10b, 5b, 3b]``` (7a moved to 10b, 4a was deleted as there\\'s no next b, 2a moved to 5b and 3b was added from root). Answer: True, as 10b and 5b both end on a word. Similarly follow the next steps:\\na              ```[8a, 6a, 2a]``` True, 6a ends on a word\\nb              ```[11b, 5b, 3b]``` True, 11b and 5b end on a word\\na              ```[8a, 6a, 2a]``` True, 6a ends on a word\\nb              ```[11b, 5b, 3b]``` True, 11b and 5b end on a word\\n\\nIn the waiting list, if any node was a word written in it, we set the answer to be true ans return ans.\\nSo final result: F, F, F, F, F, T, T, T, T, T\\n```\\nclass StreamChecker {\\n    TrieNode root;\\n    ArrayList<TrieNode> waiting;\\n    public StreamChecker(String[] words) {\\n        root = new TrieNode();\\n        root.word = \"/\";\\n        for(String i:words){\\n            insert(root, i);\\n        }\\n        waiting = new ArrayList<TrieNode>();\\n    }\\n    \\n    public boolean query(char letter) {\\n        TrieNode rootNext = root.links[letter-\\'a\\'], temp = null;\\n        boolean ans = false;\\n        int loop = waiting.size();\\n        for(int i=0;i<loop;i++){\\n            temp = waiting.get(i).links[letter-\\'a\\'];\\n            if(temp==null){\\n                waiting.remove(i);\\n                i-=1;\\n                loop-=1;                \\n            }\\n            else{\\n                if(temp.word!=null){\\n                    ans = true;\\n                }                \\n                waiting.set(i, temp);\\n            }\\n        }\\n        if(rootNext!=null){\\n            waiting.add(rootNext);\\n            if(rootNext.word!=null){\\n                ans = true;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    public void insert(TrieNode root, String word){\\n        int n = word.length();\\n        TrieNode temp = root;\\n        for(char i:word.toCharArray()){\\n            if(temp.links[i-\\'a\\']==null){\\n                temp.links[i-\\'a\\'] = new TrieNode();                \\n            }\\n            temp = temp.links[i-\\'a\\'];\\n        }\\n        temp.word = word;\\n    }\\n}\\nclass TrieNode{\\n    String word;\\n    TrieNode[] links;\\n    TrieNode(){        \\n        links = new TrieNode[26];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```[2a]```\n```[4a. 2a]```\n```[7a, 4a, 2a]```\n```[7a, 4a, 2a]```\n```[7a, 4a, 2a]```\n```[10b, 5b, 3b]```\n```[8a, 6a, 2a]```\n```[11b, 5b, 3b]```\n```[8a, 6a, 2a]```\n```[11b, 5b, 3b]```\n```\\nclass StreamChecker {\\n    TrieNode root;\\n    ArrayList<TrieNode> waiting;\\n    public StreamChecker(String[] words) {\\n        root = new TrieNode();\\n        root.word = \"/\";\\n        for(String i:words){\\n            insert(root, i);\\n        }\\n        waiting = new ArrayList<TrieNode>();\\n    }\\n    \\n    public boolean query(char letter) {\\n        TrieNode rootNext = root.links[letter-\\'a\\'], temp = null;\\n        boolean ans = false;\\n        int loop = waiting.size();\\n        for(int i=0;i<loop;i++){\\n            temp = waiting.get(i).links[letter-\\'a\\'];\\n            if(temp==null){\\n                waiting.remove(i);\\n                i-=1;\\n                loop-=1;                \\n            }\\n            else{\\n                if(temp.word!=null){\\n                    ans = true;\\n                }                \\n                waiting.set(i, temp);\\n            }\\n        }\\n        if(rootNext!=null){\\n            waiting.add(rootNext);\\n            if(rootNext.word!=null){\\n                ans = true;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    public void insert(TrieNode root, String word){\\n        int n = word.length();\\n        TrieNode temp = root;\\n        for(char i:word.toCharArray()){\\n            if(temp.links[i-\\'a\\']==null){\\n                temp.links[i-\\'a\\'] = new TrieNode();                \\n            }\\n            temp = temp.links[i-\\'a\\'];\\n        }\\n        temp.word = word;\\n    }\\n}\\nclass TrieNode{\\n    String word;\\n    TrieNode[] links;\\n    TrieNode(){        \\n        links = new TrieNode[26];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 808153,
                "title": "swift-solution",
                "content": "Clue: store the character we\\'ve seen so far, iterate the trie from the root everytime we got a character. Check if the sequence of newest character is in the trie and it\\'s a word\\n\\n```\\nclass Node {\\n    var dict = [Character: Node]()\\n    var isEnd = false\\n\\n    init() {}\\n\\n    init(_ val: Character) {\\n        dict[val] = Node()\\n    }\\n\\n    func insert(_ word: [Character], _ i: Int) {\\n        self.isEnd = self.isEnd || i == word.count\\n        if i == word.count { return }\\n\\n        if let node = dict[word[i]] {\\n            return node.insert(word, i+1)\\n        }\\n\\n        let node =  Node()\\n        dict[word[i]] = node\\n        node.insert(word, i+1)\\n    }\\n}\\n\\nclass StreamChecker {\\n    let root = Node()\\n    lazy var cur = self.root\\n    var store = [Character]()\\n\\n    init(_ words: [String]) {\\n        for word in words {\\n            root.insert(Array(word).reversed(), 0)\\n        }\\n    }\\n\\n\\n    func query(_ letter: Character) -> Bool {\\n        store.insert(letter, at: 0)\\n        var cur = root\\n        for char in store {\\n            if let node = cur.dict[char] {\\n                cur = node\\n                if node.isEnd { return true}\\n            } else { break }\\n        }\\n        return false\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Node {\\n    var dict = [Character: Node]()\\n    var isEnd = false\\n\\n    init() {}\\n\\n    init(_ val: Character) {\\n        dict[val] = Node()\\n    }\\n\\n    func insert(_ word: [Character], _ i: Int) {\\n        self.isEnd = self.isEnd || i == word.count\\n        if i == word.count { return }\\n\\n        if let node = dict[word[i]] {\\n            return node.insert(word, i+1)\\n        }\\n\\n        let node =  Node()\\n        dict[word[i]] = node\\n        node.insert(word, i+1)\\n    }\\n}\\n\\nclass StreamChecker {\\n    let root = Node()\\n    lazy var cur = self.root\\n    var store = [Character]()\\n\\n    init(_ words: [String]) {\\n        for word in words {\\n            root.insert(Array(word).reversed(), 0)\\n        }\\n    }\\n\\n\\n    func query(_ letter: Character) -> Bool {\\n        store.insert(letter, at: 0)\\n        var cur = root\\n        for char in store {\\n            if let node = cur.dict[char] {\\n                cur = node\\n                if node.isEnd { return true}\\n            } else { break }\\n        }\\n        return false\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 808019,
                "title": "c-short-solution-clean-and-simple",
                "content": "```\\nclass StreamChecker {\\n    struct TrieNode\\n    {\\n        bool isWord=false;\\n        vector<TrieNode*>children=vector<TrieNode*>(26);\\n    };\\n    TrieNode* root = new TrieNode;         //root of Trie.\\n    \\n    void insert(string word)               //insert function to insert a word in the Trie in reverse fashion.\\n    {\\n        reverse(begin(word),end(word));\\n        TrieNode* cur=root;\\n        for(int i=0 ; i<word.length() ; i++)\\n        {\\n            if(!cur->children[word[i]-\\'a\\']) cur->children[word[i]-\\'a\\']=new TrieNode;\\n            cur = cur->children[word[i]-\\'a\\'];\\n        }\\n        cur->isWord=true;\\n    }\\n    \\npublic:\\n    vector<char>queries;\\n    StreamChecker(vector<string>& words) {                      //insert all the words in the Trie in reverse fashion.\\n        for(int i=0 ; i<words.size() ; i++) insert(words[i]);\\n    }\\n    \\n    bool query(char letter) {             //chek for a word starting from this character using the previous characters in the stream.\\n        queries.push_back(letter);\\n        TrieNode* cur=root;\\n        for(int i=queries.size()-1 ; i>=0 ; i--)\\n        {\\n            if(cur->isWord) return true;\\n            if(!cur->children[queries[i]-\\'a\\']) return false;\\n            cur=cur->children[queries[i]-\\'a\\'];\\n        }\\n        return cur->isWord;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker {\\n    struct TrieNode\\n    {\\n        bool isWord=false;\\n        vector<TrieNode*>children=vector<TrieNode*>(26);\\n    };\\n    TrieNode* root = new TrieNode;         //root of Trie.\\n    \\n    void insert(string word)               //insert function to insert a word in the Trie in reverse fashion.\\n    {\\n        reverse(begin(word),end(word));\\n        TrieNode* cur=root;\\n        for(int i=0 ; i<word.length() ; i++)\\n        {\\n            if(!cur->children[word[i]-\\'a\\']) cur->children[word[i]-\\'a\\']=new TrieNode;\\n            cur = cur->children[word[i]-\\'a\\'];\\n        }\\n        cur->isWord=true;\\n    }\\n    \\npublic:\\n    vector<char>queries;\\n    StreamChecker(vector<string>& words) {                      //insert all the words in the Trie in reverse fashion.\\n        for(int i=0 ; i<words.size() ; i++) insert(words[i]);\\n    }\\n    \\n    bool query(char letter) {             //chek for a word starting from this character using the previous characters in the stream.\\n        queries.push_back(letter);\\n        TrieNode* cur=root;\\n        for(int i=queries.size()-1 ; i>=0 ; i--)\\n        {\\n            if(cur->isWord) return true;\\n            if(!cur->children[queries[i]-\\'a\\']) return false;\\n            cur=cur->children[queries[i]-\\'a\\'];\\n        }\\n        return cur->isWord;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 807900,
                "title": "python-simple-trie-solution-explained-code-video",
                "content": "https://www.youtube.com/watch?v=Z9J2SEORBug\\n[](https://www.youtube.com/watch?v=Z9J2SEORBug)\\n```\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.trie = {}\\n        self.nodes = []\\n        for word in words:\\n            node = self.trie\\n            for char in word:\\n                if char not in node:\\n                    node[char] = {}\\n                node = node[char]\\n            node[\\'end\\'] = True\\n\\n    def query(self, letter: str) -> bool:\\n        self.nodes.append(self.trie)\\n        temp = False\\n        new_nodes = []\\n        \\n        for node in self.nodes:\\n            if letter in node:\\n                node = node[letter]\\n                if \\'end\\' in node:\\n                    temp = True\\n                new_nodes.append(node)\\n        self.nodes = new_nodes\\n        return temp\\n\\n\\n# Your StreamChecker object will be instantiated and called as such:\\n# obj = StreamChecker(words)\\n# param_1 = obj.query(letter)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.trie = {}\\n        self.nodes = []\\n        for word in words:\\n            node = self.trie\\n            for char in word:\\n                if char not in node:\\n                    node[char] = {}\\n                node = node[char]\\n            node[\\'end\\'] = True\\n\\n    def query(self, letter: str) -> bool:\\n        self.nodes.append(self.trie)\\n        temp = False\\n        new_nodes = []\\n        \\n        for node in self.nodes:\\n            if letter in node:\\n                node = node[letter]\\n                if \\'end\\' in node:\\n                    temp = True\\n                new_nodes.append(node)\\n        self.nodes = new_nodes\\n        return temp\\n\\n\\n# Your StreamChecker object will be instantiated and called as such:\\n# obj = StreamChecker(words)\\n# param_1 = obj.query(letter)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 807873,
                "title": "stream-of-characters-trie-can-not-find-where-makes-memory-limit-exceeded",
                "content": "Just using C++ to implement Trie and I do not know where could make the Memory Limit Exceeded, could someone help me find it out\\uFF1F\\n```\\nclass StreamChecker {\\npublic:\\n    struct TrieNode\\n    {\\n        TrieNode* child[26];\\n        bool str;\\n        TrieNode():str(false)\\n        {\\n            for(auto &a:child)\\n                a=nullptr;\\n        }\\n    };\\n    struct Trie\\n    {\\n        TrieNode*root;\\n        Trie(){root=new TrieNode();}\\n        void insert(string s)\\n        {\\n            TrieNode* t=root;\\n            for(int i=s.size()-1;i>=0;--i)\\n            {\\n                if(!t->child[s[i]-\\'a\\']) \\n                    t->child[s[i]-\\'a\\']=new TrieNode();\\n                t=t->child[s[i]-\\'a\\'];\\n            }\\n            t->str=true;\\n        }\\n        bool find(string s)\\n        {\\n            TrieNode* t=root;\\n            int i=s.size()-1;\\n            while(i>=0)\\n            {\\n                if(t->child[s[i]-\\'a\\'])\\n                {\\n                    if(t->child[s[i]-\\'a\\']->str)\\n                        return true;\\n                    t=t->child[s[i]-\\'a\\'];\\n                    --i;\\n                }\\n                else\\n                    return false;\\n            }\\n            return false;\\n        }\\n    };\\n    StreamChecker(vector<string>& words) {\\n        trie=new Trie();\\n        for(string word:words)\\n        {\\n            trie->insert(word);\\n        }\\n        st=\"\";\\n    }\\n    \\n    bool query(char letter) {\\n        st.push_back(letter);\\n        return trie->find(st);\\n    }\\nprivate:\\n    string st;\\n    Trie* trie;\\n};\\n```\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker* obj = new StreamChecker(words);\\n * bool param_1 = obj->query(letter);\\n */\\n",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker {\\npublic:\\n    struct TrieNode\\n    {\\n        TrieNode* child[26];\\n        bool str;\\n        TrieNode():str(false)\\n        {\\n            for(auto &a:child)\\n                a=nullptr;\\n        }\\n    };\\n    struct Trie\\n    {\\n        TrieNode*root;\\n        Trie(){root=new TrieNode();}\\n        void insert(string s)\\n        {\\n            TrieNode* t=root;\\n            for(int i=s.size()-1;i>=0;--i)\\n            {\\n                if(!t->child[s[i]-\\'a\\']) \\n                    t->child[s[i]-\\'a\\']=new TrieNode();\\n                t=t->child[s[i]-\\'a\\'];\\n            }\\n            t->str=true;\\n        }\\n        bool find(string s)\\n        {\\n            TrieNode* t=root;\\n            int i=s.size()-1;\\n            while(i>=0)\\n            {\\n                if(t->child[s[i]-\\'a\\'])\\n                {\\n                    if(t->child[s[i]-\\'a\\']->str)\\n                        return true;\\n                    t=t->child[s[i]-\\'a\\'];\\n                    --i;\\n                }\\n                else\\n                    return false;\\n            }\\n            return false;\\n        }\\n    };\\n    StreamChecker(vector<string>& words) {\\n        trie=new Trie();\\n        for(string word:words)\\n        {\\n            trie->insert(word);\\n        }\\n        st=\"\";\\n    }\\n    \\n    bool query(char letter) {\\n        st.push_back(letter);\\n        return trie->find(st);\\n    }\\nprivate:\\n    string st;\\n    Trie* trie;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 807856,
                "title": "swift-simple-sweet",
                "content": "```\\nclass TrieNode {\\n    var isWord: Bool = false\\n    var chars = [Character: TrieNode]()\\n}\\n\\nclass StreamChecker {\\n    var queried = \"\"\\n    var root: TrieNode\\n    \\n    init(_ words: [String]) {\\n        root = TrieNode()\\n        \\n        for word in words {\\n            var node = root\\n            for char in word.reversed() {\\n                if node.chars[char] == nil {\\n                    node.chars[char] = TrieNode()\\n                }\\n                node = node.chars[char]!\\n            }\\n            node.isWord = true\\n        }\\n    }\\n    \\n    func query(_ letter: Character) -> Bool {\\n        queried += String(letter)\\n        \\n        var node = root\\n        for char in queried.reversed() {\\n            if let next = node.chars[char] {\\n                if next.isWord { return true }\\n                node = next\\n            } else {\\n                break\\n            }\\n        }\\n        \\n        return false\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass TrieNode {\\n    var isWord: Bool = false\\n    var chars = [Character: TrieNode]()\\n}\\n\\nclass StreamChecker {\\n    var queried = \"\"\\n    var root: TrieNode\\n    \\n    init(_ words: [String]) {\\n        root = TrieNode()\\n        \\n        for word in words {\\n            var node = root\\n            for char in word.reversed() {\\n                if node.chars[char] == nil {\\n                    node.chars[char] = TrieNode()\\n                }\\n                node = node.chars[char]!\\n            }\\n            node.isWord = true\\n        }\\n    }\\n    \\n    func query(_ letter: Character) -> Bool {\\n        queried += String(letter)\\n        \\n        var node = root\\n        for char in queried.reversed() {\\n            if let next = node.chars[char] {\\n                if next.isWord { return true }\\n                node = next\\n            } else {\\n                break\\n            }\\n        }\\n        \\n        return false\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 807765,
                "title": "java-simple-trie-solution-2-versions",
                "content": "```\\nclass TrieNode {\\n\\t\\tMap<Character, TrieNode> children;\\n\\t\\tboolean isLeaf;\\n\\n\\t\\tTrieNode() {\\n\\t\\t\\tchildren = new HashMap<>();\\n\\t\\t\\tisLeaf = false;\\n\\t\\t}\\n\\n\\t\\tvoid insert(String word) {\\n\\t\\t\\tTrieNode current = this;\\n\\t\\t\\tfor (int i=word.length()-1; i>=0; i--) {\\n\\t\\t\\t\\tchar c = word.charAt(i);\\n\\t\\t\\t\\tif (!current.children.containsKey(c)) {\\n\\t\\t\\t\\t\\tcurrent.children.put(c, new TrieNode());\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcurrent = current.children.get(c);\\n\\t\\t\\t}\\n\\n\\t\\t\\tcurrent.isLeaf = true;\\n\\t\\t}\\n\\n\\t}\\n\\n\\tclass StreamChecker {\\n\\t\\tTrieNode root;\\n\\t\\tStringBuilder sb;\\n\\n\\t\\tpublic StreamChecker(String[] words) {\\n\\t\\t\\troot = new TrieNode();\\n\\t\\t\\tsb = new StringBuilder();\\n\\n\\t\\t\\tfor (String word : words) {\\n\\t\\t\\t\\troot.insert(word);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tpublic boolean query(char letter) {\\n\\t\\t\\tsb.append(letter);\\n\\t\\t\\tTrieNode current = root;\\n\\n\\t\\t\\tfor (int i= sb.length()-1; i>=0; i--) {\\n\\t\\t\\t\\tchar c = sb.charAt(i);\\n\\t\\t\\t\\tcurrent = current.children.get(c);\\n\\t\\t\\t\\tif (current==null)\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\tif (current!=null && current.isLeaf)\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\t\\n\\t// NO reverse version\\n\\t\\n\\tclass TrieNode {\\n\\tMap<Character, TrieNode> children;\\n\\tboolean isLeaf;\\n\\n\\tTrieNode() {\\n\\t\\tchildren = new HashMap<>();\\n\\t\\tisLeaf = false;\\n\\t}\\n\\n\\tvoid insert(String word) {\\n\\t\\tTrieNode current = this;\\n\\t\\tfor (int i = 0; i < word.length(); i++) {\\n\\t\\t\\tchar c = word.charAt(i);\\n\\t\\t\\tif (!current.children.containsKey(c)) {\\n\\t\\t\\t\\tcurrent.children.put(c, new TrieNode());\\n\\t\\t\\t}\\n\\t\\t\\tcurrent = current.children.get(c);\\n\\t\\t}\\n\\n\\t\\tcurrent.isLeaf = true;\\n\\t}\\n\\n}\\n\\npublic class StreamChecker {\\n\\tTrieNode root;\\n\\tQueue<TrieNode> q;\\n\\n\\tpublic StreamChecker(String[] words) {\\n\\t\\troot = new TrieNode();\\n\\t\\tq = new ArrayDeque<>();\\n\\n\\t\\tfor (String word : words) {\\n\\t\\t\\troot.insert(word);\\n\\t\\t}\\n\\n\\t\\tq.add(root);\\n\\t}\\n\\n\\tpublic boolean query(char letter) {\\n\\t\\tboolean flag = false;\\n\\n\\t\\tint size = q.size();\\n\\n\\t\\tfor (int i = 0; i < size; i++) {\\n\\t\\t\\tTrieNode n = q.poll();\\n\\n\\t\\t\\tif (n.children.containsKey(letter)) {\\n\\t\\t\\t\\tq.add(n.children.get(letter));\\n\\t\\t\\t\\tif (n.children.get(letter).isLeaf)\\n\\t\\t\\t\\t\\tflag = true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (n == root)\\n\\t\\t\\t\\tq.add(root);\\n\\n\\t\\t}\\n\\n\\t\\treturn flag;\\n\\n\\t}\\n}\\n\\t\\n```\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass TrieNode {\\n\\t\\tMap<Character, TrieNode> children;\\n\\t\\tboolean isLeaf;\\n\\n\\t\\tTrieNode() {\\n\\t\\t\\tchildren = new HashMap<>();\\n\\t\\t\\tisLeaf = false;\\n\\t\\t}\\n\\n\\t\\tvoid insert(String word) {\\n\\t\\t\\tTrieNode current = this;\\n\\t\\t\\tfor (int i=word.length()-1; i>=0; i--) {\\n\\t\\t\\t\\tchar c = word.charAt(i);\\n\\t\\t\\t\\tif (!current.children.containsKey(c)) {\\n\\t\\t\\t\\t\\tcurrent.children.put(c, new TrieNode());\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcurrent = current.children.get(c);\\n\\t\\t\\t}\\n\\n\\t\\t\\tcurrent.isLeaf = true;\\n\\t\\t}\\n\\n\\t}\\n\\n\\tclass StreamChecker {\\n\\t\\tTrieNode root;\\n\\t\\tStringBuilder sb;\\n\\n\\t\\tpublic StreamChecker(String[] words) {\\n\\t\\t\\troot = new TrieNode();\\n\\t\\t\\tsb = new StringBuilder();\\n\\n\\t\\t\\tfor (String word : words) {\\n\\t\\t\\t\\troot.insert(word);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tpublic boolean query(char letter) {\\n\\t\\t\\tsb.append(letter);\\n\\t\\t\\tTrieNode current = root;\\n\\n\\t\\t\\tfor (int i= sb.length()-1; i>=0; i--) {\\n\\t\\t\\t\\tchar c = sb.charAt(i);\\n\\t\\t\\t\\tcurrent = current.children.get(c);\\n\\t\\t\\t\\tif (current==null)\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\tif (current!=null && current.isLeaf)\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\t\\n\\t// NO reverse version\\n\\t\\n\\tclass TrieNode {\\n\\tMap<Character, TrieNode> children;\\n\\tboolean isLeaf;\\n\\n\\tTrieNode() {\\n\\t\\tchildren = new HashMap<>();\\n\\t\\tisLeaf = false;\\n\\t}\\n\\n\\tvoid insert(String word) {\\n\\t\\tTrieNode current = this;\\n\\t\\tfor (int i = 0; i < word.length(); i++) {\\n\\t\\t\\tchar c = word.charAt(i);\\n\\t\\t\\tif (!current.children.containsKey(c)) {\\n\\t\\t\\t\\tcurrent.children.put(c, new TrieNode());\\n\\t\\t\\t}\\n\\t\\t\\tcurrent = current.children.get(c);\\n\\t\\t}\\n\\n\\t\\tcurrent.isLeaf = true;\\n\\t}\\n\\n}\\n\\npublic class StreamChecker {\\n\\tTrieNode root;\\n\\tQueue<TrieNode> q;\\n\\n\\tpublic StreamChecker(String[] words) {\\n\\t\\troot = new TrieNode();\\n\\t\\tq = new ArrayDeque<>();\\n\\n\\t\\tfor (String word : words) {\\n\\t\\t\\troot.insert(word);\\n\\t\\t}\\n\\n\\t\\tq.add(root);\\n\\t}\\n\\n\\tpublic boolean query(char letter) {\\n\\t\\tboolean flag = false;\\n\\n\\t\\tint size = q.size();\\n\\n\\t\\tfor (int i = 0; i < size; i++) {\\n\\t\\t\\tTrieNode n = q.poll();\\n\\n\\t\\t\\tif (n.children.containsKey(letter)) {\\n\\t\\t\\t\\tq.add(n.children.get(letter));\\n\\t\\t\\t\\tif (n.children.get(letter).isLeaf)\\n\\t\\t\\t\\t\\tflag = true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (n == root)\\n\\t\\t\\t\\tq.add(root);\\n\\n\\t\\t}\\n\\n\\t\\treturn flag;\\n\\n\\t}\\n}\\n\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 807744,
                "title": "java-solution-trie-accepted-clean-n-concise-commented",
                "content": "* Store the words in the trie data structure in reverse order. This will help to speed up the query function.\\n* Keep appending the  query letter parameter into the global String variable and then search for the string created in the trie.\\n* Whenever we encounter end of the word return true.\\n* **Pleas upvote if helpful!!**\\n```\\npublic class StreamChecker {\\n\\n    TrieDataStructure root = new TrieDataStructure();\\n\\n    String s = \"\";\\n\\n    public StreamChecker(String[] words) {\\n\\n\\n        for (int i = 0; i < words.length; i++) {\\n            \\n            TrieDataStructure current = root;\\n            String word = words[i];\\n\\t\\t\\t\\n            //store the words in trie data structure in REVERSE\\n\\t\\t\\t\\n            for (int j = word.length() - 1; j >= 0; j--) {\\n\\n                Character c = word.charAt(j);\\n                TrieDataStructure node = current.charMap.get(c);\\n\\n                if (node == null) {\\n                    \\n                    node = new TrieDataStructure();\\n                    current.charMap.put(c, node);\\n                    \\n                }\\n\\n                current = node;\\n\\n            }\\n\\n            current.isLastLetter = true;\\n        }\\n\\n    }\\n\\n    \\n    public boolean query(char letter) {\\n\\n        s = letter + s; //keep appending the letter at start of the string. and then search the word till u encounter last letter.\\n\\n        TrieDataStructure current = root;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            \\n            TrieDataStructure node = current.charMap.get(s.charAt(i));\\n            \\n            if (node != null) {\\n                current = node;\\n                if (current.isLastLetter) return true;  //imp to return when u encounter end of word or last letter\\n            } else {\\n                return false;\\n            }\\n        }\\n\\n        return current.isLastLetter == true;\\n\\n    }\\n\\n//TRIE data structure\\n    class TrieDataStructure {\\n\\n        Map<Character, TrieDataStructure> charMap;\\n        boolean isLastLetter;\\n\\n        TrieDataStructure() {\\n            this.charMap = new HashMap<>();\\n            isLastLetter = false;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class StreamChecker {\\n\\n    TrieDataStructure root = new TrieDataStructure();\\n\\n    String s = \"\";\\n\\n    public StreamChecker(String[] words) {\\n\\n\\n        for (int i = 0; i < words.length; i++) {\\n            \\n            TrieDataStructure current = root;\\n            String word = words[i];\\n\\t\\t\\t\\n            //store the words in trie data structure in REVERSE\\n\\t\\t\\t\\n            for (int j = word.length() - 1; j >= 0; j--) {\\n\\n                Character c = word.charAt(j);\\n                TrieDataStructure node = current.charMap.get(c);\\n\\n                if (node == null) {\\n                    \\n                    node = new TrieDataStructure();\\n                    current.charMap.put(c, node);\\n                    \\n                }\\n\\n                current = node;\\n\\n            }\\n\\n            current.isLastLetter = true;\\n        }\\n\\n    }\\n\\n    \\n    public boolean query(char letter) {\\n\\n        s = letter + s; //keep appending the letter at start of the string. and then search the word till u encounter last letter.\\n\\n        TrieDataStructure current = root;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            \\n            TrieDataStructure node = current.charMap.get(s.charAt(i));\\n            \\n            if (node != null) {\\n                current = node;\\n                if (current.isLastLetter) return true;  //imp to return when u encounter end of word or last letter\\n            } else {\\n                return false;\\n            }\\n        }\\n\\n        return current.isLastLetter == true;\\n\\n    }\\n\\n//TRIE data structure\\n    class TrieDataStructure {\\n\\n        Map<Character, TrieDataStructure> charMap;\\n        boolean isLastLetter;\\n\\n        TrieDataStructure() {\\n            this.charMap = new HashMap<>();\\n            isLastLetter = false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 807637,
                "title": "python-weird-tle-when-using-trienode-objects-vs-dict",
                "content": "When I define a TrieNode class and use objects, the overhead of using them in Python leads to TLE. Using dicts on the other hand fits within the time limit. In a job interview one would expect the first solution to be slightly better, so I think the time limit could be adjusted to allow for that solution to pass as well. I think adding a couple seconds to TL would do it.\\n```\\nclass TrieNode:\\n    def __init__(self, is_end=False):\\n        self.children = {}  # char to trie node\\n        self.is_end = is_end\\n\\nclass StreamChecker:\\n    def __init__(self, words: List[str]):\\n        self.root = TrieNode()\\n        for word in words:\\n            curnode = self.root\\n            for ch in word:\\n                if ch not in curnode.children:\\n                    curnode.children[ch] = TrieNode()\\n                curnode = curnode.children[ch]\\n            curnode.is_end = True\\n        self.leads = set([self.root]) # the pointers to the threads we follow right now\\n\\n    def query(self, letter: str) -> bool:\\n        next_leads = set([self.root])\\n        found_word = False\\n        for lead in self.leads:\\n            if letter in lead.children:\\n                next_leads.add(lead.children[letter])\\n                if lead.children[letter].is_end:\\n                    found_word = True\\n        self.leads = next_leads\\n        return found_word\\n```\\n\\nThe solution using dicts:\\n```\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.root = {}\\n        for word in words:\\n            curnode = self.root\\n            for ch in word:\\n                if ch not in curnode:\\n                    curnode[ch] = {}\\n                curnode = curnode[ch]\\n            curnode[\\'is_end\\'] = True\\n        self.leads = [self.root] # the pointers to the threads we follow right now\\n\\n    def query(self, letter: str) -> bool:\\n        next_leads = [self.root]\\n        found_word = False\\n        for lead in self.leads:\\n            if letter in lead:\\n                new_lead = lead[letter]\\n                next_leads.append(new_lead)\\n                if \\'is_end\\' in new_lead:\\n                    found_word = True\\n        self.leads = next_leads\\n        return found_word\\n```",
                "solutionTags": [
                    "Python",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode:\\n    def __init__(self, is_end=False):\\n        self.children = {}  # char to trie node\\n        self.is_end = is_end\\n\\nclass StreamChecker:\\n    def __init__(self, words: List[str]):\\n        self.root = TrieNode()\\n        for word in words:\\n            curnode = self.root\\n            for ch in word:\\n                if ch not in curnode.children:\\n                    curnode.children[ch] = TrieNode()\\n                curnode = curnode.children[ch]\\n            curnode.is_end = True\\n        self.leads = set([self.root]) # the pointers to the threads we follow right now\\n\\n    def query(self, letter: str) -> bool:\\n        next_leads = set([self.root])\\n        found_word = False\\n        for lead in self.leads:\\n            if letter in lead.children:\\n                next_leads.add(lead.children[letter])\\n                if lead.children[letter].is_end:\\n                    found_word = True\\n        self.leads = next_leads\\n        return found_word\\n```\n```\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.root = {}\\n        for word in words:\\n            curnode = self.root\\n            for ch in word:\\n                if ch not in curnode:\\n                    curnode[ch] = {}\\n                curnode = curnode[ch]\\n            curnode[\\'is_end\\'] = True\\n        self.leads = [self.root] # the pointers to the threads we follow right now\\n\\n    def query(self, letter: str) -> bool:\\n        next_leads = [self.root]\\n        found_word = False\\n        for lead in self.leads:\\n            if letter in lead:\\n                new_lead = lead[letter]\\n                next_leads.append(new_lead)\\n                if \\'is_end\\' in new_lead:\\n                    found_word = True\\n        self.leads = next_leads\\n        return found_word\\n```",
                "codeTag": "Java"
            },
            {
                "id": 807581,
                "title": "java-trie-easy-to-understand-with-comments",
                "content": "```\\nclass StreamChecker {    \\n    class TrieNode{\\n        final int N=26;\\n        TrieNode []child ;\\n        boolean  isWord; \\n        public TrieNode(){   \\n            child = new TrieNode[N];\\n            isWord = false;\\n        }  \\n    }   \\n    class Trie{\\n        TrieNode root;\\n        public Trie()\\n        {\\n           root = new TrieNode();  \\n        }\\n        // Put the word in reverse in trie \\n        public void insertReverse( String word){    \\n        TrieNode curr = root;\\n        for( int i= word.length()-1 ; i >= 0 ;i--){   \\n           char ch = word.charAt(i);\\n               if(curr.child[ch-\\'a\\'] == null)  \\n               {\\n                 curr.child[ch-\\'a\\'] = new TrieNode();  \\n               }  \\n            curr = curr.child[ch-\\'a\\'];\\n         }    \\n         curr.isWord= true;   \\n       }\\n    \\n       // serach the word in trie \\n       public boolean searchWord( String word){       \\n        TrieNode curr = root;\\n        for( int i= word.length()-1 ; i >= 0 ;i--){   \\n           char ch = word.charAt(i);\\n               if(curr.child[ch-\\'a\\'] == null)  \\n               {\\n                  return(false) ; \\n               }  \\n            curr = curr.child[ch-\\'a\\'];\\n            if(curr.isWord == true)  \\n                return(true);\\n         }    \\n         return(curr.isWord);\\n        }   \\n    }\\n    Trie  my_trie ;\\n    StringBuilder  queryWord ;\\n    public StreamChecker(String[] words) {\\n        my_trie = new Trie();\\n        queryWord = new StringBuilder(\"\");\\n        // Put each word in Trie .\\n        for( String word : words){\\n            my_trie.insertReverse(word);           \\n        }    \\n    }  \\n    public boolean query(char letter) {\\n       queryWord.append(letter) ;    \\n       return (my_trie.searchWord(queryWord.toString()));  \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker {    \\n    class TrieNode{\\n        final int N=26;\\n        TrieNode []child ;\\n        boolean  isWord; \\n        public TrieNode(){   \\n            child = new TrieNode[N];\\n            isWord = false;\\n        }  \\n    }   \\n    class Trie{\\n        TrieNode root;\\n        public Trie()\\n        {\\n           root = new TrieNode();  \\n        }\\n        // Put the word in reverse in trie \\n        public void insertReverse( String word){    \\n        TrieNode curr = root;\\n        for( int i= word.length()-1 ; i >= 0 ;i--){   \\n           char ch = word.charAt(i);\\n               if(curr.child[ch-\\'a\\'] == null)  \\n               {\\n                 curr.child[ch-\\'a\\'] = new TrieNode();  \\n               }  \\n            curr = curr.child[ch-\\'a\\'];\\n         }    \\n         curr.isWord= true;   \\n       }\\n    \\n       // serach the word in trie \\n       public boolean searchWord( String word){       \\n        TrieNode curr = root;\\n        for( int i= word.length()-1 ; i >= 0 ;i--){   \\n           char ch = word.charAt(i);\\n               if(curr.child[ch-\\'a\\'] == null)  \\n               {\\n                  return(false) ; \\n               }  \\n            curr = curr.child[ch-\\'a\\'];\\n            if(curr.isWord == true)  \\n                return(true);\\n         }    \\n         return(curr.isWord);\\n        }   \\n    }\\n    Trie  my_trie ;\\n    StringBuilder  queryWord ;\\n    public StreamChecker(String[] words) {\\n        my_trie = new Trie();\\n        queryWord = new StringBuilder(\"\");\\n        // Put each word in Trie .\\n        for( String word : words){\\n            my_trie.insertReverse(word);           \\n        }    \\n    }  \\n    public boolean query(char letter) {\\n       queryWord.append(letter) ;    \\n       return (my_trie.searchWord(queryWord.toString()));  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 807292,
                "title": "rust-trie-with-reversed-words",
                "content": "```rust\\nuse std::collections::HashMap;\\n\\n#[derive(PartialEq, Eq, Clone, Debug, Default)]\\nstruct Trie {\\n    children: HashMap<char, Trie>,\\n    end: bool,\\n}\\n\\nimpl Trie {\\n    fn new() -> Self {\\n        Self::default()\\n    }\\n\\n    fn insert(&mut self, word: String) {\\n        let mut link = self;\\n        for c in word.chars().rev() {\\n            link = link.children.entry(c).or_default();\\n        }\\n        link.end = true;\\n    }\\n\\n    fn search(&self, stream: &[char]) -> bool {\\n        let mut link = self;\\n        for c in stream.iter().rev() {\\n            if let Some(next) = link.children.get(&c) {\\n                link = next;\\n                if next.end {\\n                    return true;\\n                }\\n            } else {\\n                return false;\\n            }\\n        }\\n        false\\n    }\\n}\\n\\nstruct StreamChecker {\\n    trie: Trie,\\n    stream: Vec<char>,\\n}\\n\\nimpl StreamChecker {\\n    fn new(words: Vec<String>) -> Self {\\n        let mut trie = Trie::new();\\n        for s in words {\\n            trie.insert(s);\\n        }\\n        let stream = vec![];\\n        StreamChecker { trie, stream }\\n    }\\n\\n    fn query(&mut self, letter: char) -> bool {\\n        self.stream.push(letter);\\n        self.trie.search(&self.stream)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nuse std::collections::HashMap;\\n\\n#[derive(PartialEq, Eq, Clone, Debug, Default)]\\nstruct Trie {\\n    children: HashMap<char, Trie>,\\n    end: bool,\\n}\\n\\nimpl Trie {\\n    fn new() -> Self {\\n        Self::default()\\n    }\\n\\n    fn insert(&mut self, word: String) {\\n        let mut link = self;\\n        for c in word.chars().rev() {\\n            link = link.children.entry(c).or_default();\\n        }\\n        link.end = true;\\n    }\\n\\n    fn search(&self, stream: &[char]) -> bool {\\n        let mut link = self;\\n        for c in stream.iter().rev() {\\n            if let Some(next) = link.children.get(&c) {\\n                link = next;\\n                if next.end {\\n                    return true;\\n                }\\n            } else {\\n                return false;\\n            }\\n        }\\n        false\\n    }\\n}\\n\\nstruct StreamChecker {\\n    trie: Trie,\\n    stream: Vec<char>,\\n}\\n\\nimpl StreamChecker {\\n    fn new(words: Vec<String>) -> Self {\\n        let mut trie = Trie::new();\\n        for s in words {\\n            trie.insert(s);\\n        }\\n        let stream = vec![];\\n        StreamChecker { trie, stream }\\n    }\\n\\n    fn query(&mut self, letter: char) -> bool {\\n        self.stream.push(letter);\\n        self.trie.search(&self.stream)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 807235,
                "title": "my-c-trie-solution-o-words-length-memory-beats-70-o-word-length-queries-time",
                "content": "```\\nclass Trie_node{\\npublic:\\n    vector<Trie_node *> next;\\n    bool end;\\n    Trie_node()\\n    {\\n        next = std::vector<Trie_node *>(26,NULL);\\n        end = false;\\n    }\\n};\\n\\nclass Trie\\n{\\npublic:\\n    Trie_node *root;\\n    Trie(){\\n        root = new Trie_node();\\n    }\\n\\n    /** Inserts a word into the trie. */\\n    void insert(string &word) {\\n        Trie_node *node = root;\\n        for(char c : word)\\n        {\\n            if(node ->next[c - \\'a\\'] == NULL)\\n                node ->next[c - \\'a\\'] = new Trie_node();\\n            node = node ->next[c - \\'a\\'];\\n        }\\n        node->end = true;\\n    }\\n    \\n    bool check(deque<char> &dq){\\n        Trie_node *node = root;\\n        auto ptr = dq.rbegin();\\n        while(ptr != dq.rend()){\\n            if(node->next[*ptr - \\'a\\'] == NULL)\\n                return false;\\n            node = node->next[*ptr - \\'a\\'];\\n            if(node->end)\\n                return true;\\n            ptr ++;\\n        }\\n        return false;\\n    }\\n};\\n\\nclass StreamChecker {\\nprivate:\\n    Trie *helper;\\n    deque<char> dq;\\n    int max_s;\\npublic:\\n    StreamChecker(vector<string>& words) {\\n        max_s = 0;\\n        for(string &s: words){\\n            max_s = max(max_s, (int)s.size()); \\n            reverse(s.begin(), s.end());\\n        }\\n        helper = new Trie();\\n        for(auto &s: words)\\n            helper->insert(s);\\n    }\\n    \\n    bool query(char letter) {\\n        dq.push_back(letter);\\n        if(dq.size() > max_s){\\n            dq.pop_front();\\n        }\\n        return helper->check(dq);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Trie_node{\\npublic:\\n    vector<Trie_node *> next;\\n    bool end;\\n    Trie_node()\\n    {\\n        next = std::vector<Trie_node *>(26,NULL);\\n        end = false;\\n    }\\n};\\n\\nclass Trie\\n{\\npublic:\\n    Trie_node *root;\\n    Trie(){\\n        root = new Trie_node();\\n    }\\n\\n    /** Inserts a word into the trie. */\\n    void insert(string &word) {\\n        Trie_node *node = root;\\n        for(char c : word)\\n        {\\n            if(node ->next[c - \\'a\\'] == NULL)\\n                node ->next[c - \\'a\\'] = new Trie_node();\\n            node = node ->next[c - \\'a\\'];\\n        }\\n        node->end = true;\\n    }\\n    \\n    bool check(deque<char> &dq){\\n        Trie_node *node = root;\\n        auto ptr = dq.rbegin();\\n        while(ptr != dq.rend()){\\n            if(node->next[*ptr - \\'a\\'] == NULL)\\n                return false;\\n            node = node->next[*ptr - \\'a\\'];\\n            if(node->end)\\n                return true;\\n            ptr ++;\\n        }\\n        return false;\\n    }\\n};\\n\\nclass StreamChecker {\\nprivate:\\n    Trie *helper;\\n    deque<char> dq;\\n    int max_s;\\npublic:\\n    StreamChecker(vector<string>& words) {\\n        max_s = 0;\\n        for(string &s: words){\\n            max_s = max(max_s, (int)s.size()); \\n            reverse(s.begin(), s.end());\\n        }\\n        helper = new Trie();\\n        for(auto &s: words)\\n            helper->insert(s);\\n    }\\n    \\n    bool query(char letter) {\\n        dq.push_back(letter);\\n        if(dq.size() > max_s){\\n            dq.pop_front();\\n        }\\n        return helper->check(dq);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 807195,
                "title": "c-trie-solution-doesn-t-need-to-store-all-letters-queried-so-far",
                "content": "```\\nclass Trie {\\n    public:\\n    vector<Trie*> next;\\n    bool isWord;\\n    Trie () {\\n        next = vector<Trie*>(26,nullptr);\\n        isWord = false;\\n    }\\n    void insert (string& s) {\\n        Trie* cur = this;\\n        for (char& c: s) {\\n            if (cur->next[c-\\'a\\']==nullptr) {\\n                cur->next[c-\\'a\\'] = new Trie();\\n            }\\n            cur = cur->next[c-\\'a\\'];\\n        }\\n        cur->isWord = true;\\n    }  \\n};\\nclass StreamChecker {\\n    Trie root;\\n    list<char> buffer;\\n    int W_MAX;\\npublic:\\n    StreamChecker(vector<string>& words) {\\n        W_MAX = 0;\\n        for (auto& w: words) {\\n            if (w.size() > W_MAX) W_MAX = w.size();\\n            reverse(w.begin(), w.end());\\n            root.insert(w);\\n        }\\n    }\\n    \\n    bool query(char letter) {\\n        buffer.push_back(letter);\\n        if (buffer.size() == W_MAX+1) buffer.pop_front();\\n\\t\\t/*\\n\\t\\t * No point in writing input letters in an unbounded buffer.\\n         * the maximum size of the words from input list is W_MAX. We don\\'t need to store\\n         * more characters than that.\\n\\t\\t */\\n        Trie* cur = &root;\\n        for (auto it = buffer.rbegin(); it != buffer.rend(); ++it) {\\n            if (cur->isWord) return true;\\n            if (cur->next[*it -\\'a\\'] == nullptr) return false;\\n            cur = cur->next[*it-\\'a\\'];\\n        }\\n        return (cur->isWord);\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Trie {\\n    public:\\n    vector<Trie*> next;\\n    bool isWord;\\n    Trie () {\\n        next = vector<Trie*>(26,nullptr);\\n        isWord = false;\\n    }\\n    void insert (string& s) {\\n        Trie* cur = this;\\n        for (char& c: s) {\\n            if (cur->next[c-\\'a\\']==nullptr) {\\n                cur->next[c-\\'a\\'] = new Trie();\\n            }\\n            cur = cur->next[c-\\'a\\'];\\n        }\\n        cur->isWord = true;\\n    }  \\n};\\nclass StreamChecker {\\n    Trie root;\\n    list<char> buffer;\\n    int W_MAX;\\npublic:\\n    StreamChecker(vector<string>& words) {\\n        W_MAX = 0;\\n        for (auto& w: words) {\\n            if (w.size() > W_MAX) W_MAX = w.size();\\n            reverse(w.begin(), w.end());\\n            root.insert(w);\\n        }\\n    }\\n    \\n    bool query(char letter) {\\n        buffer.push_back(letter);\\n        if (buffer.size() == W_MAX+1) buffer.pop_front();\\n\\t\\t/*\\n\\t\\t * No point in writing input letters in an unbounded buffer.\\n         * the maximum size of the words from input list is W_MAX. We don\\'t need to store\\n         * more characters than that.\\n\\t\\t */\\n        Trie* cur = &root;\\n        for (auto it = buffer.rbegin(); it != buffer.rend(); ++it) {\\n            if (cur->isWord) return true;\\n            if (cur->next[*it -\\'a\\'] == nullptr) return false;\\n            cur = cur->next[*it-\\'a\\'];\\n        }\\n        return (cur->isWord);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 802360,
                "title": "java-trie-solution",
                "content": "```java\\n/*\\n* Problem: https://leetcode.com/problems/stream-of-characters\\n*\\n* Approach: Trie Tree\\n*/\\nclass StreamChecker {\\n    \\n    class TrieNode {\\n        boolean word = false;\\n        Map<Character, TrieNode> children = new HashMap<>();\\n    }\\n\\n    class TrieTree {\\n        TrieNode root = new TrieNode();\\n        public void insert(String s) {\\n            TrieNode current = root;\\n            for (int i = s.length()-1; i >= 0; i--) {\\n                current = current.children.computeIfAbsent(s.charAt(i), x -> new TrieNode());\\n            }\\n            current.word = true;\\n        }\\n\\n        public boolean search(StringBuilder builder) {\\n            TrieNode current = root;\\n            for (int i = builder.length()-1; i >= 0; i--) {\\n                char ch = builder.charAt(i);\\n                current = current.children.get(ch);\\n                if (current == null) return false;\\n                if (current.word) return true;\\n            }\\n            return false;\\n        }\\n    }\\n    \\n    TrieTree trie = new TrieTree();\\n    StringBuilder builder = new StringBuilder();\\n\\n    public StreamChecker(String[] words) {\\n        for (String word: words) {\\n            trie.insert(word);\\n        }\\n    }\\n\\n    public boolean query(char letter) {\\n        builder.append(letter);\\n        return trie.search(builder);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\n/*\\n* Problem: https://leetcode.com/problems/stream-of-characters\\n*\\n* Approach: Trie Tree\\n*/\\nclass StreamChecker {\\n    \\n    class TrieNode {\\n        boolean word = false;\\n        Map<Character, TrieNode> children = new HashMap<>();\\n    }\\n\\n    class TrieTree {\\n        TrieNode root = new TrieNode();\\n        public void insert(String s) {\\n            TrieNode current = root;\\n            for (int i = s.length()-1; i >= 0; i--) {\\n                current = current.children.computeIfAbsent(s.charAt(i), x -> new TrieNode());\\n            }\\n            current.word = true;\\n        }\\n\\n        public boolean search(StringBuilder builder) {\\n            TrieNode current = root;\\n            for (int i = builder.length()-1; i >= 0; i--) {\\n                char ch = builder.charAt(i);\\n                current = current.children.get(ch);\\n                if (current == null) return false;\\n                if (current.word) return true;\\n            }\\n            return false;\\n        }\\n    }\\n    \\n    TrieTree trie = new TrieTree();\\n    StringBuilder builder = new StringBuilder();\\n\\n    public StreamChecker(String[] words) {\\n        for (String word: words) {\\n            trie.insert(word);\\n        }\\n    }\\n\\n    public boolean query(char letter) {\\n        builder.append(letter);\\n        return trie.search(builder);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 797400,
                "title": "simple-trie-solution",
                "content": "```\\nclass Node:\\n        def __init__(self,ch):\\n            self.ch=ch\\n            self.childs={}\\n            self.isend=False\\nclass Trie:\\n    def __init__(self):\\n        self.root=Node(\\'/\\')\\n    def insert(self,word):\\n        temp=self.root\\n        for i in word:\\n            if i not in temp.childs:\\n                nn=Node(i)\\n                temp.childs[i]=nn\\n                temp=nn\\n            else:\\n                temp=temp.childs[i]\\n        temp.isend=True\\n    def search(self,word):\\n        temp=self.root\\n        for i in word:\\n            \\n            if temp.isend:\\n                return True\\n            if i not in temp.childs:\\n                return False\\n            temp=temp.childs[i]\\n        return temp.isend\\n\\n    \\nclass StreamChecker:\\n    def __init__(self, words: List[str]):\\n        self.t=Trie()\\n        for i in words:\\n            self.t.insert(i[::-1])\\n        self.stream=\\'\\'\\n        \\n    def query(self, letter: str) -> bool:\\n        self.stream=letter+self.stream\\n        return self.t.search(self.stream)\\n        \\n        \\n\\n\\n# Your StreamChecker object will be instantiated and called as such:\\n# obj = StreamChecker(words)\\n# param_1 = obj.query(letter)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Node:\\n        def __init__(self,ch):\\n            self.ch=ch\\n            self.childs={}\\n            self.isend=False\\nclass Trie:\\n    def __init__(self):\\n        self.root=Node(\\'/\\')\\n    def insert(self,word):\\n        temp=self.root\\n        for i in word:\\n            if i not in temp.childs:\\n                nn=Node(i)\\n                temp.childs[i]=nn\\n                temp=nn\\n            else:\\n                temp=temp.childs[i]\\n        temp.isend=True\\n    def search(self,word):\\n        temp=self.root\\n        for i in word:\\n            \\n            if temp.isend:\\n                return True\\n            if i not in temp.childs:\\n                return False\\n            temp=temp.childs[i]\\n        return temp.isend\\n\\n    \\nclass StreamChecker:\\n    def __init__(self, words: List[str]):\\n        self.t=Trie()\\n        for i in words:\\n            self.t.insert(i[::-1])\\n        self.stream=\\'\\'\\n        \\n    def query(self, letter: str) -> bool:\\n        self.stream=letter+self.stream\\n        return self.t.search(self.stream)\\n        \\n        \\n\\n\\n# Your StreamChecker object will be instantiated and called as such:\\n# obj = StreamChecker(words)\\n# param_1 = obj.query(letter)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 785743,
                "title": "c-solution",
                "content": "```\\nclass StreamChecker {\\npublic:\\n    struct TreeNode{\\n        vector<TreeNode *> nodes;\\n        bool isword;\\n        TreeNode(){\\n            nodes = vector<TreeNode *>(26,NULL);\\n            isword = false;\\n        }\\n    };\\n    \\n    TreeNode *root;\\n    string build;\\n    \\n    void insert(vector<string>& words)\\n    {\\n        for(string &s : words)\\n        {\\n            reverse(s.begin(),s.end());\\n            TreeNode *temp = root;\\n            for(char c : s)\\n            {\\n                if(!temp->nodes[c-\\'a\\']) temp->nodes[c-\\'a\\'] = new TreeNode();\\n                temp = temp->nodes[c-\\'a\\'];\\n            }\\n            temp->isword = true;\\n        }\\n    }\\n    \\n    StreamChecker(vector<string>& words) {\\n        root = new TreeNode();\\n        build = \"\";\\n        insert(words);\\n    }\\n    \\n    bool query(char letter) {\\n        build += letter;\\n        TreeNode *temp = root;\\n        for(int i=build.size()-1; i>=0 && temp; i--)\\n        {\\n            temp = temp->nodes[build[i]-\\'a\\'];\\n            if(temp && temp->isword)\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker {\\npublic:\\n    struct TreeNode{\\n        vector<TreeNode *> nodes;\\n        bool isword;\\n        TreeNode(){\\n            nodes = vector<TreeNode *>(26,NULL);\\n            isword = false;\\n        }\\n    };\\n    \\n    TreeNode *root;\\n    string build;\\n    \\n    void insert(vector<string>& words)\\n    {\\n        for(string &s : words)\\n        {\\n            reverse(s.begin(),s.end());\\n            TreeNode *temp = root;\\n            for(char c : s)\\n            {\\n                if(!temp->nodes[c-\\'a\\']) temp->nodes[c-\\'a\\'] = new TreeNode();\\n                temp = temp->nodes[c-\\'a\\'];\\n            }\\n            temp->isword = true;\\n        }\\n    }\\n    \\n    StreamChecker(vector<string>& words) {\\n        root = new TreeNode();\\n        build = \"\";\\n        insert(words);\\n    }\\n    \\n    bool query(char letter) {\\n        build += letter;\\n        TreeNode *temp = root;\\n        for(int i=build.size()-1; i>=0 && temp; i--)\\n        {\\n            temp = temp->nodes[build[i]-\\'a\\'];\\n            if(temp && temp->isword)\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 782467,
                "title": "concise-java-solution-trie-with-reversed-order",
                "content": "A dictionary and a list of letters, which easily makes one to come up with a solution of trie. If you are not familiar with trie, it is better to study this data structure now. Because it is asked frequently in an interview these days. \\nSo, with a trie we can check whether a string is in a dictionary efficiently. But in this question, it tells us to check the last k letters, which means we have to start from the last letter and trace back. To make our work easier, we just construct the trie with a reverse order:\\n```\\n[\"abc\", \"fc\", \"ae\"]\\nNormal order trie:  abc, fc, ae\\n           NA\\n\\t\\t  /  \\\\\\n\\t\\t a    f\\n\\t    /  \\\\  |\\n\\t   b    e c\\n\\t   |\\n\\t   c\\nReversed order trie: cba, cf, ea\\n           NA\\n\\t\\t  /  \\\\\\n\\t\\t c    e\\n\\t    /  \\\\  |\\n\\t   b    f a\\n\\t   |\\n\\t   a\\n```\\nWhenever we want to check a stream like \"abc\", we just start with the order \"c-b-a\" and search the reversed order trie. \\nTime complexity: O(nm) to construct the trie and O(h) for each query, where n is the length of the dictionary, m is the length of words in dictionary, and h is the height of trie. \\nSpace complexity: O(nm + q), where q is the number of characters we maintained in deque. As the max height of trie is h, so we can limit the size of q to be h. \\n```java\\nclass StreamChecker {\\n    Trie trie;\\n    Deque<Character> cur;\\n    int cap;\\n    public StreamChecker(String[] words) {\\n        trie = new Trie(words);\\n        cur = new ArrayDeque();\\n        cap = trie.height;\\n    }\\n    \\n    public boolean query(char letter) {\\n        cur.offerLast(letter);\\n        if(cur.size() > cap) cur.pollFirst();\\n        return trie.search(new ArrayList(cur));\\n    }\\n}\\n\\nclass TrieNode {\\n    TrieNode[] next;\\n    boolean term;\\n    public TrieNode() {\\n        next = new TrieNode[26];\\n        term = false;\\n    }\\n}\\n\\nclass Trie {\\n    TrieNode root;\\n    int height;\\n    public Trie(String[] words) {\\n        root = new TrieNode();\\n        height = 0;\\n        for(String word: words) {\\n            TrieNode cur = root;\\n            height = Math.max(height, word.length());\\n            for(int i = word.length() - 1; i >= 0; --i) {\\n                char c = word.charAt(i);\\n                if(cur.next[c-\\'a\\'] == null) cur.next[c-\\'a\\'] = new TrieNode();\\n                cur = cur.next[c-\\'a\\'];\\n            }\\n            cur.term = true;\\n        }\\n    }\\n    public boolean search(List<Character> s) {\\n        TrieNode cur = root;\\n        for(int i = s.size() - 1; i >= 0; --i) {\\n            char c = s.get(i);\\n            if(cur.next[c-\\'a\\'] == null) return false;\\n            cur = cur.next[c-\\'a\\'];\\n            if(cur.term) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n[\"abc\", \"fc\", \"ae\"]\\nNormal order trie:  abc, fc, ae\\n           NA\\n\\t\\t  /  \\\\\\n\\t\\t a    f\\n\\t    /  \\\\  |\\n\\t   b    e c\\n\\t   |\\n\\t   c\\nReversed order trie: cba, cf, ea\\n           NA\\n\\t\\t  /  \\\\\\n\\t\\t c    e\\n\\t    /  \\\\  |\\n\\t   b    f a\\n\\t   |\\n\\t   a\\n```\n```java\\nclass StreamChecker {\\n    Trie trie;\\n    Deque<Character> cur;\\n    int cap;\\n    public StreamChecker(String[] words) {\\n        trie = new Trie(words);\\n        cur = new ArrayDeque();\\n        cap = trie.height;\\n    }\\n    \\n    public boolean query(char letter) {\\n        cur.offerLast(letter);\\n        if(cur.size() > cap) cur.pollFirst();\\n        return trie.search(new ArrayList(cur));\\n    }\\n}\\n\\nclass TrieNode {\\n    TrieNode[] next;\\n    boolean term;\\n    public TrieNode() {\\n        next = new TrieNode[26];\\n        term = false;\\n    }\\n}\\n\\nclass Trie {\\n    TrieNode root;\\n    int height;\\n    public Trie(String[] words) {\\n        root = new TrieNode();\\n        height = 0;\\n        for(String word: words) {\\n            TrieNode cur = root;\\n            height = Math.max(height, word.length());\\n            for(int i = word.length() - 1; i >= 0; --i) {\\n                char c = word.charAt(i);\\n                if(cur.next[c-\\'a\\'] == null) cur.next[c-\\'a\\'] = new TrieNode();\\n                cur = cur.next[c-\\'a\\'];\\n            }\\n            cur.term = true;\\n        }\\n    }\\n    public boolean search(List<Character> s) {\\n        TrieNode cur = root;\\n        for(int i = s.size() - 1; i >= 0; --i) {\\n            char c = s.get(i);\\n            if(cur.next[c-\\'a\\'] == null) return false;\\n            cur = cur.next[c-\\'a\\'];\\n            if(cur.term) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780343,
                "title": "with-only-stringbuilder-set-tle-16-17-tc-s-passed-help",
                "content": "If someone reads this solution it\\'d be really great if someone can help me improve this solution, without Trie.\\n\\n**Intuition:**\\nUsed hashset to store the words and look for it. We have to maintain a window of size of the word with max length. So once the size of the StringBuilder exceeds that length, we pop a char at the front. So essentially, sb acts as a queue here.\\nSo the time complexity of 1 query is O(maxlength(words))\\n```\\nclass StreamChecker {\\n    HashSet<String> dict = new HashSet<>();\\n    int window = 0;\\n    StringBuilder sb = new StringBuilder();\\n    public StreamChecker(String[] words) {\\n        for(String word :  words) {\\n            dict.add(word);\\n            window = Math.max(window, word.length());\\n        }\\n        \\n    }\\n    \\n    public boolean query(char letter) {\\n        sb.append(letter);\\n        if(sb.length() > window)\\n            sb.deleteCharAt(0);\\n        for(int i=0; i<sb.length();i++){\\n            if(dict.contains(sb.substring(i)))\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker {\\n    HashSet<String> dict = new HashSet<>();\\n    int window = 0;\\n    StringBuilder sb = new StringBuilder();\\n    public StreamChecker(String[] words) {\\n        for(String word :  words) {\\n            dict.add(word);\\n            window = Math.max(window, word.length());\\n        }\\n        \\n    }\\n    \\n    public boolean query(char letter) {\\n        sb.append(letter);\\n        if(sb.length() > window)\\n            sb.deleteCharAt(0);\\n        for(int i=0; i<sb.length();i++){\\n            if(dict.contains(sb.substring(i)))\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 722152,
                "title": "trie-solution-with-full-explanation",
                "content": "**Idea:**\\n* Since, the problem involves in searching for a word from dictionary, trie seems a good intuition to think about for useful data structures.\\n* Here, we need to see if the words are present in dictionary from any last `k` queried characters. \\n* Hence, we can create a trie of *reversed* words, and pass the list of character `queries` to search in reverse. \\n\\n```\\nclass StreamChecker {\\n\\n    private class TrieNode {\\n        Map<Character, TrieNode> map;\\n        boolean isEnd;\\n        \\n        TrieNode() {\\n            map = new HashMap<>();\\n            isEnd = false;\\n        }\\n    }\\n    \\n    private class Trie {\\n        TrieNode root;\\n        \\n        Trie() {\\n            root = new TrieNode();\\n        }\\n        \\n        void addReversedWord(String word) {\\n            TrieNode cur = root;\\n            \\n            for (int i = word.length() - 1; i >= 0; i--) {\\n                char ch = word.charAt(i);\\n                cur.map.putIfAbsent(ch, new TrieNode());\\n                cur = cur.map.get(ch);\\n            }\\n            \\n            cur.isEnd = true;\\n        }\\n        \\n        boolean search(Deque<Character> dq) {\\n            TrieNode cur = root;\\n            for (char ch : dq) {\\n                if (!cur.map.containsKey(ch)) {\\n                    return false;\\n                }\\n                cur = cur.map.get(ch);\\n                if (cur.isEnd) {\\n                    return true;\\n                }\\n            }\\n            \\n            return cur.isEnd;\\n        }\\n    }\\n    \\n    private int maxLen = 0;\\n    private Trie t;\\n    Deque<Character> dq;\\n    \\n    public StreamChecker(String[] words) {\\n        t = new Trie();\\n        for (String word: words) {\\n            maxLen = Math.max(maxLen, word.length());\\n            t.addReversedWord(word);\\n        }\\n        dq = new ArrayDeque<>();\\n    }\\n    \\n    public boolean query(char letter) {\\n        dq.addFirst(letter);\\n        if (dq.size() > maxLen) {\\n            dq.removeLast();\\n        }\\n        \\n        return t.search(dq);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker {\\n\\n    private class TrieNode {\\n        Map<Character, TrieNode> map;\\n        boolean isEnd;\\n        \\n        TrieNode() {\\n            map = new HashMap<>();\\n            isEnd = false;\\n        }\\n    }\\n    \\n    private class Trie {\\n        TrieNode root;\\n        \\n        Trie() {\\n            root = new TrieNode();\\n        }\\n        \\n        void addReversedWord(String word) {\\n            TrieNode cur = root;\\n            \\n            for (int i = word.length() - 1; i >= 0; i--) {\\n                char ch = word.charAt(i);\\n                cur.map.putIfAbsent(ch, new TrieNode());\\n                cur = cur.map.get(ch);\\n            }\\n            \\n            cur.isEnd = true;\\n        }\\n        \\n        boolean search(Deque<Character> dq) {\\n            TrieNode cur = root;\\n            for (char ch : dq) {\\n                if (!cur.map.containsKey(ch)) {\\n                    return false;\\n                }\\n                cur = cur.map.get(ch);\\n                if (cur.isEnd) {\\n                    return true;\\n                }\\n            }\\n            \\n            return cur.isEnd;\\n        }\\n    }\\n    \\n    private int maxLen = 0;\\n    private Trie t;\\n    Deque<Character> dq;\\n    \\n    public StreamChecker(String[] words) {\\n        t = new Trie();\\n        for (String word: words) {\\n            maxLen = Math.max(maxLen, word.length());\\n            t.addReversedWord(word);\\n        }\\n        dq = new ArrayDeque<>();\\n    }\\n    \\n    public boolean query(char letter) {\\n        dq.addFirst(letter);\\n        if (dq.size() > maxLen) {\\n            dq.removeLast();\\n        }\\n        \\n        return t.search(dq);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 703255,
                "title": "python-3-652-ms-faster-than-84-39-37-5-mb-less-than-82-30",
                "content": "I initially went for this solution which got TLE:\\n\\n```\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.t, self.h = {}, []\\n        for i in words:\\n            ct = self.t\\n            for j in i[::-1]:\\n                if j not in ct: ct[j] = {}\\n                ct = ct[j]\\n            ct[1] = True\\n\\n    def query(self, letter: str) -> bool:\\n        ct = self.t\\n        self.h.append(letter)\\n        for i in self.h[::-1]:\\n            if i not in ct: return False\\n            ct = ct[i]\\n            if 1 in ct: return True\\n        return False\\n```\\n\\nThan I made a small change which I borrowed from one of lee215\\'s solutions posted in the discussion thread:\\n\\n```\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.t, self.h = {}, \\'\\'\\n        for i in words:\\n            ct = self.t\\n            for j in i[::-1]:\\n                if j not in ct: ct[j] = {}\\n                ct = ct[j]\\n            ct[1] = True\\n\\n    def query(self, letter: str) -> bool:\\n        ct, self.h = self.t, letter + self.h\\n        for i in self.h:\\n            if i not in ct: return False\\n            ct = ct[i]\\n            if 1 in ct: return True\\n        return False\\n```\\n\\nApparently, this small change makes a big difference.",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.t, self.h = {}, []\\n        for i in words:\\n            ct = self.t\\n            for j in i[::-1]:\\n                if j not in ct: ct[j] = {}\\n                ct = ct[j]\\n            ct[1] = True\\n\\n    def query(self, letter: str) -> bool:\\n        ct = self.t\\n        self.h.append(letter)\\n        for i in self.h[::-1]:\\n            if i not in ct: return False\\n            ct = ct[i]\\n            if 1 in ct: return True\\n        return False\\n```\n```\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.t, self.h = {}, \\'\\'\\n        for i in words:\\n            ct = self.t\\n            for j in i[::-1]:\\n                if j not in ct: ct[j] = {}\\n                ct = ct[j]\\n            ct[1] = True\\n\\n    def query(self, letter: str) -> bool:\\n        ct, self.h = self.t, letter + self.h\\n        for i in self.h:\\n            if i not in ct: return False\\n            ct = ct[i]\\n            if 1 in ct: return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 653776,
                "title": "c-suffix-tree-540ms",
                "content": "Idea: Use suffix tree instead of prefix tree to allow efficient histroy search, since that works in a backward way.\\n\\n```c++\\nclass TrieNode {\\npublic:\\n    TrieNode() : word_end(false) {\\n        children = vector<TrieNode*>(alphabet_size);\\n    }\\n\\n    ~TrieNode() {\\n        for (auto child : children) {\\n            if (child)\\n                delete child;\\n        }\\n    }\\n\\n    TrieNode* get(char ch) {\\n        int idx = ch - \\'a\\';\\n        return children[idx];\\n    }\\n\\n    void set(char ch) {\\n        int idx = ch - \\'a\\';\\n        children[idx] = new TrieNode();\\n    }\\n\\n    bool isEnd() {\\n        return word_end;\\n    }\\n\\n    void setEnd() {\\n        word_end = true;\\n    }\\n\\nprivate:\\n    static constexpr int alphabet_size = 26;\\n    bool word_end;\\n    vector<TrieNode*> children;\\n};\\n\\nclass Trie {\\npublic:\\n    Trie() {\\n        root = new TrieNode();\\n    }\\n\\n    ~Trie() {\\n        delete root;\\n    }\\n\\n    void reverseInsert(const string& word) {\\n        TrieNode* node = root;\\n        for (int i = word.size() - 1; i >= 0; i--) {\\n            char ch = word[i];\\n            if (!node->get(ch)) {\\n                node->set(ch);\\n            }\\n            node = node->get(ch);\\n        }\\n        node->setEnd();\\n    }\\n\\n    bool historySearch(deque<char>& history) {\\n        TrieNode* node = root;\\n        for (int i = history.size() - 1; i >= 0; i--) {\\n            node = node->get(history[i]);\\n            if (!node)\\n                break;\\n            if (node->isEnd())\\n                return true;\\n        }\\n        return false;\\n    }\\n\\nprivate:\\n    TrieNode* root;\\n};\\n\\nclass StreamChecker {\\npublic:\\n    StreamChecker(vector<string>& words) {\\n        for (string &word : words)\\n            trie.reverseInsert(word);\\n    }\\n\\n    bool query(char letter) {\\n        history.push_back(letter);\\n        if (history.size() > wordLenLimit)\\n            history.pop_front();\\n\\n        return trie.historySearch(history);\\n    }\\n\\nprivate:\\n    Trie trie;\\n    const int wordLenLimit = 2000;\\n    deque<char> history;\\n};\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker* obj = new StreamChecker(words);\\n * bool param_1 = obj->query(letter);\\n */\\n ```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\nclass TrieNode {\\npublic:\\n    TrieNode() : word_end(false) {\\n        children = vector<TrieNode*>(alphabet_size);\\n    }\\n\\n    ~TrieNode() {\\n        for (auto child : children) {\\n            if (child)\\n                delete child;\\n        }\\n    }\\n\\n    TrieNode* get(char ch) {\\n        int idx = ch - \\'a\\';\\n        return children[idx];\\n    }\\n\\n    void set(char ch) {\\n        int idx = ch - \\'a\\';\\n        children[idx] = new TrieNode();\\n    }\\n\\n    bool isEnd() {\\n        return word_end;\\n    }\\n\\n    void setEnd() {\\n        word_end = true;\\n    }\\n\\nprivate:\\n    static constexpr int alphabet_size = 26;\\n    bool word_end;\\n    vector<TrieNode*> children;\\n};\\n\\nclass Trie {\\npublic:\\n    Trie() {\\n        root = new TrieNode();\\n    }\\n\\n    ~Trie() {\\n        delete root;\\n    }\\n\\n    void reverseInsert(const string& word) {\\n        TrieNode* node = root;\\n        for (int i = word.size() - 1; i >= 0; i--) {\\n            char ch = word[i];\\n            if (!node->get(ch)) {\\n                node->set(ch);\\n            }\\n            node = node->get(ch);\\n        }\\n        node->setEnd();\\n    }\\n\\n    bool historySearch(deque<char>& history) {\\n        TrieNode* node = root;\\n        for (int i = history.size() - 1; i >= 0; i--) {\\n            node = node->get(history[i]);\\n            if (!node)\\n                break;\\n            if (node->isEnd())\\n                return true;\\n        }\\n        return false;\\n    }\\n\\nprivate:\\n    TrieNode* root;\\n};\\n\\nclass StreamChecker {\\npublic:\\n    StreamChecker(vector<string>& words) {\\n        for (string &word : words)\\n            trie.reverseInsert(word);\\n    }\\n\\n    bool query(char letter) {\\n        history.push_back(letter);\\n        if (history.size() > wordLenLimit)\\n            history.pop_front();\\n\\n        return trie.historySearch(history);\\n    }\\n\\nprivate:\\n    Trie trie;\\n    const int wordLenLimit = 2000;\\n    deque<char> history;\\n};\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker* obj = new StreamChecker(words);\\n * bool param_1 = obj->query(letter);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 620468,
                "title": "python3-trie",
                "content": "a) Create a Trie of reversed strings\\nb) For each letter try to iterate over all inserted letters in query and search them over the trie\\n```\\nfrom collections import defaultdict\\nclass TrieNode():\\n    def __init__(self):\\n        self.children = defaultdict(TrieNode)\\n        self.is_word = False\\n\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.trie = TrieNode()\\n        for word in words:\\n            trie = self.trie\\n            rev = word[::-1]\\n            for char in rev:\\n                trie = trie.children[char]\\n            trie.is_word = True\\n        self.stk = []\\n    \\n    def query(self, letter: str) -> bool:\\n        trie = self.trie\\n        self.stk.append(letter)\\n        for i in range(len(self.stk)-1, -1, -1):\\n            let = self.stk[i]\\n            if trie.is_word:\\n                return True\\n            if let not in trie.children:\\n                return False\\n            trie = trie.children[let]\\n        return trie.is_word\\n            \\n\\n# Your StreamChecker object will be instantiated and called as such:\\n# obj = StreamChecker(words)\\n# param_1 = obj.query(letter)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nclass TrieNode():\\n    def __init__(self):\\n        self.children = defaultdict(TrieNode)\\n        self.is_word = False\\n\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.trie = TrieNode()\\n        for word in words:\\n            trie = self.trie\\n            rev = word[::-1]\\n            for char in rev:\\n                trie = trie.children[char]\\n            trie.is_word = True\\n        self.stk = []\\n    \\n    def query(self, letter: str) -> bool:\\n        trie = self.trie\\n        self.stk.append(letter)\\n        for i in range(len(self.stk)-1, -1, -1):\\n            let = self.stk[i]\\n            if trie.is_word:\\n                return True\\n            if let not in trie.children:\\n                return False\\n            trie = trie.children[let]\\n        return trie.is_word\\n            \\n\\n# Your StreamChecker object will be instantiated and called as such:\\n# obj = StreamChecker(words)\\n# param_1 = obj.query(letter)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 613610,
                "title": "c-14-lines-simple-solution-sorted-set-without-trie",
                "content": "```\\nclass StreamChecker {\\npublic:\\n    \\n    StreamChecker(const vector<string>& words) {\\n        for (const string& w : words) words_.emplace(w.rbegin(), w.rend());\\n    }\\n    \\n    bool query(char letter) {\\n        stream_ += letter;\\n        string pref;\\n        for (int k=0; k < stream_.size(); k++) {\\n            pref += stream_[stream_.size() - 1 - k];\\n            \\n            auto begin = words_.lower_bound(pref);\\n            pref.back()++;\\n            auto end = words_.lower_bound(pref);\\n            pref.back()--;\\n            \\n            if (begin == end) return false;\\n            if (*begin == pref) return true;\\n        }\\n        return false;\\n    }\\n\\n    string stream_;\\n    set<string> words_;\\n};\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker* obj = new StreamChecker(words);\\n * bool param_1 = obj->query(letter);\\n */```",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker {\\npublic:\\n    \\n    StreamChecker(const vector<string>& words) {\\n        for (const string& w : words) words_.emplace(w.rbegin(), w.rend());\\n    }\\n    \\n    bool query(char letter) {\\n        stream_ += letter;\\n        string pref;\\n        for (int k=0; k < stream_.size(); k++) {\\n            pref += stream_[stream_.size() - 1 - k];\\n            \\n            auto begin = words_.lower_bound(pref);\\n            pref.back()++;\\n            auto end = words_.lower_bound(pref);\\n            pref.back()--;\\n            \\n            if (begin == end) return false;\\n            if (*begin == pref) return true;\\n        }\\n        return false;\\n    }\\n\\n    string stream_;\\n    set<string> words_;\\n};\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker* obj = new StreamChecker(words);\\n * bool param_1 = obj->query(letter);\\n */```",
                "codeTag": "Java"
            },
            {
                "id": 611580,
                "title": "java-very-easy-a-trie-solution-with-explanation",
                "content": "```\\nclass StreamChecker {\\n    private class Trie {\\n        Map<Character, Trie> map = new HashMap<>();\\n        boolean isLast;\\n    }\\n    \\n    private final Trie trie;\\n    private final FixedRotationList history;\\n\\n    public StreamChecker(String[] words) {\\n        this.trie = new Trie();\\n        this.history = new FixedRotationList();\\n        \\n        \\n        for (String word : words) {\\n            Trie cur = this.trie;\\n            \\n            char[] arr = word.toCharArray();\\n            \\n            /**\\n            * we use a reverse trie so we fill it in reverse order\\n            */\\n            for (int i = arr.length-1; i >= 0; i--) { // insert into the tree\\n                if (!cur.map.containsKey(arr[i])) {\\n                    cur.map.put(arr[i], new Trie());\\n                } \\n                \\n                cur = cur.map.get(arr[i]);            \\n            }\\n            \\n            cur.isLast = true;\\n        }\\n    }\\n    \\n    \\n    \\n    public boolean query(char letter) {\\n        history.add(letter);\\n\\n        Trie cur = this.trie; // get a link in order update it futher\\n        \\n        /**\\n        * insofar we use the reverse trie, so we iterate in reverse order\\n        */\\n        for (int i = history.size()-1; i >= 0; i--) {\\n            Character curLetter = history.get(i); \\n\\n            if (cur == null || !cur.map.containsKey(curLetter)) return false;\\n\\n            if (cur.map.containsKey(curLetter) && cur.map.get(curLetter).isLast) return true;\\n\\n            cur = cur.map.get(curLetter);\\n        }\\n\\n        return false;\\n    }\\n}\\n\\nclass FixedRotationList {\\n    private final int MAX_LENGTH = 2_000;\\n    private List<Character> list = new ArrayList<>(MAX_LENGTH);\\n    private int curLen = 0;\\n    \\n    public int size() {\\n        return list.size();\\n    }\\n    \\n    public Character get(int idx) {\\n        if (list.isEmpty())\\n            return null;\\n\\n        if (list.size() < MAX_LENGTH)\\n            return list.get(idx);\\n\\n\\n        idx = (idx + curLen) % MAX_LENGTH;\\n\\n        return list.get(idx);\\n    }\\n\\n    public void add(char letter) {\\n        if (curLen >= MAX_LENGTH) {\\n            list.set(curLen%MAX_LENGTH, letter);\\n        } else {\\n            list.add(letter);\\n        }\\n\\n\\n        curLen++;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Trie"
                ],
                "code": "```\\nclass StreamChecker {\\n    private class Trie {\\n        Map<Character, Trie> map = new HashMap<>();\\n        boolean isLast;\\n    }\\n    \\n    private final Trie trie;\\n    private final FixedRotationList history;\\n\\n    public StreamChecker(String[] words) {\\n        this.trie = new Trie();\\n        this.history = new FixedRotationList();\\n        \\n        \\n        for (String word : words) {\\n            Trie cur = this.trie;\\n            \\n            char[] arr = word.toCharArray();\\n            \\n            /**\\n            * we use a reverse trie so we fill it in reverse order\\n            */\\n            for (int i = arr.length-1; i >= 0; i--) { // insert into the tree\\n                if (!cur.map.containsKey(arr[i])) {\\n                    cur.map.put(arr[i], new Trie());\\n                } \\n                \\n                cur = cur.map.get(arr[i]);            \\n            }\\n            \\n            cur.isLast = true;\\n        }\\n    }\\n    \\n    \\n    \\n    public boolean query(char letter) {\\n        history.add(letter);\\n\\n        Trie cur = this.trie; // get a link in order update it futher\\n        \\n        /**\\n        * insofar we use the reverse trie, so we iterate in reverse order\\n        */\\n        for (int i = history.size()-1; i >= 0; i--) {\\n            Character curLetter = history.get(i); \\n\\n            if (cur == null || !cur.map.containsKey(curLetter)) return false;\\n\\n            if (cur.map.containsKey(curLetter) && cur.map.get(curLetter).isLast) return true;\\n\\n            cur = cur.map.get(curLetter);\\n        }\\n\\n        return false;\\n    }\\n}\\n\\nclass FixedRotationList {\\n    private final int MAX_LENGTH = 2_000;\\n    private List<Character> list = new ArrayList<>(MAX_LENGTH);\\n    private int curLen = 0;\\n    \\n    public int size() {\\n        return list.size();\\n    }\\n    \\n    public Character get(int idx) {\\n        if (list.isEmpty())\\n            return null;\\n\\n        if (list.size() < MAX_LENGTH)\\n            return list.get(idx);\\n\\n\\n        idx = (idx + curLen) % MAX_LENGTH;\\n\\n        return list.get(idx);\\n    }\\n\\n    public void add(char letter) {\\n        if (curLen >= MAX_LENGTH) {\\n            list.set(curLen%MAX_LENGTH, letter);\\n        } else {\\n            list.add(letter);\\n        }\\n\\n\\n        curLen++;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 570901,
                "title": "java-simple-code-trie-reverse-words",
                "content": "```\\nclass StreamChecker {\\n\\n    class TrieNode {\\n        boolean isWord = false;\\n        TrieNode[] children = new TrieNode[26];\\n    }\\n    \\n    TrieNode root = new TrieNode();\\n    List<Character> list = new ArrayList<>();\\n    \\n    public StreamChecker(String[] words) {\\n        for (String s : words) {\\n            TrieNode node = root;\\n            for (int i = s.length()-1; i >= 0; i--) {\\n                if (node.children[s.charAt(i)-\\'a\\'] == null) {\\n                    node.children[s.charAt(i)-\\'a\\'] = new TrieNode();    \\n                }                \\n                node = node.children[s.charAt(i)-\\'a\\'];\\n            }\\n            node.isWord = true;\\n        }\\n    }\\n    \\n    public boolean query(char letter) {\\n        list.add(letter);\\n        TrieNode node = root;\\n        for (int i = list.size()-1; i >= 0; i--) {\\n            TrieNode next = node.children[list.get(i)-\\'a\\'];\\n            if (next == null) return false;\\n            if (next.isWord) return true;\\n            node = next;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker {\\n\\n    class TrieNode {\\n        boolean isWord = false;\\n        TrieNode[] children = new TrieNode[26];\\n    }\\n    \\n    TrieNode root = new TrieNode();\\n    List<Character> list = new ArrayList<>();\\n    \\n    public StreamChecker(String[] words) {\\n        for (String s : words) {\\n            TrieNode node = root;\\n            for (int i = s.length()-1; i >= 0; i--) {\\n                if (node.children[s.charAt(i)-\\'a\\'] == null) {\\n                    node.children[s.charAt(i)-\\'a\\'] = new TrieNode();    \\n                }                \\n                node = node.children[s.charAt(i)-\\'a\\'];\\n            }\\n            node.isWord = true;\\n        }\\n    }\\n    \\n    public boolean query(char letter) {\\n        list.add(letter);\\n        TrieNode node = root;\\n        for (int i = list.size()-1; i >= 0; i--) {\\n            TrieNode next = node.children[list.get(i)-\\'a\\'];\\n            if (next == null) return false;\\n            if (next.isWord) return true;\\n            node = next;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 555180,
                "title": "short-and-simple-java-trie-solution",
                "content": "```\\nclass StreamChecker {\\n    private List<Character> list;\\n    private TrieNode root;\\n    \\n    public StreamChecker(String[] words) {\\n        list = new ArrayList<>();\\n        root = new TrieNode();\\n        for (String word : words) {\\n            TrieNode curr = root;\\n            for (int i = word.length() - 1; i >= 0; i--) {\\n                char c = word.charAt(i);\\n                if (curr.next[c - \\'a\\'] == null) curr.next[c - \\'a\\'] = new TrieNode();\\n                curr = curr.next[c - \\'a\\'];\\n            }\\n            curr.isWord = true;\\n        }\\n    }\\n    \\n    public boolean query(char letter) {\\n        list.add(letter);\\n        TrieNode curr = root;\\n        for (int i = list.size() - 1; i >= 0; i--) {\\n            char c = list.get(i);\\n            curr = curr.next[c - \\'a\\'];\\n            if (curr == null) return false;\\n            if (curr.isWord) return true;\\n        }\\n        return false;\\n    }\\n\\t\\n    class TrieNode {\\n        boolean isWord;\\n        TrieNode[] next;\\n        public TrieNode() {\\n            this.isWord = false;\\n            this.next = new TrieNode[26];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker {\\n    private List<Character> list;\\n    private TrieNode root;\\n    \\n    public StreamChecker(String[] words) {\\n        list = new ArrayList<>();\\n        root = new TrieNode();\\n        for (String word : words) {\\n            TrieNode curr = root;\\n            for (int i = word.length() - 1; i >= 0; i--) {\\n                char c = word.charAt(i);\\n                if (curr.next[c - \\'a\\'] == null) curr.next[c - \\'a\\'] = new TrieNode();\\n                curr = curr.next[c - \\'a\\'];\\n            }\\n            curr.isWord = true;\\n        }\\n    }\\n    \\n    public boolean query(char letter) {\\n        list.add(letter);\\n        TrieNode curr = root;\\n        for (int i = list.size() - 1; i >= 0; i--) {\\n            char c = list.get(i);\\n            curr = curr.next[c - \\'a\\'];\\n            if (curr == null) return false;\\n            if (curr.isWord) return true;\\n        }\\n        return false;\\n    }\\n\\t\\n    class TrieNode {\\n        boolean isWord;\\n        TrieNode[] next;\\n        public TrieNode() {\\n            this.isWord = false;\\n            this.next = new TrieNode[26];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 545143,
                "title": "easy-straightforward-solution-using-trie-on-c-language",
                "content": "```\\nint pos;\\ntypedef struct StreamChecker {\\n    int isLeaf;\\n    struct StreamChecker *child[26];\\n} StreamChecker;\\n\\nstruct StreamChecker* create(){\\n    struct StreamChecker* node = (struct StreamChecker*)malloc(sizeof(struct StreamChecker));\\n    int i;\\n    for(i=0;i<26;i++){\\n        node->child[i]=NULL;\\n    }\\n    node->isLeaf = 0;\\n    return node;\\n}\\nvoid insert(struct StreamChecker* root, char word[]){\\n    int i,index;\\n    struct StreamChecker* cur = root;\\n    //printf(\"%s\\\\n\",word);\\n    for(i=0;word[i];i++){\\n        index = word[i]-\\'a\\';\\n        if(!cur->child[index]){\\n            cur->child[index]=create();\\n        }\\n        cur=cur->child[index];\\n    }\\n    cur->isLeaf = 1;\\n}\\nvoid reverse(StreamChecker* root, char w[]){\\n    int i,j=0;\\n    char word[2005];\\n    for(i=0;w[i];i++);\\n    i--;\\n    while(i>=0){\\n        word[j++]=w[i];\\n        i--;\\n    }\\n    word[j]=\\'\\\\0\\';\\n   // printf(\"%s\\\\n\",word);\\n    insert(root, word); \\n}\\nStreamChecker* streamCheckerCreate(char ** words, int wSize) {\\n    struct StreamChecker* root = create();\\n    int i;pos=-1;\\n    for(i=0;i<wSize;i++){\\n        reverse(root,words[i]);\\n    }\\n    return root;\\n}\\nbool check(StreamChecker* obj, char letArr[], int j){\\n    int i,index;\\n    StreamChecker* cur = obj;\\n    while(j>=0){\\n        index = letArr[j]-\\'a\\';\\n        if(!cur->child[index]){\\n            //printf(\"False for %c\\\\n\",(char)(index+\\'a\\'));\\n            return false;\\n        }\\n        cur = cur->child[index];\\n        if(cur->isLeaf)\\n        {//printf(\"True for %c\\\\n\",(char)(index+\\'a\\'));\\n            return true;}\\n        j--;\\n    }\\n    return false;\\n}\\n\\nbool streamCheckerQuery(StreamChecker* obj, char letter) {\\n    char letArr[400005]; // This is a bug;\\n    letArr[++pos] = letter;\\n    return check(obj, letArr, pos);\\n}\\n\\nvoid streamCheckerFree(StreamChecker* obj) {\\n    int i;\\n    for(i=0;i<26;i++){\\n        if(obj->child[i]){\\n            streamCheckerFree(obj->child[i]);\\n        }\\n    }\\n    free(obj);\\n}\\n\\n/**\\n * Your StreamChecker struct will be instantiated and called as such:\\n * StreamChecker* obj = streamCheckerCreate(words, wordsSize);\\n * bool param_1 = streamCheckerQuery(obj, letter);\\n \\n * streamCheckerFree(obj);\\n*/\\n``",
                "solutionTags": [],
                "code": "```\\nint pos;\\ntypedef struct StreamChecker {\\n    int isLeaf;\\n    struct StreamChecker *child[26];\\n} StreamChecker;\\n\\nstruct StreamChecker* create(){\\n    struct StreamChecker* node = (struct StreamChecker*)malloc(sizeof(struct StreamChecker));\\n    int i;\\n    for(i=0;i<26;i++){\\n        node->child[i]=NULL;\\n    }\\n    node->isLeaf = 0;\\n    return node;\\n}\\nvoid insert(struct StreamChecker* root, char word[]){\\n    int i,index;\\n    struct StreamChecker* cur = root;\\n    //printf(\"%s\\\\n\",word);\\n    for(i=0;word[i];i++){\\n        index = word[i]-\\'a\\';\\n        if(!cur->child[index]){\\n            cur->child[index]=create();\\n        }\\n        cur=cur->child[index];\\n    }\\n    cur->isLeaf = 1;\\n}\\nvoid reverse(StreamChecker* root, char w[]){\\n    int i,j=0;\\n    char word[2005];\\n    for(i=0;w[i];i++);\\n    i--;\\n    while(i>=0){\\n        word[j++]=w[i];\\n        i--;\\n    }\\n    word[j]=\\'\\\\0\\';\\n   // printf(\"%s\\\\n\",word);\\n    insert(root, word); \\n}\\nStreamChecker* streamCheckerCreate(char ** words, int wSize) {\\n    struct StreamChecker* root = create();\\n    int i;pos=-1;\\n    for(i=0;i<wSize;i++){\\n        reverse(root,words[i]);\\n    }\\n    return root;\\n}\\nbool check(StreamChecker* obj, char letArr[], int j){\\n    int i,index;\\n    StreamChecker* cur = obj;\\n    while(j>=0){\\n        index = letArr[j]-\\'a\\';\\n        if(!cur->child[index]){\\n            //printf(\"False for %c\\\\n\",(char)(index+\\'a\\'));\\n            return false;\\n        }\\n        cur = cur->child[index];\\n        if(cur->isLeaf)\\n        {//printf(\"True for %c\\\\n\",(char)(index+\\'a\\'));\\n            return true;}\\n        j--;\\n    }\\n    return false;\\n}\\n\\nbool streamCheckerQuery(StreamChecker* obj, char letter) {\\n    char letArr[400005]; // This is a bug;\\n    letArr[++pos] = letter;\\n    return check(obj, letArr, pos);\\n}\\n\\nvoid streamCheckerFree(StreamChecker* obj) {\\n    int i;\\n    for(i=0;i<26;i++){\\n        if(obj->child[i]){\\n            streamCheckerFree(obj->child[i]);\\n        }\\n    }\\n    free(obj);\\n}\\n\\n/**\\n * Your StreamChecker struct will be instantiated and called as such:\\n * StreamChecker* obj = streamCheckerCreate(words, wordsSize);\\n * bool param_1 = streamCheckerQuery(obj, letter);\\n \\n * streamCheckerFree(obj);\\n*/\\n``",
                "codeTag": "Python3"
            },
            {
                "id": 540828,
                "title": "java-ac-and-slow",
                "content": "\\n```\\nclass StreamChecker {\\n    Trie trie = new Trie();\\n    public StreamChecker(String[] words) {\\n        \\n        for(String word : words) {\\n            trie.add(new StringBuilder(word).reverse().toString());\\n        }\\n    }\\n    StringBuilder sb = new StringBuilder();\\n    public boolean query(char letter) {\\n        sb.insert(0, letter);\\n        if(trie.root.chars[letter-\\'a\\'] != null) {\\n             if(trie.findPrefix(sb.toString())){\\n                 return true;\\n             }   \\n        }\\n        return false;\\n    }\\n    \\n    \\n    class TrieNode {\\n        TrieNode [] chars = new TrieNode[26];\\n        boolean isWord = false;            \\n    } \\n    \\n    \\n    class Trie {\\n        \\n        TrieNode root;\\n        \\n        Trie() {\\n            root = new TrieNode();\\n        }\\n        \\n        public void add(String word) {\\n            TrieNode cur = root;\\n            for(char c : word.toCharArray()) {\\n                if(cur.chars[c-\\'a\\'] == null) {\\n                    cur.chars[c-\\'a\\'] = new TrieNode();\\n                }\\n                cur = cur.chars[c-\\'a\\'];\\n            }\\n            cur.isWord = true;\\n        }\\n        \\n        public boolean find(String word) {\\n            TrieNode cur = root;\\n            for(char c : word.toCharArray()) {\\n                if(cur.chars[c-\\'a\\'] == null) return false;\\n                cur = cur.chars[c-\\'a\\'];\\n            }\\n            return cur.isWord;\\n        }\\n        \\n        \\n        public boolean findPrefix(String word) {\\n            TrieNode cur = root;\\n            for(char c : word.toCharArray()) {\\n                if(cur.chars[c-\\'a\\'] == null) return false;\\n                cur = cur.chars[c-\\'a\\'];\\n                if(cur.isWord) return true;\\n            }\\n            return false;\\n        }\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "\\n```\\nclass StreamChecker {\\n    Trie trie = new Trie();\\n    public StreamChecker(String[] words) {\\n        \\n        for(String word : words) {\\n            trie.add(new StringBuilder(word).reverse().toString());\\n        }\\n    }\\n    StringBuilder sb = new StringBuilder();\\n    public boolean query(char letter) {\\n        sb.insert(0, letter);\\n        if(trie.root.chars[letter-\\'a\\'] != null) {\\n             if(trie.findPrefix(sb.toString())){\\n                 return true;\\n             }   \\n        }\\n        return false;\\n    }\\n    \\n    \\n    class TrieNode {\\n        TrieNode [] chars = new TrieNode[26];\\n        boolean isWord = false;            \\n    } \\n    \\n    \\n    class Trie {\\n        \\n        TrieNode root;\\n        \\n        Trie() {\\n            root = new TrieNode();\\n        }\\n        \\n        public void add(String word) {\\n            TrieNode cur = root;\\n            for(char c : word.toCharArray()) {\\n                if(cur.chars[c-\\'a\\'] == null) {\\n                    cur.chars[c-\\'a\\'] = new TrieNode();\\n                }\\n                cur = cur.chars[c-\\'a\\'];\\n            }\\n            cur.isWord = true;\\n        }\\n        \\n        public boolean find(String word) {\\n            TrieNode cur = root;\\n            for(char c : word.toCharArray()) {\\n                if(cur.chars[c-\\'a\\'] == null) return false;\\n                cur = cur.chars[c-\\'a\\'];\\n            }\\n            return cur.isWord;\\n        }\\n        \\n        \\n        public boolean findPrefix(String word) {\\n            TrieNode cur = root;\\n            for(char c : word.toCharArray()) {\\n                if(cur.chars[c-\\'a\\'] == null) return false;\\n                cur = cur.chars[c-\\'a\\'];\\n                if(cur.isWord) return true;\\n            }\\n            return false;\\n        }\\n    }\\n}\\n",
                "codeTag": "Java"
            },
            {
                "id": 535938,
                "title": "golang-trie",
                "content": "```\\ntype trieNode struct {\\n\\tchildren [26]*trieNode\\n\\tisWord   bool\\n}\\n\\ntype StreamChecker struct {\\n\\tqueryWord    []byte\\n\\ttrieTreeRoot *trieNode\\n}\\n\\nfunc Constructor(words []string) StreamChecker {\\n\\troot := &trieNode{\\n\\t\\tchildren: [26]*trieNode{},\\n\\t\\tisWord:   false,\\n\\t}\\n\\tfor _, word := range words {\\n\\t\\tcur := root\\n\\t\\tfor i := len(word) - 1; i >= 0; i-- {\\n\\t\\t\\tch := int(word[i] - \\'a\\')\\n\\t\\t\\tif cur.children[ch] == nil {\\n\\t\\t\\t\\tcur.children[ch] = &trieNode{\\n\\t\\t\\t\\t\\tchildren: [26]*trieNode{},\\n\\t\\t\\t\\t\\tisWord:   false,\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tcur = cur.children[ch]\\n\\t\\t}\\n\\t\\tcur.isWord = true\\n\\t}\\n\\treturn StreamChecker{\\n\\t\\ttrieTreeRoot: root,\\n\\t\\tqueryWord:    []byte{},\\n\\t}\\n}\\n\\nfunc (this *StreamChecker) Query(letter byte) bool {\\n\\tthis.queryWord = append(this.queryWord, letter)\\n\\tcur := this.trieTreeRoot\\n\\tfor i := len(this.queryWord) - 1; i >= 0; i-- {\\n\\t\\tch := int(this.queryWord[i] - \\'a\\')\\n\\t\\tif cur.children[ch] == nil {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t\\tcur = cur.children[ch]\\n\\t\\tif cur.isWord {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntype trieNode struct {\\n\\tchildren [26]*trieNode\\n\\tisWord   bool\\n}\\n\\ntype StreamChecker struct {\\n\\tqueryWord    []byte\\n\\ttrieTreeRoot *trieNode\\n}\\n\\nfunc Constructor(words []string) StreamChecker {\\n\\troot := &trieNode{\\n\\t\\tchildren: [26]*trieNode{},\\n\\t\\tisWord:   false,\\n\\t}\\n\\tfor _, word := range words {\\n\\t\\tcur := root\\n\\t\\tfor i := len(word) - 1; i >= 0; i-- {\\n\\t\\t\\tch := int(word[i] - \\'a\\')\\n\\t\\t\\tif cur.children[ch] == nil {\\n\\t\\t\\t\\tcur.children[ch] = &trieNode{\\n\\t\\t\\t\\t\\tchildren: [26]*trieNode{},\\n\\t\\t\\t\\t\\tisWord:   false,\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tcur = cur.children[ch]\\n\\t\\t}\\n\\t\\tcur.isWord = true\\n\\t}\\n\\treturn StreamChecker{\\n\\t\\ttrieTreeRoot: root,\\n\\t\\tqueryWord:    []byte{},\\n\\t}\\n}\\n\\nfunc (this *StreamChecker) Query(letter byte) bool {\\n\\tthis.queryWord = append(this.queryWord, letter)\\n\\tcur := this.trieTreeRoot\\n\\tfor i := len(this.queryWord) - 1; i >= 0; i-- {\\n\\t\\tch := int(this.queryWord[i] - \\'a\\')\\n\\t\\tif cur.children[ch] == nil {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t\\tcur = cur.children[ch]\\n\\t\\tif cur.isWord {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 514204,
                "title": "trie-python",
                "content": "1. add the reversed words to a Trie\\n2. every add read the last k characters backwards and traverse the trie at the same time\\n\\n```\\nclass TNode(object):\\n    def __init__(self):\\n        self.d,self.f = {}, False\\nclass StreamChecker(object):\\n    def __init__(self, words):\\n        self.root = TNode()\\n        self.max_ = max(map(len, words))\\n        for w in words:\\n            cur = self.root\\n            for j in range(len(w)-1,-1,-1):\\n                if w[j] not in cur.d: cur.d[w[j]] = TNode()\\n                cur = cur.d[w[j]]\\n            cur.f = True\\n        self.q = collections.deque([])        \\n\\n    def query(self, letter):\\n        self.q.appendleft(letter)\\n        if len(self.q) > self.max_: self.q.pop()\\n        cur= self.root\\n        for l in self.q:\\n            if l not in cur.d: return False\\n            cur = cur.d[l]\\n            if cur.f:\\n                return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass TNode(object):\\n    def __init__(self):\\n        self.d,self.f = {}, False\\nclass StreamChecker(object):\\n    def __init__(self, words):\\n        self.root = TNode()\\n        self.max_ = max(map(len, words))\\n        for w in words:\\n            cur = self.root\\n            for j in range(len(w)-1,-1,-1):\\n                if w[j] not in cur.d: cur.d[w[j]] = TNode()\\n                cur = cur.d[w[j]]\\n            cur.f = True\\n        self.q = collections.deque([])        \\n\\n    def query(self, letter):\\n        self.q.appendleft(letter)\\n        if len(self.q) > self.max_: self.q.pop()\\n        cur= self.root\\n        for l in self.q:\\n            if l not in cur.d: return False\\n            cur = cur.d[l]\\n            if cur.f:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 513592,
                "title": "swift-trie-solution",
                "content": "```\\nclass Trie {\\n    var val: Character\\n    var dict = [Character: Trie]()\\n    var end: Bool = false\\n\\n    init(_ val: Character) {\\n        self.val = val\\n    }\\n}\\n\\nclass Node {\\n    var val: Character\\n    var next: Node?\\n\\n    init(_ val: Character) {\\n        self.val = val\\n    }\\n}\\n\\nclass StreamChecker {\\n    var trie = Trie(\"*\")\\n    var node: Node?\\n    var maxi: Int = 0\\n    init(_ words: [String]) {\\n        for word in words {\\n            populate(&trie, word)\\n        }\\n    }\\n    \\n    func populate(_ trie: inout Trie, _ word: String) {\\n        var temp: Trie? = trie\\n        let array = Array(word)\\n        maxi = max(maxi, array.count)\\n        for letter in Array(word).reversed() {\\n            if temp?.dict[letter] == nil {\\n                temp?.dict[letter] = Trie(letter)\\n            }\\n\\n            temp = temp?.dict[letter]\\n        }\\n\\n        temp?.end = true\\n    }\\n    \\n    func query(_ letter: Character) -> Bool {\\n        let newNode = Node(letter)\\n        if node == nil {\\n            node = newNode\\n        } else {\\n            newNode.next = node\\n            node = newNode\\n        }\\n        \\n        return search(trie, node)\\n    }\\n    \\n    func search(_ trie: Trie, _ node: Node?) -> Bool {\\n        var count = 0\\n        var temp: Node? = node\\n        var tempTrie: Trie? = trie\\n        while count <= maxi {\\n            if let current = temp?.val {\\n                count += 1\\n                if tempTrie?.dict[current] != nil {\\n                    tempTrie = tempTrie?.dict[current]\\n                    if tempTrie?.end ?? false {\\n                        return true\\n                    }\\n                } else {\\n                    return false\\n                }\\n                \\n                temp = temp?.next\\n            } else {\\n                return false\\n            }\\n        }\\n        \\n        return false\\n    }\\n}\\n\\n```\\nTime complexity = O(N)",
                "solutionTags": [],
                "code": "```\\nclass Trie {\\n    var val: Character\\n    var dict = [Character: Trie]()\\n    var end: Bool = false\\n\\n    init(_ val: Character) {\\n        self.val = val\\n    }\\n}\\n\\nclass Node {\\n    var val: Character\\n    var next: Node?\\n\\n    init(_ val: Character) {\\n        self.val = val\\n    }\\n}\\n\\nclass StreamChecker {\\n    var trie = Trie(\"*\")\\n    var node: Node?\\n    var maxi: Int = 0\\n    init(_ words: [String]) {\\n        for word in words {\\n            populate(&trie, word)\\n        }\\n    }\\n    \\n    func populate(_ trie: inout Trie, _ word: String) {\\n        var temp: Trie? = trie\\n        let array = Array(word)\\n        maxi = max(maxi, array.count)\\n        for letter in Array(word).reversed() {\\n            if temp?.dict[letter] == nil {\\n                temp?.dict[letter] = Trie(letter)\\n            }\\n\\n            temp = temp?.dict[letter]\\n        }\\n\\n        temp?.end = true\\n    }\\n    \\n    func query(_ letter: Character) -> Bool {\\n        let newNode = Node(letter)\\n        if node == nil {\\n            node = newNode\\n        } else {\\n            newNode.next = node\\n            node = newNode\\n        }\\n        \\n        return search(trie, node)\\n    }\\n    \\n    func search(_ trie: Trie, _ node: Node?) -> Bool {\\n        var count = 0\\n        var temp: Node? = node\\n        var tempTrie: Trie? = trie\\n        while count <= maxi {\\n            if let current = temp?.val {\\n                count += 1\\n                if tempTrie?.dict[current] != nil {\\n                    tempTrie = tempTrie?.dict[current]\\n                    if tempTrie?.end ?? false {\\n                        return true\\n                    }\\n                } else {\\n                    return false\\n                }\\n                \\n                temp = temp?.next\\n            } else {\\n                return false\\n            }\\n        }\\n        \\n        return false\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 505504,
                "title": "javascript-trie-solution",
                "content": "```js\\n\\n/*******************************************\\n * * Helper Items                         *\\n*******************************************/\\n\\n/**\\n * @description A trie node\\n */\\nconst TrieNode = function() {\\n  this.children = {};\\n  this.isEnd = false;\\n};\\n\\n/**\\n * @param {char} ch char == a string with a length of one\\n */\\nTrieNode.prototype.add = function(ch) {\\n  this.children[ch] = new TrieNode();\\n}\\n\\n\\n/**\\n * @param {string} word\\n */\\nTrieNode.prototype.addWord = function(word) {\\n  let curNode = this;\\n  for (let ch = 0; ch < word.length; ch++) {\\n    const char = word[ch];\\n    \\n    if (!curNode.children.hasOwnProperty(char)) {\\n      curNode.add(char);\\n      curNode = curNode.children[char];\\n    } else {\\n      curNode = curNode.children[char];\\n    }\\n  }\\n  curNode.isEnd = true;\\n}\\n\\n\\n\\n\\n/*******************************************\\n * * Given Items                           *\\n*******************************************/\\n\\n/**\\n * @param {string[]} words\\n */\\nvar StreamChecker = function(words) {\\n  this.trie = new TrieNode(null);\\n  this.searches = [];\\n\\n  for (let i = 0; i < words.length; i++) {\\n    let curNode = this.trie;\\n    const werd = words[i].split(\\'\\').reverse();\\n    curNode.addWord(werd);\\n\\n  }\\n};\\n\\n/** \\n * @param {character} letter\\n * @return {boolean}\\n */\\nStreamChecker.prototype.query = function(letter) {\\n  this.searches.push(letter);\\n\\n  let curNode = this.trie;\\n  for (let i = this.searches.length - 1; i >= 0; i--) {\\n    const curChar = this.searches[i];\\n\\n    if (!curNode.children.hasOwnProperty(curChar)) return false;\\n    else {\\n      curNode = curNode.children[curChar];\\n      if (curNode.isEnd) return true;\\n    } \\n  }\\n  return false\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```js\\n\\n/*******************************************\\n * * Helper Items                         *\\n*******************************************/\\n\\n/**\\n * @description A trie node\\n */\\nconst TrieNode = function() {\\n  this.children = {};\\n  this.isEnd = false;\\n};\\n\\n/**\\n * @param {char} ch char == a string with a length of one\\n */\\nTrieNode.prototype.add = function(ch) {\\n  this.children[ch] = new TrieNode();\\n}\\n\\n\\n/**\\n * @param {string} word\\n */\\nTrieNode.prototype.addWord = function(word) {\\n  let curNode = this;\\n  for (let ch = 0; ch < word.length; ch++) {\\n    const char = word[ch];\\n    \\n    if (!curNode.children.hasOwnProperty(char)) {\\n      curNode.add(char);\\n      curNode = curNode.children[char];\\n    } else {\\n      curNode = curNode.children[char];\\n    }\\n  }\\n  curNode.isEnd = true;\\n}\\n\\n\\n\\n\\n/*******************************************\\n * * Given Items                           *\\n*******************************************/\\n\\n/**\\n * @param {string[]} words\\n */\\nvar StreamChecker = function(words) {\\n  this.trie = new TrieNode(null);\\n  this.searches = [];\\n\\n  for (let i = 0; i < words.length; i++) {\\n    let curNode = this.trie;\\n    const werd = words[i].split(\\'\\').reverse();\\n    curNode.addWord(werd);\\n\\n  }\\n};\\n\\n/** \\n * @param {character} letter\\n * @return {boolean}\\n */\\nStreamChecker.prototype.query = function(letter) {\\n  this.searches.push(letter);\\n\\n  let curNode = this.trie;\\n  for (let i = this.searches.length - 1; i >= 0; i--) {\\n    const curChar = this.searches[i];\\n\\n    if (!curNode.children.hasOwnProperty(curChar)) return false;\\n    else {\\n      curNode = curNode.children[curChar];\\n      if (curNode.isEnd) return true;\\n    } \\n  }\\n  return false\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 473500,
                "title": "short-java-beat-95-trienode-solution",
                "content": "Wheneven we want to search a stream for a certain pattern such as this one.\\nAnd such as search a  DNA pattern in a DNS tream this could be a good method.\\nEspecially, when we can only read the stream once and the stream is too big to be read into memory.\\n#1  build up the trieNode tree use the patterns, in reverse order\\nduring the build process, we should keep the max length of the pattern string.\\n2# search, during the search we just keep the max length buffer and do a normal TrieNode prefix search.\\nSpace:  o(m) where m is the sum of all the pattern string length\\nTime:  o(n*(max Length) +m) when m is the above space, and n is the length of the stream\\n```\\nclass StreamChecker {\\n    class TrieNode{\\n        TrieNode[] children= new TrieNode[26];\\n        boolean isWord=false;\\n    }\\n    TrieNode root= new TrieNode();\\n   // int maxLen=0;   if the steam is too big and can\\'t be read into memory, then this limitation is needed\\n    StringBuilder sb= new StringBuilder();\\n    public StreamChecker(String[] words) {\\n        for(String s: words){\\n           // maxLen=Math.max(maxLen, s.length());  if the steam is too big and can\\'t be read into memory, then this is needed\\n            TrieNode cur= root;\\n            for(int j=s.length()-1;j>=0;j--){\\n                int i=s.charAt(j)-\\'a\\';\\n                if(cur.children[i]==null) cur.children[i]= new TrieNode();\\n                cur=cur.children[i];\\n            }\\n            cur.isWord=true;\\n        }\\n    }\\n    public boolean query(char letter) {\\n        sb.append(letter);\\n        //if(sb.length()>maxLen) sb.deleteCharAt(0);  if the steam is too big and can\\'t be read into memory, this line is needed\\n        TrieNode cur=root;\\n        for(int i=sb.length()-1;i>=0;i--){\\n            int j=sb.charAt(i)-\\'a\\';\\n            if(cur.children[j]==null) return false;\\n            cur=cur.children[j];\\n            if(cur.isWord) return true;\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker {\\n    class TrieNode{\\n        TrieNode[] children= new TrieNode[26];\\n        boolean isWord=false;\\n    }\\n    TrieNode root= new TrieNode();\\n   // int maxLen=0;   if the steam is too big and can\\'t be read into memory, then this limitation is needed\\n    StringBuilder sb= new StringBuilder();\\n    public StreamChecker(String[] words) {\\n        for(String s: words){\\n           // maxLen=Math.max(maxLen, s.length());  if the steam is too big and can\\'t be read into memory, then this is needed\\n            TrieNode cur= root;\\n            for(int j=s.length()-1;j>=0;j--){\\n                int i=s.charAt(j)-\\'a\\';\\n                if(cur.children[i]==null) cur.children[i]= new TrieNode();\\n                cur=cur.children[i];\\n            }\\n            cur.isWord=true;\\n        }\\n    }\\n    public boolean query(char letter) {\\n        sb.append(letter);\\n        //if(sb.length()>maxLen) sb.deleteCharAt(0);  if the steam is too big and can\\'t be read into memory, this line is needed\\n        TrieNode cur=root;\\n        for(int i=sb.length()-1;i>=0;i--){\\n            int j=sb.charAt(i)-\\'a\\';\\n            if(cur.children[j]==null) return false;\\n            cur=cur.children[j];\\n            if(cur.isWord) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 465478,
                "title": "java-trie-stringbuilder-solution-with-reverse-insert-and-prefix-search",
                "content": "The idea is to index the dictionary words in trie in reverse order. Maintain a global StringBuilder and with each query, append query character in the global StringBuilder and then check if Trie has a complete word which is a prefix of the StringBuilder in reverse order\\n\\ne.g.\\ndictionary word : \"cd\" in Trie looks like (\\'d\\' -> \\'c\\')\\nquery(\\'a\\') : (builder : \"a\"; return false since nothing in Trie starts with \\'a\\')\\nquery(\\'b\\') : (builder : \"ab\"; return false since nothing in Trie starts with \\'b\\')\\nquery(\\'c\\') : (builder : \"abc\"; return false since nothing in Trie starts with \\'c\\')\\nquery(\\'d\\') : (builder : \"abcd\"; return true since there is a complete word in the trie \"dc\" which is a prefix of reverse of builder (\"**dc**ba\"))\\n\\n```\\nclass StreamChecker {\\n    private static final class TrieNode {\\n        private boolean isEnd;\\n        private final TrieNode[] links;\\n\\n        private TrieNode() {\\n            this.links = new TrieNode[26];\\n        }\\n\\n        private boolean isEnd() {\\n            return isEnd;\\n        }\\n\\n        private void setEnd() {\\n            isEnd = true;\\n        }\\n\\n        private boolean containsCharacter(char c) {\\n            return links[c - \\'a\\'] != null;\\n        }\\n\\n        private TrieNode get(char c) {\\n            return links[c - \\'a\\'];\\n        }\\n\\n        private void put(char c) {\\n            links[c - \\'a\\'] = new TrieNode();\\n        }\\n    }\\n\\n    private static final class Trie {\\n        private final TrieNode root;\\n\\n        private Trie() {\\n            this.root = new TrieNode();\\n        }\\n\\n        private void addWord(String s) {\\n            TrieNode current = root;\\n            for (char c : s.toCharArray()) {\\n                if (!current.containsCharacter(c)) {\\n                    current.put(c);\\n                }\\n                current = current.get(c);\\n            }\\n            current.setEnd();\\n        }\\n\\n        private void addWordInReverse(String s) {\\n            TrieNode current = root;\\n            int n = s.length();\\n            for (int i = n - 1; i >= 0; i--) {\\n                char c = s.charAt(i);\\n                if (!current.containsCharacter(c)) {\\n                    current.put(c);\\n                }\\n                current = current.get(c);\\n            }\\n            current.setEnd();\\n        }\\n\\n        private boolean checkPrefix(String s) {\\n            TrieNode current = root;\\n            for (char c : s.toCharArray()) {\\n                if (!current.containsCharacter(c)) {\\n                    return false;\\n                }\\n                current = current.get(c);\\n                if (current.isEnd()) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n\\n        private boolean checkPrefixInReverse(StringBuilder s) {\\n            TrieNode current = root;\\n            int n = s.length();\\n            for (int i = n - 1; i >= 0; i--) {\\n                char c = s.charAt(i);\\n                if (!current.containsCharacter(c)) {\\n                    return false;\\n                }\\n                current = current.get(c);\\n                if (current.isEnd()) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n    }\\n\\n    private final Trie trie;\\n    private final StringBuilder builder;\\n\\n    public StreamChecker(String[] words) {\\n        this.builder = new StringBuilder();\\n        this.trie = new Trie();\\n        for (String word : words) {\\n            //trie.addWord(new StringBuilder(word).reverse().toString());\\n            trie.addWordInReverse(word);\\n        }\\n    }\\n\\n    public boolean query(char letter) {\\n        //builder.insert(0, letter);\\n        //return trie.checkPrefix(builder.toString());\\n\\n        builder.append(letter);\\n        return trie.checkPrefixInReverse(builder);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass StreamChecker {\\n    private static final class TrieNode {\\n        private boolean isEnd;\\n        private final TrieNode[] links;\\n\\n        private TrieNode() {\\n            this.links = new TrieNode[26];\\n        }\\n\\n        private boolean isEnd() {\\n            return isEnd;\\n        }\\n\\n        private void setEnd() {\\n            isEnd = true;\\n        }\\n\\n        private boolean containsCharacter(char c) {\\n            return links[c - \\'a\\'] != null;\\n        }\\n\\n        private TrieNode get(char c) {\\n            return links[c - \\'a\\'];\\n        }\\n\\n        private void put(char c) {\\n            links[c - \\'a\\'] = new TrieNode();\\n        }\\n    }\\n\\n    private static final class Trie {\\n        private final TrieNode root;\\n\\n        private Trie() {\\n            this.root = new TrieNode();\\n        }\\n\\n        private void addWord(String s) {\\n            TrieNode current = root;\\n            for (char c : s.toCharArray()) {\\n                if (!current.containsCharacter(c)) {\\n                    current.put(c);\\n                }\\n                current = current.get(c);\\n            }\\n            current.setEnd();\\n        }\\n\\n        private void addWordInReverse(String s) {\\n            TrieNode current = root;\\n            int n = s.length();\\n            for (int i = n - 1; i >= 0; i--) {\\n                char c = s.charAt(i);\\n                if (!current.containsCharacter(c)) {\\n                    current.put(c);\\n                }\\n                current = current.get(c);\\n            }\\n            current.setEnd();\\n        }\\n\\n        private boolean checkPrefix(String s) {\\n            TrieNode current = root;\\n            for (char c : s.toCharArray()) {\\n                if (!current.containsCharacter(c)) {\\n                    return false;\\n                }\\n                current = current.get(c);\\n                if (current.isEnd()) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n\\n        private boolean checkPrefixInReverse(StringBuilder s) {\\n            TrieNode current = root;\\n            int n = s.length();\\n            for (int i = n - 1; i >= 0; i--) {\\n                char c = s.charAt(i);\\n                if (!current.containsCharacter(c)) {\\n                    return false;\\n                }\\n                current = current.get(c);\\n                if (current.isEnd()) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n    }\\n\\n    private final Trie trie;\\n    private final StringBuilder builder;\\n\\n    public StreamChecker(String[] words) {\\n        this.builder = new StringBuilder();\\n        this.trie = new Trie();\\n        for (String word : words) {\\n            //trie.addWord(new StringBuilder(word).reverse().toString());\\n            trie.addWordInReverse(word);\\n        }\\n    }\\n\\n    public boolean query(char letter) {\\n        //builder.insert(0, letter);\\n        //return trie.checkPrefix(builder.toString());\\n\\n        builder.append(letter);\\n        return trie.checkPrefixInReverse(builder);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 459504,
                "title": "python-trie-solution-with-reverse-insert",
                "content": "we insert and search words inversely with using dictionary.\\n```\\nclass Trie:\\n    def __init__(self):\\n        self.root = {}\\n    \\n    def insert(self,word):\\n        cur = self.root\\n        for w in word:\\n            if w not in cur:\\n                cur[w] = {}\\n            cur = cur[w]\\n        cur[\"#\"] = True\\n        \\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.sentence = \"\"\\n        self.trie = Trie()\\n        for word in words:\\n            self.trie.insert(word[::-1])\\n            \\n    def query(self, letter: str) -> bool:\\n        self.sentence += letter\\n        \\n        def dfs(word,cur):\\n            if not cur: \\n                cur = self.trie.root\\n            if not word:\\n                if \"#\" in cur:\\n                    return True\\n                return False\\n            \\n            if \"#\" in cur:\\n                return True\\n            if word[0] in cur:\\n                return dfs(word[1:],cur[word[0]])\\n            return False \\n                    \\n        return dfs(self.sentence[::-1],None)\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Trie:\\n    def __init__(self):\\n        self.root = {}\\n    \\n    def insert(self,word):\\n        cur = self.root\\n        for w in word:\\n            if w not in cur:\\n                cur[w] = {}\\n            cur = cur[w]\\n        cur[\"#\"] = True\\n        \\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.sentence = \"\"\\n        self.trie = Trie()\\n        for word in words:\\n            self.trie.insert(word[::-1])\\n            \\n    def query(self, letter: str) -> bool:\\n        self.sentence += letter\\n        \\n        def dfs(word,cur):\\n            if not cur: \\n                cur = self.trie.root\\n            if not word:\\n                if \"#\" in cur:\\n                    return True\\n                return False\\n            \\n            if \"#\" in cur:\\n                return True\\n            if word[0] in cur:\\n                return dfs(word[1:],cur[word[0]])\\n            return False \\n                    \\n        return dfs(self.sentence[::-1],None)\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 431483,
                "title": "my-aho-corasick-solution",
                "content": "As a acmer who was active six years ago, I\\'m surprised that Aho\\u2013Corasick becomes interview questions these days....\\n\\u6211\\u9707\\u60CA\\u4E86\\u3002\\n```\\nclass Trie {\\nprivate:\\n    vector<vector<int>> trie;\\n    vector<bool> isWord;\\n    vector<int> fail;\\n    int curPos;\\npublic:\\n    Trie() {\\n        trie.resize(1, vector<int>(28));\\n        isWord.resize(1);\\n        fail.resize(1, -1);\\n        curPos = 0;\\n    }\\n\\n    int alloc(char ch) {\\n        trie.push_back(vector<int>(28));\\n        trie[trie.size()-1][27] = ch-\\'a\\';\\n        isWord.push_back(0);\\n        fail.push_back(0);\\n        return trie.size()-1;\\n    }\\n    void buildFail() {\\n        queue<pair<int, int>> q;\\n        q.push(make_pair(0, -1));\\n        while(!q.empty()) {\\n            auto curNode = q.front(); q.pop();\\n            int cur = curNode.first;\\n            int fa = curNode.second;\\n            if(cur > 0) {\\n                int chIndex = trie[cur][27];\\n                int failFa = fail[fa];\\n                while(failFa != -1) {\\n                    if(!trie[failFa][chIndex]) {\\n                        failFa = fail[failFa];\\n                    } else {\\n                        break;\\n                    }\\n                }\\n                if(failFa == -1) {\\n                    fail[cur] = 0;\\n                } else {\\n                    fail[cur] = trie[failFa][chIndex];\\n                }\\n            }\\n            for(int i=0; i<27; i++) {\\n                if(!trie[cur][i]) continue;\\n                q.push(make_pair(trie[cur][i], cur));\\n            }\\n        }\\n        \\n\\n        return;\\n    }\\n    void insert(string& word) {\\n        int cur = 0;\\n        for(char ch : word) {\\n            int index = ch-\\'a\\';\\n            if(!trie[cur][index]) {\\n                trie[cur][index] = alloc(ch);\\n            }\\n            cur = trie[cur][index];\\n        }\\n        isWord[cur] = 1;\\n        return;\\n    }\\n    bool find(char ch) {\\n        int index = ch-\\'a\\';\\n        int failFa = curPos;\\n        while(failFa != -1) {\\n            if(trie[failFa][index]) {\\n                curPos = trie[failFa][index];\\n                int tmp =curPos;\\n                while(tmp != -1) {\\n                    if(isWord[tmp]) return 1;\\n                    tmp = fail[tmp];\\n                }\\n                return 0;\\n            }\\n            failFa = fail[failFa];\\n        }\\n        curPos = 0;\\n        return 0;\\n    }\\n};\\nclass StreamChecker {\\nprivate:\\n    Trie trie;\\npublic:\\n    StreamChecker(vector<string>& words) {\\n        for(auto& str : words) {\\n            trie.insert(str);\\n        }\\n        trie.buildFail();\\n    }\\n    \\n    bool query(char letter) {\\n        return trie.find(letter);\\n    }\\n};\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker* obj = new StreamChecker(words);\\n * bool param_1 = obj->query(letter);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass Trie {\\nprivate:\\n    vector<vector<int>> trie;\\n    vector<bool> isWord;\\n    vector<int> fail;\\n    int curPos;\\npublic:\\n    Trie() {\\n        trie.resize(1, vector<int>(28));\\n        isWord.resize(1);\\n        fail.resize(1, -1);\\n        curPos = 0;\\n    }\\n\\n    int alloc(char ch) {\\n        trie.push_back(vector<int>(28));\\n        trie[trie.size()-1][27] = ch-\\'a\\';\\n        isWord.push_back(0);\\n        fail.push_back(0);\\n        return trie.size()-1;\\n    }\\n    void buildFail() {\\n        queue<pair<int, int>> q;\\n        q.push(make_pair(0, -1));\\n        while(!q.empty()) {\\n            auto curNode = q.front(); q.pop();\\n            int cur = curNode.first;\\n            int fa = curNode.second;\\n            if(cur > 0) {\\n                int chIndex = trie[cur][27];\\n                int failFa = fail[fa];\\n                while(failFa != -1) {\\n                    if(!trie[failFa][chIndex]) {\\n                        failFa = fail[failFa];\\n                    } else {\\n                        break;\\n                    }\\n                }\\n                if(failFa == -1) {\\n                    fail[cur] = 0;\\n                } else {\\n                    fail[cur] = trie[failFa][chIndex];\\n                }\\n            }\\n            for(int i=0; i<27; i++) {\\n                if(!trie[cur][i]) continue;\\n                q.push(make_pair(trie[cur][i], cur));\\n            }\\n        }\\n        \\n\\n        return;\\n    }\\n    void insert(string& word) {\\n        int cur = 0;\\n        for(char ch : word) {\\n            int index = ch-\\'a\\';\\n            if(!trie[cur][index]) {\\n                trie[cur][index] = alloc(ch);\\n            }\\n            cur = trie[cur][index];\\n        }\\n        isWord[cur] = 1;\\n        return;\\n    }\\n    bool find(char ch) {\\n        int index = ch-\\'a\\';\\n        int failFa = curPos;\\n        while(failFa != -1) {\\n            if(trie[failFa][index]) {\\n                curPos = trie[failFa][index];\\n                int tmp =curPos;\\n                while(tmp != -1) {\\n                    if(isWord[tmp]) return 1;\\n                    tmp = fail[tmp];\\n                }\\n                return 0;\\n            }\\n            failFa = fail[failFa];\\n        }\\n        curPos = 0;\\n        return 0;\\n    }\\n};\\nclass StreamChecker {\\nprivate:\\n    Trie trie;\\npublic:\\n    StreamChecker(vector<string>& words) {\\n        for(auto& str : words) {\\n            trie.insert(str);\\n        }\\n        trie.buildFail();\\n    }\\n    \\n    bool query(char letter) {\\n        return trie.find(letter);\\n    }\\n};\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker* obj = new StreamChecker(words);\\n * bool param_1 = obj->query(letter);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 420567,
                "title": "simple-with-python-and-trie-20-lines-fully-commented",
                "content": "```\\nclass StreamChecker:\\n    def __init__(self, words: List[str]):\\n        # string that remembers the stream of queris\\n        self.s = \"\"\\n\\n        # my trie has 27 slots, 26 are for letters and the last a bool for termination\\n        self.trie = [[]] * 27\\n        for word in words:\\n            curr = self.trie\\n            # i have to reverse the word\\n            for l in reversed(word):\\n                # get the index: a -> 0, z -> 25\\n                i = ord(l) - ord(\"a\")\\n                # if branch does not exist before i create it\\n                if not curr[i]:\\n                    curr[i] = [[]] * 27\\n                # switch branch and continue iteraiton\\n                curr = curr[i]\\n            # mark this as the end of the word\\n            curr[26] = True\\n\\n    def query(self, letter: str) -> bool:\\n        # add the last query to the string\\n        self.s += letter\\n        curr = self.trie\\n        # parse troguh the reversed stream\\n        for l in reversed(self.s):\\n            # get the index: a -> 0, z -> 25\\n            i = ord(l) - ord(\"a\")\\n            # if end of word, return true!\\n            if curr[26]:\\n                return True\\n            # if this letter exist (and was not end of word before)\\n            # iterate to the next one\\n            if curr[i]:\\n                curr = curr[i]\\n            # if this letter does not exist return\\n            else:\\n                return False\\n        # return if this last letter of the stream existed\\n        return curr[26]\\n```",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker:\\n    def __init__(self, words: List[str]):\\n        # string that remembers the stream of queris\\n        self.s = \"\"\\n\\n        # my trie has 27 slots, 26 are for letters and the last a bool for termination\\n        self.trie = [[]] * 27\\n        for word in words:\\n            curr = self.trie\\n            # i have to reverse the word\\n            for l in reversed(word):\\n                # get the index: a -> 0, z -> 25\\n                i = ord(l) - ord(\"a\")\\n                # if branch does not exist before i create it\\n                if not curr[i]:\\n                    curr[i] = [[]] * 27\\n                # switch branch and continue iteraiton\\n                curr = curr[i]\\n            # mark this as the end of the word\\n            curr[26] = True\\n\\n    def query(self, letter: str) -> bool:\\n        # add the last query to the string\\n        self.s += letter\\n        curr = self.trie\\n        # parse troguh the reversed stream\\n        for l in reversed(self.s):\\n            # get the index: a -> 0, z -> 25\\n            i = ord(l) - ord(\"a\")\\n            # if end of word, return true!\\n            if curr[26]:\\n                return True\\n            # if this letter exist (and was not end of word before)\\n            # iterate to the next one\\n            if curr[i]:\\n                curr = curr[i]\\n            # if this letter does not exist return\\n            else:\\n                return False\\n        # return if this last letter of the stream existed\\n        return curr[26]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 400872,
                "title": "python-trie",
                "content": "```\\nfrom collections import defaultdict, deque\\n\\nclass TrieNode:\\n    def __init__(self):\\n        self.isWord = False\\n        self.children = defaultdict(TrieNode)\\n        \\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n        \\n    def insert(self, word):\\n        node = self.root\\n        for c in word:\\n            node = node.children[c]\\n        node.isWord = True\\n    \\n    def search(self, queries):\\n        node = self.root\\n        for q in queries:\\n            if q in node.children:\\n                node = node.children[q]\\n                if node.isWord:\\n                    return True\\n            else:\\n                return False\\n\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.trie = Trie()\\n        for word in words:\\n            self.trie.insert(word[::-1])\\n        self.queries = deque() \\n    \\n    def query(self, letter: str) -> bool:\\n        self.queries.appendleft(letter)\\n        if len(self.queries) > 2000: self.queries.pop()\\n        return self.trie.search(self.queries)",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict, deque\\n\\nclass TrieNode:\\n    def __init__(self):\\n        self.isWord = False\\n        self.children = defaultdict(TrieNode)\\n        \\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n        \\n    def insert(self, word):\\n        node = self.root\\n        for c in word:\\n            node = node.children[c]\\n        node.isWord = True\\n    \\n    def search(self, queries):\\n        node = self.root\\n        for q in queries:\\n            if q in node.children:\\n                node = node.children[q]\\n                if node.isWord:\\n                    return True\\n            else:\\n                return False\\n\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.trie = Trie()\\n        for word in words:\\n            self.trie.insert(word[::-1])\\n        self.queries = deque() \\n    \\n    def query(self, letter: str) -> bool:\\n        self.queries.appendleft(letter)\\n        if len(self.queries) > 2000: self.queries.pop()\\n        return self.trie.search(self.queries)",
                "codeTag": "Java"
            },
            {
                "id": 397278,
                "title": "c-tle-on-first-approach-reverse-trie-on-second-beats-85",
                "content": "First approach I came up with was to track root characters in the trie then try each word from the most recent root to end of stream if it was in the trie or not. This worked fine on simple cases but passed only 13/17 test cases and failed from TLE. Would\\'ve been happy with this approach in an interview, could talk potential issues, etc. and then workout a more optimal answer. I also wrote this before realizing we only need to care about lowercase letters.\\n\\n```\\npublic class StreamChecker \\n{\\n    private class Trie\\n    {\\n        private class TrieNode\\n        {\\n            public char Value { get; }\\n            public bool Terminating { get; set; }\\n            public Dictionary<char, TrieNode> NextNodes { get; }\\n\\n            public TrieNode(char val)\\n            {\\n                Value = val;\\n                NextNodes = new Dictionary<char, TrieNode>();\\n            }        \\n        }\\n        \\n        private readonly Dictionary<char, TrieNode> _roots = new Dictionary<char, TrieNode>();\\n        \\n        public Trie(string[] words)\\n        {\\n            foreach (var word in words)\\n                Add(word);\\n        }\\n        \\n        public void Add(string word)\\n        {\\n            if (word == string.Empty)\\n                return;\\n\\n            if (!_roots.ContainsKey(word[0]))\\n                _roots[word[0]] = new TrieNode(word[0]);\\n            \\n            var current = _roots[word[0]];\\n            \\n            for (var i = 1; i < word.Length; i++)\\n            {\\n                var ch = word[i];\\n                if (!current.NextNodes.ContainsKey(ch))\\n                {\\n                    var next = new TrieNode(ch);\\n                    current.NextNodes[ch] = next;\\n                    current = next;\\n                }\\n                else\\n                    current = current.NextNodes[ch];\\n            }\\n            \\n            current.Terminating = true;\\n        }\\n        \\n        public bool Check(string word)\\n        {\\n            _roots.TryGetValue(word[0], out var current);\\n            if (current == null)\\n                return false;\\n            \\n            for (var i = 1; i < word.Length; i++)\\n            {\\n                var ch = word[i];\\n                \\n                current.NextNodes.TryGetValue(ch, out var next);\\n                if (next == null)\\n                    return false;\\n                current = next;\\n            }\\n            \\n            return current.Terminating;\\n        }\\n        \\n        public bool HasRoot(char ch)\\n        {\\n            _roots.TryGetValue(ch, out var node);\\n            \\n            return node != null;\\n        }\\n    }\\n    \\n    private readonly Trie _trie;\\n    private readonly StringBuilder _streamCharacters = new StringBuilder();\\n    private readonly List<int> _rootIndexes = new List<int>();\\n\\n    public StreamChecker(string[] words) \\n    {\\n        _trie = new Trie(words);\\n    }\\n    \\n    public bool Query(char letter) \\n    {\\n        _streamCharacters.Append(letter);\\n        \\n        if (_trie.HasRoot(letter))\\n            _rootIndexes.Add(_streamCharacters.Length - 1);\\n        \\n        for (var i = _rootIndexes.Count - 1; i >= 0; i--)\\n        {\\n            var current = _streamCharacters.ToString(_rootIndexes[i], _streamCharacters.Length - _rootIndexes[i]);\\n            if (_trie.Check(current))\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\n\\nSecond approach passes using the reverse word approach. Smart idea, not sure if I would\\'ve been able to come up with it in interview but it might be something an interviewer would give a clue on.\\n\\n```\\npublic class StreamChecker \\n{\\n    private class Trie\\n    {\\n        public class TrieNode\\n        {\\n            public bool Terminating { get; set; }\\n            public TrieNode[] NextNodes { get; }\\n\\n            public TrieNode()\\n            {\\n                NextNodes = new TrieNode[26];\\n            }        \\n        }\\n        \\n        public TrieNode Root { get; } = new TrieNode();\\n        \\n        public void Add(char[] word)\\n        {\\n            var current = Root.NextNodes[word[0] - \\'a\\'];\\n            if (current == null)\\n            {\\n                current = new TrieNode();\\n                Root.NextNodes[word[0] - \\'a\\'] = current;\\n            }\\n            \\n            for (var i = 1; i < word.Length; i++)\\n            {\\n                var ch = word[i];\\n                \\n                var next = current.NextNodes[ch - \\'a\\'];\\n                if (next == null)\\n                {\\n                    next = new TrieNode();\\n                    current.NextNodes[ch - \\'a\\'] = next;\\n                    current = next;\\n                }\\n                else\\n                    current = next;\\n            }\\n            \\n            current.Terminating = true;\\n        }\\n    }\\n    \\n    private readonly Trie _trie = new Trie();\\n    private readonly StringBuilder _streamCharacters = new StringBuilder();\\n\\n    public StreamChecker(string[] words) \\n    {\\n        foreach (var word in words)\\n        {\\n            char[] array = word.ToCharArray();\\n            Array.Reverse(array);\\n            _trie.Add(array);\\n        }\\n    }\\n    \\n    public bool Query(char letter) \\n    {\\n        _streamCharacters.Append(letter);\\n        \\n        var current = _trie.Root;\\n        \\n        for (var i = _streamCharacters.Length - 1; i >= 0; i--)\\n        {\\n            var next = current.NextNodes[_streamCharacters[i] - \\'a\\'];\\n            if (next == null)\\n                return false;\\n            else if (next.Terminating)\\n                return true;\\n \\n            current = next;\\n        }\\n        \\n        return current.Terminating;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class StreamChecker \\n{\\n    private class Trie\\n    {\\n        private class TrieNode\\n        {\\n            public char Value { get; }\\n            public bool Terminating { get; set; }\\n            public Dictionary<char, TrieNode> NextNodes { get; }\\n\\n            public TrieNode(char val)\\n            {\\n                Value = val;\\n                NextNodes = new Dictionary<char, TrieNode>();\\n            }        \\n        }\\n        \\n        private readonly Dictionary<char, TrieNode> _roots = new Dictionary<char, TrieNode>();\\n        \\n        public Trie(string[] words)\\n        {\\n            foreach (var word in words)\\n                Add(word);\\n        }\\n        \\n        public void Add(string word)\\n        {\\n            if (word == string.Empty)\\n                return;\\n\\n            if (!_roots.ContainsKey(word[0]))\\n                _roots[word[0]] = new TrieNode(word[0]);\\n            \\n            var current = _roots[word[0]];\\n            \\n            for (var i = 1; i < word.Length; i++)\\n            {\\n                var ch = word[i];\\n                if (!current.NextNodes.ContainsKey(ch))\\n                {\\n                    var next = new TrieNode(ch);\\n                    current.NextNodes[ch] = next;\\n                    current = next;\\n                }\\n                else\\n                    current = current.NextNodes[ch];\\n            }\\n            \\n            current.Terminating = true;\\n        }\\n        \\n        public bool Check(string word)\\n        {\\n            _roots.TryGetValue(word[0], out var current);\\n            if (current == null)\\n                return false;\\n            \\n            for (var i = 1; i < word.Length; i++)\\n            {\\n                var ch = word[i];\\n                \\n                current.NextNodes.TryGetValue(ch, out var next);\\n                if (next == null)\\n                    return false;\\n                current = next;\\n            }\\n            \\n            return current.Terminating;\\n        }\\n        \\n        public bool HasRoot(char ch)\\n        {\\n            _roots.TryGetValue(ch, out var node);\\n            \\n            return node != null;\\n        }\\n    }\\n    \\n    private readonly Trie _trie;\\n    private readonly StringBuilder _streamCharacters = new StringBuilder();\\n    private readonly List<int> _rootIndexes = new List<int>();\\n\\n    public StreamChecker(string[] words) \\n    {\\n        _trie = new Trie(words);\\n    }\\n    \\n    public bool Query(char letter) \\n    {\\n        _streamCharacters.Append(letter);\\n        \\n        if (_trie.HasRoot(letter))\\n            _rootIndexes.Add(_streamCharacters.Length - 1);\\n        \\n        for (var i = _rootIndexes.Count - 1; i >= 0; i--)\\n        {\\n            var current = _streamCharacters.ToString(_rootIndexes[i], _streamCharacters.Length - _rootIndexes[i]);\\n            if (_trie.Check(current))\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\n```\\npublic class StreamChecker \\n{\\n    private class Trie\\n    {\\n        public class TrieNode\\n        {\\n            public bool Terminating { get; set; }\\n            public TrieNode[] NextNodes { get; }\\n\\n            public TrieNode()\\n            {\\n                NextNodes = new TrieNode[26];\\n            }        \\n        }\\n        \\n        public TrieNode Root { get; } = new TrieNode();\\n        \\n        public void Add(char[] word)\\n        {\\n            var current = Root.NextNodes[word[0] - \\'a\\'];\\n            if (current == null)\\n            {\\n                current = new TrieNode();\\n                Root.NextNodes[word[0] - \\'a\\'] = current;\\n            }\\n            \\n            for (var i = 1; i < word.Length; i++)\\n            {\\n                var ch = word[i];\\n                \\n                var next = current.NextNodes[ch - \\'a\\'];\\n                if (next == null)\\n                {\\n                    next = new TrieNode();\\n                    current.NextNodes[ch - \\'a\\'] = next;\\n                    current = next;\\n                }\\n                else\\n                    current = next;\\n            }\\n            \\n            current.Terminating = true;\\n        }\\n    }\\n    \\n    private readonly Trie _trie = new Trie();\\n    private readonly StringBuilder _streamCharacters = new StringBuilder();\\n\\n    public StreamChecker(string[] words) \\n    {\\n        foreach (var word in words)\\n        {\\n            char[] array = word.ToCharArray();\\n            Array.Reverse(array);\\n            _trie.Add(array);\\n        }\\n    }\\n    \\n    public bool Query(char letter) \\n    {\\n        _streamCharacters.Append(letter);\\n        \\n        var current = _trie.Root;\\n        \\n        for (var i = _streamCharacters.Length - 1; i >= 0; i--)\\n        {\\n            var next = current.NextNodes[_streamCharacters[i] - \\'a\\'];\\n            if (next == null)\\n                return false;\\n            else if (next.Terminating)\\n                return true;\\n \\n            current = next;\\n        }\\n        \\n        return current.Terminating;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 390448,
                "title": "java-clean-trie-solution-easy-to-understand",
                "content": "Use a limited size deque to save the memory because the max depth we want to search will not exceed the max lenght of the word. Also considering the property of deque, I use an iterator here to search backward to save the time complexity.\\n```\\nclass StreamChecker {\\n    Trie trie;\\n    Deque<Character> chars;\\n    int maxLen;\\n    public StreamChecker(String[] words) {\\n        trie = new Trie();\\n        chars = new LinkedList<Character>();\\n        maxLen = 0;\\n        for (String word : words) {\\n            trie.addWord(new StringBuilder(word).reverse().toString());\\n            maxLen = Math.max(maxLen, word.length());\\n        } \\n    }\\n    \\n    public boolean query(char letter) {\\n        chars.addLast(letter);\\n        if (chars.size() > maxLen) { chars.pollFirst(); }\\n        Iterator<Character> iterator = chars.descendingIterator();\\n        return trie.containsWord(iterator);\\n    }\\n    \\n    class Trie {\\n        TreeNode root;\\n        public Trie() {\\n            this.root = new TreeNode();\\n        }\\n        \\n        public void addWord(String word) {\\n            TreeNode node = root;\\n            for (char c : word.toCharArray()) {\\n                if (node.next[c - \\'a\\'] == null) {\\n                    node.next[c - \\'a\\'] = new TreeNode();\\n                }\\n                node = node.next[c - \\'a\\'];\\n            }\\n            node.isWord = true;\\n        }\\n        \\n        public boolean containsWord(Iterator<Character> iterator) {\\n            TreeNode node = root;\\n            while (iterator.hasNext()) {\\n                char c = iterator.next();\\n                if (node.next[c - \\'a\\'] == null) return false;\\n                node = node.next[c - \\'a\\'];\\n                if (node.isWord) return true;\\n            }\\n            return false;\\n        }\\n    }\\n    \\n    class TreeNode {\\n        boolean isWord;\\n        TreeNode[] next;\\n        public TreeNode() {\\n            this.isWord = false;\\n            this.next = new TreeNode[26];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass StreamChecker {\\n    Trie trie;\\n    Deque<Character> chars;\\n    int maxLen;\\n    public StreamChecker(String[] words) {\\n        trie = new Trie();\\n        chars = new LinkedList<Character>();\\n        maxLen = 0;\\n        for (String word : words) {\\n            trie.addWord(new StringBuilder(word).reverse().toString());\\n            maxLen = Math.max(maxLen, word.length());\\n        } \\n    }\\n    \\n    public boolean query(char letter) {\\n        chars.addLast(letter);\\n        if (chars.size() > maxLen) { chars.pollFirst(); }\\n        Iterator<Character> iterator = chars.descendingIterator();\\n        return trie.containsWord(iterator);\\n    }\\n    \\n    class Trie {\\n        TreeNode root;\\n        public Trie() {\\n            this.root = new TreeNode();\\n        }\\n        \\n        public void addWord(String word) {\\n            TreeNode node = root;\\n            for (char c : word.toCharArray()) {\\n                if (node.next[c - \\'a\\'] == null) {\\n                    node.next[c - \\'a\\'] = new TreeNode();\\n                }\\n                node = node.next[c - \\'a\\'];\\n            }\\n            node.isWord = true;\\n        }\\n        \\n        public boolean containsWord(Iterator<Character> iterator) {\\n            TreeNode node = root;\\n            while (iterator.hasNext()) {\\n                char c = iterator.next();\\n                if (node.next[c - \\'a\\'] == null) return false;\\n                node = node.next[c - \\'a\\'];\\n                if (node.isWord) return true;\\n            }\\n            return false;\\n        }\\n    }\\n    \\n    class TreeNode {\\n        boolean isWord;\\n        TreeNode[] next;\\n        public TreeNode() {\\n            this.isWord = false;\\n            this.next = new TreeNode[26];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 379232,
                "title": "python-trie-tree-easy-to-understand",
                "content": "```\\nclass TreeNode:\\n    # tree node of a multi-way tree\\n    def __init__(self, val):\\n        self.val = val\\n        # children\\n        self.next = {}\\n        # mark this node as the end of a path to search a word\\n        self.is_end = False\\n\\n\\nclass StreamChecker:\\n    # search tree data structure\\n    def __init__(self, words):\\n        # root of the search tree\\n        self.root = TreeNode(None)\\n        # a list to store unfinished paths\\n        self.q = []\\n        for word in words:\\n            # add each word into the search tree\\n            head = self.root\\n            for char in word:\\n                if char not in head.next:\\n                    head.next[char] = TreeNode(char)\\n                head = head.next[char]\\n            head.is_end = True\\n\\n    def query(self, letter: str) -> bool:\\n        # add a new path\\n        self.q.append(self.root)\\n        next_q = []\\n        for each in self.q:\\n            if letter in each.next:\\n                next_q.append(each.next[letter])\\n        self.q = next_q\\n        return any([each.is_end for each in self.q])\\n```",
                "solutionTags": [],
                "code": "```\\nclass TreeNode:\\n    # tree node of a multi-way tree\\n    def __init__(self, val):\\n        self.val = val\\n        # children\\n        self.next = {}\\n        # mark this node as the end of a path to search a word\\n        self.is_end = False\\n\\n\\nclass StreamChecker:\\n    # search tree data structure\\n    def __init__(self, words):\\n        # root of the search tree\\n        self.root = TreeNode(None)\\n        # a list to store unfinished paths\\n        self.q = []\\n        for word in words:\\n            # add each word into the search tree\\n            head = self.root\\n            for char in word:\\n                if char not in head.next:\\n                    head.next[char] = TreeNode(char)\\n                head = head.next[char]\\n            head.is_end = True\\n\\n    def query(self, letter: str) -> bool:\\n        # add a new path\\n        self.q.append(self.root)\\n        next_q = []\\n        for each in self.q:\\n            if letter in each.next:\\n                next_q.append(each.next[letter])\\n        self.q = next_q\\n        return any([each.is_end for each in self.q])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 362505,
                "title": "straightforward-java-solution-using-hashmap-with-explanation",
                "content": "When we get the input of string array, we creat a table(implemented by 2 layer HashMap) to classfify all the words by the last character and the length of the words. \\nFor example, if we have [\"ab\", \"eb\", \"abb\", \"cdb\", \"cd\"], we get:\\nb:  [2, \"ab, eb\"], [3, \"abb\", \"cdb\"]\\nd:  [1, \"cd\"].\\n\\nWe put all the queried letter in a Stringbuilder sb. For a query, let\\'s say \\'b\\', we try the length of 2 and 3, and see the string comstructed by the last 2 or 3 qurried letter is contains in the correspondin set or not.\\n\\n\\n```\\nclass StreamChecker {\\n    Map<Character, Map<Integer, Set<String>>> map = new HashMap<>();\\n    StringBuilder sb = new StringBuilder();\\n    \\n    public StreamChecker(String[] words) {\\n        if (words == null || words.length == 0) return;\\n        for (String s : words) {\\n            char c = s.charAt(s.length() - 1);\\n            int length = s.length();\\n            Map<Integer, Set<String>> newEntry = map.getOrDefault(c, new HashMap<Integer, Set<String>>());\\n            Set<String> sameLengthSet = newEntry.getOrDefault(length, new HashSet<>());\\n            sameLengthSet.add(s);\\n            newEntry.put(length, sameLengthSet);\\n            map.put(c, newEntry);\\n        }\\n    }\\n    \\n    public boolean query(char letter) {\\n        sb.append(letter);\\n        Map<Integer, Set<String>> newEntry = map.get(letter);\\n        if (newEntry == null) return false;\\n        for (int length : newEntry.keySet()) {\\n            if (length > sb.length()) continue;\\n            Set<String> setWithSameLength = newEntry.get(length);\\n            String target = sb.substring(sb.length() - length, sb.length());\\n            if (setWithSameLength.contains(target)) return true;\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [],
                "code": "When we get the input of string array, we creat a table(implemented by 2 layer HashMap) to classfify all the words by the last character and the length of the words. \\nFor example, if we have [\"ab\", \"eb\", \"abb\", \"cdb\", \"cd\"], we get:\\nb:  [2, \"ab, eb\"], [3, \"abb\", \"cdb\"]\\nd:  [1, \"cd\"].\\n\\nWe put all the queried letter in a Stringbuilder sb. For a query, let\\'s say \\'b\\', we try the length of 2 and 3, and see the string comstructed by the last 2 or 3 qurried letter is contains in the correspondin set or not.\\n\\n\\n```\\nclass StreamChecker {\\n    Map<Character, Map<Integer, Set<String>>> map = new HashMap<>();\\n    StringBuilder sb = new StringBuilder();\\n    \\n    public StreamChecker(String[] words) {\\n        if (words == null || words.length == 0) return;\\n        for (String s : words) {\\n            char c = s.charAt(s.length() - 1);\\n            int length = s.length();\\n            Map<Integer, Set<String>> newEntry = map.getOrDefault(c, new HashMap<Integer, Set<String>>());\\n            Set<String> sameLengthSet = newEntry.getOrDefault(length, new HashSet<>());\\n            sameLengthSet.add(s);\\n            newEntry.put(length, sameLengthSet);\\n            map.put(c, newEntry);\\n        }\\n    }\\n    \\n    public boolean query(char letter) {\\n        sb.append(letter);\\n        Map<Integer, Set<String>> newEntry = map.get(letter);\\n        if (newEntry == null) return false;\\n        for (int length : newEntry.keySet()) {\\n            if (length > sb.length()) continue;\\n            Set<String> setWithSameLength = newEntry.get(length);\\n            String target = sb.substring(sb.length() - length, sb.length());\\n            if (setWithSameLength.contains(target)) return true;\\n        }\\n        return false;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 361612,
                "title": "trie-in-java",
                "content": "Query characters from the latest to previous, should match a word from the last character to the first (if any). So it would be more convenient if we reverse the word and perform the matching.\\n\\nIn this way, query characters from the latest to previos seem like a prefix of a reversed word. A prefix tree (trie) is a good storage of these reversed wrods.\\n\\nOnly latest maxLen query characters matter, so we clear the staled characters after each query().\\n```\\n    private Node root;\\n    private int maxLen;\\n    private StringBuilder queries;\\n\\n    public StreamChecker(String[] words) {\\n        root = new Node();\\n        maxLen = Integer.MIN_VALUE;\\n        queries = new StringBuilder();\\n        \\n        for (String word : words) {\\n            // reverse word insert into trie\\n            insert(new StringBuilder(word).reverse().toString());\\n            // update maxLen\\n            maxLen = Math.max(maxLen, word.length());\\n        }\\n    }\\n    \\n    // Clear stale before return\\n    public boolean query(char letter) {\\n        queries.append(letter);\\n        Node node = root;\\n        \\n        for (int i = queries.length() - 1; i >= Math.max(0, queries.length() - maxLen); i--) {\\n            // search queries character by character from end in trie\\n            node = node.children[queries.charAt(i) - \\'a\\'];\\n            if (node == null) {\\n                clearStale();\\n                return false;\\n            } else if (node.isLeaf) {\\n                clearStale();\\n                return true;\\n            }\\n        }\\n        \\n        clearStale();\\n        return false;\\n    }\\n    \\n    private void insert(String s) {\\n        Node ptr = root;\\n        for (char ch : s.toCharArray()) {\\n            if (ptr.children[ch - \\'a\\'] == null) {\\n                ptr.children[ch - \\'a\\'] = new Node();\\n            }\\n            ptr = ptr.children[ch - \\'a\\'];\\n        }\\n        ptr.isLeaf = true;\\n    }\\n    \\n    class Node {\\n        Node[] children;\\n        boolean isLeaf;\\n        \\n        public Node() {\\n            children = new Node[26];\\n            isLeaf = false;\\n        }\\n    }\\n    \\n    // only maxLen query characters need to be maintained\\n    // so we clear the staled characters after each query (adding a new character)\\n    private void clearStale() {\\n        if (queries.length() >= maxLen) {\\n            queries.deleteCharAt(0);\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    private Node root;\\n    private int maxLen;\\n    private StringBuilder queries;\\n\\n    public StreamChecker(String[] words) {\\n        root = new Node();\\n        maxLen = Integer.MIN_VALUE;\\n        queries = new StringBuilder();\\n        \\n        for (String word : words) {\\n            // reverse word insert into trie\\n            insert(new StringBuilder(word).reverse().toString());\\n            // update maxLen\\n            maxLen = Math.max(maxLen, word.length());\\n        }\\n    }\\n    \\n    // Clear stale before return\\n    public boolean query(char letter) {\\n        queries.append(letter);\\n        Node node = root;\\n        \\n        for (int i = queries.length() - 1; i >= Math.max(0, queries.length() - maxLen); i--) {\\n            // search queries character by character from end in trie\\n            node = node.children[queries.charAt(i) - \\'a\\'];\\n            if (node == null) {\\n                clearStale();\\n                return false;\\n            } else if (node.isLeaf) {\\n                clearStale();\\n                return true;\\n            }\\n        }\\n        \\n        clearStale();\\n        return false;\\n    }\\n    \\n    private void insert(String s) {\\n        Node ptr = root;\\n        for (char ch : s.toCharArray()) {\\n            if (ptr.children[ch - \\'a\\'] == null) {\\n                ptr.children[ch - \\'a\\'] = new Node();\\n            }\\n            ptr = ptr.children[ch - \\'a\\'];\\n        }\\n        ptr.isLeaf = true;\\n    }\\n    \\n    class Node {\\n        Node[] children;\\n        boolean isLeaf;\\n        \\n        public Node() {\\n            children = new Node[26];\\n            isLeaf = false;\\n        }\\n    }\\n    \\n    // only maxLen query characters need to be maintained\\n    // so we clear the staled characters after each query (adding a new character)\\n    private void clearStale() {\\n        if (queries.length() >= maxLen) {\\n            queries.deleteCharAt(0);\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 338459,
                "title": "java-trie-solutions-for-both-reverse-and-non-reverse",
                "content": "```\\nclass StreamChecker {\\n\\t// reverse\\n    private StringBuilder sb;\\n    \\n    private TrieNode root;\\n    \\n    private int max;\\n    \\n    public StreamChecker(String[] words) {\\n        sb = new StringBuilder();\\n        root = new TrieNode();\\n        max = 0;\\n        for (String word : words) {\\n            insert(word);\\n            max = Math.max(word.length(), max);\\n        }\\n    }\\n    \\n    public boolean query(char letter) {\\n        boolean res = false;\\n        sb.append(letter);\\n        if (sb.length() > max) {\\n            sb.deleteCharAt(0);\\n        }\\n        \\n        TrieNode cur = root;\\n        for (int i = sb.length() - 1; i >= 0; i--) {\\n            int idx = sb.charAt(i) - \\'a\\';\\n            if (cur.children[idx] != null) {\\n                if (cur.children[idx].isEnd) {\\n                    return true;\\n                }\\n                cur = cur.children[idx];\\n            } else {\\n                return false;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private void insert(String word) {\\n        TrieNode cur = root;\\n        for (int i = word.length() - 1; i >= 0; i--) {\\n            int idx = word.charAt(i) - \\'a\\';\\n            if (cur.children[idx] == null) {\\n                cur.children[idx] = new TrieNode();\\n            }\\n            cur = cur.children[idx];\\n        }\\n        cur.isEnd = true;\\n    }\\n}\\n\\nclass TrieNode {\\n    TrieNode[] children;\\n    boolean isEnd;\\n    \\n    public TrieNode() {\\n        children = new TrieNode[26];\\n        isEnd = false;\\n    }\\n}\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker obj = new StreamChecker(words);\\n * boolean param_1 = obj.query(letter);\\n */\\n```\\n\\n\\n```\\nclass StreamChecker {\\n    // non-reverse\\n    private Queue<TrieNode> queue;\\n    \\n    private TrieNode root;\\n    \\n    public StreamChecker(String[] words) {\\n        queue = new LinkedList<>();\\n        root = new TrieNode();\\n        queue.offer(root);\\n        queue.offer(null);\\n        \\n        for (String word : words) {\\n            insert(word);\\n        }\\n    }\\n    \\n    public boolean query(char letter) {\\n        boolean res = false;\\n        queue.offer(root);  \\n        \\n        TrieNode cur = queue.poll();\\n        while (cur != null) {\\n            if (cur.children[letter - \\'a\\'] != null) {\\n                queue.offer(cur.children[letter - \\'a\\']);\\n                if (cur.children[letter - \\'a\\'].isEnd) {\\n                    res = true;\\n                }\\n            }\\n            cur = queue.poll();\\n        }\\n        \\n        queue.offer(null);\\n        return res;\\n    }\\n    \\n    private void insert(String word) {\\n        TrieNode cur = root;\\n        for (char c : word.toCharArray()) {\\n            int idx = c - \\'a\\';\\n            if (cur.children[idx] == null) {\\n                cur.children[idx] = new TrieNode();\\n            }\\n            cur = cur.children[idx];\\n        }\\n        cur.isEnd = true;\\n    }\\n}\\n\\nclass TrieNode {\\n    TrieNode[] children;\\n    boolean isEnd;\\n    \\n    public TrieNode() {\\n        children = new TrieNode[26];\\n        isEnd = false;\\n    }\\n}\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker obj = new StreamChecker(words);\\n * boolean param_1 = obj.query(letter);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass StreamChecker {\\n\\t// reverse\\n    private StringBuilder sb;\\n    \\n    private TrieNode root;\\n    \\n    private int max;\\n    \\n    public StreamChecker(String[] words) {\\n        sb = new StringBuilder();\\n        root = new TrieNode();\\n        max = 0;\\n        for (String word : words) {\\n            insert(word);\\n            max = Math.max(word.length(), max);\\n        }\\n    }\\n    \\n    public boolean query(char letter) {\\n        boolean res = false;\\n        sb.append(letter);\\n        if (sb.length() > max) {\\n            sb.deleteCharAt(0);\\n        }\\n        \\n        TrieNode cur = root;\\n        for (int i = sb.length() - 1; i >= 0; i--) {\\n            int idx = sb.charAt(i) - \\'a\\';\\n            if (cur.children[idx] != null) {\\n                if (cur.children[idx].isEnd) {\\n                    return true;\\n                }\\n                cur = cur.children[idx];\\n            } else {\\n                return false;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private void insert(String word) {\\n        TrieNode cur = root;\\n        for (int i = word.length() - 1; i >= 0; i--) {\\n            int idx = word.charAt(i) - \\'a\\';\\n            if (cur.children[idx] == null) {\\n                cur.children[idx] = new TrieNode();\\n            }\\n            cur = cur.children[idx];\\n        }\\n        cur.isEnd = true;\\n    }\\n}\\n\\nclass TrieNode {\\n    TrieNode[] children;\\n    boolean isEnd;\\n    \\n    public TrieNode() {\\n        children = new TrieNode[26];\\n        isEnd = false;\\n    }\\n}\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker obj = new StreamChecker(words);\\n * boolean param_1 = obj.query(letter);\\n */\\n```\n```\\nclass StreamChecker {\\n    // non-reverse\\n    private Queue<TrieNode> queue;\\n    \\n    private TrieNode root;\\n    \\n    public StreamChecker(String[] words) {\\n        queue = new LinkedList<>();\\n        root = new TrieNode();\\n        queue.offer(root);\\n        queue.offer(null);\\n        \\n        for (String word : words) {\\n            insert(word);\\n        }\\n    }\\n    \\n    public boolean query(char letter) {\\n        boolean res = false;\\n        queue.offer(root);  \\n        \\n        TrieNode cur = queue.poll();\\n        while (cur != null) {\\n            if (cur.children[letter - \\'a\\'] != null) {\\n                queue.offer(cur.children[letter - \\'a\\']);\\n                if (cur.children[letter - \\'a\\'].isEnd) {\\n                    res = true;\\n                }\\n            }\\n            cur = queue.poll();\\n        }\\n        \\n        queue.offer(null);\\n        return res;\\n    }\\n    \\n    private void insert(String word) {\\n        TrieNode cur = root;\\n        for (char c : word.toCharArray()) {\\n            int idx = c - \\'a\\';\\n            if (cur.children[idx] == null) {\\n                cur.children[idx] = new TrieNode();\\n            }\\n            cur = cur.children[idx];\\n        }\\n        cur.isEnd = true;\\n    }\\n}\\n\\nclass TrieNode {\\n    TrieNode[] children;\\n    boolean isEnd;\\n    \\n    public TrieNode() {\\n        children = new TrieNode[26];\\n        isEnd = false;\\n    }\\n}\\n\\n/**\\n * Your StreamChecker object will be instantiated and called as such:\\n * StreamChecker obj = new StreamChecker(words);\\n * boolean param_1 = obj.query(letter);\\n */\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565720,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/stream-of-characters/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "elvinyang",
                        "content": "They can pass because the test cases are weak. O(QL) is `8e7` which is hugh enough to get you TLE.\\nI can\\'t paste my test case here because it\\'s too long, but you may try it yourselves. It\\'s very simple:\\ninput=[\"a...a\"] (just one string of 2000 repeating \\'a\\')\\nquery=\"a\" x 40000 times\\n\\nThis is just another example of terrible test cases misleading people - this problem shouldn\\'t be marked as hard if O(QL) can be accepted.\\n\\n**UPDATE: I\\'ve uploaded the test case on JSFiddle so you may try it out more conviently:**\\nhttps://jsfiddle.net/t9vbxoeu/"
                    },
                    {
                        "username": "charonme",
                        "content": "it says \"Invalid Testcase\\nexpected rows of \\'words\\' to have 1 <= size <= 200\""
                    },
                    {
                        "username": "code_coder_",
                        "content": "Every queried character gets added to the previously queried characters, forming a string. On each query, find if any of the suffix of this string exist in the original list of words.\\n\\nThe most intuitive way would be to store the original list of words in reverse in Trie. Now just reverse the queried string and parse the Trie. If at any point you see a character forming a word, return true."
                    },
                    {
                        "username": "charonme",
                        "content": "interesting idea, I tried this with the reversed words trie, but it didn\\'t seem to be significantly faster than maintaining a list of valid trie nodes for previous stream characters and adding a new node for each new character with the provided test cases"
                    },
                    {
                        "username": "Souvik93",
                        "content": "Algorithm :-\\n\\n1) Create One Trie Data Strcucture Class with two properties/attributes child node and end of word boolean flag .\\n2) Declare one StringBuilder to keep tracking all the character streams.\\n3) In The Stream Reader Constructer Initialize The Trie In Reverser Order Since We need to check Previous Letters Also In Query Method.\\n4) In Query method append letter into declared string builder and check that every char of string builder from end  is present in trie or not. And if it is present then check whether that char node is end of word or not. If it is an end of word then return true. If node is not present or null then return false. If it is not  \\n5) Else return false at the end.\\n\\n\\n\\nCode (Only if required) :- https://github.com/Souvik93/August-LeetCoding-Challenge/blob/master/Stream%20of%20Characters%20Day23.java \\n\\nExplanation :- https://youtu.be/dm5r6iZUjkM\\n"
                    },
                    {
                        "username": "phdeshpa",
                        "content": "I did go with implementing tree and storing in reverse order. I dont understand how the expected output of this is False, True\\n\\n[\"StreamChecker\",\"query\",\"query\"]\\n[[[\"ab\",\"ba\",\"aaab\",\"abab\",\"baa\"]],[\"a\"],[\"b\"]]\\n\\nShouldn\\'t \\'a\\' give true output? The last word is \\'baa\\' and it is stored as \\'aab\\' and it contains \\'a\\', thus true"
                    },
                    {
                        "username": "martinofcourse",
                        "content": "This problem should be tagged as medium at best."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "more of a medium if your familer with trie \\nonly cache is we only store upto maxlength running characters to avoid mle"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "It is not that hard if you know trie just store the words in reverse order and for each character just traverse trie."
                    }
                ]
            },
            {
                "id": 1566975,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/stream-of-characters/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "elvinyang",
                        "content": "They can pass because the test cases are weak. O(QL) is `8e7` which is hugh enough to get you TLE.\\nI can\\'t paste my test case here because it\\'s too long, but you may try it yourselves. It\\'s very simple:\\ninput=[\"a...a\"] (just one string of 2000 repeating \\'a\\')\\nquery=\"a\" x 40000 times\\n\\nThis is just another example of terrible test cases misleading people - this problem shouldn\\'t be marked as hard if O(QL) can be accepted.\\n\\n**UPDATE: I\\'ve uploaded the test case on JSFiddle so you may try it out more conviently:**\\nhttps://jsfiddle.net/t9vbxoeu/"
                    },
                    {
                        "username": "charonme",
                        "content": "it says \"Invalid Testcase\\nexpected rows of \\'words\\' to have 1 <= size <= 200\""
                    },
                    {
                        "username": "code_coder_",
                        "content": "Every queried character gets added to the previously queried characters, forming a string. On each query, find if any of the suffix of this string exist in the original list of words.\\n\\nThe most intuitive way would be to store the original list of words in reverse in Trie. Now just reverse the queried string and parse the Trie. If at any point you see a character forming a word, return true."
                    },
                    {
                        "username": "charonme",
                        "content": "interesting idea, I tried this with the reversed words trie, but it didn\\'t seem to be significantly faster than maintaining a list of valid trie nodes for previous stream characters and adding a new node for each new character with the provided test cases"
                    },
                    {
                        "username": "Souvik93",
                        "content": "Algorithm :-\\n\\n1) Create One Trie Data Strcucture Class with two properties/attributes child node and end of word boolean flag .\\n2) Declare one StringBuilder to keep tracking all the character streams.\\n3) In The Stream Reader Constructer Initialize The Trie In Reverser Order Since We need to check Previous Letters Also In Query Method.\\n4) In Query method append letter into declared string builder and check that every char of string builder from end  is present in trie or not. And if it is present then check whether that char node is end of word or not. If it is an end of word then return true. If node is not present or null then return false. If it is not  \\n5) Else return false at the end.\\n\\n\\n\\nCode (Only if required) :- https://github.com/Souvik93/August-LeetCoding-Challenge/blob/master/Stream%20of%20Characters%20Day23.java \\n\\nExplanation :- https://youtu.be/dm5r6iZUjkM\\n"
                    },
                    {
                        "username": "phdeshpa",
                        "content": "I did go with implementing tree and storing in reverse order. I dont understand how the expected output of this is False, True\\n\\n[\"StreamChecker\",\"query\",\"query\"]\\n[[[\"ab\",\"ba\",\"aaab\",\"abab\",\"baa\"]],[\"a\"],[\"b\"]]\\n\\nShouldn\\'t \\'a\\' give true output? The last word is \\'baa\\' and it is stored as \\'aab\\' and it contains \\'a\\', thus true"
                    },
                    {
                        "username": "martinofcourse",
                        "content": "This problem should be tagged as medium at best."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "more of a medium if your familer with trie \\nonly cache is we only store upto maxlength running characters to avoid mle"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "It is not that hard if you know trie just store the words in reverse order and for each character just traverse trie."
                    }
                ]
            },
            {
                "id": 1568381,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/stream-of-characters/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "elvinyang",
                        "content": "They can pass because the test cases are weak. O(QL) is `8e7` which is hugh enough to get you TLE.\\nI can\\'t paste my test case here because it\\'s too long, but you may try it yourselves. It\\'s very simple:\\ninput=[\"a...a\"] (just one string of 2000 repeating \\'a\\')\\nquery=\"a\" x 40000 times\\n\\nThis is just another example of terrible test cases misleading people - this problem shouldn\\'t be marked as hard if O(QL) can be accepted.\\n\\n**UPDATE: I\\'ve uploaded the test case on JSFiddle so you may try it out more conviently:**\\nhttps://jsfiddle.net/t9vbxoeu/"
                    },
                    {
                        "username": "charonme",
                        "content": "it says \"Invalid Testcase\\nexpected rows of \\'words\\' to have 1 <= size <= 200\""
                    },
                    {
                        "username": "code_coder_",
                        "content": "Every queried character gets added to the previously queried characters, forming a string. On each query, find if any of the suffix of this string exist in the original list of words.\\n\\nThe most intuitive way would be to store the original list of words in reverse in Trie. Now just reverse the queried string and parse the Trie. If at any point you see a character forming a word, return true."
                    },
                    {
                        "username": "charonme",
                        "content": "interesting idea, I tried this with the reversed words trie, but it didn\\'t seem to be significantly faster than maintaining a list of valid trie nodes for previous stream characters and adding a new node for each new character with the provided test cases"
                    },
                    {
                        "username": "Souvik93",
                        "content": "Algorithm :-\\n\\n1) Create One Trie Data Strcucture Class with two properties/attributes child node and end of word boolean flag .\\n2) Declare one StringBuilder to keep tracking all the character streams.\\n3) In The Stream Reader Constructer Initialize The Trie In Reverser Order Since We need to check Previous Letters Also In Query Method.\\n4) In Query method append letter into declared string builder and check that every char of string builder from end  is present in trie or not. And if it is present then check whether that char node is end of word or not. If it is an end of word then return true. If node is not present or null then return false. If it is not  \\n5) Else return false at the end.\\n\\n\\n\\nCode (Only if required) :- https://github.com/Souvik93/August-LeetCoding-Challenge/blob/master/Stream%20of%20Characters%20Day23.java \\n\\nExplanation :- https://youtu.be/dm5r6iZUjkM\\n"
                    },
                    {
                        "username": "phdeshpa",
                        "content": "I did go with implementing tree and storing in reverse order. I dont understand how the expected output of this is False, True\\n\\n[\"StreamChecker\",\"query\",\"query\"]\\n[[[\"ab\",\"ba\",\"aaab\",\"abab\",\"baa\"]],[\"a\"],[\"b\"]]\\n\\nShouldn\\'t \\'a\\' give true output? The last word is \\'baa\\' and it is stored as \\'aab\\' and it contains \\'a\\', thus true"
                    },
                    {
                        "username": "martinofcourse",
                        "content": "This problem should be tagged as medium at best."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "more of a medium if your familer with trie \\nonly cache is we only store upto maxlength running characters to avoid mle"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "It is not that hard if you know trie just store the words in reverse order and for each character just traverse trie."
                    }
                ]
            },
            {
                "id": 1570129,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/stream-of-characters/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "elvinyang",
                        "content": "They can pass because the test cases are weak. O(QL) is `8e7` which is hugh enough to get you TLE.\\nI can\\'t paste my test case here because it\\'s too long, but you may try it yourselves. It\\'s very simple:\\ninput=[\"a...a\"] (just one string of 2000 repeating \\'a\\')\\nquery=\"a\" x 40000 times\\n\\nThis is just another example of terrible test cases misleading people - this problem shouldn\\'t be marked as hard if O(QL) can be accepted.\\n\\n**UPDATE: I\\'ve uploaded the test case on JSFiddle so you may try it out more conviently:**\\nhttps://jsfiddle.net/t9vbxoeu/"
                    },
                    {
                        "username": "charonme",
                        "content": "it says \"Invalid Testcase\\nexpected rows of \\'words\\' to have 1 <= size <= 200\""
                    },
                    {
                        "username": "code_coder_",
                        "content": "Every queried character gets added to the previously queried characters, forming a string. On each query, find if any of the suffix of this string exist in the original list of words.\\n\\nThe most intuitive way would be to store the original list of words in reverse in Trie. Now just reverse the queried string and parse the Trie. If at any point you see a character forming a word, return true."
                    },
                    {
                        "username": "charonme",
                        "content": "interesting idea, I tried this with the reversed words trie, but it didn\\'t seem to be significantly faster than maintaining a list of valid trie nodes for previous stream characters and adding a new node for each new character with the provided test cases"
                    },
                    {
                        "username": "Souvik93",
                        "content": "Algorithm :-\\n\\n1) Create One Trie Data Strcucture Class with two properties/attributes child node and end of word boolean flag .\\n2) Declare one StringBuilder to keep tracking all the character streams.\\n3) In The Stream Reader Constructer Initialize The Trie In Reverser Order Since We need to check Previous Letters Also In Query Method.\\n4) In Query method append letter into declared string builder and check that every char of string builder from end  is present in trie or not. And if it is present then check whether that char node is end of word or not. If it is an end of word then return true. If node is not present or null then return false. If it is not  \\n5) Else return false at the end.\\n\\n\\n\\nCode (Only if required) :- https://github.com/Souvik93/August-LeetCoding-Challenge/blob/master/Stream%20of%20Characters%20Day23.java \\n\\nExplanation :- https://youtu.be/dm5r6iZUjkM\\n"
                    },
                    {
                        "username": "phdeshpa",
                        "content": "I did go with implementing tree and storing in reverse order. I dont understand how the expected output of this is False, True\\n\\n[\"StreamChecker\",\"query\",\"query\"]\\n[[[\"ab\",\"ba\",\"aaab\",\"abab\",\"baa\"]],[\"a\"],[\"b\"]]\\n\\nShouldn\\'t \\'a\\' give true output? The last word is \\'baa\\' and it is stored as \\'aab\\' and it contains \\'a\\', thus true"
                    },
                    {
                        "username": "martinofcourse",
                        "content": "This problem should be tagged as medium at best."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "more of a medium if your familer with trie \\nonly cache is we only store upto maxlength running characters to avoid mle"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "It is not that hard if you know trie just store the words in reverse order and for each character just traverse trie."
                    }
                ]
            },
            {
                "id": 1572631,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/stream-of-characters/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "elvinyang",
                        "content": "They can pass because the test cases are weak. O(QL) is `8e7` which is hugh enough to get you TLE.\\nI can\\'t paste my test case here because it\\'s too long, but you may try it yourselves. It\\'s very simple:\\ninput=[\"a...a\"] (just one string of 2000 repeating \\'a\\')\\nquery=\"a\" x 40000 times\\n\\nThis is just another example of terrible test cases misleading people - this problem shouldn\\'t be marked as hard if O(QL) can be accepted.\\n\\n**UPDATE: I\\'ve uploaded the test case on JSFiddle so you may try it out more conviently:**\\nhttps://jsfiddle.net/t9vbxoeu/"
                    },
                    {
                        "username": "charonme",
                        "content": "it says \"Invalid Testcase\\nexpected rows of \\'words\\' to have 1 <= size <= 200\""
                    },
                    {
                        "username": "code_coder_",
                        "content": "Every queried character gets added to the previously queried characters, forming a string. On each query, find if any of the suffix of this string exist in the original list of words.\\n\\nThe most intuitive way would be to store the original list of words in reverse in Trie. Now just reverse the queried string and parse the Trie. If at any point you see a character forming a word, return true."
                    },
                    {
                        "username": "charonme",
                        "content": "interesting idea, I tried this with the reversed words trie, but it didn\\'t seem to be significantly faster than maintaining a list of valid trie nodes for previous stream characters and adding a new node for each new character with the provided test cases"
                    },
                    {
                        "username": "Souvik93",
                        "content": "Algorithm :-\\n\\n1) Create One Trie Data Strcucture Class with two properties/attributes child node and end of word boolean flag .\\n2) Declare one StringBuilder to keep tracking all the character streams.\\n3) In The Stream Reader Constructer Initialize The Trie In Reverser Order Since We need to check Previous Letters Also In Query Method.\\n4) In Query method append letter into declared string builder and check that every char of string builder from end  is present in trie or not. And if it is present then check whether that char node is end of word or not. If it is an end of word then return true. If node is not present or null then return false. If it is not  \\n5) Else return false at the end.\\n\\n\\n\\nCode (Only if required) :- https://github.com/Souvik93/August-LeetCoding-Challenge/blob/master/Stream%20of%20Characters%20Day23.java \\n\\nExplanation :- https://youtu.be/dm5r6iZUjkM\\n"
                    },
                    {
                        "username": "phdeshpa",
                        "content": "I did go with implementing tree and storing in reverse order. I dont understand how the expected output of this is False, True\\n\\n[\"StreamChecker\",\"query\",\"query\"]\\n[[[\"ab\",\"ba\",\"aaab\",\"abab\",\"baa\"]],[\"a\"],[\"b\"]]\\n\\nShouldn\\'t \\'a\\' give true output? The last word is \\'baa\\' and it is stored as \\'aab\\' and it contains \\'a\\', thus true"
                    },
                    {
                        "username": "martinofcourse",
                        "content": "This problem should be tagged as medium at best."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "more of a medium if your familer with trie \\nonly cache is we only store upto maxlength running characters to avoid mle"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "It is not that hard if you know trie just store the words in reverse order and for each character just traverse trie."
                    }
                ]
            },
            {
                "id": 1569504,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/stream-of-characters/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "elvinyang",
                        "content": "They can pass because the test cases are weak. O(QL) is `8e7` which is hugh enough to get you TLE.\\nI can\\'t paste my test case here because it\\'s too long, but you may try it yourselves. It\\'s very simple:\\ninput=[\"a...a\"] (just one string of 2000 repeating \\'a\\')\\nquery=\"a\" x 40000 times\\n\\nThis is just another example of terrible test cases misleading people - this problem shouldn\\'t be marked as hard if O(QL) can be accepted.\\n\\n**UPDATE: I\\'ve uploaded the test case on JSFiddle so you may try it out more conviently:**\\nhttps://jsfiddle.net/t9vbxoeu/"
                    },
                    {
                        "username": "charonme",
                        "content": "it says \"Invalid Testcase\\nexpected rows of \\'words\\' to have 1 <= size <= 200\""
                    },
                    {
                        "username": "code_coder_",
                        "content": "Every queried character gets added to the previously queried characters, forming a string. On each query, find if any of the suffix of this string exist in the original list of words.\\n\\nThe most intuitive way would be to store the original list of words in reverse in Trie. Now just reverse the queried string and parse the Trie. If at any point you see a character forming a word, return true."
                    },
                    {
                        "username": "charonme",
                        "content": "interesting idea, I tried this with the reversed words trie, but it didn\\'t seem to be significantly faster than maintaining a list of valid trie nodes for previous stream characters and adding a new node for each new character with the provided test cases"
                    },
                    {
                        "username": "Souvik93",
                        "content": "Algorithm :-\\n\\n1) Create One Trie Data Strcucture Class with two properties/attributes child node and end of word boolean flag .\\n2) Declare one StringBuilder to keep tracking all the character streams.\\n3) In The Stream Reader Constructer Initialize The Trie In Reverser Order Since We need to check Previous Letters Also In Query Method.\\n4) In Query method append letter into declared string builder and check that every char of string builder from end  is present in trie or not. And if it is present then check whether that char node is end of word or not. If it is an end of word then return true. If node is not present or null then return false. If it is not  \\n5) Else return false at the end.\\n\\n\\n\\nCode (Only if required) :- https://github.com/Souvik93/August-LeetCoding-Challenge/blob/master/Stream%20of%20Characters%20Day23.java \\n\\nExplanation :- https://youtu.be/dm5r6iZUjkM\\n"
                    },
                    {
                        "username": "phdeshpa",
                        "content": "I did go with implementing tree and storing in reverse order. I dont understand how the expected output of this is False, True\\n\\n[\"StreamChecker\",\"query\",\"query\"]\\n[[[\"ab\",\"ba\",\"aaab\",\"abab\",\"baa\"]],[\"a\"],[\"b\"]]\\n\\nShouldn\\'t \\'a\\' give true output? The last word is \\'baa\\' and it is stored as \\'aab\\' and it contains \\'a\\', thus true"
                    },
                    {
                        "username": "martinofcourse",
                        "content": "This problem should be tagged as medium at best."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "more of a medium if your familer with trie \\nonly cache is we only store upto maxlength running characters to avoid mle"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "It is not that hard if you know trie just store the words in reverse order and for each character just traverse trie."
                    }
                ]
            },
            {
                "id": 2066967,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/stream-of-characters/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "elvinyang",
                        "content": "They can pass because the test cases are weak. O(QL) is `8e7` which is hugh enough to get you TLE.\\nI can\\'t paste my test case here because it\\'s too long, but you may try it yourselves. It\\'s very simple:\\ninput=[\"a...a\"] (just one string of 2000 repeating \\'a\\')\\nquery=\"a\" x 40000 times\\n\\nThis is just another example of terrible test cases misleading people - this problem shouldn\\'t be marked as hard if O(QL) can be accepted.\\n\\n**UPDATE: I\\'ve uploaded the test case on JSFiddle so you may try it out more conviently:**\\nhttps://jsfiddle.net/t9vbxoeu/"
                    },
                    {
                        "username": "charonme",
                        "content": "it says \"Invalid Testcase\\nexpected rows of \\'words\\' to have 1 <= size <= 200\""
                    },
                    {
                        "username": "code_coder_",
                        "content": "Every queried character gets added to the previously queried characters, forming a string. On each query, find if any of the suffix of this string exist in the original list of words.\\n\\nThe most intuitive way would be to store the original list of words in reverse in Trie. Now just reverse the queried string and parse the Trie. If at any point you see a character forming a word, return true."
                    },
                    {
                        "username": "charonme",
                        "content": "interesting idea, I tried this with the reversed words trie, but it didn\\'t seem to be significantly faster than maintaining a list of valid trie nodes for previous stream characters and adding a new node for each new character with the provided test cases"
                    },
                    {
                        "username": "Souvik93",
                        "content": "Algorithm :-\\n\\n1) Create One Trie Data Strcucture Class with two properties/attributes child node and end of word boolean flag .\\n2) Declare one StringBuilder to keep tracking all the character streams.\\n3) In The Stream Reader Constructer Initialize The Trie In Reverser Order Since We need to check Previous Letters Also In Query Method.\\n4) In Query method append letter into declared string builder and check that every char of string builder from end  is present in trie or not. And if it is present then check whether that char node is end of word or not. If it is an end of word then return true. If node is not present or null then return false. If it is not  \\n5) Else return false at the end.\\n\\n\\n\\nCode (Only if required) :- https://github.com/Souvik93/August-LeetCoding-Challenge/blob/master/Stream%20of%20Characters%20Day23.java \\n\\nExplanation :- https://youtu.be/dm5r6iZUjkM\\n"
                    },
                    {
                        "username": "phdeshpa",
                        "content": "I did go with implementing tree and storing in reverse order. I dont understand how the expected output of this is False, True\\n\\n[\"StreamChecker\",\"query\",\"query\"]\\n[[[\"ab\",\"ba\",\"aaab\",\"abab\",\"baa\"]],[\"a\"],[\"b\"]]\\n\\nShouldn\\'t \\'a\\' give true output? The last word is \\'baa\\' and it is stored as \\'aab\\' and it contains \\'a\\', thus true"
                    },
                    {
                        "username": "martinofcourse",
                        "content": "This problem should be tagged as medium at best."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "more of a medium if your familer with trie \\nonly cache is we only store upto maxlength running characters to avoid mle"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "It is not that hard if you know trie just store the words in reverse order and for each character just traverse trie."
                    }
                ]
            },
            {
                "id": 1816944,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/stream-of-characters/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "elvinyang",
                        "content": "They can pass because the test cases are weak. O(QL) is `8e7` which is hugh enough to get you TLE.\\nI can\\'t paste my test case here because it\\'s too long, but you may try it yourselves. It\\'s very simple:\\ninput=[\"a...a\"] (just one string of 2000 repeating \\'a\\')\\nquery=\"a\" x 40000 times\\n\\nThis is just another example of terrible test cases misleading people - this problem shouldn\\'t be marked as hard if O(QL) can be accepted.\\n\\n**UPDATE: I\\'ve uploaded the test case on JSFiddle so you may try it out more conviently:**\\nhttps://jsfiddle.net/t9vbxoeu/"
                    },
                    {
                        "username": "charonme",
                        "content": "it says \"Invalid Testcase\\nexpected rows of \\'words\\' to have 1 <= size <= 200\""
                    },
                    {
                        "username": "code_coder_",
                        "content": "Every queried character gets added to the previously queried characters, forming a string. On each query, find if any of the suffix of this string exist in the original list of words.\\n\\nThe most intuitive way would be to store the original list of words in reverse in Trie. Now just reverse the queried string and parse the Trie. If at any point you see a character forming a word, return true."
                    },
                    {
                        "username": "charonme",
                        "content": "interesting idea, I tried this with the reversed words trie, but it didn\\'t seem to be significantly faster than maintaining a list of valid trie nodes for previous stream characters and adding a new node for each new character with the provided test cases"
                    },
                    {
                        "username": "Souvik93",
                        "content": "Algorithm :-\\n\\n1) Create One Trie Data Strcucture Class with two properties/attributes child node and end of word boolean flag .\\n2) Declare one StringBuilder to keep tracking all the character streams.\\n3) In The Stream Reader Constructer Initialize The Trie In Reverser Order Since We need to check Previous Letters Also In Query Method.\\n4) In Query method append letter into declared string builder and check that every char of string builder from end  is present in trie or not. And if it is present then check whether that char node is end of word or not. If it is an end of word then return true. If node is not present or null then return false. If it is not  \\n5) Else return false at the end.\\n\\n\\n\\nCode (Only if required) :- https://github.com/Souvik93/August-LeetCoding-Challenge/blob/master/Stream%20of%20Characters%20Day23.java \\n\\nExplanation :- https://youtu.be/dm5r6iZUjkM\\n"
                    },
                    {
                        "username": "phdeshpa",
                        "content": "I did go with implementing tree and storing in reverse order. I dont understand how the expected output of this is False, True\\n\\n[\"StreamChecker\",\"query\",\"query\"]\\n[[[\"ab\",\"ba\",\"aaab\",\"abab\",\"baa\"]],[\"a\"],[\"b\"]]\\n\\nShouldn\\'t \\'a\\' give true output? The last word is \\'baa\\' and it is stored as \\'aab\\' and it contains \\'a\\', thus true"
                    },
                    {
                        "username": "martinofcourse",
                        "content": "This problem should be tagged as medium at best."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "more of a medium if your familer with trie \\nonly cache is we only store upto maxlength running characters to avoid mle"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "It is not that hard if you know trie just store the words in reverse order and for each character just traverse trie."
                    }
                ]
            }
        ]
    },
    {
        "title": "Last Moment Before All Ants Fall Out of a Plank",
        "question_content": "<p>We have a wooden plank of the length <code>n</code> <strong>units</strong>. Some ants are walking on the plank, each ant moves with a speed of <strong>1 unit per second</strong>. Some of the ants move to the <strong>left</strong>, the other move to the <strong>right</strong>.</p>\n\n<p>When two ants moving in two <strong>different</strong> directions meet at some point, they change their directions and continue moving again. Assume changing directions does not take any additional time.</p>\n\n<p>When an ant reaches <strong>one end</strong> of the plank at a time <code>t</code>, it falls out of the plank immediately.</p>\n\n<p>Given an integer <code>n</code> and two integer arrays <code>left</code> and <code>right</code>, the positions of the ants moving to the left and the right, return <em>the moment when the last ant(s) fall out of the plank</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/06/17/ants.jpg\" style=\"width: 450px; height: 610px;\" />\n<pre>\n<strong>Input:</strong> n = 4, left = [4,3], right = [0,1]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> In the image above:\n-The ant at index 0 is named A and going to the right.\n-The ant at index 1 is named B and going to the right.\n-The ant at index 3 is named C and going to the left.\n-The ant at index 4 is named D and going to the left.\nThe last moment when an ant was on the plank is t = 4 seconds. After that, it falls immediately out of the plank. (i.e., We can say that at t = 4.0000000001, there are no ants on the plank).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/06/17/ants2.jpg\" style=\"width: 639px; height: 101px;\" />\n<pre>\n<strong>Input:</strong> n = 7, left = [], right = [0,1,2,3,4,5,6,7]\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> All ants are going to the right, the ant at index 0 needs 7 seconds to fall.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/06/17/ants3.jpg\" style=\"width: 639px; height: 100px;\" />\n<pre>\n<strong>Input:</strong> n = 7, left = [0,1,2,3,4,5,6,7], right = []\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> All ants are going to the left, the ant at index 7 needs 7 seconds to fall.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= left.length &lt;= n + 1</code></li>\n\t<li><code>0 &lt;= left[i] &lt;= n</code></li>\n\t<li><code>0 &lt;= right.length &lt;= n + 1</code></li>\n\t<li><code>0 &lt;= right[i] &lt;= n</code></li>\n\t<li><code>1 &lt;= left.length + right.length &lt;= n + 1</code></li>\n\t<li>All values of <code>left</code> and <code>right</code> are unique, and each value can appear <strong>only in one</strong> of the two arrays.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 720189,
                "title": "java-c-python-ants-keep-walking-o-n",
                "content": "# **Intuition**\\nWhen two ants meet at some point,\\nthey change their directions and continue moving again.\\nBut you can assume they don\\'t change direction and keep moving.\\n\\n(You don\\'t really know the difference of ants between one and the other, do you?)\\n<br>\\n\\n# Explanation\\nFor ants in direction of left, the leaving time is `left[i]`\\nFor ants in direction of right, the leaving time is `n - right[i]`\\n<br>\\n\\n# **Complexity**\\nTime `O(N)`\\nSpace `O(1)`\\n\\n<br>\\n\\n**Java:**\\n```java\\n    public int getLastMoment(int n, int[] left, int[] right) {\\n        int res = 0;\\n        for (int i: left)\\n            res = Math.max(res, i);\\n        for (int i: right)\\n            res = Math.max(res, n - i);\\n        return res;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int res = 0;\\n        for (int& i: left)\\n            res = max(res, i);\\n        for (int& i: right)\\n            res = max(res, n - i);\\n        return res;\\n    }\\n```\\n\\n**Python:**\\n```py\\n    def getLastMoment(self, n, left, right):\\n        return max(max(left or [0]), n - min(right or [n]))\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int getLastMoment(int n, int[] left, int[] right) {\\n        int res = 0;\\n        for (int i: left)\\n            res = Math.max(res, i);\\n        for (int i: right)\\n            res = Math.max(res, n - i);\\n        return res;\\n    }\\n```\n```cpp\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int res = 0;\\n        for (int& i: left)\\n            res = max(res, i);\\n        for (int& i: right)\\n            res = max(res, n - i);\\n        return res;\\n    }\\n```\n```py\\n    def getLastMoment(self, n, left, right):\\n        return max(max(left or [0]), n - min(right or [n]))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 720313,
                "title": "c-python-java-beautiful-visual-explanation",
                "content": "# Introduction\\nFirst of all, it\\'s a too tricky for a coding problem. In interviews, generally nobody would ask questions like this, or at least most won\\'t prefer asking this. So some sigh of relief there. As for solving the problem goes - hope that the diagram makes visualization clear & hence assist in getting the intuition. \\n\\n# It\\'s a lot about observation\\nThe problem, I think, is about testing the observation skills. Observing and analysing the ant behavior will reveal that the problem is way to tricky to understand, but way to easy to implement.\\n\\n# Key idea / Intuition\\nThe idea is to think of the bigger picture and focus only on the paths of the ants. At any collision, think of it as ants transferring their responsibility of going to the other end, to each other. So one ant covers the path for the other.\\n\\n# Explanation\\nAs you see this, the implementation is trivial. Many learners suggested that I explain with code, so please check the code below which also has the explanation.\\n\\n![image](https://assets.leetcode.com/users/images/7d5d2ab8-1fb5-4a59-bc8c-d82e1e947670_1593995093.9210796.png)\\n\\n\\n## Thank you. \\n\\nPlease upvote if it helps -\\n\\n1. It encourages me to write and share my solutions if they are easy to understand.\\n2. It reaches to more learners, larger audience. :)\\n\\nThanks.\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        // The one that is farthest from the left end, but desires to go in the left\\n        // direction, will be the last one to go off of the plank from the left side.\\n        int maxLeft = left.empty() ? 0 : *max_element(left.begin(), left.end());\\n        \\n        // Similarly,\\n        // The one that is farthest from the right end, but desires to go in the right\\n        // direction, will be the last one to go off of the plank from the right side.\\n        int minRight = right.empty() ? n : *min_element(right.begin(), right.end());\\n        \\n        // The one among above two would be the last one to off of the plank among all.\\n        return max(maxLeft, n - minRight);\\n    }\\n};\\n```\\n\\nOther languages -\\n# Python\\n```\\nclass Solution(object):\\n    def getLastMoment(self, n, left, right):\\n        maxLeft  = max(left)  if len(left) > 0 else 0\\n        minRight = min(right) if (len(right)) > 0 else n\\n        return max(maxLeft, n - minRight)\\n```\\n\\n# Java\\n```\\nclass Solution {\\n    public int getLastMoment(int n, int[] left, int[] right) {\\n        int maxLeft = 0;\\n        for(int x : left) {\\n            maxLeft=Math.max(maxLeft, x);\\n        }\\n        int minRight = n;\\n        for(int x : right) {\\n            minRight=Math.min(minRight, x);\\n        }\\n        return Math.max(maxLeft, n - minRight);\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        // The one that is farthest from the left end, but desires to go in the left\\n        // direction, will be the last one to go off of the plank from the left side.\\n        int maxLeft = left.empty() ? 0 : *max_element(left.begin(), left.end());\\n        \\n        // Similarly,\\n        // The one that is farthest from the right end, but desires to go in the right\\n        // direction, will be the last one to go off of the plank from the right side.\\n        int minRight = right.empty() ? n : *min_element(right.begin(), right.end());\\n        \\n        // The one among above two would be the last one to off of the plank among all.\\n        return max(maxLeft, n - minRight);\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def getLastMoment(self, n, left, right):\\n        maxLeft  = max(left)  if len(left) > 0 else 0\\n        minRight = min(right) if (len(right)) > 0 else n\\n        return max(maxLeft, n - minRight)\\n```\n```\\nclass Solution {\\n    public int getLastMoment(int n, int[] left, int[] right) {\\n        int maxLeft = 0;\\n        for(int x : left) {\\n            maxLeft=Math.max(maxLeft, x);\\n        }\\n        int minRight = n;\\n        for(int x : right) {\\n            minRight=Math.min(minRight, x);\\n        }\\n        return Math.max(maxLeft, n - minRight);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720130,
                "title": "c-java-two-way-street-o-n",
                "content": "If two ants bump into each other and change directions, it\\'s the same as if these ants continue as nothing happens.\\n\\nSo, we can think about that plank as a two-way street. So, find the maximum units that any ant needs to travel.\\n\\n>  I got this intuition by manually solving few test cases. My first idea was simulation, but the implementation seemed too complex. \\n>  So, I was already looking for ways to simplify it.\\n>  \\n>  For me, during the contest and the interview, finding few good test cases and solving them manually is the way to unstuck.\\n\\n**C++**\\n```cpp\\nint getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n    return max(left.empty() ? 0 : *max_element(begin(left), end(left)),\\n        n - (right.empty() ? n : *min_element(begin(right), end(right))));\\n}\\n```\\nIf you do not like one-liners, here is an easier to read Java solution.\\n\\n**Java**\\n```java\\npublic int getLastMoment(int n, int[] left, int[] right) {\\n    int units = 0;\\n    for (var u : left)\\n        units = Math.max(units, u);\\n    for (var u : right)\\n        units = Math.max(units, n - u);        \\n    return units;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n    return max(left.empty() ? 0 : *max_element(begin(left), end(left)),\\n        n - (right.empty() ? n : *min_element(begin(right), end(right))));\\n}\\n```\n```java\\npublic int getLastMoment(int n, int[] left, int[] right) {\\n    int units = 0;\\n    for (var u : left)\\n        units = Math.max(units, u);\\n    for (var u : right)\\n        units = Math.max(units, n - u);        \\n    return units;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 720115,
                "title": "python3-1-line-brain-teaser",
                "content": "Algo\\nFor colliding ants, you could simply switch their identities. This is equivalent to \"no collision\" scenario. Check each ant indepdently. The one that takes the longest time would be the last moment for all ants falling out of the prank. \\n\\n`O(N)` time & `O(1)` space \\n```\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        return max(max(left, default=0), n - min(right, default=n))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        return max(max(left, default=0), n - min(right, default=n))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720094,
                "title": "c-ants-continues-walking-after-meeting-each-other",
                "content": "We can treat the two queues moving to left and right separately because meeting and turning has no cost, or we can think that the one moving left continues moving left after two ants meet, and the one moving right also continues with previous direction.\\nSo the algorithm is :\\n\\nfor the ants moving to the left, find the rightmost one, it is the last to reach index 0 and fall out,\\nfor the ants moving to the right, find the leftmost one, it is the last to reach index n-1 and fall out.\\n\\n```\\nint getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int res = 0;\\n        if(left.size()) {\\n            int t = *max_element(left.begin(), left.end());\\n            res = t;\\n        }\\n        if(right.size()) {\\n            int t = *min_element(right.begin(), right.end());\\n            res = max(res, n-t);\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int res = 0;\\n        if(left.size()) {\\n            int t = *max_element(left.begin(), left.end());\\n            res = t;\\n        }\\n        if(right.size()) {\\n            int t = *min_element(right.begin(), right.end());\\n            res = max(res, n-t);\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 720263,
                "title": "python3-ants-don-t-really-change-direction-o-n",
                "content": "You can observe that the ants can keep on walking without changing the sides.\\nNow the maximum time required is the maximum time in which the right-most ant reaches 0 and the left-most ant reaches `n`\\n```\\ndef getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        if left == [] and right == []:\\n            return 0\\n        if left == []:\\n            return n - min(right)\\n        if right == []:\\n            return max(left)\\n        return max(max(left), n-min(right))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        if left == [] and right == []:\\n            return 0\\n        if left == []:\\n            return n - min(right)\\n        if right == []:\\n            return max(left)\\n        return max(max(left), n-min(right))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 720102,
                "title": "tricky-question-java-solution-o-n",
                "content": "```\\npublic int getLastMoment(int n, int[] left, int[] right) {\\n        int max=0;\\n        for(int l:left)\\n            max=Math.max(max,l);\\n        for(int r:right)\\n            max=Math.max(max,n-r);\\n        return max;\\n    }\\n```\\nIts like a brainteaser question",
                "solutionTags": [],
                "code": "```\\npublic int getLastMoment(int n, int[] left, int[] right) {\\n        int max=0;\\n        for(int l:left)\\n            max=Math.max(max,l);\\n        for(int r:right)\\n            max=Math.max(max,n-r);\\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 759850,
                "title": "simple-c-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    // lets assume that ant left[i] and right[i] collide at any point x;\\n    // so after collision they change their direction\\n    \\n    // so after collision ant left[i] change its direction and start moving towards right from point x\\n    // after collision ant right[j] change its direction and start moving towards left from point x\\n    \\n    // now we can replace left[i] and right[j] ant -> and there will be no effect of collision\\n    \\n    //so after collision rather than changing their direction assume left[i] becomes right[j] and vice versa\\n    \\n    \\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        \\n        int ans=0;\\n        for(int i=0;i<left.size();i++){\\n            ans=max(ans,(abs(0-left[i])));\\n        }\\n        \\n        for(int i=0;i<right.size();i++){\\n            ans=max(ans,abs(n-right[i]));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // lets assume that ant left[i] and right[i] collide at any point x;\\n    // so after collision they change their direction\\n    \\n    // so after collision ant left[i] change its direction and start moving towards right from point x\\n    // after collision ant right[j] change its direction and start moving towards left from point x\\n    \\n    // now we can replace left[i] and right[j] ant -> and there will be no effect of collision\\n    \\n    //so after collision rather than changing their direction assume left[i] becomes right[j] and vice versa\\n    \\n    \\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        \\n        int ans=0;\\n        for(int i=0;i<left.size();i++){\\n            ans=max(ans,(abs(0-left[i])));\\n        }\\n        \\n        for(int i=0;i<right.size();i++){\\n            ans=max(ans,abs(n-right[i]));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720206,
                "title": "both-change-direction-both-crossed-when-met",
                "content": "Since ants are all the same, you can treat the met as:\\nboth change direction === both crossed when met\\nthe find the most right ant with left direction (rmax) and most left ant with right direction (lmin)\\n\\n```\\n    public int getLastMoment(int n, int[] left, int[] right) {\\n        int rmax = 0, lmin = n;  // \\n        for (int i : right) lmin = Math.min(i, lmin);\\n        for (int i : left) rmax = Math.max(i, rmax);\\n        return Math.max(rmax, n - lmin);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int getLastMoment(int n, int[] left, int[] right) {\\n        int rmax = 0, lmin = n;  // \\n        for (int i : right) lmin = Math.min(i, lmin);\\n        for (int i : left) rmax = Math.max(i, rmax);\\n        return Math.max(rmax, n - lmin);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 720176,
                "title": "javascript-solution",
                "content": "```\\nvar getLastMoment = function(n, left, right) {\\n    left.sort(function(a,b){return a-b});\\n    right.sort(function(a,b){return a-b});\\n    if(left.length == 0){\\n        return n-right[0];\\n    }\\n    if(right.length == 0){\\n        return left[left.length-1];\\n    }\\n    return Math.max(left[left.length-1], n-right[0])\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar getLastMoment = function(n, left, right) {\\n    left.sort(function(a,b){return a-b});\\n    right.sort(function(a,b){return a-b});\\n    if(left.length == 0){\\n        return n-right[0];\\n    }\\n    if(right.length == 0){\\n        return left[left.length-1];\\n    }\\n    return Math.max(left[left.length-1], n-right[0])\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 720140,
                "title": "javascript-image-they-switch-id-simple-solution",
                "content": "```\\nvar getLastMoment = function(n, left, right) {\\n    return Math.max(Math.max(...left), n - Math.min(...right));\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar getLastMoment = function(n, left, right) {\\n    return Math.max(Math.max(...left), n - Math.min(...right));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1894557,
                "title": "c-simple-logic-solution-with-explanation-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        //INTUITION: Ants colliding and changing direction doesn\\'t really matter because all ants are moving at the same speed\\n        //e.g. say the left boundary is at 0 and right at 5. One ant was moving towards right and one towards left, and they collide at 2.\\n        //Even then, one ant would still be moving towards right boundary from 2 and one towards the left boundary.\\n        //This is because all ants are identical, so it doesn\\'t matter even if they collide and change directions with each other.\\n        \\n        \\n        //ALGO: Find the maximum time that any ant would take to reach the left boundary and right boundary. Return this maximum time.\\n        int ans = 0;\\n        for(auto i: left)\\n            ans = max(ans,i);\\n        for(auto i: right)\\n            ans = max(ans, n-i);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        //INTUITION: Ants colliding and changing direction doesn\\'t really matter because all ants are moving at the same speed\\n        //e.g. say the left boundary is at 0 and right at 5. One ant was moving towards right and one towards left, and they collide at 2.\\n        //Even then, one ant would still be moving towards right boundary from 2 and one towards the left boundary.\\n        //This is because all ants are identical, so it doesn\\'t matter even if they collide and change directions with each other.\\n        \\n        \\n        //ALGO: Find the maximum time that any ant would take to reach the left boundary and right boundary. Return this maximum time.\\n        int ans = 0;\\n        for(auto i: left)\\n            ans = max(ans,i);\\n        for(auto i: right)\\n            ans = max(ans, n-i);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1306322,
                "title": "simple-python-solution-with-explanation",
                "content": "The condtion \"When two ants moving in two different directions meet at some point, they change their directions and continue moving again. Assume changing directions doesn\\'t take any additional time.\" is immaterial because: When two ants meet, they change their directions - we can interpret this other way round, i.e two ants crossing each other. So we can consider it as the two ants go over each other instead of changing directions.\\n\\nWe can then simplify this problem into two steps:\\n1. Find the right-most ant (right most in the sense of think of the position of ant on a number line) in the left array (max of left array). This ant will take maximum amount of time to cross and fall. \\n2. Similarly, find the leftmost ant in the right array ((closest to zero - min of right array) . Again this ant will take the most amount of time to go across the edge and fall.\\n\\nNumber of steps/time taken by rightmost ant to fall would be right_max value.\\nAnd for left most ant, it would be (n-left_min).\\nThe max of above two values should be your answer.\\n\\n```\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        \\n        if len(left):\\n            r_max = max(left)\\n        else: r_max =0\\n        if len(right):\\n            l_min = min(right)\\n        else: l_min = n    \\n        max_diff = max(r_max, n-l_min)\\n        return max_diff\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        \\n        if len(left):\\n            r_max = max(left)\\n        else: r_max =0\\n        if len(right):\\n            l_min = min(right)\\n        else: l_min = n    \\n        max_diff = max(r_max, n-l_min)\\n        return max_diff\\n```",
                "codeTag": "Java"
            },
            {
                "id": 724084,
                "title": "python3-o-n-simple-solution",
                "content": "```\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        if len(right)==0:\\n            return max(left)\\n        if len(left)==0:\\n            return n-min(right)\\n        return max(max(left),n-min(right))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        if len(right)==0:\\n            return max(left)\\n        if len(left)==0:\\n            return n-min(right)\\n        return max(max(left),n-min(right))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720397,
                "title": "python-3-lines-100-o-n",
                "content": "When left ant collides with the right ant, both of them change direction. Thus the left ant becomes the right ant, and the right ant becomes the left ant. So safely, one can ignore the collisions and check each ant independently. This is a \\'no collision\\' scenario.\\n\\nThe maximum time required is the max of following\\n\\n1) time required by furthest left ant to fall off from the right side of plank\\n\\t\\tleft_time = max(left,default=0)\\n\\t\\t\\n2) time required by furthest right ant to fall off from the left side of plank\\n\\t\\tright_time = n - min(right,default=n)\\n\\n\\' \\' \\' \\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        \\n \\n        left_time = max(left,default=0)\\n\\n        right_time = n - min(right,default=n)\\n             \\n        return max(left_time,right_time)\\n                        \\n\\' \\' \\'![image](https://assets.leetcode.com/users/images/87f6090d-f50b-4778-9766-f57f42a48025_1593928500.8293016.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "When left ant collides with the right ant, both of them change direction. Thus the left ant becomes the right ant, and the right ant becomes the left ant. So safely, one can ignore the collisions and check each ant independently. This is a \\'no collision\\' scenario.\\n\\nThe maximum time required is the max of following\\n\\n1) time required by furthest left ant to fall off from the right side of plank\\n\\t\\tleft_time = max(left,default=0)\\n\\t\\t\\n2) time required by furthest right ant to fall off from the left side of plank\\n\\t\\tright_time = n - min(right,default=n)\\n\\n\\' \\' \\' \\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        \\n \\n        left_time = max(left,default=0)\\n\\n        right_time = n - min(right,default=n)\\n             \\n        return max(left_time,right_time)\\n                        \\n\\' \\' \\'![image](https://assets.leetcode.com/users/images/87f6090d-f50b-4778-9766-f57f42a48025_1593928500.8293016.png)\\n",
                "codeTag": "Java"
            },
            {
                "id": 3854300,
                "title": "c-good-example-wonderful-explanation-faster-than-100-upvote",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        // Intution\\n        // The idea in here is, if there is a collision then in place of right ant we will get left ant and in the place of left ant we will get right ant. But, the affect would be exactly same. Consider the example below\\n\\n        // Let n be 5\\n\\n        // There are three ants two going to right, and one coming to left\\n\\n        // Initial configuration\\n\\n        // 1 - Ant1 2 - Ant2 3 - Empty 4 - Empty 5 - Ant3\\n\\n        // After one second\\n\\n        // 1 - Empty 2 - Ant1 3 - Ant2 4 - Ant3 5 - Empty\\n\\n        // After two seconds\\n\\n        // 1 - Empty 2 - Empty 3 - Ant1 4 - (Ant2 -> Right, Ant3 -> Left) 5 - Empty\\n\\n        // One collision occured. So, now Ant2 -> Left, Ant3 -> Right\\n\\n        // 1 - Empty 2 - Empty 3 - Ant2 4 - Ant1 5 - Ant3\\n\\n        // If we assumed that collision won\\'t make any change then\\n\\n        // After two seconds collision affect will be\\n\\n        // 1 - Empty 2 - Empty 3 - Ant3 4 - Ant1 5 - Ant2\\n\\n        // So, we can clearly see that the affect of collision, is simply name changing and nothing more happens.\\n\\n        // So, the question now frames to fiding the maximum times taken by ants moving to right to find the time of falling and also to the left.\\n\\n        // Keeping tracks of maxLeft, minRight\\n\\n\\n        // maxLeft to find the maximum position i.e., to find the time taken by ants moving to the left\\n\\n        // minRight to find maximum position i.e., to find the time taken by ants moving to the right\\n\\n\\n        int maxLeft = INT_MIN;\\n        for(auto &l : left) maxLeft = max(maxLeft, l);\\n        int minRight = INT_MAX;\\n        for(auto &r : right) minRight = min(minRight, r);\\n        if(maxLeft == INT_MIN)\\n            return n - minRight;\\n        else if(minRight == INT_MAX)\\n            return maxLeft;\\n        else return max(n - minRight, maxLeft);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        // Intution\\n        // The idea in here is, if there is a collision then in place of right ant we will get left ant and in the place of left ant we will get right ant. But, the affect would be exactly same. Consider the example below\\n\\n        // Let n be 5\\n\\n        // There are three ants two going to right, and one coming to left\\n\\n        // Initial configuration\\n\\n        // 1 - Ant1 2 - Ant2 3 - Empty 4 - Empty 5 - Ant3\\n\\n        // After one second\\n\\n        // 1 - Empty 2 - Ant1 3 - Ant2 4 - Ant3 5 - Empty\\n\\n        // After two seconds\\n\\n        // 1 - Empty 2 - Empty 3 - Ant1 4 - (Ant2 -> Right, Ant3 -> Left) 5 - Empty\\n\\n        // One collision occured. So, now Ant2 -> Left, Ant3 -> Right\\n\\n        // 1 - Empty 2 - Empty 3 - Ant2 4 - Ant1 5 - Ant3\\n\\n        // If we assumed that collision won\\'t make any change then\\n\\n        // After two seconds collision affect will be\\n\\n        // 1 - Empty 2 - Empty 3 - Ant3 4 - Ant1 5 - Ant2\\n\\n        // So, we can clearly see that the affect of collision, is simply name changing and nothing more happens.\\n\\n        // So, the question now frames to fiding the maximum times taken by ants moving to right to find the time of falling and also to the left.\\n\\n        // Keeping tracks of maxLeft, minRight\\n\\n\\n        // maxLeft to find the maximum position i.e., to find the time taken by ants moving to the left\\n\\n        // minRight to find maximum position i.e., to find the time taken by ants moving to the right\\n\\n\\n        int maxLeft = INT_MIN;\\n        for(auto &l : left) maxLeft = max(maxLeft, l);\\n        int minRight = INT_MAX;\\n        for(auto &r : right) minRight = min(minRight, r);\\n        if(maxLeft == INT_MIN)\\n            return n - minRight;\\n        else if(minRight == INT_MAX)\\n            return maxLeft;\\n        else return max(n - minRight, maxLeft);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3253279,
                "title": "c-simple-brain-teaser-4-liner",
                "content": "```\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int ans = 0;\\n        if(left.size()!=0){\\n            for(auto iter : left){\\n                ans = max(ans,iter);\\n            }\\n        }\\n        if(right.size()!=0){\\n            for(auto iter : right){\\n                ans = max(ans,n-iter);\\n            }            \\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int ans = 0;\\n        if(left.size()!=0){\\n            for(auto iter : left){\\n                ans = max(ans,iter);\\n            }\\n        }\\n        if(right.size()!=0){\\n            for(auto iter : right){\\n                ans = max(ans,n-iter);\\n            }            \\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3181589,
                "title": "java-easy-to-understand",
                "content": "\\n```\\nclass Solution {\\n    public int getLastMoment(int n, int[] left, int[] right) {\\n        int LeftMax =0,RightMin=0;\\n        if(left.length!=0){\\n              LeftMax = left[0];\\n        }\\n        if(right.length!=0){\\n            RightMin = right[0];\\n        }\\n       \\n    // Take max of left Array    \\n        for(int i=0;i<left.length;i++){\\n            if(left[i]>LeftMax){\\n                LeftMax = left[i];\\n            }\\n        }\\n     // Take min of right Array    \\n        for(int j=0;j<right.length;j++){\\n             if(right[j]<RightMin){\\n                RightMin = right[j];\\n            }\\n        }\\n    // For Cases When Any Array is Empty\\n        if(left.length==0){\\n              return n-RightMin;\\n        } \\n        if(right.length==0){\\n            return LeftMax;\\n        }\\n\\n       return Math.max(LeftMax,n-RightMin);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getLastMoment(int n, int[] left, int[] right) {\\n        int LeftMax =0,RightMin=0;\\n        if(left.length!=0){\\n              LeftMax = left[0];\\n        }\\n        if(right.length!=0){\\n            RightMin = right[0];\\n        }\\n       \\n    // Take max of left Array    \\n        for(int i=0;i<left.length;i++){\\n            if(left[i]>LeftMax){\\n                LeftMax = left[i];\\n            }\\n        }\\n     // Take min of right Array    \\n        for(int j=0;j<right.length;j++){\\n             if(right[j]<RightMin){\\n                RightMin = right[j];\\n            }\\n        }\\n    // For Cases When Any Array is Empty\\n        if(left.length==0){\\n              return n-RightMin;\\n        } \\n        if(right.length==0){\\n            return LeftMax;\\n        }\\n\\n       return Math.max(LeftMax,n-RightMin);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3110906,
                "title": "c-22ms-solution-w-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this problem is to find the last moment when a group of ants will be on the same side of the board. This can be done by keeping track of the maximum value of the positions of the ants on the left side and the right side, respectively.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach to this problem is to iterate through the left and right ants and store the maximum value of each side. Then, we need to compare the maximum value of left and right side and return the maximum. \\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Efficiency\\nThis solution is relatively efficient, as it has a time complexity of O(n) and a space complexity of O(1). \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int ans = 0;\\n        for (int l : left) {\\n            ans = max(ans, l);\\n        }\\n        for (int r : right) {\\n            ans = max(ans, n - r);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int ans = 0;\\n        for (int l : left) {\\n            ans = max(ans, l);\\n        }\\n        for (int r : right) {\\n            ans = max(ans, n - r);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1494887,
                "title": "o-n-simple-solution-let-ants-don-t-change-direction-when-they-collide",
                "content": "### Just think for a while , does it really matter if ants change direction or not . It\\'s the same , isn\\'t it.\\n\\n```\\n int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        \\n        int time = 0;\\n        \\n        for(auto x:left)\\n        {\\n            time = max(x , time);\\n        }\\n\\n        for(auto x: right)\\n        {\\n            time = max(time , n-x);    \\n        }\\n        \\n        return time;\\n    }",
                "solutionTags": [],
                "code": "### Just think for a while , does it really matter if ants change direction or not . It\\'s the same , isn\\'t it.\\n\\n```\\n int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        \\n        int time = 0;\\n        \\n        for(auto x:left)\\n        {\\n            time = max(x , time);\\n        }\\n\\n        for(auto x: right)\\n        {\\n            time = max(time , n-x);    \\n        }\\n        \\n        return time;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1403582,
                "title": "easy-one-liner-python-explanation",
                "content": "The trick is here that when two ants meets and change their direction, it will not affect the number or ants going left and right. So basically, ant\\'s intersection does not change anything, so we just need to find time the last ant spend to fall.\\n\\n```\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        return max(max(left+[0]), n-min(right+[n]))\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        return max(max(left+[0]), n-min(right+[n]))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1066733,
                "title": "95-faster-c-code",
                "content": "HINTS given in question -:The ants change their way when they meet is equivalent to continue moving without changing their direction.\\nAnswer is the max distance for one ant to reach the end of the plank in the facing direction.\\n```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        if(left.size()==0)\\n        {\\n            return n-*min_element(right.begin(),right.end());\\n        }\\n        if(right.size()==0)\\n        {\\n            return *max_element(left.begin(),left.end());\\n        }\\n        int left_num = *max_element(left.begin(),left.end());\\n        int right_num = n-*min_element(right.begin(),right.end());\\n        return max(left_num,right_num);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        if(left.size()==0)\\n        {\\n            return n-*min_element(right.begin(),right.end());\\n        }\\n        if(right.size()==0)\\n        {\\n            return *max_element(left.begin(),left.end());\\n        }\\n        int left_num = *max_element(left.begin(),left.end());\\n        int right_num = n-*min_element(right.begin(),right.end());\\n        return max(left_num,right_num);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 736194,
                "title": "java-video-solution",
                "content": "https://www.youtube.com/watch?v=hdatacorX7c&feature=youtu.be",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=hdatacorX7c&feature=youtu.be",
                "codeTag": "Unknown"
            },
            {
                "id": 720688,
                "title": "javascript-easy-to-understand-2-solutions",
                "content": "## SOLUTION 1\\n\\nIn this solution, we try to just follow the rules and find the answer.\\n\\nWe do a loop until there are no ants on the plank. In the loop, we follow the rules to move the ants toward or backward. Here are the detail:\\n\\n- I use 2 mask value to determine left and right. So I just need an int8 value to represent the state of a grid.\\n- If there are ants at the edge of the plank and move toward the outside, then we need to move them out and refresh the count.\\n- For other ants, we move them ahead according to their direction. For example, for an ant that is moving to the right, then we clean the mask value for the current grid and add it to the right grid.\\n\\nFinally, we get the answer. But I must say, this strategy is tooooo slow for this problem.\\n\\n```js\\nconst getLastMoment = (n, left, right) => {\\n  const LEFT = 2 ** 0;\\n  const RIGHT = 2 ** 1;\\n  const plank = new Uint8Array(n + 1);\\n  for (const val of left) plank[val] ^= LEFT;\\n  for (const val of right) plank[val] ^= RIGHT;\\n  let t = -1;\\n  let ants = left.length + right.length;\\n  while (ants > 0) {\\n    if (plank[0] & LEFT) { plank[0] ^= LEFT; --ants; }\\n    if (plank[n] & RIGHT) { plank[n] ^= RIGHT; --ants; }\\n    for (let i = 1; i <= n; ++i) {\\n      if (plank[i] & LEFT) { plank[i - 1] ^= LEFT; plank[i] ^= LEFT; }\\n      if (plank[n - i] & RIGHT) { plank[n - i + 1] ^= RIGHT; plank[n - i] ^= RIGHT; }\\n    }\\n    ++t;\\n  }\\n  return t;\\n};\\n```\\n\\n## SOLUTION 2\\n\\nThis may be a common solution to this problem.\\n\\nLet\\'s see, if two ants meet, what will we have before they meet and after they meet?\\nActually, before they meet, there are two ants, one goes to the right, another goes to the left. And after they meet, there still two ants, one goes to the right, another goes to the left.\\n\\nWe don\\'t care about which ant is which. We just need to know the time for the final ant leave the plank.\\n\\nSo, for us, we could imagine that nothing will happen for two ants meet. They just go ahead until fall from the plank.\\n\\nAccording to this, we just need to know the distance for the farthest ant. Then that\\'s the answer.\\n\\n```js\\nconst getLastMoment = (n, left, right) => {\\n  let max = 0;\\n  for (const val of left) {\\n    val > max && (max = val);\\n  }\\n  for (const val of right) {\\n    n - val > max && (max = n - val);\\n  }\\n  return max;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst getLastMoment = (n, left, right) => {\\n  const LEFT = 2 ** 0;\\n  const RIGHT = 2 ** 1;\\n  const plank = new Uint8Array(n + 1);\\n  for (const val of left) plank[val] ^= LEFT;\\n  for (const val of right) plank[val] ^= RIGHT;\\n  let t = -1;\\n  let ants = left.length + right.length;\\n  while (ants > 0) {\\n    if (plank[0] & LEFT) { plank[0] ^= LEFT; --ants; }\\n    if (plank[n] & RIGHT) { plank[n] ^= RIGHT; --ants; }\\n    for (let i = 1; i <= n; ++i) {\\n      if (plank[i] & LEFT) { plank[i - 1] ^= LEFT; plank[i] ^= LEFT; }\\n      if (plank[n - i] & RIGHT) { plank[n - i + 1] ^= RIGHT; plank[n - i] ^= RIGHT; }\\n    }\\n    ++t;\\n  }\\n  return t;\\n};\\n```\n```js\\nconst getLastMoment = (n, left, right) => {\\n  let max = 0;\\n  for (const val of left) {\\n    val > max && (max = val);\\n  }\\n  for (const val of right) {\\n    n - val > max && (max = n - val);\\n  }\\n  return max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 720385,
                "title": "simple-trick-for-dumbs-like-me",
                "content": "After reading this question, I thought of maintaining sorted set for left and right arrays, find \\'time\\' when greatest value of right array will collide with smallest value of left. After some time though, I could figure out that we don\\'t need to maintain all this info. \\n\\nAssume this: When left ant hits right ant, both of them change direction - BUT THEY STILL TRAVEL WITH SAME SPEED! Thus we can say left ant became \\'right moving ant\\' and vice versa. Following is simple implementaion of this idea.\\nNote: We can think about that plank as a two-way street. So, find the maximum units that any ant needs to travel.\\n\\n```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int leftGreater = 0;\\n        for(auto leftVal: left) {\\n            leftGreater = max(leftGreater, leftVal);\\n        }\\n        int rightSmall = n;\\n        for(auto rightVal: right) {\\n            rightSmall = min(rightVal, rightSmall);\\n        }\\n        return max(leftGreater, n-rightSmall);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int leftGreater = 0;\\n        for(auto leftVal: left) {\\n            leftGreater = max(leftGreater, leftVal);\\n        }\\n        int rightSmall = n;\\n        for(auto rightVal: right) {\\n            rightSmall = min(rightVal, rightSmall);\\n        }\\n        return max(leftGreater, n-rightSmall);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720183,
                "title": "c-easy-to-understand-o-n",
                "content": "```\\nint getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int  ans = 0;\\n        for (auto& x : left)\\n            ans = max(ans, x);\\n        for (auto& x : right)\\n            ans = max(ans, n - x);\\n        \\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "```\\nint getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int  ans = 0;\\n        for (auto& x : left)\\n            ans = max(ans, x);\\n        for (auto& x : right)\\n            ans = max(ans, n - x);\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 720169,
                "title": "very-simple-java-solution",
                "content": "Because all ants will eventually reach one another and move the other direction, the equation is just `Math.max(n-right[0], left[left.length-1]);`.\\n\\n```\\nclass Solution {\\n    public int getLastMoment(int n, int[] left, int[] right) {\\n        Arrays.sort(left);\\n        Arrays.sort(right);\\n        if(left.length == 0) return n-right[0];\\n        if(right.length == 0) return left[left.length-1];\\n        return Math.max(n-right[0], left[left.length-1]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int getLastMoment(int n, int[] left, int[] right) {\\n        Arrays.sort(left);\\n        Arrays.sort(right);\\n        if(left.length == 0) return n-right[0];\\n        if(right.length == 0) return left[left.length-1];\\n        return Math.max(n-right[0], left[left.length-1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720145,
                "title": "python-easy-solution",
                "content": "Main idea : if two ants meet and change direction, both ants continue on the other ant\\'s path.  So the meeting event can just be ignored. We only need to calculate when the last ant fall in the original case. \\n```\\ndef getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        ret = 0\\n        if left:\\n            ret = max(ret, max(left))\\n        if right:\\n            ret = max(ret, n-min(right))\\n        return ret\\n```",
                "solutionTags": [],
                "code": "```\\ndef getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        ret = 0\\n        if left:\\n            ret = max(ret, max(left))\\n        if right:\\n            ret = max(ret, n-min(right))\\n        return ret\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 720139,
                "title": "java-solution-o-n",
                "content": "```\\nclass Solution {\\n    public int getLastMoment(int n, int[] left, int[] right) {\\n        int max = 0;\\n        for(int i = 0 ;i<right.length ;i++)\\n            max = Math.max(max , n-right[i]);\\n        for(int i = 0 ;i<left.length ; i++)\\n            max = Math.max(max , left[i]);\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int getLastMoment(int n, int[] left, int[] right) {\\n        int max = 0;\\n        for(int i = 0 ;i<right.length ;i++)\\n            max = Math.max(max , n-right[i]);\\n        for(int i = 0 ;i<left.length ; i++)\\n            max = Math.max(max , left[i]);\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720108,
                "title": "python3-straight-forward-easy-solution",
                "content": "This took me an hour to figure out lol.\\n\\n```\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        \\n        if not right:\\n            return max(left)\\n        if not left:\\n            return n - min(right)\\n        \\n        l = max(left)\\n        r = n - min(right)\\n        \\n        return max(l,r)\\n                        \\n                        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        \\n        if not right:\\n            return max(left)\\n        if not left:\\n            return n - min(right)\\n        \\n        l = max(left)\\n        r = n - min(right)\\n        \\n        return max(l,r)\\n                        \\n                        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 720098,
                "title": "c-easy-solution",
                "content": "We only need to consider the position of the leftmost ant that move right and the rightmost ant which move left.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& L, vector<int>& R) {\\n        \\n        sort(L.begin(), L.end());\\n        sort(R.begin(), R.end());\\n        \\n        if(L.size() == 0 && R.size() != 0){ \\n            return n-R[0];\\n        }\\n        \\n        if(L.size() != 0 && R.size() == 0){\\n            return L[L.size()-1];\\n        }\\n\\n        return max(L[L.size()-1] , n-R[0]);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& L, vector<int>& R) {\\n        \\n        sort(L.begin(), L.end());\\n        sort(R.begin(), R.end());\\n        \\n        if(L.size() == 0 && R.size() != 0){ \\n            return n-R[0];\\n        }\\n        \\n        if(L.size() != 0 && R.size() == 0){\\n            return L[L.size()-1];\\n        }\\n\\n        return max(L[L.size()-1] , n-R[0]);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3110833,
                "title": "python3-solution-fast-runtime-oneline",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe goal of this problem is to find the last moment when any of the ants are still on the line. This can be done by looking at the leftmost ant\\'s position and the rightmost ant\\'s position. The answer will be whichever of these two is greater.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo solve this problem, we will use a two-pass approach. In the first pass, we will find the maximum position of any of the ants in the left array. In the second pass, we will find the minimum position of any of the ants in the right array. Finally, we will compare these two values and return the greater of the two. \\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        return max(max(left, default=0), n - min(right, default=n))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        return max(max(left, default=0), n - min(right, default=n))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108979,
                "title": "python-one-liner-easy",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. The function takes in two parameters: n and two lists left and right representing the positions of ants on the left and right ends of the plank respectively.\\n2. We use the max() function to find the maximum value of the last ant on the left side, and the minimum value of the last ant on the right side.\\n3. The value of n - min(right or [n]) represents the last ant on the right side, where we subtract its position from the length of the plank.\\n4. Finally, we return the maximum value of the last ant on the left and right sides.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity : $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        return max(max(left or [0]), n - min(right or [n]))\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Brainteaser",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        return max(max(left or [0]), n - min(right or [n]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2688642,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n     int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int maxLeft = left.empty() ? 0 : *max_element(left.begin(), left.end());\\n         int minRight = right.empty() ? n : *min_element(right.begin(), right.end());\\n        return max(maxLeft, n - minRight);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int maxLeft = left.empty() ? 0 : *max_element(left.begin(), left.end());\\n         int minRight = right.empty() ? n : *min_element(right.begin(), right.end());\\n        return max(maxLeft, n - minRight);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2470170,
                "title": "easy-python",
                "content": "```\\n def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        if len(right) == 0:\\n            right.append(n)\\n        \\n        if len(left) == 0:\\n            left.append(0)\\n            \\n        return max((n-min(right)), max(left))",
                "solutionTags": [],
                "code": "```\\n def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        if len(right) == 0:\\n            right.append(n)\\n        \\n        if len(left) == 0:\\n            left.append(0)\\n            \\n        return max((n-min(right)), max(left))",
                "codeTag": "Python3"
            },
            {
                "id": 2087298,
                "title": "python-pretend-all-ants-are-ghosts",
                "content": "When two ants collide and change directions, since changing directions does not take any additional time, we might as well pretend that the ants walked **through** each other as if they were ghosts \\uD83D\\uDC7B.\\n\\nThus, the time it will take for all ants to fall off will be equal the farthest distance an ant would have to walk if it was alone on the plank.\\n&#8718;\\n\\n```\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n\\t\\t# make sure left and right are not empty without changing the answer\\n        left.append(0)\\n        right.append(n)        \\n        \\n        return max(max(left), n - min(right))\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n\\t\\t# make sure left and right are not empty without changing the answer\\n        left.append(0)\\n        right.append(n)        \\n        \\n        return max(max(left), n - min(right))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1952906,
                "title": "c-one-liner-with-explanation",
                "content": "Idea is to understand that changing direction does not change anything, the ants keep walking the normal way.\\nThe problem is almost done now, we just have to see which ant is farthest from falling off the table,\\nit can be rightmost ant going left or leftmost ant going right.\\n\\n1-liner Code:\\n```\\n    int getLastMoment(int n, vector<int>& L, vector<int>& R){\\n        return max((L.size())?*max_element(L.begin(),L.end()):0,n-((R.size())?*min_element(R.begin(),R.end()):n));\\n    }\\n```\\n",
                "solutionTags": [
                    "Math",
                    "Greedy"
                ],
                "code": "```\\n    int getLastMoment(int n, vector<int>& L, vector<int>& R){\\n        return max((L.size())?*max_element(L.begin(),L.end()):0,n-((R.size())?*min_element(R.begin(),R.end()):n));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1795720,
                "title": "simple-java-solution",
                "content": "class Solution {\\n    \\n\\tpublic int getLastMoment(int n, int[] left, int[] right) {\\n        int leftMax = left.length > 0 ? Arrays.stream(left).max().getAsInt() : 0,\\n            rightMin = right.length > 0 ? Arrays.stream(right).min().getAsInt() : n;\\n        \\n        return Math.max(n - rightMin, leftMax);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n\\tpublic int getLastMoment(int n, int[] left, int[] right) {\\n        int leftMax = left.length > 0 ? Arrays.stream(left).max().getAsInt() : 0,\\n            rightMin = right.length > 0 ? Arrays.stream(right).min().getAsInt() : n;\\n        \\n        return Math.max(n - rightMin, leftMax);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1789220,
                "title": "c-easy-solution-tricky",
                "content": "\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tfor(auto &it: left){\\n\\t\\t\\t\\t//maximum time taken to reach 0th position while moving in left direction\\n\\t\\t\\t\\tans=max(ans,it-0); \\n\\t\\t\\t}\\n\\t\\t\\tfor(auto &it: right){\\n\\t\\t\\t\\t//maximum time taken to reach nth position while moving in right direction\\n\\t\\t\\t\\t ans=max(ans,n-it);\\n\\t\\t\\t}\\n\\t\\t\\t//ans is what maximum of all ants time taken to reach respective end \\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tfor(auto &it: left){\\n\\t\\t\\t\\t//maximum time taken to reach 0th position while moving in left direction\\n\\t\\t\\t\\tans=max(ans,it-0); \\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1772227,
                "title": "c-tricky-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) \\n    {\\n       int ans=  0;\\n        for(auto it: left)\\n        {\\n            ans=  max(ans, it);\\n        }\\n        for (auto it: right)\\n        {\\n            ans=  max(ans,n-it);\\n          }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) \\n    {\\n       int ans=  0;\\n        for(auto it: left)\\n        {\\n            ans=  max(ans, it);\\n        }\\n        for (auto it: right)\\n        {\\n            ans=  max(ans,n-it);\\n          }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1645221,
                "title": "c",
                "content": "Main observation is that the ants will collide and change direction is same as the case in which ants walked through each other because they have same speeds and we do not have anything specific to ant in this problem as we just want the last moment when any ant leaves the plank.  \\n\\n```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int mx = 0;\\n\\t\\t\\n        for(auto x: right)\\n            mx = max(mx, n-x);\\n      \\n        for(auto x: left)\\n            mx = max(mx, x);\\n        \\n        return mx;\\n    }\\n    \\n};\\n```\\n\\nLink to a very similar problem:\\nhttps://www.codechef.com/JAN21B/problems/ANTSCHEF",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int mx = 0;\\n\\t\\t\\n        for(auto x: right)\\n            mx = max(mx, n-x);\\n      \\n        for(auto x: left)\\n            mx = max(mx, x);\\n        \\n        return mx;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599713,
                "title": "java-simple-solution-1ms",
                "content": "```\\nclass Solution {\\n    public int getLastMoment(int n, int[] left, int[] right) {\\n        int max_time = 0;\\n        \\n        for(int i: left)\\n            max_time = Math.max(max_time, i);\\n        \\n        for(int i: right)\\n            max_time = Math.max(max_time, n-i);\\n        \\n        return max_time;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getLastMoment(int n, int[] left, int[] right) {\\n        int max_time = 0;\\n        \\n        for(int i: left)\\n            max_time = Math.max(max_time, i);\\n        \\n        for(int i: right)\\n            max_time = Math.max(max_time, n-i);\\n        \\n        return max_time;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1453347,
                "title": "nobody-thought-of-stacks",
                "content": "I tried to simulate the whole thing using stacks thinking this was just an ad-hoc. Pretty bummed that there is no `stack` tag in the discuss tab.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1172001,
                "title": "java-simple-4-liner-in-o-1-space-o-n-time",
                "content": "```\\nclass Solution {\\n    public int getLastMoment(int n, int[] left, int[] right) {\\n        int r = 0, l = 0;\\n        for (int i : right) r = Math.max(r, n-i);\\n        for (int i : left)  l = Math.max(l, i);\\n        return Math.max(r, l);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int getLastMoment(int n, int[] left, int[] right) {\\n        int r = 0, l = 0;\\n        for (int i : right) r = Math.max(r, n-i);\\n        for (int i : left)  l = Math.max(l, i);\\n        return Math.max(r, l);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 830277,
                "title": "my-java-and-python-solution-with-the-brief-explanation",
                "content": "Brief explanation:\\nFind the distance of the ant going in the left direction which is farthest from the left end of the plank.\\nFind the distance of the ant going in the right direction which is farthest from the right end of the plank. (Note here we need to consider min(right))\\nMax of the above two is the answer.\\n\\n```\\nJava.\\nclass Solution {\\n    public int getLastMoment(int n, int[] left, int[] right) {\\n        int totalDistanceLeft;\\n        int totalDistanceRight;\\n        if (left.length == 0)\\n            totalDistanceLeft = 0;\\n        else \\n            totalDistanceLeft = Arrays.stream(left).max().getAsInt();\\n        if (right.length == 0)\\n            totalDistanceRight = n;\\n        else \\n            totalDistanceRight = Arrays.stream(right).min().getAsInt();\\n        return Math.max(totalDistanceLeft, n-totalDistanceRight);\\n        \\n    }\\n}\\n```\\n\\n```\\nPython\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        if len(left) == 0:\\n            totalDistanceLeft = 0\\n        else:\\n            totalDistanceLeft = max(left)\\n        if len(right) == 0:\\n            totalDistanceRight = n\\n        else:\\n            totalDistanceRight = min(right)\\n        return max(totalDistanceLeft-0, n-totalDistanceRight)\\n```",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```\\nJava.\\nclass Solution {\\n    public int getLastMoment(int n, int[] left, int[] right) {\\n        int totalDistanceLeft;\\n        int totalDistanceRight;\\n        if (left.length == 0)\\n            totalDistanceLeft = 0;\\n        else \\n            totalDistanceLeft = Arrays.stream(left).max().getAsInt();\\n        if (right.length == 0)\\n            totalDistanceRight = n;\\n        else \\n            totalDistanceRight = Arrays.stream(right).min().getAsInt();\\n        return Math.max(totalDistanceLeft, n-totalDistanceRight);\\n        \\n    }\\n}\\n```\n```\\nPython\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        if len(left) == 0:\\n            totalDistanceLeft = 0\\n        else:\\n            totalDistanceLeft = max(left)\\n        if len(right) == 0:\\n            totalDistanceRight = n\\n        else:\\n            totalDistanceRight = min(right)\\n        return max(totalDistanceLeft-0, n-totalDistanceRight)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 760514,
                "title": "cpp-triky-solution-with-o-n",
                "content": "```\\nidea: draw an picture of several ants, you can find that last moment of the ants fall out,  is the maxinum num of distance towards left and towards right.  Since each ant has the same speed.\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int result = 0;\\n        for (int num : left) result = max(result, num);\\n        for (int num : right) result = max(result, n - num);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nidea: draw an picture of several ants, you can find that last moment of the ants fall out,  is the maxinum num of distance towards left and towards right.  Since each ant has the same speed.\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int result = 0;\\n        for (int num : left) result = max(result, num);\\n        for (int num : right) result = max(result, n - num);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 726835,
                "title": "rust-1-line",
                "content": "\\n```\\nimpl Solution {\\n    pub fn get_last_moment(n: i32, left: Vec<i32>, right: Vec<i32>) -> i32 {\\n        left.into_iter().chain(right.into_iter().map(|x| n - x)).max().unwrap()\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn get_last_moment(n: i32, left: Vec<i32>, right: Vec<i32>) -> i32 {\\n        left.into_iter().chain(right.into_iter().map(|x| n - x)).max().unwrap()\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 721691,
                "title": "python-brute-force-vs-optimized-logic-easy-to-understand",
                "content": "1. **Brute Force Approach(TLE)**\\n\\n```\\ndef getLastMoment(self, n: int, l: List[int], r: List[int]) -> int:\\n        t = 0\\n        i = 0\\n        while(i<len(l)):\\n            if l[i]<=0:\\n                l.pop(i)\\n            else:\\n                i = i + 1\\n        j = 0\\n        while(j<len(r)):\\n            if r[j]>=n:\\n                r.pop(j)\\n            else:\\n                j = j + 1\\n        while(l or r):\\n            if l:\\n                i = 0\\n                while(i<len(l)):\\n                    l[i] = l[i] - 1\\n                    if l[i]<=0:\\n                        l.pop(i)\\n                    else:\\n                        i = i + 1\\n            if r:\\n                j = 0\\n                while(j<len(r)):\\n                    r[j] = r[j] + 1\\n                    if r[j]>=n:\\n                        r.pop(j)\\n                    else:\\n                        j = j + 1\\n            t = t + 1\\n        return t\\n```\\n\\n2. **Optimized logic**\\n```\\ndef getLastMoment(self, n: int, l: List[int], r: List[int]) -> int:\\n        if l and r:\\n            return max(n-min(r),max(l))\\n        if l:\\n            return max(l)\\n        if r:\\n            return n-min(r)\\n```\\n",
                "solutionTags": [],
                "code": "```\\ndef getLastMoment(self, n: int, l: List[int], r: List[int]) -> int:\\n        t = 0\\n        i = 0\\n        while(i<len(l)):\\n            if l[i]<=0:\\n                l.pop(i)\\n            else:\\n                i = i + 1\\n        j = 0\\n        while(j<len(r)):\\n            if r[j]>=n:\\n                r.pop(j)\\n            else:\\n                j = j + 1\\n        while(l or r):\\n            if l:\\n                i = 0\\n                while(i<len(l)):\\n                    l[i] = l[i] - 1\\n                    if l[i]<=0:\\n                        l.pop(i)\\n                    else:\\n                        i = i + 1\\n            if r:\\n                j = 0\\n                while(j<len(r)):\\n                    r[j] = r[j] + 1\\n                    if r[j]>=n:\\n                        r.pop(j)\\n                    else:\\n                        j = j + 1\\n            t = t + 1\\n        return t\\n```\n```\\ndef getLastMoment(self, n: int, l: List[int], r: List[int]) -> int:\\n        if l and r:\\n            return max(n-min(r),max(l))\\n        if l:\\n            return max(l)\\n        if r:\\n            return n-min(r)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 721513,
                "title": "just-elaborate-produce-a-visual-on-lee215-s-solution-then-this-problem-became-surprisingly-easy",
                "content": "This solution is inspired by beloved @lee215. He points out a single thing that confuses me during the contest.\\n\\nI just want to elaborate on his solution. All the credit goes to him. His solution is here:\\nhttps://leetcode.com/problems/last-moment-before-all-ants-fall-out-of-a-plank/discuss/720189/JavaC%2B%2BPython-Ants-Keep-Walking-O(N)\\n\\n\\nThe difficult part is to keep track of the time and location of each ant.  In that case, we could have just do real time simulation. \\n\\n### No, we are not doing a simulation here. \\n\\nLet\\'s take a look some examples.\\n\\nCase 1: single ant heading to the right.\\n\\n|   |  ant->   |   |   |   |   |   |   |   |\\n|---|---|---|---|---|---|---|---|---|\\n|  0 |  1  | 2  | 3  | 4  | 5  | 6  | 7  | 8  |\\n\\nIt will take 8 - 1 = 7 seconds\\n\\nCase 2: two ants heading into opposite direction. A is heading to the right and B is heading to left\\n\\n|   |  A->   |   |   |   |   |   | <-B  |   |\\n|---|---|---|---|---|---|---|---|---|\\n|  0 |  1  | 2  | 3  | 4  | 5  | 6  | 7  | 8  |\\n\\n3 seconds later, two ants meet.\\n|   |     |   |   |   |   |   |   |   |\\n|---|---|---|---|---|---|---|---|---|\\n|   |     |   |   | A |   |   |   |   |\\n|   |     |   |   | B  |   |   |   |   |\\n|  0 |  1  | 2  | 3  | 4  | 5  | 6  | 7  | 8  |\\n\\nTwo ways to see what happen after the meet. \\n\\n### We need both of these two ways of thinking to formalize a clean solution.\\n\\n\\n- Natural way of thinking: A heads back right after. Same goes B\\n\\n|   |     |   |   |   |   |   |   |   |\\n|---|---|---|---|---|---|---|---|---|\\n|   |     |   |   | <-A |   |   |   |   |\\n|   |     |   |   | B->  |   |   |   |   |\\n|  0 |  1  | 2  | 3  | 4  | 5  | 6  | 7  | 8  |\\n\\n- Another way of thinking: Let\\'s say A and B not only meet, they pass through each other, like both of them are completely transparent. Then A without changing its direction, keep moving at the direction where B is heading after the meet, which is moving to the right. \\nConclusion: A didn\\'t change its course. \\nAnother Conclusion: B didn\\'t change its course, either.\\n\\nFor A to leave the plank, we need to know its heading direction and initial starting position\\n\\nWhoever leave the plank last will be the last moment\\n```\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        \\n        maxLeft = -float(\\'inf\\')\\n        maxRight = -float(\\'inf\\')\\n        \\n\\t\\t# this code block: all the ants heading to the left\\n\\t\\t# from input array left, we know max(left) wil be the last moment for all ants heading to the left\\n        if not left:\\n            maxLeft = 0\\n        else:\\n            maxLeft = max(left)\\n        \\n\\t\\t# this code block: all the ants heading to the right\\n\\t\\t# min(right) will be the last moment for all ants heading to the right\\n        if not right:\\n            maxRight = 0\\n        else:\\n            maxRight = n - min(right)\\n         \\n\\t\\t# left and right compare\\n        return max(maxLeft, maxRight)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        \\n        maxLeft = -float(\\'inf\\')\\n        maxRight = -float(\\'inf\\')\\n        \\n\\t\\t# this code block: all the ants heading to the left\\n\\t\\t# from input array left, we know max(left) wil be the last moment for all ants heading to the left\\n        if not left:\\n            maxLeft = 0\\n        else:\\n            maxLeft = max(left)\\n        \\n\\t\\t# this code block: all the ants heading to the right\\n\\t\\t# min(right) will be the last moment for all ants heading to the right\\n        if not right:\\n            maxRight = 0\\n        else:\\n            maxRight = n - min(right)\\n         \\n\\t\\t# left and right compare\\n        return max(maxLeft, maxRight)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720549,
                "title": "easy-java-solution-with-explaination",
                "content": "// In this first we will sort both the arrays\\n\\n**Condition 1: If the length of the Both the arrays is 0 then we will return 0;\\nCondition 2: If left array is zero, then we will return  n-right[0]\\nCondition 3: if right array is zero , then we will return left[left.length-1]\\ncondition 4:Store distance from left and right in separate variables\\n**\\n**Formula for left p=left[left.length-1]\\nFormula for right q= n - right[0]\\nThen whichever variable has larger value return that value**\\n\\n**solution:**\\n\\nclass Solution {\\n    public int getLastMoment(int n, int[] left, int[] right) {\\n     Arrays.sort(left); \\n        Arrays.sort(right);\\n        if(left.length==0 && right.length==0)\\n            return 0;\\n        if(left.length==0)\\n        {\\n          return n-right[0];\\n        }\\n        else if(right.length==0)\\n            return left[left.length-1];\\n        int p=left[left.length-1];\\n        int q=n-right[0];\\n        if(p>q)\\n            return p;\\n        return q;\\n    }\\n}\\n\\n**If You find my Solution Useful, then Do Upvote it!!**\\n\\n",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "class Solution {\\n    public int getLastMoment(int n, int[] left, int[] right) {\\n     Arrays.sort(left); \\n        Arrays.sort(right);\\n        if(left.length==0 && right.length==0)\\n            return 0;\\n        if(left.length==0)\\n        {\\n          return n-right[0];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 720371,
                "title": "simple-java-o-n",
                "content": "```\\nclass Solution {\\n    public int getLastMoment(int n, int[] left, int[] right) {\\n        int max=Integer.MIN_VALUE;\\n        for(int i:left){\\n            if(max<i)max=i;\\n        }\\n        int min=Integer.MAX_VALUE;\\n        for(int i:right){\\n            if(min>i)min=i;\\n        }\\n        System.out.println(min+\" \"+max);\\n        \\n        return Math.max(max,n-min);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int getLastMoment(int n, int[] left, int[] right) {\\n        int max=Integer.MIN_VALUE;\\n        for(int i:left){\\n            if(max<i)max=i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 720357,
                "title": "100-100-fatest-and-most-efficient-simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int a=0,b=0;\\n        if(left.size()!=0)\\n            a= *max_element(left.begin(), left.end()); \\n        if(right.size()!=0){\\n            b= *min_element(right.begin(), right.end());\\n            b=n-b;\\n        } \\n        \\n        if(a>b) return a;\\n        return b;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int a=0,b=0;\\n        if(left.size()!=0)\\n            a= *max_element(left.begin(), left.end()); \\n        if(right.size()!=0){\\n            b= *min_element(right.begin(), right.end());\\n            b=n-b;\\n        } \\n        \\n        if(a>b) return a;\\n        return b;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720255,
                "title": "javascript-beats-100-runtime",
                "content": "Detail Explaination: https://youtu.be/Zq1llZdFu0A?t=2\\n```\\n/**\\n * @param {number} n\\n * @param {number[]} left\\n * @param {number[]} right\\n * @return {number}\\n */\\nvar getLastMoment = function(n, left, right) {\\n    let max = 0\\n    for(let ele of left){\\n        max = Math.max(ele,max)\\n    }\\n    for(let ele of right){\\n        max = Math.max(n-ele,max)\\n    }\\n    return max\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[]} left\\n * @param {number[]} right\\n * @return {number}\\n */\\nvar getLastMoment = function(n, left, right) {\\n    let max = 0\\n    for(let ele of left){\\n        max = Math.max(ele,max)\\n    }\\n    for(let ele of right){\\n        max = Math.max(n-ele,max)\\n    }\\n    return max\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 720228,
                "title": "collisions-dont-affect-the-total-time",
                "content": "Even if two ants collide, ants conitnue to move .\\nConsider n=4\\nFor example there are two ants at say: 1-> moving right and 3->moving left\\nThey collide at 2,but the number of max steps they move to end remains same\\nNow ant 2 takes 2 units and ant 1 takes 1 unit-combining 3 units of time\\nFor example we assume no collision ant2 moving left takes 3 units of time to fall\\nSo collisions does not affect total time.\\nThis makes the total time all ants fall as\\nMaximum time taken by ant moving left to reach 0 and ant moving right to reach n\\n\\n\\n\\n```\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        if not left and not right:\\n            return 0\\n        if not left:\\n            return n-min(right)\\n        if not right:\\n            return max(left)        \\n        return max(n-min(right), max(left))\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        if not left and not right:\\n            return 0\\n        if not left:\\n            return n-min(right)\\n        if not right:\\n            return max(left)        \\n        return max(n-min(right), max(left))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 720202,
                "title": "python-python3-last-moment-before-all-ants-fall-out-of-a-plank",
                "content": "The key here is realising that ```colliding and reversing``` is same as ``dodging`` the coming ant and moving forward as it is.\\n**Alternate Explanation:**\\n1. Every ant has a different message to send to the other side. \\n2. So they take their respective messages and leave their home for target. ```0``` is target for ants delivering messages in the ```right``` array and ```n``` is the target for ants delivering messages in the ```left``` array. \\n3. We are given the co-ordinates of the ants that are moving towards left and right. Those would be the starting point for the messages and the ending point for the ants in the ```left``` array will be ```0``` and for the ants in ```right``` will ne ```n```.\\n4. Whenever they collide with an ant , they exchange the messages to be delivered to the other side and the ants colliding change their direction, going back to where they came from. (Provided here we assume that this happens only once. After once they have exchanged the messages they do not collide again with the incoming ant from its side.)\\n5. If you think this way then, count the time when the last message will reach its destination.\\n\\n\\n```\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        if left and not right:\\n            return max(left)\\n        if not left and right:\\n            return n - min(right)\\n        if not left and not right:\\n            return 0\\n        if left and right:\\n            return max(max(left), n - min(right))\\n```\\n\\nIt doesn\\'t need to be this complex, it can be written in one line which I didn\\'t know. Python has so many functions and attributes that you don\\'t know it all. You know them my seeing at someone\\'s solution. So here is the one-liner.\\n```\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        return max(max(left,default=0), n - min(right, default=n))\\n```\\n\\nFor both the solutions:\\nTime Complexity: ```O(n)```\\nSpace Compleity: ```O(1)```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```colliding and reversing```\n```0```\n```right```\n```n```\n```left```\n```left```\n```0```\n```right```\n```n```\n```\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        if left and not right:\\n            return max(left)\\n        if not left and right:\\n            return n - min(right)\\n        if not left and not right:\\n            return 0\\n        if left and right:\\n            return max(max(left), n - min(right))\\n```\n```\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        return max(max(left,default=0), n - min(right, default=n))\\n```\n```O(n)```\n```O(1)```",
                "codeTag": "Java"
            },
            {
                "id": 720174,
                "title": "c-o-n-solution-collides-or-not-doesn-t-matter-the-id-of-the-ant-is-not-important",
                "content": "Even if 2 ants collide (1 head to right, 1 head to left), the direction of those 2 ants don\\'t change\\n(still 1 head to left, 1 head to right). Because the id of the ant doesn\\'t matter.\\n->2 ants collide are same as 2 ants pass each other\\n```\\nclass Solution \\n{\\n    public:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) \\n    {\\n        int maximum=0;\\n        for(int i=0;i<left.size();i++)\\n        {\\n            maximum=max(maximum,left[i]);\\n        }\\n        for(int i=0;i<right.size();i++)\\n        {\\n            maximum=max(maximum,n-right[i]);\\n        }\\n        return maximum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) \\n    {\\n        int maximum=0;\\n        for(int i=0;i<left.size();i++)\\n        {\\n            maximum=max(maximum,left[i]);\\n        }\\n        for(int i=0;i<right.size();i++)\\n        {\\n            maximum=max(maximum,n-right[i]);\\n        }\\n        return maximum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720161,
                "title": "c-very-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int res = 0;\\n        for (int i = 0; i < left.size(); i++)\\n            res = max(res, left[i]);\\n        for (int i = 0; i < right.size(); i++)\\n            res = max(res, n - right[i]);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int res = 0;\\n        for (int i = 0; i < left.size(); i++)\\n            res = max(res, left[i]);\\n        for (int i = 0; i < right.size(); i++)\\n            res = max(res, n - right[i]);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720128,
                "title": "easy-to-understand-c-approach",
                "content": "class Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n\\t\\n        int l, r;\\n        if(!left.empty())\\n        {\\n            sort(left.begin(), left.end()); //sorting all so that we can get the right most ant as it will take the max time among them.\\n            l = left[left.size()-1];\\n        }\\n        else\\n        {\\n            l = 0; // if no left going ant\\n        }\\n        \\n        if(!right.empty())\\n        {\\n            sort(right.begin(), right.end());//sorting all so that we can get the left most ant as it will take the max time among them.\\n            r = right[0];\\n        }\\n        else\\n            r = n;//if no right going ant\\n\\n        return max(l-0, n-r); //calculating left most or right most ant will take the longest time to get over the log.\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n\\t\\n        int l, r;\\n        if(!left.empty())\\n        {\\n            sort(left.begin(), left.end()); //sorting all so that we can get the right most ant as it will take the max time among them.\\n            l = left[left.size()-1];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 720126,
                "title": "meet-and-return-cross-each-other-pretending-no-obstacle",
                "content": "```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int left_max = INT_MIN;\\n        for (auto ele : left) {\\n            left_max = max(left_max, ele);\\n        }\\n        int right_min = INT_MAX;\\n        for (auto ele : right) {\\n            right_min = min(right_min, ele);\\n        }\\n        if (left.empty() && right.empty()) {\\n            return 0;\\n        } else if (left.empty() && !right.empty()) {\\n            return n - right_min;\\n        } else if (!left.empty() && right.empty()) {\\n            return left_max;\\n        } else {\\n            return max(left_max, n - right_min);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int left_max = INT_MIN;\\n        for (auto ele : left) {\\n            left_max = max(left_max, ele);\\n        }\\n        int right_min = INT_MAX;\\n        for (auto ele : right) {\\n            right_min = min(right_min, ele);\\n        }\\n        if (left.empty() && right.empty()) {\\n            return 0;\\n        } else if (left.empty() && !right.empty()) {\\n            return n - right_min;\\n        } else if (!left.empty() && right.empty()) {\\n            return left_max;\\n        } else {\\n            return max(left_max, n - right_min);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720125,
                "title": "simple-and-easy-cpp-solution",
                "content": "\\'\\'\\'\\nint getLastMoment( int n, vector< int > & left, vector< int > & right ) {\\n     \\n\\t // sort in 0.1.2.3.4.5.6...\\n        sort( right.begin(),right.end() );\\n           \\n        // sort in   n-1 . n-2 . n-3 .....\\n        sort( left.begin(),left.end(),[](int a,int b){  return a>b; } );\\n       \\n    // there is no effect of changing the directions when they meet \\n   // maximum time taken by ants is remains same and that is\\n  // maximum distance of ant from end of her  direction\\n        \\n        // if no ant on left side maximum time taken by ant on right side\\n        \\n        if(left.size()==0)\\n            return n-right[0];\\n           \\n        if(right.size()==0)\\n            return left[n];\\n        \\n        // maximum time taken by anyone of both side ants\\n        \\n        return max(n-right[0],left[0]);\\n    }\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\nint getLastMoment( int n, vector< int > & left, vector< int > & right ) {\\n     \\n\\t // sort in 0.1.2.3.4.5.6...\\n        sort( right.begin(),right.end() );\\n           \\n        // sort in   n-1 . n-2 . n-3 .....\\n        sort( left.begin(),left.end(),[](int a,int b){  return a>b; } );\\n       \\n    // there is no effect of changing the directions when they meet \\n   // maximum time taken by ants is remains same and that is\\n  // maximum distance of ant from end of her  direction\\n        \\n        // if no ant on left side maximum time taken by ant on right side\\n        \\n        if(left.size()==0)\\n            return n-right[0];\\n           \\n        if(right.size()==0)\\n            return left[n];\\n        \\n        // maximum time taken by anyone of both side ants\\n        \\n        return max(n-right[0],left[0]);\\n    }\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 720120,
                "title": "python-simple-python-solution-with-explanation",
                "content": "Whether each ant switches direction won\\'t hurt the answer (you can think as just swapping the NUMBER of the two ants when they meet). So our answer still depends on **the ant which takes the longest time to fall at their original position**. \\n```\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        try: \\n            left_max = max(left)\\n        except:\\n            left_max = 0\\n        try:\\n            right_max = n - min(right)\\n        except:\\n            right_max = 0\\n        return max(left_max, right_max)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        try: \\n            left_max = max(left)\\n        except:\\n            left_max = 0\\n        try:\\n            right_max = n - min(right)\\n        except:\\n            right_max = 0\\n        return max(left_max, right_max)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720109,
                "title": "simple-c-solution-4-lines",
                "content": "```class Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int maxL = 0, minR = n;\\n        if (!left.empty())  maxL = *max_element (left.begin(), left.end());\\n        if (!right.empty()) minR = *min_element (right.begin(), right.end());\\n        return max (maxL, n - minR);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int maxL = 0, minR = n;\\n        if (!left.empty())  maxL = *max_element (left.begin(), left.end());\\n        if (!right.empty()) minR = *min_element (right.begin(), right.end());\\n        return max (maxL, n - minR);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 720107,
                "title": "kotlin-easy",
                "content": "![image](https://assets.leetcode.com/users/images/ff6d6b17-bb5a-4878-82c3-6fad70c76ddb_1593921883.8158321.png)\\n\\nIgonre T=1.5, it make us get confused\\n\\n```\\nfun getLastMoment(n: Int, left: IntArray, right: IntArray): Int {\\n    var maxTimeForLeft = Int.MIN_VALUE\\n    var maxTimeForRight = Int.MIN_VALUE\\n    if (left.isNotEmpty()) {\\n        val max = left.max()!!\\n        maxTimeForLeft = max - 0\\n    }\\n    if (right.isNotEmpty()) {\\n        val max = right.min()!!\\n        maxTimeForRight = n - max\\n    }\\n    return maxOf(maxTimeForLeft, maxTimeForRight)\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun getLastMoment(n: Int, left: IntArray, right: IntArray): Int {\\n    var maxTimeForLeft = Int.MIN_VALUE\\n    var maxTimeForRight = Int.MIN_VALUE\\n    if (left.isNotEmpty()) {\\n        val max = left.max()!!\\n        maxTimeForLeft = max - 0\\n    }\\n    if (right.isNotEmpty()) {\\n        val max = right.min()!!\\n        maxTimeForRight = n - max\\n    }\\n    return maxOf(maxTimeForLeft, maxTimeForRight)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4063480,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) \\n    {\\n         int ans=0;\\n         for (int i=0;i<left.size();i++)\\n         {\\n             ans=max(ans,left[i]);\\n         }  \\n         for (int i=0;i<right.size();i++)\\n         {\\n             ans=max(ans,n-right[i]);\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) \\n    {\\n         int ans=0;\\n         for (int i=0;i<left.size();i++)\\n         {\\n             ans=max(ans,left[i]);\\n         }  \\n         for (int i=0;i<right.size();i++)\\n         {\\n             ans=max(ans,n-right[i]);\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045769,
                "title": "dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int getLastMoment(int n, List<int> left, List<int> right) {\\n    if (right.isEmpty && left.isNotEmpty) {\\n      return left.reduce(max);\\n    } \\n    if (left.isEmpty && right.isNotEmpty) {\\n      final mini = right.reduce(min);\\n      return n - mini;\\n    }\\n    final maxi = left.reduce(max);\\n    final mini = right.reduce(min);\\n    return max(n - mini, maxi);\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int getLastMoment(int n, List<int> left, List<int> right) {\\n    if (right.isEmpty && left.isNotEmpty) {\\n      return left.reduce(max);\\n    } \\n    if (left.isEmpty && right.isNotEmpty) {\\n      final mini = right.reduce(min);\\n      return n - mini;\\n    }\\n    final maxi = left.reduce(max);\\n    final mini = right.reduce(min);\\n    return max(n - mini, maxi);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036834,
                "title": "kotlin-6-lines-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen two ants bump into each other and change their direction it\\'s the same as if they don\\'t meet any ants.\\n \\nFor example there are two ants: ant1 and ant2.\\n\\nWhen ant1 meets ant2, ant2 will pass ant1\\'s remaining path and ant1 will pass ant2\\'s remaining path.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe need to solve this task as if there aren\\'t any bumps.\\n\\nWe have to find the longest paths of ants:\\nThe longest path of left ants is **max(left)**\\nThe longest path of right ants is **n-min(right)**\\n\\nThen we just get max of longest paths and it will be the answer.\\n\\n# Complexity\\nTime  O(N)\\nSpace O(1) \\n\\n# Code\\n```\\nclass Solution {\\n    fun getLastMoment(n: Int, left: IntArray, right: IntArray): Int {\\n        val max = left.maxOrNull() ?: 0\\n        val min = right.minOrNull() ?: n\\n\\n        return maxOf(max, n - min)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun getLastMoment(n: Int, left: IntArray, right: IntArray): Int {\\n        val max = left.maxOrNull() ?: 0\\n        val min = right.minOrNull() ?: n\\n\\n        return maxOf(max, n - min)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984725,
                "title": "c-brainteaser-o-n",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int ans = 0;\\n        for(int l: left) ans = max(ans, l);\\n        for(int r: right) ans = max(ans, n - r);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int ans = 0;\\n        for(int l: left) ans = max(ans, l);\\n        for(int r: right) ans = max(ans, n - r);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953168,
                "title": "c-python-solution-with-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/9c12a94c-a3a7-4072-8b9a-ee0a033546b9_1692860738.7927608.png)\\ntc is O(n), sc is O(1).\\n### python\\n```python\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        ans = -1\\n        if left:\\n            ans = max(left) # the rightmost ant go to left\\n        if right:\\n            ans = max(ans, n - min(right))# the leftmost ant go to right\\n        return ans\\n```\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int ans = -1;\\n        if (!left.empty()) ans = *max_element(left.begin(), left.end());\\n        if (!right.empty()) ans = max(ans, n - *min_element(right.begin(), right.end()));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```python\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        ans = -1\\n        if left:\\n            ans = max(left) # the rightmost ant go to left\\n        if right:\\n            ans = max(ans, n - min(right))# the leftmost ant go to right\\n        return ans\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int ans = -1;\\n        if (!left.empty()) ans = *max_element(left.begin(), left.end());\\n        if (!right.empty()) ans = max(ans, n - *min_element(right.begin(), right.end()));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865921,
                "title": "easy-to-understand-javascript-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nvar getLastMoment = function(n, left, right) {\\n    const maxLeft = Math.max(...left);\\n    const minRight = Math.min(...right);\\n\\n    return Math.max(n - minRight, maxLeft);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar getLastMoment = function(n, left, right) {\\n    const maxLeft = Math.max(...left);\\n    const minRight = Math.min(...right);\\n\\n    return Math.max(n - minRight, maxLeft);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3834496,
                "title": "easy-clean-code-great-expalnation",
                "content": "# Intuition\\nThe given movement of cheeti(ants) on a plank is equivalent to movement of ants on parallel plank with all ants in same direction moving on same palnk.\\n\\nThen we have to find time when both the group of ants fall off the plank.\\n\\nHence, max of time taken by both groups to leave their planks.\\n\\n# Complexity\\n- Time complexity:O(nlog(n))\\n- Space complexity:O(1)\\n# Code\\n```\\nclass Solution {\\n    public int getLastMoment(int n, int[] left, int[] right) {\\n        Arrays.sort(left) ; \\n        Arrays.sort(right) ; \\n        int t1 = 0 ; int t2 = 0 ; \\n        if(left.length>0) t1 = left[left.length-1] ; \\n        if(right.length>0) t2 = n- right[0] ; \\n        return Math.max(t1,t2) ; \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getLastMoment(int n, int[] left, int[] right) {\\n        Arrays.sort(left) ; \\n        Arrays.sort(right) ; \\n        int t1 = 0 ; int t2 = 0 ; \\n        if(left.length>0) t1 = left[left.length-1] ; \\n        if(right.length>0) t2 = n- right[0] ; \\n        return Math.max(t1,t2) ; \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779729,
                "title": "assuming-last-ant-will-fall-on-one-side-of-the-plank-left-in-this-case",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getLastMoment(int n, int[] left, int[] right) {\\n        int ans = 0;\\n        for (int x : left) {\\n            ans = Math.max(ans, x);\\n        }\\n        for (int x : right) {\\n            ans = Math.max(ans, n - x);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getLastMoment(int n, int[] left, int[] right) {\\n        int ans = 0;\\n        for (int x : left) {\\n            ans = Math.max(ans, x);\\n        }\\n        for (int x : right) {\\n            ans = Math.max(ans, n - x);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741026,
                "title": "short-easy-c-code-100-passing-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int n1=(left.size()>0)?(*max_element(left.begin(),left.end())):0;\\n        int n2=(right.size()>0)?(n-*min_element(right.begin(),right.end())):0;\\n        return max(n1,n2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int n1=(left.size()>0)?(*max_element(left.begin(),left.end())):0;\\n        int n2=(right.size()>0)?(n-*min_element(right.begin(),right.end())):0;\\n        return max(n1,n2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3724392,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe colliding does not matter (just see it as the ants walking through each other).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTherefore, just find the one ant that will need the longest to reach the end of its specific path.\\nTo do that I calculate the furthest from the left and the furthest from the right, and I return the the bigger one of those two.\\nI am pretty new to coding, please let me know if I did the time/space complexity right :) \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->0(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->0(1)\\n\\n# Code\\n```\\nint getLastMoment(int n, int* left, int leftSize, int* right, int rightSize)\\n{\\n    int time_left = 0;\\n    int time_right = 0;\\n    \\n    for (int i = 0; i < leftSize; i++)\\n    {\\n        if (left[i] > time_left)\\n            time_left = left[i];\\n    }\\n    \\n    for (int i = 0; i < rightSize; i++)\\n    {\\n        if (n - right[i] > time_right)\\n            time_right = n - right[i];\\n    }\\n    \\n    if (time_right > time_left)\\n        return time_right;\\n    else\\n        return time_left;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint getLastMoment(int n, int* left, int leftSize, int* right, int rightSize)\\n{\\n    int time_left = 0;\\n    int time_right = 0;\\n    \\n    for (int i = 0; i < leftSize; i++)\\n    {\\n        if (left[i] > time_left)\\n            time_left = left[i];\\n    }\\n    \\n    for (int i = 0; i < rightSize; i++)\\n    {\\n        if (n - right[i] > time_right)\\n            time_right = n - right[i];\\n    }\\n    \\n    if (time_right > time_left)\\n        return time_right;\\n    else\\n        return time_left;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3694806,
                "title": "one-liner-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        return max(max(left) if left!=[] else 0 ,n-min(right) if right!=[] else 0)\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        return max(max(left) if left!=[] else 0 ,n-min(right) if right!=[] else 0)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669678,
                "title": "c-easy-3-line-solution",
                "content": "# Intuition\\n- Changing direction dosen\\'t matter.\\n- Keep moving in same direction even after collision\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int leftMax = left.size()>0?*max_element(left.begin(),left.end()):0;\\n        int rightMax = right.size()>0?n-*min_element(right.begin(),right.end()):0;\\n        return max(leftMax,rightMax);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int leftMax = left.size()>0?*max_element(left.begin(),left.end()):0;\\n        int rightMax = right.size()>0?n-*min_element(right.begin(),right.end()):0;\\n        return max(leftMax,rightMax);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3657689,
                "title": "c-just-ignore-collisions-and-get-the-maximum-distance-from-border-100-space-22-7mb",
                "content": "This problem is definitely way easier if we figure out that they are like impact in a Newtonian system where bodies of the same mass bounce on each other linearly and move back the way the other was moving - so basically they just trade places going left or right, same speed.\\n\\nWith this simplifcation in mind (a harder version of this concept can be found in the [movement of robots](https://leetcode.com/problems/movement-of-robots/solutions/) challenge, [cracked here](https://leetcode.com/problems/movement-of-robots/solutions/3653749/c-ignore-collisions-and-get-cumulative-sum-100-90ms-45-space-45-2mb/)), the problem becomes much easier, since it just boils down to just figuring out who will leave the board last.\\n\\nTo do so, we will declarethe support variable `res`, initialised to `0`, then we will parse every `ant` going `left` and know that the distance it has to walk to go off is the same to reach `0`, so we will update `res` to be the maximum between its current value and `ant` itself.\\n\\nSpecularly, for each `ant` going `right`, we will update `res` to be the maximum between its current distance and the right extreme of the board, `n` (ie: the distance will be `n - ant`).\\n\\nOnce done, we can just `return` `res` :)\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int> &left, vector<int> &right) {\\n        // support variables\\n        int res = 0;\\n        // parsing left\\n        for (int ant: left) {\\n            res = max(res, ant);\\n        }\\n        // parsing right\\n        for (int ant: right) {\\n            res = max(res, n - ant);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Brainteaser"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int> &left, vector<int> &right) {\\n        // support variables\\n        int res = 0;\\n        // parsing left\\n        for (int ant: left) {\\n            res = max(res, ant);\\n        }\\n        // parsing right\\n        for (int ant: right) {\\n            res = max(res, n - ant);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650181,
                "title": "rust-one-expression-solution",
                "content": "# Intuition\\nWhen two ants collide, we got from having one left-moving ant and one right-moving ant...to having one left-moving ant and one right-moving ant. Because the ants are only distinguished by position and direction, we can imagine that this turning around never happens, and the ants just phase through each other without affecting anything.\\n\\nSo if the ants don\\'t interact, then the last ant to drop off is either the leftmost right-moving ant, or the rightmost left-moving ant. Find these two ants, find their time to exit, and take the greater of the two (substituting 0 if there are no left-moving ants or no right-moving ants.)\\n\\n# Complexity\\n- Time complexity: O(left.len() + right.len()). We have to look at every ant to find the max or min respectively.\\n\\n- Space complexity: O(1), no data structures required.\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn get_last_moment(n: i32, left: Vec<i32>, right: Vec<i32>) -> i32 {\\n        left\\n        .into_iter()\\n        .max()\\n        .unwrap_or(0)\\n        .max(\\n            right\\n            .into_iter()\\n            .min()\\n            .map(|i| n-i)\\n            .unwrap_or(0)\\n        )\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn get_last_moment(n: i32, left: Vec<i32>, right: Vec<i32>) -> i32 {\\n        left\\n        .into_iter()\\n        .max()\\n        .unwrap_or(0)\\n        .max(\\n            right\\n            .into_iter()\\n            .min()\\n            .map(|i| n-i)\\n            .unwrap_or(0)\\n        )\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3646666,
                "title": "python-video-walkthrough-time-o-n-space-o-1-one-line-solution",
                "content": "[Click Here For Video Walkthrough](https://youtu.be/JwIuGBg3w3I)\\n```\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        return max(n-min(right,default=float(\"inf\")), max(left,default=float(\\'-inf\\')))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        return max(n-min(right,default=float(\"inf\")), max(left,default=float(\\'-inf\\')))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3644141,
                "title": "sorting-c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        sort(left.begin(),left.end());\\n        sort(right.begin(),right.end());\\n        int nl=left.size();\\n        int nr=right.size();\\n        int leftmax=0,rightmin=0;\\n        if(left.size() > 0)leftmax=left[nl-1];\\n        if(right.size() >0) rightmin=right[0];\\n        if(nl && nr)\\n        {\\n            return max(leftmax, n-rightmin);\\n        }\\n        else if(nl)\\n        {\\n            return leftmax;\\n        }\\n        return n-rightmin;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        sort(left.begin(),left.end());\\n        sort(right.begin(),right.end());\\n        int nl=left.size();\\n        int nr=right.size();\\n        int leftmax=0,rightmin=0;\\n        if(left.size() > 0)leftmax=left[nl-1];\\n        if(right.size() >0) rightmin=right[0];\\n        if(nl && nr)\\n        {\\n            return max(leftmax, n-rightmin);\\n        }\\n        else if(nl)\\n        {\\n            return leftmax;\\n        }\\n        return n-rightmin;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643069,
                "title": "c-easy-tc-0-n-sc-0-1",
                "content": "# Intuition\\nJust think for left ant and right ant.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int lf = 0, rt = 0;\\n        for(int i=0 ;i<left.size() ;i++)\\n            lf = max(lf, left[i]);\\n        for(int i=0 ;i<right.size() ;i++)\\n            rt = max(rt, n - right[i]);\\n        \\n        return max(lf, rt);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int lf = 0, rt = 0;\\n        for(int i=0 ;i<left.size() ;i++)\\n            lf = max(lf, left[i]);\\n        for(int i=0 ;i<right.size() ;i++)\\n            rt = max(rt, n - right[i]);\\n        \\n        return max(lf, rt);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3626058,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& l, vector<int>& r) {\\n        int ans = 0;\\n        for(auto &e : l) ans = max(ans, e);\\n        for(auto &e : r) ans = max(ans, n - e);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& l, vector<int>& r) {\\n        int ans = 0;\\n        for(auto &e : l) ans = max(ans, e);\\n        for(auto &e : r) ans = max(ans, n - e);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625466,
                "title": "the-great-ant-race-who-will-be-the-last-ant-standing",
                "content": "**Solution**\\n\\n```\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        return max(max(left) if left else 0, n - min(right) if right else 0)\\n```\\n\\n\\nIn this article, we are diving into an interesting problem statement that involves ants moving on a plank. The task is to find the moment when the last ant(s) fall out of the plank, given the length of the plank and the initial positions of the ants moving towards either end.\\n\\n## Problem Description\\n\\nGiven a wooden plank of `n` units length and some ants walking on it, each ant moves with a speed of 1 unit per second. Some ants move to the left, others move to the right. \\n\\nWhen two ants moving in opposite directions meet at some point, they change their directions and continue moving. It\\'s assumed that changing directions doesn\\'t take any additional time.\\n\\nWhen an ant reaches an end of the plank at time `t`, it immediately falls off the plank. The challenge is to calculate the moment when the last ant(s) fall out of the plank, given the length of the plank and the initial positions of ants moving left and right.\\n\\n## Solution Overview\\n\\nThis solution takes an ingenious approach by recognizing the underlying mechanics of the problem, leading to an intuitive and efficient solution. Here\\'s the Python code for the solution:\\n\\n```python\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        return max(max(left) if left else 0, n - min(right) if right else 0)\\n```\\n\\nThe `getLastMoment` function calculates the last moment by taking the maximum value between the farthest ant from the left end and the farthest ant from the right end. \\n\\n## How does the solution work?\\n\\nDespite the seemingly complex setup of ants moving back and forth on the plank, the problem simplifies greatly if we realize one key insight: the moment when two ants meet and decide to change their direction is indistinguishable from the two ants just passing through each other. \\n\\nThis means, in terms of computing the time when the last ant falls off, we can just consider each ant to continue its initial direction without any interruption. Given that each ant is moving at a speed of 1 unit per second, an ant\\'s distance from the edge of the plank is also exactly the time it will take for the ant to fall off.\\n\\nFor the ants moving to the left, their falling time is just their starting position, hence we use `max(left)`. For the ants moving to the right, their falling time is the distance from the right edge, which is the total length `n` minus their starting position, so we use `n - min(right)`.\\n\\nThe last ant to fall off will be the one with the maximum of these times, which is exactly what the solution returns.\\n\\n## Time Complexity\\n\\nThe time complexity of the solution is O(N) for both the left and right lists, as in the worst case we have to go through all the elements in both lists to find the maximum element in `left` and the minimum element in `right`. Here, N is the number of ants.\\n\\nThis solution, therefore, provides a highly efficient and intuitive way to solve the problem by utilizing a clever insight into the behavior of the ants on the plank. It offers an excellent example of how understanding the problem\\'s mechanics can lead to a simple and efficient solution.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        return max(max(left) if left else 0, n - min(right) if right else 0)\\n```\n```python\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        return max(max(left) if left else 0, n - min(right) if right else 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624829,
                "title": "easy-understanding-most-optimal-approach-o-n-single-pass-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n\\n        int l=0, r=n;\\n        \\n        if(left.size())\\n        l = *max_element(left.begin(), left.end());\\n        if(right.size())\\n        r = *min_element(right.begin(), right.end());\\ncout<<l<<\"  \"<<r;\\n        \\n        r=n-r;\\n\\n        return max(l, r);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n\\n        int l=0, r=n;\\n        \\n        if(left.size())\\n        l = *max_element(left.begin(), left.end());\\n        if(right.size())\\n        r = *min_element(right.begin(), right.end());\\ncout<<l<<\"  \"<<r;\\n        \\n        r=n-r;\\n\\n        return max(l, r);\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3624414,
                "title": "c-3-liner-easy-to-understand",
                "content": "**Ants will keep on walking in same direction even after the collision **\\nSo, We have to find the rightmost ant going in left direction and leftmost ant going in right direction .\\n```\\nint getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int res=0;\\n        for(int it:left)res=max(it,res);\\n        for(int it:right)res=max(n-it,res);\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int res=0;\\n        for(int it:left)res=max(it,res);\\n        for(int it:right)res=max(n-it,res);\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3623267,
                "title": "python-medium",
                "content": "```\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        ans = 0\\n\\n        for num in left:\\n            ans = max(ans, num)\\n\\n        for num in right:\\n            ans = max(ans, n - num)\\n\\n\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        ans = 0\\n\\n        for num in left:\\n            ans = max(ans, num)\\n\\n        for num in right:\\n            ans = max(ans, n - num)\\n\\n\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622928,
                "title": "one-liner-c",
                "content": "```\\nint getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n    return max(left.empty() ? 0 : *max_element(left.begin(), left.end()), right.empty() ? 0 : n - *min_element(right.begin(), right.end()));\\n}\\n\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nint getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n    return max(left.empty() ? 0 : *max_element(left.begin(), left.end()), right.empty() ? 0 : n - *min_element(right.begin(), right.end()));\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3622874,
                "title": "c-logical-solution-optimized-code",
                "content": "# Approach\\nHere the approach is solely based on the fact even if 2 ants meet and change direction there wont be change in the max time. Here only the identities of the ants get changed but not the result.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int t=-1;\\n        for(int i=0;i<left.size();i++){\\n            t=max(t,left[i]);\\n        }\\n        for(int i=0;i<right.size();i++){\\n            t=max(t,n-right[i]);\\n        }\\n    return t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Brainteaser",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int t=-1;\\n        for(int i=0;i<left.size();i++){\\n            t=max(t,left[i]);\\n        }\\n        for(int i=0;i<right.size();i++){\\n            t=max(t,n-right[i]);\\n        }\\n    return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622700,
                "title": "easiest-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int time=0;\\n        for(int i=0;i<left.size();i++)\\n        {\\n            time=max(time,left[i]-0);\\n        }\\n        for(int i=0;i<right.size();i++)\\n        time=max(time,n-right[i]);\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int time=0;\\n        for(int i=0;i<left.size();i++)\\n        {\\n            time=max(time,left[i]-0);\\n        }\\n        for(int i=0;i<right.size();i++)\\n        time=max(time,n-right[i]);\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622519,
                "title": "java-compare-min-and-max",
                "content": "# Intuition\\nThe tricky point is to undestand that wnen ants `a` and `b` meet each other `a` will swithc the direction and move like `b` and `b` will switch the direcction and continue move like `a`. Once we don\\'t care about ant ids we can just ignore the facts of meetings.\\nTo the time is min position ant moved right rich the end (`n`) or max position ant moved left rich start (`0`).\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int getLastMoment(int n, int[] left, int[] right) {\\n        int min = n;\\n        for (int ant : right) {\\n            min = Math.min(min, ant);\\n        }\\n        int max = 0;\\n        for (int ant : left) {\\n            max = Math.max(max, ant);\\n        }\\n\\n        return Math.max(n - min, max);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getLastMoment(int n, int[] left, int[] right) {\\n        int min = n;\\n        for (int ant : right) {\\n            min = Math.min(min, ant);\\n        }\\n        int max = 0;\\n        for (int ant : left) {\\n            max = Math.max(max, ant);\\n        }\\n\\n        return Math.max(n - min, max);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3543775,
                "title": "easy-c-solution-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int max1=INT_MIN;\\n        int max2=INT_MIN;\\n        for(int i=0;i<left.size();i++){\\n            max1=max(max1,left[i]-0);\\n        }\\n        for(int i=0;i<right.size();i++){\\n            max2=max(max2,n-right[i]);\\n        }\\n        return max(max1,max2);\\n    }\\n};\\n```\\nPLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F IF YOU LIKE THE SOLUTION !!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int max1=INT_MIN;\\n        int max2=INT_MIN;\\n        for(int i=0;i<left.size();i++){\\n            max1=max(max1,left[i]-0);\\n        }\\n        for(int i=0;i<right.size();i++){\\n            max2=max(max2,n-right[i]);\\n        }\\n        return max(max1,max2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538093,
                "title": "easy-solution-o-n",
                "content": "# Complexity\\n- Time complexity: o(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int ans=0;\\n        for(auto it:left) ans=max(ans,it);\\n        for(auto it:right) ans=max(ans,n-it);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int ans=0;\\n        for(auto it:left) ans=max(ans,it);\\n        for(auto it:right) ans=max(ans,n-it);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3528943,
                "title": "easy-java-solution-with-few-lines-of-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getLastMoment(int n, int[] left, int[] right) {\\n        int maxTime = 0;\\n        \\n        for (int position : left) {\\n            maxTime = Math.max(maxTime, position);\\n        }\\n        \\n        for (int position : right) {\\n            maxTime = Math.max(maxTime, n - position);\\n        }\\n        \\n        return maxTime;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getLastMoment(int n, int[] left, int[] right) {\\n        int maxTime = 0;\\n        \\n        for (int position : left) {\\n            maxTime = Math.max(maxTime, position);\\n        }\\n        \\n        for (int position : right) {\\n            maxTime = Math.max(maxTime, n - position);\\n        }\\n        \\n        return maxTime;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3491613,
                "title": "python-oneliner",
                "content": "```\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        return max(n-min(right, default=n), max(left, default=0))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        return max(n-min(right, default=n), max(left, default=0))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467438,
                "title": "simple-trick",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n2 ants collide and return to the opposite direction is effectively same as they don\\'t collide at all when you calculate the total turns. So just cound how long it\\'d take for the farest ant \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int biggestLeft = 0;\\n        for (int l : left)\\n        {\\n            biggestLeft = std::max(biggestLeft, l);\\n        }\\n\\n        int smallestRight = n + 1;\\n        for (int r : right)\\n        {\\n            smallestRight = std::min(smallestRight, r);\\n        }\\n\\n        int leftTurns = biggestLeft;\\n        int rightTurns = n - smallestRight;\\n\\n        return std::max(leftTurns, rightTurns);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int biggestLeft = 0;\\n        for (int l : left)\\n        {\\n            biggestLeft = std::max(biggestLeft, l);\\n        }\\n\\n        int smallestRight = n + 1;\\n        for (int r : right)\\n        {\\n            smallestRight = std::min(smallestRight, r);\\n        }\\n\\n        int leftTurns = biggestLeft;\\n        int rightTurns = n - smallestRight;\\n\\n        return std::max(leftTurns, rightTurns);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3408239,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func getLastMoment(_ n: Int, _ left: [Int], _ right: [Int]) -> Int {\\n        max(left.max() ?? 0, n - (right.min() ?? n))\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func getLastMoment(_ n: Int, _ left: [Int], _ right: [Int]) -> Int {\\n        max(left.max() ?? 0, n - (right.min() ?? n))\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3389268,
                "title": "cpp-simple-solution-using-left-max-and-right-min",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        ios::sync_with_stdio(false);\\n        int lmax =0, rmin = n;\\n        if(!left.empty()){\\n            lmax = *max_element(begin(left), end(left));        \\n        }\\n        if(!right.empty()){\\n            rmin = *min_element(begin(right), end(right));\\n        }\\n        return max(lmax, n - rmin);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        ios::sync_with_stdio(false);\\n        int lmax =0, rmin = n;\\n        if(!left.empty()){\\n            lmax = *max_element(begin(left), end(left));        \\n        }\\n        if(!right.empty()){\\n            rmin = *min_element(begin(right), end(right));\\n        }\\n        return max(lmax, n - rmin);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3305230,
                "title": "explained-but-not-optimal-could-be-brought-down-to-three-lines-if-needed-o-n-with-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince switching directions takes no time and movement continues unabated, when we have a double pileup crash, it\\'s like we never moved forward into the crash and just swapped directions. Due to this, we can actually think of this in terms of the ants we start with. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCouple edge cases to consider \\n- If you have no ants, it takes no time! \\n- If you have ants only heading left, the time is the maximum index of the ants heading left since they\\'ll need that many steps to exit \\n- If you have ants only heading right, the time is the minimum index of the ants heading right taken away from n, since that\\'s the distance to position n-1. \\nOtherwise, we need to calculate for each position in the lists. \\n\\nFor each ant in the left list, find the maximal ant index \\nFor each ant in the right list, find the minimal ant \\nreturn the max of the maximal left ant and the difference of n and the minimal right ant \\n\\nThis can be done in three lines as the edge cases are resolved in the base cases if we just set the left and right maximal values to 0 if there is no list \\n\\nIt was left in this form with comments for easier understanding and readability during interviews. \\n\\n\\n# Complexity\\n- Time complexity: O(N) \\n- Go over both lists once \\n\\n- Space complexity: O(1) no lists made or stored. \\n\\n# Code\\n```\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        # no ants, no time! \\n        if left is None and right is None : \\n            return 0 \\n        elif left and not right : \\n            # only got ants heading left, we need the maximal position of that lefty \\n            return max(left)\\n        elif right and not left : \\n            # only got ants heading right, we need the minimal positions distance to n \\n            return n - min(right)\\n\\n        # if you have both, we might have some fights \\n        # max hunting time \\n        left_max = -1\\n        right_max = -1 \\n        # go over left and get the max of its distance to 0  \\n        for left_index in left :\\n            # update as needed  \\n            left_max = max(left_max, left_index)\\n        # go over right. Since moving right, distance is n - index since we are at index, heading to n.  \\n        for right_index in right : \\n            # update as needed \\n            right_max = max(right_max, n-right_index)\\n        # return the maximal distance in left or right. \\n        # This only works since we know that swapping directions takes no time.  \\n        # If swapping directions took time or stopped movement, we\\'d have a much more interesting problem. \\n        return max(left_max, right_max)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        # no ants, no time! \\n        if left is None and right is None : \\n            return 0 \\n        elif left and not right : \\n            # only got ants heading left, we need the maximal position of that lefty \\n            return max(left)\\n        elif right and not left : \\n            # only got ants heading right, we need the minimal positions distance to n \\n            return n - min(right)\\n\\n        # if you have both, we might have some fights \\n        # max hunting time \\n        left_max = -1\\n        right_max = -1 \\n        # go over left and get the max of its distance to 0  \\n        for left_index in left :\\n            # update as needed  \\n            left_max = max(left_max, left_index)\\n        # go over right. Since moving right, distance is n - index since we are at index, heading to n.  \\n        for right_index in right : \\n            # update as needed \\n            right_max = max(right_max, n-right_index)\\n        # return the maximal distance in left or right. \\n        # This only works since we know that swapping directions takes no time.  \\n        # If swapping directions took time or stopped movement, we\\'d have a much more interesting problem. \\n        return max(left_max, right_max)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287483,
                "title": "easy-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) \\n    {\\n        if(left.size()==0)\\n        {\\n            int mn=*min_element(right.begin(),right.end());\\n            return n-mn;\\n        }\\n        else if(right.size()==0) \\n        {\\n            int mx=*max_element(left.begin(),left.end());\\n            return mx;\\n        }\\n        int mn=*min_element(right.begin(),right.end());\\n        int mx=*max_element(left.begin(),left.end());\\n        return max(n-mn,mx);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) \\n    {\\n        if(left.size()==0)\\n        {\\n            int mn=*min_element(right.begin(),right.end());\\n            return n-mn;\\n        }\\n        else if(right.size()==0) \\n        {\\n            int mx=*max_element(left.begin(),left.end());\\n            return mx;\\n        }\\n        int mn=*min_element(right.begin(),right.end());\\n        int mx=*max_element(left.begin(),left.end());\\n        return max(n-mn,mx);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254513,
                "title": "prabal-kumar-pandey",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        return max(!left.empty() ? *max_element(cbegin(left), cend(left)) : 0,\\n                   !right.empty() ? n - *min_element(cbegin(right), cend(right)) : 0);        \\n    }\\n};\\n// Left ANT takes long time to fall from plank so find max_element of left with \\':\\' 0.\\n// Right ANT takes short time to fall from plank so find min_element of right with \\':\\' 0.\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        return max(!left.empty() ? *max_element(cbegin(left), cend(left)) : 0,\\n                   !right.empty() ? n - *min_element(cbegin(right), cend(right)) : 0);        \\n    }\\n};\\n// Left ANT takes long time to fall from plank so find max_element of left with \\':\\' 0.\\n// Right ANT takes short time to fall from plank so find min_element of right with \\':\\' 0.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225784,
                "title": "c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) \\n    {\\n        int t=0;\\n        for(int i=0;i<left.size();i++)\\n        {\\n            t=max(t,left[i]);\\n        }    \\n        for(int i=0;i<right.size();i++)\\n        {\\n            t=max(t,n-right[i]);\\n        }\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) \\n    {\\n        int t=0;\\n        for(int i=0;i<left.size();i++)\\n        {\\n            t=max(t,left[i]);\\n        }    \\n        for(int i=0;i<right.size();i++)\\n        {\\n            t=max(t,n-right[i]);\\n        }\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3211643,
                "title": "easy-approach-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) \\n    {\\n        int t=0;\\n        for(int i=0;i<left.size();i++)\\n        {\\n            t=max(t,left[i]);\\n        }\\n        for(int i=0;i<right.size();i++)\\n        {\\n            t=max(t,n-right[i]);\\n        }\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) \\n    {\\n        int t=0;\\n        for(int i=0;i<left.size();i++)\\n        {\\n            t=max(t,left[i]);\\n        }\\n        for(int i=0;i<right.size();i++)\\n        {\\n            t=max(t,n-right[i]);\\n        }\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3195993,
                "title": "c-4-lines",
                "content": "```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int i = 0, y = n;\\n        for (auto& n : left) i = max(i, n);\\n        for (auto& n : right) y = min(n, y);\\n        return max(i, n - y);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int i = 0, y = n;\\n        for (auto& n : left) i = max(i, n);\\n        for (auto& n : right) y = min(n, y);\\n        return max(i, n - y);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3162519,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn get_last_moment(n: i32, left: Vec<i32>, right: Vec<i32>) -> i32 {\\n        let mut max = 0;\\n        for i in left {\\n            max = max.max(i);\\n        }\\n        for i in right {\\n            max = max.max(n - i);\\n        }\\n        max\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn get_last_moment(n: i32, left: Vec<i32>, right: Vec<i32>) -> i32 {\\n        let mut max = 0;\\n        for i in left {\\n            max = max.max(i);\\n        }\\n        for i in right {\\n            max = max.max(n - i);\\n        }\\n        max\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3147475,
                "title": "java-two-way-roads-explained-with-example",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int getLastMoment(int n, int[] left, int[] right) {\\n       // consider it as 2 way roads\\n       // left ants are moving on one road and right ants are moving on other road\\n        \\n       // Input: n = 4, left = [4,3], right = [0,1]\\n       \\n       // 0 1 2 3 4   1st road\\n       // <---- a b\\n       // a will reach at the left end at t = 3s\\n       // b _____________________________ t = 4s\\n\\n       // 0 1 2 3 4   2nd road\\n       // c d ---->\\n       // d will reach at the right end at t = (4 - 1) = 3s\\n       // c ______________________________ t = (4 - 0) = 4s\\n\\n       // 4s is max time \\n\\n       int maxInLeft = 0;\\n       for(int num : left){\\n           maxInLeft = Math.max(maxInLeft , num);\\n       }\\n       int minInRight = Integer.MAX_VALUE;\\n       for(int num : right){\\n           minInRight = Math.min(minInRight, num);\\n       } \\n       return Math.max(maxInLeft , n - minInRight); \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getLastMoment(int n, int[] left, int[] right) {\\n       // consider it as 2 way roads\\n       // left ants are moving on one road and right ants are moving on other road\\n        \\n       // Input: n = 4, left = [4,3], right = [0,1]\\n       \\n       // 0 1 2 3 4   1st road\\n       // <---- a b\\n       // a will reach at the left end at t = 3s\\n       // b _____________________________ t = 4s\\n\\n       // 0 1 2 3 4   2nd road\\n       // c d ---->\\n       // d will reach at the right end at t = (4 - 1) = 3s\\n       // c ______________________________ t = (4 - 0) = 4s\\n\\n       // 4s is max time \\n\\n       int maxInLeft = 0;\\n       for(int num : left){\\n           maxInLeft = Math.max(maxInLeft , num);\\n       }\\n       int minInRight = Integer.MAX_VALUE;\\n       for(int num : right){\\n           minInRight = Math.min(minInRight, num);\\n       } \\n       return Math.max(maxInLeft , n - minInRight); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3126029,
                "title": "c-solution-o-n-solution-short-and-faster-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        if(left.size() == 0){\\n            return n - *min_element(right.begin(),right.end());\\n        }\\n        if(right.size() == 0){\\n            return *max_element(left.begin(),left.end());\\n        }\\n\\n        int rightMostInLeft = *max_element(left.begin(),left.end());\\n        int leftMostInRight = *min_element(right.begin(),right.end());\\n\\n        return max(rightMostInLeft,n - leftMostInRight);;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        if(left.size() == 0){\\n            return n - *min_element(right.begin(),right.end());\\n        }\\n        if(right.size() == 0){\\n            return *max_element(left.begin(),left.end());\\n        }\\n\\n        int rightMostInLeft = *max_element(left.begin(),left.end());\\n        int leftMostInRight = *min_element(right.begin(),right.end());\\n\\n        return max(rightMostInLeft,n - leftMostInRight);;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3125240,
                "title": "python-no-turn-around-just-moving-forward-explained",
                "content": "Actually, the problem is kind of trick with the trun around case when two ants meet at a point.\\n\\nWe can just simplify the collision case by imaging the two ants are not turning around, they are still move forward on its own direction. Image that all the ants are the same, they can switch their index when they meet.\\n\\nSo the problem becomes finding the max(left) and min(right).\\n\\n```\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        if left and right:\\n            return max(max(left), n - min(right))\\n        if left:\\n            return max(left)\\n        if right:\\n            return n - min(right)\\n        return 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        if left and right:\\n            return max(max(left), n - min(right))\\n        if left:\\n            return max(left)\\n        if right:\\n            return n - min(right)\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3123882,
                "title": "simple-c-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBy Observation, assume that when two ants meet each other then don\\'t change there path\\n\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int mn = n;\\n        int mx = 0;\\n        for(auto it : right){\\n            mn = min(mn,it);\\n        }\\n        for(auto it : left){\\n            mx = max(mx,it);\\n        }\\n\\n        return max(mx,n-mn);\\n    }\\n};\\n```\\n\\n# Upvote if it\\'s help you HAPPY CODING:)",
                "solutionTags": [
                    "C++",
                    "Brainteaser",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int mn = n;\\n        int mx = 0;\\n        for(auto it : right){\\n            mn = min(mn,it);\\n        }\\n        for(auto it : left){\\n            mx = max(mx,it);\\n        }\\n\\n        return max(mx,n-mn);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3116764,
                "title": "super-easy-4-lines-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Initialize two variables ```l``` and ```r``` to store the maximum position of the ants moving to the left and right, respectively.\\n\\n2. Use a ```for``` loop to traverse the ```left``` array and update the value of ```l``` with the maximum position of the ants moving to the left.\\n\\n3. Use another ```for``` loop to traverse the ```right``` array and update the value of ```r``` with the maximum position of the ants moving to the right. To calculate the maximum position of the ants moving to the right, subtract each ant\\'s position from ```n```.\\n\\n4. Finally, return the maximum value between ```l``` and ```r```. This value represents the moment when the last ant(s) fall off the plank.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- To solve this problem, first find the maximum and minimum position of the ants at time t.\\n- Then, the maximum position minus t and t minus the minimum position should be less than or equal to n. \\n- The maximum position of the ants is the sum of the maximum positions of the ants moving left and right, and the minimum position is the maximum position of the ants moving left minus n.\\n- The moment when the last ant(s) fall out of the plank is the maximum value of t that satisfies this condition.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getLastMoment(int n, int[] left, int[] right) {\\n        int l=0,r=0;\\n        for(int i: left) l = Math.max(l,i);\\n        for(int i: right) r = Math.max(r,n-i);\\n        return Math.max(l,r);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```l```\n```r```\n```for```\n```left```\n```l```\n```for```\n```right```\n```r```\n```n```\n```l```\n```r```\n```\\nclass Solution {\\n    public int getLastMoment(int n, int[] left, int[] right) {\\n        int l=0,r=0;\\n        for(int i: left) l = Math.max(l,i);\\n        for(int i: right) r = Math.max(r,n-i);\\n        return Math.max(l,r);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115204,
                "title": "c-4-lines-code-tc-o-n-java-1-line-code-tc-o-1",
                "content": "# Intuition\\nWe will take 2 roads one for left and one for right\\n\\n# Approach\\n1.We will initialize the maxleft to 0 and minright to INT_MAX .\\n2.Then we will find the max of left array\\n3.We will find the min of right array.\\n4.Then we return the max (maxleft,n-minright);\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code - C++\\n```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int maxleft = 0;\\n        int minright = INT_MAX;\\n        for(auto it:left)maxleft = max(it,maxleft);\\n        for(auto it:right)minright = min(it,minright);\\n\\n        return max(maxleft,n-minright);\\n    }\\n};\\n\\n\\n# Code - JAVA\\nclass Solution {\\n    public int getLastMoment(int n, int[] left, int[] right) {\\n        return Math.max(Arrays.stream(left).max().orElse(0),n-Arrays.stream(right).min().orElse(Integer.MAX_VALUE));\\n    }\\n}\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int maxleft = 0;\\n        int minright = INT_MAX;\\n        for(auto it:left)maxleft = max(it,maxleft);\\n        for(auto it:right)minright = min(it,minright);\\n\\n        return max(maxleft,n-minright);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3115177,
                "title": "easy-c-4-lines-of-code-full-algorithm-explained",
                "content": "# Intuition\\nWe will take 2 roads one for left and one for right\\n\\n# Approach\\n1.We will initialize the maxleft to 0 and minright to INT_MAX .\\n2.Then we will find the max of left array\\n3.We will find the min of right array.\\n4.Then we return the max (maxleft,n-minright);\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int maxleft = 0;\\n        int minright = INT_MAX;\\n        for(auto it:left)maxleft = max(it,maxleft);\\n        for(auto it:right)minright = min(it,minright);\\n\\n        return max(maxleft,n-minright);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int maxleft = 0;\\n        int minright = INT_MAX;\\n        for(auto it:left)maxleft = max(it,maxleft);\\n        for(auto it:right)minright = min(it,minright);\\n\\n        return max(maxleft,n-minright);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3110436,
                "title": "very-easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int getLastMoment(int n, int[] left, int[] right)\\n    {\\n        int ans=Integer.MIN_VALUE;\\n        \\n        if(left.length>0)\\n        {\\n            for(int i:left)\\n            {\\n                ans=Math.max(ans,i);\\n            }\\n        }\\n        \\n        if(right.length>0)\\n        {\\n            for(int i:right)\\n            {\\n                ans=Math.max(ans,n-i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int getLastMoment(int n, int[] left, int[] right)\\n    {\\n        int ans=Integer.MIN_VALUE;\\n        \\n        if(left.length>0)\\n        {\\n            for(int i:left)\\n            {\\n                ans=Math.max(ans,i);\\n            }\\n        }\\n        \\n        if(right.length>0)\\n        {\\n            for(int i:right)\\n            {\\n                ans=Math.max(ans,n-i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109324,
                "title": "c-very-easy-solution-o-n",
                "content": "# Please UpVote if it helps you\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int ans = 0;\\n        for(auto x:left){\\n            ans = max(ans,x);\\n        }\\n        for(auto x:right){\\n            ans = max(ans,n-x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int ans = 0;\\n        for(auto x:left){\\n            ans = max(ans,x);\\n        }\\n        for(auto x:right){\\n            ans = max(ans,n-x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2986868,
                "title": "simplest-c-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint getLastMoment(int n, int* left, int leftSize, int* right, int rightSize){\\n   \\n\\n    int arrl[100001] = {0};\\n    int arrr[100001] = {0};\\n\\n    int numl = leftSize;\\n    int numr = rightSize;\\n    \\n    int maxt = 0;\\n    int maxl = -1;\\n    int minr = 999999;\\n    \\n\\n\\n    for(int i = 0 ; i < leftSize ;i++)\\n    {\\n         arrl[left[i]] = 1;\\n         maxl = maxl > left[i]?maxl:left[i];\\n\\n    }\\n   \\n    for(int i = 0 ; i < rightSize ;i++)\\n    {\\n         arrr[right[i]] = 1;\\n         minr = minr < right[i]?minr:right[i];\\n\\n    }\\n    if(leftSize == 0)\\n    return n-minr;\\n    else if(rightSize == 0)\\n    return maxl;\\n    \\n    else\\n    {\\n        maxt = maxl > n-minr ? maxl : n-minr;\\n    }\\n    return maxt;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint getLastMoment(int n, int* left, int leftSize, int* right, int rightSize){\\n   \\n\\n    int arrl[100001] = {0};\\n    int arrr[100001] = {0};\\n\\n    int numl = leftSize;\\n    int numr = rightSize;\\n    \\n    int maxt = 0;\\n    int maxl = -1;\\n    int minr = 999999;\\n    \\n\\n\\n    for(int i = 0 ; i < leftSize ;i++)\\n    {\\n         arrl[left[i]] = 1;\\n         maxl = maxl > left[i]?maxl:left[i];\\n\\n    }\\n   \\n    for(int i = 0 ; i < rightSize ;i++)\\n    {\\n         arrr[right[i]] = 1;\\n         minr = minr < right[i]?minr:right[i];\\n\\n    }\\n    if(leftSize == 0)\\n    return n-minr;\\n    else if(rightSize == 0)\\n    return maxl;\\n    \\n    else\\n    {\\n        maxt = maxl > n-minr ? maxl : n-minr;\\n    }\\n    return maxt;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2974942,
                "title": "kotlin-so-long-but-work",
                "content": "maybe like me?\\n# Code\\n```\\nclass Solution {\\n    data class ant (\\n        var pos : Float,\\n        //left-false right-true\\n        var side: Boolean\\n    )\\n    fun getLastMoment(n: Int, left: IntArray, right: IntArray): Int {\\n        if (left.isEmpty()){\\n            if (right.min() == 0) return n\\n        }\\n        if (right.isEmpty()){\\n            if (left.max() == n) return n\\n        }\\n        var counter = 0.0f\\n        val ants = arrayListOf<ant>()\\n        for (i in left) ants.add(ant(i.toFloat(), false))\\n        for (i in right) ants.add(ant(i.toFloat(), true))\\n        while (ants.size != 0){\\n            counter += 0.5f\\n            for (i in ants){\\n                if (i.side == false){\\n                    i.pos -= 0.5f\\n                }\\n                if (i.side == true){\\n                    i.pos += 0.5f\\n                }\\n            }\\n            for ((index, item) in ants.withIndex()){\\n                if (index != 0){\\n                    if (item.pos == ants[index-1].pos){\\n                        if (item.side == false) {\\n                            ants[index].side = true\\n                            ants[index-1].side = false\\n                        } else {\\n                            ants[index].side = false\\n                            ants[index-1].side = true\\n                        }\\n                    }\\n                }\\n            }\\n            var timedCounter = 0\\n            for (index in ants.indices){\\n                if((ants[index- timedCounter].pos < 0) || (ants[index- timedCounter].pos > n.toFloat()) ){\\n                    ants.remove(ants[index - timedCounter])\\n                    timedCounter++\\n                }\\n            }\\n        }\\n        return counter.toInt()\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    data class ant (\\n        var pos : Float,\\n        //left-false right-true\\n        var side: Boolean\\n    )\\n    fun getLastMoment(n: Int, left: IntArray, right: IntArray): Int {\\n        if (left.isEmpty()){\\n            if (right.min() == 0) return n\\n        }\\n        if (right.isEmpty()){\\n            if (left.max() == n) return n\\n        }\\n        var counter = 0.0f\\n        val ants = arrayListOf<ant>()\\n        for (i in left) ants.add(ant(i.toFloat(), false))\\n        for (i in right) ants.add(ant(i.toFloat(), true))\\n        while (ants.size != 0){\\n            counter += 0.5f\\n            for (i in ants){\\n                if (i.side == false){\\n                    i.pos -= 0.5f\\n                }\\n                if (i.side == true){\\n                    i.pos += 0.5f\\n                }\\n            }\\n            for ((index, item) in ants.withIndex()){\\n                if (index != 0){\\n                    if (item.pos == ants[index-1].pos){\\n                        if (item.side == false) {\\n                            ants[index].side = true\\n                            ants[index-1].side = false\\n                        } else {\\n                            ants[index].side = false\\n                            ants[index-1].side = true\\n                        }\\n                    }\\n                }\\n            }\\n            var timedCounter = 0\\n            for (index in ants.indices){\\n                if((ants[index- timedCounter].pos < 0) || (ants[index- timedCounter].pos > n.toFloat()) ){\\n                    ants.remove(ants[index - timedCounter])\\n                    timedCounter++\\n                }\\n            }\\n        }\\n        return counter.toInt()\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2970479,
                "title": "simple-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int getLastMoment(int n, int[] left, int[] right) {\\n        int min=Integer.MAX_VALUE;\\n        int max=Integer.MIN_VALUE;\\n        for(int i=0;i<left.length;i++)\\n        {\\n            max=Math.max(max,left[i]);\\n        }\\n        for(int i=0;i<right.length;i++)\\n        {\\n            min=Math.min(min,right[i]);\\n        }\\n        return Math.max(n-min,max);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getLastMoment(int n, int[] left, int[] right) {\\n        int min=Integer.MAX_VALUE;\\n        int max=Integer.MIN_VALUE;\\n        for(int i=0;i<left.length;i++)\\n        {\\n            max=Math.max(max,left[i]);\\n        }\\n        for(int i=0;i<right.length;i++)\\n        {\\n            min=Math.min(min,right[i]);\\n        }\\n        return Math.max(n-min,max);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2929993,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        if not left:\\n            return n-min(right)\\n        if not right:\\n            return max(left)\\n        return max(max(left), n-min(right))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        if not left:\\n            return n-min(right)\\n        if not right:\\n            return max(left)\\n        return max(max(left), n-min(right))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2872833,
                "title": "super-easy",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[]} left\\n * @param {number[]} right\\n * @return {number}\\n */\\nvar getLastMoment = function(n, left, right) {\\n    var maxRight = n - Math.min(...right);\\n    var maxLeft = Math.max(...left);\\n\\n    if (left.length === 0) return maxRight;\\n    if (right.length === 0) return maxLeft;\\n\\n    return Math.max(maxRight, maxLeft);\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[]} left\\n * @param {number[]} right\\n * @return {number}\\n */\\nvar getLastMoment = function(n, left, right) {\\n    var maxRight = n - Math.min(...right);\\n    var maxLeft = Math.max(...left);\\n\\n    if (left.length === 0) return maxRight;\\n    if (right.length === 0) return maxLeft;\\n\\n    return Math.max(maxRight, maxLeft);\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2744389,
                "title": "direction-doesn-t-matter-python",
                "content": "```\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        if len(left)>0 and len(right)>0:\\n            return max(max(left), max([n-x for x in right]))\\n        elif len(left)>0 :\\n            return max(left)\\n        if len(right)>0:\\n            return max([n-x for x in right])\\n```",
                "solutionTags": [],
                "code": "```\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        if len(left)>0 and len(right)>0:\\n            return max(max(left), max([n-x for x in right]))\\n        elif len(left)>0 :\\n            return max(left)\\n        if len(right)>0:\\n            return max([n-x for x in right])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2725092,
                "title": "python-naive-brute-force-solution-o-n",
                "content": "# Problem explaination\\nThe problem is very tricky. No matter how many times the ants collide, since both the ants swap the directions, it can be considered that the ants continue in their same direction as with respect to the distance to reach the end of the plank remains the same.\\n\\n# Example\\n![image](https://assets.leetcode.com/users/images/ec4fdc26-c586-4f74-8fb4-d99a89a6e9bb_1666256108.727979.png)\\n\\n\\n\\tAnt \\'A\\' has to travel 4 steps to the right to exit the plank\\n\\tAnt \\'B\\' has to travel 3 steps to the right to exit the plank\\n\\tAnt \\'C\\' has to travel 3 steps to the left to exit the plank\\n\\tAnt \\'D\\' has to travel 4 steps to the left to exit the plank\\n\\t\\nEven though ants A and D will collide at 2 and reverse their directions, the distance to the exit remains the same. It can be said that their collision and reversal of the direction had no effect on the distance left to exit the plank.\\n\\n# Code\\n\\n```\\n\\t\\tif left == []:\\n            return n - min(right)\\n        if right == []:\\n            return max(left)\\n        return max(max(left), n - min(right))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\t\\tif left == []:\\n            return n - min(right)\\n        if right == []:\\n            return max(left)\\n        return max(max(left), n - min(right))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2695070,
                "title": "4-liner-python3",
                "content": "```\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        if not left:\\n            left = [0]\\n        if not right:\\n            right = [n]\\n        max_to_left = max(left)\\n        max_to_right = max([n - r for r in right])\\n        return max(max_to_left, max_to_right)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        if not left:\\n            left = [0]\\n        if not right:\\n            right = [n]\\n        max_to_left = max(left)\\n        max_to_right = max([n - r for r in right])\\n        return max(max_to_left, max_to_right)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2692866,
                "title": "c",
                "content": "```\\nint getLastMoment(int n, int* left, int leftSize, int* right, int rightSize){\\n    //right , find min\\n    int R = INT_MAX;    \\n    for(int i = 0; i < rightSize; i++){\\n        if(right[i] < R)\\n            R = right[i] ;\\n    }    \\n    R = n - R;\\n    \\n    //left, find max\\n    int L = INT_MIN;    \\n    for(int i = 0; i < leftSize; i++){\\n        if(left[i] > L)\\n            L = left[i] ;\\n    }    \\n    \\n    if(leftSize == 0)\\n        return R;\\n    if(rightSize == 0)\\n        return L;\\n    \\n    return fmax(L, R);\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint getLastMoment(int n, int* left, int leftSize, int* right, int rightSize){\\n    //right , find min\\n    int R = INT_MAX;    \\n    for(int i = 0; i < rightSize; i++){\\n        if(right[i] < R)\\n            R = right[i] ;\\n    }    \\n    R = n - R;\\n    \\n    //left, find max\\n    int L = INT_MIN;    \\n    for(int i = 0; i < leftSize; i++){\\n        if(left[i] > L)\\n            L = left[i] ;\\n    }    \\n    \\n    if(leftSize == 0)\\n        return R;\\n    if(rightSize == 0)\\n        return L;\\n    \\n    return fmax(L, R);\\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2621940,
                "title": "python-one-liner",
                "content": "```python\\nclass Solution(object):\\n    def getLastMoment(self, n, left, right):\\n        \"\"\"\\n        :type n: int\\n        :type left: List[int]\\n        :type right: List[int]\\n        :rtype: int\\n        \"\"\"\\n        return max(max([0]+left), n-min(right+[n]))\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def getLastMoment(self, n, left, right):\\n        \"\"\"\\n        :type n: int\\n        :type left: List[int]\\n        :type right: List[int]\\n        :rtype: int\\n        \"\"\"\\n        return max(max([0]+left), n-min(right+[n]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2584271,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int a,b;\\n        int time_left;\\n        if(left.empty())time_left=0;\\n        else {\\n            a = *max_element(left.begin(),left.end());\\n            time_left=a;\\n        }       \\n    \\n        int time_right;\\n        if(right.empty())time_right=0;\\n        else{\\n            b=*min_element(right.begin(),right.end());\\n            time_right=n-b;\\n        }\\n        \\n        \\n        return max(time_left,time_right);\\n    \\n        \\n    \\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int a,b;\\n        int time_left;\\n        if(left.empty())time_left=0;\\n        else {\\n            a = *max_element(left.begin(),left.end());\\n            time_left=a;\\n        }       \\n    \\n        int time_right;\\n        if(right.empty())time_right=0;\\n        else{\\n            b=*min_element(right.begin(),right.end());\\n            time_right=n-b;\\n        }\\n        \\n        \\n        return max(time_left,time_right);\\n    \\n        \\n    \\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2581318,
                "title": "python-no-need-for-considering-meeting-staff",
                "content": "```\\nLet us see the left-running ant as [1] and right-running ant at [3].\\nThey will meet at 2 and the left-running and right-running are [2] and [2]\\nAfter they changing the direction, the left-running and right-running are still [2] and [2]\\nNO changes for direction changes after the meeting. \\n```\\n\\n```\\ndef getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n\\treturn max(max(left or [0]), n-min(right or [n]))\\n```",
                "solutionTags": [],
                "code": "```\\nLet us see the left-running ant as [1] and right-running ant at [3].\\nThey will meet at 2 and the left-running and right-running are [2] and [2]\\nAfter they changing the direction, the left-running and right-running are still [2] and [2]\\nNO changes for direction changes after the meeting. \\n```\n```\\ndef getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n\\treturn max(max(left or [0]), n-min(right or [n]))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2518596,
                "title": "java-solution",
                "content": "Change in ant\\'s direction does not matter.\\nWhy?\\nBecause we cannot distinguish between two ants. So if two ants A1 and A2 meet and change directions, it is as good as they don\\'t change direction because still we have two ants moving in either directions.\\n\\n```\\npublic int getLastMoment(int n, int[] left, int[] right) {\\n\\tif (left.length == 0)\\n\\t\\treturn n - Arrays.stream(right).min().getAsInt();\\n\\n\\tif (right.length == 0)\\n\\t\\treturn Arrays.stream(left).max().getAsInt();\\n\\n\\treturn Math.max(\\n\\t\\t\\t\\tArrays.stream(left).max().getAsInt(),\\n\\t\\t\\t\\tn - Arrays.stream(right).min().getAsInt()\\n\\t\\t\\t);\\n}\\n```\\n\\nTC : O(N)\\nSC : O(1)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int getLastMoment(int n, int[] left, int[] right) {\\n\\tif (left.length == 0)\\n\\t\\treturn n - Arrays.stream(right).min().getAsInt();\\n\\n\\tif (right.length == 0)\\n\\t\\treturn Arrays.stream(left).max().getAsInt();\\n\\n\\treturn Math.max(\\n\\t\\t\\t\\tArrays.stream(left).max().getAsInt(),\\n\\t\\t\\t\\tn - Arrays.stream(right).min().getAsInt()\\n\\t\\t\\t);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2483247,
                "title": "python-solution-but-too-slow",
                "content": "any idea how to further speed up this simulation-based approach or why it will fail due to *Time Limit Exceeded* with an approaching 6924\\n\\n```python\\nclass Solution:\\n\\n    def getLastMoment(self, n: int, left: list[int], right: list[int]) -> int:\\n\\n        #print(\"=====-----=====\")\\n\\n        def shift_with_zeros(l: list, direction=\"left\") -> list:\\n            if len(l) == 0:\\n                return [0]\\n            if direction == \"right\":\\n                l.pop(-1)\\n                l = [0] + l\\n                return l\\n            if direction == \"left\":\\n                l.pop(0)\\n                l = l + [0]\\n                return l\\n            \\n        def done(left_to_right: list, right_to_left: list) -> bool:\\n            done_left = not(any(i == 1 for i in left_to_right))\\n            done_right = not(any(i == 1 for i in right_to_left))\\n            return done_left and done_right\\n        \\n        left_to_right = [1 if i in right else 0 for i in range(n + 1)]\\n        right_to_left = [1 if i in left else 0 for i in range(n + 1)]\\n\\n        #print(\"left_to_right\", left_to_right, \"right_to_left\", right_to_left)\\n        go_on = not(done(left_to_right, right_to_left))\\n        #print(\"go_on: \", go_on)\\n\\n        t = 0\\n        while go_on:\\n            left_to_right = shift_with_zeros(left_to_right, direction=\"right\")\\n            right_to_left = shift_with_zeros(right_to_left, direction=\"left\")\\n            #print(\"left_to_right\", left_to_right, \"right_to_left\", right_to_left)\\n            go_on = not(done(left_to_right, right_to_left))\\n            #print(\"go_on: \", go_on)\\n            t += 1\\n        #print(t)\\n        return t - 1 # actually its t -1 + 0.000001 ms basically\\n\\n    #getLastMoment(n=5, left=[1], right=[3])\\n\\n    #getLastMoment(n=7, left=[], right=[0,1,2,3,4,5,6,7])\\n\\n#Solution()\\n\\n```\\ni know there\\'s easier ways to obtain the result :)\\n\\nremoving the 0 padding - which was only for easier debugging - does not do the trick :D\\nthanks",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n\\n    def getLastMoment(self, n: int, left: list[int], right: list[int]) -> int:\\n\\n        #print(\"=====-----=====\")\\n\\n        def shift_with_zeros(l: list, direction=\"left\") -> list:\\n            if len(l) == 0:\\n                return [0]\\n            if direction == \"right\":\\n                l.pop(-1)\\n                l = [0] + l\\n                return l\\n            if direction == \"left\":\\n                l.pop(0)\\n                l = l + [0]\\n                return l\\n            \\n        def done(left_to_right: list, right_to_left: list) -> bool:\\n            done_left = not(any(i == 1 for i in left_to_right))\\n            done_right = not(any(i == 1 for i in right_to_left))\\n            return done_left and done_right\\n        \\n        left_to_right = [1 if i in right else 0 for i in range(n + 1)]\\n        right_to_left = [1 if i in left else 0 for i in range(n + 1)]\\n\\n        #print(\"left_to_right\", left_to_right, \"right_to_left\", right_to_left)\\n        go_on = not(done(left_to_right, right_to_left))\\n        #print(\"go_on: \", go_on)\\n\\n        t = 0\\n        while go_on:\\n            left_to_right = shift_with_zeros(left_to_right, direction=\"right\")\\n            right_to_left = shift_with_zeros(right_to_left, direction=\"left\")\\n            #print(\"left_to_right\", left_to_right, \"right_to_left\", right_to_left)\\n            go_on = not(done(left_to_right, right_to_left))\\n            #print(\"go_on: \", go_on)\\n            t += 1\\n        #print(t)\\n        return t - 1 # actually its t -1 + 0.000001 ms basically\\n\\n    #getLastMoment(n=5, left=[1], right=[3])\\n\\n    #getLastMoment(n=7, left=[], right=[0,1,2,3,4,5,6,7])\\n\\n#Solution()\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2448565,
                "title": "c-easy-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right){\\n        \\n        if(left.size()!=0 && right.size()!=0)\\n        {\\n            int l=*max_element(left.begin(),left.end());\\n            int r=n-*min_element(right.begin(),right.end());\\n            \\n        return max(l,r);\\n        }\\n        else\\n        {\\n            if(left.size()==0)\\n            {\\n                return n-*min_element(right.begin(),right.end());\\n            }\\n            else\\n            {\\n               return *max_element(left.begin(),left.end()); \\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right){\\n        \\n        if(left.size()!=0 && right.size()!=0)\\n        {\\n            int l=*max_element(left.begin(),left.end());\\n            int r=n-*min_element(right.begin(),right.end());\\n            \\n        return max(l,r);\\n        }\\n        else\\n        {\\n            if(left.size()==0)\\n            {\\n                return n-*min_element(right.begin(),right.end());\\n            }\\n            else\\n            {\\n               return *max_element(left.begin(),left.end()); \\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2384371,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int getLastMoment(int n, int[] left, int[] right) {\\n        int max = 0;\\n        for (int i = 0; i < left.length; i++) {\\n            if (left[i] > max)\\n                max = left[i];\\n        }\\n        for (int i = 0; i < right.length; i++) {\\n            if (n - right[i] > max)\\n                max = n - right[i];\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getLastMoment(int n, int[] left, int[] right) {\\n        int max = 0;\\n        for (int i = 0; i < left.length; i++) {\\n            if (left[i] > max)\\n                max = left[i];\\n        }\\n        for (int i = 0; i < right.length; i++) {\\n            if (n - right[i] > max)\\n                max = n - right[i];\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2362975,
                "title": "c-easy-o-n-time-and-o-1-space-solution",
                "content": "No matter the collision, the ants follow the same path\\n```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        // we need minimum left and max right positon\\n        int min_right = n+1;\\n        for(int& val:right)\\n        {\\n            min_right = min(min_right,val);\\n        }\\n        int max_left= -1;\\n        for(int& val:left)\\n        {\\n            max_left = max(max_left,val);\\n        }\\n        if(min_right != n+1 && max_left != -1)\\n        {\\n            return max(n-min_right,max_left);\\n        }\\n        else if(min_right != n+1)\\n        {\\n            return n-min_right;\\n        }\\n        else\\n        {\\n            return max_left;\\n        }\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        // we need minimum left and max right positon\\n        int min_right = n+1;\\n        for(int& val:right)\\n        {\\n            min_right = min(min_right,val);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2329474,
                "title": "c-easy-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int mx=0;\\n        for(auto&i:left)mx=max(mx,i);\\n        for(auto&i:right)mx=max(mx,n-i);\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int mx=0;\\n        for(auto&i:left)mx=max(mx,i);\\n        for(auto&i:right)mx=max(mx,n-i);\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2318073,
                "title": "simple-array-traversal",
                "content": "Simply traverse both array and find maximum distance the ant need to travel to reach end.\\n```\\nclass Solution {\\n    public int getLastMoment(int n, int[] left, int[] right) {\\n        int ans=0;\\n        for(int i=0;i<left.length;i++){\\n            ans=Math.max(left[i],ans);\\n        }\\n        for(int i=0;i<right.length;i++){\\n            ans=Math.max(n-right[i],ans);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int getLastMoment(int n, int[] left, int[] right) {\\n        int ans=0;\\n        for(int i=0;i<left.length;i++){\\n            ans=Math.max(left[i],ans);\\n        }\\n        for(int i=0;i<right.length;i++){\\n            ans=Math.max(n-right[i],ans);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2316647,
                "title": "c-two-pointer",
                "content": "* Ants changing directions and moving again means the same as-> both ants continue to walk after crossing each other.\\n\\n* Each ant willl have to cover whole length from the position where they are standing now to the either end of plank.\\n\\n* check the distance covered by every ant and take max.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        sort(begin(left),end(left)) ;\\n        sort(begin(right),end(right)) ;\\n        \\n        int l = 0 , r = 0 , T = 0 ;\\n        while(l < left.size() and r < right.size()){\\n            T = max({T,left[l],n-right[r]});\\n            if(left[l] < right[r]) ++l ;\\n            else ++r ;\\n        }\\n        while(l < left.size()) T = max({T,left[l++]}) ;\\n        while(r < right.size()) T = max({T,n-right[r++]}) ;\\n        \\n        return T ;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        sort(begin(left),end(left)) ;\\n        sort(begin(right),end(right)) ;\\n        \\n        int l = 0 , r = 0 , T = 0 ;\\n        while(l < left.size() and r < right.size()){\\n            T = max({T,left[l],n-right[r]});\\n            if(left[l] < right[r]) ++l ;\\n            else ++r ;\\n        }\\n        while(l < left.size()) T = max({T,left[l++]}) ;\\n        while(r < right.size()) T = max({T,n-right[r++]}) ;\\n        \\n        return T ;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2266617,
                "title": "3-liner-easy-sol-explained-cpp",
                "content": "Here, even if the ants collide/change direction, the total distance covered stays the same. Also, the max distance covered will be equal to max distance covered by the ants close to **start index in case of right** and **end index in case of left.**\\n```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        if(!left.size()) return n-*min_element(right.begin(), right.end());\\n        if(!right.size()) return *max_element(left.begin(), left.end());\\n        return max(n-*min_element(right.begin(), right.end()), *max_element(left.begin(), left.end()));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        if(!left.size()) return n-*min_element(right.begin(), right.end());\\n        if(!right.size()) return *max_element(left.begin(), left.end());\\n        return max(n-*min_element(right.begin(), right.end()), *max_element(left.begin(), left.end()));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2245839,
                "title": "c-maths-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int n1=0,n2=0;\\n        if(left.size()>0)  n1=*max_element(left.begin(),left.end());\\n        if(right.size()>0)  n2=n-*min_element(right.begin(),right.end());\\n        return max(n1,n2);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int n1=0,n2=0;\\n        if(left.size()>0)  n1=*max_element(left.begin(),left.end());\\n        if(right.size()>0)  n2=n-*min_element(right.begin(),right.end());\\n        return max(n1,n2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2223092,
                "title": "java-using-both-for-loop-ans-for-each-loop",
                "content": "**First Solution**\\n\\n```\\nclass Solution {\\n    public int getLastMoment(int n, int[] left, int[] right) {\\n        int max=0;\\n        \\n         for(int l:left)\\n            max=Math.max(max,l);\\n         \\n         for(int r:right)\\n             max=Math.max(max,n-r);\\n        \\n        return max;\\n```\\n**Second Solution**  \\n\\n```\\nclass Solution {\\n    public int getLastMoment(int n, int[] left, int[] right) {\\n        int max = 0;\\n        for(int i=0;i<left.length;i++){\\n            max=Math.max(max,left[i]);\\n        }\\n        for(int i=0;i<right.length;i++){\\n            max=Math.max(max,n-right[i]);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getLastMoment(int n, int[] left, int[] right) {\\n        int max=0;\\n        \\n         for(int l:left)\\n            max=Math.max(max,l);\\n         \\n         for(int r:right)\\n             max=Math.max(max,n-r);\\n        \\n        return max;\\n```\n```\\nclass Solution {\\n    public int getLastMoment(int n, int[] left, int[] right) {\\n        int max = 0;\\n        for(int i=0;i<left.length;i++){\\n            max=Math.max(max,left[i]);\\n        }\\n        for(int i=0;i<right.length;i++){\\n            max=Math.max(max,n-right[i]);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2060394,
                "title": "python-readable-solution",
                "content": "This one more like a math problem. Key points are as follow.\\nFirst, all the ants move along the plank, no up or down direction;\\nSecond, all the ants move with the same speed, all the same;\\nThird, the turning back process proceed simutaneously, costs no time at all.\\nTherefore, we can ASSUME that when two ants meet at any position, they just change their name card but not turning back, and moving along the same direction with same speed. \\n**Simulating the process with some random list might help. **\\n```\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        if left and right:\\n            return max(n-min(right),max(left))\\n        else:\\n            return n-min(right) if right else max(left)\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        if left and right:\\n            return max(n-min(right),max(left))\\n        else:\\n            return n-min(right) if right else max(left)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2015740,
                "title": "1-liner",
                "content": "We can act like ants just pass through each other without interfering.\\n```\\ndef getLastMoment(self, n, l, r):\\n\\treturn max(n-min(r or [n]), max(l or [0]));\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef getLastMoment(self, n, l, r):\\n\\treturn max(n-min(r or [n]), max(l or [0]));\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2013802,
                "title": "changing-direction-is-a-rat-trap-in-question",
                "content": "there wont be any effect in the final answer if the ant changes direction or not \\njust simply compare the time taken by last element in the left vector and the first element in the right vector(sort the vector first)\\n\\n```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right){\\n        \\n        sort(left.begin(),left.end());\\n        sort(right.begin(),right.end());\\n        \\n        if(!right.size()) return left.back();\\n        if(!left.size()) return n-right[0];\\n        \\n        return max(n-right[0],left.back());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right){\\n        \\n        sort(left.begin(),left.end());\\n        sort(right.begin(),right.end());\\n        \\n        if(!right.size()) return left.back();\\n        if(!left.size()) return n-right[0];\\n        \\n        return max(n-right[0],left.back());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953035,
                "title": "python-simple-mathematical-solution",
                "content": "1)We are given length of the wooden plank n . \\n2)Pick the maximum value from the left array and subtract with 0 i.e max(left)-0\\n3)Pick the minimum value from the right array and subtract with n i.e n-min(right)\\n4)Return the maximum difference i.e \\'max(n-min(right),max(left)-0)\\' . \\n```\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        if n==0:return 0\\n        if len(left)==0:return n-min(right)\\n        if len(right)==0:return max(left)-0\\n        if len(left) and len(right):\\n            return max(n-min(right),max(left)-0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        if n==0:return 0\\n        if len(left)==0:return n-min(right)\\n        if len(right)==0:return max(left)-0\\n        if len(left) and len(right):\\n            return max(n-min(right),max(left)-0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935784,
                "title": "c-easy-to-understand-simple-code",
                "content": "Find the min position from  right array and max postion from left array the maximum distance is the answer \\n\\n```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int ans=0;\\n        \\n        int rightpos=INT_MAX;\\n        for(int i=0;i<right.size();i++)\\n        {\\n            rightpos=min(rightpos,right[i]);\\n        }\\n        \\n        int leftpos=INT_MIN;\\n        \\n        for(int i=0;i<left.size();i++)\\n        {\\n            leftpos=max(leftpos,left[i]);\\n        }\\n        \\n        if(leftpos==INT_MIN)\\n        {\\n            return n-rightpos;\\n        }\\n        if(rightpos==INT_MAX)\\n        {\\n            return leftpos;\\n        }\\n        return max(n-rightpos,leftpos);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\\n        int ans=0;\\n        \\n        int rightpos=INT_MAX;\\n        for(int i=0;i<right.size();i++)\\n        {\\n            rightpos=min(rightpos,right[i]);\\n        }\\n        \\n        int leftpos=INT_MIN;\\n        \\n        for(int i=0;i<left.size();i++)\\n        {\\n            leftpos=max(leftpos,left[i]);\\n        }\\n        \\n        if(leftpos==INT_MIN)\\n        {\\n            return n-rightpos;\\n        }\\n        if(rightpos==INT_MAX)\\n        {\\n            return leftpos;\\n        }\\n        return max(n-rightpos,leftpos);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1885364,
                "title": "c-solution-with-mathematical-explanation",
                "content": "\\nint getLastMoment(int n, int* left, int n_l, int* right, int n_r){\\n    \\n    /*\\n    ----------A-------------B---------\\n    Assume A is going right and B is going left\\n    The two ants meet at t such that their locations are equal:\\n    A + 1t = B - 1t (since the speed of the ant is 1 unit)\\n    2t = B - A ---> t = (B-A)/2\\n    Ant1 travels (B-A)/2 then all the way back to the beginning (A + (B-A)/2) = B\\n    Ant2 travels (B-A)/2 then all the way back to the end N - (B - (B-A)/2) = N - A\\n    calcuate A such that it is the farthest right ant from the beginning\\n    calculate B such that it is the closest left ant to the end\\n    return the maximum between N - A and B\\n    \\n    */\\n   int i, left_most = 0, right_most = n;\\n    \\n   for(i = 0; i < n_l; i++)\\n      left_most = fmax(left_most, left[i]);\\n        \\n   for(i = 0; i < n_r; i++)\\n      right_most = fmin(right_most, right[i]);\\n    \\n\\n   return fmax(left_most, n - right_most);\\n}\\n\\n",
                "solutionTags": [],
                "code": "\\nint getLastMoment(int n, int* left, int n_l, int* right, int n_r){\\n    \\n    /*\\n    ----------A-------------B---------\\n    Assume A is going right and B is going left\\n    The two ants meet at t such that their locations are equal:\\n    A + 1t = B - 1t (since the speed of the ant is 1 unit)\\n    2t = B - A ---> t = (B-A)/2\\n    Ant1 travels (B-A)/2 then all the way back to the beginning (A + (B-A)/2) = B\\n    Ant2 travels (B-A)/2 then all the way back to the end N - (B - (B-A)/2) = N - A\\n    calcuate A such that it is the farthest right ant from the beginning\\n    calculate B such that it is the closest left ant to the end\\n    return the maximum between N - A and B\\n    \\n    */\\n   int i, left_most = 0, right_most = n;\\n    \\n   for(i = 0; i < n_l; i++)\\n      left_most = fmax(left_most, left[i]);\\n        \\n   for(i = 0; i < n_r; i++)\\n      right_most = fmin(right_most, right[i]);\\n    \\n\\n   return fmax(left_most, n - right_most);\\n}\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1775979,
                "title": "ants-fall-out-of-plank-simple-solution-using-java",
                "content": "```\\nclass Solution {\\n    public int getLastMoment(int n, int[] left, int[] right) {\\n        int maxLeft = 0;\\n        if(left.length > 0)\\n            maxLeft = Arrays.stream(left).max().getAsInt();\\n        \\n        \\n        int maxRight = 0;\\n        if(right.length > 0)\\n            maxRight = n - Arrays.stream(right).min().getAsInt();\\n        \\n        return Math.max(maxLeft, maxRight);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int getLastMoment(int n, int[] left, int[] right) {\\n        int maxLeft = 0;\\n        if(left.length > 0)\\n            maxLeft = Arrays.stream(left).max().getAsInt();\\n        \\n        \\n        int maxRight = 0;\\n        if(right.length > 0)\\n            maxRight = n - Arrays.stream(right).min().getAsInt();\\n        \\n        return Math.max(maxLeft, maxRight);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1703412,
                "title": "ants-in-the-hard-way-simulation-python-3",
                "content": "Leetcoding is about \"problem solving skill\" This problem is not an except as usual. \\nCheck @lee215\\'s solution for interview.\\n\\nIn terms of curiosity, here\\'s my simulation following the rules literally.\\n\\nEvery 0.5s, update those ants accordingly\\n1. if out of plank, don\\'t add to nxt dict\\n2. if meet, change direction perspectively\\n3. ow, move 0.5 unit\\n\\nWe just need dict `{pos: [dir]}` to record all ants\\' states since no more than 2 ants will be in same pos, and if they do, they must in `meet` state.\\n\\nDuring the loop, I used the common double containers trick as in BFS, to prevent `RuntimeError: dictionary changed size during iteartion.`\\n\\n```\\ndef fxr_simu():\\n\\t\"\"\"\\n\\tTLE: 137 / 167 test cases passed.\\n\\n\\tn=3305, left=[...], right=[...]\\n\\t\"\"\"\\n\\tcur = defaultdict(list)  # [[dir,clk]]\\n\\tfor i in left:\\n\\t\\tcur[i].append(-1)\\n\\tfor i in right:\\n\\t\\tcur[i].append(1)\\n\\tt = 0\\n\\n\\twhile cur:\\n\\t\\t# print(t, \\'\\\\t\\', cur)\\n\\n\\t\\tnxt = defaultdict(list)\\n\\t\\tfor p in sorted(list(cur)):\\n\\t\\t\\t# meet/reverse, update\\n\\t\\t\\tif len(cur[p]) == 2:\\n\\t\\t\\t\\tnxt[p + 0.5].append(1)\\n\\t\\t\\t\\tnxt[p - 0.5].append(-1)\\n\\n\\t\\t\\t# regular update\\n\\t\\t\\telse:\\n\\t\\t\\t\\tif cur[p]:\\n\\t\\t\\t\\t\\td = cur[p].pop()\\n\\t\\t\\t\\t\\t# remove out\\n\\t\\t\\t\\t\\tif p == 0 and d == -1:\\n\\t\\t\\t\\t\\t\\t# noop\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\telif p == n and d == 1:\\n\\t\\t\\t\\t\\t\\t# noop\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tnxt[p + d * 0.5].append(d)\\n\\n\\t\\tcur = nxt\\n\\t\\tt += 0.5\\n\\treturn math.floor(t - 0.1)\\n```",
                "solutionTags": [
                    "Python3",
                    "Simulation"
                ],
                "code": "```\\ndef fxr_simu():\\n\\t\"\"\"\\n\\tTLE: 137 / 167 test cases passed.\\n\\n\\tn=3305, left=[...], right=[...]\\n\\t\"\"\"\\n\\tcur = defaultdict(list)  # [[dir,clk]]\\n\\tfor i in left:\\n\\t\\tcur[i].append(-1)\\n\\tfor i in right:\\n\\t\\tcur[i].append(1)\\n\\tt = 0\\n\\n\\twhile cur:\\n\\t\\t# print(t, \\'\\\\t\\', cur)\\n\\n\\t\\tnxt = defaultdict(list)\\n\\t\\tfor p in sorted(list(cur)):\\n\\t\\t\\t# meet/reverse, update\\n\\t\\t\\tif len(cur[p]) == 2:\\n\\t\\t\\t\\tnxt[p + 0.5].append(1)\\n\\t\\t\\t\\tnxt[p - 0.5].append(-1)\\n\\n\\t\\t\\t# regular update\\n\\t\\t\\telse:\\n\\t\\t\\t\\tif cur[p]:\\n\\t\\t\\t\\t\\td = cur[p].pop()\\n\\t\\t\\t\\t\\t# remove out\\n\\t\\t\\t\\t\\tif p == 0 and d == -1:\\n\\t\\t\\t\\t\\t\\t# noop\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\telif p == n and d == 1:\\n\\t\\t\\t\\t\\t\\t# noop\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tnxt[p + d * 0.5].append(d)\\n\\n\\t\\tcur = nxt\\n\\t\\tt += 0.5\\n\\treturn math.floor(t - 0.1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1692714,
                "title": "java-solution",
                "content": "class Solution {\\n    public int getLastMoment(int n, int[] left, int[] right) {\\n        int highestLeft = 0;\\n        int smallestRight = Integer.MAX_VALUE;\\n        for(int i=0;i<= n+1; i++) {\\n            if (i < left.length && left[i] > highestLeft)\\n                highestLeft = left[i];\\n            \\n            if (i < right.length && right[i] < smallestRight) \\n                smallestRight = right[i];\\n        }\\n        \\n        if(left.length != 0 && right.length == 0) return highestLeft;\\n        if(right.length != 0 && left.length == 0) return Math.abs(smallestRight - n);\\n        \\n        return highestLeft >= Math.abs(smallestRight - n) ? highestLeft: Math.abs(smallestRight - n);\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int getLastMoment(int n, int[] left, int[] right) {\\n        int highestLeft = 0;\\n        int smallestRight = Integer.MAX_VALUE;\\n        for(int i=0;i<= n+1; i++) {\\n            if (i < left.length && left[i] > highestLeft)\\n                highestLeft = left[i];\\n            \\n            if (i < right.length && right[i] < smallestRight) \\n                smallestRight = right[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1581488,
                "title": "brain-teaser-questions-strike-back",
                "content": "This one and egg dropping question remind me when I first read both questions as brain teaser questions. Tech companies stop asking brain teaser questions since couple of years ago. But now the tide turns over and we see more and more brain teaser questions coming back as algorithm questions.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1545188,
                "title": "go",
                "content": "```\\nfunc getLastMoment(n int, left []int, right []int) int {\\n    sort.Ints(left)\\n    sort.Ints(right)\\n    a, b := 0, 0\\n    if len(left) > 0 {\\n        a = left[len(left) - 1]\\n    }\\n    if len(right) > 0 {\\n        b = n - right[0]\\n    }\\n    \\n    if a > b {\\n        return a\\n    } else {\\n        return b\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc getLastMoment(n int, left []int, right []int) int {\\n    sort.Ints(left)\\n    sort.Ints(right)\\n    a, b := 0, 0\\n    if len(left) > 0 {\\n        a = left[len(left) - 1]\\n    }\\n    if len(right) > 0 {\\n        b = n - right[0]\\n    }\\n    \\n    if a > b {\\n        return a\\n    } else {\\n        return b\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1535939,
                "title": "c-solution",
                "content": "Time O(n) Space O(1)\\n```\\n    public int GetLastMoment(int n, int[] left, int[] right) {\\n        int ret=0;\\n        ret=left.Any()?left.Max():0;\\n        ret=Math.Max(ret,right.Any()?right.Max(x=>n-x):0);\\n        return ret;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int GetLastMoment(int n, int[] left, int[] right) {\\n        int ret=0;\\n        ret=left.Any()?left.Max():0;\\n        ret=Math.Max(ret,right.Any()?right.Max(x=>n-x):0);\\n        return ret;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1514222,
                "title": "java-solution",
                "content": "\\tclass Solution {\\n    public int getLastMoment(int n, int[] left, int[] right) {\\n        int maxLeft = 0;\\n        for(int i=0; i<left.length; i++){\\n            maxLeft = Math.max(maxLeft, left[i]);\\n        }\\n        int time1 = Math.abs(0-maxLeft);\\n        \\n        int minRight = Integer.MAX_VALUE;\\n        for(int i=0; i<right.length; i++){\\n            minRight = Math.min(minRight, right[i]);\\n        }\\n        minRight = minRight == Integer.MAX_VALUE ? n : minRight;\\n        int time2 = n - minRight;\\n            \\n        return Math.max(time1, time2);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int getLastMoment(int n, int[] left, int[] right) {\\n        int maxLeft = 0;\\n        for(int i=0; i<left.length; i++){\\n            maxLeft = Math.max(maxLeft, left[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1502078,
                "title": "py-one-liner-hahahahaha",
                "content": "```\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        return max(max(left, default=-1), n-min(right, default=n))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        return max(max(left, default=-1), n-min(right, default=n))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1471545,
                "title": "java-100-simple-code",
                "content": "```\\nclass Solution {\\n    public int getLastMoment(int n, int[] left, int[] right) {  \\n        \\n        int minright = n;\\n        int maxleft = 0;\\n        for(int i:right)\\n            minright = Math.min(minright,i);\\n        for(int i:left)\\n            maxleft = Math.max(maxleft,i);\\n        \\n        return Math.max(maxleft,n-minright);            \\n    }\\n}\\n```\\n**Upvote if helpful :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int getLastMoment(int n, int[] left, int[] right) {  \\n        \\n        int minright = n;\\n        int maxleft = 0;\\n        for(int i:right)\\n            minright = Math.min(minright,i);\\n        for(int i:left)\\n            maxleft = Math.max(maxleft,i);\\n        \\n        return Math.max(maxleft,n-minright);            \\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1570716,
                "content": [
                    {
                        "username": "gridz",
                        "content": "...i\\'m pretty sure it\\'s a banned question at alphabet and probably a few other places since it\\'s so popular.\\nthe key insight is that the collision rule doesn\\'t matter at all, the effect is the same as if the ants just phased through each other. once you realize it, the easy solution becomes obvious.\\ni don\\'t like this type of questions very much. it hinges on one epiphany and there\\'s no way to dig deeper or expand the discussion, doesn\\'t tell me a lot about candidate\\'s actual skills or thinking. i wouldn\\'t ask it in an interview and getting it in an interview would be a negative sign for me personally."
                    },
                    {
                        "username": "sroninio",
                        "content": "ants dont really change direction when the crash, each one keeps moving forward (we dont care that they changed names, they are still ants :-))"
                    },
                    {
                        "username": "atharva598",
                        "content": "Good problem, but they need to replace the depiction of the ants with a simple arrow. The current depiction only causes confusion about their direction."
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "Heart touching problem name. Justice for the ants"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": " **Ants are looking for some sugar out there. That's why they are riding on each other's back**  **):xd**"
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "looks like easy problem"
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "[@thehound](/thehound) the reason is integer overlap.  But in the contest it\\'s not the same problem in 2731 it needs to calculate all pairs in O(n) time, this ant problem only the first step  https://leetcode.com/problems/movement-of-robots/solutions/3622423/java-sorting-linear-scan/ \\n"
                    }
                ]
            },
            {
                "id": 1576004,
                "content": [
                    {
                        "username": "gridz",
                        "content": "...i\\'m pretty sure it\\'s a banned question at alphabet and probably a few other places since it\\'s so popular.\\nthe key insight is that the collision rule doesn\\'t matter at all, the effect is the same as if the ants just phased through each other. once you realize it, the easy solution becomes obvious.\\ni don\\'t like this type of questions very much. it hinges on one epiphany and there\\'s no way to dig deeper or expand the discussion, doesn\\'t tell me a lot about candidate\\'s actual skills or thinking. i wouldn\\'t ask it in an interview and getting it in an interview would be a negative sign for me personally."
                    },
                    {
                        "username": "sroninio",
                        "content": "ants dont really change direction when the crash, each one keeps moving forward (we dont care that they changed names, they are still ants :-))"
                    },
                    {
                        "username": "atharva598",
                        "content": "Good problem, but they need to replace the depiction of the ants with a simple arrow. The current depiction only causes confusion about their direction."
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "Heart touching problem name. Justice for the ants"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": " **Ants are looking for some sugar out there. That's why they are riding on each other's back**  **):xd**"
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "looks like easy problem"
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "[@thehound](/thehound) the reason is integer overlap.  But in the contest it\\'s not the same problem in 2731 it needs to calculate all pairs in O(n) time, this ant problem only the first step  https://leetcode.com/problems/movement-of-robots/solutions/3622423/java-sorting-linear-scan/ \\n"
                    }
                ]
            },
            {
                "id": 1927298,
                "content": [
                    {
                        "username": "gridz",
                        "content": "...i\\'m pretty sure it\\'s a banned question at alphabet and probably a few other places since it\\'s so popular.\\nthe key insight is that the collision rule doesn\\'t matter at all, the effect is the same as if the ants just phased through each other. once you realize it, the easy solution becomes obvious.\\ni don\\'t like this type of questions very much. it hinges on one epiphany and there\\'s no way to dig deeper or expand the discussion, doesn\\'t tell me a lot about candidate\\'s actual skills or thinking. i wouldn\\'t ask it in an interview and getting it in an interview would be a negative sign for me personally."
                    },
                    {
                        "username": "sroninio",
                        "content": "ants dont really change direction when the crash, each one keeps moving forward (we dont care that they changed names, they are still ants :-))"
                    },
                    {
                        "username": "atharva598",
                        "content": "Good problem, but they need to replace the depiction of the ants with a simple arrow. The current depiction only causes confusion about their direction."
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "Heart touching problem name. Justice for the ants"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": " **Ants are looking for some sugar out there. That's why they are riding on each other's back**  **):xd**"
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "looks like easy problem"
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "[@thehound](/thehound) the reason is integer overlap.  But in the contest it\\'s not the same problem in 2731 it needs to calculate all pairs in O(n) time, this ant problem only the first step  https://leetcode.com/problems/movement-of-robots/solutions/3622423/java-sorting-linear-scan/ \\n"
                    }
                ]
            },
            {
                "id": 2012214,
                "content": [
                    {
                        "username": "gridz",
                        "content": "...i\\'m pretty sure it\\'s a banned question at alphabet and probably a few other places since it\\'s so popular.\\nthe key insight is that the collision rule doesn\\'t matter at all, the effect is the same as if the ants just phased through each other. once you realize it, the easy solution becomes obvious.\\ni don\\'t like this type of questions very much. it hinges on one epiphany and there\\'s no way to dig deeper or expand the discussion, doesn\\'t tell me a lot about candidate\\'s actual skills or thinking. i wouldn\\'t ask it in an interview and getting it in an interview would be a negative sign for me personally."
                    },
                    {
                        "username": "sroninio",
                        "content": "ants dont really change direction when the crash, each one keeps moving forward (we dont care that they changed names, they are still ants :-))"
                    },
                    {
                        "username": "atharva598",
                        "content": "Good problem, but they need to replace the depiction of the ants with a simple arrow. The current depiction only causes confusion about their direction."
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "Heart touching problem name. Justice for the ants"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": " **Ants are looking for some sugar out there. That's why they are riding on each other's back**  **):xd**"
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "looks like easy problem"
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "[@thehound](/thehound) the reason is integer overlap.  But in the contest it\\'s not the same problem in 2731 it needs to calculate all pairs in O(n) time, this ant problem only the first step  https://leetcode.com/problems/movement-of-robots/solutions/3622423/java-sorting-linear-scan/ \\n"
                    }
                ]
            },
            {
                "id": 1935679,
                "content": [
                    {
                        "username": "gridz",
                        "content": "...i\\'m pretty sure it\\'s a banned question at alphabet and probably a few other places since it\\'s so popular.\\nthe key insight is that the collision rule doesn\\'t matter at all, the effect is the same as if the ants just phased through each other. once you realize it, the easy solution becomes obvious.\\ni don\\'t like this type of questions very much. it hinges on one epiphany and there\\'s no way to dig deeper or expand the discussion, doesn\\'t tell me a lot about candidate\\'s actual skills or thinking. i wouldn\\'t ask it in an interview and getting it in an interview would be a negative sign for me personally."
                    },
                    {
                        "username": "sroninio",
                        "content": "ants dont really change direction when the crash, each one keeps moving forward (we dont care that they changed names, they are still ants :-))"
                    },
                    {
                        "username": "atharva598",
                        "content": "Good problem, but they need to replace the depiction of the ants with a simple arrow. The current depiction only causes confusion about their direction."
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "Heart touching problem name. Justice for the ants"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": " **Ants are looking for some sugar out there. That's why they are riding on each other's back**  **):xd**"
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "looks like easy problem"
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "[@thehound](/thehound) the reason is integer overlap.  But in the contest it\\'s not the same problem in 2731 it needs to calculate all pairs in O(n) time, this ant problem only the first step  https://leetcode.com/problems/movement-of-robots/solutions/3622423/java-sorting-linear-scan/ \\n"
                    }
                ]
            },
            {
                "id": 1923852,
                "content": [
                    {
                        "username": "gridz",
                        "content": "...i\\'m pretty sure it\\'s a banned question at alphabet and probably a few other places since it\\'s so popular.\\nthe key insight is that the collision rule doesn\\'t matter at all, the effect is the same as if the ants just phased through each other. once you realize it, the easy solution becomes obvious.\\ni don\\'t like this type of questions very much. it hinges on one epiphany and there\\'s no way to dig deeper or expand the discussion, doesn\\'t tell me a lot about candidate\\'s actual skills or thinking. i wouldn\\'t ask it in an interview and getting it in an interview would be a negative sign for me personally."
                    },
                    {
                        "username": "sroninio",
                        "content": "ants dont really change direction when the crash, each one keeps moving forward (we dont care that they changed names, they are still ants :-))"
                    },
                    {
                        "username": "atharva598",
                        "content": "Good problem, but they need to replace the depiction of the ants with a simple arrow. The current depiction only causes confusion about their direction."
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "Heart touching problem name. Justice for the ants"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": " **Ants are looking for some sugar out there. That's why they are riding on each other's back**  **):xd**"
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "looks like easy problem"
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "[@thehound](/thehound) the reason is integer overlap.  But in the contest it\\'s not the same problem in 2731 it needs to calculate all pairs in O(n) time, this ant problem only the first step  https://leetcode.com/problems/movement-of-robots/solutions/3622423/java-sorting-linear-scan/ \\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Number of Swaps to Make the Binary String Alternating",
        "question_content": "<p>Given a binary string <code>s</code>, return <em>the <strong>minimum</strong> number of character swaps to make it <strong>alternating</strong>, or </em><code>-1</code><em> if it is impossible.</em></p>\n\n<p>The string is called <strong>alternating</strong> if no two adjacent characters are equal. For example, the strings <code>&quot;010&quot;</code> and <code>&quot;1010&quot;</code> are alternating, while the string <code>&quot;0100&quot;</code> is not.</p>\n\n<p>Any two characters may be swapped, even if they are&nbsp;<strong>not adjacent</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;111000&quot;\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> Swap positions 1 and 4: &quot;1<u>1</u>10<u>0</u>0&quot; -&gt; &quot;1<u>0</u>10<u>1</u>0&quot;\nThe string is now alternating.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;010&quot;\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The string is already alternating, no swaps are needed.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;1110&quot;\n<strong>Output:</strong> -1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s[i]</code> is either <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1211069,
                "title": "simplest-explanation-with-java-solution-100-faster",
                "content": "* The key to solve this problem is to count number of indexes which contain wrong character. So for string `s = 11001`, `count` will be 2 as characters at `s[1]` and `s[2]` are wrong. And number of swaps will be `count / 2`. For example, we can just swap character at index `1` and index `2` to obtain `s = 10101`.\\n\\n**Things to notice**\\n* Solving this problem will be impossible if difference between number of ones and number of zeros will be greater than 1.\\n\\n* If number of ones is greater than number of zeroes then `1` should be the first character of resulting string. Similarly if number of zeroes is greater than number of ones then `0` should be the first character of resulting string.\\n\\n* If number of ones is equal to number of zeroes, we will find minimum number of swaps of both cases:\\n    - Case 1 : `1` is the first character.\\n    - Case 2 : `0` is the first character.\\n\\n```java\\nclass Solution {\\n    public int minSwaps(String s) {\\n        int n = s.length();\\n        int ones = 0, zero = 0;\\n        for(char c : s.toCharArray()){\\n            if(c == \\'1\\')\\n                ++ones;\\n            else\\n                ++zero;\\n        }\\n        \\n        if(Math.abs(ones-zero) > 1)\\n            return -1;\\n        \\n        if(ones > zero)\\n            return helper(s, \\'1\\');\\n        else if(zero > ones)\\n            return helper(s, \\'0\\');\\n        \\n        return Math.min(helper(s, \\'1\\'), helper(s, \\'0\\'));\\n    }\\n    \\n    private int helper(String s, char c){\\n        int swaps = 0;\\n        for(char ch : s.toCharArray()){\\n            if(ch != c){\\n                ++swaps;\\n            }\\n            c ^= 1;\\n        }\\n        \\n        return swaps/2;\\n    }\\n}\\n```\\n\\n**Note - please upvote if you like the explanation. If you have any doubts, please ask in the comment section, I\\'ll be happy to answer : )**",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int minSwaps(String s) {\\n        int n = s.length();\\n        int ones = 0, zero = 0;\\n        for(char c : s.toCharArray()){\\n            if(c == \\'1\\')\\n                ++ones;\\n            else\\n                ++zero;\\n        }\\n        \\n        if(Math.abs(ones-zero) > 1)\\n            return -1;\\n        \\n        if(ones > zero)\\n            return helper(s, \\'1\\');\\n        else if(zero > ones)\\n            return helper(s, \\'0\\');\\n        \\n        return Math.min(helper(s, \\'1\\'), helper(s, \\'0\\'));\\n    }\\n    \\n    private int helper(String s, char c){\\n        int swaps = 0;\\n        for(char ch : s.toCharArray()){\\n            if(ch != c){\\n                ++swaps;\\n            }\\n            c ^= 1;\\n        }\\n        \\n        return swaps/2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1211155,
                "title": "count-misplaced-chars",
                "content": "First count the number of zeros and ones; return `-1` if the counts differ by more than one.\\n\\nIf our string is odd-sized, then we know where zeros and ones should be.  For even-sized strings, we need to check two cases: when the string starts with \\'0\\', and when with \\'1\\'.\\n> I first used two pointers, but then realized that it can be simplified.\\n\\n**C++**\\n```cpp\\nint minSwaps(string s) {\\n    int cnt0 = count(begin(s), end(s), \\'0\\'), cnt1 = s.size() - cnt0, miss0 = 0, miss1 = 0;\\n    if (abs(cnt0 - cnt1) > 1)\\n        return -1;\\n    for (int i = 0; i < s.size(); i += 2) {\\n        miss0 += s[i] != \\'0\\';\\n        miss1 += s[i] != \\'1\\';\\n    }\\n    return cnt0 == cnt1 ? min(miss0, miss1) : cnt0 > cnt1 ? miss0 : miss1;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint minSwaps(string s) {\\n    int cnt0 = count(begin(s), end(s), \\'0\\'), cnt1 = s.size() - cnt0, miss0 = 0, miss1 = 0;\\n    if (abs(cnt0 - cnt1) > 1)\\n        return -1;\\n    for (int i = 0; i < s.size(); i += 2) {\\n        miss0 += s[i] != \\'0\\';\\n        miss1 += s[i] != \\'1\\';\\n    }\\n    return cnt0 == cnt1 ? min(miss0, miss1) : cnt0 > cnt1 ? miss0 : miss1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1211118,
                "title": "java-python-count-wrong-positions-o-n-easy-to-understand",
                "content": "**Python 3**\\n```python\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        def countSwaps(start):\\n            cntWrongPos = 0\\n            for c in s:\\n                if start != c:\\n                    cntWrongPos += 1\\n                start = \\'1\\' if start == \\'0\\' else \\'0\\'\\n            return cntWrongPos // 2\\n\\n        cntOne = s.count(\\'1\\')\\n        cntZero = len(s) - cntOne\\n        if abs(cntOne - cntZero) > 1: # Invalid\\n            return -1\\n        if cntZero > cntOne:  # zero must be on even position\\n            return countSwaps(\\'0\\')\\n        if cntZero < cntOne:  # One must be on even position\\n            return countSwaps(\\'1\\')\\n        return min(countSwaps(\\'0\\'), countSwaps(\\'1\\'))  # get min swaps between 2 case (zero start first or one start first)\\n```\\n\\n**Java**\\n```java\\nclass Solution {\\n    public int minSwaps(String s) {\\n        int cntOne = 0, cntZero = 0;\\n        for (char c : s.toCharArray())\\n            if (c == \\'0\\') ++cntZero;\\n            else ++cntOne;\\n        if (Math.abs(cntOne - cntZero) > 1) // Invalid\\n            return -1;\\n        if (cntZero > cntOne) // Zero must be on even position\\n            return countSwaps(s, \\'0\\'); \\n        if (cntZero < cntOne) // One must be on even position\\n            return countSwaps(s, \\'1\\'); \\n        // get min swaps between 2 case (zero start first or one start first)\\n        return Math.min(countSwaps(s, \\'0\\'), countSwaps(s, \\'1\\'));\\n    }\\n    int countSwaps(String s, char start) {\\n        int cntWrongPos = 0;\\n        for (char c : s.toCharArray()) {\\n            if (c != start) ++cntWrongPos;\\n            start = (char) (\\'1\\' - start + \\'0\\');\\n        }\\n        return cntWrongPos / 2;\\n    }\\n}\\n```\\n\\n**Complexity:**\\n- Time: `O(N)`\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        def countSwaps(start):\\n            cntWrongPos = 0\\n            for c in s:\\n                if start != c:\\n                    cntWrongPos += 1\\n                start = \\'1\\' if start == \\'0\\' else \\'0\\'\\n            return cntWrongPos // 2\\n\\n        cntOne = s.count(\\'1\\')\\n        cntZero = len(s) - cntOne\\n        if abs(cntOne - cntZero) > 1: # Invalid\\n            return -1\\n        if cntZero > cntOne:  # zero must be on even position\\n            return countSwaps(\\'0\\')\\n        if cntZero < cntOne:  # One must be on even position\\n            return countSwaps(\\'1\\')\\n        return min(countSwaps(\\'0\\'), countSwaps(\\'1\\'))  # get min swaps between 2 case (zero start first or one start first)\\n```\n```java\\nclass Solution {\\n    public int minSwaps(String s) {\\n        int cntOne = 0, cntZero = 0;\\n        for (char c : s.toCharArray())\\n            if (c == \\'0\\') ++cntZero;\\n            else ++cntOne;\\n        if (Math.abs(cntOne - cntZero) > 1) // Invalid\\n            return -1;\\n        if (cntZero > cntOne) // Zero must be on even position\\n            return countSwaps(s, \\'0\\'); \\n        if (cntZero < cntOne) // One must be on even position\\n            return countSwaps(s, \\'1\\'); \\n        // get min swaps between 2 case (zero start first or one start first)\\n        return Math.min(countSwaps(s, \\'0\\'), countSwaps(s, \\'1\\'));\\n    }\\n    int countSwaps(String s, char start) {\\n        int cntWrongPos = 0;\\n        for (char c : s.toCharArray()) {\\n            if (c != start) ++cntWrongPos;\\n            start = (char) (\\'1\\' - start + \\'0\\');\\n        }\\n        return cntWrongPos / 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1211140,
                "title": "c-faster-than-100-self-explanatory",
                "content": "Just make both possible altenating strings of same size as input: 1. \"010....\" 2. \"101....\"\\nThese are the possible output strings. Compare these output strings with input string to get min num of swaps.\\n\\nIn case you didn\\'t get last part: (from if(o>z) statement) \\nIf number of 1s are larger than 0s, then our output string should be starting from 1, i.e. string should be \\'10101.....\\'. Hence we are storing the final required string in \\'s1\\'.\\nAfter this we are just comparing the number of values which are different and need to be swapped. Let\\'s say that there are 4 different values in \\'s\\' and \\'s1\\', so #swaps required will be half of it, i.e. 2.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        int z=0,o=0;\\n        int n=s.length();\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'0\\')z++;\\n            else o++;\\n        }\\n        if(abs(z-o)>1) return -1;\\n        string s1=\"\",s2=\"\";\\n        for(int i=0;i<n;i++){\\n            if(i%2==0){\\n                s1+=\\'0\\';\\n                s2+=\\'1\\';\\n            }\\n            else{\\n                s1+=\\'1\\';\\n                s2+=\\'0\\';\\n            }\\n        }\\n        int c1=0,c2=0;\\n        if(z==o){\\n            for(int i=0;i<n;i++){\\n                if(s[i]!=s1[i]) c1++;\\n                if(s[i]!=s2[i]) c2++;\\n            }\\n            return min(c1/2, c2/2);\\n        }\\n        if(o>z) s1=s2;\\n        for(int i=0;i<n;i++)\\n            if(s[i]!=s1[i]) c1++;\\n        return c1/2;\\n    }\\n};\\n```\\n\\n**Do UPVOTE if it helped you. Thanks :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        int z=0,o=0;\\n        int n=s.length();\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'0\\')z++;\\n            else o++;\\n        }\\n        if(abs(z-o)>1) return -1;\\n        string s1=\"\",s2=\"\";\\n        for(int i=0;i<n;i++){\\n            if(i%2==0){\\n                s1+=\\'0\\';\\n                s2+=\\'1\\';\\n            }\\n            else{\\n                s1+=\\'1\\';\\n                s2+=\\'0\\';\\n            }\\n        }\\n        int c1=0,c2=0;\\n        if(z==o){\\n            for(int i=0;i<n;i++){\\n                if(s[i]!=s1[i]) c1++;\\n                if(s[i]!=s2[i]) c2++;\\n            }\\n            return min(c1/2, c2/2);\\n        }\\n        if(o>z) s1=s2;\\n        for(int i=0;i<n;i++)\\n            if(s[i]!=s1[i]) c1++;\\n        return c1/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1211095,
                "title": "general-logic-for-this-type-of-problems-easy-understanding-implement-by-yourself",
                "content": "Here i am going to discuss only logic so for the implementation part you have to try yourself.\\nIn this type of problem like minimum swaps to convert original array to another array, just think about the answer \\nonly,like what could be the possible ans for a particuler case.If you can find limited ans (within complexity) then this \\napproach could work,not always but just think this type of approach once.\\n\\nNow for this problem there are 3 case \\nLet no of zeroes in s=zero\\n no of ones in s =one\\n\\n1) if(abs(zero - one) > 1)\\n\\treturn -1;\\n\\tyou will never be able to convert string as asked in ques.\\n\\t\\n2) if(abs(zero- one) == 1)\\n\\tThis means either zero > one or one > zero\\n\\tsuppose zero > one\\n* \\t\\t\\tex 10001\\n* \\t\\t\\tthe ans will be 01010\\n* \\t\\t\\t0 will be at 0th index then alternate 1 and 0;\\n* \\t\\t\\tcompare it with given string s\\n* \\t\\t\\tcount the no of mismatch i.e. where both are having different character\\n* \\t\\t\\tlike in this ex count=4\\n* \\t\\t\\tthen your result will be half of the count because you will swap one with another and they\\n\\t\\t\\twill reduce the count later.\\n\\t\\n\\tsuppose one > zero\\n\\t\\t\\tsimilar to previous case just 1 at 0th index.\\n\\t\\t\\t\\n3) if(zero == one)\\n\\tex : 111000\\n\\tpossible ans\\n\\t\\n\\t 1) 101010 \\n\\t 2)  2) 010101\\n\\t \\n* \\t compare both with given string s\\n* \\t take min of both counts\\n* \\t return half of the count.\\n\\t \\n\\t \\n\\n\\n\\n **Thanks @rkrrathorerohit10 for code implementation **\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        if (s.size()<2) return  0;\\n        \\n        int one=0,zero;\\n        for (int i=0;i<s.size();i++)\\n            if (s[i]==\\'1\\')\\n                one++;\\n        zero=s.size()-one;\\n        \\n        if (abs(zero-one)>1) return -1;\\n        \\n        if (one>zero) return solve(s,\\'1\\');\\n        else if (one<zero) return solve(s,\\'0\\');\\n        \\n        return min(solve(s,\\'0\\'),solve(s,\\'1\\'));\\n    }\\n    int solve(string s,char c)\\n    {\\n        int n = c-\\'0\\';\\n        int swaps = 0;\\n        for (int i=0;i<s.size();i++)\\n        {\\n            if (s[i]-\\'0\\'!=n)\\n                swaps++;\\n            n=n^1;\\n        }\\n        return swaps/2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        if (s.size()<2) return  0;\\n        \\n        int one=0,zero;\\n        for (int i=0;i<s.size();i++)\\n            if (s[i]==\\'1\\')\\n                one++;\\n        zero=s.size()-one;\\n        \\n        if (abs(zero-one)>1) return -1;\\n        \\n        if (one>zero) return solve(s,\\'1\\');\\n        else if (one<zero) return solve(s,\\'0\\');\\n        \\n        return min(solve(s,\\'0\\'),solve(s,\\'1\\'));\\n    }\\n    int solve(string s,char c)\\n    {\\n        int n = c-\\'0\\';\\n        int swaps = 0;\\n        for (int i=0;i<s.size();i++)\\n        {\\n            if (s[i]-\\'0\\'!=n)\\n                swaps++;\\n            n=n^1;\\n        }\\n        return swaps/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1211263,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\n    \\n    int minFillPos(string& s, char ch, int current = 0) {\\n        int count = 0;\\n        for(int i=0; i<s.size(); i+=2) {\\n            if(s[i] != ch) count++;\\n        }\\n        return count;\\n    }\\n    \\npublic:\\n    int minSwaps(string s) {\\n        int oneCount = count(s.begin(), s.end(), \\'1\\');\\n        int zeroCount = count(s.begin(), s.end(), \\'0\\');\\n        if(abs(oneCount-zeroCount) > 1) return -1;\\n        if(oneCount > zeroCount) return minFillPos(s,\\'1\\');\\n        if(zeroCount > oneCount) return minFillPos(s,\\'0\\');\\n        return min(minFillPos(s,\\'0\\'), minFillPos(s,\\'1\\'));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int minFillPos(string& s, char ch, int current = 0) {\\n        int count = 0;\\n        for(int i=0; i<s.size(); i+=2) {\\n            if(s[i] != ch) count++;\\n        }\\n        return count;\\n    }\\n    \\npublic:\\n    int minSwaps(string s) {\\n        int oneCount = count(s.begin(), s.end(), \\'1\\');\\n        int zeroCount = count(s.begin(), s.end(), \\'0\\');\\n        if(abs(oneCount-zeroCount) > 1) return -1;\\n        if(oneCount > zeroCount) return minFillPos(s,\\'1\\');\\n        if(zeroCount > oneCount) return minFillPos(s,\\'0\\');\\n        return min(minFillPos(s,\\'0\\'), minFillPos(s,\\'1\\'));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1211146,
                "title": "python3-greedy",
                "content": "\\n```\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        ones = s.count(\"1\")\\n        zeros = len(s) - ones \\n        if abs(ones - zeros) > 1: return -1 # impossible\\n        \\n        def fn(x): \\n            \"\"\"Return number of swaps if string starts with x.\"\"\"\\n            ans = 0 \\n            for c in s: \\n                if c != x: ans += 1\\n                x = \"1\" if x == \"0\" else \"0\"\\n            return ans//2\\n        \\n        if ones > zeros: return fn(\"1\")\\n        elif ones < zeros: return fn(\"0\")\\n        else: return min(fn(\"0\"), fn(\"1\")) \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        ones = s.count(\"1\")\\n        zeros = len(s) - ones \\n        if abs(ones - zeros) > 1: return -1 # impossible\\n        \\n        def fn(x): \\n            \"\"\"Return number of swaps if string starts with x.\"\"\"\\n            ans = 0 \\n            for c in s: \\n                if c != x: ans += 1\\n                x = \"1\" if x == \"0\" else \"0\"\\n            return ans//2\\n        \\n        if ones > zeros: return fn(\"1\")\\n        elif ones < zeros: return fn(\"0\")\\n        else: return min(fn(\"0\"), fn(\"1\")) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1226818,
                "title": "c-fast-and-simple-with-explanation",
                "content": "If a string can be changed into the alternating form, the number of `0`s (`cnt0`) and `1`s (`cnt0`) should be either\\n\\n- equal\\n- `cnt0` - `cnt1` = 1\\n- `cnt1` - `cnt0` = 1\\n\\nIf we have more `0`s, the first character must be `0`.\\nIf we have more `1`s, the first character must be `1`.\\nElse, the first character can be either case.\\n\\nStarting with the first character, we check the index of (0, 2, 4, ...) to see if they are the same as the first character. If not, they are miss placed. And the total miss placed characters are the number of swaps.\\n\\nIf \\n- `cnt0` - `cnt1` = 1, we check the miss placed characters of `0` .\\n- `cnt1` - `cnt0` = 1, we check the miss placed characters of `1` .\\n- `cnt1` = `cnt0`, we check both cases  and pick the smaller result.\\n\\n```c++\\nclass Solution {\\nprivate:\\n    int count(string& s, char c) {\\n        int miss = 0;\\n        for (int i = 0; i < s.length(); i += 2) {\\n            if (s[i] != c) miss++;\\n        }\\n        return miss;\\n    }\\npublic:\\n    int minSwaps(string s) {\\n        int cnt0 = 0, cnt1 = 0;\\n        for (char c : s) c == \\'0\\'? cnt0 += 1 : cnt1 += 1;\\n        if (abs(cnt0 - cnt1) > 1) return -1;\\n        \\n        if (cnt0 > cnt1) return count(s, \\'0\\');\\n        if (cnt0 < cnt1) return count(s, \\'1\\');\\n        return min(count(s, \\'0\\'), count(s, \\'1\\'));\\n    }\\n};\\n``",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\nprivate:\\n    int count(string& s, char c) {\\n        int miss = 0;\\n        for (int i = 0; i < s.length(); i += 2) {\\n            if (s[i] != c) miss++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1211247,
                "title": "cleanest-and-crystal-clear-codes-seen-so-far-o-n-c",
                "content": "- The absolute difference between number of \\'0\\' and \\'1\\' should not be greater than 1, otherwise the binary string cannot be alternating\\n\\n- Case 1: \\'1\\' is one more than \\'0\\'\\n\\tIn this case, \\'1\\' should be the first character. So an alternating string should be like 1X1X1X1...X1.\\n\\tWe only need to count the number of \\'1\\' that is not at even index\\n- Case 2: \\'0\\' is one more than \\'1\\'\\n   In this case, \\'0\\' should be the first character. So an alternating string should be like 0X0X0X0...X0\\n   We only need to count the number of \\'0\\' that is not at even index\\n- Case 3: numbers of \\'0\\' and \\'1\\' are equal\\n   In this case, an alternating string could either start with \\'0\\' or \\'1\\'. So we have to count swaps twice with two possible starting characters. Then return the smaller swaps.\\n   This is inspired by https://leetcode.com/problems/minimum-number-of-swaps-to-make-the-binary-string-alternating/discuss/1211069/simplest-explanation-with-java-solution-100-faster\\n\\t\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        int ones = 0, zeros = 0;\\n        for (auto c : s) {\\n            if (c == \\'1\\') ones++;\\n            else zeros++;\\n        }\\n        \\n        if (abs(zeros - ones) > 1) return -1;\\n        \\n        if (zeros < ones) return helper(s, \\'1\\');\\n        if (zeros > ones) return helper(s, \\'0\\');\\n        return min(helper(s, \\'1\\'), helper(s, \\'0\\'));       \\n    }\\n    \\n    int helper(string s, char st) {\\n        int swaps = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] == st && i % 2 != 0) swaps++;\\n        }\\n        return swaps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        int ones = 0, zeros = 0;\\n        for (auto c : s) {\\n            if (c == \\'1\\') ones++;\\n            else zeros++;\\n        }\\n        \\n        if (abs(zeros - ones) > 1) return -1;\\n        \\n        if (zeros < ones) return helper(s, \\'1\\');\\n        if (zeros > ones) return helper(s, \\'0\\');\\n        return min(helper(s, \\'1\\'), helper(s, \\'0\\'));       \\n    }\\n    \\n    int helper(string s, char st) {\\n        int swaps = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] == st && i % 2 != 0) swaps++;\\n        }\\n        return swaps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1492366,
                "title": "python-3-greedy-explanation",
                "content": "### Explanation\\n- When talking about _**swap**_, it\\'s almost always a greedy operation, no easy way around\\n- There are only two scenarios, either `010101....` or `101010....`, depends on the length of `s`, you might want to append an extra `0` or `1`\\n- Simply count the mismatches and pick the less one, see more explanation in the code comment below\\n### Implementation\\n```\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        ans = n = len(s)\\n        zero, one = 0, 0\\n        for c in s:                                    # count number of 0 & 1s\\n            if c == \\'0\\':\\n                zero += 1\\n            else:\\n                one += 1\\n        if abs(zero - one) > 1: return -1              # not possible when cnt differ over 1  \\n        if zero >= one:                                # \\'010101....\\' \\n            s1 = \\'01\\' * (n // 2)                       # when zero == one\\n            s1 += \\'0\\' if n % 2 else \\'\\'                 # when zero > one \\n            cnt = sum(c1 != c for c1, c in zip(s1, s))\\n            ans = cnt // 2\\n        if zero <= one:                                # \\'101010....\\'\\n            s2 = \\'10\\' * (n // 2)                       # when zero == one\\n            s2 += \\'1\\' if n % 2 else \\'\\'                 # when one > zero \\n            cnt = sum(c2 != c for c2, c in zip(s2, s))\\n            ans = min(ans, cnt // 2)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        ans = n = len(s)\\n        zero, one = 0, 0\\n        for c in s:                                    # count number of 0 & 1s\\n            if c == \\'0\\':\\n                zero += 1\\n            else:\\n                one += 1\\n        if abs(zero - one) > 1: return -1              # not possible when cnt differ over 1  \\n        if zero >= one:                                # \\'010101....\\' \\n            s1 = \\'01\\' * (n // 2)                       # when zero == one\\n            s1 += \\'0\\' if n % 2 else \\'\\'                 # when zero > one \\n            cnt = sum(c1 != c for c1, c in zip(s1, s))\\n            ans = cnt // 2\\n        if zero <= one:                                # \\'101010....\\'\\n            s2 = \\'10\\' * (n // 2)                       # when zero == one\\n            s2 += \\'1\\' if n % 2 else \\'\\'                 # when one > zero \\n            cnt = sum(c2 != c for c2, c in zip(s2, s))\\n            ans = min(ans, cnt // 2)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2387702,
                "title": "python-easy-to-understand-runtime-100",
                "content": "```\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        def countSwaps(ch):\\n            count  = 0\\n            for c in s[::2]:\\n                if(c != ch):\\n                    count += 1\\n            \\n            return count\\n            \\n        c0, c1 = s.count(\\'0\\'), s.count(\\'1\\')\\n        \\n        if(c0 == c1):\\n            return min(countSwaps(\\'0\\'), countSwaps(\\'1\\'))\\n        \\n        if(c0 == c1+1):\\n            return countSwaps(\\'0\\')\\n        \\n        if(c1 == c0+1):\\n            return countSwaps(\\'1\\')\\n        \\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Counting"
                ],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        def countSwaps(ch):\\n            count  = 0\\n            for c in s[::2]:\\n                if(c != ch):\\n                    count += 1\\n            \\n            return count\\n            \\n        c0, c1 = s.count(\\'0\\'), s.count(\\'1\\')\\n        \\n        if(c0 == c1):\\n            return min(countSwaps(\\'0\\'), countSwaps(\\'1\\'))\\n        \\n        if(c0 == c1+1):\\n            return countSwaps(\\'0\\')\\n        \\n        if(c1 == c0+1):\\n            return countSwaps(\\'1\\')\\n        \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1212058,
                "title": "simple-and-detailed-step-by-step-explanation-general-approach-c-100-0-ms",
                "content": "* In general to approach minimum swaps questions, try obtaining the resultant array/string and the compare it with our given input string to obtain the minimum number of swaps/edits required.\\n * We start by counting the number of zeroes and ones.\\n1.   If abs(c1-c0) is >1, we can\\'t form an alternating string hence return -1;\\n2.  Now, if the length of our given string is odd, then only 1 alternating string is possible:\\n\\t*    If c1>c0, string will be something like \"10101\".\\n\\t*    Else c0>c1, string will be someting like \"01010\".\\n\\t*    Now we simply compare the number of different characters between the above obtained string and the input string, and return the diff_count/2.\\n3. If the length of our given string is even, then 2 alternating strings are possible:\\n\\t* String starting with 1, like \"101010\".\\n    * String starting with 0, like \"010101\".\\n    * We compare our input string with both of these strings, find the diff_counts with both of them and return minimum of the two. return min(diff_count1/2, diff_count2/2); \\n\\n**Feel free to drop your queries in the comments and I\\'ll try my best to answer!**\\n```\\n   int minSwaps(string s) {\\n        int c0 = 0, c1 = 0;\\n        for(char c:s){\\n            if(c==\\'0\\')c0++;\\n            else c1++;\\n        }\\n        if(abs(c0-c1)>1)return -1;\\n        if(c0==c1){\\n            string t1,t2;\\n            c0*=2;\\n            while(c0){\\n                if(c0&1){\\n                    t1.push_back(\\'1\\');\\n                    t2.push_back(\\'0\\');\\n                }\\n                else{\\n                    t1.push_back(\\'0\\');\\n                    t2.push_back(\\'1\\');\\n                }\\n                c0--;\\n            }\\n            int count1=0, count2=0;\\n            for(int i=0; i<s.size(); i++){\\n                if(s[i]!=t1[i])count1++;\\n                else count2++;\\n            }\\n            return min(count1/2, count2/2);\\n        }\\n        else{\\n            string t;\\n            if(c1>c0){\\n                c1*=2;\\n                while(--c1){\\n                    if(c1&1){\\n                      t.push_back(\\'1\\');  \\n                    }\\n                    else t.push_back(\\'0\\');\\n                }\\n            }\\n            else{\\n                c0*=2;\\n                while(--c0){\\n                    if(c0&1)t.push_back(\\'0\\');\\n                    else t.push_back(\\'1\\');\\n                }\\n            }\\n            int count = 0;\\n            for(int i=0; i<s.size(); i++){\\n                if(s[i]!=t[i])count++;\\n            }\\n            cout<<t;\\n            return count/2;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n   int minSwaps(string s) {\\n        int c0 = 0, c1 = 0;\\n        for(char c:s){\\n            if(c==\\'0\\')c0++;\\n            else c1++;\\n        }\\n        if(abs(c0-c1)>1)return -1;\\n        if(c0==c1){\\n            string t1,t2;\\n            c0*=2;\\n            while(c0){\\n                if(c0&1){\\n                    t1.push_back(\\'1\\');\\n                    t2.push_back(\\'0\\');\\n                }\\n                else{\\n                    t1.push_back(\\'0\\');\\n                    t2.push_back(\\'1\\');\\n                }\\n                c0--;\\n            }\\n            int count1=0, count2=0;\\n            for(int i=0; i<s.size(); i++){\\n                if(s[i]!=t1[i])count1++;\\n                else count2++;\\n            }\\n            return min(count1/2, count2/2);\\n        }\\n        else{\\n            string t;\\n            if(c1>c0){\\n                c1*=2;\\n                while(--c1){\\n                    if(c1&1){\\n                      t.push_back(\\'1\\');  \\n                    }\\n                    else t.push_back(\\'0\\');\\n                }\\n            }\\n            else{\\n                c0*=2;\\n                while(--c0){\\n                    if(c0&1)t.push_back(\\'0\\');\\n                    else t.push_back(\\'1\\');\\n                }\\n            }\\n            int count = 0;\\n            for(int i=0; i<s.size(); i++){\\n                if(s[i]!=t[i])count++;\\n            }\\n            cout<<t;\\n            return count/2;\\n        }\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1232221,
                "title": "java-greedy-solution",
                "content": "**IDEA:**\\n* First calculate the count of zeros and count of ones . if absolute difference is greater than 1 means alternating string is not possible.\\n* if let say countZero>countOne basically countZero=countOne+1. So length of string is going to be odd and at even places we must have zero(string will start from zero). Similarly in case if countOne>countZero.\\n* If countZero==CountOne it means that string can start from either 0 or 1. will calculate both.\\n* Now create a function countSwaps(String s,char start) .\\n* Note in one swap we will get two positions rigth. and if we are calling countSwaps we are sure that a answer is possible. So just count the wrongpositions of start character.\\n```\\n Eg : s : 00110 \\nalternative string : 01010\\n     00110\\n       ^   here 0 should be there so its a wrongposition and we will do a swap one 0 and one 1 will get right position in one swap . 01010\\nAnswer=1 .\\n```\\n**CODE:**\\n```\\nclass Solution {\\n    public int minSwaps(String s) {\\n        int cntZero=0 , cntOne=0;\\n        for(char ch:s.toCharArray()){\\n            if(ch==\\'0\\') cntZero++;\\n            else cntOne++;\\n        }\\n        \\n        //Invalid\\n        if(Math.abs(cntOne-cntZero)>1) return -1;\\n        \\n        \\n        if(cntOne>cntZero){  //one must be at even posotion\\n            return countSwaps(s,\\'1\\');    \\n        }else if(cntOne<cntZero){\\n            return countSwaps(s,\\'0\\'); //zero must be at even position\\n        }\\n        \\n        return Math.min(countSwaps(s,\\'0\\'),countSwaps(s,\\'1\\'));    \\n    }\\n    \\n    //wrong count \\n    private int countSwaps(String s,char start){\\n        int wrongPosition=0;\\n        for(int i=0;i<s.length();i+=2){\\n            if(s.charAt(i)!=start) wrongPosition++;\\n        }\\n        return wrongPosition;\\n    }\\n} \\n```\\n\\nComplexity:\\n`Time:O(n) and Space:O(1)`",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n Eg : s : 00110 \\nalternative string : 01010\\n     00110\\n       ^   here 0 should be there so its a wrongposition and we will do a swap one 0 and one 1 will get right position in one swap . 01010\\nAnswer=1 .\\n```\n```\\nclass Solution {\\n    public int minSwaps(String s) {\\n        int cntZero=0 , cntOne=0;\\n        for(char ch:s.toCharArray()){\\n            if(ch==\\'0\\') cntZero++;\\n            else cntOne++;\\n        }\\n        \\n        //Invalid\\n        if(Math.abs(cntOne-cntZero)>1) return -1;\\n        \\n        \\n        if(cntOne>cntZero){  //one must be at even posotion\\n            return countSwaps(s,\\'1\\');    \\n        }else if(cntOne<cntZero){\\n            return countSwaps(s,\\'0\\'); //zero must be at even position\\n        }\\n        \\n        return Math.min(countSwaps(s,\\'0\\'),countSwaps(s,\\'1\\'));    \\n    }\\n    \\n    //wrong count \\n    private int countSwaps(String s,char start){\\n        int wrongPosition=0;\\n        for(int i=0;i<s.length();i+=2){\\n            if(s.charAt(i)!=start) wrongPosition++;\\n        }\\n        return wrongPosition;\\n    }\\n} \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2048325,
                "title": "c-o-n-nice-explanation",
                "content": "**Idea:**\\n1. The alternating string should be in **4 forms** below:\\n\\t\\t- **10101**: length of string is odd and number of character \\'1\\' is greater than \\'0\\' by 1\\n\\t\\t- **01010**: length of string is odd and number of character \\'1\\' is smaller than \\'0\\' by 1\\n\\t\\t- **101010**: length of string is even and number of character \\'1\\' is equal than \\'0\\'\\n\\t\\t- **010101**: length of string is even and number of character \\'1\\' is equal than \\'0\\'\\n\\t\\t- **Other cases**: return **-1**\\n\\t\\t\\n2. Basic idea is that **minimum swaps** is the **number of wrong position of character \\'1\\'**. We can swap wrong values \\'1\\' to wrong values \\'0\\':\\n\\t\\t- **11010** ==> **10101**: wrong value \\'1\\' are odd positions {1, 3} ==> minumum swaps = 2\\n\\t\\t- **00011** ==> **01010**: wrong value \\'1\\' are even positions {4} ==> minumum swaps = 1 (swap 4-index with 1-index)\\n\\t\\t- **000111** ==> **01010** or **101010** ==> wrong values is number of \\'1\\' in odd position or in even position. There are 2 character \\'1\\' in odd position and 1 character \\'1\\' in even position ==> return 1 (swap position 4-index with 1-index)\\n\\t\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        int n1e = 0, n1o = 0, n = s.size();\\n        \\n        // Number of \\'1\\' at event position\\n        for (int i = 0; i < n; i += 2) {\\n            n1e += s[i] == \\'1\\';\\n        }\\n        \\n        // Number of \\'1\\' at odd position\\n        for (int i = 1; i < n; i += 2) {\\n            n1o += s[i] == \\'1\\';   \\n        }\\n        \\n        // If length is odd ==> It should be: 10101 or 01010\\n        if (n % 2 == 1) {\\n            \\n            // 01010 case\\n            if (n1e + n1o == n / 2) {\\n                return n1e;\\n            } else if (n1e + n1o == n / 2 + 1) { // 10101 case\\n                return n1o;\\n            }\\n        } else {\\n            // Should be 010101 or 101010\\n            if (n1e + n1o == n/2)\\n                return min(n1e, n1o);\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        int n1e = 0, n1o = 0, n = s.size();\\n        \\n        // Number of \\'1\\' at event position\\n        for (int i = 0; i < n; i += 2) {\\n            n1e += s[i] == \\'1\\';\\n        }\\n        \\n        // Number of \\'1\\' at odd position\\n        for (int i = 1; i < n; i += 2) {\\n            n1o += s[i] == \\'1\\';   \\n        }\\n        \\n        // If length is odd ==> It should be: 10101 or 01010\\n        if (n % 2 == 1) {\\n            \\n            // 01010 case\\n            if (n1e + n1o == n / 2) {\\n                return n1e;\\n            } else if (n1e + n1o == n / 2 + 1) { // 10101 case\\n                return n1o;\\n            }\\n        } else {\\n            // Should be 010101 or 101010\\n            if (n1e + n1o == n/2)\\n                return min(n1e, n1o);\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2477614,
                "title": "java-solution-with-easy-to-understand-comments",
                "content": "```\\npublic int minSwaps(String s) {\\n        int one=0,zero=0;\\n        for(char ch : s.toCharArray()){\\n            if(ch == \\'1\\')   one++;\\n            else zero++;\\n        }\\n        if(Math.abs(one-zero) > 1)\\n            return -1;\\n        //if no of 1 is more then, all ones should be placed at even positions,\\n        //if it\\'s not present at even position then we need a swap. vice-versa for 0\\n        if(one > zero)\\n            return checkSwaps(s.toCharArray(),\\'1\\');\\n        else if(zero > one)\\n            return checkSwaps(s.toCharArray(),\\'0\\');\\n        //if both are having same count then either can be placed at even/odd position\\n        //so take minimum of both possibilities\\n        else\\n            return Math.min(checkSwaps(s.toCharArray(),\\'1\\'),checkSwaps(s.toCharArray(),\\'0\\'));\\n    }\\n    \\n    //checks wrong position when symbol is not present at even positon \\n    //(this symbol is present more)\\n    public int checkSwaps(char[] s, char symbol){\\n        int swaps=0;\\n        for(int i=0;i<s.length;i++){\\n            if(s[i] == symbol && i%2 != 0)\\n                swaps++;\\n        }\\n        return swaps;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int minSwaps(String s) {\\n        int one=0,zero=0;\\n        for(char ch : s.toCharArray()){\\n            if(ch == \\'1\\')   one++;\\n            else zero++;\\n        }\\n        if(Math.abs(one-zero) > 1)\\n            return -1;\\n        //if no of 1 is more then, all ones should be placed at even positions,\\n        //if it\\'s not present at even position then we need a swap. vice-versa for 0\\n        if(one > zero)\\n            return checkSwaps(s.toCharArray(),\\'1\\');\\n        else if(zero > one)\\n            return checkSwaps(s.toCharArray(),\\'0\\');\\n        //if both are having same count then either can be placed at even/odd position\\n        //so take minimum of both possibilities\\n        else\\n            return Math.min(checkSwaps(s.toCharArray(),\\'1\\'),checkSwaps(s.toCharArray(),\\'0\\'));\\n    }\\n    \\n    //checks wrong position when symbol is not present at even positon \\n    //(this symbol is present more)\\n    public int checkSwaps(char[] s, char symbol){\\n        int swaps=0;\\n        for(int i=0;i<s.length;i++){\\n            if(s[i] == symbol && i%2 != 0)\\n                swaps++;\\n        }\\n        return swaps;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1294226,
                "title": "c-with-comments",
                "content": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\n// minimum swaps to make binary string alternating\\nint minSwaps(string s)\\n{\\n    // init counter vars\\n    int countZero = 0, countOne = 0;\\n\\n    // count \\'0\\' and \\'1\\'\\n    for (int i = 0; i < s.size(); i++)\\n    {\\n        if (s[i] == \\'0\\')\\n            countZero++;\\n        else\\n            countOne++;\\n    }\\n\\n    // if counts differ by 1 or more => not possible\\n    if (countOne - countZero > 1 || countZero - countOne > 1)\\n        return -1;\\n\\n    // init possible string vars:\\n    string strZero = \"\", strOne = \"\";\\n\\n    // make all possible strings\\n    for (int i = 0; i < s.size(); i++)\\n    {\\n        if (i % 2 == 0)\\n        {\\n            strZero.push_back(\\'0\\');\\n            strOne.push_back(\\'1\\');\\n        }\\n        else\\n        {\\n            strZero.push_back(\\'1\\');\\n            strOne.push_back(\\'0\\');\\n        }\\n    }\\n\\n    // init swap counter for zero and one\\n    int swapCountOne = 0, swapCountZero = 0;\\n\\n    // if count of \\'0\\' and \\'1\\' are equal\\n    if (countZero == countOne)\\n    {\\n        // the given s should be of form strZero or strOne\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            if (s[i] != strZero[i])\\n                swapCountOne++;\\n            if (s[i] != strOne[i])\\n                swapCountZero++;\\n        }\\n\\n        // actual swap = swapCount/2\\n        return min(swapCountOne / 2, swapCountZero / 2);\\n    }\\n    // if countOne > countZero\\n    else if (countOne > countZero)\\n    {\\n        for (int i = 0; i < s.size(); i++)\\n            if (s[i] != strOne[i])\\n                swapCountOne++;\\n        return swapCountOne / 2;\\n    }\\n    // if countOne < countZero\\n    else\\n    {\\n        for (int i = 0; i < s.size(); i++)\\n            if (s[i] != strZero[i])\\n                swapCountZero++;\\n        return swapCountZero / 2;\\n    }\\n\\n    // avoid warning\\n    return -1;\\n}\\n\\n// Driver code\\nint main()\\n{\\n    // Given string\\n    string s = \"1110\";\\n\\n    // fn call\\n    cout << minSwaps(s);\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\n// minimum swaps to make binary string alternating\\nint minSwaps(string s)\\n{\\n    // init counter vars\\n    int countZero = 0, countOne = 0;\\n\\n    // count \\'0\\' and \\'1\\'\\n    for (int i = 0; i < s.size(); i++)\\n    {\\n        if (s[i] == \\'0\\')\\n            countZero++;\\n        else\\n            countOne++;\\n    }\\n\\n    // if counts differ by 1 or more => not possible\\n    if (countOne - countZero > 1 || countZero - countOne > 1)\\n        return -1;\\n\\n    // init possible string vars:\\n    string strZero = \"\", strOne = \"\";\\n\\n    // make all possible strings\\n    for (int i = 0; i < s.size(); i++)\\n    {\\n        if (i % 2 == 0)\\n        {\\n            strZero.push_back(\\'0\\');\\n            strOne.push_back(\\'1\\');\\n        }\\n        else\\n        {\\n            strZero.push_back(\\'1\\');\\n            strOne.push_back(\\'0\\');\\n        }\\n    }\\n\\n    // init swap counter for zero and one\\n    int swapCountOne = 0, swapCountZero = 0;\\n\\n    // if count of \\'0\\' and \\'1\\' are equal\\n    if (countZero == countOne)\\n    {\\n        // the given s should be of form strZero or strOne\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            if (s[i] != strZero[i])\\n                swapCountOne++;\\n            if (s[i] != strOne[i])\\n                swapCountZero++;\\n        }\\n\\n        // actual swap = swapCount/2\\n        return min(swapCountOne / 2, swapCountZero / 2);\\n    }\\n    // if countOne > countZero\\n    else if (countOne > countZero)\\n    {\\n        for (int i = 0; i < s.size(); i++)\\n            if (s[i] != strOne[i])\\n                swapCountOne++;\\n        return swapCountOne / 2;\\n    }\\n    // if countOne < countZero\\n    else\\n    {\\n        for (int i = 0; i < s.size(); i++)\\n            if (s[i] != strZero[i])\\n                swapCountZero++;\\n        return swapCountZero / 2;\\n    }\\n\\n    // avoid warning\\n    return -1;\\n}\\n\\n// Driver code\\nint main()\\n{\\n    // Given string\\n    string s = \"1110\";\\n\\n    // fn call\\n    cout << minSwaps(s);\\n}\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1211194,
                "title": "java-1-pass-o-n-counting-ones-and-zeros-faster-than-100-00",
                "content": "Java\\n```\\nclass Solution {\\n    public int minSwaps(String s) {\\n\\t\\t// count how many ones and zeros in the string\\n        int numOnes = 0, numZeros = 0;\\n        char[] arr = s.toCharArray();\\n        \\n\\t\\t// one and zero are created to simulate an alternating patter, it is either like 10101 or 01010\\n        char one = \\'1\\', zero = \\'0\\';\\n\\t\\t// one and zero are created to test how many different chars need to be changed to match the alternating pattern\\n        int cntOnes = 0, cntZeros = 0;\\n        \\n        for(char c : arr){\\n            if(c == \\'1\\')\\n                numOnes++;\\n            if(c == \\'0\\')\\n                numZeros++;\\n            \\n            if(c != one)\\n                cntOnes++;\\n            if(c != zero)\\n                cntZeros++;\\n\\t\\t\\t\\t\\n\\t\\t\\t// alternate the 10101 or 01010 pattern\\n            one = one == \\'1\\' ? \\'0\\' : \\'1\\';\\n            zero = zero == \\'1\\' ? \\'0\\' : \\'1\\';\\n        }\\n        \\n\\t\\t// if the difference is more than 1, then it is impossible to create an alter pattern\\n        if(Math.abs(numOnes-numZeros) > 1)\\n            return -1;\\n        \\n\\t\\t// if there are odd difference, then it is impossible to alter to 10101 pattern, then it should be able to alter to 01010 pattern, vise versa \\n        if(cntOnes % 2 == 1)\\n            return cntZeros / 2;\\n        \\n        if(cntZeros % 2 == 1)\\n            return cntOnes / 2;\\n        \\n\\t\\t// if can alter to both style, then get the min\\n        return Math.min(cntOnes / 2, cntZeros / 2);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSwaps(String s) {\\n\\t\\t// count how many ones and zeros in the string\\n        int numOnes = 0, numZeros = 0;\\n        char[] arr = s.toCharArray();\\n        \\n\\t\\t// one and zero are created to simulate an alternating patter, it is either like 10101 or 01010\\n        char one = \\'1\\', zero = \\'0\\';\\n\\t\\t// one and zero are created to test how many different chars need to be changed to match the alternating pattern\\n        int cntOnes = 0, cntZeros = 0;\\n        \\n        for(char c : arr){\\n            if(c == \\'1\\')\\n                numOnes++;\\n            if(c == \\'0\\')\\n                numZeros++;\\n            \\n            if(c != one)\\n                cntOnes++;\\n            if(c != zero)\\n                cntZeros++;\\n\\t\\t\\t\\t\\n\\t\\t\\t// alternate the 10101 or 01010 pattern\\n            one = one == \\'1\\' ? \\'0\\' : \\'1\\';\\n            zero = zero == \\'1\\' ? \\'0\\' : \\'1\\';\\n        }\\n        \\n\\t\\t// if the difference is more than 1, then it is impossible to create an alter pattern\\n        if(Math.abs(numOnes-numZeros) > 1)\\n            return -1;\\n        \\n\\t\\t// if there are odd difference, then it is impossible to alter to 10101 pattern, then it should be able to alter to 01010 pattern, vise versa \\n        if(cntOnes % 2 == 1)\\n            return cntZeros / 2;\\n        \\n        if(cntZeros % 2 == 1)\\n            return cntOnes / 2;\\n        \\n\\t\\t// if can alter to both style, then get the min\\n        return Math.min(cntOnes / 2, cntZeros / 2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1211156,
                "title": "python3-easy-to-understand",
                "content": "make the alternating string and compare it to the original string, the difference divided by 2 is the answer.\\nIf number of 1 and 0 are the same, need to compare to two possible alternating string and take the minimum\\n\\n```\\n    def minSwaps(self, s: str) -> int:\\n        cnt = collections.Counter(s)\\n        def diff(start):\\n            res = 0\\n            for c in s:\\n                if int(c) != start: res+=1\\n                start = 0 if start==1 else 1\\n            \\n            return res//2\\n                \\n        \\n        if cnt[\\'1\\'] - cnt[\\'0\\'] == 1:\\n            return diff(start=1)\\n        elif cnt[\\'1\\']-cnt[\\'0\\'] == -1:\\n            return diff(start=0)\\n        elif cnt[\\'1\\']==cnt[\\'0\\']:\\n            return min(diff(start=0),diff(start=1))\\n        else:\\n            return -1\\n```",
                "solutionTags": [],
                "code": "```\\n    def minSwaps(self, s: str) -> int:\\n        cnt = collections.Counter(s)\\n        def diff(start):\\n            res = 0\\n            for c in s:\\n                if int(c) != start: res+=1\\n                start = 0 if start==1 else 1\\n            \\n            return res//2\\n                \\n        \\n        if cnt[\\'1\\'] - cnt[\\'0\\'] == 1:\\n            return diff(start=1)\\n        elif cnt[\\'1\\']-cnt[\\'0\\'] == -1:\\n            return diff(start=0)\\n        elif cnt[\\'1\\']==cnt[\\'0\\']:\\n            return min(diff(start=0),diff(start=1))\\n        else:\\n            return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3240958,
                "title": "c-0-ms-o-n-count-misplaced-char",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    int solve(string s,char c){\\n        int temp = 0; //count the misplaced characters ie 11 or 00\\n        for(auto it:s){\\n            if(c!=it)++temp;\\n            c=c==\\'1\\'?\\'0\\':\\'1\\';\\n        }\\n        return temp/2; //misplaced/2 gives total moves to arrange it correctly\\n    }\\npublic:\\n    int minSwaps(string s) {\\n        int one=0,zero=0;\\n        for(auto it: s) it==\\'1\\'?++one:++zero;\\n\\n        if(abs(one-zero)>1)return -1;\\n            //cannot be alternatively arranged\\n\\n        else if(one > zero)return solve(s,\\'1\\');\\n            //start with one\\n            \\n        else if(zero>one) return solve(s,\\'0\\');\\n            //start with zero\\n\\n        else return min(solve(s,\\'0\\'),solve(s,\\'1\\'));\\n            //can start with both one and zero\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int solve(string s,char c){\\n        int temp = 0; //count the misplaced characters ie 11 or 00\\n        for(auto it:s){\\n            if(c!=it)++temp;\\n            c=c==\\'1\\'?\\'0\\':\\'1\\';\\n        }\\n        return temp/2; //misplaced/2 gives total moves to arrange it correctly\\n    }\\npublic:\\n    int minSwaps(string s) {\\n        int one=0,zero=0;\\n        for(auto it: s) it==\\'1\\'?++one:++zero;\\n\\n        if(abs(one-zero)>1)return -1;\\n            //cannot be alternatively arranged\\n\\n        else if(one > zero)return solve(s,\\'1\\');\\n            //start with one\\n            \\n        else if(zero>one) return solve(s,\\'0\\');\\n            //start with zero\\n\\n        else return min(solve(s,\\'0\\'),solve(s,\\'1\\'));\\n            //can start with both one and zero\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909653,
                "title": "observation-based",
                "content": "If abs(count1-count0) > 1 , answer doesn\\'t exist .\\nIf n is even check for min from 101010..... & 0101010....  .\\nIf n is odd check with 1010.... if c1 > c0 || 01010.... if c0>c1 .\\n\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(string s)\\n    {\\n        int n = s.length();\\n        int x = 0 , y = 0 ;\\n        for(char ch : s)\\n        {\\n            if(ch ==\\'0\\') x++;\\n            else if(ch==\\'1\\') y++;\\n        }\\n        if(abs(x-y) > 1) return -1;\\n        int res1 = 0 , res2 = 0 ;\\n        if(n&1)\\n        {\\n           if(x > y) \\n           {\\n               for(int i=0;i<n;i++)\\n               {\\n                   if(!(i&1) && (s[i]!=\\'0\\')) res1++;\\n               }\\n               return res1;\\n           }\\n           else\\n           {\\n               for(int i=0;i<n;i++)\\n               {\\n                   if((i&1) && (s[i]!=\\'0\\')) res1++;\\n               }\\n               return res1;\\n           }\\n        }\\n        else\\n        {\\n           for(int i=0;i<n;i++)\\n           {\\n               if(!(i&1) && (s[i]!=\\'0\\')) res1++;\\n           }\\n           return min(res1,n/2-res1);\\n        }\\n        return 1;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(string s)\\n    {\\n        int n = s.length();\\n        int x = 0 , y = 0 ;\\n        for(char ch : s)\\n        {\\n            if(ch ==\\'0\\') x++;\\n            else if(ch==\\'1\\') y++;\\n        }\\n        if(abs(x-y) > 1) return -1;\\n        int res1 = 0 , res2 = 0 ;\\n        if(n&1)\\n        {\\n           if(x > y) \\n           {\\n               for(int i=0;i<n;i++)\\n               {\\n                   if(!(i&1) && (s[i]!=\\'0\\')) res1++;\\n               }\\n               return res1;\\n           }\\n           else\\n           {\\n               for(int i=0;i<n;i++)\\n               {\\n                   if((i&1) && (s[i]!=\\'0\\')) res1++;\\n               }\\n               return res1;\\n           }\\n        }\\n        else\\n        {\\n           for(int i=0;i<n;i++)\\n           {\\n               if(!(i&1) && (s[i]!=\\'0\\')) res1++;\\n           }\\n           return min(res1,n/2-res1);\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1220105,
                "title": "greedy-well-explained-with-example-98-3-faster",
                "content": "##  *IDEA* :\\n\\uD83D\\uDC49  First count the number of indexes which contains the wrong character.\\n\\uD83D\\uDC49  Then the number of swaps required = count / 2\\n\\nE.g.\\ns = \"100\"\\ns[0] should be \\'1\\'\\ns[1] should be \\'0\\'\\nTherefore, count of mismatched characters, count = 2 and swaps required = count / 2 = 1.\\n* If the mismatch count > 1, then it would be impossible to create an alternating string.\\n* Also, if count of zeros > count of ones, then 1s will be in even indexes and 0swill be in odd and vice-versa.\\n* If they are the same, then we calculate for both scenarios, and take the minimum of their results.\\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def minSwaps(self, st: str) -> int:\\n        \\n        def swap(st,c):\\n            n = len(st)\\n            mis = 0\\n            for i in range(n):\\n                if i%2==0 and st[i]!=c:\\n                    mis+=1\\n                if i%2==1 and st[i]==c:\\n                    mis+=1\\n            return mis//2\\n                \\n        dic = Counter(st)\\n        z = dic[\\'0\\']\\n        o = dic[\\'1\\']\\n        res=0\\n        if abs(z-o)>1:\\n            return -1\\n        elif z>o:\\n            res = swap(st,\\'0\\')\\n        elif o>z:\\n            res = swap(st,\\'1\\')\\n        else:\\n            res = min(swap(st,\\'0\\'),swap(st,\\'1\\'))\\n        \\n        return res\\n\\nPlease dont leave the idea of this Question. If this was Helpful then u can **Upvote**\\uD83E\\uDD1E !!\\nThank You \\uD83E\\uDD17",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "##  *IDEA* :\\n\\uD83D\\uDC49  First count the number of indexes which contains the wrong character.\\n\\uD83D\\uDC49  Then the number of swaps required = count / 2\\n\\nE.g.\\ns = \"100\"\\ns[0] should be \\'1\\'\\ns[1] should be \\'0\\'\\nTherefore, count of mismatched characters, count = 2 and swaps required = count / 2 = 1.\\n* If the mismatch count > 1, then it would be impossible to create an alternating string.\\n* Also, if count of zeros > count of ones, then 1s will be in even indexes and 0swill be in odd and vice-versa.\\n* If they are the same, then we calculate for both scenarios, and take the minimum of their results.\\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def minSwaps(self, st: str) -> int:\\n        \\n        def swap(st,c):\\n            n = len(st)\\n            mis = 0\\n            for i in range(n):\\n                if i%2==0 and st[i]!=c:\\n                    mis+=1\\n                if i%2==1 and st[i]==c:\\n                    mis+=1\\n            return mis//2\\n                \\n        dic = Counter(st)\\n        z = dic[\\'0\\']\\n        o = dic[\\'1\\']\\n        res=0\\n        if abs(z-o)>1:\\n            return -1\\n        elif z>o:\\n            res = swap(st,\\'0\\')\\n        elif o>z:\\n            res = swap(st,\\'1\\')\\n        else:\\n            res = min(swap(st,\\'0\\'),swap(st,\\'1\\'))\\n        \\n        return res\\n\\nPlease dont leave the idea of this Question. If this was Helpful then u can **Upvote**\\uD83E\\uDD1E !!\\nThank You \\uD83E\\uDD17",
                "codeTag": "Java"
            },
            {
                "id": 1211107,
                "title": "cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(string s)\\n    {\\n        for(int i=0;i<s.size()-1;i++)\\n        {\\n            if(s[i]==s[i+1])\\n                return false;\\n        }\\n        return true;\\n    }\\n    int minSwaps(string s) {\\n        if(check(s))\\n            return 0;\\n        int cnta=0,cntb=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'0\\')\\n                cnta++;\\n            else\\n                cntb++;\\n        }\\n        if(abs(cnta-cntb)>1)\\n            return -1;\\n        \\n        if(cnta==cntb)\\n        {\\n            string s1,s2;\\n            for(int i=0;i<s.size();i++)\\n            {\\n                if(i%2==0)\\n                    s1.push_back(\\'1\\');\\n                else\\n                    s1.push_back(\\'0\\');\\n            }\\n            for(int i=0;i<s.size();i++)\\n            {\\n                if(i%2==0)\\n                    s2.push_back(\\'0\\');\\n                else\\n                    s2.push_back(\\'1\\');\\n            }\\n            int cnt1=0,cnt2=0;\\n            for(int i=0;i<s.size();i++)\\n            {\\n                if(s[i]!=s1[i])\\n                    cnt1++;\\n            }\\n            for(int i=0;i<s.size();i++)\\n            {\\n                if(s[i]!=s2[i])\\n                    cnt2++;\\n            }\\n            return min(cnt1/2,cnt2/2);\\n            \\n        }\\n        string s1;\\n        if(cnta>cntb)\\n        {\\n            \\n            for(int i=0;i<s.size();i++)\\n            {\\n                if(i%2==0)\\n                    s1.push_back(\\'0\\');\\n                else\\n                    s1.push_back(\\'1\\');\\n            }\\n        }\\n        else\\n        {\\n         for(int i=0;i<s.size();i++)\\n            {\\n                if(i%2==0)\\n                    s1.push_back(\\'1\\');\\n                else\\n                    s1.push_back(\\'0\\');\\n            }   \\n        }\\n        int cnt=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]!=s1[i])\\n                cnt++;\\n        }\\n        return cnt/2;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(string s)\\n    {\\n        for(int i=0;i<s.size()-1;i++)\\n        {\\n            if(s[i]==s[i+1])\\n                return false;\\n        }\\n        return true;\\n    }\\n    int minSwaps(string s) {\\n        if(check(s))\\n            return 0;\\n        int cnta=0,cntb=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'0\\')\\n                cnta++;\\n            else\\n                cntb++;\\n        }\\n        if(abs(cnta-cntb)>1)\\n            return -1;\\n        \\n        if(cnta==cntb)\\n        {\\n            string s1,s2;\\n            for(int i=0;i<s.size();i++)\\n            {\\n                if(i%2==0)\\n                    s1.push_back(\\'1\\');\\n                else\\n                    s1.push_back(\\'0\\');\\n            }\\n            for(int i=0;i<s.size();i++)\\n            {\\n                if(i%2==0)\\n                    s2.push_back(\\'0\\');\\n                else\\n                    s2.push_back(\\'1\\');\\n            }\\n            int cnt1=0,cnt2=0;\\n            for(int i=0;i<s.size();i++)\\n            {\\n                if(s[i]!=s1[i])\\n                    cnt1++;\\n            }\\n            for(int i=0;i<s.size();i++)\\n            {\\n                if(s[i]!=s2[i])\\n                    cnt2++;\\n            }\\n            return min(cnt1/2,cnt2/2);\\n            \\n        }\\n        string s1;\\n        if(cnta>cntb)\\n        {\\n            \\n            for(int i=0;i<s.size();i++)\\n            {\\n                if(i%2==0)\\n                    s1.push_back(\\'0\\');\\n                else\\n                    s1.push_back(\\'1\\');\\n            }\\n        }\\n        else\\n        {\\n         for(int i=0;i<s.size();i++)\\n            {\\n                if(i%2==0)\\n                    s1.push_back(\\'1\\');\\n                else\\n                    s1.push_back(\\'0\\');\\n            }   \\n        }\\n        int cnt=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]!=s1[i])\\n                cnt++;\\n        }\\n        return cnt/2;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1211105,
                "title": "java-solution-only-2-cases",
                "content": "Valid string either starts with 0 or starts with 1\\n```\\nclass Solution {\\n    public int minSwaps(String s) {\\n        int zeros = 0;\\n        int ones = 0;\\n        int needSwap = Integer.MAX_VALUE;\\n        int n = s.length();\\n        // starts with 0\\n        for (int i = 0; i < n; i++) {\\n            if (i % 2 == 0 && s.charAt(i) != \\'0\\') {\\n                zeros++;\\n            } else if (i % 2 == 1 && s.charAt(i) != \\'1\\') {\\n                ones++;\\n            }\\n        }\\n        if (zeros == ones) {\\n            needSwap = zeros;\\n        }\\n        zeros = 0;\\n        ones = 0;\\n        // starts with 1\\n        for (int i = 0; i < n; i++) {\\n            if (i % 2 == 1 && s.charAt(i) != \\'0\\') {\\n                ones++;\\n            } else if (i % 2 == 0 && s.charAt(i) != \\'1\\') {\\n                zeros++;\\n            }\\n        }\\n        if (zeros == ones) {\\n            needSwap = Math.min(zeros, needSwap);\\n        }\\n        return needSwap == Integer.MAX_VALUE ? -1 : needSwap;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSwaps(String s) {\\n        int zeros = 0;\\n        int ones = 0;\\n        int needSwap = Integer.MAX_VALUE;\\n        int n = s.length();\\n        // starts with 0\\n        for (int i = 0; i < n; i++) {\\n            if (i % 2 == 0 && s.charAt(i) != \\'0\\') {\\n                zeros++;\\n            } else if (i % 2 == 1 && s.charAt(i) != \\'1\\') {\\n                ones++;\\n            }\\n        }\\n        if (zeros == ones) {\\n            needSwap = zeros;\\n        }\\n        zeros = 0;\\n        ones = 0;\\n        // starts with 1\\n        for (int i = 0; i < n; i++) {\\n            if (i % 2 == 1 && s.charAt(i) != \\'0\\') {\\n                ones++;\\n            } else if (i % 2 == 0 && s.charAt(i) != \\'1\\') {\\n                zeros++;\\n            }\\n        }\\n        if (zeros == ones) {\\n            needSwap = Math.min(zeros, needSwap);\\n        }\\n        return needSwap == Integer.MAX_VALUE ? -1 : needSwap;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2610062,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Greedy***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(string str) {\\n        \\n        int n = str.size();\\n        \\n        // first off all count the no. of ones and zeros\\n        \\n        int count_0 = 0;\\n        \\n        int count_1 = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(str[i] == \\'1\\')\\n            {\\n                count_1++;\\n            }\\n            else\\n            {\\n                count_0++;\\n            }\\n        }\\n        \\n        // if diff between count of one and zero is greater the 1 then it\\'s not possible to make it alternating\\n        \\n        if(abs(count_1 - count_0) >= 2)\\n            return -1;\\n        \\n        // compare the string with \"01010101010....\" alternating string\\n        \\n        int uncommon_1 = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(i % 2 == 0)\\n            {\\n                if(str[i] != \\'0\\')\\n                {\\n                    uncommon_1++;\\n                }\\n            }\\n            else\\n            {\\n                if(str[i] != \\'1\\')\\n                {\\n                    uncommon_1++;\\n                }\\n            }\\n        }\\n        \\n        // compare the string with \"1010101010...\" alternating string\\n        \\n        int uncommon_2 = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(i % 2 == 1)\\n            {\\n                if(str[i] != \\'0\\')\\n                {\\n                    uncommon_2++;\\n                }\\n            }\\n            else\\n            {\\n                if(str[i] != \\'1\\')\\n                {\\n                    uncommon_2++;\\n                }\\n            }\\n        }\\n        \\n        // take the even min. of both uncommon_1 && uncommon_2\\n        \\n        int mini = INT_MAX;\\n        \\n        if(uncommon_1 % 2 == 0)\\n        {\\n            mini = min(mini, uncommon_1);\\n        }\\n        \\n        if(uncommon_2 % 2 == 0)\\n        {\\n            mini = min(mini, uncommon_2);\\n        }\\n        \\n        // if there is no. even, then ans is not possible\\n        \\n        if(mini == INT_MAX)\\n            return -1;\\n        \\n        // ans will be (mini / 2)\\n        \\n        return (mini) / 2;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(string str) {\\n        \\n        int n = str.size();\\n        \\n        // first off all count the no. of ones and zeros\\n        \\n        int count_0 = 0;\\n        \\n        int count_1 = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(str[i] == \\'1\\')\\n            {\\n                count_1++;\\n            }\\n            else\\n            {\\n                count_0++;\\n            }\\n        }\\n        \\n        // if diff between count of one and zero is greater the 1 then it\\'s not possible to make it alternating\\n        \\n        if(abs(count_1 - count_0) >= 2)\\n            return -1;\\n        \\n        // compare the string with \"01010101010....\" alternating string\\n        \\n        int uncommon_1 = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(i % 2 == 0)\\n            {\\n                if(str[i] != \\'0\\')\\n                {\\n                    uncommon_1++;\\n                }\\n            }\\n            else\\n            {\\n                if(str[i] != \\'1\\')\\n                {\\n                    uncommon_1++;\\n                }\\n            }\\n        }\\n        \\n        // compare the string with \"1010101010...\" alternating string\\n        \\n        int uncommon_2 = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(i % 2 == 1)\\n            {\\n                if(str[i] != \\'0\\')\\n                {\\n                    uncommon_2++;\\n                }\\n            }\\n            else\\n            {\\n                if(str[i] != \\'1\\')\\n                {\\n                    uncommon_2++;\\n                }\\n            }\\n        }\\n        \\n        // take the even min. of both uncommon_1 && uncommon_2\\n        \\n        int mini = INT_MAX;\\n        \\n        if(uncommon_1 % 2 == 0)\\n        {\\n            mini = min(mini, uncommon_1);\\n        }\\n        \\n        if(uncommon_2 % 2 == 0)\\n        {\\n            mini = min(mini, uncommon_2);\\n        }\\n        \\n        // if there is no. even, then ans is not possible\\n        \\n        if(mini == INT_MAX)\\n            return -1;\\n        \\n        // ans will be (mini / 2)\\n        \\n        return (mini) / 2;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2564088,
                "title": "python-time-complexity-o-n-space-complexity-o-1",
                "content": "**The Logic**:\\nThere are four options, for how the ideal string looks like:\\n* Starts at 1, and ends at 1: 101010...01\\n* Starts at 1, and ends at 0: 101010...0\\n* Starts at 0, and ends at 0: 01010...010\\n* Starts at 0, and ends at 1: 01010...01\\nBut the most important is: that we have either zeros on even places and ones on odd places or vice versa.\\n\\nWe loop through the string and count how many times zeros and ones appear on even and odd positions.\\n* If the difference between a total number of ones and a total number of zeros is more than one, we return -1. Thus, the difference is less than or equal to one.\\n* If we have a total number of ones more than a total number of zeros, it means that the final string should start with one and we have to swap ones, which are in odd positions. \\n* If we have a total number of zeros more than a total number of ones, it means that the final string should start by zero and we have to swap zeros, which are in odd positions. \\n* If we have a total number of ones equal to a total number of zeros, it means that the final string can start either by one or by zero and we have to swap the minimum between the numbers of mismatched positions.\\n\\n*Please upvote if you like the solution*\\n```\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        nOnes0, nZeros0 = 0, 0\\n        nOnes1, nZeros1 = 0, 0\\n\\n        for i in range(len(s)):\\n            if i % 2 == 0:\\n                if s[i] == \\'1\\':\\n                    nOnes0 += 1\\n                else:\\n                    nZeros0 += 1\\n            elif s[i] == \\'1\\':\\n                nOnes1 += 1\\n            else:\\n                nZeros1 += 1\\n\\t\\t\\t\\t\\n        #  If the difference between a total number of ones and a total number of zeros more that one\\n        if abs(nOnes1 + nOnes0 - nZeros1 - nZeros0) > 1:\\n            return -1\\n\\t\\t\\t\\n        # If we have a total number of ones more than total number of zeros,\\n        if nOnes1 + nOnes0 > nZeros1 + nZeros0:\\n            return nOnes1\\n\\t\\t\\t\\n        # If we have a total number of zeros more than total number of ones\\n        if nOnes1 + nOnes0 < nZeros1 + nZeros0:\\n            return nZeros1\\n\\t\\t\\t\\n        # If we have a total number of ones equal to a total number of zeros\\n        return min(nOnes0, nOnes1)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        nOnes0, nZeros0 = 0, 0\\n        nOnes1, nZeros1 = 0, 0\\n\\n        for i in range(len(s)):\\n            if i % 2 == 0:\\n                if s[i] == \\'1\\':\\n                    nOnes0 += 1\\n                else:\\n                    nZeros0 += 1\\n            elif s[i] == \\'1\\':\\n                nOnes1 += 1\\n            else:\\n                nZeros1 += 1\\n\\t\\t\\t\\t\\n        #  If the difference between a total number of ones and a total number of zeros more that one\\n        if abs(nOnes1 + nOnes0 - nZeros1 - nZeros0) > 1:\\n            return -1\\n\\t\\t\\t\\n        # If we have a total number of ones more than total number of zeros,\\n        if nOnes1 + nOnes0 > nZeros1 + nZeros0:\\n            return nOnes1\\n\\t\\t\\t\\n        # If we have a total number of zeros more than total number of ones\\n        if nOnes1 + nOnes0 < nZeros1 + nZeros0:\\n            return nZeros1\\n\\t\\t\\t\\n        # If we have a total number of ones equal to a total number of zeros\\n        return min(nOnes0, nOnes1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2472213,
                "title": "java-beats-100-o-n-one-pass-solution-explanation-with-comments",
                "content": "An alternating string can be formed only if the count of 0\\'s and 1\\'s differ by atmost 1 (when the string length is odd). If this criteria is not met, we can directly return -1.\\n\\nIf this criteria is met, the problem boils down to counting the minimum number of **misplaced** 1\\'s. Now let\\'s consider the following two cases:\\n\\n* When the string length is even (equal number of 0\\'s and 1\\'s):\\n\\n\\tWe can have all the 1\\'s in either all the odd positions or even positions. Count the number of 0\\'s in odd and even positions and return their minimum.\\n\\n\\tSay the input string is 11010010. Our resultant alternating string could either be 10101010 or 01010101. In either case, the minimum number of swaps required here would be 2.\\n\\n* When the string length is odd (number of 0\\'s and 1\\'s differ exactly by 1):\\n\\t* If count of 1\\'s = 1 + count of 0\\'s, then the 1\\'s need to be in even positions. For example, the string 1101001 can be converted to 1010101 only, which requires 2 swaps.\\n\\n\\t* If count of 0\\'s = 1 + count of 1\\'s, then the 1\\'s need to be in odd positions. For example, the string 1001001 can be converted to 0101010 only, which requires 2 swaps.\\n\\n```\\npublic int minSwaps(String s) {\\n\\tint swapsForEvenPositions = 0;\\n\\tint swapsForOddPositions = 0;\\n\\tint onesCount = 0;\\n\\n\\tfor (int i = 0; i < s.length(); i++) {\\n\\t\\tif (s.charAt(i) == \\'0\\') {\\n\\t\\t\\tif (i % 2 == 0)\\n\\t\\t\\t\\tswapsForEvenPositions++;\\n\\t\\t\\telse\\n\\t\\t\\t\\tswapsForOddPositions++;\\n\\t\\t} else\\n\\t\\t\\tonesCount++;\\n\\t}\\n\\n\\t// to form an alternating string, count of ones\\n\\t// and zeroes should be atmost 1\\n\\tif (Math.abs(s.length() - 2 * onesCount) > 1)\\n\\t\\treturn -1;\\n\\n\\t// if the string length is odd, it means either of the two\\n\\t// onesCount = 1 + zeroCount, or zeroCount = 1 + onesCount\\n\\tif (s.length() % 2 == 1) {\\n\\n\\t\\t// if onesCount is greater than zeroCount, then the even\\n\\t\\t// positions should have 1; return swapsForEvenPositions\\n\\t\\t// otherwise return swapsForOddPositions\\n\\t\\tif (onesCount > s.length() - onesCount)\\n\\t\\t\\treturn swapsForEvenPositions;\\n\\t\\telse\\n\\t\\t\\treturn swapsForOddPositions;\\n\\t}\\n\\n\\t// when string length is even, return the min of the swaps\\n\\t// required for even and odd places\\n\\treturn Math.min(swapsForEvenPositions, swapsForOddPositions);\\n}\\n```",
                "solutionTags": [
                    "Counting"
                ],
                "code": "```\\npublic int minSwaps(String s) {\\n\\tint swapsForEvenPositions = 0;\\n\\tint swapsForOddPositions = 0;\\n\\tint onesCount = 0;\\n\\n\\tfor (int i = 0; i < s.length(); i++) {\\n\\t\\tif (s.charAt(i) == \\'0\\') {\\n\\t\\t\\tif (i % 2 == 0)\\n\\t\\t\\t\\tswapsForEvenPositions++;\\n\\t\\t\\telse\\n\\t\\t\\t\\tswapsForOddPositions++;\\n\\t\\t} else\\n\\t\\t\\tonesCount++;\\n\\t}\\n\\n\\t// to form an alternating string, count of ones\\n\\t// and zeroes should be atmost 1\\n\\tif (Math.abs(s.length() - 2 * onesCount) > 1)\\n\\t\\treturn -1;\\n\\n\\t// if the string length is odd, it means either of the two\\n\\t// onesCount = 1 + zeroCount, or zeroCount = 1 + onesCount\\n\\tif (s.length() % 2 == 1) {\\n\\n\\t\\t// if onesCount is greater than zeroCount, then the even\\n\\t\\t// positions should have 1; return swapsForEvenPositions\\n\\t\\t// otherwise return swapsForOddPositions\\n\\t\\tif (onesCount > s.length() - onesCount)\\n\\t\\t\\treturn swapsForEvenPositions;\\n\\t\\telse\\n\\t\\t\\treturn swapsForOddPositions;\\n\\t}\\n\\n\\t// when string length is even, return the min of the swaps\\n\\t// required for even and odd places\\n\\treturn Math.min(swapsForEvenPositions, swapsForOddPositions);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2086558,
                "title": "java-o-n-time-complexity-easy-to-understand-comments",
                "content": "```\\nclass Solution {\\n    public int minSwaps(String s) {\\n        int ones = 0;\\n        int zeros = 0;\\n        \\n        //count no. of zeros and ones\\n        for(char c: s.toCharArray()){\\n            if(c==\\'0\\')\\n                zeros++;\\n            else\\n                ones++;\\n        }\\n        \\n        //base case we cannot make it alternative if this is the case\\n        if(Math.abs(ones-zeros)>1)\\n            return -1;\\n        \\n        //if ones are more, the string should start with 1\\n        if(ones>zeros)\\n            return findMinSwaps(s, \\'1\\');\\n        \\n        //string should start with 0\\n        if(zeros>ones)\\n            return findMinSwaps(s, \\'0\\');\\n        \\n        //if both are equal, lets check both possibilities\\n        return Math.min(findMinSwaps(s, \\'1\\'),findMinSwaps(s, \\'0\\'));\\n    }\\n    \\n    \\n    //we are counting the no. of changes we are doing, but we are basically swapping two indexes,\\n    //so return /2\\n    public int findMinSwaps(String s, char ch){\\n        int minSwaps = 0;\\n        \\n        for(char c: s.toCharArray()){\\n            if(c!=ch)\\n            {\\n                minSwaps++;\\n            }\\n            ch = (ch == \\'1\\')? \\'0\\':\\'1\\';\\n        }\\n        \\n        return minSwaps/2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSwaps(String s) {\\n        int ones = 0;\\n        int zeros = 0;\\n        \\n        //count no. of zeros and ones\\n        for(char c: s.toCharArray()){\\n            if(c==\\'0\\')\\n                zeros++;\\n            else\\n                ones++;\\n        }\\n        \\n        //base case we cannot make it alternative if this is the case\\n        if(Math.abs(ones-zeros)>1)\\n            return -1;\\n        \\n        //if ones are more, the string should start with 1\\n        if(ones>zeros)\\n            return findMinSwaps(s, \\'1\\');\\n        \\n        //string should start with 0\\n        if(zeros>ones)\\n            return findMinSwaps(s, \\'0\\');\\n        \\n        //if both are equal, lets check both possibilities\\n        return Math.min(findMinSwaps(s, \\'1\\'),findMinSwaps(s, \\'0\\'));\\n    }\\n    \\n    \\n    //we are counting the no. of changes we are doing, but we are basically swapping two indexes,\\n    //so return /2\\n    public int findMinSwaps(String s, char ch){\\n        int minSwaps = 0;\\n        \\n        for(char c: s.toCharArray()){\\n            if(c!=ch)\\n            {\\n                minSwaps++;\\n            }\\n            ch = (ch == \\'1\\')? \\'0\\':\\'1\\';\\n        }\\n        \\n        return minSwaps/2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1978221,
                "title": "abstract-thought-concise-solution-in-c",
                "content": "INTUITION--------------------------\\n1.   Aternate string can be made either by starting from \\'0\\' or \\'1\\'\\n2.   Now if we wish to create alternate string starting with \\'0\\'(0-indexed), then we must find how many 0s are odd indexes and how many 1s are at even indexes. These will be wrong placings of \\'1\\' and \\'0\\'. The count of wrong ones and wrong zeros must be same, then only we can swap and create valid aternate string. Return INT_MAX, if they are not equal and count of wrong_zero otherwise.\\n3.   Tweak step2 to get swaps required when starting with \\'1\\'(0-indexed).\\n4.   return min of step2 and step3, since we may have less number of swaps if we start with \\'0\\' or vice-e-versa\\n5.   if min of step2 and step3 is INT_MAX, means we cannot get an alternate string either starting with \\'0\\' or \\'1\\',\\n\\tso return -1;\\n```\\n   int swaps(string s, int n, char cur){\\n        int wrong_zero = 0, wrong_one=0;\\n       \\n        for(int i=0; i<n; i++){\\n            if(i%2 == 0 and s[i] != cur) wrong_one++;\\n            else if(i%2 != 0 and s[i] == cur) wrong_zero++;\\n        }\\n       \\n        return (wrong_zero != wrong_one) ? INT_MAX : wrong_zero;\\n    }\\n   \\n    \\n    int minSwaps(string s) {\\n        int n = s.length();\\n        int ans = min( swaps(s, n, \\'0\\'), swaps(s, n, \\'1\\'));\\n        return (ans == INT_MAX) ? -1 : ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n   int swaps(string s, int n, char cur){\\n        int wrong_zero = 0, wrong_one=0;\\n       \\n        for(int i=0; i<n; i++){\\n            if(i%2 == 0 and s[i] != cur) wrong_one++;\\n            else if(i%2 != 0 and s[i] == cur) wrong_zero++;\\n        }\\n       \\n        return (wrong_zero != wrong_one) ? INT_MAX : wrong_zero;\\n    }\\n   \\n    \\n    int minSwaps(string s) {\\n        int n = s.length();\\n        int ans = min( swaps(s, n, \\'0\\'), swaps(s, n, \\'1\\'));\\n        return (ans == INT_MAX) ? -1 : ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1796720,
                "title": "0ms-100-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        int ones = 0;\\n        int zeroes = 0;\\n        for(int i=0 ; i < s.size() ; i++){\\n            if(s[i] == \\'0\\')zeroes++;\\n            else ones++;\\n        }\\n        if(abs(ones - zeroes) > 1)return -1;\\n        \\n        if(zeroes > ones){\\n           char val = \\'0\\';\\n           int second = 0;\\n        \\n            for(int i=0 ; i < s.size() ; i++){\\n                if(s[i] != val){\\n                    second++;\\n                }\\n                val = val == \\'1\\'?\\'0\\':\\'1\\';\\n            }\\n            return second / 2;\\n        }else if(ones > zeroes){\\n            char val = \\'1\\';\\n            int first = 0;\\n        \\n            for(int i=0 ; i < s.size() ; i++){\\n                if(s[i] != val){\\n                    first++;\\n                }\\n                val = val == \\'1\\'?\\'0\\':\\'1\\';\\n            }\\n            \\n            return first / 2;\\n        }\\n        \\n        int first = 0 , second = 0;\\n        \\n        char val = \\'1\\';\\n        \\n        for(int i=0 ; i < s.size() ; i++){\\n            if(s[i] != val){\\n                first++;\\n            }\\n            val = val == \\'1\\'?\\'0\\':\\'1\\';\\n        }\\n        \\n        val = \\'0\\';\\n        \\n        for(int i=0 ; i < s.size() ; i++){\\n            if(s[i] != val){\\n                second++;\\n            }\\n            val = val == \\'1\\'?\\'0\\':\\'1\\';\\n        }\\n        \\n        int ans = min(first , second);\\n        \\n        return ans == 1 ? 1 : ans/2;\\n        \\n        // return min(first / 2 , second / 2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        int ones = 0;\\n        int zeroes = 0;\\n        for(int i=0 ; i < s.size() ; i++){\\n            if(s[i] == \\'0\\')zeroes++;\\n            else ones++;\\n        }\\n        if(abs(ones - zeroes) > 1)return -1;\\n        \\n        if(zeroes > ones){\\n           char val = \\'0\\';\\n           int second = 0;\\n        \\n            for(int i=0 ; i < s.size() ; i++){\\n                if(s[i] != val){\\n                    second++;\\n                }\\n                val = val == \\'1\\'?\\'0\\':\\'1\\';\\n            }\\n            return second / 2;\\n        }else if(ones > zeroes){\\n            char val = \\'1\\';\\n            int first = 0;\\n        \\n            for(int i=0 ; i < s.size() ; i++){\\n                if(s[i] != val){\\n                    first++;\\n                }\\n                val = val == \\'1\\'?\\'0\\':\\'1\\';\\n            }\\n            \\n            return first / 2;\\n        }\\n        \\n        int first = 0 , second = 0;\\n        \\n        char val = \\'1\\';\\n        \\n        for(int i=0 ; i < s.size() ; i++){\\n            if(s[i] != val){\\n                first++;\\n            }\\n            val = val == \\'1\\'?\\'0\\':\\'1\\';\\n        }\\n        \\n        val = \\'0\\';\\n        \\n        for(int i=0 ; i < s.size() ; i++){\\n            if(s[i] != val){\\n                second++;\\n            }\\n            val = val == \\'1\\'?\\'0\\':\\'1\\';\\n        }\\n        \\n        int ans = min(first , second);\\n        \\n        return ans == 1 ? 1 : ans/2;\\n        \\n        // return min(first / 2 , second / 2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1673952,
                "title": "java-solution-by-counting-misplaced-chars",
                "content": "```\\nclass Solution {\\n    public int minSwaps(String s) {\\n        int cnt1 = 0, cnt0 = 0;\\n        for(char c: s.toCharArray())\\n        {\\n            if(c ==\\'0\\')cnt0++;\\n            else cnt1++;\\n        }\\n        \\n        int len = s.length();\\n        \\n        if(Math.abs(cnt1-cnt0)>1)return -1;\\n        \\n        int misplaced = 0;\\n        char[] cands = new char[2];\\n        cands[0] = cnt1 > cnt0 ? \\'1\\' : \\'0\\';\\n        cands[1] = cnt1 > cnt0 ? \\'0\\' : \\'1\\';\\n        for(int i = 0; i < len; i++)\\n        {\\n             if(s.charAt(i) != cands[i%2])misplaced++;\\n        }\\n        \\n        if(len%2==0)\\n        {\\n\\n            return Math.min(misplaced, len-misplaced)/2;\\n        }\\n        else\\n        {\\n\\n            return misplaced/2;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSwaps(String s) {\\n        int cnt1 = 0, cnt0 = 0;\\n        for(char c: s.toCharArray())\\n        {\\n            if(c ==\\'0\\')cnt0++;\\n            else cnt1++;\\n        }\\n        \\n        int len = s.length();\\n        \\n        if(Math.abs(cnt1-cnt0)>1)return -1;\\n        \\n        int misplaced = 0;\\n        char[] cands = new char[2];\\n        cands[0] = cnt1 > cnt0 ? \\'1\\' : \\'0\\';\\n        cands[1] = cnt1 > cnt0 ? \\'0\\' : \\'1\\';\\n        for(int i = 0; i < len; i++)\\n        {\\n             if(s.charAt(i) != cands[i%2])misplaced++;\\n        }\\n        \\n        if(len%2==0)\\n        {\\n\\n            return Math.min(misplaced, len-misplaced)/2;\\n        }\\n        else\\n        {\\n\\n            return misplaced/2;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1336363,
                "title": "simple-string-operations-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) \\n    {\\n        int n = s.size();\\n        int zero_count=0,one_count=0;\\n        \\n        // counting the number of zeros and ones in s\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'0\\')zero_count++;\\n            else one_count++;\\n        }\\n        \\n        // condition when it\\'s not possible \\n        // to make string aternating\\n        \\n        if(abs(zero_count-one_count)>1) return -1;\\n        \\n        // the resultant string s can be after making the swaps\\n        // s1 -> 101010...\\n        // s2 -> 010101...\\n        // counting the number of similarity \\n        // between s and s1, s2.\\n        \\n        int s1c =0 ; \\n        int s2c =0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if((i%2==0 && s[i]==\\'1\\') || (i%2!=0 && s[i]==\\'0\\') )s1c++;\\n            if((i%2==0 && s[i]==\\'0\\') || (i%2!=0 && s[i]==\\'1\\') )s2c++;\\n            \\n        }\\n        \\n        // finding minimum dissimilarity\\n\\n        int x = n - max(s1c,s2c);\\n        \\n        // checking if it possible to make \\n        // swaps for the max similarity \\n        \\n        if(x%2==0) return x/2;\\n        \\n        // go with the other string because  \\n        // x is odd and not able to make all the swaps \\n        \\n        x = n - min(s1c,s2c);\\n        return x/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) \\n    {\\n        int n = s.size();\\n        int zero_count=0,one_count=0;\\n        \\n        // counting the number of zeros and ones in s\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'0\\')zero_count++;\\n            else one_count++;\\n        }\\n        \\n        // condition when it\\'s not possible \\n        // to make string aternating\\n        \\n        if(abs(zero_count-one_count)>1) return -1;\\n        \\n        // the resultant string s can be after making the swaps\\n        // s1 -> 101010...\\n        // s2 -> 010101...\\n        // counting the number of similarity \\n        // between s and s1, s2.\\n        \\n        int s1c =0 ; \\n        int s2c =0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if((i%2==0 && s[i]==\\'1\\') || (i%2!=0 && s[i]==\\'0\\') )s1c++;\\n            if((i%2==0 && s[i]==\\'0\\') || (i%2!=0 && s[i]==\\'1\\') )s2c++;\\n            \\n        }\\n        \\n        // finding minimum dissimilarity\\n\\n        int x = n - max(s1c,s2c);\\n        \\n        // checking if it possible to make \\n        // swaps for the max similarity \\n        \\n        if(x%2==0) return x/2;\\n        \\n        // go with the other string because  \\n        // x is odd and not able to make all the swaps \\n        \\n        x = n - min(s1c,s2c);\\n        return x/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1223867,
                "title": "o-n-solution-with-brief-simple-explanation-count-misplaced-zero-one",
                "content": "The main idea here : The number of swap needed is same as the number of misplaced \\'1\\' or \\'0\\' . What i mean by \"misplaced\" is if the input char is different from the candidate char.\\n\\nWe will try two candidate of the solution, first start with \\'1\\' and second start with \\'0\\'\\n\\ninput         :  100110\\ncandidat1 :  101010\\ncandidat2 :  010101\\n\\nWe can see that candidat1 has the least misplaced. It only need 1 swap (misPlacedOne = 1, misPlacedZero = 1).\\n\\nBut what if the string length is odd ? The example :\\ninput         :  100\\ncandidat1 :  101\\ncandidat2 :  010\\n\\ncandidat1  is certainly not the solution because it lack of number 1. Thus we should consider the solution only if `misPlacedOne == misPlacedZero`\\n```\\nfunc minSwaps(s string) int {\\n    n := len(s)\\n    countOne := 0\\n    for i:=0;i<n;i++{\\n        if s[i] == \\'1\\'{\\n            countOne++\\n        }\\n    }\\n    countZero := n-countOne\\n    if abs(countOne-countZero) > 1{\\n        return -1\\n    }\\n    \\n    ans := n\\n    starts := []byte{\\'0\\',\\'1\\'}\\n    var misPlacedOne int\\n    var misPlacedZero int\\n    \\n    for _,curr := range starts{\\n        for i:=0;i<n;i++{\\n            if s[i] == \\'1\\' && curr == \\'0\\'{\\n                misPlacedOne++\\n            }else if s[i] == \\'0\\' && curr == \\'1\\'{\\n                misPlacedZero++\\n            }\\n            curr = flip(curr)\\n        }\\n        if misPlacedOne == misPlacedZero{\\n            ans = min(ans,misPlacedOne)\\n        }\\n        misPlacedOne = 0\\n        misPlacedZero = 0\\n    }\\n    \\n    return ans\\n}\\n\\nfunc flip(b byte) byte{\\n    if b == \\'0\\'{\\n        return \\'1\\'\\n    }\\n    \\n    return \\'0\\'\\n}\\n\\nfunc min(a int,b int) int{\\n    if a < b{\\n        return a\\n    }\\n    \\n    return b\\n}\\n\\nfunc abs(a int) int{\\n    if a < 0{\\n        return -a\\n    }\\n    \\n    return a\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc minSwaps(s string) int {\\n    n := len(s)\\n    countOne := 0\\n    for i:=0;i<n;i++{\\n        if s[i] == \\'1\\'{\\n            countOne++\\n        }\\n    }\\n    countZero := n-countOne\\n    if abs(countOne-countZero) > 1{\\n        return -1\\n    }\\n    \\n    ans := n\\n    starts := []byte{\\'0\\',\\'1\\'}\\n    var misPlacedOne int\\n    var misPlacedZero int\\n    \\n    for _,curr := range starts{\\n        for i:=0;i<n;i++{\\n            if s[i] == \\'1\\' && curr == \\'0\\'{\\n                misPlacedOne++\\n            }else if s[i] == \\'0\\' && curr == \\'1\\'{\\n                misPlacedZero++\\n            }\\n            curr = flip(curr)\\n        }\\n        if misPlacedOne == misPlacedZero{\\n            ans = min(ans,misPlacedOne)\\n        }\\n        misPlacedOne = 0\\n        misPlacedZero = 0\\n    }\\n    \\n    return ans\\n}\\n\\nfunc flip(b byte) byte{\\n    if b == \\'0\\'{\\n        return \\'1\\'\\n    }\\n    \\n    return \\'0\\'\\n}\\n\\nfunc min(a int,b int) int{\\n    if a < b{\\n        return a\\n    }\\n    \\n    return b\\n}\\n\\nfunc abs(a int) int{\\n    if a < 0{\\n        return -a\\n    }\\n    \\n    return a\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1216029,
                "title": "python-solution-o-n",
                "content": "```\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n\\t\\n\\t\\t# for odd length string with number of 1s > number of 0s it should be starting with 1\\n\\t\\t# while for number of 0s > number of 1s it should be starting with 0\\n\\t\\t# If abs diff of number of 1s and 0s is greater than 1 then we can\\'t make it alternating\\n        one = s.count(\"1\")\\n        zero = s.count(\"0\")\\n        \\n        if (abs(one-zero) > 1):\\n            return -1\\n        \\n        def solve(s, ch):\\n            res = 0\\n            for i in range(len(s)):\\n                if (ch!= s[i]):\\n                    res += 1\\n                    \\n                if ch == \"1\":\\n                    ch = \"0\"\\n                else:\\n                    ch = \"1\"\\n                    \\n            return res // 2\\n        \\n        if zero > one:\\n            return solve(s, \"0\")\\n        elif (one > zero):\\n            return solve(s, \"1\")\\n        else:\\n             return min(solve(s, \"0\"), solve(s, \"1\"))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n\\t\\n\\t\\t# for odd length string with number of 1s > number of 0s it should be starting with 1\\n\\t\\t# while for number of 0s > number of 1s it should be starting with 0\\n\\t\\t# If abs diff of number of 1s and 0s is greater than 1 then we can\\'t make it alternating\\n        one = s.count(\"1\")\\n        zero = s.count(\"0\")\\n        \\n        if (abs(one-zero) > 1):\\n            return -1\\n        \\n        def solve(s, ch):\\n            res = 0\\n            for i in range(len(s)):\\n                if (ch!= s[i]):\\n                    res += 1\\n                    \\n                if ch == \"1\":\\n                    ch = \"0\"\\n                else:\\n                    ch = \"1\"\\n                    \\n            return res // 2\\n        \\n        if zero > one:\\n            return solve(s, \"0\")\\n        elif (one > zero):\\n            return solve(s, \"1\")\\n        else:\\n             return min(solve(s, \"0\"), solve(s, \"1\"))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1211341,
                "title": "easiest-way-using-string-to-xor-with-1010101-or-0101010",
                "content": "The main idea of my code is kind of like to use the given string to XOR with the correct results after swaping chars (1010101... or 01010101...). Then I can get the difference between the original string and the results such that I can get the swaping number.\\n\\nFor example, given string \"111000\", and correct result \"101010\" or \"010101\", to calculate the xor:\\n      \"111000\" xor \"101010\"  =  \"010010\"                               \\n     \"111000\"  xor \"010101\"  =  \"101101\"                  \\nAfter XOR, the count of ones is 2 or 4 meaning the difference is 2 or 4, so we can do it with 1 or 2 swaping.\\n\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        int ones = 0, zeros = 0; // count of 1 and 0\\n        int diff1 = 0, diff2 = 0; // difference count with 2 Alternating string\\n        bool isOne = true; // to generate 1010101... or 0101010...\\n\\n        for (char c : s)\\n        {\\n            if (c == \\'0\\') zeros++;\\n            else ones++;\\n\\n            if (c != (isOne ? \\'1\\':\\'0\\')) diff1++;\\n            else diff2++;\\n            isOne = !isOne;\\n        }\\n\\n        if (abs(ones-zeros) > 1 // if numbers of 1 and 0 is not balanced\\n            || (diff1%2 !=0 && diff2%2 !=0))// or if diffs to Alternating string are both odd numbers\\n            return -1;\\n\\n        if (diff1%2 != 0) // if diff1 is odd\\n            return diff2/2;\\n        else if (diff2%2 != 0) // if diff2 is odd\\n            return diff1/2;\\n        else\\n            return min(diff1,diff2)/2; // if both even, return min\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        int ones = 0, zeros = 0; // count of 1 and 0\\n        int diff1 = 0, diff2 = 0; // difference count with 2 Alternating string\\n        bool isOne = true; // to generate 1010101... or 0101010...\\n\\n        for (char c : s)\\n        {\\n            if (c == \\'0\\') zeros++;\\n            else ones++;\\n\\n            if (c != (isOne ? \\'1\\':\\'0\\')) diff1++;\\n            else diff2++;\\n            isOne = !isOne;\\n        }\\n\\n        if (abs(ones-zeros) > 1 // if numbers of 1 and 0 is not balanced\\n            || (diff1%2 !=0 && diff2%2 !=0))// or if diffs to Alternating string are both odd numbers\\n            return -1;\\n\\n        if (diff1%2 != 0) // if diff1 is odd\\n            return diff2/2;\\n        else if (diff2%2 != 0) // if diff2 is odd\\n            return diff1/2;\\n        else\\n            return min(diff1,diff2)/2; // if both even, return min\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1211326,
                "title": "my-java-solution-by-counting-the-swaps-and-returning-swaps-2",
                "content": "```\\nclass Solution {\\n    public int minSwaps(String s) {\\n        int length = s.length();\\n        if (length == 1)\\n            return 0;\\n        int countOf1 = 0;\\n        int countOf0 = 0;\\n        for (char ch : s.toCharArray()) {\\n            if (ch == \\'1\\')\\n                countOf1 += 1;\\n            else countOf0 += 1;\\n        }\\n        if (Math.abs(countOf1 - countOf0) > 1)\\n            return -1;\\n        if (countOf1 > countOf0)\\n            return countOfSwaps(s, \\'1\\');\\n        else if (countOf0 > countOf1)\\n            return countOfSwaps(s, \\'0\\');\\n        return Math.min(countOfSwaps(s, \\'1\\'), countOfSwaps(s, \\'0\\'));\\n    }\\n    \\n    public int countOfSwaps(String s, char current) {\\n        int swaps = 0;\\n        for (char ch : s.toCharArray()) {\\n            if (ch != current) {\\n                swaps += 1;\\n            }\\n            if (current == \\'1\\')\\n                current = \\'0\\';\\n            else\\n                current = \\'1\\';\\n        }\\n        return swaps / 2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSwaps(String s) {\\n        int length = s.length();\\n        if (length == 1)\\n            return 0;\\n        int countOf1 = 0;\\n        int countOf0 = 0;\\n        for (char ch : s.toCharArray()) {\\n            if (ch == \\'1\\')\\n                countOf1 += 1;\\n            else countOf0 += 1;\\n        }\\n        if (Math.abs(countOf1 - countOf0) > 1)\\n            return -1;\\n        if (countOf1 > countOf0)\\n            return countOfSwaps(s, \\'1\\');\\n        else if (countOf0 > countOf1)\\n            return countOfSwaps(s, \\'0\\');\\n        return Math.min(countOfSwaps(s, \\'1\\'), countOfSwaps(s, \\'0\\'));\\n    }\\n    \\n    public int countOfSwaps(String s, char current) {\\n        int swaps = 0;\\n        for (char ch : s.toCharArray()) {\\n            if (ch != current) {\\n                swaps += 1;\\n            }\\n            if (current == \\'1\\')\\n                current = \\'0\\';\\n            else\\n                current = \\'1\\';\\n        }\\n        return swaps / 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1211075,
                "title": "c-o-n-with-explanation",
                "content": "```\\n/*\\nTime Complexity - O(n) where n = s.size();\\nLogic:\\n1)In a binary alternating string , either the number of ones are equal to number of zeros eg \"1010\", or zero/ones differ by one eg(\"10101\",\"01010\").So if this condition lies false then it mean we can make such a string , so return -1.I have checked this first\\n2)Now also there are only 2 binary string we can make of n length i.e starting with 1 or 0 , all other will opposite of the previous one so i have made 2 string a and b where I store these strings\\n3)Now we can obviously make strings my swapping since if we are going ahead after checking condition 1.\\n4)Now we find the minimum swaps needed to make s == a and s == b.  We calculate it by a function getMinSwaps(which takes 2 arguments i.e the binary alternating string a or b, and the string s should be made equal to a or b). So that can be acheived easily by check how many characters are unequal let it be count. if count is even it means we can  swap count/2 times else if it is odd it means we wont be able to do count/2\\nswaps.\\n5)It is implemeted as follow,do upvote it helps a lot and i am open to questions.\\n*/\\n\\nclass Solution {\\npublic:\\n    int n;\\n    \\n    string getBinaryAlternating(string s){\\n        for(int i = 1; i < n; ++i){\\n            s += s[i-1] == \\'0\\' ? \\'1\\' : \\'0\\';\\n        }\\n        return s;\\n    }\\n    \\n    int getMinSwaps(string &s , string &a){\\n        int count = 0;\\n        for(int i = 0; i < s.size(); ++i){\\n            if(s[i]!=a[i])\\n                count++;\\n        }   \\n        if(count % 2 != 0) return INT_MAX;\\n        return count/2;\\n    }\\n    \\n    int minSwaps(string s) {\\n        \\n        int oneCount = 0 , zeroCount = 0;\\n        n = s.size();\\n        \\n        for(char c:s){\\n            if(c == \\'0\\')\\n                zeroCount++;\\n            else\\n                oneCount++;\\n        }\\n        if(abs(oneCount - zeroCount) >= 2) return -1;\\n        string a = getBinaryAlternating(\"0\") , b = getBinaryAlternating(\"1\");\\n\\n        return min(getMinSwaps(s,a),getMinSwaps(s,b));\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int n;\\n    \\n    string getBinaryAlternating(string s){\\n        for(int i = 1; i < n; ++i){\\n            s += s[i-1] == \\'0\\' ? \\'1\\' : \\'0\\';\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3019579,
                "title": "python-compare-to-good-string-o-n",
                "content": "```python\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        count = Counter(s)\\n\\n        if abs(count[\\'0\\'] - count[\\'1\\']) > 1:\\n            return -1\\n        \\n        # construct `alternating` strings\\n        if len(s) % 2 == 0:\\n            s1 = \\'01\\'*(len(s) // 2)\\n            s2 = \\'10\\'*(len(s) // 2)\\n        elif count[\\'0\\'] > count[\\'1\\']:\\n            s1 = s2 = \\'01\\'*(len(s) // 2) + \\'0\\'            \\n        else:\\n            s1 = s2 = \\'10\\'*(len(s) // 2) + \\'1\\'\\n\\n        # compare input to `alternating` strings above\\n        l1, l2 = 0, 0\\n        for a, b, c in zip(s, s1, s2):\\n            if a != b:\\n                l1 += 1\\n            if a != c:\\n                l2 += 1\\n\\n        return min(l1, l2) // 2\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        count = Counter(s)\\n\\n        if abs(count[\\'0\\'] - count[\\'1\\']) > 1:\\n            return -1\\n        \\n        # construct `alternating` strings\\n        if len(s) % 2 == 0:\\n            s1 = \\'01\\'*(len(s) // 2)\\n            s2 = \\'10\\'*(len(s) // 2)\\n        elif count[\\'0\\'] > count[\\'1\\']:\\n            s1 = s2 = \\'01\\'*(len(s) // 2) + \\'0\\'            \\n        else:\\n            s1 = s2 = \\'10\\'*(len(s) // 2) + \\'1\\'\\n\\n        # compare input to `alternating` strings above\\n        l1, l2 = 0, 0\\n        for a, b, c in zip(s, s1, s2):\\n            if a != b:\\n                l1 += 1\\n            if a != c:\\n                l2 += 1\\n\\n        return min(l1, l2) // 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2869867,
                "title": "not-that-clever",
                "content": "```\\n public int minSwaps(String s) {\\n        int count = 0 ; \\n        for(char k : s.toCharArray()) count+= k==\\'1\\'?1:-1;\\n        char ans ;\\n        if(count==1) ans = \\'1\\';\\n        else if(count==-1) ans = \\'0\\';\\n        else if(count==0) ans = \\'0\\';\\n        else return -1 ;\\n        int sum1 = 0 ; \\n        for(int i = 0 ; i < s.length() ; i++){\\n            if(s.charAt(i)!=ans) sum1++;\\n            if(ans==\\'1\\') ans = \\'0\\';\\n            else ans = \\'1\\';\\n         }\\n        int sum2 = 0 ; \\n        if(count == 0 ){\\n            ans = \\'1\\';\\n        for(int i = 0 ; i < s.length() ; i++){\\n            if(s.charAt(i)!=ans) sum2++;\\n            if(ans==\\'1\\') ans = \\'0\\';\\n            else ans = \\'1\\';\\n        }\\n            int sum = sum1<=sum2 ? sum1 : sum2;\\n        return sum/2;\\n            }\\n        return sum1/2 ;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int minSwaps(String s) {\\n        int count = 0 ; \\n        for(char k : s.toCharArray()) count+= k==\\'1\\'?1:-1;\\n        char ans ;\\n        if(count==1) ans = \\'1\\';\\n        else if(count==-1) ans = \\'0\\';\\n        else if(count==0) ans = \\'0\\';\\n        else return -1 ;\\n        int sum1 = 0 ; \\n        for(int i = 0 ; i < s.length() ; i++){\\n            if(s.charAt(i)!=ans) sum1++;\\n            if(ans==\\'1\\') ans = \\'0\\';\\n            else ans = \\'1\\';\\n         }\\n        int sum2 = 0 ; \\n        if(count == 0 ){\\n            ans = \\'1\\';\\n        for(int i = 0 ; i < s.length() ; i++){\\n            if(s.charAt(i)!=ans) sum2++;\\n            if(ans==\\'1\\') ans = \\'0\\';\\n            else ans = \\'1\\';\\n        }\\n            int sum = sum1<=sum2 ? sum1 : sum2;\\n        return sum/2;\\n            }\\n        return sum1/2 ;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2867847,
                "title": "python-3-elegant-o-n-o-1",
                "content": "```\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        n = len(s)\\n        zeros = sum(c == \\'0\\' for c in s)\\n        ones = n - zeros\\n        if abs(zeros - ones) > 1:\\n            return -1\\n        evenIndexZeros = sum(s[i] == \\'0\\' for i in range(0, n, 2))\\n        if zeros > ones:\\n            return zeros - evenIndexZeros\\n        if zeros < ones:\\n            return evenIndexZeros\\n        return min(evenIndexZeros, zeros - evenIndexZeros)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        n = len(s)\\n        zeros = sum(c == \\'0\\' for c in s)\\n        ones = n - zeros\\n        if abs(zeros - ones) > 1:\\n            return -1\\n        evenIndexZeros = sum(s[i] == \\'0\\' for i in range(0, n, 2))\\n        if zeros > ones:\\n            return zeros - evenIndexZeros\\n        if zeros < ones:\\n            return evenIndexZeros\\n        return min(evenIndexZeros, zeros - evenIndexZeros)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2823501,
                "title": "python-one-and-only-loop",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def minSwaps(self, s):\\n        ones_counts = [0, 0] # number of ones in odd indecies and even indecies\\n        for i in range(len(s)):\\n            if s[i] == \\'1\\':\\n                ones_counts[i%2] += 1\\n        num_ones = ones_counts[0] + ones_counts[1]\\n        num_zeros = len(s) - num_ones\\n        \\n        if num_zeros - num_ones > 1 or num_zeros - num_ones < -1:\\n            return -1\\n        elif num_zeros - num_ones == 1: # num zeroes are num ones + 1\\n            #return num_ones - ones_counts[1]\\n            return ones_counts[0]\\n        elif num_ones - num_zeros == 1:\\n            return ones_counts[1]\\n        else:\\n            return min(ones_counts[0], ones_counts[1])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, s):\\n        ones_counts = [0, 0] # number of ones in odd indecies and even indecies\\n        for i in range(len(s)):\\n            if s[i] == \\'1\\':\\n                ones_counts[i%2] += 1\\n        num_ones = ones_counts[0] + ones_counts[1]\\n        num_zeros = len(s) - num_ones\\n        \\n        if num_zeros - num_ones > 1 or num_zeros - num_ones < -1:\\n            return -1\\n        elif num_zeros - num_ones == 1: # num zeroes are num ones + 1\\n            #return num_ones - ones_counts[1]\\n            return ones_counts[0]\\n        elif num_ones - num_zeros == 1:\\n            return ones_counts[1]\\n        else:\\n            return min(ones_counts[0], ones_counts[1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2664489,
                "title": "c-easy-to-understand-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int minSwaps(string str) {\\n        \\n        int n = str.size();\\n        int count_0 = 0;\\n        \\n        int count_1 = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(str[i] == \\'1\\')\\n            {\\n                count_1++;\\n            }\\n            else\\n            {\\n                count_0++;\\n            }\\n        }\\n        if(abs(count_1 - count_0) >= 2)\\n            return -1;\\n        int uncommon_1 = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(i % 2 == 0)\\n            {\\n                if(str[i] != \\'0\\')\\n                {\\n                    uncommon_1++;\\n                }\\n            }\\n            else\\n            {\\n                if(str[i] != \\'1\\')\\n                {\\n                    uncommon_1++;\\n                }\\n            }\\n        }\\n        int uncommon_2 = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(i % 2 == 1)\\n            {\\n                if(str[i] != \\'0\\')\\n                {\\n                    uncommon_2++;\\n                }\\n            }\\n            else\\n            {\\n                if(str[i] != \\'1\\')\\n                {\\n                    uncommon_2++;\\n                }\\n            }\\n        }\\n        int mini = INT_MAX;\\n        \\n        if(uncommon_1 % 2 == 0)\\n        {\\n            mini = min(mini, uncommon_1);\\n        }\\n        \\n        if(uncommon_2 % 2 == 0)\\n        {\\n            mini = min(mini, uncommon_2);\\n        }\\n        if(mini == INT_MAX)\\n            return -1;\\n        return (mini) / 2;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int minSwaps(string str) {\\n        \\n        int n = str.size();\\n        int count_0 = 0;\\n        \\n        int count_1 = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(str[i] == \\'1\\')\\n            {\\n                count_1++;\\n            }\\n            else\\n            {\\n                count_0++;\\n            }\\n        }\\n        if(abs(count_1 - count_0) >= 2)\\n            return -1;\\n        int uncommon_1 = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(i % 2 == 0)\\n            {\\n                if(str[i] != \\'0\\')\\n                {\\n                    uncommon_1++;\\n                }\\n            }\\n            else\\n            {\\n                if(str[i] != \\'1\\')\\n                {\\n                    uncommon_1++;\\n                }\\n            }\\n        }\\n        int uncommon_2 = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(i % 2 == 1)\\n            {\\n                if(str[i] != \\'0\\')\\n                {\\n                    uncommon_2++;\\n                }\\n            }\\n            else\\n            {\\n                if(str[i] != \\'1\\')\\n                {\\n                    uncommon_2++;\\n                }\\n            }\\n        }\\n        int mini = INT_MAX;\\n        \\n        if(uncommon_1 % 2 == 0)\\n        {\\n            mini = min(mini, uncommon_1);\\n        }\\n        \\n        if(uncommon_2 % 2 == 0)\\n        {\\n            mini = min(mini, uncommon_2);\\n        }\\n        if(mini == INT_MAX)\\n            return -1;\\n        return (mini) / 2;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2548504,
                "title": "java-1ms",
                "content": "```\\nclass Solution {\\n    public int minSwaps(String s) {\\n        int noz = 0, noo = 0, n = s.length(), ans = 0;\\n        for(char c : s.toCharArray()) {\\n            if(c == \\'0\\') noz ++;\\n            else noo ++;\\n        }\\n        if(Math.abs(noo - noz) > 1) return -1;\\n        if(noo == noz) return Math.min(helper(s, \\'0\\'), helper(s, \\'1\\'));\\n        return noo > noz ? helper(s, \\'1\\') : helper(s, \\'0\\');\\n    }\\n    \\n    public int helper(String s, char c) {\\n        int swaps = 0;\\n        for(char ch : s.toCharArray()) {\\n            swaps += ch != c ? 1 : 0;\\n            c ^= 1;\\n        }\\n        return swaps / 2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSwaps(String s) {\\n        int noz = 0, noo = 0, n = s.length(), ans = 0;\\n        for(char c : s.toCharArray()) {\\n            if(c == \\'0\\') noz ++;\\n            else noo ++;\\n        }\\n        if(Math.abs(noo - noz) > 1) return -1;\\n        if(noo == noz) return Math.min(helper(s, \\'0\\'), helper(s, \\'1\\'));\\n        return noo > noz ? helper(s, \\'1\\') : helper(s, \\'0\\');\\n    }\\n    \\n    public int helper(String s, char c) {\\n        int swaps = 0;\\n        for(char ch : s.toCharArray()) {\\n            swaps += ch != c ? 1 : 0;\\n            c ^= 1;\\n        }\\n        return swaps / 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2513665,
                "title": "java-linear-solution-with-explanation",
                "content": "to make an alternating string, we have 2 options:\\n1)  0,1,0,1,0,1,0,1,...........\\n2)  1,0,1,0,1,0,1,0,...........\\n\\nlet\\'s create 2 counters:\\nshouldStartWith1 - to follow how many digits are \"incorrect\" if we want to make 1,0,1,0,1,0,1,0,...........\\nshouldStartWith0 - to follow how many digits are \"incorrect\" if we want to make 0,1,0,1,0,1,0,1,...........\\n\\nalso, let\\'s count 0 and 1.\\nwe can have 3 different situations:\\n1) zeroes == ones => we are going to make string like 0,1.0,1,0,1 or 1,0,1,0,1,0 (number of digits is even). then, we just return min from shouldStartWith1 and shouldStartWith0, (also divide it into 2 since we return number of swaps - pairs of incorrect 0 and 1s)\\n2) zeroes much more/less then ones => string invalid, return -1;\\n2) zeroes=ones+1 or ones=zeros+1 -> string like 0,1,0,1,0 or 1,0,1,0,1 (number of digits is odd). so we know what we need to return - shouldStartWith1 or shouldStartWith0.\\n\\n```\\nclass Solution {\\n    public int minSwaps(String s) {\\n        int shouldStartWith1 = 0;\\n        int shouldStartWith0 = 0;\\n        int ones = 0;\\n        int zeroes = 0;\\n        for (int i=0;i<s.length();i++){\\n            if (s.charAt(i)==\\'0\\') zeroes++; else ones++;\\n            if ((i%2==0 && s.charAt(i)==\\'0\\') || (i%2==1 && s.charAt(i)==\\'1\\')) shouldStartWith1++;\\n            else shouldStartWith0++;\\n        }\\n        \\n        if (Math.abs(ones-zeroes)>1) return -1;\\n        if (ones==zeroes)return Math.min(shouldStartWith1,shouldStartWith0)/2;\\n        if (ones>zeroes) return shouldStartWith1/2+shouldStartWith1%2;\\n        else return shouldStartWith0/2+shouldStartWith0%2;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSwaps(String s) {\\n        int shouldStartWith1 = 0;\\n        int shouldStartWith0 = 0;\\n        int ones = 0;\\n        int zeroes = 0;\\n        for (int i=0;i<s.length();i++){\\n            if (s.charAt(i)==\\'0\\') zeroes++; else ones++;\\n            if ((i%2==0 && s.charAt(i)==\\'0\\') || (i%2==1 && s.charAt(i)==\\'1\\')) shouldStartWith1++;\\n            else shouldStartWith0++;\\n        }\\n        \\n        if (Math.abs(ones-zeroes)>1) return -1;\\n        if (ones==zeroes)return Math.min(shouldStartWith1,shouldStartWith0)/2;\\n        if (ones>zeroes) return shouldStartWith1/2+shouldStartWith1%2;\\n        else return shouldStartWith0/2+shouldStartWith0%2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2479490,
                "title": "build-the-intuition-c-greedy",
                "content": "```\\n int calculate(string s,int first)\\n    {\\n        int misplaced=0;\\n        \\n        //0 se shuru kro 2 ki increment krte hue dkeho kaun kaun first ke equal nahi hai\\n        for(int i=0;i<s.size();i=i+2)\\n             if(s[i]-\\'0\\'!=first)\\n                 misplaced++;\\n        \\n        return misplaced;            \\n    }\\n    int minSwaps(string s) {\\n        \\n        \\n        //step 1 count 0s and 1s\\n        int ones=0,zeros=0;\\n        for(auto i:s)\\n        {\\n            if(i==\\'0\\')\\n                zeros++;\\n            else\\n                ones++;\\n        }\\n        \\n        // 001111 can never be made alternating .for alternating max diff allowed is 1\\n        \\n        if(abs(zeros-ones)>1) //if diff bw the counts of the 0s and 1s then not possible \\n            return -1;\\n  \\n        // case 1 --> if zero >ones then 0th position pe 0 hi aa skta to make alternating\\n        if(zeros>ones)\\n            return calculate(s,0);\\n        \\n        // case 2 --> if zero >ones then 0th position pe 0 hi aa skta to make alternating\\n        else if(ones>zeros)\\n            return calculate(s,1);\\n        \\n        //case 3 --> if zero=ones then koi b starting me aa skta dono case check kro MIN\\n        return min(calculate(s,1),calculate(s,0));\\n    }",
                "solutionTags": [],
                "code": "```\\n int calculate(string s,int first)\\n    {\\n        int misplaced=0;\\n        \\n        //0 se shuru kro 2 ki increment krte hue dkeho kaun kaun first ke equal nahi hai\\n        for(int i=0;i<s.size();i=i+2)\\n             if(s[i]-\\'0\\'!=first)\\n                 misplaced++;\\n        \\n        return misplaced;            \\n    }\\n    int minSwaps(string s) {\\n        \\n        \\n        //step 1 count 0s and 1s\\n        int ones=0,zeros=0;\\n        for(auto i:s)\\n        {\\n            if(i==\\'0\\')\\n                zeros++;\\n            else\\n                ones++;\\n        }\\n        \\n        // 001111 can never be made alternating .for alternating max diff allowed is 1\\n        \\n        if(abs(zeros-ones)>1) //if diff bw the counts of the 0s and 1s then not possible \\n            return -1;\\n  \\n        // case 1 --> if zero >ones then 0th position pe 0 hi aa skta to make alternating\\n        if(zeros>ones)\\n            return calculate(s,0);\\n        \\n        // case 2 --> if zero >ones then 0th position pe 0 hi aa skta to make alternating\\n        else if(ones>zeros)\\n            return calculate(s,1);\\n        \\n        //case 3 --> if zero=ones then koi b starting me aa skta dono case check kro MIN\\n        return min(calculate(s,1),calculate(s,0));\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2461028,
                "title": "java-solution-counting-ones-zeros",
                "content": "```\\nclass Solution {\\n    public int minSwaps(String s) {\\n        int zeros = 0, ones = 0;\\n        for (char ch : s.toCharArray()) {\\n            if (ch == \\'0\\') {\\n                zeros++;\\n            } else {\\n                ones++;\\n            }\\n        }\\n        if (Math.abs(zeros - ones) > 1) {\\n            return -1;\\n        }\\n        \\n        if (ones > zeros) {\\n            int c = 0;\\n            for (int i = 0; i < s.length(); i++) {\\n                char ch = s.charAt(i);\\n                if (i % 2 != 0 && ch == \\'1\\') {\\n                    c++;\\n                }\\n            }\\n            return c;\\n        }\\n        \\n        if (zeros > ones) {\\n            int c = 0;\\n            for (int i = 0; i < s.length(); i++) {\\n                char ch = s.charAt(i);\\n                if (i % 2 == 0 && ch == \\'1\\') {\\n                    c++;\\n                }\\n            }\\n            return c;\\n        }\\n        \\n        int odd = 0, even = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n            if (ch == \\'1\\') {\\n                if (i % 2 == 0) {\\n                    even++;\\n                } else {\\n                    odd++;\\n                }\\n            }\\n        }\\n        return Math.min(even, odd);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSwaps(String s) {\\n        int zeros = 0, ones = 0;\\n        for (char ch : s.toCharArray()) {\\n            if (ch == \\'0\\') {\\n                zeros++;\\n            } else {\\n                ones++;\\n            }\\n        }\\n        if (Math.abs(zeros - ones) > 1) {\\n            return -1;\\n        }\\n        \\n        if (ones > zeros) {\\n            int c = 0;\\n            for (int i = 0; i < s.length(); i++) {\\n                char ch = s.charAt(i);\\n                if (i % 2 != 0 && ch == \\'1\\') {\\n                    c++;\\n                }\\n            }\\n            return c;\\n        }\\n        \\n        if (zeros > ones) {\\n            int c = 0;\\n            for (int i = 0; i < s.length(); i++) {\\n                char ch = s.charAt(i);\\n                if (i % 2 == 0 && ch == \\'1\\') {\\n                    c++;\\n                }\\n            }\\n            return c;\\n        }\\n        \\n        int odd = 0, even = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n            if (ch == \\'1\\') {\\n                if (i % 2 == 0) {\\n                    even++;\\n                } else {\\n                    odd++;\\n                }\\n            }\\n        }\\n        return Math.min(even, odd);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2338504,
                "title": "python-count-wrong-positions-in-two-situations-and-take-the-min",
                "content": "`miss01`, document the number of mismatched characters in s (position 0 is number of mismatched \\'0\\'s, postion 1 is number of mismatched \\'1\\'s) if the alternating string starts with \\'01\\', like \\'0101..\\', the same for `miss10`. The swaps can successfully happen is number of mismatched \\'0\\' and \\'1\\'s are the same, so that they can be swaped.\\n\\n```\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        n = len(s)\\n        miss01, miss10 = [0]*2, [0]*2\\n        for i in range(n):\\n            if i % 2 == 0 and s[i] == \\'1\\':\\n                miss01[1] += 1\\n            if i % 2 and s[i] == \\'0\\':\\n                miss01[0] += 1\\n            if i % 2 == 0 and s[i] == \\'0\\':\\n                miss10[0] += 1\\n            if i % 2 and s[i] == \\'1\\':\\n                miss10[1] += 1\\n        res = sys.maxsize\\n        if miss01[0] == miss01[1]:\\n            res = min(res, miss01[0])\\n        if miss10[0] == miss10[1]:\\n            res = min(res, miss10[0])\\n        return res if res != sys.maxsize else -1",
                "solutionTags": [],
                "code": "`miss01`, document the number of mismatched characters in s (position 0 is number of mismatched \\'0\\'s, postion 1 is number of mismatched \\'1\\'s) if the alternating string starts with \\'01\\', like \\'0101..\\', the same for `miss10`. The swaps can successfully happen is number of mismatched \\'0\\' and \\'1\\'s are the same, so that they can be swaped.\\n\\n```\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        n = len(s)\\n        miss01, miss10 = [0]*2, [0]*2\\n        for i in range(n):\\n            if i % 2 == 0 and s[i] == \\'1\\':\\n                miss01[1] += 1\\n            if i % 2 and s[i] == \\'0\\':\\n                miss01[0] += 1\\n            if i % 2 == 0 and s[i] == \\'0\\':\\n                miss10[0] += 1\\n            if i % 2 and s[i] == \\'1\\':\\n                miss10[1] += 1\\n        res = sys.maxsize\\n        if miss01[0] == miss01[1]:\\n            res = min(res, miss01[0])\\n        if miss10[0] == miss10[1]:\\n            res = min(res, miss10[0])\\n        return res if res != sys.maxsize else -1",
                "codeTag": "Java"
            },
            {
                "id": 2257317,
                "title": "javascript-o-n-solution",
                "content": "```\\nvar minSwaps = function(s) {\\n    let ones = 0;\\n    let zeroes = 0;\\n    \\n    for(let c of s) {\\n        if(c === \"1\") ones++\\n        else zeroes++\\n    }\\n    \\n    if(Math.abs(ones - zeroes) > 1) return -1\\n    \\n    function count(i) {\\n        let res = 0\\n        for(let c of s) {\\n            if(i !== c) res++;\\n            if(i === \"1\") i = \"0\";\\n            else i = \"1\";\\n        }\\n        \\n        return res/2;\\n    };\\n    \\n    if(ones > zeroes) return count(\"1\")\\n    if(zeroes > ones) return count(\"0\")\\n\\n    return Math.min(count(\"1\"), count(\"0\"));\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minSwaps = function(s) {\\n    let ones = 0;\\n    let zeroes = 0;\\n    \\n    for(let c of s) {\\n        if(c === \"1\") ones++\\n        else zeroes++\\n    }\\n    \\n    if(Math.abs(ones - zeroes) > 1) return -1\\n    \\n    function count(i) {\\n        let res = 0\\n        for(let c of s) {\\n            if(i !== c) res++;\\n            if(i === \"1\") i = \"0\";\\n            else i = \"1\";\\n        }\\n        \\n        return res/2;\\n    };\\n    \\n    if(ones > zeroes) return count(\"1\")\\n    if(zeroes > ones) return count(\"0\")\\n\\n    return Math.min(count(\"1\"), count(\"0\"));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2084516,
                "title": "explained",
                "content": "**two counters**\\n**time: `O(N)`; space: `O(1)`**\\n\\nThe general idea of the algorithm is: \\n> *Gather all needed information -> make decision at the end*.\\nYou need two pieces of information:\\n* `d - #zeroes - #ones` in the string;\\n* `t` - number of places in which our string matches with string `\"010101... \"`\\n\\nFor example for input string `s=01110` we have `d=-1` and `t=1 (second character doesn\\'t match)`.\\n\\nIt\\'s easy to understand what we need `d` for.\\nLet `d` be the difference between the number of `0s` and `1s`.\\n* If `1<d<-1` no swaps can make the string alternating.\\n* If `d==1` we can start and end string with `0` and make it `01...10`.\\n* If `d==-1` we can start and end string with `0` and make it `10...01`.\\n* If `d==0` we can transform the string into `01...` or `10...`.\\nWe should choose the one which requires less swaps.\\n\\nSo `d` is a *control variable* based on which we switch to different analytical expressions.\\n```\\n\\treturn d==1 ? ... : d==-1 ? ... : d==0 ? ...  : -1;\\n```\\n\\nWhat is `t`?\\nThere are two reference strings we can transform our string into:\\n* `\"10101010101010...\"`\\n* `\"01010101010101...\"`\\nand by calculating `t` we can find the number of matched characters between these reference strings and input string:\\n* `n-t`\\n* `t`\\n\\n![image](https://assets.leetcode.com/users/images/44f8023e-70b9-45e3-9384-38b4c60d2b9e_1653845514.1217027.png)\\n\\n\\n\\n\\n\\n\\n```\\nint minSwaps(string s) \\n{\\n\\tint t{}, d{}, n(size(s));\\n\\tfor(int i{}; i<n; ++i)\\n\\t\\tt += s[i]==\\'0\\'+(i&1),    \\n\\t\\td += 2*(s[i]==\\'0\\')-1;          \\n\\treturn d==1 ? (n-t)/2 : d==-1 ? t/2 : !d ? min(n-t, t)/2 : -1;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\treturn d==1 ? ... : d==-1 ? ... : d==0 ? ...  : -1;\\n```\n```\\nint minSwaps(string s) \\n{\\n\\tint t{}, d{}, n(size(s));\\n\\tfor(int i{}; i<n; ++i)\\n\\t\\tt += s[i]==\\'0\\'+(i&1),    \\n\\t\\td += 2*(s[i]==\\'0\\')-1;          \\n\\treturn d==1 ? (n-t)/2 : d==-1 ? t/2 : !d ? min(n-t, t)/2 : -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1522028,
                "title": "java-solution",
                "content": "\\tclass Solution {\\n    public int minSwaps(String s) \\n    {\\n        int oneCount = 0, zeroCount = 0;\\n        for(char c : s.toCharArray())\\n        {\\n            if(c == \\'1\\') oneCount++;\\n            else zeroCount++;\\n        }\\n        \\n        if(Math.abs(oneCount-zeroCount) > 1) return -1;\\n        \\n        int res = 0;\\n        if(oneCount == zeroCount)\\n        {\\n            String first = generateString(oneCount, zeroCount, \\'1\\');\\n            String second = generateString(oneCount, zeroCount, \\'0\\');\\n            int diffFirst = getDiff(first, s);\\n            int diffSecond = getDiff(second, s);\\n            res = Math.min(diffFirst, diffSecond);\\n        }\\n        else if(oneCount > zeroCount)\\n        {\\n            String first = generateString(oneCount, zeroCount, \\'1\\');\\n            res = getDiff(first, s);\\n        }\\n        else\\n        {\\n            String second = generateString(oneCount, zeroCount, \\'0\\');\\n            res = getDiff(second, s);\\n        }\\n        \\n        return res%2 == 0 ? res/2 : res/2 + 1;\\n    }    \\n    \\n    int getDiff(String a, String b)\\n    {\\n        int diff = 0;\\n        for(int i = 0; i < a.length(); i++)\\n        {\\n            if(a.charAt(i) != b.charAt(i))\\n            {\\n                diff++;\\n            }\\n        }\\n        \\n        return diff;\\n    }\\n    \\n    String generateString(int ones, int zeros, char start)\\n    {\\n        StringBuilder sb = new StringBuilder();\\n        \\n        while(ones > 0 || zeros > 0)\\n        {\\n            sb.append(start);\\n            if(start == \\'1\\')\\n            {\\n                ones--;\\n                start = \\'0\\';\\n            }\\n            else\\n            {\\n                zeros--;\\n                start = \\'1\\';\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minSwaps(String s) \\n    {\\n        int oneCount = 0, zeroCount = 0;\\n        for(char c : s.toCharArray())\\n        {\\n            if(c == \\'1\\') oneCount++;\\n            else zeroCount++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1474606,
                "title": "100-faster-c-linear-time-minimum-overhead",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) \\n    {\\n        int n = s.length(), one = 0, zero = 0, ret = -1;\\n        string s1 = \"\", s2 = \"\";\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(s[i] == \\'1\\') one++;\\n            else zero++;\\n            if(i & 1) s1.push_back(\\'1\\'), s2.push_back(\\'0\\');\\n            else s2.push_back(\\'1\\'), s1.push_back(\\'0\\');\\n        }\\n        if(abs(zero - one) <= 1)\\n        {\\n            int swaps1 = 0, swaps2 = 0;\\n            for(int i = 0; i < n; i++)\\n            {\\n                if(s[i] != s1[i]) swaps1++;\\n                if(s[i] != s2[i]) swaps2++;\\n            }\\n            if((zero - one) == 0) ret = min(swaps1, swaps2) / 2;\\n            else\\n            {\\n                if(zero > one) ret = swaps1 / 2;\\n                else ret = swaps2 / 2;\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) \\n    {\\n        int n = s.length(), one = 0, zero = 0, ret = -1;\\n        string s1 = \"\", s2 = \"\";\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(s[i] == \\'1\\') one++;\\n            else zero++;\\n            if(i & 1) s1.push_back(\\'1\\'), s2.push_back(\\'0\\');\\n            else s2.push_back(\\'1\\'), s1.push_back(\\'0\\');\\n        }\\n        if(abs(zero - one) <= 1)\\n        {\\n            int swaps1 = 0, swaps2 = 0;\\n            for(int i = 0; i < n; i++)\\n            {\\n                if(s[i] != s1[i]) swaps1++;\\n                if(s[i] != s2[i]) swaps2++;\\n            }\\n            if((zero - one) == 0) ret = min(swaps1, swaps2) / 2;\\n            else\\n            {\\n                if(zero > one) ret = swaps1 / 2;\\n                else ret = swaps2 / 2;\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1396679,
                "title": "clean-java-code-one-pass-with-counting",
                "content": "```\\n/**\\n    Approach: Idea is to match the input with ideal output strings. \\n    Eg: 10110 -> Ideal output can start with 1s or 0s . \\n    So do the count for ones that are in wrong positions of output format. \\n    return the result depending on the zeros and ones that are not in the right position. \\n\\tTime Complexity: O(N)\\n\\tSpace Complexity: O(1) \\n**/\\nclass Solution {\\n    public int minSwaps(String s) {\\n        int zeros = 0;\\n        int ones = 0; \\n        int onesCount = 0; //Misplaced ones if the output starts with 0. \\n        int zerosCount = 0; //Misplaced zeros if the output starts with 1. \\n        for(int i=0; i < s.length(); i++) {\\n            if(s.charAt(i) == \\'0\\') {\\n                zeros++;\\n                if(i % 2 == 0) {\\n                    zerosCount++;\\n                }\\n            } else {\\n                ones++;\\n                if(i % 2 == 0) {\\n                    onesCount++;\\n                }\\n            }\\n            \\n        }\\n        \\n        if(Math.abs(ones - zeros) > 1) {\\n            return -1;\\n        }\\n        \\n        if(ones == zeros) {\\n            return Math.min(onesCount, zerosCount);\\n        }\\n        \\n        if(ones > zeros) {\\n            return zerosCount;\\n        } \\n        return onesCount;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n    Approach: Idea is to match the input with ideal output strings. \\n    Eg: 10110 -> Ideal output can start with 1s or 0s . \\n    So do the count for ones that are in wrong positions of output format. \\n    return the result depending on the zeros and ones that are not in the right position. \\n\\tTime Complexity: O(N)\\n\\tSpace Complexity: O(1) \\n**/\\nclass Solution {\\n    public int minSwaps(String s) {\\n        int zeros = 0;\\n        int ones = 0; \\n        int onesCount = 0; //Misplaced ones if the output starts with 0. \\n        int zerosCount = 0; //Misplaced zeros if the output starts with 1. \\n        for(int i=0; i < s.length(); i++) {\\n            if(s.charAt(i) == \\'0\\') {\\n                zeros++;\\n                if(i % 2 == 0) {\\n                    zerosCount++;\\n                }\\n            } else {\\n                ones++;\\n                if(i % 2 == 0) {\\n                    onesCount++;\\n                }\\n            }\\n            \\n        }\\n        \\n        if(Math.abs(ones - zeros) > 1) {\\n            return -1;\\n        }\\n        \\n        if(ones == zeros) {\\n            return Math.min(onesCount, zerosCount);\\n        }\\n        \\n        if(ones > zeros) {\\n            return zerosCount;\\n        } \\n        return onesCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1387535,
                "title": "one-pass-c-solution",
                "content": "```\\nint minSwaps(string s) {\\n\\tint memo[2][2] = {};\\n\\tfor (int i = 0; i < s.size(); ++i) {\\n\\t\\t++memo[s[i] - \\'0\\'][i & 1];\\n\\t}\\n\\tif (abs(memo[0][0] + memo[0][1] - memo[1][0] - memo[1][1]) > 1) {\\n\\t\\treturn -1;\\n\\t}\\n\\tint even = memo[0][0] == memo[1][1] ? memo[0][0] : INT_MAX;\\n\\tint odd = memo[0][1] == memo[1][0] ? memo[1][0] : INT_MAX;\\n\\treturn min(even, odd);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint minSwaps(string s) {\\n\\tint memo[2][2] = {};\\n\\tfor (int i = 0; i < s.size(); ++i) {\\n\\t\\t++memo[s[i] - \\'0\\'][i & 1];\\n\\t}\\n\\tif (abs(memo[0][0] + memo[0][1] - memo[1][0] - memo[1][1]) > 1) {\\n\\t\\treturn -1;\\n\\t}\\n\\tint even = memo[0][0] == memo[1][1] ? memo[0][0] : INT_MAX;\\n\\tint odd = memo[0][1] == memo[1][0] ? memo[1][0] : INT_MAX;\\n\\treturn min(even, odd);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1236541,
                "title": "c-easy-o-n",
                "content": "```\\npublic class Solution {\\n    public int MinSwaps(string s) {\\n        var len = s.Length;\\n        var zeroCount = 0;\\n        var oneCount = 0;\\n        \\n        foreach(var c in s)\\n        {\\n            if(c == \\'0\\')\\n                zeroCount++;\\n            else\\n                oneCount++;\\n        }\\n        \\n        if(Math.Abs(zeroCount - oneCount) > 1)\\n            return -1;\\n        else if(zeroCount > oneCount)\\n            return SwapCount(s, \\'0\\');\\n        else if(oneCount > zeroCount)\\n            return SwapCount(s, \\'1\\');\\n        \\n        return Math.Min(SwapCount(s, \\'0\\'), SwapCount(s, \\'1\\'));\\n    }\\n    \\n    private int SwapCount(string s, char ch)\\n    {\\n        int swaps = 0;\\n        for(int i = 0; i < s.Length; i++)\\n        {\\n            if(s[i] != ch)\\n                swaps++;\\n            ch = (char)(ch ^ 1); //gotcha Cannot implicitly convert type \\'int\\' to \\'char\\'.\\n        }\\n        return swaps/2;\\n    }\\n}\\n\\n//Ex: When 0\\'s and 1\\'s are equal\\n//0 0 1 1 0 0 1 1\\n\\n//0 1 0 1 0 1 0 1 -- 2 swaps for starting with 0\\n//1 0 1 0 1 0 1 0 -- 4 swaps for starting with 1\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MinSwaps(string s) {\\n        var len = s.Length;\\n        var zeroCount = 0;\\n        var oneCount = 0;\\n        \\n        foreach(var c in s)\\n        {\\n            if(c == \\'0\\')\\n                zeroCount++;\\n            else\\n                oneCount++;\\n        }\\n        \\n        if(Math.Abs(zeroCount - oneCount) > 1)\\n            return -1;\\n        else if(zeroCount > oneCount)\\n            return SwapCount(s, \\'0\\');\\n        else if(oneCount > zeroCount)\\n            return SwapCount(s, \\'1\\');\\n        \\n        return Math.Min(SwapCount(s, \\'0\\'), SwapCount(s, \\'1\\'));\\n    }\\n    \\n    private int SwapCount(string s, char ch)\\n    {\\n        int swaps = 0;\\n        for(int i = 0; i < s.Length; i++)\\n        {\\n            if(s[i] != ch)\\n                swaps++;\\n            ch = (char)(ch ^ 1); //gotcha Cannot implicitly convert type \\'int\\' to \\'char\\'.\\n        }\\n        return swaps/2;\\n    }\\n}\\n\\n//Ex: When 0\\'s and 1\\'s are equal\\n//0 0 1 1 0 0 1 1\\n\\n//0 1 0 1 0 1 0 1 -- 2 swaps for starting with 0\\n//1 0 1 0 1 0 1 0 -- 4 swaps for starting with 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1230964,
                "title": "java-o-n",
                "content": "```\\nclass Solution {\\n    public int minSwaps(String s) {\\n        int evenZeros = 0;\\n        int oddZeros = 0;\\n        int evenOnes = 0;\\n        int oddOnes = 0;\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            if (i % 2 == 0) {\\n                if (s.charAt(i) == \\'0\\') {\\n                    evenZeros++;\\n                } else {\\n                    evenOnes++;\\n                }\\n            } else {\\n                if (s.charAt(i) == \\'0\\') {\\n                    oddZeros++;\\n                } else {\\n                    oddOnes++;\\n                }\\n                \\n            }\\n        }\\n        \\n        int diff = (evenZeros + oddZeros) - (evenOnes + oddOnes);\\n        if (diff == 1) {\\n            return oddZeros;\\n        } else if (diff == -1) {\\n            return oddOnes;\\n        } else if (diff == 0) {\\n            return evenZeros < oddZeros ? evenZeros : oddZeros;\\n        } else {\\n            return -1;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSwaps(String s) {\\n        int evenZeros = 0;\\n        int oddZeros = 0;\\n        int evenOnes = 0;\\n        int oddOnes = 0;\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            if (i % 2 == 0) {\\n                if (s.charAt(i) == \\'0\\') {\\n                    evenZeros++;\\n                } else {\\n                    evenOnes++;\\n                }\\n            } else {\\n                if (s.charAt(i) == \\'0\\') {\\n                    oddZeros++;\\n                } else {\\n                    oddOnes++;\\n                }\\n                \\n            }\\n        }\\n        \\n        int diff = (evenZeros + oddZeros) - (evenOnes + oddOnes);\\n        if (diff == 1) {\\n            return oddZeros;\\n        } else if (diff == -1) {\\n            return oddOnes;\\n        } else if (diff == 0) {\\n            return evenZeros < oddZeros ? evenZeros : oddZeros;\\n        } else {\\n            return -1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1222998,
                "title": "simple-using-odd-and-even-condtion-and-someobservation-full-explaination-with-code",
                "content": "NOTE-- > if  given string is odd then it may be possible that that string starts with 0 or 1, if its start with zero than for sure there is always (zeroCount- OneCount)==1 means ZeroCount is always greater than oneCount by one   if this case happen we have to  make  alternating string start with zero only like \"010.......\"\\n\\nand viceversa eg if start with one the we can make \"101.... \"\\n\\n\\nif string has even length it must contain ZeroCount==OneCount for sure  to be alternating sequence \\n\\nse we have two possibilites  either alternating string start with \"0101....\"  or  \"1010.....\"\\nand in that case find the minimum no of mismatch character from original string...\\n\\n\\nin final step count the  bit that is different and return count/2;\\n\\n\\nhope it ll help you :)\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n  \\n   bool get(string s, int n)\\n   {\\n       int zero, one;\\n           zero=one=0;\\n      for(char f:s)\\n      {\\n        if(f==\\'0\\')\\n          zero++;\\n        else\\n          one++;\\n      }\\n     \\n      if(!(n&1))\\n      {\\n       return zero==one ? true: false;\\n      }\\n     else \\n     {\\n       return  abs(zero-one)==1 ? true :false;\\n     }\\n   }\\n  \\n    int minSwaps(string s) {\\n       \\n       int length=s.size();\\n      \\n       bool check= get(s,length);\\n        if(check==false)\\n          return -1;\\n         \\n      int zeroCount, oneCount;\\n      zeroCount=oneCount=0;\\n      string supposeTo=\"\";\\n      string s1,s2;\\n      \\n         if(length&1)\\n         {\\n           for(char f:s)\\n           {\\n              if(f==\\'0\\')\\n                 zeroCount++;\\n             else\\n             oneCount++;\\n           }\\n      \\n            if(zeroCount>oneCount)\\n            {\\n              int x= s.size();\\n              string require=\"0\";\\n              while(x--)\\n              {\\n               supposeTo+=require;\\n              if(require==\"0\"){\\n              require=\"1\";\\n              }else\\n              require=\"0\";\\n              }\\n            }\\n              else if(zeroCount<oneCount) \\n               {\\n                int x= s.size();\\n                string require=\"1\";\\n                 while(x--)\\n                  {\\n                    supposeTo+=require;\\n                    if(require==\"0\"){\\n                    require=\"1\";\\n                    }else\\n                    require=\"0\";\\n                   }\\n                       \\n                 }\\n      \\n         }\\n       \\n       else \\n       {\\n           int x= s.size();\\n           string require=\"0\";\\n           while(x--)\\n           {\\n           s1+=require;\\n           if(require==\"0\"){\\n             require=\"1\";\\n             }else\\n             require=\"0\";\\n            }\\n         \\n           require=\"1\";\\n            x= s.size();\\n           while(x--)\\n           {\\n            s2+=require;\\n            if(require==\"0\"){\\n             require=\"1\";\\n             }else\\n             require=\"0\";\\n            }\\n                     \\n       }\\n  \\n   \\n       int count=0;\\n       if(length&1){\\n             \\n      for(int i=0; i<s.size(); i++)\\n      {\\n    \\n         if(supposeTo[i]!=s[i])\\n         {\\n            count++;\\n         }\\n      }\\n         return (count/2);\\n      }\\n      \\n      else \\n      {\\n        int count1, count2;\\n         count1=count2=0;\\n         for(int i=0; i<s.size(); i++)\\n         {\\n         if(s1[i]!=s[i])\\n         {\\n            count1++;\\n         }\\n        \\n         }\\n        \\n        for(int i=0; i<s.size(); i++)\\n         {\\n         if(s2[i]!=s[i])\\n         {\\n            count2++;\\n         }\\n        \\n         }\\n        count= min(count1, count2);\\n             \\n         \\n      }\\n      \\n       return count/2;\\n    }\\n      \\n  /*\\n  \"111000\"\\n\"010\"\\n\"1110\"\\n\"01\"\\n  */\\n    \\n};\\n\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  \\n   bool get(string s, int n)\\n   {\\n       int zero, one;\\n           zero=one=0;\\n      for(char f:s)\\n      {\\n        if(f==\\'0\\')\\n          zero++;\\n        else\\n          one++;\\n      }\\n     \\n      if(!(n&1))\\n      {\\n       return zero==one ? true: false;\\n      }\\n     else \\n     {\\n       return  abs(zero-one)==1 ? true :false;\\n     }\\n   }\\n  \\n    int minSwaps(string s) {\\n       \\n       int length=s.size();\\n      \\n       bool check= get(s,length);\\n        if(check==false)\\n          return -1;\\n         \\n      int zeroCount, oneCount;\\n      zeroCount=oneCount=0;\\n      string supposeTo=\"\";\\n      string s1,s2;\\n      \\n         if(length&1)\\n         {\\n           for(char f:s)\\n           {\\n              if(f==\\'0\\')\\n                 zeroCount++;\\n             else\\n             oneCount++;\\n           }\\n      \\n            if(zeroCount>oneCount)\\n            {\\n              int x= s.size();\\n              string require=\"0\";\\n              while(x--)\\n              {\\n               supposeTo+=require;\\n              if(require==\"0\"){\\n              require=\"1\";\\n              }else\\n              require=\"0\";\\n              }\\n            }\\n              else if(zeroCount<oneCount) \\n               {\\n                int x= s.size();\\n                string require=\"1\";\\n                 while(x--)\\n                  {\\n                    supposeTo+=require;\\n                    if(require==\"0\"){\\n                    require=\"1\";\\n                    }else\\n                    require=\"0\";\\n                   }\\n                       \\n                 }\\n      \\n         }\\n       \\n       else \\n       {\\n           int x= s.size();\\n           string require=\"0\";\\n           while(x--)\\n           {\\n           s1+=require;\\n           if(require==\"0\"){\\n             require=\"1\";\\n             }else\\n             require=\"0\";\\n            }\\n         \\n           require=\"1\";\\n            x= s.size();\\n           while(x--)\\n           {\\n            s2+=require;\\n            if(require==\"0\"){\\n             require=\"1\";\\n             }else\\n             require=\"0\";\\n            }\\n                     \\n       }\\n  \\n   \\n       int count=0;\\n       if(length&1){\\n             \\n      for(int i=0; i<s.size(); i++)\\n      {\\n    \\n         if(supposeTo[i]!=s[i])\\n         {\\n            count++;\\n         }\\n      }\\n         return (count/2);\\n      }\\n      \\n      else \\n      {\\n        int count1, count2;\\n         count1=count2=0;\\n         for(int i=0; i<s.size(); i++)\\n         {\\n         if(s1[i]!=s[i])\\n         {\\n            count1++;\\n         }\\n        \\n         }\\n        \\n        for(int i=0; i<s.size(); i++)\\n         {\\n         if(s2[i]!=s[i])\\n         {\\n            count2++;\\n         }\\n        \\n         }\\n        count= min(count1, count2);\\n             \\n         \\n      }\\n      \\n       return count/2;\\n    }\\n      \\n  /*\\n  \"111000\"\\n\"010\"\\n\"1110\"\\n\"01\"\\n  */\\n    \\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1217010,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        \\n        if abs(s.count(\\'0\\') - s.count(\\'1\\')) > 1:\\n            \\n            return -1\\n        \\n        def helper(ls1, ls2):\\n            \\n            return sum([i!= ls2[ix] for ix, i in enumerate(ls1)]) // 2\\n        \\n        if s.count(\\'0\\') > s.count(\\'1\\'):\\n            \\n            ans = \\'\\'.join(\\'01\\' for _ in range(len(s) // 2)) + \\'0\\'\\n            \\n            return helper(s, ans)\\n            \\n        \\n        elif s.count(\\'0\\') < s.count(\\'1\\'):\\n            \\n            ans = \\'\\'.join(\\'10\\' for _ in range(len(s) // 2)) + \\'1\\'\\n            \\n            return helper(s, ans)\\n        \\n        else:\\n            ans1 = \\'\\'.join(\\'01\\' for _ in range(len(s) // 2))\\n            ans2 = \\'\\'.join(\\'10\\' for _ in range(len(s) // 2))\\n            \\n            return min(helper(s, ans1), helper(s, ans2))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        \\n        if abs(s.count(\\'0\\') - s.count(\\'1\\')) > 1:\\n            \\n            return -1\\n        \\n        def helper(ls1, ls2):\\n            \\n            return sum([i!= ls2[ix] for ix, i in enumerate(ls1)]) // 2\\n        \\n        if s.count(\\'0\\') > s.count(\\'1\\'):\\n            \\n            ans = \\'\\'.join(\\'01\\' for _ in range(len(s) // 2)) + \\'0\\'\\n            \\n            return helper(s, ans)\\n            \\n        \\n        elif s.count(\\'0\\') < s.count(\\'1\\'):\\n            \\n            ans = \\'\\'.join(\\'10\\' for _ in range(len(s) // 2)) + \\'1\\'\\n            \\n            return helper(s, ans)\\n        \\n        else:\\n            ans1 = \\'\\'.join(\\'01\\' for _ in range(len(s) // 2))\\n            ans2 = \\'\\'.join(\\'10\\' for _ in range(len(s) // 2))\\n            \\n            return min(helper(s, ans1), helper(s, ans2))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1215107,
                "title": "ruby-solution",
                "content": "```\\n# @param {String} s\\n# @return {Integer}\\ndef min_swaps(s)\\n    s = s.chars.map {|ch| ch.to_i}\\n    return -1 if (s.length - s.sum * 2).abs > 1\\n    wrong1 = 0\\n    wrong2 = 0\\n    for i in 0...s.length\\n        wrong1 += 1 if s[i] != i % 2\\n        wrong2 += 1 if s[i] != (i+1) % 2\\n    end\\n    wrong1 += 1 if wrong1 % 2 == 1\\n    wrong2 += 1 if wrong2 % 2 == 1\\n    if s.length % 2 == 1\\n        if (s.length - s.sum * 2) < 0\\n            return wrong2 / 2\\n        else\\n            return wrong1 / 2\\n        end\\n    end\\n    [wrong1 / 2, wrong2 / 2].min\\nend\\n",
                "solutionTags": [],
                "code": "```\\n# @param {String} s\\n# @return {Integer}\\ndef min_swaps(s)\\n    s = s.chars.map {|ch| ch.to_i}\\n    return -1 if (s.length - s.sum * 2).abs > 1\\n    wrong1 = 0\\n    wrong2 = 0\\n    for i in 0...s.length\\n        wrong1 += 1 if s[i] != i % 2\\n        wrong2 += 1 if s[i] != (i+1) % 2\\n    end\\n    wrong1 += 1 if wrong1 % 2 == 1\\n    wrong2 += 1 if wrong2 % 2 == 1\\n    if s.length % 2 == 1\\n        if (s.length - s.sum * 2) < 0\\n            return wrong2 / 2\\n        else\\n            return wrong1 / 2\\n        end\\n    end\\n    [wrong1 / 2, wrong2 / 2].min\\nend\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1212908,
                "title": "short-and-fast",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        int zero=0,one=0,p=0,q=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'0\\') zero++;\\n            else one++;\\n        }\\n        if(abs(zero-one)>1) return -1;\\n        for(int i=0;i<s.length();i++){\\n            if(i%2==0 && s[i]==\\'0\\')p++;\\n            else if(i%2!=0 && s[i]==\\'0\\')q++;\\n        }\\n        if(one==zero)\\n        return min(p,q);\\n        return (zero>one )?q:p ;\\n    }\\n}; \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        int zero=0,one=0,p=0,q=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'0\\') zero++;\\n            else one++;\\n        }\\n        if(abs(zero-one)>1) return -1;\\n        for(int i=0;i<s.length();i++){\\n            if(i%2==0 && s[i]==\\'0\\')p++;\\n            else if(i%2!=0 && s[i]==\\'0\\')q++;\\n        }\\n        if(one==zero)\\n        return min(p,q);\\n        return (zero>one )?q:p ;\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1212790,
                "title": "python-3-six-simple-lines-with-simple-comments",
                "content": "```\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        count_swaps = lambda ch: sum(c != ch for c in s[::2])         # Define helper function to count swaps needed if we start with \\'ch\\'\\n        c0, c1 = s.count(\\'0\\'), s.count(\\'1\\')                           # Count 0s and 1s\\n        if c0 == c1: return min(count_swaps(\\'0\\'), count_swaps(\\'1\\'))   # If counts are equal, we could start with either 0 or 1\\n        if c0 == c1 + 1: return count_swaps(\\'0\\')                      # If one extra 0, we must start with 0\\n        if c1 == c0 + 1: return count_swaps(\\'1\\')                      # If one extra 1, we must start with 1\\n        return -1                                                     # There is an imbalance between 0s and 1s",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        count_swaps = lambda ch: sum(c != ch for c in s[::2])         # Define helper function to count swaps needed if we start with \\'ch\\'\\n        c0, c1 = s.count(\\'0\\'), s.count(\\'1\\')                           # Count 0s and 1s\\n        if c0 == c1: return min(count_swaps(\\'0\\'), count_swaps(\\'1\\'))   # If counts are equal, we could start with either 0 or 1\\n        if c0 == c1 + 1: return count_swaps(\\'0\\')                      # If one extra 0, we must start with 0\\n        if c1 == c0 + 1: return count_swaps(\\'1\\')                      # If one extra 1, we must start with 1\\n        return -1                                                     # There is an imbalance between 0s and 1s",
                "codeTag": "Java"
            },
            {
                "id": 1212412,
                "title": "java-o-n-super-simple-solution-beats-100",
                "content": "We track zeros at odd, even places and similalrly track them for ones.\\nNow if total zero/odd count diff `<1` then we can take the `min` on \\n - (assume string starts with zeros at even places) swap zeros at odd places with ones at even places if count of both is same, OR\\n - (assume string starts with ones at even places) swap zeros at even places with ones at odd places if count of both is same\\n\\n```\\nclass Solution {\\n    public int minSwaps(String s) {\\n        int ze = 0, zo = 0, oe = 0, oo = 0; // zero even, zero odd, one even, one odd counts\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (c == \\'0\\') {\\n                if (i%2 == 0) ze++;\\n                else zo++;\\n            } else {\\n                if (i%2 == 0) oe++;\\n                else oo++;\\n            }\\n        }\\n        \\n        if (Math.abs(ze+zo-oe-oo) > 1) return -1;\\n        int min = Integer.MAX_VALUE;\\n        if (zo == oe) {\\n            min = zo;\\n        }\\n        if (ze == oo) {\\n            min = Math.min(min, ze);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSwaps(String s) {\\n        int ze = 0, zo = 0, oe = 0, oo = 0; // zero even, zero odd, one even, one odd counts\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (c == \\'0\\') {\\n                if (i%2 == 0) ze++;\\n                else zo++;\\n            } else {\\n                if (i%2 == 0) oe++;\\n                else oo++;\\n            }\\n        }\\n        \\n        if (Math.abs(ze+zo-oe-oo) > 1) return -1;\\n        int min = Integer.MAX_VALUE;\\n        if (zo == oe) {\\n            min = zo;\\n        }\\n        if (ze == oo) {\\n            min = Math.min(min, ze);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1211938,
                "title": "java-o-n-beats-100",
                "content": "```\\nclass Solution {\\n    public int minSwaps(String s) {\\n        int len = s.length();\\n        int cntOne = 0 , cntZero = 0 , ans = 0;\\n        for(int i = 0 ; i < len ; i++) {\\n            if(s.charAt(i) == \\'1\\') cntOne++;\\n            else cntZero++;\\n        }\\n        if(len % 2 != 0) {\\n            if(Math.abs(cntOne - cntZero) != 1) return -1;\\n            char c = (cntOne > cntZero) ? \\'1\\' : \\'0\\';\\n            for(int i = 0 ; i < len ; i+=2) {\\n                if(s.charAt(i) != c) ans++;\\n            }\\n        } else {\\n            if(Math.abs(cntOne - cntZero) != 0) return -1;\\n            int oAtEven = 0 , zAtEven = 0;\\n            for(int i = 0 ; i < len ; i+=2) {\\n                if(s.charAt(i) == \\'1\\') oAtEven++;\\n                else zAtEven++;\\n            }\\n            if(oAtEven > zAtEven) ans = (len/2) - oAtEven;\\n            else if(oAtEven < zAtEven) ans = (len/2) - zAtEven;\\n            else ans+=oAtEven;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minSwaps(String s) {\\n        int len = s.length();\\n        int cntOne = 0 , cntZero = 0 , ans = 0;\\n        for(int i = 0 ; i < len ; i++) {\\n            if(s.charAt(i) == \\'1\\') cntOne++;\\n            else cntZero++;\\n        }\\n        if(len % 2 != 0) {\\n            if(Math.abs(cntOne - cntZero) != 1) return -1;\\n            char c = (cntOne > cntZero) ? \\'1\\' : \\'0\\';\\n            for(int i = 0 ; i < len ; i+=2) {\\n                if(s.charAt(i) != c) ans++;\\n            }\\n        } else {\\n            if(Math.abs(cntOne - cntZero) != 0) return -1;\\n            int oAtEven = 0 , zAtEven = 0;\\n            for(int i = 0 ; i < len ; i+=2) {\\n                if(s.charAt(i) == \\'1\\') oAtEven++;\\n                else zAtEven++;\\n            }\\n            if(oAtEven > zAtEven) ans = (len/2) - oAtEven;\\n            else if(oAtEven < zAtEven) ans = (len/2) - zAtEven;\\n            else ans+=oAtEven;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1211680,
                "title": "c-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int find(string s,int x)\\n    {\\n        int count=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]-\\'0\\'!=x)\\n            {\\n                count++;\\n            }\\n            x=x^1;\\n        }\\n        return count/2;\\n    }\\n    int minSwaps(string st) {\\n        int c0=count(st.begin(),st.end(),\\'0\\');\\n        int c1=count(st.begin(),st.end(),\\'1\\');\\n        if(abs(c0-c1)>1)\\n        {\\n            return -1;\\n        }\\n        if(c0>c1)\\n        {\\n            return find(st,0);\\n        }\\n        else if(c1>c0)\\n        {\\n            return find(st,1);\\n        }\\n        return min(find(st,1),find(st,0));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(string s,int x)\\n    {\\n        int count=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]-\\'0\\'!=x)\\n            {\\n                count++;\\n            }\\n            x=x^1;\\n        }\\n        return count/2;\\n    }\\n    int minSwaps(string st) {\\n        int c0=count(st.begin(),st.end(),\\'0\\');\\n        int c1=count(st.begin(),st.end(),\\'1\\');\\n        if(abs(c0-c1)>1)\\n        {\\n            return -1;\\n        }\\n        if(c0>c1)\\n        {\\n            return find(st,0);\\n        }\\n        else if(c1>c0)\\n        {\\n            return find(st,1);\\n        }\\n        return min(find(st,1),find(st,0));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1211501,
                "title": "simple-python-code-greedy-o-n",
                "content": "```\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        #Count no of \\'1\\' in string s\\n        even1,odd1=0,0\\n        for i,el in enumerate(s):\\n            if i%2==0:\\n                if el==\\'1\\':even1+=1\\n            else:\\n                if el==\\'1\\':odd1+=1\\n        n=len(s)\\n        count1=even1+odd1\\n        count0=n-count1\\n        if abs(count1-count0)>1:return -1    #Invalid\\n        if n%2==0:\\n            return min(even1,odd1)\\n        else:\\n            if count1>count0:return odd1\\n            else:return even1\\n\\n\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        #Count no of \\'1\\' in string s\\n        even1,odd1=0,0\\n        for i,el in enumerate(s):\\n            if i%2==0:\\n                if el==\\'1\\':even1+=1\\n            else:\\n                if el==\\'1\\':odd1+=1\\n        n=len(s)\\n        count1=even1+odd1\\n        count0=n-count1\\n        if abs(count1-count0)>1:return -1    #Invalid\\n        if n%2==0:\\n            return min(even1,odd1)\\n        else:\\n            if count1>count0:return odd1\\n            else:return even1\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1211343,
                "title": "simple-java-solution-beats-100",
                "content": "```\\nclass Solution {\\n    public int minSwaps(String s) {\\n        int count = 0;\\n        int countOfOne = 0;;\\n        for(int i=0; i<s.length(); i++) {\\n            \\n            char c = s.charAt(i);\\n            if(c==\\'1\\')\\n                countOfOne++;\\n            \\n            if(i%2==0) {// multiple of 2 should be zeroes\\n                if(c!=\\'0\\')\\n                    count++;\\n            }\\n            else if(c!=\\'1\\')\\n                count++;\\n        }\\n        int countOfZero = s.length()-countOfOne;\\n        if(Math.abs(countOfOne-countOfZero)>1 )\\n            return -1;\\n        \\n        int count2=0;\\n        for(int i=0; i<s.length(); i++) {\\n            char c = s.charAt(i);\\n            if(i%2==1) {// odd numbers should be zeroes\\n                if(c!=\\'0\\')\\n                    count2++;\\n            }\\n            else if(c!=\\'1\\')\\n                count2++;\\n        }\\n\\n        if(count%2==0)\\n            return count2%2==0? Math.min(count2/2, count/2) : count/2;\\n        if(count2%2==0)\\n            return count%2==0? Math.min(count2/2, count/2) : count2/2;\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSwaps(String s) {\\n        int count = 0;\\n        int countOfOne = 0;;\\n        for(int i=0; i<s.length(); i++) {\\n            \\n            char c = s.charAt(i);\\n            if(c==\\'1\\')\\n                countOfOne++;\\n            \\n            if(i%2==0) {// multiple of 2 should be zeroes\\n                if(c!=\\'0\\')\\n                    count++;\\n            }\\n            else if(c!=\\'1\\')\\n                count++;\\n        }\\n        int countOfZero = s.length()-countOfOne;\\n        if(Math.abs(countOfOne-countOfZero)>1 )\\n            return -1;\\n        \\n        int count2=0;\\n        for(int i=0; i<s.length(); i++) {\\n            char c = s.charAt(i);\\n            if(i%2==1) {// odd numbers should be zeroes\\n                if(c!=\\'0\\')\\n                    count2++;\\n            }\\n            else if(c!=\\'1\\')\\n                count2++;\\n        }\\n\\n        if(count%2==0)\\n            return count2%2==0? Math.min(count2/2, count/2) : count/2;\\n        if(count2%2==0)\\n            return count%2==0? Math.min(count2/2, count/2) : count2/2;\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1211283,
                "title": "simple-solution-in-java-100-faster-100-less-memory",
                "content": "Idea here is simple and straightforward. We want the string to be alternating .i.e. 1\\'s will either be at even indices or at odd indices only and vice versa for 0\\'s. In all other cases our answer would be -1 since it will not be possible to convert that string into an alternating one.\\n\\n Cases in which we return \"-1\" :\\n \\n a) if string is of odd length then the difference between the occurences of 1\\'s and 0\\'s can not be greater than 1. for.e.g. \"10101\" is a vaid string while \"1001000\" is not.\\n \\n b) if string is of even length then the difference between the frequency of 1\\'s and 0\\'s has to be 0  .i.e both the numbers have to occur equal number of times.\\n \\n Total number of swaps required :\\n \\n  a) the count of wrongly placed 0\\'s and 1\\'s gives us the number of swaps needed.\\n       i) When we assume that 1\\'s are at even places, then we increment our count anytime we encounter a 0 placed at even index or a 1 placed at odd index. \\n\\t   ii) When we assume that 1\\'s are at odd places, then we increment our count when we encounter a 0 placed at odd index or a 1 placed at even index.\\n\\t   \\nPoint to remember while returning :\\n\\t   i) Since we are counting both 0\\'s and 1\\'s at wrong places so we are basically doing a double count of misplaced digits. Hence when we return we need to make sure that this double count is taken care of. So, to ensure that, we divide our count value by 2 while returning.\\n \\n ```\\npublic int minSwaps(String s) {\\n        int count1=0,count2=0;\\n        for(int i=0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            if(ch==\\'0\\')\\n                count2++;\\n            else\\n                count1++;\\n        }\\n        if(Math.abs(count2-count1) > 1)\\n            return -1;\\n            \\n        //Case 1 : if 1\\'s exist at even places only\\n        int c1 = 0;\\n        for(int i=0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            if(ch-\\'0\\'==1 && i%2!=0)\\n                c1+=1;\\n            else if(ch==\\'0\\' && i%2==0)\\n                c1+=1;\\n        }\\n        //Case 2 : if 1\\'s exist at odd places only\\n        int c2 = 0;\\n        for(int i=0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            if(ch-\\'0\\'==1 && i%2==0)\\n                c2+=1;\\n            else if(ch==\\'0\\' && i%2!=0)\\n                c2+=1;\\n        }\\n        if(c1%2!=0)\\n            return c2/2;\\n        else if(c2%2!=0)\\n            return c1/2;\\n        return Math.min(c1,c2)/2;\\n    }\\n\\t```\\n\\t\\n\\tPlease upvote if it helps.",
                "solutionTags": [],
                "code": "```\\npublic int minSwaps(String s) {\\n        int count1=0,count2=0;\\n        for(int i=0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            if(ch==\\'0\\')\\n                count2++;\\n            else\\n                count1++;\\n        }\\n        if(Math.abs(count2-count1) > 1)\\n            return -1;\\n            \\n        //Case 1 : if 1\\'s exist at even places only\\n        int c1 = 0;\\n        for(int i=0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            if(ch-\\'0\\'==1 && i%2!=0)\\n                c1+=1;\\n            else if(ch==\\'0\\' && i%2==0)\\n                c1+=1;\\n        }\\n        //Case 2 : if 1\\'s exist at odd places only\\n        int c2 = 0;\\n        for(int i=0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            if(ch-\\'0\\'==1 && i%2==0)\\n                c2+=1;\\n            else if(ch==\\'0\\' && i%2!=0)\\n                c2+=1;\\n        }\\n        if(c1%2!=0)\\n            return c2/2;\\n        else if(c2%2!=0)\\n            return c1/2;\\n        return Math.min(c1,c2)/2;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1211239,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) \\n    {\\n     //start with 0 \\n       \\n        string s1=\"\",s2=\"\";\\n     for(int i=0;i<s.length();i++)\\n     {\\n         if(i%2==0)\\n         {\\n            s1=s1+\\'0\\';\\n         }\\n         else\\n         {\\n             s1=s1+\\'1\\';\\n         }\\n     }\\n    \\n    for(int i=0;i<s.length();i++)\\n     {\\n         if(i%2==0)\\n         {\\n            s2=s2+\\'1\\';\\n         }\\n         else\\n         {\\n              s2=s2+\\'0\\';\\n         }\\n     }\\n    int ones=0,zeros=0;\\n        \\n    for(int i=0;i<s.length();i++)\\n    {\\n        if(s[i]!=s1[i])\\n        {\\n            zeros++;\\n        }\\n        if(s[i]!=s2[i])\\n        {\\n            ones++;\\n        }\\n    }\\n  \\n    if(ones%2==1)\\n    {\\n        \\n        ones=INT_MAX;\\n    }\\n        else\\n        {\\n            ones=ones/2;\\n        }\\n        if(zeros%2==1)\\n        {\\n            zeros=INT_MAX;\\n        }\\n        else\\n        {\\n            zeros=zeros/2;\\n        }\\n             sort(s.begin(),s.end());\\n         sort(s1.begin(),s1.end());\\n    sort(s2.begin(),s2.end());\\n        if(s!=s1)\\n        {\\n            zeros=INT_MAX;\\n        }\\n        if(s!=s2)\\n        {\\n            ones=INT_MAX;\\n        }\\n        int ans=min(ones,zeros);\\n        if(ans==INT_MAX)\\n        {\\n            ans=-1;\\n        }\\n            return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) \\n    {\\n     //start with 0 \\n       \\n        string s1=\"\",s2=\"\";\\n     for(int i=0;i<s.length();i++)\\n     {\\n         if(i%2==0)\\n         {\\n            s1=s1+\\'0\\';\\n         }\\n         else\\n         {\\n             s1=s1+\\'1\\';\\n         }\\n     }\\n    \\n    for(int i=0;i<s.length();i++)\\n     {\\n         if(i%2==0)\\n         {\\n            s2=s2+\\'1\\';\\n         }\\n         else\\n         {\\n              s2=s2+\\'0\\';\\n         }\\n     }\\n    int ones=0,zeros=0;\\n        \\n    for(int i=0;i<s.length();i++)\\n    {\\n        if(s[i]!=s1[i])\\n        {\\n            zeros++;\\n        }\\n        if(s[i]!=s2[i])\\n        {\\n            ones++;\\n        }\\n    }\\n  \\n    if(ones%2==1)\\n    {\\n        \\n        ones=INT_MAX;\\n    }\\n        else\\n        {\\n            ones=ones/2;\\n        }\\n        if(zeros%2==1)\\n        {\\n            zeros=INT_MAX;\\n        }\\n        else\\n        {\\n            zeros=zeros/2;\\n        }\\n             sort(s.begin(),s.end());\\n         sort(s1.begin(),s1.end());\\n    sort(s2.begin(),s2.end());\\n        if(s!=s1)\\n        {\\n            zeros=INT_MAX;\\n        }\\n        if(s!=s2)\\n        {\\n            ones=INT_MAX;\\n        }\\n        int ans=min(ones,zeros);\\n        if(ans==INT_MAX)\\n        {\\n            ans=-1;\\n        }\\n            return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1211233,
                "title": "python-generating-2-possible-solutions-o-n",
                "content": "```\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        \\n        numZ, numO = 0, 0\\n        \\n        for ch in s:\\n            if ch == \\'0\\':\\n                numZ+= 1\\n            else:\\n                numO+= 1\\n        \\n        if abs(numZ - numO) > 1:\\n            return -1\\n        \\n        f, e = \\'0\\', \\'1\\'\\n        \\n        for i in range(1, len(s)):\\n            if i%2 != 0:\\n                f+= \\'1\\'\\n                e+= \\'0\\'\\n            else:\\n                f+= \\'0\\'\\n                e+= \\'1\\'\\n        c1, c2 = 0, 0\\n        for i in range(len(s)):\\n            if s[i] != f[i]:\\n                c1+= 1\\n            if s[i] != e[i]:\\n                c2+= 1\\n        #print(f, e)\\n        #print(c1, c2)\\n        if c1 % 2 != 0:\\n            return c2//2\\n        elif c2 % 2 != 0:\\n            return c1//2\\n        elif c1 < c2:\\n            return c1//2\\n        else:\\n            return c2//2\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        \\n        numZ, numO = 0, 0\\n        \\n        for ch in s:\\n            if ch == \\'0\\':\\n                numZ+= 1\\n            else:\\n                numO+= 1\\n        \\n        if abs(numZ - numO) > 1:\\n            return -1\\n        \\n        f, e = \\'0\\', \\'1\\'\\n        \\n        for i in range(1, len(s)):\\n            if i%2 != 0:\\n                f+= \\'1\\'\\n                e+= \\'0\\'\\n            else:\\n                f+= \\'0\\'\\n                e+= \\'1\\'\\n        c1, c2 = 0, 0\\n        for i in range(len(s)):\\n            if s[i] != f[i]:\\n                c1+= 1\\n            if s[i] != e[i]:\\n                c2+= 1\\n        #print(f, e)\\n        #print(c1, c2)\\n        if c1 % 2 != 0:\\n            return c2//2\\n        elif c2 % 2 != 0:\\n            return c1//2\\n        elif c1 < c2:\\n            return c1//2\\n        else:\\n            return c2//2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1211229,
                "title": "python-simulation",
                "content": "There are two possible final result, first start with 0, second start with 1, i.e, either be \"010101...\" or \"10101...\"\\n- Caculate each step to change original string to final result, notice, it\\'s counting how many steps to change, not to swap,\\n- Check weather it\\'s valid to make the change. It\\'s only valid to swap if the number of change 1->0 equals 0->1\\n- Compare all valid swap number, choose the min one\\n\\n```\\n\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        \\n        n = len(s)\\n        \\n        # 0101\\n        u, v = 0, 0\\n        \\n        # 1010\\n        p, q = 0, 0\\n        \\n        for i in range(n):\\n\\t\\t\\t#0101 \\n            # 0 -> 1\\n            if i % 2 == 0 and s[i] != \"0\":\\n                u += 1\\n            # 1-> 0\\n            if i % 2 == 1 and s[i] != \"1\":\\n                v += 1 \\n            \\n\\t\\t\\t#1010 \\n            # 0 -> 1\\n            if i % 2 == 0 and s[i] != \"1\":\\n                p += 1\\n            # 1-> 0\\n            if i % 2 == 1 and s[i] != \"0\":\\n                q += 1\\n        \\n\\t\\tif u != v and p != q:\\n            return -1\\n        if u != v:\\n            return p\\n        if p != q:\\n            return u\\n        \\n        return min(u, p)\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        \\n        n = len(s)\\n        \\n        # 0101\\n        u, v = 0, 0\\n        \\n        # 1010\\n        p, q = 0, 0\\n        \\n        for i in range(n):\\n\\t\\t\\t#0101 \\n            # 0 -> 1\\n            if i % 2 == 0 and s[i] != \"0\":\\n                u += 1\\n            # 1-> 0\\n            if i % 2 == 1 and s[i] != \"1\":\\n                v += 1 \\n            \\n\\t\\t\\t#1010 \\n            # 0 -> 1\\n            if i % 2 == 0 and s[i] != \"1\":\\n                p += 1\\n            # 1-> 0\\n            if i % 2 == 1 and s[i] != \"0\":\\n                q += 1\\n        \\n\\t\\tif u != v and p != q:\\n            return -1\\n        if u != v:\\n            return p\\n        if p != q:\\n            return u\\n        \\n        return min(u, p)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1211151,
                "title": "easy-to-understand-unique-python-solution-and-explanation-on-an-xor-contest",
                "content": "Right of the bat, we know that the valid sequences or the end result have to ALWAYS be either:\\n\\n```\\n01010101... or \\n10101010\\n```\\n\\nso we reverse engineer this and compute the difference between the given sequence and the end result to compute the number of swaps needed. We can do this with XOR operator. (Coincidently, second question also turned out to be XOR based).  For example, \\n\\n`100` would be \\n\\n```\\n  100\\n^ 010 <- one of the possible end sequence\\n  ---- \\n  110\\n  ``` \\n  (difference here is two positions) so we can do 1 swap to make it fit in right place\\n\\n```\\n  100\\n^ 101 <- one of the possible end sequence\\n ----\\n    1 \\n``` \\n(difference here is 1 which is an odd difference). There is absolutely no swaps we can do for odd number of differences because one will always be left over. \\n\\nTherefore in this case, we return 2//2 = 1 \\n\\nIf we encounter a number like 1000, I check early on that the diff between 0 and 1 should be no greater than or equal to 2. \\n\\n```\\ndef minSwaps(self, s: str) -> int:\\n        c = Counter(s)\\n        if abs(c[\\'0\\'] - c[\\'1\\']) >= 2:\\n          return -1\\n        \\n        def diff(start):\\n          alt = start\\n          res = 0\\n          for letter in s:\\n            res += (int(letter) ^ alt)\\n            alt = 1 - alt\\n          return res\\n        \\n        res1 = diff(0) # if the seq starts with 0, get the difference\\n        res2 = diff(1) # if the seq starts with 1, get the difference\\n        \\n        if res1 % 2 == 0 and res2 % 2 == 0:\\n          return min(res1//2, res2//2)\\n        else:\\n          if res1 % 2 == 0:\\n            return (res1 // 2)\\n          if res2 % 2 == 0:\\n            return (res2 // 2)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n01010101... or \\n10101010\\n```\n```\\n  100\\n^ 010 <- one of the possible end sequence\\n  ---- \\n  110\\n  ```\n```\\n  100\\n^ 101 <- one of the possible end sequence\\n ----\\n    1 \\n```\n```\\ndef minSwaps(self, s: str) -> int:\\n        c = Counter(s)\\n        if abs(c[\\'0\\'] - c[\\'1\\']) >= 2:\\n          return -1\\n        \\n        def diff(start):\\n          alt = start\\n          res = 0\\n          for letter in s:\\n            res += (int(letter) ^ alt)\\n            alt = 1 - alt\\n          return res\\n        \\n        res1 = diff(0) # if the seq starts with 0, get the difference\\n        res2 = diff(1) # if the seq starts with 1, get the difference\\n        \\n        if res1 % 2 == 0 and res2 % 2 == 0:\\n          return min(res1//2, res2//2)\\n        else:\\n          if res1 % 2 == 0:\\n            return (res1 // 2)\\n          if res2 % 2 == 0:\\n            return (res2 // 2)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1211117,
                "title": "c-o-n",
                "content": "public class Solution {\\n    public int MinSwaps(string s) {\\n        int count1=0, count0 =0;\\n        foreach(char c in s)\\n        {\\n            if(c==\\'0\\')\\n                count0++;\\n            else count1++;\\n        }\\n        \\n        if(Math.Abs(count0-count1)>1) return -1;\\n        int ret =0;\\n        if(count0>count1)\\n        {\\n            string alternateString= \"0\"+MakeAlternateString(\"1\", count1);\\n            ret = FindDiff(s, alternateString);\\n        }\\n        else if(count1>count0)\\n        {\\n            string alternateString= \"1\"+MakeAlternateString(\"0\",count0);\\n            ret = FindDiff(s, alternateString);\\n        }\\n        else if(count1 == count0)\\n        {\\n            string alternateString= MakeAlternateString(\"0\",count0);\\n            ret = FindDiff(s, alternateString);\\n            alternateString= MakeAlternateString(\"1\", count1);\\n            ret = Math.Min(ret, FindDiff(s, alternateString));\\n        }      \\n        return ret/2;\\n            \\n    }\\n    \\n    public string MakeAlternateString(string startDigit,int count)\\n    {\\n        /*1 : 3,  0:3*/\\n        string ret = \"\";\\n        string alternated = startDigit==\"0\"?\"1\":\"0\";\\n        \\n        while(count>0)\\n        {\\n            ret += startDigit+alternated;           \\n            count--;\\n        }\\n        return ret;            \\n            \\n    }\\n    \\n    public int FindDiff(string originalString,string alternateString)\\n    {\\n        int len = originalString.Length;\\n        int ret = 0;\\n        for(int i=0; i<len; i++)\\n        {\\n            if(originalString[i] != alternateString[i])\\n                ret++;\\n        }\\n        return ret;\\n            \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int MinSwaps(string s) {\\n        int count1=0, count0 =0;\\n        foreach(char c in s)\\n        {\\n            if(c==\\'0\\')\\n                count0++;\\n            else count1++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1211090,
                "title": "c-0ms-approach-with-explanation-o-n",
                "content": "We can construct the target alternating string in two ways\\n* Starting with a \\'0\\'\\n* Starting with a \\'1\\'\\n\\nSo, we do a single pass over the given string, considering both target results.\\nWe compare number of mismatches at each position with given string and target strings.\\nIf the number of mismatches for zeros equals the number of mismatches for ones, then it\\'s a valid string that can be converted into an alternate string.\\n\\nIt may happen that there can be two ways of forming the alternate string as stated previously. So we take the one with lowest number of mismatches, as this will result in lower number of swaps.\\n\\n```\\nSay we are given string 1110011000\\nNow, we can generate alternate sequence in two ways - starting with 0, and starting with 1.\\n\\nCase 1: starting with 0\\n\\n1110011000 (Given)\\n1010101010 (Target)\\n\\n\\tMismatching zeros = 2\\n\\tMismatching ones = 2\\n\\nCase 2: starting with 1\\n\\n1110011000 (Given)\\n0101010101 (Target)\\n\\n\\tMismatching zeros = 3\\n\\tMismatching ones = 3\\n\\n```\\n\\nIn the below code, we consider mismatching 0s in given sequence when compared to alternating sequence starting with 0 in `mismatchZeros[0]`. And we consider mismatching 1s in given sequence when compared to alternating sequence starting with 0 in `mismatchOnes[0]`.\\nSimilarly, when comparing given sequence to alternating sequence starting with 1, we store mismatching zeros in `mismatchZeros[1]` and mismatching ones in `mismatchOnes[1]`.\\n\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(string s)\\n    {\\n        int N = s.size();\\n        int mismatchZeros[2] = {}, mismatchOnes[2] = {};\\n        \\n        for (int i = 0, flip = 0; i < N; ++i, flip ^= 1)\\n        {\\n            if (s[i] == \\'0\\')\\n            {\\n                if (flip)\\n                    // we expect alternating sequence starting with 0 to have 1 here - FAILS\\n                    // we expect alternating sequence starting with 1 to have 0 here - HOLDS\\n                    ++mismatchZeros[0];\\n                else\\n                    // we expect alternating sequence starting with 0 to have 0 here - HOLDS\\n                    // we expect alternating sequence starting with 1 to have 1 here - FAILS\\n                    ++mismatchZeros[1];\\n            }\\n            else // s[i] == \\'1\\'\\n            {\\n                if (flip)\\n                    // we expect alternating sequence starting with 0 to have 1 here - HOLDS\\n                    // we expect alternating sequence starting with 1 to have 0 here - FAILS\\n                    ++mismatchOnes[1];\\n                else\\n                    // we expect alternating sequence starting with 0 to have 0 here - FAILS\\n                    // we expect alternating sequence starting with 1 to have 1 here - HOLDS\\n                    ++mismatchOnes[0];\\n            }\\n        }\\n        \\n        if (mismatchZeros[0] == mismatchOnes[0] && mismatchZeros[1] == mismatchOnes[1])\\n            return min(mismatchZeros[0], mismatchZeros[1]);\\n        else if (mismatchZeros[0] == mismatchOnes[0])\\n            return mismatchZeros[0];\\n        else if (mismatchZeros[1] == mismatchOnes[1])\\n            return mismatchZeros[1];\\n        else\\n            return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nSay we are given string 1110011000\\nNow, we can generate alternate sequence in two ways - starting with 0, and starting with 1.\\n\\nCase 1: starting with 0\\n\\n1110011000 (Given)\\n1010101010 (Target)\\n\\n\\tMismatching zeros = 2\\n\\tMismatching ones = 2\\n\\nCase 2: starting with 1\\n\\n1110011000 (Given)\\n0101010101 (Target)\\n\\n\\tMismatching zeros = 3\\n\\tMismatching ones = 3\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int minSwaps(string s)\\n    {\\n        int N = s.size();\\n        int mismatchZeros[2] = {}, mismatchOnes[2] = {};\\n        \\n        for (int i = 0, flip = 0; i < N; ++i, flip ^= 1)\\n        {\\n            if (s[i] == \\'0\\')\\n            {\\n                if (flip)\\n                    // we expect alternating sequence starting with 0 to have 1 here - FAILS\\n                    // we expect alternating sequence starting with 1 to have 0 here - HOLDS\\n                    ++mismatchZeros[0];\\n                else\\n                    // we expect alternating sequence starting with 0 to have 0 here - HOLDS\\n                    // we expect alternating sequence starting with 1 to have 1 here - FAILS\\n                    ++mismatchZeros[1];\\n            }\\n            else // s[i] == \\'1\\'\\n            {\\n                if (flip)\\n                    // we expect alternating sequence starting with 0 to have 1 here - HOLDS\\n                    // we expect alternating sequence starting with 1 to have 0 here - FAILS\\n                    ++mismatchOnes[1];\\n                else\\n                    // we expect alternating sequence starting with 0 to have 0 here - FAILS\\n                    // we expect alternating sequence starting with 1 to have 1 here - HOLDS\\n                    ++mismatchOnes[0];\\n            }\\n        }\\n        \\n        if (mismatchZeros[0] == mismatchOnes[0] && mismatchZeros[1] == mismatchOnes[1])\\n            return min(mismatchZeros[0], mismatchZeros[1]);\\n        else if (mismatchZeros[0] == mismatchOnes[0])\\n            return mismatchZeros[0];\\n        else if (mismatchZeros[1] == mismatchOnes[1])\\n            return mismatchZeros[1];\\n        else\\n            return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979483,
                "title": "simple-o-n-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) \\n    {\\n        string a=\"\";\\n        string b=\"\";\\n        int n=s.size();\\n        int o=0;\\n        int z=0;\\n        for(auto i: s) if(i==\\'1\\') o++; else z++;\\n        \\n        if(abs(z-o)>1) return -1;\\n        if(abs(z-o)==1)\\n        {\\n            if(z>o)\\n            {\\n                a+=\\'0\\';\\n                z--;\\n                while(z--)\\n                {\\n                    a+=\"10\";\\n                }\\n            }else\\n            {\\n                a+=\\'1\\';\\n                o--;\\n                while(o--)\\n                {\\n                    a+=\"01\";\\n                }\\n            }\\n            \\n            int c=0;\\n            for(int i=0; i<n; i++) if(a[i]!=s[i]) c++;\\n            // cout<<c<<endl;\\n            return c/2;\\n                \\n        }else\\n        {\\n            while(z--)\\n            {\\n                a+=\"01\";\\n            }\\n            \\n            while(o--)\\n            {\\n                b+=\"10\";\\n            }\\n            int c1=0;\\n            for(int i=0; i<n; i++) if(a[i]!=s[i]) c1++;\\n            int c2=0;\\n            for(int i=0; i<n; i++) if(b[i]!=s[i]) c2++;\\n            // cout<<c1<<endl;\\n            // cout<<c2<<endl;\\n            c1=c1/2;\\n            c2=c2/2;\\n            return min(c1,c2);\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) \\n    {\\n        string a=\"\";\\n        string b=\"\";\\n        int n=s.size();\\n        int o=0;\\n        int z=0;\\n        for(auto i: s) if(i==\\'1\\') o++; else z++;\\n        \\n        if(abs(z-o)>1) return -1;\\n        if(abs(z-o)==1)\\n        {\\n            if(z>o)\\n            {\\n                a+=\\'0\\';\\n                z--;\\n                while(z--)\\n                {\\n                    a+=\"10\";\\n                }\\n            }else\\n            {\\n                a+=\\'1\\';\\n                o--;\\n                while(o--)\\n                {\\n                    a+=\"01\";\\n                }\\n            }\\n            \\n            int c=0;\\n            for(int i=0; i<n; i++) if(a[i]!=s[i]) c++;\\n            // cout<<c<<endl;\\n            return c/2;\\n                \\n        }else\\n        {\\n            while(z--)\\n            {\\n                a+=\"01\";\\n            }\\n            \\n            while(o--)\\n            {\\n                b+=\"10\";\\n            }\\n            int c1=0;\\n            for(int i=0; i<n; i++) if(a[i]!=s[i]) c1++;\\n            int c2=0;\\n            for(int i=0; i<n; i++) if(b[i]!=s[i]) c2++;\\n            // cout<<c1<<endl;\\n            // cout<<c2<<endl;\\n            c1=c1/2;\\n            c2=c2/2;\\n            return min(c1,c2);\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3963260,
                "title": "c-faster-100",
                "content": "**Code**\\n```c++\\nint minSwaps(string s) {\\n    int n = s.size();\\n    \\n    auto check_if_invalid = [&]() -> pair<bool, char> {\\n        auto one = count(s.begin(), s.end(), \\'1\\'), zero = n - one;\\n        if (s.size() & 1) {\\n            if (abs(one - zero) > 1) return {true, \\' \\'};\\n        } else if (one != zero) return {true, \\' \\'};\\n        return {false, one == zero ? \\' \\' : one > zero ? \\'1\\': \\'0\\'};\\n    };\\n    auto [is_invalid, flag] = check_if_invalid();\\n    if (is_invalid) return -1;\\n    \\n    auto check = [&](auto token) {\\n        char look_for = token; int defaulter = 0;\\n        for (auto c: s) {\\n            if (c != look_for) defaulter++;\\n            look_for = look_for == \\'1\\' ? \\'0\\' : \\'1\\';\\n        }\\n        return defaulter;\\n    };\\n    \\n    if (flag == \\' \\') return min(check(\\'1\\'), check(\\'0\\')) / 2; \\n    else return (check(flag) + 1) / 2 ; \\n}\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6 [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1700+ solutions.**",
                "solutionTags": [],
                "code": "```c++\\nint minSwaps(string s) {\\n    int n = s.size();\\n    \\n    auto check_if_invalid = [&]() -> pair<bool, char> {\\n        auto one = count(s.begin(), s.end(), \\'1\\'), zero = n - one;\\n        if (s.size() & 1) {\\n            if (abs(one - zero) > 1) return {true, \\' \\'};\\n        } else if (one != zero) return {true, \\' \\'};\\n        return {false, one == zero ? \\' \\' : one > zero ? \\'1\\': \\'0\\'};\\n    };\\n    auto [is_invalid, flag] = check_if_invalid();\\n    if (is_invalid) return -1;\\n    \\n    auto check = [&](auto token) {\\n        char look_for = token; int defaulter = 0;\\n        for (auto c: s) {\\n            if (c != look_for) defaulter++;\\n            look_for = look_for == \\'1\\' ? \\'0\\' : \\'1\\';\\n        }\\n        return defaulter;\\n    };\\n    \\n    if (flag == \\' \\') return min(check(\\'1\\'), check(\\'0\\')) / 2; \\n    else return (check(flag) + 1) / 2 ; \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3937696,
                "title": "easiest-possible-solution-cpp-simple-no-external-data-structure",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n       int n = s.size();\\n       int cnte=0,cnto=0;\\n       for(int i=0;i<n;i+=2)\\n       cnte+=s[i]==\\'1\\';\\n       for(int i=1;i<n;i+=2)\\n       cnto+=s[i]==\\'1\\';\\n\\n       if(n%2==1){\\n           if(cnto+cnte==n/2)\\n           return cnte;\\n           if(cnto+cnte==n/2+1)\\n           return cnto;\\n       }\\n       else{\\n           if(cnto+cnte==n/2)\\n           return min(cnto,cnte);\\n       }\\n\\n       return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n       int n = s.size();\\n       int cnte=0,cnto=0;\\n       for(int i=0;i<n;i+=2)\\n       cnte+=s[i]==\\'1\\';\\n       for(int i=1;i<n;i+=2)\\n       cnto+=s[i]==\\'1\\';\\n\\n       if(n%2==1){\\n           if(cnto+cnte==n/2)\\n           return cnte;\\n           if(cnto+cnte==n/2+1)\\n           return cnto;\\n       }\\n       else{\\n           if(cnto+cnte==n/2)\\n           return min(cnto,cnte);\\n       }\\n\\n       return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3877495,
                "title": "100-faster-javascript-greedy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minSwaps = function(str) {\\n    \\n    let check = (alter) => {\\n        let count1need = 0, count0need = 0;\\n        for(let s of str){\\n            if(s != alter){\\n                if(alter == 0) count0need++;\\n                else count1need++;\\n            }\\n            alter = !alter;\\n        } \\n        return count1need == count0need ? count0need : -1;\\n    }  \\n    let check1 = check(0);\\n    let check2 = check(1);\\n    if(check1 == -1 && check2 == -1) return -1;\\n\\n    return Math.min(check1 ==  -1 ? Infinity : check1 , \\n                    check2 ==  -1 ? Infinity : check2);\\n\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minSwaps = function(str) {\\n    \\n    let check = (alter) => {\\n        let count1need = 0, count0need = 0;\\n        for(let s of str){\\n            if(s != alter){\\n                if(alter == 0) count0need++;\\n                else count1need++;\\n            }\\n            alter = !alter;\\n        } \\n        return count1need == count0need ? count0need : -1;\\n    }  \\n    let check1 = check(0);\\n    let check2 = check(1);\\n    if(check1 == -1 && check2 == -1) return -1;\\n\\n    return Math.min(check1 ==  -1 ? Infinity : check1 , \\n                    check2 ==  -1 ? Infinity : check2);\\n\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3846144,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSwaps(char ch,string &s)\\n    {\\n        int cnt=0;\\n        for (int i=0;i<s.size();i++)\\n        {\\n            if (i%2==0)\\n            {\\n                if (s[i]!=ch) cnt++;\\n            }\\n            else \\n            {\\n                if (s[i]==ch) cnt++;\\n            }\\n        }\\n        return cnt/2;\\n    }\\n    int minSwaps(string s) \\n    {\\n        int one=0;\\n        int zero=0;\\n        int n=s.size();\\n        for (int i=0;i<s.size();i++)\\n        {\\n            if (s[i]==\\'0\\') zero++;\\n            else one++;\\n        }\\n        if (n%2==1)\\n        {\\n        if (zero+1==one)\\n        {\\n            return countSwaps(\\'1\\',s);\\n        }\\n        else if (one+1==zero)\\n        {\\n            return countSwaps(\\'0\\',s);\\n        }\\n        }\\n        if (zero!=one) return -1;\\n        return min(countSwaps(\\'0\\',s),countSwaps(\\'1\\',s));\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSwaps(char ch,string &s)\\n    {\\n        int cnt=0;\\n        for (int i=0;i<s.size();i++)\\n        {\\n            if (i%2==0)\\n            {\\n                if (s[i]!=ch) cnt++;\\n            }\\n            else \\n            {\\n                if (s[i]==ch) cnt++;\\n            }\\n        }\\n        return cnt/2;\\n    }\\n    int minSwaps(string s) \\n    {\\n        int one=0;\\n        int zero=0;\\n        int n=s.size();\\n        for (int i=0;i<s.size();i++)\\n        {\\n            if (s[i]==\\'0\\') zero++;\\n            else one++;\\n        }\\n        if (n%2==1)\\n        {\\n        if (zero+1==one)\\n        {\\n            return countSwaps(\\'1\\',s);\\n        }\\n        else if (one+1==zero)\\n        {\\n            return countSwaps(\\'0\\',s);\\n        }\\n        }\\n        if (zero!=one) return -1;\\n        return min(countSwaps(\\'0\\',s),countSwaps(\\'1\\',s));\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3816670,
                "title": "counting-ones-and-zeros",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n Count 0s and 1s,\\n E.g. if we expect 1 on the EVEN index but got 0 we borrow 1 and add an extra 0\\nWhen we face the next mismatch on an ODD index (expect 0 but got 1) we do opposite\\n borrow 0 and add 1 as extra\\n Example \\n 1 0 0 0 1 1 0\\n 1 0 1 0 1 0 0\\n If we expect 1 on even indexes we can not form a valid string\\n but if we expect 0 on even indexes we can     \\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nvar minSwaps = function(s) {\\n    const fmap={};\\n    for(const d of s) fmap[d]=fmap[d]+1||1;\\n    if(s.length===1) return 0;\\n    if(s.length%2===0 && fmap[\\'1\\']!==fmap[\\'0\\']) return -1;\\n    if(s.length%2===1 && Math.abs(fmap[\\'1\\']-fmap[\\'0\\'])!==1) return -1;\\n\\n    const swaps=(expectOnEven)=>{\\n      let borrow=0, extra=0, swaps=0;\\n      for(let i=0;i<s.length;i++){\\n        if(i%2===0){ // expecting 1\\n          if(s[i]!==expectOnEven){   // we got what we didn\\'t expect e.g expecting 1 but got 0\\n            borrow--;extra++; swaps++; // we need to borrow 1 and we have extra zero for future swap\\n          }\\n        }else{\\n          if(s[i]===expectOnEven){ // we got what we didn\\'t expect e.g expecting 0 but got 1\\n            borrow++;extra--;        // we borrow 0 and we have extra 1\\n          }\\n        }\\n      }\\n      if(borrow===0 && extra===0) return swaps; // if all 1s and 0s rearaged as needed return swaps\\n      return Number.MAX_SAFE_INTEGER; // otherwise we can not swap\\n    }\\n\\n    const minSwaps=Math.min(swaps(\\'0\\'), swaps(\\'1\\'));\\n    return (minSwaps===Number.MAX_SAFE_INTEGER)?-1:minSwaps;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minSwaps = function(s) {\\n    const fmap={};\\n    for(const d of s) fmap[d]=fmap[d]+1||1;\\n    if(s.length===1) return 0;\\n    if(s.length%2===0 && fmap[\\'1\\']!==fmap[\\'0\\']) return -1;\\n    if(s.length%2===1 && Math.abs(fmap[\\'1\\']-fmap[\\'0\\'])!==1) return -1;\\n\\n    const swaps=(expectOnEven)=>{\\n      let borrow=0, extra=0, swaps=0;\\n      for(let i=0;i<s.length;i++){\\n        if(i%2===0){ // expecting 1\\n          if(s[i]!==expectOnEven){   // we got what we didn\\'t expect e.g expecting 1 but got 0\\n            borrow--;extra++; swaps++; // we need to borrow 1 and we have extra zero for future swap\\n          }\\n        }else{\\n          if(s[i]===expectOnEven){ // we got what we didn\\'t expect e.g expecting 0 but got 1\\n            borrow++;extra--;        // we borrow 0 and we have extra 1\\n          }\\n        }\\n      }\\n      if(borrow===0 && extra===0) return swaps; // if all 1s and 0s rearaged as needed return swaps\\n      return Number.MAX_SAFE_INTEGER; // otherwise we can not swap\\n    }\\n\\n    const minSwaps=Math.min(swaps(\\'0\\'), swaps(\\'1\\'));\\n    return (minSwaps===Number.MAX_SAFE_INTEGER)?-1:minSwaps;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3784276,
                "title": "c-o-n-simple-logic-faster-solution",
                "content": "Approach is simple either we can make **010101**... or **101010**... so whichever pattern takes less swaps is our answer.\\n\\nI have take four counters **a1,a0,c1,c0** which will simply **check misplacement** of the 0 or 1 in the pattern.\\n\\nfor pattern 101010...\\n1. a1 and a0 are for misplacement in 101010.. pattern where a1 counts misplacement of 1 in this pattern as we can see 1 appears in even position so simply whenever it is even and it is not 1 in the character while traversing we will increment a1.\\n\\n2. similar to a1 we have a0 which is for misplacement in 0 and 0 appears in odd position so when it is odd position and not 0 increment a0.\\n\\nfor pattern 01010...\\nsimilar to above pattern just the flip logic and increment c0 and c1.\\n\\nat last if c0 == c1 and a0 == a1 that means we have similar 0\\'s and 1\\'s which can be swapped so which ever pattern is giving us minimum ans is our ans.\\n\\nElse if they are not equal then who ever pattern has got same number of 0\\'s misplacement and 1\\'s misplacement is our ans.\\n\\nand if no pattern has got similar 0\\'s and 1\\'s misplacement that means we can not make the string alternating by swapping the 0\\'s with 1\\'s simply return -1.\\n\\n\\n```\\nclass Solution {\\npublic:\\n\\t// approach\\n    // 111000\\n    // 010101 or 101010\\n    int minSwaps(string s) {\\n        int n = s.size();\\n        int c1 = 0 , c0 = 0;\\n        int a1 = 0, a0 = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            if(i%2 == 0 && s[i] == \\'0\\') a1++;\\n            if(i%2 == 0 && s[i] == \\'1\\') c1++;\\n            if(i%2 != 0 && s[i] == \\'0\\') c0++;\\n            if(i%2 != 0 && s[i] == \\'1\\') a0++;\\n        }\\n        int ans = -1;\\n        if(c1 == c0 && a1 == a0){\\n            ans = min(c1,a1);\\n        }\\n        else if(c1 == c0){\\n            ans = c1;\\n        }\\n        else if(a1 == a0){\\n            ans = a1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t// approach\\n    // 111000\\n    // 010101 or 101010\\n    int minSwaps(string s) {\\n        int n = s.size();\\n        int c1 = 0 , c0 = 0;\\n        int a1 = 0, a0 = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            if(i%2 == 0 && s[i] == \\'0\\') a1++;\\n            if(i%2 == 0 && s[i] == \\'1\\') c1++;\\n            if(i%2 != 0 && s[i] == \\'0\\') c0++;\\n            if(i%2 != 0 && s[i] == \\'1\\') a0++;\\n        }\\n        int ans = -1;\\n        if(c1 == c0 && a1 == a0){\\n            ans = min(c1,a1);\\n        }\\n        else if(c1 == c0){\\n            ans = c1;\\n        }\\n        else if(a1 == a0){\\n            ans = a1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766556,
                "title": "simple-solution-o-n-beats-100-00-of-users-with-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe final string has to alternate between 0 and 1. \\n==> Solution a starts with 0 \"01010101...\"\\n==> Solution b starts with 1 \"10101010...\"\\nCompare two results and pick the minimum swaps one.\\n\\nException: number of 0 to swap with 1 is not the same and vice versa.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCount missplaces 0 and 1 and check if swapping is possible. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\n    int minSwaps(const string &s, bool alternating){\\n        int countSwapsZeros = 0, countSwapsOnes = 0;\\n\\n        for(const auto c : s){\\n            if(alternating){\\n                countSwapsOnes  += c == \\'1\\' ? 0 : 1;\\n            }else{\\n                countSwapsZeros  += c == \\'0\\' ? 0 : 1;\\n            }\\n\\n            alternating = !alternating;\\n        }\\n\\n        return countSwapsZeros == countSwapsOnes ? countSwapsZeros : INT_MAX;\\n    }\\npublic:\\n    int minSwaps(const string &s) {\\n        const int swaps = min(minSwaps(s, true), minSwaps(s, false));\\n        return swaps == INT_MAX ? -1 : swaps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int minSwaps(const string &s, bool alternating){\\n        int countSwapsZeros = 0, countSwapsOnes = 0;\\n\\n        for(const auto c : s){\\n            if(alternating){\\n                countSwapsOnes  += c == \\'1\\' ? 0 : 1;\\n            }else{\\n                countSwapsZeros  += c == \\'0\\' ? 0 : 1;\\n            }\\n\\n            alternating = !alternating;\\n        }\\n\\n        return countSwapsZeros == countSwapsOnes ? countSwapsZeros : INT_MAX;\\n    }\\npublic:\\n    int minSwaps(const string &s) {\\n        const int swaps = min(minSwaps(s, true), minSwaps(s, false));\\n        return swaps == INT_MAX ? -1 : swaps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714961,
                "title": "java-simple-linear-time",
                "content": "\\n```\\nclass Solution {\\n    public int minSwaps(String s) {\\n        int ones = 0, zeros = 0;\\n        for(char c : s.toCharArray()) {\\n            if(c == \\'0\\')\\n                zeros++;\\n            if(c == \\'1\\')\\n                ones++;\\n        }\\n        if(Math.abs(ones - zeros) > 1) return -1;\\n\\n        StringBuilder ideal1 = new StringBuilder();\\n        StringBuilder ideal2 = new StringBuilder();\\n        for(int i=0; i<s.length(); i++) {\\n            ideal1.append(i%2==0 ? 0 : 1);\\n            ideal2.append(i%2==0 ? 1 : 0);\\n        }\\n        int count1 = 0, count2=0;\\n        for(int i=0; i<s.length(); i++) {\\n            if(s.charAt(i) != ideal1.charAt(i))\\n                count1++;\\n            if(s.charAt(i) != ideal2.charAt(i))\\n                count2++;\\n        }\\n\\n        int ret1 = Integer.MAX_VALUE, ret2 = Integer.MAX_VALUE;\\n        if(count1%2 == 0) \\n            ret1 = count1 / 2;\\n\\n        if(count2%2 == 0) \\n            ret2 = count2 / 2;\\n\\n        return ret1 == Integer.MAX_VALUE && ret2 == Integer.MAX_VALUE ? -1 : Math.min(ret1, ret2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSwaps(String s) {\\n        int ones = 0, zeros = 0;\\n        for(char c : s.toCharArray()) {\\n            if(c == \\'0\\')\\n                zeros++;\\n            if(c == \\'1\\')\\n                ones++;\\n        }\\n        if(Math.abs(ones - zeros) > 1) return -1;\\n\\n        StringBuilder ideal1 = new StringBuilder();\\n        StringBuilder ideal2 = new StringBuilder();\\n        for(int i=0; i<s.length(); i++) {\\n            ideal1.append(i%2==0 ? 0 : 1);\\n            ideal2.append(i%2==0 ? 1 : 0);\\n        }\\n        int count1 = 0, count2=0;\\n        for(int i=0; i<s.length(); i++) {\\n            if(s.charAt(i) != ideal1.charAt(i))\\n                count1++;\\n            if(s.charAt(i) != ideal2.charAt(i))\\n                count2++;\\n        }\\n\\n        int ret1 = Integer.MAX_VALUE, ret2 = Integer.MAX_VALUE;\\n        if(count1%2 == 0) \\n            ret1 = count1 / 2;\\n\\n        if(count2%2 == 0) \\n            ret2 = count2 / 2;\\n\\n        return ret1 == Integer.MAX_VALUE && ret2 == Integer.MAX_VALUE ? -1 : Math.min(ret1, ret2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3672120,
                "title": "python3-counting-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        ones = 0\\n        zeros = 0\\n\\n        odd_one = 0\\n        even_one = 0\\n        odd_zero = 0\\n        even_zero = 0\\n        for i in range(len(s)):\\n            if i%2==0:\\n                if s[i]==\\'0\\':\\n                    even_zero+=1\\n                else:\\n                    even_one+=1\\n            else:\\n                if s[i]==\\'0\\':\\n                    odd_zero+=1\\n                else:\\n                    odd_one+=1\\n\\n            if s[i]==\\'0\\':\\n                zeros += 1\\n            else:\\n                ones += 1\\n        if abs(ones - zeros) > 1: return -1\\n\\n        if ones==zeros:\\n            if odd_one >= even_one:\\n                return even_one\\n            else:\\n                return odd_one\\n        elif ones > zeros:\\n            return odd_one\\n        else:\\n            return odd_zero\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        ones = 0\\n        zeros = 0\\n\\n        odd_one = 0\\n        even_one = 0\\n        odd_zero = 0\\n        even_zero = 0\\n        for i in range(len(s)):\\n            if i%2==0:\\n                if s[i]==\\'0\\':\\n                    even_zero+=1\\n                else:\\n                    even_one+=1\\n            else:\\n                if s[i]==\\'0\\':\\n                    odd_zero+=1\\n                else:\\n                    odd_one+=1\\n\\n            if s[i]==\\'0\\':\\n                zeros += 1\\n            else:\\n                ones += 1\\n        if abs(ones - zeros) > 1: return -1\\n\\n        if ones==zeros:\\n            if odd_one >= even_one:\\n                return even_one\\n            else:\\n                return odd_one\\n        elif ones > zeros:\\n            return odd_one\\n        else:\\n            return odd_zero\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659789,
                "title": "greedy-o-n",
                "content": "1. Its obvious that alternating string of 2 chars must be either \\'01010101\\' or \\'1010101\\' \\n2. Try to convert the original string to the possible alternating strings by swapping the mismatching characters\\n3. If there is a mismatch at index, then there should be a chance to swap it in the upcoming indices \\n4. Store the count of mismatches if they can be swapped later\\n5. If the mismatches are not swapped at the end, then that means the string can\\'t be converted to our possible alternating string, so return inf \\n6. Our answer is the minimum count of swaps required to convert the original string to two possible alternating strings\\n        \\nTime Complexity: O(N) \\n\\n        n = len(s)\\n        alt1 = \\'01\\' * (n//2) + (\\'0\\' if n&1 else \\'\\') \\n        alt2 = \\'10\\' * (n//2) + (\\'1\\' if n&1 else \\'\\')\\n                \\n        def find(alt,res):\\n            zeroMismatch, oneMismatch = 0,0\\n            for i,j in zip(s,alt): \\n                if i==\\'0\\' and j==\\'1\\': \\n                    if oneMismatch: \\n                        oneMismatch-=1 \\n                        res+=1\\n                    else: \\n                        zeroMismatch += 1 \\n                if i==\\'1\\' and j==\\'0\\': \\n                    if zeroMismatch: \\n                        zeroMismatch-=1\\n                        res+=1\\n                    else:\\n                        oneMismatch += 1 \\n            return res if not zeroMismatch and not oneMismatch else inf\\n                    \\n        ans = min(find(alt1,0),find(alt2,0))\\n        return ans if ans != inf else -1\\n    \\n",
                "solutionTags": [],
                "code": "1. Its obvious that alternating string of 2 chars must be either \\'01010101\\' or \\'1010101\\' \\n2. Try to convert the original string to the possible alternating strings by swapping the mismatching characters\\n3. If there is a mismatch at index, then there should be a chance to swap it in the upcoming indices \\n4. Store the count of mismatches if they can be swapped later\\n5. If the mismatches are not swapped at the end, then that means the string can\\'t be converted to our possible alternating string, so return inf \\n6. Our answer is the minimum count of swaps required to convert the original string to two possible alternating strings\\n        \\nTime Complexity: O(N) \\n\\n        n = len(s)\\n        alt1 = \\'01\\' * (n//2) + (\\'0\\' if n&1 else \\'\\') \\n        alt2 = \\'10\\' * (n//2) + (\\'1\\' if n&1 else \\'\\')\\n                \\n        def find(alt,res):\\n            zeroMismatch, oneMismatch = 0,0\\n            for i,j in zip(s,alt): \\n                if i==\\'0\\' and j==\\'1\\': \\n                    if oneMismatch: \\n                        oneMismatch-=1 \\n                        res+=1\\n                    else: \\n                        zeroMismatch += 1 \\n                if i==\\'1\\' and j==\\'0\\': \\n                    if zeroMismatch: \\n                        zeroMismatch-=1\\n                        res+=1\\n                    else:\\n                        oneMismatch += 1 \\n            return res if not zeroMismatch and not oneMismatch else inf\\n                    \\n        ans = min(find(alt1,0),find(alt2,0))\\n        return ans if ans != inf else -1\\n    \\n",
                "codeTag": "Python3"
            },
            {
                "id": 3630712,
                "title": "simple-python3-solution-with-counting",
                "content": "# Code\\n```\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        cnt0 = cnt1 = miss0 = miss1 = 0\\n\\n        # Count the number of zeros and ones\\n        for char in s:\\n            if char == \"0\":\\n                cnt0+=1\\n\\n            else:\\n                cnt1+=1\\n\\n        if abs(cnt0 - cnt1) > 1: # Edge case: To make alternating, absolute difference between\\n        # count of 0 and countof 1 should never exceed one.\\n            return -1\\n\\n        # Now, for each even index, count the misses for 1 and 0, according to the character\\n        # present at that index. \\n        # Why check only the even indices? Because:\\n        # 1. If cnt0 > cnt1, then the number of 0 misses will give the final answer. Since the \\n        # sequence will start with 0, and 0 will occur at 0, 2, 4... indices.\\n        # 2. If cnt1 > cnt0, then the number of 1 misses will give the final answer. Since the \\n        # sequence will start with 1, and 1 will occur at 0, 2, 4... indices.\\n        # 3. Finally, if cnt0 == cnt1, then if miss0 < miss1, then miss0 is the minimum number\\n        # character swaps that are needed, otherwise miss1 is the minimum number character \\n        # swaps that are needed.\\n        for i in range(0, len(s), 2):\\n            if s[i] == \"0\":\\n                miss1+=1\\n\\n            else:\\n                miss0+=1\\n\\n        if cnt0 > cnt1:\\n            return miss0\\n\\n        elif cnt0 < cnt1:\\n            return miss1\\n\\n        else:\\n            return min(miss0, miss1)\\n\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Counting"
                ],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        cnt0 = cnt1 = miss0 = miss1 = 0\\n\\n        # Count the number of zeros and ones\\n        for char in s:\\n            if char == \"0\":\\n                cnt0+=1\\n\\n            else:\\n                cnt1+=1\\n\\n        if abs(cnt0 - cnt1) > 1: # Edge case: To make alternating, absolute difference between\\n        # count of 0 and countof 1 should never exceed one.\\n            return -1\\n\\n        # Now, for each even index, count the misses for 1 and 0, according to the character\\n        # present at that index. \\n        # Why check only the even indices? Because:\\n        # 1. If cnt0 > cnt1, then the number of 0 misses will give the final answer. Since the \\n        # sequence will start with 0, and 0 will occur at 0, 2, 4... indices.\\n        # 2. If cnt1 > cnt0, then the number of 1 misses will give the final answer. Since the \\n        # sequence will start with 1, and 1 will occur at 0, 2, 4... indices.\\n        # 3. Finally, if cnt0 == cnt1, then if miss0 < miss1, then miss0 is the minimum number\\n        # character swaps that are needed, otherwise miss1 is the minimum number character \\n        # swaps that are needed.\\n        for i in range(0, len(s), 2):\\n            if s[i] == \"0\":\\n                miss1+=1\\n\\n            else:\\n                miss0+=1\\n\\n        if cnt0 > cnt1:\\n            return miss0\\n\\n        elif cnt0 < cnt1:\\n            return miss1\\n\\n        else:\\n            return min(miss0, miss1)\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630597,
                "title": "best-solution-and-easy-to-understand-beats-100-step-by-step-approach",
                "content": "# Intuition\\nThe code aims to find the minimum number of character swaps required to make a binary string alternating. It checks the count of \\'0\\' and \\'1\\' characters in the string and determines whether it is possible to make the string alternating. If it is possible, the code calls the solve function to calculate the minimum swaps required by considering each possible character (\\'0\\' and \\'1\\').\\n\\n# Approach\\nStep1->Check the length of the string. If it is 1, return 0 as no swaps are needed.\\n\\nStep2->Create an unordered map mp to count the occurrences of \\'0\\' and \\'1\\' characters in the string.\\n\\nStep3->Check if either \\'0\\' or \\'1\\' is absent in the string. If true, return -1 as it is impossible to make the string alternating.\\n\\nStep4->Check if the absolute difference between the counts of \\'1\\' and \\'0\\' is greater than 1. If true, return -1 as it is impossible to make the string alternating.\\n\\nStep5->Determine the character (\\'0\\' or \\'1\\') that occurs more frequently in the string.\\n\\nStep6->Call the solve function to calculate the minimum swaps required to make the string alternating by considering the determined character.\\n\\nStep7->If both \\'0\\' and \\'1\\' occur the same number of times, return the minimum of the minimum swaps required for \\'0\\' and \\'1\\'.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nLet n be the length of the input string \\'s\\'. Calculating the count of characters in the string takes O(n) time. The solve function iterates through half of the string length, so it takes O(n/2) time. Overall, the time complexity is O(n).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(n) because of the unordered map mp that stores the count of \\'0\\' and \\'1\\' characters in the string.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint solve(string& s, char c) {\\n        int count = 0;\\n        for (int i = 0; i < s.length(); i += 2) {\\n            if (s[i] != c) count++;\\n        }\\n        return count;\\n    }\\n    int minSwaps(string s) {\\n        int n=s.length();\\n        if(n==1)\\n        {\\n            return 0;\\n        }\\n        unordered_map<char,int> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[s[i]]++;\\n        }\\n        if(abs(mp[\\'1\\']-mp[\\'0\\'])>1)\\n        {\\n            return -1;\\n        }\\n        if(mp[\\'0\\']>mp[\\'1\\'])\\n        {\\n            return solve(s,\\'0\\');\\n        }\\n        else if(mp[\\'1\\']>mp[\\'0\\'])\\n        {\\n            return solve(s,\\'1\\');\\n        }\\n        else\\n        return min(solve(s,\\'0\\'),solve(s,\\'1\\'));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint solve(string& s, char c) {\\n        int count = 0;\\n        for (int i = 0; i < s.length(); i += 2) {\\n            if (s[i] != c) count++;\\n        }\\n        return count;\\n    }\\n    int minSwaps(string s) {\\n        int n=s.length();\\n        if(n==1)\\n        {\\n            return 0;\\n        }\\n        unordered_map<char,int> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[s[i]]++;\\n        }\\n        if(abs(mp[\\'1\\']-mp[\\'0\\'])>1)\\n        {\\n            return -1;\\n        }\\n        if(mp[\\'0\\']>mp[\\'1\\'])\\n        {\\n            return solve(s,\\'0\\');\\n        }\\n        else if(mp[\\'1\\']>mp[\\'0\\'])\\n        {\\n            return solve(s,\\'1\\');\\n        }\\n        else\\n        return min(solve(s,\\'0\\'),solve(s,\\'1\\'));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586443,
                "title": "actually-simple-explanation-in-the-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution(object):\\n    def minSwaps(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \\n        KEY IDEA 1:\\n\\n        two possible strings for len n that s could be\\n\\n        1010101..\\n        0101010..\\n\\n\\n        \\n        \"\"\"\\n\\n        # the two perfect strings\\n        case1 = \"\"\\n        case2 = \"\"\\n\\n        zero = True\\n        for i in range(len(s)):\\n            if zero:\\n                case1+=\"0\"\\n                case2+=\"1\"\\n            else:\\n                case1+=\"1\"\\n                case2+=\"0\"\\n            zero = not zero\\n\\n\\n\\n        # test our str with the two possible out cases\\n        # case 1\\n        bad1 = 0 # how many are misplaced accoring to case1 str\\n        cnt1 = {\"1\":0,\"0\":0} # how many of those misplaced are 0 or 1\\n\\n        bad2 = 0\\n        cnt2 = {\"1\":0,\"0\":0}\\n\\n        for i in range(len(s)):\\n\\n            if case1[i] != s[i]:\\n                bad1+=1\\n                cnt1[s[i]]+=1\\n\\n            if case2[i] != s[i]:\\n                bad2+=1\\n                cnt2[s[i]]+=1\\n\\n\\n        if not bad1 or not bad2:\\n            return 0\\n\\n        \\'\\'\\'\\n\\n        KEY IDEA 2:\\n        !!! if a 0 is in the wrong spot we want to find a 1 thats also in the wrong spot\\n        or vice versa\\n        thats why the number of wrong 0\\'s needs to == the number of wrong 1\\'s\\n\\n        \\'\\'\\'\\n        \\n        # swaps needed would be the number of bad pos/2\\n\\n        if cnt2[\"0\"] ==  cnt2[\"1\"] and cnt1[\"0\"] ==  cnt1[\"1\"]:\\n            return min(bad1,bad2)//2\\n        if cnt2[\"0\"] ==  cnt2[\"1\"]:\\n            return bad2//2\\n        if cnt1[\"0\"] ==  cnt1[\"1\"]:\\n            return bad1//2\\n        return -1\\n            \\n\\n\\n        \\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minSwaps(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \\n        KEY IDEA 1:\\n\\n        two possible strings for len n that s could be\\n\\n        1010101..\\n        0101010..\\n\\n\\n        \\n        \"\"\"\\n\\n        # the two perfect strings\\n        case1 = \"\"\\n        case2 = \"\"\\n\\n        zero = True\\n        for i in range(len(s)):\\n            if zero:\\n                case1+=\"0\"\\n                case2+=\"1\"\\n            else:\\n                case1+=\"1\"\\n                case2+=\"0\"\\n            zero = not zero\\n\\n\\n\\n        # test our str with the two possible out cases\\n        # case 1\\n        bad1 = 0 # how many are misplaced accoring to case1 str\\n        cnt1 = {\"1\":0,\"0\":0} # how many of those misplaced are 0 or 1\\n\\n        bad2 = 0\\n        cnt2 = {\"1\":0,\"0\":0}\\n\\n        for i in range(len(s)):\\n\\n            if case1[i] != s[i]:\\n                bad1+=1\\n                cnt1[s[i]]+=1\\n\\n            if case2[i] != s[i]:\\n                bad2+=1\\n                cnt2[s[i]]+=1\\n\\n\\n        if not bad1 or not bad2:\\n            return 0\\n\\n        \\'\\'\\'\\n\\n        KEY IDEA 2:\\n        !!! if a 0 is in the wrong spot we want to find a 1 thats also in the wrong spot\\n        or vice versa\\n        thats why the number of wrong 0\\'s needs to == the number of wrong 1\\'s\\n\\n        \\'\\'\\'\\n        \\n        # swaps needed would be the number of bad pos/2\\n\\n        if cnt2[\"0\"] ==  cnt2[\"1\"] and cnt1[\"0\"] ==  cnt1[\"1\"]:\\n            return min(bad1,bad2)//2\\n        if cnt2[\"0\"] ==  cnt2[\"1\"]:\\n            return bad2//2\\n        if cnt1[\"0\"] ==  cnt1[\"1\"]:\\n            return bad1//2\\n        return -1\\n            \\n\\n\\n        \\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3498055,
                "title": "minimum-number-of-swaps-to-make-the-binary-string-alternating",
                "content": "-------------------- Easy C++ Solution ---------------\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int minSwaps(string s) {\\n        int ones = count(cbegin(s), cend(s), \\'1\\');\\n        int zeros = size(s) - ones;\\n        if (abs(ones - zeros) > 1) {\\n            return -1;\\n        }\\n        if (ones > zeros) {\\n            return cost(s, 1);\\n        }\\n        if (ones < zeros) {\\n            return cost(s, 0);\\n        }\\n        return min(cost(s, 1), cost(s, 0));\\n    }\\n\\nprivate:\\n    int cost(const string& s, int x) {\\n        int diff = 0;\\n        for (const auto& c : s) {\\n            diff += (c - \\'0\\' != x);\\n            x ^= 1;\\n        }\\n        return diff / 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int minSwaps(string s) {\\n        int ones = count(cbegin(s), cend(s), \\'1\\');\\n        int zeros = size(s) - ones;\\n        if (abs(ones - zeros) > 1) {\\n            return -1;\\n        }\\n        if (ones > zeros) {\\n            return cost(s, 1);\\n        }\\n        if (ones < zeros) {\\n            return cost(s, 0);\\n        }\\n        return min(cost(s, 1), cost(s, 0));\\n    }\\n\\nprivate:\\n    int cost(const string& s, int x) {\\n        int diff = 0;\\n        for (const auto& c : s) {\\n            diff += (c - \\'0\\' != x);\\n            x ^= 1;\\n        }\\n        return diff / 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490036,
                "title": "c-greedy-o-n-1-pass",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        int len = s.length(), zero = 0, one = 0, count1 = 0, count2 = 0;\\n        char char1 = \\'0\\', char2 = \\'1\\';\\n        for(char ch: s) {\\n            if(ch == \\'0\\') zero++;\\n            else one++;\\n            count1 += (ch != char1);\\n            count2 += (ch != char2);\\n            char1 = (char1 == \\'0\\'? \\'1\\': \\'0\\');\\n            char2 = (char2 == \\'0\\'? \\'1\\': \\'0\\');\\n        }\\n        if(abs(one - zero) >= 2) return -1;\\n        if(zero < one) return count2 / 2;\\n        else if(zero > one) return count1 / 2;\\n        return min(count1, count2) / 2;\\n    }\\n};\\n\\n\\nOR\\n\\n\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        int len = s.length(), zero = 0, one = 0, count1 = 0;\\n        char char1 = \\'0\\';\\n        for(char ch: s) {\\n            if(ch == \\'0\\') zero++;\\n            else one++;\\n            count1 += (ch != char1);\\n            char1 = (char1 == \\'0\\'? \\'1\\': \\'0\\');\\n        }\\n        if(abs(one - zero) >= 2) return -1;\\n        else if(zero < one) return (len - count1) / 2;\\n        else if(zero > one) return count1 / 2;\\n        else return min(count1, (len - count1)) / 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        int len = s.length(), zero = 0, one = 0, count1 = 0, count2 = 0;\\n        char char1 = \\'0\\', char2 = \\'1\\';\\n        for(char ch: s) {\\n            if(ch == \\'0\\') zero++;\\n            else one++;\\n            count1 += (ch != char1);\\n            count2 += (ch != char2);\\n            char1 = (char1 == \\'0\\'? \\'1\\': \\'0\\');\\n            char2 = (char2 == \\'0\\'? \\'1\\': \\'0\\');\\n        }\\n        if(abs(one - zero) >= 2) return -1;\\n        if(zero < one) return count2 / 2;\\n        else if(zero > one) return count1 / 2;\\n        return min(count1, count2) / 2;\\n    }\\n};\\n\\n\\nOR\\n\\n\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        int len = s.length(), zero = 0, one = 0, count1 = 0;\\n        char char1 = \\'0\\';\\n        for(char ch: s) {\\n            if(ch == \\'0\\') zero++;\\n            else one++;\\n            count1 += (ch != char1);\\n            char1 = (char1 == \\'0\\'? \\'1\\': \\'0\\');\\n        }\\n        if(abs(one - zero) >= 2) return -1;\\n        else if(zero < one) return (len - count1) / 2;\\n        else if(zero > one) return count1 / 2;\\n        else return min(count1, (len - count1)) / 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3489477,
                "title": "rust-custom-fold-struct",
                "content": "# Intuition\\nThe final string has to look like either 0101... or 1010... We can build a string by keeping track of how many 1s are in places which should be 0s, and making sure that we have the same number of places with 0s that should have 1s.\\n\\n# Approach\\nCreate a builder struct that keeps track of its previous character, the number of free ones, and the number of completed swaps. Make two of these, one for the 0101... case and one for the 1010...case. \\n\\nIterate over the characters in s, sequentially adding them into both. At the end, check that we\\'ve equalized on the number of 1s and 0s swapped; if not, then that string cannot be built, and return None. If both counters return None, unwrap to -1, otherwise return the smallest non-None value.\\n\\n# Complexity\\n- Time complexity:\\nO(n), we do one pass over s and do finitely many operations each pass.\\n\\n- Space complexity:\\nO(1), each counter requires only finite space and we only make two of them.\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn min_swaps(s: String) -> i32 {\\n        s\\n        .chars()\\n        .fold(\\n            [SwapCounter::new(\\'0\\'), SwapCounter::new(\\'1\\')],\\n            |mut counters, curr| {\\n                counters[0].add(curr);\\n                counters[1].add(curr);\\n                counters\\n            }\\n        )\\n        .into_iter()\\n        .filter_map(|counter| counter.finish())\\n        .min()\\n        .unwrap_or(-1)\\n    }\\n}\\n\\nstruct SwapCounter {\\n    prev: char,\\n    free_ones: i64,\\n    swaps: i32,\\n}\\n\\nimpl SwapCounter {\\n    pub fn new(prev: char) -> Self {\\n        Self {\\n            prev,\\n            free_ones: 0,\\n            swaps: 0,\\n        }\\n    }\\n\\n    pub fn add(&mut self, curr: char) {\\n        match (self.prev, curr) {\\n            (\\'0\\', \\'1\\') | (\\'1\\', \\'0\\') => {\\n                // No swaps needed\\n                self.prev = curr;\\n            },\\n            (\\'0\\', \\'0\\') => {\\n                // Swap in a free 1\\n                self.swaps += 1;\\n                self.free_ones -= 1;\\n                self.prev = \\'1\\';\\n            }\\n            (\\'1\\', \\'1\\') => {\\n                // This 1 needs to be moved somewhere\\n                // But the swap only happens when it gets assigned\\n                self.free_ones += 1;\\n                self.prev = \\'0\\';\\n            }\\n            _ => {}\\n        }\\n    }\\n\\n    pub fn finish(&self) -> Option<i32> {\\n        if self.free_ones != 0 {\\n            // Either too many 1s or not enough\\n            None\\n        } else {\\n            Some(self.swaps)\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_swaps(s: String) -> i32 {\\n        s\\n        .chars()\\n        .fold(\\n            [SwapCounter::new(\\'0\\'), SwapCounter::new(\\'1\\')],\\n            |mut counters, curr| {\\n                counters[0].add(curr);\\n                counters[1].add(curr);\\n                counters\\n            }\\n        )\\n        .into_iter()\\n        .filter_map(|counter| counter.finish())\\n        .min()\\n        .unwrap_or(-1)\\n    }\\n}\\n\\nstruct SwapCounter {\\n    prev: char,\\n    free_ones: i64,\\n    swaps: i32,\\n}\\n\\nimpl SwapCounter {\\n    pub fn new(prev: char) -> Self {\\n        Self {\\n            prev,\\n            free_ones: 0,\\n            swaps: 0,\\n        }\\n    }\\n\\n    pub fn add(&mut self, curr: char) {\\n        match (self.prev, curr) {\\n            (\\'0\\', \\'1\\') | (\\'1\\', \\'0\\') => {\\n                // No swaps needed\\n                self.prev = curr;\\n            },\\n            (\\'0\\', \\'0\\') => {\\n                // Swap in a free 1\\n                self.swaps += 1;\\n                self.free_ones -= 1;\\n                self.prev = \\'1\\';\\n            }\\n            (\\'1\\', \\'1\\') => {\\n                // This 1 needs to be moved somewhere\\n                // But the swap only happens when it gets assigned\\n                self.free_ones += 1;\\n                self.prev = \\'0\\';\\n            }\\n            _ => {}\\n        }\\n    }\\n\\n    pub fn finish(&self) -> Option<i32> {\\n        if self.free_ones != 0 {\\n            // Either too many 1s or not enough\\n            None\\n        } else {\\n            Some(self.swaps)\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3417370,
                "title": "easy-cpp-solution-beginners-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        int n = s.size();\\n        int ones = 0,zeros;\\n\\n        for(auto i : s) if(i == \\'1\\') ones++;\\n        zeros = n - ones;\\n\\n        if (max(ones,zeros) > (n + 1) / 2)  return -1;\\n\\n        string temp = \"\",temp2 = \"\";\\n        int a = ones,b = zeros ;\\n        int diff1 = 0,diff2;\\n\\n         while(ones > 0 || zeros > 0){\\n             if(ones-- > 0)temp+=\\'1\\';\\n             if(zeros-- > 0)temp += \\'0\\';\\n             if(b-- > 0) temp2 += \\'0\\';\\n             if(a-- > 0) temp2+=\\'1\\';   \\n        }\\n         for(int i = 0 ;i<temp.size();i++){\\n             if(temp[i] != s[i] && diff1 != INT_MAX) diff1++;\\n             if(temp2[i] != s[i] && diff2 != INT_MAX) diff2++;\\n             if(temp[i] == temp[i+1] && i + 1 < n ) diff1 = INT_MAX;\\n             if(temp2[i] == temp2[i+1] && i + 1 < n) diff2 = INT_MAX;\\n         }\\n        \\n        return  min(diff1,diff2)/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        int n = s.size();\\n        int ones = 0,zeros;\\n\\n        for(auto i : s) if(i == \\'1\\') ones++;\\n        zeros = n - ones;\\n\\n        if (max(ones,zeros) > (n + 1) / 2)  return -1;\\n\\n        string temp = \"\",temp2 = \"\";\\n        int a = ones,b = zeros ;\\n        int diff1 = 0,diff2;\\n\\n         while(ones > 0 || zeros > 0){\\n             if(ones-- > 0)temp+=\\'1\\';\\n             if(zeros-- > 0)temp += \\'0\\';\\n             if(b-- > 0) temp2 += \\'0\\';\\n             if(a-- > 0) temp2+=\\'1\\';   \\n        }\\n         for(int i = 0 ;i<temp.size();i++){\\n             if(temp[i] != s[i] && diff1 != INT_MAX) diff1++;\\n             if(temp2[i] != s[i] && diff2 != INT_MAX) diff2++;\\n             if(temp[i] == temp[i+1] && i + 1 < n ) diff1 = INT_MAX;\\n             if(temp2[i] == temp2[i+1] && i + 1 < n) diff2 = INT_MAX;\\n         }\\n        \\n        return  min(diff1,diff2)/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396113,
                "title": "simple-solution-c",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        int zeros = 0; int ones = 0;\\n        int n = s.size();\\n        for(int i = 0; i < n; i++) {\\n            if(s[i] == \\'1\\') ones++;\\n            else zeros++;\\n        }\\n        if(n%2 == 1) {\\n            string str;\\n            if(abs(zeros-ones) != 1) return -1;\\n            if(zeros > ones) {\\n               for(int i = 0; i < n; i++) {\\n                   if(i%2 == 0) str += \\'0\\';\\n                   else str+= \\'1\\';\\n               }\\n            }\\n            else {\\n                for(int i = 0; i < n; i++) {\\n                   if(i%2 == 0) str += \\'1\\';\\n                   else str+= \\'0\\';\\n               }\\n            }\\n            int count = 0;\\n            for(int i = 0; i < n; i++) {\\n                if(str[i] != s[i]) count++;\\n            }\\n            return count/2;\\n        }\\n        else {\\n            if(abs(zeros-ones) != 0) return -1;\\n            string str1, str2;\\n            for(int i = 0; i < n; i++) {\\n                if(i%2 == 0) { str1 += \\'1\\'; str2 += \\'0\\'; }\\n                else { str1 += \\'0\\'; str2 += \\'1\\';}\\n            }\\n            int count1 = 0; int count2 = 0;\\n            for(int i = 0; i < n; i++) {\\n                if(str1[i] != s[i]) count1++;\\n                if(str2[i] != s[i]) count2++;\\n            }\\n            int f_count = (count1 > count2) ? count2/2 : count1/2;\\n            return f_count;\\n        }\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        int zeros = 0; int ones = 0;\\n        int n = s.size();\\n        for(int i = 0; i < n; i++) {\\n            if(s[i] == \\'1\\') ones++;\\n            else zeros++;\\n        }\\n        if(n%2 == 1) {\\n            string str;\\n            if(abs(zeros-ones) != 1) return -1;\\n            if(zeros > ones) {\\n               for(int i = 0; i < n; i++) {\\n                   if(i%2 == 0) str += \\'0\\';\\n                   else str+= \\'1\\';\\n               }\\n            }\\n            else {\\n                for(int i = 0; i < n; i++) {\\n                   if(i%2 == 0) str += \\'1\\';\\n                   else str+= \\'0\\';\\n               }\\n            }\\n            int count = 0;\\n            for(int i = 0; i < n; i++) {\\n                if(str[i] != s[i]) count++;\\n            }\\n            return count/2;\\n        }\\n        else {\\n            if(abs(zeros-ones) != 0) return -1;\\n            string str1, str2;\\n            for(int i = 0; i < n; i++) {\\n                if(i%2 == 0) { str1 += \\'1\\'; str2 += \\'0\\'; }\\n                else { str1 += \\'0\\'; str2 += \\'1\\';}\\n            }\\n            int count1 = 0; int count2 = 0;\\n            for(int i = 0; i < n; i++) {\\n                if(str1[i] != s[i]) count1++;\\n                if(str2[i] != s[i]) count2++;\\n            }\\n            int f_count = (count1 > count2) ? count2/2 : count1/2;\\n            return f_count;\\n        }\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3385504,
                "title": "easy-simple-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        int zc = 0,oc = 0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i] == \\'0\\'){\\n                zc++;\\n            }\\n            else{\\n                oc++;\\n            }\\n        }\\n        // cout << zc << \" \" << oc << endl;\\n        if(abs(zc-oc) > 1){\\n            return -1;\\n        }\\n\\n        if(zc == oc){\\n            int zf =0, of =0;\\n            for(int i=0;i<s.size();i++){\\n                if(i%2 == 0 && s[i] != \\'0\\'){\\n                    zf++;\\n                }\\n                if(i%2 == 0 && s[i] != \\'1\\'){\\n                    of++;\\n                }\\n            }\\n            return min(of,zf);\\n        }\\n        \\n\\n        if(zc > oc){\\n            int zf =0;\\n            for(int i=0;i<s.size();i++){\\n                if(i%2 == 0 && s[i] != \\'0\\'){\\n                    zf++;\\n                }\\n                \\n            }\\n            return zf;\\n        }\\n        int of =0;\\n        for(int i=0;i<s.size();i++){\\n            if(i%2 == 0 && s[i] != \\'1\\'){\\n                of++;\\n            }\\n            \\n        }\\n        return of;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        int zc = 0,oc = 0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i] == \\'0\\'){\\n                zc++;\\n            }\\n            else{\\n                oc++;\\n            }\\n        }\\n        // cout << zc << \" \" << oc << endl;\\n        if(abs(zc-oc) > 1){\\n            return -1;\\n        }\\n\\n        if(zc == oc){\\n            int zf =0, of =0;\\n            for(int i=0;i<s.size();i++){\\n                if(i%2 == 0 && s[i] != \\'0\\'){\\n                    zf++;\\n                }\\n                if(i%2 == 0 && s[i] != \\'1\\'){\\n                    of++;\\n                }\\n            }\\n            return min(of,zf);\\n        }\\n        \\n\\n        if(zc > oc){\\n            int zf =0;\\n            for(int i=0;i<s.size();i++){\\n                if(i%2 == 0 && s[i] != \\'0\\'){\\n                    zf++;\\n                }\\n                \\n            }\\n            return zf;\\n        }\\n        int of =0;\\n        for(int i=0;i<s.size();i++){\\n            if(i%2 == 0 && s[i] != \\'1\\'){\\n                of++;\\n            }\\n            \\n        }\\n        return of;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3373171,
                "title": "easy-short-intuitive",
                "content": "# Intuition\\nThere are only 2 possible solutions. Finding distance between the solution and input is easier than recursively trying all moves.\\n# Approach\\nNumber of misplaced 0s should be equal to misplaced 1s for this to work. So we check same for the 2 solutions. 1 solution with 0 at odd places and other one with 0 at even places\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(1)\\n# Code\\n```ts\\nfunction minSwaps(s: string): number {\\n    let o=0,z=0,eo=0,ez=0,n=s.length;\\n    for(let i=0;i<n;i++) {\\n        const v=s[i];\\n        if(i&1) {\\n            if(v===\\'1\\') o++;\\n            else ez++;\\n        } else {\\n            if(v===\\'1\\') eo++;\\n            else z++;\\n        }\\n    }\\n    let ans=n\\n    if(o===z) ans=o\\n    if(eo===ez && ans>eo) ans=eo\\n    return ans===n ? -1:ans\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```ts\\nfunction minSwaps(s: string): number {\\n    let o=0,z=0,eo=0,ez=0,n=s.length;\\n    for(let i=0;i<n;i++) {\\n        const v=s[i];\\n        if(i&1) {\\n            if(v===\\'1\\') o++;\\n            else ez++;\\n        } else {\\n            if(v===\\'1\\') eo++;\\n            else z++;\\n        }\\n    }\\n    let ans=n\\n    if(o===z) ans=o\\n    if(eo===ez && ans>eo) ans=eo\\n    return ans===n ? -1:ans\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3353955,
                "title": "c-faster-than-100-count-misplaced",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        const int N = s.size();\\n        int zeros = 0; int ones = 0;\\n        int zeros_on_even = 0; int zeros_on_odd = 0; \\n        int ones_on_even = 0; int ones_on_odd = 0;\\n\\n        for (int i = 0; i < N; i++)\\n        {\\n            const char c = s[i];\\n            const bool is_zero = c == \\'0\\';\\n            const bool is_one = c == \\'1\\';\\n            const bool on_even = i % 2 == 0;\\n            const bool on_odd = i % 2 == 1; \\n            if (is_zero && on_even)\\n            {\\n                zeros_on_even++;\\n            }\\n            else if (is_zero && on_odd)\\n            {\\n                zeros_on_odd++;\\n            }\\n            else if (is_one && on_even)\\n            {\\n                ones_on_even++;\\n            }\\n            else if (is_one && on_odd)\\n            {\\n                ones_on_odd++;\\n            }\\n        }\\n        zeros = zeros_on_even + zeros_on_odd;\\n        ones = ones_on_even + ones_on_odd;\\n\\n        int off_by_one_or_zero = (zeros + 1 == ones) || (ones + 1 == zeros) || (ones == zeros);\\n        if (!off_by_one_or_zero) return -1;\\n        if (zeros > ones) return zeros_on_odd;\\n        if (ones > zeros) return ones_on_odd;\\n        return min({zeros_on_even, zeros_on_odd, ones_on_even, ones_on_odd});\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        const int N = s.size();\\n        int zeros = 0; int ones = 0;\\n        int zeros_on_even = 0; int zeros_on_odd = 0; \\n        int ones_on_even = 0; int ones_on_odd = 0;\\n\\n        for (int i = 0; i < N; i++)\\n        {\\n            const char c = s[i];\\n            const bool is_zero = c == \\'0\\';\\n            const bool is_one = c == \\'1\\';\\n            const bool on_even = i % 2 == 0;\\n            const bool on_odd = i % 2 == 1; \\n            if (is_zero && on_even)\\n            {\\n                zeros_on_even++;\\n            }\\n            else if (is_zero && on_odd)\\n            {\\n                zeros_on_odd++;\\n            }\\n            else if (is_one && on_even)\\n            {\\n                ones_on_even++;\\n            }\\n            else if (is_one && on_odd)\\n            {\\n                ones_on_odd++;\\n            }\\n        }\\n        zeros = zeros_on_even + zeros_on_odd;\\n        ones = ones_on_even + ones_on_odd;\\n\\n        int off_by_one_or_zero = (zeros + 1 == ones) || (ones + 1 == zeros) || (ones == zeros);\\n        if (!off_by_one_or_zero) return -1;\\n        if (zeros > ones) return zeros_on_odd;\\n        if (ones > zeros) return ones_on_odd;\\n        return min({zeros_on_even, zeros_on_odd, ones_on_even, ones_on_odd});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314637,
                "title": "array-traversal-time-o-n-space-o-1",
                "content": "# Intuition\\nArray Traversal\\n\\n# Approach\\n1. Verify that abs(num of 1s - num of 0s) <= 1 else return -1\\n2. If num of 1s == num of 0s, Check how many swaps are needed to convert s into 101010.. and 010101... by counting the number of misplaced 1s/0s and return the minimum of the two\\n3. Special cases when abs(num of 1s - num of 0s) = 1, you can only convert them into 101010..1 or 01010...0 depending upon which digit exceeds\\n \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThree traversals of the array. $$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution(object):\\n    def minSwaps(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        n_1 = 0\\n        \\n        for c in s:\\n            if c == \\'1\\':\\n                n_1 += 1\\n        \\n        n_0 = len(s) - n_1\\n\\n        def convertBin(a):\\n            i = 0\\n            mis_a = 0\\n\\n            while i < len(s):\\n                if s[i] != a:\\n                    mis_a += 1\\n                i += 2\\n            \\n            return mis_a\\n\\n\\n        if n_1 == n_0:\\n            res10 = convertBin(\\'1\\')\\n            res01 = convertBin(\\'0\\')\\n            return min(res10, res01)\\n        elif n_1 - n_0 == 1:\\n            return convertBin(\\'1\\')\\n        elif n_0 - n_1 == 1:\\n            return convertBin(\\'0\\')\\n        else:\\n            return -1\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minSwaps(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        n_1 = 0\\n        \\n        for c in s:\\n            if c == \\'1\\':\\n                n_1 += 1\\n        \\n        n_0 = len(s) - n_1\\n\\n        def convertBin(a):\\n            i = 0\\n            mis_a = 0\\n\\n            while i < len(s):\\n                if s[i] != a:\\n                    mis_a += 1\\n                i += 2\\n            \\n            return mis_a\\n\\n\\n        if n_1 == n_0:\\n            res10 = convertBin(\\'1\\')\\n            res01 = convertBin(\\'0\\')\\n            return min(res10, res01)\\n        elif n_1 - n_0 == 1:\\n            return convertBin(\\'1\\')\\n        elif n_0 - n_1 == 1:\\n            return convertBin(\\'0\\')\\n        else:\\n            return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299311,
                "title": "python-solution-with-explanation",
                "content": "```python\\n\\'\\'\\'\\ncheck if the string s can be the altanative string or not first,\\naltanative string has two types, starting with 0/1\\nif the length of s is odd, the altanative string only has one type\\nif the length of s is even, the altanative string has two types\\n\\nwe can count the difference characters between the altanative string and s to get swapping times (number of difference // 2)\\nand choose minimum swapping times between the altanative string if it is has two types.\\n\\'\\'\\'\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        num0 = 0\\n        for c in s:\\n            if c == \\'0\\': num0 += 1\\n        if (len(s) % 2 == 1 and abs(len(s) - 2 * num0) != 1) or (len(s) % 2 == 0 and num0 * 2 != len(s)): return -1\\n        if len(s) % 2:\\n            if len(s) - 2 * num0 > 0 : return self.checkSwap(s, 1)\\n            return self.checkSwap(s, 0)\\n        return min(self.checkSwap(s, 0), self.checkSwap(s, 1))\\n\\n    def checkSwap(self, s, startWith):\\n        cur = startWith\\n        cnt = 0\\n        for c in s:\\n            if c != str(cur): cnt += 1\\n            cur ^= 1\\n        return cnt // 2\\n```",
                "solutionTags": [
                    "Python",
                    "Counting"
                ],
                "code": "```python\\n\\'\\'\\'\\ncheck if the string s can be the altanative string or not first,\\naltanative string has two types, starting with 0/1\\nif the length of s is odd, the altanative string only has one type\\nif the length of s is even, the altanative string has two types\\n\\nwe can count the difference characters between the altanative string and s to get swapping times (number of difference // 2)\\nand choose minimum swapping times between the altanative string if it is has two types.\\n\\'\\'\\'\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        num0 = 0\\n        for c in s:\\n            if c == \\'0\\': num0 += 1\\n        if (len(s) % 2 == 1 and abs(len(s) - 2 * num0) != 1) or (len(s) % 2 == 0 and num0 * 2 != len(s)): return -1\\n        if len(s) % 2:\\n            if len(s) - 2 * num0 > 0 : return self.checkSwap(s, 1)\\n            return self.checkSwap(s, 0)\\n        return min(self.checkSwap(s, 0), self.checkSwap(s, 1))\\n\\n    def checkSwap(self, s, startWith):\\n        cur = startWith\\n        cnt = 0\\n        for c in s:\\n            if c != str(cur): cnt += 1\\n            cur ^= 1\\n        return cnt // 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298407,
                "title": "c-100-fast-8-lines-count-incorrectly-positioned-characters-o-n",
                "content": "***Stages of coding: \\n1.make it work\\n2.make it right\\n3.make it fast***\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        int count_zeros=count(s.begin(),s.end(),\\'0\\'),zerofirst=0; \\n        int count_ones=count(s.begin(),s.end(),\\'1\\'),onefirst=0;\\n        if(abs(count_zeros-count_ones)>1)return -1;\\n        for(int i=0;i<s.length();i++)i%2?zerofirst+=(s[i]==\\'0\\'):zerofirst+=(s[i]==\\'1\\');\\n        for(int i=0;i<s.length();i++)i%2?onefirst+=(s[i]==\\'1\\'):onefirst+=(s[i]==\\'0\\');\\n        if(count_zeros>count_ones)return zerofirst/2;\\n        else if(count_ones>count_zeros)return onefirst/2;\\n        else return min(onefirst,zerofirst)/2;\\n    }\\n};\\n```\\n**logik:**\\n1.count the frequency of each character (0,1) using the inbuilt function (count) then if there is a difference of more than 1 between the frequency we can never make it alternating by the use of pigeonhole principle\\n2.count the character not in right position in case 0 is our first character and do the same for if 1 is our first character using for loops \\n3.if frequency of zeros is more than one then use zerofirst/2 (each swap fixes 2 characters) else if frequency of one is more than of zero then use onefirst/2 else use minimum of zerofirst and onefirst divided by 2 \\n![image](https://assets.leetcode.com/users/images/ac76fb84-04a1-452e-b108-c7227983b4df_1678847727.8268447.png)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        int count_zeros=count(s.begin(),s.end(),\\'0\\'),zerofirst=0; \\n        int count_ones=count(s.begin(),s.end(),\\'1\\'),onefirst=0;\\n        if(abs(count_zeros-count_ones)>1)return -1;\\n        for(int i=0;i<s.length();i++)i%2?zerofirst+=(s[i]==\\'0\\'):zerofirst+=(s[i]==\\'1\\');\\n        for(int i=0;i<s.length();i++)i%2?onefirst+=(s[i]==\\'1\\'):onefirst+=(s[i]==\\'0\\');\\n        if(count_zeros>count_ones)return zerofirst/2;\\n        else if(count_ones>count_zeros)return onefirst/2;\\n        else return min(onefirst,zerofirst)/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3289950,
                "title": "python-explained-o-n-count-out-of-place-characters",
                "content": "O(n) time O(1) space\\n\\nFirstly if the length of the string is even the count for zeroes and ones must be the same, same with odds but they must not differ by more the 1.\\n\\nThe next plan is to compare our input against 2 masks 101 sequence and 010 sequence we will store these in cost1 and cost2.\\n\\nas we loop through if any of the characters are out of place for the respective masks we increment the cost by 1.\\nwe may run into a situation such as in \"100\" where one of the masks returns and odd # of misplaced characters. If any of the counts are out of place we can rule it out and just accept the other one.\\n\\nOnce we determine which mask we are going with we divide the result by 2 since a swap moves 2 characters but only costs 1.\\n\\n```\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n     \\n        ones = s.count(\\'1\\')\\n        zeros = len(s) - ones\\n        #edge cases\\n        if len(s) % 2 == 0 and ones != zeros:\\n            return -1\\n        elif len(s) % 2 and abs(ones - zeros) != 1:\\n            return -1\\n        \\n        res =0\\n        cost1,cost2 = 0,0\\n        \\n        for i in range(len(s)):\\n            #010\\n            if s[i] != str(i%2):\\n                cost1 +=1\\n            #101\\n            else:\\n                cost2 +=1\\n            \\n        if cost1 % 2:\\n            cost1 = float(\\'inf\\')\\n        if cost2 % 2:\\n            cost2 = float(\\'inf\\')\\n            \\n        res = min(cost1,cost2)\\n        return res // 2\\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n     \\n        ones = s.count(\\'1\\')\\n        zeros = len(s) - ones\\n        #edge cases\\n        if len(s) % 2 == 0 and ones != zeros:\\n            return -1\\n        elif len(s) % 2 and abs(ones - zeros) != 1:\\n            return -1\\n        \\n        res =0\\n        cost1,cost2 = 0,0\\n        \\n        for i in range(len(s)):\\n            #010\\n            if s[i] != str(i%2):\\n                cost1 +=1\\n            #101\\n            else:\\n                cost2 +=1\\n            \\n        if cost1 % 2:\\n            cost1 = float(\\'inf\\')\\n        if cost2 % 2:\\n            cost2 = float(\\'inf\\')\\n            \\n        res = min(cost1,cost2)\\n        return res // 2\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 3245654,
                "title": "beginner-friendly-solution-c-strings",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        \\n        int n=s.size();\\n        int cnt=0;\\n        int one=0;\\n        int zero=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i%2==0)\\n            {\\n                if(s[i]==\\'0\\')\\n                {\\n                    cnt++;\\n                }\\n            }\\n            else if(i%2==1)\\n            {\\n                if(s[i]==\\'1\\') cnt++;\\n            }\\n\\n            if(s[i]==\\'1\\') one++;\\n            else\\n            zero++;\\n        }\\n\\n        int cnt2=0;\\n         for(int i=0;i<n;i++)\\n        {\\n            if(i%2==0)\\n            {\\n                if(s[i]==\\'1\\')\\n                {\\n                    cnt2++;\\n                }\\n            }\\n            else if(i%2==1)\\n            {\\n                if(s[i]==\\'0\\') cnt2++;\\n            }\\n        }\\n        cout<<cnt<<\" \"<<cnt2<<\" \";\\n        if(abs(one-zero)>1) return -1;\\n        else\\n        {\\n            if(cnt%2==0 && cnt2%2==1) return cnt/2;\\n            if(cnt%2==0 && cnt2%2==0) return (min(cnt,cnt2))/2;\\n            if(cnt%2==1 && cnt2%2==0) return cnt2/2; \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        \\n        int n=s.size();\\n        int cnt=0;\\n        int one=0;\\n        int zero=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i%2==0)\\n            {\\n                if(s[i]==\\'0\\')\\n                {\\n                    cnt++;\\n                }\\n            }\\n            else if(i%2==1)\\n            {\\n                if(s[i]==\\'1\\') cnt++;\\n            }\\n\\n            if(s[i]==\\'1\\') one++;\\n            else\\n            zero++;\\n        }\\n\\n        int cnt2=0;\\n         for(int i=0;i<n;i++)\\n        {\\n            if(i%2==0)\\n            {\\n                if(s[i]==\\'1\\')\\n                {\\n                    cnt2++;\\n                }\\n            }\\n            else if(i%2==1)\\n            {\\n                if(s[i]==\\'0\\') cnt2++;\\n            }\\n        }\\n        cout<<cnt<<\" \"<<cnt2<<\" \";\\n        if(abs(one-zero)>1) return -1;\\n        else\\n        {\\n            if(cnt%2==0 && cnt2%2==1) return cnt/2;\\n            if(cnt%2==0 && cnt2%2==0) return (min(cnt,cnt2))/2;\\n            if(cnt%2==1 && cnt2%2==0) return cnt2/2; \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3243201,
                "title": "c-constructive-solution-100-faster",
                "content": "![Screenshot (176).png](https://assets.leetcode.com/users/images/d0da02b0-933a-49a5-ad5e-d5a6bef167df_1677663487.6980886.png)\\n\\n\\nFirst count the number of zeros and ones; return -1 if the counts differ by more than one.\\n\\nIf our string is odd-sized, then we know where zeros and ones should be. For even-sized strings, we need to check two cases: when the string starts with \\'0\\', and when with \\'1\\'.\\n\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public:\\n    bool isalt(string s){\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==s[i+1]) return false;\\n        }\\n        return true;\\n    }\\n    \\n\\n    int minSwaps(string s) {\\n        if(isalt(s)) return 0;\\n        int x=0,y=0;\\n        \\n        int o=0,z=0;\\n        cout<<s.size()<<endl;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'0\\'){\\n                z++;\\n            }\\n            else{\\n                o++;\\n            }\\n        }\\n        if(abs(o-z)>1) return -1;\\n        int ans=0;\\n        if(o==z){\\n            char l=\\'0\\';\\n            \\n            for(int i=0;i<s.size();i++){\\n                if(s[i]!=l){\\n                    x++;\\n                }\\n                if(l==\\'0\\') l=\\'1\\';\\n                else l=\\'0\\';\\n            }\\n            l=\\'1\\';\\n            for(int i=0;i<s.size();i++){\\n                if(s[i]!=l){\\n                    y++;\\n                }\\n                if(l==\\'0\\') l=\\'1\\';\\n                else l=\\'0\\';\\n            }\\n\\n            return min(x,y)/2;\\n        }\\n\\n        if(o>z){\\n            char l=\\'1\\';\\n            for(int i=0;i<s.size();i++){\\n                if(s[i]!=l){\\n                    y++;\\n                }\\n                if(l==\\'0\\') l=\\'1\\';\\n                else l=\\'0\\';\\n            }\\n            return (y+1)/2;\\n        }\\n        char l=\\'0\\';\\n      \\n        for(int i=0;i<s.size();i++){\\n           \\n                if(s[i]!=l){\\n                    x++;\\n                }\\n                if(l==\\'0\\') l=\\'1\\';\\n                else l=\\'0\\';\\n        }\\n        \\n        \\n        return (x+1)/2;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    public:\\n    bool isalt(string s){\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==s[i+1]) return false;\\n        }\\n        return true;\\n    }\\n    \\n\\n    int minSwaps(string s) {\\n        if(isalt(s)) return 0;\\n        int x=0,y=0;\\n        \\n        int o=0,z=0;\\n        cout<<s.size()<<endl;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'0\\'){\\n                z++;\\n            }\\n            else{\\n                o++;\\n            }\\n        }\\n        if(abs(o-z)>1) return -1;\\n        int ans=0;\\n        if(o==z){\\n            char l=\\'0\\';\\n            \\n            for(int i=0;i<s.size();i++){\\n                if(s[i]!=l){\\n                    x++;\\n                }\\n                if(l==\\'0\\') l=\\'1\\';\\n                else l=\\'0\\';\\n            }\\n            l=\\'1\\';\\n            for(int i=0;i<s.size();i++){\\n                if(s[i]!=l){\\n                    y++;\\n                }\\n                if(l==\\'0\\') l=\\'1\\';\\n                else l=\\'0\\';\\n            }\\n\\n            return min(x,y)/2;\\n        }\\n\\n        if(o>z){\\n            char l=\\'1\\';\\n            for(int i=0;i<s.size();i++){\\n                if(s[i]!=l){\\n                    y++;\\n                }\\n                if(l==\\'0\\') l=\\'1\\';\\n                else l=\\'0\\';\\n            }\\n            return (y+1)/2;\\n        }\\n        char l=\\'0\\';\\n      \\n        for(int i=0;i<s.size();i++){\\n           \\n                if(s[i]!=l){\\n                    x++;\\n                }\\n                if(l==\\'0\\') l=\\'1\\';\\n                else l=\\'0\\';\\n        }\\n        \\n        \\n        return (x+1)/2;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3224477,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn min_swaps(s: String) -> i32 {\\n        let s = s.chars().collect::<Vec<char>>();\\n        let mut count_0 = 0_i32;\\n        let mut count_1 = 0;\\n        for &s_i in s.iter() {\\n            if s_i == \\'1\\' {\\n                count_1 += 1;\\n            } else {\\n                count_0 += 1;\\n            }\\n        }\\n        if (count_1 - count_0).abs() >= 2 {\\n            return -1;\\n        }\\n        let mut uncommon_1 = 0;\\n        for (i, &s_i) in s.iter().enumerate() {\\n            if i % 2 == 0 {\\n                if s_i != \\'0\\' {\\n                    uncommon_1 += 1;\\n                }\\n            } else if s_i != \\'1\\' {\\n                uncommon_1 += 1;\\n            }\\n        }\\n        let mut uncommon_2 = 0;\\n        for (i, &s_i) in s.iter().enumerate() {\\n            if i % 2 == 1 {\\n                if s_i != \\'0\\' {\\n                    uncommon_2 += 1;\\n                }\\n            } else if s_i != \\'1\\' {\\n                uncommon_2 += 1;\\n            }\\n        }\\n        let mut mini = std::i32::MAX;\\n        if uncommon_1 % 2 == 0 {\\n            mini = mini.min(uncommon_1);\\n        }\\n        if uncommon_2 % 2 == 0 {\\n            mini = mini.min(uncommon_2);\\n        }\\n        if mini == std::i32::MAX {\\n            return -1;\\n        }\\n        mini / 2\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_swaps(s: String) -> i32 {\\n        let s = s.chars().collect::<Vec<char>>();\\n        let mut count_0 = 0_i32;\\n        let mut count_1 = 0;\\n        for &s_i in s.iter() {\\n            if s_i == \\'1\\' {\\n                count_1 += 1;\\n            } else {\\n                count_0 += 1;\\n            }\\n        }\\n        if (count_1 - count_0).abs() >= 2 {\\n            return -1;\\n        }\\n        let mut uncommon_1 = 0;\\n        for (i, &s_i) in s.iter().enumerate() {\\n            if i % 2 == 0 {\\n                if s_i != \\'0\\' {\\n                    uncommon_1 += 1;\\n                }\\n            } else if s_i != \\'1\\' {\\n                uncommon_1 += 1;\\n            }\\n        }\\n        let mut uncommon_2 = 0;\\n        for (i, &s_i) in s.iter().enumerate() {\\n            if i % 2 == 1 {\\n                if s_i != \\'0\\' {\\n                    uncommon_2 += 1;\\n                }\\n            } else if s_i != \\'1\\' {\\n                uncommon_2 += 1;\\n            }\\n        }\\n        let mut mini = std::i32::MAX;\\n        if uncommon_1 % 2 == 0 {\\n            mini = mini.min(uncommon_1);\\n        }\\n        if uncommon_2 % 2 == 0 {\\n            mini = mini.min(uncommon_2);\\n        }\\n        if mini == std::i32::MAX {\\n            return -1;\\n        }\\n        mini / 2\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3203576,
                "title": "c-beats-100-of-runtimes",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        int res = 0, cnt = 0;\\n        for (int i = 0; i < s.size(); ++ i) {\\n            if (s[i] == \\'1\\') ++ cnt;\\n            else -- cnt;\\n        }\\n        if (abs(cnt) > 1) return -1;\\n        char c = \\'1\\';\\n        if (cnt == -1) c = \\'0\\';\\n        if (!cnt) {\\n            int tmp = 0, cnt2 = 0;\\n            cnt = 0;\\n            for (int i = 0; i < s.size(); ++ i) {\\n                if (s[i] != c) {\\n                    if (cnt) -- cnt;\\n                    else {\\n                        ++ res;\\n                        ++ cnt;\\n                    }\\n                }\\n                if (s[i] != (\\'1\\' + \\'0\\' - c)) {\\n                    if (cnt2) -- cnt2;\\n                    else {\\n                        ++ tmp;\\n                        ++ cnt2;\\n                    }\\n                }\\n                c = \\'1\\' - c + \\'0\\';\\n            }\\n            res = min(res, tmp);\\n        } else {\\n            cnt = 0;\\n            for (int i = 0; i < s.size(); ++ i) {\\n                if (s[i] != c) {\\n                    if (cnt) -- cnt;\\n                    else {\\n                        ++ res;\\n                        ++ cnt;\\n                    }\\n                }\\n                c = \\'1\\' - c + \\'0\\';\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Please upvote if u like the solution :)**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        int res = 0, cnt = 0;\\n        for (int i = 0; i < s.size(); ++ i) {\\n            if (s[i] == \\'1\\') ++ cnt;\\n            else -- cnt;\\n        }\\n        if (abs(cnt) > 1) return -1;\\n        char c = \\'1\\';\\n        if (cnt == -1) c = \\'0\\';\\n        if (!cnt) {\\n            int tmp = 0, cnt2 = 0;\\n            cnt = 0;\\n            for (int i = 0; i < s.size(); ++ i) {\\n                if (s[i] != c) {\\n                    if (cnt) -- cnt;\\n                    else {\\n                        ++ res;\\n                        ++ cnt;\\n                    }\\n                }\\n                if (s[i] != (\\'1\\' + \\'0\\' - c)) {\\n                    if (cnt2) -- cnt2;\\n                    else {\\n                        ++ tmp;\\n                        ++ cnt2;\\n                    }\\n                }\\n                c = \\'1\\' - c + \\'0\\';\\n            }\\n            res = min(res, tmp);\\n        } else {\\n            cnt = 0;\\n            for (int i = 0; i < s.size(); ++ i) {\\n                if (s[i] != c) {\\n                    if (cnt) -- cnt;\\n                    else {\\n                        ++ res;\\n                        ++ cnt;\\n                    }\\n                }\\n                c = \\'1\\' - c + \\'0\\';\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200656,
                "title": "java-o-n-accepted-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countWrongPosition(String s, char curr){\\n        int count = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) != curr) count++;\\n            curr = curr == \\'0\\' ? \\'1\\' : \\'0\\';\\n        }\\n        return count;\\n    }\\n    public int minSwaps(String s) {\\n        int one = 0, zero = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == \\'0\\') zero++;\\n            else one++;\\n        }\\n        if(Math.abs(one - zero) > 1) return -1;\\n        char curr = one > zero ? \\'1\\' : \\'0\\';\\n        int count;\\n        if(one == zero) {\\n            count = Math.min(countWrongPosition(s, \\'0\\'), countWrongPosition(s, \\'1\\'));\\n        }\\n        else count = countWrongPosition(s, curr);\\n        return count/2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countWrongPosition(String s, char curr){\\n        int count = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) != curr) count++;\\n            curr = curr == \\'0\\' ? \\'1\\' : \\'0\\';\\n        }\\n        return count;\\n    }\\n    public int minSwaps(String s) {\\n        int one = 0, zero = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == \\'0\\') zero++;\\n            else one++;\\n        }\\n        if(Math.abs(one - zero) > 1) return -1;\\n        char curr = one > zero ? \\'1\\' : \\'0\\';\\n        int count;\\n        if(one == zero) {\\n            count = Math.min(countWrongPosition(s, \\'0\\'), countWrongPosition(s, \\'1\\'));\\n        }\\n        else count = countWrongPosition(s, curr);\\n        return count/2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173204,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first thought is to count the number of 0\\'s and 1\\'s in the string. If the difference in the number of 0\\'s and 1\\'s is more than 1, we can return -1. Otherwise, we can try to find the minimum number of swaps needed to move the 0\\'s and 1\\'s to the correct positions.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMy approach is to first count the number of 0\\'s and 1\\'s in the string. If the difference in the number of 0\\'s and 1\\'s is more than 1, we can return -1. Otherwise, we can use a loop to iterate through the string and count the number of 0\\'s and 1\\'s at even indices. We can then take the minimum of these two counts as the answer.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        int n = s.size();\\n        int cnt0 = 0, cnt1 = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (s[i] == \\'0\\') {\\n                ++cnt0;\\n            } else {\\n                ++cnt1;\\n            }\\n        }\\n        if (abs(cnt0 - cnt1) > 1) {\\n            return -1;\\n        }\\n        int ans = 0;\\n        if (cnt0 > cnt1) {\\n            for (int i = 0; i < n; i += 2) {\\n                if (s[i] == \\'1\\') {\\n                    ++ans;\\n                }\\n            }\\n        } else if (cnt0 < cnt1) {\\n            for (int i = 0; i < n; i += 2) {\\n                if (s[i] == \\'0\\') {\\n                    ++ans;\\n                }\\n            }\\n        } else {\\n            int ans1 = 0;\\n            for (int i = 0; i < n; i += 2) {\\n                if (s[i] == \\'1\\') {\\n                    ++ans1;\\n                }\\n            }\\n            int ans2 = 0;\\n            for (int i = 0; i < n; i += 2) {\\n                if (s[i] == \\'0\\') {\\n                    ++ans2;\\n                }\\n            }\\n            ans = min(ans1, ans2);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        int n = s.size();\\n        int cnt0 = 0, cnt1 = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (s[i] == \\'0\\') {\\n                ++cnt0;\\n            } else {\\n                ++cnt1;\\n            }\\n        }\\n        if (abs(cnt0 - cnt1) > 1) {\\n            return -1;\\n        }\\n        int ans = 0;\\n        if (cnt0 > cnt1) {\\n            for (int i = 0; i < n; i += 2) {\\n                if (s[i] == \\'1\\') {\\n                    ++ans;\\n                }\\n            }\\n        } else if (cnt0 < cnt1) {\\n            for (int i = 0; i < n; i += 2) {\\n                if (s[i] == \\'0\\') {\\n                    ++ans;\\n                }\\n            }\\n        } else {\\n            int ans1 = 0;\\n            for (int i = 0; i < n; i += 2) {\\n                if (s[i] == \\'1\\') {\\n                    ++ans1;\\n                }\\n            }\\n            int ans2 = 0;\\n            for (int i = 0; i < n; i += 2) {\\n                if (s[i] == \\'0\\') {\\n                    ++ans2;\\n                }\\n            }\\n            ans = min(ans1, ans2);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3167030,
                "title": "simple-java-solution-that-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSwaps(String s) {\\n        int numOfZero = 0;\\n        int numOfOne = 0;\\n        int misPositions = 0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'1\\') numOfOne++;\\n            else numOfZero++;\\n        }\\n        if(s.length()-numOfOne==numOfOne-1){\\n            boolean b = true;\\n            for(int i=0;i<s.length();i++){\\n                char c = s.charAt(i);\\n                if(b==true && c==\\'0\\' || b==false && c==\\'1\\') misPositions++;\\n                b = !b;\\n            }\\n        }\\n        else if(s.length()-numOfOne==numOfOne+1){\\n            // start with zero\\n            boolean b = false;\\n            for(int i=0;i<s.length();i++){\\n                char c = s.charAt(i);\\n                if(b==true && c==\\'0\\' || b==false && c==\\'1\\') misPositions++;\\n                b = !b;\\n            }\\n        }\\n        else if(s.length()-numOfOne==numOfOne){\\n            boolean b = true;\\n            for(int i=0;i<s.length();i++){\\n                char c = s.charAt(i);\\n                if(b==true && c==\\'0\\' || b==false && c==\\'1\\') misPositions++;\\n                b = !b;\\n            }\\n            misPositions = misPositions>s.length()/2 ? s.length()-misPositions : misPositions;\\n        }\\n        else{\\n            return -1;\\n        }\\n        return misPositions/2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSwaps(String s) {\\n        int numOfZero = 0;\\n        int numOfOne = 0;\\n        int misPositions = 0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'1\\') numOfOne++;\\n            else numOfZero++;\\n        }\\n        if(s.length()-numOfOne==numOfOne-1){\\n            boolean b = true;\\n            for(int i=0;i<s.length();i++){\\n                char c = s.charAt(i);\\n                if(b==true && c==\\'0\\' || b==false && c==\\'1\\') misPositions++;\\n                b = !b;\\n            }\\n        }\\n        else if(s.length()-numOfOne==numOfOne+1){\\n            // start with zero\\n            boolean b = false;\\n            for(int i=0;i<s.length();i++){\\n                char c = s.charAt(i);\\n                if(b==true && c==\\'0\\' || b==false && c==\\'1\\') misPositions++;\\n                b = !b;\\n            }\\n        }\\n        else if(s.length()-numOfOne==numOfOne){\\n            boolean b = true;\\n            for(int i=0;i<s.length();i++){\\n                char c = s.charAt(i);\\n                if(b==true && c==\\'0\\' || b==false && c==\\'1\\') misPositions++;\\n                b = !b;\\n            }\\n            misPositions = misPositions>s.length()/2 ? s.length()-misPositions : misPositions;\\n        }\\n        else{\\n            return -1;\\n        }\\n        return misPositions/2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3153622,
                "title": "simple-java-solution-using-count",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSwaps(String s) {\\n        int diff = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (c == \\'0\\') diff++;\\n            else diff--;\\n        }\\n        if (Math.abs(diff) > 1) return -1;\\n        if (diff == 0) {\\n            return Math.min(helper(s, 1), helper(s, -1));\\n        } else {\\n            return helper(s, diff);\\n        }\\n    }\\n\\n    public int helper(String s, int start) {\\n        int count = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (start > 0) {\\n                if (i % 2 == 0 && c != \\'0\\' || i % 2 == 1 && c != \\'1\\') {\\n                    count++;\\n                }\\n            } else {\\n                 if (i % 2 == 0 && c != \\'1\\' || i % 2 == 1 && c != \\'0\\') {\\n                    count++;\\n                }               \\n            }\\n        }\\n        return count / 2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSwaps(String s) {\\n        int diff = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (c == \\'0\\') diff++;\\n            else diff--;\\n        }\\n        if (Math.abs(diff) > 1) return -1;\\n        if (diff == 0) {\\n            return Math.min(helper(s, 1), helper(s, -1));\\n        } else {\\n            return helper(s, diff);\\n        }\\n    }\\n\\n    public int helper(String s, int start) {\\n        int count = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (start > 0) {\\n                if (i % 2 == 0 && c != \\'0\\' || i % 2 == 1 && c != \\'1\\') {\\n                    count++;\\n                }\\n            } else {\\n                 if (i % 2 == 0 && c != \\'1\\' || i % 2 == 1 && c != \\'0\\') {\\n                    count++;\\n                }               \\n            }\\n        }\\n        return count / 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145751,
                "title": "single-pass-o-n-solution-java-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRather than keeping only the count of zeroes and ones we keep the count of the odd and even separated for odd and even numbered indexes.\\nThis helps because we dont need to traverse the array again for finding the result.\\nThere are Four cases to consider : \\n1. If the difference between the ones and zeroes is more than 1 we return -1 since we cannot for a alternating string.\\n2. When the difference is equal to 1 there are two sub cases where 1 is more or 0 more. Whichever is more needs to occupy the even numbered indexes so we need to swap the particular items in the odd numbered index. Since we have the count already we can return it.\\n3. When the difference is equal to 0 the numbers need to be put in either of the indexes. If we need to put a number in even numbered indexes we need to swap all the occurence of the number in the odd numbered position and vice versa. Since we already have the count odd and even we can just return the min of the two.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSwaps(String s) {\\n        int odd1, odd0, even0, even1;\\n        odd1 = odd0 = even0 = even1 = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(i % 2 == 0) {\\n                if(s.charAt(i) == \\'0\\')\\n                    even0++;\\n                else \\n                    even1++;\\n            } else {\\n                if(s.charAt(i) == \\'0\\')\\n                    odd0++;\\n                else \\n                    odd1++;\\n            }\\n        }\\n        if(Math.abs(even0+odd0-odd1-even1) > 1)\\n            return -1;\\n        if(Math.abs(even0+odd0-odd1-even1) == 1) {\\n            if(even0+odd0-odd1-even1 < 0) {\\n                return odd1;\\n            } else {\\n                return odd0;\\n            }\\n        } else {\\n            return Math.min(even0, odd0);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSwaps(String s) {\\n        int odd1, odd0, even0, even1;\\n        odd1 = odd0 = even0 = even1 = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(i % 2 == 0) {\\n                if(s.charAt(i) == \\'0\\')\\n                    even0++;\\n                else \\n                    even1++;\\n            } else {\\n                if(s.charAt(i) == \\'0\\')\\n                    odd0++;\\n                else \\n                    odd1++;\\n            }\\n        }\\n        if(Math.abs(even0+odd0-odd1-even1) > 1)\\n            return -1;\\n        if(Math.abs(even0+odd0-odd1-even1) == 1) {\\n            if(even0+odd0-odd1-even1 < 0) {\\n                return odd1;\\n            } else {\\n                return odd0;\\n            }\\n        } else {\\n            return Math.min(even0, odd0);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3125334,
                "title": "c-o-n-greedy-solution-with-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf the size of the array is even, then ones and zeros should be balanced. If so, both of 1 and 0 can be the initial.\\n\\nOtherwise the size of the array is odd. The number of ones and zeros should differ by 1. The one with greater count should be the leading character.\\n\\nIf the string satisfy either of the above criteria, then the string always has a mismatch count divisible by 2. The number of swap needed is the number of mismatch divided by 2.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGreedy Algorithm\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int check(const string & s, bool start1) {\\n        // The string s is expected to satisfy \\n        //     1. equal number of 1 and 0 if s.size is even\\n        //     2. numbers of 1s and 0s differ by 1  if s.size is odd\\n        // Arg:\\n        //     s is the original string \\n        //     start1 tells whether the expected initial element is 1 or not\\n        // Return:\\n        //     the number of mismatched characters. The number should\\n        //     always be multiple of 2.\\n        int n = s.size(), ans = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (i % 2 == 0) {\\n                if (start1 && s[i] == \\'0\\') ++ans;\\n                else if (!start1 && s[i] == \\'1\\') ++ans;\\n            } else {\\n                if (start1 && s[i] == \\'1\\') ++ans;\\n                else if (!start1 && s[i] == \\'0\\') ++ans;\\n            }\\n        }\\n        return ans;\\n    }\\n    int minSwaps(string s) {\\n        int n = s.size();\\n        // count number of ones and zeros\\n        int n_one = accumulate(begin(s), end(s), 0, [](int x, char c) {\\n            return c == \\'1\\'?x+1:x;\\n        }), n_zero = n - n_one;\\n        \\n        // if the size of the array is even, then ones and zeros should\\n        // be balanced. If so, both of them can be the initial.\\n        if (s.size() % 2 == 0) {\\n            if (n_one != n_zero) return -1;\\n            return min(check(s, true)/2, check(s, false)/2);\\n        }\\n        // otherwise the array is odd. The number of ones and zeros should\\n        // differ by 1. The one with greater count should be the leading char\\n        if (n_one == n_zero + 1) return check(s, true)/2;\\n        if (n_zero == n_one + 1) return check(s, false)/2;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int check(const string & s, bool start1) {\\n        // The string s is expected to satisfy \\n        //     1. equal number of 1 and 0 if s.size is even\\n        //     2. numbers of 1s and 0s differ by 1  if s.size is odd\\n        // Arg:\\n        //     s is the original string \\n        //     start1 tells whether the expected initial element is 1 or not\\n        // Return:\\n        //     the number of mismatched characters. The number should\\n        //     always be multiple of 2.\\n        int n = s.size(), ans = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (i % 2 == 0) {\\n                if (start1 && s[i] == \\'0\\') ++ans;\\n                else if (!start1 && s[i] == \\'1\\') ++ans;\\n            } else {\\n                if (start1 && s[i] == \\'1\\') ++ans;\\n                else if (!start1 && s[i] == \\'0\\') ++ans;\\n            }\\n        }\\n        return ans;\\n    }\\n    int minSwaps(string s) {\\n        int n = s.size();\\n        // count number of ones and zeros\\n        int n_one = accumulate(begin(s), end(s), 0, [](int x, char c) {\\n            return c == \\'1\\'?x+1:x;\\n        }), n_zero = n - n_one;\\n        \\n        // if the size of the array is even, then ones and zeros should\\n        // be balanced. If so, both of them can be the initial.\\n        if (s.size() % 2 == 0) {\\n            if (n_one != n_zero) return -1;\\n            return min(check(s, true)/2, check(s, false)/2);\\n        }\\n        // otherwise the array is odd. The number of ones and zeros should\\n        // differ by 1. The one with greater count should be the leading char\\n        if (n_one == n_zero + 1) return check(s, true)/2;\\n        if (n_zero == n_one + 1) return check(s, false)/2;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3124021,
                "title": "java-simplest-method-with-explanation-100-faster",
                "content": "we do not really need to swap the character in string. \\n\\nIt is very easy to image what alternating string looks like(010101, or 101010), the pattern is either every even index is 0 and every odd index is 1, or every even index is 1 and every odd index is 0.  \\n\\nwe just need to check the difference bettwen the string and pattern, then we can get answer.\\n\\n```\\nclass Solution {\\n    public int minSwaps(String s) {\\n        int len = s.length();\\n        int a = 0; //count of \\'0\\' at even index\\n        int b = 0; //count of \\'1\\' at even index\\n        int c = 0; //count of \\'0\\' at odd index\\n        int d = 0; //count of \\'1\\' at odd index\\n        for(int i = 0; i < len; i++) {\\n            char ch = s.charAt(i);\\n            if(i % 2 == 0) {\\n                if(ch == \\'0\\') {\\n                    a++;\\n                } else {\\n                    b++; \\n                }\\n            } else {\\n                if(ch == \\'0\\') {\\n                    c++;\\n                } else {\\n                    d++;\\n                }\\n            }\\n        }\\n        int diff = a + c - (b + d); // a + c -> count of \\'0\\', b + d -> count of \\'1\\'\\n        if(Math.abs(diff) > 1) return -1; // if diff is more than 1, impossible\\n\\t\\t\\n\\t\\t// we only conside even index here, because if even index is right, odd index is automatically right, vice versa\\n        if(diff > 0) {\\n            return b;  //count of \\'0\\' is more than \\'1\\', so every even index must be \\'0\\'. b represent \\'1\\' at even index, so we need to swap them.\\n        } else if(diff < 0) {\\n            return a; // similar to above\\n        } else {\\n            return Math.min(a, b); // every even index can be either \\'0\\' or \\'1\\'. we want the minimum swap, so return min\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSwaps(String s) {\\n        int len = s.length();\\n        int a = 0; //count of \\'0\\' at even index\\n        int b = 0; //count of \\'1\\' at even index\\n        int c = 0; //count of \\'0\\' at odd index\\n        int d = 0; //count of \\'1\\' at odd index\\n        for(int i = 0; i < len; i++) {\\n            char ch = s.charAt(i);\\n            if(i % 2 == 0) {\\n                if(ch == \\'0\\') {\\n                    a++;\\n                } else {\\n                    b++; \\n                }\\n            } else {\\n                if(ch == \\'0\\') {\\n                    c++;\\n                } else {\\n                    d++;\\n                }\\n            }\\n        }\\n        int diff = a + c - (b + d); // a + c -> count of \\'0\\', b + d -> count of \\'1\\'\\n        if(Math.abs(diff) > 1) return -1; // if diff is more than 1, impossible\\n\\t\\t\\n\\t\\t// we only conside even index here, because if even index is right, odd index is automatically right, vice versa\\n        if(diff > 0) {\\n            return b;  //count of \\'0\\' is more than \\'1\\', so every even index must be \\'0\\'. b represent \\'1\\' at even index, so we need to swap them.\\n        } else if(diff < 0) {\\n            return a; // similar to above\\n        } else {\\n            return Math.min(a, b); // every even index can be either \\'0\\' or \\'1\\'. we want the minimum swap, so return min\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3116724,
                "title": "simple-java-code-easy-to-understand-na-ve-solution",
                "content": "Program first counts the number of zeros and ones in the string. If the difference between the two is greater than 1, the method returns -1, indicating that it is not possible to make the string an alternating binary string.\\n\\nOtherwise, it checks two cases: one where the first character of the string is 1 and another where it is 0. In both cases, it checks if the current character in the string is the same as the alternating value (1 or 0), and if not, it increments the cost. Finally, it returns the minimum cost among the two cases.\\n\\nif both cost is even it returnned min cost.\\n\\n\\n```\\nclass Solution {\\n    public int minSwaps(String str) {\\n       int count0 = 0;\\n        int count1 = 0;\\n\\n        for (int i = 0; i < str.length(); i++) {\\n            char c = str.charAt(i);\\n            if (c == \\'0\\') {\\n                count0++;\\n            } else if (c == \\'1\\') {\\n                count1++;\\n            }\\n        }\\n        if (Math.abs(count0 - count1) > 1) {\\n            return -1;\\n        } else {\\n            // 1 at first\\n            int i = 0;\\n            int cost1 = 0;\\n            while (i < str.length()) {\\n                if (i % 2 == 0) {\\n                    if (str.charAt(i) != \\'1\\') {\\n                        cost1++;\\n                    }\\n                } else {\\n                    if (str.charAt(i) != \\'0\\') {\\n                        cost1++;\\n                    }\\n                }\\n                i++;\\n            }\\n\\n            // 0 at first\\n            int j = 0;\\n            int cost0 = 0;\\n            while (j < str.length()) {\\n                if (j % 2 == 0) {\\n                    if (str.charAt(j) != \\'0\\') {\\n                        cost0++;\\n                    }\\n                } else {\\n                    if (str.charAt(j) != \\'1\\') {\\n                        cost0++;\\n                    }\\n                }\\n                j++;\\n            }\\n\\n            if (cost0 % 2 == 0 && cost1 % 2 == 0) {\\n                if (cost0 / 2 < cost1 / 2) {\\n                    return cost0 / 2;\\n                  \\n                } else {\\n                    return cost1 / 2;\\n               \\n                }\\n            }\\n\\n            else {\\n                if (cost0 % 2 == 0)\\n                    return cost0 / 2;\\n                   \\n                else\\n                    return cost1 / 2;\\n                  \\n            }  \\n    }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSwaps(String str) {\\n       int count0 = 0;\\n        int count1 = 0;\\n\\n        for (int i = 0; i < str.length(); i++) {\\n            char c = str.charAt(i);\\n            if (c == \\'0\\') {\\n                count0++;\\n            } else if (c == \\'1\\') {\\n                count1++;\\n            }\\n        }\\n        if (Math.abs(count0 - count1) > 1) {\\n            return -1;\\n        } else {\\n            // 1 at first\\n            int i = 0;\\n            int cost1 = 0;\\n            while (i < str.length()) {\\n                if (i % 2 == 0) {\\n                    if (str.charAt(i) != \\'1\\') {\\n                        cost1++;\\n                    }\\n                } else {\\n                    if (str.charAt(i) != \\'0\\') {\\n                        cost1++;\\n                    }\\n                }\\n                i++;\\n            }\\n\\n            // 0 at first\\n            int j = 0;\\n            int cost0 = 0;\\n            while (j < str.length()) {\\n                if (j % 2 == 0) {\\n                    if (str.charAt(j) != \\'0\\') {\\n                        cost0++;\\n                    }\\n                } else {\\n                    if (str.charAt(j) != \\'1\\') {\\n                        cost0++;\\n                    }\\n                }\\n                j++;\\n            }\\n\\n            if (cost0 % 2 == 0 && cost1 % 2 == 0) {\\n                if (cost0 / 2 < cost1 / 2) {\\n                    return cost0 / 2;\\n                  \\n                } else {\\n                    return cost1 / 2;\\n               \\n                }\\n            }\\n\\n            else {\\n                if (cost0 % 2 == 0)\\n                    return cost0 / 2;\\n                   \\n                else\\n                    return cost1 / 2;\\n                  \\n            }  \\n    }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3104950,
                "title": "c-faster-simple-code-with-explaination",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        int countZero = 0;\\n        int countOne = 0;\\n        int Size = s.size();\\n        int wrongPlaced = 0; \\n        for(int i = 0; i < Size; i++){\\n            if(s[i] == \\'0\\'){\\n                countZero++;\\n            }\\n            if(!(i%2) && s[i] == \\'1\\'){\\n                // considering at even indices there must be \\'0\\' otherwise it is wrong placed;\\n                wrongPlaced++;\\n            }\\n        }\\n        countOne = Size - countZero;\\n        int half = (Size+1)/2;\\n        if(abs(countZero - countOne) > 1){\\n            return -1;\\n        }\\n        if(countZero > countOne){// alternating string starts with \\'0\\'. MUST\\n            return wrongPlaced;\\n        }else if(countOne > countZero){ // alternating string starts with \\'1\\'. MUST\\n            return half-wrongPlaced;\\n        }else{\\n            return min(wrongPlaced, half-wrongPlaced); // alternating string can start with eithr \\'0\\' or \\'1\\';\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        int countZero = 0;\\n        int countOne = 0;\\n        int Size = s.size();\\n        int wrongPlaced = 0; \\n        for(int i = 0; i < Size; i++){\\n            if(s[i] == \\'0\\'){\\n                countZero++;\\n            }\\n            if(!(i%2) && s[i] == \\'1\\'){\\n                // considering at even indices there must be \\'0\\' otherwise it is wrong placed;\\n                wrongPlaced++;\\n            }\\n        }\\n        countOne = Size - countZero;\\n        int half = (Size+1)/2;\\n        if(abs(countZero - countOne) > 1){\\n            return -1;\\n        }\\n        if(countZero > countOne){// alternating string starts with \\'0\\'. MUST\\n            return wrongPlaced;\\n        }else if(countOne > countZero){ // alternating string starts with \\'1\\'. MUST\\n            return half-wrongPlaced;\\n        }else{\\n            return min(wrongPlaced, half-wrongPlaced); // alternating string can start with eithr \\'0\\' or \\'1\\';\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3032597,
                "title": "java-easy-explanation-o-n-1ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSwaps(String s) {\\n        char[] ar=s.toCharArray();\\n        int length=s.length();\\n        int m=0;\\n        int n=0;\\n        int wm=0; // no of swaps for 0\\n        int wn=0; // no of swaps for 1\\n        int ans1=0; // Expecting even numbers to be 1 and odd 0\\n        int ans2=0; // Expecting even numbers to be 0 and odd 1\\n\\n        //checking if number of 1s and 0s have a max difference of 1\\n        for(int i=0;i<length;i++){\\n            if(ar[i]==\\'0\\'){\\n                m++;\\n            }else{\\n                n++;\\n            }\\n\\n\\n        }\\n        if(m-n > 1 || n-m >1){\\n            return -1;\\n        }\\n        // Expecting even numbers to be 1 and odd 0\\n        for(int i=0;i<length;i++){\\n           if(i%2==0){\\n               if(ar[i]!=\\'1\\'){\\n                   wn++;\\n               }\\n           }else{\\n               if(ar[i]!=\\'0\\'){\\n                   wm++;\\n               }\\n\\n           }\\n        }\\n        if(wm==wn){\\n            ans1=wm;\\n        }else{\\n            //if no of swaps for 1s and 0s are not equal\\n            ans1=-1;\\n        }\\n           \\n            wm=0;\\n            wn=0;\\n            // Expecting even numbers to be 0 and odd 1\\n            for(int i=0;i<length;i++){\\n           if(i%2==0){\\n               if(ar[i]!=\\'0\\'){\\n                   wm++;\\n               }\\n           }else{\\n               if(ar[i]!=\\'1\\'){\\n                   wn++;\\n               }\\n\\n           }\\n        }\\n        if(wm==wn){\\n            ans2=wm;\\n        \\n        }else{\\n            //if no of swaps for 1s and 0s are not equal\\n            ans2=-1;\\n        }\\n       \\n\\n        if(ans2>-1 && ans1>-1){\\n            return Math.min(ans2,ans1);\\n        }\\n        if(ans2>-1)\\n        {\\n            return ans2;\\n        }else{\\n            return ans1;\\n        }\\n\\n           \\n        \\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSwaps(String s) {\\n        char[] ar=s.toCharArray();\\n        int length=s.length();\\n        int m=0;\\n        int n=0;\\n        int wm=0; // no of swaps for 0\\n        int wn=0; // no of swaps for 1\\n        int ans1=0; // Expecting even numbers to be 1 and odd 0\\n        int ans2=0; // Expecting even numbers to be 0 and odd 1\\n\\n        //checking if number of 1s and 0s have a max difference of 1\\n        for(int i=0;i<length;i++){\\n            if(ar[i]==\\'0\\'){\\n                m++;\\n            }else{\\n                n++;\\n            }\\n\\n\\n        }\\n        if(m-n > 1 || n-m >1){\\n            return -1;\\n        }\\n        // Expecting even numbers to be 1 and odd 0\\n        for(int i=0;i<length;i++){\\n           if(i%2==0){\\n               if(ar[i]!=\\'1\\'){\\n                   wn++;\\n               }\\n           }else{\\n               if(ar[i]!=\\'0\\'){\\n                   wm++;\\n               }\\n\\n           }\\n        }\\n        if(wm==wn){\\n            ans1=wm;\\n        }else{\\n            //if no of swaps for 1s and 0s are not equal\\n            ans1=-1;\\n        }\\n           \\n            wm=0;\\n            wn=0;\\n            // Expecting even numbers to be 0 and odd 1\\n            for(int i=0;i<length;i++){\\n           if(i%2==0){\\n               if(ar[i]!=\\'0\\'){\\n                   wm++;\\n               }\\n           }else{\\n               if(ar[i]!=\\'1\\'){\\n                   wn++;\\n               }\\n\\n           }\\n        }\\n        if(wm==wn){\\n            ans2=wm;\\n        \\n        }else{\\n            //if no of swaps for 1s and 0s are not equal\\n            ans2=-1;\\n        }\\n       \\n\\n        if(ans2>-1 && ans1>-1){\\n            return Math.min(ans2,ans1);\\n        }\\n        if(ans2>-1)\\n        {\\n            return ans2;\\n        }else{\\n            return ans1;\\n        }\\n\\n           \\n        \\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2970953,
                "title": "c-o-n-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n  If the string is alternating, the odd index and even index sholud   be all \\'1\\' or \\'0\\'. Let\\'s count it.\\n# Approach\\n1. count the number of \\'0\\' and \\'1\\' for odd and even index.\\n2. check whether \\'0\\' is equal to \\'1\\', because you have to swap to make it alteranting, so the number should be euqal.\\n3. return the minimum result\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        int odd_index_z = 0;\\n        int odd_index_o = 0;\\n        int even_index_z = 0;\\n        int even_index_o = 0;\\n        int res = INT_MAX;\\n        if(s.size() == 1) return 0;\\n        for(int i = 0;i < s.size();i++) {\\n          if(i % 2 == 0) {\\n            if(s[i] == \\'0\\') even_index_z++;\\n            if(s[i] == \\'1\\') even_index_o++;\\n          }else {\\n            if(s[i] == \\'0\\') odd_index_z++;\\n            if(s[i] == \\'1\\') odd_index_o++;\\n          }\\n        }\\n        if(odd_index_z == even_index_o) {\\n          res = odd_index_z;\\n        }\\n        \\n        if(odd_index_o == even_index_z) {\\n          res = min(res, odd_index_o);\\n        }\\n        return res == INT_MAX ? -1 : res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        int odd_index_z = 0;\\n        int odd_index_o = 0;\\n        int even_index_z = 0;\\n        int even_index_o = 0;\\n        int res = INT_MAX;\\n        if(s.size() == 1) return 0;\\n        for(int i = 0;i < s.size();i++) {\\n          if(i % 2 == 0) {\\n            if(s[i] == \\'0\\') even_index_z++;\\n            if(s[i] == \\'1\\') even_index_o++;\\n          }else {\\n            if(s[i] == \\'0\\') odd_index_z++;\\n            if(s[i] == \\'1\\') odd_index_o++;\\n          }\\n        }\\n        if(odd_index_z == even_index_o) {\\n          res = odd_index_z;\\n        }\\n        \\n        if(odd_index_o == even_index_z) {\\n          res = min(res, odd_index_o);\\n        }\\n        return res == INT_MAX ? -1 : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2970744,
                "title": "python-greedy-o-n",
                "content": "# Code\\n```\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        n = len(s)\\n        if abs(s.count(\\'0\\') - s.count(\\'1\\')) > 1: return -1\\n        if abs(s.count(\\'0\\') - s.count(\\'1\\')) == 0:\\n            tmp = \"\".join([str(i%2) for i in range(n)])\\n            res = sum([1 for x,y in zip(tmp,s) if x != y])\\n            tmp = \"\".join([str((i+1)%2) for i in range(n)])\\n            res = min(res, sum([1 for x,y in zip(tmp,s) if x != y]))\\n        elif s.count(\\'0\\') - s.count(\\'1\\') > 0:\\n            tmp = \"\".join([str(i%2) for i in range(n)])\\n            res = sum([1 for x,y in zip(tmp,s) if x != y])\\n        else:\\n            tmp = \"\".join([str((i+1)%2) for i in range(n)])\\n            res = sum([1 for x,y in zip(tmp,s) if x != y])\\n        return (res+1)//2\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        n = len(s)\\n        if abs(s.count(\\'0\\') - s.count(\\'1\\')) > 1: return -1\\n        if abs(s.count(\\'0\\') - s.count(\\'1\\')) == 0:\\n            tmp = \"\".join([str(i%2) for i in range(n)])\\n            res = sum([1 for x,y in zip(tmp,s) if x != y])\\n            tmp = \"\".join([str((i+1)%2) for i in range(n)])\\n            res = min(res, sum([1 for x,y in zip(tmp,s) if x != y]))\\n        elif s.count(\\'0\\') - s.count(\\'1\\') > 0:\\n            tmp = \"\".join([str(i%2) for i in range(n)])\\n            res = sum([1 for x,y in zip(tmp,s) if x != y])\\n        else:\\n            tmp = \"\".join([str((i+1)%2) for i in range(n)])\\n            res = sum([1 for x,y in zip(tmp,s) if x != y])\\n        return (res+1)//2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2940477,
                "title": "easy-python-hashmap-counting",
                "content": "class Solution:\\nuse hashmap count the characters, if diff != 0 or != 1, return -1 \\nuse odd_count to find out the number of 1s or 0s in odd index\\nif len(s) is even, we can visualize the odd even as a symmetric matrix, minimum of odd/even of either 1 or 0 is good\\nif len(s) is odd, the matrix must be asymmetric, we return the one with equal values, where odd one correspond to even zero, vice cersa \\n\\n\\n    def minSwaps(self, s: str) -> int:\\n        hashmap = defaultdict(int)\\n        odd_count = {\\'0\\':0,\\'1\\':0}\\n        for i,char in enumerate(s):\\n            hashmap[char] += 1\\n            if i%2 == 1:\\n                odd_count[char] += 1\\n        \\n        \\n        if len(s)%2 ==  1:\\n            if abs(hashmap[\\'0\\']-hashmap[\\'1\\']) != 1:\\n                return -1 \\n            \\n            \\n            even_one = hashmap[\\'1\\'] - odd_count[\\'1\\']\\n            even_zero = hashmap[\\'0\\'] - odd_count[\\'0\\']\\n            if odd_count[\\'1\\'] == even_zero:\\n                return even_zero\\n            else:\\n                return even_one\\n            \\n        else:\\n            if hashmap[\\'0\\'] != hashmap[\\'1\\']:\\n                return -1 \\n            \\n            return min(odd_count[\\'1\\'],hashmap[\\'1\\']-odd_count[\\'1\\'])",
                "solutionTags": [
                    "Counting"
                ],
                "code": "class Solution:\\nuse hashmap count the characters, if diff != 0 or != 1, return -1 \\nuse odd_count to find out the number of 1s or 0s in odd index\\nif len(s) is even, we can visualize the odd even as a symmetric matrix, minimum of odd/even of either 1 or 0 is good\\nif len(s) is odd, the matrix must be asymmetric, we return the one with equal values, where odd one correspond to even zero, vice cersa \\n\\n\\n    def minSwaps(self, s: str) -> int:\\n        hashmap = defaultdict(int)\\n        odd_count = {\\'0\\':0,\\'1\\':0}",
                "codeTag": "Java"
            },
            {
                "id": 2872076,
                "title": "c",
                "content": "Runtime: 0 ms, faster than 100.00% of C online submissions for Minimum Number of Swaps to Make the Binary String Alternating.\\nMemory Usage: 6 MB, less than 50.00% of C online submissions for Minimum Number of Swaps to Make the Binary String Alternating.\\n```\\nint minSwaps(char * s){\\n    int n = strlen(s);\\n    int one = 0;\\n    for(int i = 0; i < n; i++){\\n        if(s[i] == \\'1\\')\\n            one++;\\n    }\\n    int zero = n - one;\\n    if(abs(one - zero) > 1)\\n        return -1;\\n    \\n    if(zero > one){\\n        int cn = 0;\\n        for(int i = 0; i < n; i++){\\n            if(i % 2 == 0){\\n                if(s[i] != \\'0\\')\\n                    cn++;\\n            }\\n            else{\\n                if(s[i] != \\'1\\')\\n                    cn++;\\n            }\\n        }\\n        return cn/2;\\n    }\\n\\n    else if(one > zero){\\n        int cn = 0;\\n        for(int i = 0; i < n; i++){\\n            if(i % 2 == 0){\\n                if(s[i] != \\'1\\')\\n                    cn++;\\n            }\\n            else{\\n                if(s[i] != \\'0\\')\\n                    cn++;\\n            }\\n        }\\n        return cn/2;\\n    }\\n    else{\\n        int cn1 = 0, cn2 = 0;\\n        for(int i = 0; i < n; i++){\\n            if(i % 2 == 0){\\n                if(s[i] != \\'0\\')\\n                    cn1++;\\n            }\\n            else{\\n                if(s[i] != \\'1\\')\\n                    cn1++;\\n            }\\n        }\\n        for(int i = 0; i < n; i++){\\n            if(i % 2 == 0){\\n                if(s[i] != \\'1\\')\\n                    cn2++;\\n            }\\n            else{\\n                if(s[i] != \\'0\\')\\n                    cn2++;\\n            }\\n        }\\n        return fmin(cn1, cn2)/2;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint minSwaps(char * s){\\n    int n = strlen(s);\\n    int one = 0;\\n    for(int i = 0; i < n; i++){\\n        if(s[i] == \\'1\\')\\n            one++;\\n    }\\n    int zero = n - one;\\n    if(abs(one - zero) > 1)\\n        return -1;\\n    \\n    if(zero > one){\\n        int cn = 0;\\n        for(int i = 0; i < n; i++){\\n            if(i % 2 == 0){\\n                if(s[i] != \\'0\\')\\n                    cn++;\\n            }\\n            else{\\n                if(s[i] != \\'1\\')\\n                    cn++;\\n            }\\n        }\\n        return cn/2;\\n    }\\n\\n    else if(one > zero){\\n        int cn = 0;\\n        for(int i = 0; i < n; i++){\\n            if(i % 2 == 0){\\n                if(s[i] != \\'1\\')\\n                    cn++;\\n            }\\n            else{\\n                if(s[i] != \\'0\\')\\n                    cn++;\\n            }\\n        }\\n        return cn/2;\\n    }\\n    else{\\n        int cn1 = 0, cn2 = 0;\\n        for(int i = 0; i < n; i++){\\n            if(i % 2 == 0){\\n                if(s[i] != \\'0\\')\\n                    cn1++;\\n            }\\n            else{\\n                if(s[i] != \\'1\\')\\n                    cn1++;\\n            }\\n        }\\n        for(int i = 0; i < n; i++){\\n            if(i % 2 == 0){\\n                if(s[i] != \\'1\\')\\n                    cn2++;\\n            }\\n            else{\\n                if(s[i] != \\'0\\')\\n                    cn2++;\\n            }\\n        }\\n        return fmin(cn1, cn2)/2;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2863490,
                "title": "one-pass-count-mismatch",
                "content": "Final state should be either 0101010101... or 1010101010...\\nDuring the one-pass, count mismatch of 0 and 1 for these two cases.\\n(It can be cleverly done in the code)\\nMismatch not equal in both case: return -1\\nOne case mismatch equal: return it\\nTwo cases mismatch equal: return min(case1,case2)\\n\\n\\nOops, one-pass has already been pointed out here. (It\\'s better than mine.)\\nhttps://leetcode.com/problems/minimum-number-of-swaps-to-make-the-binary-string-alternating/discuss/2823501/Python-one-and-only-loop\\nJust regard mine as some comments on the existing one.\\n\\n```\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        \\n        misfit10 = [0,0]\\n        misfit01 = [0,0]\\n\\n        for i,c in enumerate(s):\\n            mod = i%2\\n            misfit10[mod] += (1 if c == str(mod) else 0)\\n            misfit01[mod] += (1 if c != str(mod) else 0)                \\n                \\n        if misfit10[0] != misfit10[1] and misfit01[0] != misfit01[1]:\\n            return -1\\n        if misfit10[0] != misfit10[1]:\\n            return misfit01[0]\\n        if misfit01[0] != misfit01[1]:\\n            return misfit10[0]\\n        return min(misfit01[0],misfit10[0])\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        \\n        misfit10 = [0,0]\\n        misfit01 = [0,0]\\n\\n        for i,c in enumerate(s):\\n            mod = i%2\\n            misfit10[mod] += (1 if c == str(mod) else 0)\\n            misfit01[mod] += (1 if c != str(mod) else 0)                \\n                \\n        if misfit10[0] != misfit10[1] and misfit01[0] != misfit01[1]:\\n            return -1\\n        if misfit10[0] != misfit10[1]:\\n            return misfit01[0]\\n        if misfit01[0] != misfit01[1]:\\n            return misfit10[0]\\n        return min(misfit01[0],misfit10[0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2805179,
                "title": "python-o-n-easy-way",
                "content": "\\n\\n# Approach\\nPython compare two possible permutation\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        c_s = Counter(s)\\n        if abs(c_s[\"1\"] - c_s[\"0\"]) > 1:\\n            return -1\\n\\n        # two possible permutation \"1010...\" and \"0101...\"\\n        # compare with original string \\n        ans, ans1 = 0, 0\\n        next_s, next_s1 = \"0\", \"1\"\\n        for i in range(len(s)):\\n            if s[i] == next_s:\\n                ans1 += 1\\n            else:\\n                ans += 1\\n            tmp = next_s1\\n            next_s1 = next_s\\n            next_s = tmp\\n        \\n        # if ans is not even thus it\\'s impossible to swap\\n        if ans % 2 != 0:\\n            return ans1//2\\n        elif ans1 % 2 != 0:\\n            return ans//2\\n        else:\\n            return min(ans1//2, ans//2)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        c_s = Counter(s)\\n        if abs(c_s[\"1\"] - c_s[\"0\"]) > 1:\\n            return -1\\n\\n        # two possible permutation \"1010...\" and \"0101...\"\\n        # compare with original string \\n        ans, ans1 = 0, 0\\n        next_s, next_s1 = \"0\", \"1\"\\n        for i in range(len(s)):\\n            if s[i] == next_s:\\n                ans1 += 1\\n            else:\\n                ans += 1\\n            tmp = next_s1\\n            next_s1 = next_s\\n            next_s = tmp\\n        \\n        # if ans is not even thus it\\'s impossible to swap\\n        if ans % 2 != 0:\\n            return ans1//2\\n        elif ans1 % 2 != 0:\\n            return ans//2\\n        else:\\n            return min(ans1//2, ans//2)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2804930,
                "title": "python-4-liner",
                "content": "```\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        even_ones, odd_ones = (sum(1 for c in s[i::2] if c==\\'1\\') for i in range(2))\\n        ones = even_ones + odd_ones\\n        zeros = len(s) - ones\\n        return min((zeros, odd_ones), (ones, even_ones))[1] if abs(ones - zeros) < 2 else -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        even_ones, odd_ones = (sum(1 for c in s[i::2] if c==\\'1\\') for i in range(2))\\n        ones = even_ones + odd_ones\\n        zeros = len(s) - ones\\n        return min((zeros, odd_ones), (ones, even_ones))[1] if abs(ones - zeros) < 2 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2794748,
                "title": "simple-and-clean-python-o-n-solution",
                "content": "# Intuition\\nIf we can count how many 0\\'s and 1\\'s swaps we need to produce alternating string then we have our answer if those counts do match each other. We have to do this exercise twice accounting two possible versions of alternation (010.., 101..).\\n\\n# Approach\\nWe can keep current alternating digit in a variable and use (XOR 1) to produce inverted sequence in the same time. That allows us to do single pass and populate two sets of counters.\\nIf both sets do not have matching counts we return -1.\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# IDEA: count how many 0\\'s and 1\\'s swaps we need to produce alternating string;\\n#       since there are two ways to alternate - start with 0 (010..) or inversion starting with 1 (101..),\\n#       we need to store two sets of counts and select optimal one in the end;\\n#       we will keep current alternating digit in a variable and use XOR to produce inverted sequence\\n#       O(N) time, O(1) space\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        minFlips = sys.maxsize\\n        swap0, swap1 = [0,0], [0,0]\\n        is1 = 1\\n        for c in s:\\n            if c == \\'0\\':\\n                swap0[is1] += 1\\n            else:\\n                swap1[is1^1] += 1\\n            is1 ^= 1\\n        if swap0[0] == swap1[0]:\\n            minFlips = swap0[0]\\n        if swap0[1] == swap1[1]:\\n            minFlips = min(minFlips, swap0[1])\\n        return -1 if minFlips == sys.maxsize else minFlips\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# IDEA: count how many 0\\'s and 1\\'s swaps we need to produce alternating string;\\n#       since there are two ways to alternate - start with 0 (010..) or inversion starting with 1 (101..),\\n#       we need to store two sets of counts and select optimal one in the end;\\n#       we will keep current alternating digit in a variable and use XOR to produce inverted sequence\\n#       O(N) time, O(1) space\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        minFlips = sys.maxsize\\n        swap0, swap1 = [0,0], [0,0]\\n        is1 = 1\\n        for c in s:\\n            if c == \\'0\\':\\n                swap0[is1] += 1\\n            else:\\n                swap1[is1^1] += 1\\n            is1 ^= 1\\n        if swap0[0] == swap1[0]:\\n            minFlips = swap0[0]\\n        if swap0[1] == swap1[1]:\\n            minFlips = min(minFlips, swap0[1])\\n        return -1 if minFlips == sys.maxsize else minFlips\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2785514,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        string j=\"\",k=\"\";\\n        int z=0,o=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n           if(s[i]==\\'0\\')\\n            z++;\\n            else\\n            o++;\\n            if(i==0)\\n            {\\n                \\n                j+=\\'0\\';\\n                \\n                k+=\\'1\\';\\n            }\\n            else{\\n                if(j[i-1]==\\'0\\')\\n                j+=\\'1\\',k+=\\'0\\';\\n                else\\n                j+=\\'0\\',k+=\\'1\\';\\n            }\\n        }\\n        if(abs(z-o)>1)\\n        {\\n            return -1;\\n        }\\n        else{\\n            int ctr=0,dtr=0;\\n            for(int i=0;i<s.size();i++)\\n            {\\n                if(s[i]!=j[i])\\n                 ctr++;\\n                 if(s[i]!=k[i])\\n                 dtr++;\\n            }\\n            if(dtr%2)\\n            return ctr/2;\\n            else if(ctr%2)\\n            return dtr/2;\\n            else\\n            return min(ctr/2,dtr/2);\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        string j=\"\",k=\"\";\\n        int z=0,o=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n           if(s[i]==\\'0\\')\\n            z++;\\n            else\\n            o++;\\n            if(i==0)\\n            {\\n                \\n                j+=\\'0\\';\\n                \\n                k+=\\'1\\';\\n            }\\n            else{\\n                if(j[i-1]==\\'0\\')\\n                j+=\\'1\\',k+=\\'0\\';\\n                else\\n                j+=\\'0\\',k+=\\'1\\';\\n            }\\n        }\\n        if(abs(z-o)>1)\\n        {\\n            return -1;\\n        }\\n        else{\\n            int ctr=0,dtr=0;\\n            for(int i=0;i<s.size();i++)\\n            {\\n                if(s[i]!=j[i])\\n                 ctr++;\\n                 if(s[i]!=k[i])\\n                 dtr++;\\n            }\\n            if(dtr%2)\\n            return ctr/2;\\n            else if(ctr%2)\\n            return dtr/2;\\n            else\\n            return min(ctr/2,dtr/2);\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772540,
                "title": "100tc-simple-implementation-c-greedy-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        int n=s.size();\\n        int cntone=0;\\n        int cntzero=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'1\\'){\\n                cntone++;\\n            }\\n            else cntzero++;\\n        }\\n        if(n%2==0){\\n            if(cntzero!=cntone){\\n                return -1;\\n            }\\n        }\\n        else{\\n            if((n/2==cntzero && cntone-1==cntzero) || (n/2==cntone && cntzero-1==cntone)){\\n                // continue;\\n            }\\n            else return -1;\\n        }\\n        int evenindexonecnt=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'1\\'){\\n                if(i%2==0){\\n                    evenindexonecnt++;\\n                }\\n            }\\n        }\\n        int totalevenindex=n/2+n%2;\\n        int totaloddindex=n/2;\\n\\t\\t// if total length is odd then shift all the one or zero which is greater to the even index side(0,2,4....)\\n        if(cntone>cntzero){\\n            return totalevenindex-evenindexonecnt;\\n        }\\n        else if(cntone<cntzero){\\n            return evenindexonecnt;\\n        }\\n\\t\\t// if size if even then take minimun value of shifting all value to even index or odd index\\n        return min(evenindexonecnt,totalevenindex-evenindexonecnt);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        int n=s.size();\\n        int cntone=0;\\n        int cntzero=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'1\\'){\\n                cntone++;\\n            }\\n            else cntzero++;\\n        }\\n        if(n%2==0){\\n            if(cntzero!=cntone){\\n                return -1;\\n            }\\n        }\\n        else{\\n            if((n/2==cntzero && cntone-1==cntzero) || (n/2==cntone && cntzero-1==cntone)){\\n                // continue;\\n            }\\n            else return -1;\\n        }\\n        int evenindexonecnt=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'1\\'){\\n                if(i%2==0){\\n                    evenindexonecnt++;\\n                }\\n            }\\n        }\\n        int totalevenindex=n/2+n%2;\\n        int totaloddindex=n/2;\\n\\t\\t// if total length is odd then shift all the one or zero which is greater to the even index side(0,2,4....)\\n        if(cntone>cntzero){\\n            return totalevenindex-evenindexonecnt;\\n        }\\n        else if(cntone<cntzero){\\n            return evenindexonecnt;\\n        }\\n\\t\\t// if size if even then take minimun value of shifting all value to even index or odd index\\n        return min(evenindexonecnt,totalevenindex-evenindexonecnt);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2771037,
                "title": "python-easy-understanding",
                "content": "Not an effecient solution\\n```\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        zero = 0\\n        one = 0\\n        for i in s:\\n            if i == \"0\":\\n                zero += 1\\n            else:\\n                one += 1\\n                \\n        def starts_with_one(s):\\n            arr = []\\n            for i in range(len(s)):\\n                if i % 2 == 0:\\n                    arr.append(\"1\")\\n                else:\\n                    arr.append(\"0\")\\n            count = 0\\n            for i in range(len(s)):\\n                if s[i] != arr[i]:\\n                    count += 1\\n            return count // 2\\n        \\n        def starts_with_zero(s):\\n            arr = []\\n            for i in range(len(s)):\\n                if i % 2 == 0:\\n                    arr.append(\"0\")\\n                else:\\n                    arr.append(\"1\")\\n                    \\n            count = 0\\n            for i in range(len(s)):\\n                if s[i] != arr[i]:\\n                    count += 1\\n            return count // 2\\n            \\n        \\n        if zero - one == 1:\\n            #It starts with zero and end with zero\\n            print(\"zero\")\\n            return starts_with_zero(s)\\n        elif one - zero == 1:\\n            #it starts with one and ends with one\\n            return starts_with_one(s)\\n        elif zero == one:\\n            #either starts with one or zero\\n            return min(starts_with_one(s),starts_with_zero(s))\\n        else:\\n            #not possible\\n            return -1\\n",
                "solutionTags": [],
                "code": "Not an effecient solution\\n```\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        zero = 0\\n        one = 0\\n        for i in s:\\n            if i == \"0\":\\n                zero += 1\\n            else:\\n                one += 1\\n                \\n        def starts_with_one(s):\\n            arr = []\\n            for i in range(len(s)):\\n                if i % 2 == 0:\\n                    arr.append(\"1\")\\n                else:\\n                    arr.append(\"0\")\\n            count = 0\\n            for i in range(len(s)):\\n                if s[i] != arr[i]:\\n                    count += 1\\n            return count // 2\\n        \\n        def starts_with_zero(s):\\n            arr = []\\n            for i in range(len(s)):\\n                if i % 2 == 0:\\n                    arr.append(\"0\")\\n                else:\\n                    arr.append(\"1\")\\n                    \\n            count = 0\\n            for i in range(len(s)):\\n                if s[i] != arr[i]:\\n                    count += 1\\n            return count // 2\\n            \\n        \\n        if zero - one == 1:\\n            #It starts with zero and end with zero\\n            print(\"zero\")\\n            return starts_with_zero(s)\\n        elif one - zero == 1:\\n            #it starts with one and ends with one\\n            return starts_with_one(s)\\n        elif zero == one:\\n            #either starts with one or zero\\n            return min(starts_with_one(s),starts_with_zero(s))\\n        else:\\n            #not possible\\n            return -1\\n",
                "codeTag": "Java"
            },
            {
                "id": 2770020,
                "title": "easy-to-understand-c-sol",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        int n=s.size();\\n        int cnto=0,cntz=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'1\\')cnto++;\\n            if(s[i]==\\'0\\')cntz++;\\n        }\\n        if(cnto>cntz){\\n            if((cnto-cntz)!=1)return -1;\\n            int h=0;\\n            int cnt=0;\\n            for(int i=0;i<n;i++){\\n                if(h==0){\\n                    if(s[i]==\\'0\\')cnt++;\\n                    h=1;\\n                    \\n                }\\n                else if(h==1){\\n                    if(s[i]==\\'1\\')cnt++;\\n                    h=0;\\n                }\\n            }\\n            return cnt/2;\\n        }\\n        if(cnto<cntz){\\n            if((cntz-cnto)!=1)return -1;\\n            int h=0;\\n            int cnt=0;\\n            for(int i=0;i<n;i++){\\n                if(h==0){\\n                    if(s[i]==\\'1\\')cnt++;\\n                    h=1;\\n                }\\n                else if(h==1){\\n                    if(s[i]==\\'0\\')cnt++;\\n                    h=0;\\n                }\\n            }\\n            return cnt/2;\\n        }\\n        if(cntz==cnto){\\n            int h=0;\\n            int cnt=0;\\n            int ans=INT_MAX;\\n            for(int i=0;i<n;i++){\\n                if(h==0){\\n                    if(s[i]==\\'1\\')cnt++;\\n                    h=1;\\n                }\\n                else if(h==1){\\n                    if(s[i]==\\'0\\')cnt++;\\n                    h=0;\\n                }\\n            }\\n            ans=min(ans,cnt/2);\\n            h=0;\\n            cnt=0;\\n            for(int i=0;i<n;i++){\\n                if(h==0){\\n                    if(s[i]==\\'0\\')cnt++;\\n                    h=1;\\n                }\\n                else if(h==1){\\n                    if(s[i]==\\'1\\')cnt++;\\n                    h=0;\\n                }\\n            }\\n            ans=min(ans,cnt/2);\\n            return ans;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        int n=s.size();\\n        int cnto=0,cntz=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'1\\')cnto++;\\n            if(s[i]==\\'0\\')cntz++;\\n        }\\n        if(cnto>cntz){\\n            if((cnto-cntz)!=1)return -1;\\n            int h=0;\\n            int cnt=0;\\n            for(int i=0;i<n;i++){\\n                if(h==0){\\n                    if(s[i]==\\'0\\')cnt++;\\n                    h=1;\\n                    \\n                }\\n                else if(h==1){\\n                    if(s[i]==\\'1\\')cnt++;\\n                    h=0;\\n                }\\n            }\\n            return cnt/2;\\n        }\\n        if(cnto<cntz){\\n            if((cntz-cnto)!=1)return -1;\\n            int h=0;\\n            int cnt=0;\\n            for(int i=0;i<n;i++){\\n                if(h==0){\\n                    if(s[i]==\\'1\\')cnt++;\\n                    h=1;\\n                }\\n                else if(h==1){\\n                    if(s[i]==\\'0\\')cnt++;\\n                    h=0;\\n                }\\n            }\\n            return cnt/2;\\n        }\\n        if(cntz==cnto){\\n            int h=0;\\n            int cnt=0;\\n            int ans=INT_MAX;\\n            for(int i=0;i<n;i++){\\n                if(h==0){\\n                    if(s[i]==\\'1\\')cnt++;\\n                    h=1;\\n                }\\n                else if(h==1){\\n                    if(s[i]==\\'0\\')cnt++;\\n                    h=0;\\n                }\\n            }\\n            ans=min(ans,cnt/2);\\n            h=0;\\n            cnt=0;\\n            for(int i=0;i<n;i++){\\n                if(h==0){\\n                    if(s[i]==\\'0\\')cnt++;\\n                    h=1;\\n                }\\n                else if(h==1){\\n                    if(s[i]==\\'1\\')cnt++;\\n                    h=0;\\n                }\\n            }\\n            ans=min(ans,cnt/2);\\n            return ans;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2766018,
                "title": "c-super-short-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        int zero = count(begin(s), end(s), \\'0\\'), one = s.size()-zero, cnt1 = 0, cnt2 = 0;\\n        if(abs(zero-one) > 1) return -1;\\n        for(int i = 0; i < s.size(); i += 2) {\\n            cnt1 += s[i] != \\'0\\';\\n            cnt2 += s[i] != \\'1\\';\\n        }\\n        return zero > one ? cnt1 : zero < one ? cnt2 : min(cnt1, cnt2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        int zero = count(begin(s), end(s), \\'0\\'), one = s.size()-zero, cnt1 = 0, cnt2 = 0;\\n        if(abs(zero-one) > 1) return -1;\\n        for(int i = 0; i < s.size(); i += 2) {\\n            cnt1 += s[i] != \\'0\\';\\n            cnt2 += s[i] != \\'1\\';\\n        }\\n        return zero > one ? cnt1 : zero < one ? cnt2 : min(cnt1, cnt2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2764336,
                "title": "hamming-distance-brute-force-to-optimal-c",
                "content": "# Brute Force\\n```\\nclass Solution {\\n    string helper1(int ones, int zeroes) {\\n        string alt;\\n        while(ones > 0 || zeroes > 0) {\\n            if(ones-- > 0) alt += \\'1\\';\\n            if(zeroes-- > 0) alt += \\'0\\';\\n        }\\n        return alt;\\n    }\\n    string helper2(int ones, int zeroes) {\\n        string alt;\\n        while(ones > 0 || zeroes > 0) {\\n            if(zeroes-- > 0) alt += \\'0\\';\\n            if(ones-- > 0) alt += \\'1\\';\\n        }\\n        return alt;\\n    }\\n    int hamDis(string s, string alt) {\\n        int d = 0;\\n        for(int i=0; i<s.size(); i++) if(s[i] != alt[i]) d++;\\n        return d / 2;\\n    }\\n\\npublic:\\n    int minSwaps(string s) {\\n        int ones = 0, zeroes = 0, d = 0;\\n        for(char c : s) c == \\'1\\' ? ones++ : zeroes++;\\n        \\n        if(abs(zeroes - ones) > 1) return -1;\\n        \\n        if(ones > zeroes) return hamDis(s, helper1(ones, zeroes));\\n        if(ones < zeroes) return hamDis(s, helper2(ones, zeroes));\\n\\n       return min(hamDis(s, helper1(ones, zeroes)), hamDis(s, helper2(ones, zeroes)));\\n    }\\n};\\n```\\n\\n# Optimal\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        int zeroes = 0, ones = 0, d1 = 0, d2 = 0;\\n        for(char c : s) c == \\'1\\' ? ones++ : zeroes++;\\n        if(abs(ones - zeroes) > 1) return -1;\\n        \\n        for(int i=0; i<s.size(); i += 2) d1 += s[i] != \\'1\\', d2 += s[i] != \\'0\\';\\n        return ones > zeroes ? d1 : ones < zeroes ? d2 : min(d1, d2);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    string helper1(int ones, int zeroes) {\\n        string alt;\\n        while(ones > 0 || zeroes > 0) {\\n            if(ones-- > 0) alt += \\'1\\';\\n            if(zeroes-- > 0) alt += \\'0\\';\\n        }\\n        return alt;\\n    }\\n    string helper2(int ones, int zeroes) {\\n        string alt;\\n        while(ones > 0 || zeroes > 0) {\\n            if(zeroes-- > 0) alt += \\'0\\';\\n            if(ones-- > 0) alt += \\'1\\';\\n        }\\n        return alt;\\n    }\\n    int hamDis(string s, string alt) {\\n        int d = 0;\\n        for(int i=0; i<s.size(); i++) if(s[i] != alt[i]) d++;\\n        return d / 2;\\n    }\\n\\npublic:\\n    int minSwaps(string s) {\\n        int ones = 0, zeroes = 0, d = 0;\\n        for(char c : s) c == \\'1\\' ? ones++ : zeroes++;\\n        \\n        if(abs(zeroes - ones) > 1) return -1;\\n        \\n        if(ones > zeroes) return hamDis(s, helper1(ones, zeroes));\\n        if(ones < zeroes) return hamDis(s, helper2(ones, zeroes));\\n\\n       return min(hamDis(s, helper1(ones, zeroes)), hamDis(s, helper2(ones, zeroes)));\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        int zeroes = 0, ones = 0, d1 = 0, d2 = 0;\\n        for(char c : s) c == \\'1\\' ? ones++ : zeroes++;\\n        if(abs(ones - zeroes) > 1) return -1;\\n        \\n        for(int i=0; i<s.size(); i += 2) d1 += s[i] != \\'1\\', d2 += s[i] != \\'0\\';\\n        return ones > zeroes ? d1 : ones < zeroes ? d2 : min(d1, d2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2761162,
                "title": "java-o-n-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor an element at particular index, if it doesn\\'t match target element store it for future swap operation\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe know the resulting string will either start with 0 or with 1. let this be \\'target\\' string\\n\\n we perform the following for both cases of targets:\\n            we iterate over input string and compare the current element with target element at corresponding index\\n            if both match then fine\\n            if not, the current element of s is available for swap ifneeded in future\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSwaps(String s) {\\n\\n        int n = s.length();\\n        int swaps = Integer.MAX_VALUE;\\n\\n        swaps = Math.min(findMinSwaps(\\'0\\',s), findMinSwaps(\\'1\\',s));\\n\\n        return (swaps == Integer.MAX_VALUE)?-1:swaps;\\n    }\\n\\n    int findMinSwaps(char curr, String s){\\n        int[] availableBits = new int[2];\\n        int swaps = 0;\\n        int i=0;\\n        while(i<s.length()){\\n        \\n            if(s.charAt(i) != curr){\\n                if(curr == \\'1\\'){\\n                    if(availableBits[1]>0){\\n                        swaps++;\\n                        availableBits[1]--;\\n                    }else availableBits[0]++;\\n                }else{\\n                    if(availableBits[0]>0){\\n                        swaps++;\\n                        availableBits[0]--;\\n                    }else availableBits[1]++;\\n                }\\n            }\\n\\n            i++;\\n            curr = (curr==\\'0\\')?\\'1\\':\\'0\\';\\n        }\\n\\n        if(availableBits[0] != 0 || availableBits[1] != 0) return Integer.MAX_VALUE;\\n        return swaps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSwaps(String s) {\\n\\n        int n = s.length();\\n        int swaps = Integer.MAX_VALUE;\\n\\n        swaps = Math.min(findMinSwaps(\\'0\\',s), findMinSwaps(\\'1\\',s));\\n\\n        return (swaps == Integer.MAX_VALUE)?-1:swaps;\\n    }\\n\\n    int findMinSwaps(char curr, String s){\\n        int[] availableBits = new int[2];\\n        int swaps = 0;\\n        int i=0;\\n        while(i<s.length()){\\n        \\n            if(s.charAt(i) != curr){\\n                if(curr == \\'1\\'){\\n                    if(availableBits[1]>0){\\n                        swaps++;\\n                        availableBits[1]--;\\n                    }else availableBits[0]++;\\n                }else{\\n                    if(availableBits[0]>0){\\n                        swaps++;\\n                        availableBits[0]--;\\n                    }else availableBits[1]++;\\n                }\\n            }\\n\\n            i++;\\n            curr = (curr==\\'0\\')?\\'1\\':\\'0\\';\\n        }\\n\\n        if(availableBits[0] != 0 || availableBits[1] != 0) return Integer.MAX_VALUE;\\n        return swaps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2752474,
                "title": "c-easy-solution-simple-logic",
                "content": "No need to count zero \\nCount ones at even and odd  position need to swap according to these\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        int cnt_e=0,cnt_o=0;\\n        int n=s.length();\\n        for(int i=0;i<n;i++){\\n            if(i%2){\\n                cnt_o+=(s[i]-\\'0\\');\\n            }\\n            else{\\n                cnt_e+=(s[i]-\\'0\\');\\n            }\\n        }\\n        if(n%2==0){\\n            if((cnt_e+cnt_o)==n/2)\\n            return min(cnt_e,cnt_o);\\n        }\\n        else{\\n            if((cnt_e+cnt_o)==(n+1)/2){\\n                return cnt_o;\\n            }\\n            else if((cnt_e+cnt_o)==n/2)\\n                return cnt_e;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        int cnt_e=0,cnt_o=0;\\n        int n=s.length();\\n        for(int i=0;i<n;i++){\\n            if(i%2){\\n                cnt_o+=(s[i]-\\'0\\');\\n            }\\n            else{\\n                cnt_e+=(s[i]-\\'0\\');\\n            }\\n        }\\n        if(n%2==0){\\n            if((cnt_e+cnt_o)==n/2)\\n            return min(cnt_e,cnt_o);\\n        }\\n        else{\\n            if((cnt_e+cnt_o)==(n+1)/2){\\n                return cnt_o;\\n            }\\n            else if((cnt_e+cnt_o)==n/2)\\n                return cnt_e;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2749444,
                "title": "java-easy-understanding-java-solution",
                "content": "```\\nclass Solution {\\n    public int minSwaps(String s) {\\n        int ones = 0, zeros = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'0\\') zeros++;\\n            else ones++;\\n        }\\n        if (Math.abs(ones - zeros) > 1) return -1;\\n        \\n        if (zeros == ones) return Math.min(helper(s, \\'0\\'), helper(s, \\'1\\'));\\n        else if (zeros > ones) return helper(s, \\'0\\');   //must start with 0\\n        else return helper(s, \\'1\\');                     //must start with 1\\n    }\\n    private int helper(String s, char start) {\\n        int res = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            //count the misplaced start and alternating even positions\\n            //there must be a 0/1 to swap with\\n            if (i % 2 == 0 && s.charAt(i) != start) res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSwaps(String s) {\\n        int ones = 0, zeros = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'0\\') zeros++;\\n            else ones++;\\n        }\\n        if (Math.abs(ones - zeros) > 1) return -1;\\n        \\n        if (zeros == ones) return Math.min(helper(s, \\'0\\'), helper(s, \\'1\\'));\\n        else if (zeros > ones) return helper(s, \\'0\\');   //must start with 0\\n        else return helper(s, \\'1\\');                     //must start with 1\\n    }\\n    private int helper(String s, char start) {\\n        int res = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            //count the misplaced start and alternating even positions\\n            //there must be a 0/1 to swap with\\n            if (i % 2 == 0 && s.charAt(i) != start) res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2727947,
                "title": "python3-short-easy-to-understand",
                "content": "\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        zo1 = {\"0\": 0, \"1\": 0}  # Pattern 1: 01010...\\n        zo2 = {\"0\": 0, \"1\": 0}  # Pattern 2: 10101...\\n\\n        case1, case2 = \"0\", \"1\"\\n        for i in s:\\n            # Pattern 1 mismatch\\n            if i != case1: zo1[i] += 1\\n            # Pattern 2 mismatch\\n            if i != case2: zo2[i] += 1\\n            case1, case2 = case2, case1\\n        \\n        \\n        # Case 1) Neither Pattern Possible\\n        if zo1[\"1\"] != zo1[\"0\"] and zo2[\"1\"] != zo2[\"0\"]:\\n            return -1\\n\\n        # Case 2) Both Patterns are possible\\n        if zo1[\"1\"] == zo1[\"0\"] and zo2[\"1\"] == zo2[\"0\"]:\\n            return min(zo1[\"1\"], zo2[\"1\"])\\n        \\n        # Case 3) 1 valid Pattern / 1 invalid Pattern\\n        return zo1[\"1\"] if zo1[\"1\"] == zo1[\"0\"] else zo2[\"1\"]\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        zo1 = {\"0\": 0, \"1\": 0}  # Pattern 1: 01010...\\n        zo2 = {\"0\": 0, \"1\": 0}  # Pattern 2: 10101...\\n\\n        case1, case2 = \"0\", \"1\"\\n        for i in s:\\n            # Pattern 1 mismatch\\n            if i != case1: zo1[i] += 1\\n            # Pattern 2 mismatch\\n            if i != case2: zo2[i] += 1\\n            case1, case2 = case2, case1\\n        \\n        \\n        # Case 1) Neither Pattern Possible\\n        if zo1[\"1\"] != zo1[\"0\"] and zo2[\"1\"] != zo2[\"0\"]:\\n            return -1\\n\\n        # Case 2) Both Patterns are possible\\n        if zo1[\"1\"] == zo1[\"0\"] and zo2[\"1\"] == zo2[\"0\"]:\\n            return min(zo1[\"1\"], zo2[\"1\"])\\n        \\n        # Case 3) 1 valid Pattern / 1 invalid Pattern\\n        return zo1[\"1\"] if zo1[\"1\"] == zo1[\"0\"] else zo2[\"1\"]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2719581,
                "title": "python3-greedy",
                "content": "```\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        count = Counter(s)\\n        if abs(count[\\'1\\'] - count[\\'0\\']) > 1:\\n            return -1\\n        if len(s) & 1:\\n            res1 = \\'1\\'\\n            res2 = \\'0\\'\\n        else:\\n            res1 = \\'\\'\\n            res2 = \\'\\'\\n                     \\n        res1 += \\'01\\' * (len(s)//2) \\n        res2 += \\'10\\' * (len(s)//2)\\n        \\n        def compare(s1, s2):\\n            count = 0\\n            for a,b in zip(s1,s2):\\n                if a != b:\\n                    count += 1\\n            if count & 1:\\n                return float(\\'inf\\')\\n            return count//2\\n        \\n        \\n        ans =  min(compare(s, res1), compare(s, res2))\\n        if ans != float(\\'inf\\'):\\n            return ans\\n        return -1 \\n       \\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        count = Counter(s)\\n        if abs(count[\\'1\\'] - count[\\'0\\']) > 1:\\n            return -1\\n        if len(s) & 1:\\n            res1 = \\'1\\'\\n            res2 = \\'0\\'\\n        else:\\n            res1 = \\'\\'\\n            res2 = \\'\\'\\n                     \\n        res1 += \\'01\\' * (len(s)//2) \\n        res2 += \\'10\\' * (len(s)//2)\\n        \\n        def compare(s1, s2):\\n            count = 0\\n            for a,b in zip(s1,s2):\\n                if a != b:\\n                    count += 1\\n            if count & 1:\\n                return float(\\'inf\\')\\n            return count//2\\n        \\n        \\n        ans =  min(compare(s, res1), compare(s, res2))\\n        if ans != float(\\'inf\\'):\\n            return ans\\n        return -1 \\n       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2706072,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        first_case = []\\n        second_case = []\\n\\n        n = len(s)\\n        flip = False\\n        count1 = 0\\n        count0 = 0\\n        for i in range(n):\\n            first_case.append(str(int(not flip)))\\n            second_case.append(str(int(flip)))\\n            flip = not flip\\n            \\n            if s[i] == \\'1\\':count1+=1\\n            if s[i] == \\'0\\':count0 += 1\\n        \\n        if count1+1  != count0 and count1  != count0+1 and count1 != count0: return -1\\n\\n        diff1 = 0\\n        diff2 = 0\\n        for i in range(n):\\n            if s[i] != first_case[i]:diff1 += 1\\n            if s[i] != second_case[i]:diff2 += 1\\n        \\n        if diff2 %2 != 0:\\n            return diff1//2\\n        \\n        if diff1 %2 != 0:\\n            return diff2//2\\n        \\n        return math.ceil(min(diff1,diff2)/2)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        first_case = []\\n        second_case = []\\n\\n        n = len(s)\\n        flip = False\\n        count1 = 0\\n        count0 = 0\\n        for i in range(n):\\n            first_case.append(str(int(not flip)))\\n            second_case.append(str(int(flip)))\\n            flip = not flip\\n            \\n            if s[i] == \\'1\\':count1+=1\\n            if s[i] == \\'0\\':count0 += 1\\n        \\n        if count1+1  != count0 and count1  != count0+1 and count1 != count0: return -1\\n\\n        diff1 = 0\\n        diff2 = 0\\n        for i in range(n):\\n            if s[i] != first_case[i]:diff1 += 1\\n            if s[i] != second_case[i]:diff2 += 1\\n        \\n        if diff2 %2 != 0:\\n            return diff1//2\\n        \\n        if diff1 %2 != 0:\\n            return diff2//2\\n        \\n        return math.ceil(min(diff1,diff2)/2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2699933,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    public int MinSwaps(string s) {\\n        int ones = 0, zeros = 0;\\n        foreach(char ch in s){\\n            if(ch == \\'0\\') zeros++;\\n            else ones++;\\n        }\\n\\n        if(Math.Abs(ones-zeros) > 1) return -1;\\n        else if(zeros > ones) return swaps(s, \\'0\\');\\n        else if(ones > zeros) return swaps(s, \\'1\\');\\n        else return Math.Min(swaps(s, \\'0\\'), swaps(s, \\'1\\'));\\n    }\\n\\n    private int swaps(string s, char ch){\\n        int swaps = 0;\\n        for(int i = 0; i < s.Length; i = i+2){\\n            if(s[i] != ch) swaps++;\\n        }\\n        return swaps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinSwaps(string s) {\\n        int ones = 0, zeros = 0;\\n        foreach(char ch in s){\\n            if(ch == \\'0\\') zeros++;\\n            else ones++;\\n        }\\n\\n        if(Math.Abs(ones-zeros) > 1) return -1;\\n        else if(zeros > ones) return swaps(s, \\'0\\');\\n        else if(ones > zeros) return swaps(s, \\'1\\');\\n        else return Math.Min(swaps(s, \\'0\\'), swaps(s, \\'1\\'));\\n    }\\n\\n    private int swaps(string s, char ch){\\n        int swaps = 0;\\n        for(int i = 0; i < s.Length; i = i+2){\\n            if(s[i] != ch) swaps++;\\n        }\\n        return swaps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2694816,
                "title": "python3-greedy",
                "content": "```\\nimport math\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        num_1 = s.count(\\'1\\')\\n        num_0 = len(s) - num_1\\n\\n        if abs(num_1 - num_0) > 1:\\n            return -1\\n\\n        even_1 = 0\\n        for i in range(0, len(s), 2):\\n            if s[i] == \\'1\\':\\n                even_1 += 1\\n        even_0 = math.ceil(len(s) / 2 - even_1)\\n\\n        if num_1 > num_0:\\n            return num_1 - even_1\\n        elif num_1 < num_0:\\n            return num_0 - even_0\\n        elif even_1 > even_0:\\n            return num_1 - even_1\\n        else:\\n            return num_0 - even_0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        num_1 = s.count(\\'1\\')\\n        num_0 = len(s) - num_1\\n\\n        if abs(num_1 - num_0) > 1:\\n            return -1\\n\\n        even_1 = 0\\n        for i in range(0, len(s), 2):\\n            if s[i] == \\'1\\':\\n                even_1 += 1\\n        even_0 = math.ceil(len(s) / 2 - even_1)\\n\\n        if num_1 > num_0:\\n            return num_1 - even_1\\n        elif num_1 < num_0:\\n            return num_0 - even_0\\n        elif even_1 > even_0:\\n            return num_1 - even_1\\n        else:\\n            return num_0 - even_0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693749,
                "title": "go-solution",
                "content": "```\\nfunc minSwaps(s string) int {\\n\\tvar count0s, count1s int\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tif s[i] == \\'1\\' {\\n\\t\\t\\tcount1s++\\n\\t\\t}\\n\\t}\\n\\tcount0s = len(s) - count1s\\n\\n\\tif abs(count1s-count0s) > 1 {\\n\\t\\treturn -1\\n\\t}\\n\\tvar miss0, miss1 int\\n\\tfor i := 0; i < len(s); i += 2 {\\n\\t\\tif s[i] == \\'1\\' {\\n\\t\\t\\tmiss0++\\n\\t\\t} else {\\n\\t\\t\\tmiss1++\\n\\t\\t}\\n\\t}\\n\\tif count0s == count1s {\\n\\t\\treturn min(miss0, miss1)\\n\\t}\\n\\tif count0s < count1s {\\n\\t\\treturn miss1\\n\\t}\\n\\treturn miss0\\n}\\n\\nfunc min(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn b\\n\\t}\\n\\treturn a\\n}\\nfunc abs(a int) int {\\n\\tif a < 0 {\\n\\t\\treturn -a\\n\\t}\\n\\treturn a\\n}\\n",
                "solutionTags": [],
                "code": "```\\nfunc minSwaps(s string) int {\\n\\tvar count0s, count1s int\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tif s[i] == \\'1\\' {\\n\\t\\t\\tcount1s++\\n\\t\\t}\\n\\t}\\n\\tcount0s = len(s) - count1s\\n\\n\\tif abs(count1s-count0s) > 1 {\\n\\t\\treturn -1\\n\\t}\\n\\tvar miss0, miss1 int\\n\\tfor i := 0; i < len(s); i += 2 {\\n\\t\\tif s[i] == \\'1\\' {\\n\\t\\t\\tmiss0++\\n\\t\\t} else {\\n\\t\\t\\tmiss1++\\n\\t\\t}\\n\\t}\\n\\tif count0s == count1s {\\n\\t\\treturn min(miss0, miss1)\\n\\t}\\n\\tif count0s < count1s {\\n\\t\\treturn miss1\\n\\t}\\n\\treturn miss0\\n}\\n\\nfunc min(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn b\\n\\t}\\n\\treturn a\\n}\\nfunc abs(a int) int {\\n\\tif a < 0 {\\n\\t\\treturn -a\\n\\t}\\n\\treturn a\\n}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2691687,
                "title": "o-1-space-o-n-time-count-zeros-ones-at-even-odd-indexes",
                "content": "# Intuition\\nThis problem is just about counting the zeros and ones at even and odd indexes. One we have that we just need to check the following conditions.\\n\\n# Approach\\n* If difference between count of ones and zeros is `> 1` then it\\'s impossible to make string alternative, so we return `-1`\\n* If number of zeros > ones, it mean zeros has to be at indexes 0, 2, 4.... So in case we need to count how many zeros are not even places, In other words, how many zeros are at odd places.\\n* If number of ones > zeros, Here we need to check the same things as step two.\\n* In the last if both counts are equals `ones == zeros`. Move either zero or one which is least displaced. which is min of all four values.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ \\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSwaps(String s) {\\n\\n        int[] onesAtPlaces = new int[2];    // 0: even, 1: odd\\n        int[] zerosAtPlaces = new int[2];    // 0: even, 1: odd\\n        \\n        for(int i=0; i<s.length(); i++) {\\n            if(s.charAt(i) == \\'1\\') {\\n                onesAtPlaces[i%2]++;\\n            }\\n            else {\\n                zerosAtPlaces[i%2]++;\\n            }\\n        }\\n\\n        int ones = onesAtPlaces[0] + onesAtPlaces[1];\\n        int zeros = zerosAtPlaces[0] + zerosAtPlaces[1];\\n\\n        // If diff > 1 then we cannot really make string alternative\\n        if(Math.abs(ones-zeros) > 1) {\\n            return -1;\\n        }\\n        else if(ones > zeros) {   // if ones > zeros, onces has to at even places 0, 2, 4...\\n            return onesAtPlaces[1];\\n        }\\n        else if(ones < zeros) {  // if zeros > ones, zeros has to at even places 0, 2, 4...\\n            return zerosAtPlaces[1];\\n        }\\n        else {\\n            // if boths ones and zeros as requal, see which one is least out of order\\n            return Math.min(\\n                        Math.min(zerosAtPlaces[0], zerosAtPlaces[1]), \\n                        Math.min(onesAtPlaces[0], onesAtPlaces[1])\\n                );\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSwaps(String s) {\\n\\n        int[] onesAtPlaces = new int[2];    // 0: even, 1: odd\\n        int[] zerosAtPlaces = new int[2];    // 0: even, 1: odd\\n        \\n        for(int i=0; i<s.length(); i++) {\\n            if(s.charAt(i) == \\'1\\') {\\n                onesAtPlaces[i%2]++;\\n            }\\n            else {\\n                zerosAtPlaces[i%2]++;\\n            }\\n        }\\n\\n        int ones = onesAtPlaces[0] + onesAtPlaces[1];\\n        int zeros = zerosAtPlaces[0] + zerosAtPlaces[1];\\n\\n        // If diff > 1 then we cannot really make string alternative\\n        if(Math.abs(ones-zeros) > 1) {\\n            return -1;\\n        }\\n        else if(ones > zeros) {   // if ones > zeros, onces has to at even places 0, 2, 4...\\n            return onesAtPlaces[1];\\n        }\\n        else if(ones < zeros) {  // if zeros > ones, zeros has to at even places 0, 2, 4...\\n            return zerosAtPlaces[1];\\n        }\\n        else {\\n            // if boths ones and zeros as requal, see which one is least out of order\\n            return Math.min(\\n                        Math.min(zerosAtPlaces[0], zerosAtPlaces[1]), \\n                        Math.min(onesAtPlaces[0], onesAtPlaces[1])\\n                );\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679629,
                "title": "simple-python-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        n0 = s.count(\\'0\\')\\n        n1 = s.count(\\'1\\')\\n        i0 = [i%2 for i,x in enumerate(s) if x == \\'0\\'] # index of 0\\'s mod 2\\n        i1 = [i%2 for i,x in enumerate(s) if x == \\'1\\'] # index of 1\\'s mod 2\\n        \\n        if abs(n0-n1) > 1: # if difference >= 2: impossible\\n            return -1\\n        \\n        if n0 == n1: # if equal, either one can appear first\\n            return min(sum(i0), sum(i1))\\n        if n0 > n1: # if \\'0\\' is majority: \\'0\\' should only appear in even positions ([0,2,...])\\n            return sum(i0) # number of odd positions in i0\\n        if n0 < n1:\\n            return sum(i1)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        n0 = s.count(\\'0\\')\\n        n1 = s.count(\\'1\\')\\n        i0 = [i%2 for i,x in enumerate(s) if x == \\'0\\'] # index of 0\\'s mod 2\\n        i1 = [i%2 for i,x in enumerate(s) if x == \\'1\\'] # index of 1\\'s mod 2\\n        \\n        if abs(n0-n1) > 1: # if difference >= 2: impossible\\n            return -1\\n        \\n        if n0 == n1: # if equal, either one can appear first\\n            return min(sum(i0), sum(i1))\\n        if n0 > n1: # if \\'0\\' is majority: \\'0\\' should only appear in even positions ([0,2,...])\\n            return sum(i0) # number of odd positions in i0\\n        if n0 < n1:\\n            return sum(i1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2657668,
                "title": "typescript-linear",
                "content": "Can optimize an extra redundant step in generating startWithOne, startWithTwo, not a game changer \\n```\\nfunction counter(s:string):[number, number] {\\n    let numOnes=0\\n    let numZeros=0\\n    \\n    for(const char of s){\\n        if(char===\"1\") numOnes+=1\\n        else numZeros+=1\\n    }\\n    \\n    return [numZeros, numOnes]\\n}\\n\\nfunction compare(s:string, t:string):number {\\n    let diff=0\\n    for(let i=0; i<s.length; i++){\\n        if(s[i]!==t[i]) diff+=1\\n    }\\n    \\n    return diff\\n}\\n\\nfunction minSwaps(s: string): number {\\n\\n    const [numZeros, numOnes] = counter(s)\\n    let idealString = new Array(s.length)\\n    \\n    if(s.length%2===0){\\n        //if even lengh string then equal num of zeros and ones should exists\\n        if(numZeros!==numOnes) return -1\\n        \\n        let startWithZero = new Array(s.length).fill(0).map((_,idx)=>idx%2===1 ? 1 : 0).join(\\'\\')\\n        let startWithOne = new Array(s.length).fill(1).map((_,idx)=>idx%2===1 ? 0 : 1).join(\\'\\')\\n        \\n        \\n        \\n        return Math.min(compare(s,startWithZero), compare(s, startWithOne))/2\\n        \\n    }\\n    else{\\n        //if odd, the diff in num of zeros and ones should be 1\\n        if(Math.abs(numZeros-numOnes)!==1) return -1\\n        \\n        if(numZeros>numOnes){\\n            let startWithZero = new Array(s.length).fill(0).map((_,idx)=>idx%2===1 ? 1 : 0).join(\\'\\')\\n            return compare(s, startWithZero)/2\\n        }\\n        else{\\n            let startWithOne = new Array(s.length).fill(1).map((_,idx)=>idx%2===1 ? 0 : 1).join(\\'\\')\\n            return compare(s, startWithOne)/2\\n        }\\n    }\\n    \\n    return -1\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nfunction counter(s:string):[number, number] {\\n    let numOnes=0\\n    let numZeros=0\\n    \\n    for(const char of s){\\n        if(char===\"1\") numOnes+=1\\n        else numZeros+=1\\n    }\\n    \\n    return [numZeros, numOnes]\\n}\\n\\nfunction compare(s:string, t:string):number {\\n    let diff=0\\n    for(let i=0; i<s.length; i++){\\n        if(s[i]!==t[i]) diff+=1\\n    }\\n    \\n    return diff\\n}\\n\\nfunction minSwaps(s: string): number {\\n\\n    const [numZeros, numOnes] = counter(s)\\n    let idealString = new Array(s.length)\\n    \\n    if(s.length%2===0){\\n        //if even lengh string then equal num of zeros and ones should exists\\n        if(numZeros!==numOnes) return -1\\n        \\n        let startWithZero = new Array(s.length).fill(0).map((_,idx)=>idx%2===1 ? 1 : 0).join(\\'\\')\\n        let startWithOne = new Array(s.length).fill(1).map((_,idx)=>idx%2===1 ? 0 : 1).join(\\'\\')\\n        \\n        \\n        \\n        return Math.min(compare(s,startWithZero), compare(s, startWithOne))/2\\n        \\n    }\\n    else{\\n        //if odd, the diff in num of zeros and ones should be 1\\n        if(Math.abs(numZeros-numOnes)!==1) return -1\\n        \\n        if(numZeros>numOnes){\\n            let startWithZero = new Array(s.length).fill(0).map((_,idx)=>idx%2===1 ? 1 : 0).join(\\'\\')\\n            return compare(s, startWithZero)/2\\n        }\\n        else{\\n            let startWithOne = new Array(s.length).fill(1).map((_,idx)=>idx%2===1 ? 0 : 1).join(\\'\\')\\n            return compare(s, startWithOne)/2\\n        }\\n    }\\n    \\n    return -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2648371,
                "title": "simple-python-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        def swaps(cur):\\n            mismatch = 0\\n            for c in s:\\n                if c != cur:\\n                    mismatch += 1\\n                cur = \"1\" if cur == \"0\" else \"0\"\\n            return mismatch // 2\\n        \\n        zeros, ones = 0, 0\\n        for c in s:\\n            if c == \"0\":\\n                zeros += 1\\n            else:\\n                ones += 1\\n        \\n        if abs(zeros - ones) > 1:\\n            return -1\\n        \\n        if zeros > ones:\\n            return swaps(\"0\")\\n        elif zeros < ones:\\n            return swaps(\"1\")\\n        else:\\n            return min(swaps(\"0\"), swaps(\"1\"))\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        def swaps(cur):\\n            mismatch = 0\\n            for c in s:\\n                if c != cur:\\n                    mismatch += 1\\n                cur = \"1\" if cur == \"0\" else \"0\"\\n            return mismatch // 2\\n        \\n        zeros, ones = 0, 0\\n        for c in s:\\n            if c == \"0\":\\n                zeros += 1\\n            else:\\n                ones += 1\\n        \\n        if abs(zeros - ones) > 1:\\n            return -1\\n        \\n        if zeros > ones:\\n            return swaps(\"0\")\\n        elif zeros < ones:\\n            return swaps(\"1\")\\n        else:\\n            return min(swaps(\"0\"), swaps(\"1\"))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648271,
                "title": "easy-understanding-solution",
                "content": "# Intuition\\nSince we have only two digits, there can be two ways an alternating string of 0 and 1 can be formed . \\n1 - Starting with 1 (and subsequent even indexes will have value 1)\\n2 - Starting with 0 (and subsequent even indexes will have value 0)\\n\\nThese two type of strings patterns need to be handled seperatly for odd size string and even size string . \\n# Approach\\n1 - Count number of zeros(no0) and number of ones (no1)\\n2 - Difference between number of zeros and number of ones should not be greater than one. If it is , then alternating string is not possible , regardless of size of string\\n3 - If no0 is equal to no1 , check for both cases. \\n        - String starting with 1\\n        - String starting with 0\\n    One with minimum placement errors will be the answer\\n4 - If no0 is equal to no1 , then maximum count number will be the starting char . Check for number of placement errors for the starting character and return the answer.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ \\n<!-- Add your time complexity here, e.g. -->\\n\\n- Space complexity: $$O(1)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        int no0 = 0;\\n        int no1 = 0;\\n        for(int i = 0 ; i <s.size(); i++) {\\n            if(s[i] == \\'1\\')\\n                no1++;\\n            else \\n                no0++;\\n        }\\n\\n        if(abs(no0 - no1) > 1)\\n            return -1;\\n\\n        if(no0 == no1) {\\n            int min_swap = INT_MAX;\\n            int cur_min_swap_0 = 0;\\n            int cur_min_swap_1 = 0;\\n            for(int i = 0 ; i < s.size(); i++) {\\n                if(i % 2 == 0 && s[i] != \\'1\\')\\n                    cur_min_swap_1++;\\n\\n                if(i % 2 == 0 && s[i] != \\'0\\')\\n                    cur_min_swap_0++;\\n            }\\n\\n            min_swap = min(min_swap, cur_min_swap_0);\\n            min_swap = min(min_swap, cur_min_swap_1);\\n            return min_swap;\\n        } else {\\n            bool startWithOne = no1 > no0;\\n            int min_swap = INT_MAX;\\n            int cur_min_swap = 0;\\n            for(int i = 0 ;i < s.size(); i++) {\\n                if(i%2 == 0) {\\n                    if(startWithOne) {\\n                        if(s[i] != \\'1\\')\\n                            cur_min_swap++;\\n                    } else {\\n                        if(s[i] != \\'0\\')\\n                            cur_min_swap++;\\n                    }\\n                }\\n            }\\n\\n            min_swap = min(min_swap, cur_min_swap);\\n            return min_swap;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        int no0 = 0;\\n        int no1 = 0;\\n        for(int i = 0 ; i <s.size(); i++) {\\n            if(s[i] == \\'1\\')\\n                no1++;\\n            else \\n                no0++;\\n        }\\n\\n        if(abs(no0 - no1) > 1)\\n            return -1;\\n\\n        if(no0 == no1) {\\n            int min_swap = INT_MAX;\\n            int cur_min_swap_0 = 0;\\n            int cur_min_swap_1 = 0;\\n            for(int i = 0 ; i < s.size(); i++) {\\n                if(i % 2 == 0 && s[i] != \\'1\\')\\n                    cur_min_swap_1++;\\n\\n                if(i % 2 == 0 && s[i] != \\'0\\')\\n                    cur_min_swap_0++;\\n            }\\n\\n            min_swap = min(min_swap, cur_min_swap_0);\\n            min_swap = min(min_swap, cur_min_swap_1);\\n            return min_swap;\\n        } else {\\n            bool startWithOne = no1 > no0;\\n            int min_swap = INT_MAX;\\n            int cur_min_swap = 0;\\n            for(int i = 0 ;i < s.size(); i++) {\\n                if(i%2 == 0) {\\n                    if(startWithOne) {\\n                        if(s[i] != \\'1\\')\\n                            cur_min_swap++;\\n                    } else {\\n                        if(s[i] != \\'0\\')\\n                            cur_min_swap++;\\n                    }\\n                }\\n            }\\n\\n            min_swap = min(min_swap, cur_min_swap);\\n            return min_swap;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646483,
                "title": "2-ways",
                "content": "```\\nclass Solution {\\n    public int minSwaps(String S) {\\n        char[] s = S.toCharArray();\\n        int ones=0,zeros=0;\\n        for (char c : s) {\\n            if (c == \\'1\\') ones++;\\n            else zeros++;\\n        }\\n        int a = zeroOneString(s,ones,zeros);\\n        int b = oneZeroString(s,ones,zeros);\\n        if(a==-1) return b;\\n        if(b == -1) return a;\\n        return Math.min(a,b);\\n    }\\n    private int zeroOneString(char[] s,int ones, int zeros){\\n        int n = s.length;\\n        char[] alt = new char[n];\\n        for(int i=0;i<n-n%2;i+=2){\\n            alt[i] = \\'0\\';\\n            alt[i+1] = \\'1\\';\\n            ones--;\\n            zeros--;\\n        }\\n        if(n%2==1) {\\n            alt[n-1] = \\'0\\';\\n            zeros--;\\n        }\\n        \\n        if(zeros!=0 || ones!=0) return -1;\\n        int changes = 0;\\n        for(int i=0;i<n;i++) if(alt[i]!=s[i]) changes++;\\n        return changes/2;\\n    }\\n    private int oneZeroString(char[] s,int ones, int zeros){\\n        int n = s.length;\\n        char[] alt = new char[n];\\n        for(int i=0;i<n-n%2;i+=2){\\n            alt[i+1] = \\'0\\';\\n            alt[i] = \\'1\\';\\n            ones--;\\n            zeros--;\\n        }\\n        if(n%2==1) {\\n            alt[n-1] = \\'1\\';\\n            ones--;\\n        }\\n        if(zeros!=0 || ones!=0) return -1;\\n        int changes = 0;\\n        for(int i=0;i<n;i++) if(alt[i]!=s[i]) changes++;\\n        return changes/2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSwaps(String S) {\\n        char[] s = S.toCharArray();\\n        int ones=0,zeros=0;\\n        for (char c : s) {\\n            if (c == \\'1\\') ones++;\\n            else zeros++;\\n        }\\n        int a = zeroOneString(s,ones,zeros);\\n        int b = oneZeroString(s,ones,zeros);\\n        if(a==-1) return b;\\n        if(b == -1) return a;\\n        return Math.min(a,b);\\n    }\\n    private int zeroOneString(char[] s,int ones, int zeros){\\n        int n = s.length;\\n        char[] alt = new char[n];\\n        for(int i=0;i<n-n%2;i+=2){\\n            alt[i] = \\'0\\';\\n            alt[i+1] = \\'1\\';\\n            ones--;\\n            zeros--;\\n        }\\n        if(n%2==1) {\\n            alt[n-1] = \\'0\\';\\n            zeros--;\\n        }\\n        \\n        if(zeros!=0 || ones!=0) return -1;\\n        int changes = 0;\\n        for(int i=0;i<n;i++) if(alt[i]!=s[i]) changes++;\\n        return changes/2;\\n    }\\n    private int oneZeroString(char[] s,int ones, int zeros){\\n        int n = s.length;\\n        char[] alt = new char[n];\\n        for(int i=0;i<n-n%2;i+=2){\\n            alt[i+1] = \\'0\\';\\n            alt[i] = \\'1\\';\\n            ones--;\\n            zeros--;\\n        }\\n        if(n%2==1) {\\n            alt[n-1] = \\'1\\';\\n            ones--;\\n        }\\n        if(zeros!=0 || ones!=0) return -1;\\n        int changes = 0;\\n        for(int i=0;i<n;i++) if(alt[i]!=s[i]) changes++;\\n        return changes/2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2640529,
                "title": "java-solution-easy-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSwaps(String s) {\\n        int n = s.length();\\n        int count0 = 0, count1 = 0;\\n        for(int i=0;i<n;i++) {\\n            if(s.charAt(i)==\\'1\\')\\n                count1++;\\n            else\\n                count0++;\\n        }\\n        if(Math.abs(count0-count1)>1)\\n            return -1;\\n            //case 1: 101010....\\n            int operatetion1 = 0;\\n            char flag = \\'1\\';\\n            for(int i=0;i<n;i++) {\\n                if(s.charAt(i)!=flag)\\n                    operatetion1++;\\n                flag = flag== \\'1\\'?\\'0\\':\\'1\\';\\n            }\\n            //case 2: 010101....\\n            int operatetion2 = 0;\\n            flag = \\'0\\';\\n            for(int i=0;i<n;i++) {\\n                if(s.charAt(i)!=flag)\\n                    operatetion2++;\\n                flag = flag== \\'1\\'?\\'0\\':\\'1\\'; \\n            }\\n        int res = Integer.MAX_VALUE;\\n        if(operatetion1%2==0)\\n            res = Math.min(res, operatetion1/2);\\n        if(operatetion2%2==0)\\n            res = Math.min(res, operatetion2/2);\\n        return res==Integer.MAX_VALUE?-1:res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSwaps(String s) {\\n        int n = s.length();\\n        int count0 = 0, count1 = 0;\\n        for(int i=0;i<n;i++) {\\n            if(s.charAt(i)==\\'1\\')\\n                count1++;\\n            else\\n                count0++;\\n        }\\n        if(Math.abs(count0-count1)>1)\\n            return -1;\\n            //case 1: 101010....\\n            int operatetion1 = 0;\\n            char flag = \\'1\\';\\n            for(int i=0;i<n;i++) {\\n                if(s.charAt(i)!=flag)\\n                    operatetion1++;\\n                flag = flag== \\'1\\'?\\'0\\':\\'1\\';\\n            }\\n            //case 2: 010101....\\n            int operatetion2 = 0;\\n            flag = \\'0\\';\\n            for(int i=0;i<n;i++) {\\n                if(s.charAt(i)!=flag)\\n                    operatetion2++;\\n                flag = flag== \\'1\\'?\\'0\\':\\'1\\'; \\n            }\\n        int res = Integer.MAX_VALUE;\\n        if(operatetion1%2==0)\\n            res = Math.min(res, operatetion1/2);\\n        if(operatetion2%2==0)\\n            res = Math.min(res, operatetion2/2);\\n        return res==Integer.MAX_VALUE?-1:res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2637719,
                "title": "intutive-java-solution-beats-100",
                "content": "```\\npublic int minSwaps(String s) {\\n\\t\\tint ones = 0;\\n\\t\\tint zeros = 0;\\n\\t\\tfor (char c : s.toCharArray()) {\\n\\t\\t\\tif (c == \\'0\\') {\\n\\t\\t\\t\\tzeros++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tones++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (Math.abs(ones - zeros) > 1) {\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\n\\t\\tint swaps = 0;\\n\\t\\tif (ones > zeros) {\\n\\t\\t\\tfor (int i = 0; i < s.length(); i += 2) {\\n\\t\\t\\t\\tif (s.charAt(i) != \\'1\\') {\\n\\t\\t\\t\\t\\tswaps++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else if (zeros > ones) {\\n\\t\\t\\tfor (int i = 0; i < s.length(); i += 2) {\\n\\t\\t\\t\\tif (s.charAt(i) != \\'0\\') {\\n\\t\\t\\t\\t\\tswaps++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\n\\t\\t\\tint swapsWithZero = 0;\\n\\t\\t\\tint swapsWithOne = 0;\\n\\n\\t\\t\\tfor (int i = 0; i < s.length(); i += 2) {\\n\\t\\t\\t\\tif (s.charAt(i) != \\'1\\') {\\n\\t\\t\\t\\t\\tswapsWithZero++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfor (int i = 0; i < s.length(); i += 2) {\\n\\t\\t\\t\\tif (s.charAt(i) != \\'0\\') {\\n\\t\\t\\t\\t\\tswapsWithOne++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tswaps = Math.min(swapsWithZero, swapsWithOne);\\n\\t\\t}\\n\\t\\treturn swaps;\\n\\t}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\npublic int minSwaps(String s) {\\n\\t\\tint ones = 0;\\n\\t\\tint zeros = 0;\\n\\t\\tfor (char c : s.toCharArray()) {\\n\\t\\t\\tif (c == \\'0\\') {\\n\\t\\t\\t\\tzeros++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tones++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (Math.abs(ones - zeros) > 1) {\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\n\\t\\tint swaps = 0;\\n\\t\\tif (ones > zeros) {\\n\\t\\t\\tfor (int i = 0; i < s.length(); i += 2) {\\n\\t\\t\\t\\tif (s.charAt(i) != \\'1\\') {\\n\\t\\t\\t\\t\\tswaps++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else if (zeros > ones) {\\n\\t\\t\\tfor (int i = 0; i < s.length(); i += 2) {\\n\\t\\t\\t\\tif (s.charAt(i) != \\'0\\') {\\n\\t\\t\\t\\t\\tswaps++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\n\\t\\t\\tint swapsWithZero = 0;\\n\\t\\t\\tint swapsWithOne = 0;\\n\\n\\t\\t\\tfor (int i = 0; i < s.length(); i += 2) {\\n\\t\\t\\t\\tif (s.charAt(i) != \\'1\\') {\\n\\t\\t\\t\\t\\tswapsWithZero++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfor (int i = 0; i < s.length(); i += 2) {\\n\\t\\t\\t\\tif (s.charAt(i) != \\'0\\') {\\n\\t\\t\\t\\t\\tswapsWithOne++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tswaps = Math.min(swapsWithZero, swapsWithOne);\\n\\t\\t}\\n\\t\\treturn swaps;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2637512,
                "title": "python-solution-half-of-incorrect-position",
                "content": "```\\ndef minSwaps(self, s: str) -> int:\\n\\tone, zero = s.count(\\'1\\'), s.count(\\'0\\')\\n\\tif abs(one-zero) > 1:\\n\\t\\treturn -1\\n\\tx = [\\'10\\'*one, \\'01\\'*one]\\n\\tif one>zero:\\n\\t\\tx = [\\'10\\'*zero+\\'1\\']\\n\\telif one<zero:\\n\\t\\tx = [\\'01\\'*one+\\'0\\']\\n\\tans = min(sum(1 for i in range(len(n)) if n[i]!=s[i])//2 for n in x)\\n\\treturn ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef minSwaps(self, s: str) -> int:\\n\\tone, zero = s.count(\\'1\\'), s.count(\\'0\\')\\n\\tif abs(one-zero) > 1:\\n\\t\\treturn -1\\n\\tx = [\\'10\\'*one, \\'01\\'*one]\\n\\tif one>zero:\\n\\t\\tx = [\\'10\\'*zero+\\'1\\']\\n\\telif one<zero:\\n\\t\\tx = [\\'01\\'*one+\\'0\\']\\n\\tans = min(sum(1 for i in range(len(n)) if n[i]!=s[i])//2 for n in x)\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2634326,
                "title": "python-simple-maths",
                "content": "\\n    def valid_string(self, s):\\n        n = len(s)\\n        \\n        str1, str2 = \"\", \"\"\\n        \\n        if n%2 == 0:\\n            str1 = \"10\"*(n//2)\\n            str2 = \"01\"*(n//2)\\n        else:\\n            if s.count(\"1\") > s.count(\"0\"):\\n                str1 = \"10\"*((n-1)//2) + \"1\"\\n            else:\\n                str2 = \"01\"*((n-1)//2) + \"0\"\\n                \\n        return [str1,str2]\\n            \\n    def minSwaps(self, s):\\n        if abs(s.count(\"1\") - s.count(\"0\")) > 1:\\n            return -1\\n        \\n        n, min_swap, count1, count2 = len(s), float(\"inf\"), 0, 0\\n        \\n        s1, s2 = self.valid_string(s)\\n        \\n        if n%2 == 0:\\n            for i in range(len(s1)):\\n                if s1[i] != s[i]:\\n                    count1 += 1\\n                \\n            for i in range(len(s2)):\\n                if s2[i] != s[i]:\\n                    count2 += 1\\n                \\n            min_swap = min(min_swap, count1, count2)\\n            \\n        else:\\n            if s.count(\"1\") > s.count(\"0\"):\\n                for i in range(len(s1)):\\n                    if s1[i] != s[i]:\\n                        count1 += 1\\n                        \\n                return count1//2\\n            \\n            else:\\n                for i in range(len(s2)):\\n                    if s2[i] != s[i]:\\n                        count2 += 1\\n                        \\n                return count2//2\\n                \\n        \\n        return min_swap//2",
                "solutionTags": [],
                "code": "\\n    def valid_string(self, s):\\n        n = len(s)\\n        \\n        str1, str2 = \"\", \"\"\\n        \\n        if n%2 == 0:\\n            str1 = \"10\"*(n//2)\\n            str2 = \"01\"*(n//2)\\n        else:\\n            if s.count(\"1\") > s.count(\"0\"):\\n                str1 = \"10\"*((n-1)//2) + \"1\"\\n            else:\\n                str2 = \"01\"*((n-1)//2) + \"0\"\\n                \\n        return [str1,str2]\\n            \\n    def minSwaps(self, s):\\n        if abs(s.count(\"1\") - s.count(\"0\")) > 1:\\n            return -1\\n        \\n        n, min_swap, count1, count2 = len(s), float(\"inf\"), 0, 0\\n        \\n        s1, s2 = self.valid_string(s)\\n        \\n        if n%2 == 0:\\n            for i in range(len(s1)):\\n                if s1[i] != s[i]:\\n                    count1 += 1\\n                \\n            for i in range(len(s2)):\\n                if s2[i] != s[i]:\\n                    count2 += 1\\n                \\n            min_swap = min(min_swap, count1, count2)\\n            \\n        else:\\n            if s.count(\"1\") > s.count(\"0\"):\\n                for i in range(len(s1)):\\n                    if s1[i] != s[i]:\\n                        count1 += 1\\n                        \\n                return count1//2\\n            \\n            else:\\n                for i in range(len(s2)):\\n                    if s2[i] != s[i]:\\n                        count2 += 1\\n                        \\n                return count2//2\\n                \\n        \\n        return min_swap//2",
                "codeTag": "Python3"
            },
            {
                "id": 2629547,
                "title": "python-linear-time-solution-31ms-faster-than-95",
                "content": "```\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        if abs(s.count(\\'0\\') - s.count(\\'1\\')) > 1:\\n            return -1\\n        onesAtEvenPositions, zerosAtOddPositions = 0, 0\\n        onesAtOddPositions, zerosAtEvenPositions = 0, 0\\n        for idx, char in enumerate(s):\\n            if idx % 2:\\n                if char == \\'1\\':\\n                    onesAtOddPositions += 1\\n                else:\\n                    zerosAtOddPositions += 1\\n            else:\\n                if char == \\'1\\':\\n                    onesAtEvenPositions += 1\\n                else:\\n                    zerosAtEvenPositions += 1\\n        minimum = math.inf\\n        if onesAtEvenPositions == zerosAtOddPositions:\\n           minimum = min(minimum, zerosAtOddPositions)\\n        if onesAtOddPositions == zerosAtEvenPositions:\\n           minimum = min(minimum, zerosAtEvenPositions)\\n        return minimum\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        if abs(s.count(\\'0\\') - s.count(\\'1\\')) > 1:\\n            return -1\\n        onesAtEvenPositions, zerosAtOddPositions = 0, 0\\n        onesAtOddPositions, zerosAtEvenPositions = 0, 0\\n        for idx, char in enumerate(s):\\n            if idx % 2:\\n                if char == \\'1\\':\\n                    onesAtOddPositions += 1\\n                else:\\n                    zerosAtOddPositions += 1\\n            else:\\n                if char == \\'1\\':\\n                    onesAtEvenPositions += 1\\n                else:\\n                    zerosAtEvenPositions += 1\\n        minimum = math.inf\\n        if onesAtEvenPositions == zerosAtOddPositions:\\n           minimum = min(minimum, zerosAtOddPositions)\\n        if onesAtOddPositions == zerosAtEvenPositions:\\n           minimum = min(minimum, zerosAtEvenPositions)\\n        return minimum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2628600,
                "title": "java-even-odd-count-100-faster",
                "content": "it can only be `1010101...` or `01010101...`\\nso we only need count Even and Odd position zero and ones.\\n\\n```\\nclass Solution {\\n        public int minSwaps(String s) {\\n            int evenOne = 0;\\n            int evenZero = 0;\\n            int oddOne = 0;\\n            int oddZero = 0;\\n            for (int i = 0; i < s.length(); i++) {\\n                char c = s.charAt(i);\\n                if (i % 2 == 0) {\\n                    if (c == \\'1\\') {\\n                        evenOne++;\\n                    } else {\\n                        evenZero++;\\n                    }\\n                }\\n                if (i % 2 == 1) {\\n                    if (c == \\'1\\') {\\n                        oddOne++;\\n                    } else {\\n                        oddZero++;\\n                    }\\n                }\\n            }\\n            int mini = Integer.MAX_VALUE;\\n\\t\\t\\t//change all even position 0 to odd position 1.\\n            if (evenZero == oddOne) {\\n                mini = Math.min(mini, evenZero);\\n            }\\n\\t\\t\\t//change all odd position 0 to even position 1\\n            if (evenOne == oddZero) {\\n                mini = Math.min(mini, evenOne);\\n            }\\n            return mini == Integer.MAX_VALUE ? -1 : mini;\\n        }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n        public int minSwaps(String s) {\\n            int evenOne = 0;\\n            int evenZero = 0;\\n            int oddOne = 0;\\n            int oddZero = 0;\\n            for (int i = 0; i < s.length(); i++) {\\n                char c = s.charAt(i);\\n                if (i % 2 == 0) {\\n                    if (c == \\'1\\') {\\n                        evenOne++;\\n                    } else {\\n                        evenZero++;\\n                    }\\n                }\\n                if (i % 2 == 1) {\\n                    if (c == \\'1\\') {\\n                        oddOne++;\\n                    } else {\\n                        oddZero++;\\n                    }\\n                }\\n            }\\n            int mini = Integer.MAX_VALUE;\\n\\t\\t\\t//change all even position 0 to odd position 1.\\n            if (evenZero == oddOne) {\\n                mini = Math.min(mini, evenZero);\\n            }\\n\\t\\t\\t//change all odd position 0 to even position 1\\n            if (evenOne == oddZero) {\\n                mini = Math.min(mini, evenOne);\\n            }\\n            return mini == Integer.MAX_VALUE ? -1 : mini;\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2624567,
                "title": "java-easy-and-straightforward-solution-time-o-n",
                "content": "```\\nclass Solution {\\n    public int minSwaps(String s) {\\n        int numZero=0, numOne =0, len = s.length();\\n        for(int i = 0 ; i < len ; ++i){\\n            if(s.charAt(i)==\\'0\\'){\\n                numZero++;\\n            }else{\\n                numOne++;\\n            }\\n        }\\n        if(Math.abs(numZero-numOne)>1){\\n            return -1;\\n        }\\n        \\n        \\n        int cnt1=0,cnt2=0,res=0;\\n        if(numZero!=numOne){ // s\\' length is odd number\\n            char checker = numZero>numOne? \\'0\\':\\'1\\';\\n            for(int i = 0 ; i < len; i+=2){\\n                if(s.charAt(i)!=checker){\\n                    cnt1++;\\n                }\\n            }\\n            res=cnt1;\\n        }else{ // s\\' length is even number\\n            for(int i = 0 ; i < len; i+=2){\\n                if(s.charAt(i)!=\\'0\\'){\\n                    cnt1++;\\n                }\\n                if(s.charAt(i)!=\\'1\\'){\\n                    cnt2++;\\n                }\\n                \\n            }\\n            res=Math.min(cnt1,cnt2);\\n        }\\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSwaps(String s) {\\n        int numZero=0, numOne =0, len = s.length();\\n        for(int i = 0 ; i < len ; ++i){\\n            if(s.charAt(i)==\\'0\\'){\\n                numZero++;\\n            }else{\\n                numOne++;\\n            }\\n        }\\n        if(Math.abs(numZero-numOne)>1){\\n            return -1;\\n        }\\n        \\n        \\n        int cnt1=0,cnt2=0,res=0;\\n        if(numZero!=numOne){ // s\\' length is odd number\\n            char checker = numZero>numOne? \\'0\\':\\'1\\';\\n            for(int i = 0 ; i < len; i+=2){\\n                if(s.charAt(i)!=checker){\\n                    cnt1++;\\n                }\\n            }\\n            res=cnt1;\\n        }else{ // s\\' length is even number\\n            for(int i = 0 ; i < len; i+=2){\\n                if(s.charAt(i)!=\\'0\\'){\\n                    cnt1++;\\n                }\\n                if(s.charAt(i)!=\\'1\\'){\\n                    cnt2++;\\n                }\\n                \\n            }\\n            res=Math.min(cnt1,cnt2);\\n        }\\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2601845,
                "title": "java-solution-beats-100",
                "content": "class Solution {\\n    public int minSwaps(String s) {\\n        char zero=\\'0\\',one=\\'1\\';\\n        int z=0,o=0;\\n        int az=0,ao=0;\\n        for(char curr:s.toCharArray()){\\n            if(curr==\\'0\\'){\\n                z++;\\n                if(zero!=\\'0\\')\\n                    az++;\\n                if(one!=\\'0\\')\\n                    ao++;\\n            }\\n            else{\\n                o++;\\n                if(zero!=\\'1\\')\\n                    az++;\\n                if(one!=\\'1\\')\\n                    ao++;\\n            }\\n            if(zero==\\'0\\')\\n                zero=\\'1\\';\\n            else\\n                zero=\\'0\\';\\n            if(one==\\'0\\')\\n                one=\\'1\\';\\n            else\\n                one=\\'0\\';\\n        }\\n        if(Math.max(z,o)-Math.min(z,o)>1)\\n            return -1;\\n        else if(Math.max(z,o)-Math.min(z,o)==0)\\n            return Math.min(az,ao)/2;\\n        else if(Math.max(z,o)==z)\\n            return az/2;\\n        else if(Math.max(z,o)==o)\\n            return ao/2;\\n        return -1;\\n            \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minSwaps(String s) {\\n        char zero=\\'0\\',one=\\'1\\';\\n        int z=0,o=0;\\n        int az=0,ao=0;\\n        for(char curr:s.toCharArray()){\\n            if(curr==\\'0\\'){\\n                z++;\\n                if(zero!=\\'0\\')\\n                    az++;\\n                if(one!=\\'0\\')\\n                    ao++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2598513,
                "title": "easy-java-solution",
                "content": "I kind of got stuck in this one. Had to look up the hint then it clicked. Kind of misread as I was thinking that cases like `00011` will also be possible and we have to just make the one alternate. Here\\'s the code anyways\\n```java\\nclass Solution {\\n    public int minSwaps(String s) {\\n        if (s.length()==0 || isOkay(s)) return 0;\\n        int n = s.length();\\n        int ones = 0;\\n        for (int i=0; i<n; i++) {\\n            if (s.charAt(i)==\\'1\\') ones++;\\n        }\\n        if (Math.abs(ones-(n-ones))>1) return -1;\\n        if (n%2==0) {\\n            StringBuilder sb1 = new StringBuilder();\\n            StringBuilder sb2 = new StringBuilder();\\n            for (int i=0; i<n; i++) {\\n                if (i%2==0) {\\n                    sb1.append(\\'1\\');\\n                    sb2.append(\\'0\\');\\n                } else {\\n                    sb1.append(\\'0\\');\\n                    sb2.append(\\'1\\');\\n                }\\n            }\\n            int s1 = 0;\\n            int s2 = 0;\\n            for (int i=0; i<n; i++) {\\n                if (sb1.charAt(i)!=s.charAt(i)) s1++;\\n                if (sb2.charAt(i)!=s.charAt(i)) s2++;\\n            }\\n            int min = Math.min(s1, s2)/2;\\n            return min;\\n            \\n        } else {\\n            if (n-ones>ones) { //more zeroes\\n                int c = 0;\\n                for (int i=0; i<n; i++) {\\n                    if ((i%2==0 && s.charAt(i)!=\\'0\\')) c++;\\n                    if (i%2!=0 && s.charAt(i)!=\\'1\\') c++;\\n                }\\n                return c/2;\\n            } else { //less zeroes\\n                int c = 0;\\n                for (int i=0; i<n; i++) {\\n                    if (i%2==0 && s.charAt(i)!=\\'1\\') c++;\\n                    if (i%2!=0 && s.charAt(i)!=\\'0\\') c++;\\n                }\\n                return c/2;\\n            }\\n        }\\n    }\\n    \\n    public boolean isOkay(String s) {\\n        for (int i=0; i<s.length()-1; i++) {\\n            if (s.charAt(i)==s.charAt(i+1)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int minSwaps(String s) {\\n        if (s.length()==0 || isOkay(s)) return 0;\\n        int n = s.length();\\n        int ones = 0;\\n        for (int i=0; i<n; i++) {\\n            if (s.charAt(i)==\\'1\\') ones++;\\n        }\\n        if (Math.abs(ones-(n-ones))>1) return -1;\\n        if (n%2==0) {\\n            StringBuilder sb1 = new StringBuilder();\\n            StringBuilder sb2 = new StringBuilder();\\n            for (int i=0; i<n; i++) {\\n                if (i%2==0) {\\n                    sb1.append(\\'1\\');\\n                    sb2.append(\\'0\\');\\n                } else {\\n                    sb1.append(\\'0\\');\\n                    sb2.append(\\'1\\');\\n                }\\n            }\\n            int s1 = 0;\\n            int s2 = 0;\\n            for (int i=0; i<n; i++) {\\n                if (sb1.charAt(i)!=s.charAt(i)) s1++;\\n                if (sb2.charAt(i)!=s.charAt(i)) s2++;\\n            }\\n            int min = Math.min(s1, s2)/2;\\n            return min;\\n            \\n        } else {\\n            if (n-ones>ones) { //more zeroes\\n                int c = 0;\\n                for (int i=0; i<n; i++) {\\n                    if ((i%2==0 && s.charAt(i)!=\\'0\\')) c++;\\n                    if (i%2!=0 && s.charAt(i)!=\\'1\\') c++;\\n                }\\n                return c/2;\\n            } else { //less zeroes\\n                int c = 0;\\n                for (int i=0; i<n; i++) {\\n                    if (i%2==0 && s.charAt(i)!=\\'1\\') c++;\\n                    if (i%2!=0 && s.charAt(i)!=\\'0\\') c++;\\n                }\\n                return c/2;\\n            }\\n        }\\n    }\\n    \\n    public boolean isOkay(String s) {\\n        for (int i=0; i<s.length()-1; i++) {\\n            if (s.charAt(i)==s.charAt(i+1)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2578637,
                "title": "c-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        int num1 = 0, num0 = 0;\\n        for(char c : s){\\n            num1 += (c ==\\'1\\');\\n            num0 += (c ==\\'0\\');\\n        }\\n        if(abs(num1 - num0) > 1)return -1;\\n        if(num0 == num1){\\n            int check0 = 0;\\n            char oddC = \\'0\\';\\n            for(int i = 1; i < s.length(); i += 2){\\n                if(s[i] != oddC) ++check0;\\n            }\\n            int check1 = 0;\\n            oddC = \\'1\\';\\n            for(int i = 1; i < s.length(); i += 2){\\n                if(s[i] != oddC) ++check1;\\n            }\\n            return min(check0,check1);\\n        }else{\\n            int ret = 0;\\n            char oddC = (num1 > num0) ? \\'0\\' : \\'1\\';\\n            for(int i = 1; i < s.length(); i += 2){\\n                if(s[i] != oddC) ++ret;\\n            }\\n            return ret;\\n        }\\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        int num1 = 0, num0 = 0;\\n        for(char c : s){\\n            num1 += (c ==\\'1\\');\\n            num0 += (c ==\\'0\\');\\n        }\\n        if(abs(num1 - num0) > 1)return -1;\\n        if(num0 == num1){\\n            int check0 = 0;\\n            char oddC = \\'0\\';\\n            for(int i = 1; i < s.length(); i += 2){\\n                if(s[i] != oddC) ++check0;\\n            }\\n            int check1 = 0;\\n            oddC = \\'1\\';\\n            for(int i = 1; i < s.length(); i += 2){\\n                if(s[i] != oddC) ++check1;\\n            }\\n            return min(check0,check1);\\n        }else{\\n            int ret = 0;\\n            char oddC = (num1 > num0) ? \\'0\\' : \\'1\\';\\n            for(int i = 1; i < s.length(); i += 2){\\n                if(s[i] != oddC) ++ret;\\n            }\\n            return ret;\\n        }\\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": []
    }
]