[
    {
        "title": "Interleaving String",
        "question_content": "Given strings s1, s2, and s3, find whether s3 is formed by an interleaving of s1 and s2.\nAn interleaving of two strings s and t is a configuration where s and t are divided into n and m substrings respectively, such that:\n\n\ts = s1 + s2 + ... + sn\n\tt = t1 + t2 + ... + tm\n\t|n - m| <= 1\n\tThe interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...\n\nNote: a + b is the concatenation of strings a and b.\n&nbsp;\nExample 1:\n\nInput: s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbcbcac\"\nOutput: true\nExplanation: One way to obtain s3 is:\nSplit s1 into s1 = \"aa\" + \"bc\" + \"c\", and s2 into s2 = \"dbbc\" + \"a\".\nInterleaving the two splits, we get \"aa\" + \"dbbc\" + \"bc\" + \"a\" + \"c\" = \"aadbbcbcac\".\nSince s3 can be obtained by interleaving s1 and s2, we return true.\n\nExample 2:\n\nInput: s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbbaccc\"\nOutput: false\nExplanation: Notice how it is impossible to interleave s2 with any other string to obtain s3.\n\nExample 3:\n\nInput: s1 = \"\", s2 = \"\", s3 = \"\"\nOutput: true\n\n&nbsp;\nConstraints:\n\n\t0 <= s1.length, s2.length <= 100\n\t0 <= s3.length <= 200\n\ts1, s2, and s3 consist of lowercase English letters.\n\n&nbsp;\nFollow up: Could you solve it using only O(s2.length) additional memory space?",
        "solutions": [
            {
                "id": 31879,
                "title": "my-dp-solution-in-c",
                "content": " \\n\\n     bool isInterleave(string s1, string s2, string s3) {\\n        \\n        if(s3.length() != s1.length() + s2.length())\\n            return false;\\n        \\n        bool table[s1.length()+1][s2.length()+1];\\n        \\n        for(int i=0; i<s1.length()+1; i++)\\n            for(int j=0; j< s2.length()+1; j++){\\n                if(i==0 && j==0)\\n                    table[i][j] = true;\\n                else if(i == 0)\\n                    table[i][j] = ( table[i][j-1] && s2[j-1] == s3[i+j-1]);\\n                else if(j == 0)\\n                    table[i][j] = ( table[i-1][j] && s1[i-1] == s3[i+j-1]);\\n                else\\n                    table[i][j] = (table[i-1][j] && s1[i-1] == s3[i+j-1] ) || (table[i][j-1] && s2[j-1] == s3[i+j-1] );\\n            }\\n            \\n        return table[s1.length()][s2.length()];\\n    }\\n    \\n\\n\\nHere is some explanation:\\n\\nDP table represents if s3 is interleaving at (i+j)th position when s1 is at ith position, and s2 is at jth position. 0th position means empty string.\\n\\nSo if both s1 and s2 is currently empty, s3 is empty too, and it is considered interleaving. If only s1 is empty, then if previous s2 position is interleaving and current s2 position char is equal to s3 current position char, it is considered interleaving. similar idea applies to when s2 is empty. when both s1 and s2 is not empty, then if we arrive i, j from i-1, j, then if i-1,j is already interleaving and i and current s3 position equal, it s interleaving. If we arrive i,j from i, j-1, then if i, j-1 is already interleaving and j and current s3 position equal. it is interleaving.",
                "solutionTags": [],
                "code": " \\n\\n     bool isInterleave(string s1, string s2, string s3) {\\n        \\n        if(s3.length() != s1.length() + s2.length())\\n            return false;\\n        \\n        bool table[s1.length()+1][s2.length()+1];\\n        \\n        for(int i=0; i<s1.length()+1; i++)\\n            for(int j=0; j< s2.length()+1; j++){\\n                if(i==0 && j==0)\\n                    table[i][j] = true;\\n                else if(i == 0)\\n                    table[i][j] = ( table[i][j-1] && s2[j-1] == s3[i+j-1]);\\n                else if(j == 0)\\n                    table[i][j] = ( table[i-1][j] && s1[i-1] == s3[i+j-1]);\\n                else\\n                    table[i][j] = (table[i-1][j] && s1[i-1] == s3[i+j-1] ) || (table[i][j-1] && s2[j-1] == s3[i+j-1] );\\n            }\\n            \\n        return table[s1.length()][s2.length()];\\n    }\\n    \\n\\n\\nHere is some explanation:\\n\\nDP table represents if s3 is interleaving at (i+j)th position when s1 is at ith position, and s2 is at jth position. 0th position means empty string.\\n\\nSo if both s1 and s2 is currently empty, s3 is empty too, and it is considered interleaving. If only s1 is empty, then if previous s2 position is interleaving and current s2 position char is equal to s3 current position char, it is considered interleaving. similar idea applies to when s2 is empty. when both s1 and s2 is not empty, then if we arrive i, j from i-1, j, then if i-1,j is already interleaving and i and current s3 position equal, it s interleaving. If we arrive i,j from i, j-1, then if i, j-1 is already interleaving and j and current s3 position equal. it is interleaving.",
                "codeTag": "Unknown"
            },
            {
                "id": 31948,
                "title": "8ms-c-solution-using-bfs-with-explanation",
                "content": "If we expand the two strings s1 and s2 into a chessboard, then this problem can be transferred into a path seeking problem from the top-left corner to the bottom-right corner. The key is, each cell (y, x) in the board corresponds to an interval between y-th character in s1 and x-th character in s2. And adjacent cells are connected with like a grid. A BFS can then be efficiently performed to find the path.\\n\\nBetter to illustrate with an example here:\\n\\nSay s1 = \"aab\" and s2 = \"abc\". s3 = \"aaabcb\". Then the board looks like\\n\\n    o--a--o--b--o--c--o\\n    |     |     |     |\\n    a     a     a     a\\n    |     |     |     |\\n    o--a--o--b--o--c--o\\n    |     |     |     |\\n    a     a     a     a\\n    |     |     |     |\\n    o--a--o--b--o--c--o\\n    |     |     |     |\\n    b     b     b     b\\n    |     |     |     |\\n    o--a--o--b--o--c--o\\n\\nEach \"o\" is a cell in the board. We start from the top-left corner, and try to move right or down. If the next char in s3 matches the edge connecting the next cell, then we're able to move. When we hit the bottom-right corner, this means s3 can be represented by interleaving s1 and s2. One possible path for this example is indicated with \"x\"es below:\\n\\n    x--a--x--b--o--c--o\\n    |     |     |     |\\n    a     a     a     a\\n    |     |     |     |\\n    o--a--x--b--o--c--o\\n    |     |     |     |\\n    a     a     a     a\\n    |     |     |     |\\n    o--a--x--b--x--c--x\\n    |     |     |     |\\n    b     b     b     b\\n    |     |     |     |\\n    o--a--o--b--o--c--x\\n\\nNote if we concatenate the chars on the edges we went along, it's exactly s3. And we went through all the chars in s1 and s2, in order, exactly once.\\n\\nTherefore if we view this board as a graph, such path finding problem is trivial with BFS. I use an `unordered_map` to store the visited nodes, which makes the code look a bit complicated. But a `vector` should be enough to do the job. \\n\\nAlthough the worse case timeis also O(mn), typically it doesn't require us to go through every node to find a path. Therefore it's faster than regular DP than average.\\n\\n    struct MyPoint {\\n        int y, x; \\n        bool operator==(const MyPoint &p) const {\\n            return p.y == y && p.x == x;\\n        }\\n    };\\n    namespace std {\\n        template <>\\n        struct hash<MyPoint> {\\n            size_t operator () (const MyPoint &f) const {\\n                return (std::hash<int>()(f.x) << 1) ^ std::hash<int>()(f.y);\\n            }\\n        };\\n    }\\n    \\n    class Solution {\\n    public:\\n        bool isInterleave(string s1, string s2, string s3) {\\n            if (s1.size() + s2.size() != s3.size()) return false;\\n\\n            queue<MyPoint> q;\\n            unordered_set<MyPoint> visited;\\n            bool isSuccessful = false;\\n            int i = 0;\\n    \\n            q.push(MyPoint { 0, 0 });\\n            q.push(MyPoint { -1, -1 });\\n            while (!(1 == q.size() && -1 == q.front().x)) {\\n                auto p = q.front();\\n                q.pop();\\n                if (p.y == s1.size() && p.x == s2.size()) {\\n                    return true;\\n                }\\n                if (-1 == p.y) {\\n                    q.push(p);\\n                    i++;\\n                    continue;\\n                }\\n                if (visited.find(p) != visited.end()) { continue; }\\n                visited.insert(p);\\n    \\n                if (p.y < s1.size()) { // down\\n                    if (s1[p.y] == s3[i]) { q.push(MyPoint { p.y + 1, p.x }); }\\n                }\\n                if (p.x < s2.size()) { // right \\n                    if (s2[p.x] == s3[i]) { q.push(MyPoint { p.y, p.x + 1 }); }\\n                }\\n            }\\n            return false;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isInterleave(string s1, string s2, string s3) {\\n            if (s1.size() + s2.size() != s3.size()) return false;\\n\\n            queue<MyPoint> q;\\n            unordered_set<MyPoint> visited;\\n            bool isSuccessful = false;\\n            int i = 0;\\n    \\n            q.push(MyPoint { 0, 0 }",
                "codeTag": "Java"
            },
            {
                "id": 31885,
                "title": "python-dp-solutions-o-m-n-o-n-space-bfs-dfs",
                "content": "    \\n    # O(m*n) space\\n    def isInterleave1(self, s1, s2, s3):\\n        r, c, l= len(s1), len(s2), len(s3)\\n        if r+c != l:\\n            return False\\n        dp = [[True for _ in xrange(c+1)] for _ in xrange(r+1)]\\n        for i in xrange(1, r+1):\\n            dp[i][0] = dp[i-1][0] and s1[i-1] == s3[i-1]\\n        for j in xrange(1, c+1):\\n            dp[0][j] = dp[0][j-1] and s2[j-1] == s3[j-1]\\n        for i in xrange(1, r+1):\\n            for j in xrange(1, c+1):\\n                dp[i][j] = (dp[i-1][j] and s1[i-1] == s3[i-1+j]) or \\\\\\n                   (dp[i][j-1] and s2[j-1] == s3[i-1+j])\\n        return dp[-1][-1]\\n\\n    # O(2*n) space\\n    def isInterleave2(self, s1, s2, s3):\\n        l1, l2, l3 = len(s1)+1, len(s2)+1, len(s3)+1\\n        if l1+l2 != l3+1:\\n            return False\\n        pre = [True for _ in xrange(l2)]\\n        for j in xrange(1, l2):\\n            pre[j] = pre[j-1] and s2[j-1] == s3[j-1]\\n        for i in xrange(1, l1):\\n            cur = [pre[0] and s1[i-1] == s3[i-1]] * l2\\n            for j in xrange(1, l2):\\n                cur[j] = (cur[j-1] and s2[j-1] == s3[i+j-1]) or \\\\\\n                         (pre[j] and s1[i-1] == s3[i+j-1])\\n            pre = cur[:]\\n        return pre[-1]\\n    \\n    # O(n) space\\n    def isInterleave3(self, s1, s2, s3):\\n        r, c, l= len(s1), len(s2), len(s3)\\n        if r+c != l:\\n            return False\\n        dp = [True for _ in xrange(c+1)] \\n        for j in xrange(1, c+1):\\n            dp[j] = dp[j-1] and s2[j-1] == s3[j-1]\\n        for i in xrange(1, r+1):\\n            dp[0] = (dp[0] and s1[i-1] == s3[i-1])\\n            for j in xrange(1, c+1):\\n                dp[j] = (dp[j] and s1[i-1] == s3[i-1+j]) or (dp[j-1] and s2[j-1] == s3[i-1+j])\\n        return dp[-1]\\n        \\n    # DFS \\n    def isInterleave4(self, s1, s2, s3):\\n        r, c, l= len(s1), len(s2), len(s3)\\n        if r+c != l:\\n            return False\\n        stack, visited = [(0, 0)], set((0, 0))\\n        while stack:\\n            x, y = stack.pop()\\n            if x+y == l:\\n                return True\\n            if x+1 <= r and s1[x] == s3[x+y] and (x+1, y) not in visited:\\n                stack.append((x+1, y)); visited.add((x+1, y))\\n            if y+1 <= c and s2[y] == s3[x+y] and (x, y+1) not in visited:\\n                stack.append((x, y+1)); visited.add((x, y+1))\\n        return False\\n                \\n    # BFS \\n    def isInterleave(self, s1, s2, s3):\\n        r, c, l= len(s1), len(s2), len(s3)\\n        if r+c != l:\\n            return False\\n        queue, visited = [(0, 0)], set((0, 0))\\n        while queue:\\n            x, y = queue.pop(0)\\n            if x+y == l:\\n                return True\\n            if x+1 <= r and s1[x] == s3[x+y] and (x+1, y) not in visited:\\n                queue.append((x+1, y)); visited.add((x+1, y))\\n            if y+1 <= c and s2[y] == s3[x+y] and (x, y+1) not in visited:\\n                queue.append((x, y+1)); visited.add((x, y+1))\\n        return False",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "    \\n    # O(m*n) space\\n    def isInterleave1(self, s1, s2, s3):\\n        r, c, l= len(s1), len(s2), len(s3)\\n        if r+c != l:\\n            return False\\n        dp = [[True for _ in xrange(c+1)] for _ in xrange(r+1)]\\n        for i in xrange(1, r+1):\\n            dp[i][0] = dp[i-1][0] and s1[i-1] == s3[i-1]\\n        for j in xrange(1, c+1):\\n            dp[0][j] = dp[0][j-1] and s2[j-1] == s3[j-1]\\n        for i in xrange(1, r+1):\\n            for j in xrange(1, c+1):\\n                dp[i][j] = (dp[i-1][j] and s1[i-1] == s3[i-1+j]) or \\\\\\n                   (dp[i][j-1] and s2[j-1] == s3[i-1+j])\\n        return dp[-1][-1]\\n\\n    # O(2*n) space\\n    def isInterleave2(self, s1, s2, s3):\\n        l1, l2, l3 = len(s1)+1, len(s2)+1, len(s3)+1\\n        if l1+l2 != l3+1:\\n            return False\\n        pre = [True for _ in xrange(l2)]\\n        for j in xrange(1, l2):\\n            pre[j] = pre[j-1] and s2[j-1] == s3[j-1]\\n        for i in xrange(1, l1):\\n            cur = [pre[0] and s1[i-1] == s3[i-1]] * l2\\n            for j in xrange(1, l2):\\n                cur[j] = (cur[j-1] and s2[j-1] == s3[i+j-1]) or \\\\\\n                         (pre[j] and s1[i-1] == s3[i+j-1])\\n            pre = cur[:]\\n        return pre[-1]\\n    \\n    # O(n) space\\n    def isInterleave3(self, s1, s2, s3):\\n        r, c, l= len(s1), len(s2), len(s3)\\n        if r+c != l:\\n            return False\\n        dp = [True for _ in xrange(c+1)] \\n        for j in xrange(1, c+1):\\n            dp[j] = dp[j-1] and s2[j-1] == s3[j-1]\\n        for i in xrange(1, r+1):\\n            dp[0] = (dp[0] and s1[i-1] == s3[i-1])\\n            for j in xrange(1, c+1):\\n                dp[j] = (dp[j] and s1[i-1] == s3[i-1+j]) or (dp[j-1] and s2[j-1] == s3[i-1+j])\\n        return dp[-1]\\n        \\n    # DFS \\n    def isInterleave4(self, s1, s2, s3):\\n        r, c, l= len(s1), len(s2), len(s3)\\n        if r+c != l:\\n            return False\\n        stack, visited = [(0, 0)], set((0, 0))\\n        while stack:\\n            x, y = stack.pop()\\n            if x+y == l:\\n                return True\\n            if x+1 <= r and s1[x] == s3[x+y] and (x+1, y) not in visited:\\n                stack.append((x+1, y)); visited.add((x+1, y))\\n            if y+1 <= c and s2[y] == s3[x+y] and (x, y+1) not in visited:\\n                stack.append((x, y+1)); visited.add((x, y+1))\\n        return False\\n                \\n    # BFS \\n    def isInterleave(self, s1, s2, s3):\\n        r, c, l= len(s1), len(s2), len(s3)\\n        if r+c != l:\\n            return False\\n        queue, visited = [(0, 0)], set((0, 0))\\n        while queue:\\n            x, y = queue.pop(0)\\n            if x+y == l:\\n                return True\\n            if x+1 <= r and s1[x] == s3[x+y] and (x+1, y) not in visited:\\n                queue.append((x+1, y)); visited.add((x+1, y))\\n            if y+1 <= c and s2[y] == s3[x+y] and (x, y+1) not in visited:\\n                queue.append((x, y+1)); visited.add((x, y+1))\\n        return False",
                "codeTag": "Python3"
            },
            {
                "id": 31888,
                "title": "1ms-tiny-dfs-beats-94-57",
                "content": "To solve this problem, let's look at if `s1[0 ~ i]`  `s2[0 ~ j]` can be interleaved to `s3[0 ~ k]`.\\n\\n- Start from indices`0, 0, 0` and compare `s1[i] == s3[k]` or `s2[j] == s3[k]`\\n- Return valid only if either `i` or `j` match `k` and the remaining is also valid\\n- Caching is the key to performance. This is very similar to top down dp\\n- Only need to cache `invalid[i][j]` since most of the case `s1[0 ~ i]` and `s2[0 ~ j]` does not form `s3[0 ~ k]`. Also tested caching `valid[i][j]` the run time is also `1ms`\\n- Many guys use `substring` but it's duplicate code since `substring` itself is checking char by char. We are already doing so\\n\\n\\nHope it helps!\\n\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        char[] c1 = s1.toCharArray(), c2 = s2.toCharArray(), c3 = s3.toCharArray();\\n    \\tint m = s1.length(), n = s2.length();\\n    \\tif(m + n != s3.length()) return false;\\n    \\treturn dfs(c1, c2, c3, 0, 0, 0, new boolean[m + 1][n + 1]);\\n    }\\n    \\n    public boolean dfs(char[] c1, char[] c2, char[] c3, int i, int j, int k, boolean[][] invalid) {\\n    \\tif(invalid[i][j]) return false;\\n    \\tif(k == c3.length) return true;\\n    \\tboolean valid = \\n    \\t    i < c1.length && c1[i] == c3[k] && dfs(c1, c2, c3, i + 1, j, k + 1, invalid) || \\n            j < c2.length && c2[j] == c3[k] && dfs(c1, c2, c3, i, j + 1, k + 1, invalid);\\n    \\tif(!valid) invalid[i][j] = true;\\n        return valid;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "To solve this problem, let's look at if `s1[0 ~ i]`  `s2[0 ~ j]` can be interleaved to `s3[0 ~ k]`.\\n\\n- Start from indices`0, 0, 0` and compare `s1[i] == s3[k]` or `s2[j] == s3[k]`\\n- Return valid only if either `i` or `j` match `k` and the remaining is also valid\\n- Caching is the key to performance. This is very similar to top down dp\\n- Only need to cache `invalid[i][j]` since most of the case `s1[0 ~ i]` and `s2[0 ~ j]` does not form `s3[0 ~ k]`. Also tested caching `valid[i][j]` the run time is also `1ms`\\n- Many guys use `substring` but it's duplicate code since `substring` itself is checking char by char. We are already doing so\\n\\n\\nHope it helps!\\n\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        char[] c1 = s1.toCharArray(), c2 = s2.toCharArray(), c3 = s3.toCharArray();\\n    \\tint m = s1.length(), n = s2.length();\\n    \\tif(m + n != s3.length()) return false;\\n    \\treturn dfs(c1, c2, c3, 0, 0, 0, new boolean[m + 1][n + 1]);\\n    }\\n    \\n    public boolean dfs(char[] c1, char[] c2, char[] c3, int i, int j, int k, boolean[][] invalid) {\\n    \\tif(invalid[i][j]) return false;\\n    \\tif(k == c3.length) return true;\\n    \\tboolean valid = \\n    \\t    i < c1.length && c1[i] == c3[k] && dfs(c1, c2, c3, i + 1, j, k + 1, invalid) || \\n            j < c2.length && c2[j] == c3[k] && dfs(c1, c2, c3, i, j + 1, k + 1, invalid);\\n    \\tif(!valid) invalid[i][j] = true;\\n        return valid;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2249509,
                "title": "python-simple-solution-w-explanation-recursion-dp",
                "content": "Given three strings `s1`, `s2` and `s3`, we need to check if `s3` can be formed by an interleaving of `s1` and `s2`.\\n\\nAn **interleaving** of two strings, `s1` and `s2`, means that `s1` is divided into `x` and `s2` is divided into `y` contiguous substrings, respectively. Then those substrings are concatenated without changing the order of their occurrence in `s1` and `s2`.\\nNote that the condition `|x - y| <=1` always holds true.\\n<details>\\n<summary><strong>Proof:</strong></summary>\\n<br/>\\nLet\\'s say <code>s1 = \"abcde\"</code> and <code>s2 = \"fgh\"</code>. We divide <code>s1</code> into four parts and <code>s2</code> into two parts.\\nSo, <code>x - y = 2</code>.\\n<br/>\\n<code>s1 = \"ab\" + \"c\" + \"d\" + \"e\" and s2 = \"f\" + \"gh\"</code>.\\n<br/>\\n<code>s3 = \"ab\" + \"f\" + \"c\" + \"gh\" + \"d\" + \"e\"</code>.\\n<br/>\\nThe above can rewritten as <code>s3 = \"ab\" + \"f\" + \"c\" + \"gh\" + \"de\"</code>, which is basically\\ndividing <code>s1</code> into three parts and <code>s2</code> into two parts. And hence, the condition <code>|x - y| <=1</code> holds true.\\n\\nThere are stricter proofs, but I tried to provide an intuitive one.\\n</details>\\n\\n___\\n___\\n\\u274C **Solution I: Recursion [TLE]**\\n\\nWe don\\'t know the size of each substring or the number of substrings beforehand. So, we can take all possible substrings of `s1` and `s2` and check if `s3` can be formed by interleaving them. At each step, we have two options: choose a character from `s1` or `s2`. Let\\'s call our recursive function `dfs(i, j)`. Then the two choices can be represented as:\\n\\n1. `dfs(i + 1, j)`: Choose a character at `i`th index from `s1`\\n2. `dfs(i, j + 1)`: Choose a character at `j`th index from `s2`\\n\\nActually, we can make this choice more smartly. Instead of considering all possibilities, we can make either/both choice(s) only when it matches the character at the `i + j`th index of `s3`.\\n\\n```python\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3):\\n            return False\\n\\n        def dfs(i, j):\\n            if i == len(s1) and j == len(s2):\\n                return True\\n            choose_s1, choose_s2 = False, False\\n            if i < len(s1) and s1[i] == s3[i + j]:\\n                choose_s1 = dfs(i + 1, j)\\n            if j < len(s2) and s2[j] == s3[i + j]:\\n                choose_s2 = dfs(i, j + 1)\\n\\n            return choose_s1 or choose_s2\\n\\n        return dfs(0, 0)\\n```\\n\\nWhy have I named the inside function as `dfs`? Because if we trace our actions, we can observe that it forms a binary tree. **Don\\'t worry** if you are not familiar with this term. The following visualization will help you to understand what I mean.\\n\\n```text\\n                                        \\u250F\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2513\\n                  \\u256D\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2528 0, 0 \\u2520\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u256E\\n                  \\u2502                     \\u2517\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u251B                      \\u2502\\n              \\u250F\\u2501\\u2501\\u2501\\u2537\\u2501\\u2501\\u2513                                             \\u250F\\u2501\\u2501\\u2537\\u2501\\u2501\\u2501\\u2513     \\n      \\u256D\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2528 1, 0 \\u2520\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u256E                         \\u256D\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2528 0, 1 \\u2520\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u256E                 \\n      \\u2502       \\u2517\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u251B         \\u2502                         \\u2502         \\u2517\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u251B         \\u2502 \\n  \\u250F\\u2501\\u2501\\u2501\\u2537\\u2501\\u2501\\u2513                  \\u250F\\u2501\\u2501\\u2537\\u2501\\u2501\\u2501\\u2513                 \\u250F\\u2501\\u2501\\u2501\\u2537\\u2501\\u2501\\u2513                    \\u250F\\u2501\\u2501\\u2537\\u2501\\u2501\\u2501\\u2513  \\n  \\u2503 2, 0 \\u2503                  \\u2503 1, 1 \\u2503                 \\u2503 1, 1 \\u2503                    \\u2503 0, 2 \\u2503 \\n  \\u2517\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u251B                  \\u2517\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u251B                 \\u2517\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u251B                    \\u2517\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u251B   \\n     .                         .                        .                           .\\n     .                         .                        .                           .\\n     .                         .                        .                           .\\n\\n```\\n\\nIn dfs, we traverse all the paths one by one. So, here our paths will be:\\n\\n1. (0, 0) -> (1, 0) -> (2, 0) -> ...\\n2. (0, 0) -> (1, 0) -> (1, 1) -> ...\\n3. (0, 0) -> (0, 1) -> (1, 1) -> ...\\n4. (0, 0) -> (0, 1) -> (0, 2) -> ...\\n.\\n.\\n.\\n\\n- **Time Complexity:** <code>O(2<sup>m + n</sup>)</code>\\n  > At each step, we have two choices, so 2 * 2 * 2 ... (m + n) times.\\n- **Space Complexity:** `O(m + n)`\\n  > Recursion stack space.\\n\\n___\\n\\u2705 **Solution II: Dynamic Programming - Memoization [Accepted]**\\n\\nWe are doing a lot of repetitive work in the above recursive solution. How?\\nHave a look at the above example. The subtree with the head `[1, 1]` is repeated twice. Instead of computing it again, we store the result of that state and directly use it.\\nWe can use the decorator `@cache` in Python to achieve this.\\n\\n```python\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3):\\n            return False\\n        @cache\\n        def dfs(i, j):\\n            if i == len(s1) and j == len(s2):\\n                return True\\n            choose_s1, choose_s2 = False, False\\n            if i < len(s1) and s1[i] == s3[i + j]:\\n                choose_s1 = dfs(i + 1, j)\\n            if j < len(s2) and s2[j] == s3[i + j]:\\n                choose_s2 = dfs(i, j + 1)\\n\\n            return choose_s1 or choose_s2\\n\\n        return dfs(0, 0)\\n```\\n\\n- **Time Complexity:** `O(m * n)`\\n- **Space Complexity:** `O(m * n)`\\n\\n___\\n\\u2705 **Solution III(a): Dynamic Programming - Tabulation [Accepted]**\\n\\nRecursion is generally slower than its iterative counterpart. So, we can further optimize the above solution by using tabulation. Coming up with this solution is a bit difficult, and it requires practice. Try to find similarities with the memoization approach. The value `dp[i][j]` gives the information if we can form `s3[0...(i+j-1)]` from interleaving `s1[0...(i-1)]` and `s2[0...(j-1)]`. The first column represents interleving of `s1` and an empty string, and similarly, the first row represents interleaving of `s2` and and an empty string.\\n\\n```python\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        m, n = len(s1), len(s2)\\n        if m + n != len(s3):\\n            return False\\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\\n        dp[0][0] = True\\n        for i in range(1, m + 1):\\n            dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\\n        for j in range(1, n + 1):\\n            dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                choose_s1, choose_s2 = False, False\\n                if s1[i - 1] == s3[i + j - 1]:\\n                    choose_s1 = dp[i - 1][j]\\n                if s2[j - 1] == s3[i + j - 1]:\\n                    choose_s2 = dp[i][j - 1]\\n                dp[i][j] = choose_s1 or choose_s2\\n\\n        return dp[m][n]\\n\\n```\\n\\n- **Time Complexity:** `O(m * n)`\\n- **Space Complexity:** `O(m * n)`\\n\\n___\\n\\u2705 **Solution III(b): Dynamic Programming - Tabulation (Space Optimized) [Accepted]**\\n\\nNotice that we only require the information from the cells `dp[i - 1][j]` and `dp[i][j - 1]`, i.e. the cell above the current row and the cell to the left of the current column. So, no need to use a matrix. The code can be shortened, but for the sake of understandability, I decided to leave it as it is.\\n\\n```python\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        m, n = len(s1), len(s2)\\n        if m + n != len(s3):\\n            return False\\n        if n > m:\\n            m, n = n, m\\n            s1, s2 = s2, s1\\n        dp = [False] * (n + 1)\\n        dp[0] = True\\n        for j in range(1, n + 1):\\n            dp[j] = dp[j - 1] and s2[j - 1] == s3[j - 1]\\n        for i in range(1, m + 1):\\n            dp[0] = dp[0] and s1[i - 1] == s3[i - 1]\\n            for j in range(1, n + 1):\\n                choose_s1, choose_s2 = False, False\\n                if s1[i - 1] == s3[i + j - 1]:\\n                    choose_s1 = dp[j]\\n                if s2[j - 1] == s3[i + j - 1]:\\n                    choose_s2 = dp[j - 1]\\n                dp[j] = choose_s1 or choose_s2\\n\\n        return dp[-1]\\n```\\n\\n- **Time Complexity:** `O(m * n)`\\n- **Space Complexity:** `O(min(m, n))`\\n\\n___\\n___\\nIf you like the solution, please **upvote**! \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3):\\n            return False\\n\\n        def dfs(i, j):\\n            if i == len(s1) and j == len(s2):\\n                return True\\n            choose_s1, choose_s2 = False, False\\n            if i < len(s1) and s1[i] == s3[i + j]:\\n                choose_s1 = dfs(i + 1, j)\\n            if j < len(s2) and s2[j] == s3[i + j]:\\n                choose_s2 = dfs(i, j + 1)\\n\\n            return choose_s1 or choose_s2\\n\\n        return dfs(0, 0)\\n```\n```text\\n                                        \\u250F\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2513\\n                  \\u256D\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2528 0, 0 \\u2520\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u256E\\n                  \\u2502                     \\u2517\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u251B                      \\u2502\\n              \\u250F\\u2501\\u2501\\u2501\\u2537\\u2501\\u2501\\u2513                                             \\u250F\\u2501\\u2501\\u2537\\u2501\\u2501\\u2501\\u2513     \\n      \\u256D\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2528 1, 0 \\u2520\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u256E                         \\u256D\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2528 0, 1 \\u2520\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u256E                 \\n      \\u2502       \\u2517\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u251B         \\u2502                         \\u2502         \\u2517\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u251B         \\u2502 \\n  \\u250F\\u2501\\u2501\\u2501\\u2537\\u2501\\u2501\\u2513                  \\u250F\\u2501\\u2501\\u2537\\u2501\\u2501\\u2501\\u2513                 \\u250F\\u2501\\u2501\\u2501\\u2537\\u2501\\u2501\\u2513                    \\u250F\\u2501\\u2501\\u2537\\u2501\\u2501\\u2501\\u2513  \\n  \\u2503 2, 0 \\u2503                  \\u2503 1, 1 \\u2503                 \\u2503 1, 1 \\u2503                    \\u2503 0, 2 \\u2503 \\n  \\u2517\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u251B                  \\u2517\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u251B                 \\u2517\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u251B                    \\u2517\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u251B   \\n     .                         .                        .                           .\\n     .                         .                        .                           .\\n     .                         .                        .                           .\\n\\n```\n```python\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3):\\n            return False\\n        @cache\\n        def dfs(i, j):\\n            if i == len(s1) and j == len(s2):\\n                return True\\n            choose_s1, choose_s2 = False, False\\n            if i < len(s1) and s1[i] == s3[i + j]:\\n                choose_s1 = dfs(i + 1, j)\\n            if j < len(s2) and s2[j] == s3[i + j]:\\n                choose_s2 = dfs(i, j + 1)\\n\\n            return choose_s1 or choose_s2\\n\\n        return dfs(0, 0)\\n```\n```python\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        m, n = len(s1), len(s2)\\n        if m + n != len(s3):\\n            return False\\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\\n        dp[0][0] = True\\n        for i in range(1, m + 1):\\n            dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\\n        for j in range(1, n + 1):\\n            dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                choose_s1, choose_s2 = False, False\\n                if s1[i - 1] == s3[i + j - 1]:\\n                    choose_s1 = dp[i - 1][j]\\n                if s2[j - 1] == s3[i + j - 1]:\\n                    choose_s2 = dp[i][j - 1]\\n                dp[i][j] = choose_s1 or choose_s2\\n\\n        return dp[m][n]\\n\\n```\n```python\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        m, n = len(s1), len(s2)\\n        if m + n != len(s3):\\n            return False\\n        if n > m:\\n            m, n = n, m\\n            s1, s2 = s2, s1\\n        dp = [False] * (n + 1)\\n        dp[0] = True\\n        for j in range(1, n + 1):\\n            dp[j] = dp[j - 1] and s2[j - 1] == s3[j - 1]\\n        for i in range(1, m + 1):\\n            dp[0] = dp[0] and s1[i - 1] == s3[i - 1]\\n            for j in range(1, n + 1):\\n                choose_s1, choose_s2 = False, False\\n                if s1[i - 1] == s3[i + j - 1]:\\n                    choose_s1 = dp[j]\\n                if s2[j - 1] == s3[i + j - 1]:\\n                    choose_s2 = dp[j - 1]\\n                dp[j] = choose_s1 or choose_s2\\n\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956393,
                "title": "99-78-2-approaches-dp-recursion",
                "content": "# Interview Guide: \"Interleaving String\" Problem\\n\\n## Problem Understanding\\n\\nIn the \"Interleaving String\" problem, you are given three strings: `s1`, `s2`, and `s3`. Your task is to determine whether `s3` can be formed by interleaving `s1` and `s2`. For example, if `s1 = \"aabcc\"` and `s2 = \"dbbca\"`, then `s3 = \"aadbbcbcac\"` should return `true`, but `s3 = \"aadbbbaccc\"` should return `false`.\\n\\n## Key Points to Consider\\n\\n### 1. Understand the Constraints\\n\\nBefore diving into the solution, make sure you understand the problem\\'s constraints. The lengths of the strings will not be more than 100 for `s1` and `s2`, and not more than 200 for `s3`. This can help you gauge the time complexity you should aim for.\\n\\n### 2. Multiple Approaches\\n\\nThere are multiple ways to solve this problem, including:\\n\\n  - 2D Dynamic Programming\\n  - 1D Dynamic Programming\\n  - Recursion with Memoization\\n\\nEach method has its own time and space complexity, so choose based on the problem\\'s constraints.\\n\\n### 3. Space Optimization\\n\\nWhile 2D Dynamic Programming is the most intuitive approach, you can reduce the space complexity to \\\\(O(\\\\min(m, n))\\\\) by employing 1D Dynamic Programming. In an interview setting, discussing this optimization can impress your interviewer.\\n\\n### 4. Early Exit\\n\\nIf the sum of the lengths of `s1` and `s2` does not match the length of `s3`, you can immediately return `false`. This can save computation time and demonstrate that you\\'re mindful of edge cases.\\n\\n### 5. Explain Your Thought Process\\n\\nAlways explain your thought process and why you chose a particular approach. Discuss the trade-offs you\\'re making in terms of time and space complexity.\\n\\n## Conclusion\\n\\nThe \"Interleaving String\" problem is an excellent example of a problem that can be tackled through Dynamic Programming or Recursion. Knowing the trade-offs between different approaches and optimizing for space can give you an edge in interviews. By taking the time to understand the problem, choosing the appropriate data structures, and optimizing your approach, you\\'ll not only solve the problem but also demonstrate a well-rounded skill set.\\n\\n---\\n\\n# Live Coding & Explenation: 1D Dynamic Programming\\nhttps://youtu.be/iv_cTwwsRxs\\n\\n---\\n\\n# Approach: 2D Dynamic Programming \\n\\nTo solve the \"Interleaving String\" problem using 2D Dynamic Programming, we utilize a 2D array `dp[i][j]` to represent whether the substring `s3[:i+j]` can be formed by interleaving `s1[:i]` and `s2[:j]`.\\n\\n## Key Data Structures:\\n- **dp**: A 2D list to store the results of subproblems.\\n\\n## Enhanced Breakdown:\\n\\n1. **Initialization**:\\n   - Calculate lengths of `s1`, `s2`, and `s3`.\\n   - If the sum of lengths of `s1` and `s2` is not equal to the length of `s3`, return false.\\n   - Initialize the `dp` array with dimensions `(m+1) x (n+1)`, setting `dp[0][0] = True`.\\n  \\n2. **Base Cases**:\\n   - Fill in the first row of `dp` array, considering only the characters from `s1`.\\n   - Fill in the first column of `dp` array, considering only the characters from `s2`.\\n   \\n3. **DP Loop**:\\n   - Loop through each possible `(i, j)` combination, starting from `(1, 1)`.\\n   - Update `dp[i][j]` based on the transition `dp[i][j] = (dp[i-1][j] and s1[i-1] == s3[i+j-1]) or (dp[i][j-1] and s2[j-1] == s3[i+j-1])`.\\n\\n4. **Wrap-up**:\\n   - Return the value stored in `dp[m][n]`, which indicates whether `s3` can be formed by interleaving `s1` and `s2`.\\n\\n# Complexity:\\n\\n**Time Complexity:** \\n- The solution iterates over each possible $$ (i, j) $$ combination, leading to a time complexity of $$ O(m \\\\times n) $$.\\n\\n**Space Complexity:** \\n- The space complexity is $$ O(m \\\\times n) $$ due to the 2D $$ dp $$ array.\\n\\n---\\n\\n# Approach: 1D Dynamic Programming \\n\\nThe optimization from 2D to 1D DP is based on the observation that the state of `dp[i][j]` in the 2D DP array depends only on `dp[i-1][j]` and `dp[i][j-1]`. Therefore, while iterating through the strings, the current state only depends on the states in the previous row of the 2D DP array, which means we can optimize our space complexity by just keeping track of one row (1D DP).\\n\\n## Key Data Structures:\\n\\n- **dp**: A 1D list that stores whether the substring `s3[:i+j]` can be formed by interleaving `s1[:i]` and `s2[:j]`. Initially, all values are set to `False` except `dp[0]`, which is set to `True`.\\n\\n## Enhanced Breakdown:\\n\\n1. **Initialization**:\\n   - First, calculate the lengths of `s1`, `s2`, and `s3`.\\n   - Check if the sum of the lengths of `s1` and `s2` equals the length of `s3`. If it doesn\\'t, return `False` as `s3` cannot be formed by interleaving `s1` and `s2`.\\n\\n2. **Optimization Check**:\\n   - If `m < n`, swap `s1` and `s2`. This is to ensure that `s1` is not longer than `s2`, which helps in optimizing the space complexity to `O(min(m, n))`.\\n\\n3. **Base Cases**:\\n   - Initialize a 1D array `dp` of length `n+1` with `False`.\\n   - Set `dp[0] = True` because an empty `s1` and `s2` can interleave to form an empty `s3`.\\n\\n4. **Single-Row DP Transition**:\\n   - Iterate through `s1` and `s2` to update the `dp` array.\\n   - For each character in `s1`, iterate through `s2` and update the `dp` array based on the transition rule: `dp[j] = (dp[j] and s1[i] == s3[i+j]) or (dp[j-1] and s2[j] == s3[i+j])`.\\n   - The transition rule checks if the current `s3[i+j]` can be matched by either `s1[i]` or `s2[j]`, relying solely on the previous values in the `dp` array.\\n\\n5. **Wrap-up**:\\n   - The final value in the `dp` array will indicate whether the entire `s3` can be formed by interleaving `s1` and `s2`.\\n   - Return `dp[n]`.\\n\\n\\n\\n# Complexity:\\n\\nThe primary advantage of this 1D DP approach is its space efficiency. While it maintains the same time complexity as the 2D DP approach $$O(m \\\\times n)$$, the space complexity is optimized to $$O(\\\\min(m, n))$$.\\n\\n**Time Complexity:** \\n- The solution iterates over each character of `s1` and `s2` once, leading to a complexity of $$O(m \\\\times n)$$.\\n\\n**Space Complexity:** \\n- The space complexity is optimized to $$O(\\\\min(m,n))$$ as we\\'re only using a single 1D array instead of a 2D matrix.\\n\\n---\\n\\n# Approach: Recursion with Memoization\\n\\nIn this approach, we recursively check whether the substring `s3[k:]` can be formed by interleaving `s1[i:]` and `s2[j:]`. We store the results of these sub-problems in a dictionary named `memo`.\\n\\n## Key Data Structures:\\n- **memo**: A dictionary to store the results of subproblems.\\n\\n## Enhanced Breakdown:\\n\\n1. **Initialization**:\\n   - Calculate lengths of `s1`, `s2`, and `s3`.\\n   - If the sum of lengths of `s1` and `s2` is not equal to the length of `s3`, return false.\\n   \\n2. **Recursive Function**:\\n   - Define a recursive function `helper` which takes indices `i`, `j`, and `k` as inputs.\\n   - The function checks whether the substring `s3[k:]` can be formed by interleaving `s1[i:]` and `s2[j:]`.\\n   - Store the result of each subproblem in the `memo` dictionary.\\n\\n3. **Wrap-up**:\\n   - Return the result of the recursive function for the initial values `i=0, j=0, k=0`.\\n\\n# Complexity:\\n\\n**Time Complexity:** \\n- Each combination of (i, j) is computed once and stored in the memo, leading to a time complexity of $$O(m \\\\times n)$$.\\n\\n**Space Complexity:** \\n- The space complexity is $$O(m \\\\times n)$$ for storing the memoization results.\\n\\n---\\n\\n# Performance\\n\\n| Language  | Runtime (ms) | Memory (MB) |\\n|-----------|--------------|-------------|\\n| Rust      | 0            | 2.1         |\\n| C++       | 0            | 6.4         |\\n| Go        | 1            | 1.9         |\\n| Java      | 3            | 40.5        |\\n| Python3 (1D DP) | 31     | 16.4        |\\n| Python3 (2D DP) | 34     | 16.5        |\\n| Python3 (Recursion) | 45 | 17.4        |\\n| C#        | 54           | 38.4        |\\n| JavaScript| 61           | 43.1        |\\n\\n![ir.png](https://assets.leetcode.com/users/images/6a85642f-8740-4891-a310-591b172bcee8_1692924054.2926686.png)\\n\\n# Code 1D Dynamic Programming \\n``` Python []\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        m, n, l = len(s1), len(s2), len(s3)\\n        if m + n != l:\\n            return False\\n        \\n        if m < n:\\n            return self.isInterleave(s2, s1, s3)\\n        \\n        dp = [False] * (n + 1)\\n        dp[0] = True\\n        \\n        for j in range(1, n + 1):\\n            dp[j] = dp[j-1] and s2[j-1] == s3[j-1]\\n        \\n        for i in range(1, m + 1):\\n            dp[0] = dp[0] and s1[i-1] == s3[i-1]\\n            for j in range(1, n + 1):\\n                dp[j] = (dp[j] and s1[i-1] == s3[i+j-1]) or (dp[j-1] and s2[j-1] == s3[i+j-1])\\n        \\n        return dp[n]\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int m = s1.length(), n = s2.length(), l = s3.length();\\n        if (m + n != l) return false;\\n        \\n        if (m < n) return isInterleave(s2, s1, s3);\\n\\n        vector<bool> dp(n + 1, false);\\n        dp[0] = true;\\n\\n        for (int j = 1; j <= n; ++j) {\\n            dp[j] = dp[j - 1] && s2[j - 1] == s3[j - 1];\\n        }\\n\\n        for (int i = 1; i <= m; ++i) {\\n            dp[0] = dp[0] && s1[i - 1] == s3[i - 1];\\n            for (int j = 1; j <= n; ++j) {\\n                dp[j] = (dp[j] && s1[i - 1] == s3[i + j - 1]) || (dp[j - 1] && s2[j - 1] == s3[i + j - 1]);\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n```\\n``` Java []\\npublic class Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        int m = s1.length(), n = s2.length(), l = s3.length();\\n        if (m + n != l) return false;\\n\\n        boolean[] dp = new boolean[n + 1];\\n        dp[0] = true;\\n\\n        for (int j = 1; j <= n; ++j) {\\n            dp[j] = dp[j - 1] && s2.charAt(j - 1) == s3.charAt(j - 1);\\n        }\\n\\n        for (int i = 1; i <= m; ++i) {\\n            dp[0] = dp[0] && s1.charAt(i - 1) == s3.charAt(i - 1);\\n            for (int j = 1; j <= n; ++j) {\\n                dp[j] = (dp[j] && s1.charAt(i - 1) == s3.charAt(i + j - 1)) || (dp[j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1));\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n```\\n``` Rust []\\nimpl Solution {\\n    pub fn is_interleave(s1: String, s2: String, s3: String) -> bool {\\n        let (m, n, l) = (s1.len(), s2.len(), s3.len());\\n        if m + n != l { return false; }\\n\\n        let (s1, s2, s3) = (s1.as_bytes(), s2.as_bytes(), s3.as_bytes());\\n        let mut dp = vec![false; n + 1];\\n        dp[0] = true;\\n\\n        for j in 1..=n {\\n            dp[j] = dp[j - 1] && s2[j - 1] == s3[j - 1];\\n        }\\n\\n        for i in 1..=m {\\n            dp[0] = dp[0] && s1[i - 1] == s3[i - 1];\\n            for j in 1..=n {\\n                dp[j] = (dp[j] && s1[i - 1] == s3[i + j - 1]) || (dp[j - 1] && s2[j - 1] == s3[i + j - 1]);\\n            }\\n        }\\n        \\n        dp[n]\\n    }\\n}\\n```\\n``` Go []\\nfunc isInterleave(s1 string, s2 string, s3 string) bool {\\n    m, n, l := len(s1), len(s2), len(s3)\\n    if m + n != l {\\n        return false\\n    }\\n\\n    dp := make([]bool, n+1)\\n    dp[0] = true\\n\\n    for j := 1; j <= n; j++ {\\n        dp[j] = dp[j-1] && s2[j-1] == s3[j-1]\\n    }\\n\\n    for i := 1; i <= m; i++ {\\n        dp[0] = dp[0] && s1[i-1] == s3[i-1]\\n        for j := 1; j <= n; j++ {\\n            dp[j] = (dp[j] && s1[i-1] == s3[i+j-1]) || (dp[j-1] && s2[j-1] == s3[i+j-1])\\n        }\\n    }\\n    \\n    return dp[n]\\n}\\n```\\n``` C# []\\npublic class Solution {\\n    public bool IsInterleave(string s1, string s2, string s3) {\\n        int m = s1.Length, n = s2.Length, l = s3.Length;\\n        if (m + n != l) return false;\\n\\n        bool[] dp = new bool[n + 1];\\n        dp[0] = true;\\n\\n        for (int j = 1; j <= n; ++j) {\\n            dp[j] = dp[j - 1] && s2[j - 1] == s3[j - 1];\\n        }\\n\\n        for (int i = 1; i <= m; ++i) {\\n            dp[0] = dp[0] && s1[i - 1] == s3[i - 1];\\n            for (int j = 1; j <= n; ++j) {\\n                dp[j] = (dp[j] && s1[i - 1] == s3[i + j - 1]) || (dp[j - 1] && s2[j - 1] == s3[i + j - 1]);\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {string} s1\\n * @param {string} s2\\n * @param {string} s3\\n * @return {boolean}\\n */\\nvar isInterleave = function(s1, s2, s3) {\\n    let m = s1.length, n = s2.length, l = s3.length;\\n    if (m + n !== l) return false;\\n\\n    let dp = new Array(n + 1).fill(false);\\n    dp[0] = true;\\n\\n    for (let j = 1; j <= n; ++j) {\\n        dp[j] = dp[j - 1] && s2[j - 1] === s3[j - 1];\\n    }\\n\\n    for (let i = 1; i <= m; ++i) {\\n        dp[0] = dp[0] && s1[i - 1] === s3[i - 1];\\n        for (let j = 1; j <= n; ++j) {\\n            dp[j] = (dp[j] && s1[i - 1] === s3[i + j - 1]) || (dp[j - 1] && s2[j - 1] === s3[i + j - 1]);\\n        }\\n    }\\n    \\n    return dp[n];\\n};\\n```\\n\\n# Code 2D Dynamic Programming \\n``` Python []\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        m, n, l = len(s1), len(s2), len(s3)\\n        if m + n != l:\\n            return False\\n        \\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\\n        dp[0][0] = True\\n        \\n        for i in range(1, m + 1):\\n            dp[i][0] = dp[i-1][0] and s1[i-1] == s3[i-1]\\n        \\n        for j in range(1, n + 1):\\n            dp[0][j] = dp[0][j-1] and s2[j-1] == s3[j-1]\\n        \\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                dp[i][j] = (dp[i-1][j] and s1[i-1] == s3[i+j-1]) or (dp[i][j-1] and s2[j-1] == s3[i+j-1])\\n        \\n        return dp[m][n]\\n\\n```\\n# Code Recursion with Memoization\\n``` Python []\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        m, n, l = len(s1), len(s2), len(s3)\\n        if m + n != l:\\n            return False\\n        \\n        memo = {} \\n        \\n        def helper(i: int, j: int, k: int) -> bool:\\n            if k == l:\\n                return True\\n            \\n            if (i, j) in memo:\\n                return memo[(i, j)]\\n            \\n            ans = False\\n            if i < m and s1[i] == s3[k]:\\n                ans = ans or helper(i + 1, j, k + 1)\\n                \\n            if j < n and s2[j] == s3[k]:\\n                ans = ans or helper(i, j + 1, k + 1)\\n            \\n            memo[(i, j)] = ans\\n            return ans\\n        \\n        return helper(0, 0, 0)\\n```\\n\\nBoth the given approaches provide efficient ways to solve the problem, with the first approach focusing on optimizing space and the second leveraging the power of memoization to save time. Choosing between them depends on the specific constraints and requirements of the application. \\uD83D\\uDCA1\\uD83C\\uDF20\\uD83D\\uDC69\\u200D\\uD83D\\uDCBB\\uD83D\\uDC68\\u200D\\uD83D\\uDCBB",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript",
                    "Go",
                    "Rust",
                    "Dynamic Programming"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        m, n, l = len(s1), len(s2), len(s3)\\n        if m + n != l:\\n            return False\\n        \\n        if m < n:\\n            return self.isInterleave(s2, s1, s3)\\n        \\n        dp = [False] * (n + 1)\\n        dp[0] = True\\n        \\n        for j in range(1, n + 1):\\n            dp[j] = dp[j-1] and s2[j-1] == s3[j-1]\\n        \\n        for i in range(1, m + 1):\\n            dp[0] = dp[0] and s1[i-1] == s3[i-1]\\n            for j in range(1, n + 1):\\n                dp[j] = (dp[j] and s1[i-1] == s3[i+j-1]) or (dp[j-1] and s2[j-1] == s3[i+j-1])\\n        \\n        return dp[n]\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int m = s1.length(), n = s2.length(), l = s3.length();\\n        if (m + n != l) return false;\\n        \\n        if (m < n) return isInterleave(s2, s1, s3);\\n\\n        vector<bool> dp(n + 1, false);\\n        dp[0] = true;\\n\\n        for (int j = 1; j <= n; ++j) {\\n            dp[j] = dp[j - 1] && s2[j - 1] == s3[j - 1];\\n        }\\n\\n        for (int i = 1; i <= m; ++i) {\\n            dp[0] = dp[0] && s1[i - 1] == s3[i - 1];\\n            for (int j = 1; j <= n; ++j) {\\n                dp[j] = (dp[j] && s1[i - 1] == s3[i + j - 1]) || (dp[j - 1] && s2[j - 1] == s3[i + j - 1]);\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n```\n``` Java []\\npublic class Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        int m = s1.length(), n = s2.length(), l = s3.length();\\n        if (m + n != l) return false;\\n\\n        boolean[] dp = new boolean[n + 1];\\n        dp[0] = true;\\n\\n        for (int j = 1; j <= n; ++j) {\\n            dp[j] = dp[j - 1] && s2.charAt(j - 1) == s3.charAt(j - 1);\\n        }\\n\\n        for (int i = 1; i <= m; ++i) {\\n            dp[0] = dp[0] && s1.charAt(i - 1) == s3.charAt(i - 1);\\n            for (int j = 1; j <= n; ++j) {\\n                dp[j] = (dp[j] && s1.charAt(i - 1) == s3.charAt(i + j - 1)) || (dp[j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1));\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n```\n``` Rust []\\nimpl Solution {\\n    pub fn is_interleave(s1: String, s2: String, s3: String) -> bool {\\n        let (m, n, l) = (s1.len(), s2.len(), s3.len());\\n        if m + n != l { return false; }\\n\\n        let (s1, s2, s3) = (s1.as_bytes(), s2.as_bytes(), s3.as_bytes());\\n        let mut dp = vec![false; n + 1];\\n        dp[0] = true;\\n\\n        for j in 1..=n {\\n            dp[j] = dp[j - 1] && s2[j - 1] == s3[j - 1];\\n        }\\n\\n        for i in 1..=m {\\n            dp[0] = dp[0] && s1[i - 1] == s3[i - 1];\\n            for j in 1..=n {\\n                dp[j] = (dp[j] && s1[i - 1] == s3[i + j - 1]) || (dp[j - 1] && s2[j - 1] == s3[i + j - 1]);\\n            }\\n        }\\n        \\n        dp[n]\\n    }\\n}\\n```\n``` Go []\\nfunc isInterleave(s1 string, s2 string, s3 string) bool {\\n    m, n, l := len(s1), len(s2), len(s3)\\n    if m + n != l {\\n        return false\\n    }\\n\\n    dp := make([]bool, n+1)\\n    dp[0] = true\\n\\n    for j := 1; j <= n; j++ {\\n        dp[j] = dp[j-1] && s2[j-1] == s3[j-1]\\n    }\\n\\n    for i := 1; i <= m; i++ {\\n        dp[0] = dp[0] && s1[i-1] == s3[i-1]\\n        for j := 1; j <= n; j++ {\\n            dp[j] = (dp[j] && s1[i-1] == s3[i+j-1]) || (dp[j-1] && s2[j-1] == s3[i+j-1])\\n        }\\n    }\\n    \\n    return dp[n]\\n}\\n```\n``` C# []\\npublic class Solution {\\n    public bool IsInterleave(string s1, string s2, string s3) {\\n        int m = s1.Length, n = s2.Length, l = s3.Length;\\n        if (m + n != l) return false;\\n\\n        bool[] dp = new bool[n + 1];\\n        dp[0] = true;\\n\\n        for (int j = 1; j <= n; ++j) {\\n            dp[j] = dp[j - 1] && s2[j - 1] == s3[j - 1];\\n        }\\n\\n        for (int i = 1; i <= m; ++i) {\\n            dp[0] = dp[0] && s1[i - 1] == s3[i - 1];\\n            for (int j = 1; j <= n; ++j) {\\n                dp[j] = (dp[j] && s1[i - 1] == s3[i + j - 1]) || (dp[j - 1] && s2[j - 1] == s3[i + j - 1]);\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {string} s1\\n * @param {string} s2\\n * @param {string} s3\\n * @return {boolean}\\n */\\nvar isInterleave = function(s1, s2, s3) {\\n    let m = s1.length, n = s2.length, l = s3.length;\\n    if (m + n !== l) return false;\\n\\n    let dp = new Array(n + 1).fill(false);\\n    dp[0] = true;\\n\\n    for (let j = 1; j <= n; ++j) {\\n        dp[j] = dp[j - 1] && s2[j - 1] === s3[j - 1];\\n    }\\n\\n    for (let i = 1; i <= m; ++i) {\\n        dp[0] = dp[0] && s1[i - 1] === s3[i - 1];\\n        for (let j = 1; j <= n; ++j) {\\n            dp[j] = (dp[j] && s1[i - 1] === s3[i + j - 1]) || (dp[j - 1] && s2[j - 1] === s3[i + j - 1]);\\n        }\\n    }\\n    \\n    return dp[n];\\n};\\n```\n``` Python []\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        m, n, l = len(s1), len(s2), len(s3)\\n        if m + n != l:\\n            return False\\n        \\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\\n        dp[0][0] = True\\n        \\n        for i in range(1, m + 1):\\n            dp[i][0] = dp[i-1][0] and s1[i-1] == s3[i-1]\\n        \\n        for j in range(1, n + 1):\\n            dp[0][j] = dp[0][j-1] and s2[j-1] == s3[j-1]\\n        \\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                dp[i][j] = (dp[i-1][j] and s1[i-1] == s3[i+j-1]) or (dp[i][j-1] and s2[j-1] == s3[i+j-1])\\n        \\n        return dp[m][n]\\n\\n```\n``` Python []\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        m, n, l = len(s1), len(s2), len(s3)\\n        if m + n != l:\\n            return False\\n        \\n        memo = {} \\n        \\n        def helper(i: int, j: int, k: int) -> bool:\\n            if k == l:\\n                return True\\n            \\n            if (i, j) in memo:\\n                return memo[(i, j)]\\n            \\n            ans = False\\n            if i < m and s1[i] == s3[k]:\\n                ans = ans or helper(i + 1, j, k + 1)\\n                \\n            if j < n and s2[j] == s3[k]:\\n                ans = ans or helper(i, j + 1, k + 1)\\n            \\n            memo[(i, j)] = ans\\n            return ans\\n        \\n        return helper(0, 0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32078,
                "title": "dp-solution-in-java",
                "content": "    public boolean isInterleave(String s1, String s2, String s3) {\\n\\n        if ((s1.length()+s2.length())!=s3.length()) return false;\\n\\n        boolean[][] matrix = new boolean[s2.length()+1][s1.length()+1];\\n\\n        matrix[0][0] = true;\\n\\n        for (int i = 1; i < matrix[0].length; i++){\\n            matrix[0][i] = matrix[0][i-1]&&(s1.charAt(i-1)==s3.charAt(i-1));\\n        }\\n\\n        for (int i = 1; i < matrix.length; i++){\\n            matrix[i][0] = matrix[i-1][0]&&(s2.charAt(i-1)==s3.charAt(i-1));\\n        }\\n\\n        for (int i = 1; i < matrix.length; i++){\\n            for (int j = 1; j < matrix[0].length; j++){\\n                matrix[i][j] = (matrix[i-1][j]&&(s2.charAt(i-1)==s3.charAt(i+j-1)))\\n                        || (matrix[i][j-1]&&(s1.charAt(j-1)==s3.charAt(i+j-1)));\\n            }\\n        }\\n\\n        return matrix[s2.length()][s1.length()];\\n\\n    }",
                "solutionTags": [],
                "code": "    public boolean isInterleave(String s1, String s2, String s3) {\\n\\n        if ((s1.length()+s2.length())!=s3.length()) return false;\\n\\n        boolean[][] matrix = new boolean[s2.length()+1][s1.length()+1];\\n\\n        matrix[0][0] = true;\\n\\n        for (int i = 1; i < matrix[0].length; i++){\\n            matrix[0][i] = matrix[0][i-1]&&(s1.charAt(i-1)==s3.charAt(i-1));\\n        }\\n\\n        for (int i = 1; i < matrix.length; i++){\\n            matrix[i][0] = matrix[i-1][0]&&(s2.charAt(i-1)==s3.charAt(i-1));\\n        }\\n\\n        for (int i = 1; i < matrix.length; i++){\\n            for (int j = 1; j < matrix[0].length; j++){\\n                matrix[i][j] = (matrix[i-1][j]&&(s2.charAt(i-1)==s3.charAt(i+j-1)))\\n                        || (matrix[i][j-1]&&(s1.charAt(j-1)==s3.charAt(i+j-1)));\\n            }\\n        }\\n\\n        return matrix[s2.length()][s1.length()];\\n\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2248553,
                "title": "c-recursive-memoization-code-with-explanation",
                "content": "### Recursive Solution:  (Gives TLE)\\nTraverse all the three strings from end.\\n**Base case**: When the lengths of all the strings become less than 0 (**Note**: Not less than or equal to 0, that will give a wrong answer in the case when s1=\"a\", s2=\" \", s3=\"c\" ) \\nThere are three cases:\\n- **Case 1**:  If both the last characters of s1 and s2 are equal to the last character of s3, then we have 2 choices, we can either pick last character of s1 or the last character of s2. \\n- **Case2**: If the last characters of s1 and s3 are equal, then We\\'ll simply reduce the length of s1 and s3 by 1(meaning, we\\'ll exclude both of the last characters and make the call for rest of the string)\\n- **Case3**:  If the last characters of s2 and s3 are equal, then We\\'ll simply reduce the length of s2 and s3 by 1(meaning, we\\'ll exclude both of the last characters and make the call for rest of the string).\\n\\nIf any of these cases does\\'t hold true, then return false (as none of the characters match).\\n\\n```\\nclass Solution {\\npublic:\\n    bool helper(string& s1, string& s2, string &s3, int l1, int l2, int l3) {\\n        if(l1<0 && l2<0 && l3<0) {\\n            return true;\\n        }\\n        if(l1>=0 && s1[l1]==s3[l3] && l2>=0 && s2[l2]==s3[l3] ) {\\n            return (helper(s1, s2, s3, l1-1, l2, l3-1) || helper(s1, s2, s3, l1, l2-1, l3-1));\\n        }\\n        else if(l1>=0 && s1[l1]==s3[l3])\\n            return helper(s1, s2, s3, l1-1, l2, l3-1);\\n        \\n        else if(l2>=0 &&s2[l2]==s3[l3])\\n            return helper(s1, s2, s3, l1, l2-1, l3-1);\\n        \\n        else return false;\\n    }\\n    \\n    bool isInterleave(string s1, string s2, string s3) {\\n        if(s3.size() != s1.size() + s2.size())\\n\\t\\t\\treturn false;\\n        return helper(s1, s2, s3,s1.size()-1, s2.size()-1, s3.size()-1);\\n    }\\n};\\n```\\n### Recusive solution to MEMOIZATION: (Accepted)\\n```\\nclass Solution {\\npublic:\\n    // int dp[102][102];\\n    bool helper(string& s1, string& s2, string &s3, int l1, int l2, int l3, vector<vector<int>>&dp) {\\n        if(l1<0 && l2<0 && l3<0) {\\n            return true;\\n        }\\n        if(l1>=0 && l2>=0 && dp[l1][l2]!=-1) {\\n            return dp[l1][l2];\\n        }\\n        if(l1>=0 && s1[l1]==s3[l3] && l2>=0 && s2[l2]==s3[l3] ) {\\n            return dp[l1][l2] = (helper(s1, s2, s3, l1-1, l2, l3-1, dp) || helper(s1, s2, s3, l1, l2-1, l3-1, dp));\\n        }\\n        else if(l1>=0 && s1[l1]==s3[l3])\\n            return helper(s1, s2, s3, l1-1, l2, l3-1, dp);\\n        \\n        else if(l2>=0 &&s2[l2]==s3[l3])\\n            return helper(s1, s2, s3, l1, l2-1, l3-1, dp);\\n        \\n        else return false;\\n    }\\n    \\n    bool isInterleave(string s1, string s2, string s3) {\\n        if(s3.size() != s1.size() + s2.size())\\n\\t\\t\\treturn false;\\n        vector<vector<int>>dp(s1.size()+1, (vector<int>(s2.size()+1, -1)));\\n        // memset(dp, -1, sizeof(dp));\\n        return helper(s1, s2, s3,s1.size()-1, s2.size()-1, s3.size()-1, dp);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "String",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool helper(string& s1, string& s2, string &s3, int l1, int l2, int l3) {\\n        if(l1<0 && l2<0 && l3<0) {\\n            return true;\\n        }\\n        if(l1>=0 && s1[l1]==s3[l3] && l2>=0 && s2[l2]==s3[l3] ) {\\n            return (helper(s1, s2, s3, l1-1, l2, l3-1) || helper(s1, s2, s3, l1, l2-1, l3-1));\\n        }\\n        else if(l1>=0 && s1[l1]==s3[l3])\\n            return helper(s1, s2, s3, l1-1, l2, l3-1);\\n        \\n        else if(l2>=0 &&s2[l2]==s3[l3])\\n            return helper(s1, s2, s3, l1, l2-1, l3-1);\\n        \\n        else return false;\\n    }\\n    \\n    bool isInterleave(string s1, string s2, string s3) {\\n        if(s3.size() != s1.size() + s2.size())\\n\\t\\t\\treturn false;\\n        return helper(s1, s2, s3,s1.size()-1, s2.size()-1, s3.size()-1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    // int dp[102][102];\\n    bool helper(string& s1, string& s2, string &s3, int l1, int l2, int l3, vector<vector<int>>&dp) {\\n        if(l1<0 && l2<0 && l3<0) {\\n            return true;\\n        }\\n        if(l1>=0 && l2>=0 && dp[l1][l2]!=-1) {\\n            return dp[l1][l2];\\n        }\\n        if(l1>=0 && s1[l1]==s3[l3] && l2>=0 && s2[l2]==s3[l3] ) {\\n            return dp[l1][l2] = (helper(s1, s2, s3, l1-1, l2, l3-1, dp) || helper(s1, s2, s3, l1, l2-1, l3-1, dp));\\n        }\\n        else if(l1>=0 && s1[l1]==s3[l3])\\n            return helper(s1, s2, s3, l1-1, l2, l3-1, dp);\\n        \\n        else if(l2>=0 &&s2[l2]==s3[l3])\\n            return helper(s1, s2, s3, l1, l2-1, l3-1, dp);\\n        \\n        else return false;\\n    }\\n    \\n    bool isInterleave(string s1, string s2, string s3) {\\n        if(s3.size() != s1.size() + s2.size())\\n\\t\\t\\treturn false;\\n        vector<vector<int>>dp(s1.size()+1, (vector<int>(s2.size()+1, -1)));\\n        // memset(dp, -1, sizeof(dp));\\n        return helper(s1, s2, s3,s1.size()-1, s2.size()-1, s3.size()-1, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1247494,
                "title": "python-3-from-top-down-to-bottom-up-2d-to-1d-space",
                "content": "**\\u2714\\uFE0F Solution 1: Top-down DP**\\n```python\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3): return False\\n        m, n = len(s1), len(s2)\\n        \\n        @lru_cache(None)\\n        def dp(i, j):\\n            if i == m and j == n: return True  # Found a valid match\\n            ans = False\\n            if i < m and s1[i] == s3[i+j]:  # Case match s1[i] with s3[i+j]\\n                ans |= dp(i + 1, j)\\n            if j < n and s2[j] == s3[i+j]:  # Case match s2[j] with s3[i+j]\\n                ans |= dp(i, j + 1)\\n            return ans\\n\\n        return dp(0, 0)\\n```\\nComplexity:\\n- Time: `O(m*n)`, where `m` is length of string `s1`, `n` is length of string `s2`\\n- Space: `O(m*n)`\\n---\\n\\n**\\u2714\\uFE0F Solution 2: Bottom-up DP**\\n```python\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3): return False\\n\\n        m, n = len(s1), len(s2)\\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\\n        dp[m][n] = True\\n        for i in range(m, -1, -1):\\n            for j in range(n, -1, -1):\\n                if i < m and s1[i] == s3[i + j]:\\n                    dp[i][j] |= dp[i + 1][j]\\n                if j < n and s2[j] == s3[i + j]:\\n                    dp[i][j] |= dp[i][j + 1]\\n        return dp[0][0]\\n```\\nComplexity:\\n- Time: `O(m*n)`, where `m` is length of string `s1`, `n` is length of string `s2`\\n- Space: `O(m*n)`\\n\\n---\\n**\\u2714\\uFE0F Solution 3: Bottom-up DP (Space Optimized)**\\n```python\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3): return False\\n\\n        m, n = len(s1), len(s2)\\n        dp, dpPrev = [False] * (n + 1), [False] * (n + 1)\\n        for i in range(m, -1, -1):\\n            for j in range(n, -1, -1):\\n                dp[j] = False\\n                if i == m and j == n:\\n                    dp[n] = True\\n                if i < m and s1[i] == s3[i + j]:\\n                    dp[j] |= dpPrev[j]\\n                if j < n and s2[j] == s3[i + j]:\\n                    dp[j] |= dp[j + 1]\\n            dp, dpPrev = dpPrev, dp\\n        return dpPrev[0]\\n```\\nComplexity:\\n- Time: `O(m*n)`, where `m` is length of string `s1`, `n` is length of string `s2`\\n- Space: `O(n)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3): return False\\n        m, n = len(s1), len(s2)\\n        \\n        @lru_cache(None)\\n        def dp(i, j):\\n            if i == m and j == n: return True  # Found a valid match\\n            ans = False\\n            if i < m and s1[i] == s3[i+j]:  # Case match s1[i] with s3[i+j]\\n                ans |= dp(i + 1, j)\\n            if j < n and s2[j] == s3[i+j]:  # Case match s2[j] with s3[i+j]\\n                ans |= dp(i, j + 1)\\n            return ans\\n\\n        return dp(0, 0)\\n```\n```python\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3): return False\\n\\n        m, n = len(s1), len(s2)\\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\\n        dp[m][n] = True\\n        for i in range(m, -1, -1):\\n            for j in range(n, -1, -1):\\n                if i < m and s1[i] == s3[i + j]:\\n                    dp[i][j] |= dp[i + 1][j]\\n                if j < n and s2[j] == s3[i + j]:\\n                    dp[i][j] |= dp[i][j + 1]\\n        return dp[0][0]\\n```\n```python\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3): return False\\n\\n        m, n = len(s1), len(s2)\\n        dp, dpPrev = [False] * (n + 1), [False] * (n + 1)\\n        for i in range(m, -1, -1):\\n            for j in range(n, -1, -1):\\n                dp[j] = False\\n                if i == m and j == n:\\n                    dp[n] = True\\n                if i < m and s1[i] == s3[i + j]:\\n                    dp[j] |= dpPrev[j]\\n                if j < n and s2[j] == s3[i + j]:\\n                    dp[j] |= dp[j + 1]\\n            dp, dpPrev = dpPrev, dp\\n        return dpPrev[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1247165,
                "title": "c-memoizn-3-variables-memoizn-without-3rd-var-dp-m-n-dp-n",
                "content": "```\\n//Approach-1 (Recursion + Memoization (i, j, k))\\nclass Solution {\\npublic:\\n    int m, n, N;\\n    int t[101][101][201];\\n    bool check(string s1, string s2, string s3, int i, int j, int k) {\\n        if(i >= m && j >= n && k >= N) //solution\\n            return true;\\n        \\n        if(k >= N) //other string didn\\'t get consumed whole\\n            return false;\\n            \\n        if(t[i][j][k] != -1)\\n            return t[i][j][k];\\n        \\n        return t[i][j][k] = ((s1[i]==s3[k] && check(s1, s2, s3, i+1, j, k+1)) || (s2[j]==s3[k] && check(s1, s2, s3, i, j+1, k+1)));\\n    }\\n    bool isInterleave(string s1, string s2, string s3) {\\n        memset(t, -1, sizeof(t));\\n        m = s1.length();\\n        n = s2.length();\\n        N = s3.length();\\n        \\n        return check(s1, s2, s3, 0, 0, 0);\\n    }\\n};\\n```\\n\\n```\\n//Approach-2 (Recursion + Memoization (i, j))\\nclass Solution {\\npublic:\\n    int m, n, N;\\n    int t[101][101];\\n    \\n    bool check(string s1, string s2, string s3, int i, int j) {\\n        if(i >= m && j >= n && i+j >= N) //solution\\n            return true;\\n        \\n        if(i+j >= N) //other string didn\\'t get consumed whole\\n            return false;\\n            \\n        if(t[i][j] != -1)\\n            return t[i][j];\\n        \\n        //Note that, k is same for both calls because it increases in both cases\\n        //Also, at any time k = i + j;\\n        return t[i][j] = ((s1[i]==s3[i+j] && check(s1, s2, s3, i+1, j)) || (s2[j]==s3[i+j] && check(s1, s2, s3, i, j+1)));\\n    }\\n    bool isInterleave(string s1, string s2, string s3) {\\n        memset(t, -1, sizeof(t));\\n        m = s1.length();\\n        n = s2.length();\\n        N = s3.length();\\n        \\n        if(m + n != N)\\n            return false;\\n        \\n        return check(s1, s2, s3, 0, 0);\\n    }\\n};\\n```\\n\\n```\\n//Approach - 3 (Bottom Up : Time and Space : O(m*n))\\nclass Solution {\\npublic:   \\n    bool check(string& s1, string& s2, string& s3) {\\n        int m = s1.length();\\n        int n = s2.length();\\n        int N = s3.length();\\n        if(m + n != N)\\n            return false;\\n        \\n        int t[m+1][n+1];\\n        //t[i][j] = true; //means, s1[0..i] and s2[0...j] interleaves with s3 till (i+j)\\n        \\n        //length of s1 = 0, s2 = 0 and s3 = 0 + 0, i.e. 0 . So obviously it\\'s interleaved :-)\\n        t[0][0] = true;\\n        \\n        //When s1 is of 0 length, we can interleave only when s2 forms s3\\n        for(int j = 1; j<n+1; j++) {\\n            t[0][j] = t[0][j-1] && s2[j-1]==s3[j-1];\\n        }\\n        \\n        //When s2 is of 0 length, we can interleave only if s1 forms s3\\n        for(int i = 1; i<m+1; i++) {\\n            t[i][0] = t[i-1][0] && s1[i-1]==s3[i-1];\\n        }\\n        \\n        \\n        for(int i = 1; i<m+1; i++) {\\n            for(int j = 1; j<n+1; j++) {\\n                int k = i + j - 1;\\n                \\n                bool s1_equals_s3  = t[i-1][j] && s1[i-1] == s3[k]; //Try with s1\\n                \\n                bool s2_equals_s3  = t[i][j-1] && s2[j-1] == s3[k]; //Try with s2\\n                \\n                t[i][j] = s1_equals_s3 || s2_equals_s3 ;\\n            }\\n        }\\n        \\n        return t[m][n];\\n    }\\n    \\n    bool isInterleave(string s1, string s2, string s3) {\\n        return check(s1, s2, s3);\\n    }\\n};\\n```\\n\\n```\\n//Approach - 4 (Bottom Up : Space O(n), Time O(m*n) : Converting Approach-3 to O(n) space approach)\\nclass Solution {\\npublic:   \\n    bool check(string& s1, string& s2, string& s3) {\\n        int m = s1.length();\\n        int n = s2.length();\\n        int N = s3.length();\\n        if(m + n != N)\\n            return false;\\n        \\n        bool t[n+1];\\n        \\n        \\n        for(int i = 0; i<m+1; i++) {\\n            for(int j = 0; j<n+1; j++) {\\n                if(i == 0 && j == 0) {\\n                    t[j] = true;\\n                } else if(i == 0) {\\n                    t[j] = t[j-1] && s2[j-1]==s3[i+j-1];\\n                } else if (j == 0) {\\n                    t[j] = t[j] && s1[i-1]==s3[i+j-1];\\n                } else {\\n                    t[j] = (t[j-1] && s2[j-1]==s3[i+j-1]) || (t[j] && s1[i-1]==s3[i+j-1]);\\n                }\\n            }\\n        }\\n        \\n        return t[n];\\n    }\\n    \\n    bool isInterleave(string s1, string s2, string s3) {\\n        return check(s1, s2, s3);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (Recursion + Memoization (i, j, k))\\nclass Solution {\\npublic:\\n    int m, n, N;\\n    int t[101][101][201];\\n    bool check(string s1, string s2, string s3, int i, int j, int k) {\\n        if(i >= m && j >= n && k >= N) //solution\\n            return true;\\n        \\n        if(k >= N) //other string didn\\'t get consumed whole\\n            return false;\\n            \\n        if(t[i][j][k] != -1)\\n            return t[i][j][k];\\n        \\n        return t[i][j][k] = ((s1[i]==s3[k] && check(s1, s2, s3, i+1, j, k+1)) || (s2[j]==s3[k] && check(s1, s2, s3, i, j+1, k+1)));\\n    }\\n    bool isInterleave(string s1, string s2, string s3) {\\n        memset(t, -1, sizeof(t));\\n        m = s1.length();\\n        n = s2.length();\\n        N = s3.length();\\n        \\n        return check(s1, s2, s3, 0, 0, 0);\\n    }\\n};\\n```\n```\\n//Approach-2 (Recursion + Memoization (i, j))\\nclass Solution {\\npublic:\\n    int m, n, N;\\n    int t[101][101];\\n    \\n    bool check(string s1, string s2, string s3, int i, int j) {\\n        if(i >= m && j >= n && i+j >= N) //solution\\n            return true;\\n        \\n        if(i+j >= N) //other string didn\\'t get consumed whole\\n            return false;\\n            \\n        if(t[i][j] != -1)\\n            return t[i][j];\\n        \\n        //Note that, k is same for both calls because it increases in both cases\\n        //Also, at any time k = i + j;\\n        return t[i][j] = ((s1[i]==s3[i+j] && check(s1, s2, s3, i+1, j)) || (s2[j]==s3[i+j] && check(s1, s2, s3, i, j+1)));\\n    }\\n    bool isInterleave(string s1, string s2, string s3) {\\n        memset(t, -1, sizeof(t));\\n        m = s1.length();\\n        n = s2.length();\\n        N = s3.length();\\n        \\n        if(m + n != N)\\n            return false;\\n        \\n        return check(s1, s2, s3, 0, 0);\\n    }\\n};\\n```\n```\\n//Approach - 3 (Bottom Up : Time and Space : O(m*n))\\nclass Solution {\\npublic:   \\n    bool check(string& s1, string& s2, string& s3) {\\n        int m = s1.length();\\n        int n = s2.length();\\n        int N = s3.length();\\n        if(m + n != N)\\n            return false;\\n        \\n        int t[m+1][n+1];\\n        //t[i][j] = true; //means, s1[0..i] and s2[0...j] interleaves with s3 till (i+j)\\n        \\n        //length of s1 = 0, s2 = 0 and s3 = 0 + 0, i.e. 0 . So obviously it\\'s interleaved :-)\\n        t[0][0] = true;\\n        \\n        //When s1 is of 0 length, we can interleave only when s2 forms s3\\n        for(int j = 1; j<n+1; j++) {\\n            t[0][j] = t[0][j-1] && s2[j-1]==s3[j-1];\\n        }\\n        \\n        //When s2 is of 0 length, we can interleave only if s1 forms s3\\n        for(int i = 1; i<m+1; i++) {\\n            t[i][0] = t[i-1][0] && s1[i-1]==s3[i-1];\\n        }\\n        \\n        \\n        for(int i = 1; i<m+1; i++) {\\n            for(int j = 1; j<n+1; j++) {\\n                int k = i + j - 1;\\n                \\n                bool s1_equals_s3  = t[i-1][j] && s1[i-1] == s3[k]; //Try with s1\\n                \\n                bool s2_equals_s3  = t[i][j-1] && s2[j-1] == s3[k]; //Try with s2\\n                \\n                t[i][j] = s1_equals_s3 || s2_equals_s3 ;\\n            }\\n        }\\n        \\n        return t[m][n];\\n    }\\n    \\n    bool isInterleave(string s1, string s2, string s3) {\\n        return check(s1, s2, s3);\\n    }\\n};\\n```\n```\\n//Approach - 4 (Bottom Up : Space O(n), Time O(m*n) : Converting Approach-3 to O(n) space approach)\\nclass Solution {\\npublic:   \\n    bool check(string& s1, string& s2, string& s3) {\\n        int m = s1.length();\\n        int n = s2.length();\\n        int N = s3.length();\\n        if(m + n != N)\\n            return false;\\n        \\n        bool t[n+1];\\n        \\n        \\n        for(int i = 0; i<m+1; i++) {\\n            for(int j = 0; j<n+1; j++) {\\n                if(i == 0 && j == 0) {\\n                    t[j] = true;\\n                } else if(i == 0) {\\n                    t[j] = t[j-1] && s2[j-1]==s3[i+j-1];\\n                } else if (j == 0) {\\n                    t[j] = t[j] && s1[i-1]==s3[i+j-1];\\n                } else {\\n                    t[j] = (t[j-1] && s2[j-1]==s3[i+j-1]) || (t[j] && s1[i-1]==s3[i+j-1]);\\n                }\\n            }\\n        }\\n        \\n        return t[n];\\n    }\\n    \\n    bool isInterleave(string s1, string s2, string s3) {\\n        return check(s1, s2, s3);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1246649,
                "title": "python-3-lines-dp-explained",
                "content": "In `dp(i, j)` we keep `1` if it is possible to form string `s3` upto `i+j` symbol from first `i` elements of `s1` and first `j` elements of `s2`. Every moment we need to check two at most two neighbors: `dp(i, j - 1)` and `dp(i - 1, j)`: we need to check if symbol `s[i+j+1]` is equal to `s2[j]` and answer is true for `dp(i, j-1)` and `j >= 0`, or similar condition for another string.\\n\\n#### Complexity\\nTime complexity is `O(mn)`, because we have `mn` states and two transactions from one state to others. Space complexity is `O(mn)` as well, which can be reduced to `O(m + n)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def isInterleave(self, s1, s2, s3):\\n        @lru_cache(None)\\n        def dp(i, j):\\n            if i == -1 and j == -1: return True\\n            return (j >= 0 and s2[j] == s3[i+j+1] and dp(i, j-1)) or (i >= 0 and s1[i] == s3[i+j+1] and dp(i-1,j))\\n        \\n        return len(s1) + len(s2) == len(s3) and dp(len(s1) - 1, len(s2) - 1)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def isInterleave(self, s1, s2, s3):\\n        @lru_cache(None)\\n        def dp(i, j):\\n            if i == -1 and j == -1: return True\\n            return (j >= 0 and s2[j] == s3[i+j+1] and dp(i, j-1)) or (i >= 0 and s1[i] == s3[i+j+1] and dp(i-1,j))\\n        \\n        return len(s1) + len(s2) == len(s3) and dp(len(s1) - 1, len(s2) - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31901,
                "title": "c-dp-solution-with-explanation",
                "content": "First tried brute force backtracking, it's obvious will not be accepted.\\n\\n    class Solution {\\n    public:\\n        bool isInterleave(string s1, string s2, string s3) {\\n            int n1 = s1.size(), n2 = s2.size(), n3 = s3.size();\\n            if(n1 + n2 != n3) return false;\\n            return isInterleaveHelper(s1, 0, n1, s2, 0, n2, s3, 0, n3);\\n        }\\n        \\n        bool isInterleaveHelper(string &s1, int i1, int n1, string &s2, int i2, int n2, string &s3, int i3, int n3){\\n            if(i1 == n1 && i2 == n2 && i3 == n3) return true; \\n            if(i1 < n1 && s1[i1] == s3[i3] && isInterleaveHelper(s1, i1 + 1, n1, s2, i2, n2, s3, i3 + 1, n3)) return true;\\n            if(i2 < n2 && s2[i2] == s3[i3] && isInterleaveHelper(s1, i1, n1, s2, i2 + 1, n2, s3, i3 + 1, n3)) return true;\\n            else return false;\\n        }\\n    };\\n\\n\\nThen it comes to dp solution. I first built a two dimension dp table, with drawing the path displayed below. Because it's interleaving, so certain order still needs to maintain, so that's why for a valid path, it can only go right or down, so that's why `dp[i1][i2]` is depending on `dp[i1 - 1][i2]` and `dp[i1][i2 - 1]`. After discovering the transition rule to get `dp[i1][i2]`, we just need to record true or false in the dp table. `dp[i1][i2]` means if `s3.substr(0, i1 + i2)` can be formed by `s1.substr(0, i1)` interleaving `s2.substr(0, i2)`;\\n\\n    s3 = \\u201caadbbcbcac\\u201d\\n                     a\\t    a\\t    b\\t    c\\t   c\\n    \\t\\t    0\\t 1\\t    2\\t    3\\t    4\\t   5\\n    \\n         \\t0\\t\\u201c\\u201d\\u2192\\t a  \\u2192   aa\\t\\n    \\t\\t\\t\\t        \\u2193\\n       d\\t1\\t\\t\\t    aad  \\u2192  aadb\\n    \\t\\t\\t\\t        \\u2193\\t    \\u2193\\n       b\\t2\\t\\t\\t    aadb \\u2192  aadbb \\u2192 aadbbc\\n    \\t\\t\\t\\t        \\u2193\\t\\t\\u2193\\n       b\\t3\\t\\t\\t    aadbb\\taadbbcb\\n    \\t\\t\\t\\t        \\u2193\\n       c\\t4\\t\\t\\t    aadbbc\\u2192 aadbbcb\\n    \\n       a\\t5\\n\\n\\ncode, O(n1n2) space, and O(n1n2)time, it's much better than the brute force now. \\n\\n    class Solution {\\n    public:\\n        bool isInterleave(string s1, string s2, string s3) {\\n            int n1 = (int)s1.size(), n2 = (int)s2.size(), n3 = (int)s3.size(); \\n            if(n1 + n2 != n3) return false;\\n            \\n            vector<vector<bool>> dp(n1 + 1, vector<bool>(n2 + 1, false));\\n            dp[0][0] = true;\\n            \\n            for(int i2 = 1; i2 <= n2; i2++) dp[0][i2] = dp[0][i2 - 1] && s2[i2 - 1] == s3[i2 - 1];\\n            for(int i1 = 1; i1 <= n1; i1++) dp[i1][0] = dp[i1 - 1][0] && s1[i1 - 1] == s3[i1 - 1];\\n    \\n            for(int i1 = 1; i1 <= n1; i1++){\\n                for(int i2 = 1; i2 <= n2; i2++){\\n                    dp[i1][i2] = (dp[i1 - 1][i2] && s1[i1 - 1] == s3[i1 + i2 - 1]) || (dp[i1][i2 - 1] && s2[i2 - 1] == s3[i1 + i2 - 1]);\\n                }\\n            }\\n            \\n            return dp[n1][n2];  \\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public:\\n        bool isInterleave(string s1, string s2, string s3) {\\n            int n1 = s1.size(), n2 = s2.size(), n3 = s3.size();\\n            if(n1 + n2 != n3) return false;\\n            return isInterleaveHelper(s1, 0, n1, s2, 0, n2, s3, 0, n3);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 31904,
                "title": "summary-of-solutions-bfs-dfs-dp",
                "content": "## BFS solution (6ms)\\n\\nImagine a grid, which x-axis and y-axis are s1 and s2, matching s3 is the same as\\nfinding a path from (0,0) to (len1, len2). It actually becomes a\\nBFS on grid. Since we don't need exact paths, a HashSet of\\ncoordinates is used to eliminate duplicated paths.\\n\\n    public class Solution {\\n        public boolean isInterleave(String s1, String s2, String s3) {\\n            int len1 = s1.length(),\\n                len2 = s2.length(),\\n                len3 = s3.length();\\n            if (len1 + len2 != len3) return false;\\n            Deque<Integer> queue = new LinkedList<>();\\n            int matched = 0;\\n            queue.offer(0);\\n            Set<Integer> set = new HashSet<>();\\n            while (queue.size() > 0 && matched < len3) {\\n                int size = queue.size();\\n                for (int i = 0; i < size; i++) {\\n                    int p1 = queue.peek() / len3,\\n                        p2 = queue.peek() % len3;\\n                    queue.poll();\\n                    if (p1 < len1 && s1.charAt(p1) == s3.charAt(matched)) {\\n                        int key = (p1 + 1) * len3 + p2;\\n                        if (!set.contains(key)) {\\n                            set.add(key);\\n                            queue.offer(key);\\n                        }\\n                    }\\n                    if (p2 < len2 && s2.charAt(p2) == s3.charAt(matched)) {\\n                        int key = p1 * len3 + (p2 + 1);\\n                        if (!set.contains(key)) {\\n                            set.add(key);\\n                            queue.offer(key);\\n                        }\\n                    }\\n                }\\n                matched++;\\n            }\\n            return queue.size() > 0 && matched == len3;\\n        }\\n    }\\n\\n## DFS solution with memorization (2ms)\\n\\nThis looks slow but is actually faster than BFS! Think about it carefully, in this\\nparticular problem, search always ends at the same depth. DFS with memorization\\nsearches about the same amount of paths with the same length as BFS, if it is doesn't\\nterminate on the first path found. Without the queue operations, the overall cost\\nis only smaller if we don't count call stack. The most significant runtime reducer is\\nprobably the early termination\\n\\n    public class Solution {\\n        public boolean isInterleave(String s1, String s2, String s3) {\\n            if (s1.length() + s2.length() != s3.length()) return false;\\n            HashSet<Integer> cache = new HashSet<Integer>();\\n            return isInterleave0(s1, s2, s3, 0, 0, cache);\\n        }\\n\\n        private boolean isInterleave0(String s1, String s2, String s3, int p1, int p2, HashSet<Integer> cache) {\\n            if (p1 + p2 == s3.length())\\n                return true;\\n            if (cache.contains(p1 * s3.length() + p2))\\n                return false;\\n            // no need to store actual result.\\n            // if we found the path, we have already terminated.\\n            cache.add(p1 * s3.length() + p2);\\n            boolean match1 = p1 < s1.length() && s3.charAt(p1 + p2) == s1.charAt(p1);\\n            boolean match2 = p2 < s2.length() && s3.charAt(p1 + p2) == s2.charAt(p2);\\n            if (match1 && match2)\\n                return isInterleave0(s1, s2, s3, p1 + 1, p2, cache) ||\\n                       isInterleave0(s1, s2, s3, p1, p2 + 1, cache);\\n            else if (match1)\\n                return isInterleave0(s1, s2, s3, p1 + 1, p2, cache);\\n            else if (match2)\\n                return isInterleave0(s1, s2, s3, p1, p2 + 1, cache);\\n            else\\n                return false;\\n        }\\n    }\\n\\n## 2d DP solution (6ms)\\n\\nIt's an interesting practice. There are further optimization could be done to\\nreduce cache matrix to 1d. However doing DP for this problem is tedious and not\\nseem to worth the trouble.\\n\\n    public class Solution {\\n        public boolean isInterleave(String s1, String s2, String s3) {\\n            int len1 = s1.length(),\\n                len2 = s2.length(),\\n                len3 = s3.length();\\n            if (len1 + len2 != len3) return false;\\n            // cache[i][j] == true means first i + j chars are matched by\\n            // first j chars from s1 and first i chars from s2\\n            boolean[][] cache = new boolean[len2 + 1][len1 + 1];\\n            cache[0][0] = true; // empty and empty matches empty\\n            int m3 = 1; // matched length, m1 and m2 are similar\\n            while (m3 <= len3) {\\n                // this loop fill in cache matrix from left-top to right-bottom, diagonally.\\n                // note that loop conditions are pretty tricky here.\\n                for (int m1 = Math.max(m3 - len2, 0); m1 <= len1 && m1 <= m3; m1++) {\\n                    int m2 = m3 - m1;\\n                    cache[m2][m1] =\\n                        m1 > 0 && cache[m2][m1 - 1] && s3.charAt(m3 - 1) == s1.charAt(m1 - 1) ||\\n                        m2 > 0 && cache[m2 - 1][m1] && s3.charAt(m3 - 1) == s2.charAt(m2 - 1);\\n                }\\n                m3++;\\n            }\\n            return cache[len2][len1];\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n        public boolean isInterleave(String s1, String s2, String s3) {\\n            int len1 = s1.length(),\\n                len2 = s2.length(),\\n                len3 = s3.length();\\n            if (len1 + len2 != len3) return false;\\n            Deque<Integer> queue = new LinkedList<>();\\n            int matched = 0;\\n            queue.offer(0);\\n            Set<Integer> set = new HashSet<>();\\n            while (queue.size() > 0 && matched < len3) {\\n                int size = queue.size();\\n                for (int i = 0; i < size; i++) {\\n                    int p1 = queue.peek() / len3,\\n                        p2 = queue.peek() % len3;\\n                    queue.poll();\\n                    if (p1 < len1 && s1.charAt(p1) == s3.charAt(matched)) {\\n                        int key = (p1 + 1) * len3 + p2;\\n                        if (!set.contains(key)) {\\n                            set.add(key);\\n                            queue.offer(key);\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 31907,
                "title": "my-accepted-java-recursive-solution-for-interleaving-string",
                "content": "    public class Solution {\\n      \\tprivate static Set<Integer> visited; // The combination of i1, i2 has been visited and return false\\n    \\tpublic static boolean isInterleave(String s1, String s2, String s3) {\\n    \\t\\tif(s3.length() != s1.length() + s2.length())\\n    \\t\\t\\treturn false;\\n    \\t\\tvisited = new HashSet<Integer>();\\n    \\t\\treturn isInterleave(s1, 0, s2, 0, s3, 0);\\n    \\t}\\n    \\t\\n    \\tprivate static boolean isInterleave(String s1, int i1, String s2, int i2, String s3, int i3)\\n    \\t{\\t\\n    \\t\\tint hash = i1 * s3.length() + i2;\\n    \\t\\tif(visited.contains(hash))\\n    \\t\\t\\treturn false;\\n    \\t\\t\\n    \\t\\tif(i1 == s1.length())\\n    \\t\\t\\treturn s2.substring(i2).equals(s3.substring(i3));\\n    \\t\\tif(i2 == s2.length())\\n    \\t\\t\\treturn s1.substring(i1).equals(s3.substring(i3));\\n    \\t\\t\\n    \\t\\tif(s3.charAt(i3) == s1.charAt(i1) && isInterleave(s1, i1+1, s2, i2, s3, i3+1) ||\\n    \\t\\t   s3.charAt(i3) == s2.charAt(i2) && isInterleave(s1, i1, s2, i2+1, s3, i3+1))\\n    \\t\\t\\treturn true;\\n    \\t\\t\\n    \\t\\tvisited.add(hash);\\n    \\t\\treturn false;\\n    \\t}\\n    }\\n\\nThe private method isInterleave is the recursive method. it takes additional i1, i2, i3 as the start indexes of s1, s2, s3, so it solves the substring of s1, s2, s3 with those start indexes. \\n\\nThe recursion starting condition is i1, i2, i3 are set to 0, means it solves the whole string. \\n\\nin each recursion, it will just check the first character in s3 with s2 and s1, if it equals s1, it will increase i3 and i1 to solve remain, if remain return true, this recursion will also return true. Same logic for s2.\\n\\nThe end condition is when remain of either s1 or s2 is empty, then just compare remain of s3 with remain of s1 or s2, if they are equal, it will return true.\\n\\nA pure recursive solution will cause time limit exceed. We can optimize it by caching the false visited solutions in the visited set. That will short circuit many repeated search path.",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "class Solution {\\n      \\tprivate static Set<Integer> visited; // The combination of i1, i2 has been visited and return false\\n    \\tpublic static boolean isInterleave(String s1, String s2, String s3) {\\n    \\t\\tif(s3.length() != s1.length() + s2.length())\\n    \\t\\t\\treturn false;\\n    \\t\\tvisited = new HashSet<Integer>();\\n    \\t\\treturn isInterleave(s1, 0, s2, 0, s3, 0);\\n    \\t}",
                "codeTag": "Java"
            },
            {
                "id": 3956666,
                "title": "beats-100-dp-very-easy-code-c-java-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust explore all the option  -> take if current character is same with any of the string current character string 1 and string 2.\\n\\n[ Video in Hindi click here](https://youtube.com/@LetsCodeTogether72/videos)\\n\\nor link in my profile.Here,you can find any solution in playlists monthwise from june 2023 with detailed explanation.i upload daily leetcode solution video with short and precise explanation.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The `solve` function is a recursive helper function that takes the current indices `ind1` and `ind2` for strings `s1` and `s2` respectively, along with a memoization table `dp`. The purpose of this function is to check if it\\'s possible to create the remaining part of `s3` (starting from `ind1+ind2` position) using the remaining parts of `s1` (starting from `ind1` position) and `s2` (starting from `ind2` position).\\n\\n2. The base case for the recursion is when the sum of `ind1` and `ind2` equals the length of `s3`, meaning all characters of `s3` have been matched successfully. In this case, the function returns `true`.\\n\\n3. Before proceeding with the actual computation, the function checks if the result for the current `ind1` and `ind2` indices has already been computed and stored in the memoization table `dp`. If so, it returns the precomputed result.\\n\\n4. The function initializes a boolean variable `ans` to `false`. It then checks two conditions:\\n   - If `ind1` is within bounds of `s1` and the character at `s1[ind1]` matches the character at `s3[ind1+ind2]`, it recursively calls `solve` by moving the index `ind1` of `s1` one step forward.\\n   - If `ind2` is within bounds of `s2` and the character at `s2[ind2]` matches the character at `s3[ind1+ind2]`, it recursively calls `solve` by moving the index `ind2` of `s2` one step forward.\\n   \\n   The `ans` is updated using the bitwise OR operation (`|`) to retain any previous `true` value and to combine the results of the two recursive calls.\\n\\n5. Finally, the function stores the computed `ans` in the memoization table `dp` for the current `ind1` and `ind2` indices and returns this result.\\n\\n6. The `isInterleave` function is the main function that\\'s called to determine whether `s3` can be formed by interleaving characters from `s1` and `s2`. It first checks if the total length of `s1` and `s2` matches the length of `s3`. If not, it returns `false` as it\\'s impossible to form `s3`.\\n\\n7. It initializes a 2D vector `dp` to store the memoization table. The dimensions of this table are `(s1.size() + 1)` rows and `(s2.size() + 1)` columns, with all values initialized to `-1`.\\n\\n8. It then calls the `solve` function with initial indices `ind1` and `ind2` set to `0`, along with the memoization table `dp`. The result of this call indicates whether it\\'s possible to form `s3` by interleaving `s1` and `s2`.\\n\\n9. The `isInterleave` function returns the result obtained from the `solve` function.\\n\\n# Complexity\\n- Time complexity:$$O(n*m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n*m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![Screenshot (313).png](https://assets.leetcode.com/users/images/e026a7e6-6e21-4d8c-a989-f527ccd022fa_1692933422.857026.png)\\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    bool solve(string &s1, string &s2, string &s3,int ind1,int ind2,vector<vector<int>>&dp)\\n{\\n    if(ind1+ind2==s3.size()) return 1;\\n    if(dp[ind1][ind2]!=-1) return dp[ind1][ind2];\\n    bool ans=0;        \\n    if(ind1<s1.size() && s1[ind1]==s3[ind1+ind2]) \\n    ans=(ans | solve(s1,s2,s3,ind1+1,ind2,dp));\\n    if(ind2<s2.size() && s2[ind2]==s3[ind1+ind2])\\n    ans=(ans | solve(s1,s2,s3,ind1,ind2+1,dp));\\n    return dp[ind1][ind2]=ans;\\n}\\n    bool isInterleave(string s1, string s2, string s3) {\\n         if(s1.size()+s2.size()!=s3.size()) return false;\\n    vector<vector<int>>dp(s1.size()+1,vector<int>(s2.size()+1,-1));\\n    return solve(s1,s2,s3,0,0,dp);\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    public boolean solve(String s1, String s2, String s3, int ind1, int ind2, int[][] dp) {\\n        if (ind1 + ind2 == s3.length()) return true;\\n        if (dp[ind1][ind2] != -1) return dp[ind1][ind2] == 1;\\n        boolean ans = false;\\n        \\n        if (ind1 < s1.length() && s1.charAt(ind1) == s3.charAt(ind1 + ind2)) {\\n            ans |= solve(s1, s2, s3, ind1 + 1, ind2, dp);\\n        }\\n        \\n        if (ind2 < s2.length() && s2.charAt(ind2) == s3.charAt(ind1 + ind2)) {\\n            ans |= solve(s1, s2, s3, ind1, ind2 + 1, dp);\\n        }\\n        \\n        dp[ind1][ind2] = ans ? 1 : 0;\\n        return ans;\\n    }\\n    \\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        if (s1.length() + s2.length() != s3.length()) {\\n            return false;\\n        }\\n        \\n        int[][] dp = new int[s1.length() + 1][s2.length() + 1];\\n        for (int i = 0; i <= s1.length(); i++) {\\n            Arrays.fill(dp[i], -1);\\n        }\\n        \\n        return solve(s1, s2, s3, 0, 0, dp);\\n    }\\n}\\n\\n```\\n```python []\\nclass Solution:\\n    def solve(self, s1: str, s2: str, s3: str, ind1: int, ind2: int, dp: List[List[int]]) -> bool:\\n        if ind1 + ind2 == len(s3):\\n            return True\\n        if dp[ind1][ind2] != -1:\\n            return dp[ind1][ind2] == 1\\n        ans = False\\n        \\n        if ind1 < len(s1) and s1[ind1] == s3[ind1 + ind2]:\\n            ans |= self.solve(s1, s2, s3, ind1 + 1, ind2, dp)\\n        \\n        if ind2 < len(s2) and s2[ind2] == s3[ind1 + ind2]:\\n            ans |= self.solve(s1, s2, s3, ind1, ind2 + 1, dp)\\n        \\n        dp[ind1][ind2] = 1 if ans else 0\\n        return ans\\n    \\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3):\\n            return False\\n        \\n        dp = [[-1] * (len(s2) + 1) for _ in range(len(s1) + 1)]\\n        return self.solve(s1, s2, s3, 0, 0, dp)\\n\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool solve(string &s1, string &s2, string &s3,int ind1,int ind2,vector<vector<int>>&dp)\\n{\\n    if(ind1+ind2==s3.size()) return 1;\\n    if(dp[ind1][ind2]!=-1) return dp[ind1][ind2];\\n    bool ans=0;        \\n    if(ind1<s1.size() && s1[ind1]==s3[ind1+ind2]) \\n    ans=(ans | solve(s1,s2,s3,ind1+1,ind2,dp));\\n    if(ind2<s2.size() && s2[ind2]==s3[ind1+ind2])\\n    ans=(ans | solve(s1,s2,s3,ind1,ind2+1,dp));\\n    return dp[ind1][ind2]=ans;\\n}\\n    bool isInterleave(string s1, string s2, string s3) {\\n         if(s1.size()+s2.size()!=s3.size()) return false;\\n    vector<vector<int>>dp(s1.size()+1,vector<int>(s2.size()+1,-1));\\n    return solve(s1,s2,s3,0,0,dp);\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public boolean solve(String s1, String s2, String s3, int ind1, int ind2, int[][] dp) {\\n        if (ind1 + ind2 == s3.length()) return true;\\n        if (dp[ind1][ind2] != -1) return dp[ind1][ind2] == 1;\\n        boolean ans = false;\\n        \\n        if (ind1 < s1.length() && s1.charAt(ind1) == s3.charAt(ind1 + ind2)) {\\n            ans |= solve(s1, s2, s3, ind1 + 1, ind2, dp);\\n        }\\n        \\n        if (ind2 < s2.length() && s2.charAt(ind2) == s3.charAt(ind1 + ind2)) {\\n            ans |= solve(s1, s2, s3, ind1, ind2 + 1, dp);\\n        }\\n        \\n        dp[ind1][ind2] = ans ? 1 : 0;\\n        return ans;\\n    }\\n    \\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        if (s1.length() + s2.length() != s3.length()) {\\n            return false;\\n        }\\n        \\n        int[][] dp = new int[s1.length() + 1][s2.length() + 1];\\n        for (int i = 0; i <= s1.length(); i++) {\\n            Arrays.fill(dp[i], -1);\\n        }\\n        \\n        return solve(s1, s2, s3, 0, 0, dp);\\n    }\\n}\\n\\n```\n```python []\\nclass Solution:\\n    def solve(self, s1: str, s2: str, s3: str, ind1: int, ind2: int, dp: List[List[int]]) -> bool:\\n        if ind1 + ind2 == len(s3):\\n            return True\\n        if dp[ind1][ind2] != -1:\\n            return dp[ind1][ind2] == 1\\n        ans = False\\n        \\n        if ind1 < len(s1) and s1[ind1] == s3[ind1 + ind2]:\\n            ans |= self.solve(s1, s2, s3, ind1 + 1, ind2, dp)\\n        \\n        if ind2 < len(s2) and s2[ind2] == s3[ind1 + ind2]:\\n            ans |= self.solve(s1, s2, s3, ind1, ind2 + 1, dp)\\n        \\n        dp[ind1][ind2] = 1 if ans else 0\\n        return ans\\n    \\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3):\\n            return False\\n        \\n        dp = [[-1] * (len(s2) + 1) for _ in range(len(s1) + 1)]\\n        return self.solve(s1, s2, s3, 0, 0, dp)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1247459,
                "title": "easy-understanding-recursion-and-memoization-iterative",
                "content": "**Recursive Solution that gives TLE**\\n```\\nclass Solution {\\npublic:\\n    bool solve(string s1,string s2,string s3,int l1,int l2,int n)\\n    {\\n        if(l1<0&&l2<0&&n<0)\\n        {\\n            return true;\\n        }\\n        if(l1>=0&&s1[l1]==s3[n]&&l2>=0&&s2[l2]==s3[n])\\n        {\\n            return (solve(s1,s2,s3,l1-1,l2,n-1) || solve(s1,s2,s3,l1,l2-1,n-1));\\n        }\\n        else if(l1>=0&&s1[l1]==s3[n])\\n        {\\n            return solve(s1,s2,s3,l1-1,l2,n-1);\\n        }\\n        else if(l2>=0&&s2[l2]==s3[n])\\n        {\\n           return solve(s1,s2,s3,l1,l2-1,n-1);\\n        }\\n        return false;\\n    }\\n    \\n    bool isInterleave(string s1, string s2, string s3) {\\n        if(s3.size()!=s1.size()+s2.size())return false;\\n        return solve(s1,s2,s3,s1.size()-1,s2.size()-1,s3.length()-1);\\n        \\n    }\\n};\\n```\\n\\n**Memoization of the recusive solution: ACCEPTED**\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    bool solve(string s1,string s2,string s3,int l1,int l2,int n)\\n    {\\n        if(l1>=0&&l2>=0 &&dp[l1][l2]!=-1)return dp[l1][l2];\\n        if(l1<0&&l2<0&&n<0)\\n        {\\n            return true;\\n        }\\n        \\n        if(l1>=0&&n>=0&&s1[l1]==s3[n]&&l2>=0&&s2[l2]==s3[n])\\n        {\\n            return dp[l1][l2]=(solve(s1,s2,s3,l1-1,l2,n-1) || solve(s1,s2,s3,l1,l2-1,n-1));\\n        }\\n        else if(l1>=0&&n>=0&&s1[l1]==s3[n])\\n        {\\n            return solve(s1,s2,s3,l1-1,l2,n-1);\\n        }\\n        else if(l2>=0&&n>=0&&s2[l2]==s3[n])\\n        {\\n           return solve(s1,s2,s3,l1,l2-1,n-1);\\n        }\\n        return false;\\n    }\\n    \\n    bool isInterleave(string s1, string s2, string s3) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(s1,s2,s3,s1.size()-1,s2.size()-1,s3.length()-1);\\n        \\n    }\\n};\\n\\n```\\n**Iterative Using Dp:**\\n\\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n=s1.length();\\n        int m=s2.length();\\n        if(n+m!=s3.length())\\n            return 0;\\n        bool dp[n+1][m+1];\\n        memset(dp,0,sizeof(dp));\\n        \\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=m;j++)\\n            {\\n                if(i==0&&j==0)\\n                    dp[i][j]=true;\\n                else if(i==0)\\n                {\\n                    if(s2[j-1]==s3[j-1])\\n                        dp[i][j]=dp[i][j-1];\\n                }\\n                else if(j==0)\\n                {\\n                    if(s1[i-1]==s3[i-1])\\n                        dp[i][j]=dp[i-1][j];\\n                }\\n                else if(s1[i-1]==s3[i+j-1]&&s2[j-1]!=s3[i+j-1])\\n                    dp[i][j]=dp[i-1][j];\\n                \\n                else if(s1[i-1]!=s3[i+j-1]&&s2[j-1]==s3[i+j-1])\\n                    dp[i][j]=dp[i][j-1];\\n                \\n                else if(s1[i-1]==s3[i+j-1]&&s2[j-1]==s3[i+j-1])\\n                    dp[i][j]=(dp[i-1][j] || dp[i][j-1]);\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(string s1,string s2,string s3,int l1,int l2,int n)\\n    {\\n        if(l1<0&&l2<0&&n<0)\\n        {\\n            return true;\\n        }\\n        if(l1>=0&&s1[l1]==s3[n]&&l2>=0&&s2[l2]==s3[n])\\n        {\\n            return (solve(s1,s2,s3,l1-1,l2,n-1) || solve(s1,s2,s3,l1,l2-1,n-1));\\n        }\\n        else if(l1>=0&&s1[l1]==s3[n])\\n        {\\n            return solve(s1,s2,s3,l1-1,l2,n-1);\\n        }\\n        else if(l2>=0&&s2[l2]==s3[n])\\n        {\\n           return solve(s1,s2,s3,l1,l2-1,n-1);\\n        }\\n        return false;\\n    }\\n    \\n    bool isInterleave(string s1, string s2, string s3) {\\n        if(s3.size()!=s1.size()+s2.size())return false;\\n        return solve(s1,s2,s3,s1.size()-1,s2.size()-1,s3.length()-1);\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    bool solve(string s1,string s2,string s3,int l1,int l2,int n)\\n    {\\n        if(l1>=0&&l2>=0 &&dp[l1][l2]!=-1)return dp[l1][l2];\\n        if(l1<0&&l2<0&&n<0)\\n        {\\n            return true;\\n        }\\n        \\n        if(l1>=0&&n>=0&&s1[l1]==s3[n]&&l2>=0&&s2[l2]==s3[n])\\n        {\\n            return dp[l1][l2]=(solve(s1,s2,s3,l1-1,l2,n-1) || solve(s1,s2,s3,l1,l2-1,n-1));\\n        }\\n        else if(l1>=0&&n>=0&&s1[l1]==s3[n])\\n        {\\n            return solve(s1,s2,s3,l1-1,l2,n-1);\\n        }\\n        else if(l2>=0&&n>=0&&s2[l2]==s3[n])\\n        {\\n           return solve(s1,s2,s3,l1,l2-1,n-1);\\n        }\\n        return false;\\n    }\\n    \\n    bool isInterleave(string s1, string s2, string s3) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(s1,s2,s3,s1.size()-1,s2.size()-1,s3.length()-1);\\n        \\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n=s1.length();\\n        int m=s2.length();\\n        if(n+m!=s3.length())\\n            return 0;\\n        bool dp[n+1][m+1];\\n        memset(dp,0,sizeof(dp));\\n        \\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=m;j++)\\n            {\\n                if(i==0&&j==0)\\n                    dp[i][j]=true;\\n                else if(i==0)\\n                {\\n                    if(s2[j-1]==s3[j-1])\\n                        dp[i][j]=dp[i][j-1];\\n                }\\n                else if(j==0)\\n                {\\n                    if(s1[i-1]==s3[i-1])\\n                        dp[i][j]=dp[i-1][j];\\n                }\\n                else if(s1[i-1]==s3[i+j-1]&&s2[j-1]!=s3[i+j-1])\\n                    dp[i][j]=dp[i-1][j];\\n                \\n                else if(s1[i-1]!=s3[i+j-1]&&s2[j-1]==s3[i+j-1])\\n                    dp[i][j]=dp[i][j-1];\\n                \\n                else if(s1[i-1]==s3[i+j-1]&&s2[j-1]==s3[i+j-1])\\n                    dp[i][j]=(dp[i-1][j] || dp[i][j-1]);\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1247753,
                "title": "java-dfs-with-stack-and-memoization",
                "content": "**Here\\'s the overall gist:**\\n* The stack will be used in a similar fashion to a depth-first search. It\\'ll store a series of coordinates corresponding to the indexes of characters in `s1` and `s2`, and traversal will be based on comparison with `s3`.\\n* But wait. These searches often involve graphs, nodes, and edges. How does that apply here?\\n\\n**Here\\'s an illustration of the graph we\\'re traversing:**\\nI\\'ve used example 1 from the problem description here. The solution provided by the example is in bold.\\n![image](https://assets.leetcode.com/users/images/9c0f265e-7eab-44ad-b130-70e13cac1743_1622658517.0783722.png)\\nWith this graph, we can only traverse down and right. A traversal is essentially \"building\" `s3` from `s1` and `s2`: going right corresponds to adding a character from `s1`, and going down adds a character from `s2`. You can think of a coordinate (i, j) representing the ith character in `s1`, and the jth character in `s2`.\\n\\nHow do we know which way to go? We check the next character of `s3`. If it matches the current character at `s1`, we can go right. And if it matches the current character at `s2`, we can go down. We keep going until we can reach the end states for both `s1` and `s2`, or the bottom-rightmost node in our grid, or until we get stuck somewhere.\\n\\nNotice how there are multiple paths we can go in. This is because of the fact that it\\'s sometimes possible that we can pick a valid character from both `s1` and `s2`. This is why we need to perform a search on the entire graph, and this can be done by either using recursion (which is what a lot of the other solutions use), or a stack.\\n\\n**Our overall algorithm:**\\nHere\\'s a brief recap of our algorithm. At a worst case scenario, we end up visiting every node. This gives us a time complexity of **O(m * n)**, where m and n are the lengths of each string.\\n* Add (0, 0) to our stack.\\n* Perform a DFS on the graph. With a stack, this is what it looks like:\\n\\t* Pop the topmost coordinates (i, j) off the stack and record it in our `visited` boolean matrix.\\n\\t* Check if our coordinates are at the bottom right, and return `true` if so.\\n\\t* Otherwise, check if we can traverse further.\\n\\t\\t* If the ith character in `s1` matches the next character in `s3` and if (i + 1, j) hasn\\'t been visited, push that onto the stack.\\n\\t\\t* If the jth character in `s2` matches the next character in `s3` and if (i, j + 1) hasn\\'t been visited, push that onto the stack.\\n\\t* Rinse and repeat. If we empty out the stack, our search is unsuccessful so we return `false`.\\n\\nHere\\'s a commented version of my code in Java. I encourage you to give it a shot first :)\\n```\\nimport java.util.Stack;\\n\\nclass Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        if (s1.length() + s2.length() != s3.length())\\n            return false;\\n        \\n        // coordinates are of the form [i, j], corresponding to the indexes in s1, s2\\n        Stack<int[]> stack = new Stack<int[]>();\\n        stack.push(new int[] {0, 0});\\n\\t\\t\\n        boolean[][] visited = new boolean[s1.length() + 1][s2.length() + 1];\\n        \\n        while (!stack.empty()) {\\n            int[] indexes = stack.pop();\\n            int i = indexes[0], j = indexes[1];\\n            visited[i][j] = true;\\n\\t\\t\\t\\n\\t\\t\\t// we\\'re at the bottom-rightmost coordinate; we\\'re done!\\n            if (i == s1.length() && j == s2.length())\\n                return true;\\n            \\n\\t\\t\\t// check if we can increment i (traveling right on the graph)\\n            if (i < s1.length() && !visited[i + 1][j] && s1.charAt(i) == s3.charAt(i + j))\\n                stack.push(new int[] {i + 1, j});\\n            \\n\\t\\t\\t// check if we can increment j (traveling down on the graph)\\n            if (j < s2.length() && !visited[i][j + 1] && s2.charAt(j) == s3.charAt(i + j))\\n                stack.push(new int[] {i, j + 1});\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Depth-First Search"
                ],
                "code": "```\\nimport java.util.Stack;\\n\\nclass Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        if (s1.length() + s2.length() != s3.length())\\n            return false;\\n        \\n        // coordinates are of the form [i, j], corresponding to the indexes in s1, s2\\n        Stack<int[]> stack = new Stack<int[]>();\\n        stack.push(new int[] {0, 0});\\n\\t\\t\\n        boolean[][] visited = new boolean[s1.length() + 1][s2.length() + 1];\\n        \\n        while (!stack.empty()) {\\n            int[] indexes = stack.pop();\\n            int i = indexes[0], j = indexes[1];\\n            visited[i][j] = true;\\n\\t\\t\\t\\n\\t\\t\\t// we\\'re at the bottom-rightmost coordinate; we\\'re done!\\n            if (i == s1.length() && j == s2.length())\\n                return true;\\n            \\n\\t\\t\\t// check if we can increment i (traveling right on the graph)\\n            if (i < s1.length() && !visited[i + 1][j] && s1.charAt(i) == s3.charAt(i + j))\\n                stack.push(new int[] {i + 1, j});\\n            \\n\\t\\t\\t// check if we can increment j (traveling down on the graph)\\n            if (j < s2.length() && !visited[i][j + 1] && s2.charAt(j) == s3.charAt(i + j))\\n                stack.push(new int[] {i, j + 1});\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2250195,
                "title": "java-4-solutions-recursion-memoization-dp",
                "content": "\\n**Solution 1: Brute Force (Recursion) - Time Limit Exceeded**\\n\\n```\\n// Time complexity: O(2^(m+n))\\n// Space complexity: O(m+n)\\n\\npublic boolean isInterleave(String s1, String s2, String s3) {\\n\\tif(s1.length() + s2.length() != s3.length())\\n\\t\\treturn false;\\n\\t\\n\\treturn helper(s1, s2, s3, 0, 0);\\n}\\n\\npublic boolean helper(String s1, String s2, String s3, int i, int j) {\\n\\tif(i+j == s3.length())\\n\\t\\treturn true;\\n\\t\\n\\tif(i < s1.length() && s3.charAt(i+j) == s1.charAt(i)) {\\n\\t\\tboolean flag = helper(s1, s2, s3, i+1, j);\\n\\t\\tif(flag)\\n\\t\\t\\treturn true;\\n\\t}\\n\\n\\tif(j < s2.length() && s3.charAt(i+j) == s2.charAt(j)) {\\n\\t\\tboolean flag = helper(s1, s2, s3, i, j+1);\\n\\t\\tif(flag)\\n\\t\\t\\treturn true;\\n\\t}\\n\\n\\treturn false;\\n}\\n```\\n\\n**Solution 2: Top Down DP (Recursion + Memoization)**\\n\\n```\\n// Time complexity: O(m*n)\\n// Space complexity: O(m*n)\\n\\npublic boolean isInterleave(String s1, String s2, String s3) {\\n\\tif(s1.length() + s2.length() != s3.length())\\n\\t\\treturn false;\\n\\n\\tBoolean[][] memo = new Boolean[s1.length() + 1][s2.length() + 1];\\n\\n\\treturn helper(s1, s2, s3, 0, 0, memo);\\n}\\n\\npublic boolean helper(String s1, String s2, String s3, int i, int j, Boolean[][] memo) {\\n\\tif(i+j == s3.length())\\n\\t\\treturn true;\\n\\n\\tif(memo[i][j] != null)\\n\\t\\treturn memo[i][j];\\n\\n\\t if(i < s1.length() && s3.charAt(i+j) == s1.charAt(i)) {\\n\\t\\tboolean flag = helper(s1, s2, s3, i+1, j, memo);\\n\\t\\tmemo[i][j] = flag;\\n\\t\\tif(flag) \\n\\t\\t\\treturn true;\\n\\t}\\n\\n\\tif(j < s2.length() && s3.charAt(i+j) == s2.charAt(j)) {\\n\\t\\tboolean flag = helper(s1, s2, s3, i, j+1, memo);\\n\\t\\tmemo[i][j] = flag;\\n\\t\\tif(flag) \\n\\t\\t\\treturn true;\\n\\t}\\n\\n\\tmemo[i][j] = false;\\n\\treturn false;\\n}\\n```\\n\\n**Solution 3: Bottom UP DP (2D)**\\n\\n```\\n// Time complexity: O(m*n)\\n// Space complexity: O(m*n)\\n\\npublic boolean isInterleave(String s1, String s2, String s3) {\\n\\tif(s1.length() + s2.length() != s3.length())\\n\\t\\treturn false;\\n\\n\\tboolean dp[][] = new boolean[s1.length() + 1][s2.length() + 1];\\n\\n\\tfor (int i = 0; i <= s1.length(); i++) {\\n\\t\\tfor (int j = 0; j <= s2.length(); j++) {\\n\\t\\t\\tif (i == 0 && j == 0) \\n\\t\\t\\t\\tdp[i][j] = true;\\n\\t\\t\\n\\t\\t\\telse if (i == 0) \\n\\t\\t\\t\\tdp[i][j] = dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1);\\n\\n\\t\\t\\telse if (j == 0) \\n\\t\\t\\t\\tdp[i][j] = dp[i - 1][j] && s1.charAt(i - 1) == s3.charAt(i + j - 1);\\n\\n\\t\\t\\telse \\n\\t\\t\\t\\tdp[i][j] = (dp[i - 1][j] && s1.charAt(i - 1) == s3.charAt(i + j - 1)) \\n\\t\\t\\t\\t\\t\\t\\t\\t|| (dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1));\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[s1.length()][s2.length()];\\n}\\n```\\n\\n**Solution 4: Bottom UP DP (1D)**\\n\\n```\\n// Time complexity: O(m*n)\\n// Space complexity: O(n)\\n\\npublic boolean isInterleave(String s1, String s2, String s3) {\\n\\tif(s1.length() + s2.length() != s3.length())\\n\\t\\treturn false;\\n\\n\\tboolean dp[] = new boolean[s2.length() + 1];\\n\\n\\tfor (int i = 0; i <= s1.length(); i++) {\\n\\t\\tfor (int j = 0; j <= s2.length(); j++) {\\n\\t\\t\\tif (i == 0 && j == 0) \\n\\t\\t\\t\\tdp[j] = true;\\n\\n\\t\\t\\telse if (i == 0) \\n\\t\\t\\t\\tdp[j] = dp[j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1);\\n\\n\\t\\t\\telse if (j == 0) \\n\\t\\t\\t\\tdp[j] = dp[j] && s1.charAt(i - 1) == s3.charAt(i + j - 1);\\n\\n\\t\\t\\telse \\n\\t\\t\\t\\tdp[j] = (dp[j] && s1.charAt(i - 1) == s3.charAt(i + j - 1)) \\n\\t\\t\\t\\t\\t\\t\\t|| (dp[j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1));\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[s2.length()];\\n}\\n```\\n\\nPlease upvote if you find it useful.",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n// Time complexity: O(2^(m+n))\\n// Space complexity: O(m+n)\\n\\npublic boolean isInterleave(String s1, String s2, String s3) {\\n\\tif(s1.length() + s2.length() != s3.length())\\n\\t\\treturn false;\\n\\t\\n\\treturn helper(s1, s2, s3, 0, 0);\\n}\\n\\npublic boolean helper(String s1, String s2, String s3, int i, int j) {\\n\\tif(i+j == s3.length())\\n\\t\\treturn true;\\n\\t\\n\\tif(i < s1.length() && s3.charAt(i+j) == s1.charAt(i)) {\\n\\t\\tboolean flag = helper(s1, s2, s3, i+1, j);\\n\\t\\tif(flag)\\n\\t\\t\\treturn true;\\n\\t}\\n\\n\\tif(j < s2.length() && s3.charAt(i+j) == s2.charAt(j)) {\\n\\t\\tboolean flag = helper(s1, s2, s3, i, j+1);\\n\\t\\tif(flag)\\n\\t\\t\\treturn true;\\n\\t}\\n\\n\\treturn false;\\n}\\n```\n```\\n// Time complexity: O(m*n)\\n// Space complexity: O(m*n)\\n\\npublic boolean isInterleave(String s1, String s2, String s3) {\\n\\tif(s1.length() + s2.length() != s3.length())\\n\\t\\treturn false;\\n\\n\\tBoolean[][] memo = new Boolean[s1.length() + 1][s2.length() + 1];\\n\\n\\treturn helper(s1, s2, s3, 0, 0, memo);\\n}\\n\\npublic boolean helper(String s1, String s2, String s3, int i, int j, Boolean[][] memo) {\\n\\tif(i+j == s3.length())\\n\\t\\treturn true;\\n\\n\\tif(memo[i][j] != null)\\n\\t\\treturn memo[i][j];\\n\\n\\t if(i < s1.length() && s3.charAt(i+j) == s1.charAt(i)) {\\n\\t\\tboolean flag = helper(s1, s2, s3, i+1, j, memo);\\n\\t\\tmemo[i][j] = flag;\\n\\t\\tif(flag) \\n\\t\\t\\treturn true;\\n\\t}\\n\\n\\tif(j < s2.length() && s3.charAt(i+j) == s2.charAt(j)) {\\n\\t\\tboolean flag = helper(s1, s2, s3, i, j+1, memo);\\n\\t\\tmemo[i][j] = flag;\\n\\t\\tif(flag) \\n\\t\\t\\treturn true;\\n\\t}\\n\\n\\tmemo[i][j] = false;\\n\\treturn false;\\n}\\n```\n```\\n// Time complexity: O(m*n)\\n// Space complexity: O(m*n)\\n\\npublic boolean isInterleave(String s1, String s2, String s3) {\\n\\tif(s1.length() + s2.length() != s3.length())\\n\\t\\treturn false;\\n\\n\\tboolean dp[][] = new boolean[s1.length() + 1][s2.length() + 1];\\n\\n\\tfor (int i = 0; i <= s1.length(); i++) {\\n\\t\\tfor (int j = 0; j <= s2.length(); j++) {\\n\\t\\t\\tif (i == 0 && j == 0) \\n\\t\\t\\t\\tdp[i][j] = true;\\n\\t\\t\\n\\t\\t\\telse if (i == 0) \\n\\t\\t\\t\\tdp[i][j] = dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1);\\n\\n\\t\\t\\telse if (j == 0) \\n\\t\\t\\t\\tdp[i][j] = dp[i - 1][j] && s1.charAt(i - 1) == s3.charAt(i + j - 1);\\n\\n\\t\\t\\telse \\n\\t\\t\\t\\tdp[i][j] = (dp[i - 1][j] && s1.charAt(i - 1) == s3.charAt(i + j - 1)) \\n\\t\\t\\t\\t\\t\\t\\t\\t|| (dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1));\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[s1.length()][s2.length()];\\n}\\n```\n```\\n// Time complexity: O(m*n)\\n// Space complexity: O(n)\\n\\npublic boolean isInterleave(String s1, String s2, String s3) {\\n\\tif(s1.length() + s2.length() != s3.length())\\n\\t\\treturn false;\\n\\n\\tboolean dp[] = new boolean[s2.length() + 1];\\n\\n\\tfor (int i = 0; i <= s1.length(); i++) {\\n\\t\\tfor (int j = 0; j <= s2.length(); j++) {\\n\\t\\t\\tif (i == 0 && j == 0) \\n\\t\\t\\t\\tdp[j] = true;\\n\\n\\t\\t\\telse if (i == 0) \\n\\t\\t\\t\\tdp[j] = dp[j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1);\\n\\n\\t\\t\\telse if (j == 0) \\n\\t\\t\\t\\tdp[j] = dp[j] && s1.charAt(i - 1) == s3.charAt(i + j - 1);\\n\\n\\t\\t\\telse \\n\\t\\t\\t\\tdp[j] = (dp[j] && s1.charAt(i - 1) == s3.charAt(i + j - 1)) \\n\\t\\t\\t\\t\\t\\t\\t|| (dp[j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1));\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[s2.length()];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 32076,
                "title": "simple-python-dp-solution",
                "content": "Keep two points on `s1` and `s2` and traverse `s3`, the current char in `s3` is either from `s1` or `s2` or both. Use a **set** to record all possibility and dp on.\\n\\nThe key here is to use a set to record the pointers, because duplicates are possible, using a list cause TLE.\\n     \\n    def isInterleave(self, s1, s2, s3):\\n        l1, l2 = len(s1), len(s2)\\n        if l1 + l2 != len(s3):\\n            return False\\n        \\n        last = set([(0, 0)])\\n        for char in s3:\\n            current = set()\\n            for i, j in last:\\n                if i < l1 and s1[i] == char:\\n                    current.add((i + 1, j))\\n                if j < l2 and s2[j] == char:\\n                    current.add((i, j + 1))\\n            if not current:\\n                return False\\n            last = current\\n        return True",
                "solutionTags": [
                    "Python"
                ],
                "code": "Keep two points on `s1` and `s2` and traverse `s3`, the current char in `s3` is either from `s1` or `s2` or both. Use a **set** to record all possibility and dp on.\\n\\nThe key here is to use a set to record the pointers, because duplicates are possible, using a list cause TLE.\\n     \\n    def isInterleave(self, s1, s2, s3):\\n        l1, l2 = len(s1), len(s2)\\n        if l1 + l2 != len(s3):\\n            return False\\n        \\n        last = set([(0, 0)])\\n        for char in s3:\\n            current = set()\\n            for i, j in last:\\n                if i < l1 and s1[i] == char:\\n                    current.add((i + 1, j))\\n                if j < l2 and s2[j] == char:\\n                    current.add((i, j + 1))\\n            if not current:\\n                return False\\n            last = current\\n        return True",
                "codeTag": "Python3"
            },
            {
                "id": 31989,
                "title": "share-my-analysis-of-this-problem-from-recursion-to-dp-java",
                "content": "public class Solution {\\n\\nFor this problem, we are trying to see if we can obtain s3 by interleaving s1 and s2. In other words, we need to figure out where each char of s3 comes from, s1 or s2 or nowhere. If we can find a way that all of the chars of s3 comes from s1 or s2, then we can form s3 by interleaving s1 and s2, and thus return true; otherwise we return false. For example, if s1 = abc, s2 = bcd, s3 = abbccd, then s3 can be formed by \"001011\" or \"010101\". (0 represents char comes from s1, and 1 represents char comes from s2). \\n\\nIt is easy to come up with a solution using recursion.\\n\\npublic class Solution {\\n\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        if(s1 == null || s1.length() == 0) {return s2.equals(s3);}\\n        if(s2 == null || s2.length() == 0) {return s1.equals(s3);}\\n        if(s3.charAt(0) == s1.charAt(0) && s3.charAt(0) == s2.charAt(0)){\\n            return isInterleave(s1.substring(1), s2, s3.substring(1)) || isInterleave(s1, s2.substring(1), s3.substring(1));\\n        }\\n        else if(s3.charAt(0) == s1.charAt(0)){\\n            return isInterleave(s1.substring(1), s2, s3.substring(1));\\n        }\\n        else if(s3.charAt(0) == s2.charAt(0)){\\n            return isInterleave(s1, s2.substring(1), s3.substring(1));\\n        }\\n        return false;\\n    }\\n\\n}\\n\\nBut this solution takes exponential time, because each position have two choices, a length of n of s3 would have 2^n choices need to check. Thus, we think of  DP, because it can reduce exponential time to polynomial time, and it applies to the problem that have many subproblems. \\n\\nWe create a boolean table called pathTable, and each cell of pathTable[i][j] represents whether we can form s3.substring(0, i+j) using the first s1.substring(0, i) and s2.substring(0, j). Thus, if pathTable[pathTable.length - 1][pathTable[0].length - 1] is true, it means there is a path from pathTable[0][0] to it. In other words, s3 can be formed by s1 and s2. \\n\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        if((s1 == null || s1.length() == 0) && (s2 == null || s2.length() == 0)){ \\n            return s3 == null || s3.length() == 0;\\n        }\\n        if(s1 == null || s1.length() == 0){ return s2.equals(s3);}\\n        if(s2 == null || s2.length() == 0){ return s1.equals(s3);}\\n        if(s1.length() + s2.length() != s3.length()){ return false;}\\n        \\n        boolean pathTable[][] = new boolean[s1.length() + 1][s2.length() + 1];// would be false by default.\\n        pathTable[0][0] = true;\\n        \\n        for(int i = 1; i < pathTable.length; i++){\\n            if(pathTable[i-1][0] && s1.charAt(i-1) == s3.charAt(i-1)){\\n                pathTable[i][0] = true;\\n            }\\n        }\\n        for(int j = 1; j < pathTable[0].length; j++){\\n            if(pathTable[0][j-1] && s2.charAt(j-1) == s3.charAt(j-1)){\\n                pathTable[0][j] = true;\\n            }\\n        }\\n        for(int i = 1; i < pathTable.length; i++){\\n            for(int j = 1; j < pathTable[0].length; j++){\\n                if(pathTable[i-1][j] && s1.charAt(i-1) == s3.charAt(i+j-1)){\\n                    pathTable[i][j] = true;\\n                }\\n                else if(pathTable[i][j-1] && s2.charAt(j-1) == s3.charAt(i+j-1)){\\n                    pathTable[i][j] = true;\\n                }\\n            }\\n        }\\n        return pathTable[pathTable.length - 1][pathTable[0].length - 1];\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\nFor this problem, we are trying to see if we can obtain s3 by interleaving s1 and s2. In other words, we need to figure out where each char of s3 comes from, s1 or s2 or nowhere. If we can find a way that all of the chars of s3 comes from s1 or s2, then we can form s3 by interleaving s1 and s2, and thus return true; otherwise we return false. For example, if s1 = abc, s2 = bcd, s3 = abbccd, then s3 can be formed by \"001011\" or \"010101\". (0 represents char comes from s1, and 1 represents char comes from s2). \\n\\nIt is easy to come up with a solution using recursion.\\n\\npublic class Solution {\\n\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        if(s1 == null || s1.length() == 0) {return s2.equals(s3);}",
                "codeTag": "Java"
            },
            {
                "id": 2248599,
                "title": "memoization-tabulation-space-optimization-c-dp-all-three-approach",
                "content": "# **C++ DP All Three Approach**\\n# 1. **C++ Memoization Solution**\\n```\\nclass Solution {\\npublic:\\n    bool rec(string s1,string s2,string s3,int i,int j,int k,vector<vector<int>>&dp){\\n        if(k==s3.size()&&i==s1.size()&&j==s2.size())return true;\\n        if(i>s1.size()||j>s2.size())return false;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        if(s3[k]==s2[j]&&s3[k]==s1[i]){\\n            return dp[i][j]= rec(s1,s2,s3,i+1,j,k+1,dp)||rec(s1,s2,s3,i,j+1,k+1,dp);\\n        }\\n        else if(s1[i]==s3[k]){\\n            return dp[i][j]= rec(s1,s2,s3,i+1,j,k+1,dp);\\n        }\\n        else if(s3[k]==s2[j]){\\n            return dp[i][j]= rec(s1,s2,s3,i,j+1,k+1,dp);\\n        }\\n        else{\\n            return dp[i][j]= false;\\n        }\\n    }\\n    bool isInterleave(string s1, string s2, string s3) {\\n        vector<vector<int>>dp(s1.size()+1,(vector<int>(s2.size()+1,-1)));\\n        return rec(s1,s2,s3,0,0,0,dp);\\n    }\\n};\\n```\\n# 2. **C++ Solution of DP Tabulation**\\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        vector<vector<int>>dp(s1.size()+1,(vector<int>(s2.size()+1,0)));\\n        if(s3.size()!=s1.size()+s2.size()){\\n            return false;\\n        }\\n        for(int i=s1.size();i>=0;i--){\\n            for(int j=s2.size();j>=0;j--){\\n                int k=i+j;\\n                if(i==s1.size()&&j==s2.size()){\\n                    dp[i][j]=1;\\n                }\\n                else if(s3[k]==s2[j]&&s3[k]==s1[i]){\\n                    dp[i][j]= dp[i+1][j]||dp[i][j+1];\\n                }\\n                else if(s1[i]==s3[k]){\\n                    dp[i][j]= dp[i+1][j];\\n                }\\n                else if(s3[k]==s2[j]){\\n                    dp[i][j]= dp[i][j+1];\\n                }\\n                else{\\n                    dp[i][j]= false;\\n                }  \\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```\\n# 3. **C++ Solution of Space Optimization**\\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        vector<int>cur(s2.size()+1,0),prev(s2.size()+1,0);\\n        if(s3.size()!=s1.size()+s2.size()){\\n            return false;\\n        }\\n        for(int i=s1.size();i>=0;i--){\\n            for(int j=s2.size();j>=0;j--){\\n                int k=i+j;\\n                if(i==s1.size()&&j==s2.size()){\\n                    cur[j]=1;\\n                }\\n                else if(s3[k]==s2[j]&&s3[k]==s1[i]){\\n                    cur[j]= prev[j]||cur[j+1];\\n                }\\n                else if(s1[i]==s3[k]){\\n                    cur[j]= prev[j];\\n                }\\n                else if(s3[k]==s2[j]){\\n                    cur[j]= cur[j+1];\\n                }\\n                else{\\n                    cur[j]= false;\\n                }  \\n            }\\n            prev=cur;\\n        }\\n        return cur[0];\\n    }\\n};\\n```\\n# **Please Share and Upvote**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool rec(string s1,string s2,string s3,int i,int j,int k,vector<vector<int>>&dp){\\n        if(k==s3.size()&&i==s1.size()&&j==s2.size())return true;\\n        if(i>s1.size()||j>s2.size())return false;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        if(s3[k]==s2[j]&&s3[k]==s1[i]){\\n            return dp[i][j]= rec(s1,s2,s3,i+1,j,k+1,dp)||rec(s1,s2,s3,i,j+1,k+1,dp);\\n        }\\n        else if(s1[i]==s3[k]){\\n            return dp[i][j]= rec(s1,s2,s3,i+1,j,k+1,dp);\\n        }\\n        else if(s3[k]==s2[j]){\\n            return dp[i][j]= rec(s1,s2,s3,i,j+1,k+1,dp);\\n        }\\n        else{\\n            return dp[i][j]= false;\\n        }\\n    }\\n    bool isInterleave(string s1, string s2, string s3) {\\n        vector<vector<int>>dp(s1.size()+1,(vector<int>(s2.size()+1,-1)));\\n        return rec(s1,s2,s3,0,0,0,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        vector<vector<int>>dp(s1.size()+1,(vector<int>(s2.size()+1,0)));\\n        if(s3.size()!=s1.size()+s2.size()){\\n            return false;\\n        }\\n        for(int i=s1.size();i>=0;i--){\\n            for(int j=s2.size();j>=0;j--){\\n                int k=i+j;\\n                if(i==s1.size()&&j==s2.size()){\\n                    dp[i][j]=1;\\n                }\\n                else if(s3[k]==s2[j]&&s3[k]==s1[i]){\\n                    dp[i][j]= dp[i+1][j]||dp[i][j+1];\\n                }\\n                else if(s1[i]==s3[k]){\\n                    dp[i][j]= dp[i+1][j];\\n                }\\n                else if(s3[k]==s2[j]){\\n                    dp[i][j]= dp[i][j+1];\\n                }\\n                else{\\n                    dp[i][j]= false;\\n                }  \\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        vector<int>cur(s2.size()+1,0),prev(s2.size()+1,0);\\n        if(s3.size()!=s1.size()+s2.size()){\\n            return false;\\n        }\\n        for(int i=s1.size();i>=0;i--){\\n            for(int j=s2.size();j>=0;j--){\\n                int k=i+j;\\n                if(i==s1.size()&&j==s2.size()){\\n                    cur[j]=1;\\n                }\\n                else if(s3[k]==s2[j]&&s3[k]==s1[i]){\\n                    cur[j]= prev[j]||cur[j+1];\\n                }\\n                else if(s1[i]==s3[k]){\\n                    cur[j]= prev[j];\\n                }\\n                else if(s3[k]==s2[j]){\\n                    cur[j]= cur[j+1];\\n                }\\n                else{\\n                    cur[j]= false;\\n                }  \\n            }\\n            prev=cur;\\n        }\\n        return cur[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1248268,
                "title": "js-python-java-c-easy-dp-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nIf we consider a matrix with indices (**i**) for **s1** on one axis and indices (**j**) for **s2** on the other, then a successful **s3** can be considered a path moving from the top left to the bottom right. At each point, we either move downward (**i++**) by choosing the next letter from **s1** or rightward (**j++**) by choosing the next letter from **s2**.\\n\\nAll that remains, then, is to see which vertices are possible given **s3**, and which ones are not. To do that, we can use a **dynamic programming** (**DP**) approach. Normally, we would establish a matrix as described above, along with a buffer row/column at the start of the matrix to provide space for previous row/column validation checks for the leading edges of our iteration. An additional row/column at the end of the matrix is also needed, since our final checks will occur only _after_ the strings are completed.\\n\\nWe can reduce the **space complexity** of this solution from **O(N * M)** to just **O(M)**, however, if rather than building a full DP matrix, we instead only keep the current row of the matrix (**dp**) in memory, reiterating through it for each row. The **left** value (**dp[j-1]**) will already have been calculated, and the **up** value (**dp[j]**) will not yet have been overwritten in the current cell, so it will still represent the value of the cell from the previous row.\\n\\nWe should also remember to fill **dp[1]** with a **true** (or **1**) value, representing a valid vertex at the starting position of our iteration path.\\n\\nFrom there, we can iterate through the rows, building upon previously completed entries to check the validity of the current cell. If the cell \"above\" (the not-yet-overwritten **dp[i]** represents the same index from the row above) is valid (**true** or **1**) and the corresponding characters of **s1** and **s3** match, then the current cell is valid. Similarly, if the cell to the left is valid and the corresponding characters of **s2** and **s3** match, then the current cell is valid.\\n\\nOnce we\\'ve finished iterating through **i** and **j**, a valid value in the last cell of **dp** will indicate that a valid path exists that matches **s3**, so we can just **return** the contents of that cell.\\n\\n - _**Time Complexity: O(N * M)** where **N** is the length of **s1** and **M** is the length of **s2**_\\n - _**Space Complexity: O(M)** for **dp**_\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **72ms / 38.7MB** (beats 99% / 93%).\\n```javascript\\nvar isInterleave = function(s1, s2, s3) {\\n    let n = s1.length + 2, m = s2.length + 2\\n    if (n + m - 4 !== s3.length) return false\\n    let dp = new Uint8Array(m)\\n    dp[1] = 1\\n    for (let i = 1; i < n; i++)\\n        for (let j = 1; j < m; j++) {\\n            let up = dp[j] && s1[i-2] === s3[j+i-3],\\n                left = dp[j-1] && s2[j-2] === s3[j+i-3]\\n            dp[j] = up || left\\n        }\\n    return dp[m-1]\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **36ms / 14.2MB** (beats 61% / 96%).\\n```python\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        n, m = len(s1) + 2, len(s2) + 2\\n        if n + m - 4 != len(s3): return False\\n        dp = [0] * m\\n        dp[1] = 1\\n        for i in range(1, n):\\n            for j in range(1, m):\\n                up = dp[j] and (i < 2 or s1[i-2] == s3[j+i-3])\\n                left = dp[j-1] and (j < 2 or s2[j-2] == s3[j+i-3])\\n                dp[j] = up or left\\n        return dp[-1]\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **2ms / 36.7MB** (beats 80% / 98%).\\n```java\\nclass Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        int n = s1.length() + 2, m = s2.length() + 2;\\n        char[] sc1 = s1.toCharArray(), sc2 = s2.toCharArray(), sc3 = s3.toCharArray();\\n        if (n + m - 4 != s3.length()) return false;\\n        boolean[] dp = new boolean[m];\\n        dp[1] = true;\\n        for (int i = 1; i < n; i++)\\n            for (int j = 1; j < m; j++) {\\n                boolean up = dp[j] && (i < 2 || sc1[i-2] == sc3[j+i-3]),\\n                    left =dp[j-1] && (j < 2 || sc2[j-2] == sc3[j+i-3]);\\n                dp[j] = up || left;\\n            }\\n        return dp[m-1];\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 6.6MB** (beats 100% / 61%).\\n```c++\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n = s1.length() + 2, m = s2.length() + 2;\\n        if (n + m - 4 != s3.length()) return false;\\n        vector<bool> dp(m);\\n        dp[1] = true;\\n        for (int i = 1; i < n; i++)\\n            for (int j = 1; j < m; j++) {\\n                bool up = dp[j] && (i < 2 || s1[i-2] == s3[j+i-3]),\\n                    left = dp[j-1] && (j < 2 || s2[j-2] == s3[j+i-3]);\\n               dp[j] = up || left;\\n            }\\n        return dp[m-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar isInterleave = function(s1, s2, s3) {\\n    let n = s1.length + 2, m = s2.length + 2\\n    if (n + m - 4 !== s3.length) return false\\n    let dp = new Uint8Array(m)\\n    dp[1] = 1\\n    for (let i = 1; i < n; i++)\\n        for (let j = 1; j < m; j++) {\\n            let up = dp[j] && s1[i-2] === s3[j+i-3],\\n                left = dp[j-1] && s2[j-2] === s3[j+i-3]\\n            dp[j] = up || left\\n        }\\n    return dp[m-1]\\n};\\n```\n```python\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        n, m = len(s1) + 2, len(s2) + 2\\n        if n + m - 4 != len(s3): return False\\n        dp = [0] * m\\n        dp[1] = 1\\n        for i in range(1, n):\\n            for j in range(1, m):\\n                up = dp[j] and (i < 2 or s1[i-2] == s3[j+i-3])\\n                left = dp[j-1] and (j < 2 or s2[j-2] == s3[j+i-3])\\n                dp[j] = up or left\\n        return dp[-1]\\n```\n```java\\nclass Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        int n = s1.length() + 2, m = s2.length() + 2;\\n        char[] sc1 = s1.toCharArray(), sc2 = s2.toCharArray(), sc3 = s3.toCharArray();\\n        if (n + m - 4 != s3.length()) return false;\\n        boolean[] dp = new boolean[m];\\n        dp[1] = true;\\n        for (int i = 1; i < n; i++)\\n            for (int j = 1; j < m; j++) {\\n                boolean up = dp[j] && (i < 2 || sc1[i-2] == sc3[j+i-3]),\\n                    left =dp[j-1] && (j < 2 || sc2[j-2] == sc3[j+i-3]);\\n                dp[j] = up || left;\\n            }\\n        return dp[m-1];\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n = s1.length() + 2, m = s2.length() + 2;\\n        if (n + m - 4 != s3.length()) return false;\\n        vector<bool> dp(m);\\n        dp[1] = true;\\n        for (int i = 1; i < n; i++)\\n            for (int j = 1; j < m; j++) {\\n                bool up = dp[j] && (i < 2 || s1[i-2] == s3[j+i-3]),\\n                    left = dp[j-1] && (j < 2 || s2[j-2] == s3[j+i-3]);\\n               dp[j] = up || left;\\n            }\\n        return dp[m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2249641,
                "title": "c-based-on-aditya-verma-concept-recursion-memoization",
                "content": "**Plz Upvote!**! You will loose nothing ):):\\n\\n```\\nclass Solution {\\n  public:\\n    int dp[102][102];\\n  bool solve(string s1, string s2, string s3, int x, int y, int z) {\\n    if (x < 0 and y < 0 and z < 0) return true;\\n    if (x >= 0 and y >= 0 and dp[x][y] != -1) return dp[x][y];\\n    if (x >= 0 and s1[x] == s3[z] and y >= 0 and s2[y] == s3[z])\\n      return dp[x][y] = solve(s1, s2, s3, x - 1, y, z - 1) or solve(s1, s2, s3, x, y - 1, z - 1);\\n    else if (x >= 0 and s1[x] == s3[z])\\n      return solve(s1, s2, s3, x - 1, y, z - 1);\\n    else if (y >= 0 and s2[y] == s3[z])\\n      return solve(s1, s2, s3, x, y - 1, z - 1);\\n    else\\n      return false;\\n  }\\n  bool isInterleave(string s1, string s2, string s3) {\\n    memset(dp, -1, sizeof(dp));\\n    int x = s1.size(), y = s2.size(), z = s3.size();\\n    if (x + y != z) return false;\\n    return solve(s1, s2, s3, x - 1, y - 1, z - 1);\\n  }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n  public:\\n    int dp[102][102];\\n  bool solve(string s1, string s2, string s3, int x, int y, int z) {\\n    if (x < 0 and y < 0 and z < 0) return true;\\n    if (x >= 0 and y >= 0 and dp[x][y] != -1) return dp[x][y];\\n    if (x >= 0 and s1[x] == s3[z] and y >= 0 and s2[y] == s3[z])\\n      return dp[x][y] = solve(s1, s2, s3, x - 1, y, z - 1) or solve(s1, s2, s3, x, y - 1, z - 1);\\n    else if (x >= 0 and s1[x] == s3[z])\\n      return solve(s1, s2, s3, x - 1, y, z - 1);\\n    else if (y >= 0 and s2[y] == s3[z])\\n      return solve(s1, s2, s3, x, y - 1, z - 1);\\n    else\\n      return false;\\n  }",
                "codeTag": "Java"
            },
            {
                "id": 1246668,
                "title": "c-super-short-and-easy-dp-clean-solutions-1d-2d",
                "content": "**Solution I - Using 2D Dynamic Programming Array**\\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        #define S1 (dp[i-1][j] && s1[i-1] == s3[i+j-1])\\n        #define S2 (dp[i][j-1] && s2[j-1] == s3[i+j-1])\\n        \\n        int n = s1.size(), m = s2.size(), k = s3.size();\\n        if (n + m != k) return false;\\n        vector<vector<bool>> dp(n+1, vector<bool>(m+1, 0));\\n        \\n        for (int i = 0; i <= n; i++) {\\n            for (int j = 0; j <= m; j++) {\\n                dp[i][j] = (i==0 && j==0) ? true : i==0 ? S2 : j==0 ? S1 : S1 || S2;\\n            }\\n        }\\n\\n        return dp[n][m];\\n    }\\n};\\n```\\n****\\n**Solution II - Using 1D Array**\\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        #define S1 (dp[j] && s1[i-1] == s3[i+j-1])\\n        #define S2 (dp[j-1] && s2[j-1] == s3[i+j-1])\\n        \\n        int n = s1.size(), m = s2.size(), k = s3.size();\\n        if (n + m != k) return false;\\n        vector<bool> dp(m+1, 0);\\n        \\n        for (int i = 0; i <= n; i++) {\\n            for (int j = 0; j <= m; j++) {\\n                dp[j] = (i==0 && j==0) ? true : i==0 ? S2 : j==0 ? S1 : S1 || S2;\\n            }\\n        }\\n\\n        return dp[m];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        #define S1 (dp[i-1][j] && s1[i-1] == s3[i+j-1])\\n        #define S2 (dp[i][j-1] && s2[j-1] == s3[i+j-1])\\n        \\n        int n = s1.size(), m = s2.size(), k = s3.size();\\n        if (n + m != k) return false;\\n        vector<vector<bool>> dp(n+1, vector<bool>(m+1, 0));\\n        \\n        for (int i = 0; i <= n; i++) {\\n            for (int j = 0; j <= m; j++) {\\n                dp[i][j] = (i==0 && j==0) ? true : i==0 ? S2 : j==0 ? S1 : S1 || S2;\\n            }\\n        }\\n\\n        return dp[n][m];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        #define S1 (dp[j] && s1[i-1] == s3[i+j-1])\\n        #define S2 (dp[j-1] && s2[j-1] == s3[i+j-1])\\n        \\n        int n = s1.size(), m = s2.size(), k = s3.size();\\n        if (n + m != k) return false;\\n        vector<bool> dp(m+1, 0);\\n        \\n        for (int i = 0; i <= n; i++) {\\n            for (int j = 0; j <= m; j++) {\\n                dp[j] = (i==0 && j==0) ? true : i==0 ? S2 : j==0 ? S1 : S1 || S2;\\n            }\\n        }\\n\\n        return dp[m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2249302,
                "title": "c-3-approaches-dynamic-programming-easy-explaination",
                "content": "**Interleaving String**\\n<img src=\"https://assets.leetcode.com/users/images/c226f83a-6580-4772-87e7-bda924c43e8e_1657173986.7404857.png?raw=true\" width=\"800px\" height=\"400px\" alt=\"R8_gcn_test\" align=center />\\n\\n\\n\\n\\nAs problem name suggest we need to check interleaving of strings in another string and if it\\'s not the case then return false. \\n\\nWe can try on 3 approaches : 1. Bruteforce 2. Iterative / Recursive 3. Dynamic programming\\n\\n**Bruteforce approach 1** :   TLE \\uD83D\\uDE36\\n\\nC++ || PYTHON\\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int m = s1.size(), n = s2.size(), k = s3.size();\\n        if (m + n != k) return false;\\n            while(m > 0 && n > 0 && s1[m-1] == s2[n-1] && s1[m-1] == s3[k-1]) {\\n                m--;\\n                n--;\\n                k--;\\n            }\\n            while(m > 0 && s1[m-1] == s3[k-1]) {\\n                m--;\\n                k--;\\n            }\\n            while(n > 0 && s2[n-1] == s3[k-1]) {\\n                n--;\\n                k--;\\n            }\\n            if (m == 0 && n == 0) return true;\\n            if (m == 0) return s2.substr(0, n) == s3.substr(0, n);\\n            if (n == 0) return s1.substr(0, m) == s3.substr(0, m);\\n            return s1.substr(0, m) == s3.substr(0, m) && s2.substr(0, n) == s3.substr(m, n);     \\n    }\\n};\\n```\\n\\n\\n```\\nclass Solution(object):\\n    def isInterleave(self, s1, s2, s3):\\n        f1 = list(s1)\\n        f2 = list(s2)\\n        f3 = list(s3)\\n\\n        if len(f1) + len(f2) != len(f3):\\n            return False\\n\\n        if len(f1) == 0:\\n            return f2 == f3\\n\\n        if len(f2) == 0:\\n            return f1 == f3\\n\\n        if len(f1) == 1:\\n            return f1[0] == f3[0] and f2 == f3[1:]\\n\\n        if len(f2) == 1:\\n            return f1 == f3[0:] and f2[0] == f3[-1]\\n\\n\\n        for i in range(len(f1)):\\n            if f1[i] not in f3:\\n                return False\\n\\n        for i in range(len(f2)):\\n            if f2[i] not in f3:\\n                return False\\n        \\n        i =0\\n\\n        while(i != len(s3)):\\n            if s1[i] == s3[i]:\\n                i += 1\\n            if s2[i] == s3[i]:\\n                i += 1\\n            \\n            if s1[i] != s3[i] or s2[i] != s3[i]:\\n                return False\\n        \\n        return True \\n```\\n\\n**Approach 2 Iterative** \\n\\nFor recursive approach we will use same manner as we did in bruteforce but here the stopping condition will work for us :\\n\\nWe will call the function by comparing between the string s1 and s2 whether they are folowing the order or not. \\n\\n**Time complexity** : O(2^m+n) where m & n are size of both strings \\n\\nexponential of 2 as each character in s3 has 2 option everytime it is moving. \\n\\n C++ || Python\\n \\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int m = s1.size(), n = s2.size(), k = s3.size();\\n        if (m + n != k) return false;\\n        while(m > 0 && n > 0 && s1[m-1] == s2[n-1] && s1[m-1] == s3[k-1]) {\\n            m--;\\n            n--;\\n            k--;\\n        }\\n        if (m == 0 && n == 0) return true;\\n        if (m == 0) return s2.substr(0, n) == s3.substr(0, n);\\n        if (n == 0) return s1.substr(0, m) == s3.substr(0, m);\\n        if (s1[m-1] == s3[k-1]) return isInterleave(s1.substr(0, m-1), s2, s3.substr(0, k-1));\\n\\n        if (s2[n-1] == s3[k-1]) return isInterleave(s1, s2.substr(0, n-1), s3.substr(0, k-1));\\n        return false;\\n    }\\n};\\n```\\n\\n \\n \\n```\\nclass Solution(object):\\n    def isInterleave(self, s1, s2, s3):\\n        if len(s1) + len(s2) !=len(s3):\\n            return False\\n\\n        if len(s1) == 0:\\n            return s2 == s3\\n        if len(s2) == 0:\\n            return s1 == s3\\n\\n        if s1[0] == s2[0] and s1[0] == s3[0]:\\n            return self.isInterleave(s1[1:], s2, s3[1:]) or self.isInterleave(s1, s2[1:], s3[1:])\\n        elif s1[0] == s3[0]:\\n            return self.isInterleave(s1[1:], s2, s3[1:])\\n        elif s2[0] == s3[0]:\\n            return self.isInterleave(s1, s2[1:], s3[1:])\\n        else:\\n            return False\\n```\\n\\n**Dynamic programming** \\n\\nThe DP approach(Momoisation) is easy here as we only need to store the order and if order change we will change the subsequence that we are following and move to next subsequence.\\n\\n**Time complexity** : O(m.n) \\n\\nThe image showing if we use to traverse all the branches in the tree and not storing the information from each levels in the worst case we might need to traverse all the paths when no element is matching or interleaving in the next string.\\n\\n**IF WE DO NOT STORE IN ANY COLLECTION** : Each level in tree showing the char positions in s3 and total number of level are equal to the length of the string s3. For example root level 1st char and 2nd level 2nd char and so on. When ever we have a match we start it as either in s1 or s2 if match in s1 we will start that path if match in s2 we will take that path and traverse untill mismatch occur. In this order we need to parse every path. \\n\\n\\n\\n<img src=\"https://assets.leetcode.com/users/images/d6aab695-2ad1-4810-b12b-1881f76dbf50_1657175724.992637.png \" width=\"800px\" height=\"800px\" alt=\"R8_gcn_test\" align=center />\\n\\nC++ || PYTHON \\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int m = s1.size(), n = s2.size(), k = s3.size();\\n        if (m + n != k) return false;\\n        vector<vector<bool>> dp(m + 1, vector<bool>(n + 1, false));\\n        for (int i = 0; i <= m; i++) {\\n            for (int j = 0; j <= n; j++) {\\n                if (i == 0 && j == 0) dp[i][j] = true;\\n                else if (i == 0) dp[i][j] = dp[i][j - 1] && s2[j - 1] == s3[i + j - 1];\\n                else if (j == 0) dp[i][j] = dp[i - 1][j] && s1[i - 1] == s3[i + j - 1];\\n                else dp[i][j] = (dp[i - 1][j] && s1[i - 1] == s3[i + j - 1]) || (dp[i][j - 1] && s2[j - 1] == s3[i + j - 1]);\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```\\n\\n\\n\\n```\\nclass Solution(object):\\n    def isInterleave(self, s1, s2, s3):\\n        if len(s1) + len(s2) != len(s3):\\n            return False\\n        dp = [[False for _ in range(len(s2) + 1)] for _ in range(len(s1) + 1)]\\n        for i in range(len(s1) + 1):\\n            for j in range(len(s2) + 1):\\n                if i == 0 and j == 0:\\n                    dp[i][j] = True\\n                elif i == 0:\\n                    dp[i][j] = dp[i][j - 1] and s2[j - 1] == s3[i + j - 1]\\n                elif j == 0:\\n                    dp[i][j] = dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]\\n                else:\\n                    dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\\n        return dp[len(s1)][len(s2)]\\n```\\n \\n**Consider upvote if you find it useful\\uD83D\\uDE03** \\n\\n**Thanks in advance \\u2764\\uFE0F\\u2764\\uFE0F\\u2764\\uFE0F**\\n\\n",
                "solutionTags": [
                    "Python",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int m = s1.size(), n = s2.size(), k = s3.size();\\n        if (m + n != k) return false;\\n            while(m > 0 && n > 0 && s1[m-1] == s2[n-1] && s1[m-1] == s3[k-1]) {\\n                m--;\\n                n--;\\n                k--;\\n            }\\n            while(m > 0 && s1[m-1] == s3[k-1]) {\\n                m--;\\n                k--;\\n            }\\n            while(n > 0 && s2[n-1] == s3[k-1]) {\\n                n--;\\n                k--;\\n            }\\n            if (m == 0 && n == 0) return true;\\n            if (m == 0) return s2.substr(0, n) == s3.substr(0, n);\\n            if (n == 0) return s1.substr(0, m) == s3.substr(0, m);\\n            return s1.substr(0, m) == s3.substr(0, m) && s2.substr(0, n) == s3.substr(m, n);     \\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def isInterleave(self, s1, s2, s3):\\n        f1 = list(s1)\\n        f2 = list(s2)\\n        f3 = list(s3)\\n\\n        if len(f1) + len(f2) != len(f3):\\n            return False\\n\\n        if len(f1) == 0:\\n            return f2 == f3\\n\\n        if len(f2) == 0:\\n            return f1 == f3\\n\\n        if len(f1) == 1:\\n            return f1[0] == f3[0] and f2 == f3[1:]\\n\\n        if len(f2) == 1:\\n            return f1 == f3[0:] and f2[0] == f3[-1]\\n\\n\\n        for i in range(len(f1)):\\n            if f1[i] not in f3:\\n                return False\\n\\n        for i in range(len(f2)):\\n            if f2[i] not in f3:\\n                return False\\n        \\n        i =0\\n\\n        while(i != len(s3)):\\n            if s1[i] == s3[i]:\\n                i += 1\\n            if s2[i] == s3[i]:\\n                i += 1\\n            \\n            if s1[i] != s3[i] or s2[i] != s3[i]:\\n                return False\\n        \\n        return True \\n```\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int m = s1.size(), n = s2.size(), k = s3.size();\\n        if (m + n != k) return false;\\n        while(m > 0 && n > 0 && s1[m-1] == s2[n-1] && s1[m-1] == s3[k-1]) {\\n            m--;\\n            n--;\\n            k--;\\n        }\\n        if (m == 0 && n == 0) return true;\\n        if (m == 0) return s2.substr(0, n) == s3.substr(0, n);\\n        if (n == 0) return s1.substr(0, m) == s3.substr(0, m);\\n        if (s1[m-1] == s3[k-1]) return isInterleave(s1.substr(0, m-1), s2, s3.substr(0, k-1));\\n\\n        if (s2[n-1] == s3[k-1]) return isInterleave(s1, s2.substr(0, n-1), s3.substr(0, k-1));\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def isInterleave(self, s1, s2, s3):\\n        if len(s1) + len(s2) !=len(s3):\\n            return False\\n\\n        if len(s1) == 0:\\n            return s2 == s3\\n        if len(s2) == 0:\\n            return s1 == s3\\n\\n        if s1[0] == s2[0] and s1[0] == s3[0]:\\n            return self.isInterleave(s1[1:], s2, s3[1:]) or self.isInterleave(s1, s2[1:], s3[1:])\\n        elif s1[0] == s3[0]:\\n            return self.isInterleave(s1[1:], s2, s3[1:])\\n        elif s2[0] == s3[0]:\\n            return self.isInterleave(s1, s2[1:], s3[1:])\\n        else:\\n            return False\\n```\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int m = s1.size(), n = s2.size(), k = s3.size();\\n        if (m + n != k) return false;\\n        vector<vector<bool>> dp(m + 1, vector<bool>(n + 1, false));\\n        for (int i = 0; i <= m; i++) {\\n            for (int j = 0; j <= n; j++) {\\n                if (i == 0 && j == 0) dp[i][j] = true;\\n                else if (i == 0) dp[i][j] = dp[i][j - 1] && s2[j - 1] == s3[i + j - 1];\\n                else if (j == 0) dp[i][j] = dp[i - 1][j] && s1[i - 1] == s3[i + j - 1];\\n                else dp[i][j] = (dp[i - 1][j] && s1[i - 1] == s3[i + j - 1]) || (dp[i][j - 1] && s2[j - 1] == s3[i + j - 1]);\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def isInterleave(self, s1, s2, s3):\\n        if len(s1) + len(s2) != len(s3):\\n            return False\\n        dp = [[False for _ in range(len(s2) + 1)] for _ in range(len(s1) + 1)]\\n        for i in range(len(s1) + 1):\\n            for j in range(len(s2) + 1):\\n                if i == 0 and j == 0:\\n                    dp[i][j] = True\\n                elif i == 0:\\n                    dp[i][j] = dp[i][j - 1] and s2[j - 1] == s3[i + j - 1]\\n                elif j == 0:\\n                    dp[i][j] = dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]\\n                else:\\n                    dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\\n        return dp[len(s1)][len(s2)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2248648,
                "title": "o-mn-dp-using-one-array-of-size-s2-length-python-c",
                "content": "**Upvote** if you like efficient solution code!\\n\\n**Join our discord** to meet other people preparing for interviews!\\n**https://discord.gg/7wpQQFYC**\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n\\t\\tif (s1.length() + s2.length() != s3.length()) return false;\\n\\t\\tif (s1.length() < s2.length()) swap(s1, s2);\\n\\t\\tint m = s1.length(), n = s2.length();\\n\\t\\t\\t\\n        vector<bool> dp(n + 1, false);\\n        dp[0] = true;\\n        for (int j = 1; j <= n; j++) {\\n            dp[j] = s3[j - 1] == s2[j - 1] && dp[j - 1];\\n        }\\n\\n        for (int i = 1; i <= m; i++) {\\n            dp[0] = s3[i - 1] == s1[i - 1] && dp[0];\\n            for (int j = 1; j <= n; j++) {\\n                dp[j] = (s3[i + j - 1] == s1[i - 1] && dp[j]);\\n                dp[j] = dp[j] || (s3[i + j - 1] == s2[j - 1] && dp[j - 1]);\\n            }\\n        }\\n        return dp.back();\\n    }\\n};\\n```\\n\\n**Python3**\\n```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3):\\n            return False\\n        if len(s1) < len(s2):\\n            s1, s2 = s2, s1\\n        m, n = len(s1), len(s2)\\n        \\n        dp = [True] + [False] * n\\n        for j in range(1, n + 1):\\n            dp[j] = s2[j - 1] == s3[j - 1] and dp[j - 1]\\n\\n        for i in range(1, m + 1):\\n            dp[0] = s1[i - 1] == s3[i - 1] and dp[0]\\n            for j in range(1, n + 1):\\n                dp[j] = (s1[i - 1] == s3[i + j - 1] and dp[j])\\n                dp[j] = dp[j] or (s2[j - 1] == s3[i + j - 1] and dp[j - 1])\\n        return dp[-1]\\n```\\n\\n**Time Complexity** O(mn) - A for-loop running `m` iterations with another for-loop running `n` iterations nested inside.\\n**Space Complexity** O(n) - A single array of size `n`.",
                "solutionTags": [
                    "C++",
                    "Python"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n\\t\\tif (s1.length() + s2.length() != s3.length()) return false;\\n\\t\\tif (s1.length() < s2.length()) swap(s1, s2);\\n\\t\\tint m = s1.length(), n = s2.length();\\n\\t\\t\\t\\n        vector<bool> dp(n + 1, false);\\n        dp[0] = true;\\n        for (int j = 1; j <= n; j++) {\\n            dp[j] = s3[j - 1] == s2[j - 1] && dp[j - 1];\\n        }\\n\\n        for (int i = 1; i <= m; i++) {\\n            dp[0] = s3[i - 1] == s1[i - 1] && dp[0];\\n            for (int j = 1; j <= n; j++) {\\n                dp[j] = (s3[i + j - 1] == s1[i - 1] && dp[j]);\\n                dp[j] = dp[j] || (s3[i + j - 1] == s2[j - 1] && dp[j - 1]);\\n            }\\n        }\\n        return dp.back();\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3):\\n            return False\\n        if len(s1) < len(s2):\\n            s1, s2 = s2, s1\\n        m, n = len(s1), len(s2)\\n        \\n        dp = [True] + [False] * n\\n        for j in range(1, n + 1):\\n            dp[j] = s2[j - 1] == s3[j - 1] and dp[j - 1]\\n\\n        for i in range(1, m + 1):\\n            dp[0] = s1[i - 1] == s3[i - 1] and dp[0]\\n            for j in range(1, n + 1):\\n                dp[j] = (s1[i - 1] == s3[i + j - 1] and dp[j])\\n                dp[j] = dp[j] or (s2[j - 1] == s3[i + j - 1] and dp[j - 1])\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2248511,
                "title": "java-dp-based-solution-w-video-explanation-1ms",
                "content": "*Please **upvote** if you find this helpful*\\n\\n**Video Explanation**\\n\\n[Interleaving String | YouTube](https://www.youtube.com/watch?v=kbuYSSW54tk&feature=youtu.be)\\n\\n**Java Solution**\\n\\n```\\n//1ms\\nclass Solution {\\n    private boolean[][] invalid;\\n    private char[] c1;\\n    private char[] c2;\\n    private char[] c3;\\n    \\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        c1 = s1.toCharArray();\\n        c2 = s2.toCharArray();\\n        c3 = s3.toCharArray();\\n        \\n        int m = s1.length(),n=s2.length();\\n        \\n        if(m+n != s3.length())\\n            return false;\\n        \\n        invalid = new boolean[m+1][n+1];\\n        \\n        return dfs(0,0,0);\\n    }\\n    \\n    public boolean dfs(int i, int j, int k){\\n        if(invalid[i][j])\\n            return false;\\n        \\n        if(k == c3.length)\\n            return true;\\n        \\n        boolean valid = \\n            i<c1.length && c1[i] == c3[k] && dfs(i+1,j,k+1) || \\n            j<c2.length && c2[j] == c3[k] && dfs(i,j+1,k+1);\\n        \\n        if(!valid)\\n            invalid[i][j] = true;\\n        \\n        return valid;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n//1ms\\nclass Solution {\\n    private boolean[][] invalid;\\n    private char[] c1;\\n    private char[] c2;\\n    private char[] c3;\\n    \\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        c1 = s1.toCharArray();\\n        c2 = s2.toCharArray();\\n        c3 = s3.toCharArray();\\n        \\n        int m = s1.length(),n=s2.length();\\n        \\n        if(m+n != s3.length())\\n            return false;\\n        \\n        invalid = new boolean[m+1][n+1];\\n        \\n        return dfs(0,0,0);\\n    }\\n    \\n    public boolean dfs(int i, int j, int k){\\n        if(invalid[i][j])\\n            return false;\\n        \\n        if(k == c3.length)\\n            return true;\\n        \\n        boolean valid = \\n            i<c1.length && c1[i] == c3[k] && dfs(i+1,j,k+1) || \\n            j<c2.length && c2[j] == c3[k] && dfs(i,j+1,k+1);\\n        \\n        if(!valid)\\n            invalid[i][j] = true;\\n        \\n        return valid;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31910,
                "title": "4ms-recursive-java",
                "content": "    public class Solution {\\n        Set<String> mem = new HashSet<String>();\\n        public boolean isInterleave(String s1, String s2, String s3) {\\n            if(s1.length() == 0 && s2.length() == 0 && s3.length() == 0)\\n                return true;\\n            if(mem.contains(s1+\"#\"+s2)) \\n                return false;\\n            if(s3.length() > 0){\\n                if(s1.length() > 0 &&  s1.charAt(0) == s3.charAt(0))\\n                    if(isInterleave(s1.substring(1),s2,s3.substring(1))) return true;\\n                if(s2.length() > 0 && s2.charAt(0) == s3.charAt(0))\\n                    if(isInterleave(s1,s2.substring(1),s3.substring(1))) return true;\\n            }\\n            mem.add(s1+\"#\"+s2);\\n            return false;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        Set<String> mem = new HashSet<String>();\\n        public boolean isInterleave(String s1, String s2, String s3) {\\n            if(s1.length() == 0 && s2.length() == 0 && s3.length() == 0)\\n                return true;\\n            if(mem.contains(s1+\"#\"+s2)) \\n                return false;\\n            if(s3.length() > 0){\\n                if(s1.length() > 0 &&  s1.charAt(0) == s3.charAt(0))\\n                    if(isInterleave(s1.substring(1),s2,s3.substring(1))) return true;\\n                if(s2.length() > 0 && s2.charAt(0) == s3.charAt(0))\\n                    if(isInterleave(s1,s2.substring(1),s3.substring(1))) return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3956989,
                "title": "dp-easy-best-approach",
                "content": "# Intuition\\nEasy Best Approach!!!\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nDynamic Programming Approach:\\n\\nThe key insight in this problem is to use dynamic programming to check if a certain interleaving of s1 and s2 can form s3. The DP array will be used to keep track of whether a certain prefix of s3 can be formed by interleaving a prefix of s1 and a prefix of s2.\\n\\nHere\\'s how the dynamic programming approach works:\\n\\nInitialization: Create a DP array dp of dimensions (len_s1 + 1) \\xD7 (len_s2 + 1). dp[i][j] will be True if the first i characters of s1 and the first j characters of s2 can interleave to form the first i + j characters of s3. Initialize dp[0][0] to True since two empty strings can form an empty string.\\n\\nBase Cases: Initialize the first row and the first column of the DP array. dp[0][j] is True if dp[0][j-1] is True and s2[j-1] matches s3[j-1]. Similarly, dp[i][0] is True if dp[i-1][0] is True and s1[i-1] matches s3[i-1].\\n\\nFilling the DP Array: Loop through the remaining cells of the DP array (starting from i = 1 and j = 1). The idea is to check if the current character in s3, which is s3[i+j-1], can be formed by either appending a character from s1 or a character from s2 to the previously formed interleaved strings.\\n\\nIf s1[i-1] matches s3[i+j-1] and dp[i-1][j] is True, then dp[i][j] is True.\\nIf s2[j-1] matches s3[i+j-1] and dp[i][j-1] is True, then dp[i][j] is True.\\nFinal Result: After filling the DP array, the value of dp[len_s1][len_s2] will indicate whether the entire strings s1 and s2 can interleave to form the entire string s3.\\n\\nThis approach ensures that you\\'re considering all possible interleavings and checking if each character in s3 can be formed by interweaving characters from s1 and s2 in a valid manner.\\n\\nRemember, this is just one way to approach the problem using dynamic programming. There might be other creative ways to solve this problem as well.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(len_s1 * len_s2)\\n- $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(len_s1 * len_s2)\\n- $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        len_s1, len_s2, len_s3 = len(s1), len(s2), len(s3)\\n        \\n        # If the total length of s1 and s2 is not equal to s3, it\\'s impossible\\n        if len_s1 + len_s2 != len_s3:\\n            return False\\n        \\n        # Create a 2D DP array to store intermediate results\\n        dp = [[False] * (len_s2 + 1) for _ in range(len_s1 + 1)]\\n        \\n        # Base case: empty strings can always interleave to form an empty string\\n        dp[0][0] = True\\n        \\n        # Fill the first row\\n        for j in range(1, len_s2 + 1):\\n            dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\\n        \\n        # Fill the first column\\n        for i in range(1, len_s1 + 1):\\n            dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\\n        \\n        # Fill the DP array\\n        for i in range(1, len_s1 + 1):\\n            for j in range(1, len_s2 + 1):\\n                # Check if the current position in s3 can be formed by interleaving\\n                dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or \\\\\\n                           (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\\n        \\n        return dp[len_s1][len_s2]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        len_s1, len_s2, len_s3 = len(s1), len(s2), len(s3)\\n        \\n        # If the total length of s1 and s2 is not equal to s3, it\\'s impossible\\n        if len_s1 + len_s2 != len_s3:\\n            return False\\n        \\n        # Create a 2D DP array to store intermediate results\\n        dp = [[False] * (len_s2 + 1) for _ in range(len_s1 + 1)]\\n        \\n        # Base case: empty strings can always interleave to form an empty string\\n        dp[0][0] = True\\n        \\n        # Fill the first row\\n        for j in range(1, len_s2 + 1):\\n            dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\\n        \\n        # Fill the first column\\n        for i in range(1, len_s1 + 1):\\n            dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\\n        \\n        # Fill the DP array\\n        for i in range(1, len_s1 + 1):\\n            for j in range(1, len_s2 + 1):\\n                # Check if the current position in s3 can be formed by interleaving\\n                dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or \\\\\\n                           (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\\n        \\n        return dp[len_s1][len_s2]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32083,
                "title": "my-solution-in-java-using-dp-time-o-n-m-and-space-o-m",
                "content": "Using dp to tracking select i-th seq and j-th seq in s1 and s2 could match i+j+2 th seq in s3\\n\\n 1. init optimal[0][*] by check no select from s1\\n 2. init optimal[*][0] by check no select from s2\\n 3. do search for every i-th and j-th, could match when meet one of the following two cases:\\n1. if i-th char in s2 equals to the (i+j+1)th char in s3, and previous j-th in s2 is matched without i-th char\\n2. if j-th char in s1 equals to the (i+j+1)th char in s3, and previous j-1th in s2 is matched with i-th char\\n 4. a straight-forward solution should be Time: O(n*m), and Space: O(n*m). And space could optimize since optimal[i+1][*] only depends on optimal[i][*], so could use Space O(m)\\n\\n\\n----------\\nJava code as following:\\n\\n    public static boolean isInterleaveOptz(String s1, String s2, String s3) {\\n        if (s3.length() != s1.length() + s2.length()) return false;\\n\\n        boolean[] optimal = new boolean[s2.length() + 1];    //dp optimal\\n        optimal[0] = true;\\n        for (int j = 0; j < s2.length(); j++) { //check no s1 char is selected, if s2 could equals to s3\\n            if (optimal[j] && s2.charAt(j) == s3.charAt(j)) optimal[j + 1] = true;\\n        }\\n\\n        for (int i = 0; i < s1.length(); i++) { //check select i-th char in s1\\n            if (optimal[0] && s1.charAt(i) == s3.charAt(i)) optimal[0] = true;    //no char in s2 is selected\\n            else optimal[0] = false;\\n            for (int j = 0; j < s2.length(); j++) {  //select j-th char\\n                if ((s1.charAt(i) == s3.charAt(i + j + 1) && optimal[j + 1]) ||\\n                        s2.charAt(j) == s3.charAt(i + j + 1) && optimal[j]) {\\n                    optimal[j + 1] = true;\\n                } else optimal[j + 1] = false;\\n            }\\n        }\\n        return optimal[s2.length()];\\n    }",
                "solutionTags": [],
                "code": "Using dp to tracking select i-th seq and j-th seq in s1 and s2 could match i+j+2 th seq in s3\\n\\n 1. init optimal[0][*] by check no select from s1\\n 2. init optimal[*][0] by check no select from s2\\n 3. do search for every i-th and j-th, could match when meet one of the following two cases:\\n1. if i-th char in s2 equals to the (i+j+1)th char in s3, and previous j-th in s2 is matched without i-th char\\n2. if j-th char in s1 equals to the (i+j+1)th char in s3, and previous j-1th in s2 is matched with i-th char\\n 4. a straight-forward solution should be Time: O(n*m), and Space: O(n*m). And space could optimize since optimal[i+1][*] only depends on optimal[i][*], so could use Space O(m)\\n\\n\\n----------\\nJava code as following:\\n\\n    public static boolean isInterleaveOptz(String s1, String s2, String s3) {\\n        if (s3.length() != s1.length() + s2.length()) return false;\\n\\n        boolean[] optimal = new boolean[s2.length() + 1];    //dp optimal\\n        optimal[0] = true;\\n        for (int j = 0; j < s2.length(); j++) { //check no s1 char is selected, if s2 could equals to s3\\n            if (optimal[j] && s2.charAt(j) == s3.charAt(j)) optimal[j + 1] = true;\\n        }\\n\\n        for (int i = 0; i < s1.length(); i++) { //check select i-th char in s1\\n            if (optimal[0] && s1.charAt(i) == s3.charAt(i)) optimal[0] = true;    //no char in s2 is selected\\n            else optimal[0] = false;\\n            for (int j = 0; j < s2.length(); j++) {  //select j-th char\\n                if ((s1.charAt(i) == s3.charAt(i + j + 1) && optimal[j + 1]) ||\\n                        s2.charAt(j) == s3.charAt(i + j + 1) && optimal[j]) {\\n                    optimal[j + 1] = true;\\n                } else optimal[j + 1] = false;\\n            }\\n        }\\n        return optimal[s2.length()];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3956731,
                "title": "easy-solution-python3-c-c-java-using-dfs-with-image",
                "content": "```Python3 []\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3):\\n            return False\\n\\n        dp = [ [False] * (len(s2) + 1) for i in range(len(s1) + 1)]\\n        dp[len(s1)][len(s2)] = True\\n\\n        for i in range(len(s1), -1, -1):\\n            for j in range(len(s2), -1, -1):\\n                if i < len(s1) and s1[i] == s3[i +j] and dp[i + 1][j]:\\n                    dp[i][j] = True\\n                if j < len(s2) and s2[j] == s3[i + j] and dp[i][j + 1]:\\n                    dp[i][j] = True\\n        return dp[0][0]\\n\\n\\n\\n        dp = {}\\n        def dfs(i, j):\\n            if i == len(s1) and j == len(s2):\\n                return True\\n            if (i, j) in dp:\\n                return dp[(i, j)]\\n\\n            if i < len(s1) and s1[i] == s3[i+j] and dfs(i + 1, j):\\n                return True\\n            \\n            if j < len(s2) and s2[j] == s3[i + j] and dfs(i, j + 1):\\n                return True\\n            \\n            dp[(i, j)] = False\\n            return False\\n        return dfs(0, 0)\\n```\\n```python []\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3):\\n            return False\\n\\n        dp = [ [False] * (len(s2) + 1) for i in range(len(s1) + 1)]\\n        dp[len(s1)][len(s2)] = True\\n\\n        for i in range(len(s1), -1, -1):\\n            for j in range(len(s2), -1, -1):\\n                if i < len(s1) and s1[i] == s3[i +j] and dp[i + 1][j]:\\n                    dp[i][j] = True\\n                if j < len(s2) and s2[j] == s3[i + j] and dp[i][j + 1]:\\n                    dp[i][j] = True\\n        return dp[0][0]\\n\\n\\n\\n        dp = {}\\n        def dfs(i, j):\\n            if i == len(s1) and j == len(s2):\\n                return True\\n            if (i, j) in dp:\\n                return dp[(i, j)]\\n\\n            if i < len(s1) and s1[i] == s3[i+j] and dfs(i + 1, j):\\n                return True\\n            \\n            if j < len(s2) and s2[j] == s3[i + j] and dfs(i, j + 1):\\n                return True\\n            \\n            dp[(i, j)] = False\\n            return False\\n        return dfs(0, 0)\\n```\\n```C# []\\npublic class Solution {\\n    public bool IsInterleave(string s1, string s2, string s3) {\\n        if (s1.Length + s2.Length != s3.Length) {\\n            return false;\\n        }\\n\\n        bool[,] dp = new bool[s1.Length + 1, s2.Length + 1];\\n        dp[s1.Length, s2.Length] = true;\\n\\n        for (int i = s1.Length; i >= 0; i--) {\\n            for (int j = s2.Length; j >= 0; j--) {\\n                if (i < s1.Length && s1[i] == s3[i + j] && dp[i + 1, j]) {\\n                    dp[i, j] = true;\\n                }\\n                if (j < s2.Length && s2[j] == s3[i + j] && dp[i, j + 1]) {\\n                    dp[i, j] = true;\\n                }\\n            }\\n        }\\n        return dp[0, 0];\\n    }\\n\\n    private Dictionary<(int, int), bool> dp = new Dictionary<(int, int), bool>();\\n    private bool DFS(int i, int j, string s1, string s2, string s3) {\\n        if (i == s1.Length && j == s2.Length) {\\n            return true;\\n        }\\n        if (dp.ContainsKey((i, j))) {\\n            return dp[(i, j)];\\n        }\\n\\n        bool result = false;\\n        if (i < s1.Length && s1[i] == s3[i + j] && DFS(i + 1, j, s1, s2, s3)) {\\n            result = true;\\n        }\\n        if (j < s2.Length && s2[j] == s3[i + j] && DFS(i, j + 1, s1, s2, s3)) {\\n            result = true;\\n        }\\n\\n        dp[(i, j)] = result;\\n        return result;\\n    }\\n}\\n```\\n```C++ []\\n#include <unordered_map>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        if (s1.length() + s2.length() != s3.length()) {\\n            return false;\\n        }\\n\\n        vector<vector<bool>> dp(s1.length() + 1, vector<bool>(s2.length() + 1, false));\\n        dp[s1.length()][s2.length()] = true;\\n\\n        for (int i = s1.length(); i >= 0; i--) {\\n            for (int j = s2.length(); j >= 0; j--) {\\n                if (i < s1.length() && s1[i] == s3[i + j] && dp[i + 1][j]) {\\n                    dp[i][j] = true;\\n                }\\n                if (j < s2.length() && s2[j] == s3[i + j] && dp[i][j + 1]) {\\n                    dp[i][j] = true;\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n\\nprivate:\\n    struct PairHash {\\n        template <class T1, class T2>\\n        size_t operator() (const pair<T1, T2>& p) const {\\n            auto h1 = hash<T1>{}(p.first);\\n            auto h2 = hash<T2>{}(p.second);\\n            return h1 ^ (h2 << 1);\\n        }\\n    };\\n    \\n    unordered_map<pair<int, int>, bool, PairHash> dp;\\n    bool dfs(int i, int j, string& s1, string& s2, string& s3) {\\n        if (i == s1.length() && j == s2.length()) {\\n            return true;\\n        }\\n        if (dp.find({i, j}) != dp.end()) {\\n            return dp[{i, j}];\\n        }\\n\\n        bool result = false;\\n        if (i < s1.length() && s1[i] == s3[i + j] && dfs(i + 1, j, s1, s2, s3)) {\\n            result = true;\\n        }\\n        if (j < s2.length() && s2[j] == s3[i + j] && dfs(i, j + 1, s1, s2, s3)) {\\n            result = true;\\n        }\\n\\n        dp[{i, j}] = result;\\n        return result;\\n    }\\n};\\n```\\n```Java []\\nimport java.util.HashMap;\\nimport java.util.Map;\\n\\nclass Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        if (s1.length() + s2.length() != s3.length()) {\\n            return false;\\n        }\\n\\n        boolean[][] dp = new boolean[s1.length() + 1][s2.length() + 1];\\n        dp[s1.length()][s2.length()] = true;\\n\\n        for (int i = s1.length(); i >= 0; i--) {\\n            for (int j = s2.length(); j >= 0; j--) {\\n                if (i < s1.length() && s1.charAt(i) == s3.charAt(i + j) && dp[i + 1][j]) {\\n                    dp[i][j] = true;\\n                }\\n                if (j < s2.length() && s2.charAt(j) == s3.charAt(i + j) && dp[i][j + 1]) {\\n                    dp[i][j] = true;\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n\\n    private Map<Pair, Boolean> dp = new HashMap<>();\\n    private boolean dfs(int i, int j, String s1, String s2, String s3) {\\n        if (i == s1.length() && j == s2.length()) {\\n            return true;\\n        }\\n        Pair pair = new Pair(i, j);\\n        if (dp.containsKey(pair)) {\\n            return dp.get(pair);\\n        }\\n\\n        boolean result = false;\\n        if (i < s1.length() && s1.charAt(i) == s3.charAt(i + j) && dfs(i + 1, j, s1, s2, s3)) {\\n            result = true;\\n        }\\n        if (j < s2.length() && s2.charAt(j) == s3.charAt(i + j) && dfs(i, j + 1, s1, s2, s3)) {\\n            result = true;\\n        }\\n\\n        dp.put(pair, result);\\n        return result;\\n    }\\n\\n    private class Pair {\\n        int first;\\n        int second;\\n\\n        Pair(int first, int second) {\\n            this.first = first;\\n            this.second = second;\\n        }\\n\\n        @Override\\n        public int hashCode() {\\n            return first * 31 + second;\\n        }\\n\\n        @Override\\n        public boolean equals(Object obj) {\\n            if (this == obj) return true;\\n            if (obj == null || getClass() != obj.getClass()) return false;\\n            Pair other = (Pair) obj;\\n            return first == other.first && second == other.second;\\n        }\\n    }\\n}\\n```\\n![Screenshot 2023-08-20 065922.png](https://assets.leetcode.com/users/images/87160051-906d-467d-bc82-cdf1b787371b_1692934261.5322077.png)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "C#"
                ],
                "code": "```Python3 []\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3):\\n            return False\\n\\n        dp = [ [False] * (len(s2) + 1) for i in range(len(s1) + 1)]\\n        dp[len(s1)][len(s2)] = True\\n\\n        for i in range(len(s1), -1, -1):\\n            for j in range(len(s2), -1, -1):\\n                if i < len(s1) and s1[i] == s3[i +j] and dp[i + 1][j]:\\n                    dp[i][j] = True\\n                if j < len(s2) and s2[j] == s3[i + j] and dp[i][j + 1]:\\n                    dp[i][j] = True\\n        return dp[0][0]\\n\\n\\n\\n        dp = {}\\n        def dfs(i, j):\\n            if i == len(s1) and j == len(s2):\\n                return True\\n            if (i, j) in dp:\\n                return dp[(i, j)]\\n\\n            if i < len(s1) and s1[i] == s3[i+j] and dfs(i + 1, j):\\n                return True\\n            \\n            if j < len(s2) and s2[j] == s3[i + j] and dfs(i, j + 1):\\n                return True\\n            \\n            dp[(i, j)] = False\\n            return False\\n        return dfs(0, 0)\\n```\n```python []\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3):\\n            return False\\n\\n        dp = [ [False] * (len(s2) + 1) for i in range(len(s1) + 1)]\\n        dp[len(s1)][len(s2)] = True\\n\\n        for i in range(len(s1), -1, -1):\\n            for j in range(len(s2), -1, -1):\\n                if i < len(s1) and s1[i] == s3[i +j] and dp[i + 1][j]:\\n                    dp[i][j] = True\\n                if j < len(s2) and s2[j] == s3[i + j] and dp[i][j + 1]:\\n                    dp[i][j] = True\\n        return dp[0][0]\\n\\n\\n\\n        dp = {}\\n        def dfs(i, j):\\n            if i == len(s1) and j == len(s2):\\n                return True\\n            if (i, j) in dp:\\n                return dp[(i, j)]\\n\\n            if i < len(s1) and s1[i] == s3[i+j] and dfs(i + 1, j):\\n                return True\\n            \\n            if j < len(s2) and s2[j] == s3[i + j] and dfs(i, j + 1):\\n                return True\\n            \\n            dp[(i, j)] = False\\n            return False\\n        return dfs(0, 0)\\n```\n```C# []\\npublic class Solution {\\n    public bool IsInterleave(string s1, string s2, string s3) {\\n        if (s1.Length + s2.Length != s3.Length) {\\n            return false;\\n        }\\n\\n        bool[,] dp = new bool[s1.Length + 1, s2.Length + 1];\\n        dp[s1.Length, s2.Length] = true;\\n\\n        for (int i = s1.Length; i >= 0; i--) {\\n            for (int j = s2.Length; j >= 0; j--) {\\n                if (i < s1.Length && s1[i] == s3[i + j] && dp[i + 1, j]) {\\n                    dp[i, j] = true;\\n                }\\n                if (j < s2.Length && s2[j] == s3[i + j] && dp[i, j + 1]) {\\n                    dp[i, j] = true;\\n                }\\n            }\\n        }\\n        return dp[0, 0];\\n    }\\n\\n    private Dictionary<(int, int), bool> dp = new Dictionary<(int, int), bool>();\\n    private bool DFS(int i, int j, string s1, string s2, string s3) {\\n        if (i == s1.Length && j == s2.Length) {\\n            return true;\\n        }\\n        if (dp.ContainsKey((i, j))) {\\n            return dp[(i, j)];\\n        }\\n\\n        bool result = false;\\n        if (i < s1.Length && s1[i] == s3[i + j] && DFS(i + 1, j, s1, s2, s3)) {\\n            result = true;\\n        }\\n        if (j < s2.Length && s2[j] == s3[i + j] && DFS(i, j + 1, s1, s2, s3)) {\\n            result = true;\\n        }\\n\\n        dp[(i, j)] = result;\\n        return result;\\n    }\\n}\\n```\n```C++ []\\n#include <unordered_map>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        if (s1.length() + s2.length() != s3.length()) {\\n            return false;\\n        }\\n\\n        vector<vector<bool>> dp(s1.length() + 1, vector<bool>(s2.length() + 1, false));\\n        dp[s1.length()][s2.length()] = true;\\n\\n        for (int i = s1.length(); i >= 0; i--) {\\n            for (int j = s2.length(); j >= 0; j--) {\\n                if (i < s1.length() && s1[i] == s3[i + j] && dp[i + 1][j]) {\\n                    dp[i][j] = true;\\n                }\\n                if (j < s2.length() && s2[j] == s3[i + j] && dp[i][j + 1]) {\\n                    dp[i][j] = true;\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n\\nprivate:\\n    struct PairHash {\\n        template <class T1, class T2>\\n        size_t operator() (const pair<T1, T2>& p) const {\\n            auto h1 = hash<T1>{}(p.first);\\n            auto h2 = hash<T2>{}(p.second);\\n            return h1 ^ (h2 << 1);\\n        }\\n    };\\n    \\n    unordered_map<pair<int, int>, bool, PairHash> dp;\\n    bool dfs(int i, int j, string& s1, string& s2, string& s3) {\\n        if (i == s1.length() && j == s2.length()) {\\n            return true;\\n        }\\n        if (dp.find({i, j}) != dp.end()) {\\n            return dp[{i, j}];\\n        }\\n\\n        bool result = false;\\n        if (i < s1.length() && s1[i] == s3[i + j] && dfs(i + 1, j, s1, s2, s3)) {\\n            result = true;\\n        }\\n        if (j < s2.length() && s2[j] == s3[i + j] && dfs(i, j + 1, s1, s2, s3)) {\\n            result = true;\\n        }\\n\\n        dp[{i, j}] = result;\\n        return result;\\n    }\\n};\\n```\n```Java []\\nimport java.util.HashMap;\\nimport java.util.Map;\\n\\nclass Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        if (s1.length() + s2.length() != s3.length()) {\\n            return false;\\n        }\\n\\n        boolean[][] dp = new boolean[s1.length() + 1][s2.length() + 1];\\n        dp[s1.length()][s2.length()] = true;\\n\\n        for (int i = s1.length(); i >= 0; i--) {\\n            for (int j = s2.length(); j >= 0; j--) {\\n                if (i < s1.length() && s1.charAt(i) == s3.charAt(i + j) && dp[i + 1][j]) {\\n                    dp[i][j] = true;\\n                }\\n                if (j < s2.length() && s2.charAt(j) == s3.charAt(i + j) && dp[i][j + 1]) {\\n                    dp[i][j] = true;\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n\\n    private Map<Pair, Boolean> dp = new HashMap<>();\\n    private boolean dfs(int i, int j, String s1, String s2, String s3) {\\n        if (i == s1.length() && j == s2.length()) {\\n            return true;\\n        }\\n        Pair pair = new Pair(i, j);\\n        if (dp.containsKey(pair)) {\\n            return dp.get(pair);\\n        }\\n\\n        boolean result = false;\\n        if (i < s1.length() && s1.charAt(i) == s3.charAt(i + j) && dfs(i + 1, j, s1, s2, s3)) {\\n            result = true;\\n        }\\n        if (j < s2.length() && s2.charAt(j) == s3.charAt(i + j) && dfs(i, j + 1, s1, s2, s3)) {\\n            result = true;\\n        }\\n\\n        dp.put(pair, result);\\n        return result;\\n    }\\n\\n    private class Pair {\\n        int first;\\n        int second;\\n\\n        Pair(int first, int second) {\\n            this.first = first;\\n            this.second = second;\\n        }\\n\\n        @Override\\n        public int hashCode() {\\n            return first * 31 + second;\\n        }\\n\\n        @Override\\n        public boolean equals(Object obj) {\\n            if (this == obj) return true;\\n            if (obj == null || getClass() != obj.getClass()) return false;\\n            Pair other = (Pair) obj;\\n            return first == other.first && second == other.second;\\n        }\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1347089,
                "title": "basic-recursion-in-java-for-understanding",
                "content": "*This solution will help you for the top down and bottom up approach and how the solution will be formed.\\nThis solution will not get accepted due to high time complexity. This is only to help beginners understand the recursive part as it is the most important part for dp.*\\n\\n```\\nclass Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        if(s1.length()+s2.length()!=s3.length())\\n        {\\n            return false;\\n        }\\n        return check(s1,s2,s3,0,0,0);\\n    }\\n    \\n    public boolean check(String s1,String s2,String s3,int i,int j,int n)\\n    {\\n        if(n==s3.length() && i==s1.length() && j==s2.length())\\n        {\\n            return true;\\n        }\\n        boolean res=false;\\n        \\n        if(i<s1.length() && j<s2.length() && s1.charAt(i)==s3.charAt(n) && s2.charAt(j)==s3.charAt(n))\\n        {\\n            res = res ||  check(s1,s2,s3,i+1,j,n+1) || check(s1,s2,s3,i,j+1,n+1); \\n        }\\n        else if(i<s1.length() && s1.charAt(i)==s3.charAt(n))\\n        {\\n            res = res || check(s1,s2,s3,i+1,j,n+1);\\n        }\\n        else if(j<s2.length() && s2.charAt(j)==s3.charAt(n))\\n        {\\n            res = res || check(s1,s2,s3,i,j+1,n+1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        if(s1.length()+s2.length()!=s3.length())\\n        {\\n            return false;\\n        }\\n        return check(s1,s2,s3,0,0,0);\\n    }\\n    \\n    public boolean check(String s1,String s2,String s3,int i,int j,int n)\\n    {\\n        if(n==s3.length() && i==s1.length() && j==s2.length())\\n        {\\n            return true;\\n        }\\n        boolean res=false;\\n        \\n        if(i<s1.length() && j<s2.length() && s1.charAt(i)==s3.charAt(n) && s2.charAt(j)==s3.charAt(n))\\n        {\\n            res = res ||  check(s1,s2,s3,i+1,j,n+1) || check(s1,s2,s3,i,j+1,n+1); \\n        }\\n        else if(i<s1.length() && s1.charAt(i)==s3.charAt(n))\\n        {\\n            res = res || check(s1,s2,s3,i+1,j,n+1);\\n        }\\n        else if(j<s2.length() && s2.charAt(j)==s3.charAt(n))\\n        {\\n            res = res || check(s1,s2,s3,i,j+1,n+1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 772696,
                "title": "c-0ms-beats-100",
                "content": "```c++\\nclass Solution {\\npublic:\\n    bool check(string &s1,string &s2,string &s3,int i,int j,int k,vector<vector<int>>&dp){\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        if(i==s1.length() and j==s2.length() and k==s3.length())\\n            return true;\\n        bool res=false;\\n        \\n        if(i!=s1.length())\\n            if(s1[i]==s3[k])\\n            res|=check(s1,s2,s3,i+1,j,k+1,dp);\\n        if(j!=s2.length())\\n            if(s2[j]==s3[k])\\n            res|=check(s1,s2,s3,i,j+1,k+1,dp);\\n        return dp[i][j]=res;\\n    }\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n=s1.length(),m=s2.length();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        bool ans=check(s1,s2,s3,0,0,0,dp);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    bool check(string &s1,string &s2,string &s3,int i,int j,int k,vector<vector<int>>&dp){\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        if(i==s1.length() and j==s2.length() and k==s3.length())\\n            return true;\\n        bool res=false;\\n        \\n        if(i!=s1.length())\\n            if(s1[i]==s3[k])\\n            res|=check(s1,s2,s3,i+1,j,k+1,dp);\\n        if(j!=s2.length())\\n            if(s2[j]==s3[k])\\n            res|=check(s1,s2,s3,i,j+1,k+1,dp);\\n        return dp[i][j]=res;\\n    }\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n=s1.length(),m=s2.length();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        bool ans=check(s1,s2,s3,0,0,0,dp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2250282,
                "title": "simple-top-down-memoization-with-explanation",
                "content": "3 pointers , p1 points character of s1, p2 points character of s2, p3 points character of s3\\nif all pointers reached end means we successfully formed s3 from s1 and s2..\\n**if char at p1 matches with char at p3.. that means subproblem becomes dfs(p1+1,p2,p3+1)\\nif char at p2 matches with char at p3.. that means subproblem becomes dfs(p1,p2+1,p3+1)**\\nif none of the case satisfies that means neither char at p1 matches with p3 nor p2 char matches with p1 char.. or none of the ways formed the s3 then return false\\n\\nRUNTIME : 90% faster than other python users\\n```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3): return False\\n        @lru_cache(maxsize = None)\\n        def dfs(p1,p2,p3):\\n            if p1 == len(s1) and p2 == len(s2) and p3 == len(s3): return True\\n            if p1 < len(s1) and s1[p1] == s3[p3] and dfs(p1+1,p2,p3+1): return True\\n            if p2 < len(s2) and s2[p2] == s3[p3] and dfs(p1,p2+1,p3+1): return True\\n            return False\\n        return dfs(0,0,0)\\n```\\n\\n**PLEASE UPVOTE IT**.. FEEL FREE TO ASK ANY QUERIES..",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3): return False\\n        @lru_cache(maxsize = None)\\n        def dfs(p1,p2,p3):\\n            if p1 == len(s1) and p2 == len(s2) and p3 == len(s3): return True\\n            if p1 < len(s1) and s1[p1] == s3[p3] and dfs(p1+1,p2,p3+1): return True\\n            if p2 < len(s2) and s2[p2] == s3[p3] and dfs(p1,p2+1,p3+1): return True\\n            return False\\n        return dfs(0,0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1247101,
                "title": "dp-top-down-memoization-comments-added-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n1 = s1.size();\\n        int n2 = s2.size();\\n        int n3 = s3.size();\\n        \\n        if(n3 == 0) return true;\\n        \\n        if(n1+n2 != n3) return false; \\n        \\n        int dp[n1+1][n2+1];\\n        memset(dp, 0, sizeof(dp));\\n        \\n        for(int i=0; i<=n1; i++){\\n            for(int j=0; j<=n2; j++){\\n                if(i == 0 && j == 0) //both strings are empty so it is interleaving\\n                    dp[i][j] = 1;\\n                \\n                else if(i == 0){ //s1 is empty\\n                    if(s2[j-1] == s3[j-1])\\n                        dp[i][j] = dp[i][j-1];\\n                }\\n                \\n                else if(j == 0){ // s2 is empty\\n                    if(s1[i-1] == s3[i-1])\\n                        dp[i][j] = dp[i-1][j];\\n                }\\n                \\n                else if(s1[i-1] != s3[i+j-1] && s2[j-1] == s3[i+j-1]) //if not match with s1\\n                    dp[i][j] = dp[i][j-1];\\n                \\n                else if(s1[i-1] == s3[i+j-1] && s2[j-1] != s3[i+j-1])   //if not match with s2\\n                    dp[i][j] = dp[i-1][j];\\n                \\n                else if(s1[i-1] == s3[i+j-1] && s2[j-1] == s3[i+j-1])  // If match with both s1 and s2\\n                    dp[i][j] = dp[i-1][j] || dp[i][j-1];\\n            }\\n        }      \\n        return dp[n1][n2];\\n    }\\n};\\n\\n**Please do upvote**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n1 = s1.size();\\n        int n2 = s2.size();\\n        int n3 = s3.size();\\n        \\n        if(n3 == 0) return true;\\n        \\n        if(n1+n2 != n3) return false; \\n        \\n        int dp[n1+1][n2+1];\\n        memset(dp, 0, sizeof(dp));\\n        \\n        for(int i=0; i<=n1; i++){\\n            for(int j=0; j<=n2; j++){\\n                if(i == 0 && j == 0) //both strings are empty so it is interleaving\\n                    dp[i][j] = 1;\\n                \\n                else if(i == 0){ //s1 is empty\\n                    if(s2[j-1] == s3[j-1])\\n                        dp[i][j] = dp[i][j-1];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 31952,
                "title": "no-loops-quick-n-easy-5-liner-in-python-beats-99",
                "content": "Pure recursion without loops. Useful for interviews when we need to code things fast without much bullcrap. Shortest in Python I've seen so far for this problem, but may be wrong.\\n\\n```\\nclass Solution(object):\\n    def isInterleave(self, s1, s2, s3, memo={}):\\n        if len(s1) + len(s2) != len(s3): return False\\n        if not s1 and not s2 and not s3: return True\\n        if (s1, s2, s3) in memo:         return memo[s1, s2, s3]\\n        memo[s1,s2,s3] =\\\\\\n               (len(s1) > 0 and len(s3) > 0 and s1[0] == s3[0] and self.isInterleave(s1[1:], s2, s3[1:], memo)) or\\\\\\n               (len(s2) > 0 and len(s3) > 0 and s2[0] == s3[0] and self.isInterleave(s1, s2[1:], s3[1:], memo))\\n        return memo[s1,s2,s3]\\n                \\n\\n# 101 / 101 test cases passed.\\n# Status: Accepted\\n# Runtime: 44 ms\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isInterleave(self, s1, s2, s3, memo={}):\\n        if len(s1) + len(s2) != len(s3): return False\\n        if not s1 and not s2 and not s3: return True\\n        if (s1, s2, s3) in memo:         return memo[s1, s2, s3]\\n        memo[s1,s2,s3] =\\\\\\n               (len(s1) > 0 and len(s3) > 0 and s1[0] == s3[0] and self.isInterleave(s1[1:], s2, s3[1:], memo)) or\\\\\\n               (len(s2) > 0 and len(s3) > 0 and s2[0] == s3[0] and self.isInterleave(s1, s2[1:], s3[1:], memo))\\n        return memo[s1,s2,s3]\\n                \\n\\n# 101 / 101 test cases passed.\\n# Status: Accepted\\n# Runtime: 44 ms\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1247315,
                "title": "interleaving-string-easy-dp-solution-with-explanation",
                "content": "\\t\\n\\tConsider the given example:  s1= aabcc  s2 = dbbca  s3=  aa dbbc bc a c\\n\\t\\n\\tWe start with an empty s3, adding characters one by one and finding if we can use some substring of s1 and s2  to construct this s3.\\n\\tUsing a 2D vector to store the answers along the way.\\n\\tdp[i][j] = true if it is possible to construct the string s3[0....i+j-1] using substrings s1[0...i-1]  and s2[0...j-1]\\n\\n\\t\\n1.  Base case : dp[0][0] = true\\n\\t Since we can make an empty string s3  from 2 empty strings s1 and s2.\\n\\t\\n2.\\t When one of the strings is empty\\n\\t\\t\\n\\t\\tWhen s2 is empty\\n\\t\\tAdd characters one by one to s3 and s1 while keeping s2 empty.\\t\\t\\n\\t\\teg.             s1 = \"a\"  s2 = \" \"    s3 = \"a\".    We can make s3 using this s1 and s2. \\n\\t\\t   Therefore, dp[1][0] = true  since s3[0] = s2[0] \\n\\n\\t\\tTo find dp[i][0],\\n\\t\\twe just check whether the last charcter of s3 is same as last char of s1 , s3[i-1] == s1[i-1] and\\n\\t\\tif it is possible to construct the string, s3 minus current character\\n\\t\\ti.e.  dp[i-1][0] is true.\\n\\t\\t\\tThis way we have filled the first column of our dp. \\n\\t\\t\\t\\t\\n\\t\\t\\t\\tdp[i][0] = dp[i-1][0]  and (s3[i-1] == s1[i-1])\\n\\t\\tSimilarly  we can fill the first row when s1 is empty and s2 is not.\\n\\t\\t\\t\\n\\t\\t\\tdp[0][j] = (s3[j-1] == s2[j-1] ) and dp[0][j-1]\\n\\n\\n3.\\tNow consider the case when both strings are not empty.\\n\\t \\n\\t eg. to find dp[1][1]\\n\\t\\t s1 = \"a\"  s2 = \"d\"    s3 = \"aa\"\\n  \\n\\t  \\n\\t  We need to check 2 conditions : \\n\\ta. whether the last character of s3 is same as last characters of either s1 or s2. \\n\\t\\tIf  not same then its not possible to make s3.\\n\\n\\tb. whether it\\'s possible to construct the string s3 minus current character.\\n\\t\\t\\ti.e  when s3 has a single character. Those are dp[0][1] and dp[1][0] .\\n\\n\\n\\tIf the last character of s3 comes from s1, \\n\\tthen check whether it is possible to construct the string s3 minus current character using   substring s2 and substring s1 minus last character.\\n`bool t1 = (s3[i+j-1] == s1[i-1] ) and dp[i-1][j];`\\n\\n\\tSimilarly if the last character of s3 comes from s2,\\n\\t\\t`bool t2 = (s3[i+j-1] == s2[j-1]) and dp[i][j-1];`\\n\\n\\n\\n If either of t1 or t2 is true then we can make s3 with current substrings s1 and s2.\\n\\t\\n\\n\\n\\n\\n```\\nbool isInterleave(string s1, string s2, string s3) {\\n        int m= s1.length(), n= s2.length();\\n        if(s3.length() != m+n) return false;\\n        vector<vector<bool>> dp(m+1,vector<bool>(n+1,false));\\n        \\n        dp[0][0]  = 1;\\n        \\n        for(int i=1; i<=m;i++)\\n            dp[i][0] = (s3[i-1] == s1[i-1]) and dp[i-1][0];\\n        \\n        for(int j=1;j<=n; j++)\\n            dp[0][j] = (s3[j-1] == s2[j-1]) and dp[0][j-1];\\n        \\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                bool t1 = (s3[i+j-1] == s1[i-1] ) and dp[i-1][j];\\n                bool t2 = (s3[i+j-1] == s2[j-1]) and dp[i][j-1];\\n                dp[i][j] = t1 or t2;\\n            }\\n        }\\n        \\n        return dp[m][n];\\n        \\n        \\n    }\\n```\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nbool isInterleave(string s1, string s2, string s3) {\\n        int m= s1.length(), n= s2.length();\\n        if(s3.length() != m+n) return false;\\n        vector<vector<bool>> dp(m+1,vector<bool>(n+1,false));\\n        \\n        dp[0][0]  = 1;\\n        \\n        for(int i=1; i<=m;i++)\\n            dp[i][0] = (s3[i-1] == s1[i-1]) and dp[i-1][0];\\n        \\n        for(int j=1;j<=n; j++)\\n            dp[0][j] = (s3[j-1] == s2[j-1]) and dp[0][j-1];\\n        \\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                bool t1 = (s3[i+j-1] == s1[i-1] ) and dp[i-1][j];\\n                bool t2 = (s3[i+j-1] == s2[j-1]) and dp[i][j-1];\\n                dp[i][j] = t1 or t2;\\n            }\\n        }\\n        \\n        return dp[m][n];\\n        \\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3957005,
                "title": "c-dp-recursion-memoization-day-25",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool c(int i1,int i2,int i3,string &s1,string &s2,string &s3,\\n    vector<vector<vector<int>>>&dp){\\n        if(i3==s3.size()){\\n            if(i2==s2.size() && i1==s1.size())return true;\\n            else return false;\\n        }\\n        char c1=\\'*\\',c2=\\'*\\';\\n        if(dp[i1][i2][i3]!=-1)return dp[i1][i2][i3];\\n        if(i1<s1.size())c1=s1[i1];\\n        if(i2<s2.size())c2=s2[i2];\\n        bool ans=false;\\n        if(c1==s3[i3])ans |= c(i1+1,i2,i3+1,s1,s2,s3,dp);\\n        if(c2==s3[i3])ans |= c(i1,i2+1,i3+1,s1,s2,s3,dp);\\n        return dp[i1][i2][i3]=ans;\\n        }\\n    bool isInterleave(string s1, string s2, string s3) {\\n        vector<vector<vector<int>>>dp(s1.size()+1,vector<vector<int>>(s2.size()+1,vector<int>(s3.size(),-1)));\\n        return c(0,0,0,s1,s2,s3,dp);\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/79429923-2114-4af9-9725-1f43b586a234_1692940270.5239363.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool c(int i1,int i2,int i3,string &s1,string &s2,string &s3,\\n    vector<vector<vector<int>>>&dp){\\n        if(i3==s3.size()){\\n            if(i2==s2.size() && i1==s1.size())return true;\\n            else return false;\\n        }\\n        char c1=\\'*\\',c2=\\'*\\';\\n        if(dp[i1][i2][i3]!=-1)return dp[i1][i2][i3];\\n        if(i1<s1.size())c1=s1[i1];\\n        if(i2<s2.size())c2=s2[i2];\\n        bool ans=false;\\n        if(c1==s3[i3])ans |= c(i1+1,i2,i3+1,s1,s2,s3,dp);\\n        if(c2==s3[i3])ans |= c(i1,i2+1,i3+1,s1,s2,s3,dp);\\n        return dp[i1][i2][i3]=ans;\\n        }\\n    bool isInterleave(string s1, string s2, string s3) {\\n        vector<vector<vector<int>>>dp(s1.size()+1,vector<vector<int>>(s2.size()+1,vector<int>(s3.size(),-1)));\\n        return c(0,0,0,s1,s2,s3,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1104260,
                "title": "java-dfs-faster-than-100-solution-pictorial-explanation",
                "content": "Consider the examples in the picture below to understand how we can DFS over the strings.\\n\\n![image](https://assets.leetcode.com/users/images/a3cb6432-f974-487b-b16c-b488f06f5596_1615451866.8777242.png)\\n![image](https://assets.leetcode.com/users/images/63847cfb-0c44-4271-8e55-2d6128edaa02_1615451906.4169378.png)\\n\\nCode : \\n```\\nclass Solution {\\n    \\n    private boolean dfs(String s1, String s2, String s3, int i, int j, int k, boolean[][] visited){\\n        if(i == s1.length() && j == s2.length()) return true;\\n        if(i > s1.length() || j > s2.length()) return false;\\n        if(visited[i][j]) return false;\\n        visited[i][j] = true;\\n        boolean a = false, b = false;\\n        if(i < s1.length() && s1.charAt(i) == s3.charAt(k)){\\n            a = dfs(s1, s2, s3, i+1, j, k+1, visited);\\n        }\\n        if(j < s2.length() && s2.charAt(j) == s3.charAt(k)){\\n            b = dfs(s1, s2, s3, i, j+1, k+1, visited); \\n        }   \\n        return a || b;\\n    }\\n    \\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        if(s3.length() < (s1.length() + s2.length()) || s3.length() > (s1.length() + s2.length())) return false;\\n        boolean[][] visited = new boolean[s1.length()+1][s2.length()+1];\\n        return dfs(s1, s2, s3, 0, 0, 0, visited);\\n    }\\n}\\n```\\n\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Interleaving String.\\nMemory Usage: 36.9 MB, less than 94.19% of Java online submissions for Interleaving String.\\n\\nHope this helps !\\n\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private boolean dfs(String s1, String s2, String s3, int i, int j, int k, boolean[][] visited){\\n        if(i == s1.length() && j == s2.length()) return true;\\n        if(i > s1.length() || j > s2.length()) return false;\\n        if(visited[i][j]) return false;\\n        visited[i][j] = true;\\n        boolean a = false, b = false;\\n        if(i < s1.length() && s1.charAt(i) == s3.charAt(k)){\\n            a = dfs(s1, s2, s3, i+1, j, k+1, visited);\\n        }\\n        if(j < s2.length() && s2.charAt(j) == s3.charAt(k)){\\n            b = dfs(s1, s2, s3, i, j+1, k+1, visited); \\n        }   \\n        return a || b;\\n    }\\n    \\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        if(s3.length() < (s1.length() + s2.length()) || s3.length() > (s1.length() + s2.length())) return false;\\n        boolean[][] visited = new boolean[s1.length()+1][s2.length()+1];\\n        return dfs(s1, s2, s3, 0, 0, 0, visited);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 505067,
                "title": "7-line-20-ms-small-code-top-down-dp",
                "content": "```python\\nfrom functools import lru_cache\\nclass Solution:    \\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:        \\n        if len(s3) != len(s1) + len(s2): return False\\n        \\n        @lru_cache(None)\\n        def helper(s1,s2,s3):\\n            if not s1: return s2 == s3\\n            if not s2: return s1 == s3    \\n            return (s1[0] == s3[0] and helper(s1[1:],s2,s3[1:])) or (s2[0] == s3[0] and helper(s1, s2[1:],s3[1:]))                    \\n        return helper(s1,s2,s3)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```python\\nfrom functools import lru_cache\\nclass Solution:    \\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:        \\n        if len(s3) != len(s1) + len(s2): return False\\n        \\n        @lru_cache(None)\\n        def helper(s1,s2,s3):\\n            if not s1: return s2 == s3\\n            if not s2: return s1 == s3    \\n            return (s1[0] == s3[0] and helper(s1[1:],s2,s3[1:])) or (s2[0] == s3[0] and helper(s1, s2[1:],s3[1:]))                    \\n        return helper(s1,s2,s3)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32051,
                "title": "my-dp-c-solution-is-only-10-lines-with-o-n-space",
                "content": "\\n\\n    class Solution {\\n    public:\\n        bool isInterleave(string s1, string s2, string s3) {\\n            int m = s1.size(), n = s2.size();\\n            if(m+n != s3.size())  return false;\\n            bool c[n+1] = {true};\\n            int i, j = 0;\\n            while(j < n && s2[j] == s3[j]) c[++j] = true;\\n            for(i = 0; i < m; ++i) {\\n                c[0] = c[0] & (s1[i] == s3[i]);\\n                for(j = 1; j <= n; ++j)\\n                    c[j] = ((s1[i] == s3[i+j]) & c[j]) | ((s2[j-1] == s3[i+j]) & c[j-1]);\\n            }\\n            return c[n];\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        bool isInterleave(string s1, string s2, string s3) {\\n            int m = s1.size(), n = s2.size();\\n            if(m+n != s3.size())  return false;\\n            bool c[n+1] = {true}",
                "codeTag": "Java"
            },
            {
                "id": 32082,
                "title": "c-sharing-my-recursive-tle-and-dp-solution-30ms-easy-to-understand",
                "content": "First, I'm a big recursion person. Here's my first attempt which is purely recursive. At an intermediate stage, we can either match one char from s1 to one char from s3 and advance one pointer at s1 and s3. Or we can do the same with s2 and s3. I'm open to suggestions to my recursive code. One improvement could come from not having to call the strcmp function?\\n\\n\\n    class Solution {\\n    public:\\n        bool isInterleave(char* s1, char* s2, char* s3) {\\n            \\n            if (*s1=='\\\\0' && *s2=='\\\\0')\\n                return *s3=='\\\\0'? true : false;\\n            else if (*s1=='\\\\0'){\\n                return strcmp(s2,s3)==0 ? true : false;\\n            } else if (*s2=='\\\\0'){\\n                return strcmp(s1,s3)==0 ? true : false;\\n            }\\n            \\n            return (*s1==*s3 && isInterleave(s1+1,s2,s3+1)) | (*s2==*s3 && isInterleave(s1,s2+1,s3+1));\\n        }\\n    };\\n\\n\\nHere's the DP version (30ms) as well. Unsurprisingly the DP solution passed the judge and it's pretty efficient. The logic straightforward if you understood the recursive version since there's 1:1 correspondence between the two code. I think it's elegant since it doesn't have any ugly if, else if shenanigans.\\n\\n    class Solution {\\n    public:\\n        bool isInterleave(string s1, string s2, string s3){\\n            int n1 = s1.length(), n2 = s2.length(), n3 = s3.length();\\n            if (n1+n2 != n3) return false;\\n            \\n            vector<vector<bool>> V(n1+1, vector<bool>(n2+1, false));\\n            \\n            V[n1][n2] = (s3[n1+n2]=='\\\\0');\\n            \\n            // fill bottom\\n            for (int j=n2-1; j>=0; j--) V[n1][j]  = (s2[j]==s3[n1+j] && V[n1][j+1]);\\n            \\n            // fill right\\n            for (int i=n1-1; i>=0; i--) V[i][n2] = (s1[i]==s3[n2+i] && V[i+1][n2]);\\n            \\n            // fill DP table from bottom right\\n            for (int j=n2-1; j>=0; j--){\\n                for (int i=n1-1; i>=0; i--){\\n                    V[i][j] = (s1[i]==s3[i+j] && V[i+1][j]) | (s2[j]==s3[i+j] && V[i][j+1]);\\n                }\\n            }\\n            return V[0][0];\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isInterleave(char* s1, char* s2, char* s3) {\\n            \\n            if (*s1=='\\\\0' && *s2=='\\\\0')\\n                return *s3=='\\\\0'? true : false;\\n            else if (*s1=='\\\\0'){\\n                return strcmp(s2,s3)==0 ? true : false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3187750,
                "title": "interleaving-string-python3-with-comments-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nOne way to form s3 from s1 and s2 is to take one character from s1 or s2 at a time and append it to s3. We can keep track of the index of the last character from s1 and s2 that was appended to s3. If at any point, we cannot append a character to s3, we backtrack and try a different path.\\n\\nTo optimize this approach, we can use dynamic programming. We can define a 2D boolean array dp, where dp[i][j] is true if s3[0:i+j] can be formed by an interleaving of s1[0:i] and s2[0:j].\\n\\nThe base case is when i = j = 0, and dp[0][0] is true. If either i or j is zero, then dp[i][j] is true if s3[0:i+j] is equal to either s1[0:i] or s2[0:j].\\n\\nFor the general case, if the last character of s1 matches the last character of s3, then we can append it to s3 and check if dp[i-1][j] is true. Similarly, if the last character of s2 matches the last character of s3, then we can append it to s3 and check if dp[i][j-1] is true.\\n\\nThe final answer is dp[m][n], where m is the length of s1 and n is the length of s2.\\n\\nTime complexity: O(mn), where m is the length of s1 and n is the length of s2.\\nSpace complexity: O(mn), where m is the length of s1 and n is the length of s2.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n    m, n = len(s1), len(s2)\\n    if m + n != len(s3):\\n        return False\\n    \\n    dp = [[False] * (n+1) for _ in range(m+1)]\\n    dp[0][0] = True\\n    \\n    for i in range(m+1):\\n        for j in range(n+1):\\n            if i > 0 and s1[i-1] == s3[i+j-1]:\\n                dp[i][j] = dp[i][j] or dp[i-1][j]\\n            if j > 0 and s2[j-1] == s3[i+j-1]:\\n                dp[i][j] = dp[i][j] or dp[i][j-1]\\n                \\n    return dp[m][n]\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n  def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n    m, n = len(s1), len(s2)\\n    if m + n != len(s3):\\n        return False\\n    \\n    dp = [[False] * (n+1) for _ in range(m+1)]\\n    dp[0][0] = True\\n    \\n    for i in range(m+1):\\n        for j in range(n+1):\\n            if i > 0 and s1[i-1] == s3[i+j-1]:\\n                dp[i][j] = dp[i][j] or dp[i-1][j]\\n            if j > 0 and s2[j-1] == s3[i+j-1]:\\n                dp[i][j] = dp[i][j] or dp[i][j-1]\\n                \\n    return dp[m][n]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1248271,
                "title": "interleaving-string-js-python-java-c-easy-dp-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nIf we consider a matrix with indices (**i**) for **s1** on one axis and indices (**j**) for **s2** on the other, then a successful **s3** can be considered a path moving from the top left to the bottom right. At each point, we either move downward (**i++**) by choosing the next letter from **s1** or rightward (**j++**) by choosing the next letter from **s2**.\\n\\nAll that remains, then, is to see which vertices are possible given **s3**, and which ones are not. To do that, we can use a **dynamic programming** (**DP**) approach. Normally, we would establish a matrix as described above, along with a buffer row/column at the start of the matrix to provide space for previous row/column validation checks for the leading edges of our iteration. An additional row/column at the end of the matrix is also needed, since our final checks will occur only _after_ the strings are completed.\\n\\nWe can reduce the **space complexity** of this solution from **O(N * M)** to just **O(M)**, however, if rather than building a full DP matrix, we instead only keep the current row of the matrix (**dp**) in memory, reiterating through it for each row. The **left** value (**dp[j-1]**) will already have been calculated, and the **up** value (**dp[j]**) will not yet have been overwritten in the current cell, so it will still represent the value of the cell from the previous row.\\n\\nWe should also remember to fill **dp[1]** with a **true** (or **1**) value, representing a valid vertex at the starting position of our iteration path.\\n\\nFrom there, we can iterate through the rows, building upon previously completed entries to check the validity of the current cell. If the cell \"above\" (the not-yet-overwritten **dp[i]** represents the same index from the row above) is valid (**true** or **1**) and the corresponding characters of **s1** and **s3** match, then the current cell is valid. Similarly, if the cell to the left is valid and the corresponding characters of **s2** and **s3** match, then the current cell is valid.\\n\\nOnce we\\'ve finished iterating through **i** and **j**, a valid value in the last cell of **dp** will indicate that a valid path exists that matches **s3**, so we can just **return** the contents of that cell.\\n\\n - _**Time Complexity: O(N * M)** where **N** is the length of **s1** and **M** is the length of **s2**_\\n - _**Space Complexity: O(M)** for **dp**_\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **72ms / 38.7MB** (beats 99% / 93%).\\n```javascript\\nvar isInterleave = function(s1, s2, s3) {\\n    let n = s1.length + 2, m = s2.length + 2\\n    if (n + m - 4 !== s3.length) return false\\n    let dp = new Uint8Array(m)\\n    dp[1] = 1\\n    for (let i = 1; i < n; i++)\\n        for (let j = 1; j < m; j++) {\\n            let up = dp[j] && s1[i-2] === s3[j+i-3],\\n                left = dp[j-1] && s2[j-2] === s3[j+i-3]\\n            dp[j] = up || left\\n        }\\n    return dp[m-1]\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **36ms / 14.2MB** (beats 61% / 96%).\\n```python\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        n, m = len(s1) + 2, len(s2) + 2\\n        if n + m - 4 != len(s3): return False\\n        dp = [0] * m\\n        dp[1] = 1\\n        for i in range(1, n):\\n            for j in range(1, m):\\n                up = dp[j] and (i < 2 or s1[i-2] == s3[j+i-3])\\n                left = dp[j-1] and (j < 2 or s2[j-2] == s3[j+i-3])\\n                dp[j] = up or left\\n        return dp[-1]\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **2ms / 36.7MB** (beats 80% / 98%).\\n```java\\nclass Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        int n = s1.length() + 2, m = s2.length() + 2;\\n        char[] sc1 = s1.toCharArray(), sc2 = s2.toCharArray(), sc3 = s3.toCharArray();\\n        if (n + m - 4 != s3.length()) return false;\\n        boolean[] dp = new boolean[m];\\n        dp[1] = true;\\n        for (int i = 1; i < n; i++)\\n            for (int j = 1; j < m; j++) {\\n                boolean up = dp[j] && (i < 2 || sc1[i-2] == sc3[j+i-3]),\\n                    left =dp[j-1] && (j < 2 || sc2[j-2] == sc3[j+i-3]);\\n                dp[j] = up || left;\\n            }\\n        return dp[m-1];\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 6.6MB** (beats 100% / 61%).\\n```c++\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n = s1.length() + 2, m = s2.length() + 2;\\n        if (n + m - 4 != s3.length()) return false;\\n        vector<bool> dp(m);\\n        dp[1] = true;\\n        for (int i = 1; i < n; i++)\\n            for (int j = 1; j < m; j++) {\\n                bool up = dp[j] && (i < 2 || s1[i-2] == s3[j+i-3]),\\n                    left = dp[j-1] && (j < 2 || s2[j-2] == s3[j+i-3]);\\n               dp[j] = up || left;\\n            }\\n        return dp[m-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar isInterleave = function(s1, s2, s3) {\\n    let n = s1.length + 2, m = s2.length + 2\\n    if (n + m - 4 !== s3.length) return false\\n    let dp = new Uint8Array(m)\\n    dp[1] = 1\\n    for (let i = 1; i < n; i++)\\n        for (let j = 1; j < m; j++) {\\n            let up = dp[j] && s1[i-2] === s3[j+i-3],\\n                left = dp[j-1] && s2[j-2] === s3[j+i-3]\\n            dp[j] = up || left\\n        }\\n    return dp[m-1]\\n};\\n```\n```python\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        n, m = len(s1) + 2, len(s2) + 2\\n        if n + m - 4 != len(s3): return False\\n        dp = [0] * m\\n        dp[1] = 1\\n        for i in range(1, n):\\n            for j in range(1, m):\\n                up = dp[j] and (i < 2 or s1[i-2] == s3[j+i-3])\\n                left = dp[j-1] and (j < 2 or s2[j-2] == s3[j+i-3])\\n                dp[j] = up or left\\n        return dp[-1]\\n```\n```java\\nclass Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        int n = s1.length() + 2, m = s2.length() + 2;\\n        char[] sc1 = s1.toCharArray(), sc2 = s2.toCharArray(), sc3 = s3.toCharArray();\\n        if (n + m - 4 != s3.length()) return false;\\n        boolean[] dp = new boolean[m];\\n        dp[1] = true;\\n        for (int i = 1; i < n; i++)\\n            for (int j = 1; j < m; j++) {\\n                boolean up = dp[j] && (i < 2 || sc1[i-2] == sc3[j+i-3]),\\n                    left =dp[j-1] && (j < 2 || sc2[j-2] == sc3[j+i-3]);\\n                dp[j] = up || left;\\n            }\\n        return dp[m-1];\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n = s1.length() + 2, m = s2.length() + 2;\\n        if (n + m - 4 != s3.length()) return false;\\n        vector<bool> dp(m);\\n        dp[1] = true;\\n        for (int i = 1; i < n; i++)\\n            for (int j = 1; j < m; j++) {\\n                bool up = dp[j] && (i < 2 || s1[i-2] == s3[j+i-3]),\\n                    left = dp[j-1] && (j < 2 || s2[j-2] == s3[j+i-3]);\\n               dp[j] = up || left;\\n            }\\n        return dp[m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1247663,
                "title": "interleaving-string-dp-o-s2-length-java",
                "content": "```java\\npublic boolean isInterleave(String s1, String s2, String s3) {\\n        if (s1.length() + s2.length() != s3.length())\\n            return false;\\n        int m = s1.length(), n = s2.length();\\n        \\n        boolean[] dp = new boolean[n+1];\\n        dp[0] = true;\\n        for (int i = 1; i <= n; ++i) {\\n            dp[i] = dp[i-1] && s3.charAt(i-1) == s2.charAt(i-1);\\n        }\\n        \\n        for (int i = 1; i <= m; ++i) {\\n            for (int j = 0; j <= n; ++j) {\\n                if (j == 0)\\n                    dp[j] = dp[j] && s3.charAt(i-1) == s1.charAt(i-1);\\n                else\\n                    dp[j] = (dp[j] && s3.charAt(i+j-1) == s1.charAt(i-1)) || (dp[j-1] && s3.charAt(i+j-1) == s2.charAt(j-1));\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n```",
                "solutionTags": [],
                "code": "```java\\npublic boolean isInterleave(String s1, String s2, String s3) {\\n        if (s1.length() + s2.length() != s3.length())\\n            return false;\\n        int m = s1.length(), n = s2.length();\\n        \\n        boolean[] dp = new boolean[n+1];\\n        dp[0] = true;\\n        for (int i = 1; i <= n; ++i) {\\n            dp[i] = dp[i-1] && s3.charAt(i-1) == s2.charAt(i-1);\\n        }\\n        \\n        for (int i = 1; i <= m; ++i) {\\n            for (int j = 0; j <= n; ++j) {\\n                if (j == 0)\\n                    dp[j] = dp[j] && s3.charAt(i-1) == s1.charAt(i-1);\\n                else\\n                    dp[j] = (dp[j] && s3.charAt(i+j-1) == s1.charAt(i-1)) || (dp[j-1] && s3.charAt(i+j-1) == s2.charAt(j-1));\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 602726,
                "title": "python-recursive-solution-with-memoization-and-explanation",
                "content": "The recursive function takes in the 2 given strings and the target string, shortening either s1 or s2, and s3 by 1 character for each successful recursive stack.\\n\\nLet\\'s take a simple example where memoization will be useful:\\n* \\ts1: \\'abc\\'\\n* \\ts2: \\'ade\\'\\n* \\ts3: \\'aabdce\\'\\n\\nThe recursive stack tree visualization would look like this:\\n```\\n                          [\\'abc\\'][\\'ade\\'][\\'aabdce\\']\\n                       /                            \\\\\\n           a[\\'bc\\'][\\'ade\\'][\\'abdce\\']            a[\\'de\\'][\\'abc\\'][\\'abdce\\']\\n              /          \\\\                               \\\\\\n           aa[\\'bc\\'][\\'de\\'][\\'bdce\\']           aa[\\'de\\'][\\'abc\\'][\\'bdce\\'] (already seen, so prune here)\\n\\t         /             \\\\\\n\\taab[\\'c\\'][\\'de\\'][\\'dce\\']   aad[\\'bc\\'][\\'e\\'][\\'bdce\\'] (\\'d\\' does not match \\'b\\', so stop here)\\n\\t            \\\\\\n\\taabd[\\'c\\'][\\'e\\'][\\'ce\\']\\n\\t           /\\n\\taabdc[\\'\\'][\\'e\\'][\\'e\\']\\n\\t           \\\\\\n\\taabdce[\\'\\'][\\'\\'][\\'\\'] (return True)\\n```\\nWhere the first word is the current string, followed by s1, s2 and s3.\\nEach left branch indicates popping the first letter of s1 if it matches the first letter of s3.\\nRight branch for s2 under the same condition.\\n\\n**Base case**\\nWe return True if all s1, s2 and s3 are empty.\\nThis means that we have exhaustively used all s1 and s2 to generate s3.\\n\\n**Recursive call**\\nIn each recursive stack, we have 2 options, to check s1 or s2.\\nWe do this for either s1, s2 (or both) if their first letter matches the remaining first letter of s3.\\n\\n**Memoization**\\nWe keep track of the combinations we have seen so far by keeping a record of the remaining s1 + s2 or s2 + s1.\\nThe order does not matter since the recursion will perform the algorithm on both strings anyway.\\nSo after we have done each recursive call, we need to add this to the set, and only continue if we haven\\'t seen that combination in the set yet.\\n\\n**Return value**\\nWe return True if any of the branches returns True.\\nSo we use the \\'or\\' operation with False as the default answer.\\n```\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        \\n        seen = set()\\n        \\n        def recursive(s, t, remaining):\\n            if len(s) == len(t) == len(remaining) == 0:\\n                return True\\n            \\n            ans = False\\n            \\n            if len(s) > 0 and len(remaining) > 0 and s[0] == remaining[0] and (s[1:]+\\'.\\'+t not in seen or t[1:]+\\'.\\'+s not in seen):\\n                seen.add(s[1:]+\\'.\\'+t)\\n                ans = recursive(s[1:],t,remaining[1:])\\n            if len(t) > 0 and len(remaining) > 0 and t[0] == remaining[0] and (s[1:]+\\'.\\'+t not in seen or t[1:]+\\'.\\'+s not in seen):\\n\\t\\t\\t    seen.add(t[1:]+\\'.\\'+s)\\n                ans = ans or recursive(s, t[1:], remaining[1:])\\n\\n            return ans\\n        \\n        return recursive(s1, s2, s3)\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n                          [\\'abc\\'][\\'ade\\'][\\'aabdce\\']\\n                       /                            \\\\\\n           a[\\'bc\\'][\\'ade\\'][\\'abdce\\']            a[\\'de\\'][\\'abc\\'][\\'abdce\\']\\n              /          \\\\                               \\\\\\n           aa[\\'bc\\'][\\'de\\'][\\'bdce\\']           aa[\\'de\\'][\\'abc\\'][\\'bdce\\'] (already seen, so prune here)\\n\\t         /             \\\\\\n\\taab[\\'c\\'][\\'de\\'][\\'dce\\']   aad[\\'bc\\'][\\'e\\'][\\'bdce\\'] (\\'d\\' does not match \\'b\\', so stop here)\\n\\t            \\\\\\n\\taabd[\\'c\\'][\\'e\\'][\\'ce\\']\\n\\t           /\\n\\taabdc[\\'\\'][\\'e\\'][\\'e\\']\\n\\t           \\\\\\n\\taabdce[\\'\\'][\\'\\'][\\'\\'] (return True)\\n```\n```\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        \\n        seen = set()\\n        \\n        def recursive(s, t, remaining):\\n            if len(s) == len(t) == len(remaining) == 0:\\n                return True\\n            \\n            ans = False\\n            \\n            if len(s) > 0 and len(remaining) > 0 and s[0] == remaining[0] and (s[1:]+\\'.\\'+t not in seen or t[1:]+\\'.\\'+s not in seen):\\n                seen.add(s[1:]+\\'.\\'+t)\\n                ans = recursive(s[1:],t,remaining[1:])\\n            if len(t) > 0 and len(remaining) > 0 and t[0] == remaining[0] and (s[1:]+\\'.\\'+t not in seen or t[1:]+\\'.\\'+s not in seen):\\n\\t\\t\\t    seen.add(t[1:]+\\'.\\'+s)\\n                ans = ans or recursive(s, t[1:], remaining[1:])\\n\\n            return ans\\n        \\n        return recursive(s1, s2, s3)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 200455,
                "title": "from-brute-force-to-dp",
                "content": "### Brute Force\\nTry matching s1 and s2 with s3 one letter at a time.\\n```\\nclass Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        return isInterleaveFrom(s1, s2, s3, 0, 0, 0);\\n    }\\n    \\n    private boolean isInterleaveFrom(\\n        String m, String n, String p,\\n        int mIndex, int nIndex, int pIndex) {\\n        if (pIndex == p.length())\\n            return mIndex == m.length() && nIndex == n.length();\\n        \\n        if (mIndex < m.length() && m.charAt(mIndex) == p.charAt(pIndex)) {\\n            if (isInterleaveFrom(m, n, p, mIndex + 1, nIndex, pIndex + 1))\\n                return true;\\n        }\\n        if (nIndex < n.length() && n.charAt(nIndex) == p.charAt(pIndex)) {\\n            if (isInterleaveFrom(m, n, p, mIndex, nIndex + 1, pIndex + 1))\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\n### Top-down DP\\n```\\nclass Solution {\\n    private Map<String, Boolean> dp;\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        dp = new HashMap<>();\\n        return isInterleaveFrom(s1, s2, s3, 0, 0, 0);\\n    }\\n    \\n    private boolean isInterleaveFrom(\\n        String m, String n, String p,\\n        int mIndex, int nIndex, int pIndex) {\\n        if (pIndex == p.length())\\n            return mIndex == m.length() && nIndex == n.length();\\n        \\n        String key = mIndex + \"|\" + nIndex + \"|\" + pIndex;\\n        if (dp.containsKey(key))\\n            return dp.get(key);\\n        \\n        if (mIndex < m.length() && m.charAt(mIndex) == p.charAt(pIndex)) {\\n            if (isInterleaveFrom(m, n, p, mIndex + 1, nIndex, pIndex + 1)) {\\n                dp.put(key, true);\\n                return true;\\n            }\\n        }\\n        if (nIndex < n.length() && n.charAt(nIndex) == p.charAt(pIndex)) {\\n            if (isInterleaveFrom(m, n, p, mIndex, nIndex + 1, pIndex + 1)) {\\n                dp.put(key, true);\\n                return true;\\n            }\\n        }\\n        dp.put(key, false);\\n        return false;\\n    }\\n}\\n```\\n### Bottom-up DP\\n\\n```\\nclass Solution {\\n    public boolean isInterleave(String m, String n, String p) {\\n        boolean[][] dp = new boolean[m.length() + 1][n.length() + 1];\\n\\n        if (m.length() + n.length() != p.length())\\n            return false;\\n\\n        for (int mIndex = 0; mIndex <= m.length(); mIndex++) {\\n            for (int nIndex = 0; nIndex <= n.length(); nIndex++) {\\n                if (mIndex == 0 && nIndex == 0) {\\n                    dp[mIndex][nIndex] = true;\\n                } else {\\n                    if (mIndex > 0 && m.charAt(mIndex - 1) == p.charAt(mIndex + nIndex - 1))\\n                        dp[mIndex][nIndex] = dp[mIndex - 1][nIndex];\\n                    \\n                    if (nIndex > 0 && n.charAt(nIndex - 1) == p.charAt(mIndex + nIndex - 1))\\n                        dp[mIndex][nIndex] |= dp[mIndex][nIndex - 1];\\n                }\\n            }\\n        }\\n        \\n        return dp[m.length()][n.length()];\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        return isInterleaveFrom(s1, s2, s3, 0, 0, 0);\\n    }\\n    \\n    private boolean isInterleaveFrom(\\n        String m, String n, String p,\\n        int mIndex, int nIndex, int pIndex) {\\n        if (pIndex == p.length())\\n            return mIndex == m.length() && nIndex == n.length();\\n        \\n        if (mIndex < m.length() && m.charAt(mIndex) == p.charAt(pIndex)) {\\n            if (isInterleaveFrom(m, n, p, mIndex + 1, nIndex, pIndex + 1))\\n                return true;\\n        }\\n        if (nIndex < n.length() && n.charAt(nIndex) == p.charAt(pIndex)) {\\n            if (isInterleaveFrom(m, n, p, mIndex, nIndex + 1, pIndex + 1))\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private Map<String, Boolean> dp;\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        dp = new HashMap<>();\\n        return isInterleaveFrom(s1, s2, s3, 0, 0, 0);\\n    }\\n    \\n    private boolean isInterleaveFrom(\\n        String m, String n, String p,\\n        int mIndex, int nIndex, int pIndex) {\\n        if (pIndex == p.length())\\n            return mIndex == m.length() && nIndex == n.length();\\n        \\n        String key = mIndex + \"|\" + nIndex + \"|\" + pIndex;\\n        if (dp.containsKey(key))\\n            return dp.get(key);\\n        \\n        if (mIndex < m.length() && m.charAt(mIndex) == p.charAt(pIndex)) {\\n            if (isInterleaveFrom(m, n, p, mIndex + 1, nIndex, pIndex + 1)) {\\n                dp.put(key, true);\\n                return true;\\n            }\\n        }\\n        if (nIndex < n.length() && n.charAt(nIndex) == p.charAt(pIndex)) {\\n            if (isInterleaveFrom(m, n, p, mIndex, nIndex + 1, pIndex + 1)) {\\n                dp.put(key, true);\\n                return true;\\n            }\\n        }\\n        dp.put(key, false);\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isInterleave(String m, String n, String p) {\\n        boolean[][] dp = new boolean[m.length() + 1][n.length() + 1];\\n\\n        if (m.length() + n.length() != p.length())\\n            return false;\\n\\n        for (int mIndex = 0; mIndex <= m.length(); mIndex++) {\\n            for (int nIndex = 0; nIndex <= n.length(); nIndex++) {\\n                if (mIndex == 0 && nIndex == 0) {\\n                    dp[mIndex][nIndex] = true;\\n                } else {\\n                    if (mIndex > 0 && m.charAt(mIndex - 1) == p.charAt(mIndex + nIndex - 1))\\n                        dp[mIndex][nIndex] = dp[mIndex - 1][nIndex];\\n                    \\n                    if (nIndex > 0 && n.charAt(nIndex - 1) == p.charAt(mIndex + nIndex - 1))\\n                        dp[mIndex][nIndex] |= dp[mIndex][nIndex - 1];\\n                }\\n            }\\n        }\\n        \\n        return dp[m.length()][n.length()];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32041,
                "title": "share-my-dp-solution-in-java-o-mn-in-time-and-space",
                "content": "    public class Solution {\\n        public boolean isInterleave(String s1, String s2, String s3) {\\n            if(s1.length()+s2.length() != s3.length())\\n                return false;\\n            boolean[][] record = new boolean[s1.length()+1][s2.length()+1];\\n            for(int i = 0; i<=s1.length(); i++){\\n                if(s1.substring(0, i).equals(s3.substring(0, i))){\\n                    record[i][0] = true;\\n                }\\n            }\\n            for(int i = 0; i<=s2.length(); i++){\\n                if(s2.substring(0, i).equals(s3.substring(0, i))){\\n                    record[0][i] = true;\\n                }\\n            }\\n            for(int i = 1; i<=s1.length(); i++){\\n                for(int j = 1; j<=s2.length(); j++){\\n                    if(record[i][j-1]&&s2.charAt(j-1)==s3.charAt(i+j-1))\\n                        record[i][j]=true;\\n                    if(record[i-1][j]&&s1.charAt(i-1)==s3.charAt(i+j-1))\\n                        record[i][j]=true;\\n                }\\n            }\\n            return record[s1.length()][s2.length()];\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean isInterleave(String s1, String s2, String s3) {\\n            if(s1.length()+s2.length() != s3.length())\\n                return false;\\n            boolean[][] record = new boolean[s1.length()+1][s2.length()+1];\\n            for(int i = 0; i<=s1.length(); i++){\\n                if(s1.substring(0, i).equals(s3.substring(0, i))){\\n                    record[i][0] = true;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3956432,
                "title": "c-2d-recursive-iterative-dp-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse 2D recursive DP(top-down) to solve.\\n2nd solution is just rewritting of the 1st one into iterative solution(Bottom-up).\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n_1 n_2)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n_1 n_2)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n1=s1.size(), n2=s2.size(), n3=s3.size();\\n        if (n1+n2!=n3) return 0;\\n        vector<vector<int>> dp(n1+1 , vector<int>(n2+1, -1));\\n        function<int(int, int)> dfs=[&](int i, int j)->int\\n        {\\n            if (i==n1 && j==n2) return dp[i][j]=1;\\n            if (dp[i][j]!=-1) return dp[i][j];\\n            int ch_s1, ch_s2;\\n            if (i<n1 && s1[i]==s3[i+j]) ch_s1=dfs(i+1,j);\\n            if (j<n2 && s2[j]==s3[i+j]) ch_s2=dfs(i,j+1);\\n            return dp[i][j]=ch_s1||ch_s2;\\n        };\\n        return dfs(0, 0)!=0;\\n    }\\n};\\n```\\n# Code for 2D iterative DP\\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n1 = s1.size(), n2 = s2.size(), n3 = s3.size();\\n        if (n1+n2!=n3) return 0;\\n        \\n        vector<vector<int>> dp(n1+1, vector<int>(n2+1, 0));\\n        dp[n1][n2] = 1;\\n        \\n        for (int i=n1; i >= 0; i--) {\\n            for (int j=n2; j >= 0; j--) {\\n                if (i<n1 && s1[i]==s3[i+j]) \\n                    dp[i][j] = dp[i][j] || dp[i+1][j];\\n                if (j<n2 && s2[j]==s3[i+j]) \\n                    dp[i][j] = dp[i][j] || dp[i][j+1];\\n            }\\n        }  \\n        return dp[0][0] == 1;\\n    }\\n};\\n```\\n# Code with Explanation in comments\\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n1=s1.size(), n2=s2.size(), n3=s3.size();\\n        \\n        //Check if the total length of s1 and s2 is equal to the length of s3\\n        if (n1+n2!=n3) return 0;\\n        \\n        // Initialize a 2D DP array\\n        vector<vector<int>> dp(n1+1, vector<int>(n2+1, 0));\\n        \\n        // Set the base case: the last cell in the DP array is initialized as 1\\n        dp[n1][n2] = 1;\\n        \\n        //Iterate over the DP array from bottom-right to top-left\\n        for (int i=n1; i >= 0; i--) {\\n            for (int j=n2; j >= 0; j--) {\\n                //If there are characters left in s1 and the character matches s3\\n                if (i<n1 && s1[i]==s3[i+j]) \\n                    dp[i][j]=dp[i][j] || dp[i+1][j]; // Take value from the cell below\\n                \\n                //If there are characters left in s2 and the character matches s3\\n                if (j<n2 && s2[j]==s3[i+j]) \\n                    dp[i][j]=dp[i][j] || dp[i][j+1]; //Take value from the cell on the right\\n            }\\n        }  \\n\\n        // Return true if the top-left cell of the DP array is 1 \\n        return dp[0][0] == 1;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n1=s1.size(), n2=s2.size(), n3=s3.size();\\n        if (n1+n2!=n3) return 0;\\n        vector<vector<int>> dp(n1+1 , vector<int>(n2+1, -1));\\n        function<int(int, int)> dfs=[&](int i, int j)->int\\n        {\\n            if (i==n1 && j==n2) return dp[i][j]=1;\\n            if (dp[i][j]!=-1) return dp[i][j];\\n            int ch_s1, ch_s2;\\n            if (i<n1 && s1[i]==s3[i+j]) ch_s1=dfs(i+1,j);\\n            if (j<n2 && s2[j]==s3[i+j]) ch_s2=dfs(i,j+1);\\n            return dp[i][j]=ch_s1||ch_s2;\\n        };\\n        return dfs(0, 0)!=0;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n1 = s1.size(), n2 = s2.size(), n3 = s3.size();\\n        if (n1+n2!=n3) return 0;\\n        \\n        vector<vector<int>> dp(n1+1, vector<int>(n2+1, 0));\\n        dp[n1][n2] = 1;\\n        \\n        for (int i=n1; i >= 0; i--) {\\n            for (int j=n2; j >= 0; j--) {\\n                if (i<n1 && s1[i]==s3[i+j]) \\n                    dp[i][j] = dp[i][j] || dp[i+1][j];\\n                if (j<n2 && s2[j]==s3[i+j]) \\n                    dp[i][j] = dp[i][j] || dp[i][j+1];\\n            }\\n        }  \\n        return dp[0][0] == 1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n1=s1.size(), n2=s2.size(), n3=s3.size();\\n        \\n        //Check if the total length of s1 and s2 is equal to the length of s3\\n        if (n1+n2!=n3) return 0;\\n        \\n        // Initialize a 2D DP array\\n        vector<vector<int>> dp(n1+1, vector<int>(n2+1, 0));\\n        \\n        // Set the base case: the last cell in the DP array is initialized as 1\\n        dp[n1][n2] = 1;\\n        \\n        //Iterate over the DP array from bottom-right to top-left\\n        for (int i=n1; i >= 0; i--) {\\n            for (int j=n2; j >= 0; j--) {\\n                //If there are characters left in s1 and the character matches s3\\n                if (i<n1 && s1[i]==s3[i+j]) \\n                    dp[i][j]=dp[i][j] || dp[i+1][j]; // Take value from the cell below\\n                \\n                //If there are characters left in s2 and the character matches s3\\n                if (j<n2 && s2[j]==s3[i+j]) \\n                    dp[i][j]=dp[i][j] || dp[i][j+1]; //Take value from the cell on the right\\n            }\\n        }  \\n\\n        // Return true if the top-left cell of the DP array is 1 \\n        return dp[0][0] == 1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2252482,
                "title": "java-5-methods-explained",
                "content": "**Method 1:** Recursion. Gets TLE\\n* Follow binary tree approach in which we take a character from one string and check if it matches\\n* If yes, then repeat, else backtrack and try other possibilities\\n* Method 1 will have repeated sub-problems which can be optimized using memoization (method 2)\\n>**T/S:** O(2 ^ (m + n))/O(m + n), where m = size(s1), n = size(s2)\\n\\nExample:\\n![image](https://assets.leetcode.com/users/images/030aa1fc-934b-4124-824b-0bad2fe0ecee_1657227944.4161835.png)\\n\\n```\\npublic boolean isInterleave(String s1, String s2, String s3) {\\n\\tvar m = s1.length();\\n\\tvar n = s2.length();\\n\\treturn m + n == s3.length() && isInterleave(s1, s2, s3, m, n, 0, 0);\\n}\\n\\nprivate boolean isInterleave(String s1, String s2, String s3, int m, int n, int i, int j) {\\n\\treturn i == m && j == n // reached end of both strings, so interleaving\\n\\t\\t|| i < m && s1.charAt(i) == s3.charAt(i + j) && isInterleave(s1, s2, s3, m, n, i + 1, j) // recurse over s1\\n\\t\\t|| j < n && s2.charAt(j) == s3.charAt(i + j) && isInterleave(s1, s2, s3, m, n, i, j + 1); // recurse over s2\\n}\\n```\\n**Method 2:** Inject memoization in method 1. Top Down DP (Memoization)\\n>**T/S:** O(mn)/O(mn)\\n```\\npublic boolean isInterleave(String s1, String s2, String s3) {\\n\\tvar m = s1.length();\\n\\tvar n = s2.length();\\n\\treturn m + n == s3.length() \\n\\t\\t&& isInterleave(s1, s2, s3, m, n, 0, 0, new Boolean[m + 1][n + 1]);\\n}\\n\\nprivate boolean isInterleave(String s1, String s2, String s3, int m, int n, int i, int j, Boolean[][] memo) {\\n\\tif (i == m && j == n)\\n\\t\\treturn true;\\n\\tif (memo[i][j] != null)\\n\\t\\treturn memo[i][j];\\n\\t\\t\\n\\treturn memo[i][j] = i < m && s1.charAt(i) == s3.charAt(i + j) && isInterleave(s1, s2, s3, m, n, i + 1, j, memo) \\n\\t\\t\\t\\t\\t || j < n && s2.charAt(j) == s3.charAt(i + j) && isInterleave(s1, s2, s3, m, n, i, j + 1, memo);\\n}\\n```\\n**Method 3:** Top Down Tabulation version of method 2\\n* Same idea, just iterative\\n>**T/S:** O(mn)/O(mn)\\n```\\npublic boolean isInterleave(String s1, String s2, String s3) {\\n\\tvar m = s1.length();\\n\\tvar n = s2.length();\\n\\tif (m + n != s3.length())\\n\\t\\treturn false;\\n\\n\\tvar dp = new boolean[m + 1][n + 1];\\n\\tdp[m][n] = true;\\n\\n\\tfor (var i = m; i >= 0; i--)\\n\\t\\tfor (var j = n; j >= 0; j--)\\n\\t\\t\\tif (i < m && s1.charAt(i) == s3.charAt(i + j) && dp[i + 1][j] \\n\\t\\t\\t || j < n && s2.charAt(j) == s3.charAt(i + j) && dp[i][j + 1])\\t\\t\\t\\t\\n\\t\\t\\t\\tdp[i][j] = true;\\n\\n\\treturn dp[0][0];\\n}\\n```\\n**Method 4:** Bottom Up DP (Tabulation)\\n* For each cell consider only the strings upto that point\\n* For the top left corner, both strings are empty and interleave to empty portion of s2, so `isInterleave = true`\\n* For the first column s2 is considered empty and for first row s1 is considered empty. Now fill out if the corresponding letter of s1 and s3 match. Repeat for s2 and s3. E.g.\\n\\t* s1 = aabcc, s3 = aadbbcbcac, matches occur for first 2 letters so the value is true, rest are false\\n* For cell (2, 2), consider the strings s1 = aa, s2 = db, s3 = aadb\\n\\t* Check top neighbor (remove 1 char from s1), i.e. s1 = a, s2 = db. Its false, so do nothing. False is expected since a and db can\\'t be interleaved in any way to form the first 3 letters of s3 \\n\\t* Check left neighbot (remove 1 char from s2), i.e. s1 = aa, s2 = d. Its true, so check next condition. True is expected because `aa` and `d`  can be interleaved to form the first 3 letters of s3.\\n\\t\\t* Next condition is to check whether current char of s2 is the same as current char of s3, which is true since they both are b\\n\\t\\t* Since both the conditions are true, it means s1 and s2 can be interleaved to form s3, thus the value here would be true\\n* Continue doing this for complete strings s1 and s2. Value in bottom right corner will be the answer since that denotes the end of the interleaving of 2 strings\\n\\t\\t\\nExample: `s1 = aabcc, s2 = dbbca, s3 = aadbbcbcac`\\n\\n![image](https://assets.leetcode.com/users/images/ef2f6ce0-615f-4a6b-93e2-ce34fcfff488_1657228807.3073637.png)\\n\\n>**T/S:** O(mn)/O(mn)\\n```\\npublic boolean isInterleave(String s1, String s2, String s3) {\\n\\tvar m = s1.length();\\n\\tvar n = s2.length();\\n\\tif (m + n != s3.length())\\n\\t\\treturn false;\\n\\n\\tvar dp = new boolean[m + 1][n + 1];\\n\\tdp[0][0] = true;\\n\\n\\tfor (var i = 0; i < m && dp[i][0]; i++)\\n\\t\\tdp[i + 1][0] = s1.charAt(i) == s3.charAt(i) && dp[i][0];\\n\\n\\tfor (var j = 0; j < n && dp[0][j]; j++)\\n\\t\\tdp[0][j + 1] = s2.charAt(j) == s3.charAt(j) && dp[0][j];\\n\\n\\tfor (var i = 1; i <= m; i++)\\n\\t\\tfor (var j = 1; j <= n; j++)\\n\\t\\t\\tdp[i][j] = dp[i - 1][j] && s1.charAt(i - 1) == s3.charAt(i + j - 1)\\n\\t\\t\\t\\t\\t|| dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1);\\n\\n\\treturn dp[m][n];\\n}\\n```\\n**Method 5:** Space optimized version of Method 3\\n* In any iteration only the current row and previous row of dp is being used, so we need only 2 rows, not m\\n>**T/S:** O(mn)/O(n)\\n```\\npublic boolean isInterleave(String s1, String s2, String s3) {\\n\\tvar m = s1.length();\\n\\tvar n = s2.length();\\n\\tif (m + n != s3.length())\\n\\t\\treturn false;\\n\\n\\tvar dp = new boolean[n + 1];\\n\\n\\tfor (var i = 0; i <= m; i++)\\n\\t\\tfor (var j = 0; j <= n; j++) {\\n\\t\\t\\tvar first = j != 0 && dp[j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1);\\n\\t\\t\\tvar second = i != 0 && dp[j] && s1.charAt(i - 1) == s3.charAt(i + j - 1);\\n\\n\\t\\t\\tif (i == 0 && j == 0)\\n\\t\\t\\t\\tdp[j] = true;\\n\\t\\t\\telse if (i == 0)\\n\\t\\t\\t\\tdp[j] = first;\\n\\t\\t\\telse if (j == 0)\\n\\t\\t\\t\\tdp[j] = second;\\n\\t\\t\\telse\\n\\t\\t\\t\\tdp[j] = first || second;\\n\\t\\t}\\n\\treturn dp[n];\\n}\\n```\\n\\n***Please upvote if this helps***\\n",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "```\\npublic boolean isInterleave(String s1, String s2, String s3) {\\n\\tvar m = s1.length();\\n\\tvar n = s2.length();\\n\\treturn m + n == s3.length() && isInterleave(s1, s2, s3, m, n, 0, 0);\\n}\\n\\nprivate boolean isInterleave(String s1, String s2, String s3, int m, int n, int i, int j) {\\n\\treturn i == m && j == n // reached end of both strings, so interleaving\\n\\t\\t|| i < m && s1.charAt(i) == s3.charAt(i + j) && isInterleave(s1, s2, s3, m, n, i + 1, j) // recurse over s1\\n\\t\\t|| j < n && s2.charAt(j) == s3.charAt(i + j) && isInterleave(s1, s2, s3, m, n, i, j + 1); // recurse over s2\\n}\\n```\n```\\npublic boolean isInterleave(String s1, String s2, String s3) {\\n\\tvar m = s1.length();\\n\\tvar n = s2.length();\\n\\treturn m + n == s3.length() \\n\\t\\t&& isInterleave(s1, s2, s3, m, n, 0, 0, new Boolean[m + 1][n + 1]);\\n}\\n\\nprivate boolean isInterleave(String s1, String s2, String s3, int m, int n, int i, int j, Boolean[][] memo) {\\n\\tif (i == m && j == n)\\n\\t\\treturn true;\\n\\tif (memo[i][j] != null)\\n\\t\\treturn memo[i][j];\\n\\t\\t\\n\\treturn memo[i][j] = i < m && s1.charAt(i) == s3.charAt(i + j) && isInterleave(s1, s2, s3, m, n, i + 1, j, memo) \\n\\t\\t\\t\\t\\t || j < n && s2.charAt(j) == s3.charAt(i + j) && isInterleave(s1, s2, s3, m, n, i, j + 1, memo);\\n}\\n```\n```\\npublic boolean isInterleave(String s1, String s2, String s3) {\\n\\tvar m = s1.length();\\n\\tvar n = s2.length();\\n\\tif (m + n != s3.length())\\n\\t\\treturn false;\\n\\n\\tvar dp = new boolean[m + 1][n + 1];\\n\\tdp[m][n] = true;\\n\\n\\tfor (var i = m; i >= 0; i--)\\n\\t\\tfor (var j = n; j >= 0; j--)\\n\\t\\t\\tif (i < m && s1.charAt(i) == s3.charAt(i + j) && dp[i + 1][j] \\n\\t\\t\\t || j < n && s2.charAt(j) == s3.charAt(i + j) && dp[i][j + 1])\\t\\t\\t\\t\\n\\t\\t\\t\\tdp[i][j] = true;\\n\\n\\treturn dp[0][0];\\n}\\n```\n```\\npublic boolean isInterleave(String s1, String s2, String s3) {\\n\\tvar m = s1.length();\\n\\tvar n = s2.length();\\n\\tif (m + n != s3.length())\\n\\t\\treturn false;\\n\\n\\tvar dp = new boolean[m + 1][n + 1];\\n\\tdp[0][0] = true;\\n\\n\\tfor (var i = 0; i < m && dp[i][0]; i++)\\n\\t\\tdp[i + 1][0] = s1.charAt(i) == s3.charAt(i) && dp[i][0];\\n\\n\\tfor (var j = 0; j < n && dp[0][j]; j++)\\n\\t\\tdp[0][j + 1] = s2.charAt(j) == s3.charAt(j) && dp[0][j];\\n\\n\\tfor (var i = 1; i <= m; i++)\\n\\t\\tfor (var j = 1; j <= n; j++)\\n\\t\\t\\tdp[i][j] = dp[i - 1][j] && s1.charAt(i - 1) == s3.charAt(i + j - 1)\\n\\t\\t\\t\\t\\t|| dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1);\\n\\n\\treturn dp[m][n];\\n}\\n```\n```\\npublic boolean isInterleave(String s1, String s2, String s3) {\\n\\tvar m = s1.length();\\n\\tvar n = s2.length();\\n\\tif (m + n != s3.length())\\n\\t\\treturn false;\\n\\n\\tvar dp = new boolean[n + 1];\\n\\n\\tfor (var i = 0; i <= m; i++)\\n\\t\\tfor (var j = 0; j <= n; j++) {\\n\\t\\t\\tvar first = j != 0 && dp[j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1);\\n\\t\\t\\tvar second = i != 0 && dp[j] && s1.charAt(i - 1) == s3.charAt(i + j - 1);\\n\\n\\t\\t\\tif (i == 0 && j == 0)\\n\\t\\t\\t\\tdp[j] = true;\\n\\t\\t\\telse if (i == 0)\\n\\t\\t\\t\\tdp[j] = first;\\n\\t\\t\\telse if (j == 0)\\n\\t\\t\\t\\tdp[j] = second;\\n\\t\\t\\telse\\n\\t\\t\\t\\tdp[j] = first || second;\\n\\t\\t}\\n\\treturn dp[n];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2250499,
                "title": "python-easiest-alternative-o-n-space-solution-beats-97-19",
                "content": "```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3):\\n            return False\\n        \\n        curr_layer, next_layer = set([(-1, -1)]), set()\\n        i3 = 0\\n        \\n        while curr_layer and i3 < len(s3):\\n            for i1, i2 in curr_layer:\\n                if i1 + 1 < len(s1) and s1[i1 + 1] == s3[i3]:\\n                    next_layer.add((i1 + 1, i2))\\n                if i2 + 1 < len(s2) and s2[i2 + 1] == s3[i3]:\\n                    next_layer.add((i1, i2 + 1))\\n            curr_layer, next_layer = next_layer, set()\\n            if curr_layer:\\n                i3 += 1\\n        \\n        return i3 == len(s3)\\n```\\n\\nIn this solution, we represent all possible combinations in a graph, and each time in the loop we go down one level in depth.\\n\\nTime Complexity - ```O(M *N)```, ```37``` ms, faster than ```97.19%```\\nSpace \\u0421omplexity - ```O(N)```,  ```13.9``` MB, faster than ```98.69%```\\n\\nVisualization:\\n![image](https://assets.leetcode.com/users/images/69135256-b4d7-48aa-b7d7-266639118969_1657195236.3817675.jpeg)\\n![image](https://assets.leetcode.com/users/images/bc25a80b-242d-4548-b5b4-ee0ecd75f1dd_1657195282.757755.jpeg)",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3):\\n            return False\\n        \\n        curr_layer, next_layer = set([(-1, -1)]), set()\\n        i3 = 0\\n        \\n        while curr_layer and i3 < len(s3):\\n            for i1, i2 in curr_layer:\\n                if i1 + 1 < len(s1) and s1[i1 + 1] == s3[i3]:\\n                    next_layer.add((i1 + 1, i2))\\n                if i2 + 1 < len(s2) and s2[i2 + 1] == s3[i3]:\\n                    next_layer.add((i1, i2 + 1))\\n            curr_layer, next_layer = next_layer, set()\\n            if curr_layer:\\n                i3 += 1\\n        \\n        return i3 == len(s3)\\n```\n```O(M *N)```\n```37```\n```97.19%```\n```O(N)```\n```13.9```\n```98.69%```",
                "codeTag": "Java"
            },
            {
                "id": 2249083,
                "title": "cpp-beats-100-runtime-and-100-memory-usage-users-simple-dp-memoization",
                "content": "![image](https://assets.leetcode.com/users/images/37f82ee7-e049-4f80-8432-e08a34b9e045_1657170763.5329103.png)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        \\n        if(s1.size() + s2.size()!=s3.size()){\\n            return false;\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        \\n        return fun(s1,s2,s3,0,0,0);\\n        \\n    }\\n    \\n    int dp[105][105];\\n    \\n    int fun(string& s1,string& s2,string& s3,int p1,int p2,int p3){\\n        \\n        if(p1+p2==s3.size()){\\n            return true;\\n        }\\n        \\n        if(dp[p1][p2]!=-1){\\n            return dp[p1][p2];\\n        }\\n        \\n        bool res = false;\\n        \\n        if(p1!=s1.size()&&s1[p1]==s3[p3]) res|=fun(s1,s2,s3,p1+1,p2,p3+1);\\n        if(p2!=s2.size()&&s2[p2]==s3[p3]) res|=fun(s1,s2,s3,p1,p2+1,p3+1);\\n        \\n        return dp[p1][p2]=res;\\n        \\n    }\\n    \\n};\\n```\\n\\n\\n##### Upvote !!",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        \\n        if(s1.size() + s2.size()!=s3.size()){\\n            return false;\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        \\n        return fun(s1,s2,s3,0,0,0);\\n        \\n    }\\n    \\n    int dp[105][105];\\n    \\n    int fun(string& s1,string& s2,string& s3,int p1,int p2,int p3){\\n        \\n        if(p1+p2==s3.size()){\\n            return true;\\n        }\\n        \\n        if(dp[p1][p2]!=-1){\\n            return dp[p1][p2];\\n        }\\n        \\n        bool res = false;\\n        \\n        if(p1!=s1.size()&&s1[p1]==s3[p3]) res|=fun(s1,s2,s3,p1+1,p2,p3+1);\\n        if(p2!=s2.size()&&s2[p2]==s3[p3]) res|=fun(s1,s2,s3,p1,p2+1,p3+1);\\n        \\n        return dp[p1][p2]=res;\\n        \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956582,
                "title": "easy-recursion-and-memoization-cpp",
                "content": "\\n\\n# RECURSION\\n```\\nclass Solution {\\npublic:\\n    bool helper(int i,int j,int k,string &s1, string &s2, string &s3){\\n        if(i<0 && j<0 && k<0)\\n            return true;\\n        \\n        if(i>=0 && j>=0 && k>=0 && s1[i]==s3[k] && s2[j]==s3[k])\\n            return helper(i-1,j,k-1,s1,s2,s3) || helper(i,j-1,k-1,s1,s2,s3) ;\\n        else if (i>=0 && k>=0 && s1[i]==s3[k])\\n            return helper(i-1,j,k-1,s1,s2,s3);\\n        else if(j>=0 && k>=0 && s2[j] == s3[k] )\\n            return helper(i,j-1,k-1,s1,s2,s3);\\n        else\\n            return false;\\n    }\\n    bool isInterleave(string s1, string s2, string s3) {\\n        if(s1.length() + s2.length() != s3.length())\\n            return false;\\n\\n        return helper(s1.length()-1,s2.length()-1,s3.length()-1,s1,s2,s3);\\n    }\\n};\\n```\\n\\n\\n# MEMOIZATION\\n```\\nbool helper(int i,int j,int k,string &s1, string &s2, string &s3,vector<vector<int>> &dp){\\n        if(i<0 && j<0 && k<0)\\n            return true;\\n\\n        if(dp[i+1][j+1]!=-1)\\n            return dp[i+1][j+1];\\n        \\n        bool result = false;\\n        if(i>=0 && j>=0 && k>=0 && s1[i]==s3[k] && s2[j]==s3[k])\\n            return result = helper(i-1,j,k-1,s1,s2,s3,dp) || helper(i,j-1,k-1,s1,s2,s3,dp) ;\\n        else if (i>=0 && k>=0 && s1[i]==s3[k])\\n            return result = helper(i-1,j,k-1,s1,s2,s3,dp);\\n        else if(j>=0 && k>=0 && s2[j] == s3[k] )\\n            return result = helper(i,j-1,k-1,s1,s2,s3,dp);\\n        \\n        return dp[i+1][j+1] = result;\\n    }\\n    bool isInterleave(string &s1, string &s2, string &s3) {\\n        if(s1.length() + s2.length() != s3.length())\\n            return false;\\n        vector<vector<int>> dp(s1.length()+1,vector<int>(s2.length()+1,-1));\\n        return helper(s1.length()-1,s2.length()-1,s3.length()-1,s1,s2,s3,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool helper(int i,int j,int k,string &s1, string &s2, string &s3){\\n        if(i<0 && j<0 && k<0)\\n            return true;\\n        \\n        if(i>=0 && j>=0 && k>=0 && s1[i]==s3[k] && s2[j]==s3[k])\\n            return helper(i-1,j,k-1,s1,s2,s3) || helper(i,j-1,k-1,s1,s2,s3) ;\\n        else if (i>=0 && k>=0 && s1[i]==s3[k])\\n            return helper(i-1,j,k-1,s1,s2,s3);\\n        else if(j>=0 && k>=0 && s2[j] == s3[k] )\\n            return helper(i,j-1,k-1,s1,s2,s3);\\n        else\\n            return false;\\n    }\\n    bool isInterleave(string s1, string s2, string s3) {\\n        if(s1.length() + s2.length() != s3.length())\\n            return false;\\n\\n        return helper(s1.length()-1,s2.length()-1,s3.length()-1,s1,s2,s3);\\n    }\\n};\\n```\n```\\nbool helper(int i,int j,int k,string &s1, string &s2, string &s3,vector<vector<int>> &dp){\\n        if(i<0 && j<0 && k<0)\\n            return true;\\n\\n        if(dp[i+1][j+1]!=-1)\\n            return dp[i+1][j+1];\\n        \\n        bool result = false;\\n        if(i>=0 && j>=0 && k>=0 && s1[i]==s3[k] && s2[j]==s3[k])\\n            return result = helper(i-1,j,k-1,s1,s2,s3,dp) || helper(i,j-1,k-1,s1,s2,s3,dp) ;\\n        else if (i>=0 && k>=0 && s1[i]==s3[k])\\n            return result = helper(i-1,j,k-1,s1,s2,s3,dp);\\n        else if(j>=0 && k>=0 && s2[j] == s3[k] )\\n            return result = helper(i,j-1,k-1,s1,s2,s3,dp);\\n        \\n        return dp[i+1][j+1] = result;\\n    }\\n    bool isInterleave(string &s1, string &s2, string &s3) {\\n        if(s1.length() + s2.length() != s3.length())\\n            return false;\\n        vector<vector<int>> dp(s1.length()+1,vector<int>(s2.length()+1,-1));\\n        return helper(s1.length()-1,s2.length()-1,s3.length()-1,s1,s2,s3,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2130468,
                "title": "python-recursion-with-dp-with-added-comments",
                "content": "# Interleaving Strings solution\\n\\n\\n```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        \\'\\'\\' base condition, if sum of the length of given strings, \\n\\t\\ts1 and s2 are not equal to length of the \\'interleaved\\' string,\\n\\t\\tthen The required string s3 cannot be formed by completely using s1 and s2\\'\\'\\'\\n        if len(s1)+len(s2) != len(s3):\\n            return False\\n        \\n        dp ={}\\n        \\n        \\n        def construct(p1,p2,ind):\\n            if ind == len(s3):\\n                return True\\n            \\n            if (p1,p2) in dp:\\n                return dp[(p1,p2)]\\n            \\n            \\n            \\n            # if the s1 has been traversed or the pointer at s1 doesnt match\\n            if p1>=len(s1) or s1[p1] != s3[ind]:\\n                \\n                # if s2 has not been traversed completely but still pointer is not matchin\\n                if p2<len(s2) and s2[p2]!=s3[ind]:\\n                    return False\\n                \\n                # both s1 and s2 has been traversed\\n                elif p2>=len(s2):return False\\n                \\n                # else a match is found in s2 so inc pointers to s2 and the req string\\n                dp[(p1,p2)] = construct(p1,p2+1,ind+1)\\n            \\n            \\n            # doing the same for p2\\n            elif p2>= len(s2) or s2[p2] != s3[ind]:\\n                \\n                if s1[p1] != s3[ind]: return False\\n                \\n                \\n                dp[(p1,p2)] = construct(p1+1,p2,ind+1)\\n    \\n            # in this case we have matches in both s1 and s2 so you can traverse along either of the path\\n            elif s1[p1] == s3[ind] and s2[p2] == s3[ind]:\\n                dp[(p1,p2)] = construct(p1+1,p2,ind+1) or construct(p1,p2+1,ind+1)\\n            \\n            return dp[(p1,p2)]\\n        \\n        return construct(0,0,0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        \\'\\'\\' base condition, if sum of the length of given strings, \\n\\t\\ts1 and s2 are not equal to length of the \\'interleaved\\' string,\\n\\t\\tthen The required string s3 cannot be formed by completely using s1 and s2\\'\\'\\'\\n        if len(s1)+len(s2) != len(s3):\\n            return False\\n        \\n        dp ={}\\n        \\n        \\n        def construct(p1,p2,ind):\\n            if ind == len(s3):\\n                return True\\n            \\n            if (p1,p2) in dp:\\n                return dp[(p1,p2)]\\n            \\n            \\n            \\n            # if the s1 has been traversed or the pointer at s1 doesnt match\\n            if p1>=len(s1) or s1[p1] != s3[ind]:\\n                \\n                # if s2 has not been traversed completely but still pointer is not matchin\\n                if p2<len(s2) and s2[p2]!=s3[ind]:\\n                    return False\\n                \\n                # both s1 and s2 has been traversed\\n                elif p2>=len(s2):return False\\n                \\n                # else a match is found in s2 so inc pointers to s2 and the req string\\n                dp[(p1,p2)] = construct(p1,p2+1,ind+1)\\n            \\n            \\n            # doing the same for p2\\n            elif p2>= len(s2) or s2[p2] != s3[ind]:\\n                \\n                if s1[p1] != s3[ind]: return False\\n                \\n                \\n                dp[(p1,p2)] = construct(p1+1,p2,ind+1)\\n    \\n            # in this case we have matches in both s1 and s2 so you can traverse along either of the path\\n            elif s1[p1] == s3[ind] and s2[p2] == s3[ind]:\\n                dp[(p1,p2)] = construct(p1+1,p2,ind+1) or construct(p1,p2+1,ind+1)\\n            \\n            return dp[(p1,p2)]\\n        \\n        return construct(0,0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1450701,
                "title": "simple-python-o-mn-dynamic-programming-solution",
                "content": "```Python\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s3) != len(s1)+len(s2):\\n            return False\\n        # state: dp[i][j] denote whether the first i+j letters in s3 is a \\n        # interleaving of the first i elements in s1 and the first j\\n        # elements in s2\\n        n, m = len(s1), len(s2)\\n        dp = [[False]*(m+1) for _ in range(n+1)]\\n        \\n        # initialization: fill in the first row and column\\n        dp[0][0] = True\\n        for i in range(1, n+1):\\n            dp[i][0] = dp[i-1][0] and s1[i-1] == s3[i-1]\\n        for i in range(1, m+1):\\n            dp[0][i] = dp[0][i-1] and s2[i-1] == s3[i-1]\\n        \\n        # state transition: matching last character in s1 and s2 with that\\n        # of s3\\n        for i in range(1, n+1):\\n            for j in range(1, m+1):\\n                if s1[i-1] == s3[i+j-1]:         # s3[:3] = \"abc\", s1[2] = \\'c\\'\\n                    dp[i][j] = dp[i-1][j]\\n                if s2[j-1] == s3[i+j-1]:         # s3[:3] = \"abc\", s2[2] = \\'c\\'\\n                    dp[i][j] = dp[i][j] or dp[i][j-1]\\n            \\n        # result: whether entire s3 is an interleaving of entire s1 and s2\\n        return dp[-1][-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```Python\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s3) != len(s1)+len(s2):\\n            return False\\n        # state: dp[i][j] denote whether the first i+j letters in s3 is a \\n        # interleaving of the first i elements in s1 and the first j\\n        # elements in s2\\n        n, m = len(s1), len(s2)\\n        dp = [[False]*(m+1) for _ in range(n+1)]\\n        \\n        # initialization: fill in the first row and column\\n        dp[0][0] = True\\n        for i in range(1, n+1):\\n            dp[i][0] = dp[i-1][0] and s1[i-1] == s3[i-1]\\n        for i in range(1, m+1):\\n            dp[0][i] = dp[0][i-1] and s2[i-1] == s3[i-1]\\n        \\n        # state transition: matching last character in s1 and s2 with that\\n        # of s3\\n        for i in range(1, n+1):\\n            for j in range(1, m+1):\\n                if s1[i-1] == s3[i+j-1]:         # s3[:3] = \"abc\", s1[2] = \\'c\\'\\n                    dp[i][j] = dp[i-1][j]\\n                if s2[j-1] == s3[i+j-1]:         # s3[:3] = \"abc\", s2[2] = \\'c\\'\\n                    dp[i][j] = dp[i][j] or dp[i][j-1]\\n            \\n        # result: whether entire s3 is an interleaving of entire s1 and s2\\n        return dp[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1049250,
                "title": "recursive-to-recursion-memoization-optimised-in-c",
                "content": "Recursive Solution :-\\n```\\nclass Solution {\\npublic:\\n    bool answ(string s1,int i,string s2,int j,string ans,string s3)\\n    {\\n        if(ans==s3 and i==s1.length() and j==s2.length())\\n            return true;\\n        \\n        bool a=false;\\n        \\n        if(i<s1.length())\\n            a|=answ(s1,i+1,s2,j,ans+s1[i],s3);\\n        \\n        if(j<s2.length())\\n            a|=answ(s1,i,s2,j+1,ans+s2[j],s3);\\n        \\n        return a;\\n    }\\n    \\n    bool isInterleave(string s1, string s2, string s3)\\n    {\\n        return answ(s1,0,s2,0,\"\",s3);\\n    }\\n};\\n```\\n\\nRecursive+Memoization Optimised :-\\n```\\nclass Solution {\\npublic:\\n    bool answ(string s1,int i,string s2,int j,string s3,int k,vector<vector<int>> &dp)\\n    {\\n        if(i==s1.length())\\n        {\\n            string a=s2.substr(j);\\n            string b=s3.substr(k);\\n            \\n            return a==b;\\n        }\\n        \\n        if(j==s2.length())\\n        {\\n            string a=s1.substr(i);\\n            string b=s3.substr(k);\\n            \\n            return a==b;\\n        }\\n        \\n        if(dp[i][j]>=0)\\n        {\\n            if(dp[i][j]==1)\\n                return true;\\n            return false;\\n        }\\n        \\n        bool ans=false;\\n        \\n        if((s3[k]==s1[i] and answ(s1,i+1,s2,j,s3,k+1,dp)) or (s3[k]==s2[j] and answ(s1,i,s2,j+1,s3,k+1,dp)))\\n            ans=true;\\n        \\n        dp[i][j]=ans?1:0;\\n        \\n        return ans;\\n    }\\n    \\n    bool isInterleave(string s1, string s2, string s3)\\n    {\\n        int n=s1.length();\\n        int m=s2.length();\\n        vector<vector<int>> dp(n,vector<int>(m,-1));\\n        \\n        return answ(s1,0,s2,0,s3,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool answ(string s1,int i,string s2,int j,string ans,string s3)\\n    {\\n        if(ans==s3 and i==s1.length() and j==s2.length())\\n            return true;\\n        \\n        bool a=false;\\n        \\n        if(i<s1.length())\\n            a|=answ(s1,i+1,s2,j,ans+s1[i],s3);\\n        \\n        if(j<s2.length())\\n            a|=answ(s1,i,s2,j+1,ans+s2[j],s3);\\n        \\n        return a;\\n    }\\n    \\n    bool isInterleave(string s1, string s2, string s3)\\n    {\\n        return answ(s1,0,s2,0,\"\",s3);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool answ(string s1,int i,string s2,int j,string s3,int k,vector<vector<int>> &dp)\\n    {\\n        if(i==s1.length())\\n        {\\n            string a=s2.substr(j);\\n            string b=s3.substr(k);\\n            \\n            return a==b;\\n        }\\n        \\n        if(j==s2.length())\\n        {\\n            string a=s1.substr(i);\\n            string b=s3.substr(k);\\n            \\n            return a==b;\\n        }\\n        \\n        if(dp[i][j]>=0)\\n        {\\n            if(dp[i][j]==1)\\n                return true;\\n            return false;\\n        }\\n        \\n        bool ans=false;\\n        \\n        if((s3[k]==s1[i] and answ(s1,i+1,s2,j,s3,k+1,dp)) or (s3[k]==s2[j] and answ(s1,i,s2,j+1,s3,k+1,dp)))\\n            ans=true;\\n        \\n        dp[i][j]=ans?1:0;\\n        \\n        return ans;\\n    }\\n    \\n    bool isInterleave(string s1, string s2, string s3)\\n    {\\n        int n=s1.length();\\n        int m=s2.length();\\n        vector<vector<int>> dp(n,vector<int>(m,-1));\\n        \\n        return answ(s1,0,s2,0,s3,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 617188,
                "title": "python-dp-lru-cahce-beats-97",
                "content": "```\\nfrom functools import lru_cache\\nclass Solution:\\n    @lru_cache(maxsize=None)\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if s1 == s2 == s3 == \\'\\':\\n            return True\\n        elif s3 == \\'\\' and (s1 != \\'\\' or s2 != \\'\\'):\\n            return False\\n        \\n        if s1 == \\'\\':\\n            return s2 == s3\\n        elif s2 == \\'\\':\\n            return s1 == s3\\n       \\n        if s1[0] == s2[0] == s3[0]:\\n            return self.isInterleave(s1[1:] , s2, s3[1:]) or self.isInterleave(s1 , s2[1:], s3[1:])\\n        elif s1[0] == s3[0]:\\n            return self.isInterleave(s1[1:] , s2, s3[1:])\\n        elif s2[0] == s3[0]:\\n            return self.isInterleave(s1 , s2[1:], s3[1:])\\n        else:\\n            return False\\n```\\nNo extra function required.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nfrom functools import lru_cache\\nclass Solution:\\n    @lru_cache(maxsize=None)\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if s1 == s2 == s3 == \\'\\':\\n            return True\\n        elif s3 == \\'\\' and (s1 != \\'\\' or s2 != \\'\\'):\\n            return False\\n        \\n        if s1 == \\'\\':\\n            return s2 == s3\\n        elif s2 == \\'\\':\\n            return s1 == s3\\n       \\n        if s1[0] == s2[0] == s3[0]:\\n            return self.isInterleave(s1[1:] , s2, s3[1:]) or self.isInterleave(s1 , s2[1:], s3[1:])\\n        elif s1[0] == s3[0]:\\n            return self.isInterleave(s1[1:] , s2, s3[1:])\\n        elif s2[0] == s3[0]:\\n            return self.isInterleave(s1 , s2[1:], s3[1:])\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957679,
                "title": "ex-amazon-explains-a-solution-with-python-javascript-java-and-c",
                "content": "# Intuition\\nThe problem of determining whether one string is an interleaving of two others can be approached using dynamic programming. The core intuition lies in breaking down the problem into smaller subproblems. Essentially, we want to determine if the characters from both strings, s1 and s2, can be interwoven to create the target string s3. We aim to build a dynamic programming matrix that stores the state of the interleaving at different points, helping us track the possibilities.\\n\\n# Solution Video\\n\\n### Please subscribe to my channel from here. I have 247 videos as of August 25th.\\n\\n**\\u25A0 Subscribe URL**\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\n---\\n\\n# Approach\\nThis is based on Python. Other might be different a bit.\\n\\n1. Initialize `dp` array: Create an array `dp` of size `(len(s2) + 1)` to store whether substrings of `s1` and `s2` can interleave to form substrings of `s3`.\\n\\n2. Check total length: If the sum of the lengths of `s1` and `s2` is not equal to the length of `s3`, return `False` since it\\'s impossible for `s1` and `s2` to interleave to form `s3`.\\n\\n3. Initialization: Set `dp[0]` to `True` to indicate that an empty `s1` and empty `s2` can interleave to form an empty `s3`.\\n\\n4. Loop through `s1` and `s2`: Use nested loops to iterate through all possible combinations of substrings of `s1` and `s2` to check if they can interleave to form `s3`.\\n\\n5. Base cases handling:\\n   - If `i` is `0` and `j` is `0`, it means both `s1` and `s2` are empty. Set `dp[j]` to `True`.\\n   - If `i` is `0`, update `dp[j]` using the previous value of `dp[j - 1]` and check if the character in `s2` at index `j - 1` matches the character in `s3` at index `i + j - 1`.\\n   - If `j` is `0`, update `dp[j]` using the current value of `dp[j]` and check if the character in `s1` at index `i - 1` matches the character in `s3` at index `i + j - 1`.\\n\\n6. General case:\\n   - For all other cases (when both `i` and `j` are not `0`), update `dp[j]` using the following conditions:\\n     - `dp[j]` should be the result of `(dp[j] and s1[i - 1] == s3[i + j - 1])`, meaning that the current character in `s1` matches the current character in `s3`, and the previous substring also interleave to form the previous part of `s3`.\\n     - `dp[j - 1]` should be the result of `(dp[j - 1] and s2[j - 1] == s3[i + j - 1])`, meaning that the current character in `s2` matches the current character in `s3`, and the previous substring of `s2` can interleave to form the previous part of `s3`.\\n\\n7. Return result: The final result is stored in `dp[len(s2)]`, which indicates whether `s1` and `s2` can interleave to form `s3`.\\n\\n8. The function returns the value of `dp[len(s2)]` as the final result.\\n\\nIn summary, the algorithm uses dynamic programming to determine whether substrings of `s1` and `s2` can be interleaved to form substrings of `s3`. The `dp` array stores whether the substrings can interleave at each position.\\n\\n# Complexity\\n- Time complexity: O(m * n)\\nm is the length of string s1 and n is the length of string s2. This is because we iterate through each character of s1 and s2 once while constructing the dynamic programming matrix.\\n\\n- Space complexity: O(n),\\nn is the length of string s2. We only use a dynamic programming array of length n+1 to store the state transitions.\\n\\n```python []\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        # Check if the combined length of s1 and s2 matches the length of s3\\n        if len(s1) + len(s2) != len(s3):\\n            return False\\n        \\n        # Initialize a dynamic programming array dp\\n        # dp[j] will store whether s1[0:i] and s2[0:j] can form s3[0:i+j]\\n        dp = [False] * (len(s2) + 1)\\n        \\n        for i in range(len(s1) + 1):\\n            for j in range(len(s2) + 1):\\n                if i == 0 and j == 0:\\n                    # Base case: Both s1 and s2 are empty, so s3 is also empty.\\n                    # Set dp[j] to True.\\n                    dp[j] = True\\n                elif i == 0:\\n                    # Base case: s1 is empty, so check if the previous dp[j-1]\\n                    # is True and if s2[j-1] matches s3[i+j-1].\\n                    dp[j] = dp[j - 1] and s2[j - 1] == s3[i + j - 1]\\n                elif j == 0:\\n                    # Base case: s2 is empty, so check if the current dp[j]\\n                    # is True and if s1[i-1] matches s3[i+j-1].\\n                    dp[j] = dp[j] and s1[i - 1] == s3[i + j - 1]\\n                else:\\n                    # General case: Check if either the previous dp[j] or dp[j-1]\\n                    # is True and if the corresponding characters match s3[i+j-1].\\n                    dp[j] = (dp[j] and s1[i - 1] == s3[i + j - 1]) or (dp[j - 1] and s2[j - 1] == s3[i + j - 1])\\n\\n        # Return the result stored in dp[len(s2)], which indicates whether\\n        # s1 and s2 can form s3 by interleaving characters.\\n        return dp[len(s2)]\\n\\n```\\n```javascript []\\n/**\\n * @param {string} s1\\n * @param {string} s2\\n * @param {string} s3\\n * @return {boolean}\\n */\\nvar isInterleave = function(s1, s2, s3) {\\n    if (s1.length + s2.length !== s3.length) {\\n        return false;\\n    }\\n    \\n    const dp = new Array(s2.length + 1).fill(false);\\n    \\n    for (let i = 0; i <= s1.length; i++) {\\n        for (let j = 0; j <= s2.length; j++) {\\n            if (i === 0 && j === 0) {\\n                dp[j] = true;\\n            } else if (i === 0) {\\n                dp[j] = dp[j - 1] && s2[j - 1] === s3[i + j - 1];\\n            } else if (j === 0) {\\n                dp[j] = dp[j] && s1[i - 1] === s3[i + j - 1];\\n            } else {\\n                dp[j] = (dp[j] && s1[i - 1] === s3[i + j - 1]) || (dp[j - 1] && s2[j - 1] === s3[i + j - 1]);\\n            }\\n        }\\n    }\\n    \\n    return dp[s2.length];    \\n};\\n```\\n```java []\\nclass Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        if (s1.length() + s2.length() != s3.length()) {\\n            return false;\\n        }\\n        \\n        boolean[] dp = new boolean[s2.length() + 1];\\n        \\n        for (int i = 0; i <= s1.length(); i++) {\\n            for (int j = 0; j <= s2.length(); j++) {\\n                if (i == 0 && j == 0) {\\n                    dp[j] = true;\\n                } else if (i == 0) {\\n                    dp[j] = dp[j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1);\\n                } else if (j == 0) {\\n                    dp[j] = dp[j] && s1.charAt(i - 1) == s3.charAt(i + j - 1);\\n                } else {\\n                    dp[j] = (dp[j] && s1.charAt(i - 1) == s3.charAt(i + j - 1)) || (dp[j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1));\\n                }\\n            }\\n        }\\n        \\n        return dp[s2.length()];        \\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        if (s1.length() + s2.length() != s3.length()) {\\n            return false;\\n        }\\n        \\n        vector<bool> dp(s2.length() + 1, false);\\n        \\n        for (int i = 0; i <= s1.length(); i++) {\\n            for (int j = 0; j <= s2.length(); j++) {\\n                if (i == 0 && j == 0) {\\n                    dp[j] = true;\\n                } else if (i == 0) {\\n                    dp[j] = dp[j - 1] && s2[j - 1] == s3[i + j - 1];\\n                } else if (j == 0) {\\n                    dp[j] = dp[j] && s1[i - 1] == s3[i + j - 1];\\n                } else {\\n                    dp[j] = (dp[j] && s1[i - 1] == s3[i + j - 1]) || (dp[j - 1] && s2[j - 1] == s3[i + j - 1]);\\n                }\\n            }\\n        }\\n        \\n        return dp[s2.length()];        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```python []\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        # Check if the combined length of s1 and s2 matches the length of s3\\n        if len(s1) + len(s2) != len(s3):\\n            return False\\n        \\n        # Initialize a dynamic programming array dp\\n        # dp[j] will store whether s1[0:i] and s2[0:j] can form s3[0:i+j]\\n        dp = [False] * (len(s2) + 1)\\n        \\n        for i in range(len(s1) + 1):\\n            for j in range(len(s2) + 1):\\n                if i == 0 and j == 0:\\n                    # Base case: Both s1 and s2 are empty, so s3 is also empty.\\n                    # Set dp[j] to True.\\n                    dp[j] = True\\n                elif i == 0:\\n                    # Base case: s1 is empty, so check if the previous dp[j-1]\\n                    # is True and if s2[j-1] matches s3[i+j-1].\\n                    dp[j] = dp[j - 1] and s2[j - 1] == s3[i + j - 1]\\n                elif j == 0:\\n                    # Base case: s2 is empty, so check if the current dp[j]\\n                    # is True and if s1[i-1] matches s3[i+j-1].\\n                    dp[j] = dp[j] and s1[i - 1] == s3[i + j - 1]\\n                else:\\n                    # General case: Check if either the previous dp[j] or dp[j-1]\\n                    # is True and if the corresponding characters match s3[i+j-1].\\n                    dp[j] = (dp[j] and s1[i - 1] == s3[i + j - 1]) or (dp[j - 1] and s2[j - 1] == s3[i + j - 1])\\n\\n        # Return the result stored in dp[len(s2)], which indicates whether\\n        # s1 and s2 can form s3 by interleaving characters.\\n        return dp[len(s2)]\\n\\n```\n```javascript []\\n/**\\n * @param {string} s1\\n * @param {string} s2\\n * @param {string} s3\\n * @return {boolean}\\n */\\nvar isInterleave = function(s1, s2, s3) {\\n    if (s1.length + s2.length !== s3.length) {\\n        return false;\\n    }\\n    \\n    const dp = new Array(s2.length + 1).fill(false);\\n    \\n    for (let i = 0; i <= s1.length; i++) {\\n        for (let j = 0; j <= s2.length; j++) {\\n            if (i === 0 && j === 0) {\\n                dp[j] = true;\\n            } else if (i === 0) {\\n                dp[j] = dp[j - 1] && s2[j - 1] === s3[i + j - 1];\\n            } else if (j === 0) {\\n                dp[j] = dp[j] && s1[i - 1] === s3[i + j - 1];\\n            } else {\\n                dp[j] = (dp[j] && s1[i - 1] === s3[i + j - 1]) || (dp[j - 1] && s2[j - 1] === s3[i + j - 1]);\\n            }\\n        }\\n    }\\n    \\n    return dp[s2.length];    \\n};\\n```\n```java []\\nclass Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        if (s1.length() + s2.length() != s3.length()) {\\n            return false;\\n        }\\n        \\n        boolean[] dp = new boolean[s2.length() + 1];\\n        \\n        for (int i = 0; i <= s1.length(); i++) {\\n            for (int j = 0; j <= s2.length(); j++) {\\n                if (i == 0 && j == 0) {\\n                    dp[j] = true;\\n                } else if (i == 0) {\\n                    dp[j] = dp[j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1);\\n                } else if (j == 0) {\\n                    dp[j] = dp[j] && s1.charAt(i - 1) == s3.charAt(i + j - 1);\\n                } else {\\n                    dp[j] = (dp[j] && s1.charAt(i - 1) == s3.charAt(i + j - 1)) || (dp[j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1));\\n                }\\n            }\\n        }\\n        \\n        return dp[s2.length()];        \\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        if (s1.length() + s2.length() != s3.length()) {\\n            return false;\\n        }\\n        \\n        vector<bool> dp(s2.length() + 1, false);\\n        \\n        for (int i = 0; i <= s1.length(); i++) {\\n            for (int j = 0; j <= s2.length(); j++) {\\n                if (i == 0 && j == 0) {\\n                    dp[j] = true;\\n                } else if (i == 0) {\\n                    dp[j] = dp[j - 1] && s2[j - 1] == s3[i + j - 1];\\n                } else if (j == 0) {\\n                    dp[j] = dp[j] && s1[i - 1] == s3[i + j - 1];\\n                } else {\\n                    dp[j] = (dp[j] && s1[i - 1] == s3[i + j - 1]) || (dp[j - 1] && s2[j - 1] == s3[i + j - 1]);\\n                }\\n            }\\n        }\\n        \\n        return dp[s2.length()];        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957330,
                "title": "recursion-best-optimization-4-steps-of-optimization-c-dp",
                "content": "*Note:-* Refer the last stage of this solution for *best optimization code*, else move step by step optimization for better understanding.\\n\\n\\n# 1. Naive Recursive approach \\n- **Time complexity: O(2^o)**\\nThe function f is a recursive function that explores various possibilities of interleaving s1 and s2 to form s3. In the worst case, each recursive call results in two new recursive calls, as shown in the code. Therefore, the number of recursive calls grows exponentially with the length of the strings. The maximum depth of the recursion tree will be o, the length of string s3, since each recursive call reduces the length of s3 by 1. So, the time complexity of this algorithm can be approximated as O(2^o), where o is the length of the target string s3.\\n- **Space complexity: O(o)**\\nThe space complexity is determined by the maximum depth of the recursive call stack. At any point in time, the maximum number of active recursive calls corresponds to the depth of the recursion tree. Since each recursive call only involves a few additional variables and constant space complexity operations, the dominant factor here is the recursion stack space. Therefore, the space complexity is O(o), where o is the length of the target string s3.\\n```\\nclass Solution {\\npublic:\\n    bool f(int m, int n, int o, string &s1, string &s2, string &s3){\\n        if(o==0) return true;\\n        if(m==0 && n==0) return false;\\n        if(m>0 && n>0 && s1[m-1]==s3[o-1] && s2[n-1]==s3[o-1]){\\n            return f(m-1, n, o-1, s1, s2, s3) || f(m, n-1, o-1, s1, s2, s3);\\n        }\\n        else if(n>0 && s2[n-1]==s3[o-1]){\\n            return f(m, n-1, o-1, s1, s2, s3);\\n        }\\n        else if(m>0 && s1[m-1]==s3[o-1]){\\n            return f(m-1, n, o-1, s1, s2, s3);\\n        }\\n        else return false;\\n    }\\n    bool isInterleave(string s1, string s2, string s3) {\\n        string s;\\n        int m=s1.size();\\n        int n=s2.size();\\n        int o=s3.size();\\n        if(m+n!=o) return false;\\n        return f(m, n, o, s1, s2, s3);\\n    }\\n};\\n```\\n# 2. Memoization(DP)\\n- Time complexity: O(m*n)\\n- Space complexity: O(m*n)\\n\\n```\\nclass Solution {\\npublic:\\n    bool f(int m, int n, int o, string &s1, string &s2, string &s3, vector<vector<int>>&dp){\\n        if(o==0) return true;\\n        if(m==0 && n==0) return false;\\n        if(dp[m][n]!=-1) return dp[m][n];\\n        if(m>0 && n>0 && s1[m-1]==s3[o-1] && s2[n-1]==s3[o-1]){\\n            return dp[m][n] = f(m-1, n, o-1, s1, s2, s3, dp) || f(m, n-1, o-1, s1, s2, s3, dp);\\n        }\\n        else if(n>0 && s2[n-1]==s3[o-1]){\\n            return dp[m][n] = f(m, n-1, o-1, s1, s2, s3, dp);\\n        }\\n        else if(m>0 && s1[m-1]==s3[o-1]){\\n            return dp[m][n] = f(m-1, n, o-1, s1, s2, s3, dp);\\n        }\\n        else return false;\\n    }\\n    bool isInterleave(string s1, string s2, string s3) {\\n        string s;\\n        int m=s1.size();\\n        int n=s2.size();\\n        int o=s3.size();\\n        if(m+n!=o) return false;\\n        vector<vector<int>>dp(m+1, vector<int>(n+1, -1));\\n        return f(m, n, o, s1, s2, s3, dp);\\n    }\\n};\\n```\\n\\n# 3. Tabulation(DP)\\n- Time complexity: O(m*n)\\n- Space complexity: O(m*n)\\n\\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int m = s1.size();\\n        int n = s2.size();\\n        int o = s3.size();\\n        \\n        if (m + n != o) return false;\\n        \\n        vector<vector<bool>> dp(m + 1, vector<bool>(n + 1));\\n        dp[0][0] = true;  // Base case\\n        \\n        for (int i = 0; i <= m; i++) {\\n            for (int j = 0; j <= n; j++) {\\n                int k = i + j - 1;  // Adjusted index for s3\\n                \\n                if (i > 0 && s1[i - 1] == s3[k])\\n                    dp[i][j] = dp[i][j] || dp[i - 1][j];\\n                if (j > 0 && s2[j - 1] == s3[k])\\n                    dp[i][j] = dp[i][j] || dp[i][j - 1];\\n            }\\n        }\\n        \\n        return dp[m][n];\\n    }\\n};\\n```\\n\\n# 4. Optimized Space (BEST Approach)\\n- Time complexity: O(m*n)\\n- Space complexity: O(n)\\n\\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int m = s1.size();\\n        int n = s2.size();\\n        int o = s3.size();\\n        \\n        if (m+n!=o) return false;\\n        \\n        vector<bool> dp(n + 1);\\n        dp[0]=true;  // Base case\\n        \\n        for (int i=0;i<=m;i++) {\\n            for (int j=0;j<=n;j++) {\\n                int k=i+j-1;  // Adjusted index for s3\\n                \\n                if(i>0)\\n                    dp[j]=dp[j] && s1[i-1] == s3[k];\\n                if (j > 0)\\n                    dp[j]=dp[j] || (dp[j-1] && s2[j-1] == s3[k]);\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool f(int m, int n, int o, string &s1, string &s2, string &s3){\\n        if(o==0) return true;\\n        if(m==0 && n==0) return false;\\n        if(m>0 && n>0 && s1[m-1]==s3[o-1] && s2[n-1]==s3[o-1]){\\n            return f(m-1, n, o-1, s1, s2, s3) || f(m, n-1, o-1, s1, s2, s3);\\n        }\\n        else if(n>0 && s2[n-1]==s3[o-1]){\\n            return f(m, n-1, o-1, s1, s2, s3);\\n        }\\n        else if(m>0 && s1[m-1]==s3[o-1]){\\n            return f(m-1, n, o-1, s1, s2, s3);\\n        }\\n        else return false;\\n    }\\n    bool isInterleave(string s1, string s2, string s3) {\\n        string s;\\n        int m=s1.size();\\n        int n=s2.size();\\n        int o=s3.size();\\n        if(m+n!=o) return false;\\n        return f(m, n, o, s1, s2, s3);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool f(int m, int n, int o, string &s1, string &s2, string &s3, vector<vector<int>>&dp){\\n        if(o==0) return true;\\n        if(m==0 && n==0) return false;\\n        if(dp[m][n]!=-1) return dp[m][n];\\n        if(m>0 && n>0 && s1[m-1]==s3[o-1] && s2[n-1]==s3[o-1]){\\n            return dp[m][n] = f(m-1, n, o-1, s1, s2, s3, dp) || f(m, n-1, o-1, s1, s2, s3, dp);\\n        }\\n        else if(n>0 && s2[n-1]==s3[o-1]){\\n            return dp[m][n] = f(m, n-1, o-1, s1, s2, s3, dp);\\n        }\\n        else if(m>0 && s1[m-1]==s3[o-1]){\\n            return dp[m][n] = f(m-1, n, o-1, s1, s2, s3, dp);\\n        }\\n        else return false;\\n    }\\n    bool isInterleave(string s1, string s2, string s3) {\\n        string s;\\n        int m=s1.size();\\n        int n=s2.size();\\n        int o=s3.size();\\n        if(m+n!=o) return false;\\n        vector<vector<int>>dp(m+1, vector<int>(n+1, -1));\\n        return f(m, n, o, s1, s2, s3, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int m = s1.size();\\n        int n = s2.size();\\n        int o = s3.size();\\n        \\n        if (m + n != o) return false;\\n        \\n        vector<vector<bool>> dp(m + 1, vector<bool>(n + 1));\\n        dp[0][0] = true;  // Base case\\n        \\n        for (int i = 0; i <= m; i++) {\\n            for (int j = 0; j <= n; j++) {\\n                int k = i + j - 1;  // Adjusted index for s3\\n                \\n                if (i > 0 && s1[i - 1] == s3[k])\\n                    dp[i][j] = dp[i][j] || dp[i - 1][j];\\n                if (j > 0 && s2[j - 1] == s3[k])\\n                    dp[i][j] = dp[i][j] || dp[i][j - 1];\\n            }\\n        }\\n        \\n        return dp[m][n];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int m = s1.size();\\n        int n = s2.size();\\n        int o = s3.size();\\n        \\n        if (m+n!=o) return false;\\n        \\n        vector<bool> dp(n + 1);\\n        dp[0]=true;  // Base case\\n        \\n        for (int i=0;i<=m;i++) {\\n            for (int j=0;j<=n;j++) {\\n                int k=i+j-1;  // Adjusted index for s3\\n                \\n                if(i>0)\\n                    dp[j]=dp[j] && s1[i-1] == s3[k];\\n                if (j > 0)\\n                    dp[j]=dp[j] || (dp[j-1] && s2[j-1] == s3[k]);\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957222,
                "title": "dp-solution-explanation-by-comment",
                "content": "# Intuition\\nThis code uses a dynamic programming approach to fill in a 2D table dp, where **dp[i][j]** represents whether the first **i** characters from **s1** and the first **j** characters from **s2** can form the first **i+j** characters of **s3**. The recurrence relation used is based on the idea that for **dp[i][j]** to be true, either the character from s1 should match the current character of s3, and the previous state should also be true, or the character from **s2** should match the current character of **s3**, and the current state in the previous column should be true.\\n\\n# Complexity\\n- Time complexity:O(n * m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n * m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n = s1.size();\\n        int m = s2.size();\\n        \\n        if (n + m != s3.size()) {\\n            return false;\\n        }\\n        \\n        vector<vector<bool>> dp(n + 1, vector<bool>(m + 1, false));\\n        \\n        // Base case: Empty strings interleave to form an empty string\\n        dp[0][0] = true;\\n        \\n        // Initialize the first row (s1) and first column (s2)\\n        for (int i = 1; i <= n; ++i) {\\n            dp[i][0] = dp[i - 1][0] && s1[i - 1] == s3[i - 1];\\n        }\\n        \\n        for (int j = 1; j <= m; ++j) {\\n            dp[0][j] = dp[0][j - 1] && s2[j - 1] == s3[j - 1];\\n        }\\n        \\n        // Fill in the DP table\\n        for (int i = 1; i <= n; ++i) {\\n            for (int j = 1; j <= m; ++j) {\\n                dp[i][j] = (dp[i - 1][j] && s1[i - 1] == s3[i + j - 1]) ||\\n                           (dp[i][j - 1] && s2[j - 1] == s3[i + j - 1]);\\n            }\\n        }\\n        \\n        return dp[n][m];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n = s1.size();\\n        int m = s2.size();\\n        \\n        if (n + m != s3.size()) {\\n            return false;\\n        }\\n        \\n        vector<vector<bool>> dp(n + 1, vector<bool>(m + 1, false));\\n        \\n        // Base case: Empty strings interleave to form an empty string\\n        dp[0][0] = true;\\n        \\n        // Initialize the first row (s1) and first column (s2)\\n        for (int i = 1; i <= n; ++i) {\\n            dp[i][0] = dp[i - 1][0] && s1[i - 1] == s3[i - 1];\\n        }\\n        \\n        for (int j = 1; j <= m; ++j) {\\n            dp[0][j] = dp[0][j - 1] && s2[j - 1] == s3[j - 1];\\n        }\\n        \\n        // Fill in the DP table\\n        for (int i = 1; i <= n; ++i) {\\n            for (int j = 1; j <= m; ++j) {\\n                dp[i][j] = (dp[i - 1][j] && s1[i - 1] == s3[i + j - 1]) ||\\n                           (dp[i][j - 1] && s2[j - 1] == s3[i + j - 1]);\\n            }\\n        }\\n        \\n        return dp[n][m];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2250660,
                "title": "c-recursion-memoization-tabulation-space-optimization-o-n-space-with-intuition",
                "content": "I have renamed Input Strings in my code\\na=s1,b=s2 and ist i.e Interleaved STring =s3\\n\\nRecursion:\\nTime complexity :Exponential\\nSpace complexity: O(N+M) (Auxiliary Stack Space)\\nCode:\\n```\\nbool rec(string &a, string &b, string &ist, int i = 0, int j = 0, int k = 0)\\n{\\nint n = a.length(), m = b.length();\\nif (n + m != ist.length())\\nreturn false;\\nif (i == n && j == m)\\n    return true; // base case\\n\\nbool left, right;\\nleft = i < n ? a[i] == ist[k] : false;\\nright = j < m ? b[j] == ist[k] : false;\\n\\nif (left && right)\\n    return rec(a, b, ist, i + 1, j, k + 1) || rec(a, b, ist, i, j + 1, k + 1);\\n\\nelse if (left)\\n    return rec(a, b, ist, i + 1, j, k + 1);\\n\\nelse if (right)\\n    return rec(a, b, ist, i, j + 1, k + 1);\\n\\nelse\\n    return false;\\n}\\nbool isInterleave(string s1, string s2, string s3)\\n{\\nreturn rec(s1, s2, s3);\\n}\\n```\\n\\nMemoization:\\nTime Complexity:O(N^M)\\nSpace Complexity: O(N+M)(Auxiliary Space) +O(N^M) (2D DP Vector)\\nCode:\\n\\n```\\nbool mem(string &a, string &b, string &ist, vector<vector> &dp, int i = 0, int j = 0, int k = 0)\\n{\\nint n = a.length(), m = b.length();\\nif (n + m != ist.length())\\nreturn false;\\nif (i == n && j == m)\\n    return true; // base case\\n\\nif (dp[i][j] != -1)\\n    return dp[i][j];\\n\\nbool left, right;\\nleft = i < n ? a[i] == ist[k] : false;\\nright = j < m ? b[j] == ist[k] : false;\\n\\nif (left && right)\\n    return dp[i][j] = mem(a, b, ist, dp, i + 1, j, k + 1) || mem(a, b, ist, dp, i, j + 1, k + 1);\\n\\nelse if (left)\\n    return dp[i][j] = mem(a, b, ist, dp, i + 1, j, k + 1);\\n\\nelse if (right)\\n    return dp[i][j] = mem(a, b, ist, dp, i, j + 1, k + 1);\\n\\nelse\\n    return dp[i][j] = false;\\n}\\nbool isInterleave(string s1, string s2, string s3)\\n{\\nint n = s1.length(), m = s2.length();\\nvector<vector> dp(n + 1, vector(m + 1, -1));\\nreturn mem(s1, s2, s3, dp);\\n}\\n\\n```\\n\\nTabulation:\\nTime Complexity: O(N^M)\\nSpace Complexity: O(N^M) (2D DP Vector)\\nCode:\\n\\n```\\nbool tabulation(string& a,string& b,string& ist)\\n{\\nint m = b.length(), n = a.length();\\nif (m + n != ist.length())\\nreturn false;\\nvector<vector<bool>> dp(n+1,vector<bool>(m+1,true));\\n\\nfor (int j = m - 1; j >= 0; j--)\\n{\\n    if (b[j] == ist[n + j])\\n        dp[n][j] = dp[n][j+1];\\n    else\\n        dp[n][j] = false;\\n} // base case i==n\\n\\nfor (int i = n - 1; i >= 0; i--)\\n{\\n    dp[i][m] = a[i] == ist[m + i];\\n\\n    for (int j = m - 1; j >= 0; j--)\\n    {\\n        bool left, right;\\n        left = a[i] == ist[i + j];\\n        right = b[j] == ist[i + j];\\n\\n        if (left && right)\\n            dp[i][j] = dp[i+1][j] || dp[i][j+1];\\n\\n        else if (right)\\n            dp[i][j] = dp[i][j+1];\\n\\n        else if(left)\\n            dp[i][j]=dp[i+1][j];\\n\\n        else\\n            dp[i][j] = false;\\n    }\\n}\\n\\nreturn dp[0][0];\\n}\\nbool isInterleave(string s1, string s2, string s3)\\n{\\nreturn tabulation(s1, s2, s3);\\n}\\n\\n```\\n\\nSpace-optimization:\\nTime Complexity:O(N^M)\\nSpace Complexity:O(M) (Only a prev 1D vector used of size M i.e s2.length())\\nFollow Up Question Solved\\nCode:\\n\\n```\\nbool sop(string &a, string &b, string &ist)\\n{\\nint m = b.length(), n = a.length();\\nif (m + n != ist.length())\\nreturn false;\\nvector<bool> prev(m + 1, true);\\n\\nfor (int j = m - 1; j >= 0; j--)\\n{\\n    if (b[j] == ist[n + j])\\n        prev[j] = prev[j + 1];\\n    else\\n        prev[j] = false;\\n} // base case i==n\\n\\nfor (int i = n - 1; i >= 0; i--)\\n{\\n    prev[m] = a[i] == ist[m + i];\\n\\n    for (int j = m - 1; j >= 0; j--)\\n    {\\n        bool left, right;\\n        left = a[i] == ist[i + j];\\n        right = b[j] == ist[i + j];\\n\\n        if (left && right)\\n            prev[j] = prev[j] || prev[j + 1];\\n\\n        else if (right)\\n            prev[j] = prev[j + 1];\\n\\n        else if (!left)\\n            prev[j] = false;\\n    }\\n}\\n\\nreturn prev[0];\\n}\\nbool isInterleave(string s1, string s2, string s3)\\n{\\nreturn sop(s1, s2, s3);\\n}\\n\\n```\\n\\nComplete Intuition for space optimization:-\\nThis prev array is a dp array only, but if we observer in tabulation that for filling dp[i] we are only requiring dp[i+1] and not any further. So, I thought why not only store only dp[i+1] and keep updating it for every i.\\nNow we could keep current i.e dp[i] and previous i.e dp[i+1]  but here also i tried to optimize and keeping only one i.e previous.\\nwe see that while filling dp[i][j] we are needing either dp[i][j+1](will come from current hence needs to be computed before,hence we go from j=m ->j=0) or dp[i+1][j](will come from previous). Now compare it to filling for each ith row prev[j] , we know prev[j+1] is already computed,and just before filling prev[j] value in it is prev[j],but for i+1 th row (dp[i+1][j]), and these were the two needed for prev[j].\\nThis was all intuition.\\n\\nIf you find this solution helpful , plz upvote.\\nAnd would love to hear about flaws in code in comment section.\\nThanks for reading.\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nbool rec(string &a, string &b, string &ist, int i = 0, int j = 0, int k = 0)\\n{\\nint n = a.length(), m = b.length();\\nif (n + m != ist.length())\\nreturn false;\\nif (i == n && j == m)\\n    return true; // base case\\n\\nbool left, right;\\nleft = i < n ? a[i] == ist[k] : false;\\nright = j < m ? b[j] == ist[k] : false;\\n\\nif (left && right)\\n    return rec(a, b, ist, i + 1, j, k + 1) || rec(a, b, ist, i, j + 1, k + 1);\\n\\nelse if (left)\\n    return rec(a, b, ist, i + 1, j, k + 1);\\n\\nelse if (right)\\n    return rec(a, b, ist, i, j + 1, k + 1);\\n\\nelse\\n    return false;\\n}\\nbool isInterleave(string s1, string s2, string s3)\\n{\\nreturn rec(s1, s2, s3);\\n}\\n```\n```\\nbool mem(string &a, string &b, string &ist, vector<vector> &dp, int i = 0, int j = 0, int k = 0)\\n{\\nint n = a.length(), m = b.length();\\nif (n + m != ist.length())\\nreturn false;\\nif (i == n && j == m)\\n    return true; // base case\\n\\nif (dp[i][j] != -1)\\n    return dp[i][j];\\n\\nbool left, right;\\nleft = i < n ? a[i] == ist[k] : false;\\nright = j < m ? b[j] == ist[k] : false;\\n\\nif (left && right)\\n    return dp[i][j] = mem(a, b, ist, dp, i + 1, j, k + 1) || mem(a, b, ist, dp, i, j + 1, k + 1);\\n\\nelse if (left)\\n    return dp[i][j] = mem(a, b, ist, dp, i + 1, j, k + 1);\\n\\nelse if (right)\\n    return dp[i][j] = mem(a, b, ist, dp, i, j + 1, k + 1);\\n\\nelse\\n    return dp[i][j] = false;\\n}\\nbool isInterleave(string s1, string s2, string s3)\\n{\\nint n = s1.length(), m = s2.length();\\nvector<vector> dp(n + 1, vector(m + 1, -1));\\nreturn mem(s1, s2, s3, dp);\\n}\\n\\n```\n```\\nbool tabulation(string& a,string& b,string& ist)\\n{\\nint m = b.length(), n = a.length();\\nif (m + n != ist.length())\\nreturn false;\\nvector<vector<bool>> dp(n+1,vector<bool>(m+1,true));\\n\\nfor (int j = m - 1; j >= 0; j--)\\n{\\n    if (b[j] == ist[n + j])\\n        dp[n][j] = dp[n][j+1];\\n    else\\n        dp[n][j] = false;\\n} // base case i==n\\n\\nfor (int i = n - 1; i >= 0; i--)\\n{\\n    dp[i][m] = a[i] == ist[m + i];\\n\\n    for (int j = m - 1; j >= 0; j--)\\n    {\\n        bool left, right;\\n        left = a[i] == ist[i + j];\\n        right = b[j] == ist[i + j];\\n\\n        if (left && right)\\n            dp[i][j] = dp[i+1][j] || dp[i][j+1];\\n\\n        else if (right)\\n            dp[i][j] = dp[i][j+1];\\n\\n        else if(left)\\n            dp[i][j]=dp[i+1][j];\\n\\n        else\\n            dp[i][j] = false;\\n    }\\n}\\n\\nreturn dp[0][0];\\n}\\nbool isInterleave(string s1, string s2, string s3)\\n{\\nreturn tabulation(s1, s2, s3);\\n}\\n\\n```\n```\\nbool sop(string &a, string &b, string &ist)\\n{\\nint m = b.length(), n = a.length();\\nif (m + n != ist.length())\\nreturn false;\\nvector<bool> prev(m + 1, true);\\n\\nfor (int j = m - 1; j >= 0; j--)\\n{\\n    if (b[j] == ist[n + j])\\n        prev[j] = prev[j + 1];\\n    else\\n        prev[j] = false;\\n} // base case i==n\\n\\nfor (int i = n - 1; i >= 0; i--)\\n{\\n    prev[m] = a[i] == ist[m + i];\\n\\n    for (int j = m - 1; j >= 0; j--)\\n    {\\n        bool left, right;\\n        left = a[i] == ist[i + j];\\n        right = b[j] == ist[i + j];\\n\\n        if (left && right)\\n            prev[j] = prev[j] || prev[j + 1];\\n\\n        else if (right)\\n            prev[j] = prev[j + 1];\\n\\n        else if (!left)\\n            prev[j] = false;\\n    }\\n}\\n\\nreturn prev[0];\\n}\\nbool isInterleave(string s1, string s2, string s3)\\n{\\nreturn sop(s1, s2, s3);\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2248790,
                "title": "easy-memoization-c-code",
                "content": "intuition:- we compair first element of both of s1 and s2 with s3 if match ind1 of s1 with current  index of then we go forword with ind1+1 and next index of s3 and same for s2.\\n \\n    bool isInterleave(string s1, string s2, string s3) {\\n       if(s1.size()+s2.size()!=s3.size()) return false;\\n        vector<vector<int>>dp(s1.size()+1,vector<int>(s2.size()+1,-1));\\n        \\n        return fun(s1,s2,s3,0,0,dp);\\n    }\\n\\tbool fun(string &s1, string &s2, string &s3,int ind1,int ind2,vector<vector<int>>&dp)\\n    {\\n        if(ind1+ind2==s3.size()) return 1;\\n        if(dp[ind1][ind2]!=-1) return dp[ind1][ind2];\\n        bool ans=0;        \\n        if(ind1<s1.size() and s1[ind1]==s3[ind1+ind2] and fun(s1,s2,s3,ind1+1,ind2,dp)) ans=1;\\n        if(ind2<s2.size() and s2[ind2]==s3[ind1+ind2] and fun(s1,s2,s3,ind1,ind2+1,dp)) ans=1;\\n        \\n        return dp[ind1][ind2]=ans;\\n    }\\n",
                "solutionTags": [
                    "String",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "intuition:- we compair first element of both of s1 and s2 with s3 if match ind1 of s1 with current  index of then we go forword with ind1+1 and next index of s3 and same for s2.\\n \\n    bool isInterleave(string s1, string s2, string s3) {\\n       if(s1.size()+s2.size()!=s3.size()) return false;\\n        vector<vector<int>>dp(s1.size()+1,vector<int>(s2.size()+1,-1));\\n        \\n        return fun(s1,s2,s3,0,0,dp);\\n    }\\n\\tbool fun(string &s1, string &s2, string &s3,int ind1,int ind2,vector<vector<int>>&dp)\\n    {\\n        if(ind1+ind2==s3.size()) return 1;\\n        if(dp[ind1][ind2]!=-1) return dp[ind1][ind2];\\n        bool ans=0;        \\n        if(ind1<s1.size() and s1[ind1]==s3[ind1+ind2] and fun(s1,s2,s3,ind1+1,ind2,dp)) ans=1;\\n        if(ind2<s2.size() and s2[ind2]==s3[ind1+ind2] and fun(s1,s2,s3,ind1,ind2+1,dp)) ans=1;\\n        \\n        return dp[ind1][ind2]=ans;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2248668,
                "title": "easy-js-solution",
                "content": "At first I tried to solved it linearly in which i kept three variables a, b, c all pointing to each string starting. I then kept on increasing them till i reach end of all string but this approach fails if there are two choices ( same character is availabe on both string s1, s2 ) then a wrong decision will give you wrong result. \\nSince constraints are small I tried taking all decisions using recursion where i take two decisions either from s1 or s2 and see which gives a positive result.\\n```\\nvar isInterleave = function(s1, s2, s3) {\\n    const dp = new Map();\\n    const solve = (a = 0, b = 0, c = 0) => {\\n        if(c == s3.length) return a == s1.length && b == s2.length;\\n        const key = [a, b, c].join(\\':\\');\\n        \\n        if(dp.has(key)) {\\n            // console.log(\\'hit\\');\\n            return dp.get(key);\\n        }\\n        \\n        let takeS1 = false, takeS2 = false;\\n        if(s1[a] == s3[c]) takeS1 = solve(a + 1, b, c + 1);\\n        if(s2[b] == s3[c]) takeS2 = solve(a, b + 1, c + 1);\\n\\n        dp.set(key, takeS1 || takeS2);\\n        return takeS1 || takeS2;\\n    }\\n    return solve();\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isInterleave = function(s1, s2, s3) {\\n    const dp = new Map();\\n    const solve = (a = 0, b = 0, c = 0) => {\\n        if(c == s3.length) return a == s1.length && b == s2.length;\\n        const key = [a, b, c].join(\\':\\');\\n        \\n        if(dp.has(key)) {\\n            // console.log(\\'hit\\');\\n            return dp.get(key);\\n        }\\n        \\n        let takeS1 = false, takeS2 = false;\\n        if(s1[a] == s3[c]) takeS1 = solve(a + 1, b, c + 1);\\n        if(s2[b] == s3[c]) takeS2 = solve(a, b + 1, c + 1);\\n\\n        dp.set(key, takeS1 || takeS2);\\n        return takeS1 || takeS2;\\n    }\\n    return solve();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1906440,
                "title": "c-100-fast-recursion-memoization-clean-code-t-c-s-c-o-n-2",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[102][102];\\n    bool solve(string &s1, string &s2, string &s3, int i, int j, int k){\\n        \\n        if(k >= s3.size()) \\n            return true;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        bool flag1 = false, flag2 = false;\\n        if(s1[i] == s3[k]){\\n            flag1 =  solve(s1, s2, s3, i + 1, j, k + 1);\\n        }\\n        \\n        if(s2[j] == s3[k]){\\n            flag2 =  solve(s1, s2, s3, i, j + 1, k + 1);\\n        }\\n    \\n        return dp[i][j] = (flag1 || flag2);\\n        \\n    }\\n    bool isInterleave(string s1, string s2, string s3) {\\n         if((s1.size() + s2.size()) != s3.size()) return false;\\n         memset(dp, -1,sizeof(dp));         \\n         return solve(s1, s2, s3, 0 , 0 , 0);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    int dp[102][102];\\n    bool solve(string &s1, string &s2, string &s3, int i, int j, int k){\\n        \\n        if(k >= s3.size()) \\n            return true;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        bool flag1 = false, flag2 = false;\\n        if(s1[i] == s3[k]){\\n            flag1 =  solve(s1, s2, s3, i + 1, j, k + 1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1506121,
                "title": "c-beats-100-9-lines-simple-recursion-memo",
                "content": "```\\nclass Solution {\\npublic:\\n    bool interleave(string &s1, string &s2, string &s3,int i,int j,int k,vector<vector<int>> &dp)\\n    {\\n        if(k==s3.size()) return true;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        bool ans=false;\\n        if(i<s1.size() && s3[k]==s1[i]) ans=ans || interleave(s1,s2,s3,i+1,j,k+1,dp);\\n        if(j<s2.size() && s3[k]==s2[j]) ans = ans || interleave(s1,s2,s3,i,j+1,k+1,dp);\\n        return dp[i][j]=ans;\\n    }\\n    \\n    bool isInterleave(string &s1, string &s2, string &s3) {\\n    if(s1.size()+s2.size()!=s3.size()) return false;\\n    vector<vector<int>> dp(s1.size()+1,vector<int>(s2.size()+1,-1));    \\n    return interleave(s1,s2,s3,0,0,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool interleave(string &s1, string &s2, string &s3,int i,int j,int k,vector<vector<int>> &dp)\\n    {\\n        if(k==s3.size()) return true;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        bool ans=false;\\n        if(i<s1.size() && s3[k]==s1[i]) ans=ans || interleave(s1,s2,s3,i+1,j,k+1,dp);\\n        if(j<s2.size() && s3[k]==s2[j]) ans = ans || interleave(s1,s2,s3,i,j+1,k+1,dp);\\n        return dp[i][j]=ans;\\n    }\\n    \\n    bool isInterleave(string &s1, string &s2, string &s3) {\\n    if(s1.size()+s2.size()!=s3.size()) return false;\\n    vector<vector<int>> dp(s1.size()+1,vector<int>(s2.size()+1,-1));    \\n    return interleave(s1,s2,s3,0,0,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956644,
                "title": "it-just-works-in-java",
                "content": "# Intuition\\nTry all the possibilities using recursion, now include memory to reduce time complexity.\\n\\n# Approach\\n1. Use recursion to find all the possibilites to combine 2 strings to form final string str3.\\n2. Whenever the indx3 reaches the end we can return true, but only when indx1 and indx2 also reaches their end simultaneously because it is mentioned both the strings have to be used completely.\\n3. So if there haven\\'t reached their end at the same time when indx3 had reached end we can return false.\\n4. The rest of the code is just checking all the possibilities.\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean recursion(int indx1,int indx2,int indx3,String s1,String s2,String s3,int[][][] dp){\\n        if(indx3==s3.length()) \\n        {\\n            if(indx1==s1.length() && indx2==s2.length())\\n                return true;\\n            else\\n                return false;\\n        }\\n\\n        if(dp[indx1][indx2][indx3]!=-1) return dp[indx1][indx2][indx3]==1?true:false;\\n        boolean first=false,second=false;\\n        if(indx1<s1.length() && s1.charAt(indx1)==s3.charAt(indx3))\\n            first = recursion(indx1+1,indx2,indx3+1,s1,s2,s3,dp);\\n        if(indx2<s2.length() && s2.charAt(indx2)==s3.charAt(indx3))\\n            second = recursion(indx1,indx2+1,indx3+1,s1,s2,s3,dp);\\n        \\n        dp[indx1][indx2][indx3] = (first||second)?1:0;\\n        return first || second;\\n    }\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        int[][][]dp =new int[s1.length()+1][s2.length()+1][s3.length()+1];\\n        for(int i=0;i<=s1.length();i++){\\n            for(int j=0;j<=s2.length();j++){\\n                Arrays.fill(dp[i][j],-1);\\n            }\\n        }\\n        return recursion(0,0,0,s1,s2,s3,dp);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public boolean recursion(int indx1,int indx2,int indx3,String s1,String s2,String s3,int[][][] dp){\\n        if(indx3==s3.length()) \\n        {\\n            if(indx1==s1.length() && indx2==s2.length())\\n                return true;\\n            else\\n                return false;\\n        }\\n\\n        if(dp[indx1][indx2][indx3]!=-1) return dp[indx1][indx2][indx3]==1?true:false;\\n        boolean first=false,second=false;\\n        if(indx1<s1.length() && s1.charAt(indx1)==s3.charAt(indx3))\\n            first = recursion(indx1+1,indx2,indx3+1,s1,s2,s3,dp);\\n        if(indx2<s2.length() && s2.charAt(indx2)==s3.charAt(indx3))\\n            second = recursion(indx1,indx2+1,indx3+1,s1,s2,s3,dp);\\n        \\n        dp[indx1][indx2][indx3] = (first||second)?1:0;\\n        return first || second;\\n    }\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        int[][][]dp =new int[s1.length()+1][s2.length()+1][s3.length()+1];\\n        for(int i=0;i<=s1.length();i++){\\n            for(int j=0;j<=s2.length();j++){\\n                Arrays.fill(dp[i][j],-1);\\n            }\\n        }\\n        return recursion(0,0,0,s1,s2,s3,dp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956593,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        n1=len(s1)\\n        n2=len(s2)\\n        n3=len(s3)\\n        @cache\\n        def isInter(i1,i2,i3):\\n            if i1==n1 and i2==n2 and i3==n3:\\n                return True\\n\\n            return i3<n3 and (i1<n1 and s1[i1]==s3[i3] and isInter(i1+1,i2,i3+1) or i2<n2 and s2[i2]==s3[i3] and isInter(i1,i2+1,i3+1))\\n\\n        return isInter(0,0,0)        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        n1=len(s1)\\n        n2=len(s2)\\n        n3=len(s3)\\n        @cache\\n        def isInter(i1,i2,i3):\\n            if i1==n1 and i2==n2 and i3==n3:\\n                return True\\n\\n            return i3<n3 and (i1<n1 and s1[i1]==s3[i3] and isInter(i1+1,i2,i3+1) or i2<n2 and s2[i2]==s3[i3] and isInter(i1,i2+1,i3+1))\\n\\n        return isInter(0,0,0)        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679676,
                "title": "c-easy-tabular-dp-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- At each step, we have two options: **either take a character from s1 or take a character from s2** to contribute to the interleaved string.\\n- The solution for the current step depends on the solutions for the previous steps, which leads to **overlapping subproblems**.\\n- By using a **dynamic programming table** (such as the interleaved table in the code), we can store and reuse the solutions to these smaller subproblems.\\n---\\n\\n\\n# Approach\\n- **Initialize** the **interleaved** table of size (m+1) x (n+1).\\n- Iterate through each cell of the interleaved table using two nested loops.\\n- For each cell (i, j), there are following cases:\\n    1) If both **s1 and s2 are empty strings** (i.e., i == 0 and j == 0), then **interleaved[i][j] is set to true** since there are no characters to interleave.\\n    2) If **s1 is empty** (i.e., i == 0), then **interleaved[i][j]** is determined by **comparing s2[j-1] with s3[i+j-1]** and the **previous cell interleaved[i][j-1]**.\\n    3) If **s2 is empty** (i.e., j == 0), then **interleaved[i][j]** is determined by comparing **s1[i-1] with s3[i+j-1]** and the **previous cell interleaved[i-1][j]**.\\n    4) If both **s1 and s2 are non-empty**, **interleaved[i][j]** is determined by **comparing s1[i-1] with s3[i+j-1]** and the **previous cell interleaved[i-1][j]**, as well as **comparing s2[j-1] with s3[i+j-1]** and the **previous cell interleaved[i][j-1]**.\\n- Finally, **return interleaved[m][n]**, which represents whether s1 and s2 can interleave to form s3, where m and n are the lengths of s1 and s2 respectively.\\n<!-- Describe your approach to solving the problem. -->\\n\\n---\\n\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the code is **O(m * n)**, where m and n are the lengths of **s1** and **s2** respectively. The nested loops iterate through each cell of the **interleaved** table, which has dimensions (m+1) x (n+1).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nThe space complexity of the code is **O(m * n)**, where m and n are the lengths of **s1** and **s2** respectively. The interleaved table is of size (m+1) x (n+1), which\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n    if (s1.size() + s2.size() != s3.size()) {\\n        return false;\\n    }\\n    \\n    int m = s1.size();\\n    int n = s2.size();\\n    bool interleaved[m + 1][n + 1];\\n\\n    for (int i = 0; i <= m; i++) {\\n        for (int j = 0; j <= n; j++) {\\n            if (i == 0 && j == 0) {\\n                interleaved[i][j] = true;\\n            } else if (i == 0) {\\n                interleaved[i][j] = interleaved[i][j - 1] && s2[j - 1] == s3[i + j - 1];\\n            } else if (j == 0) {\\n                interleaved[i][j] = interleaved[i - 1][j] && s1[i - 1] == s3[i + j - 1];\\n            } else {\\n                interleaved[i][j] = (interleaved[i - 1][j] && s1[i - 1] == s3[i + j - 1]) ||\\n                                    (interleaved[i][j - 1] && s2[j - 1] == s3[i + j - 1]);\\n            }\\n        }\\n    }\\n    \\n    return interleaved[m][n];\\n    }\\n};\\n```\\n**Please upvote if it helped. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n    if (s1.size() + s2.size() != s3.size()) {\\n        return false;\\n    }\\n    \\n    int m = s1.size();\\n    int n = s2.size();\\n    bool interleaved[m + 1][n + 1];\\n\\n    for (int i = 0; i <= m; i++) {\\n        for (int j = 0; j <= n; j++) {\\n            if (i == 0 && j == 0) {\\n                interleaved[i][j] = true;\\n            } else if (i == 0) {\\n                interleaved[i][j] = interleaved[i][j - 1] && s2[j - 1] == s3[i + j - 1];\\n            } else if (j == 0) {\\n                interleaved[i][j] = interleaved[i - 1][j] && s1[i - 1] == s3[i + j - 1];\\n            } else {\\n                interleaved[i][j] = (interleaved[i - 1][j] && s1[i - 1] == s3[i + j - 1]) ||\\n                                    (interleaved[i][j - 1] && s2[j - 1] == s3[i + j - 1]);\\n            }\\n        }\\n    }\\n    \\n    return interleaved[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2249605,
                "title": "python-elegant-short-top-down-dp-lru-cache",
                "content": "# Complexity\\n- Time complexity: $$O(n*m)$$\\n- Space complexity: $$O(n*m)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def isInterleave(self, a: str, b: str, target: str) -> bool:\\n        @cache\\n        def dp(i: int, j: int) -> bool:\\n            if i == n and j == m:\\n                return True\\n            return any([\\n                i < n and a[i] == target[i + j] and dp(i + 1, j),\\n                j < m and b[j] == target[i + j] and dp(i, j + 1),\\n            ])\\n\\n        n, m = len(a), len(b)\\n        return n + m == len(target) and dp(0, 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def isInterleave(self, a: str, b: str, target: str) -> bool:\\n        @cache\\n        def dp(i: int, j: int) -> bool:\\n            if i == n and j == m:\\n                return True\\n            return any([\\n                i < n and a[i] == target[i + j] and dp(i + 1, j),\\n                j < m and b[j] == target[i + j] and dp(i, j + 1),\\n            ])\\n\\n        n, m = len(a), len(b)\\n        return n + m == len(target) and dp(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783687,
                "title": "can-lcs-be-applied-to-this-problem-in-any-way",
                "content": "Can the longest common subsequence approach be applied to this problem in any way?\\n\\nMy initial intuition was we can return `true`,\\nif:\\n\\t\\ti) Length of String one + Length of String two == length of String three &&\\n\\t\\tii) Length of String one == LCS(String one, String three) &&\\n\\t\\tiii) Length of String two == LCS(String two, String three)\\n\\t\\t\\n`false` otherwise;\\n\\nBut this approach is failing some of the test cases. Please let me know if LCS can be applied to this problem in any way.",
                "solutionTags": [],
                "code": "Can the longest common subsequence approach be applied to this problem in any way?\\n\\nMy initial intuition was we can return `true`,\\nif:\\n\\t\\ti) Length of String one + Length of String two == length of String three &&\\n\\t\\tii) Length of String one == LCS(String one, String three) &&\\n\\t\\tiii) Length of String two == LCS(String two, String three)\\n\\t\\t\\n`false` otherwise;\\n\\nBut this approach is failing some of the test cases. Please let me know if LCS can be applied to this problem in any way.",
                "codeTag": "Unknown"
            },
            {
                "id": 1468511,
                "title": "simple-explanation-for-bottom-up-approach-with-diagrams",
                "content": "> First we create a dp table with s1 and s2( s1 -> Y-axis , s2-> X-axis) where **dp[i][j]** represents if first i characters of s1 and first j characters of s2 interleave to form ( i + j ) characters of s3.\\n![image](https://assets.leetcode.com/users/images/d761ab3b-78c4-426a-aee3-3f6a122fbc99_1631866519.9569435.png)\\n\\n\\n`How to fill dp table ?`\\nWe divide this into three parts \\n1. First Cell\\n2. First Row and First Column\\n3. Rest of the Cells\\n\\n* **First Cell** -> meaning  0 characters of s1 and 0 characters of s2 interleave to form 0 characters of s3 \\n\\t\\t![image](https://assets.leetcode.com/users/images/2e489f60-ac5d-46a6-b3b4-4812f788e547_1631866807.4218714.png)\\n\\t\\t\\n* **First Row** -> When  s1 is empty and s2 is not empty , then we have to check if substring of s2 = substring of s3\\n   ```\\n    if (s2[i-1] != s3[i-1])\\n\\t\\tdp[0][i] = false;\\n\\telse \\n\\t\\tdp[0][i] = dp[0][i-1];\\n   ```\\n  **Remember** : If we are at cell(i,j), then current characters of s1, s2 and s3 are (i-1)th, (j-1)th and (i+j-1)th characters of s1 , s2 and s3 respectively.\\n  \\n  Similarly ,\\n  **First Column** -> When s2 is empty and s1 is not empty, then we have to check if substring of s1 = substring of s3\\n  ```\\n\\t  if(s1[i-1] != s3[i-1])\\n\\t     dp[i][0] = false;\\n\\t  else \\n\\t\\t  dp[i][0] = dp[i-1][0];\\n  ```\\n  ![image](https://assets.leetcode.com/users/images/1c91c32c-c60f-4dfb-9e19-d785058dc61c_1631868477.9101102.png)\\n\\n  \\n*   **Rest of the cells**\\n  We have 4 possiblities for the rest of the cells, If\\n\\t  1. Current character of s3 is neither equals to current character of s1 nor current character of s2, then value of the cell is false\\n\\t  2. Current character of s3 is equal  current character of s1 but not current character of s2, then value of cell is the same cell above it.\\n\\t3. Current character of s3 is equal to current character of s2 but not current character of s1 , then value of cell is the cell left to it.\\n\\t4. Current character of s3 is equal to current character of s2 and current character of s1 , then value of cell is either from cell above it or cell left to it if they are true, otherwise false\\n\\n\\t\\t![image](https://assets.leetcode.com/users/images/fe18ed45-fe8c-4f54-bbda-8c4b74b277da_1631869257.556291.png)\\n\\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n = s1.size();\\n        int m = s2.size();\\n        int l = s3.size();\\n        \\n        if(l != n + m)return false;\\n        \\n        vector<vector<bool>> dp(n+1 , vector<bool>(m+1, false));\\n        \\n        dp[0][0] = true;\\n        \\n        //populating first row\\n        for(int i=1 ;i<=m ;i++){\\n            if(s2[i-1] != s3[i-1])dp[0][i] = false;\\n            else dp[0][i] = dp[0][i-1];\\n        }\\n        \\n        //populating first col\\n        for(int i=1 ;i<=n ;i++){\\n            if(s1[i-1] != s3[i-1])dp[i][0] = false;\\n            else dp[i][0] = dp[i-1][0];\\n        }\\n        \\n        // rest\\n        for(int i=1;i<=n ;i++){\\n            for(int j=1;j<=m ;j++){\\n                if(s1[i-1] == s3[i+j-1] and s2[j-1] == s3[i+j-1]){\\n                    dp[i][j] = (dp[i-1][j] || dp[i][j-1]);\\n                }\\n                else if(s1[i-1] == s3[i+j-1] and s2[j-1] != s3[i+j-1]){\\n                    dp[i][j] = dp[i-1][j];\\n                } \\n                else if(s1[i-1] != s3[i+j-1] and s2[j-1] == s3[i+j-1]){\\n                    dp[i][j] = dp[i][j-1];\\n                }else{\\n                    dp[i][j] = false;\\n                }\\n            }\\n        }\\n        \\n        return dp[n][m];\\n        \\n        \\n        \\n    }\\n};\\n\\n```\\n\\nTime : O(M*N)\\n\\nSpace : O(M*N)\\n\\n**Space Opitmization**\\n**Idea** : To fill the each row , we just need one row above it ( 2 rows at a time ) \\n\\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n = s1.size();\\n        int m = s2.size();\\n        int l = s3.size();\\n        \\n        if(l != n + m)return false;\\n        \\n\\t\\t// considering two rows at a time\\n        vector<vector<bool>> dp(2 , vector<bool>(m+1, false));\\n        \\n        dp[0][0] = true;\\n        \\n        //populating first row\\n        for(int i=1 ;i<=m ;i++){\\n            if(s2[i-1] != s3[i-1])dp[0][i] = false;\\n            else dp[0][i] = dp[0][i-1];\\n        }\\n        \\n     \\n        // rest\\n        for(int i=1;i<=n ;i++){\\n            for(int j=0;j<=m ;j++){\\n                if(j == 0){\\n                    // first col\\n                    if(s1[i-1] != s3[i+j-1])dp[i%2][j] = false;\\n                    else dp[i%2][j] = dp[(i-1)%2][j];\\n                }\\n                else if(s1[i-1] == s3[i+j-1] and s2[j-1] == s3[i+j-1]){\\n                    dp[i%2][j] = (dp[(i-1)%2][j] || dp[i%2][j-1]);\\n                }\\n                else if(s1[i-1] == s3[i+j-1] and s2[j-1] != s3[i+j-1]){\\n                    dp[i%2][j] = dp[(i-1)%2][j];\\n                } \\n                else if(s1[i-1] != s3[i+j-1] and s2[j-1] == s3[i+j-1]){\\n                    dp[i%2][j] = dp[i%2][j-1];\\n                }else{\\n                    dp[i%2][j] = false;\\n                }\\n            }\\n        }\\n        \\n        return dp[n%2][m];\\n        \\n        \\n        \\n    }\\n};\\n```\\n\\t\\nTime : O(M*N)\\n\\nSpace : O(M)\\n   \\n  \\n\\n\\t\\t\\t\\t\\t",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n    if (s2[i-1] != s3[i-1])\\n\\t\\tdp[0][i] = false;\\n\\telse \\n\\t\\tdp[0][i] = dp[0][i-1];\\n   ```\n```\\n\\t  if(s1[i-1] != s3[i-1])\\n\\t     dp[i][0] = false;\\n\\t  else \\n\\t\\t  dp[i][0] = dp[i-1][0];\\n  ```\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n = s1.size();\\n        int m = s2.size();\\n        int l = s3.size();\\n        \\n        if(l != n + m)return false;\\n        \\n        vector<vector<bool>> dp(n+1 , vector<bool>(m+1, false));\\n        \\n        dp[0][0] = true;\\n        \\n        //populating first row\\n        for(int i=1 ;i<=m ;i++){\\n            if(s2[i-1] != s3[i-1])dp[0][i] = false;\\n            else dp[0][i] = dp[0][i-1];\\n        }\\n        \\n        //populating first col\\n        for(int i=1 ;i<=n ;i++){\\n            if(s1[i-1] != s3[i-1])dp[i][0] = false;\\n            else dp[i][0] = dp[i-1][0];\\n        }\\n        \\n        // rest\\n        for(int i=1;i<=n ;i++){\\n            for(int j=1;j<=m ;j++){\\n                if(s1[i-1] == s3[i+j-1] and s2[j-1] == s3[i+j-1]){\\n                    dp[i][j] = (dp[i-1][j] || dp[i][j-1]);\\n                }\\n                else if(s1[i-1] == s3[i+j-1] and s2[j-1] != s3[i+j-1]){\\n                    dp[i][j] = dp[i-1][j];\\n                } \\n                else if(s1[i-1] != s3[i+j-1] and s2[j-1] == s3[i+j-1]){\\n                    dp[i][j] = dp[i][j-1];\\n                }else{\\n                    dp[i][j] = false;\\n                }\\n            }\\n        }\\n        \\n        return dp[n][m];\\n        \\n        \\n        \\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n = s1.size();\\n        int m = s2.size();\\n        int l = s3.size();\\n        \\n        if(l != n + m)return false;\\n        \\n\\t\\t// considering two rows at a time\\n        vector<vector<bool>> dp(2 , vector<bool>(m+1, false));\\n        \\n        dp[0][0] = true;\\n        \\n        //populating first row\\n        for(int i=1 ;i<=m ;i++){\\n            if(s2[i-1] != s3[i-1])dp[0][i] = false;\\n            else dp[0][i] = dp[0][i-1];\\n        }\\n        \\n     \\n        // rest\\n        for(int i=1;i<=n ;i++){\\n            for(int j=0;j<=m ;j++){\\n                if(j == 0){\\n                    // first col\\n                    if(s1[i-1] != s3[i+j-1])dp[i%2][j] = false;\\n                    else dp[i%2][j] = dp[(i-1)%2][j];\\n                }\\n                else if(s1[i-1] == s3[i+j-1] and s2[j-1] == s3[i+j-1]){\\n                    dp[i%2][j] = (dp[(i-1)%2][j] || dp[i%2][j-1]);\\n                }\\n                else if(s1[i-1] == s3[i+j-1] and s2[j-1] != s3[i+j-1]){\\n                    dp[i%2][j] = dp[(i-1)%2][j];\\n                } \\n                else if(s1[i-1] != s3[i+j-1] and s2[j-1] == s3[i+j-1]){\\n                    dp[i%2][j] = dp[i%2][j-1];\\n                }else{\\n                    dp[i%2][j] = false;\\n                }\\n            }\\n        }\\n        \\n        return dp[n%2][m];\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1406870,
                "title": "c-dp-solution-fully-explained",
                "content": "While solving dp question always first find what are the possible choices you have at any given point i.e., first make the choice diagram and then coding it will be very easy.\\n\\nAnd if you see some overlapping sub problems then just store their result and use it later.\\n\\nIn this question, we have to form `s3` using `s1` and `s2` while maintaining their orders.\\n\\n## How we\\'re getting the answer\\n\\nIn the given test case:\\n\\ns1 = `aabcc`\\ns2 = `dbbca`\\ns3 = `aadbbcbcac`\\n\\nI\\'m starting from the end and trying to make `s3` with the help of `s1` and `s2`\\n\\nLet `i = s1.size() - 1` (end of `s1`) and `j = s2.size() - 1` (end of `s2`) and `k = s3.size() - 1` (end of `s3`)\\n\\n1. First I need `c`, so take `c` from `s1` (now `s1` = `aabc ` and s2 =`dbbca` and `s3` = `aadbbcbca`)\\n2. Now,  I need `a`, so take `a` from `s2` (now `s1` = `aabc ` and s2 =`dbbc` and `s3` = `aadbbcbc`)\\n3. Now, I need `c`, so I can take `c` from either `s1` or from `s2`\\n\\nThis intuition is more than enough to make the choice diagram\\n\\n## Choice Diagram\\n\\n1. `ith` character of `s1` = `kth` character of `s3`  (aabc**c**, aadbbcbca**c**)\\n\\n\\tJust shift the two pointers `i` to `i-1` and `k` to `k-1` as we\\'ve included `c` from `s1`\\n\\t\\n\\t```\\n\\tsolve(s1, s2, s3, i-1, j, k-1);\\n\\t```\\n\\n2. `jth` character of `s2` = `kth` character of `s3`  (dbbc**a**, aadbbcbc**a**)\\n\\t\\n\\tJust shift the two pointers `j` to `j-1` and `k` to `k-1`\\n\\t\\n\\t```\\n\\tsolve(s1, s2, s3, i, j-1, k-1);\\n\\t```\\n\\t\\n3. Both `ith` and `jth` character are equal to `kth` character of `s3` (aab**c**, dbb**c**, aadbbcb**c**)\\n\\t\\n\\tIn this case I can take the character from any of the string. And since I can get answer from any of the possiblity that\\'s why I\\'m using `||` \\n\\t\\n\\t```\\n\\tsolve(s1, s2, s3, i-1, j, k-1) || solve(s1, s2,s3, i, j-1, k-1);\\n\\t```\\n\\t\\n\\n4. None of them are equal to `kth` character of `s3`\\n\\tIf none of the character is equal to the `kth` character of `s3` then it\\'s impossible to make `s3` with the help of `s1` and `s2` as they don\\'t contain the `kth` character in them.\\n\\n## Recursive Code\\n\\nIn this step we just have to code the choice diagram\\n\\n```\\nbool solve(string &s1, string &s2, string &s3, int i, int j, int k)\\n{\\n\\n\\t// Base Case\\n\\tif(k == 0 and (i or j)) // If we\\'ve reached the end of s3 but still some of the characters are remaining in s1 or s2 then return false as we\\'ve to utilise every character of s1 and s2\\n\\t\\treturn false;\\n\\n\\tif(i == 0 and j == 0 and k == 0) // If we\\'ve exhausted all of the three strings then just return true as we have finally formed s3 with the help of s1 and s2\\n\\t\\treturn true;\\n\\t\\t\\n\\t// Choice Diagram\\n\\t\\n\\t// i and j should be > 0, which make sures that there are some characters left in our string\\n\\n\\tif(i > 0 and j > 0 and s1[i-1] == s2[j-1] and s1[i-1] == s3[k-1]) // Case 3\\n\\t\\treturn solve(s1, s2, s3, i-1, j, k-1) || solve(s1, s2,s3, i, j-1, k-1);\\n\\n\\tif(i > 0 and s3[k-1] == s1[i-1]) // Case 1\\n\\t\\treturn solve(s1, s2, s3, i-1, j, k-1);\\n\\n\\tif(j > 0 and s3[k-1] == s2[j-1]) // Case 2\\n\\t\\treturn solve(s1, s2,s3, i, j-1, k-1);\\n\\n\\treturn false; // Case 4\\n}\\n\\nbool isInterleave(string s1, string s2, string s3) {\\n\\n\\tif(s1.size() + s2.size() != s3.size())\\n\\t\\treturn false;\\n\\n\\treturn solve(s1, s2, s3, s1.size(), s2.size(), s3.size());\\n}\\n```\\n\\n## Memoized Code\\n\\nWe just have to add 2-3 extra lines to convert recusive code into memoized code. Make a DP Table and store the subproblems result in it.\\n\\n```\\nbool solve(string &s1, string &s2, string &s3, int i, int j, int k, vector<vector<int>> &dp)\\n{\\n\\tif(k == 0 and (i or j))\\n\\t\\treturn false;\\n\\n\\tif(i == 0 and j == 0 and k == 0)\\n\\t\\treturn true;\\n\\n\\tif(dp[i][j] != -1) // Just return the result from the cache\\n\\t\\treturn dp[i][j];\\n\\n\\tif(i > 0 and j > 0 and s1[i-1] == s2[j-1] and s1[i-1] == s3[k-1])\\n\\t\\treturn dp[i][j] = solve(s1, s2, s3, i-1, j, k-1, dp) || solve(s1, s2,s3, i, j-1, k-1, dp); // before returning the result store it into the cache\\n\\n\\tif(i > 0 and s3[k-1] == s1[i-1])\\n\\t\\treturn dp[i][j] = solve(s1, s2, s3, i-1, j, k-1, dp);\\n\\n\\tif(j > 0 and s3[k-1] == s2[j-1])\\n\\t\\treturn dp[i][j] = solve(s1, s2,s3, i, j-1, k-1, dp);\\n\\n\\treturn dp[i][j] = false;\\n}\\n\\nbool isInterleave(string s1, string s2, string s3) {\\n\\n\\tvector<vector<int>> dp(s1.size() + 1, vector<int> (s2.size() + 1, -1)); // initialisiation of 2D vector\\n\\n\\tif(s1.size() + s2.size() != s3.size())\\n\\t\\treturn false;\\n\\n\\treturn solve(s1, s2, s3, s1.size(), s2.size(), s3.size(), dp);\\n}\\n```\\n\\nSmall tip to avoid TLE \\n\\nAlways use call by referance wherever you can as in call by referance you\\'re not wasting any time in making copies of variables in every function call.\\n\\nSo, if I\\'ve used `bool solve(string s1, string s2, string s3, int i, int j, int k, vector<vector<int>> dp)` this instead of `bool solve(string &s1, string &s2, string &s3, int i, int j, int k, vector<vector<int>> &dp)` then I would\\'ve definately gotten TLE as I\\'m unncecessarily copying the values in every function call.",
                "solutionTags": [],
                "code": "```\\n\\tsolve(s1, s2, s3, i-1, j, k-1);\\n\\t```\n```\\n\\tsolve(s1, s2, s3, i, j-1, k-1);\\n\\t```\n```\\n\\tsolve(s1, s2, s3, i-1, j, k-1) || solve(s1, s2,s3, i, j-1, k-1);\\n\\t```\n```\\nbool solve(string &s1, string &s2, string &s3, int i, int j, int k)\\n{\\n\\n\\t// Base Case\\n\\tif(k == 0 and (i or j)) // If we\\'ve reached the end of s3 but still some of the characters are remaining in s1 or s2 then return false as we\\'ve to utilise every character of s1 and s2\\n\\t\\treturn false;\\n\\n\\tif(i == 0 and j == 0 and k == 0) // If we\\'ve exhausted all of the three strings then just return true as we have finally formed s3 with the help of s1 and s2\\n\\t\\treturn true;\\n\\t\\t\\n\\t// Choice Diagram\\n\\t\\n\\t// i and j should be > 0, which make sures that there are some characters left in our string\\n\\n\\tif(i > 0 and j > 0 and s1[i-1] == s2[j-1] and s1[i-1] == s3[k-1]) // Case 3\\n\\t\\treturn solve(s1, s2, s3, i-1, j, k-1) || solve(s1, s2,s3, i, j-1, k-1);\\n\\n\\tif(i > 0 and s3[k-1] == s1[i-1]) // Case 1\\n\\t\\treturn solve(s1, s2, s3, i-1, j, k-1);\\n\\n\\tif(j > 0 and s3[k-1] == s2[j-1]) // Case 2\\n\\t\\treturn solve(s1, s2,s3, i, j-1, k-1);\\n\\n\\treturn false; // Case 4\\n}\\n\\nbool isInterleave(string s1, string s2, string s3) {\\n\\n\\tif(s1.size() + s2.size() != s3.size())\\n\\t\\treturn false;\\n\\n\\treturn solve(s1, s2, s3, s1.size(), s2.size(), s3.size());\\n}\\n```\n```\\nbool solve(string &s1, string &s2, string &s3, int i, int j, int k, vector<vector<int>> &dp)\\n{\\n\\tif(k == 0 and (i or j))\\n\\t\\treturn false;\\n\\n\\tif(i == 0 and j == 0 and k == 0)\\n\\t\\treturn true;\\n\\n\\tif(dp[i][j] != -1) // Just return the result from the cache\\n\\t\\treturn dp[i][j];\\n\\n\\tif(i > 0 and j > 0 and s1[i-1] == s2[j-1] and s1[i-1] == s3[k-1])\\n\\t\\treturn dp[i][j] = solve(s1, s2, s3, i-1, j, k-1, dp) || solve(s1, s2,s3, i, j-1, k-1, dp); // before returning the result store it into the cache\\n\\n\\tif(i > 0 and s3[k-1] == s1[i-1])\\n\\t\\treturn dp[i][j] = solve(s1, s2, s3, i-1, j, k-1, dp);\\n\\n\\tif(j > 0 and s3[k-1] == s2[j-1])\\n\\t\\treturn dp[i][j] = solve(s1, s2,s3, i, j-1, k-1, dp);\\n\\n\\treturn dp[i][j] = false;\\n}\\n\\nbool isInterleave(string s1, string s2, string s3) {\\n\\n\\tvector<vector<int>> dp(s1.size() + 1, vector<int> (s2.size() + 1, -1)); // initialisiation of 2D vector\\n\\n\\tif(s1.size() + s2.size() != s3.size())\\n\\t\\treturn false;\\n\\n\\treturn solve(s1, s2, s3, s1.size(), s2.size(), s3.size(), dp);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1248331,
                "title": "java-easy-to-understand-dp-solution",
                "content": "```\\nclass Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        int n1=s1.length();\\n        int n2=s2.length();\\n        if(n1+n2!=s3.length())\\n            return false;\\n        boolean dp[][]=new boolean[n1+1][n2+1];\\n        dp[0][0]=true;\\n        for(int j=1;j<=n2;j++)\\n        {//initializing 0th row\\n            if(s2.charAt(j-1)==s3.charAt(j-1))\\n                dp[0][j]=dp[0][j-1];\\n        }\\n        for(int i=1;i<=n1;i++)\\n        {//initializing 0th column\\n            if(s1.charAt(i-1)==s3.charAt(i-1))\\n                dp[i][0]=dp[i-1][0];\\n        }\\n        for(int i=1;i<=n1;i++)\\n        {\\n            for(int j=1;j<=n2;j++)\\n            {//the length of s3 is n1+n2, since the string is 0 indexed we check at i+j-1\\n                if(s3.charAt(i+j-1)==s1.charAt(i-1))\\n                    dp[i][j]=dp[i-1][j];\\n                if(s3.charAt(i+j-1)==s2.charAt(j-1))\\n                    dp[i][j]=dp[i][j]||dp[i][j-1];  \\n\\t\\t\\t\\t\\t//In some cases the character from s3 matches both s1 and s2, therefore we consider the value thats true\\n            }\\n        }\\n        return dp[n1][n2];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        int n1=s1.length();\\n        int n2=s2.length();\\n        if(n1+n2!=s3.length())\\n            return false;\\n        boolean dp[][]=new boolean[n1+1][n2+1];\\n        dp[0][0]=true;\\n        for(int j=1;j<=n2;j++)\\n        {//initializing 0th row\\n            if(s2.charAt(j-1)==s3.charAt(j-1))\\n                dp[0][j]=dp[0][j-1];\\n        }\\n        for(int i=1;i<=n1;i++)\\n        {//initializing 0th column\\n            if(s1.charAt(i-1)==s3.charAt(i-1))\\n                dp[i][0]=dp[i-1][0];\\n        }\\n        for(int i=1;i<=n1;i++)\\n        {\\n            for(int j=1;j<=n2;j++)\\n            {//the length of s3 is n1+n2, since the string is 0 indexed we check at i+j-1\\n                if(s3.charAt(i+j-1)==s1.charAt(i-1))\\n                    dp[i][j]=dp[i-1][j];\\n                if(s3.charAt(i+j-1)==s2.charAt(j-1))\\n                    dp[i][j]=dp[i][j]||dp[i][j-1];  \\n\\t\\t\\t\\t\\t//In some cases the character from s3 matches both s1 and s2, therefore we consider the value thats true\\n            }\\n        }\\n        return dp[n1][n2];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1247271,
                "title": "python3-fast-dp-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/images/e6742f38-33b2-4096-a3b1-5e2854d6cca6_1622643568.1336555.png)\\n```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        m = len(s1) \\n        n = len(s2)\\n        @lru_cache(None)\\n        def dfs(i,j,k) : \\n            if i > m-1 and j > n-1 : \\n                return True\\n            if i < m and s1[i] == s3[k] and dfs(i+1,j,k+1) :\\n                return True \\n            if j < n and s2[j] == s3[k] and dfs(i,j+1,k+1) : \\n                return True\\n            return False\\n        return Counter(s1) + Counter(s2) == Counter(s3) and dfs(0,0,0)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        m = len(s1) \\n        n = len(s2)\\n        @lru_cache(None)\\n        def dfs(i,j,k) : \\n            if i > m-1 and j > n-1 : \\n                return True\\n            if i < m and s1[i] == s3[k] and dfs(i+1,j,k+1) :\\n                return True \\n            if j < n and s2[j] == s3[k] and dfs(i,j+1,k+1) : \\n                return True\\n            return False\\n        return Counter(s1) + Counter(s2) == Counter(s3) and dfs(0,0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1246962,
                "title": "basic-recursion",
                "content": "THIS WILL NOT ACCEPT\\nbut if you want the logic of this question then you need to understand the recursion behind this.\\n\\n\\n boolean  helper(String s1, String s2, String s3, int i, int j, int k) {\\n\\n\\tif(i<0 && j<0 && k<0)\\n\\t{\\n\\t\\treturn true;\\n\\t}\\n\\t\\n\\tif(i>=0 && j>=0 && s1.charAt(i)==s3.charAt(k) && s2.charAt(j)==s3.charAt(k))\\n\\t{\\n\\t\\treturn helper(s1,s2,s3,i-1,j,k-1) || helper(s1,s2,s3,i,j-1,k-1);\\n\\t}\\n\\telse if(i>=0 &&s1.charAt(i)==s3.charAt(k) )\\n\\t{\\n\\t\\treturn helper(s1,s2,s3,i-1,j,k-1);\\n\\t}\\n\\telse if(j>=0 && s2.charAt(j)==s3.charAt(k) )\\n\\t{\\n\\t\\treturn helper(s1,s2,s3,i,j-1,k-1);\\n\\t}else\\n\\t\\treturn false;\\n}\\n",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "THIS WILL NOT ACCEPT\\nbut if you want the logic of this question then you need to understand the recursion behind this.\\n\\n\\n boolean  helper(String s1, String s2, String s3, int i, int j, int k) {\\n\\n\\tif(i<0 && j<0 && k<0)\\n\\t{\\n\\t\\treturn true;\\n\\t}\\n\\t\\n\\tif(i>=0 && j>=0 && s1.charAt(i)==s3.charAt(k) && s2.charAt(j)==s3.charAt(k))\\n\\t{\\n\\t\\treturn helper(s1,s2,s3,i-1,j,k-1) || helper(s1,s2,s3,i,j-1,k-1);\\n\\t}\\n\\telse if(i>=0 &&s1.charAt(i)==s3.charAt(k) )\\n\\t{\\n\\t\\treturn helper(s1,s2,s3,i-1,j,k-1);\\n\\t}\\n\\telse if(j>=0 && s2.charAt(j)==s3.charAt(k) )\\n\\t{\\n\\t\\treturn helper(s1,s2,s3,i,j-1,k-1);\\n\\t}else\\n\\t\\treturn false;\\n}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 259205,
                "title": "clean-javascript-bfs",
                "content": "I used BFS + Set for this approach and got 64ms. \\nThe idea is to try every possible combination, but skip duplicates by using set.\\n\\n```\\nvar isInterleave = function(s1, s2, s3) {    \\n  let queue = [[0, 0, 0]];\\n  let set = new Set();\\n  \\n  while (queue.length) {\\n    let [one, two, three] = queue.shift(); // indices of s1, s2, and s3\\n\\t\\n    if (set.has(`${one}-${two}`)) continue;   // Skipping any duplicates.\\n    set.add(`${one}-${two}`); \\n    \\n\\t// if all indices are same as their length we basically found our answer so return true;\\n    if (three === s3.length && one === s1.length && two === s2.length) return true;\\n    \\n\\t// we enqueue the next possibles\\n    if (one < s1.length && s3[three] === s1[one]) queue.push([one + 1, two, three + 1]);\\n    if (two < s2.length && s3[three] === s2[two]) queue.push([one, two + 1, three + 1]);\\n  }\\n  \\n  // Our queue is empty which means we tried every possible combination, so return false;\\n  return false; \\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nvar isInterleave = function(s1, s2, s3) {    \\n  let queue = [[0, 0, 0]];\\n  let set = new Set();\\n  \\n  while (queue.length) {\\n    let [one, two, three] = queue.shift(); // indices of s1, s2, and s3\\n\\t\\n    if (set.has(`${one}-${two}`)) continue;   // Skipping any duplicates.\\n    set.add(`${one}-${two}`); \\n    \\n\\t// if all indices are same as their length we basically found our answer so return true;\\n    if (three === s3.length && one === s1.length && two === s2.length) return true;\\n    \\n\\t// we enqueue the next possibles\\n    if (one < s1.length && s3[three] === s1[one]) queue.push([one + 1, two, three + 1]);\\n    if (two < s2.length && s3[three] === s2[two]) queue.push([one, two + 1, three + 1]);\\n  }\\n  \\n  // Our queue is empty which means we tried every possible combination, so return false;\\n  return false; \\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 151397,
                "title": "javascript-dp-solution",
                "content": "```js\\nfunction isInterleave(s1, s2, s3) {\\n  if (s1.length + s2.length !== s3.length) {\\n    return false;\\n  }\\n  \\n  const N1 = s1.length;\\n  const N2 = s2.length;\\n  const DP = [...Array(N1+1)].map(r => Array(N2+1).fill(false));\\n  \\n  for (let r = 0; r <= N1; r++) {\\n    for (let c = 0; c <= N2; c++) {\\n      if (r === 0 && c === 0) {\\n        DP[r][c] = true;\\n      } else if (r === 0) {\\n        DP[r][c] = DP[r][c-1] && s2[c-1] === s3[r+c-1];\\n      } else if (c === 0) {\\n        DP[r][c] = DP[r-1][c] && s1[r-1] === s3[r+c-1];\\n      } else {\\n        DP[r][c] = (DP[r][c-1] && s3[r+c-1] === s2[c-1]) || (DP[r-1][c] && s3[r+c-1] === s1[r-1]);\\n      }\\n    }\\n  }\\n  \\n  return DP[N1][N2];\\n}\\n```",
                "solutionTags": [],
                "code": "```js\\nfunction isInterleave(s1, s2, s3) {\\n  if (s1.length + s2.length !== s3.length) {\\n    return false;\\n  }\\n  \\n  const N1 = s1.length;\\n  const N2 = s2.length;\\n  const DP = [...Array(N1+1)].map(r => Array(N2+1).fill(false));\\n  \\n  for (let r = 0; r <= N1; r++) {\\n    for (let c = 0; c <= N2; c++) {\\n      if (r === 0 && c === 0) {\\n        DP[r][c] = true;\\n      } else if (r === 0) {\\n        DP[r][c] = DP[r][c-1] && s2[c-1] === s3[r+c-1];\\n      } else if (c === 0) {\\n        DP[r][c] = DP[r-1][c] && s1[r-1] === s3[r+c-1];\\n      } else {\\n        DP[r][c] = (DP[r][c-1] && s3[r+c-1] === s2[c-1]) || (DP[r-1][c] && s3[r+c-1] === s1[r-1]);\\n      }\\n    }\\n  }\\n  \\n  return DP[N1][N2];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 31998,
                "title": "my-c-dp-solution",
                "content": "This is a typical DP problem. Use an array to save the intermediate matching result. dp[i][j] represents if s3[0::i+j-1] is an interleaved version of s1[0::i-1] and s2[0::j-1].  The recursive equation is dp[i][j] = ( dp[i-1][j] && (s1[i-1]==s3[i+j-1]) ) || ( dp[i][j-1] && (s2[j-1]==s3[i+j-1]) ). This equation only needs dp[i][] and dp[i-1][], so two rows are enough.\\n\\n    class Solution {\\n    public:\\n        bool isInterleave(string s1, string s2, string s3) {\\n            int len1 = s1.size(), len2 = s2.size(), len3 = s3.size(), row, col;\\n            if(len1+len2!=len3) return false;//if the length doesn't match\\n            if(!len1 || !len2) return s3 == s1+s2; // if at least one (s1 or s2) is empty, compare if the other equals to s3\\n            bool dp[2][len2+1];\\n    \\n            for(col=1, dp[0][0] = true; col<=len2;++col)\\n                dp[0][col] = dp[0][col-1] && (s2[col-1] == s3[col-1]); // generate the first row of dp\\n            \\n            for(row=1; row<=len1;++row)\\n                for(col=1, dp[row%2][0] = dp[(row-1)%2][0] && (s1[row-1]==s3[row-1]) ; col<=len2;++col)\\n                    dp[row%2][col] = (dp[row%2][col-1] && s2[col-1] == s3[row+col-1]) ||\\n                                     (dp[(row-1)%2][col] && s1[row-1] == s3[row+col-1]); // recursive equation\\n            return dp[len1%2][len2];                         \\n         }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isInterleave(string s1, string s2, string s3) {\\n            int len1 = s1.size(), len2 = s2.size(), len3 = s3.size(), row, col;\\n            if(len1+len2!=len3) return false;//if the length doesn't match\\n            if(!len1 || !len2) return s3 == s1+s2; // if at least one (s1 or s2) is empty, compare if the other equals to s3\\n            bool dp[2][len2+1];\\n    \\n            for(col=1, dp[0][0] = true; col<=len2;++col)\\n                dp[0][col] = dp[0][col-1] && (s2[col-1] == s3[col-1]); // generate the first row of dp\\n            \\n            for(row=1; row<=len1;++row)\\n                for(col=1, dp[row%2][0] = dp[(row-1)%2][0] && (s1[row-1]==s3[row-1]) ; col<=len2;++col)\\n                    dp[row%2][col] = (dp[row%2][col-1] && s2[col-1] == s3[row+col-1]) ||\\n                                     (dp[(row-1)%2][col] && s1[row-1] == s3[row+col-1]); // recursive equation\\n            return dp[len1%2][len2];                         \\n         }",
                "codeTag": "Java"
            },
            {
                "id": 32059,
                "title": "3ms-dfs-easy-to-understand",
                "content": "    void isInterleave1(int i, int j, int k, string s1, string s2, string s3, bool &flag, vector<bool> &visit)\\n    {\\n\\tif (!flag)\\n\\t{\\n\\t\\tif (k == s3.length())\\n\\t\\t{\\n\\t\\t\\tflag = true;\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif (!visit[i*(s2.length()+1) + j])\\n\\t\\t{\\n\\t\\t\\tvisit[i*(s2.length() + 1) + j] = true;\\n\\t\\t\\tif (i < s1.length() && s3[k] == s1[i])\\n\\t\\t\\t{\\n\\t\\t\\t\\tisInterleave1(i + 1, j, k + 1, s1, s2, s3, flag, visit);\\n\\t\\t\\t}\\n\\t\\t\\tif (j < s2.length() && s3[k] == s2[j])\\n\\t\\t\\t{\\n\\t\\t\\t\\tisInterleave1(i, j + 1, k + 1, s1, s2, s3, flag, visit);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n    }\\n    bool isInterleave(string s1, string s2, string s3) {\\n\\tbool flag = false;\\n\\tif (s1.length() + s2.length() != s3.length())\\n\\t\\treturn false;\\n\\tvector<bool> visit((s1.length()+1)*(s2.length()+1), false);\\n\\tisInterleave1(0, 0, 0, s1, s2, s3, flag, visit);\\n\\treturn flag;\\n    }",
                "solutionTags": [],
                "code": "    void isInterleave1(int i, int j, int k, string s1, string s2, string s3, bool &flag, vector<bool> &visit)\\n    {\\n\\tif (!flag)\\n\\t{\\n\\t\\tif (k == s3.length())\\n\\t\\t{\\n\\t\\t\\tflag = true;\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif (!visit[i*(s2.length()+1) + j])\\n\\t\\t{\\n\\t\\t\\tvisit[i*(s2.length() + 1) + j] = true;\\n\\t\\t\\tif (i < s1.length() && s3[k] == s1[i])\\n\\t\\t\\t{\\n\\t\\t\\t\\tisInterleave1(i + 1, j, k + 1, s1, s2, s3, flag, visit);\\n\\t\\t\\t}\\n\\t\\t\\tif (j < s2.length() && s3[k] == s2[j])\\n\\t\\t\\t{\\n\\t\\t\\t\\tisInterleave1(i, j + 1, k + 1, s1, s2, s3, flag, visit);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n    }\\n    bool isInterleave(string s1, string s2, string s3) {\\n\\tbool flag = false;\\n\\tif (s1.length() + s2.length() != s3.length())\\n\\t\\treturn false;\\n\\tvector<bool> visit((s1.length()+1)*(s2.length()+1), false);\\n\\tisInterleave1(0, 0, 0, s1, s2, s3, flag, visit);\\n\\treturn flag;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3957580,
                "title": "python-easy-to-understand-fast-dp-tabulation",
                "content": "# Python | Easy to Understand | Fast | DP-Tabulation\\n```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        m, n = len(s1), len(s2)\\n        if m + n != len(s3):\\n            return False\\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\\n        dp[0][0] = True\\n        for i in range(1, m + 1):\\n            dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\\n        for j in range(1, n + 1):\\n            dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                choose_s1, choose_s2 = False, False\\n                if s1[i - 1] == s3[i + j - 1]:\\n                    choose_s1 = dp[i - 1][j]\\n                if s2[j - 1] == s3[i + j - 1]:\\n                    choose_s2 = dp[i][j - 1]\\n                dp[i][j] = choose_s1 or choose_s2\\n\\n        return dp[m][n]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        m, n = len(s1), len(s2)\\n        if m + n != len(s3):\\n            return False\\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\\n        dp[0][0] = True\\n        for i in range(1, m + 1):\\n            dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\\n        for j in range(1, n + 1):\\n            dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                choose_s1, choose_s2 = False, False\\n                if s1[i - 1] == s3[i + j - 1]:\\n                    choose_s1 = dp[i - 1][j]\\n                if s2[j - 1] == s3[i + j - 1]:\\n                    choose_s2 = dp[i][j - 1]\\n                dp[i][j] = choose_s1 or choose_s2\\n\\n        return dp[m][n]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956545,
                "title": "c-simple-solution-using-dp-tabulation-memoization",
                "content": "USING Dynamic Programming\\nMethod 1 -Memoization\\n*Time Complexity: O(m * n)\\nSpace Complexity: O(m * n)*\\n```\\nclass Solution {\\n      bool help(string& s1, string& s2, string& s3, int i, int j, int k, vector<vector<int>>& dp) {\\n\\n        if (i == s1.size() && j == s2.size() && k == s3.size()) { //base case \\n            return true;   \\n        }\\n        \\n        if (dp[i][j] != -1) {  //check is dp array\\n            return dp[i][j];\\n        }\\n        \\n        bool result = false;   //first false check s1 ,s2 element not present then return false as always\\n        if (i < s1.size() && s1[i] == s3[k]) { check string s1 first\\n            result = help(s1, s2, s3, i + 1, j, k + 1, dp);//check s1 and s3 \\n        }\\n        if (result==false && j < s2.size() && s2[j] == s3[k]) { check string s2\\n            result = help(s1, s2, s3, i, j + 1, k + 1, dp); //check s2 and s3\\n        }\\n        dp[i][j] = result;\\n        return result;\\n    }\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int m = s1.size();\\n        int n = s2.size();\\n        int k = s3.size();\\n\\n        if (m + n != k) {\\n            return false;  . // when size of s3 is larger\\n        }\\n        \\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1, -1));\\n        return help(s1, s2, s3, 0, 0, 0, dp);\\n    }\\n};\\n```\\nMethod 2 -Tabulation\\n*Time Complexity: O(m * n)\\nSpace Complexity: O(m * n)*\\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int m = s1.size();\\n        int n = s2.size();\\n        int k = s3.size();\\n\\n        if (m + n != k) {\\n            return false;\\n        }\\n\\n        vector<vector<bool>> dp(m + 1, vector<bool>(n + 1, false));\\n\\n        // base case\\n        dp[0][0] = true;\\n\\n        // Fill the dp table\\n        for (int i = 0; i <= m; ++i) {\\n            for (int j = 0; j <= n; ++j) {\\n                int l = i + j - 1; // Current character in s3\\n\\n                if (i > 0 && s1[i - 1] == s3[l]) {\\n                    dp[i][j] = dp[i][j] || dp[i - 1][j];\\n                }\\n\\n                if (j > 0 && s2[j - 1] == s3[l]) {\\n                    dp[i][j] = dp[i][j] || dp[i][j - 1];\\n                }\\n            }\\n        }\\n\\n        return dp[m][n];\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/ee427cbc-2502-4d04-9f60-13f66bf0a0b0_1692928977.5194664.webp)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n      bool help(string& s1, string& s2, string& s3, int i, int j, int k, vector<vector<int>>& dp) {\\n\\n        if (i == s1.size() && j == s2.size() && k == s3.size()) { //base case \\n            return true;   \\n        }\\n        \\n        if (dp[i][j] != -1) {  //check is dp array\\n            return dp[i][j];\\n        }\\n        \\n        bool result = false;   //first false check s1 ,s2 element not present then return false as always\\n        if (i < s1.size() && s1[i] == s3[k]) { check string s1 first\\n            result = help(s1, s2, s3, i + 1, j, k + 1, dp);//check s1 and s3 \\n        }\\n        if (result==false && j < s2.size() && s2[j] == s3[k]) { check string s2\\n            result = help(s1, s2, s3, i, j + 1, k + 1, dp); //check s2 and s3\\n        }\\n        dp[i][j] = result;\\n        return result;\\n    }\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int m = s1.size();\\n        int n = s2.size();\\n        int k = s3.size();\\n\\n        if (m + n != k) {\\n            return false;  . // when size of s3 is larger\\n        }\\n        \\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1, -1));\\n        return help(s1, s2, s3, 0, 0, 0, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int m = s1.size();\\n        int n = s2.size();\\n        int k = s3.size();\\n\\n        if (m + n != k) {\\n            return false;\\n        }\\n\\n        vector<vector<bool>> dp(m + 1, vector<bool>(n + 1, false));\\n\\n        // base case\\n        dp[0][0] = true;\\n\\n        // Fill the dp table\\n        for (int i = 0; i <= m; ++i) {\\n            for (int j = 0; j <= n; ++j) {\\n                int l = i + j - 1; // Current character in s3\\n\\n                if (i > 0 && s1[i - 1] == s3[l]) {\\n                    dp[i][j] = dp[i][j] || dp[i - 1][j];\\n                }\\n\\n                if (j > 0 && s2[j - 1] == s3[l]) {\\n                    dp[i][j] = dp[i][j] || dp[i][j - 1];\\n                }\\n            }\\n        }\\n\\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3715481,
                "title": "c-solution-with-explanation",
                "content": "\\n# Approach\\nThe dynamic programming approach uses a 2D DP array where dp[i][j] represents whether the substrings s1[0...i-1] and s2[0...j-1] can interleave to form s3[0...i+j-1].\\n\\n\\nHere\\'s a step-by-step explanation of the logic behind the solution:\\n\\n1. **Base Case Initialization**: Initialize a 2D DP array `dp`, where `dp[i][j]` represents whether the first `i` characters of `s1` and the first `j` characters of `s2` can be interleaved to form the first `i + j` characters of `s3`. Initialize `dp[0][0]` as `true`, since two empty strings can form an empty string.\\n\\n2. **Check for Matches with `s1`**: Iterate through the characters of `s1` (from index 1 to `m`). For each character in `s1`, if the current character matches the corresponding character in `s3` and the previous state `dp[i - 1][0]` is `true`, set `dp[i][0]` as `true`. This means that the first `i` characters of `s1` can form the first `i` characters of `s3`.\\n\\n3. **Check for Matches with `s2`**: Similarly, iterate through the characters of `s2` (from index 1 to `n`). For each character in `s2`, if the current character matches the corresponding character in `s3` and the previous state `dp[0][j - 1]` is `true`, set `dp[0][j]` as `true`. This means that the first `j` characters of `s2` can form the first `j` characters of `s3`.\\n\\n4. **Interleaving Check**: Iterate through both `s1` and `s2` (using nested loops). For each position `(i, j)` in the DP array, check if either of the following conditions holds:\\n   - If the current character in `s1` matches the corresponding character in `s3` and the state `dp[i - 1][j]` is `true`. This indicates that characters from `s1` are being used.\\n   - If the current character in `s2` matches the corresponding character in `s3` and the state `dp[i][j - 1]` is `true`. This indicates that characters from `s2` are being used.\\n   \\n   If either of these conditions holds, set `dp[i][j]` as `true`, indicating that the characters from both `s1` and `s2` can be interleaved to form the current prefix of `s3`.\\n\\n5. **Final Result**: After filling the DP array, the value of `dp[m][n]` will indicate whether the entire strings `s1` and `s2` can be interleaved to form the string `s3`.\\n\\n\\n\\n# Upvote for goodluck in interviews\\uD83E\\uDD1E\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int m = s1.length();\\n        int n = s2.length();\\n        \\n        // Check if the lengths of s1, s2, and s3 add up\\n        if (m + n != s3.length()) {\\n            return false;\\n        }\\n        \\n        // Create a 2D DP array to store the intermediate results\\n        vector<vector<bool>> dp(m + 1, vector<bool>(n + 1, false));\\n        \\n        // Initialize the base cases\\n        dp[0][0] = true;\\n        \\n        // Check if s1 matches with s3\\n        for (int i = 1; i <= m; i++) {\\n            if (s1[i - 1] == s3[i - 1] && dp[i - 1][0]) {\\n                dp[i][0] = true;\\n            }\\n        }\\n        \\n        // Check if s2 matches with s3\\n        for (int j = 1; j <= n; j++) {\\n            if (s2[j - 1] == s3[j - 1] && dp[0][j - 1]) {\\n                dp[0][j] = true;\\n            }\\n        }\\n        \\n        // Check if s1 and s2 interleave to form s3\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if ((s1[i - 1] == s3[i + j - 1] && dp[i - 1][j]) ||\\n                    (s2[j - 1] == s3[i + j - 1] && dp[i][j - 1])) {\\n                    dp[i][j] = true;\\n                }\\n            }\\n        }\\n        \\n        return dp[m][n];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int m = s1.length();\\n        int n = s2.length();\\n        \\n        // Check if the lengths of s1, s2, and s3 add up\\n        if (m + n != s3.length()) {\\n            return false;\\n        }\\n        \\n        // Create a 2D DP array to store the intermediate results\\n        vector<vector<bool>> dp(m + 1, vector<bool>(n + 1, false));\\n        \\n        // Initialize the base cases\\n        dp[0][0] = true;\\n        \\n        // Check if s1 matches with s3\\n        for (int i = 1; i <= m; i++) {\\n            if (s1[i - 1] == s3[i - 1] && dp[i - 1][0]) {\\n                dp[i][0] = true;\\n            }\\n        }\\n        \\n        // Check if s2 matches with s3\\n        for (int j = 1; j <= n; j++) {\\n            if (s2[j - 1] == s3[j - 1] && dp[0][j - 1]) {\\n                dp[0][j] = true;\\n            }\\n        }\\n        \\n        // Check if s1 and s2 interleave to form s3\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if ((s1[i - 1] == s3[i + j - 1] && dp[i - 1][j]) ||\\n                    (s2[j - 1] == s3[i + j - 1] && dp[i][j - 1])) {\\n                    dp[i][j] = true;\\n                }\\n            }\\n        }\\n        \\n        return dp[m][n];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3097709,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n1=s1.size(), n2=s2.size(), n3=s3.size();\\n        if(n1+n2 != n3)\\n        return false;\\n        vector<vector<bool>> dp(n1+1, vector<bool>(n2+1));\\n        for(int i=0;i<=n1;i++)\\n        {\\n            for(int j=0;j<=n2;j++)\\n            {\\n                if(i==0 && j==0)\\n                dp[i][j]=true;\\n                else if(i==0)\\n                dp[i][j]=(dp[i][j-1] && s2[j-1]==s3[j-1]);\\n                else if(j==0)\\n                dp[i][j]=(dp[i-1][j] && s1[i-1]==s3[i-1]);\\n                else\\n                dp[i][j]=(dp[i][j-1] && s2[j-1]==s3[i+j-1]) || \\n                         (dp[i-1][j] && s1[i-1]==s3[i+j-1]);\\n            }\\n        }\\n        return dp[n1][n2];\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n1=s1.size(), n2=s2.size(), n3=s3.size();\\n        if(n1+n2 != n3)\\n        return false;\\n        vector<vector<bool>> dp(n1+1, vector<bool>(n2+1));\\n        for(int i=0;i<=n1;i++)\\n        {\\n            for(int j=0;j<=n2;j++)\\n            {\\n                if(i==0 && j==0)\\n                dp[i][j]=true;\\n                else if(i==0)\\n                dp[i][j]=(dp[i][j-1] && s2[j-1]==s3[j-1]);\\n                else if(j==0)\\n                dp[i][j]=(dp[i-1][j] && s1[i-1]==s3[i-1]);\\n                else\\n                dp[i][j]=(dp[i][j-1] && s2[j-1]==s3[i+j-1]) || \\n                         (dp[i-1][j] && s1[i-1]==s3[i+j-1]);\\n            }\\n        }\\n        return dp[n1][n2];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2250515,
                "title": "c-easy-understandable-code-recursive-dp-please-upvote-if-found-useful",
                "content": "``` \\n#define ll long long\\nclass Solution {\\npublic:\\n    ll n,m,nn;\\n    bool fun(ll i,ll j,ll k,string &s1,string &s2,string &t, vector<vector<vector<int>>>&dp){\\n        \\n        \\n        if(i==n and j==m and k==nn)return true;\\n        else if(i==n and j==m)return false;\\n        else if(i==n){\\n            bool ok=true;\\n            if(s2.substr(j,m-j)==t.substr(k,nn-k))return true;\\n            else return dp[i][j][k]= false;\\n        }\\n        else if(j==m){\\n              if(s1.substr(i,n-i)==t.substr(k,nn-k))return true;\\n            else return  dp[i][j][k]=false;\\n        }\\n        \\n        if(dp[i][j][k]!=-1)return dp[i][j][k];\\n        \\n        if(s1[i]==t[k] and s2[j]==t[k]){\\n            bool ans1=fun(i+1,j,k+1,s1,s2,t,dp);\\n            bool ans2=fun(i,j+1,k+1,s1,s2,t,dp);\\n            return dp[i][j][k]= ans1|ans2;\\n        }\\n        else if(s1[i]==t[k]){\\n            return dp[i][j][k]= fun(i+1,j,k+1,s1,s2,t,dp);\\n        }\\n        else if(s2[j]==t[k]){\\n            return dp[i][j][k]= fun(i,j+1,k+1,s1,s2,t,dp);\\n        }\\n        else return dp[i][j][k]= false;\\n    }\\n    \\n    \\n    bool isInterleave(string s1, string s2, string s3) {\\n        n=s1.size();\\n        m=s2.size();\\n        nn=s3.size();\\n        if(n+m!=nn)return false;\\n        vector<vector<vector<int>>>dp(n+1,vector<vector<int>>(m+1,vector<int>(nn+1,-1)));\\n        \\n        return fun(0,0,0,s1,s2,s3,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "``` \\n#define ll long long\\nclass Solution {\\npublic:\\n    ll n,m,nn;\\n    bool fun(ll i,ll j,ll k,string &s1,string &s2,string &t, vector<vector<vector<int>>>&dp){\\n        \\n        \\n        if(i==n and j==m and k==nn)return true;\\n        else if(i==n and j==m)return false;\\n        else if(i==n){\\n            bool ok=true;\\n            if(s2.substr(j,m-j)==t.substr(k,nn-k))return true;\\n            else return dp[i][j][k]= false;\\n        }\\n        else if(j==m){\\n              if(s1.substr(i,n-i)==t.substr(k,nn-k))return true;\\n            else return  dp[i][j][k]=false;\\n        }\\n        \\n        if(dp[i][j][k]!=-1)return dp[i][j][k];\\n        \\n        if(s1[i]==t[k] and s2[j]==t[k]){\\n            bool ans1=fun(i+1,j,k+1,s1,s2,t,dp);\\n            bool ans2=fun(i,j+1,k+1,s1,s2,t,dp);\\n            return dp[i][j][k]= ans1|ans2;\\n        }\\n        else if(s1[i]==t[k]){\\n            return dp[i][j][k]= fun(i+1,j,k+1,s1,s2,t,dp);\\n        }\\n        else if(s2[j]==t[k]){\\n            return dp[i][j][k]= fun(i,j+1,k+1,s1,s2,t,dp);\\n        }\\n        else return dp[i][j][k]= false;\\n    }\\n    \\n    \\n    bool isInterleave(string s1, string s2, string s3) {\\n        n=s1.size();\\n        m=s2.size();\\n        nn=s3.size();\\n        if(n+m!=nn)return false;\\n        vector<vector<vector<int>>>dp(n+1,vector<vector<int>>(m+1,vector<int>(nn+1,-1)));\\n        \\n        return fun(0,0,0,s1,s2,s3,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2249170,
                "title": "very-very-easy-100-beat-solution",
                "content": "class Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n1=s1.size();\\n        int n2=s2.size();\\n        int n3=s3.size();\\n        if(n3!=n1+n2) return false;\\n        bool t[n1+1][n2+1];\\n        for(int i=0;i<n1+1;i++)\\n            for(int j=0;j<n2+1;j++){\\n                if(i==0&&j==0) t[i][j]= true;\\n                else if(i==0)\\n                    t[i][j]=(t[i][j-1]&&s2[j-1]==s3[i+j-1]);\\n                else if(j==0)\\n                    t[i][j]=(t[i-1][j]&&s1[i-1]==s3[i+j-1]);\\n                else \\n                    t[i][j]=(t[i-1][j]&&s1[i-1]==s3[i+j-1])||\\n                              (t[i][j-1]&&s2[j-1]==s3[i+j-1]);\\n            }\\n        return t[n1][n2];\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n1=s1.size();\\n        int n2=s2.size();\\n        int n3=s3.size();\\n        if(n3!=n1+n2) return false;\\n        bool t[n1+1][n2+1];\\n        for(int i=0;i<n1+1;i++)\\n            for(int j=0;j<n2+1;j++){\\n                if(i==0&&j==0) t[i][j]= true;\\n                else if(i==0)\\n                    t[i][j]=(t[i][j-1]&&s2[j-1]==s3[i+j-1]);\\n                else if(j==0)\\n                    t[i][j]=(t[i-1][j]&&s1[i-1]==s3[i+j-1]);\\n                else \\n                    t[i][j]=(t[i-1][j]&&s1[i-1]==s3[i+j-1])||\\n                              (t[i][j-1]&&s2[j-1]==s3[i+j-1]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2248916,
                "title": "c-top-down-approach-dynamic-programming-diagram-recursion-tree",
                "content": "![image](https://assets.leetcode.com/users/images/93cf4f7e-6b36-4465-9a08-fa9a9abef864_1657167982.869954.jpeg)\\n\\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n**Recursion Tree**\\n\\n![image](https://assets.leetcode.com/users/images/ad3ede31-8317-43b5-8338-cc74add708ed_1657167531.1246266.jpeg)\\n\\nNow take **s1=\"aa\" and s2=\"aa\" s3 = \"aaaa\"** . \\nYou will observe repeated subproblems . \\n\\n\\n***C++ Top-Down Memoization***\\n```\\nclass Solution {\\npublic:\\n    bool recursion(string s1, int i,string s2,int j ,string s3 ,int k,vector<vector<int>>&dp)\\n    {\\n        if(i==s1.length() && j==s2.length() && k==s3.length())\\n            return true; // when all three strings reach end simultaneously \\n        \\n        if(k==s3.length()) return false; \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n    \\n        if(s1[i]==s3[k] && recursion(s1,i+1,s2,j,s3,k+1,dp))\\n            return dp[i][j]=true;\\n        if(s2[j]==s3[k] && recursion(s1,i,s2,j+1,s3,k+1,dp))\\n            return dp[i][j]=true;\\n        \\n        return dp[i][j]=false;\\n    }\\n  \\n    bool isInterleave(string s1, string s2, string s3) \\n    {\\n        if(s1.length()+s2.length()!=s3.length())\\n            return false;\\n            \\n        vector<vector<int>>dp(s1.length()+1,vector<int>(s2.length()+1,-1));\\n        \\n        return recursion(s1,0,s2,0,s3,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool recursion(string s1, int i,string s2,int j ,string s3 ,int k,vector<vector<int>>&dp)\\n    {\\n        if(i==s1.length() && j==s2.length() && k==s3.length())\\n            return true; // when all three strings reach end simultaneously \\n        \\n        if(k==s3.length()) return false; \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n    \\n        if(s1[i]==s3[k] && recursion(s1,i+1,s2,j,s3,k+1,dp))\\n            return dp[i][j]=true;\\n        if(s2[j]==s3[k] && recursion(s1,i,s2,j+1,s3,k+1,dp))\\n            return dp[i][j]=true;\\n        \\n        return dp[i][j]=false;\\n    }\\n  \\n    bool isInterleave(string s1, string s2, string s3) \\n    {\\n        if(s1.length()+s2.length()!=s3.length())\\n            return false;\\n            \\n        vector<vector<int>>dp(s1.length()+1,vector<int>(s2.length()+1,-1));\\n        \\n        return recursion(s1,0,s2,0,s3,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1813050,
                "title": "c-o-n-2-top-down-memoization",
                "content": "```\\nclass Solution {\\nprivate:\\n    string p, q, s;\\n    bool f(int i, int j, vector<vector<int>>& dp) {\\n        if(i == p.size() and j == q.size())\\n            return 1;\\n        bool ans = 0;\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n         if(i < p.size() and p[i] == s[i + j])\\n             ans |= f(i + 1, j, dp);\\n        \\n         if(j < q.size() and q[j] == s[i + j])\\n            ans |= f(i, j + 1, dp);\\n\\n        \\n       \\n        return dp[i][j] = ans;\\n    }\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n                p = s1, q = s2, s = s3;\\n        vector<vector<int>> dp(101, vector<int>(101, -1));\\n        if(s1.size() + s2.size() != s3.size())\\n            return false;\\n        \\n        int i = 0, j = 0;\\n        return f(i, j, dp);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\nprivate:\\n    string p, q, s;\\n    bool f(int i, int j, vector<vector<int>>& dp) {\\n        if(i == p.size() and j == q.size())\\n            return 1;\\n        bool ans = 0;\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n         if(i < p.size() and p[i] == s[i + j])\\n             ans |= f(i + 1, j, dp);\\n        \\n         if(j < q.size() and q[j] == s[i + j])\\n            ans |= f(i, j + 1, dp);\\n\\n        \\n       \\n        return dp[i][j] = ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1731392,
                "title": "python-3-memo-soln-beginner-friendly",
                "content": "```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1)+len(s2)!=len(s3):\\n            return False\\n        \\n        dp={}\\n        \\n        def solve(i,j):\\n            \\n            if i== len(s1) and j==len(s2):\\n                return True\\n            \\n            if (i,j) in dp:\\n                return dp[(i,j)]\\n            \\n            if  i <len(s1) and s3[i+j]==s1[i] and solve(i+1,j):\\n                return True\\n\\n            if j<len(s2) and s3[i+j]==s2[j] and solve(i,j+1):\\n                return True\\n            \\n            dp[(i,j)]=False\\n         \\n        return solve(0,0)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1)+len(s2)!=len(s3):\\n            return False\\n        \\n        dp={}\\n        \\n        def solve(i,j):\\n            \\n            if i== len(s1) and j==len(s2):\\n                return True\\n            \\n            if (i,j) in dp:\\n                return dp[(i,j)]\\n            \\n            if  i <len(s1) and s3[i+j]==s1[i] and solve(i+1,j):\\n                return True\\n\\n            if j<len(s2) and s3[i+j]==s2[j] and solve(i,j+1):\\n                return True\\n            \\n            dp[(i,j)]=False\\n         \\n        return solve(0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1375149,
                "title": "simple-java-solution-dp-memoization-time-o-n-m",
                "content": "```\\nclass Solution {\\n\\tpublic boolean isInterLeave(String s1,String s2,String s3)\\n\\t{\\n       if(s1.length()+s2.length()!=s3.length())\\n       return false;\\n       Boolean dp[][]= new Boolean[s1.length()+1][s2.length()+1];\\n       return  solve(s1,s2,s3,0,0,dp);\\n    }\\n    \\n     boolean solve(String s1,String s2,String s3,int i,int j, Boolean[][]dp)\\n     {\\n           if( i == s1.length() && j == s2.length() )\\n            return  true;\\n         \\n         if(dp[i][j]!=null)\\n         {\\n             return dp[i][j];\\n         }\\n         \\n        if(i< s1.length() && s1.charAt(i)==s3.charAt(i+j)) \\n        {\\n           boolean f1= solve(s1,s2,s3,i+1,j,dp);\\n            dp[i][j] =  f1;\\n            if(f1==true)\\n            {\\n                return true;\\n            }\\n        }\\n       if(j< s2.length() && s2.charAt(j)==s3.charAt(i+j)) \\n        {\\n           boolean f2= solve(s1,s2,s3,i,j+1,dp);\\n            dp[i][j] = f2;\\n            if(f2==true)\\n            {\\n                return true;\\n            }    \\n        }   \\n       dp[i][j]=false;  \\n       return dp[i][j];  \\n     }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic boolean isInterLeave(String s1,String s2,String s3)\\n\\t{\\n       if(s1.length()+s2.length()!=s3.length())\\n       return false;\\n       Boolean dp[][]= new Boolean[s1.length()+1][s2.length()+1];\\n       return  solve(s1,s2,s3,0,0,dp);\\n    }\\n    \\n     boolean solve(String s1,String s2,String s3,int i,int j, Boolean[][]dp)\\n     {\\n           if( i == s1.length() && j == s2.length() )\\n            return  true;\\n         \\n         if(dp[i][j]!=null)\\n         {\\n             return dp[i][j];\\n         }\\n         \\n        if(i< s1.length() && s1.charAt(i)==s3.charAt(i+j)) \\n        {\\n           boolean f1= solve(s1,s2,s3,i+1,j,dp);\\n            dp[i][j] =  f1;\\n            if(f1==true)\\n            {\\n                return true;\\n            }\\n        }\\n       if(j< s2.length() && s2.charAt(j)==s3.charAt(i+j)) \\n        {\\n           boolean f2= solve(s1,s2,s3,i,j+1,dp);\\n            dp[i][j] = f2;\\n            if(f2==true)\\n            {\\n                return true;\\n            }    \\n        }   \\n       dp[i][j]=false;  \\n       return dp[i][j];  \\n     }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1247301,
                "title": "interleaving-string-dp-solution-c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int x = s1.length();\\n        int y = s2.length();\\n        int z = s3.length();\\n        if(z!=x+y)\\n            return false;\\n        bool dp[x+1][y+1];\\n        for(int i=0;i<=x;i++)\\n        {\\n            for(int j=0;j<=y;j++)\\n            {\\n                if(i==0 && j==0)\\n                    dp[i][j]=true;\\n                else if(i==0)\\n                    dp[i][j] = dp[i][j-1] && s2[j-1]==s3[j-1];\\n                else if(j==0)\\n                    dp[i][j] = dp[i-1][j] && s1[i-1]==s3[i-1];\\n                else\\n                    dp[i][j] = ((dp[i][j-1] && s2[j-1]==s3[i+j-1]) || (dp[i-1][j] && s1[i-1]==s3[i+j-1]));\\n            }\\n        }\\n        return dp[x][y];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int x = s1.length();\\n        int y = s2.length();\\n        int z = s3.length();\\n        if(z!=x+y)\\n            return false;\\n        bool dp[x+1][y+1];\\n        for(int i=0;i<=x;i++)\\n        {\\n            for(int j=0;j<=y;j++)\\n            {\\n                if(i==0 && j==0)\\n                    dp[i][j]=true;\\n                else if(i==0)\\n                    dp[i][j] = dp[i][j-1] && s2[j-1]==s3[j-1];\\n                else if(j==0)\\n                    dp[i][j] = dp[i-1][j] && s1[i-1]==s3[i-1];\\n                else\\n                    dp[i][j] = ((dp[i][j-1] && s2[j-1]==s3[i+j-1]) || (dp[i-1][j] && s1[i-1]==s3[i+j-1]));\\n            }\\n        }\\n        return dp[x][y];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1247179,
                "title": "c-clean-dp-solution-o-n-m-space-and-o-m-space",
                "content": "# **O(n\\\\*m) space**\\n\\n```\\nbool isInterleave(string s1, string s2, string s3) {\\n\\n\\tint n = s1.size(), m = s2.size(), sz = s3.size();\\n\\tif(n + m != sz) return false;\\n\\n\\tvector<vector<bool>> dp(n+1, vector<bool>(m+1));\\n\\t// dp[i][j] = is it possible to form s3[0...i+j-1] from s1[0...i-1] and s2[0...j-1]\\n\\n\\t// both strings empty\\n\\tdp[0][0] = true;\\n\\n\\t// if s2 is empty\\n\\tfor(int i = 1 ; i <= n ; i++) {\\n\\t\\tdp[i][0] = (s1[i-1] == s3[i-1]) and dp[i-1][0];\\n\\t}\\n\\n\\t// if s1 is empty\\n\\tfor(int j = 1 ; j <= m ; j++) {\\n\\t\\tdp[0][j] = (s2[j-1] == s3[j-1]) and dp[0][j-1];\\n\\t}\\n\\n\\tfor(int i = 1 ; i <= n ; i++) {\\n\\t\\tfor(int j = 1 ; j <= m ; j++) {\\n\\n\\t\\t\\tbool matchI = (s1[i-1] == s3[i+j-1]) and dp[i-1][j];\\n\\t\\t\\tbool matchJ = (s2[j-1] == s3[i+j-1]) and dp[i][j-1];\\n\\n\\t\\t\\tdp[i][j] = matchI or matchJ;\\n\\t\\t}\\n\\t}\\n\\n\\n\\treturn dp[n][m];\\n}\\n```\\n\\n# **O(m) space**\\n\\n\\n```\\nbool isInterleave(string s1, string s2, string s3) {\\n\\tint n = s1.size(), m = s2.size();\\n\\tif(n + m != s3.size()) return false;\\n\\n\\n\\tvector<bool> dp(m+1);\\n\\tdp[0] = true;\\n\\n\\tfor(int len1 = 0 ; len1 <= n ; len1++) {\\n\\t\\tfor(int len2 = 0 ; len2 <= m ; len2++) {\\n\\n\\t\\t\\tif(!len1 and !len2) continue;\\n\\t\\t\\tint len3 = len1 + len2;\\n\\t\\t\\tbool match1 = (len1) ? s1[len1-1] == s3[len3-1] and dp[len2] : false;\\n\\t\\t\\tbool match2 = (len2) ? s2[len2-1] == s3[len3-1] and dp[len2-1] : false;\\n\\t\\t\\tdp[len2] = match1 or match2;\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[m];\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nbool isInterleave(string s1, string s2, string s3) {\\n\\n\\tint n = s1.size(), m = s2.size(), sz = s3.size();\\n\\tif(n + m != sz) return false;\\n\\n\\tvector<vector<bool>> dp(n+1, vector<bool>(m+1));\\n\\t// dp[i][j] = is it possible to form s3[0...i+j-1] from s1[0...i-1] and s2[0...j-1]\\n\\n\\t// both strings empty\\n\\tdp[0][0] = true;\\n\\n\\t// if s2 is empty\\n\\tfor(int i = 1 ; i <= n ; i++) {\\n\\t\\tdp[i][0] = (s1[i-1] == s3[i-1]) and dp[i-1][0];\\n\\t}\\n\\n\\t// if s1 is empty\\n\\tfor(int j = 1 ; j <= m ; j++) {\\n\\t\\tdp[0][j] = (s2[j-1] == s3[j-1]) and dp[0][j-1];\\n\\t}\\n\\n\\tfor(int i = 1 ; i <= n ; i++) {\\n\\t\\tfor(int j = 1 ; j <= m ; j++) {\\n\\n\\t\\t\\tbool matchI = (s1[i-1] == s3[i+j-1]) and dp[i-1][j];\\n\\t\\t\\tbool matchJ = (s2[j-1] == s3[i+j-1]) and dp[i][j-1];\\n\\n\\t\\t\\tdp[i][j] = matchI or matchJ;\\n\\t\\t}\\n\\t}\\n\\n\\n\\treturn dp[n][m];\\n}\\n```\n```\\nbool isInterleave(string s1, string s2, string s3) {\\n\\tint n = s1.size(), m = s2.size();\\n\\tif(n + m != s3.size()) return false;\\n\\n\\n\\tvector<bool> dp(m+1);\\n\\tdp[0] = true;\\n\\n\\tfor(int len1 = 0 ; len1 <= n ; len1++) {\\n\\t\\tfor(int len2 = 0 ; len2 <= m ; len2++) {\\n\\n\\t\\t\\tif(!len1 and !len2) continue;\\n\\t\\t\\tint len3 = len1 + len2;\\n\\t\\t\\tbool match1 = (len1) ? s1[len1-1] == s3[len3-1] and dp[len2] : false;\\n\\t\\t\\tbool match2 = (len2) ? s2[len2-1] == s3[len3-1] and dp[len2-1] : false;\\n\\t\\t\\tdp[len2] = match1 or match2;\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[m];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1246996,
                "title": "c-dp-4ms-solution-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        if(s3.length()>s1.length()+s2.length() || s3.length()<s1.length()+s2.length()){\\n            return false; \\n        }\\n        if(s3==(s1+s2)){\\n            return true;\\n        }\\n        vector<vector<int>> dp(s1.length()+1, vector<int> (s2.length()+1,-1));\\n        return interleave(s1,s2,s3,0,0,0,dp);\\n    }\\n    bool interleave(string &s1, string &s2, string &s3, int i, int j, int k, vector<vector<int>> &dp){\\n        if((i==s1.length()&&j==s2.length()) && (k==s3.length())){\\n            return true; //base case\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j]; //look-up\\n            }\\n        if(i==s1.length()&& j< s2.length()){\\n             if(s3[k]==s2[j])\\n            return dp[i][j] = interleave(s1,s2,s3,i,j+1,k+1,dp); // if s1 string gets empty\\n            return false;\\n        }\\n        if(i<s1.length() && j==s2.length()){\\n           if(s3[k]==s1[i])\\n            return dp[i][j] = interleave(s1,s2,s3,i+1,j,k+1,dp); // if s2 string gets empty\\n            return false;\\n        }\\n        if(s3[k]==s2[j] && s3[k]==s1[i]){\\n            bool op2 = interleave(s1,s2,s3,i+1,j,k+1,dp); //choose from string s1\\n            bool op1 = interleave(s1,s2,s3,i,j+1,k+1,dp);  //choose from string s2;\\n            \\n            return dp[i][j] = op1||op2;\\n        }else if(s3[k]==s2[j]){\\n            return dp[i][j] = interleave(s1,s2,s3,i,j+1,k+1,dp); // choose from string s2;\\n        }else if(s3[k]==s1[i]){\\n            return dp[i][j] = interleave(s1,s2,s3,i+1,j,k+1,dp); // choose from string s1;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        if(s3.length()>s1.length()+s2.length() || s3.length()<s1.length()+s2.length()){\\n            return false; \\n        }\\n        if(s3==(s1+s2)){\\n            return true;\\n        }\\n        vector<vector<int>> dp(s1.length()+1, vector<int> (s2.length()+1,-1));\\n        return interleave(s1,s2,s3,0,0,0,dp);\\n    }\\n    bool interleave(string &s1, string &s2, string &s3, int i, int j, int k, vector<vector<int>> &dp){\\n        if((i==s1.length()&&j==s2.length()) && (k==s3.length())){\\n            return true; //base case\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j]; //look-up\\n            }\\n        if(i==s1.length()&& j< s2.length()){\\n             if(s3[k]==s2[j])\\n            return dp[i][j] = interleave(s1,s2,s3,i,j+1,k+1,dp); // if s1 string gets empty\\n            return false;\\n        }\\n        if(i<s1.length() && j==s2.length()){\\n           if(s3[k]==s1[i])\\n            return dp[i][j] = interleave(s1,s2,s3,i+1,j,k+1,dp); // if s2 string gets empty\\n            return false;\\n        }\\n        if(s3[k]==s2[j] && s3[k]==s1[i]){\\n            bool op2 = interleave(s1,s2,s3,i+1,j,k+1,dp); //choose from string s1\\n            bool op1 = interleave(s1,s2,s3,i,j+1,k+1,dp);  //choose from string s2;\\n            \\n            return dp[i][j] = op1||op2;\\n        }else if(s3[k]==s2[j]){\\n            return dp[i][j] = interleave(s1,s2,s3,i,j+1,k+1,dp); // choose from string s2;\\n        }else if(s3[k]==s1[i]){\\n            return dp[i][j] = interleave(s1,s2,s3,i+1,j,k+1,dp); // choose from string s1;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1246872,
                "title": "interleaving-string-100-fast-dp-solution",
                "content": "```\\n\\n\\nbool isInterleave(char * s1, char * s2, char * s3){\\n    int m = strlen(s1);\\n    int n = strlen(s2);\\n    int l = strlen(s3);\\n    if ((m + n) != l)\\n        return false;\\n    int dp[m+1][n+1];\\n    for(int i = 0;i <= m;i += 1) {\\n        for(int j = 0;j <= n;j += 1) {\\n            if (i == 0 && j == 0)\\n                dp[i][j] = 1;\\n            else if(i == 0)\\n                dp[i][j] = dp[i][j-1] && s2[j-1] == s3[j-1];\\n            else if(j == 0)\\n                dp[i][j] = dp[i-1][j] && s1[i-1] == s3[i-1];\\n            else\\n                dp[i][j] = (dp[i][j-1] && s2[j-1] == s3[i+j-1]) || (dp[i-1][j] && s1[i-1] == s3[i+j-1]);\\n        }\\n    }\\n    return dp[m][n];\\n}\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\n\\nbool isInterleave(char * s1, char * s2, char * s3){\\n    int m = strlen(s1);\\n    int n = strlen(s2);\\n    int l = strlen(s3);\\n    if ((m + n) != l)\\n        return false;\\n    int dp[m+1][n+1];\\n    for(int i = 0;i <= m;i += 1) {\\n        for(int j = 0;j <= n;j += 1) {\\n            if (i == 0 && j == 0)\\n                dp[i][j] = 1;\\n            else if(i == 0)\\n                dp[i][j] = dp[i][j-1] && s2[j-1] == s3[j-1];\\n            else if(j == 0)\\n                dp[i][j] = dp[i-1][j] && s1[i-1] == s3[i-1];\\n            else\\n                dp[i][j] = (dp[i][j-1] && s2[j-1] == s3[i+j-1]) || (dp[i-1][j] && s1[i-1] == s3[i+j-1]);\\n        }\\n    }\\n    return dp[m][n];\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1127736,
                "title": "javascript-simple-top-down-dp",
                "content": "Time: `O(N*M)`\\nSpace: `O(N*M)`\\n```javascript\\nvar isInterleave = function(s1, s2, s3) {\\n    if(s1.length + s2.length !== s3.length) return false;\\n    const memo = new Map()\\n    \\n    function run(i1, i2, i3) {\\n        if(i1 === s1.length) return s3.slice(i3) === s2.slice(i2);\\n        if(i2 === s2.length) return s3.slice(i3) === s1.slice(i1);\\n        const key = `${i1}-${i2}`;\\n        if(memo.has(key)) return memo.get(key)\\n        \\n        let res = false;\\n        \\n        if(s1[i1] === s2[i2] && s1[i1] === s3[i3]) res = run(i1+1, i2, i3+1) || run(i1, i2+1, i3+1);\\n        else if(s1[i1] === s3[i3]) res = run(i1+1, i2, i3+1);\\n        else if(s2[i2] === s3[i3]) res = run(i1, i2+1, i3+1);\\n        \\n        memo.set(key, res);\\n        return res;\\n    }\\n    return run(0, 0, 0)\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```javascript\\nvar isInterleave = function(s1, s2, s3) {\\n    if(s1.length + s2.length !== s3.length) return false;\\n    const memo = new Map()\\n    \\n    function run(i1, i2, i3) {\\n        if(i1 === s1.length) return s3.slice(i3) === s2.slice(i2);\\n        if(i2 === s2.length) return s3.slice(i3) === s1.slice(i1);\\n        const key = `${i1}-${i2}`;\\n        if(memo.has(key)) return memo.get(key)\\n        \\n        let res = false;\\n        \\n        if(s1[i1] === s2[i2] && s1[i1] === s3[i3]) res = run(i1+1, i2, i3+1) || run(i1, i2+1, i3+1);\\n        else if(s1[i1] === s3[i3]) res = run(i1+1, i2, i3+1);\\n        else if(s2[i2] === s3[i3]) res = run(i1, i2+1, i3+1);\\n        \\n        memo.set(key, res);\\n        return res;\\n    }\\n    return run(0, 0, 0)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 188575,
                "title": "extremely-easy-to-understand-java-dp-solution-with-detailed-explanations",
                "content": "  Hi! This is a quite straightforward solution using dp array. I can\\'t say this is runing with the lowest time complexity, but it\\'s really really really easy to understand!\\n\\tI introduced a array called ```boolean data[a + 1][b + 1]```, here a, b stand for the length of s1, s2. \\n  Each element in ```data``` like ```data[i + 1][j + 1]``` means if ```s3.substring(0, k + 1)``` could be formed by interleaving of ```s1.substring(0, i + 1)``` and ```s2.substring(0, j + 1)```, here ```k = i + j + 1``` in which the length of the substring of s1 + s2 equals to s3.\\n\\tThen there is the main idea of how this dp solution works:\\n\\t```Situation 1:```\\n\\t```if s3.charAt(k) == s1.charAt(i), so data[i + 1][j + 1] |= data[i][j + 1]```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t```(the default data[i + 1][j + 1] is false)``` \\n\\tAnd\\n\\t```if s3.charAt(k) == s2.charAt(j), so data[i + 1][j + 1] |= data[i + 1][j]```\\n\\t```Situation 2:```\\n\\t```s3.charAt(k) != s1.charAt(i) && s3.charAt(k) != s2.charAt(j)``` doesn\\'t match! Just leave ```data[i + 1][j + 1]``` false.\\n\\t\\tBase case: \\n\\t\\t```1. data[0][0] = true``` since empty s1, s2 match empty s3.\\n\\t\\t```2. if(s1.charAt(i) == s3.charAt(i)) data[i + 1][0] = true ``` since s3 could be form by s1 without s2.\\n\\t\\t```3. if(s2.charAt(j) == s3.charAt(j)) data[0][j + 1] = true ``` reason is same as ```2.```\\n\\t\\tTime Complexity <strong>O(ab)</strong> btw.\\n\\t\\tAnd the code is shown below:\\n\\t\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        int a = s1.length(), b = s2.length(), c = s3.length();\\n        if(a + b != c) return false;\\n        boolean[][] data = new boolean[a + 1][b + 1];\\n        data[0][0] = true;\\n        for(int i = 0; i < a && s1.charAt(i) == s3.charAt(i); i++) data[i + 1][0] = true;\\n        for(int i = 0; i < b && s2.charAt(i) == s3.charAt(i); i++) data[0][i + 1] = true;\\n        for(int i = 0; i < a; i++) {\\n            for(int j = 0; j < b; j++) {\\n                int k = i + j + 1;\\n                if(s3.charAt(k) == s1.charAt(i)) \\n                    data[i + 1][j + 1] |= data[i][j + 1];\\n                if(s3.charAt(k) == s2.charAt(j)) \\n                    data[i + 1][j + 1] |= data[i + 1][j];\\n            }\\n        }\\n        return data[a][b];\\n    }\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t",
                "solutionTags": [],
                "code": "```boolean data[a + 1][b + 1]```\n```data```\n```data[i + 1][j + 1]```\n```s3.substring(0, k + 1)```\n```s1.substring(0, i + 1)```\n```s2.substring(0, j + 1)```\n```k = i + j + 1```\n```Situation 1:```\n```if s3.charAt(k) == s1.charAt(i), so data[i + 1][j + 1] |= data[i][j + 1]```\n```(the default data[i + 1][j + 1] is false)```\n```if s3.charAt(k) == s2.charAt(j), so data[i + 1][j + 1] |= data[i + 1][j]```\n```Situation 2:```\n```s3.charAt(k) != s1.charAt(i) && s3.charAt(k) != s2.charAt(j)```\n```data[i + 1][j + 1]```\n```1. data[0][0] = true```\n```2. if(s1.charAt(i) == s3.charAt(i)) data[i + 1][0] = true ```\n```3. if(s2.charAt(j) == s3.charAt(j)) data[0][j + 1] = true ```\n```2.```",
                "codeTag": "Unknown"
            },
            {
                "id": 31918,
                "title": "9-lines-dp-js-o-s1-len-s2-len",
                "content": "```\\nvar isInterleave = function(s1, s2, s3) {\\n    // dp[i][j] <=> if s1.substr(0, i) interleaving s2.substr(0, j) generates s3.substr(0, i+j)\\n    var dp= Array(s1.length+1).fill().map(r=>[])  \\n\\n    if (s1.length+s2.length!=s3.length) // quit ealier if possible\\n        return false\\n\\n    for (var i =0;i<= s1.length;i++)\\n        for (var j=0;j<= s2.length;j++)\\n            dp[i][j] = i && dp[i-1][j] && s3[i+j-1] == s1[i-1]    \\n                    || j && dp[i][j-1] && s3[i+j-1] == s2[j-1]\\n                    || !i&&!j   // set dp[0][0] to true\\n\\n    \\n    return !!dp.pop().pop();\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar isInterleave = function(s1, s2, s3) {\\n    // dp[i][j] <=> if s1.substr(0, i) interleaving s2.substr(0, j) generates s3.substr(0, i+j)\\n    var dp= Array(s1.length+1).fill().map(r=>[])  \\n\\n    if (s1.length+s2.length!=s3.length) // quit ealier if possible\\n        return false\\n\\n    for (var i =0;i<= s1.length;i++)\\n        for (var j=0;j<= s2.length;j++)\\n            dp[i][j] = i && dp[i-1][j] && s3[i+j-1] == s1[i-1]    \\n                    || j && dp[i][j-1] && s3[i+j-1] == s2[j-1]\\n                    || !i&&!j   // set dp[0][0] to true\\n\\n    \\n    return !!dp.pop().pop();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 31974,
                "title": "java-first-got-an-idea-about-3d-dp-and-then-realized-that-i-can-change-it-to-2d-dp",
                "content": "**3D dp 46 ms:**\\n\\n        int n = s1.length();\\n        int m = s2.length();\\n        int l = s3.length();\\n        \\n        boolean[][][] dp = new boolean[l+1][n+1][m+1];\\n        \\n        for (int i = 0; i <= n; i++)\\n        {\\n        \\tfor (int j = 0; j <= m; j++)\\n        \\t\\tdp[0][i][j] = false;\\n        }\\n        \\n        dp[0][0][0] = true;\\n        \\n        for (int k = 1; k <= l; k++)\\n        {\\n        \\tfor (int i = 0; i <= n; i++)\\n        \\t{\\n        \\t\\tfor (int j = 0; j <= m; j++)\\n        \\t\\t{\\n        \\t\\t\\tdp[k][i][j] = (i+j == k)&&\\n        \\t\\t\\t\\t\\t((i >= 1 && dp[k-1][i-1][j] && s1.charAt(i-1) == s3.charAt(k-1)) \\n        \\t\\t\\t\\t\\t|| (j >= 1 && dp[k-1][i][j-1] && s2.charAt(j-1) == s3.charAt(k-1))); \\n        \\t\\t}\\n        \\t}\\n        }\\n        \\n        return dp[l][n][m];\\n  \\n**2D dp 6ms (shrink from above solution):**\\n\\n        int n = s1.length();\\n        int m = s2.length();\\n        \\n        boolean[][] dp = new boolean[n+1][m+1];\\n                \\n        dp[0][0] = true;\\n        \\n        for (int i = 0; i <= n; i++)\\n    \\t{\\n    \\t\\tfor (int j = 0; j <= m; j++)\\n    \\t\\t{\\n    \\t\\t\\tif (i == j && i == 0)\\n    \\t\\t\\t\\tcontinue;\\n    \\t\\t\\t\\n    \\t\\t\\tint k = i+j;\\n    \\t\\t\\tdp[i][j] = (i >= 1 && dp[i-1][j] && s1.charAt(i-1) == s3.charAt(k-1))\\n    \\t\\t\\t\\t\\t|| (j >= 1 && dp[i][j-1] && s2.charAt(j-1) == s3.charAt(k-1));\\n    \\t\\t}\\n    \\t}\\n                \\n        return dp[n][m];",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "**3D dp 46 ms:**\\n\\n        int n = s1.length();\\n        int m = s2.length();\\n        int l = s3.length();\\n        \\n        boolean[][][] dp = new boolean[l+1][n+1][m+1];\\n        \\n        for (int i = 0; i <= n; i++)\\n        {\\n        \\tfor (int j = 0; j <= m; j++)\\n        \\t\\tdp[0][i][j] = false;\\n        }\\n        \\n        dp[0][0][0] = true;\\n        \\n        for (int k = 1; k <= l; k++)\\n        {\\n        \\tfor (int i = 0; i <= n; i++)\\n        \\t{\\n        \\t\\tfor (int j = 0; j <= m; j++)\\n        \\t\\t{\\n        \\t\\t\\tdp[k][i][j] = (i+j == k)&&\\n        \\t\\t\\t\\t\\t((i >= 1 && dp[k-1][i-1][j] && s1.charAt(i-1) == s3.charAt(k-1)) \\n        \\t\\t\\t\\t\\t|| (j >= 1 && dp[k-1][i][j-1] && s2.charAt(j-1) == s3.charAt(k-1))); \\n        \\t\\t}\\n        \\t}\\n        }\\n        \\n        return dp[l][n][m];\\n  \\n**2D dp 6ms (shrink from above solution):**\\n\\n        int n = s1.length();\\n        int m = s2.length();\\n        \\n        boolean[][] dp = new boolean[n+1][m+1];\\n                \\n        dp[0][0] = true;\\n        \\n        for (int i = 0; i <= n; i++)\\n    \\t{\\n    \\t\\tfor (int j = 0; j <= m; j++)\\n    \\t\\t{\\n    \\t\\t\\tif (i == j && i == 0)\\n    \\t\\t\\t\\tcontinue;\\n    \\t\\t\\t\\n    \\t\\t\\tint k = i+j;\\n    \\t\\t\\tdp[i][j] = (i >= 1 && dp[i-1][j] && s1.charAt(i-1) == s3.charAt(k-1))\\n    \\t\\t\\t\\t\\t|| (j >= 1 && dp[i][j-1] && s2.charAt(j-1) == s3.charAt(k-1));\\n    \\t\\t}\\n    \\t}\\n                \\n        return dp[n][m];",
                "codeTag": "Unknown"
            },
            {
                "id": 32001,
                "title": "how-to-from-error-to-ac-thoughts-and-extensions-with-c-implementation",
                "content": "At the first glance, it seems a bit hard for me. So I want to try the tail DP.\\n\\nI set the dp[i][j] means\\n\\n         dp[i][j] = true  if s3[0...i+j-1] is the interleaving-string of  s1[0...i-1]  and  s2[0...j-1]  \\n\\nSo, we need to check the tail element .\\n\\nIt is not hard for me to think of  the equation  like this:\\n\\n        dp[i][j] = s3[i+j-1]==s1[i-1] && dp[i-1][j]\\n                           ||   s3[i+j-1]==s2[j-1] && dp[i][j-1]\\n\\nBefore seeing the AC code, I have to mention I make 2 mistakes before AC.\\n\\n**One is my code can not deal with if s1 or s2 is NULL\\nIt is important to first deal with the corner cases first.**\\n\\n\\n**Second is that when I do the initialization, I mis-type some code....**\\n\\nHere is the code.\\n\\n    class Solution {\\n    public:\\n        bool isInterleave(string s1, string s2, string s3) {\\n            int len1=s1.size(), len2=s2.size(), len3=s3.size();\\n            if(len1+len2!=len3)  return false;\\n            if(len1==0) return s2==s3;\\n            if(len2==0) return s1==s3;\\n            vector<vector<bool>> dp(len1+1, vector<bool>(len2+1, false));\\n            dp[0][0]=true;\\n            for(int i=1; i<=len1; i++) dp[i][0]=s1[i-1]==s3[i-1] && dp[i-1][0];\\n            for(int i=1; i<=len2; i++) dp[0][i]=s2[i-1]==s3[i-1] && dp[0][i-1];\\n            \\n            for(int i=1; i<=len1; i++){\\n                for(int j=1; j<=len2; j++){\\n                    dp[i][j] = (s3[i+j-1]==s1[i-1] && dp[i-1][j]) ||\\n                                  (s3[i+j-1]==s2[j-1] && dp[i][j-1]);\\n                }\\n            }\\n            return dp[len1][len2];\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isInterleave(string s1, string s2, string s3) {\\n            int len1=s1.size(), len2=s2.size(), len3=s3.size();\\n            if(len1+len2!=len3)  return false;\\n            if(len1==0) return s2==s3;\\n            if(len2==0) return s1==s3;\\n            vector<vector<bool>> dp(len1+1, vector<bool>(len2+1, false));\\n            dp[0][0]=true;\\n            for(int i=1; i<=len1; i++) dp[i][0]=s1[i-1]==s3[i-1] && dp[i-1][0];\\n            for(int i=1; i<=len2; i++) dp[0][i]=s2[i-1]==s3[i-1] && dp[0][i-1];\\n            \\n            for(int i=1; i<=len1; i++){\\n                for(int j=1; j<=len2; j++){\\n                    dp[i][j] = (s3[i+j-1]==s1[i-1] && dp[i-1][j]) ||\\n                                  (s3[i+j-1]==s2[j-1] && dp[i][j-1]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3963313,
                "title": "python3-dp-top-down-bottom-up-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n1. Top-Down\\n```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        m, n = len(s1), len(s2)\\n        if m + n != len(s3): return False\\n        \\n        @cache\\n        def dp(i: int, j: int) -> bool:\\n            if i < 0 and j < 0: return True\\n            ans = False\\n            if i >= 0 and s1[i] == s3[i + j + 1]: ans |= dp(i - 1, j)\\n            if j >= 0 and s2[j] == s3[i + j + 1]: ans |= dp(i, j - 1)\\n            return ans\\n\\n        return dp(m - 1, n - 1)\\n```\\n- TC: $$O(N^2)$$\\n- SC: $$O(N^2)$$\\n\\n2. Bottom-Up\\n```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        m, n = len(s1), len(s2)\\n        if m + n != len(s3): return False\\n\\n        dp = [[False for _ in range(n + 1)] for _ in range(m + 1)]\\n        dp[0][0] = True\\n        for i in range(-1, m):\\n            for j in range(-1, n):\\n                if i >= 0 and s1[i] == s3[i + j + 1]: dp[i + 1][j + 1] |= dp[i][j + 1]\\n                if j >= 0 and s2[j] == s3[i + j + 1]: dp[i + 1][j + 1] |= dp[i + 1][j]\\n        return dp[m][n]\\n```\\n- TC: $$O(N^2)$$\\n- SC: $$O(N^2)$$\\n",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        m, n = len(s1), len(s2)\\n        if m + n != len(s3): return False\\n        \\n        @cache\\n        def dp(i: int, j: int) -> bool:\\n            if i < 0 and j < 0: return True\\n            ans = False\\n            if i >= 0 and s1[i] == s3[i + j + 1]: ans |= dp(i - 1, j)\\n            if j >= 0 and s2[j] == s3[i + j + 1]: ans |= dp(i, j - 1)\\n            return ans\\n\\n        return dp(m - 1, n - 1)\\n```\n```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        m, n = len(s1), len(s2)\\n        if m + n != len(s3): return False\\n\\n        dp = [[False for _ in range(n + 1)] for _ in range(m + 1)]\\n        dp[0][0] = True\\n        for i in range(-1, m):\\n            for j in range(-1, n):\\n                if i >= 0 and s1[i] == s3[i + j + 1]: dp[i + 1][j + 1] |= dp[i][j + 1]\\n                if j >= 0 and s2[j] == s3[i + j + 1]: dp[i + 1][j + 1] |= dp[i + 1][j]\\n        return dp[m][n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3959849,
                "title": "recursion-to-space-optimization-dp-c-with-explanation",
                "content": "# Intuition\\nWe try to interleave `s1` & `s2` in every possible way that can form string `s3`. We can use recursion to explore all possible ways & find if there exist an answer for any possibility.\\n\\n# Recursion\\nLet\\'s define a recursive boolean function `canInterleave`. where, `canInterleave(k, i, j)` tells us that is it possible to interleave `s1[i...end]` & `s2[j...end]` to form `s3[k...end]`.\\nTherefore our answer will be `canInterleave(0, 0, 0)`.\\n\\n## Code\\n```\\nclass Solution {\\n    bool canInterleave(int k, int i, int j, string& s1, string& s2, string& s3) {\\n        \\n        // All indices reached the end then interleaving is possible\\n        if(i == s1.length() && j == s2.length() && k == s3.length())\\n            return true;\\n\\n        // Intially considering that interleaving is not possible\\n        bool res = false;\\n\\n        // Check if we can match s1[i] to s3[k]\\n        // and if we can, can we get answer by matching them\\n        if(i < s1.length() && s1[i] == s3[k])\\n            res |= canInterleave(k + 1, i + 1, j, s1, s2, s3);\\n\\n        // Check if we can match s2[j] to s3[k]\\n        // and if we can, can we get answer by matching them\\n        if(j < s2.length() && s2[j] == s3[k])\\n            res |= canInterleave(k + 1, i, j + 1, s1, s2, s3);\\n\\n        return res;\\n    }\\n\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        return canInterleave(0, 0, 0, s1, s2, s3);\\n    }\\n};\\n```\\n\\n## Complexity\\n- Time complexity:\\n$$O(2^{len3})$$, where `len3` is length of string`s3`.\\nBecause at a hypothetical situation, we\\'ll have 2 possibilities for every character in `s3` that either match it with character in `s1` or in `s2`.\\n\\n- Space complexity:\\n$$O(len3)$$, Because the recursion depth will be at most `len3` & every function call will have its constant space.\\n\\n# Memoization\\nAbove solution will not work because of it\\'s exponential nature. but we can optimize by memoizing it as there will be overlapping subproblems which we evaluate again & again unnecessarily.\\n\\n## Code\\n```\\nclass Solution {\\n    bool canInterleave(int k, int i, int j, string& s1, string& s2, string& s3, vector<vector<vector<int>>>& dp) {\\n        \\n        // All indices reached the end then interleaving is possible\\n        if(i == s1.length() && j == s2.length() && k == s3.length())\\n            return true;\\n\\n        if(dp[k][i][j] != -1)\\n            return dp[k][i][j];\\n\\n        // Intially considering that interleaving is not possible\\n        bool res = false;\\n\\n        // Check if we can match s1[i] to s3[k]\\n        // and if we can, can we get answer by matching them\\n        if(i < s1.length() && s1[i] == s3[k])\\n            res |= canInterleave(k + 1, i + 1, j, s1, s2, s3, dp);\\n\\n        // Check if we can match s2[j] to s3[k]\\n        // and if we can, can we get answer by matching them\\n        if(j < s2.length() && s2[j] == s3[k])\\n            res |= canInterleave(k + 1, i, j + 1, s1, s2, s3, dp);\\n\\n        return dp[k][i][j] = res;\\n    }\\n\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int len1 = s1.length(), len2 = s2.length(), len3 = s3.length();\\n        vector dp(len3 + 1, vector<vector<int>>(len1 + 1, vector<int>(len2 + 1, -1)));\\n        return canInterleave(0, 0, 0, s1, s2, s3, dp);\\n    }\\n};\\n```\\n\\n## Complexity\\n- Time complexity:\\n$$O(len1*len2*len3)$$, Because there are `len1*len2*len3` dp states to evaluate.\\n\\n- Space complexity:\\n$$O(len3) + O(len1*len2*len3)$$, For recursion stack space & dp array respectively.\\n\\n# Tabulation\\nWe can eliminate recursion stack space from previous solution by using a bottom up tabulation solution as follows\\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int len1 = s1.length(), len2 = s2.length(), len3 = s3.length();\\n        vector dp(len3 + 1, vector<vector<int>>(len1 + 1, vector<int>(len2 + 1, false)));\\n\\n        dp[len3][len1][len2] = true;\\n\\n        for(int k = len3 - 1; k >= 0; k--) {\\n            for(int i = len1; i >= 0; i--) {\\n                for(int j = len2; j >= 0; j--) {\\n                    bool res = false;\\n                    if(i < len1 && s1[i] == s3[k])\\n                        res |= dp[k + 1][i + 1][j];\\n\\n                    if(j < len2 && s2[j] == s3[k])\\n                        res |= dp[k + 1][i][j + 1];\\n\\n                    dp[k][i][j] = res;\\n                }\\n            }\\n        }\\n\\n        return dp[0][0][0];\\n    }\\n};\\n```\\n\\n## Complexity\\n- Time complexity:\\n$$O(len1*len2*len3)$$, Because there are `len1*len2*len3` dp states to evaluate.\\n\\n- Space complexity:\\n$$O(len1*len2*len3)$$, For dp array.\\n\\n# Space Optimization\\nTo calculate dp states for any index `k` we do not need all the previously calculated states we just need dp states for index `k+1`. We can use this to eliminate the 3D dp array with just 2 2D dp arrays.\\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int len1 = s1.length(), len2 = s2.length(), len3 = s3.length();\\n        vector curdp(len1 + 1, vector<bool>(len2 + 1, false));\\n        vector nextdp(len1 + 1, vector<bool>(len2 + 1, false));\\n\\n        nextdp[len1][len2] = true;\\n\\n        for(int k = len3 - 1; k >= 0; k--) {\\n            for(int i = len1; i >= 0; i--) {\\n                for(int j = len2; j >= 0; j--) {\\n                    bool res = false;\\n                    if(i < len1 && s1[i] == s3[k])\\n                        res |= nextdp[i + 1][j];\\n\\n                    if(j < len2 && s2[j] == s3[k])\\n                        res |= nextdp[i][j + 1];\\n\\n                    curdp[i][j] = res;\\n                }\\n            }\\n            nextdp = curdp;\\n        }\\n\\n        return nextdp[0][0];\\n    }\\n};\\n```\\n\\n## Complexity\\n- Time complexity:\\n$$O(len1*len2*len3)$$, Because there are `len1*len2*len3` dp states to evaluate.\\n\\n- Space complexity:\\n$$O(len1*len2)$$, For dp array.\\n",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    bool canInterleave(int k, int i, int j, string& s1, string& s2, string& s3) {\\n        \\n        // All indices reached the end then interleaving is possible\\n        if(i == s1.length() && j == s2.length() && k == s3.length())\\n            return true;\\n\\n        // Intially considering that interleaving is not possible\\n        bool res = false;\\n\\n        // Check if we can match s1[i] to s3[k]\\n        // and if we can, can we get answer by matching them\\n        if(i < s1.length() && s1[i] == s3[k])\\n            res |= canInterleave(k + 1, i + 1, j, s1, s2, s3);\\n\\n        // Check if we can match s2[j] to s3[k]\\n        // and if we can, can we get answer by matching them\\n        if(j < s2.length() && s2[j] == s3[k])\\n            res |= canInterleave(k + 1, i, j + 1, s1, s2, s3);\\n\\n        return res;\\n    }\\n\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        return canInterleave(0, 0, 0, s1, s2, s3);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    bool canInterleave(int k, int i, int j, string& s1, string& s2, string& s3, vector<vector<vector<int>>>& dp) {\\n        \\n        // All indices reached the end then interleaving is possible\\n        if(i == s1.length() && j == s2.length() && k == s3.length())\\n            return true;\\n\\n        if(dp[k][i][j] != -1)\\n            return dp[k][i][j];\\n\\n        // Intially considering that interleaving is not possible\\n        bool res = false;\\n\\n        // Check if we can match s1[i] to s3[k]\\n        // and if we can, can we get answer by matching them\\n        if(i < s1.length() && s1[i] == s3[k])\\n            res |= canInterleave(k + 1, i + 1, j, s1, s2, s3, dp);\\n\\n        // Check if we can match s2[j] to s3[k]\\n        // and if we can, can we get answer by matching them\\n        if(j < s2.length() && s2[j] == s3[k])\\n            res |= canInterleave(k + 1, i, j + 1, s1, s2, s3, dp);\\n\\n        return dp[k][i][j] = res;\\n    }\\n\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int len1 = s1.length(), len2 = s2.length(), len3 = s3.length();\\n        vector dp(len3 + 1, vector<vector<int>>(len1 + 1, vector<int>(len2 + 1, -1)));\\n        return canInterleave(0, 0, 0, s1, s2, s3, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int len1 = s1.length(), len2 = s2.length(), len3 = s3.length();\\n        vector dp(len3 + 1, vector<vector<int>>(len1 + 1, vector<int>(len2 + 1, false)));\\n\\n        dp[len3][len1][len2] = true;\\n\\n        for(int k = len3 - 1; k >= 0; k--) {\\n            for(int i = len1; i >= 0; i--) {\\n                for(int j = len2; j >= 0; j--) {\\n                    bool res = false;\\n                    if(i < len1 && s1[i] == s3[k])\\n                        res |= dp[k + 1][i + 1][j];\\n\\n                    if(j < len2 && s2[j] == s3[k])\\n                        res |= dp[k + 1][i][j + 1];\\n\\n                    dp[k][i][j] = res;\\n                }\\n            }\\n        }\\n\\n        return dp[0][0][0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int len1 = s1.length(), len2 = s2.length(), len3 = s3.length();\\n        vector curdp(len1 + 1, vector<bool>(len2 + 1, false));\\n        vector nextdp(len1 + 1, vector<bool>(len2 + 1, false));\\n\\n        nextdp[len1][len2] = true;\\n\\n        for(int k = len3 - 1; k >= 0; k--) {\\n            for(int i = len1; i >= 0; i--) {\\n                for(int j = len2; j >= 0; j--) {\\n                    bool res = false;\\n                    if(i < len1 && s1[i] == s3[k])\\n                        res |= nextdp[i + 1][j];\\n\\n                    if(j < len2 && s2[j] == s3[k])\\n                        res |= nextdp[i][j + 1];\\n\\n                    curdp[i][j] = res;\\n                }\\n            }\\n            nextdp = curdp;\\n        }\\n\\n        return nextdp[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957308,
                "title": "easy-video-explanation-recursive-memoization-c-java-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUses Dynamic Progrmming to solve the problem\\n\\n***I\\'ve created a video that breaks down this problem with a thorough explanation, ensuring everyone can easily grasp the concept***\\n\\nhttps://youtu.be/UJVvaO_TuX4\\n\\n# Approach\\nThe code checks if string s3 can be formed by interleaving characters from s1 and s2 while maintaining order. It uses dynamic programming with memoization to efficiently solve.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n     O(x * y)\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(x * y)\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    bool solve(int x,int y,int z,string &s1,string &s2,string &s3)\\n    {   \\n        if(x==0 && y==0 && z==0)\\n            return true;\\n        if(dp[x][y]!=-1)\\n            return dp[x][y];\\n        bool a=false,b=false;\\n        if(x-1>=0 && z-1>=0 && s1[x-1]==s3[z-1])\\n            a=solve(x-1,y,z-1,s1,s2,s3);\\n        if(y-1>=0 && z-1>=0 && s2[y-1]==s3[z-1])\\n            b=solve(x,y-1,z-1,s1,s2,s3);\\n        return dp[x][y]=a||b;\\n    }\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int x=s1.size();\\n        int y=s2.size();\\n        int z=s3.size();\\n        memset(dp,-1,sizeof(dp));\\n        bool ans=solve(x,y,z,s1,s2,s3);\\n        return ans;\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    def solve(self, x, y, z, s1, s2, s3, dp):\\n        if x == 0 and y == 0 and z == 0:\\n            return True\\n        if dp[x][y] != -1:\\n            return dp[x][y]\\n        a, b = False, False\\n        if x - 1 >= 0 and z - 1 >= 0 and s1[x - 1] == s3[z - 1]:\\n            a = self.solve(x - 1, y, z - 1, s1, s2, s3, dp)\\n        if y - 1 >= 0 and z - 1 >= 0 and s2[y - 1] == s3[z - 1]:\\n            b = self.solve(x, y - 1, z - 1, s1, s2, s3, dp)\\n        dp[x][y] = a or b\\n        return dp[x][y]\\n\\n    def isInterleave(self, s1, s2, s3):\\n        x, y, z = len(s1), len(s2), len(s3)\\n        dp = [[-1] * (y + 1) for _ in range(x + 1)]\\n        return self.solve(x, y, z, s1, s2, s3, dp)\\n\\n```\\n```java []\\npublic class Solution {\\n    private int[][] dp;\\n\\n    public boolean solve(int x, int y, int z, String s1, String s2, String s3) {\\n        if (x == 0 && y == 0 && z == 0)\\n            return true;\\n        if (dp[x][y] != -1)\\n            return dp[x][y];\\n        boolean a = false, b = false;\\n        if (x - 1 >= 0 && z - 1 >= 0 && s1.charAt(x - 1) == s3.charAt(z - 1))\\n            a = solve(x - 1, y, z - 1, s1, s2, s3);\\n        if (y - 1 >= 0 && z - 1 >= 0 && s2.charAt(y - 1) == s3.charAt(z - 1))\\n            b = solve(x, y - 1, z - 1, s1, s2, s3);\\n        return dp[x][y] = a || b;\\n    }\\n\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        int x = s1.length();\\n        int y = s2.length();\\n        int z = s3.length();\\n        dp = new int[x + 1][y + 1];\\n        for (int i = 0; i <= x; i++) {\\n            Arrays.fill(dp[i], -1);\\n        }\\n        return solve(x, y, z, s1, s2, s3);\\n    }\\n}\\n```\\n\\n\\n***If the solution resonates with you, I\\'d really appreciate an upvote. Feel free to hit the like button and consider subscribing to my channel, where I\\'ll be sharing more LeetCode challenges.***\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    bool solve(int x,int y,int z,string &s1,string &s2,string &s3)\\n    {   \\n        if(x==0 && y==0 && z==0)\\n            return true;\\n        if(dp[x][y]!=-1)\\n            return dp[x][y];\\n        bool a=false,b=false;\\n        if(x-1>=0 && z-1>=0 && s1[x-1]==s3[z-1])\\n            a=solve(x-1,y,z-1,s1,s2,s3);\\n        if(y-1>=0 && z-1>=0 && s2[y-1]==s3[z-1])\\n            b=solve(x,y-1,z-1,s1,s2,s3);\\n        return dp[x][y]=a||b;\\n    }\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int x=s1.size();\\n        int y=s2.size();\\n        int z=s3.size();\\n        memset(dp,-1,sizeof(dp));\\n        bool ans=solve(x,y,z,s1,s2,s3);\\n        return ans;\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def solve(self, x, y, z, s1, s2, s3, dp):\\n        if x == 0 and y == 0 and z == 0:\\n            return True\\n        if dp[x][y] != -1:\\n            return dp[x][y]\\n        a, b = False, False\\n        if x - 1 >= 0 and z - 1 >= 0 and s1[x - 1] == s3[z - 1]:\\n            a = self.solve(x - 1, y, z - 1, s1, s2, s3, dp)\\n        if y - 1 >= 0 and z - 1 >= 0 and s2[y - 1] == s3[z - 1]:\\n            b = self.solve(x, y - 1, z - 1, s1, s2, s3, dp)\\n        dp[x][y] = a or b\\n        return dp[x][y]\\n\\n    def isInterleave(self, s1, s2, s3):\\n        x, y, z = len(s1), len(s2), len(s3)\\n        dp = [[-1] * (y + 1) for _ in range(x + 1)]\\n        return self.solve(x, y, z, s1, s2, s3, dp)\\n\\n```\n```java []\\npublic class Solution {\\n    private int[][] dp;\\n\\n    public boolean solve(int x, int y, int z, String s1, String s2, String s3) {\\n        if (x == 0 && y == 0 && z == 0)\\n            return true;\\n        if (dp[x][y] != -1)\\n            return dp[x][y];\\n        boolean a = false, b = false;\\n        if (x - 1 >= 0 && z - 1 >= 0 && s1.charAt(x - 1) == s3.charAt(z - 1))\\n            a = solve(x - 1, y, z - 1, s1, s2, s3);\\n        if (y - 1 >= 0 && z - 1 >= 0 && s2.charAt(y - 1) == s3.charAt(z - 1))\\n            b = solve(x, y - 1, z - 1, s1, s2, s3);\\n        return dp[x][y] = a || b;\\n    }\\n\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        int x = s1.length();\\n        int y = s2.length();\\n        int z = s3.length();\\n        dp = new int[x + 1][y + 1];\\n        for (int i = 0; i <= x; i++) {\\n            Arrays.fill(dp[i], -1);\\n        }\\n        return solve(x, y, z, s1, s2, s3);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956632,
                "title": "c-solution-for-interleaving-strings-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem asks whether a string s3 can be formed by interleaving two strings s1 and s2. Interleaving means that the characters of s1 and s2 maintain their relative order while forming s3. To solve this problem efficiently, dynamic programming is used to build a table that stores whether the current substrings of s1 and s2 can form the corresponding substring of s3.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe dynamic programming approach involves using a 2D boolean array dp, where dp[i, j] represents whether the first i characters of s1 and the first j characters of s2 can form the first i + j characters of s3.\\n\\n1. Base case: Initialize dp[0, 0] as true, since empty strings can be interleaved to form an empty string.\\n1. Fill in the base cases for when one of the strings (s1 or s2) is empty.\\n1. For each remaining cell dp[i, j], consider whether the current character of s1 or s2 can be matched with the next character of s3. If yes, then check the previous states (dp[i-1, j] and dp[i, j-1]) to determine if the current interleaving is possible.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution is O(len1 * len2), where len1 is the length of string s1 and len2 is the length of string s2. This is because the 2D dp array has dimensions len1 + 1 and len2 + 1, and each cell is filled once based on the previous cells.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(len1 * len2), as the 2D array dp of size (len1 + 1) x (len2 + 1) is used to store the intermediate results.\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool IsInterleave(string s1, string s2, string s3) {\\n        int len1 = s1.Length, len2 = s2.Length, len3 = s3.Length;\\n        \\n        if (len1 + len2 != len3) {\\n            return false;\\n        }\\n        \\n        bool[,] dp = new bool[len1 + 1, len2 + 1];\\n        \\n        for (int i = 0; i <= len1; i++) {\\n            for (int j = 0; j <= len2; j++) {\\n                if (i == 0 && j == 0) {\\n                    dp[i, j] = true;\\n                } else if (i == 0) {\\n                    dp[i, j] = dp[i, j - 1] && s2[j - 1] == s3[i + j - 1];\\n                } else if (j == 0) {\\n                    dp[i, j] = dp[i - 1, j] && s1[i - 1] == s3[i + j - 1];\\n                } else {\\n                    dp[i, j] = (dp[i - 1, j] && s1[i - 1] == s3[i + j - 1]) ||\\n                               (dp[i, j - 1] && s2[j - 1] == s3[i + j - 1]);\\n                }\\n            }\\n        }\\n        \\n        return dp[len1, len2];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool IsInterleave(string s1, string s2, string s3) {\\n        int len1 = s1.Length, len2 = s2.Length, len3 = s3.Length;\\n        \\n        if (len1 + len2 != len3) {\\n            return false;\\n        }\\n        \\n        bool[,] dp = new bool[len1 + 1, len2 + 1];\\n        \\n        for (int i = 0; i <= len1; i++) {\\n            for (int j = 0; j <= len2; j++) {\\n                if (i == 0 && j == 0) {\\n                    dp[i, j] = true;\\n                } else if (i == 0) {\\n                    dp[i, j] = dp[i, j - 1] && s2[j - 1] == s3[i + j - 1];\\n                } else if (j == 0) {\\n                    dp[i, j] = dp[i - 1, j] && s1[i - 1] == s3[i + j - 1];\\n                } else {\\n                    dp[i, j] = (dp[i - 1, j] && s1[i - 1] == s3[i + j - 1]) ||\\n                               (dp[i, j - 1] && s2[j - 1] == s3[i + j - 1]);\\n                }\\n            }\\n        }\\n        \\n        return dp[len1, len2];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956471,
                "title": "easy-to-understand-memoization-approach-c-with-proper-explanation-of-each-step",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this approach involves breaking down the problem into smaller subproblems, and checking different possibilities.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- There are basically three iterators: i, j, k where i keeps track of s1 string, j and k keeps track of string s2 and s3 respectively.\\n### - **Base Cases**\\n  a.) if iterator k reaches the end of target string i.e., s3 return true as entire string is traversed\\n  b.) if s1 is finished and current character of s2 doesn\\'t matches with s3\\'s current character, then return false as there is no character left that can match with current character of s3\\n  c.) Similarly if s2 ends and current s1[i] doesn\\'t matches with s3[k], return false.\\n d.) If neither s1[i] nor s2[j] matches with s3[k], return false\\n\\n### **- Recursions**\\n a.) If character at ith position of matches with s3[k] ans s2[j] does not match then, move the iterator i and k.\\n b.) If character at jth position of matches with s3[k] ans s1[i] does not match then, move the iterator j and k.\\n c.) If both s1[i] and s2[j] match with s3[k], then we will have two options---- \\nI. take ith element of s1\\nII. take jth element of s2\\nWe will exploit both the possibilities and return true if any of the two cases return true.\\n             \\n\\n\\n# Complexity\\n- Time complexity:\\nO(s1.length() * s2.length())\\n\\n- Space complexity:\\nO(s1.length() * s2.length())\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool solve(int i, int j, int k, string s1, string s2, string s3, vector<vector<int>>&dp)\\n    {\\n        if(k==s3.length()) //base case - a - if s3 is completely traversed\\n            return true;\\n        if(dp[i][j]!=-1) // searching in dp table\\n            return dp[i][j];\\n        /* base case - b - if s1 is finished and current \\n        character of s2 doesn\\'t matches with s3\\'s current character. */\\n        if(i==s1.length() && s2[j]!=s3[k])\\n            return false;\\n        /* base case - c - if s2 is finished and current \\n        character of s1 doesn\\'t matches with s3\\'s current character. */\\n        if(j==s2.length() && s1[i]!=s3[k])\\n            return false;\\n        //base case - d - If neither s1[i] nor s2[j] matches with s3[k], return false\\n        if(s1[i]!=s3[k] && s2[j]!=s3[k])\\n            return false;\\n//RECURSION\\n    //a.\\n        if(s1[i]==s3[k] && s2[j]!=s3[k])\\n            return dp[i][j]=solve(i+1, j, k+1, s1, s2, s3, dp);\\n    //b.\\n        if(s1[i]!=s3[k] && s2[j]==s3[k])\\n            return dp[i][j]=solve(i, j+1, k+1, s1, s2, s3, dp);\\n    //c.\\n        else\\n            return dp[i][j]=(solve(i+1, j, k+1, s1, s2, s3, dp) || solve(i, j+1, k+1, s1, s2, s3, dp));\\n    }\\n    bool isInterleave(string s1, string s2, string s3) {\\n        //if length of string s3 is less than lengthof s1+s2 string then, interleaving not possible\\n        if(s1.length()+s2.length()!=s3.length())\\n            return false;\\n        vector<vector<int>>dp(s1.length()+1, vector<int>(s2.length()+1, -1));\\n        return solve(0, 0, 0, s1, s2, s3, dp);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    bool solve(int i, int j, int k, string s1, string s2, string s3, vector<vector<int>>&dp)\\n    {\\n        if(k==s3.length()) //base case - a - if s3 is completely traversed\\n            return true;\\n        if(dp[i][j]!=-1) // searching in dp table\\n            return dp[i][j];\\n        /* base case - b - if s1 is finished and current \\n        character of s2 doesn\\'t matches with s3\\'s current character. */\\n        if(i==s1.length() && s2[j]!=s3[k])\\n            return false;\\n        /* base case - c - if s2 is finished and current \\n        character of s1 doesn\\'t matches with s3\\'s current character. */\\n        if(j==s2.length() && s1[i]!=s3[k])\\n            return false;\\n        //base case - d - If neither s1[i] nor s2[j] matches with s3[k], return false\\n        if(s1[i]!=s3[k] && s2[j]!=s3[k])\\n            return false;\\n//RECURSION\\n    //a.\\n        if(s1[i]==s3[k] && s2[j]!=s3[k])\\n            return dp[i][j]=solve(i+1, j, k+1, s1, s2, s3, dp);\\n    //b.\\n        if(s1[i]!=s3[k] && s2[j]==s3[k])\\n            return dp[i][j]=solve(i, j+1, k+1, s1, s2, s3, dp);\\n    //c.\\n        else\\n            return dp[i][j]=(solve(i+1, j, k+1, s1, s2, s3, dp) || solve(i, j+1, k+1, s1, s2, s3, dp));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3699287,
                "title": "my-dp-solution-in-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int l = s1.size(), m = s2.size(), n = s3.size();\\n        if(l + m != n) return false;\\n        if (l == 0) return s2 == s3;\\n        if (m == 0) return s1 == s3;\\n        vector<vector<bool>> dp(l+1, vector<bool>(m+1, false));\\n\\n        dp[l][m] = true;\\n        for(int i = 0; i < l; i++) {\\n            if(s1.substr(i, l-i) == s3.substr(m+i, l-i))\\n                dp[i][m] = true;\\n        }\\n        for(int j = 0; j < m; j++) {\\n            if(s2.substr(j, m-j) == s3.substr(l+j, m-j))\\n                dp[l][j] = true;\\n        }\\n\\n        for(int i = l-1; i >= 0; i--) {\\n            for(int j = m-1; j >= 0; j--) {\\n                if(s1[i] == s3[i+j] && s2[j] == s3[i+j]) {\\n                    if(dp[i+1][j] == true || dp[i][j+1] == true) dp[i][j] = true;\\n                }\\n                else if(s1[i] == s3[i+j]) {\\n                    if(dp[i+1][j] == true) dp[i][j] = true;\\n                }\\n                else if(s2[j] == s3[i+j]) {\\n                    if(dp[i][j+1] == true) dp[i][j] = true;\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int l = s1.size(), m = s2.size(), n = s3.size();\\n        if(l + m != n) return false;\\n        if (l == 0) return s2 == s3;\\n        if (m == 0) return s1 == s3;\\n        vector<vector<bool>> dp(l+1, vector<bool>(m+1, false));\\n\\n        dp[l][m] = true;\\n        for(int i = 0; i < l; i++) {\\n            if(s1.substr(i, l-i) == s3.substr(m+i, l-i))\\n                dp[i][m] = true;\\n        }\\n        for(int j = 0; j < m; j++) {\\n            if(s2.substr(j, m-j) == s3.substr(l+j, m-j))\\n                dp[l][j] = true;\\n        }\\n\\n        for(int i = l-1; i >= 0; i--) {\\n            for(int j = m-1; j >= 0; j--) {\\n                if(s1[i] == s3[i+j] && s2[j] == s3[i+j]) {\\n                    if(dp[i+1][j] == true || dp[i][j+1] == true) dp[i][j] = true;\\n                }\\n                else if(s1[i] == s3[i+j]) {\\n                    if(dp[i+1][j] == true) dp[i][j] = true;\\n                }\\n                else if(s2[j] == s3[i+j]) {\\n                    if(dp[i][j+1] == true) dp[i][j] = true;\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592463,
                "title": "java-5-approaches-recursive-memoization-iterative",
                "content": "# Recursive Code \\n```\\nclass Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        Boolean[][][] memo=new Boolean[s1.length()+1][s2.length()+1][s3.length()+1];\\n        return helper(0,0,0,s1,s2,s3,memo);\\n    }\\n    public boolean helper(int i, int j, int k, String s1, String s2, String s3,Boolean[][][] memo){\\n        if(k>=s3.length() ) {\\n            if(i>=s1.length() && j>=s2.length() ) return true;\\n            return false;\\n        }\\n        \\n        if(i>=s1.length() && j>=s2.length()) return false;\\n        if(memo[i][j][k]!=null) return memo[i][j][k];\\n        boolean op1 = false;\\n        if(i<s1.length() && s1.charAt(i)==s3.charAt(k)){\\n            op1=helper(i+1,j,k+1,s1,s2,s3,memo);\\n        }\\n        boolean op2=false;\\n        if(j<s2.length()&& s2.charAt(j)==s3.charAt(k)){\\n            op2=helper(i,j+1,k+1,s1,s2,s3,memo);\\n        }\\n        return memo[i][j][k]= op1 || op2;\\n    }\\n}\\n```\\n# Recursive Code 2\\n```\\nclass Solution{\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n\\tif(s1.length() + s2.length() != s3.length())\\n\\t\\treturn false;\\n\\n\\tBoolean[][] memo = new Boolean[s1.length() + 1][s2.length() + 1];\\n\\n\\treturn helper(s1, s2, s3, 0, 0, memo);\\n}\\n\\npublic boolean helper(String s1, String s2, String s3, int i, int j, Boolean[][] memo) {\\n\\tif(i+j == s3.length())\\n\\t\\treturn true;\\n\\n\\tif(memo[i][j] != null)\\n\\t\\treturn memo[i][j];\\n    boolean op1=false;\\n\\n\\t if(i < s1.length() && s3.charAt(i+j) == s1.charAt(i)) {\\n\\t\\top1 = helper(s1, s2, s3, i+1, j, memo);\\n\\t\\t\\n\\t}\\n    boolean op2 = false;\\n\\tif(j < s2.length() && s3.charAt(i+j) == s2.charAt(j)) {\\n\\t\\top2 = helper(s1, s2, s3, i, j+1, memo);\\n\\t\\t\\n\\t}\\n\\n\\tmemo[i][j] = op1|| op2;\\n\\treturn memo[i][j];\\n}\\n}\\n```\\n# Tabulation Code - 2d\\n```\\nclass Solution{\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n\\tif(s1.length() + s2.length() != s3.length())\\n\\t\\treturn false;\\n\\n\\tboolean dp[][] = new boolean[s1.length() + 1][s2.length() + 1];\\n\\n\\tfor (int i = 0; i <= s1.length(); i++) {\\n\\t\\tfor (int j = 0; j <= s2.length(); j++) {\\n\\t\\t\\tif (i == 0 && j == 0) \\n\\t\\t\\t\\tdp[i][j] = true;\\n\\t\\t\\n\\t\\t\\telse if (i == 0) \\n\\t\\t\\t\\tdp[i][j] = dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1);\\n\\n\\t\\t\\telse if (j == 0) \\n\\t\\t\\t\\tdp[i][j] = dp[i - 1][j] && s1.charAt(i - 1) == s3.charAt(i + j - 1);\\n\\n\\t\\t\\telse \\n\\t\\t\\t\\tdp[i][j] = (dp[i - 1][j] && s1.charAt(i - 1) == s3.charAt(i + j - 1)) \\n\\t\\t\\t\\t\\t\\t\\t\\t|| (dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1));\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[s1.length()][s2.length()];\\n}\\n}\\n```\\n# Tabulation Code - 1d\\n```\\n//Tabulation 1d -> just make dp[i][j] to dp[j]\\nclass Solution{\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n\\tif(s1.length() + s2.length() != s3.length())\\n\\t\\treturn false;\\n\\n\\tboolean dp[] = new boolean[s2.length() + 1];\\n\\n\\tfor (int i = 0; i <= s1.length(); i++) {\\n\\t\\tfor (int j = 0; j <= s2.length(); j++) {\\n\\t\\t\\tif (i == 0 && j == 0) \\n\\t\\t\\t\\tdp[j] = true;\\n\\t\\t\\n\\t\\t\\telse if (i == 0) \\n\\t\\t\\t\\tdp[j] = dp[j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1);\\n\\n\\t\\t\\telse if (j == 0) \\n\\t\\t\\t\\tdp[j] = dp[j] && s1.charAt(i - 1) == s3.charAt(i + j - 1);\\n\\n\\t\\t\\telse \\n\\t\\t\\t\\tdp[j] = (dp[j] && s1.charAt(i - 1) == s3.charAt(i + j - 1)) \\n\\t\\t\\t\\t\\t\\t\\t\\t|| (dp[j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1));\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[s2.length()];\\n}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        Boolean[][][] memo=new Boolean[s1.length()+1][s2.length()+1][s3.length()+1];\\n        return helper(0,0,0,s1,s2,s3,memo);\\n    }\\n    public boolean helper(int i, int j, int k, String s1, String s2, String s3,Boolean[][][] memo){\\n        if(k>=s3.length() ) {\\n            if(i>=s1.length() && j>=s2.length() ) return true;\\n            return false;\\n        }\\n        \\n        if(i>=s1.length() && j>=s2.length()) return false;\\n        if(memo[i][j][k]!=null) return memo[i][j][k];\\n        boolean op1 = false;\\n        if(i<s1.length() && s1.charAt(i)==s3.charAt(k)){\\n            op1=helper(i+1,j,k+1,s1,s2,s3,memo);\\n        }\\n        boolean op2=false;\\n        if(j<s2.length()&& s2.charAt(j)==s3.charAt(k)){\\n            op2=helper(i,j+1,k+1,s1,s2,s3,memo);\\n        }\\n        return memo[i][j][k]= op1 || op2;\\n    }\\n}\\n```\n```\\nclass Solution{\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n\\tif(s1.length() + s2.length() != s3.length())\\n\\t\\treturn false;\\n\\n\\tBoolean[][] memo = new Boolean[s1.length() + 1][s2.length() + 1];\\n\\n\\treturn helper(s1, s2, s3, 0, 0, memo);\\n}\\n\\npublic boolean helper(String s1, String s2, String s3, int i, int j, Boolean[][] memo) {\\n\\tif(i+j == s3.length())\\n\\t\\treturn true;\\n\\n\\tif(memo[i][j] != null)\\n\\t\\treturn memo[i][j];\\n    boolean op1=false;\\n\\n\\t if(i < s1.length() && s3.charAt(i+j) == s1.charAt(i)) {\\n\\t\\top1 = helper(s1, s2, s3, i+1, j, memo);\\n\\t\\t\\n\\t}\\n    boolean op2 = false;\\n\\tif(j < s2.length() && s3.charAt(i+j) == s2.charAt(j)) {\\n\\t\\top2 = helper(s1, s2, s3, i, j+1, memo);\\n\\t\\t\\n\\t}\\n\\n\\tmemo[i][j] = op1|| op2;\\n\\treturn memo[i][j];\\n}\\n}\\n```\n```\\nclass Solution{\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n\\tif(s1.length() + s2.length() != s3.length())\\n\\t\\treturn false;\\n\\n\\tboolean dp[][] = new boolean[s1.length() + 1][s2.length() + 1];\\n\\n\\tfor (int i = 0; i <= s1.length(); i++) {\\n\\t\\tfor (int j = 0; j <= s2.length(); j++) {\\n\\t\\t\\tif (i == 0 && j == 0) \\n\\t\\t\\t\\tdp[i][j] = true;\\n\\t\\t\\n\\t\\t\\telse if (i == 0) \\n\\t\\t\\t\\tdp[i][j] = dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1);\\n\\n\\t\\t\\telse if (j == 0) \\n\\t\\t\\t\\tdp[i][j] = dp[i - 1][j] && s1.charAt(i - 1) == s3.charAt(i + j - 1);\\n\\n\\t\\t\\telse \\n\\t\\t\\t\\tdp[i][j] = (dp[i - 1][j] && s1.charAt(i - 1) == s3.charAt(i + j - 1)) \\n\\t\\t\\t\\t\\t\\t\\t\\t|| (dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1));\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[s1.length()][s2.length()];\\n}\\n}\\n```\n```\\n//Tabulation 1d -> just make dp[i][j] to dp[j]\\nclass Solution{\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n\\tif(s1.length() + s2.length() != s3.length())\\n\\t\\treturn false;\\n\\n\\tboolean dp[] = new boolean[s2.length() + 1];\\n\\n\\tfor (int i = 0; i <= s1.length(); i++) {\\n\\t\\tfor (int j = 0; j <= s2.length(); j++) {\\n\\t\\t\\tif (i == 0 && j == 0) \\n\\t\\t\\t\\tdp[j] = true;\\n\\t\\t\\n\\t\\t\\telse if (i == 0) \\n\\t\\t\\t\\tdp[j] = dp[j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1);\\n\\n\\t\\t\\telse if (j == 0) \\n\\t\\t\\t\\tdp[j] = dp[j] && s1.charAt(i - 1) == s3.charAt(i + j - 1);\\n\\n\\t\\t\\telse \\n\\t\\t\\t\\tdp[j] = (dp[j] && s1.charAt(i - 1) == s3.charAt(i + j - 1)) \\n\\t\\t\\t\\t\\t\\t\\t\\t|| (dp[j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1));\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[s2.length()];\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3353694,
                "title": "super-super-easy-to-understand-java-sol",
                "content": "\\n```\\nclass Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        if(s1.length() + s2.length() != s3.length()) return false;\\n        this.s1 = s1;\\n        this.s2 = s2;\\n        this.s3 = s3;\\n        dp = new int[s1.length() + 1][s2.length() + 1];\\n        return helper(0, 0, 0);\\n    }\\n\\n    String s1;\\n    String s2;\\n    String s3;\\n    int[][] dp;\\n\\n    private boolean helper(int i, int j, int k) {\\n        boolean isMatch = false;\\n        // base case\\n        if(k == s3.length()) return true;\\n        \\n        // we don\\'t have to calculate it again, just return result\\n        if(dp[i][j] != 0) return dp[i][j] == 1;\\n\\n        // if s1 matches pick s1\\n        if(i < s1.length() && s1.charAt(i) == s3.charAt(k)) {\\n            isMatch = isMatch || helper(i + 1, j, k + 1);\\n        }\\n\\n        // if s2 matches pick s2\\n        if(j < s2.length() && s2.charAt(j) == s3.charAt(k)) {\\n            isMatch = isMatch || helper(i, j + 1, k + 1);\\n        }\\n\\n        // memorize the final answer\\n        dp[i][j] = isMatch ? 1 : -1;\\n\\n        return isMatch;\\n    }   \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        if(s1.length() + s2.length() != s3.length()) return false;\\n        this.s1 = s1;\\n        this.s2 = s2;\\n        this.s3 = s3;\\n        dp = new int[s1.length() + 1][s2.length() + 1];\\n        return helper(0, 0, 0);\\n    }\\n\\n    String s1;\\n    String s2;\\n    String s3;\\n    int[][] dp;\\n\\n    private boolean helper(int i, int j, int k) {\\n        boolean isMatch = false;\\n        // base case\\n        if(k == s3.length()) return true;\\n        \\n        // we don\\'t have to calculate it again, just return result\\n        if(dp[i][j] != 0) return dp[i][j] == 1;\\n\\n        // if s1 matches pick s1\\n        if(i < s1.length() && s1.charAt(i) == s3.charAt(k)) {\\n            isMatch = isMatch || helper(i + 1, j, k + 1);\\n        }\\n\\n        // if s2 matches pick s2\\n        if(j < s2.length() && s2.charAt(j) == s3.charAt(k)) {\\n            isMatch = isMatch || helper(i, j + 1, k + 1);\\n        }\\n\\n        // memorize the final answer\\n        dp[i][j] = isMatch ? 1 : -1;\\n\\n        return isMatch;\\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734441,
                "title": "c",
                "content": "```\\nbool isInterleave(char * s1, char * s2, char * s3){\\n    int n1 = strlen(s1);\\n    int n2 = strlen(s2);\\n    int n3 = strlen(s3);\\n    if((n1 + n2) != n3)\\n        return false;\\n    if(n1 == 0){\\n        if(strcmp(s2, s3) == 0)\\n            return true;\\n        else\\n            return false;\\n    }\\n    if(n2 == 0){\\n        if(strcmp(s1, s3) == 0)\\n            return true;\\n        else\\n            return false;\\n    }\\n    if(s3[n3-1] != s1[n1-1]  &&  s3[n3-1] != s2[n2-1])\\n        return false;\\n    if(s3[0] != s1[0]  &&  s3[0] != s2[0])\\n        return false;\\n    \\n    bool** dp = malloc((n1+1) * sizeof(bool*));\\n    for(int i = 0; i <= n1; i++){\\n        dp[i] = calloc((n2+1), sizeof(bool));\\n    }\\n\\n    dp[0][0] = true;\\n    for(int i = 1; i <= n1; i++){\\n        dp[i][0] = (dp[i-1][0]== true && (s1[i-1] == s3[i-1]));\\n    }\\n    for(int j = 1; j <= n2; j++){\\n        dp[0][j] = (dp[0][j-1]== true && (s2[j-1] == s3[j-1]));\\n    }\\n    \\n    for(int i = 1; i <= n1; i++){\\n        for(int j = 1; j <= n2; j++){\\n            if((s1[i-1] == s3[i+j-1]) && dp[i-1][j]== true)\\n                dp[i][j] = true;\\n            else if((s2[j-1] == s3[i+j-1]) && dp[i][j-1] == true)\\n                dp[i][j] = true;\\n        }\\n    }\\n\\n    return dp[n1][n2];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool isInterleave(char * s1, char * s2, char * s3){\\n    int n1 = strlen(s1);\\n    int n2 = strlen(s2);\\n    int n3 = strlen(s3);\\n    if((n1 + n2) != n3)\\n        return false;\\n    if(n1 == 0){\\n        if(strcmp(s2, s3) == 0)\\n            return true;\\n        else\\n            return false;\\n    }\\n    if(n2 == 0){\\n        if(strcmp(s1, s3) == 0)\\n            return true;\\n        else\\n            return false;\\n    }\\n    if(s3[n3-1] != s1[n1-1]  &&  s3[n3-1] != s2[n2-1])\\n        return false;\\n    if(s3[0] != s1[0]  &&  s3[0] != s2[0])\\n        return false;\\n    \\n    bool** dp = malloc((n1+1) * sizeof(bool*));\\n    for(int i = 0; i <= n1; i++){\\n        dp[i] = calloc((n2+1), sizeof(bool));\\n    }\\n\\n    dp[0][0] = true;\\n    for(int i = 1; i <= n1; i++){\\n        dp[i][0] = (dp[i-1][0]== true && (s1[i-1] == s3[i-1]));\\n    }\\n    for(int j = 1; j <= n2; j++){\\n        dp[0][j] = (dp[0][j-1]== true && (s2[j-1] == s3[j-1]));\\n    }\\n    \\n    for(int i = 1; i <= n1; i++){\\n        for(int j = 1; j <= n2; j++){\\n            if((s1[i-1] == s3[i+j-1]) && dp[i-1][j]== true)\\n                dp[i][j] = true;\\n            else if((s2[j-1] == s3[i+j-1]) && dp[i][j-1] == true)\\n                dp[i][j] = true;\\n        }\\n    }\\n\\n    return dp[n1][n2];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2491750,
                "title": "c-three-different-method-approach-with-most-optimal-solution",
                "content": "```\\nclass Solution {\\n    \\n    //1. Top Down Approach\\n    bool SolveByMemo(string s1, string s2, string s3, vector<vector<int>> &dp)\\n    {\\n        int i = s1.length() , j = s2.length();\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        if(s3.empty())\\n            return dp[i][j] = (s1.empty() && s2.empty());\\n        \\n        if(s1.empty())\\n            return dp[i][j] = (s2 == s3);\\n        if(s2.empty())\\n            return dp[i][j] = (s1 == s3);\\n        \\n        if(s1[0] == s3[0] && s2[0] == s3[0])\\n            return dp[i][j] = SolveByMemo(s1.substr(1) , s2 , s3.substr(1) , dp) || SolveByMemo(s1 , s2.substr(1) , s3.substr(1), dp) ;\\n        if(s1[0] == s3[0] )\\n            return dp[i][j] = SolveByMemo(s1.substr(1) , s2 , s3.substr(1), dp);\\n        if(s2[0] == s3[0] )\\n            return dp[i][j] = SolveByMemo(s1 , s2.substr(1) , s3.substr(1), dp) ;\\n        \\n        return dp[i][j] = false;\\n        \\n    }\\n    \\n    // 2. Bottom UP Approach\\n    bool SolveByTab(string s1 , string s2 , string s3)\\n    {\\n         vector<vector<int>> dp(s1.length()+1, vector<int> (s2.length()+1, 0));\\n        \\n        for(int i = 0 ; i<= s1.length(); i++)\\n        {\\n            for(int j = 0; j<= s2.length() ; j++)\\n            {\\n                int k = i+j ;\\n                if(i == 0 && j == 0)\\n                   dp[0][0]  = 1;\\n                else if( i == 0)\\n                {\\n                    if(s2[j-1] == s3[k-1])\\n                        dp[i][j] = dp[i][j-1];\\n                }\\n                else if(j == 0)\\n                {\\n                    if(s1[i-1] == s3[k-1])\\n                        dp[i][j] = dp[i-1][j];\\n                }\\n                else\\n                {\\n                   dp[i][j] = (s1[i-1] == s3[k-1] && dp[i-1][j] || s2[j-1] == s3[k-1] && dp[i][j-1]);          \\n                }    \\n            }       \\n        }\\n        \\n        return dp[s1.length()][s2.length()];\\n    }\\n    \\n    // 3. Bottom Up Approach with Space Optimisation\\n      bool SolveSpaceOptimised(string s1 , string s2 , string s3)\\n    {\\n          if(s1.empty())\\n              return s2 == s3;\\n          if(s2.empty())\\n              return s1 == s3;\\n          \\n         vector<int> prev (s2.length()+1, 0);\\n         vector<int> curr (s2.length()+1, 0);\\n          \\n        for(int i = 0 ; i<= s1.length(); i++)\\n        {\\n            for(int j = 0; j<= s2.length() ; j++)\\n            {\\n                int k = i+j ;\\n                if(i == 0 && j == 0)\\n                  curr[0] = 1;\\n                else if( i == 0)\\n                {\\n                    if(s2[j-1] == s3[k-1])\\n                        curr[j] = curr[j-1];\\n                }\\n                else if(j == 0)\\n                {\\n                    if(s1[i-1] == s3[k-1])\\n                        curr[j] = prev[j];\\n                }\\n                else\\n                {\\n                   curr[j] = (s1[i-1] == s3[k-1] && prev[j] || s2[j-1] == s3[k-1] && curr[j-1]);\\n                }    \\n            }\\n            \\n            prev = curr;\\n        }\\n          \\n        return curr[s2.length()];\\n    }\\n    \\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n            \\n        if(s1.length() + s2.length() != s3.length())\\n            return false;\\n        // 1. Top Down Approach\\n        // vector<vector<int>> dp(s1.length()+1, vector<int> (s2.length()+1, -1));\\n        // return SolveByMemo(s1 , s2 , s3 , dp);\\n        \\n        // 2. Bottom Up Approach\\n         return SolveByTab(s1, s2 , s3);\\n        \\n        // 2. Bottom Up Approach + Space optimised\\n        return SolveSpaceOptimised(s1, s2 , s3);\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    \\n    //1. Top Down Approach\\n    bool SolveByMemo(string s1, string s2, string s3, vector<vector<int>> &dp)\\n    {\\n        int i = s1.length() , j = s2.length();\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        if(s3.empty())\\n            return dp[i][j] = (s1.empty() && s2.empty());\\n        \\n        if(s1.empty())\\n            return dp[i][j] = (s2 == s3);\\n        if(s2.empty())\\n            return dp[i][j] = (s1 == s3);\\n        \\n        if(s1[0] == s3[0] && s2[0] == s3[0])\\n            return dp[i][j] = SolveByMemo(s1.substr(1) , s2 , s3.substr(1) , dp) || SolveByMemo(s1 , s2.substr(1) , s3.substr(1), dp) ;\\n        if(s1[0] == s3[0] )\\n            return dp[i][j] = SolveByMemo(s1.substr(1) , s2 , s3.substr(1), dp);\\n        if(s2[0] == s3[0] )\\n            return dp[i][j] = SolveByMemo(s1 , s2.substr(1) , s3.substr(1), dp) ;\\n        \\n        return dp[i][j] = false;\\n        \\n    }\\n    \\n    // 2. Bottom UP Approach\\n    bool SolveByTab(string s1 , string s2 , string s3)\\n    {\\n         vector<vector<int>> dp(s1.length()+1, vector<int> (s2.length()+1, 0));\\n        \\n        for(int i = 0 ; i<= s1.length(); i++)\\n        {\\n            for(int j = 0; j<= s2.length() ; j++)\\n            {\\n                int k = i+j ;\\n                if(i == 0 && j == 0)\\n                   dp[0][0]  = 1;\\n                else if( i == 0)\\n                {\\n                    if(s2[j-1] == s3[k-1])\\n                        dp[i][j] = dp[i][j-1];\\n                }\\n                else if(j == 0)\\n                {\\n                    if(s1[i-1] == s3[k-1])\\n                        dp[i][j] = dp[i-1][j];\\n                }\\n                else\\n                {\\n                   dp[i][j] = (s1[i-1] == s3[k-1] && dp[i-1][j] || s2[j-1] == s3[k-1] && dp[i][j-1]);          \\n                }    \\n            }       \\n        }\\n        \\n        return dp[s1.length()][s2.length()];\\n    }\\n    \\n    // 3. Bottom Up Approach with Space Optimisation\\n      bool SolveSpaceOptimised(string s1 , string s2 , string s3)\\n    {\\n          if(s1.empty())\\n              return s2 == s3;\\n          if(s2.empty())\\n              return s1 == s3;\\n          \\n         vector<int> prev (s2.length()+1, 0);\\n         vector<int> curr (s2.length()+1, 0);\\n          \\n        for(int i = 0 ; i<= s1.length(); i++)\\n        {\\n            for(int j = 0; j<= s2.length() ; j++)\\n            {\\n                int k = i+j ;\\n                if(i == 0 && j == 0)\\n                  curr[0] = 1;\\n                else if( i == 0)\\n                {\\n                    if(s2[j-1] == s3[k-1])\\n                        curr[j] = curr[j-1];\\n                }\\n                else if(j == 0)\\n                {\\n                    if(s1[i-1] == s3[k-1])\\n                        curr[j] = prev[j];\\n                }\\n                else\\n                {\\n                   curr[j] = (s1[i-1] == s3[k-1] && prev[j] || s2[j-1] == s3[k-1] && curr[j-1]);\\n                }    \\n            }\\n            \\n            prev = curr;\\n        }\\n          \\n        return curr[s2.length()];\\n    }\\n    \\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n            \\n        if(s1.length() + s2.length() != s3.length())\\n            return false;\\n        // 1. Top Down Approach\\n        // vector<vector<int>> dp(s1.length()+1, vector<int> (s2.length()+1, -1));\\n        // return SolveByMemo(s1 , s2 , s3 , dp);\\n        \\n        // 2. Bottom Up Approach\\n         return SolveByTab(s1, s2 , s3);\\n        \\n        // 2. Bottom Up Approach + Space optimised\\n        return SolveSpaceOptimised(s1, s2 , s3);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2249713,
                "title": "dp-easy-solution-0ms-memoization-easy-and-simple-with-comments",
                "content": "DP solution (memoization)\\nTC - O(n)\\n```\\nclass Solution {\\npublic:\\n    bool f(int i,int j, int k, string &s1, string &s2, string &s3, vector<vector<int>> &dp){\\n        //base cases\\n        if(i==s1.size() && j==s2.size() && k==s3.size()) return true;\\n        if(i>s1.size() || j>s2.size()) return false;\\n        \\n        //memoization\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        //if both are same then check for both i.e. recursion\\n        if(s1[i]==s3[k] && s2[j]==s3[k]){\\n            return dp[i][j] = (f(i+1,j,k+1,s1,s2,s3,dp) || f(i,j+1,k+1,s1,s2,s3,dp));\\n        }\\n        else if(s1[i]==s3[k]){\\n            return dp[i][j] = f(i+1,j,k+1,s1,s2,s3,dp);\\n        }\\n        else if(s2[j]==s3[k]){\\n            return dp[i][j] = f(i,j+1,k+1,s1,s2,s3,dp);\\n        }else{\\n            return false;\\n        }\\n    }\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n=s1.length(),m=s2.length(),len=s3.length();\\n        //initialization of dp\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        return f(0,0,0,s1,s2,s3,dp);\\n    }\\n};\\n```\\nwe can do it with tabulation and then space optimization also.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool f(int i,int j, int k, string &s1, string &s2, string &s3, vector<vector<int>> &dp){\\n        //base cases\\n        if(i==s1.size() && j==s2.size() && k==s3.size()) return true;\\n        if(i>s1.size() || j>s2.size()) return false;\\n        \\n        //memoization\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        //if both are same then check for both i.e. recursion\\n        if(s1[i]==s3[k] && s2[j]==s3[k]){\\n            return dp[i][j] = (f(i+1,j,k+1,s1,s2,s3,dp) || f(i,j+1,k+1,s1,s2,s3,dp));\\n        }\\n        else if(s1[i]==s3[k]){\\n            return dp[i][j] = f(i+1,j,k+1,s1,s2,s3,dp);\\n        }\\n        else if(s2[j]==s3[k]){\\n            return dp[i][j] = f(i,j+1,k+1,s1,s2,s3,dp);\\n        }else{\\n            return false;\\n        }\\n    }\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n=s1.length(),m=s2.length(),len=s3.length();\\n        //initialization of dp\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        return f(0,0,0,s1,s2,s3,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2249366,
                "title": "easy-understandable-recursion-with-memoization-3d-dp",
                "content": "```\\nclass Solution {\\n    Boolean[][][] dp;\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        \\n        int s1Len = s1.length(), s2Len = s2.length(), s3Len = s3.length();\\n        \\n        dp = new Boolean[s1Len+1][s2Len+1][s3Len+1];\\n\\t\\t\\n\\t\\t// If length of s1 + s2 is not equal with that of s3 then return false bcz s3 is created by combining s1 and s2 only\\n        if((s1Len+s2Len) != s3Len) return false;\\n        \\n        return solve(s1,s2,s3,0,0,0);\\n    }\\n    \\n    private boolean solve(String s1, String s2, String s3, int i1, int i2, int j){\\n        \\n        // Base condition\\n        if(j == s3.length()) return true;\\n        \\n        if(dp[i1][i2][j] != null) return dp[i1][i2][j];\\n        \\n        // If any of string (s1 or s2) ends, then continue comparing with the remaining string\\n        if(i1 == s1.length() && i2 != s2.length())\\n            return dp[i1][i2][j] = (s2.charAt(i2)==s3.charAt(j)) && solve(s1,s2,s3,i1,i2+1,j+1);\\n        else if(i1 != s1.length() && i2 == s2.length())\\n            return dp[i1][i2][j] = (s1.charAt(i1)==s3.charAt(j)) && solve(s1,s2,s3,i1+1,i2,j+1);\\n        \\n        char s1C = s1.charAt(i1), s2C = s2.charAt(i2), s3C = s3.charAt(j);\\n        \\n        // If char of s1 matches with s3 but not of s2 \\n        if(s1C == s3C && s2C != s3C)\\n            return dp[i1][i2][j] = solve(s1,s2,s3,i1+1,i2,j+1);\\n        \\n        // If char of s2 matches with s3 but not of s1\\n        else if (s1C != s3C && s2C == s3C)\\n            return dp[i1][i2][j] = solve(s1,s2,s3,i1,i2+1,j+1);\\n        \\n        // If char of both s1 and s2 matches with s3\\n        else if(s1C == s3C && s2C == s3C)\\n            return dp[i1][i2][j] = solve(s1,s2,s3,i1,i2+1,j+1) || solve(s1,s2,s3,i1+1,i2,j+1);\\n        \\n        // If no char of either s1 or s2 matching with s3, then return false as the char in s3 is not a part of any substring of s1 and s2\\n        else return dp[i1][i2][j] = false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    Boolean[][][] dp;\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        \\n        int s1Len = s1.length(), s2Len = s2.length(), s3Len = s3.length();\\n        \\n        dp = new Boolean[s1Len+1][s2Len+1][s3Len+1];\\n\\t\\t\\n\\t\\t// If length of s1 + s2 is not equal with that of s3 then return false bcz s3 is created by combining s1 and s2 only\\n        if((s1Len+s2Len) != s3Len) return false;\\n        \\n        return solve(s1,s2,s3,0,0,0);\\n    }\\n    \\n    private boolean solve(String s1, String s2, String s3, int i1, int i2, int j){\\n        \\n        // Base condition\\n        if(j == s3.length()) return true;\\n        \\n        if(dp[i1][i2][j] != null) return dp[i1][i2][j];\\n        \\n        // If any of string (s1 or s2) ends, then continue comparing with the remaining string\\n        if(i1 == s1.length() && i2 != s2.length())\\n            return dp[i1][i2][j] = (s2.charAt(i2)==s3.charAt(j)) && solve(s1,s2,s3,i1,i2+1,j+1);\\n        else if(i1 != s1.length() && i2 == s2.length())\\n            return dp[i1][i2][j] = (s1.charAt(i1)==s3.charAt(j)) && solve(s1,s2,s3,i1+1,i2,j+1);\\n        \\n        char s1C = s1.charAt(i1), s2C = s2.charAt(i2), s3C = s3.charAt(j);\\n        \\n        // If char of s1 matches with s3 but not of s2 \\n        if(s1C == s3C && s2C != s3C)\\n            return dp[i1][i2][j] = solve(s1,s2,s3,i1+1,i2,j+1);\\n        \\n        // If char of s2 matches with s3 but not of s1\\n        else if (s1C != s3C && s2C == s3C)\\n            return dp[i1][i2][j] = solve(s1,s2,s3,i1,i2+1,j+1);\\n        \\n        // If char of both s1 and s2 matches with s3\\n        else if(s1C == s3C && s2C == s3C)\\n            return dp[i1][i2][j] = solve(s1,s2,s3,i1,i2+1,j+1) || solve(s1,s2,s3,i1+1,i2,j+1);\\n        \\n        // If no char of either s1 or s2 matching with s3, then return false as the char in s3 is not a part of any substring of s1 and s2\\n        else return dp[i1][i2][j] = false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2248912,
                "title": "dp-memoization",
                "content": "\\n\\n    class Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        if(s1.length()+s2.length()!=s3.length())return false;\\n        int dp[][][]=new int[s1.length()+1][s2.length()+1][s3.length()];\\n        for(int p[][]:dp){\\n            for(int t1[]:p){\\n                Arrays.fill(t1,-1);\\n            }\\n        }\\n        return f(0,0,0,s1,s2,s3,dp);\\n    }\\n    public boolean f(int i,int j,int k,String s1,String s2,String s3,int dp[][][]){\\n        if(i>=s1.length() && j>=s2.length() && k>=s3.length())return true;\\n        \\n        if(dp[i][j][k]!=-1)return dp[i][j][k]==0?false:true;\\n        boolean up=false;\\n        //checking if from both string characters are equal\\n        if((i<s1.length() && s1.charAt(i)==s3.charAt(k)) && (j<s2.length() && s2.charAt(j)==s3.charAt(k))){\\n            boolean take=f(i+1,j,k+1,s1,s2,s3,dp);\\n            boolean not=f(i,j+1,k+1,s1,s2,s3,dp);\\n            up=take || not;\\n        }\\n         // checking if from first string characters are equal  \\n        else if(i<s1.length() && s1.charAt(i)==s3.charAt(k)){\\n            up=f(i+1,j,k+1,s1,s2,s3,dp);\\n        }\\n        //checking if from second string characters are equal  \\n        else if(j<s2.length() && s2.charAt(j)==s3.charAt(k)){\\n            up=f(i,j+1,k+1,s1,s2,s3,dp);\\n        }\\n        dp[i][j][k]=(up==false)?0:1;\\n        return up;\\n    }\\n}",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        if(s1.length()+s2.length()!=s3.length())return false;\\n        int dp[][][]=new int[s1.length()+1][s2.length()+1][s3.length()];\\n        for(int p[][]:dp){\\n            for(int t1[]:p){\\n                Arrays.fill(t1,-1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2248489,
                "title": "java-easy-solution-with-explanation",
                "content": "\\'\\'\\'\\n class Solution {\\n\\tpublic boolean isInterleave(String s1, String s2, String s3) {\\n\\t\\tint m = s1.length(); \\n\\t\\tint n = s2.length();\\n\\n\\t\\t// Base case\\n\\t\\tif(s3.length() != m + n) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tif(s1.length() == 0) {\\n\\t\\t\\treturn s2.equals(s3);\\n\\t\\t} \\n\\t\\tif(s2.length() == 0) {\\n\\t\\t\\treturn s1.equals(s3);\\n\\t\\t}\\n\\n\\t\\t// dp[i][j] represents can we use i characters from s1 and j characters from s2 \\n\\t\\t// to form the first i+j characters from s3\\n\\t\\tboolean[][] dp = new boolean[m+1][n+1];\\n\\n\\t\\t// base case using 0 characters from both means yes. \\n\\t\\tdp[0][0] = true;\\n\\n\\t\\tfor(int i = 1; i < m+1; i++) {\\n\\t\\t\\tdp[i][0] = dp[i-1][0] && s1.charAt(i-1) == s3.charAt(i-1);\\n\\t\\t}\\n\\n\\t\\tfor(int i = 1; i < n+1; i++) {\\n\\t\\t\\tdp[0][i] = dp[0][i-1] && s2.charAt(i-1) == s3.charAt(i-1);\\n\\t\\t}\\n\\n\\t\\t// the recursive relationship\\n\\t\\tfor(int i = 1; i < m+1; i++) {\\n\\t\\t\\tfor(int j = 1; j < n+1; j++) {\\n\\t\\t\\t\\tdp[i][j] = (dp[i-1][j] && s1.charAt(i-1) == s3.charAt(i+j-1)) \\n\\t\\t\\t\\t\\t\\t|| (dp[i][j-1] && s2.charAt(j-1) == s3.charAt(i+j-1));\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn dp[m][n];\\n\\t}\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\tpublic boolean isInterleave(String s1, String s2, String s3) {\\n\\t\\tint m = s1.length(); \\n\\t\\tint n = s2.length();\\n\\n\\t\\t// Base case\\n\\t\\tif(s3.length() != m + n) {\\n\\t\\t\\treturn false;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1823087,
                "title": "super-fast-golang",
                "content": "2D DP matrix is faster than 1D DP array (100% vs 40%), for some reason. May be due to underlying slice operations. \\nBoth are included below.\\n\\n```\\nfunc isInterleave(s1 string, s2 string, s3 string) bool {\\n    /*\\n\\t\\n\\t2D DP matrix: \\n\\tPlace s1 and s2 on axes. \\n\\tmatrix[i][j] represents isInterleave(s1[:i], s2[:j], s3[:i+j]).\\n    \\n\\t       a a b c c\\n        0 1 2 3 4 5\\n      0 t t t f f f\\n    d 1 f f t t f f  \\n    b 2 f f t t t f\\n    b 3 f f t t t f\\n    c 4 f f t t t f\\n    a 5 f f f f t t\\n      \\n    */\\n    if s1 == \"\" || s2 == \"\" {\\n        return s3 == s1 + s2\\n    }\\n    if len(s1) + len(s2) != len(s3) {\\n        return false\\n    }\\n    dp := make([][]bool, len(s1)+1)\\n    for i := range dp {\\n        dp[i] = make([]bool, len(s2)+1)\\n    }\\n    for i := 0; i < len(dp); i++ {\\n        for j := 0; j < len(dp[0]); j++ {\\n            if i == 0 || j == 0 {\\n                dp[i][j] = s1[:i] + s2[:j] == s3[:i+j]\\n                continue\\n            }\\n            // check top\\n            if dp[i-1][j] && s1[i-1] == s3[i+j-1] {\\n                dp[i][j] = true\\n            }\\n            // check left\\n            if dp[i][j-1] && s2[j-1] == s3[i+j-1] {\\n                dp[i][j] = true\\n            }\\n        }\\n    }\\n    return dp[len(s1)][len(s2)]\\n}\\n```\\n\\nSince we are going row by row, we only need to hold two rows in memory (current and previous).\\n1D DP slice solution here.\\n\\n```\\nfunc isInterleave(s1 string, s2 string, s3 string) bool {\\n    if s1 == \"\" || s2 == \"\" {\\n        return s3 == s1 + s2\\n    }\\n    if len(s1) + len(s2) != len(s3) {\\n        return false\\n    }\\n    dp := make([]bool, len(s2)+1)\\n    for i := 0; i <= len(s1); i++ {\\n        nextDP := make([]bool, len(s2)+1)\\n        for j := 0; j <= len(s2); j++ {\\n            if i == 0 || j == 0 {\\n                nextDP[j] = s1[:i] + s2[:j] == s3[:i+j]\\n                continue\\n            }\\n            // check top\\n            if dp[j] && s1[i-1] == s3[i+j-1] {\\n                nextDP[j] = true\\n            }\\n            // check left\\n            if nextDP[j-1] && s2[j-1] == s3[i+j-1] {\\n                nextDP[j] = true\\n            }\\n        }\\n        dp = nextDP\\n    }\\n    return dp[len(s2)]\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc isInterleave(s1 string, s2 string, s3 string) bool {\\n    /*\\n\\t\\n\\t2D DP matrix: \\n\\tPlace s1 and s2 on axes. \\n\\tmatrix[i][j] represents isInterleave(s1[:i], s2[:j], s3[:i+j]).\\n    \\n\\t       a a b c c\\n        0 1 2 3 4 5\\n      0 t t t f f f\\n    d 1 f f t t f f  \\n    b 2 f f t t t f\\n    b 3 f f t t t f\\n    c 4 f f t t t f\\n    a 5 f f f f t t\\n      \\n    */\\n    if s1 == \"\" || s2 == \"\" {\\n        return s3 == s1 + s2\\n    }\\n    if len(s1) + len(s2) != len(s3) {\\n        return false\\n    }\\n    dp := make([][]bool, len(s1)+1)\\n    for i := range dp {\\n        dp[i] = make([]bool, len(s2)+1)\\n    }\\n    for i := 0; i < len(dp); i++ {\\n        for j := 0; j < len(dp[0]); j++ {\\n            if i == 0 || j == 0 {\\n                dp[i][j] = s1[:i] + s2[:j] == s3[:i+j]\\n                continue\\n            }\\n            // check top\\n            if dp[i-1][j] && s1[i-1] == s3[i+j-1] {\\n                dp[i][j] = true\\n            }\\n            // check left\\n            if dp[i][j-1] && s2[j-1] == s3[i+j-1] {\\n                dp[i][j] = true\\n            }\\n        }\\n    }\\n    return dp[len(s1)][len(s2)]\\n}\\n```\n```\\nfunc isInterleave(s1 string, s2 string, s3 string) bool {\\n    if s1 == \"\" || s2 == \"\" {\\n        return s3 == s1 + s2\\n    }\\n    if len(s1) + len(s2) != len(s3) {\\n        return false\\n    }\\n    dp := make([]bool, len(s2)+1)\\n    for i := 0; i <= len(s1); i++ {\\n        nextDP := make([]bool, len(s2)+1)\\n        for j := 0; j <= len(s2); j++ {\\n            if i == 0 || j == 0 {\\n                nextDP[j] = s1[:i] + s2[:j] == s3[:i+j]\\n                continue\\n            }\\n            // check top\\n            if dp[j] && s1[i-1] == s3[i+j-1] {\\n                nextDP[j] = true\\n            }\\n            // check left\\n            if nextDP[j-1] && s2[j-1] == s3[i+j-1] {\\n                nextDP[j] = true\\n            }\\n        }\\n        dp = nextDP\\n    }\\n    return dp[len(s2)]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1470519,
                "title": "recursive-dp-solution-c-0ms-faster-than-100",
                "content": "```class Solution {\\npublic:\\n    int dp[105][105];\\n    bool sol(string& s1,string& s2,string& s3,int i,int j,int k){\\n        if(k==s3.length()){\\n            if(i==s1.length()&&j==s2.length())return dp[i][j]=true;\\n            return false;\\n        }\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        if(s1[i]==s3[k]){\\n            if(s2[j]==s3[k]){\\n                bool a1=sol(s1,s2,s3,i+1,j,k+1);\\n                if(a1==true)return dp[i][j]=true;\\n                return dp[i][j]=sol(s1,s2,s3,i,j+1,k+1);\\n            }\\n            return dp[i][j]=sol(s1,s2,s3,i+1,j,k+1);\\n        }\\n        if(s2[j]==s3[k]){\\n            return dp[i][j]=sol(s1,s2,s3,i,j+1,k+1);\\n        }\\n        return dp[i][j]=false;\\n    }\\n    \\n    bool isInterleave(string s1, string s2, string s3) {\\n        if(s1.length()+s2.length()!=s3.length())return false;\\n        // if(s1+s2==s3||s2+s1==s3)return true;\\n        memset(dp,-1,sizeof(dp));\\n        return sol(s1,s2,s3,0,0,0);\\n    }\\n};```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```class Solution {\\npublic:\\n    int dp[105][105];\\n    bool sol(string& s1,string& s2,string& s3,int i,int j,int k){\\n        if(k==s3.length()){\\n            if(i==s1.length()&&j==s2.length())return dp[i][j]=true;\\n            return false;\\n        }\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        if(s1[i]==s3[k]){\\n            if(s2[j]==s3[k]){\\n                bool a1=sol(s1,s2,s3,i+1,j,k+1);\\n                if(a1==true)return dp[i][j]=true;\\n                return dp[i][j]=sol(s1,s2,s3,i,j+1,k+1);\\n            }\\n            return dp[i][j]=sol(s1,s2,s3,i+1,j,k+1);\\n        }\\n        if(s2[j]==s3[k]){\\n            return dp[i][j]=sol(s1,s2,s3,i,j+1,k+1);\\n        }\\n        return dp[i][j]=false;\\n    }\\n    \\n    bool isInterleave(string s1, string s2, string s3) {\\n        if(s1.length()+s2.length()!=s3.length())return false;\\n        // if(s1+s2==s3||s2+s1==s3)return true;\\n        memset(dp,-1,sizeof(dp));\\n        return sol(s1,s2,s3,0,0,0);\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 1311468,
                "title": "c-4-ms-faster-than-73-89-6-1-mb-less-than-93-05-dp-visualised",
                "content": "```c++\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n\\t\\n\\t/* Input\\n\\t\\n\\t\"aabcc\"\\n\\t\"dbbca\"\\n\\t\"aadbbcbcac\"\\n\\t\\n\\t*/\\n\\n        \\n    if (s1.size() > 100 \\n        || s2.size() > 100 \\n        || s1.size() + s2.size() != s3.size()) {\\n        return false;\\n    }\\n        \\n    int dp[101][101];\\n        \\n    for(int i = 0; i < 101; i++) {\\n        for(int j = 0; j < 101; j++) {\\n            dp[i][j] = 0;\\n        }\\n    }\\n\\n    // If no length then match\\n    dp[0][0] = 1;\\n        \\n    \\n    // Calculate for only s1\\n    for(int i = 0 ; i < s1.size() ; i++ ) {\\n        if( s3[i] == s1[i] ) {\\n            dp[0][i+1] =  dp[0][i];\\n        }\\n    }\\n\\n    // Calculate for only s2 \\n    for(int j = 0 ; j < s2.size() ; j++ ) {\\n        if( s3[j] == s2[j] ) {\\n            dp[j+1][0] = dp[j][0];\\n        }\\n    }\\n\\n    /* dp table lloks like\\n\\t\\n\\t1 1 1 0 0 0 \\n\\t0 0 0 0 0 0 \\n\\t0 0 0 0 0 0 \\n\\t0 0 0 0 0 0 \\n\\t0 0 0 0 0 0 \\n\\t0 0 0 0 0 0 \\n\\t\\n\\t*/\\n        \\n    for (  int j = 1;  j  <=  s2.size() ;  j++ ) {\\n        \\n        for ( int i = 1;  i <= s1.size();  i++ )  {\\n\\n            // if s3[previous] not from s2, then check if s1 match\\n\\t\\t\\t\\n            bool isFromS1 = dp[j][i-1] && s3[i+j-1] == s1[i-1];\\n\\n            // if s3[previous] not from s1, then check if s2 match\\n\\t\\t\\t\\n            bool isFromS2 = dp[j-1][i] && s3[i+j-1] == s2[j-1];\\n\\n            dp[j][i] = isFromS1 || isFromS2;\\n        }\\n    }\\n\\n   /* dp table lloks like\\n\\t\\n\\t1 1 1 0 0 0 \\n\\t0 0 1 1 0 0 \\n\\t0 0 1 1 1 0 \\n\\t0 0 1 0 1 1 \\n\\t0 0 1 1 1 0 \\n\\t0 0 0 0 1 1 \\n\\t\\n\\t*/\\n\\t\\n    return dp[s2.size()][s1.size()];\\n}\\n};\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n\\t\\n\\t/* Input\\n\\t\\n\\t\"aabcc\"\\n\\t\"dbbca\"\\n\\t\"aadbbcbcac\"\\n\\t\\n\\t*/\\n\\n        \\n    if (s1.size() > 100 \\n        || s2.size() > 100 \\n        || s1.size() + s2.size() != s3.size()) {\\n        return false;\\n    }\\n        \\n    int dp[101][101];\\n        \\n    for(int i = 0; i < 101; i++) {\\n        for(int j = 0; j < 101; j++) {\\n            dp[i][j] = 0;\\n        }\\n    }\\n\\n    // If no length then match\\n    dp[0][0] = 1;\\n        \\n    \\n    // Calculate for only s1\\n    for(int i = 0 ; i < s1.size() ; i++ ) {\\n        if( s3[i] == s1[i] ) {\\n            dp[0][i+1] =  dp[0][i];\\n        }\\n    }\\n\\n    // Calculate for only s2 \\n    for(int j = 0 ; j < s2.size() ; j++ ) {\\n        if( s3[j] == s2[j] ) {\\n            dp[j+1][0] = dp[j][0];\\n        }\\n    }\\n\\n    /* dp table lloks like\\n\\t\\n\\t1 1 1 0 0 0 \\n\\t0 0 0 0 0 0 \\n\\t0 0 0 0 0 0 \\n\\t0 0 0 0 0 0 \\n\\t0 0 0 0 0 0 \\n\\t0 0 0 0 0 0 \\n\\t\\n\\t*/\\n        \\n    for (  int j = 1;  j  <=  s2.size() ;  j++ ) {\\n        \\n        for ( int i = 1;  i <= s1.size();  i++ )  {\\n\\n            // if s3[previous] not from s2, then check if s1 match\\n\\t\\t\\t\\n            bool isFromS1 = dp[j][i-1] && s3[i+j-1] == s1[i-1];\\n\\n            // if s3[previous] not from s1, then check if s2 match\\n\\t\\t\\t\\n            bool isFromS2 = dp[j-1][i] && s3[i+j-1] == s2[j-1];\\n\\n            dp[j][i] = isFromS1 || isFromS2;\\n        }\\n    }\\n\\n   /* dp table lloks like\\n\\t\\n\\t1 1 1 0 0 0 \\n\\t0 0 1 1 0 0 \\n\\t0 0 1 1 1 0 \\n\\t0 0 1 0 1 1 \\n\\t0 0 1 1 1 0 \\n\\t0 0 0 0 1 1 \\n\\t\\n\\t*/\\n\\t\\n    return dp[s2.size()][s1.size()];\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1248583,
                "title": "c-from-top-down-memoization-using-map",
                "content": "bool godp(string s1, string s2, string s3, int i, int j, int k, map<pair<int,int>,int> &ma ) {\\n        \\n        int n = s1.length(), m = s2.length(), l = s3.length();\\n        if(k >= l && i >=n && j >= m) {\\n            return 1;\\n        }\\n        if(k >= l)\\n            return 0;\\n        if(ma.find({i,j}) != ma.end()) {\\n            return ma[{i,j}];\\n        }\\n        int op1 = 0, op2 = 0;\\n        if(j < m && s3[k] == s2[j]) {\\n                    op1 = godp(s1,s2,s3,i,j+1,k+1, ma);\\n        }\\n        if(i < n && s3[k] == s1[i]) {\\n            op2 = godp(s1,s2,s3,i+1,j,k+1, ma);\\n        }\\n        return ma[{i,j}] = (op1||op2);\\n    }\\n    \\n    bool isInterleave(string s1, string s2, string s3) {\\n         map<pair<int,int>,int> ma;\\n        int i =0, j = 0, k = 0;\\n        int n = s1.length(), m = s2.length(), l = s3.length(); \\n        return godp(s1,s2,s3,0,0,0,ma);\\n    }",
                "solutionTags": [],
                "code": "bool godp(string s1, string s2, string s3, int i, int j, int k, map<pair<int,int>,int> &ma ) {\\n        \\n        int n = s1.length(), m = s2.length(), l = s3.length();\\n        if(k >= l && i >=n && j >= m) {\\n            return 1;\\n        }\\n        if(k >= l)\\n            return 0;\\n        if(ma.find({i,j}) != ma.end()) {\\n            return ma[{i,j}];\\n        }\\n        int op1 = 0, op2 = 0;\\n        if(j < m && s3[k] == s2[j]) {\\n                    op1 = godp(s1,s2,s3,i,j+1,k+1, ma);\\n        }\\n        if(i < n && s3[k] == s1[i]) {\\n            op2 = godp(s1,s2,s3,i+1,j,k+1, ma);\\n        }\\n        return ma[{i,j}] = (op1||op2);\\n    }\\n    \\n    bool isInterleave(string s1, string s2, string s3) {\\n         map<pair<int,int>,int> ma;\\n        int i =0, j = 0, k = 0;\\n        int n = s1.length(), m = s2.length(), l = s3.length(); \\n        return godp(s1,s2,s3,0,0,0,ma);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1248054,
                "title": "java-easy-3ms-tabulation-tabulation",
                "content": "```\\nclass Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        int n = s1.length();\\n        int m = s2.length();\\n        int q = s3.length();\\n        if(n+m!=q){\\n            return false;\\n        }\\n        boolean dp[][]= new boolean[n+1][m+1];\\n        for(int i = 0;i<=n;i++){\\n            for(int j = 0;j<=m;j++){\\n                if(i==0&&j==0){\\n                    dp[i][j]=true;\\n                }\\n                else if(i==0){\\n                    char a = s3.charAt(j-1);\\n                    char b = s2.charAt(j-1);\\n                    if(a==b&&dp[i][j-1]){\\n                        dp[i][j]=true;\\n                    }\\n                }else if(j==0){\\n                    char a = s3.charAt(i-1);\\n                    char b = s1.charAt(i-1);\\n                    if(a==b&&dp[i-1][j]){\\n                        dp[i][j]=true;\\n                    }\\n                }else{\\n                    if(dp[i][j-1]&&!dp[i-1][j]){\\n                    char a = s2.charAt(j-1);\\n                    char b = s3.charAt(i+j-1);\\n                        if(a==b){\\n                            dp[i][j]=true;\\n                        }\\n                  \\n                }\\n                    else if(dp[i-1][j]&&!dp[i][j-1]){\\n                    char a = s1.charAt(i-1);\\n                    char b = s3.charAt(i+j-1);\\n                        if(a==b){\\n                            dp[i][j]=true;\\n                        }\\n                  \\n                }\\n                    else if(dp[i-1][j]&&dp[i][j-1]){\\n                         char a = s1.charAt(i-1);\\n                        char c = s2.charAt(j-1);\\n                    char b = s3.charAt(i+j-1);\\n                        if(a==b&&a==c){\\n                            dp[i][j]=true;\\n                        }\\n                    }\\n                }\\n                \\n            }\\n        }\\n       return dp[n][m]; \\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/a02d94b5-9c16-4d19-a261-d6873a24911d_1622681113.874321.png)\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        int n = s1.length();\\n        int m = s2.length();\\n        int q = s3.length();\\n        if(n+m!=q){\\n            return false;\\n        }\\n        boolean dp[][]= new boolean[n+1][m+1];\\n        for(int i = 0;i<=n;i++){\\n            for(int j = 0;j<=m;j++){\\n                if(i==0&&j==0){\\n                    dp[i][j]=true;\\n                }\\n                else if(i==0){\\n                    char a = s3.charAt(j-1);\\n                    char b = s2.charAt(j-1);\\n                    if(a==b&&dp[i][j-1]){\\n                        dp[i][j]=true;\\n                    }\\n                }else if(j==0){\\n                    char a = s3.charAt(i-1);\\n                    char b = s1.charAt(i-1);\\n                    if(a==b&&dp[i-1][j]){\\n                        dp[i][j]=true;\\n                    }\\n                }else{\\n                    if(dp[i][j-1]&&!dp[i-1][j]){\\n                    char a = s2.charAt(j-1);\\n                    char b = s3.charAt(i+j-1);\\n                        if(a==b){\\n                            dp[i][j]=true;\\n                        }\\n                  \\n                }\\n                    else if(dp[i-1][j]&&!dp[i][j-1]){\\n                    char a = s1.charAt(i-1);\\n                    char b = s3.charAt(i+j-1);\\n                        if(a==b){\\n                            dp[i][j]=true;\\n                        }\\n                  \\n                }\\n                    else if(dp[i-1][j]&&dp[i][j-1]){\\n                         char a = s1.charAt(i-1);\\n                        char c = s2.charAt(j-1);\\n                    char b = s3.charAt(i+j-1);\\n                        if(a==b&&a==c){\\n                            dp[i][j]=true;\\n                        }\\n                    }\\n                }\\n                \\n            }\\n        }\\n       return dp[n][m]; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1247877,
                "title": "clean-1d-dp-go-solution-beats-100",
                "content": "```\\nfunc isInterleave(s1 string, s2 string, s3 string) bool {\\n\\tif len(s1)+len(s2) != len(s3) {\\n\\t\\treturn false\\n\\t}\\n\\n\\tdp := make([]bool, len(s1)+1)\\n\\tfor i := 0; i < len(s2)+1; i++ {\\n\\t\\tfor j := 0; j < len(s1)+1; j++ {\\n\\t\\t\\tdp[j] = i == 0 && j == 0 || j > 0 && dp[j-1] && s1[j-1] == s3[i+j-1] || i > 0 && dp[j] && s2[i-1] == s3[i+j-1]\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[len(s1)]\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunc isInterleave(s1 string, s2 string, s3 string) bool {\\n\\tif len(s1)+len(s2) != len(s3) {\\n\\t\\treturn false\\n\\t}\\n\\n\\tdp := make([]bool, len(s1)+1)\\n\\tfor i := 0; i < len(s2)+1; i++ {\\n\\t\\tfor j := 0; j < len(s1)+1; j++ {\\n\\t\\t\\tdp[j] = i == 0 && j == 0 || j > 0 && dp[j-1] && s1[j-1] == s3[i+j-1] || i > 0 && dp[j] && s2[i-1] == s3[i+j-1]\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[len(s1)]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1247161,
                "title": "interleaving-string",
                "content": "**Basic intution**\\nthis question is somewhat similar to longest common subsequence which is a very popular dp problem. Here were are selecting last character of s3 and comparing it with  last element of s1 and s2.\\n\\n**Example1**\\n   consider s1=\"abc\",s2=\"adg\" and s3=\"aabcdg\"\\n![image](https://assets.leetcode.com/users/images/fc54b5d6-67c8-451e-af04-0903dc4809ce_1622638700.4142802.png)\\n\\n**Example2**\\n![image](https://assets.leetcode.com/users/images/944f8c3f-b56f-4ed3-b8d4-7040ac82de91_1622639036.6773384.png)\\n\\n\\t\\t\\t\\t\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int t[101][101];\\n    bool lcs(string s1,string s2,string s3,int n1,int n2,int n3){\\n        if(t[n1+1][n2+1]!=-1){\\n            return t[n1+1][n2+1];\\n        }\\n        if(n1<0 and n2<0){\\n            return t[n1+1][n2+1]=true;\\n        }\\n        if(n1<0){\\n            if(s2[n2]==s3[n3]){\\n                return t[n1+1][n2+1]=lcs(s1,s2,s3,n1,n2-1,n3-1);\\n            }\\n            else{\\n                return t[n1+1][n2+1]=false;\\n            }\\n        }\\n        else if(n2<0){\\n             if(s1[n1]==s3[n3]){\\n                return t[n1+1][n2+1]=lcs(s1,s2,s3,n1-1,n2,n3-1);\\n            }\\n            else{\\n                return t[n1+1][n2+1]=false;\\n            }\\n        }\\n        if(s1[n1]==s3[n3] and s2[n2]==s3[n3]){\\n            return t[n1+1][n2+1]=lcs(s1,s2,s3,n1-1,n2,n3-1) or lcs(s1,s2,s3,n1,n2-1,n3-1);\\n        }\\n        else if(s1[n1]==s3[n3]){\\n            return t[n1+1][n2+1]=lcs(s1,s2,s3,n1-1,n2,n3-1);\\n        }\\n        else if(s2[n2]==s3[n3]){\\n             return t[n1+1][n2+1]=lcs(s1,s2,s3,n1,n2-1,n3-1);\\n        }\\n        return t[n1+1][n2+1]=false;\\n        \\n    }    \\n    bool isInterleave(string s1, string s2, string s3) {\\n        if(s3.size()!=s1.size()+s2.size()){\\n            return false;\\n        }\\n        memset(t,-1,sizeof(t));\\n        return lcs(s1,s2,s3,s1.size()-1,s2.size()-1,s3.size()-1);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int t[101][101];\\n    bool lcs(string s1,string s2,string s3,int n1,int n2,int n3){\\n        if(t[n1+1][n2+1]!=-1){\\n            return t[n1+1][n2+1];\\n        }\\n        if(n1<0 and n2<0){\\n            return t[n1+1][n2+1]=true;\\n        }\\n        if(n1<0){\\n            if(s2[n2]==s3[n3]){\\n                return t[n1+1][n2+1]=lcs(s1,s2,s3,n1,n2-1,n3-1);\\n            }\\n            else{\\n                return t[n1+1][n2+1]=false;\\n            }\\n        }\\n        else if(n2<0){\\n             if(s1[n1]==s3[n3]){\\n                return t[n1+1][n2+1]=lcs(s1,s2,s3,n1-1,n2,n3-1);\\n            }\\n            else{\\n                return t[n1+1][n2+1]=false;\\n            }\\n        }\\n        if(s1[n1]==s3[n3] and s2[n2]==s3[n3]){\\n            return t[n1+1][n2+1]=lcs(s1,s2,s3,n1-1,n2,n3-1) or lcs(s1,s2,s3,n1,n2-1,n3-1);\\n        }\\n        else if(s1[n1]==s3[n3]){\\n            return t[n1+1][n2+1]=lcs(s1,s2,s3,n1-1,n2,n3-1);\\n        }\\n        else if(s2[n2]==s3[n3]){\\n             return t[n1+1][n2+1]=lcs(s1,s2,s3,n1,n2-1,n3-1);\\n        }\\n        return t[n1+1][n2+1]=false;\\n        \\n    }    \\n    bool isInterleave(string s1, string s2, string s3) {\\n        if(s3.size()!=s1.size()+s2.size()){\\n            return false;\\n        }\\n        memset(t,-1,sizeof(t));\\n        return lcs(s1,s2,s3,s1.size()-1,s2.size()-1,s3.size()-1);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1247111,
                "title": "interleaving-string-with-dp-solution-c",
                "content": "\\n\\n![image](https://assets.leetcode.com/users/images/ee9cb1ad-88e5-491f-aac7-2ae94816c95d_1622637178.164193.jpeg)\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    // Recursive DP Solution\\n\\t\\n    vector < vector < int > > dp;\\n    \\n    bool isInterleave(string s1, string s2, string s3) {\\n        dp.assign(s1.size() + 1, vector < int > (s2.size() + 1, -1));\\n        return ans(s1, s2, s3, 0, 0, 0);    \\n    }\\n    \\n    bool ans(string s1, string s2, string s3, int idx1, int idx2, int idx3){\\n\\t   if(idx3 == s3.size() && idx1 == s1.size() && idx2 == s2.size()) return true;\\n        if(dp[idx1][idx2] != -1) return dp[idx1][idx2];\\n        bool res = false;\\n        if(s1[idx1] == s3[idx3] && idx1 < s1.size())\\n            res |= ans(s1, s2, s3, idx1 + 1, idx2, idx3 + 1);\\n        if(s2[idx2] == s3[idx3] && idx2 < s2.size())\\n            res |= ans(s1, s2, s3, idx1, idx2 + 1, idx3 + 1);\\n        return dp[idx1][idx2] = res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // Recursive DP Solution\\n\\t\\n    vector < vector < int > > dp;\\n    \\n    bool isInterleave(string s1, string s2, string s3) {\\n        dp.assign(s1.size() + 1, vector < int > (s2.size() + 1, -1));\\n        return ans(s1, s2, s3, 0, 0, 0);    \\n    }\\n    \\n    bool ans(string s1, string s2, string s3, int idx1, int idx2, int idx3){\\n\\t   if(idx3 == s3.size() && idx1 == s1.size() && idx2 == s2.size()) return true;\\n        if(dp[idx1][idx2] != -1) return dp[idx1][idx2];\\n        bool res = false;\\n        if(s1[idx1] == s3[idx3] && idx1 < s1.size())\\n            res |= ans(s1, s2, s3, idx1 + 1, idx2, idx3 + 1);\\n        if(s2[idx2] == s3[idx3] && idx2 < s2.size())\\n            res |= ans(s1, s2, s3, idx1, idx2 + 1, idx3 + 1);\\n        return dp[idx1][idx2] = res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1246982,
                "title": "interleaving-string-simple-bottom-up-dp-python",
                "content": "Before solving this question I would advice you to solve the longest common subsequence problem and then maybe try this one again. You\\'ll be able to understand the logic better.\\n```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        m = len(s1)\\n        n = len(s2)\\n        lenS3 = len(s3)\\n        \\n        if m == 0:\\n            return s2 == s3\\n        elif n == 0:\\n            return s1 == s3\\n        elif lenS3 == 0:\\n            return m + n == 0\\n        elif m + n != lenS3:\\n            return False\\n        \\n        t = [[False] * (n + 1) for i in range(m + 1)]\\n        t[0][0] = True\\n        \\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                # Base conditions\\n                if s1[i-1] == s3[i-1]:\\n                    t[i][0] = t[i-1][0]\\n                \\n                if s2[j-1] == s3[j-1]:\\n                    t[0][j] = t[0][j-1]\\n                \\n                # Main logic - We\\'re taking i + j - 1 in s3 because of 0-index\\n                if s1[i-1] == s3[i+j-1]:\\n                    t[i][j] = t[i-1][j]\\n                \\n                # We do an OR to cover the case that both s1 and s2 match.\\n                # This way we reduce an extra loop.\\n                if s2[j-1] == s3[i+j-1]:\\n                    t[i][j] = t[i][j] or t[i][j-1]\\n        \\n        return t[m][n]\\n```\\n\\nIf you like my approach please consider upvoting. Also, if you have any doubts feel free to ask. \\nThank you.",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        m = len(s1)\\n        n = len(s2)\\n        lenS3 = len(s3)\\n        \\n        if m == 0:\\n            return s2 == s3\\n        elif n == 0:\\n            return s1 == s3\\n        elif lenS3 == 0:\\n            return m + n == 0\\n        elif m + n != lenS3:\\n            return False\\n        \\n        t = [[False] * (n + 1) for i in range(m + 1)]\\n        t[0][0] = True\\n        \\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                # Base conditions\\n                if s1[i-1] == s3[i-1]:\\n                    t[i][0] = t[i-1][0]\\n                \\n                if s2[j-1] == s3[j-1]:\\n                    t[0][j] = t[0][j-1]\\n                \\n                # Main logic - We\\'re taking i + j - 1 in s3 because of 0-index\\n                if s1[i-1] == s3[i+j-1]:\\n                    t[i][j] = t[i-1][j]\\n                \\n                # We do an OR to cover the case that both s1 and s2 match.\\n                # This way we reduce an extra loop.\\n                if s2[j-1] == s3[i+j-1]:\\n                    t[i][j] = t[i][j] or t[i][j-1]\\n        \\n        return t[m][n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1246814,
                "title": "interleaving-string-rust-dynamic-programming",
                "content": "**Intuition**\\n\\n- We have to use letters in the input order, hence it makes sense to consider prefixes.\\n- Let `dp[i1][i2]` denote the length of the longest prefix of `s3` that we can obtain by interleaving `s1[..i1]` and `s2[..i2]`.\\n- When looking at `dp[i1][i2]` we update `dp[i1 + 1][i2]` if `s1[i1] == s3[i1 + i2]` and  `dp[i1][i2 + 1]` if `s2[i2] == s3[i1 + i2]`.\\n\\n**Complexity**\\n\\n- Time is O(nm).\\n- Space is O(nm).\\n\\n**Implementation**\\n\\n```rust\\nimpl Solution {\\n    pub fn is_interleave(s1: String, s2: String, s3: String) -> bool {\\n        let (l1, l2, l3) = (s1.len(), s2.len(), s3.len());\\n        if l1 + l2 != l3 {\\n            return false;\\n        }\\n\\n        let (s1, s2, s3) = (s1.as_bytes(), s2.as_bytes(), s3.as_bytes());\\n        let mut dp: Vec<Vec<usize>> = vec![vec![0; l2 + 1]; l1 + 1];\\n\\n        for i1 in 0..=l1 {\\n            for i2 in 0..=l2 {\\n                let i3 = i1 + i2;\\n                if i1 < l1 && s1[i1] == s3[i3] {\\n                    dp[i1 + 1][i2] = std::cmp::max(dp[i1 + 1][i2], dp[i1][i2] + 1);\\n                }\\n                if i2 < l2 && s2[i2] == s3[i3] {\\n                    dp[i1][i2 + 1] = std::cmp::max(dp[i1][i2 + 1], dp[i1][i2] + 1);\\n                }\\n            }\\n        }\\n        \\n        dp[l1][l2] == l3\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Dynamic Programming"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn is_interleave(s1: String, s2: String, s3: String) -> bool {\\n        let (l1, l2, l3) = (s1.len(), s2.len(), s3.len());\\n        if l1 + l2 != l3 {\\n            return false;\\n        }\\n\\n        let (s1, s2, s3) = (s1.as_bytes(), s2.as_bytes(), s3.as_bytes());\\n        let mut dp: Vec<Vec<usize>> = vec![vec![0; l2 + 1]; l1 + 1];\\n\\n        for i1 in 0..=l1 {\\n            for i2 in 0..=l2 {\\n                let i3 = i1 + i2;\\n                if i1 < l1 && s1[i1] == s3[i3] {\\n                    dp[i1 + 1][i2] = std::cmp::max(dp[i1 + 1][i2], dp[i1][i2] + 1);\\n                }\\n                if i2 < l2 && s2[i2] == s3[i3] {\\n                    dp[i1][i2 + 1] = std::cmp::max(dp[i1][i2 + 1], dp[i1][i2] + 1);\\n                }\\n            }\\n        }\\n        \\n        dp[l1][l2] == l3\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1246757,
                "title": "explanation-brute-memorization-dp-o-l-m-time-space-dp-o-l-m-time-and-o-m-space",
                "content": "# Brute Force + Memo\\nEx.\\n\\n    s1 = abc  \\n    s2 = abcd\\n\\n    s3 = aabbccd\\n\\n  **Intution:**\\n    For making s3[k] what we have,\\n    suppose we have used s1[0...i) and s2[0...j) for making s3[0...k)\\n    So we have three condition for making s3[k]\\n    1.  s1[i] == s2[j] == s3[k], so we have 2 option\\n        i. whether we use s1[i] to make s3[k], \\n        ii. or we can use s2[j] to make s3[k]\\n    2. if none of s1[i] and s2[j] is able to make s3[k]\\n        i. We can\\'t make s3 for now.\\n    3. If s1[i] is able to make s3[k] then use s1[i] else use s2[j]\\n    \\n    vector<vector<int>> dp;\\n    bool solve(string& s1, string& s2, string& s3, int i, int j, int k) {\\n        if (k == s3.size()) {\\n            return i == s1.size() && j == s2.size();\\n        }\\n\\n        if (dp[i][j] != -1) {\\n            return dp[i][j];\\n        }\\n\\n        if (i >= s1.size()) {\\n            if (s2[j] != s3[k]) {\\n                return dp[i][j] = false;\\n            } else {\\n                return dp[i][j] = solve(s1, s2, s3, i, j + 1, k + 1);\\n            }\\n        } else if (j >= s2.size()) {\\n            if (s1[i] != s3[k]) {\\n                return dp[i][j] = false;\\n            } else {\\n                return dp[i][j] = solve(s1, s2, s3, i + 1, j, k + 1);\\n            }\\n        } else {\\n            if (s1[i] != s3[k] && s2[j] != s3[k]) {\\n                return dp[i][j] = false;\\n            }\\n        }\\n\\n        bool ans = false;\\n        if (s1[i] == s2[j]) {\\n            ans |= solve(s1, s2, s3, i + 1, j, k + 1);\\n            ans |= solve(s1, s2, s3, i, j + 1, k + 1);\\n        } else {\\n            if (s1[i] == s3[k]) {\\n                ans |= solve(s1, s2, s3, i + 1, j, k + 1);\\n            } else {\\n                ans |= solve(s1, s2, s3, i, j + 1, k + 1);\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n\\t\\n**Time Complexity :**\\n O(2^(L+M)), without memorization  but using memorization O(L*M)\\n **Space Complexity:**\\n O(L*M) Size of dp\\n# \\tIterative Dp\\n    If we look carefully recursive solution then how dp is filling.\\n    dp[i][j] is filled by \\n    1. solve(i+1,j,k+1) || solve(i,j+1,k+1) // When both s1[i] and s2[i] is able to make s3[k]\\n    2. solve(i+1,j,k+1) // When only s1[i] only able to make s3[k]\\n    3. solve(i,j+1, k + 1) // When only s2[j] only able to make s3[k]\\n\\n    So we can fill dp iterative also\\n\\t\\n\\t\\n\\tbool solve(string s1, string s2, string s3) {\\n        int l = s1.size(), m = s2.size(), n = s3.size();\\n        if (l + m != n) return false;\\n\\n        vector<vector<bool>> dp(l + 1, vector<bool>(m + 1));\\n\\n        for (int i = 0; i <= l; i++) {\\n            for (int j = 0; j <= m; j++) {\\n                if (i == 0 && j == 0) {\\n                    dp[i][j] = true;\\n                } else if (i == 0) {\\n                    dp[i][j] = (dp[i][j - 1] && s2[j - 1] == s3[i + j - 1]);\\n                } else if (j == 0) {\\n                    dp[i][j] = (dp[i - 1][j] && s1[i - 1] == s3[i + j - 1]);\\n                } else {\\n                    dp[i][j] = (dp[i - 1][j] && s1[i - 1] == s3[i + j - 1]) || (dp[i][j - 1] && s2[j - 1] == s3[i + j - 1]);\\n                }\\n            }\\n        }\\n        return dp[l][m];\\n    }\\n\\t\\n# \\tO(M) space dp\\nNow if we look the dependency of dp[i][j] then\\n    dp[i][j] -> dp[i-1][j], dp[i][j-1] only, so we can skip all the remove which are less than i-1 because we don\\'t need them\\n\\t```\\n\\t    bool solve(string s1, string s2, string s3) {\\n        int l = s1.size(), m = s2.size(), n = s3.size(), flag = 1;\\n        vector<vector<bool>> dp(2, vector<bool>(m + 1));\\n\\n        for (int i = 0; i <= l; i++) {\\n            for (int j = 0; j <= m; j++) {\\n                if (i == 0 && j == 0) {\\n                    dp[flag][j] = true;\\n                } else if (i == 0) {\\n                    dp[flag][j] = (dp[flag ^ 1][j] && (s2[j - 1] == s3[i + j - 1]));\\n                } else if (j == 0) {\\n                    dp[flag][j] = (dp[flag ^ 1])[j] && (s1[i - 1] == s3[i + j - 1]);\\n                } else {\\n                    dp[flag][j] = ((dp[flag ^ 1][j] && s1[i - 1] == s3[i + j - 1]) || (dp[flag][j - 1] && (s2[j - 1] == s3[i + j - 1])));\\n                }\\n            }\\n            flag ^= 1;\\n        }\\n        return dp[flag ^ 1][m];\\n    }\\n\\t\\n\\nHappy Coding !!!",
                "solutionTags": [],
                "code": "# Brute Force + Memo\\nEx.\\n\\n    s1 = abc  \\n    s2 = abcd\\n\\n    s3 = aabbccd\\n\\n  **Intution:**\\n    For making s3[k] what we have,\\n    suppose we have used s1[0...i) and s2[0...j) for making s3[0...k)\\n    So we have three condition for making s3[k]\\n    1.  s1[i] == s2[j] == s3[k], so we have 2 option\\n        i. whether we use s1[i] to make s3[k], \\n        ii. or we can use s2[j] to make s3[k]\\n    2. if none of s1[i] and s2[j] is able to make s3[k]\\n        i. We can\\'t make s3 for now.\\n    3. If s1[i] is able to make s3[k] then use s1[i] else use s2[j]\\n    \\n    vector<vector<int>> dp;\\n    bool solve(string& s1, string& s2, string& s3, int i, int j, int k) {\\n        if (k == s3.size()) {\\n            return i == s1.size() && j == s2.size();\\n        }\\n\\n        if (dp[i][j] != -1) {\\n            return dp[i][j];\\n        }\\n\\n        if (i >= s1.size()) {\\n            if (s2[j] != s3[k]) {\\n                return dp[i][j] = false;\\n            } else {\\n                return dp[i][j] = solve(s1, s2, s3, i, j + 1, k + 1);\\n            }\\n        } else if (j >= s2.size()) {\\n            if (s1[i] != s3[k]) {\\n                return dp[i][j] = false;\\n            } else {\\n                return dp[i][j] = solve(s1, s2, s3, i + 1, j, k + 1);\\n            }\\n        } else {\\n            if (s1[i] != s3[k] && s2[j] != s3[k]) {\\n                return dp[i][j] = false;\\n            }\\n        }\\n\\n        bool ans = false;\\n        if (s1[i] == s2[j]) {\\n            ans |= solve(s1, s2, s3, i + 1, j, k + 1);\\n            ans |= solve(s1, s2, s3, i, j + 1, k + 1);\\n        } else {\\n            if (s1[i] == s3[k]) {\\n                ans |= solve(s1, s2, s3, i + 1, j, k + 1);\\n            } else {\\n                ans |= solve(s1, s2, s3, i, j + 1, k + 1);\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n\\t\\n**Time Complexity :**\\n O(2^(L+M)), without memorization  but using memorization O(L*M)\\n **Space Complexity:**\\n O(L*M) Size of dp\\n# \\tIterative Dp\\n    If we look carefully recursive solution then how dp is filling.\\n    dp[i][j] is filled by \\n    1. solve(i+1,j,k+1) || solve(i,j+1,k+1) // When both s1[i] and s2[i] is able to make s3[k]\\n    2. solve(i+1,j,k+1) // When only s1[i] only able to make s3[k]\\n    3. solve(i,j+1, k + 1) // When only s2[j] only able to make s3[k]\\n\\n    So we can fill dp iterative also\\n\\t\\n\\t\\n\\tbool solve(string s1, string s2, string s3) {\\n        int l = s1.size(), m = s2.size(), n = s3.size();\\n        if (l + m != n) return false;\\n\\n        vector<vector<bool>> dp(l + 1, vector<bool>(m + 1));\\n\\n        for (int i = 0; i <= l; i++) {\\n            for (int j = 0; j <= m; j++) {\\n                if (i == 0 && j == 0) {\\n                    dp[i][j] = true;\\n                } else if (i == 0) {\\n                    dp[i][j] = (dp[i][j - 1] && s2[j - 1] == s3[i + j - 1]);\\n                } else if (j == 0) {\\n                    dp[i][j] = (dp[i - 1][j] && s1[i - 1] == s3[i + j - 1]);\\n                } else {\\n                    dp[i][j] = (dp[i - 1][j] && s1[i - 1] == s3[i + j - 1]) || (dp[i][j - 1] && s2[j - 1] == s3[i + j - 1]);\\n                }\\n            }\\n        }\\n        return dp[l][m];\\n    }\\n\\t\\n# \\tO(M) space dp\\nNow if we look the dependency of dp[i][j] then\\n    dp[i][j] -> dp[i-1][j], dp[i][j-1] only, so we can skip all the remove which are less than i-1 because we don\\'t need them\\n\\t```\\n\\t    bool solve(string s1, string s2, string s3) {\\n        int l = s1.size(), m = s2.size(), n = s3.size(), flag = 1;\\n        vector<vector<bool>> dp(2, vector<bool>(m + 1));\\n\\n        for (int i = 0; i <= l; i++) {\\n            for (int j = 0; j <= m; j++) {\\n                if (i == 0 && j == 0) {\\n                    dp[flag][j] = true;\\n                } else if (i == 0) {\\n                    dp[flag][j] = (dp[flag ^ 1][j] && (s2[j - 1] == s3[i + j - 1]));\\n                } else if (j == 0) {\\n                    dp[flag][j] = (dp[flag ^ 1])[j] && (s1[i - 1] == s3[i + j - 1]);\\n                } else {\\n                    dp[flag][j] = ((dp[flag ^ 1][j] && s1[i - 1] == s3[i + j - 1]) || (dp[flag][j - 1] && (s2[j - 1] == s3[i + j - 1])));\\n                }\\n            }\\n            flag ^= 1;\\n        }\\n        return dp[flag ^ 1][m];\\n    }\\n\\t\\n\\nHappy Coding !!!",
                "codeTag": "Unknown"
            },
            {
                "id": 1079837,
                "title": "c-0ms-100-recursion-memorization-with-comments",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Interleaving String.\\nMemory Usage: 7.3 MB, less than 37.03% of C++ online submissions for Interleaving String.\\n```\\nclass Solution {\\npublic:\\n  int n1,n2,n3;\\n  set<pair<int,int>> st;                              //for memorization\\n  \\n  bool helper(string &s1, string &s2, string &s3, int i1, int i2, int i3){    \\n    if(st.count({i1,i2})) return false;                                       //if we already attend this variant \\n    \\n    while(n1 != i1 || n2 != i2){\\n      \\n      if(n1 != i1 && n2 != i2 && s1[i1] == s2[i2] && s1[i1] == s3[i3]){       //if we have to use letters from two words\\n        st.insert({i1,i2});                                                   //check it situation\\n        return helper(s1, s2, s3, i1 + 1, i2 , i3 + 1) ||                     //and consider two possibilities\\n          helper(s1, s2, s3, i1 , i2 + 1 , i3 + 1);\\n      }\\n      if(n1 != i1 && s1[i1] == s3[i3]){i1++;i3++;continue;}                   //if use letter only from one word\\n      if(n2 != i2 && s2[i2] == s3[i3]){i2++;i3++;continue;}\\n      return false;\\n    }\\n    \\n    return true;                                                              //FINISH !!!!!!\\n  }\\n  \\n  \\n  bool isInterleave(string s1, string s2, string s3) {\\n    n1 = s1.size(), n2 = s2.size(), n3 = s3.size();\\n    if(n1 + n2 != n3) return false;\\n   \\n    return helper(s1,s2,s3,0,0,0);\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int n1,n2,n3;\\n  set<pair<int,int>> st;                              //for memorization\\n  \\n  bool helper(string &s1, string &s2, string &s3, int i1, int i2, int i3){    \\n    if(st.count({i1,i2})) return false;                                       //if we already attend this variant \\n    \\n    while(n1 != i1 || n2 != i2){\\n      \\n      if(n1 != i1 && n2 != i2 && s1[i1] == s2[i2] && s1[i1] == s3[i3]){       //if we have to use letters from two words\\n        st.insert({i1,i2});                                                   //check it situation\\n        return helper(s1, s2, s3, i1 + 1, i2 , i3 + 1) ||                     //and consider two possibilities\\n          helper(s1, s2, s3, i1 , i2 + 1 , i3 + 1);\\n      }\\n      if(n1 != i1 && s1[i1] == s3[i3]){i1++;i3++;continue;}                   //if use letter only from one word\\n      if(n2 != i2 && s2[i2] == s3[i3]){i2++;i3++;continue;}\\n      return false;\\n    }\\n    \\n    return true;                                                              //FINISH !!!!!!\\n  }\\n  \\n  \\n  bool isInterleave(string s1, string s2, string s3) {\\n    n1 = s1.size(), n2 = s2.size(), n3 = s3.size();\\n    if(n1 + n2 != n3) return false;\\n   \\n    return helper(s1,s2,s3,0,0,0);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 933323,
                "title": "dfs-dp-progression-with-explanation-o-s1-s2-o-s1-s2",
                "content": "In this problem, we are tasked to see if `s3` can be broken down into `s1` and `s2` where `s1` and `s2` have to be used from front to back.  Therefore to find the solution, let\\'s look at all possible combinations of breaking down `s3` given `s1` and `s2`.  DFS is a great tool for this as it allows us to express an instance of a function as the current state, and the recursive calls as actions to future states.  To start out, the best approach is to draw a DFS tree.\\n![image](https://assets.leetcode.com/users/images/8a501cca-f3a5-43f5-b047-b9f57af55712_1605200826.533606.png)\\nAt each step, we check if the first character of `s1` and/or `s2` match the first character of `s3` and recurse downwards if there is a match.  This translates well to code, and looks like\\n```\\ndef dfs(s1, s2, s3):\\n\\tif not s1:\\n\\t\\treturn s2 == s3\\n\\tif not s2:\\n\\t\\treturn s1 == s3\\n\\tif not s3:\\n\\t\\treturn True\\n\\n\\tleft = right = False\\n\\tif s1[0] == s3[0]:\\n\\t\\tleft = dfs(s1[1:], s2, s3[1:])\\n\\tif s2[0] == s3[0]:\\n\\t\\tright = dfs(s1, s2[1:], s3[1:])\\n\\treturn left or right\\nreturn dfs(s1, s2, s3)\\n```\\nIt may not exactly help us solve this problem, but notice that the solution can also be seen as finding a root -> leaf path of length `s3`.  It seems this is a very common pattern in DFS, and it makes sense why.  The tree recurses down until it hits a base case, which indicates success or failure, depending on the base case.  This DFS approach will solve the problem, but takes far too long and times out on larger inputs.  Why is that?\\nNotice in the DFS tree, after two steps, both branches have the state `s1 = b, s2 = c, s3 = bc`.  From this point onwards, the rest of the calculation will return the same answer.  However our implementation of DFS is unaware of this and will waste time calculating the answer separately for both branches.  This becomes exponentially worse as the input sizes grow and the DFS tree becomes larger.  This is where the DP solution comes in.\\n\\nThe DFS approach solves the problem from the top down, meaning it must recurse all the way to a base case before there is any idea of a solution.  Instead, let\\'s build the solution from the ground up, saving the answer to subproblems as we solve them.  Therefore instead of spending time recalculating them, we can simply reference them when needed.\\n```\\ndef dp(s1, s2, s3):\\n\\tA = [[False] * (len(s2) + 1) for _ in range(len(s1) + 1)]\\n\\t# Base cases\\n\\tA[0][0] = True\\n\\tfor i in range(1, len(s1) + 1):\\n\\t\\tA[i][0] = A[i - 1][0] and s1[i - 1] == s3[i - 1]\\n\\tfor j in range(1, len(s2) + 1):\\n\\t\\tA[0][j] = A[0][j - 1] and s2[j - 1] == s3[j - 1]\\n\\n\\tfor i in range(1, len(s1) + 1):\\n\\t\\tfor j in range(1, len(s2) + 1):                    \\n\\t\\t\\tif s1[i - 1] == s3[i - 1 + j]:\\n\\t\\t\\t\\tA[i][j] = A[i - 1][j]\\n\\t\\t\\tif s2[j - 1] == s3[i - 1 + j]:\\n\\t\\t\\t\\tA[i][j] = A[i][j] or A[i][j - 1]\\n\\treturn A[-1][-1]\\nreturn dp(s1, s2, s3)\\n```\\nNotice that the recursion relation and base cases we are using are essentially the same as we found in the DFS approach.  We check if the first character of `s1` and/or `s2` match the first character of `s3`, and simply reference the smaller subproblem that was already solved.  This technique is like building the DFS tree from bottom up, and gives us our solution.",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\ndef dfs(s1, s2, s3):\\n\\tif not s1:\\n\\t\\treturn s2 == s3\\n\\tif not s2:\\n\\t\\treturn s1 == s3\\n\\tif not s3:\\n\\t\\treturn True\\n\\n\\tleft = right = False\\n\\tif s1[0] == s3[0]:\\n\\t\\tleft = dfs(s1[1:], s2, s3[1:])\\n\\tif s2[0] == s3[0]:\\n\\t\\tright = dfs(s1, s2[1:], s3[1:])\\n\\treturn left or right\\nreturn dfs(s1, s2, s3)\\n```\n```\\ndef dp(s1, s2, s3):\\n\\tA = [[False] * (len(s2) + 1) for _ in range(len(s1) + 1)]\\n\\t# Base cases\\n\\tA[0][0] = True\\n\\tfor i in range(1, len(s1) + 1):\\n\\t\\tA[i][0] = A[i - 1][0] and s1[i - 1] == s3[i - 1]\\n\\tfor j in range(1, len(s2) + 1):\\n\\t\\tA[0][j] = A[0][j - 1] and s2[j - 1] == s3[j - 1]\\n\\n\\tfor i in range(1, len(s1) + 1):\\n\\t\\tfor j in range(1, len(s2) + 1):                    \\n\\t\\t\\tif s1[i - 1] == s3[i - 1 + j]:\\n\\t\\t\\t\\tA[i][j] = A[i - 1][j]\\n\\t\\t\\tif s2[j - 1] == s3[i - 1 + j]:\\n\\t\\t\\t\\tA[i][j] = A[i][j] or A[i][j - 1]\\n\\treturn A[-1][-1]\\nreturn dp(s1, s2, s3)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 921322,
                "title": "java-0-ms-recursion-with-memoization-two-solutions-with-comments",
                "content": "Without memoization\\n```\\nclass Solution {\\n   public boolean isInterleave(String s1, String s2, String s3) {\\n        return isInterleave(s1, s2, s3, 0, 0, 0);\\n    }\\n\\n    public boolean isInterleave(String s1, String s2, String s3, int idx1, int idx2, int idx3) {\\n\\n\\t\\t//if we have reached the end of all the strings - found the answer\\n        if (idx3 == s3.length() && idx1 == s1.length() && idx2 == s2.length()) return true;\\n\\n\\t\\t//compare the character of s3 with s1\\n\\t\\t//if same - recursively check for other characters with s3 index+1   and    s1 index+1\\n\\t\\t//if not same compare the same character of s3 with s2\\n        if (idx1 < s1.length()  && idx3 < s3.length()  && s3.charAt(idx3) == s1.charAt(idx1)) {\\n            boolean result = isInterleave(s1, s2, s3, idx1 + 1, idx2, idx3 + 1);\\n            if (result) return true;\\n        }\\n\\n\\t\\t//compare the character of s3 with s2\\n\\t\\t//if same - recursively check for other characters with s3 index+1   and    s2 index+1\\n\\t\\t//if not same return false\\n        if (idx2 < s2.length() && idx3 < s3.length()  && s3.charAt(idx3) == s2.charAt(idx2)) {\\n            boolean result = isInterleave(s1, s2, s3, idx1, idx2 + 1, idx3 + 1);\\n            if (result) return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n```\\n\\n----------------------------------------------------------\\n\\nDoing the same logic as above but saving the computed results to an array\\n\\n**With memoization**\\n```\\nclass Solution {\\n   public boolean isInterleave(String s1, String s2, String s3) {\\n       Boolean[][] dp = new Boolean[s1.length()+1][s2.length()+1];\\n        return isInterleave(s1, s2, s3, 0, 0, 0, dp);\\n    }\\n\\n    public boolean isInterleave(String s1, String s2, String s3, int idx1, int idx2, int idx3, Boolean[][] dp) {\\n\\n        if(dp[idx1][idx2] != null) return dp[idx1][idx2];\\n        \\n        if (idx3 == s3.length() && idx1 == s1.length() && idx2 == s2.length()) return true;\\n\\n        if (idx1 < s1.length()  && idx3 < s3.length()  && s3.charAt(idx3) == s1.charAt(idx1)) {\\n            boolean result = isInterleave(s1, s2, s3, idx1 + 1, idx2, idx3 + 1, dp);\\n            dp[idx1][idx2] = result;\\n            if (result) return dp[idx1][idx2];\\n        }\\n\\n        if (idx2 < s2.length() && idx3 < s3.length()  && s3.charAt(idx3) == s2.charAt(idx2)) {\\n            boolean result = isInterleave(s1, s2, s3, idx1, idx2 + 1, idx3 + 1, dp);\\n            dp[idx1][idx2] = result;\\n            if (result) return dp[idx1][idx2];\\n        }\\n        \\n        dp[idx1][idx2] = false;\\n\\n        return dp[idx1][idx2];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n   public boolean isInterleave(String s1, String s2, String s3) {\\n        return isInterleave(s1, s2, s3, 0, 0, 0);\\n    }\\n\\n    public boolean isInterleave(String s1, String s2, String s3, int idx1, int idx2, int idx3) {\\n\\n\\t\\t//if we have reached the end of all the strings - found the answer\\n        if (idx3 == s3.length() && idx1 == s1.length() && idx2 == s2.length()) return true;\\n\\n\\t\\t//compare the character of s3 with s1\\n\\t\\t//if same - recursively check for other characters with s3 index+1   and    s1 index+1\\n\\t\\t//if not same compare the same character of s3 with s2\\n        if (idx1 < s1.length()  && idx3 < s3.length()  && s3.charAt(idx3) == s1.charAt(idx1)) {\\n            boolean result = isInterleave(s1, s2, s3, idx1 + 1, idx2, idx3 + 1);\\n            if (result) return true;\\n        }\\n\\n\\t\\t//compare the character of s3 with s2\\n\\t\\t//if same - recursively check for other characters with s3 index+1   and    s2 index+1\\n\\t\\t//if not same return false\\n        if (idx2 < s2.length() && idx3 < s3.length()  && s3.charAt(idx3) == s2.charAt(idx2)) {\\n            boolean result = isInterleave(s1, s2, s3, idx1, idx2 + 1, idx3 + 1);\\n            if (result) return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n   public boolean isInterleave(String s1, String s2, String s3) {\\n       Boolean[][] dp = new Boolean[s1.length()+1][s2.length()+1];\\n        return isInterleave(s1, s2, s3, 0, 0, 0, dp);\\n    }\\n\\n    public boolean isInterleave(String s1, String s2, String s3, int idx1, int idx2, int idx3, Boolean[][] dp) {\\n\\n        if(dp[idx1][idx2] != null) return dp[idx1][idx2];\\n        \\n        if (idx3 == s3.length() && idx1 == s1.length() && idx2 == s2.length()) return true;\\n\\n        if (idx1 < s1.length()  && idx3 < s3.length()  && s3.charAt(idx3) == s1.charAt(idx1)) {\\n            boolean result = isInterleave(s1, s2, s3, idx1 + 1, idx2, idx3 + 1, dp);\\n            dp[idx1][idx2] = result;\\n            if (result) return dp[idx1][idx2];\\n        }\\n\\n        if (idx2 < s2.length() && idx3 < s3.length()  && s3.charAt(idx3) == s2.charAt(idx2)) {\\n            boolean result = isInterleave(s1, s2, s3, idx1, idx2 + 1, idx3 + 1, dp);\\n            dp[idx1][idx2] = result;\\n            if (result) return dp[idx1][idx2];\\n        }\\n        \\n        dp[idx1][idx2] = false;\\n\\n        return dp[idx1][idx2];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 815959,
                "title": "java-simple-dp-memo",
                "content": "```\\nclass Solution {\\n    HashMap<String, Boolean> map;\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        map = new HashMap();\\n        return find(s1, s2, s3, s1.length()-1, s2.length()-1, s3.length()-1);\\n    }\\n    \\n    boolean find(String a, String b, String c, int i, int j, int k){\\n        \\n        \\n        if( i == -1 && j == -1 && k == -1)  return true;\\n        String key = i+\"-\"+j+\"-\"+k;\\n        \\n        if( map.containsKey(key))   return map.get(key);\\n         \\n        if( i >= 0 && j >= 0 && k >= 0 && a.charAt(i) == b.charAt(j) && b.charAt(j) == c.charAt(k) ){\\n            boolean temp = find(a, b, c, i-1, j, k-1) || find(a, b, c, i, j-1, k-1);\\n            map.put(key, temp);\\n            return temp;\\n            \\n        }\\n        \\n        \\n        if( i >= 0 && k >= 0 && a.charAt(i) == c.charAt(k) ){\\n            boolean temp = find(a, b, c, i-1, j, k-1);\\n            map.put(key, temp);\\n            return temp;\\n        }\\n        \\n        if( j >= 0 && k >= 0 && b.charAt(j) == c.charAt(k) ){\\n            boolean temp = find(a, b, c, i, j-1, k-1);\\n            map.put(key, temp);\\n            return temp;\\n        }\\n        \\n        return false;\\n       \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    HashMap<String, Boolean> map;\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        map = new HashMap();\\n        return find(s1, s2, s3, s1.length()-1, s2.length()-1, s3.length()-1);\\n    }\\n    \\n    boolean find(String a, String b, String c, int i, int j, int k){\\n        \\n        \\n        if( i == -1 && j == -1 && k == -1)  return true;\\n        String key = i+\"-\"+j+\"-\"+k;\\n        \\n        if( map.containsKey(key))   return map.get(key);\\n         \\n        if( i >= 0 && j >= 0 && k >= 0 && a.charAt(i) == b.charAt(j) && b.charAt(j) == c.charAt(k) ){\\n            boolean temp = find(a, b, c, i-1, j, k-1) || find(a, b, c, i, j-1, k-1);\\n            map.put(key, temp);\\n            return temp;\\n            \\n        }\\n        \\n        \\n        if( i >= 0 && k >= 0 && a.charAt(i) == c.charAt(k) ){\\n            boolean temp = find(a, b, c, i-1, j, k-1);\\n            map.put(key, temp);\\n            return temp;\\n        }\\n        \\n        if( j >= 0 && k >= 0 && b.charAt(j) == c.charAt(k) ){\\n            boolean temp = find(a, b, c, i, j-1, k-1);\\n            map.put(key, temp);\\n            return temp;\\n        }\\n        \\n        return false;\\n       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 705691,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3):\\n            return False\\n        memo = {}\\n        return self.helper(s1, s2, s3, 0, 0, 0, \\'\\', {})\\n        \\n    \\n    def helper(self, s1, s2, s3, index1, index2, index3, current, memo):\\n        if current == s3 and index1 == len(s1) and index2 == len(s2):\\n            return True\\n        if current and current[-1] != s3[index3 - 1]:\\n            return False\\n        ans = False\\n        if (index1, index2) in memo:\\n            return memo[(index1, index2)]\\n        if index1 < len(s1):\\n            ans = ans or self.helper(s1, s2, s3, index1 + 1, index2, index3 + 1, current + s1[index1], memo)\\n        if index2 < len(s2):\\n            ans = ans or self.helper(s1, s2, s3, index1, index2 + 1, index3 + 1, current + s2[index2], memo)\\n        \\n        memo[(index1, index2)] = ans\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3):\\n            return False\\n        memo = {}\\n        return self.helper(s1, s2, s3, 0, 0, 0, \\'\\', {})\\n        \\n    \\n    def helper(self, s1, s2, s3, index1, index2, index3, current, memo):\\n        if current == s3 and index1 == len(s1) and index2 == len(s2):\\n            return True\\n        if current and current[-1] != s3[index3 - 1]:\\n            return False\\n        ans = False\\n        if (index1, index2) in memo:\\n            return memo[(index1, index2)]\\n        if index1 < len(s1):\\n            ans = ans or self.helper(s1, s2, s3, index1 + 1, index2, index3 + 1, current + s1[index1], memo)\\n        if index2 < len(s2):\\n            ans = ans or self.helper(s1, s2, s3, index1, index2 + 1, index3 + 1, current + s2[index2], memo)\\n        \\n        memo[(index1, index2)] = ans\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 687639,
                "title": "python3-top-down-dp",
                "content": "\\n\\n```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3): return False \\n        \\n        @cache\\n        def fn(i, j): \\n            \"\"\"Return True if s3[i+j:] is formed by interleaving s1[i:] and s2[j:]\"\"\"\\n            if i == len(s1) and j == len(s2): return True\\n            ans = False\\n            if i < len(s1) and s1[i] == s3[i+j]: ans = ans or fn(i+1, j)\\n            if j < len(s2) and s2[j] == s3[i+j]: ans = ans or fn(i, j+1)\\n            return ans \\n        \\n        return fn(0, 0)\\n```\\n\\nEdited on 6/2/2021\\nAdding bottom-up implementation \\n```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3): return False \\n        \\n        dp = [False]*len(s2) + [True]\\n        for i in reversed(range(len(s1)+1)): \\n            for j in reversed(range(len(s2)+1)): \\n                if i < len(s1): dp[j] = (dp[j] and s1[i] == s3[i+j])\\n                if j < len(s2): dp[j] = dp[j] or (dp[j+1] and s2[j] == s3[i+j])\\n        return dp[0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3): return False \\n        \\n        @cache\\n        def fn(i, j): \\n            \"\"\"Return True if s3[i+j:] is formed by interleaving s1[i:] and s2[j:]\"\"\"\\n            if i == len(s1) and j == len(s2): return True\\n            ans = False\\n            if i < len(s1) and s1[i] == s3[i+j]: ans = ans or fn(i+1, j)\\n            if j < len(s2) and s2[j] == s3[i+j]: ans = ans or fn(i, j+1)\\n            return ans \\n        \\n        return fn(0, 0)\\n```\n```\\nclass Solution:\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        if len(s1) + len(s2) != len(s3): return False \\n        \\n        dp = [False]*len(s2) + [True]\\n        for i in reversed(range(len(s1)+1)): \\n            for j in reversed(range(len(s2)+1)): \\n                if i < len(s1): dp[j] = (dp[j] and s1[i] == s3[i+j])\\n                if j < len(s2): dp[j] = dp[j] or (dp[j+1] and s2[j] == s3[i+j])\\n        return dp[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 526481,
                "title": "c-0ms-top-down-and-bottom-up-dp-solutions-detailed-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/interleaving-string/submissions/\\n    \\n    Solutions:\\n    1. Top-down, TC: O(MN)\\n    2. Bottom-up, TC: O(MN)\\n*/\\n\\nclass Solution {\\npublic:\\n    // Checks if interleaves using top-down DP\\n    /*\\n        If the string interleaves, then that means the entire s1 and s2 will be used \\n        for making s3. So len(s1) + len(s2) = len(s3).\\n        So till any pos. k in s3, we would have used i of s1 and j of s2.\\n        So we track if string till (i + j) interleaves with s3[i+j-1]\\n        \\n        TC: O(MN)\\n    */\\n    bool isInterleaveMem(int i, int j, int k, string& s1, string& s2, string& s3,\\n                        vector<vector<int>>& dp) {\\n        // when the total char length is zero\\n        // also check if s1 and s2 has ended as well\\n        if(k == 0)\\n            return (i || j) ? false : true;\\n        \\n        if(dp[i][j] == -1) {\\n            // do dfs with the string whose current char matches s3\\n            dp[i][j] = (i-1) >= 0 && s1[i-1] == s3[k-1] && isInterleaveMem(i-1, j, k-1, s1, s2, s3, dp) ||\\n                        (j-1) >= 0 && s2[j-1] == s3[k-1] && isInterleaveMem(i, j-1, k-1, s1, s2, s3, dp);\\n        }\\n        return dp[i][j];\\n    }\\n    \\n    bool isInterleaveMemDriver(string& s1, string& s2, string& s3) {\\n        int M = s1.size(), N = s2.size(), K = s3.size();\\n        // the strings interleaves only if the sum of string lengths match\\n        if(M + N != K)\\n            return false;\\n        \\n        // dp(i, j): if string till s[i+j-1] interleaves till s1[i] and s2[j]  \\n        vector<vector<int>> dp(M + 1, vector<int>(N + 1, -1));\\n        return isInterleaveMem(M, N, K, s1, s2, s3, dp);\\n    }\\n    \\n    // Checks if interleaves using bottom-up DP\\n    /*\\n        If the string interleaves, then that means the entire s1 and s2 will be used \\n        for making s3. So len(s1) + len(s2) = len(s3).\\n        So till any pos. k in s3, we would have used i of s1 and j of s2.\\n        So we track if string till (i + j) interleaves with s3[i+j-1]\\n        \\n        TC: O(MN)\\n    */\\n    bool isInterleaveTab(string& s1, string& s2, string& s3) {\\n        const int M = s1.size(), N = s2.size();\\n        // the strings interleaves only if the sum of string lengths match\\n        if(M + N != s3.size())\\n            return false;\\n        \\n        // dp(i, j): if string till s[i+j-1] interleaves till s1[i] and s2[j]  \\n        vector<vector<bool>> dp(M + 1, vector<bool>(N + 1, false));\\n        // when s1, s2 and s3 are empty\\n        dp[0][0] = true;\\n        // when s2 is empty\\n        for(int i = 1; i <= M; i++)\\n            dp[i][0] = dp[i-1][0] && s3[i-1] == s1[i-1];\\n        // when s1 is empty\\n        for(int i = 1; i <= N; i++)\\n            dp[0][i] = dp[0][i-1] && s3[i-1] == s2[i-1];\\n    \\n        for(int i = 1; i <= M; i++)\\n            for(int j = 1; j <= N; j++)\\n                // s3 interleaves if till the current length it was interleaving and one of chars from\\n                // s1 or s2 match the current position in s3\\n                dp[i][j] = (s1[i-1] == s3[i+j-1] && dp[i-1][j]) ||\\n                            (s2[j-1] == s3[i+j-1] && dp[i][j-1]);\\n        \\n        return dp[M][N];\\n    }\\n    \\n    bool isInterleave(string s1, string s2, string s3) {\\n        //return isInterleaveTab(s1, s2, s3);\\n         return isInterleaveMemDriver(s1, s2, s3);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/interleaving-string/submissions/\\n    \\n    Solutions:\\n    1. Top-down, TC: O(MN)\\n    2. Bottom-up, TC: O(MN)\\n*/\\n\\nclass Solution {\\npublic:\\n    // Checks if interleaves using top-down DP\\n    /*\\n        If the string interleaves, then that means the entire s1 and s2 will be used \\n        for making s3. So len(s1) + len(s2) = len(s3).\\n        So till any pos. k in s3, we would have used i of s1 and j of s2.\\n        So we track if string till (i + j) interleaves with s3[i+j-1]\\n        \\n        TC: O(MN)\\n    */\\n    bool isInterleaveMem(int i, int j, int k, string& s1, string& s2, string& s3,\\n                        vector<vector<int>>& dp) {\\n        // when the total char length is zero\\n        // also check if s1 and s2 has ended as well\\n        if(k == 0)\\n            return (i || j) ? false : true;\\n        \\n        if(dp[i][j] == -1) {\\n            // do dfs with the string whose current char matches s3\\n            dp[i][j] = (i-1) >= 0 && s1[i-1] == s3[k-1] && isInterleaveMem(i-1, j, k-1, s1, s2, s3, dp) ||\\n                        (j-1) >= 0 && s2[j-1] == s3[k-1] && isInterleaveMem(i, j-1, k-1, s1, s2, s3, dp);\\n        }\\n        return dp[i][j];\\n    }\\n    \\n    bool isInterleaveMemDriver(string& s1, string& s2, string& s3) {\\n        int M = s1.size(), N = s2.size(), K = s3.size();\\n        // the strings interleaves only if the sum of string lengths match\\n        if(M + N != K)\\n            return false;\\n        \\n        // dp(i, j): if string till s[i+j-1] interleaves till s1[i] and s2[j]  \\n        vector<vector<int>> dp(M + 1, vector<int>(N + 1, -1));\\n        return isInterleaveMem(M, N, K, s1, s2, s3, dp);\\n    }\\n    \\n    // Checks if interleaves using bottom-up DP\\n    /*\\n        If the string interleaves, then that means the entire s1 and s2 will be used \\n        for making s3. So len(s1) + len(s2) = len(s3).\\n        So till any pos. k in s3, we would have used i of s1 and j of s2.\\n        So we track if string till (i + j) interleaves with s3[i+j-1]\\n        \\n        TC: O(MN)\\n    */\\n    bool isInterleaveTab(string& s1, string& s2, string& s3) {\\n        const int M = s1.size(), N = s2.size();\\n        // the strings interleaves only if the sum of string lengths match\\n        if(M + N != s3.size())\\n            return false;\\n        \\n        // dp(i, j): if string till s[i+j-1] interleaves till s1[i] and s2[j]  \\n        vector<vector<bool>> dp(M + 1, vector<bool>(N + 1, false));\\n        // when s1, s2 and s3 are empty\\n        dp[0][0] = true;\\n        // when s2 is empty\\n        for(int i = 1; i <= M; i++)\\n            dp[i][0] = dp[i-1][0] && s3[i-1] == s1[i-1];\\n        // when s1 is empty\\n        for(int i = 1; i <= N; i++)\\n            dp[0][i] = dp[0][i-1] && s3[i-1] == s2[i-1];\\n    \\n        for(int i = 1; i <= M; i++)\\n            for(int j = 1; j <= N; j++)\\n                // s3 interleaves if till the current length it was interleaving and one of chars from\\n                // s1 or s2 match the current position in s3\\n                dp[i][j] = (s1[i-1] == s3[i+j-1] && dp[i-1][j]) ||\\n                            (s2[j-1] == s3[i+j-1] && dp[i][j-1]);\\n        \\n        return dp[M][N];\\n    }\\n    \\n    bool isInterleave(string s1, string s2, string s3) {\\n        //return isInterleaveTab(s1, s2, s3);\\n         return isInterleaveMemDriver(s1, s2, s3);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 518963,
                "title": "simple-python-dfs",
                "content": "```python\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    @lru_cache()\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:        \\n        if s1 == \\'\\': return s2 == s3\\n        if s2 == \\'\\': return s1 == s3\\n\\n        return ( s3[0] == s1[0] and self.isInterleave(s1[1:], s2, s3[1:]) ) \\\\\\n            or ( s3[0] == s2[0] and self.isInterleave(s1, s2[1:], s3[1:]) )\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    @lru_cache()\\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:        \\n        if s1 == \\'\\': return s2 == s3\\n        if s2 == \\'\\': return s1 == s3\\n\\n        return ( s3[0] == s1[0] and self.isInterleave(s1[1:], s2, s3[1:]) ) \\\\\\n            or ( s3[0] == s2[0] and self.isInterleave(s1, s2[1:], s3[1:]) )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 214113,
                "title": "dp-solution-with-intuition-in-java",
                "content": "```\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        // dp[i][j] = true, means first i characters of s1 and first j characters of s2 interleaved to form i+j characters of s3\\n        // intuition dp[i][j] = true, if(dp[i-1][j] = true and ith char of s1 = (i+j)th char of s3 or dp[i][j-1] = true and jth character of s2 = (i+j)th char of s3\\n        \\n        int m = s1.length();\\n        int n = s2.length();\\n        int t = s3.length();\\n        \\n        if(t==0) return true;\\n        if(m+n != t) return false;\\n        else if(m==0 && n==0 && t!=0) return false;\\n        else if(m==0 && n!=0 )\\n        {\\n            if(s2.equals(s3))\\n                return true;\\n            else\\n                return false;\\n        }\\n        else if(m!=0 && n==0)\\n        {\\n            if(s1.equals(s3))\\n                return true;\\n            else\\n                return false;\\n        }\\n            \\n        \\n        boolean dp[][] = new boolean[m+1][n+1];\\n        dp[0][0] = true;\\n        \\n        //base case 1\\n        for(int i=1;i<=m;i++)\\n        {\\n            if((s1.substring(0,i)).equals(s3.substring(0,i)))\\n                dp[i][0] = true;\\n            else\\n                dp[i][0] = false;\\n        }\\n\\n        //base case 2\\n        for(int j=1;j<=n;j++)\\n        {\\n            if((s2.substring(0,j)).equals(s3.substring(0,j)))\\n                dp[0][j] = true;\\n            else\\n                dp[0][j] = false;\\n        }\\n        \\n        //dp solution\\n        for(int i=1;i<=m;i++)\\n        {\\n            for(int j=1;j<=n;j++)\\n            {\\n                if( (dp[i-1][j]==true && s1.charAt(i-1)==s3.charAt(i+j-1)) || (dp[i][j-1]==true && s2.charAt(j-1)==s3.charAt(i+j-1)) )\\n                    dp[i][j] = true;\\n                 else\\n                    dp[i][j] = false;\\n            }\\n        }\\n        return dp[m][n]; \\n    }\\n\\n",
                "solutionTags": [],
                "code": "```\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        // dp[i][j] = true, means first i characters of s1 and first j characters of s2 interleaved to form i+j characters of s3\\n        // intuition dp[i][j] = true, if(dp[i-1][j] = true and ith char of s1 = (i+j)th char of s3 or dp[i][j-1] = true and jth character of s2 = (i+j)th char of s3\\n        \\n        int m = s1.length();\\n        int n = s2.length();\\n        int t = s3.length();\\n        \\n        if(t==0) return true;\\n        if(m+n != t) return false;\\n        else if(m==0 && n==0 && t!=0) return false;\\n        else if(m==0 && n!=0 )\\n        {\\n            if(s2.equals(s3))\\n                return true;\\n            else\\n                return false;\\n        }\\n        else if(m!=0 && n==0)\\n        {\\n            if(s1.equals(s3))\\n                return true;\\n            else\\n                return false;\\n        }\\n            \\n        \\n        boolean dp[][] = new boolean[m+1][n+1];\\n        dp[0][0] = true;\\n        \\n        //base case 1\\n        for(int i=1;i<=m;i++)\\n        {\\n            if((s1.substring(0,i)).equals(s3.substring(0,i)))\\n                dp[i][0] = true;\\n            else\\n                dp[i][0] = false;\\n        }\\n\\n        //base case 2\\n        for(int j=1;j<=n;j++)\\n        {\\n            if((s2.substring(0,j)).equals(s3.substring(0,j)))\\n                dp[0][j] = true;\\n            else\\n                dp[0][j] = false;\\n        }\\n        \\n        //dp solution\\n        for(int i=1;i<=m;i++)\\n        {\\n            for(int j=1;j<=n;j++)\\n            {\\n                if( (dp[i-1][j]==true && s1.charAt(i-1)==s3.charAt(i+j-1)) || (dp[i][j-1]==true && s2.charAt(j-1)==s3.charAt(i+j-1)) )\\n                    dp[i][j] = true;\\n                 else\\n                    dp[i][j] = false;\\n            }\\n        }\\n        return dp[m][n]; \\n    }\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 31934,
                "title": "java-dp-solution-o-m-n-time-o-n-space",
                "content": "```\\npublic class Solution {\\n    /**\\n     * Dynamic programming\\n     * Dynamic programming has 2 properties: overlapping subproblems and optimal substructure. \\n     * Then for this question, the overlapping subproblem would be matching substring of s1 or s2 with substring of s3. \\n     * Since s3 must match s1 and s2 in a way that the character has the same order, so we can just start comparison from start to end. \\n     * Say, s1.charAt(i) == s3.charAt(i + j); then we only have to deal with the subproblem of s1.substring(i + 1, s1.length()), s2.substring(j, s2.length()) and s3.substring(i + j, s3.length())\\n     * Since we don't have to know exactly how they match but rather only if they have matched for previous characters, a 2-dimensional boolean array would be enough. \\n     * One dimension record the index of s1 and the other record the index of s2.\\n     * matched[i][j] = matched[i][j-1] && current character of s2 and s3 is the same || matched[i-1][j] && current character of s1 and s3 is the same\\n     * Base case would be matched[0][0] = true\\n     * The corner case would be s1.length() + s2.length() != s3.length(), which is obviously false. \\n     * O(m * n) time and space where m and n are length of s1 and s2 respectively\\n     * The space may be further optimized to O(n), see below.\\n     */\\n    \\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        if (s1 == null || s1.length() == 0) {\\n            return s2.equals(s3);\\n        }\\n        if (s2 == null || s2.length() == 0) {\\n            return s1.equals(s3);\\n        }\\n        if (s1.length() + s2.length() != s3.length()) {\\n            return false;\\n        }\\n        \\n        boolean[][] matched = new boolean[s1.length() + 1][s2.length() + 1];\\n        char[] ch1 = s1.toCharArray();\\n        char[] ch2 = s2.toCharArray();\\n        char[] ch3 = s3.toCharArray();\\n        \\n        for (int i = 0; i <= ch1.length; i++) {\\n            for (int j = 0; j <= ch2.length; j++) {\\n                if (i == 0 && j == 0) {\\n                    matched[i][j] = true;\\n                } else if (i == 0) {\\n                    matched[i][j] = matched[i][j-1] && ch2[j - 1] == ch3[i + j - 1];\\n                } else if (j == 0) {\\n                    matched[i][j] = matched[i - 1][j] && ch1[i - 1] == ch3[i + j - 1];\\n                } else {\\n                    matched[i][j] = (matched[i][j - 1] && ch2[j - 1] == ch3[i + j - 1] || matched[i - 1][j] && ch1[i - 1] == ch3[i + j - 1]);\\n                }\\n            }\\n        }\\n        \\n        return matched[ch1.length][ch2.length];\\n    }\\n```\\n\\nSince every matched flag is only related to the flag on the right and above it, we can drop every other flags and only retain a 1-dimension array to store these flags. \\n```\\npublic Solution {\\n    /**\\n     * Further optimized to O(m * n) time and O(n) space where m and n are the length of s1 and s2 respectively\\n     */\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        if (s1 == null || s2 == null || s3 == null) {\\n            return false;\\n        }\\n        if (s1.length() + s2.length() != s3.length()) {\\n            return false;\\n        }\\n        \\n        char[] ch1 = s1.toCharArray();\\n        char[] ch2 = s2.toCharArray();\\n        char[] ch3 = s3.toCharArray();\\n        boolean[] matched = new boolean[ch2.length + 1];\\n        for (int i = 0; i <= ch1.length; i++) {\\n            for (int j = 0; j <= ch2.length; j++) {\\n                if (i == 0 && j == 0) {\\n                    matched[j] = true;\\n                } else if (i == 0) {\\n                    matched[j] = matched[j - 1] && ch2[j - 1] == ch3[i + j -1];\\n                } else if (j == 0) {\\n                    matched[j] = matched[j] && ch1[i - 1] == ch3[i + j - 1];\\n                } else {\\n                    matched[j] = matched[j - 1] && ch2[j - 1] == ch3[i + j - 1] || matched[j] && ch1[i - 1] == ch3[i + j - 1];\\n                }\\n            }\\n        }\\n        \\n        return matched[ch2.length];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    /**\\n     * Dynamic programming\\n     * Dynamic programming has 2 properties: overlapping subproblems and optimal substructure. \\n     * Then for this question, the overlapping subproblem would be matching substring of s1 or s2 with substring of s3. \\n     * Since s3 must match s1 and s2 in a way that the character has the same order, so we can just start comparison from start to end. \\n     * Say, s1.charAt(i) == s3.charAt(i + j); then we only have to deal with the subproblem of s1.substring(i + 1, s1.length()), s2.substring(j, s2.length()) and s3.substring(i + j, s3.length())\\n     * Since we don't have to know exactly how they match but rather only if they have matched for previous characters, a 2-dimensional boolean array would be enough. \\n     * One dimension record the index of s1 and the other record the index of s2.\\n     * matched[i][j] = matched[i][j-1] && current character of s2 and s3 is the same || matched[i-1][j] && current character of s1 and s3 is the same\\n     * Base case would be matched[0][0] = true\\n     * The corner case would be s1.length() + s2.length() != s3.length(), which is obviously false. \\n     * O(m * n) time and space where m and n are length of s1 and s2 respectively\\n     * The space may be further optimized to O(n), see below.\\n     */\\n    \\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        if (s1 == null || s1.length() == 0) {\\n            return s2.equals(s3);\\n        }\\n        if (s2 == null || s2.length() == 0) {\\n            return s1.equals(s3);\\n        }\\n        if (s1.length() + s2.length() != s3.length()) {\\n            return false;\\n        }\\n        \\n        boolean[][] matched = new boolean[s1.length() + 1][s2.length() + 1];\\n        char[] ch1 = s1.toCharArray();\\n        char[] ch2 = s2.toCharArray();\\n        char[] ch3 = s3.toCharArray();\\n        \\n        for (int i = 0; i <= ch1.length; i++) {\\n            for (int j = 0; j <= ch2.length; j++) {\\n                if (i == 0 && j == 0) {\\n                    matched[i][j] = true;\\n                } else if (i == 0) {\\n                    matched[i][j] = matched[i][j-1] && ch2[j - 1] == ch3[i + j - 1];\\n                } else if (j == 0) {\\n                    matched[i][j] = matched[i - 1][j] && ch1[i - 1] == ch3[i + j - 1];\\n                } else {\\n                    matched[i][j] = (matched[i][j - 1] && ch2[j - 1] == ch3[i + j - 1] || matched[i - 1][j] && ch1[i - 1] == ch3[i + j - 1]);\\n                }\\n            }\\n        }\\n        \\n        return matched[ch1.length][ch2.length];\\n    }\\n```\n```\\npublic Solution {\\n    /**\\n     * Further optimized to O(m * n) time and O(n) space where m and n are the length of s1 and s2 respectively\\n     */\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        if (s1 == null || s2 == null || s3 == null) {\\n            return false;\\n        }\\n        if (s1.length() + s2.length() != s3.length()) {\\n            return false;\\n        }\\n        \\n        char[] ch1 = s1.toCharArray();\\n        char[] ch2 = s2.toCharArray();\\n        char[] ch3 = s3.toCharArray();\\n        boolean[] matched = new boolean[ch2.length + 1];\\n        for (int i = 0; i <= ch1.length; i++) {\\n            for (int j = 0; j <= ch2.length; j++) {\\n                if (i == 0 && j == 0) {\\n                    matched[j] = true;\\n                } else if (i == 0) {\\n                    matched[j] = matched[j - 1] && ch2[j - 1] == ch3[i + j -1];\\n                } else if (j == 0) {\\n                    matched[j] = matched[j] && ch1[i - 1] == ch3[i + j - 1];\\n                } else {\\n                    matched[j] = matched[j - 1] && ch2[j - 1] == ch3[i + j - 1] || matched[j] && ch1[i - 1] == ch3[i + j - 1];\\n                }\\n            }\\n        }\\n        \\n        return matched[ch2.length];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31946,
                "title": "clear-code-java-1ms-solution",
                "content": "```\\npublic class Solution {\\n    public boolean isInterleave(String a, String b, String c) {\\n        if (a.length() + b.length() != c.length())\\n            return false;\\n        return isInterleave(0, 0, new boolean[a.length() + 1][b.length() + 1], a, b, c);\\n    }\\n    public boolean isInterleave(int i, int j, boolean[][] f, String a, String b, String c) {\\n        if (f[i][j])\\n            return false;\\n        else\\n            f[i][j] = true;\\n        if (i == a.length() && j == b.length())\\n            return true;\\n        if (i < a.length() && a.charAt(i) == c.charAt(i + j) && isInterleave(i + 1, j, f, a, b, c))\\n            return true;\\n        if (j < b.length() && b.charAt(j) == c.charAt(i + j) && isInterleave(i, j + 1, f, a, b, c))\\n            return true;\\n        return false;\\n    }\\n}\\n```\\nThe idea is very clear so that I don't think any explanation is needed. QAQ",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public boolean isInterleave(String a, String b, String c) {\\n        if (a.length() + b.length() != c.length())\\n            return false;\\n        return isInterleave(0, 0, new boolean[a.length() + 1][b.length() + 1], a, b, c);\\n    }\\n    public boolean isInterleave(int i, int j, boolean[][] f, String a, String b, String c) {\\n        if (f[i][j])\\n            return false;\\n        else\\n            f[i][j] = true;\\n        if (i == a.length() && j == b.length())\\n            return true;\\n        if (i < a.length() && a.charAt(i) == c.charAt(i + j) && isInterleave(i + 1, j, f, a, b, c))\\n            return true;\\n        if (j < b.length() && b.charAt(j) == c.charAt(i + j) && isInterleave(i, j + 1, f, a, b, c))\\n            return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32075,
                "title": "share-accepted-python-solution",
                "content": "    class Solution:\\n        # @return a boolean\\n        def isInterleave(self, s1, s2, s3):\\n            #dp[i][j][k] = True if s3[:k] is interleave of s1[:i] and s2[:j]\\n            #dp[i][j][k] = (dp[i-1][j][k-1] if s1[i] == s3[k]) or (dp[i][j-1][k-1] if s2[j] == s3[k])\\n            #dp[0][0][0] = True\\n            #dp[i][j][k] = False if i+j != k   Since k always = i+j, we can eliminate one dimension\\n            if len(s1)+len(s2) != len(s3): return False\\n            dp = [[False for j in range(len(s2)+1)] for i in range(len(s1)+1)]\\n            for i in range(0, len(s1)+1):\\n                for j in range(0, len(s2)+1): #k is determined\\n                    if i == 0 and j == 0:\\n                        dp[i][j] = True\\n                    elif i == 0:                        #\"aa\", \"ab\", \"abaa\" length of s1 is 0\\n                        dp[i][j] = s2[:j] == s3[:j]\\n                    elif j == 0:                        #length of s2 is 0\\n                        dp[i][j] = s1[:i] == s3[:i]\\n                    else:\\n                        dp[i][j] = (dp[i-1][j] and s1[i-1] == s3[i+j-1]) or (dp[i][j-1] and s2[j-1] == s3[i+j-1])\\n            return dp[-1][-1]",
                "solutionTags": [],
                "code": "    class Solution:\\n        # @return a boolean\\n        def isInterleave(self, s1, s2, s3):\\n            #dp[i][j][k] = True if s3[:k] is interleave of s1[:i] and s2[:j]\\n            #dp[i][j][k] = (dp[i-1][j][k-1] if s1[i] == s3[k]) or (dp[i][j-1][k-1] if s2[j] == s3[k])\\n            #dp[0][0][0] = True\\n            #dp[i][j][k] = False if i+j != k   Since k always = i+j, we can eliminate one dimension\\n            if len(s1)+len(s2) != len(s3): return False\\n            dp = [[False for j in range(len(s2)+1)] for i in range(len(s1)+1)]\\n            for i in range(0, len(s1)+1):\\n                for j in range(0, len(s2)+1): #k is determined\\n                    if i == 0 and j == 0:\\n                        dp[i][j] = True\\n                    elif i == 0:                        #\"aa\", \"ab\", \"abaa\" length of s1 is 0\\n                        dp[i][j] = s2[:j] == s3[:j]\\n                    elif j == 0:                        #length of s2 is 0\\n                        dp[i][j] = s1[:i] == s3[:i]\\n                    else:\\n                        dp[i][j] = (dp[i-1][j] and s1[i-1] == s3[i+j-1]) or (dp[i][j-1] and s2[j-1] == s3[i+j-1])\\n            return dp[-1][-1]",
                "codeTag": "Java"
            },
            {
                "id": 31933,
                "title": "definition-of-interleave-on-test-examples",
                "content": "    The example says:\\n    s1 \"aabcc\"\\n    s2 \"dbbca\"\\n    s3 \"aadbbcbcac\" is interleave,\\n    \\n    if we decompose: s3\\n    \"aa\"   \"db\"  \"bc\"  \"bc\"  \"a\"  \"c\"\\n     s1     s2    s1    s2   s2    s1\\n    \\n    It is not interleaving right?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 3997350,
                "title": "interleaving-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int dp[101][101];\\n    bool solve(string &s1, string &s2, string &s3,int i,int j)\\n    {\\n        if(i == s1.length() && j == s2.length() && i+j == s3.length()) return true;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        bool result = false;\\n        \\n        if(i < s1.length() && j < s2.length() && s1[i] == s3[i+j] && s2[j] == s3[i+j])\\n        {\\n            result = (solve(s1,s2,s3,i+1,j) || solve(s1,s2,s3,i,j+1));\\n        }\\n        else if(i < s1.length() && s1[i] == s3[i+j])\\n        {\\n            result = solve(s1,s2,s3,i+1,j);\\n        }\\n        else if(j < s2.length() && s2[j] == s3[i+j])\\n        {\\n            result = solve(s1,s2,s3,i,j+1);\\n        }\\n        return dp[i][j] = result;\\n    }\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) \\n    {\\n      if(s1.length() + s2.length() != s3.length()) return false;\\n      memset(dp,-1,sizeof(dp));\\n      return solve(s1,s2,s3,0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int dp[101][101];\\n    bool solve(string &s1, string &s2, string &s3,int i,int j)\\n    {\\n        if(i == s1.length() && j == s2.length() && i+j == s3.length()) return true;\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        bool result = false;\\n        \\n        if(i < s1.length() && j < s2.length() && s1[i] == s3[i+j] && s2[j] == s3[i+j])\\n        {\\n            result = (solve(s1,s2,s3,i+1,j) || solve(s1,s2,s3,i,j+1));\\n        }\\n        else if(i < s1.length() && s1[i] == s3[i+j])\\n        {\\n            result = solve(s1,s2,s3,i+1,j);\\n        }\\n        else if(j < s2.length() && s2[j] == s3[i+j])\\n        {\\n            result = solve(s1,s2,s3,i,j+1);\\n        }\\n        return dp[i][j] = result;\\n    }\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) \\n    {\\n      if(s1.length() + s2.length() != s3.length()) return false;\\n      memset(dp,-1,sizeof(dp));\\n      return solve(s1,s2,s3,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3959506,
                "title": "faster-99-73-easy-and-clean-dp-top-down-bottom-up",
                "content": "# Please Upvote if you liked my Solution \\uD83E\\uDD17\\uD83E\\uDD17\\n> **Please do UpVote** it took lot of time to figure out these solutions\\n\\n# Complexity \\n- Time complexity: $$O(N*M)$$ for `N = s1.length` and `M = s2.length`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N*M)$$ for `Solution 1` and `Solution 2`\\n- Space complexity: $$O(N)$$ for `Solution 3`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n# C++ Code\\n```\\nclass Solution {\\n    int isInterleaveHelp(int i, int j, vector<vector<int>> &dp, string &s1, string &s2, string &s3) {\\n        if( i+j == s3.size() ) return 1;\\n        if( dp[i][j] != -1 ) return dp[i][j];\\n\\n        if( i<s1.size() && s1[i] == s3[i+j] && isInterleaveHelp(i+1, j, dp, s1, s2, s3) )\\n            return dp[i][j] = 1;\\n        if( j<s2.size() && s2[j] == s3[i+j] && isInterleaveHelp(i, j+1, dp, s1, s2, s3) )\\n            return dp[i][j] = 1;\\n        return dp[i][j] = 0;\\n    }\\n\\npublic:\\n    // Solution 1 - TOP DOWN DP - SC - O(N*M)\\n    bool isInterleave1(string s1, string s2, string s3) {\\n        if( s1.size() + s2.size() != s3.size() ) return 0;\\n        int n = s1.size(), m = s2.size();\\n        vector<vector<int>> dp(n+1, vector<int>(m+1, -1));\\n        return isInterleaveHelp(0, 0, dp, s1, s2, s3) == 1;\\n    }\\n\\n\\n    // Solution 2 - BOTTOM UP DP - SC - O(N*M)\\n    bool isInterleave2(string s1, string s2, string s3) {\\n        if( s1.size() + s2.size() != s3.size() ) return 0;\\n        int n = s1.size(), m = s2.size();\\n        vector<vector<int>> dp(n+1, vector<int>(m+1, 0));\\n\\n        for(int i=n; i>=0; i--){\\n            for(int j=m; j>=0; j--){\\n                int ans = (i + j == s3.size());\\n                if( i<s1.size() && s1[i] == s3[i+j] ) ans |= dp[i+1][j];\\n                if( j<s2.size() && s2[j] == s3[i+j] ) ans |= dp[i][j+1];\\n                dp[i][j] = ans;\\n            }\\n        }\\n        return dp[0][0] == 1;\\n    }\\n\\n\\n    // Solution 3 - BOTTOM UP - Space Optimized - SC - O(M)\\n    bool isInterleave(string s1, string s2, string s3) {\\n        if( s1.size() + s2.size() != s3.size() ) return 0;\\n        int n = s1.size(), m = s2.size();\\n        vector<int> cur(m+1, 0);\\n\\n        for(int i=n; i>=0; i--){\\n            for(int j=m; j>=0; j--){\\n                int ans = (i + j == s3.size());\\n                if( i<s1.size() && s1[i] == s3[i+j] ) ans |= cur[j];\\n                if( j<s2.size() && s2[j] == s3[i+j] ) ans |= cur[j+1];\\n                cur[j] = ans;\\n            }\\n        }\\n        return cur[0] == 1;\\n    }\\n};\\n```\\n\\n---\\n\\n# Java Code\\n```\\nclass Solution {\\n    private int isInterleaveHelp(int i, int j, int dp[][], String s1, String s2, String s3) {\\n        if( i+j == s3.length() ) return 1;\\n        if( dp[i][j] != -1 ) return dp[i][j];\\n\\n        int ans = 0;\\n        if( i<s1.length() && s1.charAt(i) == s3.charAt(i+j) )\\n            ans |= isInterleaveHelp(i+1, j, dp, s1, s2, s3);\\n        \\n        if( j<s2.length() && s2.charAt(j) == s3.charAt(i+j) )\\n            ans |= isInterleaveHelp(i, j+1, dp, s1, s2, s3);\\n        \\n        return dp[i][j] = ans;\\n    }\\n\\n\\n\\n    // Solution 1 - TOP DOWN DP - SC - O(N*M)\\n    public boolean isInterleave1(String s1, String s2, String s3) {\\n        if( s1.length() + s2.length() != s3.length() ) return false;\\n        int n = s1.length(), m = s2.length();\\n        int dp[][] = new int[n+1][m+1];\\n        for(int row[] : dp) Arrays.fill(row, -1);\\n        return isInterleaveHelp(0, 0, dp, s1, s2, s3) == 1;\\n    }\\n\\n\\n\\n    // Solution 2 - BOTTOM UP DP - SC - O(N*M)\\n    public boolean isInterleave2(String s1, String s2, String s3) {\\n        if( s1.length() + s2.length() != s3.length() ) return false;\\n        int n = s1.length(), m = s2.length();\\n        int dp[][] = new int[n+1][m+1];\\n\\n        for(int i=n; i>=0; i--){\\n            for(int j=m; j>=0; j--){\\n                int ans = (i + j == s3.length() ? 1 : 0);\\n                if( i<s1.length() && s1.charAt(i) == s3.charAt(i+j) ) ans |= dp[i+1][j];\\n                if( j<s2.length() && s2.charAt(j) == s3.charAt(i+j) ) ans |= dp[i][j+1];\\n                dp[i][j] = ans;\\n            }\\n        }\\n        return dp[0][0] == 1;\\n    }\\n\\n\\n\\n    // Solution 3 - BOTTOM UP - Space Optimized - SC - O(M)\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        if( s1.length() + s2.length() != s3.length() ) return false;\\n        int n = s1.length(), m = s2.length();\\n        int cur[] = new int[m+1];\\n\\n        for(int i=n; i>=0; i--){\\n            for(int j=m; j>=0; j--){\\n                int ans = (i + j == s3.length() ? 1 : 0 );\\n                if( i<n && s1.charAt(i) == s3.charAt(i+j) ) ans |= cur[j];\\n                if( j<m && s2.charAt(j) == s3.charAt(i+j) ) ans |= cur[j+1];\\n                cur[j] = ans;\\n            }\\n        }\\n        return cur[0] == 1;\\n    }\\n}\\n```\\n\\n![upvote-4.png](https://assets.leetcode.com/users/images/5af4e2a5-e8b2-4f46-be00-75247cfdf9ff_1689947516.7818904.png)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "String",
                    "Dynamic Programming",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\n    int isInterleaveHelp(int i, int j, vector<vector<int>> &dp, string &s1, string &s2, string &s3) {\\n        if( i+j == s3.size() ) return 1;\\n        if( dp[i][j] != -1 ) return dp[i][j];\\n\\n        if( i<s1.size() && s1[i] == s3[i+j] && isInterleaveHelp(i+1, j, dp, s1, s2, s3) )\\n            return dp[i][j] = 1;\\n        if( j<s2.size() && s2[j] == s3[i+j] && isInterleaveHelp(i, j+1, dp, s1, s2, s3) )\\n            return dp[i][j] = 1;\\n        return dp[i][j] = 0;\\n    }\\n\\npublic:\\n    // Solution 1 - TOP DOWN DP - SC - O(N*M)\\n    bool isInterleave1(string s1, string s2, string s3) {\\n        if( s1.size() + s2.size() != s3.size() ) return 0;\\n        int n = s1.size(), m = s2.size();\\n        vector<vector<int>> dp(n+1, vector<int>(m+1, -1));\\n        return isInterleaveHelp(0, 0, dp, s1, s2, s3) == 1;\\n    }\\n\\n\\n    // Solution 2 - BOTTOM UP DP - SC - O(N*M)\\n    bool isInterleave2(string s1, string s2, string s3) {\\n        if( s1.size() + s2.size() != s3.size() ) return 0;\\n        int n = s1.size(), m = s2.size();\\n        vector<vector<int>> dp(n+1, vector<int>(m+1, 0));\\n\\n        for(int i=n; i>=0; i--){\\n            for(int j=m; j>=0; j--){\\n                int ans = (i + j == s3.size());\\n                if( i<s1.size() && s1[i] == s3[i+j] ) ans |= dp[i+1][j];\\n                if( j<s2.size() && s2[j] == s3[i+j] ) ans |= dp[i][j+1];\\n                dp[i][j] = ans;\\n            }\\n        }\\n        return dp[0][0] == 1;\\n    }\\n\\n\\n    // Solution 3 - BOTTOM UP - Space Optimized - SC - O(M)\\n    bool isInterleave(string s1, string s2, string s3) {\\n        if( s1.size() + s2.size() != s3.size() ) return 0;\\n        int n = s1.size(), m = s2.size();\\n        vector<int> cur(m+1, 0);\\n\\n        for(int i=n; i>=0; i--){\\n            for(int j=m; j>=0; j--){\\n                int ans = (i + j == s3.size());\\n                if( i<s1.size() && s1[i] == s3[i+j] ) ans |= cur[j];\\n                if( j<s2.size() && s2[j] == s3[i+j] ) ans |= cur[j+1];\\n                cur[j] = ans;\\n            }\\n        }\\n        return cur[0] == 1;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    private int isInterleaveHelp(int i, int j, int dp[][], String s1, String s2, String s3) {\\n        if( i+j == s3.length() ) return 1;\\n        if( dp[i][j] != -1 ) return dp[i][j];\\n\\n        int ans = 0;\\n        if( i<s1.length() && s1.charAt(i) == s3.charAt(i+j) )\\n            ans |= isInterleaveHelp(i+1, j, dp, s1, s2, s3);\\n        \\n        if( j<s2.length() && s2.charAt(j) == s3.charAt(i+j) )\\n            ans |= isInterleaveHelp(i, j+1, dp, s1, s2, s3);\\n        \\n        return dp[i][j] = ans;\\n    }\\n\\n\\n\\n    // Solution 1 - TOP DOWN DP - SC - O(N*M)\\n    public boolean isInterleave1(String s1, String s2, String s3) {\\n        if( s1.length() + s2.length() != s3.length() ) return false;\\n        int n = s1.length(), m = s2.length();\\n        int dp[][] = new int[n+1][m+1];\\n        for(int row[] : dp) Arrays.fill(row, -1);\\n        return isInterleaveHelp(0, 0, dp, s1, s2, s3) == 1;\\n    }\\n\\n\\n\\n    // Solution 2 - BOTTOM UP DP - SC - O(N*M)\\n    public boolean isInterleave2(String s1, String s2, String s3) {\\n        if( s1.length() + s2.length() != s3.length() ) return false;\\n        int n = s1.length(), m = s2.length();\\n        int dp[][] = new int[n+1][m+1];\\n\\n        for(int i=n; i>=0; i--){\\n            for(int j=m; j>=0; j--){\\n                int ans = (i + j == s3.length() ? 1 : 0);\\n                if( i<s1.length() && s1.charAt(i) == s3.charAt(i+j) ) ans |= dp[i+1][j];\\n                if( j<s2.length() && s2.charAt(j) == s3.charAt(i+j) ) ans |= dp[i][j+1];\\n                dp[i][j] = ans;\\n            }\\n        }\\n        return dp[0][0] == 1;\\n    }\\n\\n\\n\\n    // Solution 3 - BOTTOM UP - Space Optimized - SC - O(M)\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n        if( s1.length() + s2.length() != s3.length() ) return false;\\n        int n = s1.length(), m = s2.length();\\n        int cur[] = new int[m+1];\\n\\n        for(int i=n; i>=0; i--){\\n            for(int j=m; j>=0; j--){\\n                int ans = (i + j == s3.length() ? 1 : 0 );\\n                if( i<n && s1.charAt(i) == s3.charAt(i+j) ) ans |= cur[j];\\n                if( j<m && s2.charAt(j) == s3.charAt(i+j) ) ans |= cur[j+1];\\n                cur[j] = ans;\\n            }\\n        }\\n        return cur[0] == 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957919,
                "title": "python-3-one-line",
                "content": "Looks like this is the shortest:\\n```python\\nclass Solution:\\n    @cache\\n    def isInterleave(self, a: str, b: str, c: str) -> bool:\\n        return any(c[:1]==x[:1]and self.isInterleave(x[1:],y,c[1:])for x,y in((a,b),(b,a)))if(a and b)else(a or b or\\'\\')==c\\n```\\nYou can also use cache decorator as a function:\\n```python\\nclass Solution:\\n    def isInterleave(self, a: str, b: str, c: str) -> bool:\\n        return(f:=cache(lambda a,b,c:any(c[:1]==x[:1]and f(x[1:],y,c[1:])for x,y in((a,b),(b,a)))if(a and b)else(a or b or\\'\\')==c))(a,b,c)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    @cache\\n    def isInterleave(self, a: str, b: str, c: str) -> bool:\\n        return any(c[:1]==x[:1]and self.isInterleave(x[1:],y,c[1:])for x,y in((a,b),(b,a)))if(a and b)else(a or b or\\'\\')==c\\n```\n```python\\nclass Solution:\\n    def isInterleave(self, a: str, b: str, c: str) -> bool:\\n        return(f:=cache(lambda a,b,c:any(c[:1]==x[:1]and f(x[1:],y,c[1:])for x,y in((a,b),(b,a)))if(a and b)else(a or b or\\'\\')==c))(a,b,c)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957841,
                "title": "using-dp",
                "content": "# Intuition\\nYou can solve this problem using dynamic programming.\\n\\n# Approach\\n\\n\\nThe dp[i][j] entry in the 2D array represents whether the first i characters of s1 and the first j characters of s2 can form the first i+j characters of s3. The dynamic programming approach iterates through all possible combinations of s1 and s2 substrings and checks if they can form the corresponding substring of s3.\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n^2)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def isInterleave(self, s1, s2, s3):\\n        \"\"\"\\n        :type s1: str\\n        :type s2: str\\n        :type s3: str\\n        :rtype: bool\\n        \"\"\"\\n        if len(s1) + len(s2) != len(s3):\\n            return False\\n    \\n        dp = [[False] * (len(s2) + 1) for _ in range(len(s1) + 1)]\\n        \\n        dp[0][0] = True\\n        \\n        for i in range(len(s1) + 1):\\n            for j in range(len(s2) + 1):\\n                if i > 0 and s1[i - 1] == s3[i + j - 1]:\\n                    dp[i][j] |= dp[i - 1][j]\\n                if j > 0 and s2[j - 1] == s3[i + j - 1]:\\n                    dp[i][j] |= dp[i][j - 1]\\n                    \\n        return dp[len(s1)][len(s2)]\\n\\n\\n```\\n# **PLEASE DO UPVOTE!!!\\uD83E\\uDD79**",
                "solutionTags": [
                    "Python",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def isInterleave(self, s1, s2, s3):\\n        \"\"\"\\n        :type s1: str\\n        :type s2: str\\n        :type s3: str\\n        :rtype: bool\\n        \"\"\"\\n        if len(s1) + len(s2) != len(s3):\\n            return False\\n    \\n        dp = [[False] * (len(s2) + 1) for _ in range(len(s1) + 1)]\\n        \\n        dp[0][0] = True\\n        \\n        for i in range(len(s1) + 1):\\n            for j in range(len(s2) + 1):\\n                if i > 0 and s1[i - 1] == s3[i + j - 1]:\\n                    dp[i][j] |= dp[i - 1][j]\\n                if j > 0 and s2[j - 1] == s3[i + j - 1]:\\n                    dp[i][j] |= dp[i][j - 1]\\n                    \\n        return dp[len(s1)][len(s2)]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957744,
                "title": "inter-leave",
                "content": "# Intuition\\nMy initial thoughts on solving this problem are to use a Depth-First Search (DFS) approach to determine whether a given string `s3` can be formed by interleaving characters from two input strings `s1` and `s2`.\\n\\n# Approach\\nThe approach I\\'ve taken to solve this problem is to use a recursive DFS algorithm with memoization. The idea is to consider each character of `s1` and `s2` and check if it matches the current character of `s3`. If there\\'s a match, we recursively check the next characters from both `s1` and `s2` along with the next character from `s3`. If either of these recursive calls returns true, it means that we\\'ve successfully formed an interleaved string up to this point. \\n\\nI\\'m using a 2D boolean array `dp` to store the memoization information. The element `dp[i][j]` represents whether the substring formed by considering the first `i` characters from `s1` and the first `j` characters from `s2` can form the first `i+j` characters of `s3`.\\n\\n# Complexity\\n- Time complexity: The worst-case time complexity of the algorithm is O(m * n), where `m` is the length of string `s1` and `n` is the length of string `s2`. This is because for each character of `s1`, we potentially explore all characters of `s2`.\\n- Space complexity: The space complexity is O(m * n), as we are using a 2D array `dp` of size `(m+1) x (n+1)` for memoization.\\n\\n# Code\\n```java\\nimport java.util.*;\\n\\nclass Solution {\\n    public static boolean dfs(char c1[], char c2[], char c3[], int i, int j, int k, boolean dp[][]) {\\n        if (dp[i][j]) {\\n            return false;\\n        }\\n        if (k == c3.length) {\\n            return true;\\n        }\\n        boolean valid = i < c1.length && c1[i] == c3[k] && dfs(c1, c2, c3, i + 1, j, k + 1, dp)\\n                || j < c2.length && c2[j] == c3[k] && dfs(c1, c2, c3, i, j + 1, k + 1, dp);\\n        if (!valid) {\\n            dp[i][j] = true;\\n        }\\n        return valid;\\n    }\\n\\n    public static boolean isInterleave(String s1, String s2, String s3) {\\n        char c1[] = s1.toCharArray(), c2[] = s2.toCharArray(), c3[] = s3.toCharArray();\\n        int m = s1.length(), n = s2.length();\\n        if (m + n != s3.length()) {\\n            return false;\\n        }\\n        boolean dp[][] = new boolean[m + 1][n + 1];\\n        return dfs(c1, c2, c3, 0, 0, 0, dp);\\n    }\\n}\\n```\\n\\nThis code implements the DFS algorithm with memoization to solve the problem of determining whether `s3` can be formed by interleaving characters from `s1` and `s2`.",
                "solutionTags": [
                    "Java",
                    "String",
                    "Dynamic Programming",
                    "Memoization",
                    "Matrix"
                ],
                "code": "```java\\nimport java.util.*;\\n\\nclass Solution {\\n    public static boolean dfs(char c1[], char c2[], char c3[], int i, int j, int k, boolean dp[][]) {\\n        if (dp[i][j]) {\\n            return false;\\n        }\\n        if (k == c3.length) {\\n            return true;\\n        }\\n        boolean valid = i < c1.length && c1[i] == c3[k] && dfs(c1, c2, c3, i + 1, j, k + 1, dp)\\n                || j < c2.length && c2[j] == c3[k] && dfs(c1, c2, c3, i, j + 1, k + 1, dp);\\n        if (!valid) {\\n            dp[i][j] = true;\\n        }\\n        return valid;\\n    }\\n\\n    public static boolean isInterleave(String s1, String s2, String s3) {\\n        char c1[] = s1.toCharArray(), c2[] = s2.toCharArray(), c3[] = s3.toCharArray();\\n        int m = s1.length(), n = s2.length();\\n        if (m + n != s3.length()) {\\n            return false;\\n        }\\n        boolean dp[][] = new boolean[m + 1][n + 1];\\n        return dfs(c1, c2, c3, 0, 0, 0, dp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957693,
                "title": "most-easy-dp-solution-u-can-get",
                "content": "\\n# **PLS UPVOTE IF YOU LIKE AND COMMENT FOR ANY DOUBT**\\n# Approach\\nsolve function: This function takes the current indices i, j, and k as well as the three strings s1, s2, and s3 and the dp table for memoization.\\n\\nBase Case: The base case of the recursion is when all three strings have been completely used (i == s1.length(), j == s2.length(), and k == s3.length()). In this case, if both s1 and s2 have been fully used, it means we have successfully interleaved s1 and s2 to create s3, and thus, we return true.\\n\\nMemoization: If the state (i, j) has been computed before (indicated by dp[i][j] != -1), then we directly return the precomputed result.\\n\\nRecursive Steps: Two conditions are checked here to recursively explore the interleaving possibilities:\\n\\nIf the current character of s1 (s1[i]) matches the current character of s3 (s3[k]), then we can consider this match and recurse with the next character from s1 and s3. We increment i and k.\\nSimilarly, if the current character of s2 (s2[j]) matches the current character of s3 (s3[k]), then we can consider this match and recurse with the next character from s2 and s3. We increment j and k.\\nReturn: The result of the current state (i, j) is stored in the dp table and returned as a || b, where a and b are the results of the two recursive steps mentioned above.\\n\\nisInterleave function: This function is the entry point of the solution. It checks if the lengths of the strings match correctly. If not, it returns false immediately since interleaving wouldn\\'t be possible. Otherwise, it initializes the dp table and starts the recursion from the (0, 0, 0) state of the solve function\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N*M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(N*M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool solve(string& s1, string& s2, string& s3, int i, int j, int k, vector<vector<int>>& dp) {\\n    if (i == s1.length() && j == s2.length() && k == s3.length()) {\\n        // Both s1 and s2 should be empty at this point to return true\\n        return true;\\n    }\\n    if (dp[i][j] != -1) {\\n        return dp[i][j];\\n    }\\n    bool a = false, b = false;\\n    if( i!=s1.length() && k!=s3.length() && s1[i] == s3[k]) {\\n        a = solve(s1, s2, s3, i+1, j , k+1, dp);\\n    }\\n    if ( j!=s2.length() && k!=s3.length() && s2[j] == s3[k]) {\\n        b = solve(s1, s2, s3, i , j+1 , k+1 , dp);\\n    }\\n    return dp[i][j] = a || b;\\n}\\n\\n   bool isInterleave(string s1, string s2, string s3) {\\n        int n = s1.length();\\n        int m = s2.length();\\n        int len= s3.length();\\n        if(n+m!=len)\\n        {\\n            return false;\\n        }\\n        vector<vector<int>>dp(201,vector<int>(201,-1));\\n        return solve(s1 , s2 , s3 , 0 , 0 , 0 , dp);\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool solve(string& s1, string& s2, string& s3, int i, int j, int k, vector<vector<int>>& dp) {\\n    if (i == s1.length() && j == s2.length() && k == s3.length()) {\\n        // Both s1 and s2 should be empty at this point to return true\\n        return true;\\n    }\\n    if (dp[i][j] != -1) {\\n        return dp[i][j];\\n    }\\n    bool a = false, b = false;\\n    if( i!=s1.length() && k!=s3.length() && s1[i] == s3[k]) {\\n        a = solve(s1, s2, s3, i+1, j , k+1, dp);\\n    }\\n    if ( j!=s2.length() && k!=s3.length() && s2[j] == s3[k]) {\\n        b = solve(s1, s2, s3, i , j+1 , k+1 , dp);\\n    }\\n    return dp[i][j] = a || b;\\n}\\n\\n   bool isInterleave(string s1, string s2, string s3) {\\n        int n = s1.length();\\n        int m = s2.length();\\n        int len= s3.length();\\n        if(n+m!=len)\\n        {\\n            return false;\\n        }\\n        vector<vector<int>>dp(201,vector<int>(201,-1));\\n        return solve(s1 , s2 , s3 , 0 , 0 , 0 , dp);\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957663,
                "title": "c-recursion-memoisation-tabulation-follow-up-space-optimisation",
                "content": "\\n# Recursion(TLE)\\n```\\nclass Solution {\\npublic:\\n    bool helper(string&s1,string&s2,string&s3,int i,int j){\\n        if(i+j==s3.length())return true;\\n        int ans=false;\\n        if(i<s1.length()&&j<s2.length()&&s1[i]==s3[i+j]&&s2[j]==s3[i+j]){\\n            bool take1 =helper(s1,s2,s3,i+1,j);\\n            bool take2=helper(s1,s2,s3,i,j+1);\\n            ans=take1||take2;\\n        }\\n        else if(i<s1.length()&&s1[i]==s3[i+j]){\\n            ans=helper(s1,s2,s3,i+1,j);\\n        }\\n        else if(j<s2.length()&&s2[j]==s3[i+j]){\\n            ans=helper(s1,s2,s3,i,j+1);\\n        }\\n        return ans;\\n\\n    }\\n    bool isInterleave(string s1, string s2, string s3) {\\n        if(s1.length()+s2.length()!=s3.length())return false;\\n        return helper(s1,s2,s3,0,0);\\n    }\\n};\\n```\\n# Memoisation(AC)\\n```\\nclass Solution {\\npublic:\\nvector<vector<int>>memo;\\n    bool helper(string&s1,string&s2,string&s3,int i,int j){\\n        if(i+j==s3.length())return true;\\n        if(memo[i][j]!=-1)return memo[i][j];\\n        int ans=false;\\n        if(i<s1.length()&&j<s2.length()&&s1[i]==s3[i+j]&&s2[j]==s3[i+j]){\\n            bool take1 =helper(s1,s2,s3,i+1,j);\\n            bool take2=helper(s1,s2,s3,i,j+1);\\n            ans=take1||take2;\\n        }\\n        else if(i<s1.length()&&s1[i]==s3[i+j]){\\n            ans=helper(s1,s2,s3,i+1,j);\\n        }\\n        else if(j<s2.length()&&s2[j]==s3[i+j]){\\n            ans=helper(s1,s2,s3,i,j+1);\\n        }\\n        return memo[i][j]= ans;\\n\\n    }\\n    bool isInterleave(string s1, string s2, string s3) {\\n        memo.resize(s1.length()+1,vector<int>(s2.length()+1,-1));\\n        if(s1.length()+s2.length()!=s3.length())return false;\\n        return helper(s1,s2,s3,0,0);\\n    }\\n};\\n```\\n# Tabulation(AC) \\n**space complexity**: `0(s1.length*s2.length)`\\n```\\nclass Solution {\\npublic:\\n\\n    bool isInterleave(string s1, string s2, string s3) {\\n        if(s1.length()+s2.length()!=s3.length())return false;\\n        vector<vector<bool>>dp(s1.length()+1,vector<bool>(s2.length()+1));\\n        dp[0][0]=1; //satisfies because s1,s2,and s3 are empty strings\\n        for(int j=1;j<s2.length()+1;j++){ //check when s1 length is zero\\n             dp[0][j]=dp[0][j-1]&&(s2[j-1]==s3[j-1]);\\n        }\\n        for(int i=1;i<s1.length()+1;i++){ //check when s2 length is zero\\n             dp[i][0]=dp[i-1][0]&&(s1[i-1]==s3[i-1]);\\n        }\\n        for(int i=1;i<s1.length()+1;i++){\\n            for(int j=1;j<s2.length()+1;j++){\\n                bool a=(s1[i-1]==s3[i+j-1])&&dp[i-1][j];\\n                bool b=(s2[j-1]==s3[i+j-1])&&dp[i][j-1];\\n                dp[i][j]=a||b;\\n            }\\n        }\\n        return dp[s1.length()][s2.length()];\\n    }\\n};\\n```\\n# Space optimisation(Follow up):\\n **space complexity**: `0(s2.length)`\\n```\\n bool isInterleave(string s1, string s2, string s3) {\\n        if(s1.length()+s2.length()!=s3.length())return false;\\n\\n       vector<bool>dp(s2.length()+1);\\n        dp[0]=1; //satisfies because s1,s2,and s3 are empty strings\\n        for(int j=1;j<s2.length()+1;j++){ //check when s1 length is zero\\n             dp[j]=dp[j-1]&&(s2[j-1]==s3[j-1]);\\n        }\\n        \\n        for(int i=1;i<s1.length()+1;i++){\\n            dp[0]=(s3[i-1]==s1[i-1])&&dp[0];\\n            for(int j=1;j<s2.length()+1;j++){\\n                bool a=(s1[i-1]==s3[i+j-1])&&dp[j];\\n                bool b=(s2[j-1]==s3[i+j-1])&&dp[j-1];\\n                dp[j]=a||b;\\n            }\\n        }\\n        return dp[s2.length()];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool helper(string&s1,string&s2,string&s3,int i,int j){\\n        if(i+j==s3.length())return true;\\n        int ans=false;\\n        if(i<s1.length()&&j<s2.length()&&s1[i]==s3[i+j]&&s2[j]==s3[i+j]){\\n            bool take1 =helper(s1,s2,s3,i+1,j);\\n            bool take2=helper(s1,s2,s3,i,j+1);\\n            ans=take1||take2;\\n        }\\n        else if(i<s1.length()&&s1[i]==s3[i+j]){\\n            ans=helper(s1,s2,s3,i+1,j);\\n        }\\n        else if(j<s2.length()&&s2[j]==s3[i+j]){\\n            ans=helper(s1,s2,s3,i,j+1);\\n        }\\n        return ans;\\n\\n    }\\n    bool isInterleave(string s1, string s2, string s3) {\\n        if(s1.length()+s2.length()!=s3.length())return false;\\n        return helper(s1,s2,s3,0,0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\nvector<vector<int>>memo;\\n    bool helper(string&s1,string&s2,string&s3,int i,int j){\\n        if(i+j==s3.length())return true;\\n        if(memo[i][j]!=-1)return memo[i][j];\\n        int ans=false;\\n        if(i<s1.length()&&j<s2.length()&&s1[i]==s3[i+j]&&s2[j]==s3[i+j]){\\n            bool take1 =helper(s1,s2,s3,i+1,j);\\n            bool take2=helper(s1,s2,s3,i,j+1);\\n            ans=take1||take2;\\n        }\\n        else if(i<s1.length()&&s1[i]==s3[i+j]){\\n            ans=helper(s1,s2,s3,i+1,j);\\n        }\\n        else if(j<s2.length()&&s2[j]==s3[i+j]){\\n            ans=helper(s1,s2,s3,i,j+1);\\n        }\\n        return memo[i][j]= ans;\\n\\n    }\\n    bool isInterleave(string s1, string s2, string s3) {\\n        memo.resize(s1.length()+1,vector<int>(s2.length()+1,-1));\\n        if(s1.length()+s2.length()!=s3.length())return false;\\n        return helper(s1,s2,s3,0,0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\n    bool isInterleave(string s1, string s2, string s3) {\\n        if(s1.length()+s2.length()!=s3.length())return false;\\n        vector<vector<bool>>dp(s1.length()+1,vector<bool>(s2.length()+1));\\n        dp[0][0]=1; //satisfies because s1,s2,and s3 are empty strings\\n        for(int j=1;j<s2.length()+1;j++){ //check when s1 length is zero\\n             dp[0][j]=dp[0][j-1]&&(s2[j-1]==s3[j-1]);\\n        }\\n        for(int i=1;i<s1.length()+1;i++){ //check when s2 length is zero\\n             dp[i][0]=dp[i-1][0]&&(s1[i-1]==s3[i-1]);\\n        }\\n        for(int i=1;i<s1.length()+1;i++){\\n            for(int j=1;j<s2.length()+1;j++){\\n                bool a=(s1[i-1]==s3[i+j-1])&&dp[i-1][j];\\n                bool b=(s2[j-1]==s3[i+j-1])&&dp[i][j-1];\\n                dp[i][j]=a||b;\\n            }\\n        }\\n        return dp[s1.length()][s2.length()];\\n    }\\n};\\n```\n```\\n bool isInterleave(string s1, string s2, string s3) {\\n        if(s1.length()+s2.length()!=s3.length())return false;\\n\\n       vector<bool>dp(s2.length()+1);\\n        dp[0]=1; //satisfies because s1,s2,and s3 are empty strings\\n        for(int j=1;j<s2.length()+1;j++){ //check when s1 length is zero\\n             dp[j]=dp[j-1]&&(s2[j-1]==s3[j-1]);\\n        }\\n        \\n        for(int i=1;i<s1.length()+1;i++){\\n            dp[0]=(s3[i-1]==s1[i-1])&&dp[0];\\n            for(int j=1;j<s2.length()+1;j++){\\n                bool a=(s1[i-1]==s3[i+j-1])&&dp[j];\\n                bool b=(s2[j-1]==s3[i+j-1])&&dp[j-1];\\n                dp[j]=a||b;\\n            }\\n        }\\n        return dp[s2.length()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957198,
                "title": "c-recursion-memoization-dp-simple-code-with-explanation-mr-robot",
                "content": "# Approach 1 Recursion : TLE\\n```\\nclass Solution {\\n    private:\\n    bool solve(string &s1,int i, string &s2, int j,string &s3,int k){\\n        if(k == s3.length())return true;\\n        if(i < s1.size() && s1[i] == s3[k]  && j<s2.size() && s2[j] == s3[k]){\\n           \\n            return solve(s1,i+1,s2,j,s3,k+1) ||  solve(s1,i,s2,j+1,s3,k+1);\\n        }\\n        else if(i < s1.size() && s1[i] == s3[k]){\\n           \\n            return solve(s1,i+1,s2,j,s3,k+1);\\n        }\\n        else if (j<s2.size() && s2[j] == s3[k]){\\n          \\n            return solve(s1,i,s2,j+1,s3,k+1);\\n        }\\n        else return false;\\n    }\\npublic:\\n\\n    bool isInterleave(string s1, string s2, string s3) {\\n        if(s1.size() + s2.size() != s3.size())return false;\\n        return solve(s1,0,s2,0,s3,0);\\n    }\\n};\\n```\\n\\n# Complexity Analysis\\n\\n- **Time complexity** : O(2^{m+n})\\n- **Space complexity** : O(m+n).The size of stack for recursive calls can go upto m+n\\n- m = s1.length()\\n- n = s2.length()\\n\\n\\n\\n---\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n# Approach 2 \\n- Solve Function: This is a recursive helper function that determines whether s3 can be formed by interleaving characters from s1 and s2. The function uses dynamic programming with memoization to avoid redundant calculations. The parameters are the current indices (i, j, k) for s1, s2, and s3 respectively, along with the memoization dp vector.\\n\\n- Base Case: The base case checks if the index k has reached the length of s3, indicating that the interleaving is successful, and the function returns true.\\n\\n- Memoization: The dp vector is used to store the results of subproblems to avoid recalculating them. If a particular state (i, j, k) has been computed before, it is stored in dp[i][j][k].\\n\\n- Interleaving Logic: The code checks three scenarios to determine if the current characters from s1 and s2 match the character at index k in s3:\\n\\n- If both s1[i] and s2[j] match s3[k], then the function recursively calls itself by either incrementing i or j.\\n- If only s1[i] matches s3[k], the function increments i and proceeds with the next character comparison.\\n- If only s2[j] matches s3[k], the function increments j and proceeds with the next character comparison.\\n- Return: If none of the conditions are met, it means that the current characters of s1 and s2 cannot contribute to the interleaving of s3, so the function returns false.\\n\\n- Return Value: The result of the solve function is returned, which indicates whether s3 can be formed by interleaving s1 and s2.\\n\\n- This solution uses dynamic programming with memoization to avoid redundant calculations, ensuring efficiency in solving the interleaving problem. The concept of recursion and memoization is key to understanding and implementing this solution.\\n\\n\\n\\n---\\n\\n\\n# Approach 2 : Recursion + Memoization\\n```\\nclass Solution {\\n    private:\\n    bool solve(string &s1,int i, string &s2, int j,string &s3,int k,vector<vector<vector<int>>>&dp){\\n        if(k == s3.length())return true;\\n        if(dp[i][j][k] != -1)return dp[i][j][k];\\n        if(i < s1.size() && s1[i] == s3[k]  && j<s2.size() && s2[j] == s3[k]){\\n            return  dp[i][j][k]=solve(s1,i+1,s2,j,s3,k+1,dp) || solve(s1,i,s2,j+1,s3,k+1,dp);\\n        }\\n        else if(i < s1.size() && s1[i] == s3[k]){\\n            return  dp[i][j][k]=solve(s1,i+1,s2,j,s3,k+1,dp);\\n        }\\n        else if (j<s2.size() && s2[j] == s3[k]){ \\n            return  dp[i][j][k]=solve(s1,i,s2,j+1,s3,k+1,dp);\\n        }\\n        else return  dp[i][j][k]=false;\\n    }\\npublic:\\n\\n    bool isInterleave(string s1, string s2, string s3) {\\n        if(s1.size() + s2.size() != s3.size())return false;\\n        vector<vector<vector<int>>>dp(s1.size()+ 1, vector<vector<int>>(s2.size()+1,vector<int>(s3.size()+1,-1)));\\n        return solve(s1,0,s2,0,s3,0,dp);\\n    }\\n\\n};\\n```\\n---\\n![image.png](https://assets.leetcode.com/users/images/9a3019b7-d663-4c47-94a6-c33d8916a04b_1692943277.9862583.png)\\n\\n---\\nDO UPVOTE\\u2B06\\uFE0F\\nDROP YOUR SUGGESTIONS IN THE COMMENT\\n\\nKeep Coding\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\n\\n-- *MR.ROBOT SIGNING OFF*\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    private:\\n    bool solve(string &s1,int i, string &s2, int j,string &s3,int k){\\n        if(k == s3.length())return true;\\n        if(i < s1.size() && s1[i] == s3[k]  && j<s2.size() && s2[j] == s3[k]){\\n           \\n            return solve(s1,i+1,s2,j,s3,k+1) ||  solve(s1,i,s2,j+1,s3,k+1);\\n        }\\n        else if(i < s1.size() && s1[i] == s3[k]){\\n           \\n            return solve(s1,i+1,s2,j,s3,k+1);\\n        }\\n        else if (j<s2.size() && s2[j] == s3[k]){\\n          \\n            return solve(s1,i,s2,j+1,s3,k+1);\\n        }\\n        else return false;\\n    }\\npublic:\\n\\n    bool isInterleave(string s1, string s2, string s3) {\\n        if(s1.size() + s2.size() != s3.size())return false;\\n        return solve(s1,0,s2,0,s3,0);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    private:\\n    bool solve(string &s1,int i, string &s2, int j,string &s3,int k,vector<vector<vector<int>>>&dp){\\n        if(k == s3.length())return true;\\n        if(dp[i][j][k] != -1)return dp[i][j][k];\\n        if(i < s1.size() && s1[i] == s3[k]  && j<s2.size() && s2[j] == s3[k]){\\n            return  dp[i][j][k]=solve(s1,i+1,s2,j,s3,k+1,dp) || solve(s1,i,s2,j+1,s3,k+1,dp);\\n        }\\n        else if(i < s1.size() && s1[i] == s3[k]){\\n            return  dp[i][j][k]=solve(s1,i+1,s2,j,s3,k+1,dp);\\n        }\\n        else if (j<s2.size() && s2[j] == s3[k]){ \\n            return  dp[i][j][k]=solve(s1,i,s2,j+1,s3,k+1,dp);\\n        }\\n        else return  dp[i][j][k]=false;\\n    }\\npublic:\\n\\n    bool isInterleave(string s1, string s2, string s3) {\\n        if(s1.size() + s2.size() != s3.size())return false;\\n        vector<vector<vector<int>>>dp(s1.size()+ 1, vector<vector<int>>(s2.size()+1,vector<int>(s3.size()+1,-1)));\\n        return solve(s1,0,s2,0,s3,0,dp);\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957156,
                "title": "video-solution-explanation-with-drawings-in-depth-c-java",
                "content": "# Intuition, approach, and complexity disucssed in detail in video solution\\nhttps://youtu.be/_X9aOayXvl0\\n\\n# Code\\nC++\\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int len1 = s1.length(), len2 = s2.length(), len3 = s3.length();\\n        if((len1 + len2) != len3){\\n            return false;\\n        }\\n        vector<vector<bool>> indxState(len1+1, vector<bool>(len2+1, false));\\n        indxState[0][0] = true;\\n\\n        for(int indx1 = 1; indx1<indxState.size(); indx1++){\\n            indxState[indx1][0] = indxState[indx1-1][0] && (s1[indx1-1] == s3[indx1-1]); \\n        }\\n        for(int indx2 = 1; indx2<indxState[0].size(); indx2++){\\n            indxState[0][indx2] = indxState[0][indx2-1] && (s2[indx2-1] == s3[indx2-1]);\\n        }\\n        for(int indx1 = 1; indx1<indxState.size(); indx1++){\\n            for(int indx2 = 1; indx2<indxState[0].size(); indx2++){\\n                indxState[indx1][indx2] = (indxState[indx1-1][indx2] && s1[indx1-1] == s3[indx1+indx2-1]) || (indxState[indx1][indx2-1] && s2[indx2-1] == s3[indx1+indx2-1]); \\n            }\\n        }\\n        return indxState[len1][len2];\\n    }\\n};\\n```\\nJava\\n```\\nclass Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n           int len1 = s1.length(), len2 = s2.length(), len3 = s3.length();\\n        if((len1 + len2) != len3){\\n            return false;\\n        }\\n        boolean indxState[][] = new boolean[len1+1][len2+1];\\n        indxState[0][0] = true;\\n\\n        for(int indx1 = 1; indx1<indxState.length; indx1++){\\n            indxState[indx1][0] = indxState[indx1-1][0] && (s1.charAt(indx1-1) == s3.charAt(indx1-1)); \\n        }\\n        for(int indx2 = 1; indx2<indxState[0].length; indx2++){\\n            indxState[0][indx2] = indxState[0][indx2-1] && (s2.charAt(indx2-1) == s3.charAt(indx2-1));\\n        }\\n        for(int indx1 = 1; indx1<indxState.length; indx1++){\\n            for(int indx2 = 1; indx2<indxState[0].length; indx2++){\\n                indxState[indx1][indx2] = (indxState[indx1-1][indx2] && s1.charAt(indx1-1) == s3.charAt(indx1+indx2-1)) || (indxState[indx1][indx2-1] && s2.charAt(indx2-1) == s3.charAt(indx1+indx2-1)); \\n            }\\n        }\\n        return indxState[len1][len2];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int len1 = s1.length(), len2 = s2.length(), len3 = s3.length();\\n        if((len1 + len2) != len3){\\n            return false;\\n        }\\n        vector<vector<bool>> indxState(len1+1, vector<bool>(len2+1, false));\\n        indxState[0][0] = true;\\n\\n        for(int indx1 = 1; indx1<indxState.size(); indx1++){\\n            indxState[indx1][0] = indxState[indx1-1][0] && (s1[indx1-1] == s3[indx1-1]); \\n        }\\n        for(int indx2 = 1; indx2<indxState[0].size(); indx2++){\\n            indxState[0][indx2] = indxState[0][indx2-1] && (s2[indx2-1] == s3[indx2-1]);\\n        }\\n        for(int indx1 = 1; indx1<indxState.size(); indx1++){\\n            for(int indx2 = 1; indx2<indxState[0].size(); indx2++){\\n                indxState[indx1][indx2] = (indxState[indx1-1][indx2] && s1[indx1-1] == s3[indx1+indx2-1]) || (indxState[indx1][indx2-1] && s2[indx2-1] == s3[indx1+indx2-1]); \\n            }\\n        }\\n        return indxState[len1][len2];\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public boolean isInterleave(String s1, String s2, String s3) {\\n           int len1 = s1.length(), len2 = s2.length(), len3 = s3.length();\\n        if((len1 + len2) != len3){\\n            return false;\\n        }\\n        boolean indxState[][] = new boolean[len1+1][len2+1];\\n        indxState[0][0] = true;\\n\\n        for(int indx1 = 1; indx1<indxState.length; indx1++){\\n            indxState[indx1][0] = indxState[indx1-1][0] && (s1.charAt(indx1-1) == s3.charAt(indx1-1)); \\n        }\\n        for(int indx2 = 1; indx2<indxState[0].length; indx2++){\\n            indxState[0][indx2] = indxState[0][indx2-1] && (s2.charAt(indx2-1) == s3.charAt(indx2-1));\\n        }\\n        for(int indx1 = 1; indx1<indxState.length; indx1++){\\n            for(int indx2 = 1; indx2<indxState[0].length; indx2++){\\n                indxState[indx1][indx2] = (indxState[indx1-1][indx2] && s1.charAt(indx1-1) == s3.charAt(indx1+indx2-1)) || (indxState[indx1][indx2-1] && s2.charAt(indx2-1) == s3.charAt(indx1+indx2-1)); \\n            }\\n        }\\n        return indxState[len1][len2];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956862,
                "title": "c-dp",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        if (s3.size() != s1.size() + s2.size()) {\\n            return false;\\n        }\\n        return dfs(s1, s2, s3, 0, 0);\\n    }\\nprivate:\\n    map<pair<int, int>, bool> dp;\\n    \\n    bool dfs(string s1, string s2, string s3, int i, int j) {\\n        if (i == s1.size() && j == s2.size()) {\\n            return true;\\n        }\\n        if (dp.find({i, j}) != dp.end()) {\\n            return dp[{i, j}];\\n        }\\n        \\n        if (i < s1.size() && s1[i] == s3[i + j] && dfs(s1, s2, s3, i + 1, j)) {\\n            return true;\\n        }\\n        if (j < s2.size() && s2[j] == s3[i + j] && dfs(s1, s2, s3, i, j + 1)) {\\n            return true;\\n        }\\n        \\n        dp[{i, j}] = false;\\n        return dp[{i, j}];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        if (s3.size() != s1.size() + s2.size()) {\\n            return false;\\n        }\\n        return dfs(s1, s2, s3, 0, 0);\\n    }\\nprivate:\\n    map<pair<int, int>, bool> dp;\\n    \\n    bool dfs(string s1, string s2, string s3, int i, int j) {\\n        if (i == s1.size() && j == s2.size()) {\\n            return true;\\n        }\\n        if (dp.find({i, j}) != dp.end()) {\\n            return dp[{i, j}];\\n        }\\n        \\n        if (i < s1.size() && s1[i] == s3[i + j] && dfs(s1, s2, s3, i + 1, j)) {\\n            return true;\\n        }\\n        if (j < s2.size() && s2[j] == s3[i + j] && dfs(s1, s2, s3, i, j + 1)) {\\n            return true;\\n        }\\n        \\n        dp[{i, j}] = false;\\n        return dp[{i, j}];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956861,
                "title": "very-simple-dp-code-memoization-c",
                "content": "# Intuition\\n\\n# Approach\\nThere are three states of dp in this question :\\n- character of string s3 matches with s1 and s2\\n- character of string s3 matches with string s1 only\\n- character of string s3 matches with string s2 only\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n     bool solve(int i,int j, int k,string s1,string s2,string s3,vector<vector<int>>&dp){\\n      if(i==s1.size() && j==s2.size() && k==s3.size()) return true;\\n      if(i<s1.size() && j<s2.size() && dp[i][j]!=-1) return dp[i][j];\\n      if(i<s1.size() && j<s2.size() && s1[i]==s3[k] && s2[j]==s3[k]){\\n       return dp[i][j]= solve(i+1,j,k+1,s1,s2,s3,dp)||solve(i,j+1,k+1,s1,s2,s3,dp);\\n      }else if(i<s1.size() && s1[i]==s3[k]){\\n        return dp[i][j]=solve(i+1,j,k+1,s1,s2,s3,dp);\\n       }else if(j<s2.size() && s2[j]==s3[k]){\\n         return dp[i][j]=solve(i,j+1,k+1,s1,s2,s3,dp);\\n       }\\n         return dp[i][j]= false;  \\n            \\n     }\\n     \\n    bool isInterleave(string s1, string s2, string s3) {\\n      if(s1.size()+s2.size() !=s3.size()) return false;\\n      vector<vector<int>>dp(s1.size()+1,vector<int>(s2.size()+1,-1));\\n     return solve(0,0,0,s1,s2,s3,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n     bool solve(int i,int j, int k,string s1,string s2,string s3,vector<vector<int>>&dp){\\n      if(i==s1.size() && j==s2.size() && k==s3.size()) return true;\\n      if(i<s1.size() && j<s2.size() && dp[i][j]!=-1) return dp[i][j];\\n      if(i<s1.size() && j<s2.size() && s1[i]==s3[k] && s2[j]==s3[k]){\\n       return dp[i][j]= solve(i+1,j,k+1,s1,s2,s3,dp)||solve(i,j+1,k+1,s1,s2,s3,dp);\\n      }else if(i<s1.size() && s1[i]==s3[k]){\\n        return dp[i][j]=solve(i+1,j,k+1,s1,s2,s3,dp);\\n       }else if(j<s2.size() && s2[j]==s3[k]){\\n         return dp[i][j]=solve(i,j+1,k+1,s1,s2,s3,dp);\\n       }\\n         return dp[i][j]= false;  \\n            \\n     }\\n     \\n    bool isInterleave(string s1, string s2, string s3) {\\n      if(s1.size()+s2.size() !=s3.size()) return false;\\n      vector<vector<int>>dp(s1.size()+1,vector<int>(s2.size()+1,-1));\\n     return solve(0,0,0,s1,s2,s3,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956476,
                "title": "javascript-solution-explanation-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s1\\n * @param {string} s2\\n * @param {string} s3\\n * @return {boolean}\\n */\\n\\nfunction isInterleave(s1, s2, s3) {\\n    // Check if the total length of s1 and s2 is equal to s3\\n    if (s1.length + s2.length !== s3.length) {\\n        return false;\\n    }\\n\\n    // Create a 2D dynamic programming array dp\\n    const dp = new Array(s1.length + 1).fill(false).map(() => new Array(s2.length + 1).fill(false));\\n\\n    // Base case: Both s1 and s2 are empty, and s3 is also empty\\n    dp[0][0] = true;\\n\\n    // Fill the first column of dp using s1 and s3\\n    for (let i = 1; i <= s1.length; i++) {\\n        dp[i][0] = dp[i - 1][0] && s1[i - 1] === s3[i - 1];\\n    }\\n\\n    // Fill the first row of dp using s2 and s3\\n    for (let j = 1; j <= s2.length; j++) {\\n        dp[0][j] = dp[0][j - 1] && s2[j - 1] === s3[j - 1];\\n    }\\n\\n    // Fill the rest of the dp array based on character matching logic\\n    for (let i = 1; i <= s1.length; i++) {\\n        for (let j = 1; j <= s2.length; j++) {\\n            dp[i][j] = (dp[i - 1][j] && s1[i - 1] === s3[i + j - 1]) ||\\n                       (dp[i][j - 1] && s2[j - 1] === s3[i + j - 1]);\\n        }\\n    }\\n\\n    // Return whether the last cell of dp is true, indicating s3 can be formed by interleaving s1 and s2\\n    return dp[s1.length][s2.length];\\n}\\n\\nconst s1 = \"aabcc\";\\nconst s2 = \"dbbca\";\\nconst s3 = \"aadbbcbcac\";\\nconsole.log(isInterleave(s1, s2, s3)); // Output: true\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s1\\n * @param {string} s2\\n * @param {string} s3\\n * @return {boolean}\\n */\\n\\nfunction isInterleave(s1, s2, s3) {\\n    // Check if the total length of s1 and s2 is equal to s3\\n    if (s1.length + s2.length !== s3.length) {\\n        return false;\\n    }\\n\\n    // Create a 2D dynamic programming array dp\\n    const dp = new Array(s1.length + 1).fill(false).map(() => new Array(s2.length + 1).fill(false));\\n\\n    // Base case: Both s1 and s2 are empty, and s3 is also empty\\n    dp[0][0] = true;\\n\\n    // Fill the first column of dp using s1 and s3\\n    for (let i = 1; i <= s1.length; i++) {\\n        dp[i][0] = dp[i - 1][0] && s1[i - 1] === s3[i - 1];\\n    }\\n\\n    // Fill the first row of dp using s2 and s3\\n    for (let j = 1; j <= s2.length; j++) {\\n        dp[0][j] = dp[0][j - 1] && s2[j - 1] === s3[j - 1];\\n    }\\n\\n    // Fill the rest of the dp array based on character matching logic\\n    for (let i = 1; i <= s1.length; i++) {\\n        for (let j = 1; j <= s2.length; j++) {\\n            dp[i][j] = (dp[i - 1][j] && s1[i - 1] === s3[i + j - 1]) ||\\n                       (dp[i][j - 1] && s2[j - 1] === s3[i + j - 1]);\\n        }\\n    }\\n\\n    // Return whether the last cell of dp is true, indicating s3 can be formed by interleaving s1 and s2\\n    return dp[s1.length][s2.length];\\n}\\n\\nconst s1 = \"aabcc\";\\nconst s2 = \"dbbca\";\\nconst s3 = \"aadbbcbcac\";\\nconsole.log(isInterleave(s1, s2, s3)); // Output: true\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3786588,
                "title": "backtracking-with-memoization-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIdea is that we create this type of a path \\n\\n\\n![image.png](https://assets.leetcode.com/users/images/a028a997-21fc-4f04-8b14-e6c7b78cf49e_1689750812.7706375.png)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf char from s1 is chosen we travel downwards (i+1 ,j) \\n\\nand char from s2 is chosen we travel to the right.\\n\\nand there we update the value.\\n\\n\\n\\nThe trace on the dict is as follows :\\n\\n{(5, 3): False, (5, 5): True, (4, 5): True, (4, 4): True, (4, 3): True, (4, 2): True, (3, 2): True, (3, 1): True, (2, 1): True, (2, 0): True, (1, 0): True, (0, 0): True}\\n\\nGoing from last to first The right path would be like:\\n\\n![image.png](https://assets.leetcode.com/users/images/c3d4b55e-d142-4fef-890b-54d03fa6409a_1689752315.7093666.png)\\n\\nNote :**The movement is backwards and we check the incremented cell before we update our current cell.**\\n\\nIn this wrong trace where \\'c\\' was chosen from s1 , we would not have gotten the subset and thus that backtracking run has failed\\n\\n![image.png](https://assets.leetcode.com/users/images/e9af376b-b69c-4ed0-8458-66dcb3e68e4c_1689752552.5403507.png)\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m*n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m*n)\\n\\n\\n# Code\\n```\\nclass Solution:\\n\\n    \\'\\'\\'\\n            This recursion goes all in and backtracks\\n\\n            Goal string : aadbbcbcac\\n\\n             +---+---+---+---+---+---+\\n            |   | d | b | b | c |   |\\n            +---+---+---+---+---+---+\\n            | a |   |   |   |   |   |\\n            +---+---+---+---+---+---+\\n            | a |   |   |   |   |   |\\n            +---+---+---+---+---+---+\\n            | b |   |   |   |   |   |\\n            +---+---+---+---+---+---+\\n            | c |   |   |   |   |   |\\n            +---+---+---+---+---+---+\\n            | c |   |   |   |   |   |\\n            +---+---+---+---+---+---+\\n            |   |   |   |   |   | T |\\n            +---+---+---+---+---+---+\\n\\n\\n    \\'\\'\\'\\n    \\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        def topDownBacktrack(i,j):\\n            # Bottom Up approach This is the goal state\\n            if i == len(s1) and j == len(s2):\\n                return True \\n            # using memo\\n            if (i,j) in dp:\\n                return dp[(i,j)]\\n\\n            if i < len(s1) and s1[i] == s3[i+j] and topDownBacktrack(i+1,j) : # Checking if we take the s1 substring \\n                dp[(i,j)] = True\\n                return True\\n            if j < len(s2) and s2[j] == s3[i+j] and topDownBacktrack(i,j+1) : # Checking if we take the s2 substring\\n                dp[(i,j)] = True\\n                return True\\n            dp[(i,j)] = False\\n            return False\\n            \\n\\n        if len(s1) +len(s2) != len(s3):\\n            return False\\n\\n        dp = {} #memo : [(i,j)] = True or False, need to only mark false nodes\\n        \\n\\n        \\n        \\n\\n        # while i <= len(s1) and j <=len(s2) and i+j len(s3):\\n            \\n            \\n            \\n        return topDownBacktrack(0,0)\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Backtracking",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n\\n    \\'\\'\\'\\n            This recursion goes all in and backtracks\\n\\n            Goal string : aadbbcbcac\\n\\n             +---+---+---+---+---+---+\\n            |   | d | b | b | c |   |\\n            +---+---+---+---+---+---+\\n            | a |   |   |   |   |   |\\n            +---+---+---+---+---+---+\\n            | a |   |   |   |   |   |\\n            +---+---+---+---+---+---+\\n            | b |   |   |   |   |   |\\n            +---+---+---+---+---+---+\\n            | c |   |   |   |   |   |\\n            +---+---+---+---+---+---+\\n            | c |   |   |   |   |   |\\n            +---+---+---+---+---+---+\\n            |   |   |   |   |   | T |\\n            +---+---+---+---+---+---+\\n\\n\\n    \\'\\'\\'\\n    \\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\\n        def topDownBacktrack(i,j):\\n            # Bottom Up approach This is the goal state\\n            if i == len(s1) and j == len(s2):\\n                return True \\n            # using memo\\n            if (i,j) in dp:\\n                return dp[(i,j)]\\n\\n            if i < len(s1) and s1[i] == s3[i+j] and topDownBacktrack(i+1,j) : # Checking if we take the s1 substring \\n                dp[(i,j)] = True\\n                return True\\n            if j < len(s2) and s2[j] == s3[i+j] and topDownBacktrack(i,j+1) : # Checking if we take the s2 substring\\n                dp[(i,j)] = True\\n                return True\\n            dp[(i,j)] = False\\n            return False\\n            \\n\\n        if len(s1) +len(s2) != len(s3):\\n            return False\\n\\n        dp = {} #memo : [(i,j)] = True or False, need to only mark false nodes\\n        \\n\\n        \\n        \\n\\n        # while i <= len(s1) and j <=len(s2) and i+j len(s3):\\n            \\n            \\n            \\n        return topDownBacktrack(0,0)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146211,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int rec(int i1,int i2,int i3,string &s1,string &s2,string &s3,int n1,int n2,int n3,vector<vector<vector<int>>>&dp)\\n   {\\n       if (i1==n1 && i2==n2 && i3==n3)\\n       return 1;\\n       if (i3==n3) return 0;\\n       if (dp[i1][i2][i3]!=-1) return dp[i1][i2][i3];\\n       int a=0;\\n       if(i1<n1 && s3[i3]==s1[i1])\\n       a=rec(i1+1,i2,i3+1,s1,s2,s3,n1,n2,n3,dp);\\n       int b=0;\\n        if(i2<n2 && s3[i3]==s2[i2])\\n       b=rec(i1,i2+1,i3+1,s1,s2,s3,n1,n2,n3,dp);\\n       return dp[i1][i2][i3]=a||b;\\n   }\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n1=s1.size(),n2=s2.size(),n3=s3.size();\\n        vector<vector<vector<int>>>dp(n1+1,vector<vector<int>>(n2+1,vector<int>(n3+1,-1)));\\n        return rec(0,0,0,s1,s2,s3,n1,n2,n3,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int rec(int i1,int i2,int i3,string &s1,string &s2,string &s3,int n1,int n2,int n3,vector<vector<vector<int>>>&dp)\\n   {\\n       if (i1==n1 && i2==n2 && i3==n3)\\n       return 1;\\n       if (i3==n3) return 0;\\n       if (dp[i1][i2][i3]!=-1) return dp[i1][i2][i3];\\n       int a=0;\\n       if(i1<n1 && s3[i3]==s1[i1])\\n       a=rec(i1+1,i2,i3+1,s1,s2,s3,n1,n2,n3,dp);\\n       int b=0;\\n        if(i2<n2 && s3[i3]==s2[i2])\\n       b=rec(i1,i2+1,i3+1,s1,s2,s3,n1,n2,n3,dp);\\n       return dp[i1][i2][i3]=a||b;\\n   }\\n    bool isInterleave(string s1, string s2, string s3) {\\n        int n1=s1.size(),n2=s2.size(),n3=s3.size();\\n        vector<vector<vector<int>>>dp(n1+1,vector<vector<int>>(n2+1,vector<int>(n3+1,-1)));\\n        return rec(0,0,0,s1,s2,s3,n1,n2,n3,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1576535,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "So you need to ask yourself ..why is dp used here?\\n In first look this questions looks pretty simple and can be done using 2 pointers. \\n \\n Then you implement the 2 pointer approach and upon submission your code get a wrong ans on the below testcase.\\n \\n This test case then tells you why this que is asking for a dp solution.\\n \\n s1 = \"aabc\"\\n s2 = \"abad\"\\n s3= \"aabadabc\"\\n \\n Now in this, if you start moving from the back using the 2 pointer approach, it keeps on eleminating the character from the 1st string i.e s1. But when s1 gets exhausted, your s3 does not match with s2. \\n Here you take a note that, when char at s1 and s2 are equal, we need to check if deleting the char from s1 is a correct move or deleting the char from s2 would be a correct move.\\n \\n That clearly means, we have 2 choices here, either to delete the char from s1 or s2.\\n \\n Now for a bigger testcase like this it is clearly evidant that the que is asking for a Dyanmic Programming solution!!\\n \\n s1 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s2 = \"aaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s3 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\\t\\t aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n"
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "great intution \\uD83D\\uDD25\\uD83D\\uDD25\\uD83C\\uDF89"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "I CAN\\'T BELIEVE I SOLVED THIS ONE BY MY SELF :OOOOOOOOOO"
                    },
                    {
                        "username": "SeineAle",
                        "content": "ME TOO !\nFeels Good :)"
                    },
                    {
                        "username": "killerraj369",
                        "content": "After watching this comment I solved it by myself at first attempt itself."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good... doesn\\'t it?"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "same bro... feeling proud in my small achievement lol !"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "I am ashamed of my self. "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "same bruh!\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "whenever i see leaving, it reminds me of her :("
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "slow claps :)"
                    },
                    {
                        "username": "santanusen",
                        "content": "Please share how did you make her leave :p"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "Logic level with realistic view on top "
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "riyal"
                    },
                    {
                        "username": "Vicjr",
                        "content": "real"
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "real"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\\uD83D\\uDE06 "
                    },
                    {
                        "username": "maysrv",
                        "content": "You might be tempted to use i, j and k to keep track of s1, s2 and s3 respectively in your recursive calls but it gave me TLE. (Please note that it is not wrong)\\nThe trick here was to remove k from your changing state and reduce dp from 3D to 2D.\\nYou may reason about it by manipulating what you think of i and j at each point and it may work for you but I would like to point out how I reason it. \\nThe thing here is, at every step k is nothing but i+j, so we dont need to keep track of k because we can get it from i and j."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@chenon](/chenon) The problem here is you\\'re greedily checking if s3 can be created from s1 if not then you\\'re checking for s2.\\n\\nIf somehow the test-case you\\'re mentioning currently is cleared then you\\'ll stuck later on."
                    },
                    {
                        "username": "chenon",
                        "content": "I was exactly keeping track of the indexes on s1 and s2  . See my submission https://leetcode.com/problems/interleaving-string/submissions/1031746304/ . NO TLE but wrong answer."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I used 4D and beat 9%..."
                    },
                    {
                        "username": "parmani",
                        "content": "but 3d also works, since the constraints are low"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "at first i also did the 3d dp, then i figured it out that we dont need k..:p"
                    },
                    {
                        "username": "sanket54",
                        "content": "What is meaning of |n-m| <= 1 and why it is being ignored in all solutions ?"
                    },
                    {
                        "username": "sanjeeb42",
                        "content": "[@mahesh105](/mahesh105) Thanks for the explanation. I was exactly looking for this"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@mahesh105](/mahesh105)  thankss bro"
                    },
                    {
                        "username": "mahesh105",
                        "content": "All of the reasons in this threads were not explaining why?\\nLet me tell you.\\nsuppose you take n substrings of S1 and place it like this\\n__  __  __  __  __  __  __  __  __  __  __  __\\nthen you can fill the S2 substrings in the gaps or the boundary...in either case the inequality holds.\\nSo yeah if the string is interleaving, this inequality is automatically held due to this observation.\\nHappy Debugging : )"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The fact is that |n - m| <= 1 (where m and n are the no. of substring used for interleaving the string) is just the condition which supports that strings must be interleaved.\\nIf there are interleaved correctly then this condition will be automatically true.\\nThat\\'s why every piece of information not need to be included in code some time based on few logic we have to neglect few of them."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@unters](/unters) |n-m| <= 1 means you cannot divide the strings into arbitrarily sized pieces. If string 1 is divided into 4 parts, then string 5 can only be divided into 3, 4 or 5 parts. "
                    },
                    {
                        "username": "unters",
                        "content": "[@WajeehHasan](/WajeehHasan), in my opinion you\\'re not quite right. `m` and `n` are not numbers of characters in each string - that are numbers of nonoverlapping substrings in each string (each substring can contain more than one character). `|m - n| <= 1\\' means there can not be two adjacent substrings in p3 that belong to one string."
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Exactly what I am looking for."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "simply means difference of the length of string s and t is less than or equal to 1"
                    },
                    {
                        "username": "eddy66",
                        "content": "I think `|n-m|<=1` just means the substrings of `s` are interleaved with the substrings of `t`. So they could be `s1, t1, s2`, or `s1, t1, s2, t2`. But since each substring can be anything, so it\\'s not important when we solve the problem"
                    },
                    {
                        "username": "mvo13",
                        "content": "|n-m| <= 1 \\n=> The time complexity is O(n^2)"
                    },
                    {
                        "username": "shiva_San",
                        "content": "be ready for this testcase if you are using two pointer method without dp..\n\ns1 =\n\"aabc\"\ns2 =\n\"abad\"\ns3 =\n\"aabadabc\"\n\noutput=true\n"
                    },
                    {
                        "username": "oisinfarrell00",
                        "content": "In the brief of Intervealving strings it states that:\\n - The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...\\nHowever then they give this example:\\n![image](https://assets.leetcode.com/users/images/28de80e4-3308-48c9-9f45-46d243f7a928_1622621577.219354.png)\\nI dont really understand how this example works. It takes two letters from the first string and then 4 from the next and then back to two and so on. I thought it had to be like s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ... Am I missing something here?"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "s1 and so on may not necessarily be single characters. That is the trick here."
                    },
                    {
                        "username": "Kaltu",
                        "content": "`s1 = \\'aa\\', s2 = \\'bc\\', s3 = \\'c\\'` and `t1 = \\'dbbc\\', t2 = \\'a\\'` so the answer is `s1 + t1 + s2 + t2 + s3`"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Here s or t don\\'t represent the charecters but a substring, which means in above example s1 is \"aa\" and t1 is \"dbbc\" and similarily s2 is \"bc\"..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a string problem. But it needs some method to solve. A 2D DP is possible, since s3 depends on both s1 & s2. "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@meow_power](/meow_power) because we don\\'t need it, i and j together can always determine k uniquely (i+j = k; always holds if ur not doing anything sus)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@meow_power](/meow_power) Your solution is fine. 2D array is used."
                    },
                    {
                        "username": "meow_power",
                        "content": "my solution uses k as third parameter but in memoization why is it not used.Please help"
                    },
                    {
                        "username": "mayliao",
                        "content": "It is so strange use static variable get the answer is different from my computer. After I changed it as parameter, it worked well."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "relevant article \\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-"
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "cuz static variable will be kept and be operated by the function u implemented for each different test cases, without resetting its original value. while local parameter will be wiped after function is done for one test case, and created and set for the next test case."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/interleaving-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Recursion with memoization\n\n  \n**Approach 3:** Using 2D Dynamic Programming\n\n  \n**Approach 4:** Using 1D Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1646591,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "So you need to ask yourself ..why is dp used here?\\n In first look this questions looks pretty simple and can be done using 2 pointers. \\n \\n Then you implement the 2 pointer approach and upon submission your code get a wrong ans on the below testcase.\\n \\n This test case then tells you why this que is asking for a dp solution.\\n \\n s1 = \"aabc\"\\n s2 = \"abad\"\\n s3= \"aabadabc\"\\n \\n Now in this, if you start moving from the back using the 2 pointer approach, it keeps on eleminating the character from the 1st string i.e s1. But when s1 gets exhausted, your s3 does not match with s2. \\n Here you take a note that, when char at s1 and s2 are equal, we need to check if deleting the char from s1 is a correct move or deleting the char from s2 would be a correct move.\\n \\n That clearly means, we have 2 choices here, either to delete the char from s1 or s2.\\n \\n Now for a bigger testcase like this it is clearly evidant that the que is asking for a Dyanmic Programming solution!!\\n \\n s1 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s2 = \"aaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s3 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\\t\\t aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n"
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "great intution \\uD83D\\uDD25\\uD83D\\uDD25\\uD83C\\uDF89"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "I CAN\\'T BELIEVE I SOLVED THIS ONE BY MY SELF :OOOOOOOOOO"
                    },
                    {
                        "username": "SeineAle",
                        "content": "ME TOO !\nFeels Good :)"
                    },
                    {
                        "username": "killerraj369",
                        "content": "After watching this comment I solved it by myself at first attempt itself."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good... doesn\\'t it?"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "same bro... feeling proud in my small achievement lol !"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "I am ashamed of my self. "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "same bruh!\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "whenever i see leaving, it reminds me of her :("
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "slow claps :)"
                    },
                    {
                        "username": "santanusen",
                        "content": "Please share how did you make her leave :p"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "Logic level with realistic view on top "
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "riyal"
                    },
                    {
                        "username": "Vicjr",
                        "content": "real"
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "real"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\\uD83D\\uDE06 "
                    },
                    {
                        "username": "maysrv",
                        "content": "You might be tempted to use i, j and k to keep track of s1, s2 and s3 respectively in your recursive calls but it gave me TLE. (Please note that it is not wrong)\\nThe trick here was to remove k from your changing state and reduce dp from 3D to 2D.\\nYou may reason about it by manipulating what you think of i and j at each point and it may work for you but I would like to point out how I reason it. \\nThe thing here is, at every step k is nothing but i+j, so we dont need to keep track of k because we can get it from i and j."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@chenon](/chenon) The problem here is you\\'re greedily checking if s3 can be created from s1 if not then you\\'re checking for s2.\\n\\nIf somehow the test-case you\\'re mentioning currently is cleared then you\\'ll stuck later on."
                    },
                    {
                        "username": "chenon",
                        "content": "I was exactly keeping track of the indexes on s1 and s2  . See my submission https://leetcode.com/problems/interleaving-string/submissions/1031746304/ . NO TLE but wrong answer."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I used 4D and beat 9%..."
                    },
                    {
                        "username": "parmani",
                        "content": "but 3d also works, since the constraints are low"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "at first i also did the 3d dp, then i figured it out that we dont need k..:p"
                    },
                    {
                        "username": "sanket54",
                        "content": "What is meaning of |n-m| <= 1 and why it is being ignored in all solutions ?"
                    },
                    {
                        "username": "sanjeeb42",
                        "content": "[@mahesh105](/mahesh105) Thanks for the explanation. I was exactly looking for this"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@mahesh105](/mahesh105)  thankss bro"
                    },
                    {
                        "username": "mahesh105",
                        "content": "All of the reasons in this threads were not explaining why?\\nLet me tell you.\\nsuppose you take n substrings of S1 and place it like this\\n__  __  __  __  __  __  __  __  __  __  __  __\\nthen you can fill the S2 substrings in the gaps or the boundary...in either case the inequality holds.\\nSo yeah if the string is interleaving, this inequality is automatically held due to this observation.\\nHappy Debugging : )"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The fact is that |n - m| <= 1 (where m and n are the no. of substring used for interleaving the string) is just the condition which supports that strings must be interleaved.\\nIf there are interleaved correctly then this condition will be automatically true.\\nThat\\'s why every piece of information not need to be included in code some time based on few logic we have to neglect few of them."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@unters](/unters) |n-m| <= 1 means you cannot divide the strings into arbitrarily sized pieces. If string 1 is divided into 4 parts, then string 5 can only be divided into 3, 4 or 5 parts. "
                    },
                    {
                        "username": "unters",
                        "content": "[@WajeehHasan](/WajeehHasan), in my opinion you\\'re not quite right. `m` and `n` are not numbers of characters in each string - that are numbers of nonoverlapping substrings in each string (each substring can contain more than one character). `|m - n| <= 1\\' means there can not be two adjacent substrings in p3 that belong to one string."
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Exactly what I am looking for."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "simply means difference of the length of string s and t is less than or equal to 1"
                    },
                    {
                        "username": "eddy66",
                        "content": "I think `|n-m|<=1` just means the substrings of `s` are interleaved with the substrings of `t`. So they could be `s1, t1, s2`, or `s1, t1, s2, t2`. But since each substring can be anything, so it\\'s not important when we solve the problem"
                    },
                    {
                        "username": "mvo13",
                        "content": "|n-m| <= 1 \\n=> The time complexity is O(n^2)"
                    },
                    {
                        "username": "shiva_San",
                        "content": "be ready for this testcase if you are using two pointer method without dp..\n\ns1 =\n\"aabc\"\ns2 =\n\"abad\"\ns3 =\n\"aabadabc\"\n\noutput=true\n"
                    },
                    {
                        "username": "oisinfarrell00",
                        "content": "In the brief of Intervealving strings it states that:\\n - The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...\\nHowever then they give this example:\\n![image](https://assets.leetcode.com/users/images/28de80e4-3308-48c9-9f45-46d243f7a928_1622621577.219354.png)\\nI dont really understand how this example works. It takes two letters from the first string and then 4 from the next and then back to two and so on. I thought it had to be like s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ... Am I missing something here?"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "s1 and so on may not necessarily be single characters. That is the trick here."
                    },
                    {
                        "username": "Kaltu",
                        "content": "`s1 = \\'aa\\', s2 = \\'bc\\', s3 = \\'c\\'` and `t1 = \\'dbbc\\', t2 = \\'a\\'` so the answer is `s1 + t1 + s2 + t2 + s3`"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Here s or t don\\'t represent the charecters but a substring, which means in above example s1 is \"aa\" and t1 is \"dbbc\" and similarily s2 is \"bc\"..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a string problem. But it needs some method to solve. A 2D DP is possible, since s3 depends on both s1 & s2. "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@meow_power](/meow_power) because we don\\'t need it, i and j together can always determine k uniquely (i+j = k; always holds if ur not doing anything sus)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@meow_power](/meow_power) Your solution is fine. 2D array is used."
                    },
                    {
                        "username": "meow_power",
                        "content": "my solution uses k as third parameter but in memoization why is it not used.Please help"
                    },
                    {
                        "username": "mayliao",
                        "content": "It is so strange use static variable get the answer is different from my computer. After I changed it as parameter, it worked well."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "relevant article \\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-"
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "cuz static variable will be kept and be operated by the function u implemented for each different test cases, without resetting its original value. while local parameter will be wiped after function is done for one test case, and created and set for the next test case."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/interleaving-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Recursion with memoization\n\n  \n**Approach 3:** Using 2D Dynamic Programming\n\n  \n**Approach 4:** Using 1D Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 2029056,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "So you need to ask yourself ..why is dp used here?\\n In first look this questions looks pretty simple and can be done using 2 pointers. \\n \\n Then you implement the 2 pointer approach and upon submission your code get a wrong ans on the below testcase.\\n \\n This test case then tells you why this que is asking for a dp solution.\\n \\n s1 = \"aabc\"\\n s2 = \"abad\"\\n s3= \"aabadabc\"\\n \\n Now in this, if you start moving from the back using the 2 pointer approach, it keeps on eleminating the character from the 1st string i.e s1. But when s1 gets exhausted, your s3 does not match with s2. \\n Here you take a note that, when char at s1 and s2 are equal, we need to check if deleting the char from s1 is a correct move or deleting the char from s2 would be a correct move.\\n \\n That clearly means, we have 2 choices here, either to delete the char from s1 or s2.\\n \\n Now for a bigger testcase like this it is clearly evidant that the que is asking for a Dyanmic Programming solution!!\\n \\n s1 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s2 = \"aaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s3 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\\t\\t aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n"
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "great intution \\uD83D\\uDD25\\uD83D\\uDD25\\uD83C\\uDF89"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "I CAN\\'T BELIEVE I SOLVED THIS ONE BY MY SELF :OOOOOOOOOO"
                    },
                    {
                        "username": "SeineAle",
                        "content": "ME TOO !\nFeels Good :)"
                    },
                    {
                        "username": "killerraj369",
                        "content": "After watching this comment I solved it by myself at first attempt itself."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good... doesn\\'t it?"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "same bro... feeling proud in my small achievement lol !"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "I am ashamed of my self. "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "same bruh!\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "whenever i see leaving, it reminds me of her :("
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "slow claps :)"
                    },
                    {
                        "username": "santanusen",
                        "content": "Please share how did you make her leave :p"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "Logic level with realistic view on top "
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "riyal"
                    },
                    {
                        "username": "Vicjr",
                        "content": "real"
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "real"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\\uD83D\\uDE06 "
                    },
                    {
                        "username": "maysrv",
                        "content": "You might be tempted to use i, j and k to keep track of s1, s2 and s3 respectively in your recursive calls but it gave me TLE. (Please note that it is not wrong)\\nThe trick here was to remove k from your changing state and reduce dp from 3D to 2D.\\nYou may reason about it by manipulating what you think of i and j at each point and it may work for you but I would like to point out how I reason it. \\nThe thing here is, at every step k is nothing but i+j, so we dont need to keep track of k because we can get it from i and j."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@chenon](/chenon) The problem here is you\\'re greedily checking if s3 can be created from s1 if not then you\\'re checking for s2.\\n\\nIf somehow the test-case you\\'re mentioning currently is cleared then you\\'ll stuck later on."
                    },
                    {
                        "username": "chenon",
                        "content": "I was exactly keeping track of the indexes on s1 and s2  . See my submission https://leetcode.com/problems/interleaving-string/submissions/1031746304/ . NO TLE but wrong answer."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I used 4D and beat 9%..."
                    },
                    {
                        "username": "parmani",
                        "content": "but 3d also works, since the constraints are low"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "at first i also did the 3d dp, then i figured it out that we dont need k..:p"
                    },
                    {
                        "username": "sanket54",
                        "content": "What is meaning of |n-m| <= 1 and why it is being ignored in all solutions ?"
                    },
                    {
                        "username": "sanjeeb42",
                        "content": "[@mahesh105](/mahesh105) Thanks for the explanation. I was exactly looking for this"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@mahesh105](/mahesh105)  thankss bro"
                    },
                    {
                        "username": "mahesh105",
                        "content": "All of the reasons in this threads were not explaining why?\\nLet me tell you.\\nsuppose you take n substrings of S1 and place it like this\\n__  __  __  __  __  __  __  __  __  __  __  __\\nthen you can fill the S2 substrings in the gaps or the boundary...in either case the inequality holds.\\nSo yeah if the string is interleaving, this inequality is automatically held due to this observation.\\nHappy Debugging : )"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The fact is that |n - m| <= 1 (where m and n are the no. of substring used for interleaving the string) is just the condition which supports that strings must be interleaved.\\nIf there are interleaved correctly then this condition will be automatically true.\\nThat\\'s why every piece of information not need to be included in code some time based on few logic we have to neglect few of them."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@unters](/unters) |n-m| <= 1 means you cannot divide the strings into arbitrarily sized pieces. If string 1 is divided into 4 parts, then string 5 can only be divided into 3, 4 or 5 parts. "
                    },
                    {
                        "username": "unters",
                        "content": "[@WajeehHasan](/WajeehHasan), in my opinion you\\'re not quite right. `m` and `n` are not numbers of characters in each string - that are numbers of nonoverlapping substrings in each string (each substring can contain more than one character). `|m - n| <= 1\\' means there can not be two adjacent substrings in p3 that belong to one string."
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Exactly what I am looking for."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "simply means difference of the length of string s and t is less than or equal to 1"
                    },
                    {
                        "username": "eddy66",
                        "content": "I think `|n-m|<=1` just means the substrings of `s` are interleaved with the substrings of `t`. So they could be `s1, t1, s2`, or `s1, t1, s2, t2`. But since each substring can be anything, so it\\'s not important when we solve the problem"
                    },
                    {
                        "username": "mvo13",
                        "content": "|n-m| <= 1 \\n=> The time complexity is O(n^2)"
                    },
                    {
                        "username": "shiva_San",
                        "content": "be ready for this testcase if you are using two pointer method without dp..\n\ns1 =\n\"aabc\"\ns2 =\n\"abad\"\ns3 =\n\"aabadabc\"\n\noutput=true\n"
                    },
                    {
                        "username": "oisinfarrell00",
                        "content": "In the brief of Intervealving strings it states that:\\n - The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...\\nHowever then they give this example:\\n![image](https://assets.leetcode.com/users/images/28de80e4-3308-48c9-9f45-46d243f7a928_1622621577.219354.png)\\nI dont really understand how this example works. It takes two letters from the first string and then 4 from the next and then back to two and so on. I thought it had to be like s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ... Am I missing something here?"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "s1 and so on may not necessarily be single characters. That is the trick here."
                    },
                    {
                        "username": "Kaltu",
                        "content": "`s1 = \\'aa\\', s2 = \\'bc\\', s3 = \\'c\\'` and `t1 = \\'dbbc\\', t2 = \\'a\\'` so the answer is `s1 + t1 + s2 + t2 + s3`"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Here s or t don\\'t represent the charecters but a substring, which means in above example s1 is \"aa\" and t1 is \"dbbc\" and similarily s2 is \"bc\"..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a string problem. But it needs some method to solve. A 2D DP is possible, since s3 depends on both s1 & s2. "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@meow_power](/meow_power) because we don\\'t need it, i and j together can always determine k uniquely (i+j = k; always holds if ur not doing anything sus)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@meow_power](/meow_power) Your solution is fine. 2D array is used."
                    },
                    {
                        "username": "meow_power",
                        "content": "my solution uses k as third parameter but in memoization why is it not used.Please help"
                    },
                    {
                        "username": "mayliao",
                        "content": "It is so strange use static variable get the answer is different from my computer. After I changed it as parameter, it worked well."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "relevant article \\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-"
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "cuz static variable will be kept and be operated by the function u implemented for each different test cases, without resetting its original value. while local parameter will be wiped after function is done for one test case, and created and set for the next test case."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/interleaving-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Recursion with memoization\n\n  \n**Approach 3:** Using 2D Dynamic Programming\n\n  \n**Approach 4:** Using 1D Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1576855,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "So you need to ask yourself ..why is dp used here?\\n In first look this questions looks pretty simple and can be done using 2 pointers. \\n \\n Then you implement the 2 pointer approach and upon submission your code get a wrong ans on the below testcase.\\n \\n This test case then tells you why this que is asking for a dp solution.\\n \\n s1 = \"aabc\"\\n s2 = \"abad\"\\n s3= \"aabadabc\"\\n \\n Now in this, if you start moving from the back using the 2 pointer approach, it keeps on eleminating the character from the 1st string i.e s1. But when s1 gets exhausted, your s3 does not match with s2. \\n Here you take a note that, when char at s1 and s2 are equal, we need to check if deleting the char from s1 is a correct move or deleting the char from s2 would be a correct move.\\n \\n That clearly means, we have 2 choices here, either to delete the char from s1 or s2.\\n \\n Now for a bigger testcase like this it is clearly evidant that the que is asking for a Dyanmic Programming solution!!\\n \\n s1 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s2 = \"aaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s3 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\\t\\t aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n"
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "great intution \\uD83D\\uDD25\\uD83D\\uDD25\\uD83C\\uDF89"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "I CAN\\'T BELIEVE I SOLVED THIS ONE BY MY SELF :OOOOOOOOOO"
                    },
                    {
                        "username": "SeineAle",
                        "content": "ME TOO !\nFeels Good :)"
                    },
                    {
                        "username": "killerraj369",
                        "content": "After watching this comment I solved it by myself at first attempt itself."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good... doesn\\'t it?"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "same bro... feeling proud in my small achievement lol !"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "I am ashamed of my self. "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "same bruh!\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "whenever i see leaving, it reminds me of her :("
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "slow claps :)"
                    },
                    {
                        "username": "santanusen",
                        "content": "Please share how did you make her leave :p"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "Logic level with realistic view on top "
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "riyal"
                    },
                    {
                        "username": "Vicjr",
                        "content": "real"
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "real"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\\uD83D\\uDE06 "
                    },
                    {
                        "username": "maysrv",
                        "content": "You might be tempted to use i, j and k to keep track of s1, s2 and s3 respectively in your recursive calls but it gave me TLE. (Please note that it is not wrong)\\nThe trick here was to remove k from your changing state and reduce dp from 3D to 2D.\\nYou may reason about it by manipulating what you think of i and j at each point and it may work for you but I would like to point out how I reason it. \\nThe thing here is, at every step k is nothing but i+j, so we dont need to keep track of k because we can get it from i and j."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@chenon](/chenon) The problem here is you\\'re greedily checking if s3 can be created from s1 if not then you\\'re checking for s2.\\n\\nIf somehow the test-case you\\'re mentioning currently is cleared then you\\'ll stuck later on."
                    },
                    {
                        "username": "chenon",
                        "content": "I was exactly keeping track of the indexes on s1 and s2  . See my submission https://leetcode.com/problems/interleaving-string/submissions/1031746304/ . NO TLE but wrong answer."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I used 4D and beat 9%..."
                    },
                    {
                        "username": "parmani",
                        "content": "but 3d also works, since the constraints are low"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "at first i also did the 3d dp, then i figured it out that we dont need k..:p"
                    },
                    {
                        "username": "sanket54",
                        "content": "What is meaning of |n-m| <= 1 and why it is being ignored in all solutions ?"
                    },
                    {
                        "username": "sanjeeb42",
                        "content": "[@mahesh105](/mahesh105) Thanks for the explanation. I was exactly looking for this"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@mahesh105](/mahesh105)  thankss bro"
                    },
                    {
                        "username": "mahesh105",
                        "content": "All of the reasons in this threads were not explaining why?\\nLet me tell you.\\nsuppose you take n substrings of S1 and place it like this\\n__  __  __  __  __  __  __  __  __  __  __  __\\nthen you can fill the S2 substrings in the gaps or the boundary...in either case the inequality holds.\\nSo yeah if the string is interleaving, this inequality is automatically held due to this observation.\\nHappy Debugging : )"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The fact is that |n - m| <= 1 (where m and n are the no. of substring used for interleaving the string) is just the condition which supports that strings must be interleaved.\\nIf there are interleaved correctly then this condition will be automatically true.\\nThat\\'s why every piece of information not need to be included in code some time based on few logic we have to neglect few of them."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@unters](/unters) |n-m| <= 1 means you cannot divide the strings into arbitrarily sized pieces. If string 1 is divided into 4 parts, then string 5 can only be divided into 3, 4 or 5 parts. "
                    },
                    {
                        "username": "unters",
                        "content": "[@WajeehHasan](/WajeehHasan), in my opinion you\\'re not quite right. `m` and `n` are not numbers of characters in each string - that are numbers of nonoverlapping substrings in each string (each substring can contain more than one character). `|m - n| <= 1\\' means there can not be two adjacent substrings in p3 that belong to one string."
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Exactly what I am looking for."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "simply means difference of the length of string s and t is less than or equal to 1"
                    },
                    {
                        "username": "eddy66",
                        "content": "I think `|n-m|<=1` just means the substrings of `s` are interleaved with the substrings of `t`. So they could be `s1, t1, s2`, or `s1, t1, s2, t2`. But since each substring can be anything, so it\\'s not important when we solve the problem"
                    },
                    {
                        "username": "mvo13",
                        "content": "|n-m| <= 1 \\n=> The time complexity is O(n^2)"
                    },
                    {
                        "username": "shiva_San",
                        "content": "be ready for this testcase if you are using two pointer method without dp..\n\ns1 =\n\"aabc\"\ns2 =\n\"abad\"\ns3 =\n\"aabadabc\"\n\noutput=true\n"
                    },
                    {
                        "username": "oisinfarrell00",
                        "content": "In the brief of Intervealving strings it states that:\\n - The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...\\nHowever then they give this example:\\n![image](https://assets.leetcode.com/users/images/28de80e4-3308-48c9-9f45-46d243f7a928_1622621577.219354.png)\\nI dont really understand how this example works. It takes two letters from the first string and then 4 from the next and then back to two and so on. I thought it had to be like s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ... Am I missing something here?"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "s1 and so on may not necessarily be single characters. That is the trick here."
                    },
                    {
                        "username": "Kaltu",
                        "content": "`s1 = \\'aa\\', s2 = \\'bc\\', s3 = \\'c\\'` and `t1 = \\'dbbc\\', t2 = \\'a\\'` so the answer is `s1 + t1 + s2 + t2 + s3`"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Here s or t don\\'t represent the charecters but a substring, which means in above example s1 is \"aa\" and t1 is \"dbbc\" and similarily s2 is \"bc\"..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a string problem. But it needs some method to solve. A 2D DP is possible, since s3 depends on both s1 & s2. "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@meow_power](/meow_power) because we don\\'t need it, i and j together can always determine k uniquely (i+j = k; always holds if ur not doing anything sus)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@meow_power](/meow_power) Your solution is fine. 2D array is used."
                    },
                    {
                        "username": "meow_power",
                        "content": "my solution uses k as third parameter but in memoization why is it not used.Please help"
                    },
                    {
                        "username": "mayliao",
                        "content": "It is so strange use static variable get the answer is different from my computer. After I changed it as parameter, it worked well."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "relevant article \\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-"
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "cuz static variable will be kept and be operated by the function u implemented for each different test cases, without resetting its original value. while local parameter will be wiped after function is done for one test case, and created and set for the next test case."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/interleaving-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Recursion with memoization\n\n  \n**Approach 3:** Using 2D Dynamic Programming\n\n  \n**Approach 4:** Using 1D Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1568627,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "So you need to ask yourself ..why is dp used here?\\n In first look this questions looks pretty simple and can be done using 2 pointers. \\n \\n Then you implement the 2 pointer approach and upon submission your code get a wrong ans on the below testcase.\\n \\n This test case then tells you why this que is asking for a dp solution.\\n \\n s1 = \"aabc\"\\n s2 = \"abad\"\\n s3= \"aabadabc\"\\n \\n Now in this, if you start moving from the back using the 2 pointer approach, it keeps on eleminating the character from the 1st string i.e s1. But when s1 gets exhausted, your s3 does not match with s2. \\n Here you take a note that, when char at s1 and s2 are equal, we need to check if deleting the char from s1 is a correct move or deleting the char from s2 would be a correct move.\\n \\n That clearly means, we have 2 choices here, either to delete the char from s1 or s2.\\n \\n Now for a bigger testcase like this it is clearly evidant that the que is asking for a Dyanmic Programming solution!!\\n \\n s1 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s2 = \"aaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s3 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\\t\\t aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n"
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "great intution \\uD83D\\uDD25\\uD83D\\uDD25\\uD83C\\uDF89"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "I CAN\\'T BELIEVE I SOLVED THIS ONE BY MY SELF :OOOOOOOOOO"
                    },
                    {
                        "username": "SeineAle",
                        "content": "ME TOO !\nFeels Good :)"
                    },
                    {
                        "username": "killerraj369",
                        "content": "After watching this comment I solved it by myself at first attempt itself."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good... doesn\\'t it?"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "same bro... feeling proud in my small achievement lol !"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "I am ashamed of my self. "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "same bruh!\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "whenever i see leaving, it reminds me of her :("
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "slow claps :)"
                    },
                    {
                        "username": "santanusen",
                        "content": "Please share how did you make her leave :p"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "Logic level with realistic view on top "
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "riyal"
                    },
                    {
                        "username": "Vicjr",
                        "content": "real"
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "real"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\\uD83D\\uDE06 "
                    },
                    {
                        "username": "maysrv",
                        "content": "You might be tempted to use i, j and k to keep track of s1, s2 and s3 respectively in your recursive calls but it gave me TLE. (Please note that it is not wrong)\\nThe trick here was to remove k from your changing state and reduce dp from 3D to 2D.\\nYou may reason about it by manipulating what you think of i and j at each point and it may work for you but I would like to point out how I reason it. \\nThe thing here is, at every step k is nothing but i+j, so we dont need to keep track of k because we can get it from i and j."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@chenon](/chenon) The problem here is you\\'re greedily checking if s3 can be created from s1 if not then you\\'re checking for s2.\\n\\nIf somehow the test-case you\\'re mentioning currently is cleared then you\\'ll stuck later on."
                    },
                    {
                        "username": "chenon",
                        "content": "I was exactly keeping track of the indexes on s1 and s2  . See my submission https://leetcode.com/problems/interleaving-string/submissions/1031746304/ . NO TLE but wrong answer."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I used 4D and beat 9%..."
                    },
                    {
                        "username": "parmani",
                        "content": "but 3d also works, since the constraints are low"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "at first i also did the 3d dp, then i figured it out that we dont need k..:p"
                    },
                    {
                        "username": "sanket54",
                        "content": "What is meaning of |n-m| <= 1 and why it is being ignored in all solutions ?"
                    },
                    {
                        "username": "sanjeeb42",
                        "content": "[@mahesh105](/mahesh105) Thanks for the explanation. I was exactly looking for this"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@mahesh105](/mahesh105)  thankss bro"
                    },
                    {
                        "username": "mahesh105",
                        "content": "All of the reasons in this threads were not explaining why?\\nLet me tell you.\\nsuppose you take n substrings of S1 and place it like this\\n__  __  __  __  __  __  __  __  __  __  __  __\\nthen you can fill the S2 substrings in the gaps or the boundary...in either case the inequality holds.\\nSo yeah if the string is interleaving, this inequality is automatically held due to this observation.\\nHappy Debugging : )"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The fact is that |n - m| <= 1 (where m and n are the no. of substring used for interleaving the string) is just the condition which supports that strings must be interleaved.\\nIf there are interleaved correctly then this condition will be automatically true.\\nThat\\'s why every piece of information not need to be included in code some time based on few logic we have to neglect few of them."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@unters](/unters) |n-m| <= 1 means you cannot divide the strings into arbitrarily sized pieces. If string 1 is divided into 4 parts, then string 5 can only be divided into 3, 4 or 5 parts. "
                    },
                    {
                        "username": "unters",
                        "content": "[@WajeehHasan](/WajeehHasan), in my opinion you\\'re not quite right. `m` and `n` are not numbers of characters in each string - that are numbers of nonoverlapping substrings in each string (each substring can contain more than one character). `|m - n| <= 1\\' means there can not be two adjacent substrings in p3 that belong to one string."
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Exactly what I am looking for."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "simply means difference of the length of string s and t is less than or equal to 1"
                    },
                    {
                        "username": "eddy66",
                        "content": "I think `|n-m|<=1` just means the substrings of `s` are interleaved with the substrings of `t`. So they could be `s1, t1, s2`, or `s1, t1, s2, t2`. But since each substring can be anything, so it\\'s not important when we solve the problem"
                    },
                    {
                        "username": "mvo13",
                        "content": "|n-m| <= 1 \\n=> The time complexity is O(n^2)"
                    },
                    {
                        "username": "shiva_San",
                        "content": "be ready for this testcase if you are using two pointer method without dp..\n\ns1 =\n\"aabc\"\ns2 =\n\"abad\"\ns3 =\n\"aabadabc\"\n\noutput=true\n"
                    },
                    {
                        "username": "oisinfarrell00",
                        "content": "In the brief of Intervealving strings it states that:\\n - The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...\\nHowever then they give this example:\\n![image](https://assets.leetcode.com/users/images/28de80e4-3308-48c9-9f45-46d243f7a928_1622621577.219354.png)\\nI dont really understand how this example works. It takes two letters from the first string and then 4 from the next and then back to two and so on. I thought it had to be like s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ... Am I missing something here?"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "s1 and so on may not necessarily be single characters. That is the trick here."
                    },
                    {
                        "username": "Kaltu",
                        "content": "`s1 = \\'aa\\', s2 = \\'bc\\', s3 = \\'c\\'` and `t1 = \\'dbbc\\', t2 = \\'a\\'` so the answer is `s1 + t1 + s2 + t2 + s3`"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Here s or t don\\'t represent the charecters but a substring, which means in above example s1 is \"aa\" and t1 is \"dbbc\" and similarily s2 is \"bc\"..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a string problem. But it needs some method to solve. A 2D DP is possible, since s3 depends on both s1 & s2. "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@meow_power](/meow_power) because we don\\'t need it, i and j together can always determine k uniquely (i+j = k; always holds if ur not doing anything sus)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@meow_power](/meow_power) Your solution is fine. 2D array is used."
                    },
                    {
                        "username": "meow_power",
                        "content": "my solution uses k as third parameter but in memoization why is it not used.Please help"
                    },
                    {
                        "username": "mayliao",
                        "content": "It is so strange use static variable get the answer is different from my computer. After I changed it as parameter, it worked well."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "relevant article \\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-"
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "cuz static variable will be kept and be operated by the function u implemented for each different test cases, without resetting its original value. while local parameter will be wiped after function is done for one test case, and created and set for the next test case."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/interleaving-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Recursion with memoization\n\n  \n**Approach 3:** Using 2D Dynamic Programming\n\n  \n**Approach 4:** Using 1D Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 2029275,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "So you need to ask yourself ..why is dp used here?\\n In first look this questions looks pretty simple and can be done using 2 pointers. \\n \\n Then you implement the 2 pointer approach and upon submission your code get a wrong ans on the below testcase.\\n \\n This test case then tells you why this que is asking for a dp solution.\\n \\n s1 = \"aabc\"\\n s2 = \"abad\"\\n s3= \"aabadabc\"\\n \\n Now in this, if you start moving from the back using the 2 pointer approach, it keeps on eleminating the character from the 1st string i.e s1. But when s1 gets exhausted, your s3 does not match with s2. \\n Here you take a note that, when char at s1 and s2 are equal, we need to check if deleting the char from s1 is a correct move or deleting the char from s2 would be a correct move.\\n \\n That clearly means, we have 2 choices here, either to delete the char from s1 or s2.\\n \\n Now for a bigger testcase like this it is clearly evidant that the que is asking for a Dyanmic Programming solution!!\\n \\n s1 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s2 = \"aaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s3 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\\t\\t aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n"
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "great intution \\uD83D\\uDD25\\uD83D\\uDD25\\uD83C\\uDF89"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "I CAN\\'T BELIEVE I SOLVED THIS ONE BY MY SELF :OOOOOOOOOO"
                    },
                    {
                        "username": "SeineAle",
                        "content": "ME TOO !\nFeels Good :)"
                    },
                    {
                        "username": "killerraj369",
                        "content": "After watching this comment I solved it by myself at first attempt itself."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good... doesn\\'t it?"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "same bro... feeling proud in my small achievement lol !"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "I am ashamed of my self. "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "same bruh!\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "whenever i see leaving, it reminds me of her :("
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "slow claps :)"
                    },
                    {
                        "username": "santanusen",
                        "content": "Please share how did you make her leave :p"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "Logic level with realistic view on top "
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "riyal"
                    },
                    {
                        "username": "Vicjr",
                        "content": "real"
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "real"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\\uD83D\\uDE06 "
                    },
                    {
                        "username": "maysrv",
                        "content": "You might be tempted to use i, j and k to keep track of s1, s2 and s3 respectively in your recursive calls but it gave me TLE. (Please note that it is not wrong)\\nThe trick here was to remove k from your changing state and reduce dp from 3D to 2D.\\nYou may reason about it by manipulating what you think of i and j at each point and it may work for you but I would like to point out how I reason it. \\nThe thing here is, at every step k is nothing but i+j, so we dont need to keep track of k because we can get it from i and j."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@chenon](/chenon) The problem here is you\\'re greedily checking if s3 can be created from s1 if not then you\\'re checking for s2.\\n\\nIf somehow the test-case you\\'re mentioning currently is cleared then you\\'ll stuck later on."
                    },
                    {
                        "username": "chenon",
                        "content": "I was exactly keeping track of the indexes on s1 and s2  . See my submission https://leetcode.com/problems/interleaving-string/submissions/1031746304/ . NO TLE but wrong answer."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I used 4D and beat 9%..."
                    },
                    {
                        "username": "parmani",
                        "content": "but 3d also works, since the constraints are low"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "at first i also did the 3d dp, then i figured it out that we dont need k..:p"
                    },
                    {
                        "username": "sanket54",
                        "content": "What is meaning of |n-m| <= 1 and why it is being ignored in all solutions ?"
                    },
                    {
                        "username": "sanjeeb42",
                        "content": "[@mahesh105](/mahesh105) Thanks for the explanation. I was exactly looking for this"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@mahesh105](/mahesh105)  thankss bro"
                    },
                    {
                        "username": "mahesh105",
                        "content": "All of the reasons in this threads were not explaining why?\\nLet me tell you.\\nsuppose you take n substrings of S1 and place it like this\\n__  __  __  __  __  __  __  __  __  __  __  __\\nthen you can fill the S2 substrings in the gaps or the boundary...in either case the inequality holds.\\nSo yeah if the string is interleaving, this inequality is automatically held due to this observation.\\nHappy Debugging : )"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The fact is that |n - m| <= 1 (where m and n are the no. of substring used for interleaving the string) is just the condition which supports that strings must be interleaved.\\nIf there are interleaved correctly then this condition will be automatically true.\\nThat\\'s why every piece of information not need to be included in code some time based on few logic we have to neglect few of them."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@unters](/unters) |n-m| <= 1 means you cannot divide the strings into arbitrarily sized pieces. If string 1 is divided into 4 parts, then string 5 can only be divided into 3, 4 or 5 parts. "
                    },
                    {
                        "username": "unters",
                        "content": "[@WajeehHasan](/WajeehHasan), in my opinion you\\'re not quite right. `m` and `n` are not numbers of characters in each string - that are numbers of nonoverlapping substrings in each string (each substring can contain more than one character). `|m - n| <= 1\\' means there can not be two adjacent substrings in p3 that belong to one string."
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Exactly what I am looking for."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "simply means difference of the length of string s and t is less than or equal to 1"
                    },
                    {
                        "username": "eddy66",
                        "content": "I think `|n-m|<=1` just means the substrings of `s` are interleaved with the substrings of `t`. So they could be `s1, t1, s2`, or `s1, t1, s2, t2`. But since each substring can be anything, so it\\'s not important when we solve the problem"
                    },
                    {
                        "username": "mvo13",
                        "content": "|n-m| <= 1 \\n=> The time complexity is O(n^2)"
                    },
                    {
                        "username": "shiva_San",
                        "content": "be ready for this testcase if you are using two pointer method without dp..\n\ns1 =\n\"aabc\"\ns2 =\n\"abad\"\ns3 =\n\"aabadabc\"\n\noutput=true\n"
                    },
                    {
                        "username": "oisinfarrell00",
                        "content": "In the brief of Intervealving strings it states that:\\n - The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...\\nHowever then they give this example:\\n![image](https://assets.leetcode.com/users/images/28de80e4-3308-48c9-9f45-46d243f7a928_1622621577.219354.png)\\nI dont really understand how this example works. It takes two letters from the first string and then 4 from the next and then back to two and so on. I thought it had to be like s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ... Am I missing something here?"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "s1 and so on may not necessarily be single characters. That is the trick here."
                    },
                    {
                        "username": "Kaltu",
                        "content": "`s1 = \\'aa\\', s2 = \\'bc\\', s3 = \\'c\\'` and `t1 = \\'dbbc\\', t2 = \\'a\\'` so the answer is `s1 + t1 + s2 + t2 + s3`"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Here s or t don\\'t represent the charecters but a substring, which means in above example s1 is \"aa\" and t1 is \"dbbc\" and similarily s2 is \"bc\"..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a string problem. But it needs some method to solve. A 2D DP is possible, since s3 depends on both s1 & s2. "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@meow_power](/meow_power) because we don\\'t need it, i and j together can always determine k uniquely (i+j = k; always holds if ur not doing anything sus)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@meow_power](/meow_power) Your solution is fine. 2D array is used."
                    },
                    {
                        "username": "meow_power",
                        "content": "my solution uses k as third parameter but in memoization why is it not used.Please help"
                    },
                    {
                        "username": "mayliao",
                        "content": "It is so strange use static variable get the answer is different from my computer. After I changed it as parameter, it worked well."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "relevant article \\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-"
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "cuz static variable will be kept and be operated by the function u implemented for each different test cases, without resetting its original value. while local parameter will be wiped after function is done for one test case, and created and set for the next test case."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/interleaving-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Recursion with memoization\n\n  \n**Approach 3:** Using 2D Dynamic Programming\n\n  \n**Approach 4:** Using 1D Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1568580,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "So you need to ask yourself ..why is dp used here?\\n In first look this questions looks pretty simple and can be done using 2 pointers. \\n \\n Then you implement the 2 pointer approach and upon submission your code get a wrong ans on the below testcase.\\n \\n This test case then tells you why this que is asking for a dp solution.\\n \\n s1 = \"aabc\"\\n s2 = \"abad\"\\n s3= \"aabadabc\"\\n \\n Now in this, if you start moving from the back using the 2 pointer approach, it keeps on eleminating the character from the 1st string i.e s1. But when s1 gets exhausted, your s3 does not match with s2. \\n Here you take a note that, when char at s1 and s2 are equal, we need to check if deleting the char from s1 is a correct move or deleting the char from s2 would be a correct move.\\n \\n That clearly means, we have 2 choices here, either to delete the char from s1 or s2.\\n \\n Now for a bigger testcase like this it is clearly evidant that the que is asking for a Dyanmic Programming solution!!\\n \\n s1 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s2 = \"aaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s3 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\\t\\t aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n"
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "great intution \\uD83D\\uDD25\\uD83D\\uDD25\\uD83C\\uDF89"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "I CAN\\'T BELIEVE I SOLVED THIS ONE BY MY SELF :OOOOOOOOOO"
                    },
                    {
                        "username": "SeineAle",
                        "content": "ME TOO !\nFeels Good :)"
                    },
                    {
                        "username": "killerraj369",
                        "content": "After watching this comment I solved it by myself at first attempt itself."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good... doesn\\'t it?"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "same bro... feeling proud in my small achievement lol !"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "I am ashamed of my self. "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "same bruh!\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "whenever i see leaving, it reminds me of her :("
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "slow claps :)"
                    },
                    {
                        "username": "santanusen",
                        "content": "Please share how did you make her leave :p"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "Logic level with realistic view on top "
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "riyal"
                    },
                    {
                        "username": "Vicjr",
                        "content": "real"
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "real"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\\uD83D\\uDE06 "
                    },
                    {
                        "username": "maysrv",
                        "content": "You might be tempted to use i, j and k to keep track of s1, s2 and s3 respectively in your recursive calls but it gave me TLE. (Please note that it is not wrong)\\nThe trick here was to remove k from your changing state and reduce dp from 3D to 2D.\\nYou may reason about it by manipulating what you think of i and j at each point and it may work for you but I would like to point out how I reason it. \\nThe thing here is, at every step k is nothing but i+j, so we dont need to keep track of k because we can get it from i and j."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@chenon](/chenon) The problem here is you\\'re greedily checking if s3 can be created from s1 if not then you\\'re checking for s2.\\n\\nIf somehow the test-case you\\'re mentioning currently is cleared then you\\'ll stuck later on."
                    },
                    {
                        "username": "chenon",
                        "content": "I was exactly keeping track of the indexes on s1 and s2  . See my submission https://leetcode.com/problems/interleaving-string/submissions/1031746304/ . NO TLE but wrong answer."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I used 4D and beat 9%..."
                    },
                    {
                        "username": "parmani",
                        "content": "but 3d also works, since the constraints are low"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "at first i also did the 3d dp, then i figured it out that we dont need k..:p"
                    },
                    {
                        "username": "sanket54",
                        "content": "What is meaning of |n-m| <= 1 and why it is being ignored in all solutions ?"
                    },
                    {
                        "username": "sanjeeb42",
                        "content": "[@mahesh105](/mahesh105) Thanks for the explanation. I was exactly looking for this"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@mahesh105](/mahesh105)  thankss bro"
                    },
                    {
                        "username": "mahesh105",
                        "content": "All of the reasons in this threads were not explaining why?\\nLet me tell you.\\nsuppose you take n substrings of S1 and place it like this\\n__  __  __  __  __  __  __  __  __  __  __  __\\nthen you can fill the S2 substrings in the gaps or the boundary...in either case the inequality holds.\\nSo yeah if the string is interleaving, this inequality is automatically held due to this observation.\\nHappy Debugging : )"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The fact is that |n - m| <= 1 (where m and n are the no. of substring used for interleaving the string) is just the condition which supports that strings must be interleaved.\\nIf there are interleaved correctly then this condition will be automatically true.\\nThat\\'s why every piece of information not need to be included in code some time based on few logic we have to neglect few of them."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@unters](/unters) |n-m| <= 1 means you cannot divide the strings into arbitrarily sized pieces. If string 1 is divided into 4 parts, then string 5 can only be divided into 3, 4 or 5 parts. "
                    },
                    {
                        "username": "unters",
                        "content": "[@WajeehHasan](/WajeehHasan), in my opinion you\\'re not quite right. `m` and `n` are not numbers of characters in each string - that are numbers of nonoverlapping substrings in each string (each substring can contain more than one character). `|m - n| <= 1\\' means there can not be two adjacent substrings in p3 that belong to one string."
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Exactly what I am looking for."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "simply means difference of the length of string s and t is less than or equal to 1"
                    },
                    {
                        "username": "eddy66",
                        "content": "I think `|n-m|<=1` just means the substrings of `s` are interleaved with the substrings of `t`. So they could be `s1, t1, s2`, or `s1, t1, s2, t2`. But since each substring can be anything, so it\\'s not important when we solve the problem"
                    },
                    {
                        "username": "mvo13",
                        "content": "|n-m| <= 1 \\n=> The time complexity is O(n^2)"
                    },
                    {
                        "username": "shiva_San",
                        "content": "be ready for this testcase if you are using two pointer method without dp..\n\ns1 =\n\"aabc\"\ns2 =\n\"abad\"\ns3 =\n\"aabadabc\"\n\noutput=true\n"
                    },
                    {
                        "username": "oisinfarrell00",
                        "content": "In the brief of Intervealving strings it states that:\\n - The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...\\nHowever then they give this example:\\n![image](https://assets.leetcode.com/users/images/28de80e4-3308-48c9-9f45-46d243f7a928_1622621577.219354.png)\\nI dont really understand how this example works. It takes two letters from the first string and then 4 from the next and then back to two and so on. I thought it had to be like s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ... Am I missing something here?"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "s1 and so on may not necessarily be single characters. That is the trick here."
                    },
                    {
                        "username": "Kaltu",
                        "content": "`s1 = \\'aa\\', s2 = \\'bc\\', s3 = \\'c\\'` and `t1 = \\'dbbc\\', t2 = \\'a\\'` so the answer is `s1 + t1 + s2 + t2 + s3`"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Here s or t don\\'t represent the charecters but a substring, which means in above example s1 is \"aa\" and t1 is \"dbbc\" and similarily s2 is \"bc\"..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a string problem. But it needs some method to solve. A 2D DP is possible, since s3 depends on both s1 & s2. "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@meow_power](/meow_power) because we don\\'t need it, i and j together can always determine k uniquely (i+j = k; always holds if ur not doing anything sus)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@meow_power](/meow_power) Your solution is fine. 2D array is used."
                    },
                    {
                        "username": "meow_power",
                        "content": "my solution uses k as third parameter but in memoization why is it not used.Please help"
                    },
                    {
                        "username": "mayliao",
                        "content": "It is so strange use static variable get the answer is different from my computer. After I changed it as parameter, it worked well."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "relevant article \\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-"
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "cuz static variable will be kept and be operated by the function u implemented for each different test cases, without resetting its original value. while local parameter will be wiped after function is done for one test case, and created and set for the next test case."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/interleaving-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Recursion with memoization\n\n  \n**Approach 3:** Using 2D Dynamic Programming\n\n  \n**Approach 4:** Using 1D Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 2029043,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "So you need to ask yourself ..why is dp used here?\\n In first look this questions looks pretty simple and can be done using 2 pointers. \\n \\n Then you implement the 2 pointer approach and upon submission your code get a wrong ans on the below testcase.\\n \\n This test case then tells you why this que is asking for a dp solution.\\n \\n s1 = \"aabc\"\\n s2 = \"abad\"\\n s3= \"aabadabc\"\\n \\n Now in this, if you start moving from the back using the 2 pointer approach, it keeps on eleminating the character from the 1st string i.e s1. But when s1 gets exhausted, your s3 does not match with s2. \\n Here you take a note that, when char at s1 and s2 are equal, we need to check if deleting the char from s1 is a correct move or deleting the char from s2 would be a correct move.\\n \\n That clearly means, we have 2 choices here, either to delete the char from s1 or s2.\\n \\n Now for a bigger testcase like this it is clearly evidant that the que is asking for a Dyanmic Programming solution!!\\n \\n s1 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s2 = \"aaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s3 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\\t\\t aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n"
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "great intution \\uD83D\\uDD25\\uD83D\\uDD25\\uD83C\\uDF89"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "I CAN\\'T BELIEVE I SOLVED THIS ONE BY MY SELF :OOOOOOOOOO"
                    },
                    {
                        "username": "SeineAle",
                        "content": "ME TOO !\nFeels Good :)"
                    },
                    {
                        "username": "killerraj369",
                        "content": "After watching this comment I solved it by myself at first attempt itself."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good... doesn\\'t it?"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "same bro... feeling proud in my small achievement lol !"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "I am ashamed of my self. "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "same bruh!\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "whenever i see leaving, it reminds me of her :("
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "slow claps :)"
                    },
                    {
                        "username": "santanusen",
                        "content": "Please share how did you make her leave :p"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "Logic level with realistic view on top "
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "riyal"
                    },
                    {
                        "username": "Vicjr",
                        "content": "real"
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "real"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\\uD83D\\uDE06 "
                    },
                    {
                        "username": "maysrv",
                        "content": "You might be tempted to use i, j and k to keep track of s1, s2 and s3 respectively in your recursive calls but it gave me TLE. (Please note that it is not wrong)\\nThe trick here was to remove k from your changing state and reduce dp from 3D to 2D.\\nYou may reason about it by manipulating what you think of i and j at each point and it may work for you but I would like to point out how I reason it. \\nThe thing here is, at every step k is nothing but i+j, so we dont need to keep track of k because we can get it from i and j."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@chenon](/chenon) The problem here is you\\'re greedily checking if s3 can be created from s1 if not then you\\'re checking for s2.\\n\\nIf somehow the test-case you\\'re mentioning currently is cleared then you\\'ll stuck later on."
                    },
                    {
                        "username": "chenon",
                        "content": "I was exactly keeping track of the indexes on s1 and s2  . See my submission https://leetcode.com/problems/interleaving-string/submissions/1031746304/ . NO TLE but wrong answer."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I used 4D and beat 9%..."
                    },
                    {
                        "username": "parmani",
                        "content": "but 3d also works, since the constraints are low"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "at first i also did the 3d dp, then i figured it out that we dont need k..:p"
                    },
                    {
                        "username": "sanket54",
                        "content": "What is meaning of |n-m| <= 1 and why it is being ignored in all solutions ?"
                    },
                    {
                        "username": "sanjeeb42",
                        "content": "[@mahesh105](/mahesh105) Thanks for the explanation. I was exactly looking for this"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@mahesh105](/mahesh105)  thankss bro"
                    },
                    {
                        "username": "mahesh105",
                        "content": "All of the reasons in this threads were not explaining why?\\nLet me tell you.\\nsuppose you take n substrings of S1 and place it like this\\n__  __  __  __  __  __  __  __  __  __  __  __\\nthen you can fill the S2 substrings in the gaps or the boundary...in either case the inequality holds.\\nSo yeah if the string is interleaving, this inequality is automatically held due to this observation.\\nHappy Debugging : )"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The fact is that |n - m| <= 1 (where m and n are the no. of substring used for interleaving the string) is just the condition which supports that strings must be interleaved.\\nIf there are interleaved correctly then this condition will be automatically true.\\nThat\\'s why every piece of information not need to be included in code some time based on few logic we have to neglect few of them."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@unters](/unters) |n-m| <= 1 means you cannot divide the strings into arbitrarily sized pieces. If string 1 is divided into 4 parts, then string 5 can only be divided into 3, 4 or 5 parts. "
                    },
                    {
                        "username": "unters",
                        "content": "[@WajeehHasan](/WajeehHasan), in my opinion you\\'re not quite right. `m` and `n` are not numbers of characters in each string - that are numbers of nonoverlapping substrings in each string (each substring can contain more than one character). `|m - n| <= 1\\' means there can not be two adjacent substrings in p3 that belong to one string."
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Exactly what I am looking for."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "simply means difference of the length of string s and t is less than or equal to 1"
                    },
                    {
                        "username": "eddy66",
                        "content": "I think `|n-m|<=1` just means the substrings of `s` are interleaved with the substrings of `t`. So they could be `s1, t1, s2`, or `s1, t1, s2, t2`. But since each substring can be anything, so it\\'s not important when we solve the problem"
                    },
                    {
                        "username": "mvo13",
                        "content": "|n-m| <= 1 \\n=> The time complexity is O(n^2)"
                    },
                    {
                        "username": "shiva_San",
                        "content": "be ready for this testcase if you are using two pointer method without dp..\n\ns1 =\n\"aabc\"\ns2 =\n\"abad\"\ns3 =\n\"aabadabc\"\n\noutput=true\n"
                    },
                    {
                        "username": "oisinfarrell00",
                        "content": "In the brief of Intervealving strings it states that:\\n - The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...\\nHowever then they give this example:\\n![image](https://assets.leetcode.com/users/images/28de80e4-3308-48c9-9f45-46d243f7a928_1622621577.219354.png)\\nI dont really understand how this example works. It takes two letters from the first string and then 4 from the next and then back to two and so on. I thought it had to be like s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ... Am I missing something here?"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "s1 and so on may not necessarily be single characters. That is the trick here."
                    },
                    {
                        "username": "Kaltu",
                        "content": "`s1 = \\'aa\\', s2 = \\'bc\\', s3 = \\'c\\'` and `t1 = \\'dbbc\\', t2 = \\'a\\'` so the answer is `s1 + t1 + s2 + t2 + s3`"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Here s or t don\\'t represent the charecters but a substring, which means in above example s1 is \"aa\" and t1 is \"dbbc\" and similarily s2 is \"bc\"..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a string problem. But it needs some method to solve. A 2D DP is possible, since s3 depends on both s1 & s2. "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@meow_power](/meow_power) because we don\\'t need it, i and j together can always determine k uniquely (i+j = k; always holds if ur not doing anything sus)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@meow_power](/meow_power) Your solution is fine. 2D array is used."
                    },
                    {
                        "username": "meow_power",
                        "content": "my solution uses k as third parameter but in memoization why is it not used.Please help"
                    },
                    {
                        "username": "mayliao",
                        "content": "It is so strange use static variable get the answer is different from my computer. After I changed it as parameter, it worked well."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "relevant article \\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-"
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "cuz static variable will be kept and be operated by the function u implemented for each different test cases, without resetting its original value. while local parameter will be wiped after function is done for one test case, and created and set for the next test case."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/interleaving-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Recursion with memoization\n\n  \n**Approach 3:** Using 2D Dynamic Programming\n\n  \n**Approach 4:** Using 1D Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1570461,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "So you need to ask yourself ..why is dp used here?\\n In first look this questions looks pretty simple and can be done using 2 pointers. \\n \\n Then you implement the 2 pointer approach and upon submission your code get a wrong ans on the below testcase.\\n \\n This test case then tells you why this que is asking for a dp solution.\\n \\n s1 = \"aabc\"\\n s2 = \"abad\"\\n s3= \"aabadabc\"\\n \\n Now in this, if you start moving from the back using the 2 pointer approach, it keeps on eleminating the character from the 1st string i.e s1. But when s1 gets exhausted, your s3 does not match with s2. \\n Here you take a note that, when char at s1 and s2 are equal, we need to check if deleting the char from s1 is a correct move or deleting the char from s2 would be a correct move.\\n \\n That clearly means, we have 2 choices here, either to delete the char from s1 or s2.\\n \\n Now for a bigger testcase like this it is clearly evidant that the que is asking for a Dyanmic Programming solution!!\\n \\n s1 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s2 = \"aaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s3 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\\t\\t aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n"
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "great intution \\uD83D\\uDD25\\uD83D\\uDD25\\uD83C\\uDF89"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "I CAN\\'T BELIEVE I SOLVED THIS ONE BY MY SELF :OOOOOOOOOO"
                    },
                    {
                        "username": "SeineAle",
                        "content": "ME TOO !\nFeels Good :)"
                    },
                    {
                        "username": "killerraj369",
                        "content": "After watching this comment I solved it by myself at first attempt itself."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good... doesn\\'t it?"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "same bro... feeling proud in my small achievement lol !"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "I am ashamed of my self. "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "same bruh!\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "whenever i see leaving, it reminds me of her :("
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "slow claps :)"
                    },
                    {
                        "username": "santanusen",
                        "content": "Please share how did you make her leave :p"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "Logic level with realistic view on top "
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "riyal"
                    },
                    {
                        "username": "Vicjr",
                        "content": "real"
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "real"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\\uD83D\\uDE06 "
                    },
                    {
                        "username": "maysrv",
                        "content": "You might be tempted to use i, j and k to keep track of s1, s2 and s3 respectively in your recursive calls but it gave me TLE. (Please note that it is not wrong)\\nThe trick here was to remove k from your changing state and reduce dp from 3D to 2D.\\nYou may reason about it by manipulating what you think of i and j at each point and it may work for you but I would like to point out how I reason it. \\nThe thing here is, at every step k is nothing but i+j, so we dont need to keep track of k because we can get it from i and j."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@chenon](/chenon) The problem here is you\\'re greedily checking if s3 can be created from s1 if not then you\\'re checking for s2.\\n\\nIf somehow the test-case you\\'re mentioning currently is cleared then you\\'ll stuck later on."
                    },
                    {
                        "username": "chenon",
                        "content": "I was exactly keeping track of the indexes on s1 and s2  . See my submission https://leetcode.com/problems/interleaving-string/submissions/1031746304/ . NO TLE but wrong answer."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I used 4D and beat 9%..."
                    },
                    {
                        "username": "parmani",
                        "content": "but 3d also works, since the constraints are low"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "at first i also did the 3d dp, then i figured it out that we dont need k..:p"
                    },
                    {
                        "username": "sanket54",
                        "content": "What is meaning of |n-m| <= 1 and why it is being ignored in all solutions ?"
                    },
                    {
                        "username": "sanjeeb42",
                        "content": "[@mahesh105](/mahesh105) Thanks for the explanation. I was exactly looking for this"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@mahesh105](/mahesh105)  thankss bro"
                    },
                    {
                        "username": "mahesh105",
                        "content": "All of the reasons in this threads were not explaining why?\\nLet me tell you.\\nsuppose you take n substrings of S1 and place it like this\\n__  __  __  __  __  __  __  __  __  __  __  __\\nthen you can fill the S2 substrings in the gaps or the boundary...in either case the inequality holds.\\nSo yeah if the string is interleaving, this inequality is automatically held due to this observation.\\nHappy Debugging : )"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The fact is that |n - m| <= 1 (where m and n are the no. of substring used for interleaving the string) is just the condition which supports that strings must be interleaved.\\nIf there are interleaved correctly then this condition will be automatically true.\\nThat\\'s why every piece of information not need to be included in code some time based on few logic we have to neglect few of them."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@unters](/unters) |n-m| <= 1 means you cannot divide the strings into arbitrarily sized pieces. If string 1 is divided into 4 parts, then string 5 can only be divided into 3, 4 or 5 parts. "
                    },
                    {
                        "username": "unters",
                        "content": "[@WajeehHasan](/WajeehHasan), in my opinion you\\'re not quite right. `m` and `n` are not numbers of characters in each string - that are numbers of nonoverlapping substrings in each string (each substring can contain more than one character). `|m - n| <= 1\\' means there can not be two adjacent substrings in p3 that belong to one string."
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Exactly what I am looking for."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "simply means difference of the length of string s and t is less than or equal to 1"
                    },
                    {
                        "username": "eddy66",
                        "content": "I think `|n-m|<=1` just means the substrings of `s` are interleaved with the substrings of `t`. So they could be `s1, t1, s2`, or `s1, t1, s2, t2`. But since each substring can be anything, so it\\'s not important when we solve the problem"
                    },
                    {
                        "username": "mvo13",
                        "content": "|n-m| <= 1 \\n=> The time complexity is O(n^2)"
                    },
                    {
                        "username": "shiva_San",
                        "content": "be ready for this testcase if you are using two pointer method without dp..\n\ns1 =\n\"aabc\"\ns2 =\n\"abad\"\ns3 =\n\"aabadabc\"\n\noutput=true\n"
                    },
                    {
                        "username": "oisinfarrell00",
                        "content": "In the brief of Intervealving strings it states that:\\n - The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...\\nHowever then they give this example:\\n![image](https://assets.leetcode.com/users/images/28de80e4-3308-48c9-9f45-46d243f7a928_1622621577.219354.png)\\nI dont really understand how this example works. It takes two letters from the first string and then 4 from the next and then back to two and so on. I thought it had to be like s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ... Am I missing something here?"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "s1 and so on may not necessarily be single characters. That is the trick here."
                    },
                    {
                        "username": "Kaltu",
                        "content": "`s1 = \\'aa\\', s2 = \\'bc\\', s3 = \\'c\\'` and `t1 = \\'dbbc\\', t2 = \\'a\\'` so the answer is `s1 + t1 + s2 + t2 + s3`"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Here s or t don\\'t represent the charecters but a substring, which means in above example s1 is \"aa\" and t1 is \"dbbc\" and similarily s2 is \"bc\"..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a string problem. But it needs some method to solve. A 2D DP is possible, since s3 depends on both s1 & s2. "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@meow_power](/meow_power) because we don\\'t need it, i and j together can always determine k uniquely (i+j = k; always holds if ur not doing anything sus)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@meow_power](/meow_power) Your solution is fine. 2D array is used."
                    },
                    {
                        "username": "meow_power",
                        "content": "my solution uses k as third parameter but in memoization why is it not used.Please help"
                    },
                    {
                        "username": "mayliao",
                        "content": "It is so strange use static variable get the answer is different from my computer. After I changed it as parameter, it worked well."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "relevant article \\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-"
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "cuz static variable will be kept and be operated by the function u implemented for each different test cases, without resetting its original value. while local parameter will be wiped after function is done for one test case, and created and set for the next test case."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/interleaving-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Recursion with memoization\n\n  \n**Approach 3:** Using 2D Dynamic Programming\n\n  \n**Approach 4:** Using 1D Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1567151,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "So you need to ask yourself ..why is dp used here?\\n In first look this questions looks pretty simple and can be done using 2 pointers. \\n \\n Then you implement the 2 pointer approach and upon submission your code get a wrong ans on the below testcase.\\n \\n This test case then tells you why this que is asking for a dp solution.\\n \\n s1 = \"aabc\"\\n s2 = \"abad\"\\n s3= \"aabadabc\"\\n \\n Now in this, if you start moving from the back using the 2 pointer approach, it keeps on eleminating the character from the 1st string i.e s1. But when s1 gets exhausted, your s3 does not match with s2. \\n Here you take a note that, when char at s1 and s2 are equal, we need to check if deleting the char from s1 is a correct move or deleting the char from s2 would be a correct move.\\n \\n That clearly means, we have 2 choices here, either to delete the char from s1 or s2.\\n \\n Now for a bigger testcase like this it is clearly evidant that the que is asking for a Dyanmic Programming solution!!\\n \\n s1 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s2 = \"aaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s3 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\\t\\t aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n"
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "great intution \\uD83D\\uDD25\\uD83D\\uDD25\\uD83C\\uDF89"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "I CAN\\'T BELIEVE I SOLVED THIS ONE BY MY SELF :OOOOOOOOOO"
                    },
                    {
                        "username": "SeineAle",
                        "content": "ME TOO !\nFeels Good :)"
                    },
                    {
                        "username": "killerraj369",
                        "content": "After watching this comment I solved it by myself at first attempt itself."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good... doesn\\'t it?"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "same bro... feeling proud in my small achievement lol !"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "I am ashamed of my self. "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "same bruh!\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "whenever i see leaving, it reminds me of her :("
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "slow claps :)"
                    },
                    {
                        "username": "santanusen",
                        "content": "Please share how did you make her leave :p"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "Logic level with realistic view on top "
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "riyal"
                    },
                    {
                        "username": "Vicjr",
                        "content": "real"
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "real"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\\uD83D\\uDE06 "
                    },
                    {
                        "username": "maysrv",
                        "content": "You might be tempted to use i, j and k to keep track of s1, s2 and s3 respectively in your recursive calls but it gave me TLE. (Please note that it is not wrong)\\nThe trick here was to remove k from your changing state and reduce dp from 3D to 2D.\\nYou may reason about it by manipulating what you think of i and j at each point and it may work for you but I would like to point out how I reason it. \\nThe thing here is, at every step k is nothing but i+j, so we dont need to keep track of k because we can get it from i and j."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@chenon](/chenon) The problem here is you\\'re greedily checking if s3 can be created from s1 if not then you\\'re checking for s2.\\n\\nIf somehow the test-case you\\'re mentioning currently is cleared then you\\'ll stuck later on."
                    },
                    {
                        "username": "chenon",
                        "content": "I was exactly keeping track of the indexes on s1 and s2  . See my submission https://leetcode.com/problems/interleaving-string/submissions/1031746304/ . NO TLE but wrong answer."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I used 4D and beat 9%..."
                    },
                    {
                        "username": "parmani",
                        "content": "but 3d also works, since the constraints are low"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "at first i also did the 3d dp, then i figured it out that we dont need k..:p"
                    },
                    {
                        "username": "sanket54",
                        "content": "What is meaning of |n-m| <= 1 and why it is being ignored in all solutions ?"
                    },
                    {
                        "username": "sanjeeb42",
                        "content": "[@mahesh105](/mahesh105) Thanks for the explanation. I was exactly looking for this"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@mahesh105](/mahesh105)  thankss bro"
                    },
                    {
                        "username": "mahesh105",
                        "content": "All of the reasons in this threads were not explaining why?\\nLet me tell you.\\nsuppose you take n substrings of S1 and place it like this\\n__  __  __  __  __  __  __  __  __  __  __  __\\nthen you can fill the S2 substrings in the gaps or the boundary...in either case the inequality holds.\\nSo yeah if the string is interleaving, this inequality is automatically held due to this observation.\\nHappy Debugging : )"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The fact is that |n - m| <= 1 (where m and n are the no. of substring used for interleaving the string) is just the condition which supports that strings must be interleaved.\\nIf there are interleaved correctly then this condition will be automatically true.\\nThat\\'s why every piece of information not need to be included in code some time based on few logic we have to neglect few of them."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@unters](/unters) |n-m| <= 1 means you cannot divide the strings into arbitrarily sized pieces. If string 1 is divided into 4 parts, then string 5 can only be divided into 3, 4 or 5 parts. "
                    },
                    {
                        "username": "unters",
                        "content": "[@WajeehHasan](/WajeehHasan), in my opinion you\\'re not quite right. `m` and `n` are not numbers of characters in each string - that are numbers of nonoverlapping substrings in each string (each substring can contain more than one character). `|m - n| <= 1\\' means there can not be two adjacent substrings in p3 that belong to one string."
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Exactly what I am looking for."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "simply means difference of the length of string s and t is less than or equal to 1"
                    },
                    {
                        "username": "eddy66",
                        "content": "I think `|n-m|<=1` just means the substrings of `s` are interleaved with the substrings of `t`. So they could be `s1, t1, s2`, or `s1, t1, s2, t2`. But since each substring can be anything, so it\\'s not important when we solve the problem"
                    },
                    {
                        "username": "mvo13",
                        "content": "|n-m| <= 1 \\n=> The time complexity is O(n^2)"
                    },
                    {
                        "username": "shiva_San",
                        "content": "be ready for this testcase if you are using two pointer method without dp..\n\ns1 =\n\"aabc\"\ns2 =\n\"abad\"\ns3 =\n\"aabadabc\"\n\noutput=true\n"
                    },
                    {
                        "username": "oisinfarrell00",
                        "content": "In the brief of Intervealving strings it states that:\\n - The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...\\nHowever then they give this example:\\n![image](https://assets.leetcode.com/users/images/28de80e4-3308-48c9-9f45-46d243f7a928_1622621577.219354.png)\\nI dont really understand how this example works. It takes two letters from the first string and then 4 from the next and then back to two and so on. I thought it had to be like s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ... Am I missing something here?"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "s1 and so on may not necessarily be single characters. That is the trick here."
                    },
                    {
                        "username": "Kaltu",
                        "content": "`s1 = \\'aa\\', s2 = \\'bc\\', s3 = \\'c\\'` and `t1 = \\'dbbc\\', t2 = \\'a\\'` so the answer is `s1 + t1 + s2 + t2 + s3`"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Here s or t don\\'t represent the charecters but a substring, which means in above example s1 is \"aa\" and t1 is \"dbbc\" and similarily s2 is \"bc\"..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a string problem. But it needs some method to solve. A 2D DP is possible, since s3 depends on both s1 & s2. "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@meow_power](/meow_power) because we don\\'t need it, i and j together can always determine k uniquely (i+j = k; always holds if ur not doing anything sus)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@meow_power](/meow_power) Your solution is fine. 2D array is used."
                    },
                    {
                        "username": "meow_power",
                        "content": "my solution uses k as third parameter but in memoization why is it not used.Please help"
                    },
                    {
                        "username": "mayliao",
                        "content": "It is so strange use static variable get the answer is different from my computer. After I changed it as parameter, it worked well."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "relevant article \\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-"
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "cuz static variable will be kept and be operated by the function u implemented for each different test cases, without resetting its original value. while local parameter will be wiped after function is done for one test case, and created and set for the next test case."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/interleaving-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Recursion with memoization\n\n  \n**Approach 3:** Using 2D Dynamic Programming\n\n  \n**Approach 4:** Using 1D Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1576535,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "So you need to ask yourself ..why is dp used here?\\n In first look this questions looks pretty simple and can be done using 2 pointers. \\n \\n Then you implement the 2 pointer approach and upon submission your code get a wrong ans on the below testcase.\\n \\n This test case then tells you why this que is asking for a dp solution.\\n \\n s1 = \"aabc\"\\n s2 = \"abad\"\\n s3= \"aabadabc\"\\n \\n Now in this, if you start moving from the back using the 2 pointer approach, it keeps on eleminating the character from the 1st string i.e s1. But when s1 gets exhausted, your s3 does not match with s2. \\n Here you take a note that, when char at s1 and s2 are equal, we need to check if deleting the char from s1 is a correct move or deleting the char from s2 would be a correct move.\\n \\n That clearly means, we have 2 choices here, either to delete the char from s1 or s2.\\n \\n Now for a bigger testcase like this it is clearly evidant that the que is asking for a Dyanmic Programming solution!!\\n \\n s1 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s2 = \"aaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s3 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\\t\\t aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n"
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "great intution \\uD83D\\uDD25\\uD83D\\uDD25\\uD83C\\uDF89"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "I CAN\\'T BELIEVE I SOLVED THIS ONE BY MY SELF :OOOOOOOOOO"
                    },
                    {
                        "username": "SeineAle",
                        "content": "ME TOO !\nFeels Good :)"
                    },
                    {
                        "username": "killerraj369",
                        "content": "After watching this comment I solved it by myself at first attempt itself."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good... doesn\\'t it?"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "same bro... feeling proud in my small achievement lol !"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "I am ashamed of my self. "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "same bruh!\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "whenever i see leaving, it reminds me of her :("
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "slow claps :)"
                    },
                    {
                        "username": "santanusen",
                        "content": "Please share how did you make her leave :p"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "Logic level with realistic view on top "
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "riyal"
                    },
                    {
                        "username": "Vicjr",
                        "content": "real"
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "real"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\\uD83D\\uDE06 "
                    },
                    {
                        "username": "maysrv",
                        "content": "You might be tempted to use i, j and k to keep track of s1, s2 and s3 respectively in your recursive calls but it gave me TLE. (Please note that it is not wrong)\\nThe trick here was to remove k from your changing state and reduce dp from 3D to 2D.\\nYou may reason about it by manipulating what you think of i and j at each point and it may work for you but I would like to point out how I reason it. \\nThe thing here is, at every step k is nothing but i+j, so we dont need to keep track of k because we can get it from i and j."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@chenon](/chenon) The problem here is you\\'re greedily checking if s3 can be created from s1 if not then you\\'re checking for s2.\\n\\nIf somehow the test-case you\\'re mentioning currently is cleared then you\\'ll stuck later on."
                    },
                    {
                        "username": "chenon",
                        "content": "I was exactly keeping track of the indexes on s1 and s2  . See my submission https://leetcode.com/problems/interleaving-string/submissions/1031746304/ . NO TLE but wrong answer."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I used 4D and beat 9%..."
                    },
                    {
                        "username": "parmani",
                        "content": "but 3d also works, since the constraints are low"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "at first i also did the 3d dp, then i figured it out that we dont need k..:p"
                    },
                    {
                        "username": "sanket54",
                        "content": "What is meaning of |n-m| <= 1 and why it is being ignored in all solutions ?"
                    },
                    {
                        "username": "sanjeeb42",
                        "content": "[@mahesh105](/mahesh105) Thanks for the explanation. I was exactly looking for this"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@mahesh105](/mahesh105)  thankss bro"
                    },
                    {
                        "username": "mahesh105",
                        "content": "All of the reasons in this threads were not explaining why?\\nLet me tell you.\\nsuppose you take n substrings of S1 and place it like this\\n__  __  __  __  __  __  __  __  __  __  __  __\\nthen you can fill the S2 substrings in the gaps or the boundary...in either case the inequality holds.\\nSo yeah if the string is interleaving, this inequality is automatically held due to this observation.\\nHappy Debugging : )"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The fact is that |n - m| <= 1 (where m and n are the no. of substring used for interleaving the string) is just the condition which supports that strings must be interleaved.\\nIf there are interleaved correctly then this condition will be automatically true.\\nThat\\'s why every piece of information not need to be included in code some time based on few logic we have to neglect few of them."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@unters](/unters) |n-m| <= 1 means you cannot divide the strings into arbitrarily sized pieces. If string 1 is divided into 4 parts, then string 5 can only be divided into 3, 4 or 5 parts. "
                    },
                    {
                        "username": "unters",
                        "content": "[@WajeehHasan](/WajeehHasan), in my opinion you\\'re not quite right. `m` and `n` are not numbers of characters in each string - that are numbers of nonoverlapping substrings in each string (each substring can contain more than one character). `|m - n| <= 1\\' means there can not be two adjacent substrings in p3 that belong to one string."
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Exactly what I am looking for."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "simply means difference of the length of string s and t is less than or equal to 1"
                    },
                    {
                        "username": "eddy66",
                        "content": "I think `|n-m|<=1` just means the substrings of `s` are interleaved with the substrings of `t`. So they could be `s1, t1, s2`, or `s1, t1, s2, t2`. But since each substring can be anything, so it\\'s not important when we solve the problem"
                    },
                    {
                        "username": "mvo13",
                        "content": "|n-m| <= 1 \\n=> The time complexity is O(n^2)"
                    },
                    {
                        "username": "shiva_San",
                        "content": "be ready for this testcase if you are using two pointer method without dp..\n\ns1 =\n\"aabc\"\ns2 =\n\"abad\"\ns3 =\n\"aabadabc\"\n\noutput=true\n"
                    },
                    {
                        "username": "oisinfarrell00",
                        "content": "In the brief of Intervealving strings it states that:\\n - The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...\\nHowever then they give this example:\\n![image](https://assets.leetcode.com/users/images/28de80e4-3308-48c9-9f45-46d243f7a928_1622621577.219354.png)\\nI dont really understand how this example works. It takes two letters from the first string and then 4 from the next and then back to two and so on. I thought it had to be like s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ... Am I missing something here?"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "s1 and so on may not necessarily be single characters. That is the trick here."
                    },
                    {
                        "username": "Kaltu",
                        "content": "`s1 = \\'aa\\', s2 = \\'bc\\', s3 = \\'c\\'` and `t1 = \\'dbbc\\', t2 = \\'a\\'` so the answer is `s1 + t1 + s2 + t2 + s3`"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Here s or t don\\'t represent the charecters but a substring, which means in above example s1 is \"aa\" and t1 is \"dbbc\" and similarily s2 is \"bc\"..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a string problem. But it needs some method to solve. A 2D DP is possible, since s3 depends on both s1 & s2. "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@meow_power](/meow_power) because we don\\'t need it, i and j together can always determine k uniquely (i+j = k; always holds if ur not doing anything sus)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@meow_power](/meow_power) Your solution is fine. 2D array is used."
                    },
                    {
                        "username": "meow_power",
                        "content": "my solution uses k as third parameter but in memoization why is it not used.Please help"
                    },
                    {
                        "username": "mayliao",
                        "content": "It is so strange use static variable get the answer is different from my computer. After I changed it as parameter, it worked well."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "relevant article \\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-"
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "cuz static variable will be kept and be operated by the function u implemented for each different test cases, without resetting its original value. while local parameter will be wiped after function is done for one test case, and created and set for the next test case."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/interleaving-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Recursion with memoization\n\n  \n**Approach 3:** Using 2D Dynamic Programming\n\n  \n**Approach 4:** Using 1D Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1646591,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "So you need to ask yourself ..why is dp used here?\\n In first look this questions looks pretty simple and can be done using 2 pointers. \\n \\n Then you implement the 2 pointer approach and upon submission your code get a wrong ans on the below testcase.\\n \\n This test case then tells you why this que is asking for a dp solution.\\n \\n s1 = \"aabc\"\\n s2 = \"abad\"\\n s3= \"aabadabc\"\\n \\n Now in this, if you start moving from the back using the 2 pointer approach, it keeps on eleminating the character from the 1st string i.e s1. But when s1 gets exhausted, your s3 does not match with s2. \\n Here you take a note that, when char at s1 and s2 are equal, we need to check if deleting the char from s1 is a correct move or deleting the char from s2 would be a correct move.\\n \\n That clearly means, we have 2 choices here, either to delete the char from s1 or s2.\\n \\n Now for a bigger testcase like this it is clearly evidant that the que is asking for a Dyanmic Programming solution!!\\n \\n s1 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s2 = \"aaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s3 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\\t\\t aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n"
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "great intution \\uD83D\\uDD25\\uD83D\\uDD25\\uD83C\\uDF89"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "I CAN\\'T BELIEVE I SOLVED THIS ONE BY MY SELF :OOOOOOOOOO"
                    },
                    {
                        "username": "SeineAle",
                        "content": "ME TOO !\nFeels Good :)"
                    },
                    {
                        "username": "killerraj369",
                        "content": "After watching this comment I solved it by myself at first attempt itself."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good... doesn\\'t it?"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "same bro... feeling proud in my small achievement lol !"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "I am ashamed of my self. "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "same bruh!\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "whenever i see leaving, it reminds me of her :("
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "slow claps :)"
                    },
                    {
                        "username": "santanusen",
                        "content": "Please share how did you make her leave :p"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "Logic level with realistic view on top "
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "riyal"
                    },
                    {
                        "username": "Vicjr",
                        "content": "real"
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "real"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\\uD83D\\uDE06 "
                    },
                    {
                        "username": "maysrv",
                        "content": "You might be tempted to use i, j and k to keep track of s1, s2 and s3 respectively in your recursive calls but it gave me TLE. (Please note that it is not wrong)\\nThe trick here was to remove k from your changing state and reduce dp from 3D to 2D.\\nYou may reason about it by manipulating what you think of i and j at each point and it may work for you but I would like to point out how I reason it. \\nThe thing here is, at every step k is nothing but i+j, so we dont need to keep track of k because we can get it from i and j."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@chenon](/chenon) The problem here is you\\'re greedily checking if s3 can be created from s1 if not then you\\'re checking for s2.\\n\\nIf somehow the test-case you\\'re mentioning currently is cleared then you\\'ll stuck later on."
                    },
                    {
                        "username": "chenon",
                        "content": "I was exactly keeping track of the indexes on s1 and s2  . See my submission https://leetcode.com/problems/interleaving-string/submissions/1031746304/ . NO TLE but wrong answer."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I used 4D and beat 9%..."
                    },
                    {
                        "username": "parmani",
                        "content": "but 3d also works, since the constraints are low"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "at first i also did the 3d dp, then i figured it out that we dont need k..:p"
                    },
                    {
                        "username": "sanket54",
                        "content": "What is meaning of |n-m| <= 1 and why it is being ignored in all solutions ?"
                    },
                    {
                        "username": "sanjeeb42",
                        "content": "[@mahesh105](/mahesh105) Thanks for the explanation. I was exactly looking for this"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@mahesh105](/mahesh105)  thankss bro"
                    },
                    {
                        "username": "mahesh105",
                        "content": "All of the reasons in this threads were not explaining why?\\nLet me tell you.\\nsuppose you take n substrings of S1 and place it like this\\n__  __  __  __  __  __  __  __  __  __  __  __\\nthen you can fill the S2 substrings in the gaps or the boundary...in either case the inequality holds.\\nSo yeah if the string is interleaving, this inequality is automatically held due to this observation.\\nHappy Debugging : )"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The fact is that |n - m| <= 1 (where m and n are the no. of substring used for interleaving the string) is just the condition which supports that strings must be interleaved.\\nIf there are interleaved correctly then this condition will be automatically true.\\nThat\\'s why every piece of information not need to be included in code some time based on few logic we have to neglect few of them."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@unters](/unters) |n-m| <= 1 means you cannot divide the strings into arbitrarily sized pieces. If string 1 is divided into 4 parts, then string 5 can only be divided into 3, 4 or 5 parts. "
                    },
                    {
                        "username": "unters",
                        "content": "[@WajeehHasan](/WajeehHasan), in my opinion you\\'re not quite right. `m` and `n` are not numbers of characters in each string - that are numbers of nonoverlapping substrings in each string (each substring can contain more than one character). `|m - n| <= 1\\' means there can not be two adjacent substrings in p3 that belong to one string."
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Exactly what I am looking for."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "simply means difference of the length of string s and t is less than or equal to 1"
                    },
                    {
                        "username": "eddy66",
                        "content": "I think `|n-m|<=1` just means the substrings of `s` are interleaved with the substrings of `t`. So they could be `s1, t1, s2`, or `s1, t1, s2, t2`. But since each substring can be anything, so it\\'s not important when we solve the problem"
                    },
                    {
                        "username": "mvo13",
                        "content": "|n-m| <= 1 \\n=> The time complexity is O(n^2)"
                    },
                    {
                        "username": "shiva_San",
                        "content": "be ready for this testcase if you are using two pointer method without dp..\n\ns1 =\n\"aabc\"\ns2 =\n\"abad\"\ns3 =\n\"aabadabc\"\n\noutput=true\n"
                    },
                    {
                        "username": "oisinfarrell00",
                        "content": "In the brief of Intervealving strings it states that:\\n - The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...\\nHowever then they give this example:\\n![image](https://assets.leetcode.com/users/images/28de80e4-3308-48c9-9f45-46d243f7a928_1622621577.219354.png)\\nI dont really understand how this example works. It takes two letters from the first string and then 4 from the next and then back to two and so on. I thought it had to be like s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ... Am I missing something here?"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "s1 and so on may not necessarily be single characters. That is the trick here."
                    },
                    {
                        "username": "Kaltu",
                        "content": "`s1 = \\'aa\\', s2 = \\'bc\\', s3 = \\'c\\'` and `t1 = \\'dbbc\\', t2 = \\'a\\'` so the answer is `s1 + t1 + s2 + t2 + s3`"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Here s or t don\\'t represent the charecters but a substring, which means in above example s1 is \"aa\" and t1 is \"dbbc\" and similarily s2 is \"bc\"..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a string problem. But it needs some method to solve. A 2D DP is possible, since s3 depends on both s1 & s2. "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@meow_power](/meow_power) because we don\\'t need it, i and j together can always determine k uniquely (i+j = k; always holds if ur not doing anything sus)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@meow_power](/meow_power) Your solution is fine. 2D array is used."
                    },
                    {
                        "username": "meow_power",
                        "content": "my solution uses k as third parameter but in memoization why is it not used.Please help"
                    },
                    {
                        "username": "mayliao",
                        "content": "It is so strange use static variable get the answer is different from my computer. After I changed it as parameter, it worked well."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "relevant article \\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-"
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "cuz static variable will be kept and be operated by the function u implemented for each different test cases, without resetting its original value. while local parameter will be wiped after function is done for one test case, and created and set for the next test case."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/interleaving-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Recursion with memoization\n\n  \n**Approach 3:** Using 2D Dynamic Programming\n\n  \n**Approach 4:** Using 1D Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 2029056,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "So you need to ask yourself ..why is dp used here?\\n In first look this questions looks pretty simple and can be done using 2 pointers. \\n \\n Then you implement the 2 pointer approach and upon submission your code get a wrong ans on the below testcase.\\n \\n This test case then tells you why this que is asking for a dp solution.\\n \\n s1 = \"aabc\"\\n s2 = \"abad\"\\n s3= \"aabadabc\"\\n \\n Now in this, if you start moving from the back using the 2 pointer approach, it keeps on eleminating the character from the 1st string i.e s1. But when s1 gets exhausted, your s3 does not match with s2. \\n Here you take a note that, when char at s1 and s2 are equal, we need to check if deleting the char from s1 is a correct move or deleting the char from s2 would be a correct move.\\n \\n That clearly means, we have 2 choices here, either to delete the char from s1 or s2.\\n \\n Now for a bigger testcase like this it is clearly evidant that the que is asking for a Dyanmic Programming solution!!\\n \\n s1 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s2 = \"aaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s3 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\\t\\t aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n"
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "great intution \\uD83D\\uDD25\\uD83D\\uDD25\\uD83C\\uDF89"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "I CAN\\'T BELIEVE I SOLVED THIS ONE BY MY SELF :OOOOOOOOOO"
                    },
                    {
                        "username": "SeineAle",
                        "content": "ME TOO !\nFeels Good :)"
                    },
                    {
                        "username": "killerraj369",
                        "content": "After watching this comment I solved it by myself at first attempt itself."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good... doesn\\'t it?"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "same bro... feeling proud in my small achievement lol !"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "I am ashamed of my self. "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "same bruh!\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "whenever i see leaving, it reminds me of her :("
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "slow claps :)"
                    },
                    {
                        "username": "santanusen",
                        "content": "Please share how did you make her leave :p"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "Logic level with realistic view on top "
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "riyal"
                    },
                    {
                        "username": "Vicjr",
                        "content": "real"
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "real"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\\uD83D\\uDE06 "
                    },
                    {
                        "username": "maysrv",
                        "content": "You might be tempted to use i, j and k to keep track of s1, s2 and s3 respectively in your recursive calls but it gave me TLE. (Please note that it is not wrong)\\nThe trick here was to remove k from your changing state and reduce dp from 3D to 2D.\\nYou may reason about it by manipulating what you think of i and j at each point and it may work for you but I would like to point out how I reason it. \\nThe thing here is, at every step k is nothing but i+j, so we dont need to keep track of k because we can get it from i and j."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@chenon](/chenon) The problem here is you\\'re greedily checking if s3 can be created from s1 if not then you\\'re checking for s2.\\n\\nIf somehow the test-case you\\'re mentioning currently is cleared then you\\'ll stuck later on."
                    },
                    {
                        "username": "chenon",
                        "content": "I was exactly keeping track of the indexes on s1 and s2  . See my submission https://leetcode.com/problems/interleaving-string/submissions/1031746304/ . NO TLE but wrong answer."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I used 4D and beat 9%..."
                    },
                    {
                        "username": "parmani",
                        "content": "but 3d also works, since the constraints are low"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "at first i also did the 3d dp, then i figured it out that we dont need k..:p"
                    },
                    {
                        "username": "sanket54",
                        "content": "What is meaning of |n-m| <= 1 and why it is being ignored in all solutions ?"
                    },
                    {
                        "username": "sanjeeb42",
                        "content": "[@mahesh105](/mahesh105) Thanks for the explanation. I was exactly looking for this"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@mahesh105](/mahesh105)  thankss bro"
                    },
                    {
                        "username": "mahesh105",
                        "content": "All of the reasons in this threads were not explaining why?\\nLet me tell you.\\nsuppose you take n substrings of S1 and place it like this\\n__  __  __  __  __  __  __  __  __  __  __  __\\nthen you can fill the S2 substrings in the gaps or the boundary...in either case the inequality holds.\\nSo yeah if the string is interleaving, this inequality is automatically held due to this observation.\\nHappy Debugging : )"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The fact is that |n - m| <= 1 (where m and n are the no. of substring used for interleaving the string) is just the condition which supports that strings must be interleaved.\\nIf there are interleaved correctly then this condition will be automatically true.\\nThat\\'s why every piece of information not need to be included in code some time based on few logic we have to neglect few of them."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@unters](/unters) |n-m| <= 1 means you cannot divide the strings into arbitrarily sized pieces. If string 1 is divided into 4 parts, then string 5 can only be divided into 3, 4 or 5 parts. "
                    },
                    {
                        "username": "unters",
                        "content": "[@WajeehHasan](/WajeehHasan), in my opinion you\\'re not quite right. `m` and `n` are not numbers of characters in each string - that are numbers of nonoverlapping substrings in each string (each substring can contain more than one character). `|m - n| <= 1\\' means there can not be two adjacent substrings in p3 that belong to one string."
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Exactly what I am looking for."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "simply means difference of the length of string s and t is less than or equal to 1"
                    },
                    {
                        "username": "eddy66",
                        "content": "I think `|n-m|<=1` just means the substrings of `s` are interleaved with the substrings of `t`. So they could be `s1, t1, s2`, or `s1, t1, s2, t2`. But since each substring can be anything, so it\\'s not important when we solve the problem"
                    },
                    {
                        "username": "mvo13",
                        "content": "|n-m| <= 1 \\n=> The time complexity is O(n^2)"
                    },
                    {
                        "username": "shiva_San",
                        "content": "be ready for this testcase if you are using two pointer method without dp..\n\ns1 =\n\"aabc\"\ns2 =\n\"abad\"\ns3 =\n\"aabadabc\"\n\noutput=true\n"
                    },
                    {
                        "username": "oisinfarrell00",
                        "content": "In the brief of Intervealving strings it states that:\\n - The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...\\nHowever then they give this example:\\n![image](https://assets.leetcode.com/users/images/28de80e4-3308-48c9-9f45-46d243f7a928_1622621577.219354.png)\\nI dont really understand how this example works. It takes two letters from the first string and then 4 from the next and then back to two and so on. I thought it had to be like s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ... Am I missing something here?"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "s1 and so on may not necessarily be single characters. That is the trick here."
                    },
                    {
                        "username": "Kaltu",
                        "content": "`s1 = \\'aa\\', s2 = \\'bc\\', s3 = \\'c\\'` and `t1 = \\'dbbc\\', t2 = \\'a\\'` so the answer is `s1 + t1 + s2 + t2 + s3`"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Here s or t don\\'t represent the charecters but a substring, which means in above example s1 is \"aa\" and t1 is \"dbbc\" and similarily s2 is \"bc\"..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a string problem. But it needs some method to solve. A 2D DP is possible, since s3 depends on both s1 & s2. "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@meow_power](/meow_power) because we don\\'t need it, i and j together can always determine k uniquely (i+j = k; always holds if ur not doing anything sus)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@meow_power](/meow_power) Your solution is fine. 2D array is used."
                    },
                    {
                        "username": "meow_power",
                        "content": "my solution uses k as third parameter but in memoization why is it not used.Please help"
                    },
                    {
                        "username": "mayliao",
                        "content": "It is so strange use static variable get the answer is different from my computer. After I changed it as parameter, it worked well."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "relevant article \\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-"
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "cuz static variable will be kept and be operated by the function u implemented for each different test cases, without resetting its original value. while local parameter will be wiped after function is done for one test case, and created and set for the next test case."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/interleaving-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Recursion with memoization\n\n  \n**Approach 3:** Using 2D Dynamic Programming\n\n  \n**Approach 4:** Using 1D Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1576855,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "So you need to ask yourself ..why is dp used here?\\n In first look this questions looks pretty simple and can be done using 2 pointers. \\n \\n Then you implement the 2 pointer approach and upon submission your code get a wrong ans on the below testcase.\\n \\n This test case then tells you why this que is asking for a dp solution.\\n \\n s1 = \"aabc\"\\n s2 = \"abad\"\\n s3= \"aabadabc\"\\n \\n Now in this, if you start moving from the back using the 2 pointer approach, it keeps on eleminating the character from the 1st string i.e s1. But when s1 gets exhausted, your s3 does not match with s2. \\n Here you take a note that, when char at s1 and s2 are equal, we need to check if deleting the char from s1 is a correct move or deleting the char from s2 would be a correct move.\\n \\n That clearly means, we have 2 choices here, either to delete the char from s1 or s2.\\n \\n Now for a bigger testcase like this it is clearly evidant that the que is asking for a Dyanmic Programming solution!!\\n \\n s1 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s2 = \"aaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s3 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\\t\\t aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n"
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "great intution \\uD83D\\uDD25\\uD83D\\uDD25\\uD83C\\uDF89"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "I CAN\\'T BELIEVE I SOLVED THIS ONE BY MY SELF :OOOOOOOOOO"
                    },
                    {
                        "username": "SeineAle",
                        "content": "ME TOO !\nFeels Good :)"
                    },
                    {
                        "username": "killerraj369",
                        "content": "After watching this comment I solved it by myself at first attempt itself."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good... doesn\\'t it?"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "same bro... feeling proud in my small achievement lol !"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "I am ashamed of my self. "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "same bruh!\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "whenever i see leaving, it reminds me of her :("
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "slow claps :)"
                    },
                    {
                        "username": "santanusen",
                        "content": "Please share how did you make her leave :p"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "Logic level with realistic view on top "
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "riyal"
                    },
                    {
                        "username": "Vicjr",
                        "content": "real"
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "real"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\\uD83D\\uDE06 "
                    },
                    {
                        "username": "maysrv",
                        "content": "You might be tempted to use i, j and k to keep track of s1, s2 and s3 respectively in your recursive calls but it gave me TLE. (Please note that it is not wrong)\\nThe trick here was to remove k from your changing state and reduce dp from 3D to 2D.\\nYou may reason about it by manipulating what you think of i and j at each point and it may work for you but I would like to point out how I reason it. \\nThe thing here is, at every step k is nothing but i+j, so we dont need to keep track of k because we can get it from i and j."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@chenon](/chenon) The problem here is you\\'re greedily checking if s3 can be created from s1 if not then you\\'re checking for s2.\\n\\nIf somehow the test-case you\\'re mentioning currently is cleared then you\\'ll stuck later on."
                    },
                    {
                        "username": "chenon",
                        "content": "I was exactly keeping track of the indexes on s1 and s2  . See my submission https://leetcode.com/problems/interleaving-string/submissions/1031746304/ . NO TLE but wrong answer."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I used 4D and beat 9%..."
                    },
                    {
                        "username": "parmani",
                        "content": "but 3d also works, since the constraints are low"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "at first i also did the 3d dp, then i figured it out that we dont need k..:p"
                    },
                    {
                        "username": "sanket54",
                        "content": "What is meaning of |n-m| <= 1 and why it is being ignored in all solutions ?"
                    },
                    {
                        "username": "sanjeeb42",
                        "content": "[@mahesh105](/mahesh105) Thanks for the explanation. I was exactly looking for this"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@mahesh105](/mahesh105)  thankss bro"
                    },
                    {
                        "username": "mahesh105",
                        "content": "All of the reasons in this threads were not explaining why?\\nLet me tell you.\\nsuppose you take n substrings of S1 and place it like this\\n__  __  __  __  __  __  __  __  __  __  __  __\\nthen you can fill the S2 substrings in the gaps or the boundary...in either case the inequality holds.\\nSo yeah if the string is interleaving, this inequality is automatically held due to this observation.\\nHappy Debugging : )"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The fact is that |n - m| <= 1 (where m and n are the no. of substring used for interleaving the string) is just the condition which supports that strings must be interleaved.\\nIf there are interleaved correctly then this condition will be automatically true.\\nThat\\'s why every piece of information not need to be included in code some time based on few logic we have to neglect few of them."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@unters](/unters) |n-m| <= 1 means you cannot divide the strings into arbitrarily sized pieces. If string 1 is divided into 4 parts, then string 5 can only be divided into 3, 4 or 5 parts. "
                    },
                    {
                        "username": "unters",
                        "content": "[@WajeehHasan](/WajeehHasan), in my opinion you\\'re not quite right. `m` and `n` are not numbers of characters in each string - that are numbers of nonoverlapping substrings in each string (each substring can contain more than one character). `|m - n| <= 1\\' means there can not be two adjacent substrings in p3 that belong to one string."
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Exactly what I am looking for."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "simply means difference of the length of string s and t is less than or equal to 1"
                    },
                    {
                        "username": "eddy66",
                        "content": "I think `|n-m|<=1` just means the substrings of `s` are interleaved with the substrings of `t`. So they could be `s1, t1, s2`, or `s1, t1, s2, t2`. But since each substring can be anything, so it\\'s not important when we solve the problem"
                    },
                    {
                        "username": "mvo13",
                        "content": "|n-m| <= 1 \\n=> The time complexity is O(n^2)"
                    },
                    {
                        "username": "shiva_San",
                        "content": "be ready for this testcase if you are using two pointer method without dp..\n\ns1 =\n\"aabc\"\ns2 =\n\"abad\"\ns3 =\n\"aabadabc\"\n\noutput=true\n"
                    },
                    {
                        "username": "oisinfarrell00",
                        "content": "In the brief of Intervealving strings it states that:\\n - The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...\\nHowever then they give this example:\\n![image](https://assets.leetcode.com/users/images/28de80e4-3308-48c9-9f45-46d243f7a928_1622621577.219354.png)\\nI dont really understand how this example works. It takes two letters from the first string and then 4 from the next and then back to two and so on. I thought it had to be like s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ... Am I missing something here?"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "s1 and so on may not necessarily be single characters. That is the trick here."
                    },
                    {
                        "username": "Kaltu",
                        "content": "`s1 = \\'aa\\', s2 = \\'bc\\', s3 = \\'c\\'` and `t1 = \\'dbbc\\', t2 = \\'a\\'` so the answer is `s1 + t1 + s2 + t2 + s3`"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Here s or t don\\'t represent the charecters but a substring, which means in above example s1 is \"aa\" and t1 is \"dbbc\" and similarily s2 is \"bc\"..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a string problem. But it needs some method to solve. A 2D DP is possible, since s3 depends on both s1 & s2. "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@meow_power](/meow_power) because we don\\'t need it, i and j together can always determine k uniquely (i+j = k; always holds if ur not doing anything sus)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@meow_power](/meow_power) Your solution is fine. 2D array is used."
                    },
                    {
                        "username": "meow_power",
                        "content": "my solution uses k as third parameter but in memoization why is it not used.Please help"
                    },
                    {
                        "username": "mayliao",
                        "content": "It is so strange use static variable get the answer is different from my computer. After I changed it as parameter, it worked well."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "relevant article \\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-"
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "cuz static variable will be kept and be operated by the function u implemented for each different test cases, without resetting its original value. while local parameter will be wiped after function is done for one test case, and created and set for the next test case."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/interleaving-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Recursion with memoization\n\n  \n**Approach 3:** Using 2D Dynamic Programming\n\n  \n**Approach 4:** Using 1D Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1568627,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "So you need to ask yourself ..why is dp used here?\\n In first look this questions looks pretty simple and can be done using 2 pointers. \\n \\n Then you implement the 2 pointer approach and upon submission your code get a wrong ans on the below testcase.\\n \\n This test case then tells you why this que is asking for a dp solution.\\n \\n s1 = \"aabc\"\\n s2 = \"abad\"\\n s3= \"aabadabc\"\\n \\n Now in this, if you start moving from the back using the 2 pointer approach, it keeps on eleminating the character from the 1st string i.e s1. But when s1 gets exhausted, your s3 does not match with s2. \\n Here you take a note that, when char at s1 and s2 are equal, we need to check if deleting the char from s1 is a correct move or deleting the char from s2 would be a correct move.\\n \\n That clearly means, we have 2 choices here, either to delete the char from s1 or s2.\\n \\n Now for a bigger testcase like this it is clearly evidant that the que is asking for a Dyanmic Programming solution!!\\n \\n s1 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s2 = \"aaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s3 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\\t\\t aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n"
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "great intution \\uD83D\\uDD25\\uD83D\\uDD25\\uD83C\\uDF89"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "I CAN\\'T BELIEVE I SOLVED THIS ONE BY MY SELF :OOOOOOOOOO"
                    },
                    {
                        "username": "SeineAle",
                        "content": "ME TOO !\nFeels Good :)"
                    },
                    {
                        "username": "killerraj369",
                        "content": "After watching this comment I solved it by myself at first attempt itself."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good... doesn\\'t it?"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "same bro... feeling proud in my small achievement lol !"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "I am ashamed of my self. "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "same bruh!\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "whenever i see leaving, it reminds me of her :("
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "slow claps :)"
                    },
                    {
                        "username": "santanusen",
                        "content": "Please share how did you make her leave :p"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "Logic level with realistic view on top "
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "riyal"
                    },
                    {
                        "username": "Vicjr",
                        "content": "real"
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "real"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\\uD83D\\uDE06 "
                    },
                    {
                        "username": "maysrv",
                        "content": "You might be tempted to use i, j and k to keep track of s1, s2 and s3 respectively in your recursive calls but it gave me TLE. (Please note that it is not wrong)\\nThe trick here was to remove k from your changing state and reduce dp from 3D to 2D.\\nYou may reason about it by manipulating what you think of i and j at each point and it may work for you but I would like to point out how I reason it. \\nThe thing here is, at every step k is nothing but i+j, so we dont need to keep track of k because we can get it from i and j."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@chenon](/chenon) The problem here is you\\'re greedily checking if s3 can be created from s1 if not then you\\'re checking for s2.\\n\\nIf somehow the test-case you\\'re mentioning currently is cleared then you\\'ll stuck later on."
                    },
                    {
                        "username": "chenon",
                        "content": "I was exactly keeping track of the indexes on s1 and s2  . See my submission https://leetcode.com/problems/interleaving-string/submissions/1031746304/ . NO TLE but wrong answer."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I used 4D and beat 9%..."
                    },
                    {
                        "username": "parmani",
                        "content": "but 3d also works, since the constraints are low"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "at first i also did the 3d dp, then i figured it out that we dont need k..:p"
                    },
                    {
                        "username": "sanket54",
                        "content": "What is meaning of |n-m| <= 1 and why it is being ignored in all solutions ?"
                    },
                    {
                        "username": "sanjeeb42",
                        "content": "[@mahesh105](/mahesh105) Thanks for the explanation. I was exactly looking for this"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@mahesh105](/mahesh105)  thankss bro"
                    },
                    {
                        "username": "mahesh105",
                        "content": "All of the reasons in this threads were not explaining why?\\nLet me tell you.\\nsuppose you take n substrings of S1 and place it like this\\n__  __  __  __  __  __  __  __  __  __  __  __\\nthen you can fill the S2 substrings in the gaps or the boundary...in either case the inequality holds.\\nSo yeah if the string is interleaving, this inequality is automatically held due to this observation.\\nHappy Debugging : )"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The fact is that |n - m| <= 1 (where m and n are the no. of substring used for interleaving the string) is just the condition which supports that strings must be interleaved.\\nIf there are interleaved correctly then this condition will be automatically true.\\nThat\\'s why every piece of information not need to be included in code some time based on few logic we have to neglect few of them."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@unters](/unters) |n-m| <= 1 means you cannot divide the strings into arbitrarily sized pieces. If string 1 is divided into 4 parts, then string 5 can only be divided into 3, 4 or 5 parts. "
                    },
                    {
                        "username": "unters",
                        "content": "[@WajeehHasan](/WajeehHasan), in my opinion you\\'re not quite right. `m` and `n` are not numbers of characters in each string - that are numbers of nonoverlapping substrings in each string (each substring can contain more than one character). `|m - n| <= 1\\' means there can not be two adjacent substrings in p3 that belong to one string."
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Exactly what I am looking for."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "simply means difference of the length of string s and t is less than or equal to 1"
                    },
                    {
                        "username": "eddy66",
                        "content": "I think `|n-m|<=1` just means the substrings of `s` are interleaved with the substrings of `t`. So they could be `s1, t1, s2`, or `s1, t1, s2, t2`. But since each substring can be anything, so it\\'s not important when we solve the problem"
                    },
                    {
                        "username": "mvo13",
                        "content": "|n-m| <= 1 \\n=> The time complexity is O(n^2)"
                    },
                    {
                        "username": "shiva_San",
                        "content": "be ready for this testcase if you are using two pointer method without dp..\n\ns1 =\n\"aabc\"\ns2 =\n\"abad\"\ns3 =\n\"aabadabc\"\n\noutput=true\n"
                    },
                    {
                        "username": "oisinfarrell00",
                        "content": "In the brief of Intervealving strings it states that:\\n - The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...\\nHowever then they give this example:\\n![image](https://assets.leetcode.com/users/images/28de80e4-3308-48c9-9f45-46d243f7a928_1622621577.219354.png)\\nI dont really understand how this example works. It takes two letters from the first string and then 4 from the next and then back to two and so on. I thought it had to be like s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ... Am I missing something here?"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "s1 and so on may not necessarily be single characters. That is the trick here."
                    },
                    {
                        "username": "Kaltu",
                        "content": "`s1 = \\'aa\\', s2 = \\'bc\\', s3 = \\'c\\'` and `t1 = \\'dbbc\\', t2 = \\'a\\'` so the answer is `s1 + t1 + s2 + t2 + s3`"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Here s or t don\\'t represent the charecters but a substring, which means in above example s1 is \"aa\" and t1 is \"dbbc\" and similarily s2 is \"bc\"..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a string problem. But it needs some method to solve. A 2D DP is possible, since s3 depends on both s1 & s2. "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@meow_power](/meow_power) because we don\\'t need it, i and j together can always determine k uniquely (i+j = k; always holds if ur not doing anything sus)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@meow_power](/meow_power) Your solution is fine. 2D array is used."
                    },
                    {
                        "username": "meow_power",
                        "content": "my solution uses k as third parameter but in memoization why is it not used.Please help"
                    },
                    {
                        "username": "mayliao",
                        "content": "It is so strange use static variable get the answer is different from my computer. After I changed it as parameter, it worked well."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "relevant article \\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-"
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "cuz static variable will be kept and be operated by the function u implemented for each different test cases, without resetting its original value. while local parameter will be wiped after function is done for one test case, and created and set for the next test case."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/interleaving-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Recursion with memoization\n\n  \n**Approach 3:** Using 2D Dynamic Programming\n\n  \n**Approach 4:** Using 1D Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 2029275,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "So you need to ask yourself ..why is dp used here?\\n In first look this questions looks pretty simple and can be done using 2 pointers. \\n \\n Then you implement the 2 pointer approach and upon submission your code get a wrong ans on the below testcase.\\n \\n This test case then tells you why this que is asking for a dp solution.\\n \\n s1 = \"aabc\"\\n s2 = \"abad\"\\n s3= \"aabadabc\"\\n \\n Now in this, if you start moving from the back using the 2 pointer approach, it keeps on eleminating the character from the 1st string i.e s1. But when s1 gets exhausted, your s3 does not match with s2. \\n Here you take a note that, when char at s1 and s2 are equal, we need to check if deleting the char from s1 is a correct move or deleting the char from s2 would be a correct move.\\n \\n That clearly means, we have 2 choices here, either to delete the char from s1 or s2.\\n \\n Now for a bigger testcase like this it is clearly evidant that the que is asking for a Dyanmic Programming solution!!\\n \\n s1 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s2 = \"aaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s3 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\\t\\t aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n"
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "great intution \\uD83D\\uDD25\\uD83D\\uDD25\\uD83C\\uDF89"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "I CAN\\'T BELIEVE I SOLVED THIS ONE BY MY SELF :OOOOOOOOOO"
                    },
                    {
                        "username": "SeineAle",
                        "content": "ME TOO !\nFeels Good :)"
                    },
                    {
                        "username": "killerraj369",
                        "content": "After watching this comment I solved it by myself at first attempt itself."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good... doesn\\'t it?"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "same bro... feeling proud in my small achievement lol !"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "I am ashamed of my self. "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "same bruh!\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "whenever i see leaving, it reminds me of her :("
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "slow claps :)"
                    },
                    {
                        "username": "santanusen",
                        "content": "Please share how did you make her leave :p"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "Logic level with realistic view on top "
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "riyal"
                    },
                    {
                        "username": "Vicjr",
                        "content": "real"
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "real"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\\uD83D\\uDE06 "
                    },
                    {
                        "username": "maysrv",
                        "content": "You might be tempted to use i, j and k to keep track of s1, s2 and s3 respectively in your recursive calls but it gave me TLE. (Please note that it is not wrong)\\nThe trick here was to remove k from your changing state and reduce dp from 3D to 2D.\\nYou may reason about it by manipulating what you think of i and j at each point and it may work for you but I would like to point out how I reason it. \\nThe thing here is, at every step k is nothing but i+j, so we dont need to keep track of k because we can get it from i and j."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@chenon](/chenon) The problem here is you\\'re greedily checking if s3 can be created from s1 if not then you\\'re checking for s2.\\n\\nIf somehow the test-case you\\'re mentioning currently is cleared then you\\'ll stuck later on."
                    },
                    {
                        "username": "chenon",
                        "content": "I was exactly keeping track of the indexes on s1 and s2  . See my submission https://leetcode.com/problems/interleaving-string/submissions/1031746304/ . NO TLE but wrong answer."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I used 4D and beat 9%..."
                    },
                    {
                        "username": "parmani",
                        "content": "but 3d also works, since the constraints are low"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "at first i also did the 3d dp, then i figured it out that we dont need k..:p"
                    },
                    {
                        "username": "sanket54",
                        "content": "What is meaning of |n-m| <= 1 and why it is being ignored in all solutions ?"
                    },
                    {
                        "username": "sanjeeb42",
                        "content": "[@mahesh105](/mahesh105) Thanks for the explanation. I was exactly looking for this"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@mahesh105](/mahesh105)  thankss bro"
                    },
                    {
                        "username": "mahesh105",
                        "content": "All of the reasons in this threads were not explaining why?\\nLet me tell you.\\nsuppose you take n substrings of S1 and place it like this\\n__  __  __  __  __  __  __  __  __  __  __  __\\nthen you can fill the S2 substrings in the gaps or the boundary...in either case the inequality holds.\\nSo yeah if the string is interleaving, this inequality is automatically held due to this observation.\\nHappy Debugging : )"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The fact is that |n - m| <= 1 (where m and n are the no. of substring used for interleaving the string) is just the condition which supports that strings must be interleaved.\\nIf there are interleaved correctly then this condition will be automatically true.\\nThat\\'s why every piece of information not need to be included in code some time based on few logic we have to neglect few of them."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@unters](/unters) |n-m| <= 1 means you cannot divide the strings into arbitrarily sized pieces. If string 1 is divided into 4 parts, then string 5 can only be divided into 3, 4 or 5 parts. "
                    },
                    {
                        "username": "unters",
                        "content": "[@WajeehHasan](/WajeehHasan), in my opinion you\\'re not quite right. `m` and `n` are not numbers of characters in each string - that are numbers of nonoverlapping substrings in each string (each substring can contain more than one character). `|m - n| <= 1\\' means there can not be two adjacent substrings in p3 that belong to one string."
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Exactly what I am looking for."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "simply means difference of the length of string s and t is less than or equal to 1"
                    },
                    {
                        "username": "eddy66",
                        "content": "I think `|n-m|<=1` just means the substrings of `s` are interleaved with the substrings of `t`. So they could be `s1, t1, s2`, or `s1, t1, s2, t2`. But since each substring can be anything, so it\\'s not important when we solve the problem"
                    },
                    {
                        "username": "mvo13",
                        "content": "|n-m| <= 1 \\n=> The time complexity is O(n^2)"
                    },
                    {
                        "username": "shiva_San",
                        "content": "be ready for this testcase if you are using two pointer method without dp..\n\ns1 =\n\"aabc\"\ns2 =\n\"abad\"\ns3 =\n\"aabadabc\"\n\noutput=true\n"
                    },
                    {
                        "username": "oisinfarrell00",
                        "content": "In the brief of Intervealving strings it states that:\\n - The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...\\nHowever then they give this example:\\n![image](https://assets.leetcode.com/users/images/28de80e4-3308-48c9-9f45-46d243f7a928_1622621577.219354.png)\\nI dont really understand how this example works. It takes two letters from the first string and then 4 from the next and then back to two and so on. I thought it had to be like s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ... Am I missing something here?"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "s1 and so on may not necessarily be single characters. That is the trick here."
                    },
                    {
                        "username": "Kaltu",
                        "content": "`s1 = \\'aa\\', s2 = \\'bc\\', s3 = \\'c\\'` and `t1 = \\'dbbc\\', t2 = \\'a\\'` so the answer is `s1 + t1 + s2 + t2 + s3`"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Here s or t don\\'t represent the charecters but a substring, which means in above example s1 is \"aa\" and t1 is \"dbbc\" and similarily s2 is \"bc\"..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a string problem. But it needs some method to solve. A 2D DP is possible, since s3 depends on both s1 & s2. "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@meow_power](/meow_power) because we don\\'t need it, i and j together can always determine k uniquely (i+j = k; always holds if ur not doing anything sus)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@meow_power](/meow_power) Your solution is fine. 2D array is used."
                    },
                    {
                        "username": "meow_power",
                        "content": "my solution uses k as third parameter but in memoization why is it not used.Please help"
                    },
                    {
                        "username": "mayliao",
                        "content": "It is so strange use static variable get the answer is different from my computer. After I changed it as parameter, it worked well."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "relevant article \\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-"
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "cuz static variable will be kept and be operated by the function u implemented for each different test cases, without resetting its original value. while local parameter will be wiped after function is done for one test case, and created and set for the next test case."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/interleaving-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Recursion with memoization\n\n  \n**Approach 3:** Using 2D Dynamic Programming\n\n  \n**Approach 4:** Using 1D Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1568580,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "So you need to ask yourself ..why is dp used here?\\n In first look this questions looks pretty simple and can be done using 2 pointers. \\n \\n Then you implement the 2 pointer approach and upon submission your code get a wrong ans on the below testcase.\\n \\n This test case then tells you why this que is asking for a dp solution.\\n \\n s1 = \"aabc\"\\n s2 = \"abad\"\\n s3= \"aabadabc\"\\n \\n Now in this, if you start moving from the back using the 2 pointer approach, it keeps on eleminating the character from the 1st string i.e s1. But when s1 gets exhausted, your s3 does not match with s2. \\n Here you take a note that, when char at s1 and s2 are equal, we need to check if deleting the char from s1 is a correct move or deleting the char from s2 would be a correct move.\\n \\n That clearly means, we have 2 choices here, either to delete the char from s1 or s2.\\n \\n Now for a bigger testcase like this it is clearly evidant that the que is asking for a Dyanmic Programming solution!!\\n \\n s1 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s2 = \"aaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s3 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\\t\\t aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n"
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "great intution \\uD83D\\uDD25\\uD83D\\uDD25\\uD83C\\uDF89"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "I CAN\\'T BELIEVE I SOLVED THIS ONE BY MY SELF :OOOOOOOOOO"
                    },
                    {
                        "username": "SeineAle",
                        "content": "ME TOO !\nFeels Good :)"
                    },
                    {
                        "username": "killerraj369",
                        "content": "After watching this comment I solved it by myself at first attempt itself."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good... doesn\\'t it?"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "same bro... feeling proud in my small achievement lol !"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "I am ashamed of my self. "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "same bruh!\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "whenever i see leaving, it reminds me of her :("
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "slow claps :)"
                    },
                    {
                        "username": "santanusen",
                        "content": "Please share how did you make her leave :p"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "Logic level with realistic view on top "
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "riyal"
                    },
                    {
                        "username": "Vicjr",
                        "content": "real"
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "real"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\\uD83D\\uDE06 "
                    },
                    {
                        "username": "maysrv",
                        "content": "You might be tempted to use i, j and k to keep track of s1, s2 and s3 respectively in your recursive calls but it gave me TLE. (Please note that it is not wrong)\\nThe trick here was to remove k from your changing state and reduce dp from 3D to 2D.\\nYou may reason about it by manipulating what you think of i and j at each point and it may work for you but I would like to point out how I reason it. \\nThe thing here is, at every step k is nothing but i+j, so we dont need to keep track of k because we can get it from i and j."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@chenon](/chenon) The problem here is you\\'re greedily checking if s3 can be created from s1 if not then you\\'re checking for s2.\\n\\nIf somehow the test-case you\\'re mentioning currently is cleared then you\\'ll stuck later on."
                    },
                    {
                        "username": "chenon",
                        "content": "I was exactly keeping track of the indexes on s1 and s2  . See my submission https://leetcode.com/problems/interleaving-string/submissions/1031746304/ . NO TLE but wrong answer."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I used 4D and beat 9%..."
                    },
                    {
                        "username": "parmani",
                        "content": "but 3d also works, since the constraints are low"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "at first i also did the 3d dp, then i figured it out that we dont need k..:p"
                    },
                    {
                        "username": "sanket54",
                        "content": "What is meaning of |n-m| <= 1 and why it is being ignored in all solutions ?"
                    },
                    {
                        "username": "sanjeeb42",
                        "content": "[@mahesh105](/mahesh105) Thanks for the explanation. I was exactly looking for this"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@mahesh105](/mahesh105)  thankss bro"
                    },
                    {
                        "username": "mahesh105",
                        "content": "All of the reasons in this threads were not explaining why?\\nLet me tell you.\\nsuppose you take n substrings of S1 and place it like this\\n__  __  __  __  __  __  __  __  __  __  __  __\\nthen you can fill the S2 substrings in the gaps or the boundary...in either case the inequality holds.\\nSo yeah if the string is interleaving, this inequality is automatically held due to this observation.\\nHappy Debugging : )"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The fact is that |n - m| <= 1 (where m and n are the no. of substring used for interleaving the string) is just the condition which supports that strings must be interleaved.\\nIf there are interleaved correctly then this condition will be automatically true.\\nThat\\'s why every piece of information not need to be included in code some time based on few logic we have to neglect few of them."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@unters](/unters) |n-m| <= 1 means you cannot divide the strings into arbitrarily sized pieces. If string 1 is divided into 4 parts, then string 5 can only be divided into 3, 4 or 5 parts. "
                    },
                    {
                        "username": "unters",
                        "content": "[@WajeehHasan](/WajeehHasan), in my opinion you\\'re not quite right. `m` and `n` are not numbers of characters in each string - that are numbers of nonoverlapping substrings in each string (each substring can contain more than one character). `|m - n| <= 1\\' means there can not be two adjacent substrings in p3 that belong to one string."
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Exactly what I am looking for."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "simply means difference of the length of string s and t is less than or equal to 1"
                    },
                    {
                        "username": "eddy66",
                        "content": "I think `|n-m|<=1` just means the substrings of `s` are interleaved with the substrings of `t`. So they could be `s1, t1, s2`, or `s1, t1, s2, t2`. But since each substring can be anything, so it\\'s not important when we solve the problem"
                    },
                    {
                        "username": "mvo13",
                        "content": "|n-m| <= 1 \\n=> The time complexity is O(n^2)"
                    },
                    {
                        "username": "shiva_San",
                        "content": "be ready for this testcase if you are using two pointer method without dp..\n\ns1 =\n\"aabc\"\ns2 =\n\"abad\"\ns3 =\n\"aabadabc\"\n\noutput=true\n"
                    },
                    {
                        "username": "oisinfarrell00",
                        "content": "In the brief of Intervealving strings it states that:\\n - The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...\\nHowever then they give this example:\\n![image](https://assets.leetcode.com/users/images/28de80e4-3308-48c9-9f45-46d243f7a928_1622621577.219354.png)\\nI dont really understand how this example works. It takes two letters from the first string and then 4 from the next and then back to two and so on. I thought it had to be like s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ... Am I missing something here?"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "s1 and so on may not necessarily be single characters. That is the trick here."
                    },
                    {
                        "username": "Kaltu",
                        "content": "`s1 = \\'aa\\', s2 = \\'bc\\', s3 = \\'c\\'` and `t1 = \\'dbbc\\', t2 = \\'a\\'` so the answer is `s1 + t1 + s2 + t2 + s3`"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Here s or t don\\'t represent the charecters but a substring, which means in above example s1 is \"aa\" and t1 is \"dbbc\" and similarily s2 is \"bc\"..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a string problem. But it needs some method to solve. A 2D DP is possible, since s3 depends on both s1 & s2. "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@meow_power](/meow_power) because we don\\'t need it, i and j together can always determine k uniquely (i+j = k; always holds if ur not doing anything sus)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@meow_power](/meow_power) Your solution is fine. 2D array is used."
                    },
                    {
                        "username": "meow_power",
                        "content": "my solution uses k as third parameter but in memoization why is it not used.Please help"
                    },
                    {
                        "username": "mayliao",
                        "content": "It is so strange use static variable get the answer is different from my computer. After I changed it as parameter, it worked well."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "relevant article \\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-"
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "cuz static variable will be kept and be operated by the function u implemented for each different test cases, without resetting its original value. while local parameter will be wiped after function is done for one test case, and created and set for the next test case."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/interleaving-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Recursion with memoization\n\n  \n**Approach 3:** Using 2D Dynamic Programming\n\n  \n**Approach 4:** Using 1D Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 2029043,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "So you need to ask yourself ..why is dp used here?\\n In first look this questions looks pretty simple and can be done using 2 pointers. \\n \\n Then you implement the 2 pointer approach and upon submission your code get a wrong ans on the below testcase.\\n \\n This test case then tells you why this que is asking for a dp solution.\\n \\n s1 = \"aabc\"\\n s2 = \"abad\"\\n s3= \"aabadabc\"\\n \\n Now in this, if you start moving from the back using the 2 pointer approach, it keeps on eleminating the character from the 1st string i.e s1. But when s1 gets exhausted, your s3 does not match with s2. \\n Here you take a note that, when char at s1 and s2 are equal, we need to check if deleting the char from s1 is a correct move or deleting the char from s2 would be a correct move.\\n \\n That clearly means, we have 2 choices here, either to delete the char from s1 or s2.\\n \\n Now for a bigger testcase like this it is clearly evidant that the que is asking for a Dyanmic Programming solution!!\\n \\n s1 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s2 = \"aaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s3 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\\t\\t aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n"
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "great intution \\uD83D\\uDD25\\uD83D\\uDD25\\uD83C\\uDF89"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "I CAN\\'T BELIEVE I SOLVED THIS ONE BY MY SELF :OOOOOOOOOO"
                    },
                    {
                        "username": "SeineAle",
                        "content": "ME TOO !\nFeels Good :)"
                    },
                    {
                        "username": "killerraj369",
                        "content": "After watching this comment I solved it by myself at first attempt itself."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good... doesn\\'t it?"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "same bro... feeling proud in my small achievement lol !"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "I am ashamed of my self. "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "same bruh!\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "whenever i see leaving, it reminds me of her :("
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "slow claps :)"
                    },
                    {
                        "username": "santanusen",
                        "content": "Please share how did you make her leave :p"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "Logic level with realistic view on top "
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "riyal"
                    },
                    {
                        "username": "Vicjr",
                        "content": "real"
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "real"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\\uD83D\\uDE06 "
                    },
                    {
                        "username": "maysrv",
                        "content": "You might be tempted to use i, j and k to keep track of s1, s2 and s3 respectively in your recursive calls but it gave me TLE. (Please note that it is not wrong)\\nThe trick here was to remove k from your changing state and reduce dp from 3D to 2D.\\nYou may reason about it by manipulating what you think of i and j at each point and it may work for you but I would like to point out how I reason it. \\nThe thing here is, at every step k is nothing but i+j, so we dont need to keep track of k because we can get it from i and j."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@chenon](/chenon) The problem here is you\\'re greedily checking if s3 can be created from s1 if not then you\\'re checking for s2.\\n\\nIf somehow the test-case you\\'re mentioning currently is cleared then you\\'ll stuck later on."
                    },
                    {
                        "username": "chenon",
                        "content": "I was exactly keeping track of the indexes on s1 and s2  . See my submission https://leetcode.com/problems/interleaving-string/submissions/1031746304/ . NO TLE but wrong answer."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I used 4D and beat 9%..."
                    },
                    {
                        "username": "parmani",
                        "content": "but 3d also works, since the constraints are low"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "at first i also did the 3d dp, then i figured it out that we dont need k..:p"
                    },
                    {
                        "username": "sanket54",
                        "content": "What is meaning of |n-m| <= 1 and why it is being ignored in all solutions ?"
                    },
                    {
                        "username": "sanjeeb42",
                        "content": "[@mahesh105](/mahesh105) Thanks for the explanation. I was exactly looking for this"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@mahesh105](/mahesh105)  thankss bro"
                    },
                    {
                        "username": "mahesh105",
                        "content": "All of the reasons in this threads were not explaining why?\\nLet me tell you.\\nsuppose you take n substrings of S1 and place it like this\\n__  __  __  __  __  __  __  __  __  __  __  __\\nthen you can fill the S2 substrings in the gaps or the boundary...in either case the inequality holds.\\nSo yeah if the string is interleaving, this inequality is automatically held due to this observation.\\nHappy Debugging : )"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The fact is that |n - m| <= 1 (where m and n are the no. of substring used for interleaving the string) is just the condition which supports that strings must be interleaved.\\nIf there are interleaved correctly then this condition will be automatically true.\\nThat\\'s why every piece of information not need to be included in code some time based on few logic we have to neglect few of them."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@unters](/unters) |n-m| <= 1 means you cannot divide the strings into arbitrarily sized pieces. If string 1 is divided into 4 parts, then string 5 can only be divided into 3, 4 or 5 parts. "
                    },
                    {
                        "username": "unters",
                        "content": "[@WajeehHasan](/WajeehHasan), in my opinion you\\'re not quite right. `m` and `n` are not numbers of characters in each string - that are numbers of nonoverlapping substrings in each string (each substring can contain more than one character). `|m - n| <= 1\\' means there can not be two adjacent substrings in p3 that belong to one string."
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Exactly what I am looking for."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "simply means difference of the length of string s and t is less than or equal to 1"
                    },
                    {
                        "username": "eddy66",
                        "content": "I think `|n-m|<=1` just means the substrings of `s` are interleaved with the substrings of `t`. So they could be `s1, t1, s2`, or `s1, t1, s2, t2`. But since each substring can be anything, so it\\'s not important when we solve the problem"
                    },
                    {
                        "username": "mvo13",
                        "content": "|n-m| <= 1 \\n=> The time complexity is O(n^2)"
                    },
                    {
                        "username": "shiva_San",
                        "content": "be ready for this testcase if you are using two pointer method without dp..\n\ns1 =\n\"aabc\"\ns2 =\n\"abad\"\ns3 =\n\"aabadabc\"\n\noutput=true\n"
                    },
                    {
                        "username": "oisinfarrell00",
                        "content": "In the brief of Intervealving strings it states that:\\n - The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...\\nHowever then they give this example:\\n![image](https://assets.leetcode.com/users/images/28de80e4-3308-48c9-9f45-46d243f7a928_1622621577.219354.png)\\nI dont really understand how this example works. It takes two letters from the first string and then 4 from the next and then back to two and so on. I thought it had to be like s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ... Am I missing something here?"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "s1 and so on may not necessarily be single characters. That is the trick here."
                    },
                    {
                        "username": "Kaltu",
                        "content": "`s1 = \\'aa\\', s2 = \\'bc\\', s3 = \\'c\\'` and `t1 = \\'dbbc\\', t2 = \\'a\\'` so the answer is `s1 + t1 + s2 + t2 + s3`"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Here s or t don\\'t represent the charecters but a substring, which means in above example s1 is \"aa\" and t1 is \"dbbc\" and similarily s2 is \"bc\"..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a string problem. But it needs some method to solve. A 2D DP is possible, since s3 depends on both s1 & s2. "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@meow_power](/meow_power) because we don\\'t need it, i and j together can always determine k uniquely (i+j = k; always holds if ur not doing anything sus)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@meow_power](/meow_power) Your solution is fine. 2D array is used."
                    },
                    {
                        "username": "meow_power",
                        "content": "my solution uses k as third parameter but in memoization why is it not used.Please help"
                    },
                    {
                        "username": "mayliao",
                        "content": "It is so strange use static variable get the answer is different from my computer. After I changed it as parameter, it worked well."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "relevant article \\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-"
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "cuz static variable will be kept and be operated by the function u implemented for each different test cases, without resetting its original value. while local parameter will be wiped after function is done for one test case, and created and set for the next test case."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/interleaving-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Recursion with memoization\n\n  \n**Approach 3:** Using 2D Dynamic Programming\n\n  \n**Approach 4:** Using 1D Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1570461,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "So you need to ask yourself ..why is dp used here?\\n In first look this questions looks pretty simple and can be done using 2 pointers. \\n \\n Then you implement the 2 pointer approach and upon submission your code get a wrong ans on the below testcase.\\n \\n This test case then tells you why this que is asking for a dp solution.\\n \\n s1 = \"aabc\"\\n s2 = \"abad\"\\n s3= \"aabadabc\"\\n \\n Now in this, if you start moving from the back using the 2 pointer approach, it keeps on eleminating the character from the 1st string i.e s1. But when s1 gets exhausted, your s3 does not match with s2. \\n Here you take a note that, when char at s1 and s2 are equal, we need to check if deleting the char from s1 is a correct move or deleting the char from s2 would be a correct move.\\n \\n That clearly means, we have 2 choices here, either to delete the char from s1 or s2.\\n \\n Now for a bigger testcase like this it is clearly evidant that the que is asking for a Dyanmic Programming solution!!\\n \\n s1 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s2 = \"aaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s3 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\\t\\t aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n"
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "great intution \\uD83D\\uDD25\\uD83D\\uDD25\\uD83C\\uDF89"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "I CAN\\'T BELIEVE I SOLVED THIS ONE BY MY SELF :OOOOOOOOOO"
                    },
                    {
                        "username": "SeineAle",
                        "content": "ME TOO !\nFeels Good :)"
                    },
                    {
                        "username": "killerraj369",
                        "content": "After watching this comment I solved it by myself at first attempt itself."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good... doesn\\'t it?"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "same bro... feeling proud in my small achievement lol !"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "I am ashamed of my self. "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "same bruh!\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "whenever i see leaving, it reminds me of her :("
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "slow claps :)"
                    },
                    {
                        "username": "santanusen",
                        "content": "Please share how did you make her leave :p"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "Logic level with realistic view on top "
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "riyal"
                    },
                    {
                        "username": "Vicjr",
                        "content": "real"
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "real"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\\uD83D\\uDE06 "
                    },
                    {
                        "username": "maysrv",
                        "content": "You might be tempted to use i, j and k to keep track of s1, s2 and s3 respectively in your recursive calls but it gave me TLE. (Please note that it is not wrong)\\nThe trick here was to remove k from your changing state and reduce dp from 3D to 2D.\\nYou may reason about it by manipulating what you think of i and j at each point and it may work for you but I would like to point out how I reason it. \\nThe thing here is, at every step k is nothing but i+j, so we dont need to keep track of k because we can get it from i and j."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@chenon](/chenon) The problem here is you\\'re greedily checking if s3 can be created from s1 if not then you\\'re checking for s2.\\n\\nIf somehow the test-case you\\'re mentioning currently is cleared then you\\'ll stuck later on."
                    },
                    {
                        "username": "chenon",
                        "content": "I was exactly keeping track of the indexes on s1 and s2  . See my submission https://leetcode.com/problems/interleaving-string/submissions/1031746304/ . NO TLE but wrong answer."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I used 4D and beat 9%..."
                    },
                    {
                        "username": "parmani",
                        "content": "but 3d also works, since the constraints are low"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "at first i also did the 3d dp, then i figured it out that we dont need k..:p"
                    },
                    {
                        "username": "sanket54",
                        "content": "What is meaning of |n-m| <= 1 and why it is being ignored in all solutions ?"
                    },
                    {
                        "username": "sanjeeb42",
                        "content": "[@mahesh105](/mahesh105) Thanks for the explanation. I was exactly looking for this"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@mahesh105](/mahesh105)  thankss bro"
                    },
                    {
                        "username": "mahesh105",
                        "content": "All of the reasons in this threads were not explaining why?\\nLet me tell you.\\nsuppose you take n substrings of S1 and place it like this\\n__  __  __  __  __  __  __  __  __  __  __  __\\nthen you can fill the S2 substrings in the gaps or the boundary...in either case the inequality holds.\\nSo yeah if the string is interleaving, this inequality is automatically held due to this observation.\\nHappy Debugging : )"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The fact is that |n - m| <= 1 (where m and n are the no. of substring used for interleaving the string) is just the condition which supports that strings must be interleaved.\\nIf there are interleaved correctly then this condition will be automatically true.\\nThat\\'s why every piece of information not need to be included in code some time based on few logic we have to neglect few of them."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@unters](/unters) |n-m| <= 1 means you cannot divide the strings into arbitrarily sized pieces. If string 1 is divided into 4 parts, then string 5 can only be divided into 3, 4 or 5 parts. "
                    },
                    {
                        "username": "unters",
                        "content": "[@WajeehHasan](/WajeehHasan), in my opinion you\\'re not quite right. `m` and `n` are not numbers of characters in each string - that are numbers of nonoverlapping substrings in each string (each substring can contain more than one character). `|m - n| <= 1\\' means there can not be two adjacent substrings in p3 that belong to one string."
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Exactly what I am looking for."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "simply means difference of the length of string s and t is less than or equal to 1"
                    },
                    {
                        "username": "eddy66",
                        "content": "I think `|n-m|<=1` just means the substrings of `s` are interleaved with the substrings of `t`. So they could be `s1, t1, s2`, or `s1, t1, s2, t2`. But since each substring can be anything, so it\\'s not important when we solve the problem"
                    },
                    {
                        "username": "mvo13",
                        "content": "|n-m| <= 1 \\n=> The time complexity is O(n^2)"
                    },
                    {
                        "username": "shiva_San",
                        "content": "be ready for this testcase if you are using two pointer method without dp..\n\ns1 =\n\"aabc\"\ns2 =\n\"abad\"\ns3 =\n\"aabadabc\"\n\noutput=true\n"
                    },
                    {
                        "username": "oisinfarrell00",
                        "content": "In the brief of Intervealving strings it states that:\\n - The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...\\nHowever then they give this example:\\n![image](https://assets.leetcode.com/users/images/28de80e4-3308-48c9-9f45-46d243f7a928_1622621577.219354.png)\\nI dont really understand how this example works. It takes two letters from the first string and then 4 from the next and then back to two and so on. I thought it had to be like s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ... Am I missing something here?"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "s1 and so on may not necessarily be single characters. That is the trick here."
                    },
                    {
                        "username": "Kaltu",
                        "content": "`s1 = \\'aa\\', s2 = \\'bc\\', s3 = \\'c\\'` and `t1 = \\'dbbc\\', t2 = \\'a\\'` so the answer is `s1 + t1 + s2 + t2 + s3`"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Here s or t don\\'t represent the charecters but a substring, which means in above example s1 is \"aa\" and t1 is \"dbbc\" and similarily s2 is \"bc\"..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a string problem. But it needs some method to solve. A 2D DP is possible, since s3 depends on both s1 & s2. "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@meow_power](/meow_power) because we don\\'t need it, i and j together can always determine k uniquely (i+j = k; always holds if ur not doing anything sus)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@meow_power](/meow_power) Your solution is fine. 2D array is used."
                    },
                    {
                        "username": "meow_power",
                        "content": "my solution uses k as third parameter but in memoization why is it not used.Please help"
                    },
                    {
                        "username": "mayliao",
                        "content": "It is so strange use static variable get the answer is different from my computer. After I changed it as parameter, it worked well."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "relevant article \\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-"
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "cuz static variable will be kept and be operated by the function u implemented for each different test cases, without resetting its original value. while local parameter will be wiped after function is done for one test case, and created and set for the next test case."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/interleaving-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Recursion with memoization\n\n  \n**Approach 3:** Using 2D Dynamic Programming\n\n  \n**Approach 4:** Using 1D Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1567151,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "So you need to ask yourself ..why is dp used here?\\n In first look this questions looks pretty simple and can be done using 2 pointers. \\n \\n Then you implement the 2 pointer approach and upon submission your code get a wrong ans on the below testcase.\\n \\n This test case then tells you why this que is asking for a dp solution.\\n \\n s1 = \"aabc\"\\n s2 = \"abad\"\\n s3= \"aabadabc\"\\n \\n Now in this, if you start moving from the back using the 2 pointer approach, it keeps on eleminating the character from the 1st string i.e s1. But when s1 gets exhausted, your s3 does not match with s2. \\n Here you take a note that, when char at s1 and s2 are equal, we need to check if deleting the char from s1 is a correct move or deleting the char from s2 would be a correct move.\\n \\n That clearly means, we have 2 choices here, either to delete the char from s1 or s2.\\n \\n Now for a bigger testcase like this it is clearly evidant that the que is asking for a Dyanmic Programming solution!!\\n \\n s1 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s2 = \"aaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n s3 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\\t\\t aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n"
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "great intution \\uD83D\\uDD25\\uD83D\\uDD25\\uD83C\\uDF89"
                    },
                    {
                        "username": "sandeshnep",
                        "content": "I CAN\\'T BELIEVE I SOLVED THIS ONE BY MY SELF :OOOOOOOOOO"
                    },
                    {
                        "username": "SeineAle",
                        "content": "ME TOO !\nFeels Good :)"
                    },
                    {
                        "username": "killerraj369",
                        "content": "After watching this comment I solved it by myself at first attempt itself."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good... doesn\\'t it?"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "same bro... feeling proud in my small achievement lol !"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "I am ashamed of my self. "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "same bruh!\\n"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "whenever i see leaving, it reminds me of her :("
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "slow claps :)"
                    },
                    {
                        "username": "santanusen",
                        "content": "Please share how did you make her leave :p"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "Logic level with realistic view on top "
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "riyal"
                    },
                    {
                        "username": "Vicjr",
                        "content": "real"
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "real"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\\uD83D\\uDE06 "
                    },
                    {
                        "username": "maysrv",
                        "content": "You might be tempted to use i, j and k to keep track of s1, s2 and s3 respectively in your recursive calls but it gave me TLE. (Please note that it is not wrong)\\nThe trick here was to remove k from your changing state and reduce dp from 3D to 2D.\\nYou may reason about it by manipulating what you think of i and j at each point and it may work for you but I would like to point out how I reason it. \\nThe thing here is, at every step k is nothing but i+j, so we dont need to keep track of k because we can get it from i and j."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "[@chenon](/chenon) The problem here is you\\'re greedily checking if s3 can be created from s1 if not then you\\'re checking for s2.\\n\\nIf somehow the test-case you\\'re mentioning currently is cleared then you\\'ll stuck later on."
                    },
                    {
                        "username": "chenon",
                        "content": "I was exactly keeping track of the indexes on s1 and s2  . See my submission https://leetcode.com/problems/interleaving-string/submissions/1031746304/ . NO TLE but wrong answer."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I used 4D and beat 9%..."
                    },
                    {
                        "username": "parmani",
                        "content": "but 3d also works, since the constraints are low"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "at first i also did the 3d dp, then i figured it out that we dont need k..:p"
                    },
                    {
                        "username": "sanket54",
                        "content": "What is meaning of |n-m| <= 1 and why it is being ignored in all solutions ?"
                    },
                    {
                        "username": "sanjeeb42",
                        "content": "[@mahesh105](/mahesh105) Thanks for the explanation. I was exactly looking for this"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@mahesh105](/mahesh105)  thankss bro"
                    },
                    {
                        "username": "mahesh105",
                        "content": "All of the reasons in this threads were not explaining why?\\nLet me tell you.\\nsuppose you take n substrings of S1 and place it like this\\n__  __  __  __  __  __  __  __  __  __  __  __\\nthen you can fill the S2 substrings in the gaps or the boundary...in either case the inequality holds.\\nSo yeah if the string is interleaving, this inequality is automatically held due to this observation.\\nHappy Debugging : )"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The fact is that |n - m| <= 1 (where m and n are the no. of substring used for interleaving the string) is just the condition which supports that strings must be interleaved.\\nIf there are interleaved correctly then this condition will be automatically true.\\nThat\\'s why every piece of information not need to be included in code some time based on few logic we have to neglect few of them."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@unters](/unters) |n-m| <= 1 means you cannot divide the strings into arbitrarily sized pieces. If string 1 is divided into 4 parts, then string 5 can only be divided into 3, 4 or 5 parts. "
                    },
                    {
                        "username": "unters",
                        "content": "[@WajeehHasan](/WajeehHasan), in my opinion you\\'re not quite right. `m` and `n` are not numbers of characters in each string - that are numbers of nonoverlapping substrings in each string (each substring can contain more than one character). `|m - n| <= 1\\' means there can not be two adjacent substrings in p3 that belong to one string."
                    },
                    {
                        "username": "Sanskar_Garg",
                        "content": "Exactly what I am looking for."
                    },
                    {
                        "username": "WajeehHasan",
                        "content": "simply means difference of the length of string s and t is less than or equal to 1"
                    },
                    {
                        "username": "eddy66",
                        "content": "I think `|n-m|<=1` just means the substrings of `s` are interleaved with the substrings of `t`. So they could be `s1, t1, s2`, or `s1, t1, s2, t2`. But since each substring can be anything, so it\\'s not important when we solve the problem"
                    },
                    {
                        "username": "mvo13",
                        "content": "|n-m| <= 1 \\n=> The time complexity is O(n^2)"
                    },
                    {
                        "username": "shiva_San",
                        "content": "be ready for this testcase if you are using two pointer method without dp..\n\ns1 =\n\"aabc\"\ns2 =\n\"abad\"\ns3 =\n\"aabadabc\"\n\noutput=true\n"
                    },
                    {
                        "username": "oisinfarrell00",
                        "content": "In the brief of Intervealving strings it states that:\\n - The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...\\nHowever then they give this example:\\n![image](https://assets.leetcode.com/users/images/28de80e4-3308-48c9-9f45-46d243f7a928_1622621577.219354.png)\\nI dont really understand how this example works. It takes two letters from the first string and then 4 from the next and then back to two and so on. I thought it had to be like s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ... Am I missing something here?"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "s1 and so on may not necessarily be single characters. That is the trick here."
                    },
                    {
                        "username": "Kaltu",
                        "content": "`s1 = \\'aa\\', s2 = \\'bc\\', s3 = \\'c\\'` and `t1 = \\'dbbc\\', t2 = \\'a\\'` so the answer is `s1 + t1 + s2 + t2 + s3`"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "Here s or t don\\'t represent the charecters but a substring, which means in above example s1 is \"aa\" and t1 is \"dbbc\" and similarily s2 is \"bc\"..."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a string problem. But it needs some method to solve. A 2D DP is possible, since s3 depends on both s1 & s2. "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "[@meow_power](/meow_power) because we don\\'t need it, i and j together can always determine k uniquely (i+j = k; always holds if ur not doing anything sus)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@meow_power](/meow_power) Your solution is fine. 2D array is used."
                    },
                    {
                        "username": "meow_power",
                        "content": "my solution uses k as third parameter but in memoization why is it not used.Please help"
                    },
                    {
                        "username": "mayliao",
                        "content": "It is so strange use static variable get the answer is different from my computer. After I changed it as parameter, it worked well."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "relevant article \\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-"
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "cuz static variable will be kept and be operated by the function u implemented for each different test cases, without resetting its original value. while local parameter will be wiped after function is done for one test case, and created and set for the next test case."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/interleaving-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Recursion with memoization\n\n  \n**Approach 3:** Using 2D Dynamic Programming\n\n  \n**Approach 4:** Using 1D Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566477,
                "content": [
                    {
                        "username": "merce",
                        "content": "If s1 = \"a\" and s2 = \"b\" and s3 = \"aba\" \\n\\nWhy isn't this a valid interleaving?? Sorry if I seem stupid."
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "BECASE THE QUANTITY OF \\'a\\' is over by using it frst time in \"aba\""
                    },
                    {
                        "username": "northern-flower",
                        "content": "Because s3 should contain all the characters of both s1 and s2.. Actually in my code if the length of s3 is not the sum of the lengths of s1 and s2 - I am already returning \\'false\\' as a result, to speed up the checking process."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "*This problem is quite challenging.*\n**Here is a tip to overcome this challenge**\nThis problem involves finding whether a target string s3 can be formed by interleaving two given strings s1 and s2. An important observation is that the relative order of characters within each string needs to be maintained in the interleaved result.\n\nHere's a high-level approach to consider:\n\n**Dynamic Programming:** Consider using a dynamic programming approach. Create a 2D DP table where dp[i][j] represents whether the first i characters of s1 and the first j characters of s2 can form the first i+j characters of s3.\n\n**Base Cases:** Initialize the DP table with base cases. For example, dp[0][0] should be true, as both empty strings can form an empty string.\n\n**Recurrence Relation:** Build the DP table bottom-up using a recurrence relation. You can consider the following cases:\n\nIf the current character in s3 matches the current character in s1, you can check if the previous characters in s1 and s3 match and update dp[i][j] accordingly.\nSimilarly, if the current character in s3 matches the current character in s2, you can check if the previous characters in s2 and s3 match and update dp[i][j] accordingly.\nFinal Result: After filling the DP table, the value of dp[s1.length()][s2.length()] will indicate whether s3 can be formed by interleaving s1 and s2.\n\nRemember to handle the edge cases and index mapping properly while implementing the DP solution.\n\nGood luck! Dynamic programming can be powerful for such sequence-related problems.  "
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "Did I just solve this on my own \\uD83D\\uDE2D"
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good.... doesn\\'t it :)"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "can someone explain why we it is not problem of 3d dp but 2d? since 3 variables are changing,it should be 3D DP"
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "You can think of the third variable as the sum of the first two and that way you don\\'t have to keep track of all three of them."
                    },
                    {
                        "username": "humaocheng75",
                        "content": "because s3\\'s pointer is controlled by s1 and s2 directly... it is not independent..."
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Hooray! I did it myself!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "this test case (second to last one) forced me to use memoization.  if you\\'re shooting for 100% acceptance use this as your custom performance test.\\n\\ns1 = \"abababababababababababababababababababababababababababababababababababababababababababababababababbb\"\\ns2 = \"babababababababababababababababababababababababababababababababababababababababababababababababaaaba\"\\ns3 = \"abababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababbb\""
                    },
                    {
                        "username": "brunotg",
                        "content": "Why do we need to generate all the interleavings? I was trynig to have a pointer that moves along s1, another that moves along s2 and another that moves along s3. \\n\\nAs long as you have the same characters on s1 as on s3, you move them both. An you do the same with s2 and s3.\\n"
                    },
                    {
                        "username": "packle",
                        "content": "same characters on s1 and s2, we do not know which ptr to move. have to branch and try both"
                    },
                    {
                        "username": "humaocheng75",
                        "content": "I got timeout..."
                    },
                    {
                        "username": "vdas53073",
                        "content": "i was doing the same and in example 2 it gives true according to my logic but don\\'t know why it is false"
                    },
                    {
                        "username": "1711",
                        "content": "maybe it\\'s very hard"
                    },
                    {
                        "username": "anurag_819",
                        "content": "Can anyone pls explain me this testcase?\\n\\ns1= \"aaaa\"\\ns2= \"aa\"\\ns3= \"aaa\"\\n\\nThe expected output is false."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@kdhjd](/kdhjd) Why would that matter? If we have two strings, \"a\" and \"bbbb\" then \"bbabb\" should be a valid interleaving, even though the difference of their lengths is 3. "
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@kdhjd](/kdhjd) \n`s3` is formed by **interleaving** `s1` and `s2`. therefore, `s3.length == s1.length + s2.length`. \nidk why they put `|n -m| <= 1` as one of the conditions but surely they did NOT say `n` is `s1.length` and `m` is `s2.length`.\nbtw, i did nothing with that `|n -m| <= 1` and still got passed"
                    },
                    {
                        "username": "kdhjd",
                        "content": "The expected output is false as | len(s1)-len(s2) | > 1."
                    },
                    {
                        "username": "chirag019",
                        "content": "Additional info: \n- You can't use a character twice.\n- You have to necessarily use all the characters of s1 and s2.\n\nTip:\n- Initialize two pointers, say `i` and `j` for `s1` and `s2` resp. No need for an explicit pointer for `s3`, since it will always be equal to `i+j`"
                    }
                ]
            },
            {
                "id": 2030001,
                "content": [
                    {
                        "username": "merce",
                        "content": "If s1 = \"a\" and s2 = \"b\" and s3 = \"aba\" \\n\\nWhy isn't this a valid interleaving?? Sorry if I seem stupid."
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "BECASE THE QUANTITY OF \\'a\\' is over by using it frst time in \"aba\""
                    },
                    {
                        "username": "northern-flower",
                        "content": "Because s3 should contain all the characters of both s1 and s2.. Actually in my code if the length of s3 is not the sum of the lengths of s1 and s2 - I am already returning \\'false\\' as a result, to speed up the checking process."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "*This problem is quite challenging.*\n**Here is a tip to overcome this challenge**\nThis problem involves finding whether a target string s3 can be formed by interleaving two given strings s1 and s2. An important observation is that the relative order of characters within each string needs to be maintained in the interleaved result.\n\nHere's a high-level approach to consider:\n\n**Dynamic Programming:** Consider using a dynamic programming approach. Create a 2D DP table where dp[i][j] represents whether the first i characters of s1 and the first j characters of s2 can form the first i+j characters of s3.\n\n**Base Cases:** Initialize the DP table with base cases. For example, dp[0][0] should be true, as both empty strings can form an empty string.\n\n**Recurrence Relation:** Build the DP table bottom-up using a recurrence relation. You can consider the following cases:\n\nIf the current character in s3 matches the current character in s1, you can check if the previous characters in s1 and s3 match and update dp[i][j] accordingly.\nSimilarly, if the current character in s3 matches the current character in s2, you can check if the previous characters in s2 and s3 match and update dp[i][j] accordingly.\nFinal Result: After filling the DP table, the value of dp[s1.length()][s2.length()] will indicate whether s3 can be formed by interleaving s1 and s2.\n\nRemember to handle the edge cases and index mapping properly while implementing the DP solution.\n\nGood luck! Dynamic programming can be powerful for such sequence-related problems.  "
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "Did I just solve this on my own \\uD83D\\uDE2D"
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good.... doesn\\'t it :)"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "can someone explain why we it is not problem of 3d dp but 2d? since 3 variables are changing,it should be 3D DP"
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "You can think of the third variable as the sum of the first two and that way you don\\'t have to keep track of all three of them."
                    },
                    {
                        "username": "humaocheng75",
                        "content": "because s3\\'s pointer is controlled by s1 and s2 directly... it is not independent..."
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Hooray! I did it myself!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "this test case (second to last one) forced me to use memoization.  if you\\'re shooting for 100% acceptance use this as your custom performance test.\\n\\ns1 = \"abababababababababababababababababababababababababababababababababababababababababababababababababbb\"\\ns2 = \"babababababababababababababababababababababababababababababababababababababababababababababababaaaba\"\\ns3 = \"abababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababbb\""
                    },
                    {
                        "username": "brunotg",
                        "content": "Why do we need to generate all the interleavings? I was trynig to have a pointer that moves along s1, another that moves along s2 and another that moves along s3. \\n\\nAs long as you have the same characters on s1 as on s3, you move them both. An you do the same with s2 and s3.\\n"
                    },
                    {
                        "username": "packle",
                        "content": "same characters on s1 and s2, we do not know which ptr to move. have to branch and try both"
                    },
                    {
                        "username": "humaocheng75",
                        "content": "I got timeout..."
                    },
                    {
                        "username": "vdas53073",
                        "content": "i was doing the same and in example 2 it gives true according to my logic but don\\'t know why it is false"
                    },
                    {
                        "username": "1711",
                        "content": "maybe it\\'s very hard"
                    },
                    {
                        "username": "anurag_819",
                        "content": "Can anyone pls explain me this testcase?\\n\\ns1= \"aaaa\"\\ns2= \"aa\"\\ns3= \"aaa\"\\n\\nThe expected output is false."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@kdhjd](/kdhjd) Why would that matter? If we have two strings, \"a\" and \"bbbb\" then \"bbabb\" should be a valid interleaving, even though the difference of their lengths is 3. "
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@kdhjd](/kdhjd) \n`s3` is formed by **interleaving** `s1` and `s2`. therefore, `s3.length == s1.length + s2.length`. \nidk why they put `|n -m| <= 1` as one of the conditions but surely they did NOT say `n` is `s1.length` and `m` is `s2.length`.\nbtw, i did nothing with that `|n -m| <= 1` and still got passed"
                    },
                    {
                        "username": "kdhjd",
                        "content": "The expected output is false as | len(s1)-len(s2) | > 1."
                    },
                    {
                        "username": "chirag019",
                        "content": "Additional info: \n- You can't use a character twice.\n- You have to necessarily use all the characters of s1 and s2.\n\nTip:\n- Initialize two pointers, say `i` and `j` for `s1` and `s2` resp. No need for an explicit pointer for `s3`, since it will always be equal to `i+j`"
                    }
                ]
            },
            {
                "id": 2029182,
                "content": [
                    {
                        "username": "merce",
                        "content": "If s1 = \"a\" and s2 = \"b\" and s3 = \"aba\" \\n\\nWhy isn't this a valid interleaving?? Sorry if I seem stupid."
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "BECASE THE QUANTITY OF \\'a\\' is over by using it frst time in \"aba\""
                    },
                    {
                        "username": "northern-flower",
                        "content": "Because s3 should contain all the characters of both s1 and s2.. Actually in my code if the length of s3 is not the sum of the lengths of s1 and s2 - I am already returning \\'false\\' as a result, to speed up the checking process."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "*This problem is quite challenging.*\n**Here is a tip to overcome this challenge**\nThis problem involves finding whether a target string s3 can be formed by interleaving two given strings s1 and s2. An important observation is that the relative order of characters within each string needs to be maintained in the interleaved result.\n\nHere's a high-level approach to consider:\n\n**Dynamic Programming:** Consider using a dynamic programming approach. Create a 2D DP table where dp[i][j] represents whether the first i characters of s1 and the first j characters of s2 can form the first i+j characters of s3.\n\n**Base Cases:** Initialize the DP table with base cases. For example, dp[0][0] should be true, as both empty strings can form an empty string.\n\n**Recurrence Relation:** Build the DP table bottom-up using a recurrence relation. You can consider the following cases:\n\nIf the current character in s3 matches the current character in s1, you can check if the previous characters in s1 and s3 match and update dp[i][j] accordingly.\nSimilarly, if the current character in s3 matches the current character in s2, you can check if the previous characters in s2 and s3 match and update dp[i][j] accordingly.\nFinal Result: After filling the DP table, the value of dp[s1.length()][s2.length()] will indicate whether s3 can be formed by interleaving s1 and s2.\n\nRemember to handle the edge cases and index mapping properly while implementing the DP solution.\n\nGood luck! Dynamic programming can be powerful for such sequence-related problems.  "
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "Did I just solve this on my own \\uD83D\\uDE2D"
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good.... doesn\\'t it :)"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "can someone explain why we it is not problem of 3d dp but 2d? since 3 variables are changing,it should be 3D DP"
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "You can think of the third variable as the sum of the first two and that way you don\\'t have to keep track of all three of them."
                    },
                    {
                        "username": "humaocheng75",
                        "content": "because s3\\'s pointer is controlled by s1 and s2 directly... it is not independent..."
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Hooray! I did it myself!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "this test case (second to last one) forced me to use memoization.  if you\\'re shooting for 100% acceptance use this as your custom performance test.\\n\\ns1 = \"abababababababababababababababababababababababababababababababababababababababababababababababababbb\"\\ns2 = \"babababababababababababababababababababababababababababababababababababababababababababababababaaaba\"\\ns3 = \"abababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababbb\""
                    },
                    {
                        "username": "brunotg",
                        "content": "Why do we need to generate all the interleavings? I was trynig to have a pointer that moves along s1, another that moves along s2 and another that moves along s3. \\n\\nAs long as you have the same characters on s1 as on s3, you move them both. An you do the same with s2 and s3.\\n"
                    },
                    {
                        "username": "packle",
                        "content": "same characters on s1 and s2, we do not know which ptr to move. have to branch and try both"
                    },
                    {
                        "username": "humaocheng75",
                        "content": "I got timeout..."
                    },
                    {
                        "username": "vdas53073",
                        "content": "i was doing the same and in example 2 it gives true according to my logic but don\\'t know why it is false"
                    },
                    {
                        "username": "1711",
                        "content": "maybe it\\'s very hard"
                    },
                    {
                        "username": "anurag_819",
                        "content": "Can anyone pls explain me this testcase?\\n\\ns1= \"aaaa\"\\ns2= \"aa\"\\ns3= \"aaa\"\\n\\nThe expected output is false."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@kdhjd](/kdhjd) Why would that matter? If we have two strings, \"a\" and \"bbbb\" then \"bbabb\" should be a valid interleaving, even though the difference of their lengths is 3. "
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@kdhjd](/kdhjd) \n`s3` is formed by **interleaving** `s1` and `s2`. therefore, `s3.length == s1.length + s2.length`. \nidk why they put `|n -m| <= 1` as one of the conditions but surely they did NOT say `n` is `s1.length` and `m` is `s2.length`.\nbtw, i did nothing with that `|n -m| <= 1` and still got passed"
                    },
                    {
                        "username": "kdhjd",
                        "content": "The expected output is false as | len(s1)-len(s2) | > 1."
                    },
                    {
                        "username": "chirag019",
                        "content": "Additional info: \n- You can't use a character twice.\n- You have to necessarily use all the characters of s1 and s2.\n\nTip:\n- Initialize two pointers, say `i` and `j` for `s1` and `s2` resp. No need for an explicit pointer for `s3`, since it will always be equal to `i+j`"
                    }
                ]
            },
            {
                "id": 1575397,
                "content": [
                    {
                        "username": "merce",
                        "content": "If s1 = \"a\" and s2 = \"b\" and s3 = \"aba\" \\n\\nWhy isn't this a valid interleaving?? Sorry if I seem stupid."
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "BECASE THE QUANTITY OF \\'a\\' is over by using it frst time in \"aba\""
                    },
                    {
                        "username": "northern-flower",
                        "content": "Because s3 should contain all the characters of both s1 and s2.. Actually in my code if the length of s3 is not the sum of the lengths of s1 and s2 - I am already returning \\'false\\' as a result, to speed up the checking process."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "*This problem is quite challenging.*\n**Here is a tip to overcome this challenge**\nThis problem involves finding whether a target string s3 can be formed by interleaving two given strings s1 and s2. An important observation is that the relative order of characters within each string needs to be maintained in the interleaved result.\n\nHere's a high-level approach to consider:\n\n**Dynamic Programming:** Consider using a dynamic programming approach. Create a 2D DP table where dp[i][j] represents whether the first i characters of s1 and the first j characters of s2 can form the first i+j characters of s3.\n\n**Base Cases:** Initialize the DP table with base cases. For example, dp[0][0] should be true, as both empty strings can form an empty string.\n\n**Recurrence Relation:** Build the DP table bottom-up using a recurrence relation. You can consider the following cases:\n\nIf the current character in s3 matches the current character in s1, you can check if the previous characters in s1 and s3 match and update dp[i][j] accordingly.\nSimilarly, if the current character in s3 matches the current character in s2, you can check if the previous characters in s2 and s3 match and update dp[i][j] accordingly.\nFinal Result: After filling the DP table, the value of dp[s1.length()][s2.length()] will indicate whether s3 can be formed by interleaving s1 and s2.\n\nRemember to handle the edge cases and index mapping properly while implementing the DP solution.\n\nGood luck! Dynamic programming can be powerful for such sequence-related problems.  "
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "Did I just solve this on my own \\uD83D\\uDE2D"
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good.... doesn\\'t it :)"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "can someone explain why we it is not problem of 3d dp but 2d? since 3 variables are changing,it should be 3D DP"
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "You can think of the third variable as the sum of the first two and that way you don\\'t have to keep track of all three of them."
                    },
                    {
                        "username": "humaocheng75",
                        "content": "because s3\\'s pointer is controlled by s1 and s2 directly... it is not independent..."
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Hooray! I did it myself!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "this test case (second to last one) forced me to use memoization.  if you\\'re shooting for 100% acceptance use this as your custom performance test.\\n\\ns1 = \"abababababababababababababababababababababababababababababababababababababababababababababababababbb\"\\ns2 = \"babababababababababababababababababababababababababababababababababababababababababababababababaaaba\"\\ns3 = \"abababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababbb\""
                    },
                    {
                        "username": "brunotg",
                        "content": "Why do we need to generate all the interleavings? I was trynig to have a pointer that moves along s1, another that moves along s2 and another that moves along s3. \\n\\nAs long as you have the same characters on s1 as on s3, you move them both. An you do the same with s2 and s3.\\n"
                    },
                    {
                        "username": "packle",
                        "content": "same characters on s1 and s2, we do not know which ptr to move. have to branch and try both"
                    },
                    {
                        "username": "humaocheng75",
                        "content": "I got timeout..."
                    },
                    {
                        "username": "vdas53073",
                        "content": "i was doing the same and in example 2 it gives true according to my logic but don\\'t know why it is false"
                    },
                    {
                        "username": "1711",
                        "content": "maybe it\\'s very hard"
                    },
                    {
                        "username": "anurag_819",
                        "content": "Can anyone pls explain me this testcase?\\n\\ns1= \"aaaa\"\\ns2= \"aa\"\\ns3= \"aaa\"\\n\\nThe expected output is false."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@kdhjd](/kdhjd) Why would that matter? If we have two strings, \"a\" and \"bbbb\" then \"bbabb\" should be a valid interleaving, even though the difference of their lengths is 3. "
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@kdhjd](/kdhjd) \n`s3` is formed by **interleaving** `s1` and `s2`. therefore, `s3.length == s1.length + s2.length`. \nidk why they put `|n -m| <= 1` as one of the conditions but surely they did NOT say `n` is `s1.length` and `m` is `s2.length`.\nbtw, i did nothing with that `|n -m| <= 1` and still got passed"
                    },
                    {
                        "username": "kdhjd",
                        "content": "The expected output is false as | len(s1)-len(s2) | > 1."
                    },
                    {
                        "username": "chirag019",
                        "content": "Additional info: \n- You can't use a character twice.\n- You have to necessarily use all the characters of s1 and s2.\n\nTip:\n- Initialize two pointers, say `i` and `j` for `s1` and `s2` resp. No need for an explicit pointer for `s3`, since it will always be equal to `i+j`"
                    }
                ]
            },
            {
                "id": 2030072,
                "content": [
                    {
                        "username": "merce",
                        "content": "If s1 = \"a\" and s2 = \"b\" and s3 = \"aba\" \\n\\nWhy isn't this a valid interleaving?? Sorry if I seem stupid."
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "BECASE THE QUANTITY OF \\'a\\' is over by using it frst time in \"aba\""
                    },
                    {
                        "username": "northern-flower",
                        "content": "Because s3 should contain all the characters of both s1 and s2.. Actually in my code if the length of s3 is not the sum of the lengths of s1 and s2 - I am already returning \\'false\\' as a result, to speed up the checking process."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "*This problem is quite challenging.*\n**Here is a tip to overcome this challenge**\nThis problem involves finding whether a target string s3 can be formed by interleaving two given strings s1 and s2. An important observation is that the relative order of characters within each string needs to be maintained in the interleaved result.\n\nHere's a high-level approach to consider:\n\n**Dynamic Programming:** Consider using a dynamic programming approach. Create a 2D DP table where dp[i][j] represents whether the first i characters of s1 and the first j characters of s2 can form the first i+j characters of s3.\n\n**Base Cases:** Initialize the DP table with base cases. For example, dp[0][0] should be true, as both empty strings can form an empty string.\n\n**Recurrence Relation:** Build the DP table bottom-up using a recurrence relation. You can consider the following cases:\n\nIf the current character in s3 matches the current character in s1, you can check if the previous characters in s1 and s3 match and update dp[i][j] accordingly.\nSimilarly, if the current character in s3 matches the current character in s2, you can check if the previous characters in s2 and s3 match and update dp[i][j] accordingly.\nFinal Result: After filling the DP table, the value of dp[s1.length()][s2.length()] will indicate whether s3 can be formed by interleaving s1 and s2.\n\nRemember to handle the edge cases and index mapping properly while implementing the DP solution.\n\nGood luck! Dynamic programming can be powerful for such sequence-related problems.  "
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "Did I just solve this on my own \\uD83D\\uDE2D"
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good.... doesn\\'t it :)"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "can someone explain why we it is not problem of 3d dp but 2d? since 3 variables are changing,it should be 3D DP"
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "You can think of the third variable as the sum of the first two and that way you don\\'t have to keep track of all three of them."
                    },
                    {
                        "username": "humaocheng75",
                        "content": "because s3\\'s pointer is controlled by s1 and s2 directly... it is not independent..."
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Hooray! I did it myself!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "this test case (second to last one) forced me to use memoization.  if you\\'re shooting for 100% acceptance use this as your custom performance test.\\n\\ns1 = \"abababababababababababababababababababababababababababababababababababababababababababababababababbb\"\\ns2 = \"babababababababababababababababababababababababababababababababababababababababababababababababaaaba\"\\ns3 = \"abababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababbb\""
                    },
                    {
                        "username": "brunotg",
                        "content": "Why do we need to generate all the interleavings? I was trynig to have a pointer that moves along s1, another that moves along s2 and another that moves along s3. \\n\\nAs long as you have the same characters on s1 as on s3, you move them both. An you do the same with s2 and s3.\\n"
                    },
                    {
                        "username": "packle",
                        "content": "same characters on s1 and s2, we do not know which ptr to move. have to branch and try both"
                    },
                    {
                        "username": "humaocheng75",
                        "content": "I got timeout..."
                    },
                    {
                        "username": "vdas53073",
                        "content": "i was doing the same and in example 2 it gives true according to my logic but don\\'t know why it is false"
                    },
                    {
                        "username": "1711",
                        "content": "maybe it\\'s very hard"
                    },
                    {
                        "username": "anurag_819",
                        "content": "Can anyone pls explain me this testcase?\\n\\ns1= \"aaaa\"\\ns2= \"aa\"\\ns3= \"aaa\"\\n\\nThe expected output is false."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@kdhjd](/kdhjd) Why would that matter? If we have two strings, \"a\" and \"bbbb\" then \"bbabb\" should be a valid interleaving, even though the difference of their lengths is 3. "
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@kdhjd](/kdhjd) \n`s3` is formed by **interleaving** `s1` and `s2`. therefore, `s3.length == s1.length + s2.length`. \nidk why they put `|n -m| <= 1` as one of the conditions but surely they did NOT say `n` is `s1.length` and `m` is `s2.length`.\nbtw, i did nothing with that `|n -m| <= 1` and still got passed"
                    },
                    {
                        "username": "kdhjd",
                        "content": "The expected output is false as | len(s1)-len(s2) | > 1."
                    },
                    {
                        "username": "chirag019",
                        "content": "Additional info: \n- You can't use a character twice.\n- You have to necessarily use all the characters of s1 and s2.\n\nTip:\n- Initialize two pointers, say `i` and `j` for `s1` and `s2` resp. No need for an explicit pointer for `s3`, since it will always be equal to `i+j`"
                    }
                ]
            },
            {
                "id": 2029778,
                "content": [
                    {
                        "username": "merce",
                        "content": "If s1 = \"a\" and s2 = \"b\" and s3 = \"aba\" \\n\\nWhy isn't this a valid interleaving?? Sorry if I seem stupid."
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "BECASE THE QUANTITY OF \\'a\\' is over by using it frst time in \"aba\""
                    },
                    {
                        "username": "northern-flower",
                        "content": "Because s3 should contain all the characters of both s1 and s2.. Actually in my code if the length of s3 is not the sum of the lengths of s1 and s2 - I am already returning \\'false\\' as a result, to speed up the checking process."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "*This problem is quite challenging.*\n**Here is a tip to overcome this challenge**\nThis problem involves finding whether a target string s3 can be formed by interleaving two given strings s1 and s2. An important observation is that the relative order of characters within each string needs to be maintained in the interleaved result.\n\nHere's a high-level approach to consider:\n\n**Dynamic Programming:** Consider using a dynamic programming approach. Create a 2D DP table where dp[i][j] represents whether the first i characters of s1 and the first j characters of s2 can form the first i+j characters of s3.\n\n**Base Cases:** Initialize the DP table with base cases. For example, dp[0][0] should be true, as both empty strings can form an empty string.\n\n**Recurrence Relation:** Build the DP table bottom-up using a recurrence relation. You can consider the following cases:\n\nIf the current character in s3 matches the current character in s1, you can check if the previous characters in s1 and s3 match and update dp[i][j] accordingly.\nSimilarly, if the current character in s3 matches the current character in s2, you can check if the previous characters in s2 and s3 match and update dp[i][j] accordingly.\nFinal Result: After filling the DP table, the value of dp[s1.length()][s2.length()] will indicate whether s3 can be formed by interleaving s1 and s2.\n\nRemember to handle the edge cases and index mapping properly while implementing the DP solution.\n\nGood luck! Dynamic programming can be powerful for such sequence-related problems.  "
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "Did I just solve this on my own \\uD83D\\uDE2D"
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good.... doesn\\'t it :)"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "can someone explain why we it is not problem of 3d dp but 2d? since 3 variables are changing,it should be 3D DP"
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "You can think of the third variable as the sum of the first two and that way you don\\'t have to keep track of all three of them."
                    },
                    {
                        "username": "humaocheng75",
                        "content": "because s3\\'s pointer is controlled by s1 and s2 directly... it is not independent..."
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Hooray! I did it myself!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "this test case (second to last one) forced me to use memoization.  if you\\'re shooting for 100% acceptance use this as your custom performance test.\\n\\ns1 = \"abababababababababababababababababababababababababababababababababababababababababababababababababbb\"\\ns2 = \"babababababababababababababababababababababababababababababababababababababababababababababababaaaba\"\\ns3 = \"abababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababbb\""
                    },
                    {
                        "username": "brunotg",
                        "content": "Why do we need to generate all the interleavings? I was trynig to have a pointer that moves along s1, another that moves along s2 and another that moves along s3. \\n\\nAs long as you have the same characters on s1 as on s3, you move them both. An you do the same with s2 and s3.\\n"
                    },
                    {
                        "username": "packle",
                        "content": "same characters on s1 and s2, we do not know which ptr to move. have to branch and try both"
                    },
                    {
                        "username": "humaocheng75",
                        "content": "I got timeout..."
                    },
                    {
                        "username": "vdas53073",
                        "content": "i was doing the same and in example 2 it gives true according to my logic but don\\'t know why it is false"
                    },
                    {
                        "username": "1711",
                        "content": "maybe it\\'s very hard"
                    },
                    {
                        "username": "anurag_819",
                        "content": "Can anyone pls explain me this testcase?\\n\\ns1= \"aaaa\"\\ns2= \"aa\"\\ns3= \"aaa\"\\n\\nThe expected output is false."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@kdhjd](/kdhjd) Why would that matter? If we have two strings, \"a\" and \"bbbb\" then \"bbabb\" should be a valid interleaving, even though the difference of their lengths is 3. "
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@kdhjd](/kdhjd) \n`s3` is formed by **interleaving** `s1` and `s2`. therefore, `s3.length == s1.length + s2.length`. \nidk why they put `|n -m| <= 1` as one of the conditions but surely they did NOT say `n` is `s1.length` and `m` is `s2.length`.\nbtw, i did nothing with that `|n -m| <= 1` and still got passed"
                    },
                    {
                        "username": "kdhjd",
                        "content": "The expected output is false as | len(s1)-len(s2) | > 1."
                    },
                    {
                        "username": "chirag019",
                        "content": "Additional info: \n- You can't use a character twice.\n- You have to necessarily use all the characters of s1 and s2.\n\nTip:\n- Initialize two pointers, say `i` and `j` for `s1` and `s2` resp. No need for an explicit pointer for `s3`, since it will always be equal to `i+j`"
                    }
                ]
            },
            {
                "id": 1576218,
                "content": [
                    {
                        "username": "merce",
                        "content": "If s1 = \"a\" and s2 = \"b\" and s3 = \"aba\" \\n\\nWhy isn't this a valid interleaving?? Sorry if I seem stupid."
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "BECASE THE QUANTITY OF \\'a\\' is over by using it frst time in \"aba\""
                    },
                    {
                        "username": "northern-flower",
                        "content": "Because s3 should contain all the characters of both s1 and s2.. Actually in my code if the length of s3 is not the sum of the lengths of s1 and s2 - I am already returning \\'false\\' as a result, to speed up the checking process."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "*This problem is quite challenging.*\n**Here is a tip to overcome this challenge**\nThis problem involves finding whether a target string s3 can be formed by interleaving two given strings s1 and s2. An important observation is that the relative order of characters within each string needs to be maintained in the interleaved result.\n\nHere's a high-level approach to consider:\n\n**Dynamic Programming:** Consider using a dynamic programming approach. Create a 2D DP table where dp[i][j] represents whether the first i characters of s1 and the first j characters of s2 can form the first i+j characters of s3.\n\n**Base Cases:** Initialize the DP table with base cases. For example, dp[0][0] should be true, as both empty strings can form an empty string.\n\n**Recurrence Relation:** Build the DP table bottom-up using a recurrence relation. You can consider the following cases:\n\nIf the current character in s3 matches the current character in s1, you can check if the previous characters in s1 and s3 match and update dp[i][j] accordingly.\nSimilarly, if the current character in s3 matches the current character in s2, you can check if the previous characters in s2 and s3 match and update dp[i][j] accordingly.\nFinal Result: After filling the DP table, the value of dp[s1.length()][s2.length()] will indicate whether s3 can be formed by interleaving s1 and s2.\n\nRemember to handle the edge cases and index mapping properly while implementing the DP solution.\n\nGood luck! Dynamic programming can be powerful for such sequence-related problems.  "
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "Did I just solve this on my own \\uD83D\\uDE2D"
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good.... doesn\\'t it :)"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "can someone explain why we it is not problem of 3d dp but 2d? since 3 variables are changing,it should be 3D DP"
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "You can think of the third variable as the sum of the first two and that way you don\\'t have to keep track of all three of them."
                    },
                    {
                        "username": "humaocheng75",
                        "content": "because s3\\'s pointer is controlled by s1 and s2 directly... it is not independent..."
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Hooray! I did it myself!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "this test case (second to last one) forced me to use memoization.  if you\\'re shooting for 100% acceptance use this as your custom performance test.\\n\\ns1 = \"abababababababababababababababababababababababababababababababababababababababababababababababababbb\"\\ns2 = \"babababababababababababababababababababababababababababababababababababababababababababababababaaaba\"\\ns3 = \"abababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababbb\""
                    },
                    {
                        "username": "brunotg",
                        "content": "Why do we need to generate all the interleavings? I was trynig to have a pointer that moves along s1, another that moves along s2 and another that moves along s3. \\n\\nAs long as you have the same characters on s1 as on s3, you move them both. An you do the same with s2 and s3.\\n"
                    },
                    {
                        "username": "packle",
                        "content": "same characters on s1 and s2, we do not know which ptr to move. have to branch and try both"
                    },
                    {
                        "username": "humaocheng75",
                        "content": "I got timeout..."
                    },
                    {
                        "username": "vdas53073",
                        "content": "i was doing the same and in example 2 it gives true according to my logic but don\\'t know why it is false"
                    },
                    {
                        "username": "1711",
                        "content": "maybe it\\'s very hard"
                    },
                    {
                        "username": "anurag_819",
                        "content": "Can anyone pls explain me this testcase?\\n\\ns1= \"aaaa\"\\ns2= \"aa\"\\ns3= \"aaa\"\\n\\nThe expected output is false."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@kdhjd](/kdhjd) Why would that matter? If we have two strings, \"a\" and \"bbbb\" then \"bbabb\" should be a valid interleaving, even though the difference of their lengths is 3. "
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@kdhjd](/kdhjd) \n`s3` is formed by **interleaving** `s1` and `s2`. therefore, `s3.length == s1.length + s2.length`. \nidk why they put `|n -m| <= 1` as one of the conditions but surely they did NOT say `n` is `s1.length` and `m` is `s2.length`.\nbtw, i did nothing with that `|n -m| <= 1` and still got passed"
                    },
                    {
                        "username": "kdhjd",
                        "content": "The expected output is false as | len(s1)-len(s2) | > 1."
                    },
                    {
                        "username": "chirag019",
                        "content": "Additional info: \n- You can't use a character twice.\n- You have to necessarily use all the characters of s1 and s2.\n\nTip:\n- Initialize two pointers, say `i` and `j` for `s1` and `s2` resp. No need for an explicit pointer for `s3`, since it will always be equal to `i+j`"
                    }
                ]
            },
            {
                "id": 2029643,
                "content": [
                    {
                        "username": "merce",
                        "content": "If s1 = \"a\" and s2 = \"b\" and s3 = \"aba\" \\n\\nWhy isn't this a valid interleaving?? Sorry if I seem stupid."
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "BECASE THE QUANTITY OF \\'a\\' is over by using it frst time in \"aba\""
                    },
                    {
                        "username": "northern-flower",
                        "content": "Because s3 should contain all the characters of both s1 and s2.. Actually in my code if the length of s3 is not the sum of the lengths of s1 and s2 - I am already returning \\'false\\' as a result, to speed up the checking process."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "*This problem is quite challenging.*\n**Here is a tip to overcome this challenge**\nThis problem involves finding whether a target string s3 can be formed by interleaving two given strings s1 and s2. An important observation is that the relative order of characters within each string needs to be maintained in the interleaved result.\n\nHere's a high-level approach to consider:\n\n**Dynamic Programming:** Consider using a dynamic programming approach. Create a 2D DP table where dp[i][j] represents whether the first i characters of s1 and the first j characters of s2 can form the first i+j characters of s3.\n\n**Base Cases:** Initialize the DP table with base cases. For example, dp[0][0] should be true, as both empty strings can form an empty string.\n\n**Recurrence Relation:** Build the DP table bottom-up using a recurrence relation. You can consider the following cases:\n\nIf the current character in s3 matches the current character in s1, you can check if the previous characters in s1 and s3 match and update dp[i][j] accordingly.\nSimilarly, if the current character in s3 matches the current character in s2, you can check if the previous characters in s2 and s3 match and update dp[i][j] accordingly.\nFinal Result: After filling the DP table, the value of dp[s1.length()][s2.length()] will indicate whether s3 can be formed by interleaving s1 and s2.\n\nRemember to handle the edge cases and index mapping properly while implementing the DP solution.\n\nGood luck! Dynamic programming can be powerful for such sequence-related problems.  "
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "Did I just solve this on my own \\uD83D\\uDE2D"
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good.... doesn\\'t it :)"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "can someone explain why we it is not problem of 3d dp but 2d? since 3 variables are changing,it should be 3D DP"
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "You can think of the third variable as the sum of the first two and that way you don\\'t have to keep track of all three of them."
                    },
                    {
                        "username": "humaocheng75",
                        "content": "because s3\\'s pointer is controlled by s1 and s2 directly... it is not independent..."
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Hooray! I did it myself!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "this test case (second to last one) forced me to use memoization.  if you\\'re shooting for 100% acceptance use this as your custom performance test.\\n\\ns1 = \"abababababababababababababababababababababababababababababababababababababababababababababababababbb\"\\ns2 = \"babababababababababababababababababababababababababababababababababababababababababababababababaaaba\"\\ns3 = \"abababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababbb\""
                    },
                    {
                        "username": "brunotg",
                        "content": "Why do we need to generate all the interleavings? I was trynig to have a pointer that moves along s1, another that moves along s2 and another that moves along s3. \\n\\nAs long as you have the same characters on s1 as on s3, you move them both. An you do the same with s2 and s3.\\n"
                    },
                    {
                        "username": "packle",
                        "content": "same characters on s1 and s2, we do not know which ptr to move. have to branch and try both"
                    },
                    {
                        "username": "humaocheng75",
                        "content": "I got timeout..."
                    },
                    {
                        "username": "vdas53073",
                        "content": "i was doing the same and in example 2 it gives true according to my logic but don\\'t know why it is false"
                    },
                    {
                        "username": "1711",
                        "content": "maybe it\\'s very hard"
                    },
                    {
                        "username": "anurag_819",
                        "content": "Can anyone pls explain me this testcase?\\n\\ns1= \"aaaa\"\\ns2= \"aa\"\\ns3= \"aaa\"\\n\\nThe expected output is false."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@kdhjd](/kdhjd) Why would that matter? If we have two strings, \"a\" and \"bbbb\" then \"bbabb\" should be a valid interleaving, even though the difference of their lengths is 3. "
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@kdhjd](/kdhjd) \n`s3` is formed by **interleaving** `s1` and `s2`. therefore, `s3.length == s1.length + s2.length`. \nidk why they put `|n -m| <= 1` as one of the conditions but surely they did NOT say `n` is `s1.length` and `m` is `s2.length`.\nbtw, i did nothing with that `|n -m| <= 1` and still got passed"
                    },
                    {
                        "username": "kdhjd",
                        "content": "The expected output is false as | len(s1)-len(s2) | > 1."
                    },
                    {
                        "username": "chirag019",
                        "content": "Additional info: \n- You can't use a character twice.\n- You have to necessarily use all the characters of s1 and s2.\n\nTip:\n- Initialize two pointers, say `i` and `j` for `s1` and `s2` resp. No need for an explicit pointer for `s3`, since it will always be equal to `i+j`"
                    }
                ]
            },
            {
                "id": 2029496,
                "content": [
                    {
                        "username": "merce",
                        "content": "If s1 = \"a\" and s2 = \"b\" and s3 = \"aba\" \\n\\nWhy isn't this a valid interleaving?? Sorry if I seem stupid."
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "BECASE THE QUANTITY OF \\'a\\' is over by using it frst time in \"aba\""
                    },
                    {
                        "username": "northern-flower",
                        "content": "Because s3 should contain all the characters of both s1 and s2.. Actually in my code if the length of s3 is not the sum of the lengths of s1 and s2 - I am already returning \\'false\\' as a result, to speed up the checking process."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "*This problem is quite challenging.*\n**Here is a tip to overcome this challenge**\nThis problem involves finding whether a target string s3 can be formed by interleaving two given strings s1 and s2. An important observation is that the relative order of characters within each string needs to be maintained in the interleaved result.\n\nHere's a high-level approach to consider:\n\n**Dynamic Programming:** Consider using a dynamic programming approach. Create a 2D DP table where dp[i][j] represents whether the first i characters of s1 and the first j characters of s2 can form the first i+j characters of s3.\n\n**Base Cases:** Initialize the DP table with base cases. For example, dp[0][0] should be true, as both empty strings can form an empty string.\n\n**Recurrence Relation:** Build the DP table bottom-up using a recurrence relation. You can consider the following cases:\n\nIf the current character in s3 matches the current character in s1, you can check if the previous characters in s1 and s3 match and update dp[i][j] accordingly.\nSimilarly, if the current character in s3 matches the current character in s2, you can check if the previous characters in s2 and s3 match and update dp[i][j] accordingly.\nFinal Result: After filling the DP table, the value of dp[s1.length()][s2.length()] will indicate whether s3 can be formed by interleaving s1 and s2.\n\nRemember to handle the edge cases and index mapping properly while implementing the DP solution.\n\nGood luck! Dynamic programming can be powerful for such sequence-related problems.  "
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "Did I just solve this on my own \\uD83D\\uDE2D"
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good.... doesn\\'t it :)"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "can someone explain why we it is not problem of 3d dp but 2d? since 3 variables are changing,it should be 3D DP"
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "You can think of the third variable as the sum of the first two and that way you don\\'t have to keep track of all three of them."
                    },
                    {
                        "username": "humaocheng75",
                        "content": "because s3\\'s pointer is controlled by s1 and s2 directly... it is not independent..."
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Hooray! I did it myself!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "this test case (second to last one) forced me to use memoization.  if you\\'re shooting for 100% acceptance use this as your custom performance test.\\n\\ns1 = \"abababababababababababababababababababababababababababababababababababababababababababababababababbb\"\\ns2 = \"babababababababababababababababababababababababababababababababababababababababababababababababaaaba\"\\ns3 = \"abababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababbb\""
                    },
                    {
                        "username": "brunotg",
                        "content": "Why do we need to generate all the interleavings? I was trynig to have a pointer that moves along s1, another that moves along s2 and another that moves along s3. \\n\\nAs long as you have the same characters on s1 as on s3, you move them both. An you do the same with s2 and s3.\\n"
                    },
                    {
                        "username": "packle",
                        "content": "same characters on s1 and s2, we do not know which ptr to move. have to branch and try both"
                    },
                    {
                        "username": "humaocheng75",
                        "content": "I got timeout..."
                    },
                    {
                        "username": "vdas53073",
                        "content": "i was doing the same and in example 2 it gives true according to my logic but don\\'t know why it is false"
                    },
                    {
                        "username": "1711",
                        "content": "maybe it\\'s very hard"
                    },
                    {
                        "username": "anurag_819",
                        "content": "Can anyone pls explain me this testcase?\\n\\ns1= \"aaaa\"\\ns2= \"aa\"\\ns3= \"aaa\"\\n\\nThe expected output is false."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@kdhjd](/kdhjd) Why would that matter? If we have two strings, \"a\" and \"bbbb\" then \"bbabb\" should be a valid interleaving, even though the difference of their lengths is 3. "
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@kdhjd](/kdhjd) \n`s3` is formed by **interleaving** `s1` and `s2`. therefore, `s3.length == s1.length + s2.length`. \nidk why they put `|n -m| <= 1` as one of the conditions but surely they did NOT say `n` is `s1.length` and `m` is `s2.length`.\nbtw, i did nothing with that `|n -m| <= 1` and still got passed"
                    },
                    {
                        "username": "kdhjd",
                        "content": "The expected output is false as | len(s1)-len(s2) | > 1."
                    },
                    {
                        "username": "chirag019",
                        "content": "Additional info: \n- You can't use a character twice.\n- You have to necessarily use all the characters of s1 and s2.\n\nTip:\n- Initialize two pointers, say `i` and `j` for `s1` and `s2` resp. No need for an explicit pointer for `s3`, since it will always be equal to `i+j`"
                    }
                ]
            },
            {
                "id": 2029343,
                "content": [
                    {
                        "username": "merce",
                        "content": "If s1 = \"a\" and s2 = \"b\" and s3 = \"aba\" \\n\\nWhy isn't this a valid interleaving?? Sorry if I seem stupid."
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "BECASE THE QUANTITY OF \\'a\\' is over by using it frst time in \"aba\""
                    },
                    {
                        "username": "northern-flower",
                        "content": "Because s3 should contain all the characters of both s1 and s2.. Actually in my code if the length of s3 is not the sum of the lengths of s1 and s2 - I am already returning \\'false\\' as a result, to speed up the checking process."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "*This problem is quite challenging.*\n**Here is a tip to overcome this challenge**\nThis problem involves finding whether a target string s3 can be formed by interleaving two given strings s1 and s2. An important observation is that the relative order of characters within each string needs to be maintained in the interleaved result.\n\nHere's a high-level approach to consider:\n\n**Dynamic Programming:** Consider using a dynamic programming approach. Create a 2D DP table where dp[i][j] represents whether the first i characters of s1 and the first j characters of s2 can form the first i+j characters of s3.\n\n**Base Cases:** Initialize the DP table with base cases. For example, dp[0][0] should be true, as both empty strings can form an empty string.\n\n**Recurrence Relation:** Build the DP table bottom-up using a recurrence relation. You can consider the following cases:\n\nIf the current character in s3 matches the current character in s1, you can check if the previous characters in s1 and s3 match and update dp[i][j] accordingly.\nSimilarly, if the current character in s3 matches the current character in s2, you can check if the previous characters in s2 and s3 match and update dp[i][j] accordingly.\nFinal Result: After filling the DP table, the value of dp[s1.length()][s2.length()] will indicate whether s3 can be formed by interleaving s1 and s2.\n\nRemember to handle the edge cases and index mapping properly while implementing the DP solution.\n\nGood luck! Dynamic programming can be powerful for such sequence-related problems.  "
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "Did I just solve this on my own \\uD83D\\uDE2D"
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "It feels good.... doesn\\'t it :)"
                    },
                    {
                        "username": "rvrishav7",
                        "content": "can someone explain why we it is not problem of 3d dp but 2d? since 3 variables are changing,it should be 3D DP"
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "You can think of the third variable as the sum of the first two and that way you don\\'t have to keep track of all three of them."
                    },
                    {
                        "username": "humaocheng75",
                        "content": "because s3\\'s pointer is controlled by s1 and s2 directly... it is not independent..."
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Hooray! I did it myself!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "this test case (second to last one) forced me to use memoization.  if you\\'re shooting for 100% acceptance use this as your custom performance test.\\n\\ns1 = \"abababababababababababababababababababababababababababababababababababababababababababababababababbb\"\\ns2 = \"babababababababababababababababababababababababababababababababababababababababababababababababaaaba\"\\ns3 = \"abababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababbb\""
                    },
                    {
                        "username": "brunotg",
                        "content": "Why do we need to generate all the interleavings? I was trynig to have a pointer that moves along s1, another that moves along s2 and another that moves along s3. \\n\\nAs long as you have the same characters on s1 as on s3, you move them both. An you do the same with s2 and s3.\\n"
                    },
                    {
                        "username": "packle",
                        "content": "same characters on s1 and s2, we do not know which ptr to move. have to branch and try both"
                    },
                    {
                        "username": "humaocheng75",
                        "content": "I got timeout..."
                    },
                    {
                        "username": "vdas53073",
                        "content": "i was doing the same and in example 2 it gives true according to my logic but don\\'t know why it is false"
                    },
                    {
                        "username": "1711",
                        "content": "maybe it\\'s very hard"
                    },
                    {
                        "username": "anurag_819",
                        "content": "Can anyone pls explain me this testcase?\\n\\ns1= \"aaaa\"\\ns2= \"aa\"\\ns3= \"aaa\"\\n\\nThe expected output is false."
                    },
                    {
                        "username": "0x6B0",
                        "content": "[@kdhjd](/kdhjd) Why would that matter? If we have two strings, \"a\" and \"bbbb\" then \"bbabb\" should be a valid interleaving, even though the difference of their lengths is 3. "
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@kdhjd](/kdhjd) \n`s3` is formed by **interleaving** `s1` and `s2`. therefore, `s3.length == s1.length + s2.length`. \nidk why they put `|n -m| <= 1` as one of the conditions but surely they did NOT say `n` is `s1.length` and `m` is `s2.length`.\nbtw, i did nothing with that `|n -m| <= 1` and still got passed"
                    },
                    {
                        "username": "kdhjd",
                        "content": "The expected output is false as | len(s1)-len(s2) | > 1."
                    },
                    {
                        "username": "chirag019",
                        "content": "Additional info: \n- You can't use a character twice.\n- You have to necessarily use all the characters of s1 and s2.\n\nTip:\n- Initialize two pointers, say `i` and `j` for `s1` and `s2` resp. No need for an explicit pointer for `s3`, since it will always be equal to `i+j`"
                    }
                ]
            },
            {
                "id": 2029121,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nSee this before the solution.\\n\\nSo the trick here is to how to implement this alternate selection of substrings. I am pretty much sure you have concluded that we need recursion to solve this, but how to ensure that when we append the string, it is the way it\\'s mentioned.\\n\\nWhat you need to do it, instead of appending substrings, append character of strings. At each iteration, check if `s1[i] == s3[i+j]` and below that check `s2[j] == s3[i+j]`. \\n\\nOn satisfaction , call again the function with incremented i or j.\\n\\nThis way, if you observe, you will have implemented the above condition of alternating substrings.\\n\\nIn base case,\\n\\n` if temp == s3,` return `true`.\\n\\n`if i == s1.length() `return `temp+s2.subtr(j) == s3.`\\n\\n`if j == s2.length() `return `temp+s1.substr(i) == s3.`"
                    },
                    {
                        "username": "sergei99",
                        "content": "Would it even complete within time limit?"
                    },
                    {
                        "username": "xfffrank",
                        "content": "Did someone find this one a lot more difficult than other DP problems like \"63. Unique Paths II\\n\"..."
                    },
                    {
                        "username": "luoyunfeng1853",
                        "content": "Anyone can explain this constraint |n - m| <= 1?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "means if you split s1 into 3 parts, you must split s2 either to 2, 3 or 4 parts.\\n|3-2| = 1\\n|3-3| = 0\\n|3-4| = 1"
                    },
                    {
                        "username": "patilc125",
                        "content": "n-m==0 or n-m==-1 or n-m==1"
                    },
                    {
                        "username": "upendrabartwalymail",
                        "content": "s1:\"\"\\ns2:\"\"\\ns3:\"a\"\\nwhy this should return false?\\na empty string is part of all string so this should be true. Help me!\\n"
                    },
                    {
                        "username": "northern-flower",
                        "content": "Because the length of s3 is not the sum of the lengths s1 and s2."
                    },
                    {
                        "username": "alik",
                        "content": "It's quite easy to solve it using recursion but the result is \"Time Limit Exceeded\" on some very long input.\\nI can convert the recursion to a for loop, but it's quite tedious and I feel I'm missing the whole point of the question.\\nIs there some kind of a trick here?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "The reason you are getting TLE is because you are making the same calculations many times. In other words, assuming you use a 2 pointer approach, where i and j point to the current character you are considering for s1 and s2 respectively. you get the same i and j  many times. \\n\\nTo avoid this you can use memo. where the key is something like `${i}-${j}` so that you just stop when you get the same i and j, because you know you have already made that specific calculation. In a 2d dp array you do essentially the same thing, but more elegantly, but I am not entirely sure how. "
                    },
                    {
                        "username": "sergei99",
                        "content": "My first solution was a loop with a vector-based stack of todo items. But it exceeded the time limit as well. Recusion seems to give a consistenly bad rating on memory usage, let alone exponential time in this particular case.\nP.S. Can't believe this task is there for 10 years already. They gave it to me as a daily challenge... indeed it took half a day."
                    },
                    {
                        "username": "northern-flower",
                        "content": "You can use 2 pointers - one in s1 and another in s2 and move the respective one when you find the character of s3 in one of them"
                    },
                    {
                        "username": "rv14",
                        "content": "# I could not understand this program. Please help me to make me understand.\\n\\n\\n# Thank You ...."
                    },
                    {
                        "username": "strawhatdragon",
                        "content": "Need help with the 1D implementation for this.\n```\nclass Solution {\n    public boolean isInterleave(String s1, String s2, String s3) {\n        int m = s1.length();\n        int n = s2.length();\n        if(m + n != s3.length()) return false;\n        boolean[] next = new boolean[n+1];\n        next[n] = true;\n        for(int i = m-1; i >= 0; i--) {\n            boolean[] curr = new boolean[n+1];\n            for(int j = n; j >= 0; j--) {\n                if(i < s1.length() && s1.charAt(i) == s3.charAt(i+j) && next[j]) {\n                    curr[j] = next[j];\n                }\n                if(j < s2.length() && s2.charAt(j) == s3.charAt(i+j) && curr[j+1]) {\n                    curr[j] = curr[j+1];\n                }\n            }\n            next = curr;\n        }\n        return next[0];\n    }\n}\n```"
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "Can anyone give example for repeating subproblem in this question"
                    },
                    {
                        "username": "olsonpm",
                        "content": "the edge cases on this problem are extremely stupid.  Empty strings should be removed via constraints because the result makes no sense.  Why would 'a', 'b', 'a' be false but 'a', '', 'a' output true, yet '', 'abc', 'ab'  is false ?  Interview problems should have some level of intuition because otherwise we're guess'n'checking the author's mind"
                    },
                    {
                        "username": "tifv",
                        "content": "I don\\'t see the need to guess anyone\\'s mind, at least not in this particular problem. Its description is quite precise, one just needs to read it carefully.\\nIn particular, empty string can be represented as a concatenation of one empty substring (like `n = 1` or `m = 1`).\\nAll the other examples you list should obviously output false, since for `s3` to be an interleaving, its length must be the sum of lengths of `s1` and `s2`."
                    },
                    {
                        "username": "quan_mai",
                        "content": "string + dp = best combo!"
                    }
                ]
            },
            {
                "id": 1944239,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nSee this before the solution.\\n\\nSo the trick here is to how to implement this alternate selection of substrings. I am pretty much sure you have concluded that we need recursion to solve this, but how to ensure that when we append the string, it is the way it\\'s mentioned.\\n\\nWhat you need to do it, instead of appending substrings, append character of strings. At each iteration, check if `s1[i] == s3[i+j]` and below that check `s2[j] == s3[i+j]`. \\n\\nOn satisfaction , call again the function with incremented i or j.\\n\\nThis way, if you observe, you will have implemented the above condition of alternating substrings.\\n\\nIn base case,\\n\\n` if temp == s3,` return `true`.\\n\\n`if i == s1.length() `return `temp+s2.subtr(j) == s3.`\\n\\n`if j == s2.length() `return `temp+s1.substr(i) == s3.`"
                    },
                    {
                        "username": "sergei99",
                        "content": "Would it even complete within time limit?"
                    },
                    {
                        "username": "xfffrank",
                        "content": "Did someone find this one a lot more difficult than other DP problems like \"63. Unique Paths II\\n\"..."
                    },
                    {
                        "username": "luoyunfeng1853",
                        "content": "Anyone can explain this constraint |n - m| <= 1?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "means if you split s1 into 3 parts, you must split s2 either to 2, 3 or 4 parts.\\n|3-2| = 1\\n|3-3| = 0\\n|3-4| = 1"
                    },
                    {
                        "username": "patilc125",
                        "content": "n-m==0 or n-m==-1 or n-m==1"
                    },
                    {
                        "username": "upendrabartwalymail",
                        "content": "s1:\"\"\\ns2:\"\"\\ns3:\"a\"\\nwhy this should return false?\\na empty string is part of all string so this should be true. Help me!\\n"
                    },
                    {
                        "username": "northern-flower",
                        "content": "Because the length of s3 is not the sum of the lengths s1 and s2."
                    },
                    {
                        "username": "alik",
                        "content": "It's quite easy to solve it using recursion but the result is \"Time Limit Exceeded\" on some very long input.\\nI can convert the recursion to a for loop, but it's quite tedious and I feel I'm missing the whole point of the question.\\nIs there some kind of a trick here?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "The reason you are getting TLE is because you are making the same calculations many times. In other words, assuming you use a 2 pointer approach, where i and j point to the current character you are considering for s1 and s2 respectively. you get the same i and j  many times. \\n\\nTo avoid this you can use memo. where the key is something like `${i}-${j}` so that you just stop when you get the same i and j, because you know you have already made that specific calculation. In a 2d dp array you do essentially the same thing, but more elegantly, but I am not entirely sure how. "
                    },
                    {
                        "username": "sergei99",
                        "content": "My first solution was a loop with a vector-based stack of todo items. But it exceeded the time limit as well. Recusion seems to give a consistenly bad rating on memory usage, let alone exponential time in this particular case.\nP.S. Can't believe this task is there for 10 years already. They gave it to me as a daily challenge... indeed it took half a day."
                    },
                    {
                        "username": "northern-flower",
                        "content": "You can use 2 pointers - one in s1 and another in s2 and move the respective one when you find the character of s3 in one of them"
                    },
                    {
                        "username": "rv14",
                        "content": "# I could not understand this program. Please help me to make me understand.\\n\\n\\n# Thank You ...."
                    },
                    {
                        "username": "strawhatdragon",
                        "content": "Need help with the 1D implementation for this.\n```\nclass Solution {\n    public boolean isInterleave(String s1, String s2, String s3) {\n        int m = s1.length();\n        int n = s2.length();\n        if(m + n != s3.length()) return false;\n        boolean[] next = new boolean[n+1];\n        next[n] = true;\n        for(int i = m-1; i >= 0; i--) {\n            boolean[] curr = new boolean[n+1];\n            for(int j = n; j >= 0; j--) {\n                if(i < s1.length() && s1.charAt(i) == s3.charAt(i+j) && next[j]) {\n                    curr[j] = next[j];\n                }\n                if(j < s2.length() && s2.charAt(j) == s3.charAt(i+j) && curr[j+1]) {\n                    curr[j] = curr[j+1];\n                }\n            }\n            next = curr;\n        }\n        return next[0];\n    }\n}\n```"
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "Can anyone give example for repeating subproblem in this question"
                    },
                    {
                        "username": "olsonpm",
                        "content": "the edge cases on this problem are extremely stupid.  Empty strings should be removed via constraints because the result makes no sense.  Why would 'a', 'b', 'a' be false but 'a', '', 'a' output true, yet '', 'abc', 'ab'  is false ?  Interview problems should have some level of intuition because otherwise we're guess'n'checking the author's mind"
                    },
                    {
                        "username": "tifv",
                        "content": "I don\\'t see the need to guess anyone\\'s mind, at least not in this particular problem. Its description is quite precise, one just needs to read it carefully.\\nIn particular, empty string can be represented as a concatenation of one empty substring (like `n = 1` or `m = 1`).\\nAll the other examples you list should obviously output false, since for `s3` to be an interleaving, its length must be the sum of lengths of `s1` and `s2`."
                    },
                    {
                        "username": "quan_mai",
                        "content": "string + dp = best combo!"
                    }
                ]
            },
            {
                "id": 1575375,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nSee this before the solution.\\n\\nSo the trick here is to how to implement this alternate selection of substrings. I am pretty much sure you have concluded that we need recursion to solve this, but how to ensure that when we append the string, it is the way it\\'s mentioned.\\n\\nWhat you need to do it, instead of appending substrings, append character of strings. At each iteration, check if `s1[i] == s3[i+j]` and below that check `s2[j] == s3[i+j]`. \\n\\nOn satisfaction , call again the function with incremented i or j.\\n\\nThis way, if you observe, you will have implemented the above condition of alternating substrings.\\n\\nIn base case,\\n\\n` if temp == s3,` return `true`.\\n\\n`if i == s1.length() `return `temp+s2.subtr(j) == s3.`\\n\\n`if j == s2.length() `return `temp+s1.substr(i) == s3.`"
                    },
                    {
                        "username": "sergei99",
                        "content": "Would it even complete within time limit?"
                    },
                    {
                        "username": "xfffrank",
                        "content": "Did someone find this one a lot more difficult than other DP problems like \"63. Unique Paths II\\n\"..."
                    },
                    {
                        "username": "luoyunfeng1853",
                        "content": "Anyone can explain this constraint |n - m| <= 1?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "means if you split s1 into 3 parts, you must split s2 either to 2, 3 or 4 parts.\\n|3-2| = 1\\n|3-3| = 0\\n|3-4| = 1"
                    },
                    {
                        "username": "patilc125",
                        "content": "n-m==0 or n-m==-1 or n-m==1"
                    },
                    {
                        "username": "upendrabartwalymail",
                        "content": "s1:\"\"\\ns2:\"\"\\ns3:\"a\"\\nwhy this should return false?\\na empty string is part of all string so this should be true. Help me!\\n"
                    },
                    {
                        "username": "northern-flower",
                        "content": "Because the length of s3 is not the sum of the lengths s1 and s2."
                    },
                    {
                        "username": "alik",
                        "content": "It's quite easy to solve it using recursion but the result is \"Time Limit Exceeded\" on some very long input.\\nI can convert the recursion to a for loop, but it's quite tedious and I feel I'm missing the whole point of the question.\\nIs there some kind of a trick here?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "The reason you are getting TLE is because you are making the same calculations many times. In other words, assuming you use a 2 pointer approach, where i and j point to the current character you are considering for s1 and s2 respectively. you get the same i and j  many times. \\n\\nTo avoid this you can use memo. where the key is something like `${i}-${j}` so that you just stop when you get the same i and j, because you know you have already made that specific calculation. In a 2d dp array you do essentially the same thing, but more elegantly, but I am not entirely sure how. "
                    },
                    {
                        "username": "sergei99",
                        "content": "My first solution was a loop with a vector-based stack of todo items. But it exceeded the time limit as well. Recusion seems to give a consistenly bad rating on memory usage, let alone exponential time in this particular case.\nP.S. Can't believe this task is there for 10 years already. They gave it to me as a daily challenge... indeed it took half a day."
                    },
                    {
                        "username": "northern-flower",
                        "content": "You can use 2 pointers - one in s1 and another in s2 and move the respective one when you find the character of s3 in one of them"
                    },
                    {
                        "username": "rv14",
                        "content": "# I could not understand this program. Please help me to make me understand.\\n\\n\\n# Thank You ...."
                    },
                    {
                        "username": "strawhatdragon",
                        "content": "Need help with the 1D implementation for this.\n```\nclass Solution {\n    public boolean isInterleave(String s1, String s2, String s3) {\n        int m = s1.length();\n        int n = s2.length();\n        if(m + n != s3.length()) return false;\n        boolean[] next = new boolean[n+1];\n        next[n] = true;\n        for(int i = m-1; i >= 0; i--) {\n            boolean[] curr = new boolean[n+1];\n            for(int j = n; j >= 0; j--) {\n                if(i < s1.length() && s1.charAt(i) == s3.charAt(i+j) && next[j]) {\n                    curr[j] = next[j];\n                }\n                if(j < s2.length() && s2.charAt(j) == s3.charAt(i+j) && curr[j+1]) {\n                    curr[j] = curr[j+1];\n                }\n            }\n            next = curr;\n        }\n        return next[0];\n    }\n}\n```"
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "Can anyone give example for repeating subproblem in this question"
                    },
                    {
                        "username": "olsonpm",
                        "content": "the edge cases on this problem are extremely stupid.  Empty strings should be removed via constraints because the result makes no sense.  Why would 'a', 'b', 'a' be false but 'a', '', 'a' output true, yet '', 'abc', 'ab'  is false ?  Interview problems should have some level of intuition because otherwise we're guess'n'checking the author's mind"
                    },
                    {
                        "username": "tifv",
                        "content": "I don\\'t see the need to guess anyone\\'s mind, at least not in this particular problem. Its description is quite precise, one just needs to read it carefully.\\nIn particular, empty string can be represented as a concatenation of one empty substring (like `n = 1` or `m = 1`).\\nAll the other examples you list should obviously output false, since for `s3` to be an interleaving, its length must be the sum of lengths of `s1` and `s2`."
                    },
                    {
                        "username": "quan_mai",
                        "content": "string + dp = best combo!"
                    }
                ]
            },
            {
                "id": 1572625,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nSee this before the solution.\\n\\nSo the trick here is to how to implement this alternate selection of substrings. I am pretty much sure you have concluded that we need recursion to solve this, but how to ensure that when we append the string, it is the way it\\'s mentioned.\\n\\nWhat you need to do it, instead of appending substrings, append character of strings. At each iteration, check if `s1[i] == s3[i+j]` and below that check `s2[j] == s3[i+j]`. \\n\\nOn satisfaction , call again the function with incremented i or j.\\n\\nThis way, if you observe, you will have implemented the above condition of alternating substrings.\\n\\nIn base case,\\n\\n` if temp == s3,` return `true`.\\n\\n`if i == s1.length() `return `temp+s2.subtr(j) == s3.`\\n\\n`if j == s2.length() `return `temp+s1.substr(i) == s3.`"
                    },
                    {
                        "username": "sergei99",
                        "content": "Would it even complete within time limit?"
                    },
                    {
                        "username": "xfffrank",
                        "content": "Did someone find this one a lot more difficult than other DP problems like \"63. Unique Paths II\\n\"..."
                    },
                    {
                        "username": "luoyunfeng1853",
                        "content": "Anyone can explain this constraint |n - m| <= 1?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "means if you split s1 into 3 parts, you must split s2 either to 2, 3 or 4 parts.\\n|3-2| = 1\\n|3-3| = 0\\n|3-4| = 1"
                    },
                    {
                        "username": "patilc125",
                        "content": "n-m==0 or n-m==-1 or n-m==1"
                    },
                    {
                        "username": "upendrabartwalymail",
                        "content": "s1:\"\"\\ns2:\"\"\\ns3:\"a\"\\nwhy this should return false?\\na empty string is part of all string so this should be true. Help me!\\n"
                    },
                    {
                        "username": "northern-flower",
                        "content": "Because the length of s3 is not the sum of the lengths s1 and s2."
                    },
                    {
                        "username": "alik",
                        "content": "It's quite easy to solve it using recursion but the result is \"Time Limit Exceeded\" on some very long input.\\nI can convert the recursion to a for loop, but it's quite tedious and I feel I'm missing the whole point of the question.\\nIs there some kind of a trick here?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "The reason you are getting TLE is because you are making the same calculations many times. In other words, assuming you use a 2 pointer approach, where i and j point to the current character you are considering for s1 and s2 respectively. you get the same i and j  many times. \\n\\nTo avoid this you can use memo. where the key is something like `${i}-${j}` so that you just stop when you get the same i and j, because you know you have already made that specific calculation. In a 2d dp array you do essentially the same thing, but more elegantly, but I am not entirely sure how. "
                    },
                    {
                        "username": "sergei99",
                        "content": "My first solution was a loop with a vector-based stack of todo items. But it exceeded the time limit as well. Recusion seems to give a consistenly bad rating on memory usage, let alone exponential time in this particular case.\nP.S. Can't believe this task is there for 10 years already. They gave it to me as a daily challenge... indeed it took half a day."
                    },
                    {
                        "username": "northern-flower",
                        "content": "You can use 2 pointers - one in s1 and another in s2 and move the respective one when you find the character of s3 in one of them"
                    },
                    {
                        "username": "rv14",
                        "content": "# I could not understand this program. Please help me to make me understand.\\n\\n\\n# Thank You ...."
                    },
                    {
                        "username": "strawhatdragon",
                        "content": "Need help with the 1D implementation for this.\n```\nclass Solution {\n    public boolean isInterleave(String s1, String s2, String s3) {\n        int m = s1.length();\n        int n = s2.length();\n        if(m + n != s3.length()) return false;\n        boolean[] next = new boolean[n+1];\n        next[n] = true;\n        for(int i = m-1; i >= 0; i--) {\n            boolean[] curr = new boolean[n+1];\n            for(int j = n; j >= 0; j--) {\n                if(i < s1.length() && s1.charAt(i) == s3.charAt(i+j) && next[j]) {\n                    curr[j] = next[j];\n                }\n                if(j < s2.length() && s2.charAt(j) == s3.charAt(i+j) && curr[j+1]) {\n                    curr[j] = curr[j+1];\n                }\n            }\n            next = curr;\n        }\n        return next[0];\n    }\n}\n```"
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "Can anyone give example for repeating subproblem in this question"
                    },
                    {
                        "username": "olsonpm",
                        "content": "the edge cases on this problem are extremely stupid.  Empty strings should be removed via constraints because the result makes no sense.  Why would 'a', 'b', 'a' be false but 'a', '', 'a' output true, yet '', 'abc', 'ab'  is false ?  Interview problems should have some level of intuition because otherwise we're guess'n'checking the author's mind"
                    },
                    {
                        "username": "tifv",
                        "content": "I don\\'t see the need to guess anyone\\'s mind, at least not in this particular problem. Its description is quite precise, one just needs to read it carefully.\\nIn particular, empty string can be represented as a concatenation of one empty substring (like `n = 1` or `m = 1`).\\nAll the other examples you list should obviously output false, since for `s3` to be an interleaving, its length must be the sum of lengths of `s1` and `s2`."
                    },
                    {
                        "username": "quan_mai",
                        "content": "string + dp = best combo!"
                    }
                ]
            },
            {
                "id": 1571211,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nSee this before the solution.\\n\\nSo the trick here is to how to implement this alternate selection of substrings. I am pretty much sure you have concluded that we need recursion to solve this, but how to ensure that when we append the string, it is the way it\\'s mentioned.\\n\\nWhat you need to do it, instead of appending substrings, append character of strings. At each iteration, check if `s1[i] == s3[i+j]` and below that check `s2[j] == s3[i+j]`. \\n\\nOn satisfaction , call again the function with incremented i or j.\\n\\nThis way, if you observe, you will have implemented the above condition of alternating substrings.\\n\\nIn base case,\\n\\n` if temp == s3,` return `true`.\\n\\n`if i == s1.length() `return `temp+s2.subtr(j) == s3.`\\n\\n`if j == s2.length() `return `temp+s1.substr(i) == s3.`"
                    },
                    {
                        "username": "sergei99",
                        "content": "Would it even complete within time limit?"
                    },
                    {
                        "username": "xfffrank",
                        "content": "Did someone find this one a lot more difficult than other DP problems like \"63. Unique Paths II\\n\"..."
                    },
                    {
                        "username": "luoyunfeng1853",
                        "content": "Anyone can explain this constraint |n - m| <= 1?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "means if you split s1 into 3 parts, you must split s2 either to 2, 3 or 4 parts.\\n|3-2| = 1\\n|3-3| = 0\\n|3-4| = 1"
                    },
                    {
                        "username": "patilc125",
                        "content": "n-m==0 or n-m==-1 or n-m==1"
                    },
                    {
                        "username": "upendrabartwalymail",
                        "content": "s1:\"\"\\ns2:\"\"\\ns3:\"a\"\\nwhy this should return false?\\na empty string is part of all string so this should be true. Help me!\\n"
                    },
                    {
                        "username": "northern-flower",
                        "content": "Because the length of s3 is not the sum of the lengths s1 and s2."
                    },
                    {
                        "username": "alik",
                        "content": "It's quite easy to solve it using recursion but the result is \"Time Limit Exceeded\" on some very long input.\\nI can convert the recursion to a for loop, but it's quite tedious and I feel I'm missing the whole point of the question.\\nIs there some kind of a trick here?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "The reason you are getting TLE is because you are making the same calculations many times. In other words, assuming you use a 2 pointer approach, where i and j point to the current character you are considering for s1 and s2 respectively. you get the same i and j  many times. \\n\\nTo avoid this you can use memo. where the key is something like `${i}-${j}` so that you just stop when you get the same i and j, because you know you have already made that specific calculation. In a 2d dp array you do essentially the same thing, but more elegantly, but I am not entirely sure how. "
                    },
                    {
                        "username": "sergei99",
                        "content": "My first solution was a loop with a vector-based stack of todo items. But it exceeded the time limit as well. Recusion seems to give a consistenly bad rating on memory usage, let alone exponential time in this particular case.\nP.S. Can't believe this task is there for 10 years already. They gave it to me as a daily challenge... indeed it took half a day."
                    },
                    {
                        "username": "northern-flower",
                        "content": "You can use 2 pointers - one in s1 and another in s2 and move the respective one when you find the character of s3 in one of them"
                    },
                    {
                        "username": "rv14",
                        "content": "# I could not understand this program. Please help me to make me understand.\\n\\n\\n# Thank You ...."
                    },
                    {
                        "username": "strawhatdragon",
                        "content": "Need help with the 1D implementation for this.\n```\nclass Solution {\n    public boolean isInterleave(String s1, String s2, String s3) {\n        int m = s1.length();\n        int n = s2.length();\n        if(m + n != s3.length()) return false;\n        boolean[] next = new boolean[n+1];\n        next[n] = true;\n        for(int i = m-1; i >= 0; i--) {\n            boolean[] curr = new boolean[n+1];\n            for(int j = n; j >= 0; j--) {\n                if(i < s1.length() && s1.charAt(i) == s3.charAt(i+j) && next[j]) {\n                    curr[j] = next[j];\n                }\n                if(j < s2.length() && s2.charAt(j) == s3.charAt(i+j) && curr[j+1]) {\n                    curr[j] = curr[j+1];\n                }\n            }\n            next = curr;\n        }\n        return next[0];\n    }\n}\n```"
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "Can anyone give example for repeating subproblem in this question"
                    },
                    {
                        "username": "olsonpm",
                        "content": "the edge cases on this problem are extremely stupid.  Empty strings should be removed via constraints because the result makes no sense.  Why would 'a', 'b', 'a' be false but 'a', '', 'a' output true, yet '', 'abc', 'ab'  is false ?  Interview problems should have some level of intuition because otherwise we're guess'n'checking the author's mind"
                    },
                    {
                        "username": "tifv",
                        "content": "I don\\'t see the need to guess anyone\\'s mind, at least not in this particular problem. Its description is quite precise, one just needs to read it carefully.\\nIn particular, empty string can be represented as a concatenation of one empty substring (like `n = 1` or `m = 1`).\\nAll the other examples you list should obviously output false, since for `s3` to be an interleaving, its length must be the sum of lengths of `s1` and `s2`."
                    },
                    {
                        "username": "quan_mai",
                        "content": "string + dp = best combo!"
                    }
                ]
            },
            {
                "id": 1575347,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nSee this before the solution.\\n\\nSo the trick here is to how to implement this alternate selection of substrings. I am pretty much sure you have concluded that we need recursion to solve this, but how to ensure that when we append the string, it is the way it\\'s mentioned.\\n\\nWhat you need to do it, instead of appending substrings, append character of strings. At each iteration, check if `s1[i] == s3[i+j]` and below that check `s2[j] == s3[i+j]`. \\n\\nOn satisfaction , call again the function with incremented i or j.\\n\\nThis way, if you observe, you will have implemented the above condition of alternating substrings.\\n\\nIn base case,\\n\\n` if temp == s3,` return `true`.\\n\\n`if i == s1.length() `return `temp+s2.subtr(j) == s3.`\\n\\n`if j == s2.length() `return `temp+s1.substr(i) == s3.`"
                    },
                    {
                        "username": "sergei99",
                        "content": "Would it even complete within time limit?"
                    },
                    {
                        "username": "xfffrank",
                        "content": "Did someone find this one a lot more difficult than other DP problems like \"63. Unique Paths II\\n\"..."
                    },
                    {
                        "username": "luoyunfeng1853",
                        "content": "Anyone can explain this constraint |n - m| <= 1?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "means if you split s1 into 3 parts, you must split s2 either to 2, 3 or 4 parts.\\n|3-2| = 1\\n|3-3| = 0\\n|3-4| = 1"
                    },
                    {
                        "username": "patilc125",
                        "content": "n-m==0 or n-m==-1 or n-m==1"
                    },
                    {
                        "username": "upendrabartwalymail",
                        "content": "s1:\"\"\\ns2:\"\"\\ns3:\"a\"\\nwhy this should return false?\\na empty string is part of all string so this should be true. Help me!\\n"
                    },
                    {
                        "username": "northern-flower",
                        "content": "Because the length of s3 is not the sum of the lengths s1 and s2."
                    },
                    {
                        "username": "alik",
                        "content": "It's quite easy to solve it using recursion but the result is \"Time Limit Exceeded\" on some very long input.\\nI can convert the recursion to a for loop, but it's quite tedious and I feel I'm missing the whole point of the question.\\nIs there some kind of a trick here?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "The reason you are getting TLE is because you are making the same calculations many times. In other words, assuming you use a 2 pointer approach, where i and j point to the current character you are considering for s1 and s2 respectively. you get the same i and j  many times. \\n\\nTo avoid this you can use memo. where the key is something like `${i}-${j}` so that you just stop when you get the same i and j, because you know you have already made that specific calculation. In a 2d dp array you do essentially the same thing, but more elegantly, but I am not entirely sure how. "
                    },
                    {
                        "username": "sergei99",
                        "content": "My first solution was a loop with a vector-based stack of todo items. But it exceeded the time limit as well. Recusion seems to give a consistenly bad rating on memory usage, let alone exponential time in this particular case.\nP.S. Can't believe this task is there for 10 years already. They gave it to me as a daily challenge... indeed it took half a day."
                    },
                    {
                        "username": "northern-flower",
                        "content": "You can use 2 pointers - one in s1 and another in s2 and move the respective one when you find the character of s3 in one of them"
                    },
                    {
                        "username": "rv14",
                        "content": "# I could not understand this program. Please help me to make me understand.\\n\\n\\n# Thank You ...."
                    },
                    {
                        "username": "strawhatdragon",
                        "content": "Need help with the 1D implementation for this.\n```\nclass Solution {\n    public boolean isInterleave(String s1, String s2, String s3) {\n        int m = s1.length();\n        int n = s2.length();\n        if(m + n != s3.length()) return false;\n        boolean[] next = new boolean[n+1];\n        next[n] = true;\n        for(int i = m-1; i >= 0; i--) {\n            boolean[] curr = new boolean[n+1];\n            for(int j = n; j >= 0; j--) {\n                if(i < s1.length() && s1.charAt(i) == s3.charAt(i+j) && next[j]) {\n                    curr[j] = next[j];\n                }\n                if(j < s2.length() && s2.charAt(j) == s3.charAt(i+j) && curr[j+1]) {\n                    curr[j] = curr[j+1];\n                }\n            }\n            next = curr;\n        }\n        return next[0];\n    }\n}\n```"
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "Can anyone give example for repeating subproblem in this question"
                    },
                    {
                        "username": "olsonpm",
                        "content": "the edge cases on this problem are extremely stupid.  Empty strings should be removed via constraints because the result makes no sense.  Why would 'a', 'b', 'a' be false but 'a', '', 'a' output true, yet '', 'abc', 'ab'  is false ?  Interview problems should have some level of intuition because otherwise we're guess'n'checking the author's mind"
                    },
                    {
                        "username": "tifv",
                        "content": "I don\\'t see the need to guess anyone\\'s mind, at least not in this particular problem. Its description is quite precise, one just needs to read it carefully.\\nIn particular, empty string can be represented as a concatenation of one empty substring (like `n = 1` or `m = 1`).\\nAll the other examples you list should obviously output false, since for `s3` to be an interleaving, its length must be the sum of lengths of `s1` and `s2`."
                    },
                    {
                        "username": "quan_mai",
                        "content": "string + dp = best combo!"
                    }
                ]
            },
            {
                "id": 2043146,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nSee this before the solution.\\n\\nSo the trick here is to how to implement this alternate selection of substrings. I am pretty much sure you have concluded that we need recursion to solve this, but how to ensure that when we append the string, it is the way it\\'s mentioned.\\n\\nWhat you need to do it, instead of appending substrings, append character of strings. At each iteration, check if `s1[i] == s3[i+j]` and below that check `s2[j] == s3[i+j]`. \\n\\nOn satisfaction , call again the function with incremented i or j.\\n\\nThis way, if you observe, you will have implemented the above condition of alternating substrings.\\n\\nIn base case,\\n\\n` if temp == s3,` return `true`.\\n\\n`if i == s1.length() `return `temp+s2.subtr(j) == s3.`\\n\\n`if j == s2.length() `return `temp+s1.substr(i) == s3.`"
                    },
                    {
                        "username": "sergei99",
                        "content": "Would it even complete within time limit?"
                    },
                    {
                        "username": "xfffrank",
                        "content": "Did someone find this one a lot more difficult than other DP problems like \"63. Unique Paths II\\n\"..."
                    },
                    {
                        "username": "luoyunfeng1853",
                        "content": "Anyone can explain this constraint |n - m| <= 1?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "means if you split s1 into 3 parts, you must split s2 either to 2, 3 or 4 parts.\\n|3-2| = 1\\n|3-3| = 0\\n|3-4| = 1"
                    },
                    {
                        "username": "patilc125",
                        "content": "n-m==0 or n-m==-1 or n-m==1"
                    },
                    {
                        "username": "upendrabartwalymail",
                        "content": "s1:\"\"\\ns2:\"\"\\ns3:\"a\"\\nwhy this should return false?\\na empty string is part of all string so this should be true. Help me!\\n"
                    },
                    {
                        "username": "northern-flower",
                        "content": "Because the length of s3 is not the sum of the lengths s1 and s2."
                    },
                    {
                        "username": "alik",
                        "content": "It's quite easy to solve it using recursion but the result is \"Time Limit Exceeded\" on some very long input.\\nI can convert the recursion to a for loop, but it's quite tedious and I feel I'm missing the whole point of the question.\\nIs there some kind of a trick here?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "The reason you are getting TLE is because you are making the same calculations many times. In other words, assuming you use a 2 pointer approach, where i and j point to the current character you are considering for s1 and s2 respectively. you get the same i and j  many times. \\n\\nTo avoid this you can use memo. where the key is something like `${i}-${j}` so that you just stop when you get the same i and j, because you know you have already made that specific calculation. In a 2d dp array you do essentially the same thing, but more elegantly, but I am not entirely sure how. "
                    },
                    {
                        "username": "sergei99",
                        "content": "My first solution was a loop with a vector-based stack of todo items. But it exceeded the time limit as well. Recusion seems to give a consistenly bad rating on memory usage, let alone exponential time in this particular case.\nP.S. Can't believe this task is there for 10 years already. They gave it to me as a daily challenge... indeed it took half a day."
                    },
                    {
                        "username": "northern-flower",
                        "content": "You can use 2 pointers - one in s1 and another in s2 and move the respective one when you find the character of s3 in one of them"
                    },
                    {
                        "username": "rv14",
                        "content": "# I could not understand this program. Please help me to make me understand.\\n\\n\\n# Thank You ...."
                    },
                    {
                        "username": "strawhatdragon",
                        "content": "Need help with the 1D implementation for this.\n```\nclass Solution {\n    public boolean isInterleave(String s1, String s2, String s3) {\n        int m = s1.length();\n        int n = s2.length();\n        if(m + n != s3.length()) return false;\n        boolean[] next = new boolean[n+1];\n        next[n] = true;\n        for(int i = m-1; i >= 0; i--) {\n            boolean[] curr = new boolean[n+1];\n            for(int j = n; j >= 0; j--) {\n                if(i < s1.length() && s1.charAt(i) == s3.charAt(i+j) && next[j]) {\n                    curr[j] = next[j];\n                }\n                if(j < s2.length() && s2.charAt(j) == s3.charAt(i+j) && curr[j+1]) {\n                    curr[j] = curr[j+1];\n                }\n            }\n            next = curr;\n        }\n        return next[0];\n    }\n}\n```"
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "Can anyone give example for repeating subproblem in this question"
                    },
                    {
                        "username": "olsonpm",
                        "content": "the edge cases on this problem are extremely stupid.  Empty strings should be removed via constraints because the result makes no sense.  Why would 'a', 'b', 'a' be false but 'a', '', 'a' output true, yet '', 'abc', 'ab'  is false ?  Interview problems should have some level of intuition because otherwise we're guess'n'checking the author's mind"
                    },
                    {
                        "username": "tifv",
                        "content": "I don\\'t see the need to guess anyone\\'s mind, at least not in this particular problem. Its description is quite precise, one just needs to read it carefully.\\nIn particular, empty string can be represented as a concatenation of one empty substring (like `n = 1` or `m = 1`).\\nAll the other examples you list should obviously output false, since for `s3` to be an interleaving, its length must be the sum of lengths of `s1` and `s2`."
                    },
                    {
                        "username": "quan_mai",
                        "content": "string + dp = best combo!"
                    }
                ]
            },
            {
                "id": 2032884,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nSee this before the solution.\\n\\nSo the trick here is to how to implement this alternate selection of substrings. I am pretty much sure you have concluded that we need recursion to solve this, but how to ensure that when we append the string, it is the way it\\'s mentioned.\\n\\nWhat you need to do it, instead of appending substrings, append character of strings. At each iteration, check if `s1[i] == s3[i+j]` and below that check `s2[j] == s3[i+j]`. \\n\\nOn satisfaction , call again the function with incremented i or j.\\n\\nThis way, if you observe, you will have implemented the above condition of alternating substrings.\\n\\nIn base case,\\n\\n` if temp == s3,` return `true`.\\n\\n`if i == s1.length() `return `temp+s2.subtr(j) == s3.`\\n\\n`if j == s2.length() `return `temp+s1.substr(i) == s3.`"
                    },
                    {
                        "username": "sergei99",
                        "content": "Would it even complete within time limit?"
                    },
                    {
                        "username": "xfffrank",
                        "content": "Did someone find this one a lot more difficult than other DP problems like \"63. Unique Paths II\\n\"..."
                    },
                    {
                        "username": "luoyunfeng1853",
                        "content": "Anyone can explain this constraint |n - m| <= 1?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "means if you split s1 into 3 parts, you must split s2 either to 2, 3 or 4 parts.\\n|3-2| = 1\\n|3-3| = 0\\n|3-4| = 1"
                    },
                    {
                        "username": "patilc125",
                        "content": "n-m==0 or n-m==-1 or n-m==1"
                    },
                    {
                        "username": "upendrabartwalymail",
                        "content": "s1:\"\"\\ns2:\"\"\\ns3:\"a\"\\nwhy this should return false?\\na empty string is part of all string so this should be true. Help me!\\n"
                    },
                    {
                        "username": "northern-flower",
                        "content": "Because the length of s3 is not the sum of the lengths s1 and s2."
                    },
                    {
                        "username": "alik",
                        "content": "It's quite easy to solve it using recursion but the result is \"Time Limit Exceeded\" on some very long input.\\nI can convert the recursion to a for loop, but it's quite tedious and I feel I'm missing the whole point of the question.\\nIs there some kind of a trick here?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "The reason you are getting TLE is because you are making the same calculations many times. In other words, assuming you use a 2 pointer approach, where i and j point to the current character you are considering for s1 and s2 respectively. you get the same i and j  many times. \\n\\nTo avoid this you can use memo. where the key is something like `${i}-${j}` so that you just stop when you get the same i and j, because you know you have already made that specific calculation. In a 2d dp array you do essentially the same thing, but more elegantly, but I am not entirely sure how. "
                    },
                    {
                        "username": "sergei99",
                        "content": "My first solution was a loop with a vector-based stack of todo items. But it exceeded the time limit as well. Recusion seems to give a consistenly bad rating on memory usage, let alone exponential time in this particular case.\nP.S. Can't believe this task is there for 10 years already. They gave it to me as a daily challenge... indeed it took half a day."
                    },
                    {
                        "username": "northern-flower",
                        "content": "You can use 2 pointers - one in s1 and another in s2 and move the respective one when you find the character of s3 in one of them"
                    },
                    {
                        "username": "rv14",
                        "content": "# I could not understand this program. Please help me to make me understand.\\n\\n\\n# Thank You ...."
                    },
                    {
                        "username": "strawhatdragon",
                        "content": "Need help with the 1D implementation for this.\n```\nclass Solution {\n    public boolean isInterleave(String s1, String s2, String s3) {\n        int m = s1.length();\n        int n = s2.length();\n        if(m + n != s3.length()) return false;\n        boolean[] next = new boolean[n+1];\n        next[n] = true;\n        for(int i = m-1; i >= 0; i--) {\n            boolean[] curr = new boolean[n+1];\n            for(int j = n; j >= 0; j--) {\n                if(i < s1.length() && s1.charAt(i) == s3.charAt(i+j) && next[j]) {\n                    curr[j] = next[j];\n                }\n                if(j < s2.length() && s2.charAt(j) == s3.charAt(i+j) && curr[j+1]) {\n                    curr[j] = curr[j+1];\n                }\n            }\n            next = curr;\n        }\n        return next[0];\n    }\n}\n```"
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "Can anyone give example for repeating subproblem in this question"
                    },
                    {
                        "username": "olsonpm",
                        "content": "the edge cases on this problem are extremely stupid.  Empty strings should be removed via constraints because the result makes no sense.  Why would 'a', 'b', 'a' be false but 'a', '', 'a' output true, yet '', 'abc', 'ab'  is false ?  Interview problems should have some level of intuition because otherwise we're guess'n'checking the author's mind"
                    },
                    {
                        "username": "tifv",
                        "content": "I don\\'t see the need to guess anyone\\'s mind, at least not in this particular problem. Its description is quite precise, one just needs to read it carefully.\\nIn particular, empty string can be represented as a concatenation of one empty substring (like `n = 1` or `m = 1`).\\nAll the other examples you list should obviously output false, since for `s3` to be an interleaving, its length must be the sum of lengths of `s1` and `s2`."
                    },
                    {
                        "username": "quan_mai",
                        "content": "string + dp = best combo!"
                    }
                ]
            },
            {
                "id": 2031581,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nSee this before the solution.\\n\\nSo the trick here is to how to implement this alternate selection of substrings. I am pretty much sure you have concluded that we need recursion to solve this, but how to ensure that when we append the string, it is the way it\\'s mentioned.\\n\\nWhat you need to do it, instead of appending substrings, append character of strings. At each iteration, check if `s1[i] == s3[i+j]` and below that check `s2[j] == s3[i+j]`. \\n\\nOn satisfaction , call again the function with incremented i or j.\\n\\nThis way, if you observe, you will have implemented the above condition of alternating substrings.\\n\\nIn base case,\\n\\n` if temp == s3,` return `true`.\\n\\n`if i == s1.length() `return `temp+s2.subtr(j) == s3.`\\n\\n`if j == s2.length() `return `temp+s1.substr(i) == s3.`"
                    },
                    {
                        "username": "sergei99",
                        "content": "Would it even complete within time limit?"
                    },
                    {
                        "username": "xfffrank",
                        "content": "Did someone find this one a lot more difficult than other DP problems like \"63. Unique Paths II\\n\"..."
                    },
                    {
                        "username": "luoyunfeng1853",
                        "content": "Anyone can explain this constraint |n - m| <= 1?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "means if you split s1 into 3 parts, you must split s2 either to 2, 3 or 4 parts.\\n|3-2| = 1\\n|3-3| = 0\\n|3-4| = 1"
                    },
                    {
                        "username": "patilc125",
                        "content": "n-m==0 or n-m==-1 or n-m==1"
                    },
                    {
                        "username": "upendrabartwalymail",
                        "content": "s1:\"\"\\ns2:\"\"\\ns3:\"a\"\\nwhy this should return false?\\na empty string is part of all string so this should be true. Help me!\\n"
                    },
                    {
                        "username": "northern-flower",
                        "content": "Because the length of s3 is not the sum of the lengths s1 and s2."
                    },
                    {
                        "username": "alik",
                        "content": "It's quite easy to solve it using recursion but the result is \"Time Limit Exceeded\" on some very long input.\\nI can convert the recursion to a for loop, but it's quite tedious and I feel I'm missing the whole point of the question.\\nIs there some kind of a trick here?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "The reason you are getting TLE is because you are making the same calculations many times. In other words, assuming you use a 2 pointer approach, where i and j point to the current character you are considering for s1 and s2 respectively. you get the same i and j  many times. \\n\\nTo avoid this you can use memo. where the key is something like `${i}-${j}` so that you just stop when you get the same i and j, because you know you have already made that specific calculation. In a 2d dp array you do essentially the same thing, but more elegantly, but I am not entirely sure how. "
                    },
                    {
                        "username": "sergei99",
                        "content": "My first solution was a loop with a vector-based stack of todo items. But it exceeded the time limit as well. Recusion seems to give a consistenly bad rating on memory usage, let alone exponential time in this particular case.\nP.S. Can't believe this task is there for 10 years already. They gave it to me as a daily challenge... indeed it took half a day."
                    },
                    {
                        "username": "northern-flower",
                        "content": "You can use 2 pointers - one in s1 and another in s2 and move the respective one when you find the character of s3 in one of them"
                    },
                    {
                        "username": "rv14",
                        "content": "# I could not understand this program. Please help me to make me understand.\\n\\n\\n# Thank You ...."
                    },
                    {
                        "username": "strawhatdragon",
                        "content": "Need help with the 1D implementation for this.\n```\nclass Solution {\n    public boolean isInterleave(String s1, String s2, String s3) {\n        int m = s1.length();\n        int n = s2.length();\n        if(m + n != s3.length()) return false;\n        boolean[] next = new boolean[n+1];\n        next[n] = true;\n        for(int i = m-1; i >= 0; i--) {\n            boolean[] curr = new boolean[n+1];\n            for(int j = n; j >= 0; j--) {\n                if(i < s1.length() && s1.charAt(i) == s3.charAt(i+j) && next[j]) {\n                    curr[j] = next[j];\n                }\n                if(j < s2.length() && s2.charAt(j) == s3.charAt(i+j) && curr[j+1]) {\n                    curr[j] = curr[j+1];\n                }\n            }\n            next = curr;\n        }\n        return next[0];\n    }\n}\n```"
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "Can anyone give example for repeating subproblem in this question"
                    },
                    {
                        "username": "olsonpm",
                        "content": "the edge cases on this problem are extremely stupid.  Empty strings should be removed via constraints because the result makes no sense.  Why would 'a', 'b', 'a' be false but 'a', '', 'a' output true, yet '', 'abc', 'ab'  is false ?  Interview problems should have some level of intuition because otherwise we're guess'n'checking the author's mind"
                    },
                    {
                        "username": "tifv",
                        "content": "I don\\'t see the need to guess anyone\\'s mind, at least not in this particular problem. Its description is quite precise, one just needs to read it carefully.\\nIn particular, empty string can be represented as a concatenation of one empty substring (like `n = 1` or `m = 1`).\\nAll the other examples you list should obviously output false, since for `s3` to be an interleaving, its length must be the sum of lengths of `s1` and `s2`."
                    },
                    {
                        "username": "quan_mai",
                        "content": "string + dp = best combo!"
                    }
                ]
            },
            {
                "id": 2030326,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nSee this before the solution.\\n\\nSo the trick here is to how to implement this alternate selection of substrings. I am pretty much sure you have concluded that we need recursion to solve this, but how to ensure that when we append the string, it is the way it\\'s mentioned.\\n\\nWhat you need to do it, instead of appending substrings, append character of strings. At each iteration, check if `s1[i] == s3[i+j]` and below that check `s2[j] == s3[i+j]`. \\n\\nOn satisfaction , call again the function with incremented i or j.\\n\\nThis way, if you observe, you will have implemented the above condition of alternating substrings.\\n\\nIn base case,\\n\\n` if temp == s3,` return `true`.\\n\\n`if i == s1.length() `return `temp+s2.subtr(j) == s3.`\\n\\n`if j == s2.length() `return `temp+s1.substr(i) == s3.`"
                    },
                    {
                        "username": "sergei99",
                        "content": "Would it even complete within time limit?"
                    },
                    {
                        "username": "xfffrank",
                        "content": "Did someone find this one a lot more difficult than other DP problems like \"63. Unique Paths II\\n\"..."
                    },
                    {
                        "username": "luoyunfeng1853",
                        "content": "Anyone can explain this constraint |n - m| <= 1?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "means if you split s1 into 3 parts, you must split s2 either to 2, 3 or 4 parts.\\n|3-2| = 1\\n|3-3| = 0\\n|3-4| = 1"
                    },
                    {
                        "username": "patilc125",
                        "content": "n-m==0 or n-m==-1 or n-m==1"
                    },
                    {
                        "username": "upendrabartwalymail",
                        "content": "s1:\"\"\\ns2:\"\"\\ns3:\"a\"\\nwhy this should return false?\\na empty string is part of all string so this should be true. Help me!\\n"
                    },
                    {
                        "username": "northern-flower",
                        "content": "Because the length of s3 is not the sum of the lengths s1 and s2."
                    },
                    {
                        "username": "alik",
                        "content": "It's quite easy to solve it using recursion but the result is \"Time Limit Exceeded\" on some very long input.\\nI can convert the recursion to a for loop, but it's quite tedious and I feel I'm missing the whole point of the question.\\nIs there some kind of a trick here?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "The reason you are getting TLE is because you are making the same calculations many times. In other words, assuming you use a 2 pointer approach, where i and j point to the current character you are considering for s1 and s2 respectively. you get the same i and j  many times. \\n\\nTo avoid this you can use memo. where the key is something like `${i}-${j}` so that you just stop when you get the same i and j, because you know you have already made that specific calculation. In a 2d dp array you do essentially the same thing, but more elegantly, but I am not entirely sure how. "
                    },
                    {
                        "username": "sergei99",
                        "content": "My first solution was a loop with a vector-based stack of todo items. But it exceeded the time limit as well. Recusion seems to give a consistenly bad rating on memory usage, let alone exponential time in this particular case.\nP.S. Can't believe this task is there for 10 years already. They gave it to me as a daily challenge... indeed it took half a day."
                    },
                    {
                        "username": "northern-flower",
                        "content": "You can use 2 pointers - one in s1 and another in s2 and move the respective one when you find the character of s3 in one of them"
                    },
                    {
                        "username": "rv14",
                        "content": "# I could not understand this program. Please help me to make me understand.\\n\\n\\n# Thank You ...."
                    },
                    {
                        "username": "strawhatdragon",
                        "content": "Need help with the 1D implementation for this.\n```\nclass Solution {\n    public boolean isInterleave(String s1, String s2, String s3) {\n        int m = s1.length();\n        int n = s2.length();\n        if(m + n != s3.length()) return false;\n        boolean[] next = new boolean[n+1];\n        next[n] = true;\n        for(int i = m-1; i >= 0; i--) {\n            boolean[] curr = new boolean[n+1];\n            for(int j = n; j >= 0; j--) {\n                if(i < s1.length() && s1.charAt(i) == s3.charAt(i+j) && next[j]) {\n                    curr[j] = next[j];\n                }\n                if(j < s2.length() && s2.charAt(j) == s3.charAt(i+j) && curr[j+1]) {\n                    curr[j] = curr[j+1];\n                }\n            }\n            next = curr;\n        }\n        return next[0];\n    }\n}\n```"
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "Can anyone give example for repeating subproblem in this question"
                    },
                    {
                        "username": "olsonpm",
                        "content": "the edge cases on this problem are extremely stupid.  Empty strings should be removed via constraints because the result makes no sense.  Why would 'a', 'b', 'a' be false but 'a', '', 'a' output true, yet '', 'abc', 'ab'  is false ?  Interview problems should have some level of intuition because otherwise we're guess'n'checking the author's mind"
                    },
                    {
                        "username": "tifv",
                        "content": "I don\\'t see the need to guess anyone\\'s mind, at least not in this particular problem. Its description is quite precise, one just needs to read it carefully.\\nIn particular, empty string can be represented as a concatenation of one empty substring (like `n = 1` or `m = 1`).\\nAll the other examples you list should obviously output false, since for `s3` to be an interleaving, its length must be the sum of lengths of `s1` and `s2`."
                    },
                    {
                        "username": "quan_mai",
                        "content": "string + dp = best combo!"
                    }
                ]
            },
            {
                "id": 2030217,
                "content": [
                    {
                        "username": "abhi2616",
                        "content": "Information provided in this question is just not sufficient \\nwho else feel this"
                    },
                    {
                        "username": "sergei99",
                        "content": "Yes it is. Got no problem solving it, excep debugging the bloody thing for 4 hours in a row..."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Once again, I have to thank LeetCode for pushing DP for 2-3 weeks in a row last month. Today, I easily solved this problem."
                    },
                    {
                        "username": "mahesh105",
                        "content": "Can anyone help to do the follow up question?"
                    },
                    {
                        "username": "tifv",
                        "content": "Notice that in your [solution](https://leetcode.com/submissions/detail/1031603649/) you only ever use two adjacent rows of `dp` matrix (`dp[i]` and `dp[i-1]`). You can rewrite solution in such a way that other rows are not stored in memory. (It is in fact possible to use only one row, overwriting it in each cycle. One has to be careful about the order of operations, though.)"
                    },
                    {
                        "username": "shuchisaini462",
                        "content": "I started solving this but n-m\\u22641 given for partitioning how can we get that up "
                    },
                    {
                        "username": "olzh06",
                        "content": "As I understand it:\\nLet\\'s assume you start with `s1` and split it into `n` parts. Now you can insert `n-1` pieces of `s2` between these `s1` parts. Finally you either have no pieces of `s2` left or a single piece to be append at the end of resulting string. So, it seems the condition will be satisfied automatically if `s3` is interleaving string of `s1` and `s2`"
                    },
                    {
                        "username": "Priyanshu1_618031",
                        "content": "Passed 89/106 test cases, then got Memory limit exceeded error! I really wished my recursive solution to get accepted :( \\nI will attempt again after learning DP."
                    },
                    {
                        "username": "crocedev",
                        "content": "Can\\'t believe I finished a DP problem before finishing my coffee. \\n\\nThanks daily challenges for beating my brain into eventual comprehension!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Done. 0ms and 6.18 Mb, beating 100% and 96.97% respectively. 7 unsuccessful submissions. Dynamic programming, of course, and a light fixed size bitset of 1.3 Kb. Debugged the bloody edge cases for 4 hours in a row with a short lunch break, feel like I've just unloaded a truck of heavy items alone... and for free."
                    },
                    {
                        "username": "mzvic",
                        "content": "s1 = \"ABCDEF\"\\ns2 = \"ABC\"\\noutput = \"DEF\"\\n\\nsomehow, the solution is \"\", i can\\'t understand why"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "here in output string only def is there, it must contain all the s1+s2 in some manner that it satisfies the question.\\n\\nsome possible output can be:\\n\"abcdefabc\", \"abcabcdef\"."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Could you solve it using only O(s2.length) additional memory space? --- just thinking about this"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "I Think we ignore |n-m|<=1 because we cannot take two consecutive substring from the same string therefore we just ignore it correct me if am wrong plz"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "We don\\'t take two consecutive substrings as we can count them as one anyways. We can keep taking the characters from the same string as long as they satisfy the condition."
                    }
                ]
            },
            {
                "id": 2030197,
                "content": [
                    {
                        "username": "abhi2616",
                        "content": "Information provided in this question is just not sufficient \\nwho else feel this"
                    },
                    {
                        "username": "sergei99",
                        "content": "Yes it is. Got no problem solving it, excep debugging the bloody thing for 4 hours in a row..."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Once again, I have to thank LeetCode for pushing DP for 2-3 weeks in a row last month. Today, I easily solved this problem."
                    },
                    {
                        "username": "mahesh105",
                        "content": "Can anyone help to do the follow up question?"
                    },
                    {
                        "username": "tifv",
                        "content": "Notice that in your [solution](https://leetcode.com/submissions/detail/1031603649/) you only ever use two adjacent rows of `dp` matrix (`dp[i]` and `dp[i-1]`). You can rewrite solution in such a way that other rows are not stored in memory. (It is in fact possible to use only one row, overwriting it in each cycle. One has to be careful about the order of operations, though.)"
                    },
                    {
                        "username": "shuchisaini462",
                        "content": "I started solving this but n-m\\u22641 given for partitioning how can we get that up "
                    },
                    {
                        "username": "olzh06",
                        "content": "As I understand it:\\nLet\\'s assume you start with `s1` and split it into `n` parts. Now you can insert `n-1` pieces of `s2` between these `s1` parts. Finally you either have no pieces of `s2` left or a single piece to be append at the end of resulting string. So, it seems the condition will be satisfied automatically if `s3` is interleaving string of `s1` and `s2`"
                    },
                    {
                        "username": "Priyanshu1_618031",
                        "content": "Passed 89/106 test cases, then got Memory limit exceeded error! I really wished my recursive solution to get accepted :( \\nI will attempt again after learning DP."
                    },
                    {
                        "username": "crocedev",
                        "content": "Can\\'t believe I finished a DP problem before finishing my coffee. \\n\\nThanks daily challenges for beating my brain into eventual comprehension!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Done. 0ms and 6.18 Mb, beating 100% and 96.97% respectively. 7 unsuccessful submissions. Dynamic programming, of course, and a light fixed size bitset of 1.3 Kb. Debugged the bloody edge cases for 4 hours in a row with a short lunch break, feel like I've just unloaded a truck of heavy items alone... and for free."
                    },
                    {
                        "username": "mzvic",
                        "content": "s1 = \"ABCDEF\"\\ns2 = \"ABC\"\\noutput = \"DEF\"\\n\\nsomehow, the solution is \"\", i can\\'t understand why"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "here in output string only def is there, it must contain all the s1+s2 in some manner that it satisfies the question.\\n\\nsome possible output can be:\\n\"abcdefabc\", \"abcabcdef\"."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Could you solve it using only O(s2.length) additional memory space? --- just thinking about this"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "I Think we ignore |n-m|<=1 because we cannot take two consecutive substring from the same string therefore we just ignore it correct me if am wrong plz"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "We don\\'t take two consecutive substrings as we can count them as one anyways. We can keep taking the characters from the same string as long as they satisfy the condition."
                    }
                ]
            },
            {
                "id": 2030096,
                "content": [
                    {
                        "username": "abhi2616",
                        "content": "Information provided in this question is just not sufficient \\nwho else feel this"
                    },
                    {
                        "username": "sergei99",
                        "content": "Yes it is. Got no problem solving it, excep debugging the bloody thing for 4 hours in a row..."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Once again, I have to thank LeetCode for pushing DP for 2-3 weeks in a row last month. Today, I easily solved this problem."
                    },
                    {
                        "username": "mahesh105",
                        "content": "Can anyone help to do the follow up question?"
                    },
                    {
                        "username": "tifv",
                        "content": "Notice that in your [solution](https://leetcode.com/submissions/detail/1031603649/) you only ever use two adjacent rows of `dp` matrix (`dp[i]` and `dp[i-1]`). You can rewrite solution in such a way that other rows are not stored in memory. (It is in fact possible to use only one row, overwriting it in each cycle. One has to be careful about the order of operations, though.)"
                    },
                    {
                        "username": "shuchisaini462",
                        "content": "I started solving this but n-m\\u22641 given for partitioning how can we get that up "
                    },
                    {
                        "username": "olzh06",
                        "content": "As I understand it:\\nLet\\'s assume you start with `s1` and split it into `n` parts. Now you can insert `n-1` pieces of `s2` between these `s1` parts. Finally you either have no pieces of `s2` left or a single piece to be append at the end of resulting string. So, it seems the condition will be satisfied automatically if `s3` is interleaving string of `s1` and `s2`"
                    },
                    {
                        "username": "Priyanshu1_618031",
                        "content": "Passed 89/106 test cases, then got Memory limit exceeded error! I really wished my recursive solution to get accepted :( \\nI will attempt again after learning DP."
                    },
                    {
                        "username": "crocedev",
                        "content": "Can\\'t believe I finished a DP problem before finishing my coffee. \\n\\nThanks daily challenges for beating my brain into eventual comprehension!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Done. 0ms and 6.18 Mb, beating 100% and 96.97% respectively. 7 unsuccessful submissions. Dynamic programming, of course, and a light fixed size bitset of 1.3 Kb. Debugged the bloody edge cases for 4 hours in a row with a short lunch break, feel like I've just unloaded a truck of heavy items alone... and for free."
                    },
                    {
                        "username": "mzvic",
                        "content": "s1 = \"ABCDEF\"\\ns2 = \"ABC\"\\noutput = \"DEF\"\\n\\nsomehow, the solution is \"\", i can\\'t understand why"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "here in output string only def is there, it must contain all the s1+s2 in some manner that it satisfies the question.\\n\\nsome possible output can be:\\n\"abcdefabc\", \"abcabcdef\"."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Could you solve it using only O(s2.length) additional memory space? --- just thinking about this"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "I Think we ignore |n-m|<=1 because we cannot take two consecutive substring from the same string therefore we just ignore it correct me if am wrong plz"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "We don\\'t take two consecutive substrings as we can count them as one anyways. We can keep taking the characters from the same string as long as they satisfy the condition."
                    }
                ]
            },
            {
                "id": 2030092,
                "content": [
                    {
                        "username": "abhi2616",
                        "content": "Information provided in this question is just not sufficient \\nwho else feel this"
                    },
                    {
                        "username": "sergei99",
                        "content": "Yes it is. Got no problem solving it, excep debugging the bloody thing for 4 hours in a row..."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Once again, I have to thank LeetCode for pushing DP for 2-3 weeks in a row last month. Today, I easily solved this problem."
                    },
                    {
                        "username": "mahesh105",
                        "content": "Can anyone help to do the follow up question?"
                    },
                    {
                        "username": "tifv",
                        "content": "Notice that in your [solution](https://leetcode.com/submissions/detail/1031603649/) you only ever use two adjacent rows of `dp` matrix (`dp[i]` and `dp[i-1]`). You can rewrite solution in such a way that other rows are not stored in memory. (It is in fact possible to use only one row, overwriting it in each cycle. One has to be careful about the order of operations, though.)"
                    },
                    {
                        "username": "shuchisaini462",
                        "content": "I started solving this but n-m\\u22641 given for partitioning how can we get that up "
                    },
                    {
                        "username": "olzh06",
                        "content": "As I understand it:\\nLet\\'s assume you start with `s1` and split it into `n` parts. Now you can insert `n-1` pieces of `s2` between these `s1` parts. Finally you either have no pieces of `s2` left or a single piece to be append at the end of resulting string. So, it seems the condition will be satisfied automatically if `s3` is interleaving string of `s1` and `s2`"
                    },
                    {
                        "username": "Priyanshu1_618031",
                        "content": "Passed 89/106 test cases, then got Memory limit exceeded error! I really wished my recursive solution to get accepted :( \\nI will attempt again after learning DP."
                    },
                    {
                        "username": "crocedev",
                        "content": "Can\\'t believe I finished a DP problem before finishing my coffee. \\n\\nThanks daily challenges for beating my brain into eventual comprehension!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Done. 0ms and 6.18 Mb, beating 100% and 96.97% respectively. 7 unsuccessful submissions. Dynamic programming, of course, and a light fixed size bitset of 1.3 Kb. Debugged the bloody edge cases for 4 hours in a row with a short lunch break, feel like I've just unloaded a truck of heavy items alone... and for free."
                    },
                    {
                        "username": "mzvic",
                        "content": "s1 = \"ABCDEF\"\\ns2 = \"ABC\"\\noutput = \"DEF\"\\n\\nsomehow, the solution is \"\", i can\\'t understand why"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "here in output string only def is there, it must contain all the s1+s2 in some manner that it satisfies the question.\\n\\nsome possible output can be:\\n\"abcdefabc\", \"abcabcdef\"."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Could you solve it using only O(s2.length) additional memory space? --- just thinking about this"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "I Think we ignore |n-m|<=1 because we cannot take two consecutive substring from the same string therefore we just ignore it correct me if am wrong plz"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "We don\\'t take two consecutive substrings as we can count them as one anyways. We can keep taking the characters from the same string as long as they satisfy the condition."
                    }
                ]
            },
            {
                "id": 2029995,
                "content": [
                    {
                        "username": "abhi2616",
                        "content": "Information provided in this question is just not sufficient \\nwho else feel this"
                    },
                    {
                        "username": "sergei99",
                        "content": "Yes it is. Got no problem solving it, excep debugging the bloody thing for 4 hours in a row..."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Once again, I have to thank LeetCode for pushing DP for 2-3 weeks in a row last month. Today, I easily solved this problem."
                    },
                    {
                        "username": "mahesh105",
                        "content": "Can anyone help to do the follow up question?"
                    },
                    {
                        "username": "tifv",
                        "content": "Notice that in your [solution](https://leetcode.com/submissions/detail/1031603649/) you only ever use two adjacent rows of `dp` matrix (`dp[i]` and `dp[i-1]`). You can rewrite solution in such a way that other rows are not stored in memory. (It is in fact possible to use only one row, overwriting it in each cycle. One has to be careful about the order of operations, though.)"
                    },
                    {
                        "username": "shuchisaini462",
                        "content": "I started solving this but n-m\\u22641 given for partitioning how can we get that up "
                    },
                    {
                        "username": "olzh06",
                        "content": "As I understand it:\\nLet\\'s assume you start with `s1` and split it into `n` parts. Now you can insert `n-1` pieces of `s2` between these `s1` parts. Finally you either have no pieces of `s2` left or a single piece to be append at the end of resulting string. So, it seems the condition will be satisfied automatically if `s3` is interleaving string of `s1` and `s2`"
                    },
                    {
                        "username": "Priyanshu1_618031",
                        "content": "Passed 89/106 test cases, then got Memory limit exceeded error! I really wished my recursive solution to get accepted :( \\nI will attempt again after learning DP."
                    },
                    {
                        "username": "crocedev",
                        "content": "Can\\'t believe I finished a DP problem before finishing my coffee. \\n\\nThanks daily challenges for beating my brain into eventual comprehension!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Done. 0ms and 6.18 Mb, beating 100% and 96.97% respectively. 7 unsuccessful submissions. Dynamic programming, of course, and a light fixed size bitset of 1.3 Kb. Debugged the bloody edge cases for 4 hours in a row with a short lunch break, feel like I've just unloaded a truck of heavy items alone... and for free."
                    },
                    {
                        "username": "mzvic",
                        "content": "s1 = \"ABCDEF\"\\ns2 = \"ABC\"\\noutput = \"DEF\"\\n\\nsomehow, the solution is \"\", i can\\'t understand why"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "here in output string only def is there, it must contain all the s1+s2 in some manner that it satisfies the question.\\n\\nsome possible output can be:\\n\"abcdefabc\", \"abcabcdef\"."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Could you solve it using only O(s2.length) additional memory space? --- just thinking about this"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "I Think we ignore |n-m|<=1 because we cannot take two consecutive substring from the same string therefore we just ignore it correct me if am wrong plz"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "We don\\'t take two consecutive substrings as we can count them as one anyways. We can keep taking the characters from the same string as long as they satisfy the condition."
                    }
                ]
            },
            {
                "id": 2029886,
                "content": [
                    {
                        "username": "abhi2616",
                        "content": "Information provided in this question is just not sufficient \\nwho else feel this"
                    },
                    {
                        "username": "sergei99",
                        "content": "Yes it is. Got no problem solving it, excep debugging the bloody thing for 4 hours in a row..."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Once again, I have to thank LeetCode for pushing DP for 2-3 weeks in a row last month. Today, I easily solved this problem."
                    },
                    {
                        "username": "mahesh105",
                        "content": "Can anyone help to do the follow up question?"
                    },
                    {
                        "username": "tifv",
                        "content": "Notice that in your [solution](https://leetcode.com/submissions/detail/1031603649/) you only ever use two adjacent rows of `dp` matrix (`dp[i]` and `dp[i-1]`). You can rewrite solution in such a way that other rows are not stored in memory. (It is in fact possible to use only one row, overwriting it in each cycle. One has to be careful about the order of operations, though.)"
                    },
                    {
                        "username": "shuchisaini462",
                        "content": "I started solving this but n-m\\u22641 given for partitioning how can we get that up "
                    },
                    {
                        "username": "olzh06",
                        "content": "As I understand it:\\nLet\\'s assume you start with `s1` and split it into `n` parts. Now you can insert `n-1` pieces of `s2` between these `s1` parts. Finally you either have no pieces of `s2` left or a single piece to be append at the end of resulting string. So, it seems the condition will be satisfied automatically if `s3` is interleaving string of `s1` and `s2`"
                    },
                    {
                        "username": "Priyanshu1_618031",
                        "content": "Passed 89/106 test cases, then got Memory limit exceeded error! I really wished my recursive solution to get accepted :( \\nI will attempt again after learning DP."
                    },
                    {
                        "username": "crocedev",
                        "content": "Can\\'t believe I finished a DP problem before finishing my coffee. \\n\\nThanks daily challenges for beating my brain into eventual comprehension!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Done. 0ms and 6.18 Mb, beating 100% and 96.97% respectively. 7 unsuccessful submissions. Dynamic programming, of course, and a light fixed size bitset of 1.3 Kb. Debugged the bloody edge cases for 4 hours in a row with a short lunch break, feel like I've just unloaded a truck of heavy items alone... and for free."
                    },
                    {
                        "username": "mzvic",
                        "content": "s1 = \"ABCDEF\"\\ns2 = \"ABC\"\\noutput = \"DEF\"\\n\\nsomehow, the solution is \"\", i can\\'t understand why"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "here in output string only def is there, it must contain all the s1+s2 in some manner that it satisfies the question.\\n\\nsome possible output can be:\\n\"abcdefabc\", \"abcabcdef\"."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Could you solve it using only O(s2.length) additional memory space? --- just thinking about this"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "I Think we ignore |n-m|<=1 because we cannot take two consecutive substring from the same string therefore we just ignore it correct me if am wrong plz"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "We don\\'t take two consecutive substrings as we can count them as one anyways. We can keep taking the characters from the same string as long as they satisfy the condition."
                    }
                ]
            },
            {
                "id": 2029879,
                "content": [
                    {
                        "username": "abhi2616",
                        "content": "Information provided in this question is just not sufficient \\nwho else feel this"
                    },
                    {
                        "username": "sergei99",
                        "content": "Yes it is. Got no problem solving it, excep debugging the bloody thing for 4 hours in a row..."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Once again, I have to thank LeetCode for pushing DP for 2-3 weeks in a row last month. Today, I easily solved this problem."
                    },
                    {
                        "username": "mahesh105",
                        "content": "Can anyone help to do the follow up question?"
                    },
                    {
                        "username": "tifv",
                        "content": "Notice that in your [solution](https://leetcode.com/submissions/detail/1031603649/) you only ever use two adjacent rows of `dp` matrix (`dp[i]` and `dp[i-1]`). You can rewrite solution in such a way that other rows are not stored in memory. (It is in fact possible to use only one row, overwriting it in each cycle. One has to be careful about the order of operations, though.)"
                    },
                    {
                        "username": "shuchisaini462",
                        "content": "I started solving this but n-m\\u22641 given for partitioning how can we get that up "
                    },
                    {
                        "username": "olzh06",
                        "content": "As I understand it:\\nLet\\'s assume you start with `s1` and split it into `n` parts. Now you can insert `n-1` pieces of `s2` between these `s1` parts. Finally you either have no pieces of `s2` left or a single piece to be append at the end of resulting string. So, it seems the condition will be satisfied automatically if `s3` is interleaving string of `s1` and `s2`"
                    },
                    {
                        "username": "Priyanshu1_618031",
                        "content": "Passed 89/106 test cases, then got Memory limit exceeded error! I really wished my recursive solution to get accepted :( \\nI will attempt again after learning DP."
                    },
                    {
                        "username": "crocedev",
                        "content": "Can\\'t believe I finished a DP problem before finishing my coffee. \\n\\nThanks daily challenges for beating my brain into eventual comprehension!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Done. 0ms and 6.18 Mb, beating 100% and 96.97% respectively. 7 unsuccessful submissions. Dynamic programming, of course, and a light fixed size bitset of 1.3 Kb. Debugged the bloody edge cases for 4 hours in a row with a short lunch break, feel like I've just unloaded a truck of heavy items alone... and for free."
                    },
                    {
                        "username": "mzvic",
                        "content": "s1 = \"ABCDEF\"\\ns2 = \"ABC\"\\noutput = \"DEF\"\\n\\nsomehow, the solution is \"\", i can\\'t understand why"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "here in output string only def is there, it must contain all the s1+s2 in some manner that it satisfies the question.\\n\\nsome possible output can be:\\n\"abcdefabc\", \"abcabcdef\"."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Could you solve it using only O(s2.length) additional memory space? --- just thinking about this"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "I Think we ignore |n-m|<=1 because we cannot take two consecutive substring from the same string therefore we just ignore it correct me if am wrong plz"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "We don\\'t take two consecutive substrings as we can count them as one anyways. We can keep taking the characters from the same string as long as they satisfy the condition."
                    }
                ]
            },
            {
                "id": 2029827,
                "content": [
                    {
                        "username": "abhi2616",
                        "content": "Information provided in this question is just not sufficient \\nwho else feel this"
                    },
                    {
                        "username": "sergei99",
                        "content": "Yes it is. Got no problem solving it, excep debugging the bloody thing for 4 hours in a row..."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Once again, I have to thank LeetCode for pushing DP for 2-3 weeks in a row last month. Today, I easily solved this problem."
                    },
                    {
                        "username": "mahesh105",
                        "content": "Can anyone help to do the follow up question?"
                    },
                    {
                        "username": "tifv",
                        "content": "Notice that in your [solution](https://leetcode.com/submissions/detail/1031603649/) you only ever use two adjacent rows of `dp` matrix (`dp[i]` and `dp[i-1]`). You can rewrite solution in such a way that other rows are not stored in memory. (It is in fact possible to use only one row, overwriting it in each cycle. One has to be careful about the order of operations, though.)"
                    },
                    {
                        "username": "shuchisaini462",
                        "content": "I started solving this but n-m\\u22641 given for partitioning how can we get that up "
                    },
                    {
                        "username": "olzh06",
                        "content": "As I understand it:\\nLet\\'s assume you start with `s1` and split it into `n` parts. Now you can insert `n-1` pieces of `s2` between these `s1` parts. Finally you either have no pieces of `s2` left or a single piece to be append at the end of resulting string. So, it seems the condition will be satisfied automatically if `s3` is interleaving string of `s1` and `s2`"
                    },
                    {
                        "username": "Priyanshu1_618031",
                        "content": "Passed 89/106 test cases, then got Memory limit exceeded error! I really wished my recursive solution to get accepted :( \\nI will attempt again after learning DP."
                    },
                    {
                        "username": "crocedev",
                        "content": "Can\\'t believe I finished a DP problem before finishing my coffee. \\n\\nThanks daily challenges for beating my brain into eventual comprehension!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Done. 0ms and 6.18 Mb, beating 100% and 96.97% respectively. 7 unsuccessful submissions. Dynamic programming, of course, and a light fixed size bitset of 1.3 Kb. Debugged the bloody edge cases for 4 hours in a row with a short lunch break, feel like I've just unloaded a truck of heavy items alone... and for free."
                    },
                    {
                        "username": "mzvic",
                        "content": "s1 = \"ABCDEF\"\\ns2 = \"ABC\"\\noutput = \"DEF\"\\n\\nsomehow, the solution is \"\", i can\\'t understand why"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "here in output string only def is there, it must contain all the s1+s2 in some manner that it satisfies the question.\\n\\nsome possible output can be:\\n\"abcdefabc\", \"abcabcdef\"."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Could you solve it using only O(s2.length) additional memory space? --- just thinking about this"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "I Think we ignore |n-m|<=1 because we cannot take two consecutive substring from the same string therefore we just ignore it correct me if am wrong plz"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "We don\\'t take two consecutive substrings as we can count them as one anyways. We can keep taking the characters from the same string as long as they satisfy the condition."
                    }
                ]
            },
            {
                "id": 2029820,
                "content": [
                    {
                        "username": "abhi2616",
                        "content": "Information provided in this question is just not sufficient \\nwho else feel this"
                    },
                    {
                        "username": "sergei99",
                        "content": "Yes it is. Got no problem solving it, excep debugging the bloody thing for 4 hours in a row..."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Once again, I have to thank LeetCode for pushing DP for 2-3 weeks in a row last month. Today, I easily solved this problem."
                    },
                    {
                        "username": "mahesh105",
                        "content": "Can anyone help to do the follow up question?"
                    },
                    {
                        "username": "tifv",
                        "content": "Notice that in your [solution](https://leetcode.com/submissions/detail/1031603649/) you only ever use two adjacent rows of `dp` matrix (`dp[i]` and `dp[i-1]`). You can rewrite solution in such a way that other rows are not stored in memory. (It is in fact possible to use only one row, overwriting it in each cycle. One has to be careful about the order of operations, though.)"
                    },
                    {
                        "username": "shuchisaini462",
                        "content": "I started solving this but n-m\\u22641 given for partitioning how can we get that up "
                    },
                    {
                        "username": "olzh06",
                        "content": "As I understand it:\\nLet\\'s assume you start with `s1` and split it into `n` parts. Now you can insert `n-1` pieces of `s2` between these `s1` parts. Finally you either have no pieces of `s2` left or a single piece to be append at the end of resulting string. So, it seems the condition will be satisfied automatically if `s3` is interleaving string of `s1` and `s2`"
                    },
                    {
                        "username": "Priyanshu1_618031",
                        "content": "Passed 89/106 test cases, then got Memory limit exceeded error! I really wished my recursive solution to get accepted :( \\nI will attempt again after learning DP."
                    },
                    {
                        "username": "crocedev",
                        "content": "Can\\'t believe I finished a DP problem before finishing my coffee. \\n\\nThanks daily challenges for beating my brain into eventual comprehension!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Done. 0ms and 6.18 Mb, beating 100% and 96.97% respectively. 7 unsuccessful submissions. Dynamic programming, of course, and a light fixed size bitset of 1.3 Kb. Debugged the bloody edge cases for 4 hours in a row with a short lunch break, feel like I've just unloaded a truck of heavy items alone... and for free."
                    },
                    {
                        "username": "mzvic",
                        "content": "s1 = \"ABCDEF\"\\ns2 = \"ABC\"\\noutput = \"DEF\"\\n\\nsomehow, the solution is \"\", i can\\'t understand why"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "here in output string only def is there, it must contain all the s1+s2 in some manner that it satisfies the question.\\n\\nsome possible output can be:\\n\"abcdefabc\", \"abcabcdef\"."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Could you solve it using only O(s2.length) additional memory space? --- just thinking about this"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "I Think we ignore |n-m|<=1 because we cannot take two consecutive substring from the same string therefore we just ignore it correct me if am wrong plz"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "We don\\'t take two consecutive substrings as we can count them as one anyways. We can keep taking the characters from the same string as long as they satisfy the condition."
                    }
                ]
            },
            {
                "id": 2029809,
                "content": [
                    {
                        "username": "abhi2616",
                        "content": "Information provided in this question is just not sufficient \\nwho else feel this"
                    },
                    {
                        "username": "sergei99",
                        "content": "Yes it is. Got no problem solving it, excep debugging the bloody thing for 4 hours in a row..."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Once again, I have to thank LeetCode for pushing DP for 2-3 weeks in a row last month. Today, I easily solved this problem."
                    },
                    {
                        "username": "mahesh105",
                        "content": "Can anyone help to do the follow up question?"
                    },
                    {
                        "username": "tifv",
                        "content": "Notice that in your [solution](https://leetcode.com/submissions/detail/1031603649/) you only ever use two adjacent rows of `dp` matrix (`dp[i]` and `dp[i-1]`). You can rewrite solution in such a way that other rows are not stored in memory. (It is in fact possible to use only one row, overwriting it in each cycle. One has to be careful about the order of operations, though.)"
                    },
                    {
                        "username": "shuchisaini462",
                        "content": "I started solving this but n-m\\u22641 given for partitioning how can we get that up "
                    },
                    {
                        "username": "olzh06",
                        "content": "As I understand it:\\nLet\\'s assume you start with `s1` and split it into `n` parts. Now you can insert `n-1` pieces of `s2` between these `s1` parts. Finally you either have no pieces of `s2` left or a single piece to be append at the end of resulting string. So, it seems the condition will be satisfied automatically if `s3` is interleaving string of `s1` and `s2`"
                    },
                    {
                        "username": "Priyanshu1_618031",
                        "content": "Passed 89/106 test cases, then got Memory limit exceeded error! I really wished my recursive solution to get accepted :( \\nI will attempt again after learning DP."
                    },
                    {
                        "username": "crocedev",
                        "content": "Can\\'t believe I finished a DP problem before finishing my coffee. \\n\\nThanks daily challenges for beating my brain into eventual comprehension!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Done. 0ms and 6.18 Mb, beating 100% and 96.97% respectively. 7 unsuccessful submissions. Dynamic programming, of course, and a light fixed size bitset of 1.3 Kb. Debugged the bloody edge cases for 4 hours in a row with a short lunch break, feel like I've just unloaded a truck of heavy items alone... and for free."
                    },
                    {
                        "username": "mzvic",
                        "content": "s1 = \"ABCDEF\"\\ns2 = \"ABC\"\\noutput = \"DEF\"\\n\\nsomehow, the solution is \"\", i can\\'t understand why"
                    },
                    {
                        "username": "__sunny15__",
                        "content": "here in output string only def is there, it must contain all the s1+s2 in some manner that it satisfies the question.\\n\\nsome possible output can be:\\n\"abcdefabc\", \"abcabcdef\"."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 Could you solve it using only O(s2.length) additional memory space? --- just thinking about this"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "I Think we ignore |n-m|<=1 because we cannot take two consecutive substring from the same string therefore we just ignore it correct me if am wrong plz"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "We don\\'t take two consecutive substrings as we can count them as one anyways. We can keep taking the characters from the same string as long as they satisfy the condition."
                    }
                ]
            },
            {
                "id": 2029768,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "Am I the only one who has no idea what the task wants?\\n\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Why is my recursive solution with `O(s1.length * s2.length)` space faster than my iterative solution with `O(s2.length)` space?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "after more than twice times reading their description, which is also very \"humanity\" as they usually do...\n`|n -m| <= 1` is just a weird condition explaining for a weird example they provided `s = s1 + s2 + ... + sn`, `t = t1 + t2 + ... + tm`\nbut no need to care about it. e.g.: `s1 = \"a\" + \"b\" + \"c\" + \"d\" (m=4)`, `s2 = \"e\" + \"f\" (n=2)`, `s3 = \"aebfcd\"`. it is not `s3 = \"a\" + \"e\" + \"b\"+ \"f\" + \"c\" + \"d\"`  (m=4, n=2), because obviously \"c\" and \"d\" are 2 continuous characters in `s1`. it is `s3 = \"a\" + \"e\" + \"b\"+ \"f\" + \"cd\"` (m=3, n=2)\nhence, just ignore it"
                    },
                    {
                        "username": "ahrix268",
                        "content": "I remember when I was a newbie to Leetcode and DP, using pick one randomly and they gave me this problem. I was like how the hell people could solve this shit..."
                    },
                    {
                        "username": "mindstuck",
                        "content": "Why are we ignoring the condition |n-m|<=1?\\nNone of the solutions is checking that condition."
                    },
                    {
                        "username": "mindstuck",
                        "content": "[@ahrix268](/ahrix268) Gotch Thanks!"
                    },
                    {
                        "username": "mindstuck",
                        "content": "[@amitbansal13](/amitbansal13) cool, gotcha thanks!"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Consider the case s1,s2 and t1,t2,t3,t4\\n\\nWe will have the final string as \\n\\nsomething like s1,t1,s2,t2,t3,t4 - We can consider t2,t3,t4 as one substring \\n\\nSimilar situation for other permutations/cases."
                    },
                    {
                        "username": "ahrix268",
                        "content": "https://leetcode.com/problems/interleaving-string/description/comments/2029662 i explained in this. conclusion: \"just a weird and obviously condition explaining for their very \"humanity\" example\""
                    },
                    {
                        "username": "JiayingGao",
                        "content": "This is so classic."
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "1. What is meaning by |n - m| <= 1 ?\\n\\nAnd in every solution it ignored. In question\\'s description it is mentioned that interleaving string means concatenate the substrings alternately. \\n2. Am i going wrong with the understanding of the question??"
                    },
                    {
                        "username": "ahrix268",
                        "content": "https://leetcode.com/problems/interleaving-string/description/comments/2029662 conclusion: \"just a weird and obviously condition explaining for their very \"humanity\" example\""
                    },
                    {
                        "username": "bhati25",
                        "content": "<h1>Thank you leetcode daily questions, you have made DP so easy. </h1>\\n<h1>Now DP is \\uD83E\\uDEF6.</h1>"
                    },
                    {
                        "username": "yash___saxena",
                        "content": "It is giving TLE, Some one can help😣, I don't know Why?\njava:  \n\nclass Solution {\n\n    public boolean isInterleave(String s1, String s2, String s3) {\n        if(s1.length()+s2.length()!=s3.length())\n        return false;\n        Boolean dp[][]=new Boolean[s1.length()+1][s2.length()+1];\n        return interleave(0,0,0,dp,s1,s2,s3);\n    }\n    boolean interleave(int i,int j,int k,Boolean dp[][],String s1,String s2,String s3)\n    {\n        if(dp[i][j]!=null)\n        return dp[i][j];\n         while(k<s3.length())\n            {\n                if(i<s1.length() &&  j<s2.length()  && s3.charAt(k)==s2.charAt(j) && s3.charAt(k)==s1.charAt(i))\n              {\n                return dp[i][j]=interleave(i+1,j,k+1,dp,s1,s2,s3)|| interleave(i,j+1,k+1,dp,s1,s2,s3); \n              }\n            else if(i<s1.length() && s3.charAt(k)==s1.charAt(i))\n            {\n                i++;\n\n            }\n            else if( j<s2.length() && s3.charAt(k)==s2.charAt(j))\n            {\n              j++;\n            }\n            else\n            return dp[i][j]=false;\n            k++;\n        }\n        if(i==s1.length() && j==s2.length())\n        return dp[i][j]=true;\n        else\n        return dp[i][j]=false;\n    }\n}"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "This Question makes my mind more Curious and Puzzled."
                    }
                ]
            },
            {
                "id": 2029709,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "Am I the only one who has no idea what the task wants?\\n\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Why is my recursive solution with `O(s1.length * s2.length)` space faster than my iterative solution with `O(s2.length)` space?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "after more than twice times reading their description, which is also very \"humanity\" as they usually do...\n`|n -m| <= 1` is just a weird condition explaining for a weird example they provided `s = s1 + s2 + ... + sn`, `t = t1 + t2 + ... + tm`\nbut no need to care about it. e.g.: `s1 = \"a\" + \"b\" + \"c\" + \"d\" (m=4)`, `s2 = \"e\" + \"f\" (n=2)`, `s3 = \"aebfcd\"`. it is not `s3 = \"a\" + \"e\" + \"b\"+ \"f\" + \"c\" + \"d\"`  (m=4, n=2), because obviously \"c\" and \"d\" are 2 continuous characters in `s1`. it is `s3 = \"a\" + \"e\" + \"b\"+ \"f\" + \"cd\"` (m=3, n=2)\nhence, just ignore it"
                    },
                    {
                        "username": "ahrix268",
                        "content": "I remember when I was a newbie to Leetcode and DP, using pick one randomly and they gave me this problem. I was like how the hell people could solve this shit..."
                    },
                    {
                        "username": "mindstuck",
                        "content": "Why are we ignoring the condition |n-m|<=1?\\nNone of the solutions is checking that condition."
                    },
                    {
                        "username": "mindstuck",
                        "content": "[@ahrix268](/ahrix268) Gotch Thanks!"
                    },
                    {
                        "username": "mindstuck",
                        "content": "[@amitbansal13](/amitbansal13) cool, gotcha thanks!"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Consider the case s1,s2 and t1,t2,t3,t4\\n\\nWe will have the final string as \\n\\nsomething like s1,t1,s2,t2,t3,t4 - We can consider t2,t3,t4 as one substring \\n\\nSimilar situation for other permutations/cases."
                    },
                    {
                        "username": "ahrix268",
                        "content": "https://leetcode.com/problems/interleaving-string/description/comments/2029662 i explained in this. conclusion: \"just a weird and obviously condition explaining for their very \"humanity\" example\""
                    },
                    {
                        "username": "JiayingGao",
                        "content": "This is so classic."
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "1. What is meaning by |n - m| <= 1 ?\\n\\nAnd in every solution it ignored. In question\\'s description it is mentioned that interleaving string means concatenate the substrings alternately. \\n2. Am i going wrong with the understanding of the question??"
                    },
                    {
                        "username": "ahrix268",
                        "content": "https://leetcode.com/problems/interleaving-string/description/comments/2029662 conclusion: \"just a weird and obviously condition explaining for their very \"humanity\" example\""
                    },
                    {
                        "username": "bhati25",
                        "content": "<h1>Thank you leetcode daily questions, you have made DP so easy. </h1>\\n<h1>Now DP is \\uD83E\\uDEF6.</h1>"
                    },
                    {
                        "username": "yash___saxena",
                        "content": "It is giving TLE, Some one can help😣, I don't know Why?\njava:  \n\nclass Solution {\n\n    public boolean isInterleave(String s1, String s2, String s3) {\n        if(s1.length()+s2.length()!=s3.length())\n        return false;\n        Boolean dp[][]=new Boolean[s1.length()+1][s2.length()+1];\n        return interleave(0,0,0,dp,s1,s2,s3);\n    }\n    boolean interleave(int i,int j,int k,Boolean dp[][],String s1,String s2,String s3)\n    {\n        if(dp[i][j]!=null)\n        return dp[i][j];\n         while(k<s3.length())\n            {\n                if(i<s1.length() &&  j<s2.length()  && s3.charAt(k)==s2.charAt(j) && s3.charAt(k)==s1.charAt(i))\n              {\n                return dp[i][j]=interleave(i+1,j,k+1,dp,s1,s2,s3)|| interleave(i,j+1,k+1,dp,s1,s2,s3); \n              }\n            else if(i<s1.length() && s3.charAt(k)==s1.charAt(i))\n            {\n                i++;\n\n            }\n            else if( j<s2.length() && s3.charAt(k)==s2.charAt(j))\n            {\n              j++;\n            }\n            else\n            return dp[i][j]=false;\n            k++;\n        }\n        if(i==s1.length() && j==s2.length())\n        return dp[i][j]=true;\n        else\n        return dp[i][j]=false;\n    }\n}"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "This Question makes my mind more Curious and Puzzled."
                    }
                ]
            },
            {
                "id": 2029662,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "Am I the only one who has no idea what the task wants?\\n\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Why is my recursive solution with `O(s1.length * s2.length)` space faster than my iterative solution with `O(s2.length)` space?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "after more than twice times reading their description, which is also very \"humanity\" as they usually do...\n`|n -m| <= 1` is just a weird condition explaining for a weird example they provided `s = s1 + s2 + ... + sn`, `t = t1 + t2 + ... + tm`\nbut no need to care about it. e.g.: `s1 = \"a\" + \"b\" + \"c\" + \"d\" (m=4)`, `s2 = \"e\" + \"f\" (n=2)`, `s3 = \"aebfcd\"`. it is not `s3 = \"a\" + \"e\" + \"b\"+ \"f\" + \"c\" + \"d\"`  (m=4, n=2), because obviously \"c\" and \"d\" are 2 continuous characters in `s1`. it is `s3 = \"a\" + \"e\" + \"b\"+ \"f\" + \"cd\"` (m=3, n=2)\nhence, just ignore it"
                    },
                    {
                        "username": "ahrix268",
                        "content": "I remember when I was a newbie to Leetcode and DP, using pick one randomly and they gave me this problem. I was like how the hell people could solve this shit..."
                    },
                    {
                        "username": "mindstuck",
                        "content": "Why are we ignoring the condition |n-m|<=1?\\nNone of the solutions is checking that condition."
                    },
                    {
                        "username": "mindstuck",
                        "content": "[@ahrix268](/ahrix268) Gotch Thanks!"
                    },
                    {
                        "username": "mindstuck",
                        "content": "[@amitbansal13](/amitbansal13) cool, gotcha thanks!"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Consider the case s1,s2 and t1,t2,t3,t4\\n\\nWe will have the final string as \\n\\nsomething like s1,t1,s2,t2,t3,t4 - We can consider t2,t3,t4 as one substring \\n\\nSimilar situation for other permutations/cases."
                    },
                    {
                        "username": "ahrix268",
                        "content": "https://leetcode.com/problems/interleaving-string/description/comments/2029662 i explained in this. conclusion: \"just a weird and obviously condition explaining for their very \"humanity\" example\""
                    },
                    {
                        "username": "JiayingGao",
                        "content": "This is so classic."
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "1. What is meaning by |n - m| <= 1 ?\\n\\nAnd in every solution it ignored. In question\\'s description it is mentioned that interleaving string means concatenate the substrings alternately. \\n2. Am i going wrong with the understanding of the question??"
                    },
                    {
                        "username": "ahrix268",
                        "content": "https://leetcode.com/problems/interleaving-string/description/comments/2029662 conclusion: \"just a weird and obviously condition explaining for their very \"humanity\" example\""
                    },
                    {
                        "username": "bhati25",
                        "content": "<h1>Thank you leetcode daily questions, you have made DP so easy. </h1>\\n<h1>Now DP is \\uD83E\\uDEF6.</h1>"
                    },
                    {
                        "username": "yash___saxena",
                        "content": "It is giving TLE, Some one can help😣, I don't know Why?\njava:  \n\nclass Solution {\n\n    public boolean isInterleave(String s1, String s2, String s3) {\n        if(s1.length()+s2.length()!=s3.length())\n        return false;\n        Boolean dp[][]=new Boolean[s1.length()+1][s2.length()+1];\n        return interleave(0,0,0,dp,s1,s2,s3);\n    }\n    boolean interleave(int i,int j,int k,Boolean dp[][],String s1,String s2,String s3)\n    {\n        if(dp[i][j]!=null)\n        return dp[i][j];\n         while(k<s3.length())\n            {\n                if(i<s1.length() &&  j<s2.length()  && s3.charAt(k)==s2.charAt(j) && s3.charAt(k)==s1.charAt(i))\n              {\n                return dp[i][j]=interleave(i+1,j,k+1,dp,s1,s2,s3)|| interleave(i,j+1,k+1,dp,s1,s2,s3); \n              }\n            else if(i<s1.length() && s3.charAt(k)==s1.charAt(i))\n            {\n                i++;\n\n            }\n            else if( j<s2.length() && s3.charAt(k)==s2.charAt(j))\n            {\n              j++;\n            }\n            else\n            return dp[i][j]=false;\n            k++;\n        }\n        if(i==s1.length() && j==s2.length())\n        return dp[i][j]=true;\n        else\n        return dp[i][j]=false;\n    }\n}"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "This Question makes my mind more Curious and Puzzled."
                    }
                ]
            },
            {
                "id": 2029600,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "Am I the only one who has no idea what the task wants?\\n\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Why is my recursive solution with `O(s1.length * s2.length)` space faster than my iterative solution with `O(s2.length)` space?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "after more than twice times reading their description, which is also very \"humanity\" as they usually do...\n`|n -m| <= 1` is just a weird condition explaining for a weird example they provided `s = s1 + s2 + ... + sn`, `t = t1 + t2 + ... + tm`\nbut no need to care about it. e.g.: `s1 = \"a\" + \"b\" + \"c\" + \"d\" (m=4)`, `s2 = \"e\" + \"f\" (n=2)`, `s3 = \"aebfcd\"`. it is not `s3 = \"a\" + \"e\" + \"b\"+ \"f\" + \"c\" + \"d\"`  (m=4, n=2), because obviously \"c\" and \"d\" are 2 continuous characters in `s1`. it is `s3 = \"a\" + \"e\" + \"b\"+ \"f\" + \"cd\"` (m=3, n=2)\nhence, just ignore it"
                    },
                    {
                        "username": "ahrix268",
                        "content": "I remember when I was a newbie to Leetcode and DP, using pick one randomly and they gave me this problem. I was like how the hell people could solve this shit..."
                    },
                    {
                        "username": "mindstuck",
                        "content": "Why are we ignoring the condition |n-m|<=1?\\nNone of the solutions is checking that condition."
                    },
                    {
                        "username": "mindstuck",
                        "content": "[@ahrix268](/ahrix268) Gotch Thanks!"
                    },
                    {
                        "username": "mindstuck",
                        "content": "[@amitbansal13](/amitbansal13) cool, gotcha thanks!"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Consider the case s1,s2 and t1,t2,t3,t4\\n\\nWe will have the final string as \\n\\nsomething like s1,t1,s2,t2,t3,t4 - We can consider t2,t3,t4 as one substring \\n\\nSimilar situation for other permutations/cases."
                    },
                    {
                        "username": "ahrix268",
                        "content": "https://leetcode.com/problems/interleaving-string/description/comments/2029662 i explained in this. conclusion: \"just a weird and obviously condition explaining for their very \"humanity\" example\""
                    },
                    {
                        "username": "JiayingGao",
                        "content": "This is so classic."
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "1. What is meaning by |n - m| <= 1 ?\\n\\nAnd in every solution it ignored. In question\\'s description it is mentioned that interleaving string means concatenate the substrings alternately. \\n2. Am i going wrong with the understanding of the question??"
                    },
                    {
                        "username": "ahrix268",
                        "content": "https://leetcode.com/problems/interleaving-string/description/comments/2029662 conclusion: \"just a weird and obviously condition explaining for their very \"humanity\" example\""
                    },
                    {
                        "username": "bhati25",
                        "content": "<h1>Thank you leetcode daily questions, you have made DP so easy. </h1>\\n<h1>Now DP is \\uD83E\\uDEF6.</h1>"
                    },
                    {
                        "username": "yash___saxena",
                        "content": "It is giving TLE, Some one can help😣, I don't know Why?\njava:  \n\nclass Solution {\n\n    public boolean isInterleave(String s1, String s2, String s3) {\n        if(s1.length()+s2.length()!=s3.length())\n        return false;\n        Boolean dp[][]=new Boolean[s1.length()+1][s2.length()+1];\n        return interleave(0,0,0,dp,s1,s2,s3);\n    }\n    boolean interleave(int i,int j,int k,Boolean dp[][],String s1,String s2,String s3)\n    {\n        if(dp[i][j]!=null)\n        return dp[i][j];\n         while(k<s3.length())\n            {\n                if(i<s1.length() &&  j<s2.length()  && s3.charAt(k)==s2.charAt(j) && s3.charAt(k)==s1.charAt(i))\n              {\n                return dp[i][j]=interleave(i+1,j,k+1,dp,s1,s2,s3)|| interleave(i,j+1,k+1,dp,s1,s2,s3); \n              }\n            else if(i<s1.length() && s3.charAt(k)==s1.charAt(i))\n            {\n                i++;\n\n            }\n            else if( j<s2.length() && s3.charAt(k)==s2.charAt(j))\n            {\n              j++;\n            }\n            else\n            return dp[i][j]=false;\n            k++;\n        }\n        if(i==s1.length() && j==s2.length())\n        return dp[i][j]=true;\n        else\n        return dp[i][j]=false;\n    }\n}"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "This Question makes my mind more Curious and Puzzled."
                    }
                ]
            },
            {
                "id": 2029564,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "Am I the only one who has no idea what the task wants?\\n\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Why is my recursive solution with `O(s1.length * s2.length)` space faster than my iterative solution with `O(s2.length)` space?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "after more than twice times reading their description, which is also very \"humanity\" as they usually do...\n`|n -m| <= 1` is just a weird condition explaining for a weird example they provided `s = s1 + s2 + ... + sn`, `t = t1 + t2 + ... + tm`\nbut no need to care about it. e.g.: `s1 = \"a\" + \"b\" + \"c\" + \"d\" (m=4)`, `s2 = \"e\" + \"f\" (n=2)`, `s3 = \"aebfcd\"`. it is not `s3 = \"a\" + \"e\" + \"b\"+ \"f\" + \"c\" + \"d\"`  (m=4, n=2), because obviously \"c\" and \"d\" are 2 continuous characters in `s1`. it is `s3 = \"a\" + \"e\" + \"b\"+ \"f\" + \"cd\"` (m=3, n=2)\nhence, just ignore it"
                    },
                    {
                        "username": "ahrix268",
                        "content": "I remember when I was a newbie to Leetcode and DP, using pick one randomly and they gave me this problem. I was like how the hell people could solve this shit..."
                    },
                    {
                        "username": "mindstuck",
                        "content": "Why are we ignoring the condition |n-m|<=1?\\nNone of the solutions is checking that condition."
                    },
                    {
                        "username": "mindstuck",
                        "content": "[@ahrix268](/ahrix268) Gotch Thanks!"
                    },
                    {
                        "username": "mindstuck",
                        "content": "[@amitbansal13](/amitbansal13) cool, gotcha thanks!"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Consider the case s1,s2 and t1,t2,t3,t4\\n\\nWe will have the final string as \\n\\nsomething like s1,t1,s2,t2,t3,t4 - We can consider t2,t3,t4 as one substring \\n\\nSimilar situation for other permutations/cases."
                    },
                    {
                        "username": "ahrix268",
                        "content": "https://leetcode.com/problems/interleaving-string/description/comments/2029662 i explained in this. conclusion: \"just a weird and obviously condition explaining for their very \"humanity\" example\""
                    },
                    {
                        "username": "JiayingGao",
                        "content": "This is so classic."
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "1. What is meaning by |n - m| <= 1 ?\\n\\nAnd in every solution it ignored. In question\\'s description it is mentioned that interleaving string means concatenate the substrings alternately. \\n2. Am i going wrong with the understanding of the question??"
                    },
                    {
                        "username": "ahrix268",
                        "content": "https://leetcode.com/problems/interleaving-string/description/comments/2029662 conclusion: \"just a weird and obviously condition explaining for their very \"humanity\" example\""
                    },
                    {
                        "username": "bhati25",
                        "content": "<h1>Thank you leetcode daily questions, you have made DP so easy. </h1>\\n<h1>Now DP is \\uD83E\\uDEF6.</h1>"
                    },
                    {
                        "username": "yash___saxena",
                        "content": "It is giving TLE, Some one can help😣, I don't know Why?\njava:  \n\nclass Solution {\n\n    public boolean isInterleave(String s1, String s2, String s3) {\n        if(s1.length()+s2.length()!=s3.length())\n        return false;\n        Boolean dp[][]=new Boolean[s1.length()+1][s2.length()+1];\n        return interleave(0,0,0,dp,s1,s2,s3);\n    }\n    boolean interleave(int i,int j,int k,Boolean dp[][],String s1,String s2,String s3)\n    {\n        if(dp[i][j]!=null)\n        return dp[i][j];\n         while(k<s3.length())\n            {\n                if(i<s1.length() &&  j<s2.length()  && s3.charAt(k)==s2.charAt(j) && s3.charAt(k)==s1.charAt(i))\n              {\n                return dp[i][j]=interleave(i+1,j,k+1,dp,s1,s2,s3)|| interleave(i,j+1,k+1,dp,s1,s2,s3); \n              }\n            else if(i<s1.length() && s3.charAt(k)==s1.charAt(i))\n            {\n                i++;\n\n            }\n            else if( j<s2.length() && s3.charAt(k)==s2.charAt(j))\n            {\n              j++;\n            }\n            else\n            return dp[i][j]=false;\n            k++;\n        }\n        if(i==s1.length() && j==s2.length())\n        return dp[i][j]=true;\n        else\n        return dp[i][j]=false;\n    }\n}"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "This Question makes my mind more Curious and Puzzled."
                    }
                ]
            },
            {
                "id": 2029559,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "Am I the only one who has no idea what the task wants?\\n\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Why is my recursive solution with `O(s1.length * s2.length)` space faster than my iterative solution with `O(s2.length)` space?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "after more than twice times reading their description, which is also very \"humanity\" as they usually do...\n`|n -m| <= 1` is just a weird condition explaining for a weird example they provided `s = s1 + s2 + ... + sn`, `t = t1 + t2 + ... + tm`\nbut no need to care about it. e.g.: `s1 = \"a\" + \"b\" + \"c\" + \"d\" (m=4)`, `s2 = \"e\" + \"f\" (n=2)`, `s3 = \"aebfcd\"`. it is not `s3 = \"a\" + \"e\" + \"b\"+ \"f\" + \"c\" + \"d\"`  (m=4, n=2), because obviously \"c\" and \"d\" are 2 continuous characters in `s1`. it is `s3 = \"a\" + \"e\" + \"b\"+ \"f\" + \"cd\"` (m=3, n=2)\nhence, just ignore it"
                    },
                    {
                        "username": "ahrix268",
                        "content": "I remember when I was a newbie to Leetcode and DP, using pick one randomly and they gave me this problem. I was like how the hell people could solve this shit..."
                    },
                    {
                        "username": "mindstuck",
                        "content": "Why are we ignoring the condition |n-m|<=1?\\nNone of the solutions is checking that condition."
                    },
                    {
                        "username": "mindstuck",
                        "content": "[@ahrix268](/ahrix268) Gotch Thanks!"
                    },
                    {
                        "username": "mindstuck",
                        "content": "[@amitbansal13](/amitbansal13) cool, gotcha thanks!"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Consider the case s1,s2 and t1,t2,t3,t4\\n\\nWe will have the final string as \\n\\nsomething like s1,t1,s2,t2,t3,t4 - We can consider t2,t3,t4 as one substring \\n\\nSimilar situation for other permutations/cases."
                    },
                    {
                        "username": "ahrix268",
                        "content": "https://leetcode.com/problems/interleaving-string/description/comments/2029662 i explained in this. conclusion: \"just a weird and obviously condition explaining for their very \"humanity\" example\""
                    },
                    {
                        "username": "JiayingGao",
                        "content": "This is so classic."
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "1. What is meaning by |n - m| <= 1 ?\\n\\nAnd in every solution it ignored. In question\\'s description it is mentioned that interleaving string means concatenate the substrings alternately. \\n2. Am i going wrong with the understanding of the question??"
                    },
                    {
                        "username": "ahrix268",
                        "content": "https://leetcode.com/problems/interleaving-string/description/comments/2029662 conclusion: \"just a weird and obviously condition explaining for their very \"humanity\" example\""
                    },
                    {
                        "username": "bhati25",
                        "content": "<h1>Thank you leetcode daily questions, you have made DP so easy. </h1>\\n<h1>Now DP is \\uD83E\\uDEF6.</h1>"
                    },
                    {
                        "username": "yash___saxena",
                        "content": "It is giving TLE, Some one can help😣, I don't know Why?\njava:  \n\nclass Solution {\n\n    public boolean isInterleave(String s1, String s2, String s3) {\n        if(s1.length()+s2.length()!=s3.length())\n        return false;\n        Boolean dp[][]=new Boolean[s1.length()+1][s2.length()+1];\n        return interleave(0,0,0,dp,s1,s2,s3);\n    }\n    boolean interleave(int i,int j,int k,Boolean dp[][],String s1,String s2,String s3)\n    {\n        if(dp[i][j]!=null)\n        return dp[i][j];\n         while(k<s3.length())\n            {\n                if(i<s1.length() &&  j<s2.length()  && s3.charAt(k)==s2.charAt(j) && s3.charAt(k)==s1.charAt(i))\n              {\n                return dp[i][j]=interleave(i+1,j,k+1,dp,s1,s2,s3)|| interleave(i,j+1,k+1,dp,s1,s2,s3); \n              }\n            else if(i<s1.length() && s3.charAt(k)==s1.charAt(i))\n            {\n                i++;\n\n            }\n            else if( j<s2.length() && s3.charAt(k)==s2.charAt(j))\n            {\n              j++;\n            }\n            else\n            return dp[i][j]=false;\n            k++;\n        }\n        if(i==s1.length() && j==s2.length())\n        return dp[i][j]=true;\n        else\n        return dp[i][j]=false;\n    }\n}"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "This Question makes my mind more Curious and Puzzled."
                    }
                ]
            },
            {
                "id": 2029518,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "Am I the only one who has no idea what the task wants?\\n\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Why is my recursive solution with `O(s1.length * s2.length)` space faster than my iterative solution with `O(s2.length)` space?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "after more than twice times reading their description, which is also very \"humanity\" as they usually do...\n`|n -m| <= 1` is just a weird condition explaining for a weird example they provided `s = s1 + s2 + ... + sn`, `t = t1 + t2 + ... + tm`\nbut no need to care about it. e.g.: `s1 = \"a\" + \"b\" + \"c\" + \"d\" (m=4)`, `s2 = \"e\" + \"f\" (n=2)`, `s3 = \"aebfcd\"`. it is not `s3 = \"a\" + \"e\" + \"b\"+ \"f\" + \"c\" + \"d\"`  (m=4, n=2), because obviously \"c\" and \"d\" are 2 continuous characters in `s1`. it is `s3 = \"a\" + \"e\" + \"b\"+ \"f\" + \"cd\"` (m=3, n=2)\nhence, just ignore it"
                    },
                    {
                        "username": "ahrix268",
                        "content": "I remember when I was a newbie to Leetcode and DP, using pick one randomly and they gave me this problem. I was like how the hell people could solve this shit..."
                    },
                    {
                        "username": "mindstuck",
                        "content": "Why are we ignoring the condition |n-m|<=1?\\nNone of the solutions is checking that condition."
                    },
                    {
                        "username": "mindstuck",
                        "content": "[@ahrix268](/ahrix268) Gotch Thanks!"
                    },
                    {
                        "username": "mindstuck",
                        "content": "[@amitbansal13](/amitbansal13) cool, gotcha thanks!"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Consider the case s1,s2 and t1,t2,t3,t4\\n\\nWe will have the final string as \\n\\nsomething like s1,t1,s2,t2,t3,t4 - We can consider t2,t3,t4 as one substring \\n\\nSimilar situation for other permutations/cases."
                    },
                    {
                        "username": "ahrix268",
                        "content": "https://leetcode.com/problems/interleaving-string/description/comments/2029662 i explained in this. conclusion: \"just a weird and obviously condition explaining for their very \"humanity\" example\""
                    },
                    {
                        "username": "JiayingGao",
                        "content": "This is so classic."
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "1. What is meaning by |n - m| <= 1 ?\\n\\nAnd in every solution it ignored. In question\\'s description it is mentioned that interleaving string means concatenate the substrings alternately. \\n2. Am i going wrong with the understanding of the question??"
                    },
                    {
                        "username": "ahrix268",
                        "content": "https://leetcode.com/problems/interleaving-string/description/comments/2029662 conclusion: \"just a weird and obviously condition explaining for their very \"humanity\" example\""
                    },
                    {
                        "username": "bhati25",
                        "content": "<h1>Thank you leetcode daily questions, you have made DP so easy. </h1>\\n<h1>Now DP is \\uD83E\\uDEF6.</h1>"
                    },
                    {
                        "username": "yash___saxena",
                        "content": "It is giving TLE, Some one can help😣, I don't know Why?\njava:  \n\nclass Solution {\n\n    public boolean isInterleave(String s1, String s2, String s3) {\n        if(s1.length()+s2.length()!=s3.length())\n        return false;\n        Boolean dp[][]=new Boolean[s1.length()+1][s2.length()+1];\n        return interleave(0,0,0,dp,s1,s2,s3);\n    }\n    boolean interleave(int i,int j,int k,Boolean dp[][],String s1,String s2,String s3)\n    {\n        if(dp[i][j]!=null)\n        return dp[i][j];\n         while(k<s3.length())\n            {\n                if(i<s1.length() &&  j<s2.length()  && s3.charAt(k)==s2.charAt(j) && s3.charAt(k)==s1.charAt(i))\n              {\n                return dp[i][j]=interleave(i+1,j,k+1,dp,s1,s2,s3)|| interleave(i,j+1,k+1,dp,s1,s2,s3); \n              }\n            else if(i<s1.length() && s3.charAt(k)==s1.charAt(i))\n            {\n                i++;\n\n            }\n            else if( j<s2.length() && s3.charAt(k)==s2.charAt(j))\n            {\n              j++;\n            }\n            else\n            return dp[i][j]=false;\n            k++;\n        }\n        if(i==s1.length() && j==s2.length())\n        return dp[i][j]=true;\n        else\n        return dp[i][j]=false;\n    }\n}"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "This Question makes my mind more Curious and Puzzled."
                    }
                ]
            },
            {
                "id": 2029479,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "Am I the only one who has no idea what the task wants?\\n\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Why is my recursive solution with `O(s1.length * s2.length)` space faster than my iterative solution with `O(s2.length)` space?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "after more than twice times reading their description, which is also very \"humanity\" as they usually do...\n`|n -m| <= 1` is just a weird condition explaining for a weird example they provided `s = s1 + s2 + ... + sn`, `t = t1 + t2 + ... + tm`\nbut no need to care about it. e.g.: `s1 = \"a\" + \"b\" + \"c\" + \"d\" (m=4)`, `s2 = \"e\" + \"f\" (n=2)`, `s3 = \"aebfcd\"`. it is not `s3 = \"a\" + \"e\" + \"b\"+ \"f\" + \"c\" + \"d\"`  (m=4, n=2), because obviously \"c\" and \"d\" are 2 continuous characters in `s1`. it is `s3 = \"a\" + \"e\" + \"b\"+ \"f\" + \"cd\"` (m=3, n=2)\nhence, just ignore it"
                    },
                    {
                        "username": "ahrix268",
                        "content": "I remember when I was a newbie to Leetcode and DP, using pick one randomly and they gave me this problem. I was like how the hell people could solve this shit..."
                    },
                    {
                        "username": "mindstuck",
                        "content": "Why are we ignoring the condition |n-m|<=1?\\nNone of the solutions is checking that condition."
                    },
                    {
                        "username": "mindstuck",
                        "content": "[@ahrix268](/ahrix268) Gotch Thanks!"
                    },
                    {
                        "username": "mindstuck",
                        "content": "[@amitbansal13](/amitbansal13) cool, gotcha thanks!"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Consider the case s1,s2 and t1,t2,t3,t4\\n\\nWe will have the final string as \\n\\nsomething like s1,t1,s2,t2,t3,t4 - We can consider t2,t3,t4 as one substring \\n\\nSimilar situation for other permutations/cases."
                    },
                    {
                        "username": "ahrix268",
                        "content": "https://leetcode.com/problems/interleaving-string/description/comments/2029662 i explained in this. conclusion: \"just a weird and obviously condition explaining for their very \"humanity\" example\""
                    },
                    {
                        "username": "JiayingGao",
                        "content": "This is so classic."
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "1. What is meaning by |n - m| <= 1 ?\\n\\nAnd in every solution it ignored. In question\\'s description it is mentioned that interleaving string means concatenate the substrings alternately. \\n2. Am i going wrong with the understanding of the question??"
                    },
                    {
                        "username": "ahrix268",
                        "content": "https://leetcode.com/problems/interleaving-string/description/comments/2029662 conclusion: \"just a weird and obviously condition explaining for their very \"humanity\" example\""
                    },
                    {
                        "username": "bhati25",
                        "content": "<h1>Thank you leetcode daily questions, you have made DP so easy. </h1>\\n<h1>Now DP is \\uD83E\\uDEF6.</h1>"
                    },
                    {
                        "username": "yash___saxena",
                        "content": "It is giving TLE, Some one can help😣, I don't know Why?\njava:  \n\nclass Solution {\n\n    public boolean isInterleave(String s1, String s2, String s3) {\n        if(s1.length()+s2.length()!=s3.length())\n        return false;\n        Boolean dp[][]=new Boolean[s1.length()+1][s2.length()+1];\n        return interleave(0,0,0,dp,s1,s2,s3);\n    }\n    boolean interleave(int i,int j,int k,Boolean dp[][],String s1,String s2,String s3)\n    {\n        if(dp[i][j]!=null)\n        return dp[i][j];\n         while(k<s3.length())\n            {\n                if(i<s1.length() &&  j<s2.length()  && s3.charAt(k)==s2.charAt(j) && s3.charAt(k)==s1.charAt(i))\n              {\n                return dp[i][j]=interleave(i+1,j,k+1,dp,s1,s2,s3)|| interleave(i,j+1,k+1,dp,s1,s2,s3); \n              }\n            else if(i<s1.length() && s3.charAt(k)==s1.charAt(i))\n            {\n                i++;\n\n            }\n            else if( j<s2.length() && s3.charAt(k)==s2.charAt(j))\n            {\n              j++;\n            }\n            else\n            return dp[i][j]=false;\n            k++;\n        }\n        if(i==s1.length() && j==s2.length())\n        return dp[i][j]=true;\n        else\n        return dp[i][j]=false;\n    }\n}"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "This Question makes my mind more Curious and Puzzled."
                    }
                ]
            },
            {
                "id": 2029477,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "Am I the only one who has no idea what the task wants?\\n\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Why is my recursive solution with `O(s1.length * s2.length)` space faster than my iterative solution with `O(s2.length)` space?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "after more than twice times reading their description, which is also very \"humanity\" as they usually do...\n`|n -m| <= 1` is just a weird condition explaining for a weird example they provided `s = s1 + s2 + ... + sn`, `t = t1 + t2 + ... + tm`\nbut no need to care about it. e.g.: `s1 = \"a\" + \"b\" + \"c\" + \"d\" (m=4)`, `s2 = \"e\" + \"f\" (n=2)`, `s3 = \"aebfcd\"`. it is not `s3 = \"a\" + \"e\" + \"b\"+ \"f\" + \"c\" + \"d\"`  (m=4, n=2), because obviously \"c\" and \"d\" are 2 continuous characters in `s1`. it is `s3 = \"a\" + \"e\" + \"b\"+ \"f\" + \"cd\"` (m=3, n=2)\nhence, just ignore it"
                    },
                    {
                        "username": "ahrix268",
                        "content": "I remember when I was a newbie to Leetcode and DP, using pick one randomly and they gave me this problem. I was like how the hell people could solve this shit..."
                    },
                    {
                        "username": "mindstuck",
                        "content": "Why are we ignoring the condition |n-m|<=1?\\nNone of the solutions is checking that condition."
                    },
                    {
                        "username": "mindstuck",
                        "content": "[@ahrix268](/ahrix268) Gotch Thanks!"
                    },
                    {
                        "username": "mindstuck",
                        "content": "[@amitbansal13](/amitbansal13) cool, gotcha thanks!"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Consider the case s1,s2 and t1,t2,t3,t4\\n\\nWe will have the final string as \\n\\nsomething like s1,t1,s2,t2,t3,t4 - We can consider t2,t3,t4 as one substring \\n\\nSimilar situation for other permutations/cases."
                    },
                    {
                        "username": "ahrix268",
                        "content": "https://leetcode.com/problems/interleaving-string/description/comments/2029662 i explained in this. conclusion: \"just a weird and obviously condition explaining for their very \"humanity\" example\""
                    },
                    {
                        "username": "JiayingGao",
                        "content": "This is so classic."
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "1. What is meaning by |n - m| <= 1 ?\\n\\nAnd in every solution it ignored. In question\\'s description it is mentioned that interleaving string means concatenate the substrings alternately. \\n2. Am i going wrong with the understanding of the question??"
                    },
                    {
                        "username": "ahrix268",
                        "content": "https://leetcode.com/problems/interleaving-string/description/comments/2029662 conclusion: \"just a weird and obviously condition explaining for their very \"humanity\" example\""
                    },
                    {
                        "username": "bhati25",
                        "content": "<h1>Thank you leetcode daily questions, you have made DP so easy. </h1>\\n<h1>Now DP is \\uD83E\\uDEF6.</h1>"
                    },
                    {
                        "username": "yash___saxena",
                        "content": "It is giving TLE, Some one can help😣, I don't know Why?\njava:  \n\nclass Solution {\n\n    public boolean isInterleave(String s1, String s2, String s3) {\n        if(s1.length()+s2.length()!=s3.length())\n        return false;\n        Boolean dp[][]=new Boolean[s1.length()+1][s2.length()+1];\n        return interleave(0,0,0,dp,s1,s2,s3);\n    }\n    boolean interleave(int i,int j,int k,Boolean dp[][],String s1,String s2,String s3)\n    {\n        if(dp[i][j]!=null)\n        return dp[i][j];\n         while(k<s3.length())\n            {\n                if(i<s1.length() &&  j<s2.length()  && s3.charAt(k)==s2.charAt(j) && s3.charAt(k)==s1.charAt(i))\n              {\n                return dp[i][j]=interleave(i+1,j,k+1,dp,s1,s2,s3)|| interleave(i,j+1,k+1,dp,s1,s2,s3); \n              }\n            else if(i<s1.length() && s3.charAt(k)==s1.charAt(i))\n            {\n                i++;\n\n            }\n            else if( j<s2.length() && s3.charAt(k)==s2.charAt(j))\n            {\n              j++;\n            }\n            else\n            return dp[i][j]=false;\n            k++;\n        }\n        if(i==s1.length() && j==s2.length())\n        return dp[i][j]=true;\n        else\n        return dp[i][j]=false;\n    }\n}"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "This Question makes my mind more Curious and Puzzled."
                    }
                ]
            },
            {
                "id": 2029419,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "Am I the only one who has no idea what the task wants?\\n\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Why is my recursive solution with `O(s1.length * s2.length)` space faster than my iterative solution with `O(s2.length)` space?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "after more than twice times reading their description, which is also very \"humanity\" as they usually do...\n`|n -m| <= 1` is just a weird condition explaining for a weird example they provided `s = s1 + s2 + ... + sn`, `t = t1 + t2 + ... + tm`\nbut no need to care about it. e.g.: `s1 = \"a\" + \"b\" + \"c\" + \"d\" (m=4)`, `s2 = \"e\" + \"f\" (n=2)`, `s3 = \"aebfcd\"`. it is not `s3 = \"a\" + \"e\" + \"b\"+ \"f\" + \"c\" + \"d\"`  (m=4, n=2), because obviously \"c\" and \"d\" are 2 continuous characters in `s1`. it is `s3 = \"a\" + \"e\" + \"b\"+ \"f\" + \"cd\"` (m=3, n=2)\nhence, just ignore it"
                    },
                    {
                        "username": "ahrix268",
                        "content": "I remember when I was a newbie to Leetcode and DP, using pick one randomly and they gave me this problem. I was like how the hell people could solve this shit..."
                    },
                    {
                        "username": "mindstuck",
                        "content": "Why are we ignoring the condition |n-m|<=1?\\nNone of the solutions is checking that condition."
                    },
                    {
                        "username": "mindstuck",
                        "content": "[@ahrix268](/ahrix268) Gotch Thanks!"
                    },
                    {
                        "username": "mindstuck",
                        "content": "[@amitbansal13](/amitbansal13) cool, gotcha thanks!"
                    },
                    {
                        "username": "amitbansal13",
                        "content": "Consider the case s1,s2 and t1,t2,t3,t4\\n\\nWe will have the final string as \\n\\nsomething like s1,t1,s2,t2,t3,t4 - We can consider t2,t3,t4 as one substring \\n\\nSimilar situation for other permutations/cases."
                    },
                    {
                        "username": "ahrix268",
                        "content": "https://leetcode.com/problems/interleaving-string/description/comments/2029662 i explained in this. conclusion: \"just a weird and obviously condition explaining for their very \"humanity\" example\""
                    },
                    {
                        "username": "JiayingGao",
                        "content": "This is so classic."
                    },
                    {
                        "username": "avigaikwad007",
                        "content": "1. What is meaning by |n - m| <= 1 ?\\n\\nAnd in every solution it ignored. In question\\'s description it is mentioned that interleaving string means concatenate the substrings alternately. \\n2. Am i going wrong with the understanding of the question??"
                    },
                    {
                        "username": "ahrix268",
                        "content": "https://leetcode.com/problems/interleaving-string/description/comments/2029662 conclusion: \"just a weird and obviously condition explaining for their very \"humanity\" example\""
                    },
                    {
                        "username": "bhati25",
                        "content": "<h1>Thank you leetcode daily questions, you have made DP so easy. </h1>\\n<h1>Now DP is \\uD83E\\uDEF6.</h1>"
                    },
                    {
                        "username": "yash___saxena",
                        "content": "It is giving TLE, Some one can help😣, I don't know Why?\njava:  \n\nclass Solution {\n\n    public boolean isInterleave(String s1, String s2, String s3) {\n        if(s1.length()+s2.length()!=s3.length())\n        return false;\n        Boolean dp[][]=new Boolean[s1.length()+1][s2.length()+1];\n        return interleave(0,0,0,dp,s1,s2,s3);\n    }\n    boolean interleave(int i,int j,int k,Boolean dp[][],String s1,String s2,String s3)\n    {\n        if(dp[i][j]!=null)\n        return dp[i][j];\n         while(k<s3.length())\n            {\n                if(i<s1.length() &&  j<s2.length()  && s3.charAt(k)==s2.charAt(j) && s3.charAt(k)==s1.charAt(i))\n              {\n                return dp[i][j]=interleave(i+1,j,k+1,dp,s1,s2,s3)|| interleave(i,j+1,k+1,dp,s1,s2,s3); \n              }\n            else if(i<s1.length() && s3.charAt(k)==s1.charAt(i))\n            {\n                i++;\n\n            }\n            else if( j<s2.length() && s3.charAt(k)==s2.charAt(j))\n            {\n              j++;\n            }\n            else\n            return dp[i][j]=false;\n            k++;\n        }\n        if(i==s1.length() && j==s2.length())\n        return dp[i][j]=true;\n        else\n        return dp[i][j]=false;\n    }\n}"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "This Question makes my mind more Curious and Puzzled."
                    }
                ]
            },
            {
                "id": 2029248,
                "content": [
                    {
                        "username": "dEAthWednesday",
                        "content": "passed 72 test cases plz help me\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        \\n        int n1 = s1.size();\\n        int n2 = s2.size();\\n        int n3 = s3.size();\\n        if (n1 + n2 != n3) {\\n            return false;\\n        }\\n\\n        queue<char> q1,q2;\\n\\n        for(int i=0;i<n1;i++){\\n            q1.push(s1[i]);\\n        }\\n        for(int i=0;i<n2;i++){\\n            q2.push(s2[i]);\\n        }\\n\\n        int i=0;\\n        while(!q1.empty() && !q2.empty() && i< n3){\\n            while(i<n3 && s3[i]==q1.front()){\\n                q1.pop();\\n                i++;\\n            }\\n            while(i<n3 && s3[i]==q2.front()){\\n                q2.pop();\\n                i++;\\n            }\\n            if(s3[i]!=q1.front() && s3[i]!=q2.front()){\\n                return false;\\n            }\\n        }\\n        while(!q1.empty() && i<n3){\\n            if(s3[i]==q1.front()){\\n                i++;\\n                q1.pop();\\n            }\\n            else return false;\\n        }\\n        while(!q2.empty() && i<n3){\\n            if(s3[i]==q2.front()){\\n                i++;\\n                q2.pop();\\n            }\\n            else return false;\\n        }\\n        return q1.empty() && q2.empty() && i == n3;\\n    }\\n};\\n// failed for s1 = \"a\" s2 = \"b\" s3=\"ab\""
                    },
                    {
                        "username": "sexyshit66",
                        "content": "  Can someone explain where is my code missing  to solve this problem\n\n class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        a, b, c = 0, 0, 0\n        while c < len(s3):\n            if a < len(s1) and s3[c] == s1[a]:\n                a += 1\n            elif b < len(s2) and s3[c] == s2[b]:\n                b += 1\n            else:\n                return False\n            c += 1\n        return True "
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "it shouldn\\'t be elif, for you need to check increment of a and b within the same c. Thus, both increment on a and b should be consider at the same time."
                    },
                    {
                        "username": "ingato",
                        "content": "Man, LeetCode really need to do a better job at explaining what they mean on a problem. It is not obvious AT ALL why the second example does not work. After doing a full implementation and trying to understand why my code is not working I finally realized that in order to work all the letters need to stay in the same order. Why can\\'t they just say that? "
                    },
                    {
                        "username": "tifv",
                        "content": "It follows directly from the given definition of \\u201Cinterleaving\\u201D. Relation $s = s_{1} + s_{2} + ... + s_{n}$ implies that $s_{1}$, \\u2026 $s_{n}$ form $s$ in that particular order; this is the same relative order in which they appear in the interleaved concatenations.\\n\\nLeetCode does not always succeed at giving clear problem statements, but in this particular case the definition is quite precise, in my opinion; example are not necessary to understand it."
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "This question looks lovely after the hard weekend"
                    },
                    {
                        "username": "psionl0",
                        "content": "The weekend is yet to come."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Oops \\uD83D\\uDE2C"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Initially I used a 3D table. Had to check the solution to figure out the 2D tabulation trick."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "For those who concern the constrain |n-m| <= 1, it is intrinsically right, you can do a small proof and you can see that. "
                    },
                    {
                        "username": "keshav3899",
                        "content": "Is there any way to solve this using LCS ?"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "Yes, it\\'s kind of LCS. Analyze deeply. "
                    },
                    {
                        "username": "boliu1997",
                        "content": "By definition of substring which requires it to be non-empty, the following testcase should give false instead of true:\\n\\ns1 = \"deeff\"\\ns2 = \"abbcc\"\\ns3 = \"abbccdeeff\"\\n\\nbecause the first substring of s1 has to be empty \"\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "In every test case, you will reach the end of one of the substrings before reaching the end of the other. Therefore, every test case would return false by your definition."
                    },
                    {
                        "username": "rohith1002",
                        "content": "\\nCan anyone tell whether this code is right , I\\'m able to pass 61 case and getting TLE , if these code is wrong pls let me know where did i go wrong. If this code is right pls help me in implementing dp !!!\\n \\n```\\nbool solve(string s1,string s2,int i,int j,string s3,bool flag,string temp)\\n  {\\n    if(temp==s3)\\n    return 1;\\n\\n    bool ans=0;\\n    if(flag)\\n    {\\n      for(int k=j+1;k<=s2.length();k++)\\n        ans=ans || solve(s1,s2,i,k,s3,0,temp+s2.substr(j,k-j));\\n    }\\n    else\\n    {\\n      for(int k=i+1;k<=s1.length();k++)\\n        ans=ans || solve(s1,s2,k,j,s3,1,temp+s1.substr(i,k-i));\\n    }\\n    return ans;\\n  }\\n  bool isInterleave(string s1, string s2, string s3) {\\n\\n    if(s1.length()+s2.length()!=s3.length())\\n    return 0;\\n    \\n    return solve(s1,s2,0,0,s3,0,\"\") || solve(s1,s2,0,0,s3,1,\"\");\\n  }\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Without memoization your code will repeatedly calculate the same sub cases over and over again."
                    }
                ]
            },
            {
                "id": 2029134,
                "content": [
                    {
                        "username": "dEAthWednesday",
                        "content": "passed 72 test cases plz help me\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        \\n        int n1 = s1.size();\\n        int n2 = s2.size();\\n        int n3 = s3.size();\\n        if (n1 + n2 != n3) {\\n            return false;\\n        }\\n\\n        queue<char> q1,q2;\\n\\n        for(int i=0;i<n1;i++){\\n            q1.push(s1[i]);\\n        }\\n        for(int i=0;i<n2;i++){\\n            q2.push(s2[i]);\\n        }\\n\\n        int i=0;\\n        while(!q1.empty() && !q2.empty() && i< n3){\\n            while(i<n3 && s3[i]==q1.front()){\\n                q1.pop();\\n                i++;\\n            }\\n            while(i<n3 && s3[i]==q2.front()){\\n                q2.pop();\\n                i++;\\n            }\\n            if(s3[i]!=q1.front() && s3[i]!=q2.front()){\\n                return false;\\n            }\\n        }\\n        while(!q1.empty() && i<n3){\\n            if(s3[i]==q1.front()){\\n                i++;\\n                q1.pop();\\n            }\\n            else return false;\\n        }\\n        while(!q2.empty() && i<n3){\\n            if(s3[i]==q2.front()){\\n                i++;\\n                q2.pop();\\n            }\\n            else return false;\\n        }\\n        return q1.empty() && q2.empty() && i == n3;\\n    }\\n};\\n// failed for s1 = \"a\" s2 = \"b\" s3=\"ab\""
                    },
                    {
                        "username": "sexyshit66",
                        "content": "  Can someone explain where is my code missing  to solve this problem\n\n class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        a, b, c = 0, 0, 0\n        while c < len(s3):\n            if a < len(s1) and s3[c] == s1[a]:\n                a += 1\n            elif b < len(s2) and s3[c] == s2[b]:\n                b += 1\n            else:\n                return False\n            c += 1\n        return True "
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "it shouldn\\'t be elif, for you need to check increment of a and b within the same c. Thus, both increment on a and b should be consider at the same time."
                    },
                    {
                        "username": "ingato",
                        "content": "Man, LeetCode really need to do a better job at explaining what they mean on a problem. It is not obvious AT ALL why the second example does not work. After doing a full implementation and trying to understand why my code is not working I finally realized that in order to work all the letters need to stay in the same order. Why can\\'t they just say that? "
                    },
                    {
                        "username": "tifv",
                        "content": "It follows directly from the given definition of \\u201Cinterleaving\\u201D. Relation $s = s_{1} + s_{2} + ... + s_{n}$ implies that $s_{1}$, \\u2026 $s_{n}$ form $s$ in that particular order; this is the same relative order in which they appear in the interleaved concatenations.\\n\\nLeetCode does not always succeed at giving clear problem statements, but in this particular case the definition is quite precise, in my opinion; example are not necessary to understand it."
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "This question looks lovely after the hard weekend"
                    },
                    {
                        "username": "psionl0",
                        "content": "The weekend is yet to come."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Oops \\uD83D\\uDE2C"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Initially I used a 3D table. Had to check the solution to figure out the 2D tabulation trick."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "For those who concern the constrain |n-m| <= 1, it is intrinsically right, you can do a small proof and you can see that. "
                    },
                    {
                        "username": "keshav3899",
                        "content": "Is there any way to solve this using LCS ?"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "Yes, it\\'s kind of LCS. Analyze deeply. "
                    },
                    {
                        "username": "boliu1997",
                        "content": "By definition of substring which requires it to be non-empty, the following testcase should give false instead of true:\\n\\ns1 = \"deeff\"\\ns2 = \"abbcc\"\\ns3 = \"abbccdeeff\"\\n\\nbecause the first substring of s1 has to be empty \"\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "In every test case, you will reach the end of one of the substrings before reaching the end of the other. Therefore, every test case would return false by your definition."
                    },
                    {
                        "username": "rohith1002",
                        "content": "\\nCan anyone tell whether this code is right , I\\'m able to pass 61 case and getting TLE , if these code is wrong pls let me know where did i go wrong. If this code is right pls help me in implementing dp !!!\\n \\n```\\nbool solve(string s1,string s2,int i,int j,string s3,bool flag,string temp)\\n  {\\n    if(temp==s3)\\n    return 1;\\n\\n    bool ans=0;\\n    if(flag)\\n    {\\n      for(int k=j+1;k<=s2.length();k++)\\n        ans=ans || solve(s1,s2,i,k,s3,0,temp+s2.substr(j,k-j));\\n    }\\n    else\\n    {\\n      for(int k=i+1;k<=s1.length();k++)\\n        ans=ans || solve(s1,s2,k,j,s3,1,temp+s1.substr(i,k-i));\\n    }\\n    return ans;\\n  }\\n  bool isInterleave(string s1, string s2, string s3) {\\n\\n    if(s1.length()+s2.length()!=s3.length())\\n    return 0;\\n    \\n    return solve(s1,s2,0,0,s3,0,\"\") || solve(s1,s2,0,0,s3,1,\"\");\\n  }\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Without memoization your code will repeatedly calculate the same sub cases over and over again."
                    }
                ]
            },
            {
                "id": 2029075,
                "content": [
                    {
                        "username": "dEAthWednesday",
                        "content": "passed 72 test cases plz help me\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        \\n        int n1 = s1.size();\\n        int n2 = s2.size();\\n        int n3 = s3.size();\\n        if (n1 + n2 != n3) {\\n            return false;\\n        }\\n\\n        queue<char> q1,q2;\\n\\n        for(int i=0;i<n1;i++){\\n            q1.push(s1[i]);\\n        }\\n        for(int i=0;i<n2;i++){\\n            q2.push(s2[i]);\\n        }\\n\\n        int i=0;\\n        while(!q1.empty() && !q2.empty() && i< n3){\\n            while(i<n3 && s3[i]==q1.front()){\\n                q1.pop();\\n                i++;\\n            }\\n            while(i<n3 && s3[i]==q2.front()){\\n                q2.pop();\\n                i++;\\n            }\\n            if(s3[i]!=q1.front() && s3[i]!=q2.front()){\\n                return false;\\n            }\\n        }\\n        while(!q1.empty() && i<n3){\\n            if(s3[i]==q1.front()){\\n                i++;\\n                q1.pop();\\n            }\\n            else return false;\\n        }\\n        while(!q2.empty() && i<n3){\\n            if(s3[i]==q2.front()){\\n                i++;\\n                q2.pop();\\n            }\\n            else return false;\\n        }\\n        return q1.empty() && q2.empty() && i == n3;\\n    }\\n};\\n// failed for s1 = \"a\" s2 = \"b\" s3=\"ab\""
                    },
                    {
                        "username": "sexyshit66",
                        "content": "  Can someone explain where is my code missing  to solve this problem\n\n class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        a, b, c = 0, 0, 0\n        while c < len(s3):\n            if a < len(s1) and s3[c] == s1[a]:\n                a += 1\n            elif b < len(s2) and s3[c] == s2[b]:\n                b += 1\n            else:\n                return False\n            c += 1\n        return True "
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "it shouldn\\'t be elif, for you need to check increment of a and b within the same c. Thus, both increment on a and b should be consider at the same time."
                    },
                    {
                        "username": "ingato",
                        "content": "Man, LeetCode really need to do a better job at explaining what they mean on a problem. It is not obvious AT ALL why the second example does not work. After doing a full implementation and trying to understand why my code is not working I finally realized that in order to work all the letters need to stay in the same order. Why can\\'t they just say that? "
                    },
                    {
                        "username": "tifv",
                        "content": "It follows directly from the given definition of \\u201Cinterleaving\\u201D. Relation $s = s_{1} + s_{2} + ... + s_{n}$ implies that $s_{1}$, \\u2026 $s_{n}$ form $s$ in that particular order; this is the same relative order in which they appear in the interleaved concatenations.\\n\\nLeetCode does not always succeed at giving clear problem statements, but in this particular case the definition is quite precise, in my opinion; example are not necessary to understand it."
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "This question looks lovely after the hard weekend"
                    },
                    {
                        "username": "psionl0",
                        "content": "The weekend is yet to come."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Oops \\uD83D\\uDE2C"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Initially I used a 3D table. Had to check the solution to figure out the 2D tabulation trick."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "For those who concern the constrain |n-m| <= 1, it is intrinsically right, you can do a small proof and you can see that. "
                    },
                    {
                        "username": "keshav3899",
                        "content": "Is there any way to solve this using LCS ?"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "Yes, it\\'s kind of LCS. Analyze deeply. "
                    },
                    {
                        "username": "boliu1997",
                        "content": "By definition of substring which requires it to be non-empty, the following testcase should give false instead of true:\\n\\ns1 = \"deeff\"\\ns2 = \"abbcc\"\\ns3 = \"abbccdeeff\"\\n\\nbecause the first substring of s1 has to be empty \"\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "In every test case, you will reach the end of one of the substrings before reaching the end of the other. Therefore, every test case would return false by your definition."
                    },
                    {
                        "username": "rohith1002",
                        "content": "\\nCan anyone tell whether this code is right , I\\'m able to pass 61 case and getting TLE , if these code is wrong pls let me know where did i go wrong. If this code is right pls help me in implementing dp !!!\\n \\n```\\nbool solve(string s1,string s2,int i,int j,string s3,bool flag,string temp)\\n  {\\n    if(temp==s3)\\n    return 1;\\n\\n    bool ans=0;\\n    if(flag)\\n    {\\n      for(int k=j+1;k<=s2.length();k++)\\n        ans=ans || solve(s1,s2,i,k,s3,0,temp+s2.substr(j,k-j));\\n    }\\n    else\\n    {\\n      for(int k=i+1;k<=s1.length();k++)\\n        ans=ans || solve(s1,s2,k,j,s3,1,temp+s1.substr(i,k-i));\\n    }\\n    return ans;\\n  }\\n  bool isInterleave(string s1, string s2, string s3) {\\n\\n    if(s1.length()+s2.length()!=s3.length())\\n    return 0;\\n    \\n    return solve(s1,s2,0,0,s3,0,\"\") || solve(s1,s2,0,0,s3,1,\"\");\\n  }\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Without memoization your code will repeatedly calculate the same sub cases over and over again."
                    }
                ]
            },
            {
                "id": 2029021,
                "content": [
                    {
                        "username": "dEAthWednesday",
                        "content": "passed 72 test cases plz help me\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        \\n        int n1 = s1.size();\\n        int n2 = s2.size();\\n        int n3 = s3.size();\\n        if (n1 + n2 != n3) {\\n            return false;\\n        }\\n\\n        queue<char> q1,q2;\\n\\n        for(int i=0;i<n1;i++){\\n            q1.push(s1[i]);\\n        }\\n        for(int i=0;i<n2;i++){\\n            q2.push(s2[i]);\\n        }\\n\\n        int i=0;\\n        while(!q1.empty() && !q2.empty() && i< n3){\\n            while(i<n3 && s3[i]==q1.front()){\\n                q1.pop();\\n                i++;\\n            }\\n            while(i<n3 && s3[i]==q2.front()){\\n                q2.pop();\\n                i++;\\n            }\\n            if(s3[i]!=q1.front() && s3[i]!=q2.front()){\\n                return false;\\n            }\\n        }\\n        while(!q1.empty() && i<n3){\\n            if(s3[i]==q1.front()){\\n                i++;\\n                q1.pop();\\n            }\\n            else return false;\\n        }\\n        while(!q2.empty() && i<n3){\\n            if(s3[i]==q2.front()){\\n                i++;\\n                q2.pop();\\n            }\\n            else return false;\\n        }\\n        return q1.empty() && q2.empty() && i == n3;\\n    }\\n};\\n// failed for s1 = \"a\" s2 = \"b\" s3=\"ab\""
                    },
                    {
                        "username": "sexyshit66",
                        "content": "  Can someone explain where is my code missing  to solve this problem\n\n class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        a, b, c = 0, 0, 0\n        while c < len(s3):\n            if a < len(s1) and s3[c] == s1[a]:\n                a += 1\n            elif b < len(s2) and s3[c] == s2[b]:\n                b += 1\n            else:\n                return False\n            c += 1\n        return True "
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "it shouldn\\'t be elif, for you need to check increment of a and b within the same c. Thus, both increment on a and b should be consider at the same time."
                    },
                    {
                        "username": "ingato",
                        "content": "Man, LeetCode really need to do a better job at explaining what they mean on a problem. It is not obvious AT ALL why the second example does not work. After doing a full implementation and trying to understand why my code is not working I finally realized that in order to work all the letters need to stay in the same order. Why can\\'t they just say that? "
                    },
                    {
                        "username": "tifv",
                        "content": "It follows directly from the given definition of \\u201Cinterleaving\\u201D. Relation $s = s_{1} + s_{2} + ... + s_{n}$ implies that $s_{1}$, \\u2026 $s_{n}$ form $s$ in that particular order; this is the same relative order in which they appear in the interleaved concatenations.\\n\\nLeetCode does not always succeed at giving clear problem statements, but in this particular case the definition is quite precise, in my opinion; example are not necessary to understand it."
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "This question looks lovely after the hard weekend"
                    },
                    {
                        "username": "psionl0",
                        "content": "The weekend is yet to come."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Oops \\uD83D\\uDE2C"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Initially I used a 3D table. Had to check the solution to figure out the 2D tabulation trick."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "For those who concern the constrain |n-m| <= 1, it is intrinsically right, you can do a small proof and you can see that. "
                    },
                    {
                        "username": "keshav3899",
                        "content": "Is there any way to solve this using LCS ?"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "Yes, it\\'s kind of LCS. Analyze deeply. "
                    },
                    {
                        "username": "boliu1997",
                        "content": "By definition of substring which requires it to be non-empty, the following testcase should give false instead of true:\\n\\ns1 = \"deeff\"\\ns2 = \"abbcc\"\\ns3 = \"abbccdeeff\"\\n\\nbecause the first substring of s1 has to be empty \"\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "In every test case, you will reach the end of one of the substrings before reaching the end of the other. Therefore, every test case would return false by your definition."
                    },
                    {
                        "username": "rohith1002",
                        "content": "\\nCan anyone tell whether this code is right , I\\'m able to pass 61 case and getting TLE , if these code is wrong pls let me know where did i go wrong. If this code is right pls help me in implementing dp !!!\\n \\n```\\nbool solve(string s1,string s2,int i,int j,string s3,bool flag,string temp)\\n  {\\n    if(temp==s3)\\n    return 1;\\n\\n    bool ans=0;\\n    if(flag)\\n    {\\n      for(int k=j+1;k<=s2.length();k++)\\n        ans=ans || solve(s1,s2,i,k,s3,0,temp+s2.substr(j,k-j));\\n    }\\n    else\\n    {\\n      for(int k=i+1;k<=s1.length();k++)\\n        ans=ans || solve(s1,s2,k,j,s3,1,temp+s1.substr(i,k-i));\\n    }\\n    return ans;\\n  }\\n  bool isInterleave(string s1, string s2, string s3) {\\n\\n    if(s1.length()+s2.length()!=s3.length())\\n    return 0;\\n    \\n    return solve(s1,s2,0,0,s3,0,\"\") || solve(s1,s2,0,0,s3,1,\"\");\\n  }\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Without memoization your code will repeatedly calculate the same sub cases over and over again."
                    }
                ]
            },
            {
                "id": 2029017,
                "content": [
                    {
                        "username": "dEAthWednesday",
                        "content": "passed 72 test cases plz help me\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        \\n        int n1 = s1.size();\\n        int n2 = s2.size();\\n        int n3 = s3.size();\\n        if (n1 + n2 != n3) {\\n            return false;\\n        }\\n\\n        queue<char> q1,q2;\\n\\n        for(int i=0;i<n1;i++){\\n            q1.push(s1[i]);\\n        }\\n        for(int i=0;i<n2;i++){\\n            q2.push(s2[i]);\\n        }\\n\\n        int i=0;\\n        while(!q1.empty() && !q2.empty() && i< n3){\\n            while(i<n3 && s3[i]==q1.front()){\\n                q1.pop();\\n                i++;\\n            }\\n            while(i<n3 && s3[i]==q2.front()){\\n                q2.pop();\\n                i++;\\n            }\\n            if(s3[i]!=q1.front() && s3[i]!=q2.front()){\\n                return false;\\n            }\\n        }\\n        while(!q1.empty() && i<n3){\\n            if(s3[i]==q1.front()){\\n                i++;\\n                q1.pop();\\n            }\\n            else return false;\\n        }\\n        while(!q2.empty() && i<n3){\\n            if(s3[i]==q2.front()){\\n                i++;\\n                q2.pop();\\n            }\\n            else return false;\\n        }\\n        return q1.empty() && q2.empty() && i == n3;\\n    }\\n};\\n// failed for s1 = \"a\" s2 = \"b\" s3=\"ab\""
                    },
                    {
                        "username": "sexyshit66",
                        "content": "  Can someone explain where is my code missing  to solve this problem\n\n class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        a, b, c = 0, 0, 0\n        while c < len(s3):\n            if a < len(s1) and s3[c] == s1[a]:\n                a += 1\n            elif b < len(s2) and s3[c] == s2[b]:\n                b += 1\n            else:\n                return False\n            c += 1\n        return True "
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "it shouldn\\'t be elif, for you need to check increment of a and b within the same c. Thus, both increment on a and b should be consider at the same time."
                    },
                    {
                        "username": "ingato",
                        "content": "Man, LeetCode really need to do a better job at explaining what they mean on a problem. It is not obvious AT ALL why the second example does not work. After doing a full implementation and trying to understand why my code is not working I finally realized that in order to work all the letters need to stay in the same order. Why can\\'t they just say that? "
                    },
                    {
                        "username": "tifv",
                        "content": "It follows directly from the given definition of \\u201Cinterleaving\\u201D. Relation $s = s_{1} + s_{2} + ... + s_{n}$ implies that $s_{1}$, \\u2026 $s_{n}$ form $s$ in that particular order; this is the same relative order in which they appear in the interleaved concatenations.\\n\\nLeetCode does not always succeed at giving clear problem statements, but in this particular case the definition is quite precise, in my opinion; example are not necessary to understand it."
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "This question looks lovely after the hard weekend"
                    },
                    {
                        "username": "psionl0",
                        "content": "The weekend is yet to come."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Oops \\uD83D\\uDE2C"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Initially I used a 3D table. Had to check the solution to figure out the 2D tabulation trick."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "For those who concern the constrain |n-m| <= 1, it is intrinsically right, you can do a small proof and you can see that. "
                    },
                    {
                        "username": "keshav3899",
                        "content": "Is there any way to solve this using LCS ?"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "Yes, it\\'s kind of LCS. Analyze deeply. "
                    },
                    {
                        "username": "boliu1997",
                        "content": "By definition of substring which requires it to be non-empty, the following testcase should give false instead of true:\\n\\ns1 = \"deeff\"\\ns2 = \"abbcc\"\\ns3 = \"abbccdeeff\"\\n\\nbecause the first substring of s1 has to be empty \"\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "In every test case, you will reach the end of one of the substrings before reaching the end of the other. Therefore, every test case would return false by your definition."
                    },
                    {
                        "username": "rohith1002",
                        "content": "\\nCan anyone tell whether this code is right , I\\'m able to pass 61 case and getting TLE , if these code is wrong pls let me know where did i go wrong. If this code is right pls help me in implementing dp !!!\\n \\n```\\nbool solve(string s1,string s2,int i,int j,string s3,bool flag,string temp)\\n  {\\n    if(temp==s3)\\n    return 1;\\n\\n    bool ans=0;\\n    if(flag)\\n    {\\n      for(int k=j+1;k<=s2.length();k++)\\n        ans=ans || solve(s1,s2,i,k,s3,0,temp+s2.substr(j,k-j));\\n    }\\n    else\\n    {\\n      for(int k=i+1;k<=s1.length();k++)\\n        ans=ans || solve(s1,s2,k,j,s3,1,temp+s1.substr(i,k-i));\\n    }\\n    return ans;\\n  }\\n  bool isInterleave(string s1, string s2, string s3) {\\n\\n    if(s1.length()+s2.length()!=s3.length())\\n    return 0;\\n    \\n    return solve(s1,s2,0,0,s3,0,\"\") || solve(s1,s2,0,0,s3,1,\"\");\\n  }\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Without memoization your code will repeatedly calculate the same sub cases over and over again."
                    }
                ]
            },
            {
                "id": 2020501,
                "content": [
                    {
                        "username": "dEAthWednesday",
                        "content": "passed 72 test cases plz help me\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        \\n        int n1 = s1.size();\\n        int n2 = s2.size();\\n        int n3 = s3.size();\\n        if (n1 + n2 != n3) {\\n            return false;\\n        }\\n\\n        queue<char> q1,q2;\\n\\n        for(int i=0;i<n1;i++){\\n            q1.push(s1[i]);\\n        }\\n        for(int i=0;i<n2;i++){\\n            q2.push(s2[i]);\\n        }\\n\\n        int i=0;\\n        while(!q1.empty() && !q2.empty() && i< n3){\\n            while(i<n3 && s3[i]==q1.front()){\\n                q1.pop();\\n                i++;\\n            }\\n            while(i<n3 && s3[i]==q2.front()){\\n                q2.pop();\\n                i++;\\n            }\\n            if(s3[i]!=q1.front() && s3[i]!=q2.front()){\\n                return false;\\n            }\\n        }\\n        while(!q1.empty() && i<n3){\\n            if(s3[i]==q1.front()){\\n                i++;\\n                q1.pop();\\n            }\\n            else return false;\\n        }\\n        while(!q2.empty() && i<n3){\\n            if(s3[i]==q2.front()){\\n                i++;\\n                q2.pop();\\n            }\\n            else return false;\\n        }\\n        return q1.empty() && q2.empty() && i == n3;\\n    }\\n};\\n// failed for s1 = \"a\" s2 = \"b\" s3=\"ab\""
                    },
                    {
                        "username": "sexyshit66",
                        "content": "  Can someone explain where is my code missing  to solve this problem\n\n class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        a, b, c = 0, 0, 0\n        while c < len(s3):\n            if a < len(s1) and s3[c] == s1[a]:\n                a += 1\n            elif b < len(s2) and s3[c] == s2[b]:\n                b += 1\n            else:\n                return False\n            c += 1\n        return True "
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "it shouldn\\'t be elif, for you need to check increment of a and b within the same c. Thus, both increment on a and b should be consider at the same time."
                    },
                    {
                        "username": "ingato",
                        "content": "Man, LeetCode really need to do a better job at explaining what they mean on a problem. It is not obvious AT ALL why the second example does not work. After doing a full implementation and trying to understand why my code is not working I finally realized that in order to work all the letters need to stay in the same order. Why can\\'t they just say that? "
                    },
                    {
                        "username": "tifv",
                        "content": "It follows directly from the given definition of \\u201Cinterleaving\\u201D. Relation $s = s_{1} + s_{2} + ... + s_{n}$ implies that $s_{1}$, \\u2026 $s_{n}$ form $s$ in that particular order; this is the same relative order in which they appear in the interleaved concatenations.\\n\\nLeetCode does not always succeed at giving clear problem statements, but in this particular case the definition is quite precise, in my opinion; example are not necessary to understand it."
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "This question looks lovely after the hard weekend"
                    },
                    {
                        "username": "psionl0",
                        "content": "The weekend is yet to come."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Oops \\uD83D\\uDE2C"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Initially I used a 3D table. Had to check the solution to figure out the 2D tabulation trick."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "For those who concern the constrain |n-m| <= 1, it is intrinsically right, you can do a small proof and you can see that. "
                    },
                    {
                        "username": "keshav3899",
                        "content": "Is there any way to solve this using LCS ?"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "Yes, it\\'s kind of LCS. Analyze deeply. "
                    },
                    {
                        "username": "boliu1997",
                        "content": "By definition of substring which requires it to be non-empty, the following testcase should give false instead of true:\\n\\ns1 = \"deeff\"\\ns2 = \"abbcc\"\\ns3 = \"abbccdeeff\"\\n\\nbecause the first substring of s1 has to be empty \"\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "In every test case, you will reach the end of one of the substrings before reaching the end of the other. Therefore, every test case would return false by your definition."
                    },
                    {
                        "username": "rohith1002",
                        "content": "\\nCan anyone tell whether this code is right , I\\'m able to pass 61 case and getting TLE , if these code is wrong pls let me know where did i go wrong. If this code is right pls help me in implementing dp !!!\\n \\n```\\nbool solve(string s1,string s2,int i,int j,string s3,bool flag,string temp)\\n  {\\n    if(temp==s3)\\n    return 1;\\n\\n    bool ans=0;\\n    if(flag)\\n    {\\n      for(int k=j+1;k<=s2.length();k++)\\n        ans=ans || solve(s1,s2,i,k,s3,0,temp+s2.substr(j,k-j));\\n    }\\n    else\\n    {\\n      for(int k=i+1;k<=s1.length();k++)\\n        ans=ans || solve(s1,s2,k,j,s3,1,temp+s1.substr(i,k-i));\\n    }\\n    return ans;\\n  }\\n  bool isInterleave(string s1, string s2, string s3) {\\n\\n    if(s1.length()+s2.length()!=s3.length())\\n    return 0;\\n    \\n    return solve(s1,s2,0,0,s3,0,\"\") || solve(s1,s2,0,0,s3,1,\"\");\\n  }\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Without memoization your code will repeatedly calculate the same sub cases over and over again."
                    }
                ]
            },
            {
                "id": 2014006,
                "content": [
                    {
                        "username": "dEAthWednesday",
                        "content": "passed 72 test cases plz help me\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        \\n        int n1 = s1.size();\\n        int n2 = s2.size();\\n        int n3 = s3.size();\\n        if (n1 + n2 != n3) {\\n            return false;\\n        }\\n\\n        queue<char> q1,q2;\\n\\n        for(int i=0;i<n1;i++){\\n            q1.push(s1[i]);\\n        }\\n        for(int i=0;i<n2;i++){\\n            q2.push(s2[i]);\\n        }\\n\\n        int i=0;\\n        while(!q1.empty() && !q2.empty() && i< n3){\\n            while(i<n3 && s3[i]==q1.front()){\\n                q1.pop();\\n                i++;\\n            }\\n            while(i<n3 && s3[i]==q2.front()){\\n                q2.pop();\\n                i++;\\n            }\\n            if(s3[i]!=q1.front() && s3[i]!=q2.front()){\\n                return false;\\n            }\\n        }\\n        while(!q1.empty() && i<n3){\\n            if(s3[i]==q1.front()){\\n                i++;\\n                q1.pop();\\n            }\\n            else return false;\\n        }\\n        while(!q2.empty() && i<n3){\\n            if(s3[i]==q2.front()){\\n                i++;\\n                q2.pop();\\n            }\\n            else return false;\\n        }\\n        return q1.empty() && q2.empty() && i == n3;\\n    }\\n};\\n// failed for s1 = \"a\" s2 = \"b\" s3=\"ab\""
                    },
                    {
                        "username": "sexyshit66",
                        "content": "  Can someone explain where is my code missing  to solve this problem\n\n class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        a, b, c = 0, 0, 0\n        while c < len(s3):\n            if a < len(s1) and s3[c] == s1[a]:\n                a += 1\n            elif b < len(s2) and s3[c] == s2[b]:\n                b += 1\n            else:\n                return False\n            c += 1\n        return True "
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "it shouldn\\'t be elif, for you need to check increment of a and b within the same c. Thus, both increment on a and b should be consider at the same time."
                    },
                    {
                        "username": "ingato",
                        "content": "Man, LeetCode really need to do a better job at explaining what they mean on a problem. It is not obvious AT ALL why the second example does not work. After doing a full implementation and trying to understand why my code is not working I finally realized that in order to work all the letters need to stay in the same order. Why can\\'t they just say that? "
                    },
                    {
                        "username": "tifv",
                        "content": "It follows directly from the given definition of \\u201Cinterleaving\\u201D. Relation $s = s_{1} + s_{2} + ... + s_{n}$ implies that $s_{1}$, \\u2026 $s_{n}$ form $s$ in that particular order; this is the same relative order in which they appear in the interleaved concatenations.\\n\\nLeetCode does not always succeed at giving clear problem statements, but in this particular case the definition is quite precise, in my opinion; example are not necessary to understand it."
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "This question looks lovely after the hard weekend"
                    },
                    {
                        "username": "psionl0",
                        "content": "The weekend is yet to come."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Oops \\uD83D\\uDE2C"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Initially I used a 3D table. Had to check the solution to figure out the 2D tabulation trick."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "For those who concern the constrain |n-m| <= 1, it is intrinsically right, you can do a small proof and you can see that. "
                    },
                    {
                        "username": "keshav3899",
                        "content": "Is there any way to solve this using LCS ?"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "Yes, it\\'s kind of LCS. Analyze deeply. "
                    },
                    {
                        "username": "boliu1997",
                        "content": "By definition of substring which requires it to be non-empty, the following testcase should give false instead of true:\\n\\ns1 = \"deeff\"\\ns2 = \"abbcc\"\\ns3 = \"abbccdeeff\"\\n\\nbecause the first substring of s1 has to be empty \"\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "In every test case, you will reach the end of one of the substrings before reaching the end of the other. Therefore, every test case would return false by your definition."
                    },
                    {
                        "username": "rohith1002",
                        "content": "\\nCan anyone tell whether this code is right , I\\'m able to pass 61 case and getting TLE , if these code is wrong pls let me know where did i go wrong. If this code is right pls help me in implementing dp !!!\\n \\n```\\nbool solve(string s1,string s2,int i,int j,string s3,bool flag,string temp)\\n  {\\n    if(temp==s3)\\n    return 1;\\n\\n    bool ans=0;\\n    if(flag)\\n    {\\n      for(int k=j+1;k<=s2.length();k++)\\n        ans=ans || solve(s1,s2,i,k,s3,0,temp+s2.substr(j,k-j));\\n    }\\n    else\\n    {\\n      for(int k=i+1;k<=s1.length();k++)\\n        ans=ans || solve(s1,s2,k,j,s3,1,temp+s1.substr(i,k-i));\\n    }\\n    return ans;\\n  }\\n  bool isInterleave(string s1, string s2, string s3) {\\n\\n    if(s1.length()+s2.length()!=s3.length())\\n    return 0;\\n    \\n    return solve(s1,s2,0,0,s3,0,\"\") || solve(s1,s2,0,0,s3,1,\"\");\\n  }\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Without memoization your code will repeatedly calculate the same sub cases over and over again."
                    }
                ]
            },
            {
                "id": 1967139,
                "content": [
                    {
                        "username": "dEAthWednesday",
                        "content": "passed 72 test cases plz help me\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        \\n        int n1 = s1.size();\\n        int n2 = s2.size();\\n        int n3 = s3.size();\\n        if (n1 + n2 != n3) {\\n            return false;\\n        }\\n\\n        queue<char> q1,q2;\\n\\n        for(int i=0;i<n1;i++){\\n            q1.push(s1[i]);\\n        }\\n        for(int i=0;i<n2;i++){\\n            q2.push(s2[i]);\\n        }\\n\\n        int i=0;\\n        while(!q1.empty() && !q2.empty() && i< n3){\\n            while(i<n3 && s3[i]==q1.front()){\\n                q1.pop();\\n                i++;\\n            }\\n            while(i<n3 && s3[i]==q2.front()){\\n                q2.pop();\\n                i++;\\n            }\\n            if(s3[i]!=q1.front() && s3[i]!=q2.front()){\\n                return false;\\n            }\\n        }\\n        while(!q1.empty() && i<n3){\\n            if(s3[i]==q1.front()){\\n                i++;\\n                q1.pop();\\n            }\\n            else return false;\\n        }\\n        while(!q2.empty() && i<n3){\\n            if(s3[i]==q2.front()){\\n                i++;\\n                q2.pop();\\n            }\\n            else return false;\\n        }\\n        return q1.empty() && q2.empty() && i == n3;\\n    }\\n};\\n// failed for s1 = \"a\" s2 = \"b\" s3=\"ab\""
                    },
                    {
                        "username": "sexyshit66",
                        "content": "  Can someone explain where is my code missing  to solve this problem\n\n class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        a, b, c = 0, 0, 0\n        while c < len(s3):\n            if a < len(s1) and s3[c] == s1[a]:\n                a += 1\n            elif b < len(s2) and s3[c] == s2[b]:\n                b += 1\n            else:\n                return False\n            c += 1\n        return True "
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "it shouldn\\'t be elif, for you need to check increment of a and b within the same c. Thus, both increment on a and b should be consider at the same time."
                    },
                    {
                        "username": "ingato",
                        "content": "Man, LeetCode really need to do a better job at explaining what they mean on a problem. It is not obvious AT ALL why the second example does not work. After doing a full implementation and trying to understand why my code is not working I finally realized that in order to work all the letters need to stay in the same order. Why can\\'t they just say that? "
                    },
                    {
                        "username": "tifv",
                        "content": "It follows directly from the given definition of \\u201Cinterleaving\\u201D. Relation $s = s_{1} + s_{2} + ... + s_{n}$ implies that $s_{1}$, \\u2026 $s_{n}$ form $s$ in that particular order; this is the same relative order in which they appear in the interleaved concatenations.\\n\\nLeetCode does not always succeed at giving clear problem statements, but in this particular case the definition is quite precise, in my opinion; example are not necessary to understand it."
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "This question looks lovely after the hard weekend"
                    },
                    {
                        "username": "psionl0",
                        "content": "The weekend is yet to come."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Oops \\uD83D\\uDE2C"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Initially I used a 3D table. Had to check the solution to figure out the 2D tabulation trick."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "For those who concern the constrain |n-m| <= 1, it is intrinsically right, you can do a small proof and you can see that. "
                    },
                    {
                        "username": "keshav3899",
                        "content": "Is there any way to solve this using LCS ?"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "Yes, it\\'s kind of LCS. Analyze deeply. "
                    },
                    {
                        "username": "boliu1997",
                        "content": "By definition of substring which requires it to be non-empty, the following testcase should give false instead of true:\\n\\ns1 = \"deeff\"\\ns2 = \"abbcc\"\\ns3 = \"abbccdeeff\"\\n\\nbecause the first substring of s1 has to be empty \"\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "In every test case, you will reach the end of one of the substrings before reaching the end of the other. Therefore, every test case would return false by your definition."
                    },
                    {
                        "username": "rohith1002",
                        "content": "\\nCan anyone tell whether this code is right , I\\'m able to pass 61 case and getting TLE , if these code is wrong pls let me know where did i go wrong. If this code is right pls help me in implementing dp !!!\\n \\n```\\nbool solve(string s1,string s2,int i,int j,string s3,bool flag,string temp)\\n  {\\n    if(temp==s3)\\n    return 1;\\n\\n    bool ans=0;\\n    if(flag)\\n    {\\n      for(int k=j+1;k<=s2.length();k++)\\n        ans=ans || solve(s1,s2,i,k,s3,0,temp+s2.substr(j,k-j));\\n    }\\n    else\\n    {\\n      for(int k=i+1;k<=s1.length();k++)\\n        ans=ans || solve(s1,s2,k,j,s3,1,temp+s1.substr(i,k-i));\\n    }\\n    return ans;\\n  }\\n  bool isInterleave(string s1, string s2, string s3) {\\n\\n    if(s1.length()+s2.length()!=s3.length())\\n    return 0;\\n    \\n    return solve(s1,s2,0,0,s3,0,\"\") || solve(s1,s2,0,0,s3,1,\"\");\\n  }\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Without memoization your code will repeatedly calculate the same sub cases over and over again."
                    }
                ]
            },
            {
                "id": 1953238,
                "content": [
                    {
                        "username": "dEAthWednesday",
                        "content": "passed 72 test cases plz help me\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        \\n        int n1 = s1.size();\\n        int n2 = s2.size();\\n        int n3 = s3.size();\\n        if (n1 + n2 != n3) {\\n            return false;\\n        }\\n\\n        queue<char> q1,q2;\\n\\n        for(int i=0;i<n1;i++){\\n            q1.push(s1[i]);\\n        }\\n        for(int i=0;i<n2;i++){\\n            q2.push(s2[i]);\\n        }\\n\\n        int i=0;\\n        while(!q1.empty() && !q2.empty() && i< n3){\\n            while(i<n3 && s3[i]==q1.front()){\\n                q1.pop();\\n                i++;\\n            }\\n            while(i<n3 && s3[i]==q2.front()){\\n                q2.pop();\\n                i++;\\n            }\\n            if(s3[i]!=q1.front() && s3[i]!=q2.front()){\\n                return false;\\n            }\\n        }\\n        while(!q1.empty() && i<n3){\\n            if(s3[i]==q1.front()){\\n                i++;\\n                q1.pop();\\n            }\\n            else return false;\\n        }\\n        while(!q2.empty() && i<n3){\\n            if(s3[i]==q2.front()){\\n                i++;\\n                q2.pop();\\n            }\\n            else return false;\\n        }\\n        return q1.empty() && q2.empty() && i == n3;\\n    }\\n};\\n// failed for s1 = \"a\" s2 = \"b\" s3=\"ab\""
                    },
                    {
                        "username": "sexyshit66",
                        "content": "  Can someone explain where is my code missing  to solve this problem\n\n class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        a, b, c = 0, 0, 0\n        while c < len(s3):\n            if a < len(s1) and s3[c] == s1[a]:\n                a += 1\n            elif b < len(s2) and s3[c] == s2[b]:\n                b += 1\n            else:\n                return False\n            c += 1\n        return True "
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "it shouldn\\'t be elif, for you need to check increment of a and b within the same c. Thus, both increment on a and b should be consider at the same time."
                    },
                    {
                        "username": "ingato",
                        "content": "Man, LeetCode really need to do a better job at explaining what they mean on a problem. It is not obvious AT ALL why the second example does not work. After doing a full implementation and trying to understand why my code is not working I finally realized that in order to work all the letters need to stay in the same order. Why can\\'t they just say that? "
                    },
                    {
                        "username": "tifv",
                        "content": "It follows directly from the given definition of \\u201Cinterleaving\\u201D. Relation $s = s_{1} + s_{2} + ... + s_{n}$ implies that $s_{1}$, \\u2026 $s_{n}$ form $s$ in that particular order; this is the same relative order in which they appear in the interleaved concatenations.\\n\\nLeetCode does not always succeed at giving clear problem statements, but in this particular case the definition is quite precise, in my opinion; example are not necessary to understand it."
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "This question looks lovely after the hard weekend"
                    },
                    {
                        "username": "psionl0",
                        "content": "The weekend is yet to come."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Oops \\uD83D\\uDE2C"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Initially I used a 3D table. Had to check the solution to figure out the 2D tabulation trick."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "For those who concern the constrain |n-m| <= 1, it is intrinsically right, you can do a small proof and you can see that. "
                    },
                    {
                        "username": "keshav3899",
                        "content": "Is there any way to solve this using LCS ?"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "Yes, it\\'s kind of LCS. Analyze deeply. "
                    },
                    {
                        "username": "boliu1997",
                        "content": "By definition of substring which requires it to be non-empty, the following testcase should give false instead of true:\\n\\ns1 = \"deeff\"\\ns2 = \"abbcc\"\\ns3 = \"abbccdeeff\"\\n\\nbecause the first substring of s1 has to be empty \"\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "In every test case, you will reach the end of one of the substrings before reaching the end of the other. Therefore, every test case would return false by your definition."
                    },
                    {
                        "username": "rohith1002",
                        "content": "\\nCan anyone tell whether this code is right , I\\'m able to pass 61 case and getting TLE , if these code is wrong pls let me know where did i go wrong. If this code is right pls help me in implementing dp !!!\\n \\n```\\nbool solve(string s1,string s2,int i,int j,string s3,bool flag,string temp)\\n  {\\n    if(temp==s3)\\n    return 1;\\n\\n    bool ans=0;\\n    if(flag)\\n    {\\n      for(int k=j+1;k<=s2.length();k++)\\n        ans=ans || solve(s1,s2,i,k,s3,0,temp+s2.substr(j,k-j));\\n    }\\n    else\\n    {\\n      for(int k=i+1;k<=s1.length();k++)\\n        ans=ans || solve(s1,s2,k,j,s3,1,temp+s1.substr(i,k-i));\\n    }\\n    return ans;\\n  }\\n  bool isInterleave(string s1, string s2, string s3) {\\n\\n    if(s1.length()+s2.length()!=s3.length())\\n    return 0;\\n    \\n    return solve(s1,s2,0,0,s3,0,\"\") || solve(s1,s2,0,0,s3,1,\"\");\\n  }\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Without memoization your code will repeatedly calculate the same sub cases over and over again."
                    }
                ]
            },
            {
                "id": 1926683,
                "content": [
                    {
                        "username": "dEAthWednesday",
                        "content": "passed 72 test cases plz help me\\nclass Solution {\\npublic:\\n    bool isInterleave(string s1, string s2, string s3) {\\n        \\n        int n1 = s1.size();\\n        int n2 = s2.size();\\n        int n3 = s3.size();\\n        if (n1 + n2 != n3) {\\n            return false;\\n        }\\n\\n        queue<char> q1,q2;\\n\\n        for(int i=0;i<n1;i++){\\n            q1.push(s1[i]);\\n        }\\n        for(int i=0;i<n2;i++){\\n            q2.push(s2[i]);\\n        }\\n\\n        int i=0;\\n        while(!q1.empty() && !q2.empty() && i< n3){\\n            while(i<n3 && s3[i]==q1.front()){\\n                q1.pop();\\n                i++;\\n            }\\n            while(i<n3 && s3[i]==q2.front()){\\n                q2.pop();\\n                i++;\\n            }\\n            if(s3[i]!=q1.front() && s3[i]!=q2.front()){\\n                return false;\\n            }\\n        }\\n        while(!q1.empty() && i<n3){\\n            if(s3[i]==q1.front()){\\n                i++;\\n                q1.pop();\\n            }\\n            else return false;\\n        }\\n        while(!q2.empty() && i<n3){\\n            if(s3[i]==q2.front()){\\n                i++;\\n                q2.pop();\\n            }\\n            else return false;\\n        }\\n        return q1.empty() && q2.empty() && i == n3;\\n    }\\n};\\n// failed for s1 = \"a\" s2 = \"b\" s3=\"ab\""
                    },
                    {
                        "username": "sexyshit66",
                        "content": "  Can someone explain where is my code missing  to solve this problem\n\n class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        a, b, c = 0, 0, 0\n        while c < len(s3):\n            if a < len(s1) and s3[c] == s1[a]:\n                a += 1\n            elif b < len(s2) and s3[c] == s2[b]:\n                b += 1\n            else:\n                return False\n            c += 1\n        return True "
                    },
                    {
                        "username": "Sword0fDamoc1es",
                        "content": "it shouldn\\'t be elif, for you need to check increment of a and b within the same c. Thus, both increment on a and b should be consider at the same time."
                    },
                    {
                        "username": "ingato",
                        "content": "Man, LeetCode really need to do a better job at explaining what they mean on a problem. It is not obvious AT ALL why the second example does not work. After doing a full implementation and trying to understand why my code is not working I finally realized that in order to work all the letters need to stay in the same order. Why can\\'t they just say that? "
                    },
                    {
                        "username": "tifv",
                        "content": "It follows directly from the given definition of \\u201Cinterleaving\\u201D. Relation $s = s_{1} + s_{2} + ... + s_{n}$ implies that $s_{1}$, \\u2026 $s_{n}$ form $s$ in that particular order; this is the same relative order in which they appear in the interleaved concatenations.\\n\\nLeetCode does not always succeed at giving clear problem statements, but in this particular case the definition is quite precise, in my opinion; example are not necessary to understand it."
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "This question looks lovely after the hard weekend"
                    },
                    {
                        "username": "psionl0",
                        "content": "The weekend is yet to come."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Oops \\uD83D\\uDE2C"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Initially I used a 3D table. Had to check the solution to figure out the 2D tabulation trick."
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "For those who concern the constrain |n-m| <= 1, it is intrinsically right, you can do a small proof and you can see that. "
                    },
                    {
                        "username": "keshav3899",
                        "content": "Is there any way to solve this using LCS ?"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "Yes, it\\'s kind of LCS. Analyze deeply. "
                    },
                    {
                        "username": "boliu1997",
                        "content": "By definition of substring which requires it to be non-empty, the following testcase should give false instead of true:\\n\\ns1 = \"deeff\"\\ns2 = \"abbcc\"\\ns3 = \"abbccdeeff\"\\n\\nbecause the first substring of s1 has to be empty \"\"."
                    },
                    {
                        "username": "psionl0",
                        "content": "In every test case, you will reach the end of one of the substrings before reaching the end of the other. Therefore, every test case would return false by your definition."
                    },
                    {
                        "username": "rohith1002",
                        "content": "\\nCan anyone tell whether this code is right , I\\'m able to pass 61 case and getting TLE , if these code is wrong pls let me know where did i go wrong. If this code is right pls help me in implementing dp !!!\\n \\n```\\nbool solve(string s1,string s2,int i,int j,string s3,bool flag,string temp)\\n  {\\n    if(temp==s3)\\n    return 1;\\n\\n    bool ans=0;\\n    if(flag)\\n    {\\n      for(int k=j+1;k<=s2.length();k++)\\n        ans=ans || solve(s1,s2,i,k,s3,0,temp+s2.substr(j,k-j));\\n    }\\n    else\\n    {\\n      for(int k=i+1;k<=s1.length();k++)\\n        ans=ans || solve(s1,s2,k,j,s3,1,temp+s1.substr(i,k-i));\\n    }\\n    return ans;\\n  }\\n  bool isInterleave(string s1, string s2, string s3) {\\n\\n    if(s1.length()+s2.length()!=s3.length())\\n    return 0;\\n    \\n    return solve(s1,s2,0,0,s3,0,\"\") || solve(s1,s2,0,0,s3,1,\"\");\\n  }\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Without memoization your code will repeatedly calculate the same sub cases over and over again."
                    }
                ]
            }
        ]
    },
    {
        "title": "Rising Temperature",
        "question_content": "<p>Table: <code>Weather</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| id            | int     |\n| recordDate    | date    |\n| temperature   | int     |\n+---------------+---------+\nid is the column with unique values for this table.\nThis table contains information about the temperature on a certain day.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to find all dates&#39; <code>Id</code> with higher temperatures compared to its previous dates (yesterday).</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nWeather table:\n+----+------------+-------------+\n| id | recordDate | temperature |\n+----+------------+-------------+\n| 1  | 2015-01-01 | 10          |\n| 2  | 2015-01-02 | 25          |\n| 3  | 2015-01-03 | 20          |\n| 4  | 2015-01-04 | 30          |\n+----+------------+-------------+\n<strong>Output:</strong> \n+----+\n| id |\n+----+\n| 2  |\n| 4  |\n+----+\n<strong>Explanation:</strong> \nIn 2015-01-02, the temperature was higher than the previous day (10 -&gt; 25).\nIn 2015-01-04, the temperature was higher than the previous day (20 -&gt; 30).\n</pre>\n",
        "solutions": [
            {
                "id": 1308831,
                "title": "faster-easy",
                "content": "***Do upvote if you like the solution to keep me motivated*** \\uD83D\\uDE0A\\u270C\\n```\\nSELECT w1.id\\nFROM Weather AS w1 , Weather AS w2\\nWHERE w1.Temperature > w2.Temperature AND DATEDIFF(w1.recordDate , w2.recordDate) = 1\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT w1.id\\nFROM Weather AS w1 , Weather AS w2\\nWHERE w1.Temperature > w2.Temperature AND DATEDIFF(w1.recordDate , w2.recordDate) = 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55619,
                "title": "simple-solution",
                "content": "    SELECT wt1.Id \\n    FROM Weather wt1, Weather wt2\\n    WHERE wt1.Temperature > wt2.Temperature AND \\n          TO_DAYS(wt1.DATE)-TO_DAYS(wt2.DATE)=1;\\n\\n\\nEXPLANATION:\\n\\n**TO_DAYS(wt1.DATE)** return the number of days between from year 0 to date DATE\\n**TO_DAYS(wt1.DATE)-TO_DAYS(wt2.DATE)=1** check if wt2.DATE is yesterday respect to wt1.DATE\\n\\nWe select from the joined tables the rows that have \\n\\n**wt1.Temperature > wt2.Temperature** \\n\\nand difference between dates in days of 1 (yesterday):\\n\\n**TO_DAYS(wt1.DATE)-TO_DAYS(wt2.DATE)=1;**",
                "solutionTags": [],
                "code": "    SELECT wt1.Id \\n    FROM Weather wt1, Weather wt2\\n    WHERE wt1.Temperature > wt2.Temperature AND \\n          TO_DAYS(wt1.DATE)-TO_DAYS(wt2.DATE)=1;\\n\\n\\nEXPLANATION:\\n\\n**TO_DAYS(wt1.DATE)** return the number of days between from year 0 to date DATE\\n**TO_DAYS(wt1.DATE)-TO_DAYS(wt2.DATE)=1** check if wt2.DATE is yesterday respect to wt1.DATE\\n\\nWe select from the joined tables the rows that have \\n\\n**wt1.Temperature > wt2.Temperature** \\n\\nand difference between dates in days of 1 (yesterday):\\n\\n**TO_DAYS(wt1.DATE)-TO_DAYS(wt2.DATE)=1;**",
                "codeTag": "Unknown"
            },
            {
                "id": 3716884,
                "title": "mysql-simple-and-clean-beats-88",
                "content": "### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n\\n\\n## Intuition\\n\\nThe problem requires us to find all the dates with higher temperatures compared to their previous dates (yesterday). To solve this, we need to compare each date\\'s temperature with the temperature of the previous date.\\n\\n## Approach\\n\\nTo solve the problem, we can use the following approach:\\n\\n1. Join the Weather table with itself, denoting the first occurrence as `w1` and the second occurrence as `w2`.\\n2. Compare the dates of `w1` and `w2` using the `DATEDIFF()` function to check if they are consecutive days (with a difference of 1 day).\\n3. Add a condition in the WHERE clause to select the rows where the temperature of `w1` is greater than the temperature of `w2`.\\n4. Select the `id` of `w1` as the result.\\n\\nThe SQL query for the above approach is as follows:\\n\\n```sql\\nSELECT w1.id\\nFROM Weather w1, Weather w2\\nWHERE DATEDIFF(w1.recordDate, w2.recordDate) = 1 AND w1.temperature > w2.temperature;\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n\\n\\n## Intuition\\n\\nThe problem requires us to find all the dates with higher temperatures compared to their previous dates (yesterday). To solve this, we need to compare each date\\'s temperature with the temperature of the previous date.\\n\\n## Approach\\n\\nTo solve the problem, we can use the following approach:\\n\\n1. Join the Weather table with itself, denoting the first occurrence as `w1` and the second occurrence as `w2`.\\n2. Compare the dates of `w1` and `w2` using the `DATEDIFF()` function to check if they are consecutive days (with a difference of 1 day).\\n3. Add a condition in the WHERE clause to select the rows where the temperature of `w1` is greater than the temperature of `w2`.\\n4. Select the `id` of `w1` as the result.\\n\\nThe SQL query for the above approach is as follows:\\n\\n```sql\\nSELECT w1.id\\nFROM Weather w1, Weather w2\\nWHERE DATEDIFF(w1.recordDate, w2.recordDate) = 1 AND w1.temperature > w2.temperature;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2386995,
                "title": "three-different-solutions-datediff-subdate",
                "content": "```\\n# 1.\\nSELECT w2.id from Weather w1,Weather w2\\nWHERE datediff(w2.recordDate, w1.recordDate) = 1 AND w2.temperature > w1.temperature;\\n// where datediff -> date difference b/w two dates\\n# 2.\\nSELECT w2.id from Weather w1, Weather w2\\nWHERE w2.temperature > w1.temperature AND\\nsubdate(w2.recordDate, 1) = w1.recordDate;\\n// where subdate -> subtract date \\n\\n#3.\\nSELECT w2.id from Weather w1 JOIN Weather w2\\nON w2.temperature > w1.temperature AND\\ndatediff(w2.recordDate,w1.recordDate) = 1;\\n```\\n**If you have any doubts, feel free to ask...\\nIf you understand the concept. Don\\'t Forget to upvote \\uD83D\\uDE0A**",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# 1.\\nSELECT w2.id from Weather w1,Weather w2\\nWHERE datediff(w2.recordDate, w1.recordDate) = 1 AND w2.temperature > w1.temperature;\\n// where datediff -> date difference b/w two dates\\n# 2.\\nSELECT w2.id from Weather w1, Weather w2\\nWHERE w2.temperature > w1.temperature AND\\nsubdate(w2.recordDate, 1) = w1.recordDate;\\n// where subdate -> subtract date \\n\\n#3.\\nSELECT w2.id from Weather w1 JOIN Weather w2\\nON w2.temperature > w1.temperature AND\\ndatediff(w2.recordDate,w1.recordDate) = 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3218931,
                "title": "197-beats-92-26-solution-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nExplanation:\\n\\n- The query selects the id from Weather table where the temperature on a certain day is higher than its previous day.\\n- It uses a self join to compare the temperature of each day with its previous day. The w1 and w2 aliases are used to distinguish between the two instances of the Weather table being joined.\\n- The JOIN condition matches records where w1\\'s recordDate is equal to w2\\'s recordDate plus one day, effectively joining each record with its previous day\\'s record.\\n- The WHERE clause filters records where the temperature on the current day (w1) is higher than the temperature on the previous day (w2).\\n- Finally, the query selects the id from the Weather table for the records that match the JOIN and WHERE conditions.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nSELECT w1.id\\nFROM Weather w1\\nJOIN Weather w2 ON w1.recordDate = DATE_ADD(w2.recordDate, INTERVAL 1 DAY)\\nWHERE w1.temperature > w2.temperature\\n\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\nSELECT w1.id\\nFROM Weather w1\\nJOIN Weather w2 ON w1.recordDate = DATE_ADD(w2.recordDate, INTERVAL 1 DAY)\\nWHERE w1.temperature > w2.temperature\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3700586,
                "title": "easy-understandible-solution",
                "content": "# Code\\n```\\nSELECT w2.id\\nFROM Weather w1\\njoin Weather w2\\nON DATEDIFF (w1.recordDate ,w2.recordDate ) = -1\\nAND w2.temperature>w1.temperature   \\n```PLEASE UPVOTE TO MOTIVATE ME WRITE MORE SOLUTION",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT w2.id\\nFROM Weather w1\\njoin Weather w2\\nON DATEDIFF (w1.recordDate ,w2.recordDate ) = -1\\nAND w2.temperature>w1.temperature   \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55620,
                "title": "my-simple-solution-using-inner-join",
                "content": "    SELECT t1.Id\\n    FROM Weather t1\\n    INNER JOIN Weather t2\\n    ON TO_DAYS(t1.Date) = TO_DAYS(t2.Date) + 1\\n    WHERE t1.Temperature > t2.Temperatur",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "    SELECT t1.Id\\n    FROM Weather t1\\n    INNER JOIN Weather t2\\n    ON TO_DAYS(t1.Date) = TO_DAYS(t2.Date) + 1\\n    WHERE t1.Temperature > t2.Temperatur",
                "codeTag": "Unknown"
            },
            {
                "id": 1522560,
                "title": "5-solutions-with-different-date-functions-in-mysql",
                "content": "The main catch of this problem is how we can compare todays\\' temperature with yesterdays\\' temperature. \\n\\nI thought it should be great to list all the MySQL methods we can use to calculate the time difference `RecordDate - 1` \\n\\n1. Using `DATE_SUB`\\n``` \\nSELECT\\n    w1.Id\\nFROM weather w1, weather w2\\nWHERE DATE_SUB(w1.RecordDate, interval 1 Day) = w2.RecordDate \\nAND w1.Temperature > w2.Temperature;\\n```\\n\\n2. Using `DATEDIFF`\\n```\\nSELECT\\n    w1.Id\\nFROM weather w1, weather w2\\nWHERE DATEDIFF(w1.RecordDate, w2.RecordDate)=1\\nAND w1.Temperature > w2.Temperature;\\n```\\n3. `SUBDATE`(solution 1)\\n```\\nSELECT\\n    w1.Id\\nFROM weather w1, weather w2\\nWHERE w2.RecordDate = subdate(w1.RecordDate, 1) /*This is w1.RecordDate with 1*/\\nAND w1.Temperature > w2.Temperature;\\n```\\n4. `SUBDATE`(solution 2)\\n```\\nSELECT\\n    w1.Id\\nFROM weather w1, weather w2\\nWHERE w1.RecordDate = subdate(w2.RecordDate, -1) /*This is w2.RecordDate with -1*/\\nAND w1.Temperature > w2.Temperature;\\n```\\n5. Using `TO_DAYS`\\n```\\nSELECT\\n    w1.Id\\nFROM weather w1, weather w2\\nWHERE TO_DAYS(w1.RecordDate) - TO_DAYS(w2.RecordDate) = 1\\nAND w1.Temperature > w2.Temperature;\\n```\\n\\nHope it will help.",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "``` \\nSELECT\\n    w1.Id\\nFROM weather w1, weather w2\\nWHERE DATE_SUB(w1.RecordDate, interval 1 Day) = w2.RecordDate \\nAND w1.Temperature > w2.Temperature;\\n```\n```\\nSELECT\\n    w1.Id\\nFROM weather w1, weather w2\\nWHERE DATEDIFF(w1.RecordDate, w2.RecordDate)=1\\nAND w1.Temperature > w2.Temperature;\\n```\n```\\nSELECT\\n    w1.Id\\nFROM weather w1, weather w2\\nWHERE w2.RecordDate = subdate(w1.RecordDate, 1) /*This is w1.RecordDate with 1*/\\nAND w1.Temperature > w2.Temperature;\\n```\n```\\nSELECT\\n    w1.Id\\nFROM weather w1, weather w2\\nWHERE w1.RecordDate = subdate(w2.RecordDate, -1) /*This is w2.RecordDate with -1*/\\nAND w1.Temperature > w2.Temperature;\\n```\n```\\nSELECT\\n    w1.Id\\nFROM weather w1, weather w2\\nWHERE TO_DAYS(w1.RecordDate) - TO_DAYS(w2.RecordDate) = 1\\nAND w1.Temperature > w2.Temperature;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3438022,
                "title": "superb-logic-query",
                "content": "# DATEDIFF Concept\\n```\\nselect x.id from weather x,weather y\\nwhere x.temperature>y.temperature and DATEDIFF(x.recordDate,y.recordDate)=1\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect x.id from weather x,weather y\\nwhere x.temperature>y.temperature and DATEDIFF(x.recordDate,y.recordDate)=1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55662,
                "title": "two-solutions",
                "content": "1.\\n\\n    SELECT a.Id FROM Weather AS a, Weather AS b\\n    WHERE DATEDIFF(a.Date, b.Date)=1 AND a.Temperature > b.Temperature\\n\\n2.\\n\\n    SELECT Id FROM (\\n        SELECT CASE\\n            WHEN Temperature > @prevtemp AND DATEDIFF(Date, @prevdate) = 1 THEN Id ELSE NULL END AS Id,\\n            @prevtemp:=Temperature,\\n            @prevdate:=Date\\n        FROM Weather, (SELECT @prevtemp:=NULL) AS A, (SELECT @prevdate:=NULL) AS B ORDER BY Date ASC\\n    ) AS D WHERE Id IS NOT NULL",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "1.\\n\\n    SELECT a.Id FROM Weather AS a, Weather AS b\\n    WHERE DATEDIFF(a.Date, b.Date)=1 AND a.Temperature > b.Temperature\\n\\n2.\\n\\n    SELECT Id FROM (\\n        SELECT CASE\\n            WHEN Temperature > @prevtemp AND DATEDIFF(Date, @prevdate) = 1 THEN Id ELSE NULL END AS Id,\\n            @prevtemp:=Temperature,\\n            @prevdate:=Date\\n        FROM Weather, (SELECT @prevtemp:=NULL) AS A, (SELECT @prevdate:=NULL) AS B ORDER BY Date ASC\\n    ) AS D WHERE Id IS NOT NULL",
                "codeTag": "Unknown"
            },
            {
                "id": 3644783,
                "title": "concise-solution-with-selfjoin-mysql",
                "content": "# Intuition and Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSo coming to the explanation is pretty easy.\\nComing to the explanation where we using selfjoin concepts on the dates.\\n\\n```\\nSelf-Join Syntax:\\n\\nSELECT column_name(s)\\nFROM table1 T1, table1 T2\\nWHERE condition;\\n```\\n\\nSo in this question we were aksed to find the id of where the temperature is increased than the previous date.\\nWe used ```datediff(current_date,prev_date)=1 this is means we are comapring with yesterday and one more condition is current.temp > prev.temp.```\\n\\n## Please Upvote if you like the explanation.I appreciate it.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSelect w1.id \\nfrom Weather w1,Weather w2\\nwhere datediff(w1.recordDate,w2.recordDate)=1 and w1.temperature > w2.temperature;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSelf-Join Syntax:\\n\\nSELECT column_name(s)\\nFROM table1 T1, table1 T2\\nWHERE condition;\\n```\n```datediff(current_date,prev_date)=1 this is means we are comapring with yesterday and one more condition is current.temp > prev.temp.```\n```\\n# Write your MySQL query statement below\\nSelect w1.id \\nfrom Weather w1,Weather w2\\nwhere datediff(w1.recordDate,w2.recordDate)=1 and w1.temperature > w2.temperature;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2507742,
                "title": "mysql-simple-and-clean-solution",
                "content": "**Please Upvote if it helped you !!!**\\n```\\nselect t1.id as id from weather t1 \\ninner join weather t2 \\nwhere t1.temperature >t2.temperature and datediff(t1.recorddate ,t2.recorddate)=1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect t1.id as id from weather t1 \\ninner join weather t2 \\nwhere t1.temperature >t2.temperature and datediff(t1.recorddate ,t2.recorddate)=1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1971476,
                "title": "easy-to-understand-sql",
                "content": "```\\nselect\\n    A.id\\nfrom\\n    weather A, weather B\\nwhere \\n    datediff(A.recordDate, B.recordDate)= 1\\nand\\n    A.temperature > B.temperature;\\n    \\n```\\n\\nIf you have any **doubts**, feel **free to ask**...\\nIf you understand the **concept**. Don\\'t Forget to **upvote** \\uD83D\\uDE0A\\n\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect\\n    A.id\\nfrom\\n    weather A, weather B\\nwhere \\n    datediff(A.recordDate, B.recordDate)= 1\\nand\\n    A.temperature > B.temperature;\\n    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1114624,
                "title": "using-lag",
                "content": "```\\nSELECT id\\nFROM\\n(SELECT *, \\n    LAG(temperature,1) OVER (ORDER BY recordDate)  as prevTemp,\\n    LAG(recordDate,1) OVER (ORDER BY recordDate)  as prevDate\\n    FROM Weather) a\\nWHERE temperature > prevTemp\\nAND DATEDIFF(day,recordDate,prevDate) = -1 \\n```",
                "solutionTags": [],
                "code": "```\\nSELECT id\\nFROM\\n(SELECT *, \\n    LAG(temperature,1) OVER (ORDER BY recordDate)  as prevTemp,\\n    LAG(recordDate,1) OVER (ORDER BY recordDate)  as prevDate\\n    FROM Weather) a\\nWHERE temperature > prevTemp\\nAND DATEDIFF(day,recordDate,prevDate) = -1 \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3549798,
                "title": "implementation-using-datediff-and-dateadd-with-explanation",
                "content": "\\n# Code\\n``` DateDIFF []\\nSELECT w1.id as Id \\nFROM Weather as w1, Weather as w2\\nWHERE w1.temperature > w2.temperature\\nAND DATEDIFF( DAY, w2.recordDate, w1.recordDate) = 1\\n```\\n``` DateADD []\\nSELECT w1.id as Id \\nFROM Weather as w1, Weather as w2\\nWHERE w1.temperature > w2.temperature\\nAND w1.recordDate = DATEADD( DAY, 1, w2.recordDate)\\n```\\n\\nSince you need to **compare date values** and you have only **one table**, the direct choice is to use **self joins**. \\nThe above implementation is one way to self join table **without using** \\'*JOIN*\\' and \\'*ON*\\'.\\n\\n`DATEDIFF` and `DATEADD` are two functions in SQL Server that are used to manipulate dates.\\n\\n\\n# DateDIFF \\n**DATEDIFF** function returns the difference between two dates in terms of the specified datepart. The syntax for DATEDIFF is as follows:\\n`DATEDIFF(datepart,startdate,enddate)`\\n\\n1. In the problem, the `datepart` will be `day` (other dateparts can be found [here](https://learn.microsoft.com/en-us/sql/t-sql/functions/datediff-transact-sql?view=sql-server-ver16#arguments))\\n2. The `startdate` will be the previous date\\n3. The `enddate` will be the next date\\n4. The `DATEDIFF should be 1`, i.e., there is 1 day difference between our startdate and enddate.\\n\\n# DateADD \\n**DATEADD** function adds a specified number of intervals (such as days, months, or years) to a date and returns a new date. The syntax for DATEADD is as follows:\\n`DATEADD(interval,number,date)`\\n1. The `interval` is same as datepart. For our problem, our interval is `day`. \\n2. The `number` is the amount that you want to add to the date. For us, it is `1`\\n3. The `date` is the previous date and we use it to add the `number` and check with the nextDate.\\n",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "``` DateDIFF []\\nSELECT w1.id as Id \\nFROM Weather as w1, Weather as w2\\nWHERE w1.temperature > w2.temperature\\nAND DATEDIFF( DAY, w2.recordDate, w1.recordDate) = 1\\n```\n``` DateADD []\\nSELECT w1.id as Id \\nFROM Weather as w1, Weather as w2\\nWHERE w1.temperature > w2.temperature\\nAND w1.recordDate = DATEADD( DAY, 1, w2.recordDate)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2423953,
                "title": "mysql-2-different-approach-beginner-level-simple-short-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome**.*\\n______________________\\n\\u2705 **MySQL Code :**\\n***Approach 1:***\\n**Runtime:** 418 ms, faster than 86.29% of MySQL online submissions for Rising Temperature.\\n```\\nSELECT a.id as Id\\nFROM weather a , weather b\\nWHERE DATEDIFF(a.recordDate , b.recordDate)= 1 AND a.temperature > b.temperature; \\n```\\n**Runtime:** 418 ms\\n**Memory Usage:**  0B\\n__________________________________\\n***Approach 2***:\\n**Runtime:** 417 ms, faster than 86.59% of MySQL online submissions for Rising Temperature.\\n```\\nSELECT w1.Id\\nFROM Weather AS w1 , Weather AS w2\\nWHERE w1.Temperature > w2.Temperature AND DATEDIFF(w1.recordDate , w2.recordDate) = 1\\n```\\t  \\n**Runtime:** 418 ms\\n**Memory Usage:**  0B\\n_________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT a.id as Id\\nFROM weather a , weather b\\nWHERE DATEDIFF(a.recordDate , b.recordDate)= 1 AND a.temperature > b.temperature; \\n```\n```\\nSELECT w1.Id\\nFROM Weather AS w1 , Weather AS w2\\nWHERE w1.Temperature > w2.Temperature AND DATEDIFF(w1.recordDate , w2.recordDate) = 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529199,
                "title": "mysql-solution-for-rising-temperature-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given query selects the IDs from the \"Weather\" table for records where the temperature on a particular date (w1) is higher than the temperature on the previous date (w2) for consecutive days.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. It performs a self-join on the \"Weather\" table, creating two aliases, w1 and w2, representing different instances of the table.\\n2. The join condition is datediff(w1.RecordDate, w2.RecordDate) = 1, which ensures that the dates for w1 and w2 are consecutive.\\n3. The condition w1.Temperature > w2.Temperature checks if the temperature on the current day (w1) is higher than the temperature on the previous day (w2).\\n4. The query selects the IDs (w1.id) for the matching records.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this query depends on the size of the \"Weather\" table and the efficiency of indexing on the \"RecordDate\" and \"Temperature\" columns. In the worst case, the query may require a full table scan or an index scan, resulting in a time complexity of O(N), where N is the number of rows in the table. The datediff function can also contribute to the time complexity, but its impact is typically negligible compared to the overall query execution.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this query is determined by the memory required to process the join operation and store the result set. The space complexity is generally proportional to the size of the result set. If the result set is large, it may require additional memory resources to store and return the data. However, if the result set is relatively small compared to the total table size, the impact on space complexity is minimal.\\n\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect w1.id from Weather as w1, Weather as w2\\nwhere datediff(w1.RecordDate, w2.RecordDate) = 1 and w1.Temperature > w2.Temperature\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect w1.id from Weather as w1, Weather as w2\\nwhere datediff(w1.RecordDate, w2.RecordDate) = 1 and w1.Temperature > w2.Temperature\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55672,
                "title": "my-simple-solution",
                "content": "select w1.id \\nfrom Weather w1, Weather w2 \\nwhere (DATEDIFF(w1.Date, w2.Date) = 1) AND w1.Temperature > w2.Temperature",
                "solutionTags": [],
                "code": "select w1.id \\nfrom Weather w1, Weather w2 \\nwhere (DATEDIFF(w1.Date, w2.Date) = 1) AND w1.Temperature > w2.Temperature",
                "codeTag": "Unknown"
            },
            {
                "id": 3796586,
                "title": "sql-cartesian-join-datediff-easy-to-understand",
                "content": "\\n![image.png](https://assets.leetcode.com/users/images/155e784c-1690-4960-96de-302469345e50_1689937627.06149.png)\\n\\n\\n# Code\\n```\\nselect w1.id\\nfrom Weather w1, Weather w2\\nwhere DATEDIFF(w1.recordDate, w2.recordDate) = 1 and w1.temperature > w2.temperature;\\n\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\nselect w1.id\\nfrom Weather w1, Weather w2\\nwhere DATEDIFF(w1.recordDate, w2.recordDate) = 1 and w1.temperature > w2.temperature;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1964678,
                "title": "mysql-and-ms-sql-solutions",
                "content": "MySQL solutions:\\n```\\nSELECT w2.Id \\nFROM Weather w1\\nINNER JOIN Weather w2 ON DATEDIFF(w2.recordDate, w1.recordDate)=1 AND w2.Temperature > w1.Temperature\\n```\\n\\n\\nMS SQL solution:\\n```\\nSELECT w2.Id \\nFROM Weather w1\\nINNER JOIN Weather w2 ON DATEDIFF(day, w1.recordDate, w2.recordDate)=1 AND w2.Temperature > w1.Temperature\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server"
                ],
                "code": "```\\nSELECT w2.Id \\nFROM Weather w1\\nINNER JOIN Weather w2 ON DATEDIFF(w2.recordDate, w1.recordDate)=1 AND w2.Temperature > w1.Temperature\\n```\n```\\nSELECT w2.Id \\nFROM Weather w1\\nINNER JOIN Weather w2 ON DATEDIFF(day, w1.recordDate, w2.recordDate)=1 AND w2.Temperature > w1.Temperature\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55649,
                "title": "solution-with-mysql-built-in-function",
                "content": "    SELECT \\n        t1.Id\\n    From \\n        Weather t1, Weather t2\\n    WHERE \\n        t1.Temperature > t2.Temperature\\n    AND\\n        subdate(t1.Date, 1) = t2.Date\\n\\nMySQL SUBDATE() subtracts a time value (as interval) from a given date.",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "    SELECT \\n        t1.Id\\n    From \\n        Weather t1, Weather t2\\n    WHERE \\n        t1.Temperature > t2.Temperature\\n    AND\\n        subdate(t1.Date, 1) = t2.Date\\n\\nMySQL SUBDATE() subtracts a time value (as interval) from a given date.",
                "codeTag": "Unknown"
            },
            {
                "id": 55629,
                "title": "a-simple-straightforward-solution-and-it-s-very-fast",
                "content": "    select w1.Id Id from Weather w1, Weather w2 where datediff(w1.Date,w2.Date)=1 and w1.Temperature>w2.Temperature",
                "solutionTags": [],
                "code": "    select w1.Id Id from Weather w1, Weather w2 where datediff(w1.Date,w2.Date)=1 and w1.Temperature>w2.Temperature",
                "codeTag": "Unknown"
            },
            {
                "id": 3881503,
                "title": "pandas-simple-solution",
                "content": "# Intuition\\nSort days, select consecutive days with increasing temperature\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst we sort the table so that we only have to compare consecutive rows. Next we filter over two conditions: 1) the temperature must be rising and 2) the difference in dates should be one day.\\n\\nNote that difference of dates is of type `np.timedelta64t`. We use `.dt.days` to convert it into an integer day count. Alternatively, we could compare the date difference directly to \"1 day\" typed properly: `weather.recordDate.diff() == np.timedelta64(1, \\'D\\')`. Not sure which way is more proper, but the complexity is obviously the same.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n \\\\log n)$$ due to neccessity of sorting\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ - bound by size of output\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef rising_temperature(weather: pd.DataFrame) -> pd.DataFrame:\\n    weather.sort_values(by=\\'recordDate\\', inplace=True)\\n    return weather[\\n        (weather.temperature.diff() > 0)\\n      & (weather.recordDate.diff().dt.days == 1)\\n    ][[\\'id\\']]\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef rising_temperature(weather: pd.DataFrame) -> pd.DataFrame:\\n    weather.sort_values(by=\\'recordDate\\', inplace=True)\\n    return weather[\\n        (weather.temperature.diff() > 0)\\n      & (weather.recordDate.diff().dt.days == 1)\\n    ][[\\'id\\']]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1887936,
                "title": "simple-and-clean-date-diff-mysql-and-ms-sql",
                "content": "**MySQL**:\\n```\\nSELECT Today.id FROM Weather Today, Weather Yesterday\\nWHERE DATEDIFF(Today.recordDate, Yesterday.recordDate) = 1\\nAND Today.temperature > Yesterday.temperature\\n```\\n\\n**MS SQL**:\\n```\\nSELECT Today.id FROM Weather Today, Weather Yesterday\\nWHERE DATEDIFF(DAY, Today.recordDate, Yesterday.recordDate) = -1\\nAND Today.temperature > Yesterday.temperature\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Oracle"
                ],
                "code": "```\\nSELECT Today.id FROM Weather Today, Weather Yesterday\\nWHERE DATEDIFF(Today.recordDate, Yesterday.recordDate) = 1\\nAND Today.temperature > Yesterday.temperature\\n```\n```\\nSELECT Today.id FROM Weather Today, Weather Yesterday\\nWHERE DATEDIFF(DAY, Today.recordDate, Yesterday.recordDate) = -1\\nAND Today.temperature > Yesterday.temperature\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2444928,
                "title": "simple-solution-explanation-datediff-mysql-solution",
                "content": "```\\n# MySQL DATEDIFF() returns the number of days between two dates or datetimes\\n\\nSELECT w1.id FROM Weather w1, Weather w2 \\nWHERE DATEDIFF(w1.recordDate, w2.recordDate) = 1 AND w1.temperature > w2.temperature;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# MySQL DATEDIFF() returns the number of days between two dates or datetimes\\n\\nSELECT w1.id FROM Weather w1, Weather w2 \\nWHERE DATEDIFF(w1.recordDate, w2.recordDate) = 1 AND w1.temperature > w2.temperature;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1538722,
                "title": "simple-datediff-soluiton",
                "content": "```\\nselect w1.id\\nfrom Weather w1\\njoin Weather w2\\nwhere w1.temperature > w2.temperature \\nand DATEDIFF(w1.RecordDate, w2.RecordDate)=1\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect w1.id\\nfrom Weather w1\\njoin Weather w2\\nwhere w1.temperature > w2.temperature \\nand DATEDIFF(w1.RecordDate, w2.RecordDate)=1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3254419,
                "title": "easy-to-understand-mysql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nselect A.id\\nfrom weather A, weather B\\nwhere datediff(A.recordDate, B.recordDate)= 1\\nand A.temperature > B.temperature;\\n    \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect A.id\\nfrom weather A, weather B\\nwhere datediff(A.recordDate, B.recordDate)= 1\\nand A.temperature > B.temperature;\\n    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1399980,
                "title": "2-simple-sql-solutions",
                "content": "Solution 1 using DateDiff()\\n\\n```\\nselect w1.id from Weather w1, Weather w2\\nwhere w1.Temperature  > w2.Temperature AND DATEDIFF(w1.recordDate,w2.recordDate)=1\\n```\\n\\nSolution 2 using To_Days()\\n\\n```\\nSELECT w1.Id \\nFROM Weather w1, Weather w2\\nWHERE w1.Temperature > w2.Temperature AND \\n      TO_DAYS(w1.recordDate )-TO_DAYS(w2.recordDate )=1;",
                "solutionTags": [],
                "code": "```\\nselect w1.id from Weather w1, Weather w2\\nwhere w1.Temperature  > w2.Temperature AND DATEDIFF(w1.recordDate,w2.recordDate)=1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1139635,
                "title": "mysql-faster-than-92",
                "content": "```\\nSELECT w2.id FROM Weather w1, Weather w2 \\nWHERE w2.recordDate = w1.recordDate + INTERVAL 1 DAY AND w2.temperature > w1.temperature;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT w2.id FROM Weather w1, Weather w2 \\nWHERE w2.recordDate = w1.recordDate + INTERVAL 1 DAY AND w2.temperature > w1.temperature;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55653,
                "title": "my-first-sql-query",
                "content": "select a.Id as Id\\n        from \\n        Weather as a\\n        join\\n        Weather as b\\n        ON\\n        b.Date = subdate(a.Date,1)\\n        where \\n        a.Temperature > b.Temperature;",
                "solutionTags": [],
                "code": "select a.Id as Id\\n        from \\n        Weather as a\\n        join\\n        Weather as b\\n        ON\\n        b.Date = subdate(a.Date,1)\\n        where \\n        a.Temperature > b.Temperature;",
                "codeTag": "Unknown"
            },
            {
                "id": 3548974,
                "title": "using-window-function-and-cte",
                "content": "# Intuition\\nTo solve this problem we need to compare current and previous temperature of two \"consecutive dates\" \\n\\n# Approach\\nFOR TEMPERATURE:\\n\\nTo achieve this, we need to have the consecutive dates in proper order thats why I have applied \"order by recordDate\"\\nNow to compare temperatures, we need both previous and current temperature.\\nCurrent temperature we already have, all we need is the previous one which can be achieved by \"lag()\", Lag function will add a new column having previous temperature beside the current one.\\nHence applied a condition in final query to make sure temperature of next date is greater than the previous.\\n\\n\\nFOR DATE:\\nNow, to make sure we are comparing temperature of previous date(yesterday), again applied a lag() to recordDate and therefore applied a condition in final query which makes sure the date difference is 1.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nWITH CTE AS(\\nSELECT id, \\n       recordDate, \\n       temperature,\\n       lag(temperature) over(order by recordDate) as pre_temp,\\n       lag(recordDate) over(order by recordDate) as pre_date\\nFROM Weather\\n)\\nSELECT id as Id \\nFROM CTE \\nWHERE temperature>pre_temp AND datediff(recordDate,pre_date)=1\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nWITH CTE AS(\\nSELECT id, \\n       recordDate, \\n       temperature,\\n       lag(temperature) over(order by recordDate) as pre_temp,\\n       lag(recordDate) over(order by recordDate) as pre_date\\nFROM Weather\\n)\\nSELECT id as Id \\nFROM CTE \\nWHERE temperature>pre_temp AND datediff(recordDate,pre_date)=1\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2169224,
                "title": "mysql-easiest-solution",
                "content": "```\\nselect w1.id from Weather w1,Weather w2 where DateDiff(w1.recordDate,w2.recordDate)=1 and \\nw1.temperature > w2.temperature;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect w1.id from Weather w1,Weather w2 where DateDiff(w1.recordDate,w2.recordDate)=1 and \\nw1.temperature > w2.temperature;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1326477,
                "title": "oracle-lag",
                "content": "```\\nselect t.id as ID\\n  from (select w.id,\\n            --   w.recorddate,\\n               w.temperature as tt,\\n             --  lag(w.recorddate, 1) over(order by w.recorddate) as dt,\\n               w.recorddate - lag(w.recorddate, 1) over(order by w.recorddate) as dtmin,\\n               lag(w.temperature, 1) over(order by w.recorddate) as tmp\\n          from weather w) t\\n where dtmin = 1\\n   and t.tt > t.tmp\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nselect t.id as ID\\n  from (select w.id,\\n            --   w.recorddate,\\n               w.temperature as tt,\\n             --  lag(w.recorddate, 1) over(order by w.recorddate) as dt,\\n               w.recorddate - lag(w.recorddate, 1) over(order by w.recorddate) as dtmin,\\n               lag(w.temperature, 1) over(order by w.recorddate) as tmp\\n          from weather w) t\\n where dtmin = 1\\n   and t.tt > t.tmp\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 817353,
                "title": "mysql-easy-to-follow",
                "content": "```\\nSELECT w1.id\\nFROM Weather w1, Weather w2\\nWHERE DATEDIFF(w1.recordDate, w2.recordDate) = 1\\nAND w1.Temperature > w2.Temperature;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT w1.id\\nFROM Weather w1, Weather w2\\nWHERE DATEDIFF(w1.recordDate, w2.recordDate) = 1\\nAND w1.Temperature > w2.Temperature;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 673040,
                "title": "ms-server-solution",
                "content": "```\\nSELECT today.Id \\nFROM Weather today\\nINNER JOIN Weather y\\nON today.RecordDate = DATEADD(d, 1, y.RecordDate)\\nWHERE today.Temperature > y.Temperature\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nSELECT today.Id \\nFROM Weather today\\nINNER JOIN Weather y\\nON today.RecordDate = DATEADD(d, 1, y.RecordDate)\\nWHERE today.Temperature > y.Temperature\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 317553,
                "title": "easy-solution",
                "content": "select w.Id from Weather as w inner join Weather as h on to_days(w.RecordDate) = to_days(h.RecordDate)+1 and w.Temperature > h.Temperature;",
                "solutionTags": [],
                "code": "select w.Id from Weather as w inner join Weather as h on to_days(w.RecordDate) = to_days(h.RecordDate)+1 and w.Temperature > h.Temperature;",
                "codeTag": "Unknown"
            },
            {
                "id": 55635,
                "title": "why-using-a-condition-on-id-not-working",
                "content": "\\n    SELECT a.Id FROM Weather a INNER JOIN Weather b ON a.Id=b.Id+1\\n     WHERE a.Temperature>b.Temperature\\n\\nI know the logic here is all about one day earlier, but the code I write should have given the same answer. However, it was not working here. Why?",
                "solutionTags": [],
                "code": "\\n    SELECT a.Id FROM Weather a INNER JOIN Weather b ON a.Id=b.Id+1\\n     WHERE a.Temperature>b.Temperature\\n\\nI know the logic here is all about one day earlier, but the code I write should have given the same answer. However, it was not working here. Why?",
                "codeTag": "Unknown"
            },
            {
                "id": 3511128,
                "title": "93-beats-with-lag-over-100-memory-oracle",
                "content": "If you have any doubts, feel free to ask...\\nIf you understand the concept. Don\\'t Forget to upvote \\uD83D\\uDE0A\\n\\n# Code\\n```\\nselect id from\\n(select\\nid,\\ntemperature,\\nrecordDate,\\nlag(recordDate) OVER (order by recordDate) as prevDate,\\nlag(temperature) OVER (order by recordDate) as prevTemp\\nfrom weather)\\nwhere temperature>prevTemp and recordDate-prevDate=1;\\n```\\n",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nselect id from\\n(select\\nid,\\ntemperature,\\nrecordDate,\\nlag(recordDate) OVER (order by recordDate) as prevDate,\\nlag(temperature) OVER (order by recordDate) as prevTemp\\nfrom weather)\\nwhere temperature>prevTemp and recordDate-prevDate=1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3303954,
                "title": "sql-server-clean-easy",
                "content": "```\\nSELECT w.id\\nFROM Weather w\\nJOIN Weather yesterday\\nON DATEDIFF(DAY, yesterday.recordDate, w.recordDate) = 1\\nWHERE w.temperature > yesterday.temperature\\n\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT w.id\\nFROM Weather w\\nJOIN Weather yesterday\\nON DATEDIFF(DAY, yesterday.recordDate, w.recordDate) = 1\\nWHERE w.temperature > yesterday.temperature\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3218996,
                "title": "91-with-inner-join-sql-server",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\n\\n\\n\\nselect\\n\\tT2.id\\nfrom\\n\\tWeather T1\\nINNER JOIN\\n\\tWeather T2 ON    \\n\\t\\t\\t\\tDATEADD(DAY,1,T1.recordDate ) = T2.recordDate\\n            AND\\n              T1.temperature  < T2.temperature \\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\n\\n\\nselect\\n\\tT2.id\\nfrom\\n\\tWeather T1\\nINNER JOIN\\n\\tWeather T2 ON    \\n\\t\\t\\t\\tDATEADD(DAY,1,T1.recordDate ) = T2.recordDate\\n            AND\\n              T1.temperature  < T2.temperature \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2708617,
                "title": "simple-solution-mysql",
                "content": "```\\nSelect (a.id) as Id from weather a, weather b\\nwhere\\ndatediff(a.recordDate , b.recordDate)=1 and a.temperature > b.temperature ;\\n```",
                "solutionTags": [],
                "code": "```\\nSelect (a.id) as Id from weather a, weather b\\nwhere\\ndatediff(a.recordDate , b.recordDate)=1 and a.temperature > b.temperature ;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2101723,
                "title": "simple-solution",
                "content": "```\\n# Write your MySQL query statement below\\nSELECT \\n    A.ID \\nFROM\\n    WEATHER A,\\n    WEATHER B\\nWHERE\\n    DATEDIFF(A.RECORDDATE, B.RECORDDATE) = 1\\n    AND\\n    B.TEMPERATURE < A.TEMPERATURE\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT \\n    A.ID \\nFROM\\n    WEATHER A,\\n    WEATHER B\\nWHERE\\n    DATEDIFF(A.RECORDDATE, B.RECORDDATE) = 1\\n    AND\\n    B.TEMPERATURE < A.TEMPERATURE\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1198477,
                "title": "ms-sql-server-solution",
                "content": "```\\n\\nselect  id from\\n(\\nselect id,recordDate, Temperature,\\nlag(Temperature,1) over(order by recordDate) as Temperature_lag,\\nlag(recordDate,1) over(order by recordDate) as recordDate_lag\\nfrom Weather ) tbl1\\nwhere \\ndatediff(day,recordDate, recordDate_lag) = -1 and Temperature > Temperature_lag\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nselect  id from\\n(\\nselect id,recordDate, Temperature,\\nlag(Temperature,1) over(order by recordDate) as Temperature_lag,\\nlag(recordDate,1) over(order by recordDate) as recordDate_lag\\nfrom Weather ) tbl1\\nwhere \\ndatediff(day,recordDate, recordDate_lag) = -1 and Temperature > Temperature_lag\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55645,
                "title": "datediff-and-inner-join",
                "content": "select B.Id from Weather A,Weather B where A.Temperature < B.Temperature and datediff(B.Date,A.date)=1\\n\\nMysql\\u7684datediff \\u51fd\\u6570\\u548csql server\\u4e0d\\u540c\\uff0cDATEDIFF() \\u51fd\\u6570\\u8fd4\\u56de\\u4e24\\u4e2a\\u65e5\\u671f\\u4e4b\\u95f4\\u7684\\u5929\\u6570\\u3002 \\u683c\\u5f0f DATEDIFF(date1,date2)\\n\\ndate1-date2",
                "solutionTags": [],
                "code": "select B.Id from Weather A,Weather B where A.Temperature < B.Temperature and datediff(B.Date,A.date)=1\\n\\nMysql\\u7684datediff \\u51fd\\u6570\\u548csql server\\u4e0d\\u540c\\uff0cDATEDIFF() \\u51fd\\u6570\\u8fd4\\u56de\\u4e24\\u4e2a\\u65e5\\u671f\\u4e4b\\u95f4\\u7684\\u5929\\u6570\\u3002 \\u683c\\u5f0f DATEDIFF(date1,date2)\\n\\ndate1-date2",
                "codeTag": "Unknown"
            },
            {
                "id": 55646,
                "title": "a-solusion-with-time-1025-ms",
                "content": "    select a.Id from (select w2.Id from Weather w1 join Weather w2 on datediff(w2.Date,w1.Date)=1 where w1.Temperature < w2.Temperature) a",
                "solutionTags": [],
                "code": "    select a.Id from (select w2.Id from Weather w1 join Weather w2 on datediff(w2.Date,w1.Date)=1 where w1.Temperature < w2.Temperature) a",
                "codeTag": "Unknown"
            },
            {
                "id": 3977250,
                "title": "197-rising-temperature",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nSELECT W1.id FROM Weather W1, Weather W2 \\nWHERE DATEDIFF(W1.recordDate, W2.recordDate) = 1 \\nAND W1.temperature > W2.temperature;\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT W1.id FROM Weather W1, Weather W2 \\nWHERE DATEDIFF(W1.recordDate, W2.recordDate) = 1 \\nAND W1.temperature > W2.temperature;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3757668,
                "title": "what-or-why-solution-approach-wow-solution-approach",
                "content": "# Intuition\\nTo find date, which are having higher temperature then yesterday.\\nSo first observation is that we have to find the relation between same column elements, why leads us to SELF JOIN, now as SELF JOIN uses simple O(n^2) approach( other words two for loops on same table) to match the values on the value we want here we are concerned about two things \\n1. Comparision between two date, which can be 1 or -1 let use take 1 only to  understand\\n2. If difference between two dates is 1 means first date is today and second date is yesterday ( thing what does -1 means then? ) now today temperature should be greater then yesterdays temperature.\\n\\n\\n# Approach\\n1. For Comparision or date difference we used DATEDIFF and checked if it is 1 ( you should try -1 also)\\n2. As differnce is 1 implies first.temp > sec.temp\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSelect first.id\\nfrom Weather first, Weather sec\\nwhere DATEDIFF(first.recordDate,sec.recordDate) =1 and first.temperature>sec.temperature;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSelect first.id\\nfrom Weather first, Weather sec\\nwhere DATEDIFF(first.recordDate,sec.recordDate) =1 and first.temperature>sec.temperature;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3565539,
                "title": "simple-sql-solution",
                "content": "# Code\\n```\\nSelect w1.id\\nfrom Weather w1, Weather w2\\nwhere w1.Temperature > w2.temperature \\nand datediff(w1.recordDate, w2.recordDate) = 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSelect w1.id\\nfrom Weather w1, Weather w2\\nwhere w1.Temperature > w2.temperature \\nand datediff(w1.recordDate, w2.recordDate) = 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3537651,
                "title": "197-rising-temperature",
                "content": "SELECT a.id\\nFROM Weather as a,Weather as b\\nWHERE a.temperature>b.temperature\\nAND DATEDIFF(a.recordDate,b.recordDate)=1",
                "solutionTags": [],
                "code": "SELECT a.id\\nFROM Weather as a,Weather as b\\nWHERE a.temperature>b.temperature\\nAND DATEDIFF(a.recordDate,b.recordDate)=1",
                "codeTag": "Unknown"
            },
            {
                "id": 2945816,
                "title": "easy-solution-sql",
                "content": "\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nselect t2.id from weather t1 , weather t2 \\nwhere t2.temperature > t1.temperature \\nand to_date(t2.recorddate) - to_date(t1.recorddate)=1 ;\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nselect t2.id from weather t1 , weather t2 \\nwhere t2.temperature > t1.temperature \\nand to_date(t2.recorddate) - to_date(t1.recorddate)=1 ;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2919590,
                "title": "best-and-optimized-solution",
                "content": "# The fast solution\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Code\\n```\\nselect W1.id as Id\\nfrom Weather W1, Weather W2\\nwhere W2.recordDate = DATEADD(day, -1, W1.recordDate) \\nand W1.temperature > W2.temperature\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nselect W1.id as Id\\nfrom Weather W1, Weather W2\\nwhere W2.recordDate = DATEADD(day, -1, W1.recordDate) \\nand W1.temperature > W2.temperature\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2849302,
                "title": "easiest-solution-mysql-simple-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n# select x.id from Weather x,Weather y where x.temperature>y.temperature and (x.id-y.id)=1;\\nselect x.id from Weather x,Weather y where x.temperature>y.temperature and datediff(x.recordDate,y.recordDate)=1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n# select x.id from Weather x,Weather y where x.temperature>y.temperature and (x.id-y.id)=1;\\nselect x.id from Weather x,Weather y where x.temperature>y.temperature and datediff(x.recordDate,y.recordDate)=1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2691996,
                "title": "mysql-solution-with-lag-beats-93-95-100-memory",
                "content": "![image](https://assets.leetcode.com/users/images/ff421f3e-f38a-4e8e-b682-f7bddadfc7ae_1665518625.636787.png)\\n```\\n# Write your MySQL query statement below\\nselect id from (\\n  select id, temperature, recordDate,\\n  lag(temperature) over(order by recordDate) as prevTemp,\\n  lag(recordDate) over(order by recordDate) as prevDate\\n  from Weather\\n) as T\\nwhere T.temperature > T.prevTemp\\n      and datediff(T.recordDate, T.prevDate)=1;\\n\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nselect id from (\\n  select id, temperature, recordDate,\\n  lag(temperature) over(order by recordDate) as prevTemp,\\n  lag(recordDate) over(order by recordDate) as prevDate\\n  from Weather\\n) as T\\nwhere T.temperature > T.prevTemp\\n      and datediff(T.recordDate, T.prevDate)=1;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2686629,
                "title": "mysql-solution",
                "content": "```\\nselect w1.id\\nfrom weather as w1, weather as w2\\nwhere w1.temperature> w2.temperature \\nand datediff(w1.recordDate, w2.recordDate)=1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect w1.id\\nfrom weather as w1, weather as w2\\nwhere w1.temperature> w2.temperature \\nand datediff(w1.recordDate, w2.recordDate)=1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2679834,
                "title": "mysql-join-beginner-friendly",
                "content": "# Write your MySQL query statement below\\n```\\nSELECT w1.id FROM weather w1,weather w2 \\nWHERE DATEDIFF(w1.recordDate,w2.recordDate)=1\\nAND w1.temperature>w2.temperature;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT w1.id FROM weather w1,weather w2 \\nWHERE DATEDIFF(w1.recordDate,w2.recordDate)=1\\nAND w1.temperature>w2.temperature;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2562379,
                "title": "datediff-self-join-think-first-using-these-concepts",
                "content": "***So you\\'re here , this is the solution.  Do upvote if you liked it***\\n\\n```\\nselect w1.id \\nfrom weather w1, weather w2 \\nwhere w1.temperature > w2.temperature and \\ndatediff(w1.recordDate , w2.recordDate) = 1 ;\\n```\\n\\ndatediff function as name suggests gives the difference b/w two dates and we have to calculate only for previous days as mentioned.\\nElse is understandable.\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nselect w1.id \\nfrom weather w1, weather w2 \\nwhere w1.temperature > w2.temperature and \\ndatediff(w1.recordDate , w2.recordDate) = 1 ;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2545810,
                "title": "197-rising-temperature",
                "content": "```\\nSELECT Weather.id\\nFROM Weather\\n\\nINNER JOIN Weather AS W2\\nON W2.RecordDate = SUBDATE(Weather.RecordDate, INTERVAL 1 DAY)\\nWHERE W2.Temperature < Weather.Temperature;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT Weather.id\\nFROM Weather\\n\\nINNER JOIN Weather AS W2\\nON W2.RecordDate = SUBDATE(Weather.RecordDate, INTERVAL 1 DAY)\\nWHERE W2.Temperature < Weather.Temperature;",
                "codeTag": "Unknown"
            },
            {
                "id": 2347380,
                "title": "2-approaches-to-learn-from-mistake",
                "content": "This one ran 9/14 cases\\n```\\nselect DISTINCT d2.id\\nfrom Weather as d1, Weather as d2\\nWhere d1.recordDate<d2.recordDate AND d2.temperature>d1.temperature and d2.id-d1.id=1;\\n```\\nCorrect ans is below \\n```\\nSELECT wt1.Id \\nFROM Weather wt1, Weather wt2\\nWHERE wt1.Temperature > wt2.Temperature AND TO_DAYS(wt1.recordDate)-TO_DAYS(wt2.recordDate)=1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect DISTINCT d2.id\\nfrom Weather as d1, Weather as d2\\nWhere d1.recordDate<d2.recordDate AND d2.temperature>d1.temperature and d2.id-d1.id=1;\\n```\n```\\nSELECT wt1.Id \\nFROM Weather wt1, Weather wt2\\nWHERE wt1.Temperature > wt2.Temperature AND TO_DAYS(wt1.recordDate)-TO_DAYS(wt2.recordDate)=1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2091635,
                "title": "mysql-easiest-solution",
                "content": "**Pls Upvote if you like the Solution!**\\n```\\nSELECT wt1.Id \\nFROM Weather wt1, Weather wt2\\nWHERE wt1.Temperature > wt2.Temperature AND \\n      TO_DAYS(wt1.recordDate)-TO_DAYS(wt2.recordDate)=1;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "**Pls Upvote if you like the Solution!**\\n```\\nSELECT wt1.Id \\nFROM Weather wt1, Weather wt2\\nWHERE wt1.Temperature > wt2.Temperature AND \\n      TO_DAYS(wt1.recordDate)-TO_DAYS(wt2.recordDate)=1;",
                "codeTag": "Unknown"
            },
            {
                "id": 1986879,
                "title": "simple-solution-oracle-and-mysql",
                "content": "Simple approach in Oracle and MySQL \\n\\n```\\nOracle:\\n\\nselect w1.id from Weather w1, Weather w2\\nwhere w1.recordDate-w2.recordDate=1\\nand w1.temperature > w2.temperature\\n\\nMySQL:\\n\\nselect w1.id from Weather w1\\njoin Weather w2\\non datediff(w1.recordDate,w2.recordDate)=1\\nand w1.temperature>w2.temperature\\n\\n```",
                "solutionTags": [
                    "MySQL",
                    "Oracle"
                ],
                "code": "```\\nOracle:\\n\\nselect w1.id from Weather w1, Weather w2\\nwhere w1.recordDate-w2.recordDate=1\\nand w1.temperature > w2.temperature\\n\\nMySQL:\\n\\nselect w1.id from Weather w1\\njoin Weather w2\\non datediff(w1.recordDate,w2.recordDate)=1\\nand w1.temperature>w2.temperature\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1598224,
                "title": "mysql-datediff",
                "content": "```\\nSELECT a.id FROM Weather a\\nCROSS JOIN Weather b\\nWHERE DATEDIFF(a.recordDate, b.recordDate) = 1\\nAND a.temperature>b.temperature\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT a.id FROM Weather a\\nCROSS JOIN Weather b\\nWHERE DATEDIFF(a.recordDate, b.recordDate) = 1\\nAND a.temperature>b.temperature\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1346230,
                "title": "simple-inner-join-oracle",
                "content": "```\\nselect a.id from weather a,weather b where a.recorddate-1=b.recorddate and a.temperature>b.temperature;\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nselect a.id from weather a,weather b where a.recorddate-1=b.recorddate and a.temperature>b.temperature;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1336386,
                "title": "why-is-this-not-giving-the-correct-result-the-last-test-case-fails",
                "content": "SELECT W.Id FROM Weather W \\nINNER JOIN Weather W1 ON \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t(W.RecordDate = W1.RecordDate + 1 \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tAND W.Temperature > W1.Temperature);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\nUPD: I changed the first condition to \\nDATEDIFF(W.RecDate, W1.RecDate) = 1\\n and it worked. I\\'m still curious though, why did the initial arithmetic work for the first 13 test cases?",
                "solutionTags": [],
                "code": "SELECT W.Id FROM Weather W \\nINNER JOIN Weather W1 ON \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t(W.RecordDate = W1.RecordDate + 1 \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tAND W.Temperature > W1.Temperature);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\nUPD: I changed the first condition to \\nDATEDIFF(W.RecDate, W1.RecDate) = 1\\n and it worked. I\\'m still curious though, why did the initial arithmetic work for the first 13 test cases?",
                "codeTag": "Unknown"
            },
            {
                "id": 1090326,
                "title": "easy-mysql-solution",
                "content": "```\\nSELECT w1.id\\nFROM Weather w1, Weather w2\\nWHERE DATEDIFF(w1.recordDate, w2.recordDate) = 1\\nAND w1.Temperature > w2.Temperature\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT w1.id\\nFROM Weather w1, Weather w2\\nWHERE DATEDIFF(w1.recordDate, w2.recordDate) = 1\\nAND w1.Temperature > w2.Temperature\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55644,
                "title": "simple-solution-using-datediff",
                "content": "    select w1.Id from Weather w1, Weather w2\\n    where w1.Temperature > w2.Temperature \\n    and datediff(w1.Date, w2.Date) = 1;",
                "solutionTags": [],
                "code": "    select w1.Id from Weather w1, Weather w2\\n    where w1.Temperature > w2.Temperature \\n    and datediff(w1.Date, w2.Date) = 1;",
                "codeTag": "Unknown"
            },
            {
                "id": 55637,
                "title": "incorrect-expectation-for-first-day-of-the-month-results",
                "content": "The approach [chriszeng8](https://leetcode.com/discuss/44574/subtracting-directly-from-date-working-subdate-date-works) took is actually correct for this particular problem, even though it may not work for date differences bigger than `1`; here's how I tried it:\\n\\n    select wCurr.id as 'Id'\\n    from Weather wCurr\\n    join Weather wPrev on wCurr.date - 1 = wPrev.date\\n    where wPrev.temperature < wCurr.temperature\\n\\nAnd then my answer was rejected with \"Wrong answer\":\\n> https://leetcode.com/submissions/detail/45866299/  \\n> 13 / 14 test cases passed.\\n\\nThe `output` and `expected` diff looks like this:\\n\\n    {\"headers\": [\"Id\"], \"values\": [\\n        ..., [407], ..., [507], ..., [295], ..., [921], ..., [225], ..., [1167], ..., [462],\\n        ..., [925], ..., [875], ..., [178], ..., [1112], ..., [397], ..., [625], ...\\n    ]}\\n\\nWhere `...` are exact matches for the expected output, meaning the values listed above are extra results in my output. Let's see what those IDs correspond to in the `input` (sorted by date, filtered relevant lines):\\n\\n\\t|------|------------|------|\\n\\t|  id  |    date    | temp |\\n\\t|======|============|======|\\n\\t|  255 | 1998-08-31 |  -62 |\\n\\t|  225 | 1998-09-01 |   91 |\\n\\t|------|------------|------|\\n\\t|  139 | 1998-09-30 |  -43 |\\n\\t| 1167 | 1998-10-01 |  -17 |\\n\\t|------|------------|------|\\n\\t|  636 | 1998-10-31 |  -32 |\\n\\t|  407 | 1998-11-01 |   -9 |\\n\\t|------|------------|------|\\n\\t|   85 | 1999-03-31 |  -26 |\\n\\t|  178 | 1999-04-01 |   -1 |\\n\\t|------|------------|------|\\n\\t|  699 | 1999-05-31 |  -97 |\\n\\t|  875 | 1999-06-01 |   79 |\\n\\t|------|------------|------|\\n\\t|  247 | 1999-07-31 |  -67 |\\n\\t|  295 | 1999-08-01 |   76 |\\n\\t|------|------------|------|\\n\\t|  509 | 1999-10-31 |  -40 |\\n\\t|  462 | 1999-11-01 |  -13 |\\n\\t|------|------------|------|\\n\\t|  157 | 2000-12-31 |  -72 |\\n\\t|  397 | 2001-01-01 |   90 |\\n\\t|------|------------|------|\\n\\t|  472 | 2001-09-30 |    4 |\\n\\t|  507 | 2001-10-01 |   38 |\\n\\t|------|------------|------|\\n\\t|  707 | 2001-12-31 |   55 |\\n\\t|  625 | 2002-01-01 |   87 |\\n\\t|------|------------|------|\\n\\t|  126 | 2002-06-30 |  -50 |\\n\\t|  925 | 2002-07-01 |   -4 |\\n\\t|------|------------|------|\\n\\t|  840 | 2002-07-31 |  -46 |\\n\\t|  921 | 2002-08-01 |  -35 |\\n\\t|------|------------|------|\\n\\t|  753 | 2002-08-31 |   42 |\\n\\t| 1112 | 2002-09-01 |   57 |\\n\\t|------|------------|------|",
                "solutionTags": [],
                "code": "The approach [chriszeng8](https://leetcode.com/discuss/44574/subtracting-directly-from-date-working-subdate-date-works) took is actually correct for this particular problem, even though it may not work for date differences bigger than `1`; here's how I tried it:\\n\\n    select wCurr.id as 'Id'\\n    from Weather wCurr\\n    join Weather wPrev on wCurr.date - 1 = wPrev.date\\n    where wPrev.temperature < wCurr.temperature\\n\\nAnd then my answer was rejected with \"Wrong answer\":\\n> https://leetcode.com/submissions/detail/45866299/  \\n> 13 / 14 test cases passed.\\n\\nThe `output` and `expected` diff looks like this:\\n\\n    {\"headers\": [\"Id\"], \"values\": [\\n        ..., [407], ..., [507], ..., [295], ..., [921], ..., [225], ..., [1167], ..., [462],\\n        ..., [925], ..., [875], ..., [178], ..., [1112], ..., [397], ..., [625], ...\\n    ]}\\n\\nWhere `...` are exact matches for the expected output, meaning the values listed above are extra results in my output. Let's see what those IDs correspond to in the `input` (sorted by date, filtered relevant lines):\\n\\n\\t|------|------------|------|\\n\\t|  id  |    date    | temp |\\n\\t|======|============|======|\\n\\t|  255 | 1998-08-31 |  -62 |\\n\\t|  225 | 1998-09-01 |   91 |\\n\\t|------|------------|------|\\n\\t|  139 | 1998-09-30 |  -43 |\\n\\t| 1167 | 1998-10-01 |  -17 |\\n\\t|------|------------|------|\\n\\t|  636 | 1998-10-31 |  -32 |\\n\\t|  407 | 1998-11-01 |   -9 |\\n\\t|------|------------|------|\\n\\t|   85 | 1999-03-31 |  -26 |\\n\\t|  178 | 1999-04-01 |   -1 |\\n\\t|------|------------|------|\\n\\t|  699 | 1999-05-31 |  -97 |\\n\\t|  875 | 1999-06-01 |   79 |\\n\\t|------|------------|------|\\n\\t|  247 | 1999-07-31 |  -67 |\\n\\t|  295 | 1999-08-01 |   76 |\\n\\t|------|------------|------|\\n\\t|  509 | 1999-10-31 |  -40 |\\n\\t|  462 | 1999-11-01 |  -13 |\\n\\t|------|------------|------|\\n\\t|  157 | 2000-12-31 |  -72 |\\n\\t|  397 | 2001-01-01 |   90 |\\n\\t|------|------------|------|\\n\\t|  472 | 2001-09-30 |    4 |\\n\\t|  507 | 2001-10-01 |   38 |\\n\\t|------|------------|------|\\n\\t|  707 | 2001-12-31 |   55 |\\n\\t|  625 | 2002-01-01 |   87 |\\n\\t|------|------------|------|\\n\\t|  126 | 2002-06-30 |  -50 |\\n\\t|  925 | 2002-07-01 |   -4 |\\n\\t|------|------------|------|\\n\\t|  840 | 2002-07-31 |  -46 |\\n\\t|  921 | 2002-08-01 |  -35 |\\n\\t|------|------------|------|\\n\\t|  753 | 2002-08-31 |   42 |\\n\\t| 1112 | 2002-09-01 |   57 |\\n\\t|------|------------|------|",
                "codeTag": "Unknown"
            },
            {
                "id": 4095278,
                "title": "easiest-ms-sql-server-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCross join on the given table and just write the conditions as in the question and select the the id from w2 as the id of the second table in join will give you the desired output as per the conditions.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nselect w2.id from weather w1 \\ninner join weather w2\\non DATEDIFF(day, w1.recordDate, w2.recordDate ) = 1 and w2.temperature > w1.temperature\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nselect w2.id from weather w1 \\ninner join weather w2\\non DATEDIFF(day, w1.recordDate, w2.recordDate ) = 1 and w2.temperature > w1.temperature\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4088116,
                "title": "simple-sql-beat-96-51",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT w1.id\\nFROM Weather w1 \\nINNER JOIN Weather w2\\nON w1.recordDate = DATE_ADD(w2.recordDate,INTERVAL 1 DAY)\\nWHERE w1.temperature > w2.temperature\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT w1.id\\nFROM Weather w1 \\nINNER JOIN Weather w2\\nON w1.recordDate = DATE_ADD(w2.recordDate,INTERVAL 1 DAY)\\nWHERE w1.temperature > w2.temperature\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4056328,
                "title": "pandas-sql-easy-rising-temperature-easy",
                "content": "[see the Accepted Solution](https://leetcode.com/submissions/detail/1051882154/)\\n```\\ndef rising_temperature(weather: pd.DataFrame) -> pd.DataFrame:\\n    \\n    # 1) First, we sort the DataFrame by \\'recordDate\\' in ascending order\\n    weather.sort_values(by=\\'recordDate\\', ascending=True, inplace=True)\\n\\n    # 2) Then, the difference in temperature between consecutive rows are calculated\\n    weather[\\'temperature_diff\\'] = weather[\\'temperature\\'] - weather[\\'temperature\\'].shift(1)\\n    \\n    # 3) At the same time, we calculate the difference in recordDate between consecutive rows\\n    weather[\\'recordDate_diff\\'] = weather[\\'recordDate\\'] - weather[\\'recordDate\\'].shift(1)\\n\\n    # 4) then, we select rows where the temperature difference is greater than 0 and the date difference is 1 day\\n    filter_rising_temperature = weather[(weather[\\'temperature_diff\\'] > 0) & (weather[\\'recordDate_diff\\'] == pd.Timedelta(days=1))][\\'id\\']\\n    \\n    # 5) Finaly, a new Pandas DataFrame from the filtered data above is created\\n    result_df = pd.DataFrame(filter_rising_temperature)\\n \\n    return result_df\\n```\\n\\n**SQL**\\n[see the Accepted Solution](https://leetcode.com/submissions/detail/1061634982/)\\n\\n```\\nSELECT weather1.id\\nFROM Weather weather1 \\nINNER JOIN Weather weather2\\nON weather1.recordDate = DATE_ADD(weather2.recordDate, \\n                                  INTERVAL 1 DAY)\\nWHERE weather1.temperature > weather2.temperature\\n```\\n\\n```\\n-- Select the \"id\" column from the \"Weather\" table using the alias \"weather1\"\\nSELECT weather1.id\\n\\n-- Specify that we are performing an INNER JOIN between two instances of the \"Weather\" table: \"weather1\" and \"weather2\"\\nFROM Weather weather1\\nINNER JOIN Weather weather2\\n\\n-- Define the JOIN condition: we are matching records where the \"recordDate\" in \"weather1\" matches the \"recordDate\" in \"weather2\" \\n-- after adding one day to the date from \"weather2\" using DATE_ADD function\\nON weather1.recordDate = DATE_ADD(weather2.recordDate, INTERVAL 1 DAY)\\n\\n-- Apply a WHERE clause to further filter the results:\\n-- We are selecting records where the \"temperature\" in \"weather1\" is greater than the \"temperature\" in \"weather2\"\\nWHERE weather1.temperature > weather2.temperature\\n```\\n\\t\\n![image](https://assets.leetcode.com/users/images/365567d6-f863-4d76-8095-d8e7800a8a35_1695222065.3166265.jpeg)\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\ndef rising_temperature(weather: pd.DataFrame) -> pd.DataFrame:\\n    \\n    # 1) First, we sort the DataFrame by \\'recordDate\\' in ascending order\\n    weather.sort_values(by=\\'recordDate\\', ascending=True, inplace=True)\\n\\n    # 2) Then, the difference in temperature between consecutive rows are calculated\\n    weather[\\'temperature_diff\\'] = weather[\\'temperature\\'] - weather[\\'temperature\\'].shift(1)\\n    \\n    # 3) At the same time, we calculate the difference in recordDate between consecutive rows\\n    weather[\\'recordDate_diff\\'] = weather[\\'recordDate\\'] - weather[\\'recordDate\\'].shift(1)\\n\\n    # 4) then, we select rows where the temperature difference is greater than 0 and the date difference is 1 day\\n    filter_rising_temperature = weather[(weather[\\'temperature_diff\\'] > 0) & (weather[\\'recordDate_diff\\'] == pd.Timedelta(days=1))][\\'id\\']\\n    \\n    # 5) Finaly, a new Pandas DataFrame from the filtered data above is created\\n    result_df = pd.DataFrame(filter_rising_temperature)\\n \\n    return result_df\\n```\n```\\nSELECT weather1.id\\nFROM Weather weather1 \\nINNER JOIN Weather weather2\\nON weather1.recordDate = DATE_ADD(weather2.recordDate, \\n                                  INTERVAL 1 DAY)\\nWHERE weather1.temperature > weather2.temperature\\n```\n```\\n-- Select the \"id\" column from the \"Weather\" table using the alias \"weather1\"\\nSELECT weather1.id\\n\\n-- Specify that we are performing an INNER JOIN between two instances of the \"Weather\" table: \"weather1\" and \"weather2\"\\nFROM Weather weather1\\nINNER JOIN Weather weather2\\n\\n-- Define the JOIN condition: we are matching records where the \"recordDate\" in \"weather1\" matches the \"recordDate\" in \"weather2\" \\n-- after adding one day to the date from \"weather2\" using DATE_ADD function\\nON weather1.recordDate = DATE_ADD(weather2.recordDate, INTERVAL 1 DAY)\\n\\n-- Apply a WHERE clause to further filter the results:\\n-- We are selecting records where the \"temperature\" in \"weather1\" is greater than the \"temperature\" in \"weather2\"\\nWHERE weather1.temperature > weather2.temperature\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3791432,
                "title": "i-solve-it-using-inner-join",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#w1 is testerday and w2 is today\\n\\nselect w2.id\\nfrom weather w1\\ninner join weather w2\\non  w1.recordDate  = Date_add(w2.recordDate, interval - 1 day)\\nAND w2.temperature > w1.temperature\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n#w1 is testerday and w2 is today\\n\\nselect w2.id\\nfrom weather w1\\ninner join weather w2\\non  w1.recordDate  = Date_add(w2.recordDate, interval - 1 day)\\nAND w2.temperature > w1.temperature\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3787575,
                "title": "easy-mysql-solution",
                "content": "\\n# Code\\n```\\n\\n\\nSELECT w2.id from Weather w1,Weather w2\\nWHERE datediff(w2.recordDate, w1.recordDate) = 1 AND w2.temperature > w1.temperature;\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n\\n\\nSELECT w2.id from Weather w1,Weather w2\\nWHERE datediff(w2.recordDate, w1.recordDate) = 1 AND w2.temperature > w1.temperature;\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3770092,
                "title": "eassy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect w1.id from Weather w1, Weather w2 where dateDiff(w1.recordDate,w2.recordDate) = 1 And w1.Temperature> w2.Temperature\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect w1.id from Weather w1, Weather w2 where dateDiff(w1.recordDate,w2.recordDate) = 1 And w1.Temperature> w2.Temperature\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3762750,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe first thought after looking into the Problem Statement should be that there is only one Table, We need to write a query which will do Self Join on itself\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe keypoint should be :\\n- **create a query where we check the data between Dates having a difference of \"1 DAY\"**\\n- **AND (very important and not OR)**\\n- **temp of day 1 should be greater than day 2**\\n\\n\\n# Code\\n```\\n\\nselect w1.id from Weather w1, Weather w2\\nwhere dateDiff(w1.recordDate,w2.recordDate) = 1\\nAnd \\nw1.Temperature> w2.Temperature\\n```\\n\\nHope it Helps\\nAlso This is my First Solution on LeetCode\\nHave a Great Day!\\n**Be consistent**",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n\\nselect w1.id from Weather w1, Weather w2\\nwhere dateDiff(w1.recordDate,w2.recordDate) = 1\\nAnd \\nw1.Temperature> w2.Temperature\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3758636,
                "title": "rising-temp-datediff",
                "content": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect w2.id \\nfrom Weather as w1 ,Weather as w2 \\nwhere datediff(w2.recordDate,w1.recordDate)=1 \\nand w2.temperature>w1.temperature;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect w2.id \\nfrom Weather as w1 ,Weather as w2 \\nwhere datediff(w2.recordDate,w1.recordDate)=1 \\nand w2.temperature>w1.temperature;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3757167,
                "title": "solution-with-70-percent-beating-rate",
                "content": "# Intuition\\nWe need to compare the temperature of each date with the temperature of the previous date (yesterday).\\nTo perform this comparison, we can join the Weather table with itself, creating two instances of the table (w1 and w2).\\nBy joining the tables based on the recordDate column of w1 and the next day\\'s date (DATE_ADD(w2.recordDate, INTERVAL 1 DAY)), we can align the temperatures of consecutive dates for comparison.\\nThe WHERE clause filters the rows where the temperature of the current date (w1.temperature) is higher than the temperature of the previous day (w2.temperature).\\nFinally, we select the id values from w1 for the matched rows, representing the dates with higher temperatures than their previous dates.\\n\\nThe intuition is to use a self-join operation to align the temperatures of consecutive dates, enabling direct comparison. By checking if the temperature of a date is higher than its previous date, we can identify the desired rows.\\n\\n# Approach\\nThe query joins the Weather table w1 with itself w2 by matching the recordDate of w1 with the next day\\'s recordDate in w2 using the DATE_ADD function. The WHERE clause filters the rows where the temperature of the current day (w1.temperature) is higher than the temperature of the next day (w2.temperature). Finally, the SELECT statement retrieves the id values from the w1 table for the matched rows.\\n\\n# Complexity\\n- Time complexity:\\nJoining two tables typically has a time complexity of O(n * m), where n is the number of rows in the first table and m is the number of rows in the second table.\\nIn this case, assuming the recordDate column is indexed, the join operation can be efficient and reduce the time complexity.\\nTherefore, the time complexity of the query is typically O(n), where n is the number of rows in the Weather table.\\n\\n- Space complexity:\\nThe space complexity of the query is minimal since it doesn\\'t require any additional data structures or memory beyond what is used by the database system itself.\\nIt only requires space to store the result set, which in this case is the id values of the rows where the temperature is higher than the next day\\'s temperature.\\nTherefore, the space complexity is typically O(k), where k is the number of rows in the result set.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSelect w1.id\\nfrom Weather w1\\njoin Weather w2 on w1.recordDate = DATE_ADD(w2.recordDate, INTERVAL 1 DAY)\\nwhere w1.temperature > w2.temperature\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSelect w1.id\\nfrom Weather w1\\njoin Weather w2 on w1.recordDate = DATE_ADD(w2.recordDate, INTERVAL 1 DAY)\\nwhere w1.temperature > w2.temperature\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3742691,
                "title": "ms-sql-self-join",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nSELECT id FROM (\\nSELECT w2.id, w2.temperature - w1.temperature AS temp_diff FROM Weather w1\\nJOIN Weather w2 ON w1.recordDate = DATEADD(day, -1, w2.recordDate)\\n) temp WHERE temp.temp_diff > 0\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nSELECT id FROM (\\nSELECT w2.id, w2.temperature - w1.temperature AS temp_diff FROM Weather w1\\nJOIN Weather w2 ON w1.recordDate = DATEADD(day, -1, w2.recordDate)\\n) temp WHERE temp.temp_diff > 0\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3703263,
                "title": "easy-beats-95",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT t1.id\\nfrom weather t1\\njoin weather t2 on t1.recordDate = date_add(t2.recordDate,interval 1 day)\\nwhere t1.temperature > t2.temperature\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT t1.id\\nfrom weather t1\\njoin weather t2 on t1.recordDate = date_add(t2.recordDate,interval 1 day)\\nwhere t1.temperature > t2.temperature\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3310263,
                "title": "easy-sql-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT X.id FROM WEATHER X,WEATHER Y WHERE DATEDIFF(X.recordDate,Y.recordDate)=1 AND X.temperature>Y.temperature;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT X.id FROM WEATHER X,WEATHER Y WHERE DATEDIFF(X.recordDate,Y.recordDate)=1 AND X.temperature>Y.temperature;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3292046,
                "title": "mysql-solution",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nselect A.id from weather A, weather B\\nwhere datediff(A.recordDate, B.recordDate) = 1 and A.temperature > B.temperature;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect A.id from weather A, weather B\\nwhere datediff(A.recordDate, B.recordDate) = 1 and A.temperature > B.temperature;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3258865,
                "title": "easy-to-understand-query-sql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT A.id FROM weather A, weather B\\nWHERE datediff(A.recordDate, B.recordDate)= 1\\nAND A.temperature > B.temperature;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT A.id FROM weather A, weather B\\nWHERE datediff(A.recordDate, B.recordDate)= 1\\nAND A.temperature > B.temperature;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3244033,
                "title": "mysql-simple-solution-uwu",
                "content": "\\n```\\nSELECT x.id\\nFROM Weather x\\nJOIN Weather y ON x.recordDate = DATE_ADD(y.recordDate, INTERVAL 1 DAY)\\nWHERE x.temperature > y.temperature;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT x.id\\nFROM Weather x\\nJOIN Weather y ON x.recordDate = DATE_ADD(y.recordDate, INTERVAL 1 DAY)\\nWHERE x.temperature > y.temperature;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2930251,
                "title": "fastest",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\n\\nselect a.id from Weather a ,weather b\\nwhere a.recordDate =(b.recordDate +1)\\nand a.temperature>b.temperature   \\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\n\\nselect a.id from Weather a ,weather b\\nwhere a.recordDate =(b.recordDate +1)\\nand a.temperature>b.temperature   \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2905066,
                "title": "easy-solution",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT w1.id\\nFROM Weather AS w1 , Weather AS w2\\nWHERE w1.Temperature > w2.Temperature AND DATEDIFF(w1.recordDate , w2.recordDate) = 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT w1.id\\nFROM Weather AS w1 , Weather AS w2\\nWHERE w1.Temperature > w2.Temperature AND DATEDIFF(w1.recordDate , w2.recordDate) = 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2901027,
                "title": "using-datediff-and-self-join",
                "content": "# Query\\n```\\n# Write your MySQL query statement below\\nSELECT w1.id FROM Weather w1 JOIN Weather w2\\nON DATEDIFF(w1.recordDate, w2.recordDate) = 1\\nAND w1.temperature > w2.temperature;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT w1.id FROM Weather w1 JOIN Weather w2\\nON DATEDIFF(w1.recordDate, w2.recordDate) = 1\\nAND w1.temperature > w2.temperature;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2888726,
                "title": "mysql-solution",
                "content": "\\n```\\n\\nselect w2.id from Weather w1, Weather w2 \\nwhere w2.temperature>w1.temperature \\nAND DATEDIFF(w2.recordDate,w1.recordDate)=1;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n\\nselect w2.id from Weather w1, Weather w2 \\nwhere w2.temperature>w1.temperature \\nAND DATEDIFF(w2.recordDate,w1.recordDate)=1;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2851150,
                "title": "mysql-simple-solution",
                "content": "\\n\\n# Code\\n```\\nselect w2.id\\nfrom Weather w1, Weather w2\\nwhere w1.recordDate = date_add(w2.recordDate, interval -1 day)\\nand w1.temperature < w2.temperature\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect w2.id\\nfrom Weather w1, Weather w2\\nwhere w1.recordDate = date_add(w2.recordDate, interval -1 day)\\nand w1.temperature < w2.temperature\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2677938,
                "title": "mssql-join-weather-to-itself-on-recorddate",
                "content": "```\\nSELECT w1.id FROM weather w1\\n\\nLEFT JOIN weather w2 ON w1.recordDate = dateadd(day, 1, w2.recordDate)\\n\\nWHERE w1.temperature > w2.temperature\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT w1.id FROM weather w1\\n\\nLEFT JOIN weather w2 ON w1.recordDate = dateadd(day, 1, w2.recordDate)\\n\\nWHERE w1.temperature > w2.temperature\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2668343,
                "title": "easy-understanding-mysql",
                "content": "approach- \\n*  consider weather as 2 table\\n*  compare the temperatures and check the date difference\\nusing DATEDIFF() function we check if the difference between current and previous date is 1\\n\\n\\n```\\nselect distinct a.id as \\'Id\\' from weather a, weather b\\nwhere a.temperature > b.temperature\\nand DATEDIFF(a.recorddate,b.recorddate)=1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect distinct a.id as \\'Id\\' from weather a, weather b\\nwhere a.temperature > b.temperature\\nand DATEDIFF(a.recorddate,b.recorddate)=1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2593952,
                "title": "nice-and-easy-mysql-using-lag-datediff",
                "content": "```\\nwith CTE as (select *, lag(recordDate) over(order by recordDate) as prev_date, lag(temperature) over() \\n             as prev_day_temp from Weather)\\nselect id from CTE where\\ntemperature>prev_day_temp and DATEDIFF(recordDate,prev_date)=1\\n```",
                "solutionTags": [],
                "code": "```\\nwith CTE as (select *, lag(recordDate) over(order by recordDate) as prev_date, lag(temperature) over() \\n             as prev_day_temp from Weather)\\nselect id from CTE where\\ntemperature>prev_day_temp and DATEDIFF(recordDate,prev_date)=1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2580487,
                "title": "pretty-simple-using-dateadd-in-sql-server",
                "content": "**Upvote if you feel it easy :)**\\n```\\nSELECT wt.id\\nFROM Weather wt INNER JOIN Weather wy on wy.recorddate = DATEADD(DAY, -1, wt.recorddate)\\nWHERE wt.temperature > wy.temperature;\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nSELECT wt.id\\nFROM Weather wt INNER JOIN Weather wy on wy.recorddate = DATEADD(DAY, -1, wt.recorddate)\\nWHERE wt.temperature > wy.temperature;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2571054,
                "title": "mysql-with-explanation",
                "content": "We need to specify that: \\n- difference of days has to be 1 with DATEDIFF(date1, date2) function.\\n\\tIt calculates like this: (date1-date2). In order to get **datediff=1**, date1 must be the \"next\" day (higher value). Then date1-date2 = 1\\n- following the above, also date1 temp has to be higher than date2 (previous day) temp\\n\\nWe specify which is which (date1, date2, date1.temp, date2.temp) by comparing table to itself with two aliases (w, r)\\n\\n\\tSELECT w.id FROM Weather w, Weather r\\n\\tWHERE DATEDIFF(w.recordDate, r.recordDate) = 1 AND w.temperature > r.temperature",
                "solutionTags": [],
                "code": "We need to specify that: \\n- difference of days has to be 1 with DATEDIFF(date1, date2) function.\\n\\tIt calculates like this: (date1-date2). In order to get **datediff=1**, date1 must be the \"next\" day (higher value). Then date1-date2 = 1\\n- following the above, also date1 temp has to be higher than date2 (previous day) temp\\n\\nWe specify which is which (date1, date2, date1.temp, date2.temp) by comparing table to itself with two aliases (w, r)\\n\\n\\tSELECT w.id FROM Weather w, Weather r\\n\\tWHERE DATEDIFF(w.recordDate, r.recordDate) = 1 AND w.temperature > r.temperature",
                "codeTag": "Unknown"
            },
            {
                "id": 2556659,
                "title": "mysql-solution",
                "content": "```\\nSELECT w2.id FROM Weather w1 JOIN Weather w2 ON DATE_ADD(w1.recordDate, INTERVAL 1 DAY) = w2.recordDate and w2.temperature > w1.temperature;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT w2.id FROM Weather w1 JOIN Weather w2 ON DATE_ADD(w1.recordDate, INTERVAL 1 DAY) = w2.recordDate and w2.temperature > w1.temperature;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2529991,
                "title": "easy-mysql-solution-simple-to-understand",
                "content": "\\tselect wt2.id \\n\\tfrom Weather wt1, Weather wt2\\n\\twhere wt2.temperature > wt1.temperature and\\n\\t\\tto_days(wt2.recordDate) - to_days(wt1.recordDate) = 1;\\nI hope that you\\'ve found the solution useful.\\nIn that case, please do upvote. Happy Coding :)",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "\\tselect wt2.id \\n\\tfrom Weather wt1, Weather wt2\\n\\twhere wt2.temperature > wt1.temperature and\\n\\t\\tto_days(wt2.recordDate) - to_days(wt1.recordDate) = 1;\\nI hope that you\\'ve found the solution useful.\\nIn that case, please do upvote. Happy Coding :)",
                "codeTag": "Unknown"
            },
            {
                "id": 2529736,
                "title": "lag-and-datediff-functions-beats-95",
                "content": "\\'\\'\\'\\nselect id from\\n(select id, \\ntemperature, \\nLAG(temperature) over (order by recordDate) as \\'lt\\', \\nrecordDate,\\nLAG(recordDate) over (order by recordDate) as \\'ld\\'  \\nfrom Weather) t\\nWHERE t.temperature>lt and DATEDIFF(day,ld,recordDate)=1;\\n\\'\\'\\'",
                "solutionTags": [
                    "MySQL",
                    "Oracle"
                ],
                "code": "\\'\\'\\'\\nselect id from\\n(select id, \\ntemperature, \\nLAG(temperature) over (order by recordDate) as \\'lt\\', \\nrecordDate,\\nLAG(recordDate) over (order by recordDate) as \\'ld\\'  \\nfrom Weather) t\\nWHERE t.temperature>lt and DATEDIFF(day,ld,recordDate)=1;\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2497511,
                "title": "multiple-solutions",
                "content": "Thing to learn form this problem: comparing dates.\\n\\n## Solution 1: `DATEDIFF`\\n\\n```sql\\nSELECT DISTINCT current.id\\nFROM Weather previous, Weather current\\nWHERE DATEDIFF(current.recordDate, previous.recordDate) = 1\\nAND previous.temperature < current.temperature\\n```\\n\\n## Solution 2: `TO_DAYS`\\n\\n```sql\\nSELECT DISTINCT current.id\\nFROM Weather previous, Weather current\\nWHERE TO_DAYS(current.recordDate) - TO_DAYS(previous.recordDate) = 1\\nAND previous.temperature < current.temperature\\n```\\nor\\n```sql\\nSELECT DISTINCT current.id\\nFROM Weather previous, Weather current\\nWHERE TO_DAYS(current.recordDate) - 1 = TO_DAYS(previous.recordDate)\\nAND previous.temperature < current.temperature\\n```\\nor\\n```sql\\nSELECT DISTINCT current.id\\nFROM Weather previous, Weather current\\nWHERE TO_DAYS(previous.recordDate) + 1 = TO_DAYS(current.recordDate)\\nAND previous.temperature < current.temperature\\n```\\n\\n## Solution 3: `interval`\\n\\n```sql\\nSELECT DISTINCT current.id\\nFROM Weather previous, Weather current\\nWHERE previous.recordDate + interval 1 day = current.recordDate\\nAND previous.temperature < current.temperature\\n```\\nor\\n```sql\\nSELECT DISTINCT current.id\\nFROM Weather previous, Weather current\\nWHERE current.recordDate - interval 1 day = previous.recordDate\\nAND previous.temperature < current.temperature\\n```\\n\\n## Solution 4: `DATE_ADD` and `interval`\\n\\n```sql\\nSELECT DISTINCT current.id\\nFROM Weather previous, Weather current\\nWHERE DATE_ADD(previous.recordDate, interval 1 day) = current.recordDate\\nAND previous.temperature < current.temperature\\n```\\n\\n## Solution 5: `DATE_SUB` and `interval`\\n\\n```sql\\nSELECT DISTINCT current.id\\nFROM Weather previous, Weather current\\nWHERE DATE_SUB(current.recordDate, interval 1 day) = previous.recordDate\\nAND previous.temperature < current.temperature\\n```\\n\\n## And more\\n\\nAnd many other options, like using `JOIN`s in previous solutions.",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```sql\\nSELECT DISTINCT current.id\\nFROM Weather previous, Weather current\\nWHERE DATEDIFF(current.recordDate, previous.recordDate) = 1\\nAND previous.temperature < current.temperature\\n```\n```sql\\nSELECT DISTINCT current.id\\nFROM Weather previous, Weather current\\nWHERE TO_DAYS(current.recordDate) - TO_DAYS(previous.recordDate) = 1\\nAND previous.temperature < current.temperature\\n```\n```sql\\nSELECT DISTINCT current.id\\nFROM Weather previous, Weather current\\nWHERE TO_DAYS(current.recordDate) - 1 = TO_DAYS(previous.recordDate)\\nAND previous.temperature < current.temperature\\n```\n```sql\\nSELECT DISTINCT current.id\\nFROM Weather previous, Weather current\\nWHERE TO_DAYS(previous.recordDate) + 1 = TO_DAYS(current.recordDate)\\nAND previous.temperature < current.temperature\\n```\n```sql\\nSELECT DISTINCT current.id\\nFROM Weather previous, Weather current\\nWHERE previous.recordDate + interval 1 day = current.recordDate\\nAND previous.temperature < current.temperature\\n```\n```sql\\nSELECT DISTINCT current.id\\nFROM Weather previous, Weather current\\nWHERE current.recordDate - interval 1 day = previous.recordDate\\nAND previous.temperature < current.temperature\\n```\n```sql\\nSELECT DISTINCT current.id\\nFROM Weather previous, Weather current\\nWHERE DATE_ADD(previous.recordDate, interval 1 day) = current.recordDate\\nAND previous.temperature < current.temperature\\n```\n```sql\\nSELECT DISTINCT current.id\\nFROM Weather previous, Weather current\\nWHERE DATE_SUB(current.recordDate, interval 1 day) = previous.recordDate\\nAND previous.temperature < current.temperature\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2481185,
                "title": "mysql-2-solutions-very-easy-lag-twice-join",
                "content": "### \\uD83D\\uDE4B\\uD83C\\uDFFB\\u200D\\u2640\\uFE0F Hello, here are my solutions to the problem.\\n### Please upvote to motivate me post future solutions. HAPPY CODING \\u2764\\uFE0F\\n##### Any suggestions and improvements are always welcome.\\n##### Solution 1: Only join, long, not good \\uD83E\\uDD26\\uD83C\\uDFFB\\u200D\\u2640\\uFE0F\\n##### \\u2705 Runtime: 783 ms, faster than 25.50% of MySQL.\\n```\\nselect\\n    a.id as id\\nfrom\\n    weather a\\njoin weather b \\non datediff(a.recordDate, b.recordDate) = 1\\nand a.Temperature > b.Temperature\\n```\\n##### Solution 2: Lag twice, faster \\uD83C\\uDFAF\\n##### \\u2705 Runtime: 654 ms, faster than 39.98% of MySQL.\\n```\\nwith q1 as (\\nselect *, \\n    lag(temperature) over(order by recordDate) previous_day_temperature,\\n    lag(recordDate) over(order by recordDate) previous_Date\\nfrom Weather\\n)\\nselect id\\nfrom q1\\nwhere temperature > previous_day_temperature\\nand datediff(recordDate, previous_Date) = 1\\n```\\n##### If you like the solutions, please upvote \\uD83D\\uDD3C\\n##### For any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect\\n    a.id as id\\nfrom\\n    weather a\\njoin weather b \\non datediff(a.recordDate, b.recordDate) = 1\\nand a.Temperature > b.Temperature\\n```\n```\\nwith q1 as (\\nselect *, \\n    lag(temperature) over(order by recordDate) previous_day_temperature,\\n    lag(recordDate) over(order by recordDate) previous_Date\\nfrom Weather\\n)\\nselect id\\nfrom q1\\nwhere temperature > previous_day_temperature\\nand datediff(recordDate, previous_Date) = 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2459482,
                "title": "datediff-function-sql",
                "content": "```\\n# Write your MySQL query statement below\\nselect Weather.id\\nfrom Weather join Weather as a\\nwhere DATEDIFF(Weather.recordDate, a.recordDate) = 1 and Weather.temperature > a.temperature;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect Weather.id\\nfrom Weather join Weather as a\\nwhere DATEDIFF(Weather.recordDate, a.recordDate) = 1 and Weather.temperature > a.temperature;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2412765,
                "title": "using-sub-query",
                "content": "```\\nSelect W1.id\\nfrom Weather W1\\nwhere W1.temperature > \\n            (select W2.temperature from Weather W2\\n             where W2.recordDate = DATE_ADD( W1.recordDate,INTERVAL -1 DAY));\\n```",
                "solutionTags": [],
                "code": "```\\nSelect W1.id\\nfrom Weather W1\\nwhere W1.temperature > \\n            (select W2.temperature from Weather W2\\n             where W2.recordDate = DATE_ADD( W1.recordDate,INTERVAL -1 DAY));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2354879,
                "title": "dekh-lo-bhala-hoga",
                "content": "```\\n# Write your MySQL query statement below\\nselect distinct a.id from\\n    Weather as a,\\n    Weather as b\\n    where \\n    a.temperature > b.temperature and datediff(a.recorddate,b.recorddate)=1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect distinct a.id from\\n    Weather as a,\\n    Weather as b\\n    where \\n    a.temperature > b.temperature and datediff(a.recorddate,b.recorddate)=1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2157907,
                "title": "copy-paste-leetcode",
                "content": "## **ok! you know** \\n### **What to do**\\n\\n![image](https://assets.leetcode.com/users/images/b032b449-c10b-4f5c-81f8-63b2ae013a63_1655367309.3055308.gif)\\n\\n```\\nSELECT\\n    weather.id AS \\'Id\\'\\nFROM\\n    weather\\n        JOIN\\n    weather w ON DATEDIFF(weather.recordDate, w.recordDate) = 1\\n        AND weather.Temperature > w.Temperature\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT\\n    weather.id AS \\'Id\\'\\nFROM\\n    weather\\n        JOIN\\n    weather w ON DATEDIFF(weather.recordDate, w.recordDate) = 1\\n        AND weather.Temperature > w.Temperature\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2070640,
                "title": "easy-and-simple-solution",
                "content": "**197. Rising Temperature**\\n```\\n/* Write your T-SQL query statement below */\\nSELECT w2.id  \\n    FROM weather w1 \\n        JOIN \\n        weather w2\\n            ON datediff(day, w1.recorddate, w2.recorddate) = 1\\n                AND\\n                w2.temperature > w1.temperature;\\n```",
                "solutionTags": [],
                "code": "```\\n/* Write your T-SQL query statement below */\\nSELECT w2.id  \\n    FROM weather w1 \\n        JOIN \\n        weather w2\\n            ON datediff(day, w1.recorddate, w2.recorddate) = 1\\n                AND\\n                w2.temperature > w1.temperature;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2002582,
                "title": "two-simple-mysql-solutions-join-vs-lag",
                "content": "**Using Join**\\n```\\n# Write your MySQL query statement below\\nSELECT a.id\\nFROM Weather a\\nJOIN Weather b\\nWHERE a.temperature > b.temperature AND DATEDIFF(a.recordDate , b.recordDate) = 1;\\n```\\n\\n**Using LAG()**\\n```\\n# Write your MySQL query statement below\\nSELECT id FROM(\\n    SELECT *,\\n    LAG(temperature) OVER(ORDER BY recordDate) AS prevT,\\n    DATEDIFF(recordDate, LAG(recordDate) OVER(ORDER BY recordDate)) AS Delta\\n    FROM Weather) t\\nWHERE Delta = 1 AND temperature>prevT\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT a.id\\nFROM Weather a\\nJOIN Weather b\\nWHERE a.temperature > b.temperature AND DATEDIFF(a.recordDate , b.recordDate) = 1;\\n```\n```\\n# Write your MySQL query statement below\\nSELECT id FROM(\\n    SELECT *,\\n    LAG(temperature) OVER(ORDER BY recordDate) AS prevT,\\n    DATEDIFF(recordDate, LAG(recordDate) OVER(ORDER BY recordDate)) AS Delta\\n    FROM Weather) t\\nWHERE Delta = 1 AND temperature>prevT\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1992297,
                "title": "oracle-very-easy-solution",
                "content": "```\\n/* Write your PL/SQL query statement below */\\nselect w1.id from Weather w1, Weather  w2\\nwhere w1.recordDate-w2.recordDate=1\\nand w1.temperature > w2.temperature\\n```\\n",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nselect w1.id from Weather w1, Weather  w2\\nwhere w1.recordDate-w2.recordDate=1\\nand w1.temperature > w2.temperature\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1992266,
                "title": "rising-temperature-easy-solution",
                "content": "select w1.id from Weather w1\\njoin Weather w2\\non datediff(w1.recordDate,w2.recordDate)=1\\nand w1.temperature>w2.temperature",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "select w1.id from Weather w1\\njoin Weather w2\\non datediff(w1.recordDate,w2.recordDate)=1\\nand w1.temperature>w2.temperature",
                "codeTag": "Unknown"
            },
            {
                "id": 1975985,
                "title": "mysql-solution-using-inner-join",
                "content": "```\\nSELECT w1.Id\\nFROM Weather w1\\nINNER JOIN Weather w2\\nON TO_DAYS(w1.recordDate) = TO_DAYS(w2.recordDate) + 1\\nWHERE w1.Temperature > w2.Temperature\\n```\\n\\n![image](https://assets.leetcode.com/users/images/3ce3cbb7-07df-40af-9a80-ad5292bc202d_1650737075.1208518.png)\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT w1.Id\\nFROM Weather w1\\nINNER JOIN Weather w2\\nON TO_DAYS(w1.recordDate) = TO_DAYS(w2.recordDate) + 1\\nWHERE w1.Temperature > w2.Temperature\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1940792,
                "title": "accepted-solution-for-mysql",
                "content": "```sql\\nSELECT w1.Id FROM Weather w1\\nJOIN weather w2 ON w2.recorddate = date_sub(w1.recorddate, interval 1 day)\\nWHERE w1.temperature > w2.temperature\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```sql\\nSELECT w1.Id FROM Weather w1\\nJOIN weather w2 ON w2.recorddate = date_sub(w1.recorddate, interval 1 day)\\nWHERE w1.temperature > w2.temperature\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1924180,
                "title": "mysql-date-add-vs-plus-doubt",
                "content": "Does anybody know why this is accepted\\n```\\nselect w2.id as id from \\nweather w1 inner join weather w2\\non DATE_ADD(w1.recordDate, INTERVAL 1 DAY)  = w2.recordDate\\nwhere w2.temperature > w1.temperature;\\n```\\nWhile this is not accepted?\\n``` \\nselect w2.id as id from \\nweather w1 inner join weather w2\\non w1.recordDate + 1 = w2.recordDate\\nwhere w2.temperature > w1.temperature;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect w2.id as id from \\nweather w1 inner join weather w2\\non DATE_ADD(w1.recordDate, INTERVAL 1 DAY)  = w2.recordDate\\nwhere w2.temperature > w1.temperature;\\n```\n``` \\nselect w2.id as id from \\nweather w1 inner join weather w2\\non w1.recordDate + 1 = w2.recordDate\\nwhere w2.temperature > w1.temperature;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1756684,
                "title": "mssql-simple-solution",
                "content": "```\\nselect a.id\\n\\nfrom Weather a,\\nWeather b\\n\\nwhere DATEADD(day, -1, a.recordDate) = b.recordDate\\nand a.temperature > b.temperature\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server"
                ],
                "code": "```\\nselect a.id\\n\\nfrom Weather a,\\nWeather b\\n\\nwhere DATEADD(day, -1, a.recordDate) = b.recordDate\\nand a.temperature > b.temperature\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1670397,
                "title": "easy-mysql-solution-faster-than-98-3-of-submissions",
                "content": "```\\nselect a.id \\nfrom weather a \\nleft join weather b\\non a.recordDate = date_add(b.recordDate,interval 1 day) \\nwhere a.temperature > b.temperature \\n```",
                "solutionTags": [],
                "code": "```\\nselect a.id \\nfrom weather a \\nleft join weather b\\non a.recordDate = date_add(b.recordDate,interval 1 day) \\nwhere a.temperature > b.temperature \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1603462,
                "title": "efficient-solution-using-self-join-and-where-clauses",
                "content": "```\\nSELECT\\n    W1.id\\nFROM\\n    Weather W1, Weather W2\\nWHERE\\n    W1.recordDate = W2.recordDate + INTERVAL 1 DAY\\n    AND\\n    W1.temperature > W2.temperature\\n;\\n    \\n```",
                "solutionTags": [],
                "code": "```\\nSELECT\\n    W1.id\\nFROM\\n    Weather W1, Weather W2\\nWHERE\\n    W1.recordDate = W2.recordDate + INTERVAL 1 DAY\\n    AND\\n    W1.temperature > W2.temperature\\n;\\n    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1499808,
                "title": "89-faster-mysql",
                "content": "```\\nselect\\n    W1.id\\nfrom\\n    Weather W1\\ninner join\\n    Weather W2\\non W1.Temperature > W2.Temperature and DATE(W1.RecordDate) = DATE(W2.RecordDate + INTERVAL 1 DAY)\\n```\\n",
                "solutionTags": [],
                "code": "```\\nselect\\n    W1.id\\nfrom\\n    Weather W1\\ninner join\\n    Weather W2\\non W1.Temperature > W2.Temperature and DATE(W1.RecordDate) = DATE(W2.RecordDate + INTERVAL 1 DAY)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1410233,
                "title": "subquery-with-datediff",
                "content": "```\\nSELECT id \\nFROM Weather w1\\nWHERE Temperature > (\\n    SELECT Temperature \\n    FROM Weather w2\\n    WHERE DATEDIFF(w1.recordDate, w2.recordDate) = 1\\n\\t)\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT id \\nFROM Weather w1\\nWHERE Temperature > (\\n    SELECT Temperature \\n    FROM Weather w2\\n    WHERE DATEDIFF(w1.recordDate, w2.recordDate) = 1\\n\\t)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1387867,
                "title": "extremely-fast-solution-no-joins-using-lag-cte",
                "content": "```\\nWITH TEMP AS(\\nSELECT\\n    id, \\n    recordDate, \\n    LAG(recordDate) OVER(ORDER BY recordDate) \"recordDate2\", \\n    Temperature, \\n\\tLAG(Temperature) OVER(ORDER BY recordDate) \"Temperature2\"\\nFROM\\n    Weather\\n)\\n\\nSELECT id\\nFROM TEMP \\nWHERE \\n    (Temperature IS NOT NULL) AND \\n    (Temperature > Temperature2) AND \\n    (DATEDIFF(recordDate,recordDate2)) = 1\\n```",
                "solutionTags": [],
                "code": "```\\nWITH TEMP AS(\\nSELECT\\n    id, \\n    recordDate, \\n    LAG(recordDate) OVER(ORDER BY recordDate) \"recordDate2\", \\n    Temperature, \\n\\tLAG(Temperature) OVER(ORDER BY recordDate) \"Temperature2\"\\nFROM\\n    Weather\\n)\\n\\nSELECT id\\nFROM TEMP \\nWHERE \\n    (Temperature IS NOT NULL) AND \\n    (Temperature > Temperature2) AND \\n    (DATEDIFF(recordDate,recordDate2)) = 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1375759,
                "title": "cross-join-mysql-simple-solution",
                "content": "SELECT \\n    DISTINCT w2.id\\nFROM \\n    Weather w1 JOIN Weather w2\\n    ON w1.recordDate <> w2.recordDate\\nWHERE \\n    DATEDIFF(w2.recordDate,w1.recordDate) = 1\\n    AND \\n    w2.Temperature > w1.Temperature",
                "solutionTags": [],
                "code": "SELECT \\n    DISTINCT w2.id\\nFROM \\n    Weather w1 JOIN Weather w2\\n    ON w1.recordDate <> w2.recordDate\\nWHERE \\n    DATEDIFF(w2.recordDate,w1.recordDate) = 1\\n    AND \\n    w2.Temperature > w1.Temperature",
                "codeTag": "Unknown"
            },
            {
                "id": 1361768,
                "title": "faster-than-91-06-296ms-using-lag-window-function",
                "content": "```\\nWITH cte as (\\n    select id, \\n    temperature,\\n    recordDate,\\n    lag(temperature) OVER (ORDER BY recordDate) as \"prev_temp\",\\n    lag(recordDate) OVER (ORDER BY recordDate) as \"prev_date\"\\n    FROM Weather\\n)\\nSELECT id from cte\\nWHERE temperature > prev_temp\\nAND DATEDIFF(recordDate, prev_date) = 1\\n```",
                "solutionTags": [],
                "code": "```\\nWITH cte as (\\n    select id, \\n    temperature,\\n    recordDate,\\n    lag(temperature) OVER (ORDER BY recordDate) as \"prev_temp\",\\n    lag(recordDate) OVER (ORDER BY recordDate) as \"prev_date\"\\n    FROM Weather\\n)\\nSELECT id from cte\\nWHERE temperature > prev_temp\\nAND DATEDIFF(recordDate, prev_date) = 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1177152,
                "title": "easy-to-understand",
                "content": "SELECT a.id as Id\\nFROM weather a , weather b\\nWHERE DATEDIFF(a.recordDate , b.recordDate)= 1 // for recognize pervious date \\nAND a.temperature > b.temperature;    // compare temperature between perious two dates",
                "solutionTags": [],
                "code": "SELECT a.id as Id\\nFROM weather a , weather b\\nWHERE DATEDIFF(a.recordDate , b.recordDate)= 1 // for recognize pervious date \\nAND a.temperature > b.temperature;    // compare temperature between perious two dates",
                "codeTag": "Unknown"
            },
            {
                "id": 1165750,
                "title": "mysql-using-cte-and-lag",
                "content": "```\\nwith cte as \\n            (\\n            select  id,\\n                    datediff(recordDate, LAG(recordDate, 1) over(order by recordDate)) day_diff,\\n                    temperature - LAG(Temperature) over(order by recordDate) temp_diff\\n            from weather\\n            )\\nselect id \\nfrom cte\\nwhere day_diff = 1 \\nand  temp_diff > 0\\n\\n```",
                "solutionTags": [],
                "code": "```\\nwith cte as \\n            (\\n            select  id,\\n                    datediff(recordDate, LAG(recordDate, 1) over(order by recordDate)) day_diff,\\n                    temperature - LAG(Temperature) over(order by recordDate) temp_diff\\n            from weather\\n            )\\nselect id \\nfrom cte\\nwhere day_diff = 1 \\nand  temp_diff > 0\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1095133,
                "title": "e197-rising-temperature",
                "content": "```\\nSELECT w1.id FROM Weather w1, Weather w2\\nWHERE w1.Temperature > w2.Temperature \\nAND TO_DAYS(w1.recordDate) - TO_DAYS(w2.recordDate) = 1\\n```\\n```\\nSELECT w1.id FROM Weather w1, Weather w2\\nWHERE w1.Temperature > w2.Temperature \\nAND DATEDIFF(w1.recordDate, w2.recordDate) = 1\\n```\\n```\\nSELECT w1.id FROM Weather w1, Weather w2\\nWHERE w1.Temperature > w2.Temperature \\nAND SUBDATE(w1.recordDate, 1) = w2.recordDate\\n```\\n```\\nSELECT w1.id FROM Weather w1 JOIN Weather w2\\nON SUBDATE(w1.recordDate, 1) = w2.recordDate\\nWHERE w1.Temperature > w2.Temperature \\n```",
                "solutionTags": [],
                "code": "```\\nSELECT w1.id FROM Weather w1, Weather w2\\nWHERE w1.Temperature > w2.Temperature \\nAND TO_DAYS(w1.recordDate) - TO_DAYS(w2.recordDate) = 1\\n```\n```\\nSELECT w1.id FROM Weather w1, Weather w2\\nWHERE w1.Temperature > w2.Temperature \\nAND DATEDIFF(w1.recordDate, w2.recordDate) = 1\\n```\n```\\nSELECT w1.id FROM Weather w1, Weather w2\\nWHERE w1.Temperature > w2.Temperature \\nAND SUBDATE(w1.recordDate, 1) = w2.recordDate\\n```\n```\\nSELECT w1.id FROM Weather w1 JOIN Weather w2\\nON SUBDATE(w1.recordDate, 1) = w2.recordDate\\nWHERE w1.Temperature > w2.Temperature \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1058654,
                "title": "lag-function-datediff-82-75-faster",
                "content": "```\\nWITH Weather_Diff AS(\\n    SELECT id, \\n    Temperature  - LAG(Temperature) OVER(ORDER BY recordDate) temp_diff ,\\n    DATEDIFF(recordDate , LAG(recordDate) OVER (ORDER BY recordDate)) date_diff   \\n    FROM Weather)\\n\\nSELECT id\\nFROM Weather_Diff\\nWHERE temp_diff > 0 and date_diff = 1;\\n```\\n",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nWITH Weather_Diff AS(\\n    SELECT id, \\n    Temperature  - LAG(Temperature) OVER(ORDER BY recordDate) temp_diff ,\\n    DATEDIFF(recordDate , LAG(recordDate) OVER (ORDER BY recordDate)) date_diff   \\n    FROM Weather)\\n\\nSELECT id\\nFROM Weather_Diff\\nWHERE temp_diff > 0 and date_diff = 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1024840,
                "title": "datediff-and-lag",
                "content": "```\\n# Write your MySQL query statement below\\nWITH tab1 AS\\n    (SELECT\\n        *,\\n        temperature- LAG(temperature) OVER (ORDER BY recordDate) AS temp_diff,\\n        DATEDIFF(recordDate, LAG(recordDate) OVER (ORDER BY recordDate)) AS date_diff\\n    FROM\\n        weather)\\n        \\n\\nSELECT\\n    id\\nFROM\\n    tab1\\nWHERE\\n    temp_diff > 0 AND \\n    date_diff = 1\\n\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nWITH tab1 AS\\n    (SELECT\\n        *,\\n        temperature- LAG(temperature) OVER (ORDER BY recordDate) AS temp_diff,\\n        DATEDIFF(recordDate, LAG(recordDate) OVER (ORDER BY recordDate)) AS date_diff\\n    FROM\\n        weather)\\n        \\n\\nSELECT\\n    id\\nFROM\\n    tab1\\nWHERE\\n    temp_diff > 0 AND \\n    date_diff = 1\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 882134,
                "title": "just-another-approach-still-beats-99",
                "content": "Not the easiest way ofc but it is interesting how fast it is. Decided to share\\n\\n```\\nselect b.id from (\\n    select row_number() over(order by recordDate) i, Id, Temperature, recordDate\\n    from weather\\n\\t) a,\\n    (select row_number() over(order by recordDate) i, Id, Temperature, recordDate\\n    from weather\\n\\t) b\\nwhere a.i + 1 = b.i\\nand a.Temperature < b.Temperature\\nand date(a.recordDate) + interval 1 day = date(b.recordDate);\\n```",
                "solutionTags": [],
                "code": "```\\nselect b.id from (\\n    select row_number() over(order by recordDate) i, Id, Temperature, recordDate\\n    from weather\\n\\t) a,\\n    (select row_number() over(order by recordDate) i, Id, Temperature, recordDate\\n    from weather\\n\\t) b\\nwhere a.i + 1 = b.i\\nand a.Temperature < b.Temperature\\nand date(a.recordDate) + interval 1 day = date(b.recordDate);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 869624,
                "title": "still-don-t-get-why-i-m-wrong-can-anyone-help-mysql",
                "content": "SELECT id AS Id\\nFROM (SELECT * ,\\n             LAG(Temperature, 1) OVER (ORDER BY recordDate) as pre\\n      FROM Weather) table1\\nWHERE table1.Temperature > table1.pre",
                "solutionTags": [],
                "code": "SELECT id AS Id\\nFROM (SELECT * ,\\n             LAG(Temperature, 1) OVER (ORDER BY recordDate) as pre\\n      FROM Weather) table1\\nWHERE table1.Temperature > table1.pre",
                "codeTag": "Unknown"
            },
            {
                "id": 863383,
                "title": "use-inner-join-to-date",
                "content": "```\\n/* Write your PL/SQL query statement below */\\nSELECT W1.Id \\nFROM Weather W1\\nINNER JOIN Weather W2 ON W1.RecordDate -1= W2.RecordDate\\nWHERE W1.Temperature > W2.Temperature;\\n```\\n\\u8981\\u6BD4\\u8F83\\u4E24\\u4E2A\\u6E29\\u5EA6\\u8FD8\\u662F\\u4F7F\\u7528\\u5185\\u8FDE\\u63A5\\uFF0C\\u67E5\\u4E86\\u7F51\\u7EDC\\u624D\\u77E5\\u9053\\u5185\\u8FDE\\u63A5\\u4E5F\\u53EF\\u4EE5\\u7528\\u8BA1\\u7B97\\u7B26\\u7684\\uFF0C\\u8FD9\\u4E2A\\u7EA0\\u7ED3\\u4E86\\u4E00\\u4E0B\\uFF0C\\u975E\\u65E5\\u671F\\u7C7B\\u578Bdate\\u7684\\u683C\\u5F0F\\u8981\\u6BD4\\u8F83\\u8981\\u4F7F\\u7528to_date\\u51FD\\u6570\\uFF0C\\u5E76\\u4E14\\u540E\\u9762\\u65E5\\u671F\\u683C\\u5F0F\\u8BB0\\u5F97\\u662F**\\u5355\\u5F15\\u53F7**\\uFF0C\\u4F7F\\u7528\\u53CC\\u5F15\\u53F7\\u4F1A\\u62A5\\u9519\\n```\\nORA-00904: \"YYYY-MM-DD\": invalid identifier\\n```\\n\\u5982\\u679C\\u8FD9\\u9053\\u9898\\u662F\\u5B57\\u7B26\\u4E32\\u683C\\u5F0F\\u7684\\u65E5\\u671F\\uFF0C\\u8FD8\\u8981\\u5148to_date\\u8F6C\\u6362\\n```\\n/* Write your PL/SQL query statement below \\uFF0C\\u5047\\u8BBERecoreDate\\u5B57\\u6BB5\\u662F\\u5B57\\u7B26\\u4E32\\u683C\\u5F0F\\uFF0C\\u5176\\u5B9E\\u7528\\u4E86TO_DATE\\u4E4B\\u540E\\u6548\\u7387\\u53CD\\u800C\\u9AD8\\u4E86*/\\nSELECT W1.Id \\nFROM Weather W1\\nINNER JOIN Weather W2 ON TO_DATE(W1.RecordDate,\\'YYYY-MM-DD\\') -1= TO_DATE(W2.RecordDate,\\'YYYY-MM-DD\\')\\nWHERE W1.Temperature > W2.Temperature;\\n```\\n\\u8FD8\\u6709\\u8FD9\\u9053\\u9898\\u6709\\u4E2A\\u5C0F\\u5751\\uFF0C\\u6D4B\\u8BD5\\u9636\\u6BB5\\u8F93\\u5165\\u7684\\u6570\\u636E\\u8DDF\\u63D0\\u4EA4\\u9636\\u6BB5\\u8F93\\u5165\\u7684\\u6570\\u636E\\u662F\\u4E0D\\u4E00\\u6837\\u7684\\uFF0C\\u6240\\u4EE5\\u7528ID\\u5B57\\u6BB5\\u53D6\\u5DE7\\u662F\\u4E0D\\u884C\\u4E86\\uFF0C\\u9644\\u4E0A\\u6211\\u4E00\\u5F00\\u59CB\\u53D6\\u5DE7\\u5728\\u6D4B\\u8BD5\\u9636\\u6BB5\\u8DD1\\u6210\\u529F\\u4F46\\u63D0\\u4EA4\\u5931\\u8D25\\u7684\\u4EE3\\u7801\\n```\\n/* Write your PL/SQL query statement below */\\nSELECT W1.id \\nFROM Weather W1\\nINNER JOIN Weather W2 ON W2.id +1 = W1.id\\nWHERE W1.Temperature > W2.Temperature;\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nSELECT W1.Id \\nFROM Weather W1\\nINNER JOIN Weather W2 ON W1.RecordDate -1= W2.RecordDate\\nWHERE W1.Temperature > W2.Temperature;\\n```\n```\\nORA-00904: \"YYYY-MM-DD\": invalid identifier\\n```\n```\\n/* Write your PL/SQL query statement below \\uFF0C\\u5047\\u8BBERecoreDate\\u5B57\\u6BB5\\u662F\\u5B57\\u7B26\\u4E32\\u683C\\u5F0F\\uFF0C\\u5176\\u5B9E\\u7528\\u4E86TO_DATE\\u4E4B\\u540E\\u6548\\u7387\\u53CD\\u800C\\u9AD8\\u4E86*/\\nSELECT W1.Id \\nFROM Weather W1\\nINNER JOIN Weather W2 ON TO_DATE(W1.RecordDate,\\'YYYY-MM-DD\\') -1= TO_DATE(W2.RecordDate,\\'YYYY-MM-DD\\')\\nWHERE W1.Temperature > W2.Temperature;\\n```\n```\\n/* Write your PL/SQL query statement below */\\nSELECT W1.id \\nFROM Weather W1\\nINNER JOIN Weather W2 ON W2.id +1 = W1.id\\nWHERE W1.Temperature > W2.Temperature;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 847664,
                "title": "oracle-99-9",
                "content": "```\\nselect b.id\\nfrom Weather a join Weather b on\\na.recordDate=b.recordDate-1\\nwhere b.Temperature>a.Temperature\\n```",
                "solutionTags": [],
                "code": "```\\nselect b.id\\nfrom Weather a join Weather b on\\na.recordDate=b.recordDate-1\\nwhere b.Temperature>a.Temperature\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 822793,
                "title": "mysql-faster-easier",
                "content": "```\\nSELECT temp.id\\nFROM(\\n    SELECT w1.id, (w1.Temperature - w2.Temperature) as diff \\n    FROM Weather w1\\n    JOIN Weather w2\\n    ON DATEDIFF(w1.recordDate, w2.recordDate)=1) temp\\nWHERE temp.diff > 0;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT temp.id\\nFROM(\\n    SELECT w1.id, (w1.Temperature - w2.Temperature) as diff \\n    FROM Weather w1\\n    JOIN Weather w2\\n    ON DATEDIFF(w1.recordDate, w2.recordDate)=1) temp\\nWHERE temp.diff > 0;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 705734,
                "title": "mysql-uses-inferred-join-and-to-days",
                "content": "```\\n# Write your MySQL query statement below\\n\\nSELECT higher.Id \\nFROM Weather higher, Weather lower\\nWHERE higher.Temperature > lower.Temperature \\nAND to_days(higher.RecordDate)-to_days(lower.RecordDate)=1;\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSELECT higher.Id \\nFROM Weather higher, Weather lower\\nWHERE higher.Temperature > lower.Temperature \\nAND to_days(higher.RecordDate)-to_days(lower.RecordDate)=1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 566700,
                "title": "very-simple-solution-in-mysql",
                "content": "```\\nSELECT w2.Id FROM Weather w1, Weather w2\\nWHERE DATEDIFF(w2.RecordDate, w1.RecordDate) = 1\\nAND w2.Temperature >  w1.Temperature\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT w2.Id FROM Weather w1, Weather w2\\nWHERE DATEDIFF(w2.RecordDate, w1.RecordDate) = 1\\nAND w2.Temperature >  w1.Temperature\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 501996,
                "title": "easy-mssql",
                "content": "SELECT\\nw1.Id \\nFROM Weather w1\\nINNER JOIN  Weather w2\\nON w1. RecordDate = w2. RecordDate+1\\nWHERE w1.Temperature > w2. Temperature",
                "solutionTags": [],
                "code": "SELECT\\nw1.Id \\nFROM Weather w1\\nINNER JOIN  Weather w2\\nON w1. RecordDate = w2. RecordDate+1\\nWHERE w1.Temperature > w2. Temperature",
                "codeTag": "Unknown"
            },
            {
                "id": 429095,
                "title": "sqlserver",
                "content": "select a.id as Id\\nfrom Weather a , Weather b \\nwhere datediff(day,  b.RecordDate, a.RecordDate) = 1\\nand a.Temperature > b.Temperature",
                "solutionTags": [],
                "code": "select a.id as Id\\nfrom Weather a , Weather b \\nwhere datediff(day,  b.RecordDate, a.RecordDate) = 1\\nand a.Temperature > b.Temperature",
                "codeTag": "Unknown"
            },
            {
                "id": 359006,
                "title": "oracle-solution-easy-to-unserstand",
                "content": "```\\nselect w.id id\\nfrom weather w\\njoin \\nweather k\\non w.recorddate - 1 = k.recorddate \\nwhere w.temperature > k.temperature;\\n```",
                "solutionTags": [],
                "code": "```\\nselect w.id id\\nfrom weather w\\njoin \\nweather k\\non w.recorddate - 1 = k.recorddate \\nwhere w.temperature > k.temperature;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 349638,
                "title": "mssql-window-functions-beats-97",
                "content": "```\\n;WITH Diffs AS\\n(\\n    SELECT \\n        Id,\\n        RecordDate,\\n        LAG(RecordDate) OVER (ORDER BY RecordDate ASC) AS PrevDate,\\n        Temperature - LAG(Temperature) OVER (ORDER BY RecordDate ASC) AS Diff\\n    FROM Weather\\n)\\nSELECT Id FROM Diffs\\nWHERE Diff > 0 AND DATEDIFF(day, PrevDate, RecordDate) = 1\\nORDER BY Id ASC\\n```",
                "solutionTags": [],
                "code": "```\\n;WITH Diffs AS\\n(\\n    SELECT \\n        Id,\\n        RecordDate,\\n        LAG(RecordDate) OVER (ORDER BY RecordDate ASC) AS PrevDate,\\n        Temperature - LAG(Temperature) OVER (ORDER BY RecordDate ASC) AS Diff\\n    FROM Weather\\n)\\nSELECT Id FROM Diffs\\nWHERE Diff > 0 AND DATEDIFF(day, PrevDate, RecordDate) = 1\\nORDER BY Id ASC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 340373,
                "title": "using-lag-function",
                "content": "```\\nselect id from (\\nselect id,RecordDate,datediff(day,RecordDate,lag(RecordDate,1,RecordDate)over(order by RecordDate )) as date_dif,\\ncase when Temperature > lag(Temperature,1,Temperature)over(order by RecordDate) then 1 else 0 end as result\\nfrom weather) a\\nwhere result = 1 and date_dif=-1\\n\\n```",
                "solutionTags": [],
                "code": "```\\nselect id from (\\nselect id,RecordDate,datediff(day,RecordDate,lag(RecordDate,1,RecordDate)over(order by RecordDate )) as date_dif,\\ncase when Temperature > lag(Temperature,1,Temperature)over(order by RecordDate) then 1 else 0 end as result\\nfrom weather) a\\nwhere result = 1 and date_dif=-1\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 290178,
                "title": "mssql-solution",
                "content": "select b.Id from weather a\\nleft join weather b\\non a.RecordDate=dateadd(day,-1,b.RecordDate)\\nwhere a.Temperature<b.Temperature",
                "solutionTags": [],
                "code": "select b.Id from weather a\\nleft join weather b\\non a.RecordDate=dateadd(day,-1,b.RecordDate)\\nwhere a.Temperature<b.Temperature",
                "codeTag": "Unknown"
            },
            {
                "id": 198459,
                "title": "what-is-wrong-with-this-query-i-could-not-pass-the-14th-test-case",
                "content": "select w1.Id\\nfrom Weather w1 join Weather w2\\non w1.RecordDate = w2.RecordDate+1\\nwhere w1.Temperature > w2.Temperature;",
                "solutionTags": [],
                "code": "select w1.Id\\nfrom Weather w1 join Weather w2\\non w1.RecordDate = w2.RecordDate+1\\nwhere w1.Temperature > w2.Temperature;",
                "codeTag": "Unknown"
            },
            {
                "id": 173071,
                "title": "ms-server-solution-using-dateadd-function",
                "content": "```\\nSELECT w1.Id FROM Weather w1\\nJOIN Weather w2 \\nON w2.Temperature < w1.Temperature AND w2.RecordDate = DATEADD(day, -1, w1.RecordDate)\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT w1.Id FROM Weather w1\\nJOIN Weather w2 \\nON w2.Temperature < w1.Temperature AND w2.RecordDate = DATEADD(day, -1, w1.RecordDate)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 167225,
                "title": "same-output-why-it-shows-wrong-answer",
                "content": "Select a.Id\\nFrom Weather a, Weather b\\nWhere a.RecordDate-b.RecordDate = 1 and a.Temperature > b.Temperature;",
                "solutionTags": [],
                "code": "Select a.Id\\nFrom Weather a, Weather b\\nWhere a.RecordDate-b.RecordDate = 1 and a.Temperature > b.Temperature;",
                "codeTag": "Unknown"
            },
            {
                "id": 55640,
                "title": "using-two-variables-1000ms",
                "content": "    # Write your MySQL query statement below\\n    select Id \\n    from(\\n            select \\n                w.Id, \\n                if(@prev<Temperature && DATEDIFF(@prevD,Date)=-1,1,0) as increased,\\n                @prev := w.Temperature, \\n                @prevD :=w.Date\\n            from \\n                (select * from Weather order by Date asc) w, # order the dates\\n                (select @prev := 10000) p, \\n                (select @prevD := null) d\\n        ) a\\n    where \\n    increased = 1;",
                "solutionTags": [],
                "code": "    # Write your MySQL query statement below\\n    select Id \\n    from(\\n            select \\n                w.Id, \\n                if(@prev<Temperature && DATEDIFF(@prevD,Date)=-1,1,0) as increased,\\n                @prev := w.Temperature, \\n                @prevD :=w.Date\\n            from \\n                (select * from Weather order by Date asc) w, # order the dates\\n                (select @prev := 10000) p, \\n                (select @prevD := null) d\\n        ) a\\n    where \\n    increased = 1;",
                "codeTag": "Unknown"
            },
            {
                "id": 3782741,
                "title": "easy-explanation",
                "content": "**We have to perform inner join since we comparing 2 values in one table**\\n# How do we get the second value ?\\nTo get the second value we use DATE_ADD Function and save it in  w1.recordDate\\n# WHATS THIS FUNCTION\\nThe DATE_ADD() function adds a time/date interval to a date and then returns the date.\\n\\nSyntax\\nDATE_ADD(date, INTERVAL value addunit)\\nIn our case we need one day\\n\\nFinally , we compare and get the result based on ther where condition\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT w1.id FROM Weather w1\\nJOIN Weather w2\\nON w1.recordDate = DATE_ADD(w2.recordDate, INTERVAL 1 DAY)\\nWHERE w1.temperature > w2.temperature\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT w1.id FROM Weather w1\\nJOIN Weather w2\\nON w1.recordDate = DATE_ADD(w2.recordDate, INTERVAL 1 DAY)\\nWHERE w1.temperature > w2.temperature\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3666772,
                "title": "correlated-queries-sql-nested-queries",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT w1.id\\nFROM weather  w1\\nWHERE exists (\\n  SELECT w2.id \\n  FROM weather  w2\\n  WHERE DATEDIFF(w1.recordDate, w2.recordDate) = 1 AND w1.temperature > w2.temperature\\n);\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT w1.id\\nFROM weather  w1\\nWHERE exists (\\n  SELECT w2.id \\n  FROM weather  w2\\n  WHERE DATEDIFF(w1.recordDate, w2.recordDate) = 1 AND w1.temperature > w2.temperature\\n);\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3589091,
                "title": "easy-solution-with-line-by-line-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- The query must retrieve the id of the date when the temperature was more than the previous date.\\n- A **self-join is done on Weather table with aliases W1 and W2**, with W1 chosen as the table to retrieve the id.\\n- For this, we use the **DATEDIFF() function** in the Where Clause such that the difference between the date is 1, meaning they are **consecutive dates**.\\n- Since we retrieve id from W1, we must take care to write** W1 in the first argument of DATEDIFF()**. The correct code with retrieval of id from W2 is commented below in the solution.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. In the SELECT statement, we retrieve the id from the chosen alias of the table, here W1. If you retrieve id from W2, consider the commented code.\\n2. In the FROM statement, we perform a **JOIN operation between the two aliases of Weather table namely W1 and W2**.\\n3. In the WHERE clause, we use the **DATEDIFF() function** such that the difference between the date is 1, meaning they are consecutive dates. Here, we take **W1 as first argument to the DATEDIFF() function**.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT W1.id\\nFROM Weather as W1 JOIN Weather as W2\\nWHERE DATEDIFF(W1.RecordDate, W2.RecordDate) = 1 AND W1.Temperature > W2.Temperature;\\n\\n# SELECT W2.id\\n# FROM Weather as W1 JOIN Weather as W2\\n# WHERE DATEDIFF(W2.RecordDate, W1.RecordDate) = 1 AND W2.Temperature > W1.Temperature;\\n```\\n# Note \\nPlease upvote if you find my solution helpful. If you have any doubts, suggestion or want to discuss any solution, comment it. If you wish to discuss other related topics, feel free to message me on LinkedIn, https://leetcode.com/prathams29/",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT W1.id\\nFROM Weather as W1 JOIN Weather as W2\\nWHERE DATEDIFF(W1.RecordDate, W2.RecordDate) = 1 AND W1.Temperature > W2.Temperature;\\n\\n# SELECT W2.id\\n# FROM Weather as W1 JOIN Weather as W2\\n# WHERE DATEDIFF(W2.RecordDate, W1.RecordDate) = 1 AND W2.Temperature > W1.Temperature;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3555500,
                "title": "inner-join-on-basis-of-date-diff-and-temperature",
                "content": "# MySql\\n```\\nselect w1.id  from Weather w1 inner join Weather w2 on datediff(w1.recordDate,w2.recordDate)=1 and w1.temperature >w2.temperature;\\n```\\n# Oracle\\n```\\nselect w1.id  from Weather w1 inner join Weather w2 on w1.recordDate-w2.recordDate=1 and w1.temperature >w2.temperature;\\n```",
                "solutionTags": [
                    "MySQL",
                    "Oracle"
                ],
                "code": "```\\nselect w1.id  from Weather w1 inner join Weather w2 on datediff(w1.recordDate,w2.recordDate)=1 and w1.temperature >w2.temperature;\\n```\n```\\nselect w1.id  from Weather w1 inner join Weather w2 on w1.recordDate-w2.recordDate=1 and w1.temperature >w2.temperature;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3550973,
                "title": "easy-sql-code",
                "content": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT wt1.id FROM Weather AS wt1 , Weather AS wt2 \\nWHERE wt1.temperature> wt2.temperature AND TO_DAYS(wt1.recordDate)-TO_DAYS(wt2.recordDate)=1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT wt1.id FROM Weather AS wt1 , Weather AS wt2 \\nWHERE wt1.temperature> wt2.temperature AND TO_DAYS(wt1.recordDate)-TO_DAYS(wt2.recordDate)=1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3161723,
                "title": "mysql-date-add",
                "content": "```\\n# Write your MySQL query statement below\\nSELECT DISTINCT w1.id as Id FROM Weather w1\\nINNER JOIN Weather w2 \\nON w1.temperature > w2.temperature \\nAND w1.recordDate = DATE_ADD(w2.recordDate, INTERVAL 1 DAY);\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT DISTINCT w1.id as Id FROM Weather w1\\nINNER JOIN Weather w2 \\nON w1.temperature > w2.temperature \\nAND w1.recordDate = DATE_ADD(w2.recordDate, INTERVAL 1 DAY);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3085850,
                "title": "simple-query-rising-temperature",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect a.id from Weather a, Weather b where a.temperature>b.temperature and datediff(a.recorddate ,b.recorddate)=1  order by id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect a.id from Weather a, Weather b where a.temperature>b.temperature and datediff(a.recorddate ,b.recorddate)=1  order by id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3055912,
                "title": "easy-solution-oracle",
                "content": "\\n\\n# Code\\n```\\n\\nselect distinct id\\nfrom Weather\\nwhere prior temperature < temperature\\nconnect by prior recordDate +1 = recordDate\\n\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n\\nselect distinct id\\nfrom Weather\\nwhere prior temperature < temperature\\nconnect by prior recordDate +1 = recordDate\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3043381,
                "title": "mysql-3-different-solution-date-add-and-datediff-function",
                "content": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect w2.id\\nfrom Weather w1, Weather w2\\nwhere w1.recordDate = date_add(w2.recordDate, interval -1 day)\\nand w1.temperature < w2.temperature\\n\\ntake more time  \\nSELECT w1.id \\nFROM Weather w1 JOIN Weather w2\\nON DATEDIFF(w1.recordDate, w2.recordDate) = 1\\nAND w1.temperature > w2.temperature;\\n\\n\\nselect x.id \\nfrom Weather x,Weather y \\nwhere x.temperature>y.temperature and datediff(x.recordDate,y.recordDate)=1;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect w2.id\\nfrom Weather w1, Weather w2\\nwhere w1.recordDate = date_add(w2.recordDate, interval -1 day)\\nand w1.temperature < w2.temperature\\n\\ntake more time  \\nSELECT w1.id \\nFROM Weather w1 JOIN Weather w2\\nON DATEDIFF(w1.recordDate, w2.recordDate) = 1\\nAND w1.temperature > w2.temperature;\\n\\n\\nselect x.id \\nfrom Weather x,Weather y \\nwhere x.temperature>y.temperature and datediff(x.recordDate,y.recordDate)=1;",
                "codeTag": "Unknown"
            },
            {
                "id": 2917749,
                "title": "oracle-solution-with-window-function-nth-value",
                "content": "```\\n/* Write your PL/SQL query statement below */\\nwith wind_tmp as (\\n    select t.id, t.recordDate, t.temperature, NTH_VALUE(t.temperature, 2) from last over (order by t.recordDate range between 1 preceding and current row) as prev_temp\\n        from Weather t\\n)\\n\\nselect t.id\\n    from wind_tmp t\\n        where t.temperature > t.prev_temp\\n\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nwith wind_tmp as (\\n    select t.id, t.recordDate, t.temperature, NTH_VALUE(t.temperature, 2) from last over (order by t.recordDate range between 1 preceding and current row) as prev_temp\\n        from Weather t\\n)\\n\\nselect t.id\\n    from wind_tmp t\\n        where t.temperature > t.prev_temp\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2915318,
                "title": "solution-using-date-add-on-mysql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nselect w1.id \\nfrom weather w1 join weather w2\\nwhere w1.temperature > w2.temperature \\nand w1.recordDate = DATE_ADD(w2.recordDate, INTERVAL 1 DAY)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect w1.id \\nfrom weather w1 join weather w2\\nwhere w1.temperature > w2.temperature \\nand w1.recordDate = DATE_ADD(w2.recordDate, INTERVAL 1 DAY)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2909289,
                "title": "used-dateadd-to-compare-find-yesterday-s-date",
                "content": "Using DATEADD to compare find yesterdays date\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\n\\nselect w.id from weather w where w.temperature  > (\\n    select temperature from weather where recordDate = DATEADD(day, -1, w.recordDate) and temperature is not null )\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\nselect w.id from weather w where w.temperature  > (\\n    select temperature from weather where recordDate = DATEADD(day, -1, w.recordDate) and temperature is not null )\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2851438,
                "title": "mysql-complex-solution-using-window-functions-and-common-table-expressions",
                "content": "I saw so many people putting out \"simple\" solutions so I thought why not just put a complex one?\\n```\\nWITH cte AS (\\n    SELECT \\n        id, \\n        recordDate,\\n\\t\\tLAG(recordDate) OVER (ORDER BY recordDate) AS prev_date,\\n        temperature, \\n        LAG(temperature) OVER (ORDER BY recordDate) AS prev_temp\\n    FROM Weather\\n)\\nSELECT id \\nFROM cte\\nWHERE \\n    temperature > prev_temp AND\\n    DATEDIFF(recordDate, prev_date) = 1;\\n```\\nSo, Here we are using 2 important concepts of SQL:\\n1. Common Table Expressions or CTEs, and\\n2. LAG() Window Function\\n\\nLet\\'s understand both of them, one by one:\\n* **CTEs:**\\n\\nCommon Table Expressions are used to simplify (quite ironic in this solution though, innit?) complex SQL queries. Now, the question is how does it do it?\\nSo, it basically stores (temporarily only) the result set of a SQL query which we can reference for later use. For eg:\\n```\\n-- The CTE \"name_of_cte\" can be used later, i.e. the result set with field foo can be referenced later in another query as in our solution.\\nWITH name_of_cte AS (\\n\\tSELECT foo FROM bar\\n)\\nSELECT foo FROM name_of_cte;\\n```\\nIt\\'s pretty much just that. Simple, right?\\n\\n* **LAG() Window Function**\\n\\nThe LAG() function allows us to simply (Oh! I said it again) shift the row data for any particular field by an specific offset value, as sorted by a specified column or set of columns.\\nSyntax:\\n`LAG(expression [,offset[,default_value]]) OVER(ORDER BY columns)`\\n\\nSo, in our solution I shifted the recordDate and temperature column as prev_date and prev_temp respectively and refrenced them later (CTE?) to check if:\\n```\\ntemperature > prev_temp AND DATEDIFF(recordDate, prev_date) = 1;\\n```\\n\\nSo, I hope you learned something complex today (ofcourse, if you don\\'t already find this simple). Later!",
                "solutionTags": [],
                "code": "```\\nWITH cte AS (\\n    SELECT \\n        id, \\n        recordDate,\\n\\t\\tLAG(recordDate) OVER (ORDER BY recordDate) AS prev_date,\\n        temperature, \\n        LAG(temperature) OVER (ORDER BY recordDate) AS prev_temp\\n    FROM Weather\\n)\\nSELECT id \\nFROM cte\\nWHERE \\n    temperature > prev_temp AND\\n    DATEDIFF(recordDate, prev_date) = 1;\\n```\n```\\n-- The CTE \"name_of_cte\" can be used later, i.e. the result set with field foo can be referenced later in another query as in our solution.\\nWITH name_of_cte AS (\\n\\tSELECT foo FROM bar\\n)\\nSELECT foo FROM name_of_cte;\\n```\n```\\ntemperature > prev_temp AND DATEDIFF(recordDate, prev_date) = 1;\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1569017,
                "content": [
                    {
                        "username": "frunfola1229",
                        "content": "\\n**SELECT**  w1.Id \\n**FROM**     Weather w1, Weather w2\\n**WHERE**   dateDiff(w1.Date,w2.Date) = 1        **AND**    w1.Temperature > w2.Temperature;"
                    },
                    {
                        "username": "Vipul_Chaudhary_2003",
                        "content": "Okay great.\nNow let's read rules together\n\nDiscussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jargolastik",
                        "content": "[@user8224IM](/user8224IM) self join creates every possible combination of columns so that means that you can just filter out the rows where the current temp is greater than yesterday\\'s"
                    },
                    {
                        "username": "JerryBlank",
                        "content": "[@user8224IM](/user8224IM) They have created 2 copies of the same table w1 and w2 and comparing each and every row. \\nSelecting only the ids for rows where \\nw1.date - w2.date =1 means that w1 is the date of next day to w2 (example: 2nd August - 1st August =1)\\nAND\\nw1.Temperature > w2.Temperature means Temperature on Date w1 is greater than Temperature on Date w2. \\n\\nso that would get Id with higher temperatures compared to its previous dates (yesterday).\\nHope this helps!"
                    },
                    {
                        "username": "user8224IM",
                        "content": "can you explain how/why this works please\\n"
                    },
                    {
                        "username": "chriszeng8",
                        "content": "Why is subtracting 1 directly from Date not working, but subdate(a.Date,1) works?\\n\\nMy code is \\n\\n    select W1.Id\\n    from Weather as W1, Weather as W2\\n    where W1.Date-1 = W2.Date and W1.Temperature> W2.Temperature\\n\\nit only passed 13/14 cases.\\n\\nHowever, when I changed `W1.Date-1` to `sub(W1.Date,1)` in the where clause, it worked. What is fundamental difference?"
                    },
                    {
                        "username": "Lysa123",
                        "content": "[@minhphamduy](/minhphamduy) cho m\\xECnh h\\u1ECFi v\\xEC sao ph\\u1EA3i c\\xF3 ch\\u1EEF subquery \\u1EDF cu\\u1ED1i v?\\n"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "I think you not should do that, use date_add instead\\n# Write your MySQL query statement below\\n\\nselect id\\nfrom (\\n    select w1.id\\n    from weather w1, weather w2\\n    where w1.recordDate= DATE_ADD(w2.recordDate, interval 1 day) and w1.temperature > w2.temperature\\n) subquery"
                    },
                    {
                        "username": "har0101",
                        "content": "date is not int"
                    },
                    {
                        "username": "291831388",
                        "content": "[@michaelniki](/michaelniki)  Thank your for your response, it really helps me."
                    },
                    {
                        "username": "michaelniki",
                        "content": "subtracting 1 does not work for the date at the end of the month or year.\nTake this test case for example:\n\n| id | recordDate | temperature |\n| -- | ---------- | ----------- |\n| 1  | 2014-12-31 | 1           |\n| 2  | 2015-01-01 | 10          |\n| 3  | 2015-01-02 | 25          |\n\nrecordDate of id 2 (2015-01-01) - 1 does not equal to  2014-12-31\n\n```\nselect\n    *\n    , w1.recordDate - w2.recordDate\nfrom\n    weather w1, weather w2\norder by w1.id\n\n```\n\n| id | recordDate | temperature | id | recordDate | temperature | w1.recordDate - w2.recordDate |\n| -- | ---------- | ----------- | -- | ---------- | ----------- | ----------------------------- |\n| 1  | 2014-12-31 | 1           | 1  | 2014-12-31 | 1           | 0                             |\n| 1  | 2014-12-31 | 1           | 2  | 2015-01-01 | 10          | -8870                         |\n| 1  | 2014-12-31 | 1           | 3  | 2015-01-02 | 25          | -8871                         |\n| 2  | 2015-01-01 | 10          | 1  | 2014-12-31 | 1           | 8870                          |\n| 2  | 2015-01-01 | 10          | 2  | 2015-01-01 | 10          | 0                             |\n| 2  | 2015-01-01 | 10          | 3  | 2015-01-02 | 25          | -1                            |\n| 3  | 2015-01-02 | 25          | 1  | 2014-12-31 | 1           | 8871                          |\n| 3  | 2015-01-02 | 25          | 2  | 2015-01-01 | 10          | 1                             |\n| 3  | 2015-01-02 | 25          | 3  | 2015-01-02 | 25          | 0                             |\n"
                    },
                    {
                        "username": "suraj21193",
                        "content": "Its is running successfully but not able to submit!\\nSelect a.id\\nfrom \\n(Select id, temperature, lag(temperature) over(order by recordDate) as lt,\\ncase when temperature>lag(temperature) over(order by recordDate) then \\'High\\'\\nelse \\'Low\\'\\nend as \\'Status\\'\\nfrom Weather) a\\nwhere Status = \\'High\\';"
                    },
                    {
                        "username": "themanutdmaniac",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) the reason is that the test case has 2 dates with a day missing in between."
                    },
                    {
                        "username": "Palash5043",
                        "content": "\nselect x.Id from (\nselect Id,\n       recordDate,\n       temperature as temp,\n    lag(temperature,1) over(order by recordDate asc) as pre_day_temp\n    from weather) x\n    where x.temp>x.pre_day_temp;\n\nI am also facing the similar issue "
                    },
                    {
                        "username": "kashrex",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) test cases are failing because the dates have to be exact previous date. \"2000-12-14 |     |2000-12-16\"  have a date difference of more than 1 day."
                    },
                    {
                        "username": "jingpingyu1127",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) I think this is because that we are finding records with only 1 day difference. The records in the test case is using date with 2 days difference, which should not return anything for the output."
                    },
                    {
                        "username": "avinashkumarjha05",
                        "content": "mine too ... have u understood why the test case failing?\\n"
                    },
                    {
                        "username": "sandeep_kumar_75",
                        "content": "**SELECT a.id\\nFROM Weather a, Weather b\\nWHERE datediff(a.recordDate, b.recordDate) = 1\\nAND a.temperature > b.temperature;**"
                    },
                    {
                        "username": "themanutdmaniac",
                        "content": "Wow, what a solution. GOAT. amazing. all the best sandeep."
                    },
                    {
                        "username": "xudaiyanzi",
                        "content": "Hi everyone, I tried the query below. It works when I run MySQL, but it can not work when it is submitted.  Please help me. Thank you.\\n# Write your MySQL query statement below\\nSELECT y.id\\nFROM Weather x\\nLEFT JOIN Weather y ON x.Id +1 = y.Id\\nWHERE x.Temperature < y.Temperature\\n"
                    },
                    {
                        "username": "cassiellong1113",
                        "content": "date is not ascending sorted, and thus if you do not compare with dates but with ID, you may get wrong answer "
                    },
                    {
                        "username": "Avazbeka_dev",
                        "content": "SELECT a.id\\nFROM Weather as a,Weather as b\\nWHERE a.temperature>b.temperature\\nAND DATEDIFF(a.recordDate,b.recordDate)=1\\n\\nYou must check the datas !"
                    },
                    {
                        "username": "patnanavarun",
                        "content": "you are just checking the id values .But not comparing the dates.\\n"
                    },
                    {
                        "username": "snehanshu17",
                        "content": "with tmp as (\\nselect id ,RecordDate,Temperature,\\nLAG (Temperature,1) OVER (ORDER BY RecordDate) AS prev_Temperature,\\n    LAG (RecordDate,1) OVER (ORDER BY RecordDate) AS prev_RecordDate\\nfrom Weather)\\n\\nselect id  from tmp where Temperature>prev_Temperature and (RecordDate-prev_RecordDate)=1"
                    },
                    {
                        "username": "mr-xed",
                        "content": "Really interesting approach, except it didn\\'t work for me from the get go for some reason, how ever I was able to solve it using `dateDiff(RecordDate, prev_RecordDate)` instead of `(RecordDate-prev_RecordDate)`"
                    },
                    {
                        "username": "XinyiQiu",
                        "content": "WITH yesterday AS (SELECT id,recordDate,temperature,DATE_SUB(recordDate, INTERVAL 1 DAY) AS yesterday\\nFROM Weather)\\n\\nSELECT yesterday.id\\nFROM yesterday LEFT JOIN Weather on yesterday.yesterday = Weather.recordDate\\nWHERE Weather.temperature IS NOT NULL AND yesterday.temperature > Weather.temperature"
                    },
                    {
                        "username": "nasirxia",
                        "content": "the idea is brilliant but why make things complicated? There should be a reasons for doing this."
                    },
                    {
                        "username": "anand_vineet19",
                        "content": "# Write your MySQL query statement below\\nSELECT id\\nFROM\\n(\\nSELECT id, recordDate, temperature AS today_temp, LAG(temperature,1) OVER (ORDER BY recordDate) AS yesterday_temp, LAG(recordDate,1) OVER (ORDER BY recordDate) AS yes_date\\n\\nFROM Weather\\n) AS temp_table\\n\\nWHERE today_temp>yesterday_temp AND DATEDIFF(recordDate,yes_date)=1"
                    },
                    {
                        "username": "priyarb96",
                        "content": "Simple and neat query"
                    },
                    {
                        "username": "abebe_1983",
                        "content": "we need to rearrange this query a little bit as follows \\nwith CTE as (\\nselect\\nid,recordDate as [date], temperature as temp,\\nlag(temperature) over(order by recordDate,id) as prev_temp,\\nlag(recordDate) over(order by recordDate,id) as prev_date\\nfrom Weather\\n)\\n\\nselect\\nid\\nfrom CTE\\nwhere temp > prev_temp and datediff(day,  prev_date, [date] ) = 1\\n\\n\\n"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect a.id\\nfrom weather a\\ninner join weather b\\non datediff(day, b.recordDate, a.recordDate) = 1\\nand a.temperature > b.temperature\\n\\n2)\\nwith cte as\\n(select *, \\n        lag(temperature)over(order by recordDate) as perviousTemp,\\n        lag(recordDate)over(order by recordDate) as perviousDate\\nfrom weather)\\nselect id from cte where temperature > perviousTemp and datediff(day, perviousDate, recordDate) = 1"
                    },
                    {
                        "username": "ann1996015",
                        "content": "This is my code, i think it is very hard ==\\n\\nSELECT DISTINCT  w2.id\\nFROM Weather w1\\nLEFT JOIN Weather w2 ON ABS(DATEDIFF(day,w2.recordDate, w1.recordDate)) = 1\\nWHERE w2.temperature > w1.temperature and w2.recordDate>w1.recordDate"
                    }
                ]
            },
            {
                "id": 1565745,
                "content": [
                    {
                        "username": "frunfola1229",
                        "content": "\\n**SELECT**  w1.Id \\n**FROM**     Weather w1, Weather w2\\n**WHERE**   dateDiff(w1.Date,w2.Date) = 1        **AND**    w1.Temperature > w2.Temperature;"
                    },
                    {
                        "username": "Vipul_Chaudhary_2003",
                        "content": "Okay great.\nNow let's read rules together\n\nDiscussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jargolastik",
                        "content": "[@user8224IM](/user8224IM) self join creates every possible combination of columns so that means that you can just filter out the rows where the current temp is greater than yesterday\\'s"
                    },
                    {
                        "username": "JerryBlank",
                        "content": "[@user8224IM](/user8224IM) They have created 2 copies of the same table w1 and w2 and comparing each and every row. \\nSelecting only the ids for rows where \\nw1.date - w2.date =1 means that w1 is the date of next day to w2 (example: 2nd August - 1st August =1)\\nAND\\nw1.Temperature > w2.Temperature means Temperature on Date w1 is greater than Temperature on Date w2. \\n\\nso that would get Id with higher temperatures compared to its previous dates (yesterday).\\nHope this helps!"
                    },
                    {
                        "username": "user8224IM",
                        "content": "can you explain how/why this works please\\n"
                    },
                    {
                        "username": "chriszeng8",
                        "content": "Why is subtracting 1 directly from Date not working, but subdate(a.Date,1) works?\\n\\nMy code is \\n\\n    select W1.Id\\n    from Weather as W1, Weather as W2\\n    where W1.Date-1 = W2.Date and W1.Temperature> W2.Temperature\\n\\nit only passed 13/14 cases.\\n\\nHowever, when I changed `W1.Date-1` to `sub(W1.Date,1)` in the where clause, it worked. What is fundamental difference?"
                    },
                    {
                        "username": "Lysa123",
                        "content": "[@minhphamduy](/minhphamduy) cho m\\xECnh h\\u1ECFi v\\xEC sao ph\\u1EA3i c\\xF3 ch\\u1EEF subquery \\u1EDF cu\\u1ED1i v?\\n"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "I think you not should do that, use date_add instead\\n# Write your MySQL query statement below\\n\\nselect id\\nfrom (\\n    select w1.id\\n    from weather w1, weather w2\\n    where w1.recordDate= DATE_ADD(w2.recordDate, interval 1 day) and w1.temperature > w2.temperature\\n) subquery"
                    },
                    {
                        "username": "har0101",
                        "content": "date is not int"
                    },
                    {
                        "username": "291831388",
                        "content": "[@michaelniki](/michaelniki)  Thank your for your response, it really helps me."
                    },
                    {
                        "username": "michaelniki",
                        "content": "subtracting 1 does not work for the date at the end of the month or year.\nTake this test case for example:\n\n| id | recordDate | temperature |\n| -- | ---------- | ----------- |\n| 1  | 2014-12-31 | 1           |\n| 2  | 2015-01-01 | 10          |\n| 3  | 2015-01-02 | 25          |\n\nrecordDate of id 2 (2015-01-01) - 1 does not equal to  2014-12-31\n\n```\nselect\n    *\n    , w1.recordDate - w2.recordDate\nfrom\n    weather w1, weather w2\norder by w1.id\n\n```\n\n| id | recordDate | temperature | id | recordDate | temperature | w1.recordDate - w2.recordDate |\n| -- | ---------- | ----------- | -- | ---------- | ----------- | ----------------------------- |\n| 1  | 2014-12-31 | 1           | 1  | 2014-12-31 | 1           | 0                             |\n| 1  | 2014-12-31 | 1           | 2  | 2015-01-01 | 10          | -8870                         |\n| 1  | 2014-12-31 | 1           | 3  | 2015-01-02 | 25          | -8871                         |\n| 2  | 2015-01-01 | 10          | 1  | 2014-12-31 | 1           | 8870                          |\n| 2  | 2015-01-01 | 10          | 2  | 2015-01-01 | 10          | 0                             |\n| 2  | 2015-01-01 | 10          | 3  | 2015-01-02 | 25          | -1                            |\n| 3  | 2015-01-02 | 25          | 1  | 2014-12-31 | 1           | 8871                          |\n| 3  | 2015-01-02 | 25          | 2  | 2015-01-01 | 10          | 1                             |\n| 3  | 2015-01-02 | 25          | 3  | 2015-01-02 | 25          | 0                             |\n"
                    },
                    {
                        "username": "suraj21193",
                        "content": "Its is running successfully but not able to submit!\\nSelect a.id\\nfrom \\n(Select id, temperature, lag(temperature) over(order by recordDate) as lt,\\ncase when temperature>lag(temperature) over(order by recordDate) then \\'High\\'\\nelse \\'Low\\'\\nend as \\'Status\\'\\nfrom Weather) a\\nwhere Status = \\'High\\';"
                    },
                    {
                        "username": "themanutdmaniac",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) the reason is that the test case has 2 dates with a day missing in between."
                    },
                    {
                        "username": "Palash5043",
                        "content": "\nselect x.Id from (\nselect Id,\n       recordDate,\n       temperature as temp,\n    lag(temperature,1) over(order by recordDate asc) as pre_day_temp\n    from weather) x\n    where x.temp>x.pre_day_temp;\n\nI am also facing the similar issue "
                    },
                    {
                        "username": "kashrex",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) test cases are failing because the dates have to be exact previous date. \"2000-12-14 |     |2000-12-16\"  have a date difference of more than 1 day."
                    },
                    {
                        "username": "jingpingyu1127",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) I think this is because that we are finding records with only 1 day difference. The records in the test case is using date with 2 days difference, which should not return anything for the output."
                    },
                    {
                        "username": "avinashkumarjha05",
                        "content": "mine too ... have u understood why the test case failing?\\n"
                    },
                    {
                        "username": "sandeep_kumar_75",
                        "content": "**SELECT a.id\\nFROM Weather a, Weather b\\nWHERE datediff(a.recordDate, b.recordDate) = 1\\nAND a.temperature > b.temperature;**"
                    },
                    {
                        "username": "themanutdmaniac",
                        "content": "Wow, what a solution. GOAT. amazing. all the best sandeep."
                    },
                    {
                        "username": "xudaiyanzi",
                        "content": "Hi everyone, I tried the query below. It works when I run MySQL, but it can not work when it is submitted.  Please help me. Thank you.\\n# Write your MySQL query statement below\\nSELECT y.id\\nFROM Weather x\\nLEFT JOIN Weather y ON x.Id +1 = y.Id\\nWHERE x.Temperature < y.Temperature\\n"
                    },
                    {
                        "username": "cassiellong1113",
                        "content": "date is not ascending sorted, and thus if you do not compare with dates but with ID, you may get wrong answer "
                    },
                    {
                        "username": "Avazbeka_dev",
                        "content": "SELECT a.id\\nFROM Weather as a,Weather as b\\nWHERE a.temperature>b.temperature\\nAND DATEDIFF(a.recordDate,b.recordDate)=1\\n\\nYou must check the datas !"
                    },
                    {
                        "username": "patnanavarun",
                        "content": "you are just checking the id values .But not comparing the dates.\\n"
                    },
                    {
                        "username": "snehanshu17",
                        "content": "with tmp as (\\nselect id ,RecordDate,Temperature,\\nLAG (Temperature,1) OVER (ORDER BY RecordDate) AS prev_Temperature,\\n    LAG (RecordDate,1) OVER (ORDER BY RecordDate) AS prev_RecordDate\\nfrom Weather)\\n\\nselect id  from tmp where Temperature>prev_Temperature and (RecordDate-prev_RecordDate)=1"
                    },
                    {
                        "username": "mr-xed",
                        "content": "Really interesting approach, except it didn\\'t work for me from the get go for some reason, how ever I was able to solve it using `dateDiff(RecordDate, prev_RecordDate)` instead of `(RecordDate-prev_RecordDate)`"
                    },
                    {
                        "username": "XinyiQiu",
                        "content": "WITH yesterday AS (SELECT id,recordDate,temperature,DATE_SUB(recordDate, INTERVAL 1 DAY) AS yesterday\\nFROM Weather)\\n\\nSELECT yesterday.id\\nFROM yesterday LEFT JOIN Weather on yesterday.yesterday = Weather.recordDate\\nWHERE Weather.temperature IS NOT NULL AND yesterday.temperature > Weather.temperature"
                    },
                    {
                        "username": "nasirxia",
                        "content": "the idea is brilliant but why make things complicated? There should be a reasons for doing this."
                    },
                    {
                        "username": "anand_vineet19",
                        "content": "# Write your MySQL query statement below\\nSELECT id\\nFROM\\n(\\nSELECT id, recordDate, temperature AS today_temp, LAG(temperature,1) OVER (ORDER BY recordDate) AS yesterday_temp, LAG(recordDate,1) OVER (ORDER BY recordDate) AS yes_date\\n\\nFROM Weather\\n) AS temp_table\\n\\nWHERE today_temp>yesterday_temp AND DATEDIFF(recordDate,yes_date)=1"
                    },
                    {
                        "username": "priyarb96",
                        "content": "Simple and neat query"
                    },
                    {
                        "username": "abebe_1983",
                        "content": "we need to rearrange this query a little bit as follows \\nwith CTE as (\\nselect\\nid,recordDate as [date], temperature as temp,\\nlag(temperature) over(order by recordDate,id) as prev_temp,\\nlag(recordDate) over(order by recordDate,id) as prev_date\\nfrom Weather\\n)\\n\\nselect\\nid\\nfrom CTE\\nwhere temp > prev_temp and datediff(day,  prev_date, [date] ) = 1\\n\\n\\n"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect a.id\\nfrom weather a\\ninner join weather b\\non datediff(day, b.recordDate, a.recordDate) = 1\\nand a.temperature > b.temperature\\n\\n2)\\nwith cte as\\n(select *, \\n        lag(temperature)over(order by recordDate) as perviousTemp,\\n        lag(recordDate)over(order by recordDate) as perviousDate\\nfrom weather)\\nselect id from cte where temperature > perviousTemp and datediff(day, perviousDate, recordDate) = 1"
                    },
                    {
                        "username": "ann1996015",
                        "content": "This is my code, i think it is very hard ==\\n\\nSELECT DISTINCT  w2.id\\nFROM Weather w1\\nLEFT JOIN Weather w2 ON ABS(DATEDIFF(day,w2.recordDate, w1.recordDate)) = 1\\nWHERE w2.temperature > w1.temperature and w2.recordDate>w1.recordDate"
                    }
                ]
            },
            {
                "id": 1576886,
                "content": [
                    {
                        "username": "frunfola1229",
                        "content": "\\n**SELECT**  w1.Id \\n**FROM**     Weather w1, Weather w2\\n**WHERE**   dateDiff(w1.Date,w2.Date) = 1        **AND**    w1.Temperature > w2.Temperature;"
                    },
                    {
                        "username": "Vipul_Chaudhary_2003",
                        "content": "Okay great.\nNow let's read rules together\n\nDiscussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jargolastik",
                        "content": "[@user8224IM](/user8224IM) self join creates every possible combination of columns so that means that you can just filter out the rows where the current temp is greater than yesterday\\'s"
                    },
                    {
                        "username": "JerryBlank",
                        "content": "[@user8224IM](/user8224IM) They have created 2 copies of the same table w1 and w2 and comparing each and every row. \\nSelecting only the ids for rows where \\nw1.date - w2.date =1 means that w1 is the date of next day to w2 (example: 2nd August - 1st August =1)\\nAND\\nw1.Temperature > w2.Temperature means Temperature on Date w1 is greater than Temperature on Date w2. \\n\\nso that would get Id with higher temperatures compared to its previous dates (yesterday).\\nHope this helps!"
                    },
                    {
                        "username": "user8224IM",
                        "content": "can you explain how/why this works please\\n"
                    },
                    {
                        "username": "chriszeng8",
                        "content": "Why is subtracting 1 directly from Date not working, but subdate(a.Date,1) works?\\n\\nMy code is \\n\\n    select W1.Id\\n    from Weather as W1, Weather as W2\\n    where W1.Date-1 = W2.Date and W1.Temperature> W2.Temperature\\n\\nit only passed 13/14 cases.\\n\\nHowever, when I changed `W1.Date-1` to `sub(W1.Date,1)` in the where clause, it worked. What is fundamental difference?"
                    },
                    {
                        "username": "Lysa123",
                        "content": "[@minhphamduy](/minhphamduy) cho m\\xECnh h\\u1ECFi v\\xEC sao ph\\u1EA3i c\\xF3 ch\\u1EEF subquery \\u1EDF cu\\u1ED1i v?\\n"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "I think you not should do that, use date_add instead\\n# Write your MySQL query statement below\\n\\nselect id\\nfrom (\\n    select w1.id\\n    from weather w1, weather w2\\n    where w1.recordDate= DATE_ADD(w2.recordDate, interval 1 day) and w1.temperature > w2.temperature\\n) subquery"
                    },
                    {
                        "username": "har0101",
                        "content": "date is not int"
                    },
                    {
                        "username": "291831388",
                        "content": "[@michaelniki](/michaelniki)  Thank your for your response, it really helps me."
                    },
                    {
                        "username": "michaelniki",
                        "content": "subtracting 1 does not work for the date at the end of the month or year.\nTake this test case for example:\n\n| id | recordDate | temperature |\n| -- | ---------- | ----------- |\n| 1  | 2014-12-31 | 1           |\n| 2  | 2015-01-01 | 10          |\n| 3  | 2015-01-02 | 25          |\n\nrecordDate of id 2 (2015-01-01) - 1 does not equal to  2014-12-31\n\n```\nselect\n    *\n    , w1.recordDate - w2.recordDate\nfrom\n    weather w1, weather w2\norder by w1.id\n\n```\n\n| id | recordDate | temperature | id | recordDate | temperature | w1.recordDate - w2.recordDate |\n| -- | ---------- | ----------- | -- | ---------- | ----------- | ----------------------------- |\n| 1  | 2014-12-31 | 1           | 1  | 2014-12-31 | 1           | 0                             |\n| 1  | 2014-12-31 | 1           | 2  | 2015-01-01 | 10          | -8870                         |\n| 1  | 2014-12-31 | 1           | 3  | 2015-01-02 | 25          | -8871                         |\n| 2  | 2015-01-01 | 10          | 1  | 2014-12-31 | 1           | 8870                          |\n| 2  | 2015-01-01 | 10          | 2  | 2015-01-01 | 10          | 0                             |\n| 2  | 2015-01-01 | 10          | 3  | 2015-01-02 | 25          | -1                            |\n| 3  | 2015-01-02 | 25          | 1  | 2014-12-31 | 1           | 8871                          |\n| 3  | 2015-01-02 | 25          | 2  | 2015-01-01 | 10          | 1                             |\n| 3  | 2015-01-02 | 25          | 3  | 2015-01-02 | 25          | 0                             |\n"
                    },
                    {
                        "username": "suraj21193",
                        "content": "Its is running successfully but not able to submit!\\nSelect a.id\\nfrom \\n(Select id, temperature, lag(temperature) over(order by recordDate) as lt,\\ncase when temperature>lag(temperature) over(order by recordDate) then \\'High\\'\\nelse \\'Low\\'\\nend as \\'Status\\'\\nfrom Weather) a\\nwhere Status = \\'High\\';"
                    },
                    {
                        "username": "themanutdmaniac",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) the reason is that the test case has 2 dates with a day missing in between."
                    },
                    {
                        "username": "Palash5043",
                        "content": "\nselect x.Id from (\nselect Id,\n       recordDate,\n       temperature as temp,\n    lag(temperature,1) over(order by recordDate asc) as pre_day_temp\n    from weather) x\n    where x.temp>x.pre_day_temp;\n\nI am also facing the similar issue "
                    },
                    {
                        "username": "kashrex",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) test cases are failing because the dates have to be exact previous date. \"2000-12-14 |     |2000-12-16\"  have a date difference of more than 1 day."
                    },
                    {
                        "username": "jingpingyu1127",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) I think this is because that we are finding records with only 1 day difference. The records in the test case is using date with 2 days difference, which should not return anything for the output."
                    },
                    {
                        "username": "avinashkumarjha05",
                        "content": "mine too ... have u understood why the test case failing?\\n"
                    },
                    {
                        "username": "sandeep_kumar_75",
                        "content": "**SELECT a.id\\nFROM Weather a, Weather b\\nWHERE datediff(a.recordDate, b.recordDate) = 1\\nAND a.temperature > b.temperature;**"
                    },
                    {
                        "username": "themanutdmaniac",
                        "content": "Wow, what a solution. GOAT. amazing. all the best sandeep."
                    },
                    {
                        "username": "xudaiyanzi",
                        "content": "Hi everyone, I tried the query below. It works when I run MySQL, but it can not work when it is submitted.  Please help me. Thank you.\\n# Write your MySQL query statement below\\nSELECT y.id\\nFROM Weather x\\nLEFT JOIN Weather y ON x.Id +1 = y.Id\\nWHERE x.Temperature < y.Temperature\\n"
                    },
                    {
                        "username": "cassiellong1113",
                        "content": "date is not ascending sorted, and thus if you do not compare with dates but with ID, you may get wrong answer "
                    },
                    {
                        "username": "Avazbeka_dev",
                        "content": "SELECT a.id\\nFROM Weather as a,Weather as b\\nWHERE a.temperature>b.temperature\\nAND DATEDIFF(a.recordDate,b.recordDate)=1\\n\\nYou must check the datas !"
                    },
                    {
                        "username": "patnanavarun",
                        "content": "you are just checking the id values .But not comparing the dates.\\n"
                    },
                    {
                        "username": "snehanshu17",
                        "content": "with tmp as (\\nselect id ,RecordDate,Temperature,\\nLAG (Temperature,1) OVER (ORDER BY RecordDate) AS prev_Temperature,\\n    LAG (RecordDate,1) OVER (ORDER BY RecordDate) AS prev_RecordDate\\nfrom Weather)\\n\\nselect id  from tmp where Temperature>prev_Temperature and (RecordDate-prev_RecordDate)=1"
                    },
                    {
                        "username": "mr-xed",
                        "content": "Really interesting approach, except it didn\\'t work for me from the get go for some reason, how ever I was able to solve it using `dateDiff(RecordDate, prev_RecordDate)` instead of `(RecordDate-prev_RecordDate)`"
                    },
                    {
                        "username": "XinyiQiu",
                        "content": "WITH yesterday AS (SELECT id,recordDate,temperature,DATE_SUB(recordDate, INTERVAL 1 DAY) AS yesterday\\nFROM Weather)\\n\\nSELECT yesterday.id\\nFROM yesterday LEFT JOIN Weather on yesterday.yesterday = Weather.recordDate\\nWHERE Weather.temperature IS NOT NULL AND yesterday.temperature > Weather.temperature"
                    },
                    {
                        "username": "nasirxia",
                        "content": "the idea is brilliant but why make things complicated? There should be a reasons for doing this."
                    },
                    {
                        "username": "anand_vineet19",
                        "content": "# Write your MySQL query statement below\\nSELECT id\\nFROM\\n(\\nSELECT id, recordDate, temperature AS today_temp, LAG(temperature,1) OVER (ORDER BY recordDate) AS yesterday_temp, LAG(recordDate,1) OVER (ORDER BY recordDate) AS yes_date\\n\\nFROM Weather\\n) AS temp_table\\n\\nWHERE today_temp>yesterday_temp AND DATEDIFF(recordDate,yes_date)=1"
                    },
                    {
                        "username": "priyarb96",
                        "content": "Simple and neat query"
                    },
                    {
                        "username": "abebe_1983",
                        "content": "we need to rearrange this query a little bit as follows \\nwith CTE as (\\nselect\\nid,recordDate as [date], temperature as temp,\\nlag(temperature) over(order by recordDate,id) as prev_temp,\\nlag(recordDate) over(order by recordDate,id) as prev_date\\nfrom Weather\\n)\\n\\nselect\\nid\\nfrom CTE\\nwhere temp > prev_temp and datediff(day,  prev_date, [date] ) = 1\\n\\n\\n"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect a.id\\nfrom weather a\\ninner join weather b\\non datediff(day, b.recordDate, a.recordDate) = 1\\nand a.temperature > b.temperature\\n\\n2)\\nwith cte as\\n(select *, \\n        lag(temperature)over(order by recordDate) as perviousTemp,\\n        lag(recordDate)over(order by recordDate) as perviousDate\\nfrom weather)\\nselect id from cte where temperature > perviousTemp and datediff(day, perviousDate, recordDate) = 1"
                    },
                    {
                        "username": "ann1996015",
                        "content": "This is my code, i think it is very hard ==\\n\\nSELECT DISTINCT  w2.id\\nFROM Weather w1\\nLEFT JOIN Weather w2 ON ABS(DATEDIFF(day,w2.recordDate, w1.recordDate)) = 1\\nWHERE w2.temperature > w1.temperature and w2.recordDate>w1.recordDate"
                    }
                ]
            },
            {
                "id": 1576869,
                "content": [
                    {
                        "username": "frunfola1229",
                        "content": "\\n**SELECT**  w1.Id \\n**FROM**     Weather w1, Weather w2\\n**WHERE**   dateDiff(w1.Date,w2.Date) = 1        **AND**    w1.Temperature > w2.Temperature;"
                    },
                    {
                        "username": "Vipul_Chaudhary_2003",
                        "content": "Okay great.\nNow let's read rules together\n\nDiscussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jargolastik",
                        "content": "[@user8224IM](/user8224IM) self join creates every possible combination of columns so that means that you can just filter out the rows where the current temp is greater than yesterday\\'s"
                    },
                    {
                        "username": "JerryBlank",
                        "content": "[@user8224IM](/user8224IM) They have created 2 copies of the same table w1 and w2 and comparing each and every row. \\nSelecting only the ids for rows where \\nw1.date - w2.date =1 means that w1 is the date of next day to w2 (example: 2nd August - 1st August =1)\\nAND\\nw1.Temperature > w2.Temperature means Temperature on Date w1 is greater than Temperature on Date w2. \\n\\nso that would get Id with higher temperatures compared to its previous dates (yesterday).\\nHope this helps!"
                    },
                    {
                        "username": "user8224IM",
                        "content": "can you explain how/why this works please\\n"
                    },
                    {
                        "username": "chriszeng8",
                        "content": "Why is subtracting 1 directly from Date not working, but subdate(a.Date,1) works?\\n\\nMy code is \\n\\n    select W1.Id\\n    from Weather as W1, Weather as W2\\n    where W1.Date-1 = W2.Date and W1.Temperature> W2.Temperature\\n\\nit only passed 13/14 cases.\\n\\nHowever, when I changed `W1.Date-1` to `sub(W1.Date,1)` in the where clause, it worked. What is fundamental difference?"
                    },
                    {
                        "username": "Lysa123",
                        "content": "[@minhphamduy](/minhphamduy) cho m\\xECnh h\\u1ECFi v\\xEC sao ph\\u1EA3i c\\xF3 ch\\u1EEF subquery \\u1EDF cu\\u1ED1i v?\\n"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "I think you not should do that, use date_add instead\\n# Write your MySQL query statement below\\n\\nselect id\\nfrom (\\n    select w1.id\\n    from weather w1, weather w2\\n    where w1.recordDate= DATE_ADD(w2.recordDate, interval 1 day) and w1.temperature > w2.temperature\\n) subquery"
                    },
                    {
                        "username": "har0101",
                        "content": "date is not int"
                    },
                    {
                        "username": "291831388",
                        "content": "[@michaelniki](/michaelniki)  Thank your for your response, it really helps me."
                    },
                    {
                        "username": "michaelniki",
                        "content": "subtracting 1 does not work for the date at the end of the month or year.\nTake this test case for example:\n\n| id | recordDate | temperature |\n| -- | ---------- | ----------- |\n| 1  | 2014-12-31 | 1           |\n| 2  | 2015-01-01 | 10          |\n| 3  | 2015-01-02 | 25          |\n\nrecordDate of id 2 (2015-01-01) - 1 does not equal to  2014-12-31\n\n```\nselect\n    *\n    , w1.recordDate - w2.recordDate\nfrom\n    weather w1, weather w2\norder by w1.id\n\n```\n\n| id | recordDate | temperature | id | recordDate | temperature | w1.recordDate - w2.recordDate |\n| -- | ---------- | ----------- | -- | ---------- | ----------- | ----------------------------- |\n| 1  | 2014-12-31 | 1           | 1  | 2014-12-31 | 1           | 0                             |\n| 1  | 2014-12-31 | 1           | 2  | 2015-01-01 | 10          | -8870                         |\n| 1  | 2014-12-31 | 1           | 3  | 2015-01-02 | 25          | -8871                         |\n| 2  | 2015-01-01 | 10          | 1  | 2014-12-31 | 1           | 8870                          |\n| 2  | 2015-01-01 | 10          | 2  | 2015-01-01 | 10          | 0                             |\n| 2  | 2015-01-01 | 10          | 3  | 2015-01-02 | 25          | -1                            |\n| 3  | 2015-01-02 | 25          | 1  | 2014-12-31 | 1           | 8871                          |\n| 3  | 2015-01-02 | 25          | 2  | 2015-01-01 | 10          | 1                             |\n| 3  | 2015-01-02 | 25          | 3  | 2015-01-02 | 25          | 0                             |\n"
                    },
                    {
                        "username": "suraj21193",
                        "content": "Its is running successfully but not able to submit!\\nSelect a.id\\nfrom \\n(Select id, temperature, lag(temperature) over(order by recordDate) as lt,\\ncase when temperature>lag(temperature) over(order by recordDate) then \\'High\\'\\nelse \\'Low\\'\\nend as \\'Status\\'\\nfrom Weather) a\\nwhere Status = \\'High\\';"
                    },
                    {
                        "username": "themanutdmaniac",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) the reason is that the test case has 2 dates with a day missing in between."
                    },
                    {
                        "username": "Palash5043",
                        "content": "\nselect x.Id from (\nselect Id,\n       recordDate,\n       temperature as temp,\n    lag(temperature,1) over(order by recordDate asc) as pre_day_temp\n    from weather) x\n    where x.temp>x.pre_day_temp;\n\nI am also facing the similar issue "
                    },
                    {
                        "username": "kashrex",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) test cases are failing because the dates have to be exact previous date. \"2000-12-14 |     |2000-12-16\"  have a date difference of more than 1 day."
                    },
                    {
                        "username": "jingpingyu1127",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) I think this is because that we are finding records with only 1 day difference. The records in the test case is using date with 2 days difference, which should not return anything for the output."
                    },
                    {
                        "username": "avinashkumarjha05",
                        "content": "mine too ... have u understood why the test case failing?\\n"
                    },
                    {
                        "username": "sandeep_kumar_75",
                        "content": "**SELECT a.id\\nFROM Weather a, Weather b\\nWHERE datediff(a.recordDate, b.recordDate) = 1\\nAND a.temperature > b.temperature;**"
                    },
                    {
                        "username": "themanutdmaniac",
                        "content": "Wow, what a solution. GOAT. amazing. all the best sandeep."
                    },
                    {
                        "username": "xudaiyanzi",
                        "content": "Hi everyone, I tried the query below. It works when I run MySQL, but it can not work when it is submitted.  Please help me. Thank you.\\n# Write your MySQL query statement below\\nSELECT y.id\\nFROM Weather x\\nLEFT JOIN Weather y ON x.Id +1 = y.Id\\nWHERE x.Temperature < y.Temperature\\n"
                    },
                    {
                        "username": "cassiellong1113",
                        "content": "date is not ascending sorted, and thus if you do not compare with dates but with ID, you may get wrong answer "
                    },
                    {
                        "username": "Avazbeka_dev",
                        "content": "SELECT a.id\\nFROM Weather as a,Weather as b\\nWHERE a.temperature>b.temperature\\nAND DATEDIFF(a.recordDate,b.recordDate)=1\\n\\nYou must check the datas !"
                    },
                    {
                        "username": "patnanavarun",
                        "content": "you are just checking the id values .But not comparing the dates.\\n"
                    },
                    {
                        "username": "snehanshu17",
                        "content": "with tmp as (\\nselect id ,RecordDate,Temperature,\\nLAG (Temperature,1) OVER (ORDER BY RecordDate) AS prev_Temperature,\\n    LAG (RecordDate,1) OVER (ORDER BY RecordDate) AS prev_RecordDate\\nfrom Weather)\\n\\nselect id  from tmp where Temperature>prev_Temperature and (RecordDate-prev_RecordDate)=1"
                    },
                    {
                        "username": "mr-xed",
                        "content": "Really interesting approach, except it didn\\'t work for me from the get go for some reason, how ever I was able to solve it using `dateDiff(RecordDate, prev_RecordDate)` instead of `(RecordDate-prev_RecordDate)`"
                    },
                    {
                        "username": "XinyiQiu",
                        "content": "WITH yesterday AS (SELECT id,recordDate,temperature,DATE_SUB(recordDate, INTERVAL 1 DAY) AS yesterday\\nFROM Weather)\\n\\nSELECT yesterday.id\\nFROM yesterday LEFT JOIN Weather on yesterday.yesterday = Weather.recordDate\\nWHERE Weather.temperature IS NOT NULL AND yesterday.temperature > Weather.temperature"
                    },
                    {
                        "username": "nasirxia",
                        "content": "the idea is brilliant but why make things complicated? There should be a reasons for doing this."
                    },
                    {
                        "username": "anand_vineet19",
                        "content": "# Write your MySQL query statement below\\nSELECT id\\nFROM\\n(\\nSELECT id, recordDate, temperature AS today_temp, LAG(temperature,1) OVER (ORDER BY recordDate) AS yesterday_temp, LAG(recordDate,1) OVER (ORDER BY recordDate) AS yes_date\\n\\nFROM Weather\\n) AS temp_table\\n\\nWHERE today_temp>yesterday_temp AND DATEDIFF(recordDate,yes_date)=1"
                    },
                    {
                        "username": "priyarb96",
                        "content": "Simple and neat query"
                    },
                    {
                        "username": "abebe_1983",
                        "content": "we need to rearrange this query a little bit as follows \\nwith CTE as (\\nselect\\nid,recordDate as [date], temperature as temp,\\nlag(temperature) over(order by recordDate,id) as prev_temp,\\nlag(recordDate) over(order by recordDate,id) as prev_date\\nfrom Weather\\n)\\n\\nselect\\nid\\nfrom CTE\\nwhere temp > prev_temp and datediff(day,  prev_date, [date] ) = 1\\n\\n\\n"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect a.id\\nfrom weather a\\ninner join weather b\\non datediff(day, b.recordDate, a.recordDate) = 1\\nand a.temperature > b.temperature\\n\\n2)\\nwith cte as\\n(select *, \\n        lag(temperature)over(order by recordDate) as perviousTemp,\\n        lag(recordDate)over(order by recordDate) as perviousDate\\nfrom weather)\\nselect id from cte where temperature > perviousTemp and datediff(day, perviousDate, recordDate) = 1"
                    },
                    {
                        "username": "ann1996015",
                        "content": "This is my code, i think it is very hard ==\\n\\nSELECT DISTINCT  w2.id\\nFROM Weather w1\\nLEFT JOIN Weather w2 ON ABS(DATEDIFF(day,w2.recordDate, w1.recordDate)) = 1\\nWHERE w2.temperature > w1.temperature and w2.recordDate>w1.recordDate"
                    }
                ]
            },
            {
                "id": 1574935,
                "content": [
                    {
                        "username": "frunfola1229",
                        "content": "\\n**SELECT**  w1.Id \\n**FROM**     Weather w1, Weather w2\\n**WHERE**   dateDiff(w1.Date,w2.Date) = 1        **AND**    w1.Temperature > w2.Temperature;"
                    },
                    {
                        "username": "Vipul_Chaudhary_2003",
                        "content": "Okay great.\nNow let's read rules together\n\nDiscussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jargolastik",
                        "content": "[@user8224IM](/user8224IM) self join creates every possible combination of columns so that means that you can just filter out the rows where the current temp is greater than yesterday\\'s"
                    },
                    {
                        "username": "JerryBlank",
                        "content": "[@user8224IM](/user8224IM) They have created 2 copies of the same table w1 and w2 and comparing each and every row. \\nSelecting only the ids for rows where \\nw1.date - w2.date =1 means that w1 is the date of next day to w2 (example: 2nd August - 1st August =1)\\nAND\\nw1.Temperature > w2.Temperature means Temperature on Date w1 is greater than Temperature on Date w2. \\n\\nso that would get Id with higher temperatures compared to its previous dates (yesterday).\\nHope this helps!"
                    },
                    {
                        "username": "user8224IM",
                        "content": "can you explain how/why this works please\\n"
                    },
                    {
                        "username": "chriszeng8",
                        "content": "Why is subtracting 1 directly from Date not working, but subdate(a.Date,1) works?\\n\\nMy code is \\n\\n    select W1.Id\\n    from Weather as W1, Weather as W2\\n    where W1.Date-1 = W2.Date and W1.Temperature> W2.Temperature\\n\\nit only passed 13/14 cases.\\n\\nHowever, when I changed `W1.Date-1` to `sub(W1.Date,1)` in the where clause, it worked. What is fundamental difference?"
                    },
                    {
                        "username": "Lysa123",
                        "content": "[@minhphamduy](/minhphamduy) cho m\\xECnh h\\u1ECFi v\\xEC sao ph\\u1EA3i c\\xF3 ch\\u1EEF subquery \\u1EDF cu\\u1ED1i v?\\n"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "I think you not should do that, use date_add instead\\n# Write your MySQL query statement below\\n\\nselect id\\nfrom (\\n    select w1.id\\n    from weather w1, weather w2\\n    where w1.recordDate= DATE_ADD(w2.recordDate, interval 1 day) and w1.temperature > w2.temperature\\n) subquery"
                    },
                    {
                        "username": "har0101",
                        "content": "date is not int"
                    },
                    {
                        "username": "291831388",
                        "content": "[@michaelniki](/michaelniki)  Thank your for your response, it really helps me."
                    },
                    {
                        "username": "michaelniki",
                        "content": "subtracting 1 does not work for the date at the end of the month or year.\nTake this test case for example:\n\n| id | recordDate | temperature |\n| -- | ---------- | ----------- |\n| 1  | 2014-12-31 | 1           |\n| 2  | 2015-01-01 | 10          |\n| 3  | 2015-01-02 | 25          |\n\nrecordDate of id 2 (2015-01-01) - 1 does not equal to  2014-12-31\n\n```\nselect\n    *\n    , w1.recordDate - w2.recordDate\nfrom\n    weather w1, weather w2\norder by w1.id\n\n```\n\n| id | recordDate | temperature | id | recordDate | temperature | w1.recordDate - w2.recordDate |\n| -- | ---------- | ----------- | -- | ---------- | ----------- | ----------------------------- |\n| 1  | 2014-12-31 | 1           | 1  | 2014-12-31 | 1           | 0                             |\n| 1  | 2014-12-31 | 1           | 2  | 2015-01-01 | 10          | -8870                         |\n| 1  | 2014-12-31 | 1           | 3  | 2015-01-02 | 25          | -8871                         |\n| 2  | 2015-01-01 | 10          | 1  | 2014-12-31 | 1           | 8870                          |\n| 2  | 2015-01-01 | 10          | 2  | 2015-01-01 | 10          | 0                             |\n| 2  | 2015-01-01 | 10          | 3  | 2015-01-02 | 25          | -1                            |\n| 3  | 2015-01-02 | 25          | 1  | 2014-12-31 | 1           | 8871                          |\n| 3  | 2015-01-02 | 25          | 2  | 2015-01-01 | 10          | 1                             |\n| 3  | 2015-01-02 | 25          | 3  | 2015-01-02 | 25          | 0                             |\n"
                    },
                    {
                        "username": "suraj21193",
                        "content": "Its is running successfully but not able to submit!\\nSelect a.id\\nfrom \\n(Select id, temperature, lag(temperature) over(order by recordDate) as lt,\\ncase when temperature>lag(temperature) over(order by recordDate) then \\'High\\'\\nelse \\'Low\\'\\nend as \\'Status\\'\\nfrom Weather) a\\nwhere Status = \\'High\\';"
                    },
                    {
                        "username": "themanutdmaniac",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) the reason is that the test case has 2 dates with a day missing in between."
                    },
                    {
                        "username": "Palash5043",
                        "content": "\nselect x.Id from (\nselect Id,\n       recordDate,\n       temperature as temp,\n    lag(temperature,1) over(order by recordDate asc) as pre_day_temp\n    from weather) x\n    where x.temp>x.pre_day_temp;\n\nI am also facing the similar issue "
                    },
                    {
                        "username": "kashrex",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) test cases are failing because the dates have to be exact previous date. \"2000-12-14 |     |2000-12-16\"  have a date difference of more than 1 day."
                    },
                    {
                        "username": "jingpingyu1127",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) I think this is because that we are finding records with only 1 day difference. The records in the test case is using date with 2 days difference, which should not return anything for the output."
                    },
                    {
                        "username": "avinashkumarjha05",
                        "content": "mine too ... have u understood why the test case failing?\\n"
                    },
                    {
                        "username": "sandeep_kumar_75",
                        "content": "**SELECT a.id\\nFROM Weather a, Weather b\\nWHERE datediff(a.recordDate, b.recordDate) = 1\\nAND a.temperature > b.temperature;**"
                    },
                    {
                        "username": "themanutdmaniac",
                        "content": "Wow, what a solution. GOAT. amazing. all the best sandeep."
                    },
                    {
                        "username": "xudaiyanzi",
                        "content": "Hi everyone, I tried the query below. It works when I run MySQL, but it can not work when it is submitted.  Please help me. Thank you.\\n# Write your MySQL query statement below\\nSELECT y.id\\nFROM Weather x\\nLEFT JOIN Weather y ON x.Id +1 = y.Id\\nWHERE x.Temperature < y.Temperature\\n"
                    },
                    {
                        "username": "cassiellong1113",
                        "content": "date is not ascending sorted, and thus if you do not compare with dates but with ID, you may get wrong answer "
                    },
                    {
                        "username": "Avazbeka_dev",
                        "content": "SELECT a.id\\nFROM Weather as a,Weather as b\\nWHERE a.temperature>b.temperature\\nAND DATEDIFF(a.recordDate,b.recordDate)=1\\n\\nYou must check the datas !"
                    },
                    {
                        "username": "patnanavarun",
                        "content": "you are just checking the id values .But not comparing the dates.\\n"
                    },
                    {
                        "username": "snehanshu17",
                        "content": "with tmp as (\\nselect id ,RecordDate,Temperature,\\nLAG (Temperature,1) OVER (ORDER BY RecordDate) AS prev_Temperature,\\n    LAG (RecordDate,1) OVER (ORDER BY RecordDate) AS prev_RecordDate\\nfrom Weather)\\n\\nselect id  from tmp where Temperature>prev_Temperature and (RecordDate-prev_RecordDate)=1"
                    },
                    {
                        "username": "mr-xed",
                        "content": "Really interesting approach, except it didn\\'t work for me from the get go for some reason, how ever I was able to solve it using `dateDiff(RecordDate, prev_RecordDate)` instead of `(RecordDate-prev_RecordDate)`"
                    },
                    {
                        "username": "XinyiQiu",
                        "content": "WITH yesterday AS (SELECT id,recordDate,temperature,DATE_SUB(recordDate, INTERVAL 1 DAY) AS yesterday\\nFROM Weather)\\n\\nSELECT yesterday.id\\nFROM yesterday LEFT JOIN Weather on yesterday.yesterday = Weather.recordDate\\nWHERE Weather.temperature IS NOT NULL AND yesterday.temperature > Weather.temperature"
                    },
                    {
                        "username": "nasirxia",
                        "content": "the idea is brilliant but why make things complicated? There should be a reasons for doing this."
                    },
                    {
                        "username": "anand_vineet19",
                        "content": "# Write your MySQL query statement below\\nSELECT id\\nFROM\\n(\\nSELECT id, recordDate, temperature AS today_temp, LAG(temperature,1) OVER (ORDER BY recordDate) AS yesterday_temp, LAG(recordDate,1) OVER (ORDER BY recordDate) AS yes_date\\n\\nFROM Weather\\n) AS temp_table\\n\\nWHERE today_temp>yesterday_temp AND DATEDIFF(recordDate,yes_date)=1"
                    },
                    {
                        "username": "priyarb96",
                        "content": "Simple and neat query"
                    },
                    {
                        "username": "abebe_1983",
                        "content": "we need to rearrange this query a little bit as follows \\nwith CTE as (\\nselect\\nid,recordDate as [date], temperature as temp,\\nlag(temperature) over(order by recordDate,id) as prev_temp,\\nlag(recordDate) over(order by recordDate,id) as prev_date\\nfrom Weather\\n)\\n\\nselect\\nid\\nfrom CTE\\nwhere temp > prev_temp and datediff(day,  prev_date, [date] ) = 1\\n\\n\\n"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect a.id\\nfrom weather a\\ninner join weather b\\non datediff(day, b.recordDate, a.recordDate) = 1\\nand a.temperature > b.temperature\\n\\n2)\\nwith cte as\\n(select *, \\n        lag(temperature)over(order by recordDate) as perviousTemp,\\n        lag(recordDate)over(order by recordDate) as perviousDate\\nfrom weather)\\nselect id from cte where temperature > perviousTemp and datediff(day, perviousDate, recordDate) = 1"
                    },
                    {
                        "username": "ann1996015",
                        "content": "This is my code, i think it is very hard ==\\n\\nSELECT DISTINCT  w2.id\\nFROM Weather w1\\nLEFT JOIN Weather w2 ON ABS(DATEDIFF(day,w2.recordDate, w1.recordDate)) = 1\\nWHERE w2.temperature > w1.temperature and w2.recordDate>w1.recordDate"
                    }
                ]
            },
            {
                "id": 1572856,
                "content": [
                    {
                        "username": "frunfola1229",
                        "content": "\\n**SELECT**  w1.Id \\n**FROM**     Weather w1, Weather w2\\n**WHERE**   dateDiff(w1.Date,w2.Date) = 1        **AND**    w1.Temperature > w2.Temperature;"
                    },
                    {
                        "username": "Vipul_Chaudhary_2003",
                        "content": "Okay great.\nNow let's read rules together\n\nDiscussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jargolastik",
                        "content": "[@user8224IM](/user8224IM) self join creates every possible combination of columns so that means that you can just filter out the rows where the current temp is greater than yesterday\\'s"
                    },
                    {
                        "username": "JerryBlank",
                        "content": "[@user8224IM](/user8224IM) They have created 2 copies of the same table w1 and w2 and comparing each and every row. \\nSelecting only the ids for rows where \\nw1.date - w2.date =1 means that w1 is the date of next day to w2 (example: 2nd August - 1st August =1)\\nAND\\nw1.Temperature > w2.Temperature means Temperature on Date w1 is greater than Temperature on Date w2. \\n\\nso that would get Id with higher temperatures compared to its previous dates (yesterday).\\nHope this helps!"
                    },
                    {
                        "username": "user8224IM",
                        "content": "can you explain how/why this works please\\n"
                    },
                    {
                        "username": "chriszeng8",
                        "content": "Why is subtracting 1 directly from Date not working, but subdate(a.Date,1) works?\\n\\nMy code is \\n\\n    select W1.Id\\n    from Weather as W1, Weather as W2\\n    where W1.Date-1 = W2.Date and W1.Temperature> W2.Temperature\\n\\nit only passed 13/14 cases.\\n\\nHowever, when I changed `W1.Date-1` to `sub(W1.Date,1)` in the where clause, it worked. What is fundamental difference?"
                    },
                    {
                        "username": "Lysa123",
                        "content": "[@minhphamduy](/minhphamduy) cho m\\xECnh h\\u1ECFi v\\xEC sao ph\\u1EA3i c\\xF3 ch\\u1EEF subquery \\u1EDF cu\\u1ED1i v?\\n"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "I think you not should do that, use date_add instead\\n# Write your MySQL query statement below\\n\\nselect id\\nfrom (\\n    select w1.id\\n    from weather w1, weather w2\\n    where w1.recordDate= DATE_ADD(w2.recordDate, interval 1 day) and w1.temperature > w2.temperature\\n) subquery"
                    },
                    {
                        "username": "har0101",
                        "content": "date is not int"
                    },
                    {
                        "username": "291831388",
                        "content": "[@michaelniki](/michaelniki)  Thank your for your response, it really helps me."
                    },
                    {
                        "username": "michaelniki",
                        "content": "subtracting 1 does not work for the date at the end of the month or year.\nTake this test case for example:\n\n| id | recordDate | temperature |\n| -- | ---------- | ----------- |\n| 1  | 2014-12-31 | 1           |\n| 2  | 2015-01-01 | 10          |\n| 3  | 2015-01-02 | 25          |\n\nrecordDate of id 2 (2015-01-01) - 1 does not equal to  2014-12-31\n\n```\nselect\n    *\n    , w1.recordDate - w2.recordDate\nfrom\n    weather w1, weather w2\norder by w1.id\n\n```\n\n| id | recordDate | temperature | id | recordDate | temperature | w1.recordDate - w2.recordDate |\n| -- | ---------- | ----------- | -- | ---------- | ----------- | ----------------------------- |\n| 1  | 2014-12-31 | 1           | 1  | 2014-12-31 | 1           | 0                             |\n| 1  | 2014-12-31 | 1           | 2  | 2015-01-01 | 10          | -8870                         |\n| 1  | 2014-12-31 | 1           | 3  | 2015-01-02 | 25          | -8871                         |\n| 2  | 2015-01-01 | 10          | 1  | 2014-12-31 | 1           | 8870                          |\n| 2  | 2015-01-01 | 10          | 2  | 2015-01-01 | 10          | 0                             |\n| 2  | 2015-01-01 | 10          | 3  | 2015-01-02 | 25          | -1                            |\n| 3  | 2015-01-02 | 25          | 1  | 2014-12-31 | 1           | 8871                          |\n| 3  | 2015-01-02 | 25          | 2  | 2015-01-01 | 10          | 1                             |\n| 3  | 2015-01-02 | 25          | 3  | 2015-01-02 | 25          | 0                             |\n"
                    },
                    {
                        "username": "suraj21193",
                        "content": "Its is running successfully but not able to submit!\\nSelect a.id\\nfrom \\n(Select id, temperature, lag(temperature) over(order by recordDate) as lt,\\ncase when temperature>lag(temperature) over(order by recordDate) then \\'High\\'\\nelse \\'Low\\'\\nend as \\'Status\\'\\nfrom Weather) a\\nwhere Status = \\'High\\';"
                    },
                    {
                        "username": "themanutdmaniac",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) the reason is that the test case has 2 dates with a day missing in between."
                    },
                    {
                        "username": "Palash5043",
                        "content": "\nselect x.Id from (\nselect Id,\n       recordDate,\n       temperature as temp,\n    lag(temperature,1) over(order by recordDate asc) as pre_day_temp\n    from weather) x\n    where x.temp>x.pre_day_temp;\n\nI am also facing the similar issue "
                    },
                    {
                        "username": "kashrex",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) test cases are failing because the dates have to be exact previous date. \"2000-12-14 |     |2000-12-16\"  have a date difference of more than 1 day."
                    },
                    {
                        "username": "jingpingyu1127",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) I think this is because that we are finding records with only 1 day difference. The records in the test case is using date with 2 days difference, which should not return anything for the output."
                    },
                    {
                        "username": "avinashkumarjha05",
                        "content": "mine too ... have u understood why the test case failing?\\n"
                    },
                    {
                        "username": "sandeep_kumar_75",
                        "content": "**SELECT a.id\\nFROM Weather a, Weather b\\nWHERE datediff(a.recordDate, b.recordDate) = 1\\nAND a.temperature > b.temperature;**"
                    },
                    {
                        "username": "themanutdmaniac",
                        "content": "Wow, what a solution. GOAT. amazing. all the best sandeep."
                    },
                    {
                        "username": "xudaiyanzi",
                        "content": "Hi everyone, I tried the query below. It works when I run MySQL, but it can not work when it is submitted.  Please help me. Thank you.\\n# Write your MySQL query statement below\\nSELECT y.id\\nFROM Weather x\\nLEFT JOIN Weather y ON x.Id +1 = y.Id\\nWHERE x.Temperature < y.Temperature\\n"
                    },
                    {
                        "username": "cassiellong1113",
                        "content": "date is not ascending sorted, and thus if you do not compare with dates but with ID, you may get wrong answer "
                    },
                    {
                        "username": "Avazbeka_dev",
                        "content": "SELECT a.id\\nFROM Weather as a,Weather as b\\nWHERE a.temperature>b.temperature\\nAND DATEDIFF(a.recordDate,b.recordDate)=1\\n\\nYou must check the datas !"
                    },
                    {
                        "username": "patnanavarun",
                        "content": "you are just checking the id values .But not comparing the dates.\\n"
                    },
                    {
                        "username": "snehanshu17",
                        "content": "with tmp as (\\nselect id ,RecordDate,Temperature,\\nLAG (Temperature,1) OVER (ORDER BY RecordDate) AS prev_Temperature,\\n    LAG (RecordDate,1) OVER (ORDER BY RecordDate) AS prev_RecordDate\\nfrom Weather)\\n\\nselect id  from tmp where Temperature>prev_Temperature and (RecordDate-prev_RecordDate)=1"
                    },
                    {
                        "username": "mr-xed",
                        "content": "Really interesting approach, except it didn\\'t work for me from the get go for some reason, how ever I was able to solve it using `dateDiff(RecordDate, prev_RecordDate)` instead of `(RecordDate-prev_RecordDate)`"
                    },
                    {
                        "username": "XinyiQiu",
                        "content": "WITH yesterday AS (SELECT id,recordDate,temperature,DATE_SUB(recordDate, INTERVAL 1 DAY) AS yesterday\\nFROM Weather)\\n\\nSELECT yesterday.id\\nFROM yesterday LEFT JOIN Weather on yesterday.yesterday = Weather.recordDate\\nWHERE Weather.temperature IS NOT NULL AND yesterday.temperature > Weather.temperature"
                    },
                    {
                        "username": "nasirxia",
                        "content": "the idea is brilliant but why make things complicated? There should be a reasons for doing this."
                    },
                    {
                        "username": "anand_vineet19",
                        "content": "# Write your MySQL query statement below\\nSELECT id\\nFROM\\n(\\nSELECT id, recordDate, temperature AS today_temp, LAG(temperature,1) OVER (ORDER BY recordDate) AS yesterday_temp, LAG(recordDate,1) OVER (ORDER BY recordDate) AS yes_date\\n\\nFROM Weather\\n) AS temp_table\\n\\nWHERE today_temp>yesterday_temp AND DATEDIFF(recordDate,yes_date)=1"
                    },
                    {
                        "username": "priyarb96",
                        "content": "Simple and neat query"
                    },
                    {
                        "username": "abebe_1983",
                        "content": "we need to rearrange this query a little bit as follows \\nwith CTE as (\\nselect\\nid,recordDate as [date], temperature as temp,\\nlag(temperature) over(order by recordDate,id) as prev_temp,\\nlag(recordDate) over(order by recordDate,id) as prev_date\\nfrom Weather\\n)\\n\\nselect\\nid\\nfrom CTE\\nwhere temp > prev_temp and datediff(day,  prev_date, [date] ) = 1\\n\\n\\n"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect a.id\\nfrom weather a\\ninner join weather b\\non datediff(day, b.recordDate, a.recordDate) = 1\\nand a.temperature > b.temperature\\n\\n2)\\nwith cte as\\n(select *, \\n        lag(temperature)over(order by recordDate) as perviousTemp,\\n        lag(recordDate)over(order by recordDate) as perviousDate\\nfrom weather)\\nselect id from cte where temperature > perviousTemp and datediff(day, perviousDate, recordDate) = 1"
                    },
                    {
                        "username": "ann1996015",
                        "content": "This is my code, i think it is very hard ==\\n\\nSELECT DISTINCT  w2.id\\nFROM Weather w1\\nLEFT JOIN Weather w2 ON ABS(DATEDIFF(day,w2.recordDate, w1.recordDate)) = 1\\nWHERE w2.temperature > w1.temperature and w2.recordDate>w1.recordDate"
                    }
                ]
            },
            {
                "id": 1576214,
                "content": [
                    {
                        "username": "frunfola1229",
                        "content": "\\n**SELECT**  w1.Id \\n**FROM**     Weather w1, Weather w2\\n**WHERE**   dateDiff(w1.Date,w2.Date) = 1        **AND**    w1.Temperature > w2.Temperature;"
                    },
                    {
                        "username": "Vipul_Chaudhary_2003",
                        "content": "Okay great.\nNow let's read rules together\n\nDiscussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jargolastik",
                        "content": "[@user8224IM](/user8224IM) self join creates every possible combination of columns so that means that you can just filter out the rows where the current temp is greater than yesterday\\'s"
                    },
                    {
                        "username": "JerryBlank",
                        "content": "[@user8224IM](/user8224IM) They have created 2 copies of the same table w1 and w2 and comparing each and every row. \\nSelecting only the ids for rows where \\nw1.date - w2.date =1 means that w1 is the date of next day to w2 (example: 2nd August - 1st August =1)\\nAND\\nw1.Temperature > w2.Temperature means Temperature on Date w1 is greater than Temperature on Date w2. \\n\\nso that would get Id with higher temperatures compared to its previous dates (yesterday).\\nHope this helps!"
                    },
                    {
                        "username": "user8224IM",
                        "content": "can you explain how/why this works please\\n"
                    },
                    {
                        "username": "chriszeng8",
                        "content": "Why is subtracting 1 directly from Date not working, but subdate(a.Date,1) works?\\n\\nMy code is \\n\\n    select W1.Id\\n    from Weather as W1, Weather as W2\\n    where W1.Date-1 = W2.Date and W1.Temperature> W2.Temperature\\n\\nit only passed 13/14 cases.\\n\\nHowever, when I changed `W1.Date-1` to `sub(W1.Date,1)` in the where clause, it worked. What is fundamental difference?"
                    },
                    {
                        "username": "Lysa123",
                        "content": "[@minhphamduy](/minhphamduy) cho m\\xECnh h\\u1ECFi v\\xEC sao ph\\u1EA3i c\\xF3 ch\\u1EEF subquery \\u1EDF cu\\u1ED1i v?\\n"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "I think you not should do that, use date_add instead\\n# Write your MySQL query statement below\\n\\nselect id\\nfrom (\\n    select w1.id\\n    from weather w1, weather w2\\n    where w1.recordDate= DATE_ADD(w2.recordDate, interval 1 day) and w1.temperature > w2.temperature\\n) subquery"
                    },
                    {
                        "username": "har0101",
                        "content": "date is not int"
                    },
                    {
                        "username": "291831388",
                        "content": "[@michaelniki](/michaelniki)  Thank your for your response, it really helps me."
                    },
                    {
                        "username": "michaelniki",
                        "content": "subtracting 1 does not work for the date at the end of the month or year.\nTake this test case for example:\n\n| id | recordDate | temperature |\n| -- | ---------- | ----------- |\n| 1  | 2014-12-31 | 1           |\n| 2  | 2015-01-01 | 10          |\n| 3  | 2015-01-02 | 25          |\n\nrecordDate of id 2 (2015-01-01) - 1 does not equal to  2014-12-31\n\n```\nselect\n    *\n    , w1.recordDate - w2.recordDate\nfrom\n    weather w1, weather w2\norder by w1.id\n\n```\n\n| id | recordDate | temperature | id | recordDate | temperature | w1.recordDate - w2.recordDate |\n| -- | ---------- | ----------- | -- | ---------- | ----------- | ----------------------------- |\n| 1  | 2014-12-31 | 1           | 1  | 2014-12-31 | 1           | 0                             |\n| 1  | 2014-12-31 | 1           | 2  | 2015-01-01 | 10          | -8870                         |\n| 1  | 2014-12-31 | 1           | 3  | 2015-01-02 | 25          | -8871                         |\n| 2  | 2015-01-01 | 10          | 1  | 2014-12-31 | 1           | 8870                          |\n| 2  | 2015-01-01 | 10          | 2  | 2015-01-01 | 10          | 0                             |\n| 2  | 2015-01-01 | 10          | 3  | 2015-01-02 | 25          | -1                            |\n| 3  | 2015-01-02 | 25          | 1  | 2014-12-31 | 1           | 8871                          |\n| 3  | 2015-01-02 | 25          | 2  | 2015-01-01 | 10          | 1                             |\n| 3  | 2015-01-02 | 25          | 3  | 2015-01-02 | 25          | 0                             |\n"
                    },
                    {
                        "username": "suraj21193",
                        "content": "Its is running successfully but not able to submit!\\nSelect a.id\\nfrom \\n(Select id, temperature, lag(temperature) over(order by recordDate) as lt,\\ncase when temperature>lag(temperature) over(order by recordDate) then \\'High\\'\\nelse \\'Low\\'\\nend as \\'Status\\'\\nfrom Weather) a\\nwhere Status = \\'High\\';"
                    },
                    {
                        "username": "themanutdmaniac",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) the reason is that the test case has 2 dates with a day missing in between."
                    },
                    {
                        "username": "Palash5043",
                        "content": "\nselect x.Id from (\nselect Id,\n       recordDate,\n       temperature as temp,\n    lag(temperature,1) over(order by recordDate asc) as pre_day_temp\n    from weather) x\n    where x.temp>x.pre_day_temp;\n\nI am also facing the similar issue "
                    },
                    {
                        "username": "kashrex",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) test cases are failing because the dates have to be exact previous date. \"2000-12-14 |     |2000-12-16\"  have a date difference of more than 1 day."
                    },
                    {
                        "username": "jingpingyu1127",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) I think this is because that we are finding records with only 1 day difference. The records in the test case is using date with 2 days difference, which should not return anything for the output."
                    },
                    {
                        "username": "avinashkumarjha05",
                        "content": "mine too ... have u understood why the test case failing?\\n"
                    },
                    {
                        "username": "sandeep_kumar_75",
                        "content": "**SELECT a.id\\nFROM Weather a, Weather b\\nWHERE datediff(a.recordDate, b.recordDate) = 1\\nAND a.temperature > b.temperature;**"
                    },
                    {
                        "username": "themanutdmaniac",
                        "content": "Wow, what a solution. GOAT. amazing. all the best sandeep."
                    },
                    {
                        "username": "xudaiyanzi",
                        "content": "Hi everyone, I tried the query below. It works when I run MySQL, but it can not work when it is submitted.  Please help me. Thank you.\\n# Write your MySQL query statement below\\nSELECT y.id\\nFROM Weather x\\nLEFT JOIN Weather y ON x.Id +1 = y.Id\\nWHERE x.Temperature < y.Temperature\\n"
                    },
                    {
                        "username": "cassiellong1113",
                        "content": "date is not ascending sorted, and thus if you do not compare with dates but with ID, you may get wrong answer "
                    },
                    {
                        "username": "Avazbeka_dev",
                        "content": "SELECT a.id\\nFROM Weather as a,Weather as b\\nWHERE a.temperature>b.temperature\\nAND DATEDIFF(a.recordDate,b.recordDate)=1\\n\\nYou must check the datas !"
                    },
                    {
                        "username": "patnanavarun",
                        "content": "you are just checking the id values .But not comparing the dates.\\n"
                    },
                    {
                        "username": "snehanshu17",
                        "content": "with tmp as (\\nselect id ,RecordDate,Temperature,\\nLAG (Temperature,1) OVER (ORDER BY RecordDate) AS prev_Temperature,\\n    LAG (RecordDate,1) OVER (ORDER BY RecordDate) AS prev_RecordDate\\nfrom Weather)\\n\\nselect id  from tmp where Temperature>prev_Temperature and (RecordDate-prev_RecordDate)=1"
                    },
                    {
                        "username": "mr-xed",
                        "content": "Really interesting approach, except it didn\\'t work for me from the get go for some reason, how ever I was able to solve it using `dateDiff(RecordDate, prev_RecordDate)` instead of `(RecordDate-prev_RecordDate)`"
                    },
                    {
                        "username": "XinyiQiu",
                        "content": "WITH yesterday AS (SELECT id,recordDate,temperature,DATE_SUB(recordDate, INTERVAL 1 DAY) AS yesterday\\nFROM Weather)\\n\\nSELECT yesterday.id\\nFROM yesterday LEFT JOIN Weather on yesterday.yesterday = Weather.recordDate\\nWHERE Weather.temperature IS NOT NULL AND yesterday.temperature > Weather.temperature"
                    },
                    {
                        "username": "nasirxia",
                        "content": "the idea is brilliant but why make things complicated? There should be a reasons for doing this."
                    },
                    {
                        "username": "anand_vineet19",
                        "content": "# Write your MySQL query statement below\\nSELECT id\\nFROM\\n(\\nSELECT id, recordDate, temperature AS today_temp, LAG(temperature,1) OVER (ORDER BY recordDate) AS yesterday_temp, LAG(recordDate,1) OVER (ORDER BY recordDate) AS yes_date\\n\\nFROM Weather\\n) AS temp_table\\n\\nWHERE today_temp>yesterday_temp AND DATEDIFF(recordDate,yes_date)=1"
                    },
                    {
                        "username": "priyarb96",
                        "content": "Simple and neat query"
                    },
                    {
                        "username": "abebe_1983",
                        "content": "we need to rearrange this query a little bit as follows \\nwith CTE as (\\nselect\\nid,recordDate as [date], temperature as temp,\\nlag(temperature) over(order by recordDate,id) as prev_temp,\\nlag(recordDate) over(order by recordDate,id) as prev_date\\nfrom Weather\\n)\\n\\nselect\\nid\\nfrom CTE\\nwhere temp > prev_temp and datediff(day,  prev_date, [date] ) = 1\\n\\n\\n"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect a.id\\nfrom weather a\\ninner join weather b\\non datediff(day, b.recordDate, a.recordDate) = 1\\nand a.temperature > b.temperature\\n\\n2)\\nwith cte as\\n(select *, \\n        lag(temperature)over(order by recordDate) as perviousTemp,\\n        lag(recordDate)over(order by recordDate) as perviousDate\\nfrom weather)\\nselect id from cte where temperature > perviousTemp and datediff(day, perviousDate, recordDate) = 1"
                    },
                    {
                        "username": "ann1996015",
                        "content": "This is my code, i think it is very hard ==\\n\\nSELECT DISTINCT  w2.id\\nFROM Weather w1\\nLEFT JOIN Weather w2 ON ABS(DATEDIFF(day,w2.recordDate, w1.recordDate)) = 1\\nWHERE w2.temperature > w1.temperature and w2.recordDate>w1.recordDate"
                    }
                ]
            },
            {
                "id": 1576015,
                "content": [
                    {
                        "username": "frunfola1229",
                        "content": "\\n**SELECT**  w1.Id \\n**FROM**     Weather w1, Weather w2\\n**WHERE**   dateDiff(w1.Date,w2.Date) = 1        **AND**    w1.Temperature > w2.Temperature;"
                    },
                    {
                        "username": "Vipul_Chaudhary_2003",
                        "content": "Okay great.\nNow let's read rules together\n\nDiscussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jargolastik",
                        "content": "[@user8224IM](/user8224IM) self join creates every possible combination of columns so that means that you can just filter out the rows where the current temp is greater than yesterday\\'s"
                    },
                    {
                        "username": "JerryBlank",
                        "content": "[@user8224IM](/user8224IM) They have created 2 copies of the same table w1 and w2 and comparing each and every row. \\nSelecting only the ids for rows where \\nw1.date - w2.date =1 means that w1 is the date of next day to w2 (example: 2nd August - 1st August =1)\\nAND\\nw1.Temperature > w2.Temperature means Temperature on Date w1 is greater than Temperature on Date w2. \\n\\nso that would get Id with higher temperatures compared to its previous dates (yesterday).\\nHope this helps!"
                    },
                    {
                        "username": "user8224IM",
                        "content": "can you explain how/why this works please\\n"
                    },
                    {
                        "username": "chriszeng8",
                        "content": "Why is subtracting 1 directly from Date not working, but subdate(a.Date,1) works?\\n\\nMy code is \\n\\n    select W1.Id\\n    from Weather as W1, Weather as W2\\n    where W1.Date-1 = W2.Date and W1.Temperature> W2.Temperature\\n\\nit only passed 13/14 cases.\\n\\nHowever, when I changed `W1.Date-1` to `sub(W1.Date,1)` in the where clause, it worked. What is fundamental difference?"
                    },
                    {
                        "username": "Lysa123",
                        "content": "[@minhphamduy](/minhphamduy) cho m\\xECnh h\\u1ECFi v\\xEC sao ph\\u1EA3i c\\xF3 ch\\u1EEF subquery \\u1EDF cu\\u1ED1i v?\\n"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "I think you not should do that, use date_add instead\\n# Write your MySQL query statement below\\n\\nselect id\\nfrom (\\n    select w1.id\\n    from weather w1, weather w2\\n    where w1.recordDate= DATE_ADD(w2.recordDate, interval 1 day) and w1.temperature > w2.temperature\\n) subquery"
                    },
                    {
                        "username": "har0101",
                        "content": "date is not int"
                    },
                    {
                        "username": "291831388",
                        "content": "[@michaelniki](/michaelniki)  Thank your for your response, it really helps me."
                    },
                    {
                        "username": "michaelniki",
                        "content": "subtracting 1 does not work for the date at the end of the month or year.\nTake this test case for example:\n\n| id | recordDate | temperature |\n| -- | ---------- | ----------- |\n| 1  | 2014-12-31 | 1           |\n| 2  | 2015-01-01 | 10          |\n| 3  | 2015-01-02 | 25          |\n\nrecordDate of id 2 (2015-01-01) - 1 does not equal to  2014-12-31\n\n```\nselect\n    *\n    , w1.recordDate - w2.recordDate\nfrom\n    weather w1, weather w2\norder by w1.id\n\n```\n\n| id | recordDate | temperature | id | recordDate | temperature | w1.recordDate - w2.recordDate |\n| -- | ---------- | ----------- | -- | ---------- | ----------- | ----------------------------- |\n| 1  | 2014-12-31 | 1           | 1  | 2014-12-31 | 1           | 0                             |\n| 1  | 2014-12-31 | 1           | 2  | 2015-01-01 | 10          | -8870                         |\n| 1  | 2014-12-31 | 1           | 3  | 2015-01-02 | 25          | -8871                         |\n| 2  | 2015-01-01 | 10          | 1  | 2014-12-31 | 1           | 8870                          |\n| 2  | 2015-01-01 | 10          | 2  | 2015-01-01 | 10          | 0                             |\n| 2  | 2015-01-01 | 10          | 3  | 2015-01-02 | 25          | -1                            |\n| 3  | 2015-01-02 | 25          | 1  | 2014-12-31 | 1           | 8871                          |\n| 3  | 2015-01-02 | 25          | 2  | 2015-01-01 | 10          | 1                             |\n| 3  | 2015-01-02 | 25          | 3  | 2015-01-02 | 25          | 0                             |\n"
                    },
                    {
                        "username": "suraj21193",
                        "content": "Its is running successfully but not able to submit!\\nSelect a.id\\nfrom \\n(Select id, temperature, lag(temperature) over(order by recordDate) as lt,\\ncase when temperature>lag(temperature) over(order by recordDate) then \\'High\\'\\nelse \\'Low\\'\\nend as \\'Status\\'\\nfrom Weather) a\\nwhere Status = \\'High\\';"
                    },
                    {
                        "username": "themanutdmaniac",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) the reason is that the test case has 2 dates with a day missing in between."
                    },
                    {
                        "username": "Palash5043",
                        "content": "\nselect x.Id from (\nselect Id,\n       recordDate,\n       temperature as temp,\n    lag(temperature,1) over(order by recordDate asc) as pre_day_temp\n    from weather) x\n    where x.temp>x.pre_day_temp;\n\nI am also facing the similar issue "
                    },
                    {
                        "username": "kashrex",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) test cases are failing because the dates have to be exact previous date. \"2000-12-14 |     |2000-12-16\"  have a date difference of more than 1 day."
                    },
                    {
                        "username": "jingpingyu1127",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) I think this is because that we are finding records with only 1 day difference. The records in the test case is using date with 2 days difference, which should not return anything for the output."
                    },
                    {
                        "username": "avinashkumarjha05",
                        "content": "mine too ... have u understood why the test case failing?\\n"
                    },
                    {
                        "username": "sandeep_kumar_75",
                        "content": "**SELECT a.id\\nFROM Weather a, Weather b\\nWHERE datediff(a.recordDate, b.recordDate) = 1\\nAND a.temperature > b.temperature;**"
                    },
                    {
                        "username": "themanutdmaniac",
                        "content": "Wow, what a solution. GOAT. amazing. all the best sandeep."
                    },
                    {
                        "username": "xudaiyanzi",
                        "content": "Hi everyone, I tried the query below. It works when I run MySQL, but it can not work when it is submitted.  Please help me. Thank you.\\n# Write your MySQL query statement below\\nSELECT y.id\\nFROM Weather x\\nLEFT JOIN Weather y ON x.Id +1 = y.Id\\nWHERE x.Temperature < y.Temperature\\n"
                    },
                    {
                        "username": "cassiellong1113",
                        "content": "date is not ascending sorted, and thus if you do not compare with dates but with ID, you may get wrong answer "
                    },
                    {
                        "username": "Avazbeka_dev",
                        "content": "SELECT a.id\\nFROM Weather as a,Weather as b\\nWHERE a.temperature>b.temperature\\nAND DATEDIFF(a.recordDate,b.recordDate)=1\\n\\nYou must check the datas !"
                    },
                    {
                        "username": "patnanavarun",
                        "content": "you are just checking the id values .But not comparing the dates.\\n"
                    },
                    {
                        "username": "snehanshu17",
                        "content": "with tmp as (\\nselect id ,RecordDate,Temperature,\\nLAG (Temperature,1) OVER (ORDER BY RecordDate) AS prev_Temperature,\\n    LAG (RecordDate,1) OVER (ORDER BY RecordDate) AS prev_RecordDate\\nfrom Weather)\\n\\nselect id  from tmp where Temperature>prev_Temperature and (RecordDate-prev_RecordDate)=1"
                    },
                    {
                        "username": "mr-xed",
                        "content": "Really interesting approach, except it didn\\'t work for me from the get go for some reason, how ever I was able to solve it using `dateDiff(RecordDate, prev_RecordDate)` instead of `(RecordDate-prev_RecordDate)`"
                    },
                    {
                        "username": "XinyiQiu",
                        "content": "WITH yesterday AS (SELECT id,recordDate,temperature,DATE_SUB(recordDate, INTERVAL 1 DAY) AS yesterday\\nFROM Weather)\\n\\nSELECT yesterday.id\\nFROM yesterday LEFT JOIN Weather on yesterday.yesterday = Weather.recordDate\\nWHERE Weather.temperature IS NOT NULL AND yesterday.temperature > Weather.temperature"
                    },
                    {
                        "username": "nasirxia",
                        "content": "the idea is brilliant but why make things complicated? There should be a reasons for doing this."
                    },
                    {
                        "username": "anand_vineet19",
                        "content": "# Write your MySQL query statement below\\nSELECT id\\nFROM\\n(\\nSELECT id, recordDate, temperature AS today_temp, LAG(temperature,1) OVER (ORDER BY recordDate) AS yesterday_temp, LAG(recordDate,1) OVER (ORDER BY recordDate) AS yes_date\\n\\nFROM Weather\\n) AS temp_table\\n\\nWHERE today_temp>yesterday_temp AND DATEDIFF(recordDate,yes_date)=1"
                    },
                    {
                        "username": "priyarb96",
                        "content": "Simple and neat query"
                    },
                    {
                        "username": "abebe_1983",
                        "content": "we need to rearrange this query a little bit as follows \\nwith CTE as (\\nselect\\nid,recordDate as [date], temperature as temp,\\nlag(temperature) over(order by recordDate,id) as prev_temp,\\nlag(recordDate) over(order by recordDate,id) as prev_date\\nfrom Weather\\n)\\n\\nselect\\nid\\nfrom CTE\\nwhere temp > prev_temp and datediff(day,  prev_date, [date] ) = 1\\n\\n\\n"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect a.id\\nfrom weather a\\ninner join weather b\\non datediff(day, b.recordDate, a.recordDate) = 1\\nand a.temperature > b.temperature\\n\\n2)\\nwith cte as\\n(select *, \\n        lag(temperature)over(order by recordDate) as perviousTemp,\\n        lag(recordDate)over(order by recordDate) as perviousDate\\nfrom weather)\\nselect id from cte where temperature > perviousTemp and datediff(day, perviousDate, recordDate) = 1"
                    },
                    {
                        "username": "ann1996015",
                        "content": "This is my code, i think it is very hard ==\\n\\nSELECT DISTINCT  w2.id\\nFROM Weather w1\\nLEFT JOIN Weather w2 ON ABS(DATEDIFF(day,w2.recordDate, w1.recordDate)) = 1\\nWHERE w2.temperature > w1.temperature and w2.recordDate>w1.recordDate"
                    }
                ]
            },
            {
                "id": 1576857,
                "content": [
                    {
                        "username": "frunfola1229",
                        "content": "\\n**SELECT**  w1.Id \\n**FROM**     Weather w1, Weather w2\\n**WHERE**   dateDiff(w1.Date,w2.Date) = 1        **AND**    w1.Temperature > w2.Temperature;"
                    },
                    {
                        "username": "Vipul_Chaudhary_2003",
                        "content": "Okay great.\nNow let's read rules together\n\nDiscussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jargolastik",
                        "content": "[@user8224IM](/user8224IM) self join creates every possible combination of columns so that means that you can just filter out the rows where the current temp is greater than yesterday\\'s"
                    },
                    {
                        "username": "JerryBlank",
                        "content": "[@user8224IM](/user8224IM) They have created 2 copies of the same table w1 and w2 and comparing each and every row. \\nSelecting only the ids for rows where \\nw1.date - w2.date =1 means that w1 is the date of next day to w2 (example: 2nd August - 1st August =1)\\nAND\\nw1.Temperature > w2.Temperature means Temperature on Date w1 is greater than Temperature on Date w2. \\n\\nso that would get Id with higher temperatures compared to its previous dates (yesterday).\\nHope this helps!"
                    },
                    {
                        "username": "user8224IM",
                        "content": "can you explain how/why this works please\\n"
                    },
                    {
                        "username": "chriszeng8",
                        "content": "Why is subtracting 1 directly from Date not working, but subdate(a.Date,1) works?\\n\\nMy code is \\n\\n    select W1.Id\\n    from Weather as W1, Weather as W2\\n    where W1.Date-1 = W2.Date and W1.Temperature> W2.Temperature\\n\\nit only passed 13/14 cases.\\n\\nHowever, when I changed `W1.Date-1` to `sub(W1.Date,1)` in the where clause, it worked. What is fundamental difference?"
                    },
                    {
                        "username": "Lysa123",
                        "content": "[@minhphamduy](/minhphamduy) cho m\\xECnh h\\u1ECFi v\\xEC sao ph\\u1EA3i c\\xF3 ch\\u1EEF subquery \\u1EDF cu\\u1ED1i v?\\n"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "I think you not should do that, use date_add instead\\n# Write your MySQL query statement below\\n\\nselect id\\nfrom (\\n    select w1.id\\n    from weather w1, weather w2\\n    where w1.recordDate= DATE_ADD(w2.recordDate, interval 1 day) and w1.temperature > w2.temperature\\n) subquery"
                    },
                    {
                        "username": "har0101",
                        "content": "date is not int"
                    },
                    {
                        "username": "291831388",
                        "content": "[@michaelniki](/michaelniki)  Thank your for your response, it really helps me."
                    },
                    {
                        "username": "michaelniki",
                        "content": "subtracting 1 does not work for the date at the end of the month or year.\nTake this test case for example:\n\n| id | recordDate | temperature |\n| -- | ---------- | ----------- |\n| 1  | 2014-12-31 | 1           |\n| 2  | 2015-01-01 | 10          |\n| 3  | 2015-01-02 | 25          |\n\nrecordDate of id 2 (2015-01-01) - 1 does not equal to  2014-12-31\n\n```\nselect\n    *\n    , w1.recordDate - w2.recordDate\nfrom\n    weather w1, weather w2\norder by w1.id\n\n```\n\n| id | recordDate | temperature | id | recordDate | temperature | w1.recordDate - w2.recordDate |\n| -- | ---------- | ----------- | -- | ---------- | ----------- | ----------------------------- |\n| 1  | 2014-12-31 | 1           | 1  | 2014-12-31 | 1           | 0                             |\n| 1  | 2014-12-31 | 1           | 2  | 2015-01-01 | 10          | -8870                         |\n| 1  | 2014-12-31 | 1           | 3  | 2015-01-02 | 25          | -8871                         |\n| 2  | 2015-01-01 | 10          | 1  | 2014-12-31 | 1           | 8870                          |\n| 2  | 2015-01-01 | 10          | 2  | 2015-01-01 | 10          | 0                             |\n| 2  | 2015-01-01 | 10          | 3  | 2015-01-02 | 25          | -1                            |\n| 3  | 2015-01-02 | 25          | 1  | 2014-12-31 | 1           | 8871                          |\n| 3  | 2015-01-02 | 25          | 2  | 2015-01-01 | 10          | 1                             |\n| 3  | 2015-01-02 | 25          | 3  | 2015-01-02 | 25          | 0                             |\n"
                    },
                    {
                        "username": "suraj21193",
                        "content": "Its is running successfully but not able to submit!\\nSelect a.id\\nfrom \\n(Select id, temperature, lag(temperature) over(order by recordDate) as lt,\\ncase when temperature>lag(temperature) over(order by recordDate) then \\'High\\'\\nelse \\'Low\\'\\nend as \\'Status\\'\\nfrom Weather) a\\nwhere Status = \\'High\\';"
                    },
                    {
                        "username": "themanutdmaniac",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) the reason is that the test case has 2 dates with a day missing in between."
                    },
                    {
                        "username": "Palash5043",
                        "content": "\nselect x.Id from (\nselect Id,\n       recordDate,\n       temperature as temp,\n    lag(temperature,1) over(order by recordDate asc) as pre_day_temp\n    from weather) x\n    where x.temp>x.pre_day_temp;\n\nI am also facing the similar issue "
                    },
                    {
                        "username": "kashrex",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) test cases are failing because the dates have to be exact previous date. \"2000-12-14 |     |2000-12-16\"  have a date difference of more than 1 day."
                    },
                    {
                        "username": "jingpingyu1127",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) I think this is because that we are finding records with only 1 day difference. The records in the test case is using date with 2 days difference, which should not return anything for the output."
                    },
                    {
                        "username": "avinashkumarjha05",
                        "content": "mine too ... have u understood why the test case failing?\\n"
                    },
                    {
                        "username": "sandeep_kumar_75",
                        "content": "**SELECT a.id\\nFROM Weather a, Weather b\\nWHERE datediff(a.recordDate, b.recordDate) = 1\\nAND a.temperature > b.temperature;**"
                    },
                    {
                        "username": "themanutdmaniac",
                        "content": "Wow, what a solution. GOAT. amazing. all the best sandeep."
                    },
                    {
                        "username": "xudaiyanzi",
                        "content": "Hi everyone, I tried the query below. It works when I run MySQL, but it can not work when it is submitted.  Please help me. Thank you.\\n# Write your MySQL query statement below\\nSELECT y.id\\nFROM Weather x\\nLEFT JOIN Weather y ON x.Id +1 = y.Id\\nWHERE x.Temperature < y.Temperature\\n"
                    },
                    {
                        "username": "cassiellong1113",
                        "content": "date is not ascending sorted, and thus if you do not compare with dates but with ID, you may get wrong answer "
                    },
                    {
                        "username": "Avazbeka_dev",
                        "content": "SELECT a.id\\nFROM Weather as a,Weather as b\\nWHERE a.temperature>b.temperature\\nAND DATEDIFF(a.recordDate,b.recordDate)=1\\n\\nYou must check the datas !"
                    },
                    {
                        "username": "patnanavarun",
                        "content": "you are just checking the id values .But not comparing the dates.\\n"
                    },
                    {
                        "username": "snehanshu17",
                        "content": "with tmp as (\\nselect id ,RecordDate,Temperature,\\nLAG (Temperature,1) OVER (ORDER BY RecordDate) AS prev_Temperature,\\n    LAG (RecordDate,1) OVER (ORDER BY RecordDate) AS prev_RecordDate\\nfrom Weather)\\n\\nselect id  from tmp where Temperature>prev_Temperature and (RecordDate-prev_RecordDate)=1"
                    },
                    {
                        "username": "mr-xed",
                        "content": "Really interesting approach, except it didn\\'t work for me from the get go for some reason, how ever I was able to solve it using `dateDiff(RecordDate, prev_RecordDate)` instead of `(RecordDate-prev_RecordDate)`"
                    },
                    {
                        "username": "XinyiQiu",
                        "content": "WITH yesterday AS (SELECT id,recordDate,temperature,DATE_SUB(recordDate, INTERVAL 1 DAY) AS yesterday\\nFROM Weather)\\n\\nSELECT yesterday.id\\nFROM yesterday LEFT JOIN Weather on yesterday.yesterday = Weather.recordDate\\nWHERE Weather.temperature IS NOT NULL AND yesterday.temperature > Weather.temperature"
                    },
                    {
                        "username": "nasirxia",
                        "content": "the idea is brilliant but why make things complicated? There should be a reasons for doing this."
                    },
                    {
                        "username": "anand_vineet19",
                        "content": "# Write your MySQL query statement below\\nSELECT id\\nFROM\\n(\\nSELECT id, recordDate, temperature AS today_temp, LAG(temperature,1) OVER (ORDER BY recordDate) AS yesterday_temp, LAG(recordDate,1) OVER (ORDER BY recordDate) AS yes_date\\n\\nFROM Weather\\n) AS temp_table\\n\\nWHERE today_temp>yesterday_temp AND DATEDIFF(recordDate,yes_date)=1"
                    },
                    {
                        "username": "priyarb96",
                        "content": "Simple and neat query"
                    },
                    {
                        "username": "abebe_1983",
                        "content": "we need to rearrange this query a little bit as follows \\nwith CTE as (\\nselect\\nid,recordDate as [date], temperature as temp,\\nlag(temperature) over(order by recordDate,id) as prev_temp,\\nlag(recordDate) over(order by recordDate,id) as prev_date\\nfrom Weather\\n)\\n\\nselect\\nid\\nfrom CTE\\nwhere temp > prev_temp and datediff(day,  prev_date, [date] ) = 1\\n\\n\\n"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect a.id\\nfrom weather a\\ninner join weather b\\non datediff(day, b.recordDate, a.recordDate) = 1\\nand a.temperature > b.temperature\\n\\n2)\\nwith cte as\\n(select *, \\n        lag(temperature)over(order by recordDate) as perviousTemp,\\n        lag(recordDate)over(order by recordDate) as perviousDate\\nfrom weather)\\nselect id from cte where temperature > perviousTemp and datediff(day, perviousDate, recordDate) = 1"
                    },
                    {
                        "username": "ann1996015",
                        "content": "This is my code, i think it is very hard ==\\n\\nSELECT DISTINCT  w2.id\\nFROM Weather w1\\nLEFT JOIN Weather w2 ON ABS(DATEDIFF(day,w2.recordDate, w1.recordDate)) = 1\\nWHERE w2.temperature > w1.temperature and w2.recordDate>w1.recordDate"
                    }
                ]
            },
            {
                "id": 1883213,
                "content": [
                    {
                        "username": "frunfola1229",
                        "content": "\\n**SELECT**  w1.Id \\n**FROM**     Weather w1, Weather w2\\n**WHERE**   dateDiff(w1.Date,w2.Date) = 1        **AND**    w1.Temperature > w2.Temperature;"
                    },
                    {
                        "username": "Vipul_Chaudhary_2003",
                        "content": "Okay great.\nNow let's read rules together\n\nDiscussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jargolastik",
                        "content": "[@user8224IM](/user8224IM) self join creates every possible combination of columns so that means that you can just filter out the rows where the current temp is greater than yesterday\\'s"
                    },
                    {
                        "username": "JerryBlank",
                        "content": "[@user8224IM](/user8224IM) They have created 2 copies of the same table w1 and w2 and comparing each and every row. \\nSelecting only the ids for rows where \\nw1.date - w2.date =1 means that w1 is the date of next day to w2 (example: 2nd August - 1st August =1)\\nAND\\nw1.Temperature > w2.Temperature means Temperature on Date w1 is greater than Temperature on Date w2. \\n\\nso that would get Id with higher temperatures compared to its previous dates (yesterday).\\nHope this helps!"
                    },
                    {
                        "username": "user8224IM",
                        "content": "can you explain how/why this works please\\n"
                    },
                    {
                        "username": "chriszeng8",
                        "content": "Why is subtracting 1 directly from Date not working, but subdate(a.Date,1) works?\\n\\nMy code is \\n\\n    select W1.Id\\n    from Weather as W1, Weather as W2\\n    where W1.Date-1 = W2.Date and W1.Temperature> W2.Temperature\\n\\nit only passed 13/14 cases.\\n\\nHowever, when I changed `W1.Date-1` to `sub(W1.Date,1)` in the where clause, it worked. What is fundamental difference?"
                    },
                    {
                        "username": "Lysa123",
                        "content": "[@minhphamduy](/minhphamduy) cho m\\xECnh h\\u1ECFi v\\xEC sao ph\\u1EA3i c\\xF3 ch\\u1EEF subquery \\u1EDF cu\\u1ED1i v?\\n"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "I think you not should do that, use date_add instead\\n# Write your MySQL query statement below\\n\\nselect id\\nfrom (\\n    select w1.id\\n    from weather w1, weather w2\\n    where w1.recordDate= DATE_ADD(w2.recordDate, interval 1 day) and w1.temperature > w2.temperature\\n) subquery"
                    },
                    {
                        "username": "har0101",
                        "content": "date is not int"
                    },
                    {
                        "username": "291831388",
                        "content": "[@michaelniki](/michaelniki)  Thank your for your response, it really helps me."
                    },
                    {
                        "username": "michaelniki",
                        "content": "subtracting 1 does not work for the date at the end of the month or year.\nTake this test case for example:\n\n| id | recordDate | temperature |\n| -- | ---------- | ----------- |\n| 1  | 2014-12-31 | 1           |\n| 2  | 2015-01-01 | 10          |\n| 3  | 2015-01-02 | 25          |\n\nrecordDate of id 2 (2015-01-01) - 1 does not equal to  2014-12-31\n\n```\nselect\n    *\n    , w1.recordDate - w2.recordDate\nfrom\n    weather w1, weather w2\norder by w1.id\n\n```\n\n| id | recordDate | temperature | id | recordDate | temperature | w1.recordDate - w2.recordDate |\n| -- | ---------- | ----------- | -- | ---------- | ----------- | ----------------------------- |\n| 1  | 2014-12-31 | 1           | 1  | 2014-12-31 | 1           | 0                             |\n| 1  | 2014-12-31 | 1           | 2  | 2015-01-01 | 10          | -8870                         |\n| 1  | 2014-12-31 | 1           | 3  | 2015-01-02 | 25          | -8871                         |\n| 2  | 2015-01-01 | 10          | 1  | 2014-12-31 | 1           | 8870                          |\n| 2  | 2015-01-01 | 10          | 2  | 2015-01-01 | 10          | 0                             |\n| 2  | 2015-01-01 | 10          | 3  | 2015-01-02 | 25          | -1                            |\n| 3  | 2015-01-02 | 25          | 1  | 2014-12-31 | 1           | 8871                          |\n| 3  | 2015-01-02 | 25          | 2  | 2015-01-01 | 10          | 1                             |\n| 3  | 2015-01-02 | 25          | 3  | 2015-01-02 | 25          | 0                             |\n"
                    },
                    {
                        "username": "suraj21193",
                        "content": "Its is running successfully but not able to submit!\\nSelect a.id\\nfrom \\n(Select id, temperature, lag(temperature) over(order by recordDate) as lt,\\ncase when temperature>lag(temperature) over(order by recordDate) then \\'High\\'\\nelse \\'Low\\'\\nend as \\'Status\\'\\nfrom Weather) a\\nwhere Status = \\'High\\';"
                    },
                    {
                        "username": "themanutdmaniac",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) the reason is that the test case has 2 dates with a day missing in between."
                    },
                    {
                        "username": "Palash5043",
                        "content": "\nselect x.Id from (\nselect Id,\n       recordDate,\n       temperature as temp,\n    lag(temperature,1) over(order by recordDate asc) as pre_day_temp\n    from weather) x\n    where x.temp>x.pre_day_temp;\n\nI am also facing the similar issue "
                    },
                    {
                        "username": "kashrex",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) test cases are failing because the dates have to be exact previous date. \"2000-12-14 |     |2000-12-16\"  have a date difference of more than 1 day."
                    },
                    {
                        "username": "jingpingyu1127",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) I think this is because that we are finding records with only 1 day difference. The records in the test case is using date with 2 days difference, which should not return anything for the output."
                    },
                    {
                        "username": "avinashkumarjha05",
                        "content": "mine too ... have u understood why the test case failing?\\n"
                    },
                    {
                        "username": "sandeep_kumar_75",
                        "content": "**SELECT a.id\\nFROM Weather a, Weather b\\nWHERE datediff(a.recordDate, b.recordDate) = 1\\nAND a.temperature > b.temperature;**"
                    },
                    {
                        "username": "themanutdmaniac",
                        "content": "Wow, what a solution. GOAT. amazing. all the best sandeep."
                    },
                    {
                        "username": "xudaiyanzi",
                        "content": "Hi everyone, I tried the query below. It works when I run MySQL, but it can not work when it is submitted.  Please help me. Thank you.\\n# Write your MySQL query statement below\\nSELECT y.id\\nFROM Weather x\\nLEFT JOIN Weather y ON x.Id +1 = y.Id\\nWHERE x.Temperature < y.Temperature\\n"
                    },
                    {
                        "username": "cassiellong1113",
                        "content": "date is not ascending sorted, and thus if you do not compare with dates but with ID, you may get wrong answer "
                    },
                    {
                        "username": "Avazbeka_dev",
                        "content": "SELECT a.id\\nFROM Weather as a,Weather as b\\nWHERE a.temperature>b.temperature\\nAND DATEDIFF(a.recordDate,b.recordDate)=1\\n\\nYou must check the datas !"
                    },
                    {
                        "username": "patnanavarun",
                        "content": "you are just checking the id values .But not comparing the dates.\\n"
                    },
                    {
                        "username": "snehanshu17",
                        "content": "with tmp as (\\nselect id ,RecordDate,Temperature,\\nLAG (Temperature,1) OVER (ORDER BY RecordDate) AS prev_Temperature,\\n    LAG (RecordDate,1) OVER (ORDER BY RecordDate) AS prev_RecordDate\\nfrom Weather)\\n\\nselect id  from tmp where Temperature>prev_Temperature and (RecordDate-prev_RecordDate)=1"
                    },
                    {
                        "username": "mr-xed",
                        "content": "Really interesting approach, except it didn\\'t work for me from the get go for some reason, how ever I was able to solve it using `dateDiff(RecordDate, prev_RecordDate)` instead of `(RecordDate-prev_RecordDate)`"
                    },
                    {
                        "username": "XinyiQiu",
                        "content": "WITH yesterday AS (SELECT id,recordDate,temperature,DATE_SUB(recordDate, INTERVAL 1 DAY) AS yesterday\\nFROM Weather)\\n\\nSELECT yesterday.id\\nFROM yesterday LEFT JOIN Weather on yesterday.yesterday = Weather.recordDate\\nWHERE Weather.temperature IS NOT NULL AND yesterday.temperature > Weather.temperature"
                    },
                    {
                        "username": "nasirxia",
                        "content": "the idea is brilliant but why make things complicated? There should be a reasons for doing this."
                    },
                    {
                        "username": "anand_vineet19",
                        "content": "# Write your MySQL query statement below\\nSELECT id\\nFROM\\n(\\nSELECT id, recordDate, temperature AS today_temp, LAG(temperature,1) OVER (ORDER BY recordDate) AS yesterday_temp, LAG(recordDate,1) OVER (ORDER BY recordDate) AS yes_date\\n\\nFROM Weather\\n) AS temp_table\\n\\nWHERE today_temp>yesterday_temp AND DATEDIFF(recordDate,yes_date)=1"
                    },
                    {
                        "username": "priyarb96",
                        "content": "Simple and neat query"
                    },
                    {
                        "username": "abebe_1983",
                        "content": "we need to rearrange this query a little bit as follows \\nwith CTE as (\\nselect\\nid,recordDate as [date], temperature as temp,\\nlag(temperature) over(order by recordDate,id) as prev_temp,\\nlag(recordDate) over(order by recordDate,id) as prev_date\\nfrom Weather\\n)\\n\\nselect\\nid\\nfrom CTE\\nwhere temp > prev_temp and datediff(day,  prev_date, [date] ) = 1\\n\\n\\n"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect a.id\\nfrom weather a\\ninner join weather b\\non datediff(day, b.recordDate, a.recordDate) = 1\\nand a.temperature > b.temperature\\n\\n2)\\nwith cte as\\n(select *, \\n        lag(temperature)over(order by recordDate) as perviousTemp,\\n        lag(recordDate)over(order by recordDate) as perviousDate\\nfrom weather)\\nselect id from cte where temperature > perviousTemp and datediff(day, perviousDate, recordDate) = 1"
                    },
                    {
                        "username": "ann1996015",
                        "content": "This is my code, i think it is very hard ==\\n\\nSELECT DISTINCT  w2.id\\nFROM Weather w1\\nLEFT JOIN Weather w2 ON ABS(DATEDIFF(day,w2.recordDate, w1.recordDate)) = 1\\nWHERE w2.temperature > w1.temperature and w2.recordDate>w1.recordDate"
                    }
                ]
            },
            {
                "id": 1569017,
                "content": [
                    {
                        "username": "frunfola1229",
                        "content": "\\n**SELECT**  w1.Id \\n**FROM**     Weather w1, Weather w2\\n**WHERE**   dateDiff(w1.Date,w2.Date) = 1        **AND**    w1.Temperature > w2.Temperature;"
                    },
                    {
                        "username": "Vipul_Chaudhary_2003",
                        "content": "Okay great.\nNow let's read rules together\n\nDiscussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jargolastik",
                        "content": "[@user8224IM](/user8224IM) self join creates every possible combination of columns so that means that you can just filter out the rows where the current temp is greater than yesterday\\'s"
                    },
                    {
                        "username": "JerryBlank",
                        "content": "[@user8224IM](/user8224IM) They have created 2 copies of the same table w1 and w2 and comparing each and every row. \\nSelecting only the ids for rows where \\nw1.date - w2.date =1 means that w1 is the date of next day to w2 (example: 2nd August - 1st August =1)\\nAND\\nw1.Temperature > w2.Temperature means Temperature on Date w1 is greater than Temperature on Date w2. \\n\\nso that would get Id with higher temperatures compared to its previous dates (yesterday).\\nHope this helps!"
                    },
                    {
                        "username": "user8224IM",
                        "content": "can you explain how/why this works please\\n"
                    },
                    {
                        "username": "chriszeng8",
                        "content": "Why is subtracting 1 directly from Date not working, but subdate(a.Date,1) works?\\n\\nMy code is \\n\\n    select W1.Id\\n    from Weather as W1, Weather as W2\\n    where W1.Date-1 = W2.Date and W1.Temperature> W2.Temperature\\n\\nit only passed 13/14 cases.\\n\\nHowever, when I changed `W1.Date-1` to `sub(W1.Date,1)` in the where clause, it worked. What is fundamental difference?"
                    },
                    {
                        "username": "Lysa123",
                        "content": "[@minhphamduy](/minhphamduy) cho m\\xECnh h\\u1ECFi v\\xEC sao ph\\u1EA3i c\\xF3 ch\\u1EEF subquery \\u1EDF cu\\u1ED1i v?\\n"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "I think you not should do that, use date_add instead\\n# Write your MySQL query statement below\\n\\nselect id\\nfrom (\\n    select w1.id\\n    from weather w1, weather w2\\n    where w1.recordDate= DATE_ADD(w2.recordDate, interval 1 day) and w1.temperature > w2.temperature\\n) subquery"
                    },
                    {
                        "username": "har0101",
                        "content": "date is not int"
                    },
                    {
                        "username": "291831388",
                        "content": "[@michaelniki](/michaelniki)  Thank your for your response, it really helps me."
                    },
                    {
                        "username": "michaelniki",
                        "content": "subtracting 1 does not work for the date at the end of the month or year.\nTake this test case for example:\n\n| id | recordDate | temperature |\n| -- | ---------- | ----------- |\n| 1  | 2014-12-31 | 1           |\n| 2  | 2015-01-01 | 10          |\n| 3  | 2015-01-02 | 25          |\n\nrecordDate of id 2 (2015-01-01) - 1 does not equal to  2014-12-31\n\n```\nselect\n    *\n    , w1.recordDate - w2.recordDate\nfrom\n    weather w1, weather w2\norder by w1.id\n\n```\n\n| id | recordDate | temperature | id | recordDate | temperature | w1.recordDate - w2.recordDate |\n| -- | ---------- | ----------- | -- | ---------- | ----------- | ----------------------------- |\n| 1  | 2014-12-31 | 1           | 1  | 2014-12-31 | 1           | 0                             |\n| 1  | 2014-12-31 | 1           | 2  | 2015-01-01 | 10          | -8870                         |\n| 1  | 2014-12-31 | 1           | 3  | 2015-01-02 | 25          | -8871                         |\n| 2  | 2015-01-01 | 10          | 1  | 2014-12-31 | 1           | 8870                          |\n| 2  | 2015-01-01 | 10          | 2  | 2015-01-01 | 10          | 0                             |\n| 2  | 2015-01-01 | 10          | 3  | 2015-01-02 | 25          | -1                            |\n| 3  | 2015-01-02 | 25          | 1  | 2014-12-31 | 1           | 8871                          |\n| 3  | 2015-01-02 | 25          | 2  | 2015-01-01 | 10          | 1                             |\n| 3  | 2015-01-02 | 25          | 3  | 2015-01-02 | 25          | 0                             |\n"
                    },
                    {
                        "username": "suraj21193",
                        "content": "Its is running successfully but not able to submit!\\nSelect a.id\\nfrom \\n(Select id, temperature, lag(temperature) over(order by recordDate) as lt,\\ncase when temperature>lag(temperature) over(order by recordDate) then \\'High\\'\\nelse \\'Low\\'\\nend as \\'Status\\'\\nfrom Weather) a\\nwhere Status = \\'High\\';"
                    },
                    {
                        "username": "themanutdmaniac",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) the reason is that the test case has 2 dates with a day missing in between."
                    },
                    {
                        "username": "Palash5043",
                        "content": "\nselect x.Id from (\nselect Id,\n       recordDate,\n       temperature as temp,\n    lag(temperature,1) over(order by recordDate asc) as pre_day_temp\n    from weather) x\n    where x.temp>x.pre_day_temp;\n\nI am also facing the similar issue "
                    },
                    {
                        "username": "kashrex",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) test cases are failing because the dates have to be exact previous date. \"2000-12-14 |     |2000-12-16\"  have a date difference of more than 1 day."
                    },
                    {
                        "username": "jingpingyu1127",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) I think this is because that we are finding records with only 1 day difference. The records in the test case is using date with 2 days difference, which should not return anything for the output."
                    },
                    {
                        "username": "avinashkumarjha05",
                        "content": "mine too ... have u understood why the test case failing?\\n"
                    },
                    {
                        "username": "sandeep_kumar_75",
                        "content": "**SELECT a.id\\nFROM Weather a, Weather b\\nWHERE datediff(a.recordDate, b.recordDate) = 1\\nAND a.temperature > b.temperature;**"
                    },
                    {
                        "username": "themanutdmaniac",
                        "content": "Wow, what a solution. GOAT. amazing. all the best sandeep."
                    },
                    {
                        "username": "xudaiyanzi",
                        "content": "Hi everyone, I tried the query below. It works when I run MySQL, but it can not work when it is submitted.  Please help me. Thank you.\\n# Write your MySQL query statement below\\nSELECT y.id\\nFROM Weather x\\nLEFT JOIN Weather y ON x.Id +1 = y.Id\\nWHERE x.Temperature < y.Temperature\\n"
                    },
                    {
                        "username": "cassiellong1113",
                        "content": "date is not ascending sorted, and thus if you do not compare with dates but with ID, you may get wrong answer "
                    },
                    {
                        "username": "Avazbeka_dev",
                        "content": "SELECT a.id\\nFROM Weather as a,Weather as b\\nWHERE a.temperature>b.temperature\\nAND DATEDIFF(a.recordDate,b.recordDate)=1\\n\\nYou must check the datas !"
                    },
                    {
                        "username": "patnanavarun",
                        "content": "you are just checking the id values .But not comparing the dates.\\n"
                    },
                    {
                        "username": "snehanshu17",
                        "content": "with tmp as (\\nselect id ,RecordDate,Temperature,\\nLAG (Temperature,1) OVER (ORDER BY RecordDate) AS prev_Temperature,\\n    LAG (RecordDate,1) OVER (ORDER BY RecordDate) AS prev_RecordDate\\nfrom Weather)\\n\\nselect id  from tmp where Temperature>prev_Temperature and (RecordDate-prev_RecordDate)=1"
                    },
                    {
                        "username": "mr-xed",
                        "content": "Really interesting approach, except it didn\\'t work for me from the get go for some reason, how ever I was able to solve it using `dateDiff(RecordDate, prev_RecordDate)` instead of `(RecordDate-prev_RecordDate)`"
                    },
                    {
                        "username": "XinyiQiu",
                        "content": "WITH yesterday AS (SELECT id,recordDate,temperature,DATE_SUB(recordDate, INTERVAL 1 DAY) AS yesterday\\nFROM Weather)\\n\\nSELECT yesterday.id\\nFROM yesterday LEFT JOIN Weather on yesterday.yesterday = Weather.recordDate\\nWHERE Weather.temperature IS NOT NULL AND yesterday.temperature > Weather.temperature"
                    },
                    {
                        "username": "nasirxia",
                        "content": "the idea is brilliant but why make things complicated? There should be a reasons for doing this."
                    },
                    {
                        "username": "anand_vineet19",
                        "content": "# Write your MySQL query statement below\\nSELECT id\\nFROM\\n(\\nSELECT id, recordDate, temperature AS today_temp, LAG(temperature,1) OVER (ORDER BY recordDate) AS yesterday_temp, LAG(recordDate,1) OVER (ORDER BY recordDate) AS yes_date\\n\\nFROM Weather\\n) AS temp_table\\n\\nWHERE today_temp>yesterday_temp AND DATEDIFF(recordDate,yes_date)=1"
                    },
                    {
                        "username": "priyarb96",
                        "content": "Simple and neat query"
                    },
                    {
                        "username": "abebe_1983",
                        "content": "we need to rearrange this query a little bit as follows \\nwith CTE as (\\nselect\\nid,recordDate as [date], temperature as temp,\\nlag(temperature) over(order by recordDate,id) as prev_temp,\\nlag(recordDate) over(order by recordDate,id) as prev_date\\nfrom Weather\\n)\\n\\nselect\\nid\\nfrom CTE\\nwhere temp > prev_temp and datediff(day,  prev_date, [date] ) = 1\\n\\n\\n"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect a.id\\nfrom weather a\\ninner join weather b\\non datediff(day, b.recordDate, a.recordDate) = 1\\nand a.temperature > b.temperature\\n\\n2)\\nwith cte as\\n(select *, \\n        lag(temperature)over(order by recordDate) as perviousTemp,\\n        lag(recordDate)over(order by recordDate) as perviousDate\\nfrom weather)\\nselect id from cte where temperature > perviousTemp and datediff(day, perviousDate, recordDate) = 1"
                    },
                    {
                        "username": "ann1996015",
                        "content": "This is my code, i think it is very hard ==\\n\\nSELECT DISTINCT  w2.id\\nFROM Weather w1\\nLEFT JOIN Weather w2 ON ABS(DATEDIFF(day,w2.recordDate, w1.recordDate)) = 1\\nWHERE w2.temperature > w1.temperature and w2.recordDate>w1.recordDate"
                    }
                ]
            },
            {
                "id": 1565745,
                "content": [
                    {
                        "username": "frunfola1229",
                        "content": "\\n**SELECT**  w1.Id \\n**FROM**     Weather w1, Weather w2\\n**WHERE**   dateDiff(w1.Date,w2.Date) = 1        **AND**    w1.Temperature > w2.Temperature;"
                    },
                    {
                        "username": "Vipul_Chaudhary_2003",
                        "content": "Okay great.\nNow let's read rules together\n\nDiscussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jargolastik",
                        "content": "[@user8224IM](/user8224IM) self join creates every possible combination of columns so that means that you can just filter out the rows where the current temp is greater than yesterday\\'s"
                    },
                    {
                        "username": "JerryBlank",
                        "content": "[@user8224IM](/user8224IM) They have created 2 copies of the same table w1 and w2 and comparing each and every row. \\nSelecting only the ids for rows where \\nw1.date - w2.date =1 means that w1 is the date of next day to w2 (example: 2nd August - 1st August =1)\\nAND\\nw1.Temperature > w2.Temperature means Temperature on Date w1 is greater than Temperature on Date w2. \\n\\nso that would get Id with higher temperatures compared to its previous dates (yesterday).\\nHope this helps!"
                    },
                    {
                        "username": "user8224IM",
                        "content": "can you explain how/why this works please\\n"
                    },
                    {
                        "username": "chriszeng8",
                        "content": "Why is subtracting 1 directly from Date not working, but subdate(a.Date,1) works?\\n\\nMy code is \\n\\n    select W1.Id\\n    from Weather as W1, Weather as W2\\n    where W1.Date-1 = W2.Date and W1.Temperature> W2.Temperature\\n\\nit only passed 13/14 cases.\\n\\nHowever, when I changed `W1.Date-1` to `sub(W1.Date,1)` in the where clause, it worked. What is fundamental difference?"
                    },
                    {
                        "username": "Lysa123",
                        "content": "[@minhphamduy](/minhphamduy) cho m\\xECnh h\\u1ECFi v\\xEC sao ph\\u1EA3i c\\xF3 ch\\u1EEF subquery \\u1EDF cu\\u1ED1i v?\\n"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "I think you not should do that, use date_add instead\\n# Write your MySQL query statement below\\n\\nselect id\\nfrom (\\n    select w1.id\\n    from weather w1, weather w2\\n    where w1.recordDate= DATE_ADD(w2.recordDate, interval 1 day) and w1.temperature > w2.temperature\\n) subquery"
                    },
                    {
                        "username": "har0101",
                        "content": "date is not int"
                    },
                    {
                        "username": "291831388",
                        "content": "[@michaelniki](/michaelniki)  Thank your for your response, it really helps me."
                    },
                    {
                        "username": "michaelniki",
                        "content": "subtracting 1 does not work for the date at the end of the month or year.\nTake this test case for example:\n\n| id | recordDate | temperature |\n| -- | ---------- | ----------- |\n| 1  | 2014-12-31 | 1           |\n| 2  | 2015-01-01 | 10          |\n| 3  | 2015-01-02 | 25          |\n\nrecordDate of id 2 (2015-01-01) - 1 does not equal to  2014-12-31\n\n```\nselect\n    *\n    , w1.recordDate - w2.recordDate\nfrom\n    weather w1, weather w2\norder by w1.id\n\n```\n\n| id | recordDate | temperature | id | recordDate | temperature | w1.recordDate - w2.recordDate |\n| -- | ---------- | ----------- | -- | ---------- | ----------- | ----------------------------- |\n| 1  | 2014-12-31 | 1           | 1  | 2014-12-31 | 1           | 0                             |\n| 1  | 2014-12-31 | 1           | 2  | 2015-01-01 | 10          | -8870                         |\n| 1  | 2014-12-31 | 1           | 3  | 2015-01-02 | 25          | -8871                         |\n| 2  | 2015-01-01 | 10          | 1  | 2014-12-31 | 1           | 8870                          |\n| 2  | 2015-01-01 | 10          | 2  | 2015-01-01 | 10          | 0                             |\n| 2  | 2015-01-01 | 10          | 3  | 2015-01-02 | 25          | -1                            |\n| 3  | 2015-01-02 | 25          | 1  | 2014-12-31 | 1           | 8871                          |\n| 3  | 2015-01-02 | 25          | 2  | 2015-01-01 | 10          | 1                             |\n| 3  | 2015-01-02 | 25          | 3  | 2015-01-02 | 25          | 0                             |\n"
                    },
                    {
                        "username": "suraj21193",
                        "content": "Its is running successfully but not able to submit!\\nSelect a.id\\nfrom \\n(Select id, temperature, lag(temperature) over(order by recordDate) as lt,\\ncase when temperature>lag(temperature) over(order by recordDate) then \\'High\\'\\nelse \\'Low\\'\\nend as \\'Status\\'\\nfrom Weather) a\\nwhere Status = \\'High\\';"
                    },
                    {
                        "username": "themanutdmaniac",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) the reason is that the test case has 2 dates with a day missing in between."
                    },
                    {
                        "username": "Palash5043",
                        "content": "\nselect x.Id from (\nselect Id,\n       recordDate,\n       temperature as temp,\n    lag(temperature,1) over(order by recordDate asc) as pre_day_temp\n    from weather) x\n    where x.temp>x.pre_day_temp;\n\nI am also facing the similar issue "
                    },
                    {
                        "username": "kashrex",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) test cases are failing because the dates have to be exact previous date. \"2000-12-14 |     |2000-12-16\"  have a date difference of more than 1 day."
                    },
                    {
                        "username": "jingpingyu1127",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) I think this is because that we are finding records with only 1 day difference. The records in the test case is using date with 2 days difference, which should not return anything for the output."
                    },
                    {
                        "username": "avinashkumarjha05",
                        "content": "mine too ... have u understood why the test case failing?\\n"
                    },
                    {
                        "username": "sandeep_kumar_75",
                        "content": "**SELECT a.id\\nFROM Weather a, Weather b\\nWHERE datediff(a.recordDate, b.recordDate) = 1\\nAND a.temperature > b.temperature;**"
                    },
                    {
                        "username": "themanutdmaniac",
                        "content": "Wow, what a solution. GOAT. amazing. all the best sandeep."
                    },
                    {
                        "username": "xudaiyanzi",
                        "content": "Hi everyone, I tried the query below. It works when I run MySQL, but it can not work when it is submitted.  Please help me. Thank you.\\n# Write your MySQL query statement below\\nSELECT y.id\\nFROM Weather x\\nLEFT JOIN Weather y ON x.Id +1 = y.Id\\nWHERE x.Temperature < y.Temperature\\n"
                    },
                    {
                        "username": "cassiellong1113",
                        "content": "date is not ascending sorted, and thus if you do not compare with dates but with ID, you may get wrong answer "
                    },
                    {
                        "username": "Avazbeka_dev",
                        "content": "SELECT a.id\\nFROM Weather as a,Weather as b\\nWHERE a.temperature>b.temperature\\nAND DATEDIFF(a.recordDate,b.recordDate)=1\\n\\nYou must check the datas !"
                    },
                    {
                        "username": "patnanavarun",
                        "content": "you are just checking the id values .But not comparing the dates.\\n"
                    },
                    {
                        "username": "snehanshu17",
                        "content": "with tmp as (\\nselect id ,RecordDate,Temperature,\\nLAG (Temperature,1) OVER (ORDER BY RecordDate) AS prev_Temperature,\\n    LAG (RecordDate,1) OVER (ORDER BY RecordDate) AS prev_RecordDate\\nfrom Weather)\\n\\nselect id  from tmp where Temperature>prev_Temperature and (RecordDate-prev_RecordDate)=1"
                    },
                    {
                        "username": "mr-xed",
                        "content": "Really interesting approach, except it didn\\'t work for me from the get go for some reason, how ever I was able to solve it using `dateDiff(RecordDate, prev_RecordDate)` instead of `(RecordDate-prev_RecordDate)`"
                    },
                    {
                        "username": "XinyiQiu",
                        "content": "WITH yesterday AS (SELECT id,recordDate,temperature,DATE_SUB(recordDate, INTERVAL 1 DAY) AS yesterday\\nFROM Weather)\\n\\nSELECT yesterday.id\\nFROM yesterday LEFT JOIN Weather on yesterday.yesterday = Weather.recordDate\\nWHERE Weather.temperature IS NOT NULL AND yesterday.temperature > Weather.temperature"
                    },
                    {
                        "username": "nasirxia",
                        "content": "the idea is brilliant but why make things complicated? There should be a reasons for doing this."
                    },
                    {
                        "username": "anand_vineet19",
                        "content": "# Write your MySQL query statement below\\nSELECT id\\nFROM\\n(\\nSELECT id, recordDate, temperature AS today_temp, LAG(temperature,1) OVER (ORDER BY recordDate) AS yesterday_temp, LAG(recordDate,1) OVER (ORDER BY recordDate) AS yes_date\\n\\nFROM Weather\\n) AS temp_table\\n\\nWHERE today_temp>yesterday_temp AND DATEDIFF(recordDate,yes_date)=1"
                    },
                    {
                        "username": "priyarb96",
                        "content": "Simple and neat query"
                    },
                    {
                        "username": "abebe_1983",
                        "content": "we need to rearrange this query a little bit as follows \\nwith CTE as (\\nselect\\nid,recordDate as [date], temperature as temp,\\nlag(temperature) over(order by recordDate,id) as prev_temp,\\nlag(recordDate) over(order by recordDate,id) as prev_date\\nfrom Weather\\n)\\n\\nselect\\nid\\nfrom CTE\\nwhere temp > prev_temp and datediff(day,  prev_date, [date] ) = 1\\n\\n\\n"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect a.id\\nfrom weather a\\ninner join weather b\\non datediff(day, b.recordDate, a.recordDate) = 1\\nand a.temperature > b.temperature\\n\\n2)\\nwith cte as\\n(select *, \\n        lag(temperature)over(order by recordDate) as perviousTemp,\\n        lag(recordDate)over(order by recordDate) as perviousDate\\nfrom weather)\\nselect id from cte where temperature > perviousTemp and datediff(day, perviousDate, recordDate) = 1"
                    },
                    {
                        "username": "ann1996015",
                        "content": "This is my code, i think it is very hard ==\\n\\nSELECT DISTINCT  w2.id\\nFROM Weather w1\\nLEFT JOIN Weather w2 ON ABS(DATEDIFF(day,w2.recordDate, w1.recordDate)) = 1\\nWHERE w2.temperature > w1.temperature and w2.recordDate>w1.recordDate"
                    }
                ]
            },
            {
                "id": 1576886,
                "content": [
                    {
                        "username": "frunfola1229",
                        "content": "\\n**SELECT**  w1.Id \\n**FROM**     Weather w1, Weather w2\\n**WHERE**   dateDiff(w1.Date,w2.Date) = 1        **AND**    w1.Temperature > w2.Temperature;"
                    },
                    {
                        "username": "Vipul_Chaudhary_2003",
                        "content": "Okay great.\nNow let's read rules together\n\nDiscussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jargolastik",
                        "content": "[@user8224IM](/user8224IM) self join creates every possible combination of columns so that means that you can just filter out the rows where the current temp is greater than yesterday\\'s"
                    },
                    {
                        "username": "JerryBlank",
                        "content": "[@user8224IM](/user8224IM) They have created 2 copies of the same table w1 and w2 and comparing each and every row. \\nSelecting only the ids for rows where \\nw1.date - w2.date =1 means that w1 is the date of next day to w2 (example: 2nd August - 1st August =1)\\nAND\\nw1.Temperature > w2.Temperature means Temperature on Date w1 is greater than Temperature on Date w2. \\n\\nso that would get Id with higher temperatures compared to its previous dates (yesterday).\\nHope this helps!"
                    },
                    {
                        "username": "user8224IM",
                        "content": "can you explain how/why this works please\\n"
                    },
                    {
                        "username": "chriszeng8",
                        "content": "Why is subtracting 1 directly from Date not working, but subdate(a.Date,1) works?\\n\\nMy code is \\n\\n    select W1.Id\\n    from Weather as W1, Weather as W2\\n    where W1.Date-1 = W2.Date and W1.Temperature> W2.Temperature\\n\\nit only passed 13/14 cases.\\n\\nHowever, when I changed `W1.Date-1` to `sub(W1.Date,1)` in the where clause, it worked. What is fundamental difference?"
                    },
                    {
                        "username": "Lysa123",
                        "content": "[@minhphamduy](/minhphamduy) cho m\\xECnh h\\u1ECFi v\\xEC sao ph\\u1EA3i c\\xF3 ch\\u1EEF subquery \\u1EDF cu\\u1ED1i v?\\n"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "I think you not should do that, use date_add instead\\n# Write your MySQL query statement below\\n\\nselect id\\nfrom (\\n    select w1.id\\n    from weather w1, weather w2\\n    where w1.recordDate= DATE_ADD(w2.recordDate, interval 1 day) and w1.temperature > w2.temperature\\n) subquery"
                    },
                    {
                        "username": "har0101",
                        "content": "date is not int"
                    },
                    {
                        "username": "291831388",
                        "content": "[@michaelniki](/michaelniki)  Thank your for your response, it really helps me."
                    },
                    {
                        "username": "michaelniki",
                        "content": "subtracting 1 does not work for the date at the end of the month or year.\nTake this test case for example:\n\n| id | recordDate | temperature |\n| -- | ---------- | ----------- |\n| 1  | 2014-12-31 | 1           |\n| 2  | 2015-01-01 | 10          |\n| 3  | 2015-01-02 | 25          |\n\nrecordDate of id 2 (2015-01-01) - 1 does not equal to  2014-12-31\n\n```\nselect\n    *\n    , w1.recordDate - w2.recordDate\nfrom\n    weather w1, weather w2\norder by w1.id\n\n```\n\n| id | recordDate | temperature | id | recordDate | temperature | w1.recordDate - w2.recordDate |\n| -- | ---------- | ----------- | -- | ---------- | ----------- | ----------------------------- |\n| 1  | 2014-12-31 | 1           | 1  | 2014-12-31 | 1           | 0                             |\n| 1  | 2014-12-31 | 1           | 2  | 2015-01-01 | 10          | -8870                         |\n| 1  | 2014-12-31 | 1           | 3  | 2015-01-02 | 25          | -8871                         |\n| 2  | 2015-01-01 | 10          | 1  | 2014-12-31 | 1           | 8870                          |\n| 2  | 2015-01-01 | 10          | 2  | 2015-01-01 | 10          | 0                             |\n| 2  | 2015-01-01 | 10          | 3  | 2015-01-02 | 25          | -1                            |\n| 3  | 2015-01-02 | 25          | 1  | 2014-12-31 | 1           | 8871                          |\n| 3  | 2015-01-02 | 25          | 2  | 2015-01-01 | 10          | 1                             |\n| 3  | 2015-01-02 | 25          | 3  | 2015-01-02 | 25          | 0                             |\n"
                    },
                    {
                        "username": "suraj21193",
                        "content": "Its is running successfully but not able to submit!\\nSelect a.id\\nfrom \\n(Select id, temperature, lag(temperature) over(order by recordDate) as lt,\\ncase when temperature>lag(temperature) over(order by recordDate) then \\'High\\'\\nelse \\'Low\\'\\nend as \\'Status\\'\\nfrom Weather) a\\nwhere Status = \\'High\\';"
                    },
                    {
                        "username": "themanutdmaniac",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) the reason is that the test case has 2 dates with a day missing in between."
                    },
                    {
                        "username": "Palash5043",
                        "content": "\nselect x.Id from (\nselect Id,\n       recordDate,\n       temperature as temp,\n    lag(temperature,1) over(order by recordDate asc) as pre_day_temp\n    from weather) x\n    where x.temp>x.pre_day_temp;\n\nI am also facing the similar issue "
                    },
                    {
                        "username": "kashrex",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) test cases are failing because the dates have to be exact previous date. \"2000-12-14 |     |2000-12-16\"  have a date difference of more than 1 day."
                    },
                    {
                        "username": "jingpingyu1127",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) I think this is because that we are finding records with only 1 day difference. The records in the test case is using date with 2 days difference, which should not return anything for the output."
                    },
                    {
                        "username": "avinashkumarjha05",
                        "content": "mine too ... have u understood why the test case failing?\\n"
                    },
                    {
                        "username": "sandeep_kumar_75",
                        "content": "**SELECT a.id\\nFROM Weather a, Weather b\\nWHERE datediff(a.recordDate, b.recordDate) = 1\\nAND a.temperature > b.temperature;**"
                    },
                    {
                        "username": "themanutdmaniac",
                        "content": "Wow, what a solution. GOAT. amazing. all the best sandeep."
                    },
                    {
                        "username": "xudaiyanzi",
                        "content": "Hi everyone, I tried the query below. It works when I run MySQL, but it can not work when it is submitted.  Please help me. Thank you.\\n# Write your MySQL query statement below\\nSELECT y.id\\nFROM Weather x\\nLEFT JOIN Weather y ON x.Id +1 = y.Id\\nWHERE x.Temperature < y.Temperature\\n"
                    },
                    {
                        "username": "cassiellong1113",
                        "content": "date is not ascending sorted, and thus if you do not compare with dates but with ID, you may get wrong answer "
                    },
                    {
                        "username": "Avazbeka_dev",
                        "content": "SELECT a.id\\nFROM Weather as a,Weather as b\\nWHERE a.temperature>b.temperature\\nAND DATEDIFF(a.recordDate,b.recordDate)=1\\n\\nYou must check the datas !"
                    },
                    {
                        "username": "patnanavarun",
                        "content": "you are just checking the id values .But not comparing the dates.\\n"
                    },
                    {
                        "username": "snehanshu17",
                        "content": "with tmp as (\\nselect id ,RecordDate,Temperature,\\nLAG (Temperature,1) OVER (ORDER BY RecordDate) AS prev_Temperature,\\n    LAG (RecordDate,1) OVER (ORDER BY RecordDate) AS prev_RecordDate\\nfrom Weather)\\n\\nselect id  from tmp where Temperature>prev_Temperature and (RecordDate-prev_RecordDate)=1"
                    },
                    {
                        "username": "mr-xed",
                        "content": "Really interesting approach, except it didn\\'t work for me from the get go for some reason, how ever I was able to solve it using `dateDiff(RecordDate, prev_RecordDate)` instead of `(RecordDate-prev_RecordDate)`"
                    },
                    {
                        "username": "XinyiQiu",
                        "content": "WITH yesterday AS (SELECT id,recordDate,temperature,DATE_SUB(recordDate, INTERVAL 1 DAY) AS yesterday\\nFROM Weather)\\n\\nSELECT yesterday.id\\nFROM yesterday LEFT JOIN Weather on yesterday.yesterday = Weather.recordDate\\nWHERE Weather.temperature IS NOT NULL AND yesterday.temperature > Weather.temperature"
                    },
                    {
                        "username": "nasirxia",
                        "content": "the idea is brilliant but why make things complicated? There should be a reasons for doing this."
                    },
                    {
                        "username": "anand_vineet19",
                        "content": "# Write your MySQL query statement below\\nSELECT id\\nFROM\\n(\\nSELECT id, recordDate, temperature AS today_temp, LAG(temperature,1) OVER (ORDER BY recordDate) AS yesterday_temp, LAG(recordDate,1) OVER (ORDER BY recordDate) AS yes_date\\n\\nFROM Weather\\n) AS temp_table\\n\\nWHERE today_temp>yesterday_temp AND DATEDIFF(recordDate,yes_date)=1"
                    },
                    {
                        "username": "priyarb96",
                        "content": "Simple and neat query"
                    },
                    {
                        "username": "abebe_1983",
                        "content": "we need to rearrange this query a little bit as follows \\nwith CTE as (\\nselect\\nid,recordDate as [date], temperature as temp,\\nlag(temperature) over(order by recordDate,id) as prev_temp,\\nlag(recordDate) over(order by recordDate,id) as prev_date\\nfrom Weather\\n)\\n\\nselect\\nid\\nfrom CTE\\nwhere temp > prev_temp and datediff(day,  prev_date, [date] ) = 1\\n\\n\\n"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect a.id\\nfrom weather a\\ninner join weather b\\non datediff(day, b.recordDate, a.recordDate) = 1\\nand a.temperature > b.temperature\\n\\n2)\\nwith cte as\\n(select *, \\n        lag(temperature)over(order by recordDate) as perviousTemp,\\n        lag(recordDate)over(order by recordDate) as perviousDate\\nfrom weather)\\nselect id from cte where temperature > perviousTemp and datediff(day, perviousDate, recordDate) = 1"
                    },
                    {
                        "username": "ann1996015",
                        "content": "This is my code, i think it is very hard ==\\n\\nSELECT DISTINCT  w2.id\\nFROM Weather w1\\nLEFT JOIN Weather w2 ON ABS(DATEDIFF(day,w2.recordDate, w1.recordDate)) = 1\\nWHERE w2.temperature > w1.temperature and w2.recordDate>w1.recordDate"
                    }
                ]
            },
            {
                "id": 1576869,
                "content": [
                    {
                        "username": "frunfola1229",
                        "content": "\\n**SELECT**  w1.Id \\n**FROM**     Weather w1, Weather w2\\n**WHERE**   dateDiff(w1.Date,w2.Date) = 1        **AND**    w1.Temperature > w2.Temperature;"
                    },
                    {
                        "username": "Vipul_Chaudhary_2003",
                        "content": "Okay great.\nNow let's read rules together\n\nDiscussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jargolastik",
                        "content": "[@user8224IM](/user8224IM) self join creates every possible combination of columns so that means that you can just filter out the rows where the current temp is greater than yesterday\\'s"
                    },
                    {
                        "username": "JerryBlank",
                        "content": "[@user8224IM](/user8224IM) They have created 2 copies of the same table w1 and w2 and comparing each and every row. \\nSelecting only the ids for rows where \\nw1.date - w2.date =1 means that w1 is the date of next day to w2 (example: 2nd August - 1st August =1)\\nAND\\nw1.Temperature > w2.Temperature means Temperature on Date w1 is greater than Temperature on Date w2. \\n\\nso that would get Id with higher temperatures compared to its previous dates (yesterday).\\nHope this helps!"
                    },
                    {
                        "username": "user8224IM",
                        "content": "can you explain how/why this works please\\n"
                    },
                    {
                        "username": "chriszeng8",
                        "content": "Why is subtracting 1 directly from Date not working, but subdate(a.Date,1) works?\\n\\nMy code is \\n\\n    select W1.Id\\n    from Weather as W1, Weather as W2\\n    where W1.Date-1 = W2.Date and W1.Temperature> W2.Temperature\\n\\nit only passed 13/14 cases.\\n\\nHowever, when I changed `W1.Date-1` to `sub(W1.Date,1)` in the where clause, it worked. What is fundamental difference?"
                    },
                    {
                        "username": "Lysa123",
                        "content": "[@minhphamduy](/minhphamduy) cho m\\xECnh h\\u1ECFi v\\xEC sao ph\\u1EA3i c\\xF3 ch\\u1EEF subquery \\u1EDF cu\\u1ED1i v?\\n"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "I think you not should do that, use date_add instead\\n# Write your MySQL query statement below\\n\\nselect id\\nfrom (\\n    select w1.id\\n    from weather w1, weather w2\\n    where w1.recordDate= DATE_ADD(w2.recordDate, interval 1 day) and w1.temperature > w2.temperature\\n) subquery"
                    },
                    {
                        "username": "har0101",
                        "content": "date is not int"
                    },
                    {
                        "username": "291831388",
                        "content": "[@michaelniki](/michaelniki)  Thank your for your response, it really helps me."
                    },
                    {
                        "username": "michaelniki",
                        "content": "subtracting 1 does not work for the date at the end of the month or year.\nTake this test case for example:\n\n| id | recordDate | temperature |\n| -- | ---------- | ----------- |\n| 1  | 2014-12-31 | 1           |\n| 2  | 2015-01-01 | 10          |\n| 3  | 2015-01-02 | 25          |\n\nrecordDate of id 2 (2015-01-01) - 1 does not equal to  2014-12-31\n\n```\nselect\n    *\n    , w1.recordDate - w2.recordDate\nfrom\n    weather w1, weather w2\norder by w1.id\n\n```\n\n| id | recordDate | temperature | id | recordDate | temperature | w1.recordDate - w2.recordDate |\n| -- | ---------- | ----------- | -- | ---------- | ----------- | ----------------------------- |\n| 1  | 2014-12-31 | 1           | 1  | 2014-12-31 | 1           | 0                             |\n| 1  | 2014-12-31 | 1           | 2  | 2015-01-01 | 10          | -8870                         |\n| 1  | 2014-12-31 | 1           | 3  | 2015-01-02 | 25          | -8871                         |\n| 2  | 2015-01-01 | 10          | 1  | 2014-12-31 | 1           | 8870                          |\n| 2  | 2015-01-01 | 10          | 2  | 2015-01-01 | 10          | 0                             |\n| 2  | 2015-01-01 | 10          | 3  | 2015-01-02 | 25          | -1                            |\n| 3  | 2015-01-02 | 25          | 1  | 2014-12-31 | 1           | 8871                          |\n| 3  | 2015-01-02 | 25          | 2  | 2015-01-01 | 10          | 1                             |\n| 3  | 2015-01-02 | 25          | 3  | 2015-01-02 | 25          | 0                             |\n"
                    },
                    {
                        "username": "suraj21193",
                        "content": "Its is running successfully but not able to submit!\\nSelect a.id\\nfrom \\n(Select id, temperature, lag(temperature) over(order by recordDate) as lt,\\ncase when temperature>lag(temperature) over(order by recordDate) then \\'High\\'\\nelse \\'Low\\'\\nend as \\'Status\\'\\nfrom Weather) a\\nwhere Status = \\'High\\';"
                    },
                    {
                        "username": "themanutdmaniac",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) the reason is that the test case has 2 dates with a day missing in between."
                    },
                    {
                        "username": "Palash5043",
                        "content": "\nselect x.Id from (\nselect Id,\n       recordDate,\n       temperature as temp,\n    lag(temperature,1) over(order by recordDate asc) as pre_day_temp\n    from weather) x\n    where x.temp>x.pre_day_temp;\n\nI am also facing the similar issue "
                    },
                    {
                        "username": "kashrex",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) test cases are failing because the dates have to be exact previous date. \"2000-12-14 |     |2000-12-16\"  have a date difference of more than 1 day."
                    },
                    {
                        "username": "jingpingyu1127",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) I think this is because that we are finding records with only 1 day difference. The records in the test case is using date with 2 days difference, which should not return anything for the output."
                    },
                    {
                        "username": "avinashkumarjha05",
                        "content": "mine too ... have u understood why the test case failing?\\n"
                    },
                    {
                        "username": "sandeep_kumar_75",
                        "content": "**SELECT a.id\\nFROM Weather a, Weather b\\nWHERE datediff(a.recordDate, b.recordDate) = 1\\nAND a.temperature > b.temperature;**"
                    },
                    {
                        "username": "themanutdmaniac",
                        "content": "Wow, what a solution. GOAT. amazing. all the best sandeep."
                    },
                    {
                        "username": "xudaiyanzi",
                        "content": "Hi everyone, I tried the query below. It works when I run MySQL, but it can not work when it is submitted.  Please help me. Thank you.\\n# Write your MySQL query statement below\\nSELECT y.id\\nFROM Weather x\\nLEFT JOIN Weather y ON x.Id +1 = y.Id\\nWHERE x.Temperature < y.Temperature\\n"
                    },
                    {
                        "username": "cassiellong1113",
                        "content": "date is not ascending sorted, and thus if you do not compare with dates but with ID, you may get wrong answer "
                    },
                    {
                        "username": "Avazbeka_dev",
                        "content": "SELECT a.id\\nFROM Weather as a,Weather as b\\nWHERE a.temperature>b.temperature\\nAND DATEDIFF(a.recordDate,b.recordDate)=1\\n\\nYou must check the datas !"
                    },
                    {
                        "username": "patnanavarun",
                        "content": "you are just checking the id values .But not comparing the dates.\\n"
                    },
                    {
                        "username": "snehanshu17",
                        "content": "with tmp as (\\nselect id ,RecordDate,Temperature,\\nLAG (Temperature,1) OVER (ORDER BY RecordDate) AS prev_Temperature,\\n    LAG (RecordDate,1) OVER (ORDER BY RecordDate) AS prev_RecordDate\\nfrom Weather)\\n\\nselect id  from tmp where Temperature>prev_Temperature and (RecordDate-prev_RecordDate)=1"
                    },
                    {
                        "username": "mr-xed",
                        "content": "Really interesting approach, except it didn\\'t work for me from the get go for some reason, how ever I was able to solve it using `dateDiff(RecordDate, prev_RecordDate)` instead of `(RecordDate-prev_RecordDate)`"
                    },
                    {
                        "username": "XinyiQiu",
                        "content": "WITH yesterday AS (SELECT id,recordDate,temperature,DATE_SUB(recordDate, INTERVAL 1 DAY) AS yesterday\\nFROM Weather)\\n\\nSELECT yesterday.id\\nFROM yesterday LEFT JOIN Weather on yesterday.yesterday = Weather.recordDate\\nWHERE Weather.temperature IS NOT NULL AND yesterday.temperature > Weather.temperature"
                    },
                    {
                        "username": "nasirxia",
                        "content": "the idea is brilliant but why make things complicated? There should be a reasons for doing this."
                    },
                    {
                        "username": "anand_vineet19",
                        "content": "# Write your MySQL query statement below\\nSELECT id\\nFROM\\n(\\nSELECT id, recordDate, temperature AS today_temp, LAG(temperature,1) OVER (ORDER BY recordDate) AS yesterday_temp, LAG(recordDate,1) OVER (ORDER BY recordDate) AS yes_date\\n\\nFROM Weather\\n) AS temp_table\\n\\nWHERE today_temp>yesterday_temp AND DATEDIFF(recordDate,yes_date)=1"
                    },
                    {
                        "username": "priyarb96",
                        "content": "Simple and neat query"
                    },
                    {
                        "username": "abebe_1983",
                        "content": "we need to rearrange this query a little bit as follows \\nwith CTE as (\\nselect\\nid,recordDate as [date], temperature as temp,\\nlag(temperature) over(order by recordDate,id) as prev_temp,\\nlag(recordDate) over(order by recordDate,id) as prev_date\\nfrom Weather\\n)\\n\\nselect\\nid\\nfrom CTE\\nwhere temp > prev_temp and datediff(day,  prev_date, [date] ) = 1\\n\\n\\n"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect a.id\\nfrom weather a\\ninner join weather b\\non datediff(day, b.recordDate, a.recordDate) = 1\\nand a.temperature > b.temperature\\n\\n2)\\nwith cte as\\n(select *, \\n        lag(temperature)over(order by recordDate) as perviousTemp,\\n        lag(recordDate)over(order by recordDate) as perviousDate\\nfrom weather)\\nselect id from cte where temperature > perviousTemp and datediff(day, perviousDate, recordDate) = 1"
                    },
                    {
                        "username": "ann1996015",
                        "content": "This is my code, i think it is very hard ==\\n\\nSELECT DISTINCT  w2.id\\nFROM Weather w1\\nLEFT JOIN Weather w2 ON ABS(DATEDIFF(day,w2.recordDate, w1.recordDate)) = 1\\nWHERE w2.temperature > w1.temperature and w2.recordDate>w1.recordDate"
                    }
                ]
            },
            {
                "id": 1574935,
                "content": [
                    {
                        "username": "frunfola1229",
                        "content": "\\n**SELECT**  w1.Id \\n**FROM**     Weather w1, Weather w2\\n**WHERE**   dateDiff(w1.Date,w2.Date) = 1        **AND**    w1.Temperature > w2.Temperature;"
                    },
                    {
                        "username": "Vipul_Chaudhary_2003",
                        "content": "Okay great.\nNow let's read rules together\n\nDiscussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jargolastik",
                        "content": "[@user8224IM](/user8224IM) self join creates every possible combination of columns so that means that you can just filter out the rows where the current temp is greater than yesterday\\'s"
                    },
                    {
                        "username": "JerryBlank",
                        "content": "[@user8224IM](/user8224IM) They have created 2 copies of the same table w1 and w2 and comparing each and every row. \\nSelecting only the ids for rows where \\nw1.date - w2.date =1 means that w1 is the date of next day to w2 (example: 2nd August - 1st August =1)\\nAND\\nw1.Temperature > w2.Temperature means Temperature on Date w1 is greater than Temperature on Date w2. \\n\\nso that would get Id with higher temperatures compared to its previous dates (yesterday).\\nHope this helps!"
                    },
                    {
                        "username": "user8224IM",
                        "content": "can you explain how/why this works please\\n"
                    },
                    {
                        "username": "chriszeng8",
                        "content": "Why is subtracting 1 directly from Date not working, but subdate(a.Date,1) works?\\n\\nMy code is \\n\\n    select W1.Id\\n    from Weather as W1, Weather as W2\\n    where W1.Date-1 = W2.Date and W1.Temperature> W2.Temperature\\n\\nit only passed 13/14 cases.\\n\\nHowever, when I changed `W1.Date-1` to `sub(W1.Date,1)` in the where clause, it worked. What is fundamental difference?"
                    },
                    {
                        "username": "Lysa123",
                        "content": "[@minhphamduy](/minhphamduy) cho m\\xECnh h\\u1ECFi v\\xEC sao ph\\u1EA3i c\\xF3 ch\\u1EEF subquery \\u1EDF cu\\u1ED1i v?\\n"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "I think you not should do that, use date_add instead\\n# Write your MySQL query statement below\\n\\nselect id\\nfrom (\\n    select w1.id\\n    from weather w1, weather w2\\n    where w1.recordDate= DATE_ADD(w2.recordDate, interval 1 day) and w1.temperature > w2.temperature\\n) subquery"
                    },
                    {
                        "username": "har0101",
                        "content": "date is not int"
                    },
                    {
                        "username": "291831388",
                        "content": "[@michaelniki](/michaelniki)  Thank your for your response, it really helps me."
                    },
                    {
                        "username": "michaelniki",
                        "content": "subtracting 1 does not work for the date at the end of the month or year.\nTake this test case for example:\n\n| id | recordDate | temperature |\n| -- | ---------- | ----------- |\n| 1  | 2014-12-31 | 1           |\n| 2  | 2015-01-01 | 10          |\n| 3  | 2015-01-02 | 25          |\n\nrecordDate of id 2 (2015-01-01) - 1 does not equal to  2014-12-31\n\n```\nselect\n    *\n    , w1.recordDate - w2.recordDate\nfrom\n    weather w1, weather w2\norder by w1.id\n\n```\n\n| id | recordDate | temperature | id | recordDate | temperature | w1.recordDate - w2.recordDate |\n| -- | ---------- | ----------- | -- | ---------- | ----------- | ----------------------------- |\n| 1  | 2014-12-31 | 1           | 1  | 2014-12-31 | 1           | 0                             |\n| 1  | 2014-12-31 | 1           | 2  | 2015-01-01 | 10          | -8870                         |\n| 1  | 2014-12-31 | 1           | 3  | 2015-01-02 | 25          | -8871                         |\n| 2  | 2015-01-01 | 10          | 1  | 2014-12-31 | 1           | 8870                          |\n| 2  | 2015-01-01 | 10          | 2  | 2015-01-01 | 10          | 0                             |\n| 2  | 2015-01-01 | 10          | 3  | 2015-01-02 | 25          | -1                            |\n| 3  | 2015-01-02 | 25          | 1  | 2014-12-31 | 1           | 8871                          |\n| 3  | 2015-01-02 | 25          | 2  | 2015-01-01 | 10          | 1                             |\n| 3  | 2015-01-02 | 25          | 3  | 2015-01-02 | 25          | 0                             |\n"
                    },
                    {
                        "username": "suraj21193",
                        "content": "Its is running successfully but not able to submit!\\nSelect a.id\\nfrom \\n(Select id, temperature, lag(temperature) over(order by recordDate) as lt,\\ncase when temperature>lag(temperature) over(order by recordDate) then \\'High\\'\\nelse \\'Low\\'\\nend as \\'Status\\'\\nfrom Weather) a\\nwhere Status = \\'High\\';"
                    },
                    {
                        "username": "themanutdmaniac",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) the reason is that the test case has 2 dates with a day missing in between."
                    },
                    {
                        "username": "Palash5043",
                        "content": "\nselect x.Id from (\nselect Id,\n       recordDate,\n       temperature as temp,\n    lag(temperature,1) over(order by recordDate asc) as pre_day_temp\n    from weather) x\n    where x.temp>x.pre_day_temp;\n\nI am also facing the similar issue "
                    },
                    {
                        "username": "kashrex",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) test cases are failing because the dates have to be exact previous date. \"2000-12-14 |     |2000-12-16\"  have a date difference of more than 1 day."
                    },
                    {
                        "username": "jingpingyu1127",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) I think this is because that we are finding records with only 1 day difference. The records in the test case is using date with 2 days difference, which should not return anything for the output."
                    },
                    {
                        "username": "avinashkumarjha05",
                        "content": "mine too ... have u understood why the test case failing?\\n"
                    },
                    {
                        "username": "sandeep_kumar_75",
                        "content": "**SELECT a.id\\nFROM Weather a, Weather b\\nWHERE datediff(a.recordDate, b.recordDate) = 1\\nAND a.temperature > b.temperature;**"
                    },
                    {
                        "username": "themanutdmaniac",
                        "content": "Wow, what a solution. GOAT. amazing. all the best sandeep."
                    },
                    {
                        "username": "xudaiyanzi",
                        "content": "Hi everyone, I tried the query below. It works when I run MySQL, but it can not work when it is submitted.  Please help me. Thank you.\\n# Write your MySQL query statement below\\nSELECT y.id\\nFROM Weather x\\nLEFT JOIN Weather y ON x.Id +1 = y.Id\\nWHERE x.Temperature < y.Temperature\\n"
                    },
                    {
                        "username": "cassiellong1113",
                        "content": "date is not ascending sorted, and thus if you do not compare with dates but with ID, you may get wrong answer "
                    },
                    {
                        "username": "Avazbeka_dev",
                        "content": "SELECT a.id\\nFROM Weather as a,Weather as b\\nWHERE a.temperature>b.temperature\\nAND DATEDIFF(a.recordDate,b.recordDate)=1\\n\\nYou must check the datas !"
                    },
                    {
                        "username": "patnanavarun",
                        "content": "you are just checking the id values .But not comparing the dates.\\n"
                    },
                    {
                        "username": "snehanshu17",
                        "content": "with tmp as (\\nselect id ,RecordDate,Temperature,\\nLAG (Temperature,1) OVER (ORDER BY RecordDate) AS prev_Temperature,\\n    LAG (RecordDate,1) OVER (ORDER BY RecordDate) AS prev_RecordDate\\nfrom Weather)\\n\\nselect id  from tmp where Temperature>prev_Temperature and (RecordDate-prev_RecordDate)=1"
                    },
                    {
                        "username": "mr-xed",
                        "content": "Really interesting approach, except it didn\\'t work for me from the get go for some reason, how ever I was able to solve it using `dateDiff(RecordDate, prev_RecordDate)` instead of `(RecordDate-prev_RecordDate)`"
                    },
                    {
                        "username": "XinyiQiu",
                        "content": "WITH yesterday AS (SELECT id,recordDate,temperature,DATE_SUB(recordDate, INTERVAL 1 DAY) AS yesterday\\nFROM Weather)\\n\\nSELECT yesterday.id\\nFROM yesterday LEFT JOIN Weather on yesterday.yesterday = Weather.recordDate\\nWHERE Weather.temperature IS NOT NULL AND yesterday.temperature > Weather.temperature"
                    },
                    {
                        "username": "nasirxia",
                        "content": "the idea is brilliant but why make things complicated? There should be a reasons for doing this."
                    },
                    {
                        "username": "anand_vineet19",
                        "content": "# Write your MySQL query statement below\\nSELECT id\\nFROM\\n(\\nSELECT id, recordDate, temperature AS today_temp, LAG(temperature,1) OVER (ORDER BY recordDate) AS yesterday_temp, LAG(recordDate,1) OVER (ORDER BY recordDate) AS yes_date\\n\\nFROM Weather\\n) AS temp_table\\n\\nWHERE today_temp>yesterday_temp AND DATEDIFF(recordDate,yes_date)=1"
                    },
                    {
                        "username": "priyarb96",
                        "content": "Simple and neat query"
                    },
                    {
                        "username": "abebe_1983",
                        "content": "we need to rearrange this query a little bit as follows \\nwith CTE as (\\nselect\\nid,recordDate as [date], temperature as temp,\\nlag(temperature) over(order by recordDate,id) as prev_temp,\\nlag(recordDate) over(order by recordDate,id) as prev_date\\nfrom Weather\\n)\\n\\nselect\\nid\\nfrom CTE\\nwhere temp > prev_temp and datediff(day,  prev_date, [date] ) = 1\\n\\n\\n"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect a.id\\nfrom weather a\\ninner join weather b\\non datediff(day, b.recordDate, a.recordDate) = 1\\nand a.temperature > b.temperature\\n\\n2)\\nwith cte as\\n(select *, \\n        lag(temperature)over(order by recordDate) as perviousTemp,\\n        lag(recordDate)over(order by recordDate) as perviousDate\\nfrom weather)\\nselect id from cte where temperature > perviousTemp and datediff(day, perviousDate, recordDate) = 1"
                    },
                    {
                        "username": "ann1996015",
                        "content": "This is my code, i think it is very hard ==\\n\\nSELECT DISTINCT  w2.id\\nFROM Weather w1\\nLEFT JOIN Weather w2 ON ABS(DATEDIFF(day,w2.recordDate, w1.recordDate)) = 1\\nWHERE w2.temperature > w1.temperature and w2.recordDate>w1.recordDate"
                    }
                ]
            },
            {
                "id": 1572856,
                "content": [
                    {
                        "username": "frunfola1229",
                        "content": "\\n**SELECT**  w1.Id \\n**FROM**     Weather w1, Weather w2\\n**WHERE**   dateDiff(w1.Date,w2.Date) = 1        **AND**    w1.Temperature > w2.Temperature;"
                    },
                    {
                        "username": "Vipul_Chaudhary_2003",
                        "content": "Okay great.\nNow let's read rules together\n\nDiscussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jargolastik",
                        "content": "[@user8224IM](/user8224IM) self join creates every possible combination of columns so that means that you can just filter out the rows where the current temp is greater than yesterday\\'s"
                    },
                    {
                        "username": "JerryBlank",
                        "content": "[@user8224IM](/user8224IM) They have created 2 copies of the same table w1 and w2 and comparing each and every row. \\nSelecting only the ids for rows where \\nw1.date - w2.date =1 means that w1 is the date of next day to w2 (example: 2nd August - 1st August =1)\\nAND\\nw1.Temperature > w2.Temperature means Temperature on Date w1 is greater than Temperature on Date w2. \\n\\nso that would get Id with higher temperatures compared to its previous dates (yesterday).\\nHope this helps!"
                    },
                    {
                        "username": "user8224IM",
                        "content": "can you explain how/why this works please\\n"
                    },
                    {
                        "username": "chriszeng8",
                        "content": "Why is subtracting 1 directly from Date not working, but subdate(a.Date,1) works?\\n\\nMy code is \\n\\n    select W1.Id\\n    from Weather as W1, Weather as W2\\n    where W1.Date-1 = W2.Date and W1.Temperature> W2.Temperature\\n\\nit only passed 13/14 cases.\\n\\nHowever, when I changed `W1.Date-1` to `sub(W1.Date,1)` in the where clause, it worked. What is fundamental difference?"
                    },
                    {
                        "username": "Lysa123",
                        "content": "[@minhphamduy](/minhphamduy) cho m\\xECnh h\\u1ECFi v\\xEC sao ph\\u1EA3i c\\xF3 ch\\u1EEF subquery \\u1EDF cu\\u1ED1i v?\\n"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "I think you not should do that, use date_add instead\\n# Write your MySQL query statement below\\n\\nselect id\\nfrom (\\n    select w1.id\\n    from weather w1, weather w2\\n    where w1.recordDate= DATE_ADD(w2.recordDate, interval 1 day) and w1.temperature > w2.temperature\\n) subquery"
                    },
                    {
                        "username": "har0101",
                        "content": "date is not int"
                    },
                    {
                        "username": "291831388",
                        "content": "[@michaelniki](/michaelniki)  Thank your for your response, it really helps me."
                    },
                    {
                        "username": "michaelniki",
                        "content": "subtracting 1 does not work for the date at the end of the month or year.\nTake this test case for example:\n\n| id | recordDate | temperature |\n| -- | ---------- | ----------- |\n| 1  | 2014-12-31 | 1           |\n| 2  | 2015-01-01 | 10          |\n| 3  | 2015-01-02 | 25          |\n\nrecordDate of id 2 (2015-01-01) - 1 does not equal to  2014-12-31\n\n```\nselect\n    *\n    , w1.recordDate - w2.recordDate\nfrom\n    weather w1, weather w2\norder by w1.id\n\n```\n\n| id | recordDate | temperature | id | recordDate | temperature | w1.recordDate - w2.recordDate |\n| -- | ---------- | ----------- | -- | ---------- | ----------- | ----------------------------- |\n| 1  | 2014-12-31 | 1           | 1  | 2014-12-31 | 1           | 0                             |\n| 1  | 2014-12-31 | 1           | 2  | 2015-01-01 | 10          | -8870                         |\n| 1  | 2014-12-31 | 1           | 3  | 2015-01-02 | 25          | -8871                         |\n| 2  | 2015-01-01 | 10          | 1  | 2014-12-31 | 1           | 8870                          |\n| 2  | 2015-01-01 | 10          | 2  | 2015-01-01 | 10          | 0                             |\n| 2  | 2015-01-01 | 10          | 3  | 2015-01-02 | 25          | -1                            |\n| 3  | 2015-01-02 | 25          | 1  | 2014-12-31 | 1           | 8871                          |\n| 3  | 2015-01-02 | 25          | 2  | 2015-01-01 | 10          | 1                             |\n| 3  | 2015-01-02 | 25          | 3  | 2015-01-02 | 25          | 0                             |\n"
                    },
                    {
                        "username": "suraj21193",
                        "content": "Its is running successfully but not able to submit!\\nSelect a.id\\nfrom \\n(Select id, temperature, lag(temperature) over(order by recordDate) as lt,\\ncase when temperature>lag(temperature) over(order by recordDate) then \\'High\\'\\nelse \\'Low\\'\\nend as \\'Status\\'\\nfrom Weather) a\\nwhere Status = \\'High\\';"
                    },
                    {
                        "username": "themanutdmaniac",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) the reason is that the test case has 2 dates with a day missing in between."
                    },
                    {
                        "username": "Palash5043",
                        "content": "\nselect x.Id from (\nselect Id,\n       recordDate,\n       temperature as temp,\n    lag(temperature,1) over(order by recordDate asc) as pre_day_temp\n    from weather) x\n    where x.temp>x.pre_day_temp;\n\nI am also facing the similar issue "
                    },
                    {
                        "username": "kashrex",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) test cases are failing because the dates have to be exact previous date. \"2000-12-14 |     |2000-12-16\"  have a date difference of more than 1 day."
                    },
                    {
                        "username": "jingpingyu1127",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) I think this is because that we are finding records with only 1 day difference. The records in the test case is using date with 2 days difference, which should not return anything for the output."
                    },
                    {
                        "username": "avinashkumarjha05",
                        "content": "mine too ... have u understood why the test case failing?\\n"
                    },
                    {
                        "username": "sandeep_kumar_75",
                        "content": "**SELECT a.id\\nFROM Weather a, Weather b\\nWHERE datediff(a.recordDate, b.recordDate) = 1\\nAND a.temperature > b.temperature;**"
                    },
                    {
                        "username": "themanutdmaniac",
                        "content": "Wow, what a solution. GOAT. amazing. all the best sandeep."
                    },
                    {
                        "username": "xudaiyanzi",
                        "content": "Hi everyone, I tried the query below. It works when I run MySQL, but it can not work when it is submitted.  Please help me. Thank you.\\n# Write your MySQL query statement below\\nSELECT y.id\\nFROM Weather x\\nLEFT JOIN Weather y ON x.Id +1 = y.Id\\nWHERE x.Temperature < y.Temperature\\n"
                    },
                    {
                        "username": "cassiellong1113",
                        "content": "date is not ascending sorted, and thus if you do not compare with dates but with ID, you may get wrong answer "
                    },
                    {
                        "username": "Avazbeka_dev",
                        "content": "SELECT a.id\\nFROM Weather as a,Weather as b\\nWHERE a.temperature>b.temperature\\nAND DATEDIFF(a.recordDate,b.recordDate)=1\\n\\nYou must check the datas !"
                    },
                    {
                        "username": "patnanavarun",
                        "content": "you are just checking the id values .But not comparing the dates.\\n"
                    },
                    {
                        "username": "snehanshu17",
                        "content": "with tmp as (\\nselect id ,RecordDate,Temperature,\\nLAG (Temperature,1) OVER (ORDER BY RecordDate) AS prev_Temperature,\\n    LAG (RecordDate,1) OVER (ORDER BY RecordDate) AS prev_RecordDate\\nfrom Weather)\\n\\nselect id  from tmp where Temperature>prev_Temperature and (RecordDate-prev_RecordDate)=1"
                    },
                    {
                        "username": "mr-xed",
                        "content": "Really interesting approach, except it didn\\'t work for me from the get go for some reason, how ever I was able to solve it using `dateDiff(RecordDate, prev_RecordDate)` instead of `(RecordDate-prev_RecordDate)`"
                    },
                    {
                        "username": "XinyiQiu",
                        "content": "WITH yesterday AS (SELECT id,recordDate,temperature,DATE_SUB(recordDate, INTERVAL 1 DAY) AS yesterday\\nFROM Weather)\\n\\nSELECT yesterday.id\\nFROM yesterday LEFT JOIN Weather on yesterday.yesterday = Weather.recordDate\\nWHERE Weather.temperature IS NOT NULL AND yesterday.temperature > Weather.temperature"
                    },
                    {
                        "username": "nasirxia",
                        "content": "the idea is brilliant but why make things complicated? There should be a reasons for doing this."
                    },
                    {
                        "username": "anand_vineet19",
                        "content": "# Write your MySQL query statement below\\nSELECT id\\nFROM\\n(\\nSELECT id, recordDate, temperature AS today_temp, LAG(temperature,1) OVER (ORDER BY recordDate) AS yesterday_temp, LAG(recordDate,1) OVER (ORDER BY recordDate) AS yes_date\\n\\nFROM Weather\\n) AS temp_table\\n\\nWHERE today_temp>yesterday_temp AND DATEDIFF(recordDate,yes_date)=1"
                    },
                    {
                        "username": "priyarb96",
                        "content": "Simple and neat query"
                    },
                    {
                        "username": "abebe_1983",
                        "content": "we need to rearrange this query a little bit as follows \\nwith CTE as (\\nselect\\nid,recordDate as [date], temperature as temp,\\nlag(temperature) over(order by recordDate,id) as prev_temp,\\nlag(recordDate) over(order by recordDate,id) as prev_date\\nfrom Weather\\n)\\n\\nselect\\nid\\nfrom CTE\\nwhere temp > prev_temp and datediff(day,  prev_date, [date] ) = 1\\n\\n\\n"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect a.id\\nfrom weather a\\ninner join weather b\\non datediff(day, b.recordDate, a.recordDate) = 1\\nand a.temperature > b.temperature\\n\\n2)\\nwith cte as\\n(select *, \\n        lag(temperature)over(order by recordDate) as perviousTemp,\\n        lag(recordDate)over(order by recordDate) as perviousDate\\nfrom weather)\\nselect id from cte where temperature > perviousTemp and datediff(day, perviousDate, recordDate) = 1"
                    },
                    {
                        "username": "ann1996015",
                        "content": "This is my code, i think it is very hard ==\\n\\nSELECT DISTINCT  w2.id\\nFROM Weather w1\\nLEFT JOIN Weather w2 ON ABS(DATEDIFF(day,w2.recordDate, w1.recordDate)) = 1\\nWHERE w2.temperature > w1.temperature and w2.recordDate>w1.recordDate"
                    }
                ]
            },
            {
                "id": 1576214,
                "content": [
                    {
                        "username": "frunfola1229",
                        "content": "\\n**SELECT**  w1.Id \\n**FROM**     Weather w1, Weather w2\\n**WHERE**   dateDiff(w1.Date,w2.Date) = 1        **AND**    w1.Temperature > w2.Temperature;"
                    },
                    {
                        "username": "Vipul_Chaudhary_2003",
                        "content": "Okay great.\nNow let's read rules together\n\nDiscussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jargolastik",
                        "content": "[@user8224IM](/user8224IM) self join creates every possible combination of columns so that means that you can just filter out the rows where the current temp is greater than yesterday\\'s"
                    },
                    {
                        "username": "JerryBlank",
                        "content": "[@user8224IM](/user8224IM) They have created 2 copies of the same table w1 and w2 and comparing each and every row. \\nSelecting only the ids for rows where \\nw1.date - w2.date =1 means that w1 is the date of next day to w2 (example: 2nd August - 1st August =1)\\nAND\\nw1.Temperature > w2.Temperature means Temperature on Date w1 is greater than Temperature on Date w2. \\n\\nso that would get Id with higher temperatures compared to its previous dates (yesterday).\\nHope this helps!"
                    },
                    {
                        "username": "user8224IM",
                        "content": "can you explain how/why this works please\\n"
                    },
                    {
                        "username": "chriszeng8",
                        "content": "Why is subtracting 1 directly from Date not working, but subdate(a.Date,1) works?\\n\\nMy code is \\n\\n    select W1.Id\\n    from Weather as W1, Weather as W2\\n    where W1.Date-1 = W2.Date and W1.Temperature> W2.Temperature\\n\\nit only passed 13/14 cases.\\n\\nHowever, when I changed `W1.Date-1` to `sub(W1.Date,1)` in the where clause, it worked. What is fundamental difference?"
                    },
                    {
                        "username": "Lysa123",
                        "content": "[@minhphamduy](/minhphamduy) cho m\\xECnh h\\u1ECFi v\\xEC sao ph\\u1EA3i c\\xF3 ch\\u1EEF subquery \\u1EDF cu\\u1ED1i v?\\n"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "I think you not should do that, use date_add instead\\n# Write your MySQL query statement below\\n\\nselect id\\nfrom (\\n    select w1.id\\n    from weather w1, weather w2\\n    where w1.recordDate= DATE_ADD(w2.recordDate, interval 1 day) and w1.temperature > w2.temperature\\n) subquery"
                    },
                    {
                        "username": "har0101",
                        "content": "date is not int"
                    },
                    {
                        "username": "291831388",
                        "content": "[@michaelniki](/michaelniki)  Thank your for your response, it really helps me."
                    },
                    {
                        "username": "michaelniki",
                        "content": "subtracting 1 does not work for the date at the end of the month or year.\nTake this test case for example:\n\n| id | recordDate | temperature |\n| -- | ---------- | ----------- |\n| 1  | 2014-12-31 | 1           |\n| 2  | 2015-01-01 | 10          |\n| 3  | 2015-01-02 | 25          |\n\nrecordDate of id 2 (2015-01-01) - 1 does not equal to  2014-12-31\n\n```\nselect\n    *\n    , w1.recordDate - w2.recordDate\nfrom\n    weather w1, weather w2\norder by w1.id\n\n```\n\n| id | recordDate | temperature | id | recordDate | temperature | w1.recordDate - w2.recordDate |\n| -- | ---------- | ----------- | -- | ---------- | ----------- | ----------------------------- |\n| 1  | 2014-12-31 | 1           | 1  | 2014-12-31 | 1           | 0                             |\n| 1  | 2014-12-31 | 1           | 2  | 2015-01-01 | 10          | -8870                         |\n| 1  | 2014-12-31 | 1           | 3  | 2015-01-02 | 25          | -8871                         |\n| 2  | 2015-01-01 | 10          | 1  | 2014-12-31 | 1           | 8870                          |\n| 2  | 2015-01-01 | 10          | 2  | 2015-01-01 | 10          | 0                             |\n| 2  | 2015-01-01 | 10          | 3  | 2015-01-02 | 25          | -1                            |\n| 3  | 2015-01-02 | 25          | 1  | 2014-12-31 | 1           | 8871                          |\n| 3  | 2015-01-02 | 25          | 2  | 2015-01-01 | 10          | 1                             |\n| 3  | 2015-01-02 | 25          | 3  | 2015-01-02 | 25          | 0                             |\n"
                    },
                    {
                        "username": "suraj21193",
                        "content": "Its is running successfully but not able to submit!\\nSelect a.id\\nfrom \\n(Select id, temperature, lag(temperature) over(order by recordDate) as lt,\\ncase when temperature>lag(temperature) over(order by recordDate) then \\'High\\'\\nelse \\'Low\\'\\nend as \\'Status\\'\\nfrom Weather) a\\nwhere Status = \\'High\\';"
                    },
                    {
                        "username": "themanutdmaniac",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) the reason is that the test case has 2 dates with a day missing in between."
                    },
                    {
                        "username": "Palash5043",
                        "content": "\nselect x.Id from (\nselect Id,\n       recordDate,\n       temperature as temp,\n    lag(temperature,1) over(order by recordDate asc) as pre_day_temp\n    from weather) x\n    where x.temp>x.pre_day_temp;\n\nI am also facing the similar issue "
                    },
                    {
                        "username": "kashrex",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) test cases are failing because the dates have to be exact previous date. \"2000-12-14 |     |2000-12-16\"  have a date difference of more than 1 day."
                    },
                    {
                        "username": "jingpingyu1127",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) I think this is because that we are finding records with only 1 day difference. The records in the test case is using date with 2 days difference, which should not return anything for the output."
                    },
                    {
                        "username": "avinashkumarjha05",
                        "content": "mine too ... have u understood why the test case failing?\\n"
                    },
                    {
                        "username": "sandeep_kumar_75",
                        "content": "**SELECT a.id\\nFROM Weather a, Weather b\\nWHERE datediff(a.recordDate, b.recordDate) = 1\\nAND a.temperature > b.temperature;**"
                    },
                    {
                        "username": "themanutdmaniac",
                        "content": "Wow, what a solution. GOAT. amazing. all the best sandeep."
                    },
                    {
                        "username": "xudaiyanzi",
                        "content": "Hi everyone, I tried the query below. It works when I run MySQL, but it can not work when it is submitted.  Please help me. Thank you.\\n# Write your MySQL query statement below\\nSELECT y.id\\nFROM Weather x\\nLEFT JOIN Weather y ON x.Id +1 = y.Id\\nWHERE x.Temperature < y.Temperature\\n"
                    },
                    {
                        "username": "cassiellong1113",
                        "content": "date is not ascending sorted, and thus if you do not compare with dates but with ID, you may get wrong answer "
                    },
                    {
                        "username": "Avazbeka_dev",
                        "content": "SELECT a.id\\nFROM Weather as a,Weather as b\\nWHERE a.temperature>b.temperature\\nAND DATEDIFF(a.recordDate,b.recordDate)=1\\n\\nYou must check the datas !"
                    },
                    {
                        "username": "patnanavarun",
                        "content": "you are just checking the id values .But not comparing the dates.\\n"
                    },
                    {
                        "username": "snehanshu17",
                        "content": "with tmp as (\\nselect id ,RecordDate,Temperature,\\nLAG (Temperature,1) OVER (ORDER BY RecordDate) AS prev_Temperature,\\n    LAG (RecordDate,1) OVER (ORDER BY RecordDate) AS prev_RecordDate\\nfrom Weather)\\n\\nselect id  from tmp where Temperature>prev_Temperature and (RecordDate-prev_RecordDate)=1"
                    },
                    {
                        "username": "mr-xed",
                        "content": "Really interesting approach, except it didn\\'t work for me from the get go for some reason, how ever I was able to solve it using `dateDiff(RecordDate, prev_RecordDate)` instead of `(RecordDate-prev_RecordDate)`"
                    },
                    {
                        "username": "XinyiQiu",
                        "content": "WITH yesterday AS (SELECT id,recordDate,temperature,DATE_SUB(recordDate, INTERVAL 1 DAY) AS yesterday\\nFROM Weather)\\n\\nSELECT yesterday.id\\nFROM yesterday LEFT JOIN Weather on yesterday.yesterday = Weather.recordDate\\nWHERE Weather.temperature IS NOT NULL AND yesterday.temperature > Weather.temperature"
                    },
                    {
                        "username": "nasirxia",
                        "content": "the idea is brilliant but why make things complicated? There should be a reasons for doing this."
                    },
                    {
                        "username": "anand_vineet19",
                        "content": "# Write your MySQL query statement below\\nSELECT id\\nFROM\\n(\\nSELECT id, recordDate, temperature AS today_temp, LAG(temperature,1) OVER (ORDER BY recordDate) AS yesterday_temp, LAG(recordDate,1) OVER (ORDER BY recordDate) AS yes_date\\n\\nFROM Weather\\n) AS temp_table\\n\\nWHERE today_temp>yesterday_temp AND DATEDIFF(recordDate,yes_date)=1"
                    },
                    {
                        "username": "priyarb96",
                        "content": "Simple and neat query"
                    },
                    {
                        "username": "abebe_1983",
                        "content": "we need to rearrange this query a little bit as follows \\nwith CTE as (\\nselect\\nid,recordDate as [date], temperature as temp,\\nlag(temperature) over(order by recordDate,id) as prev_temp,\\nlag(recordDate) over(order by recordDate,id) as prev_date\\nfrom Weather\\n)\\n\\nselect\\nid\\nfrom CTE\\nwhere temp > prev_temp and datediff(day,  prev_date, [date] ) = 1\\n\\n\\n"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect a.id\\nfrom weather a\\ninner join weather b\\non datediff(day, b.recordDate, a.recordDate) = 1\\nand a.temperature > b.temperature\\n\\n2)\\nwith cte as\\n(select *, \\n        lag(temperature)over(order by recordDate) as perviousTemp,\\n        lag(recordDate)over(order by recordDate) as perviousDate\\nfrom weather)\\nselect id from cte where temperature > perviousTemp and datediff(day, perviousDate, recordDate) = 1"
                    },
                    {
                        "username": "ann1996015",
                        "content": "This is my code, i think it is very hard ==\\n\\nSELECT DISTINCT  w2.id\\nFROM Weather w1\\nLEFT JOIN Weather w2 ON ABS(DATEDIFF(day,w2.recordDate, w1.recordDate)) = 1\\nWHERE w2.temperature > w1.temperature and w2.recordDate>w1.recordDate"
                    }
                ]
            },
            {
                "id": 1576015,
                "content": [
                    {
                        "username": "frunfola1229",
                        "content": "\\n**SELECT**  w1.Id \\n**FROM**     Weather w1, Weather w2\\n**WHERE**   dateDiff(w1.Date,w2.Date) = 1        **AND**    w1.Temperature > w2.Temperature;"
                    },
                    {
                        "username": "Vipul_Chaudhary_2003",
                        "content": "Okay great.\nNow let's read rules together\n\nDiscussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jargolastik",
                        "content": "[@user8224IM](/user8224IM) self join creates every possible combination of columns so that means that you can just filter out the rows where the current temp is greater than yesterday\\'s"
                    },
                    {
                        "username": "JerryBlank",
                        "content": "[@user8224IM](/user8224IM) They have created 2 copies of the same table w1 and w2 and comparing each and every row. \\nSelecting only the ids for rows where \\nw1.date - w2.date =1 means that w1 is the date of next day to w2 (example: 2nd August - 1st August =1)\\nAND\\nw1.Temperature > w2.Temperature means Temperature on Date w1 is greater than Temperature on Date w2. \\n\\nso that would get Id with higher temperatures compared to its previous dates (yesterday).\\nHope this helps!"
                    },
                    {
                        "username": "user8224IM",
                        "content": "can you explain how/why this works please\\n"
                    },
                    {
                        "username": "chriszeng8",
                        "content": "Why is subtracting 1 directly from Date not working, but subdate(a.Date,1) works?\\n\\nMy code is \\n\\n    select W1.Id\\n    from Weather as W1, Weather as W2\\n    where W1.Date-1 = W2.Date and W1.Temperature> W2.Temperature\\n\\nit only passed 13/14 cases.\\n\\nHowever, when I changed `W1.Date-1` to `sub(W1.Date,1)` in the where clause, it worked. What is fundamental difference?"
                    },
                    {
                        "username": "Lysa123",
                        "content": "[@minhphamduy](/minhphamduy) cho m\\xECnh h\\u1ECFi v\\xEC sao ph\\u1EA3i c\\xF3 ch\\u1EEF subquery \\u1EDF cu\\u1ED1i v?\\n"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "I think you not should do that, use date_add instead\\n# Write your MySQL query statement below\\n\\nselect id\\nfrom (\\n    select w1.id\\n    from weather w1, weather w2\\n    where w1.recordDate= DATE_ADD(w2.recordDate, interval 1 day) and w1.temperature > w2.temperature\\n) subquery"
                    },
                    {
                        "username": "har0101",
                        "content": "date is not int"
                    },
                    {
                        "username": "291831388",
                        "content": "[@michaelniki](/michaelniki)  Thank your for your response, it really helps me."
                    },
                    {
                        "username": "michaelniki",
                        "content": "subtracting 1 does not work for the date at the end of the month or year.\nTake this test case for example:\n\n| id | recordDate | temperature |\n| -- | ---------- | ----------- |\n| 1  | 2014-12-31 | 1           |\n| 2  | 2015-01-01 | 10          |\n| 3  | 2015-01-02 | 25          |\n\nrecordDate of id 2 (2015-01-01) - 1 does not equal to  2014-12-31\n\n```\nselect\n    *\n    , w1.recordDate - w2.recordDate\nfrom\n    weather w1, weather w2\norder by w1.id\n\n```\n\n| id | recordDate | temperature | id | recordDate | temperature | w1.recordDate - w2.recordDate |\n| -- | ---------- | ----------- | -- | ---------- | ----------- | ----------------------------- |\n| 1  | 2014-12-31 | 1           | 1  | 2014-12-31 | 1           | 0                             |\n| 1  | 2014-12-31 | 1           | 2  | 2015-01-01 | 10          | -8870                         |\n| 1  | 2014-12-31 | 1           | 3  | 2015-01-02 | 25          | -8871                         |\n| 2  | 2015-01-01 | 10          | 1  | 2014-12-31 | 1           | 8870                          |\n| 2  | 2015-01-01 | 10          | 2  | 2015-01-01 | 10          | 0                             |\n| 2  | 2015-01-01 | 10          | 3  | 2015-01-02 | 25          | -1                            |\n| 3  | 2015-01-02 | 25          | 1  | 2014-12-31 | 1           | 8871                          |\n| 3  | 2015-01-02 | 25          | 2  | 2015-01-01 | 10          | 1                             |\n| 3  | 2015-01-02 | 25          | 3  | 2015-01-02 | 25          | 0                             |\n"
                    },
                    {
                        "username": "suraj21193",
                        "content": "Its is running successfully but not able to submit!\\nSelect a.id\\nfrom \\n(Select id, temperature, lag(temperature) over(order by recordDate) as lt,\\ncase when temperature>lag(temperature) over(order by recordDate) then \\'High\\'\\nelse \\'Low\\'\\nend as \\'Status\\'\\nfrom Weather) a\\nwhere Status = \\'High\\';"
                    },
                    {
                        "username": "themanutdmaniac",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) the reason is that the test case has 2 dates with a day missing in between."
                    },
                    {
                        "username": "Palash5043",
                        "content": "\nselect x.Id from (\nselect Id,\n       recordDate,\n       temperature as temp,\n    lag(temperature,1) over(order by recordDate asc) as pre_day_temp\n    from weather) x\n    where x.temp>x.pre_day_temp;\n\nI am also facing the similar issue "
                    },
                    {
                        "username": "kashrex",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) test cases are failing because the dates have to be exact previous date. \"2000-12-14 |     |2000-12-16\"  have a date difference of more than 1 day."
                    },
                    {
                        "username": "jingpingyu1127",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) I think this is because that we are finding records with only 1 day difference. The records in the test case is using date with 2 days difference, which should not return anything for the output."
                    },
                    {
                        "username": "avinashkumarjha05",
                        "content": "mine too ... have u understood why the test case failing?\\n"
                    },
                    {
                        "username": "sandeep_kumar_75",
                        "content": "**SELECT a.id\\nFROM Weather a, Weather b\\nWHERE datediff(a.recordDate, b.recordDate) = 1\\nAND a.temperature > b.temperature;**"
                    },
                    {
                        "username": "themanutdmaniac",
                        "content": "Wow, what a solution. GOAT. amazing. all the best sandeep."
                    },
                    {
                        "username": "xudaiyanzi",
                        "content": "Hi everyone, I tried the query below. It works when I run MySQL, but it can not work when it is submitted.  Please help me. Thank you.\\n# Write your MySQL query statement below\\nSELECT y.id\\nFROM Weather x\\nLEFT JOIN Weather y ON x.Id +1 = y.Id\\nWHERE x.Temperature < y.Temperature\\n"
                    },
                    {
                        "username": "cassiellong1113",
                        "content": "date is not ascending sorted, and thus if you do not compare with dates but with ID, you may get wrong answer "
                    },
                    {
                        "username": "Avazbeka_dev",
                        "content": "SELECT a.id\\nFROM Weather as a,Weather as b\\nWHERE a.temperature>b.temperature\\nAND DATEDIFF(a.recordDate,b.recordDate)=1\\n\\nYou must check the datas !"
                    },
                    {
                        "username": "patnanavarun",
                        "content": "you are just checking the id values .But not comparing the dates.\\n"
                    },
                    {
                        "username": "snehanshu17",
                        "content": "with tmp as (\\nselect id ,RecordDate,Temperature,\\nLAG (Temperature,1) OVER (ORDER BY RecordDate) AS prev_Temperature,\\n    LAG (RecordDate,1) OVER (ORDER BY RecordDate) AS prev_RecordDate\\nfrom Weather)\\n\\nselect id  from tmp where Temperature>prev_Temperature and (RecordDate-prev_RecordDate)=1"
                    },
                    {
                        "username": "mr-xed",
                        "content": "Really interesting approach, except it didn\\'t work for me from the get go for some reason, how ever I was able to solve it using `dateDiff(RecordDate, prev_RecordDate)` instead of `(RecordDate-prev_RecordDate)`"
                    },
                    {
                        "username": "XinyiQiu",
                        "content": "WITH yesterday AS (SELECT id,recordDate,temperature,DATE_SUB(recordDate, INTERVAL 1 DAY) AS yesterday\\nFROM Weather)\\n\\nSELECT yesterday.id\\nFROM yesterday LEFT JOIN Weather on yesterday.yesterday = Weather.recordDate\\nWHERE Weather.temperature IS NOT NULL AND yesterday.temperature > Weather.temperature"
                    },
                    {
                        "username": "nasirxia",
                        "content": "the idea is brilliant but why make things complicated? There should be a reasons for doing this."
                    },
                    {
                        "username": "anand_vineet19",
                        "content": "# Write your MySQL query statement below\\nSELECT id\\nFROM\\n(\\nSELECT id, recordDate, temperature AS today_temp, LAG(temperature,1) OVER (ORDER BY recordDate) AS yesterday_temp, LAG(recordDate,1) OVER (ORDER BY recordDate) AS yes_date\\n\\nFROM Weather\\n) AS temp_table\\n\\nWHERE today_temp>yesterday_temp AND DATEDIFF(recordDate,yes_date)=1"
                    },
                    {
                        "username": "priyarb96",
                        "content": "Simple and neat query"
                    },
                    {
                        "username": "abebe_1983",
                        "content": "we need to rearrange this query a little bit as follows \\nwith CTE as (\\nselect\\nid,recordDate as [date], temperature as temp,\\nlag(temperature) over(order by recordDate,id) as prev_temp,\\nlag(recordDate) over(order by recordDate,id) as prev_date\\nfrom Weather\\n)\\n\\nselect\\nid\\nfrom CTE\\nwhere temp > prev_temp and datediff(day,  prev_date, [date] ) = 1\\n\\n\\n"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect a.id\\nfrom weather a\\ninner join weather b\\non datediff(day, b.recordDate, a.recordDate) = 1\\nand a.temperature > b.temperature\\n\\n2)\\nwith cte as\\n(select *, \\n        lag(temperature)over(order by recordDate) as perviousTemp,\\n        lag(recordDate)over(order by recordDate) as perviousDate\\nfrom weather)\\nselect id from cte where temperature > perviousTemp and datediff(day, perviousDate, recordDate) = 1"
                    },
                    {
                        "username": "ann1996015",
                        "content": "This is my code, i think it is very hard ==\\n\\nSELECT DISTINCT  w2.id\\nFROM Weather w1\\nLEFT JOIN Weather w2 ON ABS(DATEDIFF(day,w2.recordDate, w1.recordDate)) = 1\\nWHERE w2.temperature > w1.temperature and w2.recordDate>w1.recordDate"
                    }
                ]
            },
            {
                "id": 1576857,
                "content": [
                    {
                        "username": "frunfola1229",
                        "content": "\\n**SELECT**  w1.Id \\n**FROM**     Weather w1, Weather w2\\n**WHERE**   dateDiff(w1.Date,w2.Date) = 1        **AND**    w1.Temperature > w2.Temperature;"
                    },
                    {
                        "username": "Vipul_Chaudhary_2003",
                        "content": "Okay great.\nNow let's read rules together\n\nDiscussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jargolastik",
                        "content": "[@user8224IM](/user8224IM) self join creates every possible combination of columns so that means that you can just filter out the rows where the current temp is greater than yesterday\\'s"
                    },
                    {
                        "username": "JerryBlank",
                        "content": "[@user8224IM](/user8224IM) They have created 2 copies of the same table w1 and w2 and comparing each and every row. \\nSelecting only the ids for rows where \\nw1.date - w2.date =1 means that w1 is the date of next day to w2 (example: 2nd August - 1st August =1)\\nAND\\nw1.Temperature > w2.Temperature means Temperature on Date w1 is greater than Temperature on Date w2. \\n\\nso that would get Id with higher temperatures compared to its previous dates (yesterday).\\nHope this helps!"
                    },
                    {
                        "username": "user8224IM",
                        "content": "can you explain how/why this works please\\n"
                    },
                    {
                        "username": "chriszeng8",
                        "content": "Why is subtracting 1 directly from Date not working, but subdate(a.Date,1) works?\\n\\nMy code is \\n\\n    select W1.Id\\n    from Weather as W1, Weather as W2\\n    where W1.Date-1 = W2.Date and W1.Temperature> W2.Temperature\\n\\nit only passed 13/14 cases.\\n\\nHowever, when I changed `W1.Date-1` to `sub(W1.Date,1)` in the where clause, it worked. What is fundamental difference?"
                    },
                    {
                        "username": "Lysa123",
                        "content": "[@minhphamduy](/minhphamduy) cho m\\xECnh h\\u1ECFi v\\xEC sao ph\\u1EA3i c\\xF3 ch\\u1EEF subquery \\u1EDF cu\\u1ED1i v?\\n"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "I think you not should do that, use date_add instead\\n# Write your MySQL query statement below\\n\\nselect id\\nfrom (\\n    select w1.id\\n    from weather w1, weather w2\\n    where w1.recordDate= DATE_ADD(w2.recordDate, interval 1 day) and w1.temperature > w2.temperature\\n) subquery"
                    },
                    {
                        "username": "har0101",
                        "content": "date is not int"
                    },
                    {
                        "username": "291831388",
                        "content": "[@michaelniki](/michaelniki)  Thank your for your response, it really helps me."
                    },
                    {
                        "username": "michaelniki",
                        "content": "subtracting 1 does not work for the date at the end of the month or year.\nTake this test case for example:\n\n| id | recordDate | temperature |\n| -- | ---------- | ----------- |\n| 1  | 2014-12-31 | 1           |\n| 2  | 2015-01-01 | 10          |\n| 3  | 2015-01-02 | 25          |\n\nrecordDate of id 2 (2015-01-01) - 1 does not equal to  2014-12-31\n\n```\nselect\n    *\n    , w1.recordDate - w2.recordDate\nfrom\n    weather w1, weather w2\norder by w1.id\n\n```\n\n| id | recordDate | temperature | id | recordDate | temperature | w1.recordDate - w2.recordDate |\n| -- | ---------- | ----------- | -- | ---------- | ----------- | ----------------------------- |\n| 1  | 2014-12-31 | 1           | 1  | 2014-12-31 | 1           | 0                             |\n| 1  | 2014-12-31 | 1           | 2  | 2015-01-01 | 10          | -8870                         |\n| 1  | 2014-12-31 | 1           | 3  | 2015-01-02 | 25          | -8871                         |\n| 2  | 2015-01-01 | 10          | 1  | 2014-12-31 | 1           | 8870                          |\n| 2  | 2015-01-01 | 10          | 2  | 2015-01-01 | 10          | 0                             |\n| 2  | 2015-01-01 | 10          | 3  | 2015-01-02 | 25          | -1                            |\n| 3  | 2015-01-02 | 25          | 1  | 2014-12-31 | 1           | 8871                          |\n| 3  | 2015-01-02 | 25          | 2  | 2015-01-01 | 10          | 1                             |\n| 3  | 2015-01-02 | 25          | 3  | 2015-01-02 | 25          | 0                             |\n"
                    },
                    {
                        "username": "suraj21193",
                        "content": "Its is running successfully but not able to submit!\\nSelect a.id\\nfrom \\n(Select id, temperature, lag(temperature) over(order by recordDate) as lt,\\ncase when temperature>lag(temperature) over(order by recordDate) then \\'High\\'\\nelse \\'Low\\'\\nend as \\'Status\\'\\nfrom Weather) a\\nwhere Status = \\'High\\';"
                    },
                    {
                        "username": "themanutdmaniac",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) the reason is that the test case has 2 dates with a day missing in between."
                    },
                    {
                        "username": "Palash5043",
                        "content": "\nselect x.Id from (\nselect Id,\n       recordDate,\n       temperature as temp,\n    lag(temperature,1) over(order by recordDate asc) as pre_day_temp\n    from weather) x\n    where x.temp>x.pre_day_temp;\n\nI am also facing the similar issue "
                    },
                    {
                        "username": "kashrex",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) test cases are failing because the dates have to be exact previous date. \"2000-12-14 |     |2000-12-16\"  have a date difference of more than 1 day."
                    },
                    {
                        "username": "jingpingyu1127",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) I think this is because that we are finding records with only 1 day difference. The records in the test case is using date with 2 days difference, which should not return anything for the output."
                    },
                    {
                        "username": "avinashkumarjha05",
                        "content": "mine too ... have u understood why the test case failing?\\n"
                    },
                    {
                        "username": "sandeep_kumar_75",
                        "content": "**SELECT a.id\\nFROM Weather a, Weather b\\nWHERE datediff(a.recordDate, b.recordDate) = 1\\nAND a.temperature > b.temperature;**"
                    },
                    {
                        "username": "themanutdmaniac",
                        "content": "Wow, what a solution. GOAT. amazing. all the best sandeep."
                    },
                    {
                        "username": "xudaiyanzi",
                        "content": "Hi everyone, I tried the query below. It works when I run MySQL, but it can not work when it is submitted.  Please help me. Thank you.\\n# Write your MySQL query statement below\\nSELECT y.id\\nFROM Weather x\\nLEFT JOIN Weather y ON x.Id +1 = y.Id\\nWHERE x.Temperature < y.Temperature\\n"
                    },
                    {
                        "username": "cassiellong1113",
                        "content": "date is not ascending sorted, and thus if you do not compare with dates but with ID, you may get wrong answer "
                    },
                    {
                        "username": "Avazbeka_dev",
                        "content": "SELECT a.id\\nFROM Weather as a,Weather as b\\nWHERE a.temperature>b.temperature\\nAND DATEDIFF(a.recordDate,b.recordDate)=1\\n\\nYou must check the datas !"
                    },
                    {
                        "username": "patnanavarun",
                        "content": "you are just checking the id values .But not comparing the dates.\\n"
                    },
                    {
                        "username": "snehanshu17",
                        "content": "with tmp as (\\nselect id ,RecordDate,Temperature,\\nLAG (Temperature,1) OVER (ORDER BY RecordDate) AS prev_Temperature,\\n    LAG (RecordDate,1) OVER (ORDER BY RecordDate) AS prev_RecordDate\\nfrom Weather)\\n\\nselect id  from tmp where Temperature>prev_Temperature and (RecordDate-prev_RecordDate)=1"
                    },
                    {
                        "username": "mr-xed",
                        "content": "Really interesting approach, except it didn\\'t work for me from the get go for some reason, how ever I was able to solve it using `dateDiff(RecordDate, prev_RecordDate)` instead of `(RecordDate-prev_RecordDate)`"
                    },
                    {
                        "username": "XinyiQiu",
                        "content": "WITH yesterday AS (SELECT id,recordDate,temperature,DATE_SUB(recordDate, INTERVAL 1 DAY) AS yesterday\\nFROM Weather)\\n\\nSELECT yesterday.id\\nFROM yesterday LEFT JOIN Weather on yesterday.yesterday = Weather.recordDate\\nWHERE Weather.temperature IS NOT NULL AND yesterday.temperature > Weather.temperature"
                    },
                    {
                        "username": "nasirxia",
                        "content": "the idea is brilliant but why make things complicated? There should be a reasons for doing this."
                    },
                    {
                        "username": "anand_vineet19",
                        "content": "# Write your MySQL query statement below\\nSELECT id\\nFROM\\n(\\nSELECT id, recordDate, temperature AS today_temp, LAG(temperature,1) OVER (ORDER BY recordDate) AS yesterday_temp, LAG(recordDate,1) OVER (ORDER BY recordDate) AS yes_date\\n\\nFROM Weather\\n) AS temp_table\\n\\nWHERE today_temp>yesterday_temp AND DATEDIFF(recordDate,yes_date)=1"
                    },
                    {
                        "username": "priyarb96",
                        "content": "Simple and neat query"
                    },
                    {
                        "username": "abebe_1983",
                        "content": "we need to rearrange this query a little bit as follows \\nwith CTE as (\\nselect\\nid,recordDate as [date], temperature as temp,\\nlag(temperature) over(order by recordDate,id) as prev_temp,\\nlag(recordDate) over(order by recordDate,id) as prev_date\\nfrom Weather\\n)\\n\\nselect\\nid\\nfrom CTE\\nwhere temp > prev_temp and datediff(day,  prev_date, [date] ) = 1\\n\\n\\n"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect a.id\\nfrom weather a\\ninner join weather b\\non datediff(day, b.recordDate, a.recordDate) = 1\\nand a.temperature > b.temperature\\n\\n2)\\nwith cte as\\n(select *, \\n        lag(temperature)over(order by recordDate) as perviousTemp,\\n        lag(recordDate)over(order by recordDate) as perviousDate\\nfrom weather)\\nselect id from cte where temperature > perviousTemp and datediff(day, perviousDate, recordDate) = 1"
                    },
                    {
                        "username": "ann1996015",
                        "content": "This is my code, i think it is very hard ==\\n\\nSELECT DISTINCT  w2.id\\nFROM Weather w1\\nLEFT JOIN Weather w2 ON ABS(DATEDIFF(day,w2.recordDate, w1.recordDate)) = 1\\nWHERE w2.temperature > w1.temperature and w2.recordDate>w1.recordDate"
                    }
                ]
            },
            {
                "id": 1883213,
                "content": [
                    {
                        "username": "frunfola1229",
                        "content": "\\n**SELECT**  w1.Id \\n**FROM**     Weather w1, Weather w2\\n**WHERE**   dateDiff(w1.Date,w2.Date) = 1        **AND**    w1.Temperature > w2.Temperature;"
                    },
                    {
                        "username": "Vipul_Chaudhary_2003",
                        "content": "Okay great.\nNow let's read rules together\n\nDiscussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jargolastik",
                        "content": "[@user8224IM](/user8224IM) self join creates every possible combination of columns so that means that you can just filter out the rows where the current temp is greater than yesterday\\'s"
                    },
                    {
                        "username": "JerryBlank",
                        "content": "[@user8224IM](/user8224IM) They have created 2 copies of the same table w1 and w2 and comparing each and every row. \\nSelecting only the ids for rows where \\nw1.date - w2.date =1 means that w1 is the date of next day to w2 (example: 2nd August - 1st August =1)\\nAND\\nw1.Temperature > w2.Temperature means Temperature on Date w1 is greater than Temperature on Date w2. \\n\\nso that would get Id with higher temperatures compared to its previous dates (yesterday).\\nHope this helps!"
                    },
                    {
                        "username": "user8224IM",
                        "content": "can you explain how/why this works please\\n"
                    },
                    {
                        "username": "chriszeng8",
                        "content": "Why is subtracting 1 directly from Date not working, but subdate(a.Date,1) works?\\n\\nMy code is \\n\\n    select W1.Id\\n    from Weather as W1, Weather as W2\\n    where W1.Date-1 = W2.Date and W1.Temperature> W2.Temperature\\n\\nit only passed 13/14 cases.\\n\\nHowever, when I changed `W1.Date-1` to `sub(W1.Date,1)` in the where clause, it worked. What is fundamental difference?"
                    },
                    {
                        "username": "Lysa123",
                        "content": "[@minhphamduy](/minhphamduy) cho m\\xECnh h\\u1ECFi v\\xEC sao ph\\u1EA3i c\\xF3 ch\\u1EEF subquery \\u1EDF cu\\u1ED1i v?\\n"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "I think you not should do that, use date_add instead\\n# Write your MySQL query statement below\\n\\nselect id\\nfrom (\\n    select w1.id\\n    from weather w1, weather w2\\n    where w1.recordDate= DATE_ADD(w2.recordDate, interval 1 day) and w1.temperature > w2.temperature\\n) subquery"
                    },
                    {
                        "username": "har0101",
                        "content": "date is not int"
                    },
                    {
                        "username": "291831388",
                        "content": "[@michaelniki](/michaelniki)  Thank your for your response, it really helps me."
                    },
                    {
                        "username": "michaelniki",
                        "content": "subtracting 1 does not work for the date at the end of the month or year.\nTake this test case for example:\n\n| id | recordDate | temperature |\n| -- | ---------- | ----------- |\n| 1  | 2014-12-31 | 1           |\n| 2  | 2015-01-01 | 10          |\n| 3  | 2015-01-02 | 25          |\n\nrecordDate of id 2 (2015-01-01) - 1 does not equal to  2014-12-31\n\n```\nselect\n    *\n    , w1.recordDate - w2.recordDate\nfrom\n    weather w1, weather w2\norder by w1.id\n\n```\n\n| id | recordDate | temperature | id | recordDate | temperature | w1.recordDate - w2.recordDate |\n| -- | ---------- | ----------- | -- | ---------- | ----------- | ----------------------------- |\n| 1  | 2014-12-31 | 1           | 1  | 2014-12-31 | 1           | 0                             |\n| 1  | 2014-12-31 | 1           | 2  | 2015-01-01 | 10          | -8870                         |\n| 1  | 2014-12-31 | 1           | 3  | 2015-01-02 | 25          | -8871                         |\n| 2  | 2015-01-01 | 10          | 1  | 2014-12-31 | 1           | 8870                          |\n| 2  | 2015-01-01 | 10          | 2  | 2015-01-01 | 10          | 0                             |\n| 2  | 2015-01-01 | 10          | 3  | 2015-01-02 | 25          | -1                            |\n| 3  | 2015-01-02 | 25          | 1  | 2014-12-31 | 1           | 8871                          |\n| 3  | 2015-01-02 | 25          | 2  | 2015-01-01 | 10          | 1                             |\n| 3  | 2015-01-02 | 25          | 3  | 2015-01-02 | 25          | 0                             |\n"
                    },
                    {
                        "username": "suraj21193",
                        "content": "Its is running successfully but not able to submit!\\nSelect a.id\\nfrom \\n(Select id, temperature, lag(temperature) over(order by recordDate) as lt,\\ncase when temperature>lag(temperature) over(order by recordDate) then \\'High\\'\\nelse \\'Low\\'\\nend as \\'Status\\'\\nfrom Weather) a\\nwhere Status = \\'High\\';"
                    },
                    {
                        "username": "themanutdmaniac",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) the reason is that the test case has 2 dates with a day missing in between."
                    },
                    {
                        "username": "Palash5043",
                        "content": "\nselect x.Id from (\nselect Id,\n       recordDate,\n       temperature as temp,\n    lag(temperature,1) over(order by recordDate asc) as pre_day_temp\n    from weather) x\n    where x.temp>x.pre_day_temp;\n\nI am also facing the similar issue "
                    },
                    {
                        "username": "kashrex",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) test cases are failing because the dates have to be exact previous date. \"2000-12-14 |     |2000-12-16\"  have a date difference of more than 1 day."
                    },
                    {
                        "username": "jingpingyu1127",
                        "content": "[@avinashkumarjha05](/avinashkumarjha05) I think this is because that we are finding records with only 1 day difference. The records in the test case is using date with 2 days difference, which should not return anything for the output."
                    },
                    {
                        "username": "avinashkumarjha05",
                        "content": "mine too ... have u understood why the test case failing?\\n"
                    },
                    {
                        "username": "sandeep_kumar_75",
                        "content": "**SELECT a.id\\nFROM Weather a, Weather b\\nWHERE datediff(a.recordDate, b.recordDate) = 1\\nAND a.temperature > b.temperature;**"
                    },
                    {
                        "username": "themanutdmaniac",
                        "content": "Wow, what a solution. GOAT. amazing. all the best sandeep."
                    },
                    {
                        "username": "xudaiyanzi",
                        "content": "Hi everyone, I tried the query below. It works when I run MySQL, but it can not work when it is submitted.  Please help me. Thank you.\\n# Write your MySQL query statement below\\nSELECT y.id\\nFROM Weather x\\nLEFT JOIN Weather y ON x.Id +1 = y.Id\\nWHERE x.Temperature < y.Temperature\\n"
                    },
                    {
                        "username": "cassiellong1113",
                        "content": "date is not ascending sorted, and thus if you do not compare with dates but with ID, you may get wrong answer "
                    },
                    {
                        "username": "Avazbeka_dev",
                        "content": "SELECT a.id\\nFROM Weather as a,Weather as b\\nWHERE a.temperature>b.temperature\\nAND DATEDIFF(a.recordDate,b.recordDate)=1\\n\\nYou must check the datas !"
                    },
                    {
                        "username": "patnanavarun",
                        "content": "you are just checking the id values .But not comparing the dates.\\n"
                    },
                    {
                        "username": "snehanshu17",
                        "content": "with tmp as (\\nselect id ,RecordDate,Temperature,\\nLAG (Temperature,1) OVER (ORDER BY RecordDate) AS prev_Temperature,\\n    LAG (RecordDate,1) OVER (ORDER BY RecordDate) AS prev_RecordDate\\nfrom Weather)\\n\\nselect id  from tmp where Temperature>prev_Temperature and (RecordDate-prev_RecordDate)=1"
                    },
                    {
                        "username": "mr-xed",
                        "content": "Really interesting approach, except it didn\\'t work for me from the get go for some reason, how ever I was able to solve it using `dateDiff(RecordDate, prev_RecordDate)` instead of `(RecordDate-prev_RecordDate)`"
                    },
                    {
                        "username": "XinyiQiu",
                        "content": "WITH yesterday AS (SELECT id,recordDate,temperature,DATE_SUB(recordDate, INTERVAL 1 DAY) AS yesterday\\nFROM Weather)\\n\\nSELECT yesterday.id\\nFROM yesterday LEFT JOIN Weather on yesterday.yesterday = Weather.recordDate\\nWHERE Weather.temperature IS NOT NULL AND yesterday.temperature > Weather.temperature"
                    },
                    {
                        "username": "nasirxia",
                        "content": "the idea is brilliant but why make things complicated? There should be a reasons for doing this."
                    },
                    {
                        "username": "anand_vineet19",
                        "content": "# Write your MySQL query statement below\\nSELECT id\\nFROM\\n(\\nSELECT id, recordDate, temperature AS today_temp, LAG(temperature,1) OVER (ORDER BY recordDate) AS yesterday_temp, LAG(recordDate,1) OVER (ORDER BY recordDate) AS yes_date\\n\\nFROM Weather\\n) AS temp_table\\n\\nWHERE today_temp>yesterday_temp AND DATEDIFF(recordDate,yes_date)=1"
                    },
                    {
                        "username": "priyarb96",
                        "content": "Simple and neat query"
                    },
                    {
                        "username": "abebe_1983",
                        "content": "we need to rearrange this query a little bit as follows \\nwith CTE as (\\nselect\\nid,recordDate as [date], temperature as temp,\\nlag(temperature) over(order by recordDate,id) as prev_temp,\\nlag(recordDate) over(order by recordDate,id) as prev_date\\nfrom Weather\\n)\\n\\nselect\\nid\\nfrom CTE\\nwhere temp > prev_temp and datediff(day,  prev_date, [date] ) = 1\\n\\n\\n"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect a.id\\nfrom weather a\\ninner join weather b\\non datediff(day, b.recordDate, a.recordDate) = 1\\nand a.temperature > b.temperature\\n\\n2)\\nwith cte as\\n(select *, \\n        lag(temperature)over(order by recordDate) as perviousTemp,\\n        lag(recordDate)over(order by recordDate) as perviousDate\\nfrom weather)\\nselect id from cte where temperature > perviousTemp and datediff(day, perviousDate, recordDate) = 1"
                    },
                    {
                        "username": "ann1996015",
                        "content": "This is my code, i think it is very hard ==\\n\\nSELECT DISTINCT  w2.id\\nFROM Weather w1\\nLEFT JOIN Weather w2 ON ABS(DATEDIFF(day,w2.recordDate, w1.recordDate)) = 1\\nWHERE w2.temperature > w1.temperature and w2.recordDate>w1.recordDate"
                    }
                ]
            },
            {
                "id": 1818339,
                "content": [
                    {
                        "username": "Imelman",
                        "content": "| id | recordDate | temperature |\\n| -- | ------------  | ----------- |\\n| 1  | 2000-12-14 |     3           |\\n| 2  | 2000-12-16 |     5           |\\n\\nIn this test my answer is \"Id 2\". Why is it wrong? He has a higher temperature than the previous day."
                    },
                    {
                        "username": "dk9571288791",
                        "content": "I think this is because previous day of 2000-12-16 is 2000-12-15 (it is not in the table) not 2000-12-14. So, your query should  consider a null as previous temperature for the date 2000-12-16."
                    },
                    {
                        "username": "DanielAlegriaLino",
                        "content": "Same Error "
                    },
                    {
                        "username": "marchodl",
                        "content": "\\'\\'\\'\\nwith CTE as (\\nselect\\nid,recordDate as date, temperature as temp,\\nlag(temperature) over(order by recordDate,id) as prev_temp,\\nlag(recordDate) over(order by recordDate,id) as prev_date\\nfrom Weather \\n)\\n\\n\\nselect\\nid\\nfrom CTE\\nwhere temp > prev_temp and (date - prev_date =1 )\\n\\'\\'\\'"
                    },
                    {
                        "username": "vaishvel",
                        "content": "**Working Solution:**\\n\\nwith cte as\\n(select *, lag(temperature,1) over (order by RecordDate) as prev_t,\\n            lag(RecordDate,1) over (order by RecordDate) as prev_d\\nfrom weather)\\n\\nselect id from cte \\nwhere temperature>prev_t\\nand datediff(RecordDate,prev_d)=1\\n\\n\\n**Wrong Answer**: *[2] only not the expected [2],[4]*\\n\\nwith cte as\\n(select *, lead(temperature,1) over (order by RecordDate) as n_t,\\n            lead(RecordDate,1) over (order by RecordDate) as n_d\\nfrom weather)\\n\\nselect id from cte \\nwhere temperature>n_t"
                    },
                    {
                        "username": "mahala",
                        "content": "Hi all,\\n\\nI have written down two queries. Kindly let me know which query is optimized query and is efficient? If I am having billions of rows, then which query is good?\\n\\n# Method 1:\\nselect w1.id from weather as w1\\ninner join weather as w2\\non datediff(w1.recordDate,w2.recordDate) = 1\\nand w1.temperature > w2.temperature;\\n\\n# Method 2:\\nselect w1.id from weather as w1\\ninner join weather as w2\\non datediff(w1.recordDate,w2.recordDate) = 1\\nwhere w1.temperature > w2.temperature;"
                    },
                    {
                        "username": "dana777",
                        "content": "\\'\\'\\'\\nselect w2.id\\nfrom weather w1, weather w2\\nwhere w1.temperature < w2.temperature\\n      and ADDDATE(W1.RecordDate, 1) = W2.RecordDate\\n\\'\\'\\'"
                    },
                    {
                        "username": "minhbgbgvn",
                        "content": "`\\nSELECT d2.Id as Id \\nFROM Weather d1, Weather d2 \\nWHERE d2.Temperature > d1.Temperature \\n\\tAND TRUNC(d2.RecordDate) - TRUNC(d1.RecordDate) = 1\\n`"
                    },
                    {
                        "username": "s9811219",
                        "content": "Hi,\\n\\nHere\\'s the Mandarin Chinese version to explain this problem in MySQL with 2 solutions.\\nWelcome to discuss together and join this projects!\\n\\n[[\\u4F86\\u5B78\\u8CC7\\u6599\\u5EAB] LeetCode DataBase SQL \\u89C0\\u5FF5\\u89E3\\u6790(07): #197. Rising Temperature](https://medium.com/@s9811219/rising-temperature-leetcode-4cde8ad1e681)\\n\\n![image](https://assets.leetcode.com/users/s9811219/image_1574246339.png)\\n"
                    },
                    {
                        "username": "legbird3",
                        "content": "If use \"full join\" or \"full outer join\" instead of \"join\", it will throw a runtime error. Anybody knows why?"
                    },
                    {
                        "username": "louisepenberthy",
                        "content": "Mysql doesn\\'t have a full join."
                    },
                    {
                        "username": "skbysp",
                        "content": "I learn for mysql just few days, my solution was as following:\\nselect t1.Id from Weather as t1, Weather as t2 where datediff(t1.Date, t2.Date)=1 and (t1.Temperature - t2.Temperature) > 0;"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "/* Write your PL/SQL query statement below */\\nwith cte as (\\nSELECT Id,temperature, LAG(temperature,1) OVER (\\n\\t\\tORDER BY recordDate\\n\\t) as py_temp,recordDate,\\nlag (recordDate,1) over (order by recordDate) as py_record_date\\n\\nFROM WEATHER \\n) select id from cte where temperature > py_temp and (recordDate-py_record_date)=1;"
                    }
                ]
            },
            {
                "id": 1575998,
                "content": [
                    {
                        "username": "Imelman",
                        "content": "| id | recordDate | temperature |\\n| -- | ------------  | ----------- |\\n| 1  | 2000-12-14 |     3           |\\n| 2  | 2000-12-16 |     5           |\\n\\nIn this test my answer is \"Id 2\". Why is it wrong? He has a higher temperature than the previous day."
                    },
                    {
                        "username": "dk9571288791",
                        "content": "I think this is because previous day of 2000-12-16 is 2000-12-15 (it is not in the table) not 2000-12-14. So, your query should  consider a null as previous temperature for the date 2000-12-16."
                    },
                    {
                        "username": "DanielAlegriaLino",
                        "content": "Same Error "
                    },
                    {
                        "username": "marchodl",
                        "content": "\\'\\'\\'\\nwith CTE as (\\nselect\\nid,recordDate as date, temperature as temp,\\nlag(temperature) over(order by recordDate,id) as prev_temp,\\nlag(recordDate) over(order by recordDate,id) as prev_date\\nfrom Weather \\n)\\n\\n\\nselect\\nid\\nfrom CTE\\nwhere temp > prev_temp and (date - prev_date =1 )\\n\\'\\'\\'"
                    },
                    {
                        "username": "vaishvel",
                        "content": "**Working Solution:**\\n\\nwith cte as\\n(select *, lag(temperature,1) over (order by RecordDate) as prev_t,\\n            lag(RecordDate,1) over (order by RecordDate) as prev_d\\nfrom weather)\\n\\nselect id from cte \\nwhere temperature>prev_t\\nand datediff(RecordDate,prev_d)=1\\n\\n\\n**Wrong Answer**: *[2] only not the expected [2],[4]*\\n\\nwith cte as\\n(select *, lead(temperature,1) over (order by RecordDate) as n_t,\\n            lead(RecordDate,1) over (order by RecordDate) as n_d\\nfrom weather)\\n\\nselect id from cte \\nwhere temperature>n_t"
                    },
                    {
                        "username": "mahala",
                        "content": "Hi all,\\n\\nI have written down two queries. Kindly let me know which query is optimized query and is efficient? If I am having billions of rows, then which query is good?\\n\\n# Method 1:\\nselect w1.id from weather as w1\\ninner join weather as w2\\non datediff(w1.recordDate,w2.recordDate) = 1\\nand w1.temperature > w2.temperature;\\n\\n# Method 2:\\nselect w1.id from weather as w1\\ninner join weather as w2\\non datediff(w1.recordDate,w2.recordDate) = 1\\nwhere w1.temperature > w2.temperature;"
                    },
                    {
                        "username": "dana777",
                        "content": "\\'\\'\\'\\nselect w2.id\\nfrom weather w1, weather w2\\nwhere w1.temperature < w2.temperature\\n      and ADDDATE(W1.RecordDate, 1) = W2.RecordDate\\n\\'\\'\\'"
                    },
                    {
                        "username": "minhbgbgvn",
                        "content": "`\\nSELECT d2.Id as Id \\nFROM Weather d1, Weather d2 \\nWHERE d2.Temperature > d1.Temperature \\n\\tAND TRUNC(d2.RecordDate) - TRUNC(d1.RecordDate) = 1\\n`"
                    },
                    {
                        "username": "s9811219",
                        "content": "Hi,\\n\\nHere\\'s the Mandarin Chinese version to explain this problem in MySQL with 2 solutions.\\nWelcome to discuss together and join this projects!\\n\\n[[\\u4F86\\u5B78\\u8CC7\\u6599\\u5EAB] LeetCode DataBase SQL \\u89C0\\u5FF5\\u89E3\\u6790(07): #197. Rising Temperature](https://medium.com/@s9811219/rising-temperature-leetcode-4cde8ad1e681)\\n\\n![image](https://assets.leetcode.com/users/s9811219/image_1574246339.png)\\n"
                    },
                    {
                        "username": "legbird3",
                        "content": "If use \"full join\" or \"full outer join\" instead of \"join\", it will throw a runtime error. Anybody knows why?"
                    },
                    {
                        "username": "louisepenberthy",
                        "content": "Mysql doesn\\'t have a full join."
                    },
                    {
                        "username": "skbysp",
                        "content": "I learn for mysql just few days, my solution was as following:\\nselect t1.Id from Weather as t1, Weather as t2 where datediff(t1.Date, t2.Date)=1 and (t1.Temperature - t2.Temperature) > 0;"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "/* Write your PL/SQL query statement below */\\nwith cte as (\\nSELECT Id,temperature, LAG(temperature,1) OVER (\\n\\t\\tORDER BY recordDate\\n\\t) as py_temp,recordDate,\\nlag (recordDate,1) over (order by recordDate) as py_record_date\\n\\nFROM WEATHER \\n) select id from cte where temperature > py_temp and (recordDate-py_record_date)=1;"
                    }
                ]
            },
            {
                "id": 1575760,
                "content": [
                    {
                        "username": "Imelman",
                        "content": "| id | recordDate | temperature |\\n| -- | ------------  | ----------- |\\n| 1  | 2000-12-14 |     3           |\\n| 2  | 2000-12-16 |     5           |\\n\\nIn this test my answer is \"Id 2\". Why is it wrong? He has a higher temperature than the previous day."
                    },
                    {
                        "username": "dk9571288791",
                        "content": "I think this is because previous day of 2000-12-16 is 2000-12-15 (it is not in the table) not 2000-12-14. So, your query should  consider a null as previous temperature for the date 2000-12-16."
                    },
                    {
                        "username": "DanielAlegriaLino",
                        "content": "Same Error "
                    },
                    {
                        "username": "marchodl",
                        "content": "\\'\\'\\'\\nwith CTE as (\\nselect\\nid,recordDate as date, temperature as temp,\\nlag(temperature) over(order by recordDate,id) as prev_temp,\\nlag(recordDate) over(order by recordDate,id) as prev_date\\nfrom Weather \\n)\\n\\n\\nselect\\nid\\nfrom CTE\\nwhere temp > prev_temp and (date - prev_date =1 )\\n\\'\\'\\'"
                    },
                    {
                        "username": "vaishvel",
                        "content": "**Working Solution:**\\n\\nwith cte as\\n(select *, lag(temperature,1) over (order by RecordDate) as prev_t,\\n            lag(RecordDate,1) over (order by RecordDate) as prev_d\\nfrom weather)\\n\\nselect id from cte \\nwhere temperature>prev_t\\nand datediff(RecordDate,prev_d)=1\\n\\n\\n**Wrong Answer**: *[2] only not the expected [2],[4]*\\n\\nwith cte as\\n(select *, lead(temperature,1) over (order by RecordDate) as n_t,\\n            lead(RecordDate,1) over (order by RecordDate) as n_d\\nfrom weather)\\n\\nselect id from cte \\nwhere temperature>n_t"
                    },
                    {
                        "username": "mahala",
                        "content": "Hi all,\\n\\nI have written down two queries. Kindly let me know which query is optimized query and is efficient? If I am having billions of rows, then which query is good?\\n\\n# Method 1:\\nselect w1.id from weather as w1\\ninner join weather as w2\\non datediff(w1.recordDate,w2.recordDate) = 1\\nand w1.temperature > w2.temperature;\\n\\n# Method 2:\\nselect w1.id from weather as w1\\ninner join weather as w2\\non datediff(w1.recordDate,w2.recordDate) = 1\\nwhere w1.temperature > w2.temperature;"
                    },
                    {
                        "username": "dana777",
                        "content": "\\'\\'\\'\\nselect w2.id\\nfrom weather w1, weather w2\\nwhere w1.temperature < w2.temperature\\n      and ADDDATE(W1.RecordDate, 1) = W2.RecordDate\\n\\'\\'\\'"
                    },
                    {
                        "username": "minhbgbgvn",
                        "content": "`\\nSELECT d2.Id as Id \\nFROM Weather d1, Weather d2 \\nWHERE d2.Temperature > d1.Temperature \\n\\tAND TRUNC(d2.RecordDate) - TRUNC(d1.RecordDate) = 1\\n`"
                    },
                    {
                        "username": "s9811219",
                        "content": "Hi,\\n\\nHere\\'s the Mandarin Chinese version to explain this problem in MySQL with 2 solutions.\\nWelcome to discuss together and join this projects!\\n\\n[[\\u4F86\\u5B78\\u8CC7\\u6599\\u5EAB] LeetCode DataBase SQL \\u89C0\\u5FF5\\u89E3\\u6790(07): #197. Rising Temperature](https://medium.com/@s9811219/rising-temperature-leetcode-4cde8ad1e681)\\n\\n![image](https://assets.leetcode.com/users/s9811219/image_1574246339.png)\\n"
                    },
                    {
                        "username": "legbird3",
                        "content": "If use \"full join\" or \"full outer join\" instead of \"join\", it will throw a runtime error. Anybody knows why?"
                    },
                    {
                        "username": "louisepenberthy",
                        "content": "Mysql doesn\\'t have a full join."
                    },
                    {
                        "username": "skbysp",
                        "content": "I learn for mysql just few days, my solution was as following:\\nselect t1.Id from Weather as t1, Weather as t2 where datediff(t1.Date, t2.Date)=1 and (t1.Temperature - t2.Temperature) > 0;"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "/* Write your PL/SQL query statement below */\\nwith cte as (\\nSELECT Id,temperature, LAG(temperature,1) OVER (\\n\\t\\tORDER BY recordDate\\n\\t) as py_temp,recordDate,\\nlag (recordDate,1) over (order by recordDate) as py_record_date\\n\\nFROM WEATHER \\n) select id from cte where temperature > py_temp and (recordDate-py_record_date)=1;"
                    }
                ]
            },
            {
                "id": 1575702,
                "content": [
                    {
                        "username": "Imelman",
                        "content": "| id | recordDate | temperature |\\n| -- | ------------  | ----------- |\\n| 1  | 2000-12-14 |     3           |\\n| 2  | 2000-12-16 |     5           |\\n\\nIn this test my answer is \"Id 2\". Why is it wrong? He has a higher temperature than the previous day."
                    },
                    {
                        "username": "dk9571288791",
                        "content": "I think this is because previous day of 2000-12-16 is 2000-12-15 (it is not in the table) not 2000-12-14. So, your query should  consider a null as previous temperature for the date 2000-12-16."
                    },
                    {
                        "username": "DanielAlegriaLino",
                        "content": "Same Error "
                    },
                    {
                        "username": "marchodl",
                        "content": "\\'\\'\\'\\nwith CTE as (\\nselect\\nid,recordDate as date, temperature as temp,\\nlag(temperature) over(order by recordDate,id) as prev_temp,\\nlag(recordDate) over(order by recordDate,id) as prev_date\\nfrom Weather \\n)\\n\\n\\nselect\\nid\\nfrom CTE\\nwhere temp > prev_temp and (date - prev_date =1 )\\n\\'\\'\\'"
                    },
                    {
                        "username": "vaishvel",
                        "content": "**Working Solution:**\\n\\nwith cte as\\n(select *, lag(temperature,1) over (order by RecordDate) as prev_t,\\n            lag(RecordDate,1) over (order by RecordDate) as prev_d\\nfrom weather)\\n\\nselect id from cte \\nwhere temperature>prev_t\\nand datediff(RecordDate,prev_d)=1\\n\\n\\n**Wrong Answer**: *[2] only not the expected [2],[4]*\\n\\nwith cte as\\n(select *, lead(temperature,1) over (order by RecordDate) as n_t,\\n            lead(RecordDate,1) over (order by RecordDate) as n_d\\nfrom weather)\\n\\nselect id from cte \\nwhere temperature>n_t"
                    },
                    {
                        "username": "mahala",
                        "content": "Hi all,\\n\\nI have written down two queries. Kindly let me know which query is optimized query and is efficient? If I am having billions of rows, then which query is good?\\n\\n# Method 1:\\nselect w1.id from weather as w1\\ninner join weather as w2\\non datediff(w1.recordDate,w2.recordDate) = 1\\nand w1.temperature > w2.temperature;\\n\\n# Method 2:\\nselect w1.id from weather as w1\\ninner join weather as w2\\non datediff(w1.recordDate,w2.recordDate) = 1\\nwhere w1.temperature > w2.temperature;"
                    },
                    {
                        "username": "dana777",
                        "content": "\\'\\'\\'\\nselect w2.id\\nfrom weather w1, weather w2\\nwhere w1.temperature < w2.temperature\\n      and ADDDATE(W1.RecordDate, 1) = W2.RecordDate\\n\\'\\'\\'"
                    },
                    {
                        "username": "minhbgbgvn",
                        "content": "`\\nSELECT d2.Id as Id \\nFROM Weather d1, Weather d2 \\nWHERE d2.Temperature > d1.Temperature \\n\\tAND TRUNC(d2.RecordDate) - TRUNC(d1.RecordDate) = 1\\n`"
                    },
                    {
                        "username": "s9811219",
                        "content": "Hi,\\n\\nHere\\'s the Mandarin Chinese version to explain this problem in MySQL with 2 solutions.\\nWelcome to discuss together and join this projects!\\n\\n[[\\u4F86\\u5B78\\u8CC7\\u6599\\u5EAB] LeetCode DataBase SQL \\u89C0\\u5FF5\\u89E3\\u6790(07): #197. Rising Temperature](https://medium.com/@s9811219/rising-temperature-leetcode-4cde8ad1e681)\\n\\n![image](https://assets.leetcode.com/users/s9811219/image_1574246339.png)\\n"
                    },
                    {
                        "username": "legbird3",
                        "content": "If use \"full join\" or \"full outer join\" instead of \"join\", it will throw a runtime error. Anybody knows why?"
                    },
                    {
                        "username": "louisepenberthy",
                        "content": "Mysql doesn\\'t have a full join."
                    },
                    {
                        "username": "skbysp",
                        "content": "I learn for mysql just few days, my solution was as following:\\nselect t1.Id from Weather as t1, Weather as t2 where datediff(t1.Date, t2.Date)=1 and (t1.Temperature - t2.Temperature) > 0;"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "/* Write your PL/SQL query statement below */\\nwith cte as (\\nSELECT Id,temperature, LAG(temperature,1) OVER (\\n\\t\\tORDER BY recordDate\\n\\t) as py_temp,recordDate,\\nlag (recordDate,1) over (order by recordDate) as py_record_date\\n\\nFROM WEATHER \\n) select id from cte where temperature > py_temp and (recordDate-py_record_date)=1;"
                    }
                ]
            },
            {
                "id": 1574353,
                "content": [
                    {
                        "username": "Imelman",
                        "content": "| id | recordDate | temperature |\\n| -- | ------------  | ----------- |\\n| 1  | 2000-12-14 |     3           |\\n| 2  | 2000-12-16 |     5           |\\n\\nIn this test my answer is \"Id 2\". Why is it wrong? He has a higher temperature than the previous day."
                    },
                    {
                        "username": "dk9571288791",
                        "content": "I think this is because previous day of 2000-12-16 is 2000-12-15 (it is not in the table) not 2000-12-14. So, your query should  consider a null as previous temperature for the date 2000-12-16."
                    },
                    {
                        "username": "DanielAlegriaLino",
                        "content": "Same Error "
                    },
                    {
                        "username": "marchodl",
                        "content": "\\'\\'\\'\\nwith CTE as (\\nselect\\nid,recordDate as date, temperature as temp,\\nlag(temperature) over(order by recordDate,id) as prev_temp,\\nlag(recordDate) over(order by recordDate,id) as prev_date\\nfrom Weather \\n)\\n\\n\\nselect\\nid\\nfrom CTE\\nwhere temp > prev_temp and (date - prev_date =1 )\\n\\'\\'\\'"
                    },
                    {
                        "username": "vaishvel",
                        "content": "**Working Solution:**\\n\\nwith cte as\\n(select *, lag(temperature,1) over (order by RecordDate) as prev_t,\\n            lag(RecordDate,1) over (order by RecordDate) as prev_d\\nfrom weather)\\n\\nselect id from cte \\nwhere temperature>prev_t\\nand datediff(RecordDate,prev_d)=1\\n\\n\\n**Wrong Answer**: *[2] only not the expected [2],[4]*\\n\\nwith cte as\\n(select *, lead(temperature,1) over (order by RecordDate) as n_t,\\n            lead(RecordDate,1) over (order by RecordDate) as n_d\\nfrom weather)\\n\\nselect id from cte \\nwhere temperature>n_t"
                    },
                    {
                        "username": "mahala",
                        "content": "Hi all,\\n\\nI have written down two queries. Kindly let me know which query is optimized query and is efficient? If I am having billions of rows, then which query is good?\\n\\n# Method 1:\\nselect w1.id from weather as w1\\ninner join weather as w2\\non datediff(w1.recordDate,w2.recordDate) = 1\\nand w1.temperature > w2.temperature;\\n\\n# Method 2:\\nselect w1.id from weather as w1\\ninner join weather as w2\\non datediff(w1.recordDate,w2.recordDate) = 1\\nwhere w1.temperature > w2.temperature;"
                    },
                    {
                        "username": "dana777",
                        "content": "\\'\\'\\'\\nselect w2.id\\nfrom weather w1, weather w2\\nwhere w1.temperature < w2.temperature\\n      and ADDDATE(W1.RecordDate, 1) = W2.RecordDate\\n\\'\\'\\'"
                    },
                    {
                        "username": "minhbgbgvn",
                        "content": "`\\nSELECT d2.Id as Id \\nFROM Weather d1, Weather d2 \\nWHERE d2.Temperature > d1.Temperature \\n\\tAND TRUNC(d2.RecordDate) - TRUNC(d1.RecordDate) = 1\\n`"
                    },
                    {
                        "username": "s9811219",
                        "content": "Hi,\\n\\nHere\\'s the Mandarin Chinese version to explain this problem in MySQL with 2 solutions.\\nWelcome to discuss together and join this projects!\\n\\n[[\\u4F86\\u5B78\\u8CC7\\u6599\\u5EAB] LeetCode DataBase SQL \\u89C0\\u5FF5\\u89E3\\u6790(07): #197. Rising Temperature](https://medium.com/@s9811219/rising-temperature-leetcode-4cde8ad1e681)\\n\\n![image](https://assets.leetcode.com/users/s9811219/image_1574246339.png)\\n"
                    },
                    {
                        "username": "legbird3",
                        "content": "If use \"full join\" or \"full outer join\" instead of \"join\", it will throw a runtime error. Anybody knows why?"
                    },
                    {
                        "username": "louisepenberthy",
                        "content": "Mysql doesn\\'t have a full join."
                    },
                    {
                        "username": "skbysp",
                        "content": "I learn for mysql just few days, my solution was as following:\\nselect t1.Id from Weather as t1, Weather as t2 where datediff(t1.Date, t2.Date)=1 and (t1.Temperature - t2.Temperature) > 0;"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "/* Write your PL/SQL query statement below */\\nwith cte as (\\nSELECT Id,temperature, LAG(temperature,1) OVER (\\n\\t\\tORDER BY recordDate\\n\\t) as py_temp,recordDate,\\nlag (recordDate,1) over (order by recordDate) as py_record_date\\n\\nFROM WEATHER \\n) select id from cte where temperature > py_temp and (recordDate-py_record_date)=1;"
                    }
                ]
            },
            {
                "id": 1573458,
                "content": [
                    {
                        "username": "Imelman",
                        "content": "| id | recordDate | temperature |\\n| -- | ------------  | ----------- |\\n| 1  | 2000-12-14 |     3           |\\n| 2  | 2000-12-16 |     5           |\\n\\nIn this test my answer is \"Id 2\". Why is it wrong? He has a higher temperature than the previous day."
                    },
                    {
                        "username": "dk9571288791",
                        "content": "I think this is because previous day of 2000-12-16 is 2000-12-15 (it is not in the table) not 2000-12-14. So, your query should  consider a null as previous temperature for the date 2000-12-16."
                    },
                    {
                        "username": "DanielAlegriaLino",
                        "content": "Same Error "
                    },
                    {
                        "username": "marchodl",
                        "content": "\\'\\'\\'\\nwith CTE as (\\nselect\\nid,recordDate as date, temperature as temp,\\nlag(temperature) over(order by recordDate,id) as prev_temp,\\nlag(recordDate) over(order by recordDate,id) as prev_date\\nfrom Weather \\n)\\n\\n\\nselect\\nid\\nfrom CTE\\nwhere temp > prev_temp and (date - prev_date =1 )\\n\\'\\'\\'"
                    },
                    {
                        "username": "vaishvel",
                        "content": "**Working Solution:**\\n\\nwith cte as\\n(select *, lag(temperature,1) over (order by RecordDate) as prev_t,\\n            lag(RecordDate,1) over (order by RecordDate) as prev_d\\nfrom weather)\\n\\nselect id from cte \\nwhere temperature>prev_t\\nand datediff(RecordDate,prev_d)=1\\n\\n\\n**Wrong Answer**: *[2] only not the expected [2],[4]*\\n\\nwith cte as\\n(select *, lead(temperature,1) over (order by RecordDate) as n_t,\\n            lead(RecordDate,1) over (order by RecordDate) as n_d\\nfrom weather)\\n\\nselect id from cte \\nwhere temperature>n_t"
                    },
                    {
                        "username": "mahala",
                        "content": "Hi all,\\n\\nI have written down two queries. Kindly let me know which query is optimized query and is efficient? If I am having billions of rows, then which query is good?\\n\\n# Method 1:\\nselect w1.id from weather as w1\\ninner join weather as w2\\non datediff(w1.recordDate,w2.recordDate) = 1\\nand w1.temperature > w2.temperature;\\n\\n# Method 2:\\nselect w1.id from weather as w1\\ninner join weather as w2\\non datediff(w1.recordDate,w2.recordDate) = 1\\nwhere w1.temperature > w2.temperature;"
                    },
                    {
                        "username": "dana777",
                        "content": "\\'\\'\\'\\nselect w2.id\\nfrom weather w1, weather w2\\nwhere w1.temperature < w2.temperature\\n      and ADDDATE(W1.RecordDate, 1) = W2.RecordDate\\n\\'\\'\\'"
                    },
                    {
                        "username": "minhbgbgvn",
                        "content": "`\\nSELECT d2.Id as Id \\nFROM Weather d1, Weather d2 \\nWHERE d2.Temperature > d1.Temperature \\n\\tAND TRUNC(d2.RecordDate) - TRUNC(d1.RecordDate) = 1\\n`"
                    },
                    {
                        "username": "s9811219",
                        "content": "Hi,\\n\\nHere\\'s the Mandarin Chinese version to explain this problem in MySQL with 2 solutions.\\nWelcome to discuss together and join this projects!\\n\\n[[\\u4F86\\u5B78\\u8CC7\\u6599\\u5EAB] LeetCode DataBase SQL \\u89C0\\u5FF5\\u89E3\\u6790(07): #197. Rising Temperature](https://medium.com/@s9811219/rising-temperature-leetcode-4cde8ad1e681)\\n\\n![image](https://assets.leetcode.com/users/s9811219/image_1574246339.png)\\n"
                    },
                    {
                        "username": "legbird3",
                        "content": "If use \"full join\" or \"full outer join\" instead of \"join\", it will throw a runtime error. Anybody knows why?"
                    },
                    {
                        "username": "louisepenberthy",
                        "content": "Mysql doesn\\'t have a full join."
                    },
                    {
                        "username": "skbysp",
                        "content": "I learn for mysql just few days, my solution was as following:\\nselect t1.Id from Weather as t1, Weather as t2 where datediff(t1.Date, t2.Date)=1 and (t1.Temperature - t2.Temperature) > 0;"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "/* Write your PL/SQL query statement below */\\nwith cte as (\\nSELECT Id,temperature, LAG(temperature,1) OVER (\\n\\t\\tORDER BY recordDate\\n\\t) as py_temp,recordDate,\\nlag (recordDate,1) over (order by recordDate) as py_record_date\\n\\nFROM WEATHER \\n) select id from cte where temperature > py_temp and (recordDate-py_record_date)=1;"
                    }
                ]
            },
            {
                "id": 1573199,
                "content": [
                    {
                        "username": "Imelman",
                        "content": "| id | recordDate | temperature |\\n| -- | ------------  | ----------- |\\n| 1  | 2000-12-14 |     3           |\\n| 2  | 2000-12-16 |     5           |\\n\\nIn this test my answer is \"Id 2\". Why is it wrong? He has a higher temperature than the previous day."
                    },
                    {
                        "username": "dk9571288791",
                        "content": "I think this is because previous day of 2000-12-16 is 2000-12-15 (it is not in the table) not 2000-12-14. So, your query should  consider a null as previous temperature for the date 2000-12-16."
                    },
                    {
                        "username": "DanielAlegriaLino",
                        "content": "Same Error "
                    },
                    {
                        "username": "marchodl",
                        "content": "\\'\\'\\'\\nwith CTE as (\\nselect\\nid,recordDate as date, temperature as temp,\\nlag(temperature) over(order by recordDate,id) as prev_temp,\\nlag(recordDate) over(order by recordDate,id) as prev_date\\nfrom Weather \\n)\\n\\n\\nselect\\nid\\nfrom CTE\\nwhere temp > prev_temp and (date - prev_date =1 )\\n\\'\\'\\'"
                    },
                    {
                        "username": "vaishvel",
                        "content": "**Working Solution:**\\n\\nwith cte as\\n(select *, lag(temperature,1) over (order by RecordDate) as prev_t,\\n            lag(RecordDate,1) over (order by RecordDate) as prev_d\\nfrom weather)\\n\\nselect id from cte \\nwhere temperature>prev_t\\nand datediff(RecordDate,prev_d)=1\\n\\n\\n**Wrong Answer**: *[2] only not the expected [2],[4]*\\n\\nwith cte as\\n(select *, lead(temperature,1) over (order by RecordDate) as n_t,\\n            lead(RecordDate,1) over (order by RecordDate) as n_d\\nfrom weather)\\n\\nselect id from cte \\nwhere temperature>n_t"
                    },
                    {
                        "username": "mahala",
                        "content": "Hi all,\\n\\nI have written down two queries. Kindly let me know which query is optimized query and is efficient? If I am having billions of rows, then which query is good?\\n\\n# Method 1:\\nselect w1.id from weather as w1\\ninner join weather as w2\\non datediff(w1.recordDate,w2.recordDate) = 1\\nand w1.temperature > w2.temperature;\\n\\n# Method 2:\\nselect w1.id from weather as w1\\ninner join weather as w2\\non datediff(w1.recordDate,w2.recordDate) = 1\\nwhere w1.temperature > w2.temperature;"
                    },
                    {
                        "username": "dana777",
                        "content": "\\'\\'\\'\\nselect w2.id\\nfrom weather w1, weather w2\\nwhere w1.temperature < w2.temperature\\n      and ADDDATE(W1.RecordDate, 1) = W2.RecordDate\\n\\'\\'\\'"
                    },
                    {
                        "username": "minhbgbgvn",
                        "content": "`\\nSELECT d2.Id as Id \\nFROM Weather d1, Weather d2 \\nWHERE d2.Temperature > d1.Temperature \\n\\tAND TRUNC(d2.RecordDate) - TRUNC(d1.RecordDate) = 1\\n`"
                    },
                    {
                        "username": "s9811219",
                        "content": "Hi,\\n\\nHere\\'s the Mandarin Chinese version to explain this problem in MySQL with 2 solutions.\\nWelcome to discuss together and join this projects!\\n\\n[[\\u4F86\\u5B78\\u8CC7\\u6599\\u5EAB] LeetCode DataBase SQL \\u89C0\\u5FF5\\u89E3\\u6790(07): #197. Rising Temperature](https://medium.com/@s9811219/rising-temperature-leetcode-4cde8ad1e681)\\n\\n![image](https://assets.leetcode.com/users/s9811219/image_1574246339.png)\\n"
                    },
                    {
                        "username": "legbird3",
                        "content": "If use \"full join\" or \"full outer join\" instead of \"join\", it will throw a runtime error. Anybody knows why?"
                    },
                    {
                        "username": "louisepenberthy",
                        "content": "Mysql doesn\\'t have a full join."
                    },
                    {
                        "username": "skbysp",
                        "content": "I learn for mysql just few days, my solution was as following:\\nselect t1.Id from Weather as t1, Weather as t2 where datediff(t1.Date, t2.Date)=1 and (t1.Temperature - t2.Temperature) > 0;"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "/* Write your PL/SQL query statement below */\\nwith cte as (\\nSELECT Id,temperature, LAG(temperature,1) OVER (\\n\\t\\tORDER BY recordDate\\n\\t) as py_temp,recordDate,\\nlag (recordDate,1) over (order by recordDate) as py_record_date\\n\\nFROM WEATHER \\n) select id from cte where temperature > py_temp and (recordDate-py_record_date)=1;"
                    }
                ]
            },
            {
                "id": 1571834,
                "content": [
                    {
                        "username": "Imelman",
                        "content": "| id | recordDate | temperature |\\n| -- | ------------  | ----------- |\\n| 1  | 2000-12-14 |     3           |\\n| 2  | 2000-12-16 |     5           |\\n\\nIn this test my answer is \"Id 2\". Why is it wrong? He has a higher temperature than the previous day."
                    },
                    {
                        "username": "dk9571288791",
                        "content": "I think this is because previous day of 2000-12-16 is 2000-12-15 (it is not in the table) not 2000-12-14. So, your query should  consider a null as previous temperature for the date 2000-12-16."
                    },
                    {
                        "username": "DanielAlegriaLino",
                        "content": "Same Error "
                    },
                    {
                        "username": "marchodl",
                        "content": "\\'\\'\\'\\nwith CTE as (\\nselect\\nid,recordDate as date, temperature as temp,\\nlag(temperature) over(order by recordDate,id) as prev_temp,\\nlag(recordDate) over(order by recordDate,id) as prev_date\\nfrom Weather \\n)\\n\\n\\nselect\\nid\\nfrom CTE\\nwhere temp > prev_temp and (date - prev_date =1 )\\n\\'\\'\\'"
                    },
                    {
                        "username": "vaishvel",
                        "content": "**Working Solution:**\\n\\nwith cte as\\n(select *, lag(temperature,1) over (order by RecordDate) as prev_t,\\n            lag(RecordDate,1) over (order by RecordDate) as prev_d\\nfrom weather)\\n\\nselect id from cte \\nwhere temperature>prev_t\\nand datediff(RecordDate,prev_d)=1\\n\\n\\n**Wrong Answer**: *[2] only not the expected [2],[4]*\\n\\nwith cte as\\n(select *, lead(temperature,1) over (order by RecordDate) as n_t,\\n            lead(RecordDate,1) over (order by RecordDate) as n_d\\nfrom weather)\\n\\nselect id from cte \\nwhere temperature>n_t"
                    },
                    {
                        "username": "mahala",
                        "content": "Hi all,\\n\\nI have written down two queries. Kindly let me know which query is optimized query and is efficient? If I am having billions of rows, then which query is good?\\n\\n# Method 1:\\nselect w1.id from weather as w1\\ninner join weather as w2\\non datediff(w1.recordDate,w2.recordDate) = 1\\nand w1.temperature > w2.temperature;\\n\\n# Method 2:\\nselect w1.id from weather as w1\\ninner join weather as w2\\non datediff(w1.recordDate,w2.recordDate) = 1\\nwhere w1.temperature > w2.temperature;"
                    },
                    {
                        "username": "dana777",
                        "content": "\\'\\'\\'\\nselect w2.id\\nfrom weather w1, weather w2\\nwhere w1.temperature < w2.temperature\\n      and ADDDATE(W1.RecordDate, 1) = W2.RecordDate\\n\\'\\'\\'"
                    },
                    {
                        "username": "minhbgbgvn",
                        "content": "`\\nSELECT d2.Id as Id \\nFROM Weather d1, Weather d2 \\nWHERE d2.Temperature > d1.Temperature \\n\\tAND TRUNC(d2.RecordDate) - TRUNC(d1.RecordDate) = 1\\n`"
                    },
                    {
                        "username": "s9811219",
                        "content": "Hi,\\n\\nHere\\'s the Mandarin Chinese version to explain this problem in MySQL with 2 solutions.\\nWelcome to discuss together and join this projects!\\n\\n[[\\u4F86\\u5B78\\u8CC7\\u6599\\u5EAB] LeetCode DataBase SQL \\u89C0\\u5FF5\\u89E3\\u6790(07): #197. Rising Temperature](https://medium.com/@s9811219/rising-temperature-leetcode-4cde8ad1e681)\\n\\n![image](https://assets.leetcode.com/users/s9811219/image_1574246339.png)\\n"
                    },
                    {
                        "username": "legbird3",
                        "content": "If use \"full join\" or \"full outer join\" instead of \"join\", it will throw a runtime error. Anybody knows why?"
                    },
                    {
                        "username": "louisepenberthy",
                        "content": "Mysql doesn\\'t have a full join."
                    },
                    {
                        "username": "skbysp",
                        "content": "I learn for mysql just few days, my solution was as following:\\nselect t1.Id from Weather as t1, Weather as t2 where datediff(t1.Date, t2.Date)=1 and (t1.Temperature - t2.Temperature) > 0;"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "/* Write your PL/SQL query statement below */\\nwith cte as (\\nSELECT Id,temperature, LAG(temperature,1) OVER (\\n\\t\\tORDER BY recordDate\\n\\t) as py_temp,recordDate,\\nlag (recordDate,1) over (order by recordDate) as py_record_date\\n\\nFROM WEATHER \\n) select id from cte where temperature > py_temp and (recordDate-py_record_date)=1;"
                    }
                ]
            },
            {
                "id": 1571417,
                "content": [
                    {
                        "username": "Imelman",
                        "content": "| id | recordDate | temperature |\\n| -- | ------------  | ----------- |\\n| 1  | 2000-12-14 |     3           |\\n| 2  | 2000-12-16 |     5           |\\n\\nIn this test my answer is \"Id 2\". Why is it wrong? He has a higher temperature than the previous day."
                    },
                    {
                        "username": "dk9571288791",
                        "content": "I think this is because previous day of 2000-12-16 is 2000-12-15 (it is not in the table) not 2000-12-14. So, your query should  consider a null as previous temperature for the date 2000-12-16."
                    },
                    {
                        "username": "DanielAlegriaLino",
                        "content": "Same Error "
                    },
                    {
                        "username": "marchodl",
                        "content": "\\'\\'\\'\\nwith CTE as (\\nselect\\nid,recordDate as date, temperature as temp,\\nlag(temperature) over(order by recordDate,id) as prev_temp,\\nlag(recordDate) over(order by recordDate,id) as prev_date\\nfrom Weather \\n)\\n\\n\\nselect\\nid\\nfrom CTE\\nwhere temp > prev_temp and (date - prev_date =1 )\\n\\'\\'\\'"
                    },
                    {
                        "username": "vaishvel",
                        "content": "**Working Solution:**\\n\\nwith cte as\\n(select *, lag(temperature,1) over (order by RecordDate) as prev_t,\\n            lag(RecordDate,1) over (order by RecordDate) as prev_d\\nfrom weather)\\n\\nselect id from cte \\nwhere temperature>prev_t\\nand datediff(RecordDate,prev_d)=1\\n\\n\\n**Wrong Answer**: *[2] only not the expected [2],[4]*\\n\\nwith cte as\\n(select *, lead(temperature,1) over (order by RecordDate) as n_t,\\n            lead(RecordDate,1) over (order by RecordDate) as n_d\\nfrom weather)\\n\\nselect id from cte \\nwhere temperature>n_t"
                    },
                    {
                        "username": "mahala",
                        "content": "Hi all,\\n\\nI have written down two queries. Kindly let me know which query is optimized query and is efficient? If I am having billions of rows, then which query is good?\\n\\n# Method 1:\\nselect w1.id from weather as w1\\ninner join weather as w2\\non datediff(w1.recordDate,w2.recordDate) = 1\\nand w1.temperature > w2.temperature;\\n\\n# Method 2:\\nselect w1.id from weather as w1\\ninner join weather as w2\\non datediff(w1.recordDate,w2.recordDate) = 1\\nwhere w1.temperature > w2.temperature;"
                    },
                    {
                        "username": "dana777",
                        "content": "\\'\\'\\'\\nselect w2.id\\nfrom weather w1, weather w2\\nwhere w1.temperature < w2.temperature\\n      and ADDDATE(W1.RecordDate, 1) = W2.RecordDate\\n\\'\\'\\'"
                    },
                    {
                        "username": "minhbgbgvn",
                        "content": "`\\nSELECT d2.Id as Id \\nFROM Weather d1, Weather d2 \\nWHERE d2.Temperature > d1.Temperature \\n\\tAND TRUNC(d2.RecordDate) - TRUNC(d1.RecordDate) = 1\\n`"
                    },
                    {
                        "username": "s9811219",
                        "content": "Hi,\\n\\nHere\\'s the Mandarin Chinese version to explain this problem in MySQL with 2 solutions.\\nWelcome to discuss together and join this projects!\\n\\n[[\\u4F86\\u5B78\\u8CC7\\u6599\\u5EAB] LeetCode DataBase SQL \\u89C0\\u5FF5\\u89E3\\u6790(07): #197. Rising Temperature](https://medium.com/@s9811219/rising-temperature-leetcode-4cde8ad1e681)\\n\\n![image](https://assets.leetcode.com/users/s9811219/image_1574246339.png)\\n"
                    },
                    {
                        "username": "legbird3",
                        "content": "If use \"full join\" or \"full outer join\" instead of \"join\", it will throw a runtime error. Anybody knows why?"
                    },
                    {
                        "username": "louisepenberthy",
                        "content": "Mysql doesn\\'t have a full join."
                    },
                    {
                        "username": "skbysp",
                        "content": "I learn for mysql just few days, my solution was as following:\\nselect t1.Id from Weather as t1, Weather as t2 where datediff(t1.Date, t2.Date)=1 and (t1.Temperature - t2.Temperature) > 0;"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "/* Write your PL/SQL query statement below */\\nwith cte as (\\nSELECT Id,temperature, LAG(temperature,1) OVER (\\n\\t\\tORDER BY recordDate\\n\\t) as py_temp,recordDate,\\nlag (recordDate,1) over (order by recordDate) as py_record_date\\n\\nFROM WEATHER \\n) select id from cte where temperature > py_temp and (recordDate-py_record_date)=1;"
                    }
                ]
            },
            {
                "id": 2072819,
                "content": [
                    {
                        "username": "Imelman",
                        "content": "| id | recordDate | temperature |\\n| -- | ------------  | ----------- |\\n| 1  | 2000-12-14 |     3           |\\n| 2  | 2000-12-16 |     5           |\\n\\nIn this test my answer is \"Id 2\". Why is it wrong? He has a higher temperature than the previous day."
                    },
                    {
                        "username": "dk9571288791",
                        "content": "I think this is because previous day of 2000-12-16 is 2000-12-15 (it is not in the table) not 2000-12-14. So, your query should  consider a null as previous temperature for the date 2000-12-16."
                    },
                    {
                        "username": "DanielAlegriaLino",
                        "content": "Same Error "
                    },
                    {
                        "username": "marchodl",
                        "content": "\\'\\'\\'\\nwith CTE as (\\nselect\\nid,recordDate as date, temperature as temp,\\nlag(temperature) over(order by recordDate,id) as prev_temp,\\nlag(recordDate) over(order by recordDate,id) as prev_date\\nfrom Weather \\n)\\n\\n\\nselect\\nid\\nfrom CTE\\nwhere temp > prev_temp and (date - prev_date =1 )\\n\\'\\'\\'"
                    },
                    {
                        "username": "vaishvel",
                        "content": "**Working Solution:**\\n\\nwith cte as\\n(select *, lag(temperature,1) over (order by RecordDate) as prev_t,\\n            lag(RecordDate,1) over (order by RecordDate) as prev_d\\nfrom weather)\\n\\nselect id from cte \\nwhere temperature>prev_t\\nand datediff(RecordDate,prev_d)=1\\n\\n\\n**Wrong Answer**: *[2] only not the expected [2],[4]*\\n\\nwith cte as\\n(select *, lead(temperature,1) over (order by RecordDate) as n_t,\\n            lead(RecordDate,1) over (order by RecordDate) as n_d\\nfrom weather)\\n\\nselect id from cte \\nwhere temperature>n_t"
                    },
                    {
                        "username": "mahala",
                        "content": "Hi all,\\n\\nI have written down two queries. Kindly let me know which query is optimized query and is efficient? If I am having billions of rows, then which query is good?\\n\\n# Method 1:\\nselect w1.id from weather as w1\\ninner join weather as w2\\non datediff(w1.recordDate,w2.recordDate) = 1\\nand w1.temperature > w2.temperature;\\n\\n# Method 2:\\nselect w1.id from weather as w1\\ninner join weather as w2\\non datediff(w1.recordDate,w2.recordDate) = 1\\nwhere w1.temperature > w2.temperature;"
                    },
                    {
                        "username": "dana777",
                        "content": "\\'\\'\\'\\nselect w2.id\\nfrom weather w1, weather w2\\nwhere w1.temperature < w2.temperature\\n      and ADDDATE(W1.RecordDate, 1) = W2.RecordDate\\n\\'\\'\\'"
                    },
                    {
                        "username": "minhbgbgvn",
                        "content": "`\\nSELECT d2.Id as Id \\nFROM Weather d1, Weather d2 \\nWHERE d2.Temperature > d1.Temperature \\n\\tAND TRUNC(d2.RecordDate) - TRUNC(d1.RecordDate) = 1\\n`"
                    },
                    {
                        "username": "s9811219",
                        "content": "Hi,\\n\\nHere\\'s the Mandarin Chinese version to explain this problem in MySQL with 2 solutions.\\nWelcome to discuss together and join this projects!\\n\\n[[\\u4F86\\u5B78\\u8CC7\\u6599\\u5EAB] LeetCode DataBase SQL \\u89C0\\u5FF5\\u89E3\\u6790(07): #197. Rising Temperature](https://medium.com/@s9811219/rising-temperature-leetcode-4cde8ad1e681)\\n\\n![image](https://assets.leetcode.com/users/s9811219/image_1574246339.png)\\n"
                    },
                    {
                        "username": "legbird3",
                        "content": "If use \"full join\" or \"full outer join\" instead of \"join\", it will throw a runtime error. Anybody knows why?"
                    },
                    {
                        "username": "louisepenberthy",
                        "content": "Mysql doesn\\'t have a full join."
                    },
                    {
                        "username": "skbysp",
                        "content": "I learn for mysql just few days, my solution was as following:\\nselect t1.Id from Weather as t1, Weather as t2 where datediff(t1.Date, t2.Date)=1 and (t1.Temperature - t2.Temperature) > 0;"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "/* Write your PL/SQL query statement below */\\nwith cte as (\\nSELECT Id,temperature, LAG(temperature,1) OVER (\\n\\t\\tORDER BY recordDate\\n\\t) as py_temp,recordDate,\\nlag (recordDate,1) over (order by recordDate) as py_record_date\\n\\nFROM WEATHER \\n) select id from cte where temperature > py_temp and (recordDate-py_record_date)=1;"
                    }
                ]
            },
            {
                "id": 2072128,
                "content": [
                    {
                        "username": "scrltkllr",
                        "content": "Hey can someone help pls, i use pandas and don\\'t know what\\'s wrong with my code  \\n \\nV1\\ndef rising_temperature(weather: pd.DataFrame) -> pd.DataFrame:\\n    weather[\"recordDate\"] = pd.to_datetime(weather[\"recordDate\"])\\n    weather[\"temperature_1\"] = weather[\"temperature\"].shift(1)\\n    output = weather[abs(weather[\"temperature\"]) > abs(weather[\"temperature_1\"])]\\n    return pd.DataFrame(output[\"id\"])\\n\\nV2\\ndef rising_temperature(weather: pd.DataFrame) -> pd.DataFrame:\\n    weather[\"recordDate\"] = pd.to_datetime(weather[\"recordDate\"])\\n    weather[\"recordDate1\"] = weather[\"recordDate\"] - pd.DateOffset(days=1)\\n    weather[\"temperature1\"] = weather[\"temperature\"].shift(1)\\n    output = weather[(weather[\"recordDate\"] - weather[\"recordDate1\"] == pd.Timedelta(days=1)) & (abs(weather[\"temperature\"]) > abs(weather[\"temperature1\"]))]\\n    return pd.DataFrame(output[\"id\"])\\n"
                    },
                    {
                        "username": "slavnikov",
                        "content": "My code is pointed as correct when I run it, however it's not able to be submitted until MySQL is changed to Oracle. \nDon't understand the reason, but lots of people here reported similar issues.\n\nSo try to shift from MySQL to Oracle. May be it helps in such a situation."
                    },
                    {
                        "username": "ak_ydv",
                        "content": "select id from(\\n  select temperature, lag(temperature,1) over(order by id) as prev_num\\n  from Weather\\n)a where temperature > prev_num;\\n\\nwhy this is showing me error ?? some buddy help !!"
                    },
                    {
                        "username": "sfan0037",
                        "content": "FROM Weather AS w1, Weather AS w2\\nWHERE DATEDIFF(w1.recordDate,w2.recordDate)=1\\nAND w1.temperature> W2.temperature"
                    },
                    {
                        "username": "Geetanjali262",
                        "content": "Best and easy way using Date _add and self join\\nSelect curr.id\\nfrom weather Curr\\ninner join weather pre\\non curr.recordDate = date_add(pre.recordDate, interval 1 day)\\nand curr.temperature > pre.temperature;\\n"
                    },
                    {
                        "username": "adrios93",
                        "content": "Accepted but cant submit\n\nselect Id\nfrom Weather w\norder by w.temperature desc\nlimit 2"
                    },
                    {
                        "username": "sarvanibulusu",
                        "content": "I have tried two approaches, surprising thing is Approach 2 has faster execution time than Approach 1, even though Approach 1 is accessing underlying Weather table only once. It does imply Lag and over maybe slower.\\n\\nApproach 1:\\n# Write your MySQL query statement below\\nwith temp as\\n(\\n    select id, RecordDate, Temperature,\\n    lag(Temperature,1) over (order by RecordDate) as previousTemperature,\\n    lag(RecordDate,1) over (order by RecordDate) as PreviousDate\\n    from Weather\\n)\\nSelect id from Temp where Temperature > PreviousTemperature and and datediff(RecordDate,PreviousDate) =1\\n\\nApproach 2:\\n# Write your MySQL query statement below\\nSelect\\ncurrentDay.id\\nfrom\\n(Select id, recordDate, temperature from Weather) as prevDay\\ninner join\\n(Select id, date_sub(recordDate, Interval 1 Day) as recordDate, temperature from Weather)  as currentDay\\non \\nprevDay.recordDate = currentDay.recordDate\\nwhere prevDay.temperature < currentDay.temperature\\n"
                    },
                    {
                        "username": "sunil93",
                        "content": "Oracle SQL:\n\nWITH cte1 as (select id, recorddate, temperature, lag(temperature) over (order by recorddate) as previous_day_temp from weather)\nselect id from cte1 \nwhere temperature > previous_day_temp\nOrder by id asc;"
                    },
                    {
                        "username": "VanTai",
                        "content": "select id from (select *, lag(temperature, 1) over(order by recordDate asc) as lagtemp from weather) as sub2 where (temperature - lagtemp) > 0"
                    },
                    {
                        "username": "vlad_egrv",
                        "content": "can anyone explain, why this code dosn\\'t pass 5 test case?\\n\\nselect id from weather \\nexcept\\nselect id from weather \\nwhere \\ntemperature < (select temperature from weather limit 1 offset 1);\\n\\ni don\\'t understand"
                    },
                    {
                        "username": "vlad_egrv",
                        "content": "ok, i\\'m little stpd. don\\'t know why, but i thought this works like cycle, but it always compare value with second row"
                    }
                ]
            },
            {
                "id": 2071766,
                "content": [
                    {
                        "username": "scrltkllr",
                        "content": "Hey can someone help pls, i use pandas and don\\'t know what\\'s wrong with my code  \\n \\nV1\\ndef rising_temperature(weather: pd.DataFrame) -> pd.DataFrame:\\n    weather[\"recordDate\"] = pd.to_datetime(weather[\"recordDate\"])\\n    weather[\"temperature_1\"] = weather[\"temperature\"].shift(1)\\n    output = weather[abs(weather[\"temperature\"]) > abs(weather[\"temperature_1\"])]\\n    return pd.DataFrame(output[\"id\"])\\n\\nV2\\ndef rising_temperature(weather: pd.DataFrame) -> pd.DataFrame:\\n    weather[\"recordDate\"] = pd.to_datetime(weather[\"recordDate\"])\\n    weather[\"recordDate1\"] = weather[\"recordDate\"] - pd.DateOffset(days=1)\\n    weather[\"temperature1\"] = weather[\"temperature\"].shift(1)\\n    output = weather[(weather[\"recordDate\"] - weather[\"recordDate1\"] == pd.Timedelta(days=1)) & (abs(weather[\"temperature\"]) > abs(weather[\"temperature1\"]))]\\n    return pd.DataFrame(output[\"id\"])\\n"
                    },
                    {
                        "username": "slavnikov",
                        "content": "My code is pointed as correct when I run it, however it's not able to be submitted until MySQL is changed to Oracle. \nDon't understand the reason, but lots of people here reported similar issues.\n\nSo try to shift from MySQL to Oracle. May be it helps in such a situation."
                    },
                    {
                        "username": "ak_ydv",
                        "content": "select id from(\\n  select temperature, lag(temperature,1) over(order by id) as prev_num\\n  from Weather\\n)a where temperature > prev_num;\\n\\nwhy this is showing me error ?? some buddy help !!"
                    },
                    {
                        "username": "sfan0037",
                        "content": "FROM Weather AS w1, Weather AS w2\\nWHERE DATEDIFF(w1.recordDate,w2.recordDate)=1\\nAND w1.temperature> W2.temperature"
                    },
                    {
                        "username": "Geetanjali262",
                        "content": "Best and easy way using Date _add and self join\\nSelect curr.id\\nfrom weather Curr\\ninner join weather pre\\non curr.recordDate = date_add(pre.recordDate, interval 1 day)\\nand curr.temperature > pre.temperature;\\n"
                    },
                    {
                        "username": "adrios93",
                        "content": "Accepted but cant submit\n\nselect Id\nfrom Weather w\norder by w.temperature desc\nlimit 2"
                    },
                    {
                        "username": "sarvanibulusu",
                        "content": "I have tried two approaches, surprising thing is Approach 2 has faster execution time than Approach 1, even though Approach 1 is accessing underlying Weather table only once. It does imply Lag and over maybe slower.\\n\\nApproach 1:\\n# Write your MySQL query statement below\\nwith temp as\\n(\\n    select id, RecordDate, Temperature,\\n    lag(Temperature,1) over (order by RecordDate) as previousTemperature,\\n    lag(RecordDate,1) over (order by RecordDate) as PreviousDate\\n    from Weather\\n)\\nSelect id from Temp where Temperature > PreviousTemperature and and datediff(RecordDate,PreviousDate) =1\\n\\nApproach 2:\\n# Write your MySQL query statement below\\nSelect\\ncurrentDay.id\\nfrom\\n(Select id, recordDate, temperature from Weather) as prevDay\\ninner join\\n(Select id, date_sub(recordDate, Interval 1 Day) as recordDate, temperature from Weather)  as currentDay\\non \\nprevDay.recordDate = currentDay.recordDate\\nwhere prevDay.temperature < currentDay.temperature\\n"
                    },
                    {
                        "username": "sunil93",
                        "content": "Oracle SQL:\n\nWITH cte1 as (select id, recorddate, temperature, lag(temperature) over (order by recorddate) as previous_day_temp from weather)\nselect id from cte1 \nwhere temperature > previous_day_temp\nOrder by id asc;"
                    },
                    {
                        "username": "VanTai",
                        "content": "select id from (select *, lag(temperature, 1) over(order by recordDate asc) as lagtemp from weather) as sub2 where (temperature - lagtemp) > 0"
                    },
                    {
                        "username": "vlad_egrv",
                        "content": "can anyone explain, why this code dosn\\'t pass 5 test case?\\n\\nselect id from weather \\nexcept\\nselect id from weather \\nwhere \\ntemperature < (select temperature from weather limit 1 offset 1);\\n\\ni don\\'t understand"
                    },
                    {
                        "username": "vlad_egrv",
                        "content": "ok, i\\'m little stpd. don\\'t know why, but i thought this works like cycle, but it always compare value with second row"
                    }
                ]
            },
            {
                "id": 2071004,
                "content": [
                    {
                        "username": "scrltkllr",
                        "content": "Hey can someone help pls, i use pandas and don\\'t know what\\'s wrong with my code  \\n \\nV1\\ndef rising_temperature(weather: pd.DataFrame) -> pd.DataFrame:\\n    weather[\"recordDate\"] = pd.to_datetime(weather[\"recordDate\"])\\n    weather[\"temperature_1\"] = weather[\"temperature\"].shift(1)\\n    output = weather[abs(weather[\"temperature\"]) > abs(weather[\"temperature_1\"])]\\n    return pd.DataFrame(output[\"id\"])\\n\\nV2\\ndef rising_temperature(weather: pd.DataFrame) -> pd.DataFrame:\\n    weather[\"recordDate\"] = pd.to_datetime(weather[\"recordDate\"])\\n    weather[\"recordDate1\"] = weather[\"recordDate\"] - pd.DateOffset(days=1)\\n    weather[\"temperature1\"] = weather[\"temperature\"].shift(1)\\n    output = weather[(weather[\"recordDate\"] - weather[\"recordDate1\"] == pd.Timedelta(days=1)) & (abs(weather[\"temperature\"]) > abs(weather[\"temperature1\"]))]\\n    return pd.DataFrame(output[\"id\"])\\n"
                    },
                    {
                        "username": "slavnikov",
                        "content": "My code is pointed as correct when I run it, however it's not able to be submitted until MySQL is changed to Oracle. \nDon't understand the reason, but lots of people here reported similar issues.\n\nSo try to shift from MySQL to Oracle. May be it helps in such a situation."
                    },
                    {
                        "username": "ak_ydv",
                        "content": "select id from(\\n  select temperature, lag(temperature,1) over(order by id) as prev_num\\n  from Weather\\n)a where temperature > prev_num;\\n\\nwhy this is showing me error ?? some buddy help !!"
                    },
                    {
                        "username": "sfan0037",
                        "content": "FROM Weather AS w1, Weather AS w2\\nWHERE DATEDIFF(w1.recordDate,w2.recordDate)=1\\nAND w1.temperature> W2.temperature"
                    },
                    {
                        "username": "Geetanjali262",
                        "content": "Best and easy way using Date _add and self join\\nSelect curr.id\\nfrom weather Curr\\ninner join weather pre\\non curr.recordDate = date_add(pre.recordDate, interval 1 day)\\nand curr.temperature > pre.temperature;\\n"
                    },
                    {
                        "username": "adrios93",
                        "content": "Accepted but cant submit\n\nselect Id\nfrom Weather w\norder by w.temperature desc\nlimit 2"
                    },
                    {
                        "username": "sarvanibulusu",
                        "content": "I have tried two approaches, surprising thing is Approach 2 has faster execution time than Approach 1, even though Approach 1 is accessing underlying Weather table only once. It does imply Lag and over maybe slower.\\n\\nApproach 1:\\n# Write your MySQL query statement below\\nwith temp as\\n(\\n    select id, RecordDate, Temperature,\\n    lag(Temperature,1) over (order by RecordDate) as previousTemperature,\\n    lag(RecordDate,1) over (order by RecordDate) as PreviousDate\\n    from Weather\\n)\\nSelect id from Temp where Temperature > PreviousTemperature and and datediff(RecordDate,PreviousDate) =1\\n\\nApproach 2:\\n# Write your MySQL query statement below\\nSelect\\ncurrentDay.id\\nfrom\\n(Select id, recordDate, temperature from Weather) as prevDay\\ninner join\\n(Select id, date_sub(recordDate, Interval 1 Day) as recordDate, temperature from Weather)  as currentDay\\non \\nprevDay.recordDate = currentDay.recordDate\\nwhere prevDay.temperature < currentDay.temperature\\n"
                    },
                    {
                        "username": "sunil93",
                        "content": "Oracle SQL:\n\nWITH cte1 as (select id, recorddate, temperature, lag(temperature) over (order by recorddate) as previous_day_temp from weather)\nselect id from cte1 \nwhere temperature > previous_day_temp\nOrder by id asc;"
                    },
                    {
                        "username": "VanTai",
                        "content": "select id from (select *, lag(temperature, 1) over(order by recordDate asc) as lagtemp from weather) as sub2 where (temperature - lagtemp) > 0"
                    },
                    {
                        "username": "vlad_egrv",
                        "content": "can anyone explain, why this code dosn\\'t pass 5 test case?\\n\\nselect id from weather \\nexcept\\nselect id from weather \\nwhere \\ntemperature < (select temperature from weather limit 1 offset 1);\\n\\ni don\\'t understand"
                    },
                    {
                        "username": "vlad_egrv",
                        "content": "ok, i\\'m little stpd. don\\'t know why, but i thought this works like cycle, but it always compare value with second row"
                    }
                ]
            },
            {
                "id": 2068174,
                "content": [
                    {
                        "username": "scrltkllr",
                        "content": "Hey can someone help pls, i use pandas and don\\'t know what\\'s wrong with my code  \\n \\nV1\\ndef rising_temperature(weather: pd.DataFrame) -> pd.DataFrame:\\n    weather[\"recordDate\"] = pd.to_datetime(weather[\"recordDate\"])\\n    weather[\"temperature_1\"] = weather[\"temperature\"].shift(1)\\n    output = weather[abs(weather[\"temperature\"]) > abs(weather[\"temperature_1\"])]\\n    return pd.DataFrame(output[\"id\"])\\n\\nV2\\ndef rising_temperature(weather: pd.DataFrame) -> pd.DataFrame:\\n    weather[\"recordDate\"] = pd.to_datetime(weather[\"recordDate\"])\\n    weather[\"recordDate1\"] = weather[\"recordDate\"] - pd.DateOffset(days=1)\\n    weather[\"temperature1\"] = weather[\"temperature\"].shift(1)\\n    output = weather[(weather[\"recordDate\"] - weather[\"recordDate1\"] == pd.Timedelta(days=1)) & (abs(weather[\"temperature\"]) > abs(weather[\"temperature1\"]))]\\n    return pd.DataFrame(output[\"id\"])\\n"
                    },
                    {
                        "username": "slavnikov",
                        "content": "My code is pointed as correct when I run it, however it's not able to be submitted until MySQL is changed to Oracle. \nDon't understand the reason, but lots of people here reported similar issues.\n\nSo try to shift from MySQL to Oracle. May be it helps in such a situation."
                    },
                    {
                        "username": "ak_ydv",
                        "content": "select id from(\\n  select temperature, lag(temperature,1) over(order by id) as prev_num\\n  from Weather\\n)a where temperature > prev_num;\\n\\nwhy this is showing me error ?? some buddy help !!"
                    },
                    {
                        "username": "sfan0037",
                        "content": "FROM Weather AS w1, Weather AS w2\\nWHERE DATEDIFF(w1.recordDate,w2.recordDate)=1\\nAND w1.temperature> W2.temperature"
                    },
                    {
                        "username": "Geetanjali262",
                        "content": "Best and easy way using Date _add and self join\\nSelect curr.id\\nfrom weather Curr\\ninner join weather pre\\non curr.recordDate = date_add(pre.recordDate, interval 1 day)\\nand curr.temperature > pre.temperature;\\n"
                    },
                    {
                        "username": "adrios93",
                        "content": "Accepted but cant submit\n\nselect Id\nfrom Weather w\norder by w.temperature desc\nlimit 2"
                    },
                    {
                        "username": "sarvanibulusu",
                        "content": "I have tried two approaches, surprising thing is Approach 2 has faster execution time than Approach 1, even though Approach 1 is accessing underlying Weather table only once. It does imply Lag and over maybe slower.\\n\\nApproach 1:\\n# Write your MySQL query statement below\\nwith temp as\\n(\\n    select id, RecordDate, Temperature,\\n    lag(Temperature,1) over (order by RecordDate) as previousTemperature,\\n    lag(RecordDate,1) over (order by RecordDate) as PreviousDate\\n    from Weather\\n)\\nSelect id from Temp where Temperature > PreviousTemperature and and datediff(RecordDate,PreviousDate) =1\\n\\nApproach 2:\\n# Write your MySQL query statement below\\nSelect\\ncurrentDay.id\\nfrom\\n(Select id, recordDate, temperature from Weather) as prevDay\\ninner join\\n(Select id, date_sub(recordDate, Interval 1 Day) as recordDate, temperature from Weather)  as currentDay\\non \\nprevDay.recordDate = currentDay.recordDate\\nwhere prevDay.temperature < currentDay.temperature\\n"
                    },
                    {
                        "username": "sunil93",
                        "content": "Oracle SQL:\n\nWITH cte1 as (select id, recorddate, temperature, lag(temperature) over (order by recorddate) as previous_day_temp from weather)\nselect id from cte1 \nwhere temperature > previous_day_temp\nOrder by id asc;"
                    },
                    {
                        "username": "VanTai",
                        "content": "select id from (select *, lag(temperature, 1) over(order by recordDate asc) as lagtemp from weather) as sub2 where (temperature - lagtemp) > 0"
                    },
                    {
                        "username": "vlad_egrv",
                        "content": "can anyone explain, why this code dosn\\'t pass 5 test case?\\n\\nselect id from weather \\nexcept\\nselect id from weather \\nwhere \\ntemperature < (select temperature from weather limit 1 offset 1);\\n\\ni don\\'t understand"
                    },
                    {
                        "username": "vlad_egrv",
                        "content": "ok, i\\'m little stpd. don\\'t know why, but i thought this works like cycle, but it always compare value with second row"
                    }
                ]
            },
            {
                "id": 2065611,
                "content": [
                    {
                        "username": "scrltkllr",
                        "content": "Hey can someone help pls, i use pandas and don\\'t know what\\'s wrong with my code  \\n \\nV1\\ndef rising_temperature(weather: pd.DataFrame) -> pd.DataFrame:\\n    weather[\"recordDate\"] = pd.to_datetime(weather[\"recordDate\"])\\n    weather[\"temperature_1\"] = weather[\"temperature\"].shift(1)\\n    output = weather[abs(weather[\"temperature\"]) > abs(weather[\"temperature_1\"])]\\n    return pd.DataFrame(output[\"id\"])\\n\\nV2\\ndef rising_temperature(weather: pd.DataFrame) -> pd.DataFrame:\\n    weather[\"recordDate\"] = pd.to_datetime(weather[\"recordDate\"])\\n    weather[\"recordDate1\"] = weather[\"recordDate\"] - pd.DateOffset(days=1)\\n    weather[\"temperature1\"] = weather[\"temperature\"].shift(1)\\n    output = weather[(weather[\"recordDate\"] - weather[\"recordDate1\"] == pd.Timedelta(days=1)) & (abs(weather[\"temperature\"]) > abs(weather[\"temperature1\"]))]\\n    return pd.DataFrame(output[\"id\"])\\n"
                    },
                    {
                        "username": "slavnikov",
                        "content": "My code is pointed as correct when I run it, however it's not able to be submitted until MySQL is changed to Oracle. \nDon't understand the reason, but lots of people here reported similar issues.\n\nSo try to shift from MySQL to Oracle. May be it helps in such a situation."
                    },
                    {
                        "username": "ak_ydv",
                        "content": "select id from(\\n  select temperature, lag(temperature,1) over(order by id) as prev_num\\n  from Weather\\n)a where temperature > prev_num;\\n\\nwhy this is showing me error ?? some buddy help !!"
                    },
                    {
                        "username": "sfan0037",
                        "content": "FROM Weather AS w1, Weather AS w2\\nWHERE DATEDIFF(w1.recordDate,w2.recordDate)=1\\nAND w1.temperature> W2.temperature"
                    },
                    {
                        "username": "Geetanjali262",
                        "content": "Best and easy way using Date _add and self join\\nSelect curr.id\\nfrom weather Curr\\ninner join weather pre\\non curr.recordDate = date_add(pre.recordDate, interval 1 day)\\nand curr.temperature > pre.temperature;\\n"
                    },
                    {
                        "username": "adrios93",
                        "content": "Accepted but cant submit\n\nselect Id\nfrom Weather w\norder by w.temperature desc\nlimit 2"
                    },
                    {
                        "username": "sarvanibulusu",
                        "content": "I have tried two approaches, surprising thing is Approach 2 has faster execution time than Approach 1, even though Approach 1 is accessing underlying Weather table only once. It does imply Lag and over maybe slower.\\n\\nApproach 1:\\n# Write your MySQL query statement below\\nwith temp as\\n(\\n    select id, RecordDate, Temperature,\\n    lag(Temperature,1) over (order by RecordDate) as previousTemperature,\\n    lag(RecordDate,1) over (order by RecordDate) as PreviousDate\\n    from Weather\\n)\\nSelect id from Temp where Temperature > PreviousTemperature and and datediff(RecordDate,PreviousDate) =1\\n\\nApproach 2:\\n# Write your MySQL query statement below\\nSelect\\ncurrentDay.id\\nfrom\\n(Select id, recordDate, temperature from Weather) as prevDay\\ninner join\\n(Select id, date_sub(recordDate, Interval 1 Day) as recordDate, temperature from Weather)  as currentDay\\non \\nprevDay.recordDate = currentDay.recordDate\\nwhere prevDay.temperature < currentDay.temperature\\n"
                    },
                    {
                        "username": "sunil93",
                        "content": "Oracle SQL:\n\nWITH cte1 as (select id, recorddate, temperature, lag(temperature) over (order by recorddate) as previous_day_temp from weather)\nselect id from cte1 \nwhere temperature > previous_day_temp\nOrder by id asc;"
                    },
                    {
                        "username": "VanTai",
                        "content": "select id from (select *, lag(temperature, 1) over(order by recordDate asc) as lagtemp from weather) as sub2 where (temperature - lagtemp) > 0"
                    },
                    {
                        "username": "vlad_egrv",
                        "content": "can anyone explain, why this code dosn\\'t pass 5 test case?\\n\\nselect id from weather \\nexcept\\nselect id from weather \\nwhere \\ntemperature < (select temperature from weather limit 1 offset 1);\\n\\ni don\\'t understand"
                    },
                    {
                        "username": "vlad_egrv",
                        "content": "ok, i\\'m little stpd. don\\'t know why, but i thought this works like cycle, but it always compare value with second row"
                    }
                ]
            },
            {
                "id": 2062054,
                "content": [
                    {
                        "username": "scrltkllr",
                        "content": "Hey can someone help pls, i use pandas and don\\'t know what\\'s wrong with my code  \\n \\nV1\\ndef rising_temperature(weather: pd.DataFrame) -> pd.DataFrame:\\n    weather[\"recordDate\"] = pd.to_datetime(weather[\"recordDate\"])\\n    weather[\"temperature_1\"] = weather[\"temperature\"].shift(1)\\n    output = weather[abs(weather[\"temperature\"]) > abs(weather[\"temperature_1\"])]\\n    return pd.DataFrame(output[\"id\"])\\n\\nV2\\ndef rising_temperature(weather: pd.DataFrame) -> pd.DataFrame:\\n    weather[\"recordDate\"] = pd.to_datetime(weather[\"recordDate\"])\\n    weather[\"recordDate1\"] = weather[\"recordDate\"] - pd.DateOffset(days=1)\\n    weather[\"temperature1\"] = weather[\"temperature\"].shift(1)\\n    output = weather[(weather[\"recordDate\"] - weather[\"recordDate1\"] == pd.Timedelta(days=1)) & (abs(weather[\"temperature\"]) > abs(weather[\"temperature1\"]))]\\n    return pd.DataFrame(output[\"id\"])\\n"
                    },
                    {
                        "username": "slavnikov",
                        "content": "My code is pointed as correct when I run it, however it's not able to be submitted until MySQL is changed to Oracle. \nDon't understand the reason, but lots of people here reported similar issues.\n\nSo try to shift from MySQL to Oracle. May be it helps in such a situation."
                    },
                    {
                        "username": "ak_ydv",
                        "content": "select id from(\\n  select temperature, lag(temperature,1) over(order by id) as prev_num\\n  from Weather\\n)a where temperature > prev_num;\\n\\nwhy this is showing me error ?? some buddy help !!"
                    },
                    {
                        "username": "sfan0037",
                        "content": "FROM Weather AS w1, Weather AS w2\\nWHERE DATEDIFF(w1.recordDate,w2.recordDate)=1\\nAND w1.temperature> W2.temperature"
                    },
                    {
                        "username": "Geetanjali262",
                        "content": "Best and easy way using Date _add and self join\\nSelect curr.id\\nfrom weather Curr\\ninner join weather pre\\non curr.recordDate = date_add(pre.recordDate, interval 1 day)\\nand curr.temperature > pre.temperature;\\n"
                    },
                    {
                        "username": "adrios93",
                        "content": "Accepted but cant submit\n\nselect Id\nfrom Weather w\norder by w.temperature desc\nlimit 2"
                    },
                    {
                        "username": "sarvanibulusu",
                        "content": "I have tried two approaches, surprising thing is Approach 2 has faster execution time than Approach 1, even though Approach 1 is accessing underlying Weather table only once. It does imply Lag and over maybe slower.\\n\\nApproach 1:\\n# Write your MySQL query statement below\\nwith temp as\\n(\\n    select id, RecordDate, Temperature,\\n    lag(Temperature,1) over (order by RecordDate) as previousTemperature,\\n    lag(RecordDate,1) over (order by RecordDate) as PreviousDate\\n    from Weather\\n)\\nSelect id from Temp where Temperature > PreviousTemperature and and datediff(RecordDate,PreviousDate) =1\\n\\nApproach 2:\\n# Write your MySQL query statement below\\nSelect\\ncurrentDay.id\\nfrom\\n(Select id, recordDate, temperature from Weather) as prevDay\\ninner join\\n(Select id, date_sub(recordDate, Interval 1 Day) as recordDate, temperature from Weather)  as currentDay\\non \\nprevDay.recordDate = currentDay.recordDate\\nwhere prevDay.temperature < currentDay.temperature\\n"
                    },
                    {
                        "username": "sunil93",
                        "content": "Oracle SQL:\n\nWITH cte1 as (select id, recorddate, temperature, lag(temperature) over (order by recorddate) as previous_day_temp from weather)\nselect id from cte1 \nwhere temperature > previous_day_temp\nOrder by id asc;"
                    },
                    {
                        "username": "VanTai",
                        "content": "select id from (select *, lag(temperature, 1) over(order by recordDate asc) as lagtemp from weather) as sub2 where (temperature - lagtemp) > 0"
                    },
                    {
                        "username": "vlad_egrv",
                        "content": "can anyone explain, why this code dosn\\'t pass 5 test case?\\n\\nselect id from weather \\nexcept\\nselect id from weather \\nwhere \\ntemperature < (select temperature from weather limit 1 offset 1);\\n\\ni don\\'t understand"
                    },
                    {
                        "username": "vlad_egrv",
                        "content": "ok, i\\'m little stpd. don\\'t know why, but i thought this works like cycle, but it always compare value with second row"
                    }
                ]
            },
            {
                "id": 2059302,
                "content": [
                    {
                        "username": "scrltkllr",
                        "content": "Hey can someone help pls, i use pandas and don\\'t know what\\'s wrong with my code  \\n \\nV1\\ndef rising_temperature(weather: pd.DataFrame) -> pd.DataFrame:\\n    weather[\"recordDate\"] = pd.to_datetime(weather[\"recordDate\"])\\n    weather[\"temperature_1\"] = weather[\"temperature\"].shift(1)\\n    output = weather[abs(weather[\"temperature\"]) > abs(weather[\"temperature_1\"])]\\n    return pd.DataFrame(output[\"id\"])\\n\\nV2\\ndef rising_temperature(weather: pd.DataFrame) -> pd.DataFrame:\\n    weather[\"recordDate\"] = pd.to_datetime(weather[\"recordDate\"])\\n    weather[\"recordDate1\"] = weather[\"recordDate\"] - pd.DateOffset(days=1)\\n    weather[\"temperature1\"] = weather[\"temperature\"].shift(1)\\n    output = weather[(weather[\"recordDate\"] - weather[\"recordDate1\"] == pd.Timedelta(days=1)) & (abs(weather[\"temperature\"]) > abs(weather[\"temperature1\"]))]\\n    return pd.DataFrame(output[\"id\"])\\n"
                    },
                    {
                        "username": "slavnikov",
                        "content": "My code is pointed as correct when I run it, however it's not able to be submitted until MySQL is changed to Oracle. \nDon't understand the reason, but lots of people here reported similar issues.\n\nSo try to shift from MySQL to Oracle. May be it helps in such a situation."
                    },
                    {
                        "username": "ak_ydv",
                        "content": "select id from(\\n  select temperature, lag(temperature,1) over(order by id) as prev_num\\n  from Weather\\n)a where temperature > prev_num;\\n\\nwhy this is showing me error ?? some buddy help !!"
                    },
                    {
                        "username": "sfan0037",
                        "content": "FROM Weather AS w1, Weather AS w2\\nWHERE DATEDIFF(w1.recordDate,w2.recordDate)=1\\nAND w1.temperature> W2.temperature"
                    },
                    {
                        "username": "Geetanjali262",
                        "content": "Best and easy way using Date _add and self join\\nSelect curr.id\\nfrom weather Curr\\ninner join weather pre\\non curr.recordDate = date_add(pre.recordDate, interval 1 day)\\nand curr.temperature > pre.temperature;\\n"
                    },
                    {
                        "username": "adrios93",
                        "content": "Accepted but cant submit\n\nselect Id\nfrom Weather w\norder by w.temperature desc\nlimit 2"
                    },
                    {
                        "username": "sarvanibulusu",
                        "content": "I have tried two approaches, surprising thing is Approach 2 has faster execution time than Approach 1, even though Approach 1 is accessing underlying Weather table only once. It does imply Lag and over maybe slower.\\n\\nApproach 1:\\n# Write your MySQL query statement below\\nwith temp as\\n(\\n    select id, RecordDate, Temperature,\\n    lag(Temperature,1) over (order by RecordDate) as previousTemperature,\\n    lag(RecordDate,1) over (order by RecordDate) as PreviousDate\\n    from Weather\\n)\\nSelect id from Temp where Temperature > PreviousTemperature and and datediff(RecordDate,PreviousDate) =1\\n\\nApproach 2:\\n# Write your MySQL query statement below\\nSelect\\ncurrentDay.id\\nfrom\\n(Select id, recordDate, temperature from Weather) as prevDay\\ninner join\\n(Select id, date_sub(recordDate, Interval 1 Day) as recordDate, temperature from Weather)  as currentDay\\non \\nprevDay.recordDate = currentDay.recordDate\\nwhere prevDay.temperature < currentDay.temperature\\n"
                    },
                    {
                        "username": "sunil93",
                        "content": "Oracle SQL:\n\nWITH cte1 as (select id, recorddate, temperature, lag(temperature) over (order by recorddate) as previous_day_temp from weather)\nselect id from cte1 \nwhere temperature > previous_day_temp\nOrder by id asc;"
                    },
                    {
                        "username": "VanTai",
                        "content": "select id from (select *, lag(temperature, 1) over(order by recordDate asc) as lagtemp from weather) as sub2 where (temperature - lagtemp) > 0"
                    },
                    {
                        "username": "vlad_egrv",
                        "content": "can anyone explain, why this code dosn\\'t pass 5 test case?\\n\\nselect id from weather \\nexcept\\nselect id from weather \\nwhere \\ntemperature < (select temperature from weather limit 1 offset 1);\\n\\ni don\\'t understand"
                    },
                    {
                        "username": "vlad_egrv",
                        "content": "ok, i\\'m little stpd. don\\'t know why, but i thought this works like cycle, but it always compare value with second row"
                    }
                ]
            },
            {
                "id": 2058694,
                "content": [
                    {
                        "username": "scrltkllr",
                        "content": "Hey can someone help pls, i use pandas and don\\'t know what\\'s wrong with my code  \\n \\nV1\\ndef rising_temperature(weather: pd.DataFrame) -> pd.DataFrame:\\n    weather[\"recordDate\"] = pd.to_datetime(weather[\"recordDate\"])\\n    weather[\"temperature_1\"] = weather[\"temperature\"].shift(1)\\n    output = weather[abs(weather[\"temperature\"]) > abs(weather[\"temperature_1\"])]\\n    return pd.DataFrame(output[\"id\"])\\n\\nV2\\ndef rising_temperature(weather: pd.DataFrame) -> pd.DataFrame:\\n    weather[\"recordDate\"] = pd.to_datetime(weather[\"recordDate\"])\\n    weather[\"recordDate1\"] = weather[\"recordDate\"] - pd.DateOffset(days=1)\\n    weather[\"temperature1\"] = weather[\"temperature\"].shift(1)\\n    output = weather[(weather[\"recordDate\"] - weather[\"recordDate1\"] == pd.Timedelta(days=1)) & (abs(weather[\"temperature\"]) > abs(weather[\"temperature1\"]))]\\n    return pd.DataFrame(output[\"id\"])\\n"
                    },
                    {
                        "username": "slavnikov",
                        "content": "My code is pointed as correct when I run it, however it's not able to be submitted until MySQL is changed to Oracle. \nDon't understand the reason, but lots of people here reported similar issues.\n\nSo try to shift from MySQL to Oracle. May be it helps in such a situation."
                    },
                    {
                        "username": "ak_ydv",
                        "content": "select id from(\\n  select temperature, lag(temperature,1) over(order by id) as prev_num\\n  from Weather\\n)a where temperature > prev_num;\\n\\nwhy this is showing me error ?? some buddy help !!"
                    },
                    {
                        "username": "sfan0037",
                        "content": "FROM Weather AS w1, Weather AS w2\\nWHERE DATEDIFF(w1.recordDate,w2.recordDate)=1\\nAND w1.temperature> W2.temperature"
                    },
                    {
                        "username": "Geetanjali262",
                        "content": "Best and easy way using Date _add and self join\\nSelect curr.id\\nfrom weather Curr\\ninner join weather pre\\non curr.recordDate = date_add(pre.recordDate, interval 1 day)\\nand curr.temperature > pre.temperature;\\n"
                    },
                    {
                        "username": "adrios93",
                        "content": "Accepted but cant submit\n\nselect Id\nfrom Weather w\norder by w.temperature desc\nlimit 2"
                    },
                    {
                        "username": "sarvanibulusu",
                        "content": "I have tried two approaches, surprising thing is Approach 2 has faster execution time than Approach 1, even though Approach 1 is accessing underlying Weather table only once. It does imply Lag and over maybe slower.\\n\\nApproach 1:\\n# Write your MySQL query statement below\\nwith temp as\\n(\\n    select id, RecordDate, Temperature,\\n    lag(Temperature,1) over (order by RecordDate) as previousTemperature,\\n    lag(RecordDate,1) over (order by RecordDate) as PreviousDate\\n    from Weather\\n)\\nSelect id from Temp where Temperature > PreviousTemperature and and datediff(RecordDate,PreviousDate) =1\\n\\nApproach 2:\\n# Write your MySQL query statement below\\nSelect\\ncurrentDay.id\\nfrom\\n(Select id, recordDate, temperature from Weather) as prevDay\\ninner join\\n(Select id, date_sub(recordDate, Interval 1 Day) as recordDate, temperature from Weather)  as currentDay\\non \\nprevDay.recordDate = currentDay.recordDate\\nwhere prevDay.temperature < currentDay.temperature\\n"
                    },
                    {
                        "username": "sunil93",
                        "content": "Oracle SQL:\n\nWITH cte1 as (select id, recorddate, temperature, lag(temperature) over (order by recorddate) as previous_day_temp from weather)\nselect id from cte1 \nwhere temperature > previous_day_temp\nOrder by id asc;"
                    },
                    {
                        "username": "VanTai",
                        "content": "select id from (select *, lag(temperature, 1) over(order by recordDate asc) as lagtemp from weather) as sub2 where (temperature - lagtemp) > 0"
                    },
                    {
                        "username": "vlad_egrv",
                        "content": "can anyone explain, why this code dosn\\'t pass 5 test case?\\n\\nselect id from weather \\nexcept\\nselect id from weather \\nwhere \\ntemperature < (select temperature from weather limit 1 offset 1);\\n\\ni don\\'t understand"
                    },
                    {
                        "username": "vlad_egrv",
                        "content": "ok, i\\'m little stpd. don\\'t know why, but i thought this works like cycle, but it always compare value with second row"
                    }
                ]
            },
            {
                "id": 2057372,
                "content": [
                    {
                        "username": "scrltkllr",
                        "content": "Hey can someone help pls, i use pandas and don\\'t know what\\'s wrong with my code  \\n \\nV1\\ndef rising_temperature(weather: pd.DataFrame) -> pd.DataFrame:\\n    weather[\"recordDate\"] = pd.to_datetime(weather[\"recordDate\"])\\n    weather[\"temperature_1\"] = weather[\"temperature\"].shift(1)\\n    output = weather[abs(weather[\"temperature\"]) > abs(weather[\"temperature_1\"])]\\n    return pd.DataFrame(output[\"id\"])\\n\\nV2\\ndef rising_temperature(weather: pd.DataFrame) -> pd.DataFrame:\\n    weather[\"recordDate\"] = pd.to_datetime(weather[\"recordDate\"])\\n    weather[\"recordDate1\"] = weather[\"recordDate\"] - pd.DateOffset(days=1)\\n    weather[\"temperature1\"] = weather[\"temperature\"].shift(1)\\n    output = weather[(weather[\"recordDate\"] - weather[\"recordDate1\"] == pd.Timedelta(days=1)) & (abs(weather[\"temperature\"]) > abs(weather[\"temperature1\"]))]\\n    return pd.DataFrame(output[\"id\"])\\n"
                    },
                    {
                        "username": "slavnikov",
                        "content": "My code is pointed as correct when I run it, however it's not able to be submitted until MySQL is changed to Oracle. \nDon't understand the reason, but lots of people here reported similar issues.\n\nSo try to shift from MySQL to Oracle. May be it helps in such a situation."
                    },
                    {
                        "username": "ak_ydv",
                        "content": "select id from(\\n  select temperature, lag(temperature,1) over(order by id) as prev_num\\n  from Weather\\n)a where temperature > prev_num;\\n\\nwhy this is showing me error ?? some buddy help !!"
                    },
                    {
                        "username": "sfan0037",
                        "content": "FROM Weather AS w1, Weather AS w2\\nWHERE DATEDIFF(w1.recordDate,w2.recordDate)=1\\nAND w1.temperature> W2.temperature"
                    },
                    {
                        "username": "Geetanjali262",
                        "content": "Best and easy way using Date _add and self join\\nSelect curr.id\\nfrom weather Curr\\ninner join weather pre\\non curr.recordDate = date_add(pre.recordDate, interval 1 day)\\nand curr.temperature > pre.temperature;\\n"
                    },
                    {
                        "username": "adrios93",
                        "content": "Accepted but cant submit\n\nselect Id\nfrom Weather w\norder by w.temperature desc\nlimit 2"
                    },
                    {
                        "username": "sarvanibulusu",
                        "content": "I have tried two approaches, surprising thing is Approach 2 has faster execution time than Approach 1, even though Approach 1 is accessing underlying Weather table only once. It does imply Lag and over maybe slower.\\n\\nApproach 1:\\n# Write your MySQL query statement below\\nwith temp as\\n(\\n    select id, RecordDate, Temperature,\\n    lag(Temperature,1) over (order by RecordDate) as previousTemperature,\\n    lag(RecordDate,1) over (order by RecordDate) as PreviousDate\\n    from Weather\\n)\\nSelect id from Temp where Temperature > PreviousTemperature and and datediff(RecordDate,PreviousDate) =1\\n\\nApproach 2:\\n# Write your MySQL query statement below\\nSelect\\ncurrentDay.id\\nfrom\\n(Select id, recordDate, temperature from Weather) as prevDay\\ninner join\\n(Select id, date_sub(recordDate, Interval 1 Day) as recordDate, temperature from Weather)  as currentDay\\non \\nprevDay.recordDate = currentDay.recordDate\\nwhere prevDay.temperature < currentDay.temperature\\n"
                    },
                    {
                        "username": "sunil93",
                        "content": "Oracle SQL:\n\nWITH cte1 as (select id, recorddate, temperature, lag(temperature) over (order by recorddate) as previous_day_temp from weather)\nselect id from cte1 \nwhere temperature > previous_day_temp\nOrder by id asc;"
                    },
                    {
                        "username": "VanTai",
                        "content": "select id from (select *, lag(temperature, 1) over(order by recordDate asc) as lagtemp from weather) as sub2 where (temperature - lagtemp) > 0"
                    },
                    {
                        "username": "vlad_egrv",
                        "content": "can anyone explain, why this code dosn\\'t pass 5 test case?\\n\\nselect id from weather \\nexcept\\nselect id from weather \\nwhere \\ntemperature < (select temperature from weather limit 1 offset 1);\\n\\ni don\\'t understand"
                    },
                    {
                        "username": "vlad_egrv",
                        "content": "ok, i\\'m little stpd. don\\'t know why, but i thought this works like cycle, but it always compare value with second row"
                    }
                ]
            },
            {
                "id": 2057223,
                "content": [
                    {
                        "username": "scrltkllr",
                        "content": "Hey can someone help pls, i use pandas and don\\'t know what\\'s wrong with my code  \\n \\nV1\\ndef rising_temperature(weather: pd.DataFrame) -> pd.DataFrame:\\n    weather[\"recordDate\"] = pd.to_datetime(weather[\"recordDate\"])\\n    weather[\"temperature_1\"] = weather[\"temperature\"].shift(1)\\n    output = weather[abs(weather[\"temperature\"]) > abs(weather[\"temperature_1\"])]\\n    return pd.DataFrame(output[\"id\"])\\n\\nV2\\ndef rising_temperature(weather: pd.DataFrame) -> pd.DataFrame:\\n    weather[\"recordDate\"] = pd.to_datetime(weather[\"recordDate\"])\\n    weather[\"recordDate1\"] = weather[\"recordDate\"] - pd.DateOffset(days=1)\\n    weather[\"temperature1\"] = weather[\"temperature\"].shift(1)\\n    output = weather[(weather[\"recordDate\"] - weather[\"recordDate1\"] == pd.Timedelta(days=1)) & (abs(weather[\"temperature\"]) > abs(weather[\"temperature1\"]))]\\n    return pd.DataFrame(output[\"id\"])\\n"
                    },
                    {
                        "username": "slavnikov",
                        "content": "My code is pointed as correct when I run it, however it's not able to be submitted until MySQL is changed to Oracle. \nDon't understand the reason, but lots of people here reported similar issues.\n\nSo try to shift from MySQL to Oracle. May be it helps in such a situation."
                    },
                    {
                        "username": "ak_ydv",
                        "content": "select id from(\\n  select temperature, lag(temperature,1) over(order by id) as prev_num\\n  from Weather\\n)a where temperature > prev_num;\\n\\nwhy this is showing me error ?? some buddy help !!"
                    },
                    {
                        "username": "sfan0037",
                        "content": "FROM Weather AS w1, Weather AS w2\\nWHERE DATEDIFF(w1.recordDate,w2.recordDate)=1\\nAND w1.temperature> W2.temperature"
                    },
                    {
                        "username": "Geetanjali262",
                        "content": "Best and easy way using Date _add and self join\\nSelect curr.id\\nfrom weather Curr\\ninner join weather pre\\non curr.recordDate = date_add(pre.recordDate, interval 1 day)\\nand curr.temperature > pre.temperature;\\n"
                    },
                    {
                        "username": "adrios93",
                        "content": "Accepted but cant submit\n\nselect Id\nfrom Weather w\norder by w.temperature desc\nlimit 2"
                    },
                    {
                        "username": "sarvanibulusu",
                        "content": "I have tried two approaches, surprising thing is Approach 2 has faster execution time than Approach 1, even though Approach 1 is accessing underlying Weather table only once. It does imply Lag and over maybe slower.\\n\\nApproach 1:\\n# Write your MySQL query statement below\\nwith temp as\\n(\\n    select id, RecordDate, Temperature,\\n    lag(Temperature,1) over (order by RecordDate) as previousTemperature,\\n    lag(RecordDate,1) over (order by RecordDate) as PreviousDate\\n    from Weather\\n)\\nSelect id from Temp where Temperature > PreviousTemperature and and datediff(RecordDate,PreviousDate) =1\\n\\nApproach 2:\\n# Write your MySQL query statement below\\nSelect\\ncurrentDay.id\\nfrom\\n(Select id, recordDate, temperature from Weather) as prevDay\\ninner join\\n(Select id, date_sub(recordDate, Interval 1 Day) as recordDate, temperature from Weather)  as currentDay\\non \\nprevDay.recordDate = currentDay.recordDate\\nwhere prevDay.temperature < currentDay.temperature\\n"
                    },
                    {
                        "username": "sunil93",
                        "content": "Oracle SQL:\n\nWITH cte1 as (select id, recorddate, temperature, lag(temperature) over (order by recorddate) as previous_day_temp from weather)\nselect id from cte1 \nwhere temperature > previous_day_temp\nOrder by id asc;"
                    },
                    {
                        "username": "VanTai",
                        "content": "select id from (select *, lag(temperature, 1) over(order by recordDate asc) as lagtemp from weather) as sub2 where (temperature - lagtemp) > 0"
                    },
                    {
                        "username": "vlad_egrv",
                        "content": "can anyone explain, why this code dosn\\'t pass 5 test case?\\n\\nselect id from weather \\nexcept\\nselect id from weather \\nwhere \\ntemperature < (select temperature from weather limit 1 offset 1);\\n\\ni don\\'t understand"
                    },
                    {
                        "username": "vlad_egrv",
                        "content": "ok, i\\'m little stpd. don\\'t know why, but i thought this works like cycle, but it always compare value with second row"
                    }
                ]
            },
            {
                "id": 2052851,
                "content": [
                    {
                        "username": "seankala",
                        "content": "Can anyone explain the difference between using `DATEDIFF(date1, date2)` and `date1 - 1 = date2`? The latter one worked for me except for one test case."
                    },
                    {
                        "username": "zsd890912",
                        "content": "This is my code, but I do not know why it does not work.... Thanks\\nWITH p1 AS (\\n  SELECT id, recordDate, temperature,\\n    recordDate - Lag(recordDate, 1) OVER(ORDER BY recordDate ASC) AS diff_date,\\n    temperature - Lag(temperature, 1) OVER(ORDER BY recordDate ASC) AS diff_temp\\n  FROM Weather\\n  ORDER BY recordDate\\n)\\nSELECT id\\nFROM p1\\nWHERE diff_temp > 0 \\nAND diff_date = 1;\\n"
                    },
                    {
                        "username": "mayankmadhur",
                        "content": "Can someone help me understand why my query is not working. It runs but does not let me submit as it fails some testcases.\\n\\n`Select S.id from weather W, Weather S\\nwhere S.recorddate - W.recorddate = 1 and S.temperature > W.temperature\\norder by S.id as`"
                    },
                    {
                        "username": "himsm",
                        "content": "The below query is running correctly, but not able to submit.\\nwith t1 \\nas (select id, temperature,\\nlag (temperature) over (order by recorddate) as lag_temp, (lag (temperature) over (order by recorddate)-temperature) as Diff\\nfrom weather)\\n\\nselect t1.id\\nfrom t1\\nwhere t1.diff<0"
                    },
                    {
                        "username": "Adilummer1",
                        "content": "with window function working code\\nselect  id  from(\\nselect  id,temperature  ,\\nLAG  (temperature ) \\nOVER (\\nORDER BY ID) as temp  from Weather ) a\\nWHERE temperature>a.temp"
                    },
                    {
                        "username": "user4580f",
                        "content": "select id from\\n(select id,recordDate,temperature as current_temp,lag(temperature) over (order by recordDate) as prev_temp from weather) a\\nwhere current_temp>prev_temp\\n\\n"
                    },
                    {
                        "username": "Ravi_Gupta1",
                        "content": "Hii,\\nwhen i run this code it shows me that it is accepted but when i submit it, it shows me error\\n\\nselect id\\nfrom (\\nselect id,recordDate,temperature,lag(temperature,1,null)\\n       over(order by recordDate asc) as temp\\nfrom Weather) a\\nwhere (temperature - temp) > 0;"
                    },
                    {
                        "username": "Jayshiv",
                        "content": "select ID from \\n(select a.id, a.temperature as atemperature,b.temperature  as btemperature\\nfrom weather a\\nLEFT JOIN weather b ON DATEADD(dd,+1,b.recordDate) = a.recordDate )a\\nwhere atemperature>btemperature"
                    },
                    {
                        "username": "himansumallick502",
                        "content": "# my code is failing only on one  testcase ,can u plzz help to resolve .\\n\\nselect  a.id  from  Weather a join Weather b where (a.recordDate - b.recordDate)=1  and a.temperature > b.temperature ;"
                    },
                    {
                        "username": "jargolastik",
                        "content": " (a.recordDate - b.recordDate)=1 doesn\\'t work correctly on all dates because it will treat dates as integers\\n\\nSept 1 - Aug 31 would not be equal to 1 if you use that equation"
                    },
                    {
                        "username": "siva291197",
                        "content": "Has anyone tried using CTE? I am able to pass 13/14 test cases using this but not sure why it is not passing the last one. Any suggestions or inputs?\\n\\nwith temp as\\n(\\nselect *,\\nlag(temperature,1,null) over(order by recorddate asc) as Lagtemp,\\nlag(datepart(dayofyear,recorddate),1,null) over(order by recorddate asc) as Lagdate\\nfrom weather\\n)\\nselect id from temp where (temperature-lagtemp) > 0 and\\ndatepart(dayofyear,recorddate)-Lagdate = 1\\n"
                    }
                ]
            },
            {
                "id": 2052496,
                "content": [
                    {
                        "username": "seankala",
                        "content": "Can anyone explain the difference between using `DATEDIFF(date1, date2)` and `date1 - 1 = date2`? The latter one worked for me except for one test case."
                    },
                    {
                        "username": "zsd890912",
                        "content": "This is my code, but I do not know why it does not work.... Thanks\\nWITH p1 AS (\\n  SELECT id, recordDate, temperature,\\n    recordDate - Lag(recordDate, 1) OVER(ORDER BY recordDate ASC) AS diff_date,\\n    temperature - Lag(temperature, 1) OVER(ORDER BY recordDate ASC) AS diff_temp\\n  FROM Weather\\n  ORDER BY recordDate\\n)\\nSELECT id\\nFROM p1\\nWHERE diff_temp > 0 \\nAND diff_date = 1;\\n"
                    },
                    {
                        "username": "mayankmadhur",
                        "content": "Can someone help me understand why my query is not working. It runs but does not let me submit as it fails some testcases.\\n\\n`Select S.id from weather W, Weather S\\nwhere S.recorddate - W.recorddate = 1 and S.temperature > W.temperature\\norder by S.id as`"
                    },
                    {
                        "username": "himsm",
                        "content": "The below query is running correctly, but not able to submit.\\nwith t1 \\nas (select id, temperature,\\nlag (temperature) over (order by recorddate) as lag_temp, (lag (temperature) over (order by recorddate)-temperature) as Diff\\nfrom weather)\\n\\nselect t1.id\\nfrom t1\\nwhere t1.diff<0"
                    },
                    {
                        "username": "Adilummer1",
                        "content": "with window function working code\\nselect  id  from(\\nselect  id,temperature  ,\\nLAG  (temperature ) \\nOVER (\\nORDER BY ID) as temp  from Weather ) a\\nWHERE temperature>a.temp"
                    },
                    {
                        "username": "user4580f",
                        "content": "select id from\\n(select id,recordDate,temperature as current_temp,lag(temperature) over (order by recordDate) as prev_temp from weather) a\\nwhere current_temp>prev_temp\\n\\n"
                    },
                    {
                        "username": "Ravi_Gupta1",
                        "content": "Hii,\\nwhen i run this code it shows me that it is accepted but when i submit it, it shows me error\\n\\nselect id\\nfrom (\\nselect id,recordDate,temperature,lag(temperature,1,null)\\n       over(order by recordDate asc) as temp\\nfrom Weather) a\\nwhere (temperature - temp) > 0;"
                    },
                    {
                        "username": "Jayshiv",
                        "content": "select ID from \\n(select a.id, a.temperature as atemperature,b.temperature  as btemperature\\nfrom weather a\\nLEFT JOIN weather b ON DATEADD(dd,+1,b.recordDate) = a.recordDate )a\\nwhere atemperature>btemperature"
                    },
                    {
                        "username": "himansumallick502",
                        "content": "# my code is failing only on one  testcase ,can u plzz help to resolve .\\n\\nselect  a.id  from  Weather a join Weather b where (a.recordDate - b.recordDate)=1  and a.temperature > b.temperature ;"
                    },
                    {
                        "username": "jargolastik",
                        "content": " (a.recordDate - b.recordDate)=1 doesn\\'t work correctly on all dates because it will treat dates as integers\\n\\nSept 1 - Aug 31 would not be equal to 1 if you use that equation"
                    },
                    {
                        "username": "siva291197",
                        "content": "Has anyone tried using CTE? I am able to pass 13/14 test cases using this but not sure why it is not passing the last one. Any suggestions or inputs?\\n\\nwith temp as\\n(\\nselect *,\\nlag(temperature,1,null) over(order by recorddate asc) as Lagtemp,\\nlag(datepart(dayofyear,recorddate),1,null) over(order by recorddate asc) as Lagdate\\nfrom weather\\n)\\nselect id from temp where (temperature-lagtemp) > 0 and\\ndatepart(dayofyear,recorddate)-Lagdate = 1\\n"
                    }
                ]
            },
            {
                "id": 2049740,
                "content": [
                    {
                        "username": "seankala",
                        "content": "Can anyone explain the difference between using `DATEDIFF(date1, date2)` and `date1 - 1 = date2`? The latter one worked for me except for one test case."
                    },
                    {
                        "username": "zsd890912",
                        "content": "This is my code, but I do not know why it does not work.... Thanks\\nWITH p1 AS (\\n  SELECT id, recordDate, temperature,\\n    recordDate - Lag(recordDate, 1) OVER(ORDER BY recordDate ASC) AS diff_date,\\n    temperature - Lag(temperature, 1) OVER(ORDER BY recordDate ASC) AS diff_temp\\n  FROM Weather\\n  ORDER BY recordDate\\n)\\nSELECT id\\nFROM p1\\nWHERE diff_temp > 0 \\nAND diff_date = 1;\\n"
                    },
                    {
                        "username": "mayankmadhur",
                        "content": "Can someone help me understand why my query is not working. It runs but does not let me submit as it fails some testcases.\\n\\n`Select S.id from weather W, Weather S\\nwhere S.recorddate - W.recorddate = 1 and S.temperature > W.temperature\\norder by S.id as`"
                    },
                    {
                        "username": "himsm",
                        "content": "The below query is running correctly, but not able to submit.\\nwith t1 \\nas (select id, temperature,\\nlag (temperature) over (order by recorddate) as lag_temp, (lag (temperature) over (order by recorddate)-temperature) as Diff\\nfrom weather)\\n\\nselect t1.id\\nfrom t1\\nwhere t1.diff<0"
                    },
                    {
                        "username": "Adilummer1",
                        "content": "with window function working code\\nselect  id  from(\\nselect  id,temperature  ,\\nLAG  (temperature ) \\nOVER (\\nORDER BY ID) as temp  from Weather ) a\\nWHERE temperature>a.temp"
                    },
                    {
                        "username": "user4580f",
                        "content": "select id from\\n(select id,recordDate,temperature as current_temp,lag(temperature) over (order by recordDate) as prev_temp from weather) a\\nwhere current_temp>prev_temp\\n\\n"
                    },
                    {
                        "username": "Ravi_Gupta1",
                        "content": "Hii,\\nwhen i run this code it shows me that it is accepted but when i submit it, it shows me error\\n\\nselect id\\nfrom (\\nselect id,recordDate,temperature,lag(temperature,1,null)\\n       over(order by recordDate asc) as temp\\nfrom Weather) a\\nwhere (temperature - temp) > 0;"
                    },
                    {
                        "username": "Jayshiv",
                        "content": "select ID from \\n(select a.id, a.temperature as atemperature,b.temperature  as btemperature\\nfrom weather a\\nLEFT JOIN weather b ON DATEADD(dd,+1,b.recordDate) = a.recordDate )a\\nwhere atemperature>btemperature"
                    },
                    {
                        "username": "himansumallick502",
                        "content": "# my code is failing only on one  testcase ,can u plzz help to resolve .\\n\\nselect  a.id  from  Weather a join Weather b where (a.recordDate - b.recordDate)=1  and a.temperature > b.temperature ;"
                    },
                    {
                        "username": "jargolastik",
                        "content": " (a.recordDate - b.recordDate)=1 doesn\\'t work correctly on all dates because it will treat dates as integers\\n\\nSept 1 - Aug 31 would not be equal to 1 if you use that equation"
                    },
                    {
                        "username": "siva291197",
                        "content": "Has anyone tried using CTE? I am able to pass 13/14 test cases using this but not sure why it is not passing the last one. Any suggestions or inputs?\\n\\nwith temp as\\n(\\nselect *,\\nlag(temperature,1,null) over(order by recorddate asc) as Lagtemp,\\nlag(datepart(dayofyear,recorddate),1,null) over(order by recorddate asc) as Lagdate\\nfrom weather\\n)\\nselect id from temp where (temperature-lagtemp) > 0 and\\ndatepart(dayofyear,recorddate)-Lagdate = 1\\n"
                    }
                ]
            },
            {
                "id": 2045814,
                "content": [
                    {
                        "username": "seankala",
                        "content": "Can anyone explain the difference between using `DATEDIFF(date1, date2)` and `date1 - 1 = date2`? The latter one worked for me except for one test case."
                    },
                    {
                        "username": "zsd890912",
                        "content": "This is my code, but I do not know why it does not work.... Thanks\\nWITH p1 AS (\\n  SELECT id, recordDate, temperature,\\n    recordDate - Lag(recordDate, 1) OVER(ORDER BY recordDate ASC) AS diff_date,\\n    temperature - Lag(temperature, 1) OVER(ORDER BY recordDate ASC) AS diff_temp\\n  FROM Weather\\n  ORDER BY recordDate\\n)\\nSELECT id\\nFROM p1\\nWHERE diff_temp > 0 \\nAND diff_date = 1;\\n"
                    },
                    {
                        "username": "mayankmadhur",
                        "content": "Can someone help me understand why my query is not working. It runs but does not let me submit as it fails some testcases.\\n\\n`Select S.id from weather W, Weather S\\nwhere S.recorddate - W.recorddate = 1 and S.temperature > W.temperature\\norder by S.id as`"
                    },
                    {
                        "username": "himsm",
                        "content": "The below query is running correctly, but not able to submit.\\nwith t1 \\nas (select id, temperature,\\nlag (temperature) over (order by recorddate) as lag_temp, (lag (temperature) over (order by recorddate)-temperature) as Diff\\nfrom weather)\\n\\nselect t1.id\\nfrom t1\\nwhere t1.diff<0"
                    },
                    {
                        "username": "Adilummer1",
                        "content": "with window function working code\\nselect  id  from(\\nselect  id,temperature  ,\\nLAG  (temperature ) \\nOVER (\\nORDER BY ID) as temp  from Weather ) a\\nWHERE temperature>a.temp"
                    },
                    {
                        "username": "user4580f",
                        "content": "select id from\\n(select id,recordDate,temperature as current_temp,lag(temperature) over (order by recordDate) as prev_temp from weather) a\\nwhere current_temp>prev_temp\\n\\n"
                    },
                    {
                        "username": "Ravi_Gupta1",
                        "content": "Hii,\\nwhen i run this code it shows me that it is accepted but when i submit it, it shows me error\\n\\nselect id\\nfrom (\\nselect id,recordDate,temperature,lag(temperature,1,null)\\n       over(order by recordDate asc) as temp\\nfrom Weather) a\\nwhere (temperature - temp) > 0;"
                    },
                    {
                        "username": "Jayshiv",
                        "content": "select ID from \\n(select a.id, a.temperature as atemperature,b.temperature  as btemperature\\nfrom weather a\\nLEFT JOIN weather b ON DATEADD(dd,+1,b.recordDate) = a.recordDate )a\\nwhere atemperature>btemperature"
                    },
                    {
                        "username": "himansumallick502",
                        "content": "# my code is failing only on one  testcase ,can u plzz help to resolve .\\n\\nselect  a.id  from  Weather a join Weather b where (a.recordDate - b.recordDate)=1  and a.temperature > b.temperature ;"
                    },
                    {
                        "username": "jargolastik",
                        "content": " (a.recordDate - b.recordDate)=1 doesn\\'t work correctly on all dates because it will treat dates as integers\\n\\nSept 1 - Aug 31 would not be equal to 1 if you use that equation"
                    },
                    {
                        "username": "siva291197",
                        "content": "Has anyone tried using CTE? I am able to pass 13/14 test cases using this but not sure why it is not passing the last one. Any suggestions or inputs?\\n\\nwith temp as\\n(\\nselect *,\\nlag(temperature,1,null) over(order by recorddate asc) as Lagtemp,\\nlag(datepart(dayofyear,recorddate),1,null) over(order by recorddate asc) as Lagdate\\nfrom weather\\n)\\nselect id from temp where (temperature-lagtemp) > 0 and\\ndatepart(dayofyear,recorddate)-Lagdate = 1\\n"
                    }
                ]
            },
            {
                "id": 2045140,
                "content": [
                    {
                        "username": "seankala",
                        "content": "Can anyone explain the difference between using `DATEDIFF(date1, date2)` and `date1 - 1 = date2`? The latter one worked for me except for one test case."
                    },
                    {
                        "username": "zsd890912",
                        "content": "This is my code, but I do not know why it does not work.... Thanks\\nWITH p1 AS (\\n  SELECT id, recordDate, temperature,\\n    recordDate - Lag(recordDate, 1) OVER(ORDER BY recordDate ASC) AS diff_date,\\n    temperature - Lag(temperature, 1) OVER(ORDER BY recordDate ASC) AS diff_temp\\n  FROM Weather\\n  ORDER BY recordDate\\n)\\nSELECT id\\nFROM p1\\nWHERE diff_temp > 0 \\nAND diff_date = 1;\\n"
                    },
                    {
                        "username": "mayankmadhur",
                        "content": "Can someone help me understand why my query is not working. It runs but does not let me submit as it fails some testcases.\\n\\n`Select S.id from weather W, Weather S\\nwhere S.recorddate - W.recorddate = 1 and S.temperature > W.temperature\\norder by S.id as`"
                    },
                    {
                        "username": "himsm",
                        "content": "The below query is running correctly, but not able to submit.\\nwith t1 \\nas (select id, temperature,\\nlag (temperature) over (order by recorddate) as lag_temp, (lag (temperature) over (order by recorddate)-temperature) as Diff\\nfrom weather)\\n\\nselect t1.id\\nfrom t1\\nwhere t1.diff<0"
                    },
                    {
                        "username": "Adilummer1",
                        "content": "with window function working code\\nselect  id  from(\\nselect  id,temperature  ,\\nLAG  (temperature ) \\nOVER (\\nORDER BY ID) as temp  from Weather ) a\\nWHERE temperature>a.temp"
                    },
                    {
                        "username": "user4580f",
                        "content": "select id from\\n(select id,recordDate,temperature as current_temp,lag(temperature) over (order by recordDate) as prev_temp from weather) a\\nwhere current_temp>prev_temp\\n\\n"
                    },
                    {
                        "username": "Ravi_Gupta1",
                        "content": "Hii,\\nwhen i run this code it shows me that it is accepted but when i submit it, it shows me error\\n\\nselect id\\nfrom (\\nselect id,recordDate,temperature,lag(temperature,1,null)\\n       over(order by recordDate asc) as temp\\nfrom Weather) a\\nwhere (temperature - temp) > 0;"
                    },
                    {
                        "username": "Jayshiv",
                        "content": "select ID from \\n(select a.id, a.temperature as atemperature,b.temperature  as btemperature\\nfrom weather a\\nLEFT JOIN weather b ON DATEADD(dd,+1,b.recordDate) = a.recordDate )a\\nwhere atemperature>btemperature"
                    },
                    {
                        "username": "himansumallick502",
                        "content": "# my code is failing only on one  testcase ,can u plzz help to resolve .\\n\\nselect  a.id  from  Weather a join Weather b where (a.recordDate - b.recordDate)=1  and a.temperature > b.temperature ;"
                    },
                    {
                        "username": "jargolastik",
                        "content": " (a.recordDate - b.recordDate)=1 doesn\\'t work correctly on all dates because it will treat dates as integers\\n\\nSept 1 - Aug 31 would not be equal to 1 if you use that equation"
                    },
                    {
                        "username": "siva291197",
                        "content": "Has anyone tried using CTE? I am able to pass 13/14 test cases using this but not sure why it is not passing the last one. Any suggestions or inputs?\\n\\nwith temp as\\n(\\nselect *,\\nlag(temperature,1,null) over(order by recorddate asc) as Lagtemp,\\nlag(datepart(dayofyear,recorddate),1,null) over(order by recorddate asc) as Lagdate\\nfrom weather\\n)\\nselect id from temp where (temperature-lagtemp) > 0 and\\ndatepart(dayofyear,recorddate)-Lagdate = 1\\n"
                    }
                ]
            },
            {
                "id": 2043620,
                "content": [
                    {
                        "username": "seankala",
                        "content": "Can anyone explain the difference between using `DATEDIFF(date1, date2)` and `date1 - 1 = date2`? The latter one worked for me except for one test case."
                    },
                    {
                        "username": "zsd890912",
                        "content": "This is my code, but I do not know why it does not work.... Thanks\\nWITH p1 AS (\\n  SELECT id, recordDate, temperature,\\n    recordDate - Lag(recordDate, 1) OVER(ORDER BY recordDate ASC) AS diff_date,\\n    temperature - Lag(temperature, 1) OVER(ORDER BY recordDate ASC) AS diff_temp\\n  FROM Weather\\n  ORDER BY recordDate\\n)\\nSELECT id\\nFROM p1\\nWHERE diff_temp > 0 \\nAND diff_date = 1;\\n"
                    },
                    {
                        "username": "mayankmadhur",
                        "content": "Can someone help me understand why my query is not working. It runs but does not let me submit as it fails some testcases.\\n\\n`Select S.id from weather W, Weather S\\nwhere S.recorddate - W.recorddate = 1 and S.temperature > W.temperature\\norder by S.id as`"
                    },
                    {
                        "username": "himsm",
                        "content": "The below query is running correctly, but not able to submit.\\nwith t1 \\nas (select id, temperature,\\nlag (temperature) over (order by recorddate) as lag_temp, (lag (temperature) over (order by recorddate)-temperature) as Diff\\nfrom weather)\\n\\nselect t1.id\\nfrom t1\\nwhere t1.diff<0"
                    },
                    {
                        "username": "Adilummer1",
                        "content": "with window function working code\\nselect  id  from(\\nselect  id,temperature  ,\\nLAG  (temperature ) \\nOVER (\\nORDER BY ID) as temp  from Weather ) a\\nWHERE temperature>a.temp"
                    },
                    {
                        "username": "user4580f",
                        "content": "select id from\\n(select id,recordDate,temperature as current_temp,lag(temperature) over (order by recordDate) as prev_temp from weather) a\\nwhere current_temp>prev_temp\\n\\n"
                    },
                    {
                        "username": "Ravi_Gupta1",
                        "content": "Hii,\\nwhen i run this code it shows me that it is accepted but when i submit it, it shows me error\\n\\nselect id\\nfrom (\\nselect id,recordDate,temperature,lag(temperature,1,null)\\n       over(order by recordDate asc) as temp\\nfrom Weather) a\\nwhere (temperature - temp) > 0;"
                    },
                    {
                        "username": "Jayshiv",
                        "content": "select ID from \\n(select a.id, a.temperature as atemperature,b.temperature  as btemperature\\nfrom weather a\\nLEFT JOIN weather b ON DATEADD(dd,+1,b.recordDate) = a.recordDate )a\\nwhere atemperature>btemperature"
                    },
                    {
                        "username": "himansumallick502",
                        "content": "# my code is failing only on one  testcase ,can u plzz help to resolve .\\n\\nselect  a.id  from  Weather a join Weather b where (a.recordDate - b.recordDate)=1  and a.temperature > b.temperature ;"
                    },
                    {
                        "username": "jargolastik",
                        "content": " (a.recordDate - b.recordDate)=1 doesn\\'t work correctly on all dates because it will treat dates as integers\\n\\nSept 1 - Aug 31 would not be equal to 1 if you use that equation"
                    },
                    {
                        "username": "siva291197",
                        "content": "Has anyone tried using CTE? I am able to pass 13/14 test cases using this but not sure why it is not passing the last one. Any suggestions or inputs?\\n\\nwith temp as\\n(\\nselect *,\\nlag(temperature,1,null) over(order by recorddate asc) as Lagtemp,\\nlag(datepart(dayofyear,recorddate),1,null) over(order by recorddate asc) as Lagdate\\nfrom weather\\n)\\nselect id from temp where (temperature-lagtemp) > 0 and\\ndatepart(dayofyear,recorddate)-Lagdate = 1\\n"
                    }
                ]
            },
            {
                "id": 2042261,
                "content": [
                    {
                        "username": "seankala",
                        "content": "Can anyone explain the difference between using `DATEDIFF(date1, date2)` and `date1 - 1 = date2`? The latter one worked for me except for one test case."
                    },
                    {
                        "username": "zsd890912",
                        "content": "This is my code, but I do not know why it does not work.... Thanks\\nWITH p1 AS (\\n  SELECT id, recordDate, temperature,\\n    recordDate - Lag(recordDate, 1) OVER(ORDER BY recordDate ASC) AS diff_date,\\n    temperature - Lag(temperature, 1) OVER(ORDER BY recordDate ASC) AS diff_temp\\n  FROM Weather\\n  ORDER BY recordDate\\n)\\nSELECT id\\nFROM p1\\nWHERE diff_temp > 0 \\nAND diff_date = 1;\\n"
                    },
                    {
                        "username": "mayankmadhur",
                        "content": "Can someone help me understand why my query is not working. It runs but does not let me submit as it fails some testcases.\\n\\n`Select S.id from weather W, Weather S\\nwhere S.recorddate - W.recorddate = 1 and S.temperature > W.temperature\\norder by S.id as`"
                    },
                    {
                        "username": "himsm",
                        "content": "The below query is running correctly, but not able to submit.\\nwith t1 \\nas (select id, temperature,\\nlag (temperature) over (order by recorddate) as lag_temp, (lag (temperature) over (order by recorddate)-temperature) as Diff\\nfrom weather)\\n\\nselect t1.id\\nfrom t1\\nwhere t1.diff<0"
                    },
                    {
                        "username": "Adilummer1",
                        "content": "with window function working code\\nselect  id  from(\\nselect  id,temperature  ,\\nLAG  (temperature ) \\nOVER (\\nORDER BY ID) as temp  from Weather ) a\\nWHERE temperature>a.temp"
                    },
                    {
                        "username": "user4580f",
                        "content": "select id from\\n(select id,recordDate,temperature as current_temp,lag(temperature) over (order by recordDate) as prev_temp from weather) a\\nwhere current_temp>prev_temp\\n\\n"
                    },
                    {
                        "username": "Ravi_Gupta1",
                        "content": "Hii,\\nwhen i run this code it shows me that it is accepted but when i submit it, it shows me error\\n\\nselect id\\nfrom (\\nselect id,recordDate,temperature,lag(temperature,1,null)\\n       over(order by recordDate asc) as temp\\nfrom Weather) a\\nwhere (temperature - temp) > 0;"
                    },
                    {
                        "username": "Jayshiv",
                        "content": "select ID from \\n(select a.id, a.temperature as atemperature,b.temperature  as btemperature\\nfrom weather a\\nLEFT JOIN weather b ON DATEADD(dd,+1,b.recordDate) = a.recordDate )a\\nwhere atemperature>btemperature"
                    },
                    {
                        "username": "himansumallick502",
                        "content": "# my code is failing only on one  testcase ,can u plzz help to resolve .\\n\\nselect  a.id  from  Weather a join Weather b where (a.recordDate - b.recordDate)=1  and a.temperature > b.temperature ;"
                    },
                    {
                        "username": "jargolastik",
                        "content": " (a.recordDate - b.recordDate)=1 doesn\\'t work correctly on all dates because it will treat dates as integers\\n\\nSept 1 - Aug 31 would not be equal to 1 if you use that equation"
                    },
                    {
                        "username": "siva291197",
                        "content": "Has anyone tried using CTE? I am able to pass 13/14 test cases using this but not sure why it is not passing the last one. Any suggestions or inputs?\\n\\nwith temp as\\n(\\nselect *,\\nlag(temperature,1,null) over(order by recorddate asc) as Lagtemp,\\nlag(datepart(dayofyear,recorddate),1,null) over(order by recorddate asc) as Lagdate\\nfrom weather\\n)\\nselect id from temp where (temperature-lagtemp) > 0 and\\ndatepart(dayofyear,recorddate)-Lagdate = 1\\n"
                    }
                ]
            },
            {
                "id": 2039424,
                "content": [
                    {
                        "username": "seankala",
                        "content": "Can anyone explain the difference between using `DATEDIFF(date1, date2)` and `date1 - 1 = date2`? The latter one worked for me except for one test case."
                    },
                    {
                        "username": "zsd890912",
                        "content": "This is my code, but I do not know why it does not work.... Thanks\\nWITH p1 AS (\\n  SELECT id, recordDate, temperature,\\n    recordDate - Lag(recordDate, 1) OVER(ORDER BY recordDate ASC) AS diff_date,\\n    temperature - Lag(temperature, 1) OVER(ORDER BY recordDate ASC) AS diff_temp\\n  FROM Weather\\n  ORDER BY recordDate\\n)\\nSELECT id\\nFROM p1\\nWHERE diff_temp > 0 \\nAND diff_date = 1;\\n"
                    },
                    {
                        "username": "mayankmadhur",
                        "content": "Can someone help me understand why my query is not working. It runs but does not let me submit as it fails some testcases.\\n\\n`Select S.id from weather W, Weather S\\nwhere S.recorddate - W.recorddate = 1 and S.temperature > W.temperature\\norder by S.id as`"
                    },
                    {
                        "username": "himsm",
                        "content": "The below query is running correctly, but not able to submit.\\nwith t1 \\nas (select id, temperature,\\nlag (temperature) over (order by recorddate) as lag_temp, (lag (temperature) over (order by recorddate)-temperature) as Diff\\nfrom weather)\\n\\nselect t1.id\\nfrom t1\\nwhere t1.diff<0"
                    },
                    {
                        "username": "Adilummer1",
                        "content": "with window function working code\\nselect  id  from(\\nselect  id,temperature  ,\\nLAG  (temperature ) \\nOVER (\\nORDER BY ID) as temp  from Weather ) a\\nWHERE temperature>a.temp"
                    },
                    {
                        "username": "user4580f",
                        "content": "select id from\\n(select id,recordDate,temperature as current_temp,lag(temperature) over (order by recordDate) as prev_temp from weather) a\\nwhere current_temp>prev_temp\\n\\n"
                    },
                    {
                        "username": "Ravi_Gupta1",
                        "content": "Hii,\\nwhen i run this code it shows me that it is accepted but when i submit it, it shows me error\\n\\nselect id\\nfrom (\\nselect id,recordDate,temperature,lag(temperature,1,null)\\n       over(order by recordDate asc) as temp\\nfrom Weather) a\\nwhere (temperature - temp) > 0;"
                    },
                    {
                        "username": "Jayshiv",
                        "content": "select ID from \\n(select a.id, a.temperature as atemperature,b.temperature  as btemperature\\nfrom weather a\\nLEFT JOIN weather b ON DATEADD(dd,+1,b.recordDate) = a.recordDate )a\\nwhere atemperature>btemperature"
                    },
                    {
                        "username": "himansumallick502",
                        "content": "# my code is failing only on one  testcase ,can u plzz help to resolve .\\n\\nselect  a.id  from  Weather a join Weather b where (a.recordDate - b.recordDate)=1  and a.temperature > b.temperature ;"
                    },
                    {
                        "username": "jargolastik",
                        "content": " (a.recordDate - b.recordDate)=1 doesn\\'t work correctly on all dates because it will treat dates as integers\\n\\nSept 1 - Aug 31 would not be equal to 1 if you use that equation"
                    },
                    {
                        "username": "siva291197",
                        "content": "Has anyone tried using CTE? I am able to pass 13/14 test cases using this but not sure why it is not passing the last one. Any suggestions or inputs?\\n\\nwith temp as\\n(\\nselect *,\\nlag(temperature,1,null) over(order by recorddate asc) as Lagtemp,\\nlag(datepart(dayofyear,recorddate),1,null) over(order by recorddate asc) as Lagdate\\nfrom weather\\n)\\nselect id from temp where (temperature-lagtemp) > 0 and\\ndatepart(dayofyear,recorddate)-Lagdate = 1\\n"
                    }
                ]
            },
            {
                "id": 2038519,
                "content": [
                    {
                        "username": "seankala",
                        "content": "Can anyone explain the difference between using `DATEDIFF(date1, date2)` and `date1 - 1 = date2`? The latter one worked for me except for one test case."
                    },
                    {
                        "username": "zsd890912",
                        "content": "This is my code, but I do not know why it does not work.... Thanks\\nWITH p1 AS (\\n  SELECT id, recordDate, temperature,\\n    recordDate - Lag(recordDate, 1) OVER(ORDER BY recordDate ASC) AS diff_date,\\n    temperature - Lag(temperature, 1) OVER(ORDER BY recordDate ASC) AS diff_temp\\n  FROM Weather\\n  ORDER BY recordDate\\n)\\nSELECT id\\nFROM p1\\nWHERE diff_temp > 0 \\nAND diff_date = 1;\\n"
                    },
                    {
                        "username": "mayankmadhur",
                        "content": "Can someone help me understand why my query is not working. It runs but does not let me submit as it fails some testcases.\\n\\n`Select S.id from weather W, Weather S\\nwhere S.recorddate - W.recorddate = 1 and S.temperature > W.temperature\\norder by S.id as`"
                    },
                    {
                        "username": "himsm",
                        "content": "The below query is running correctly, but not able to submit.\\nwith t1 \\nas (select id, temperature,\\nlag (temperature) over (order by recorddate) as lag_temp, (lag (temperature) over (order by recorddate)-temperature) as Diff\\nfrom weather)\\n\\nselect t1.id\\nfrom t1\\nwhere t1.diff<0"
                    },
                    {
                        "username": "Adilummer1",
                        "content": "with window function working code\\nselect  id  from(\\nselect  id,temperature  ,\\nLAG  (temperature ) \\nOVER (\\nORDER BY ID) as temp  from Weather ) a\\nWHERE temperature>a.temp"
                    },
                    {
                        "username": "user4580f",
                        "content": "select id from\\n(select id,recordDate,temperature as current_temp,lag(temperature) over (order by recordDate) as prev_temp from weather) a\\nwhere current_temp>prev_temp\\n\\n"
                    },
                    {
                        "username": "Ravi_Gupta1",
                        "content": "Hii,\\nwhen i run this code it shows me that it is accepted but when i submit it, it shows me error\\n\\nselect id\\nfrom (\\nselect id,recordDate,temperature,lag(temperature,1,null)\\n       over(order by recordDate asc) as temp\\nfrom Weather) a\\nwhere (temperature - temp) > 0;"
                    },
                    {
                        "username": "Jayshiv",
                        "content": "select ID from \\n(select a.id, a.temperature as atemperature,b.temperature  as btemperature\\nfrom weather a\\nLEFT JOIN weather b ON DATEADD(dd,+1,b.recordDate) = a.recordDate )a\\nwhere atemperature>btemperature"
                    },
                    {
                        "username": "himansumallick502",
                        "content": "# my code is failing only on one  testcase ,can u plzz help to resolve .\\n\\nselect  a.id  from  Weather a join Weather b where (a.recordDate - b.recordDate)=1  and a.temperature > b.temperature ;"
                    },
                    {
                        "username": "jargolastik",
                        "content": " (a.recordDate - b.recordDate)=1 doesn\\'t work correctly on all dates because it will treat dates as integers\\n\\nSept 1 - Aug 31 would not be equal to 1 if you use that equation"
                    },
                    {
                        "username": "siva291197",
                        "content": "Has anyone tried using CTE? I am able to pass 13/14 test cases using this but not sure why it is not passing the last one. Any suggestions or inputs?\\n\\nwith temp as\\n(\\nselect *,\\nlag(temperature,1,null) over(order by recorddate asc) as Lagtemp,\\nlag(datepart(dayofyear,recorddate),1,null) over(order by recorddate asc) as Lagdate\\nfrom weather\\n)\\nselect id from temp where (temperature-lagtemp) > 0 and\\ndatepart(dayofyear,recorddate)-Lagdate = 1\\n"
                    }
                ]
            },
            {
                "id": 2035336,
                "content": [
                    {
                        "username": "seankala",
                        "content": "Can anyone explain the difference between using `DATEDIFF(date1, date2)` and `date1 - 1 = date2`? The latter one worked for me except for one test case."
                    },
                    {
                        "username": "zsd890912",
                        "content": "This is my code, but I do not know why it does not work.... Thanks\\nWITH p1 AS (\\n  SELECT id, recordDate, temperature,\\n    recordDate - Lag(recordDate, 1) OVER(ORDER BY recordDate ASC) AS diff_date,\\n    temperature - Lag(temperature, 1) OVER(ORDER BY recordDate ASC) AS diff_temp\\n  FROM Weather\\n  ORDER BY recordDate\\n)\\nSELECT id\\nFROM p1\\nWHERE diff_temp > 0 \\nAND diff_date = 1;\\n"
                    },
                    {
                        "username": "mayankmadhur",
                        "content": "Can someone help me understand why my query is not working. It runs but does not let me submit as it fails some testcases.\\n\\n`Select S.id from weather W, Weather S\\nwhere S.recorddate - W.recorddate = 1 and S.temperature > W.temperature\\norder by S.id as`"
                    },
                    {
                        "username": "himsm",
                        "content": "The below query is running correctly, but not able to submit.\\nwith t1 \\nas (select id, temperature,\\nlag (temperature) over (order by recorddate) as lag_temp, (lag (temperature) over (order by recorddate)-temperature) as Diff\\nfrom weather)\\n\\nselect t1.id\\nfrom t1\\nwhere t1.diff<0"
                    },
                    {
                        "username": "Adilummer1",
                        "content": "with window function working code\\nselect  id  from(\\nselect  id,temperature  ,\\nLAG  (temperature ) \\nOVER (\\nORDER BY ID) as temp  from Weather ) a\\nWHERE temperature>a.temp"
                    },
                    {
                        "username": "user4580f",
                        "content": "select id from\\n(select id,recordDate,temperature as current_temp,lag(temperature) over (order by recordDate) as prev_temp from weather) a\\nwhere current_temp>prev_temp\\n\\n"
                    },
                    {
                        "username": "Ravi_Gupta1",
                        "content": "Hii,\\nwhen i run this code it shows me that it is accepted but when i submit it, it shows me error\\n\\nselect id\\nfrom (\\nselect id,recordDate,temperature,lag(temperature,1,null)\\n       over(order by recordDate asc) as temp\\nfrom Weather) a\\nwhere (temperature - temp) > 0;"
                    },
                    {
                        "username": "Jayshiv",
                        "content": "select ID from \\n(select a.id, a.temperature as atemperature,b.temperature  as btemperature\\nfrom weather a\\nLEFT JOIN weather b ON DATEADD(dd,+1,b.recordDate) = a.recordDate )a\\nwhere atemperature>btemperature"
                    },
                    {
                        "username": "himansumallick502",
                        "content": "# my code is failing only on one  testcase ,can u plzz help to resolve .\\n\\nselect  a.id  from  Weather a join Weather b where (a.recordDate - b.recordDate)=1  and a.temperature > b.temperature ;"
                    },
                    {
                        "username": "jargolastik",
                        "content": " (a.recordDate - b.recordDate)=1 doesn\\'t work correctly on all dates because it will treat dates as integers\\n\\nSept 1 - Aug 31 would not be equal to 1 if you use that equation"
                    },
                    {
                        "username": "siva291197",
                        "content": "Has anyone tried using CTE? I am able to pass 13/14 test cases using this but not sure why it is not passing the last one. Any suggestions or inputs?\\n\\nwith temp as\\n(\\nselect *,\\nlag(temperature,1,null) over(order by recorddate asc) as Lagtemp,\\nlag(datepart(dayofyear,recorddate),1,null) over(order by recorddate asc) as Lagdate\\nfrom weather\\n)\\nselect id from temp where (temperature-lagtemp) > 0 and\\ndatepart(dayofyear,recorddate)-Lagdate = 1\\n"
                    }
                ]
            },
            {
                "id": 2031325,
                "content": [
                    {
                        "username": "i_0x6c1_i",
                        "content": "lot of answers here are using WHERE clause. But if you understand JOIN makes more sense here."
                    },
                    {
                        "username": "user0437YA",
                        "content": "better use this comment select id from weather where temperature = 25 or temperature = 30 "
                    },
                    {
                        "username": "prmems",
                        "content": "Haven\\'t seen anyone use this method:\\nSELECT id\\nFROM Weather w1\\nWHERE temperature > (SELECT temperature from Weather w2 WHERE w1.id = w2.id + 1)\\nIs there something wrong with it? it worked for me."
                    },
                    {
                        "username": "mr-xed",
                        "content": "it only works if you always insured the ids are sequential and there are no deleted rows, a simple example, think about a glitch that has removed a row of the id `3`, now the dependent next row will not be able to get the correct result hence `4` needs to know what `3` has but it doesn\\'t exist, if we really have a higher temp on either we can\\'t tell anymore."
                    },
                    {
                        "username": "superdrifter",
                        "content": "Hi guys, I used the following codes but it showed that the parameters inside DATEDIFF() are wrong, anyone knows why?\\n\\nSELECT id\\nFROM Weather w1\\nWHERE w1.temperature >(\\nSELECT temperature\\nFROM Weather w2\\nWHERE DATEDIFF( day, w1.recordDate, w2.recordDate) =1\\n)"
                    },
                    {
                        "username": "brunomac",
                        "content": "that was my code\\nSELECT t1.id\\nFROM weather t1\\nJOIN weather t2 ON t1.id = t2.id + 1\\nWHERE t2.temperature < t1.temperature;\\n\\nthis was the result when i submit\\nWeather =\\n| id | recordDate | temperature |\\n| -- | ---------- | ----------- |\\n| 1  | 2000-12-16 | 3           |\\n| 2  | 2000-12-15 | -1          |\\nOutput\\n| id |\\n| -- |\\n\\nIts is running successfully but not able to submit!"
                    },
                    {
                        "username": "user8998lj",
                        "content": "can some one help me understand the iteration of the self join ? how the rows are considered?"
                    },
                    {
                        "username": "abhishekverma24",
                        "content": "Any hints why this solution is not working?  It works when I use dateDiff function\n`SELECT W2.id\nFROM Weather W1, Weather W2\nWHERE W2.temperature>W1.temperature AND DATE(W2.recordDate-1)=W1.recordDate;`"
                    },
                    {
                        "username": "zwan7415",
                        "content": "SELECT b.id as Id \\nFROM Weather a, Weather b \\nWHERE datediff(day,a.recordDate,b.recordDate)=1 \\nAND a.temperature < b.temperature "
                    },
                    {
                        "username": "jawad-shaikh",
                        "content": "`SELECT w1.id FROM Weather AS w1 INNER JOIN Weather AS w2\\nON w1.recordDate = DATE_ADD(w2.recordDate, INTERVAL 1 DAY) AND w1.temperature > w2.temperature`\\n\\nthis worked for me."
                    },
                    {
                        "username": "sanigo",
                        "content": "Can someone please let me know why the below solution does not satisfy all the test cases?\\nselect w1.id from weather w1 inner join weather w2 on w1.id!=w2.id\\nwhere\\nw1.recordDate=w2.recordDate+1 and\\nw1.temperature>w2.temperature"
                    }
                ]
            },
            {
                "id": 2030627,
                "content": [
                    {
                        "username": "i_0x6c1_i",
                        "content": "lot of answers here are using WHERE clause. But if you understand JOIN makes more sense here."
                    },
                    {
                        "username": "user0437YA",
                        "content": "better use this comment select id from weather where temperature = 25 or temperature = 30 "
                    },
                    {
                        "username": "prmems",
                        "content": "Haven\\'t seen anyone use this method:\\nSELECT id\\nFROM Weather w1\\nWHERE temperature > (SELECT temperature from Weather w2 WHERE w1.id = w2.id + 1)\\nIs there something wrong with it? it worked for me."
                    },
                    {
                        "username": "mr-xed",
                        "content": "it only works if you always insured the ids are sequential and there are no deleted rows, a simple example, think about a glitch that has removed a row of the id `3`, now the dependent next row will not be able to get the correct result hence `4` needs to know what `3` has but it doesn\\'t exist, if we really have a higher temp on either we can\\'t tell anymore."
                    },
                    {
                        "username": "superdrifter",
                        "content": "Hi guys, I used the following codes but it showed that the parameters inside DATEDIFF() are wrong, anyone knows why?\\n\\nSELECT id\\nFROM Weather w1\\nWHERE w1.temperature >(\\nSELECT temperature\\nFROM Weather w2\\nWHERE DATEDIFF( day, w1.recordDate, w2.recordDate) =1\\n)"
                    },
                    {
                        "username": "brunomac",
                        "content": "that was my code\\nSELECT t1.id\\nFROM weather t1\\nJOIN weather t2 ON t1.id = t2.id + 1\\nWHERE t2.temperature < t1.temperature;\\n\\nthis was the result when i submit\\nWeather =\\n| id | recordDate | temperature |\\n| -- | ---------- | ----------- |\\n| 1  | 2000-12-16 | 3           |\\n| 2  | 2000-12-15 | -1          |\\nOutput\\n| id |\\n| -- |\\n\\nIts is running successfully but not able to submit!"
                    },
                    {
                        "username": "user8998lj",
                        "content": "can some one help me understand the iteration of the self join ? how the rows are considered?"
                    },
                    {
                        "username": "abhishekverma24",
                        "content": "Any hints why this solution is not working?  It works when I use dateDiff function\n`SELECT W2.id\nFROM Weather W1, Weather W2\nWHERE W2.temperature>W1.temperature AND DATE(W2.recordDate-1)=W1.recordDate;`"
                    },
                    {
                        "username": "zwan7415",
                        "content": "SELECT b.id as Id \\nFROM Weather a, Weather b \\nWHERE datediff(day,a.recordDate,b.recordDate)=1 \\nAND a.temperature < b.temperature "
                    },
                    {
                        "username": "jawad-shaikh",
                        "content": "`SELECT w1.id FROM Weather AS w1 INNER JOIN Weather AS w2\\nON w1.recordDate = DATE_ADD(w2.recordDate, INTERVAL 1 DAY) AND w1.temperature > w2.temperature`\\n\\nthis worked for me."
                    },
                    {
                        "username": "sanigo",
                        "content": "Can someone please let me know why the below solution does not satisfy all the test cases?\\nselect w1.id from weather w1 inner join weather w2 on w1.id!=w2.id\\nwhere\\nw1.recordDate=w2.recordDate+1 and\\nw1.temperature>w2.temperature"
                    }
                ]
            },
            {
                "id": 2022784,
                "content": [
                    {
                        "username": "i_0x6c1_i",
                        "content": "lot of answers here are using WHERE clause. But if you understand JOIN makes more sense here."
                    },
                    {
                        "username": "user0437YA",
                        "content": "better use this comment select id from weather where temperature = 25 or temperature = 30 "
                    },
                    {
                        "username": "prmems",
                        "content": "Haven\\'t seen anyone use this method:\\nSELECT id\\nFROM Weather w1\\nWHERE temperature > (SELECT temperature from Weather w2 WHERE w1.id = w2.id + 1)\\nIs there something wrong with it? it worked for me."
                    },
                    {
                        "username": "mr-xed",
                        "content": "it only works if you always insured the ids are sequential and there are no deleted rows, a simple example, think about a glitch that has removed a row of the id `3`, now the dependent next row will not be able to get the correct result hence `4` needs to know what `3` has but it doesn\\'t exist, if we really have a higher temp on either we can\\'t tell anymore."
                    },
                    {
                        "username": "superdrifter",
                        "content": "Hi guys, I used the following codes but it showed that the parameters inside DATEDIFF() are wrong, anyone knows why?\\n\\nSELECT id\\nFROM Weather w1\\nWHERE w1.temperature >(\\nSELECT temperature\\nFROM Weather w2\\nWHERE DATEDIFF( day, w1.recordDate, w2.recordDate) =1\\n)"
                    },
                    {
                        "username": "brunomac",
                        "content": "that was my code\\nSELECT t1.id\\nFROM weather t1\\nJOIN weather t2 ON t1.id = t2.id + 1\\nWHERE t2.temperature < t1.temperature;\\n\\nthis was the result when i submit\\nWeather =\\n| id | recordDate | temperature |\\n| -- | ---------- | ----------- |\\n| 1  | 2000-12-16 | 3           |\\n| 2  | 2000-12-15 | -1          |\\nOutput\\n| id |\\n| -- |\\n\\nIts is running successfully but not able to submit!"
                    },
                    {
                        "username": "user8998lj",
                        "content": "can some one help me understand the iteration of the self join ? how the rows are considered?"
                    },
                    {
                        "username": "abhishekverma24",
                        "content": "Any hints why this solution is not working?  It works when I use dateDiff function\n`SELECT W2.id\nFROM Weather W1, Weather W2\nWHERE W2.temperature>W1.temperature AND DATE(W2.recordDate-1)=W1.recordDate;`"
                    },
                    {
                        "username": "zwan7415",
                        "content": "SELECT b.id as Id \\nFROM Weather a, Weather b \\nWHERE datediff(day,a.recordDate,b.recordDate)=1 \\nAND a.temperature < b.temperature "
                    },
                    {
                        "username": "jawad-shaikh",
                        "content": "`SELECT w1.id FROM Weather AS w1 INNER JOIN Weather AS w2\\nON w1.recordDate = DATE_ADD(w2.recordDate, INTERVAL 1 DAY) AND w1.temperature > w2.temperature`\\n\\nthis worked for me."
                    },
                    {
                        "username": "sanigo",
                        "content": "Can someone please let me know why the below solution does not satisfy all the test cases?\\nselect w1.id from weather w1 inner join weather w2 on w1.id!=w2.id\\nwhere\\nw1.recordDate=w2.recordDate+1 and\\nw1.temperature>w2.temperature"
                    }
                ]
            },
            {
                "id": 2018989,
                "content": [
                    {
                        "username": "i_0x6c1_i",
                        "content": "lot of answers here are using WHERE clause. But if you understand JOIN makes more sense here."
                    },
                    {
                        "username": "user0437YA",
                        "content": "better use this comment select id from weather where temperature = 25 or temperature = 30 "
                    },
                    {
                        "username": "prmems",
                        "content": "Haven\\'t seen anyone use this method:\\nSELECT id\\nFROM Weather w1\\nWHERE temperature > (SELECT temperature from Weather w2 WHERE w1.id = w2.id + 1)\\nIs there something wrong with it? it worked for me."
                    },
                    {
                        "username": "mr-xed",
                        "content": "it only works if you always insured the ids are sequential and there are no deleted rows, a simple example, think about a glitch that has removed a row of the id `3`, now the dependent next row will not be able to get the correct result hence `4` needs to know what `3` has but it doesn\\'t exist, if we really have a higher temp on either we can\\'t tell anymore."
                    },
                    {
                        "username": "superdrifter",
                        "content": "Hi guys, I used the following codes but it showed that the parameters inside DATEDIFF() are wrong, anyone knows why?\\n\\nSELECT id\\nFROM Weather w1\\nWHERE w1.temperature >(\\nSELECT temperature\\nFROM Weather w2\\nWHERE DATEDIFF( day, w1.recordDate, w2.recordDate) =1\\n)"
                    },
                    {
                        "username": "brunomac",
                        "content": "that was my code\\nSELECT t1.id\\nFROM weather t1\\nJOIN weather t2 ON t1.id = t2.id + 1\\nWHERE t2.temperature < t1.temperature;\\n\\nthis was the result when i submit\\nWeather =\\n| id | recordDate | temperature |\\n| -- | ---------- | ----------- |\\n| 1  | 2000-12-16 | 3           |\\n| 2  | 2000-12-15 | -1          |\\nOutput\\n| id |\\n| -- |\\n\\nIts is running successfully but not able to submit!"
                    },
                    {
                        "username": "user8998lj",
                        "content": "can some one help me understand the iteration of the self join ? how the rows are considered?"
                    },
                    {
                        "username": "abhishekverma24",
                        "content": "Any hints why this solution is not working?  It works when I use dateDiff function\n`SELECT W2.id\nFROM Weather W1, Weather W2\nWHERE W2.temperature>W1.temperature AND DATE(W2.recordDate-1)=W1.recordDate;`"
                    },
                    {
                        "username": "zwan7415",
                        "content": "SELECT b.id as Id \\nFROM Weather a, Weather b \\nWHERE datediff(day,a.recordDate,b.recordDate)=1 \\nAND a.temperature < b.temperature "
                    },
                    {
                        "username": "jawad-shaikh",
                        "content": "`SELECT w1.id FROM Weather AS w1 INNER JOIN Weather AS w2\\nON w1.recordDate = DATE_ADD(w2.recordDate, INTERVAL 1 DAY) AND w1.temperature > w2.temperature`\\n\\nthis worked for me."
                    },
                    {
                        "username": "sanigo",
                        "content": "Can someone please let me know why the below solution does not satisfy all the test cases?\\nselect w1.id from weather w1 inner join weather w2 on w1.id!=w2.id\\nwhere\\nw1.recordDate=w2.recordDate+1 and\\nw1.temperature>w2.temperature"
                    }
                ]
            },
            {
                "id": 2018616,
                "content": [
                    {
                        "username": "i_0x6c1_i",
                        "content": "lot of answers here are using WHERE clause. But if you understand JOIN makes more sense here."
                    },
                    {
                        "username": "user0437YA",
                        "content": "better use this comment select id from weather where temperature = 25 or temperature = 30 "
                    },
                    {
                        "username": "prmems",
                        "content": "Haven\\'t seen anyone use this method:\\nSELECT id\\nFROM Weather w1\\nWHERE temperature > (SELECT temperature from Weather w2 WHERE w1.id = w2.id + 1)\\nIs there something wrong with it? it worked for me."
                    },
                    {
                        "username": "mr-xed",
                        "content": "it only works if you always insured the ids are sequential and there are no deleted rows, a simple example, think about a glitch that has removed a row of the id `3`, now the dependent next row will not be able to get the correct result hence `4` needs to know what `3` has but it doesn\\'t exist, if we really have a higher temp on either we can\\'t tell anymore."
                    },
                    {
                        "username": "superdrifter",
                        "content": "Hi guys, I used the following codes but it showed that the parameters inside DATEDIFF() are wrong, anyone knows why?\\n\\nSELECT id\\nFROM Weather w1\\nWHERE w1.temperature >(\\nSELECT temperature\\nFROM Weather w2\\nWHERE DATEDIFF( day, w1.recordDate, w2.recordDate) =1\\n)"
                    },
                    {
                        "username": "brunomac",
                        "content": "that was my code\\nSELECT t1.id\\nFROM weather t1\\nJOIN weather t2 ON t1.id = t2.id + 1\\nWHERE t2.temperature < t1.temperature;\\n\\nthis was the result when i submit\\nWeather =\\n| id | recordDate | temperature |\\n| -- | ---------- | ----------- |\\n| 1  | 2000-12-16 | 3           |\\n| 2  | 2000-12-15 | -1          |\\nOutput\\n| id |\\n| -- |\\n\\nIts is running successfully but not able to submit!"
                    },
                    {
                        "username": "user8998lj",
                        "content": "can some one help me understand the iteration of the self join ? how the rows are considered?"
                    },
                    {
                        "username": "abhishekverma24",
                        "content": "Any hints why this solution is not working?  It works when I use dateDiff function\n`SELECT W2.id\nFROM Weather W1, Weather W2\nWHERE W2.temperature>W1.temperature AND DATE(W2.recordDate-1)=W1.recordDate;`"
                    },
                    {
                        "username": "zwan7415",
                        "content": "SELECT b.id as Id \\nFROM Weather a, Weather b \\nWHERE datediff(day,a.recordDate,b.recordDate)=1 \\nAND a.temperature < b.temperature "
                    },
                    {
                        "username": "jawad-shaikh",
                        "content": "`SELECT w1.id FROM Weather AS w1 INNER JOIN Weather AS w2\\nON w1.recordDate = DATE_ADD(w2.recordDate, INTERVAL 1 DAY) AND w1.temperature > w2.temperature`\\n\\nthis worked for me."
                    },
                    {
                        "username": "sanigo",
                        "content": "Can someone please let me know why the below solution does not satisfy all the test cases?\\nselect w1.id from weather w1 inner join weather w2 on w1.id!=w2.id\\nwhere\\nw1.recordDate=w2.recordDate+1 and\\nw1.temperature>w2.temperature"
                    }
                ]
            },
            {
                "id": 2017462,
                "content": [
                    {
                        "username": "i_0x6c1_i",
                        "content": "lot of answers here are using WHERE clause. But if you understand JOIN makes more sense here."
                    },
                    {
                        "username": "user0437YA",
                        "content": "better use this comment select id from weather where temperature = 25 or temperature = 30 "
                    },
                    {
                        "username": "prmems",
                        "content": "Haven\\'t seen anyone use this method:\\nSELECT id\\nFROM Weather w1\\nWHERE temperature > (SELECT temperature from Weather w2 WHERE w1.id = w2.id + 1)\\nIs there something wrong with it? it worked for me."
                    },
                    {
                        "username": "mr-xed",
                        "content": "it only works if you always insured the ids are sequential and there are no deleted rows, a simple example, think about a glitch that has removed a row of the id `3`, now the dependent next row will not be able to get the correct result hence `4` needs to know what `3` has but it doesn\\'t exist, if we really have a higher temp on either we can\\'t tell anymore."
                    },
                    {
                        "username": "superdrifter",
                        "content": "Hi guys, I used the following codes but it showed that the parameters inside DATEDIFF() are wrong, anyone knows why?\\n\\nSELECT id\\nFROM Weather w1\\nWHERE w1.temperature >(\\nSELECT temperature\\nFROM Weather w2\\nWHERE DATEDIFF( day, w1.recordDate, w2.recordDate) =1\\n)"
                    },
                    {
                        "username": "brunomac",
                        "content": "that was my code\\nSELECT t1.id\\nFROM weather t1\\nJOIN weather t2 ON t1.id = t2.id + 1\\nWHERE t2.temperature < t1.temperature;\\n\\nthis was the result when i submit\\nWeather =\\n| id | recordDate | temperature |\\n| -- | ---------- | ----------- |\\n| 1  | 2000-12-16 | 3           |\\n| 2  | 2000-12-15 | -1          |\\nOutput\\n| id |\\n| -- |\\n\\nIts is running successfully but not able to submit!"
                    },
                    {
                        "username": "user8998lj",
                        "content": "can some one help me understand the iteration of the self join ? how the rows are considered?"
                    },
                    {
                        "username": "abhishekverma24",
                        "content": "Any hints why this solution is not working?  It works when I use dateDiff function\n`SELECT W2.id\nFROM Weather W1, Weather W2\nWHERE W2.temperature>W1.temperature AND DATE(W2.recordDate-1)=W1.recordDate;`"
                    },
                    {
                        "username": "zwan7415",
                        "content": "SELECT b.id as Id \\nFROM Weather a, Weather b \\nWHERE datediff(day,a.recordDate,b.recordDate)=1 \\nAND a.temperature < b.temperature "
                    },
                    {
                        "username": "jawad-shaikh",
                        "content": "`SELECT w1.id FROM Weather AS w1 INNER JOIN Weather AS w2\\nON w1.recordDate = DATE_ADD(w2.recordDate, INTERVAL 1 DAY) AND w1.temperature > w2.temperature`\\n\\nthis worked for me."
                    },
                    {
                        "username": "sanigo",
                        "content": "Can someone please let me know why the below solution does not satisfy all the test cases?\\nselect w1.id from weather w1 inner join weather w2 on w1.id!=w2.id\\nwhere\\nw1.recordDate=w2.recordDate+1 and\\nw1.temperature>w2.temperature"
                    }
                ]
            },
            {
                "id": 2017099,
                "content": [
                    {
                        "username": "i_0x6c1_i",
                        "content": "lot of answers here are using WHERE clause. But if you understand JOIN makes more sense here."
                    },
                    {
                        "username": "user0437YA",
                        "content": "better use this comment select id from weather where temperature = 25 or temperature = 30 "
                    },
                    {
                        "username": "prmems",
                        "content": "Haven\\'t seen anyone use this method:\\nSELECT id\\nFROM Weather w1\\nWHERE temperature > (SELECT temperature from Weather w2 WHERE w1.id = w2.id + 1)\\nIs there something wrong with it? it worked for me."
                    },
                    {
                        "username": "mr-xed",
                        "content": "it only works if you always insured the ids are sequential and there are no deleted rows, a simple example, think about a glitch that has removed a row of the id `3`, now the dependent next row will not be able to get the correct result hence `4` needs to know what `3` has but it doesn\\'t exist, if we really have a higher temp on either we can\\'t tell anymore."
                    },
                    {
                        "username": "superdrifter",
                        "content": "Hi guys, I used the following codes but it showed that the parameters inside DATEDIFF() are wrong, anyone knows why?\\n\\nSELECT id\\nFROM Weather w1\\nWHERE w1.temperature >(\\nSELECT temperature\\nFROM Weather w2\\nWHERE DATEDIFF( day, w1.recordDate, w2.recordDate) =1\\n)"
                    },
                    {
                        "username": "brunomac",
                        "content": "that was my code\\nSELECT t1.id\\nFROM weather t1\\nJOIN weather t2 ON t1.id = t2.id + 1\\nWHERE t2.temperature < t1.temperature;\\n\\nthis was the result when i submit\\nWeather =\\n| id | recordDate | temperature |\\n| -- | ---------- | ----------- |\\n| 1  | 2000-12-16 | 3           |\\n| 2  | 2000-12-15 | -1          |\\nOutput\\n| id |\\n| -- |\\n\\nIts is running successfully but not able to submit!"
                    },
                    {
                        "username": "user8998lj",
                        "content": "can some one help me understand the iteration of the self join ? how the rows are considered?"
                    },
                    {
                        "username": "abhishekverma24",
                        "content": "Any hints why this solution is not working?  It works when I use dateDiff function\n`SELECT W2.id\nFROM Weather W1, Weather W2\nWHERE W2.temperature>W1.temperature AND DATE(W2.recordDate-1)=W1.recordDate;`"
                    },
                    {
                        "username": "zwan7415",
                        "content": "SELECT b.id as Id \\nFROM Weather a, Weather b \\nWHERE datediff(day,a.recordDate,b.recordDate)=1 \\nAND a.temperature < b.temperature "
                    },
                    {
                        "username": "jawad-shaikh",
                        "content": "`SELECT w1.id FROM Weather AS w1 INNER JOIN Weather AS w2\\nON w1.recordDate = DATE_ADD(w2.recordDate, INTERVAL 1 DAY) AND w1.temperature > w2.temperature`\\n\\nthis worked for me."
                    },
                    {
                        "username": "sanigo",
                        "content": "Can someone please let me know why the below solution does not satisfy all the test cases?\\nselect w1.id from weather w1 inner join weather w2 on w1.id!=w2.id\\nwhere\\nw1.recordDate=w2.recordDate+1 and\\nw1.temperature>w2.temperature"
                    }
                ]
            },
            {
                "id": 2016102,
                "content": [
                    {
                        "username": "i_0x6c1_i",
                        "content": "lot of answers here are using WHERE clause. But if you understand JOIN makes more sense here."
                    },
                    {
                        "username": "user0437YA",
                        "content": "better use this comment select id from weather where temperature = 25 or temperature = 30 "
                    },
                    {
                        "username": "prmems",
                        "content": "Haven\\'t seen anyone use this method:\\nSELECT id\\nFROM Weather w1\\nWHERE temperature > (SELECT temperature from Weather w2 WHERE w1.id = w2.id + 1)\\nIs there something wrong with it? it worked for me."
                    },
                    {
                        "username": "mr-xed",
                        "content": "it only works if you always insured the ids are sequential and there are no deleted rows, a simple example, think about a glitch that has removed a row of the id `3`, now the dependent next row will not be able to get the correct result hence `4` needs to know what `3` has but it doesn\\'t exist, if we really have a higher temp on either we can\\'t tell anymore."
                    },
                    {
                        "username": "superdrifter",
                        "content": "Hi guys, I used the following codes but it showed that the parameters inside DATEDIFF() are wrong, anyone knows why?\\n\\nSELECT id\\nFROM Weather w1\\nWHERE w1.temperature >(\\nSELECT temperature\\nFROM Weather w2\\nWHERE DATEDIFF( day, w1.recordDate, w2.recordDate) =1\\n)"
                    },
                    {
                        "username": "brunomac",
                        "content": "that was my code\\nSELECT t1.id\\nFROM weather t1\\nJOIN weather t2 ON t1.id = t2.id + 1\\nWHERE t2.temperature < t1.temperature;\\n\\nthis was the result when i submit\\nWeather =\\n| id | recordDate | temperature |\\n| -- | ---------- | ----------- |\\n| 1  | 2000-12-16 | 3           |\\n| 2  | 2000-12-15 | -1          |\\nOutput\\n| id |\\n| -- |\\n\\nIts is running successfully but not able to submit!"
                    },
                    {
                        "username": "user8998lj",
                        "content": "can some one help me understand the iteration of the self join ? how the rows are considered?"
                    },
                    {
                        "username": "abhishekverma24",
                        "content": "Any hints why this solution is not working?  It works when I use dateDiff function\n`SELECT W2.id\nFROM Weather W1, Weather W2\nWHERE W2.temperature>W1.temperature AND DATE(W2.recordDate-1)=W1.recordDate;`"
                    },
                    {
                        "username": "zwan7415",
                        "content": "SELECT b.id as Id \\nFROM Weather a, Weather b \\nWHERE datediff(day,a.recordDate,b.recordDate)=1 \\nAND a.temperature < b.temperature "
                    },
                    {
                        "username": "jawad-shaikh",
                        "content": "`SELECT w1.id FROM Weather AS w1 INNER JOIN Weather AS w2\\nON w1.recordDate = DATE_ADD(w2.recordDate, INTERVAL 1 DAY) AND w1.temperature > w2.temperature`\\n\\nthis worked for me."
                    },
                    {
                        "username": "sanigo",
                        "content": "Can someone please let me know why the below solution does not satisfy all the test cases?\\nselect w1.id from weather w1 inner join weather w2 on w1.id!=w2.id\\nwhere\\nw1.recordDate=w2.recordDate+1 and\\nw1.temperature>w2.temperature"
                    }
                ]
            },
            {
                "id": 2014444,
                "content": [
                    {
                        "username": "i_0x6c1_i",
                        "content": "lot of answers here are using WHERE clause. But if you understand JOIN makes more sense here."
                    },
                    {
                        "username": "user0437YA",
                        "content": "better use this comment select id from weather where temperature = 25 or temperature = 30 "
                    },
                    {
                        "username": "prmems",
                        "content": "Haven\\'t seen anyone use this method:\\nSELECT id\\nFROM Weather w1\\nWHERE temperature > (SELECT temperature from Weather w2 WHERE w1.id = w2.id + 1)\\nIs there something wrong with it? it worked for me."
                    },
                    {
                        "username": "mr-xed",
                        "content": "it only works if you always insured the ids are sequential and there are no deleted rows, a simple example, think about a glitch that has removed a row of the id `3`, now the dependent next row will not be able to get the correct result hence `4` needs to know what `3` has but it doesn\\'t exist, if we really have a higher temp on either we can\\'t tell anymore."
                    },
                    {
                        "username": "superdrifter",
                        "content": "Hi guys, I used the following codes but it showed that the parameters inside DATEDIFF() are wrong, anyone knows why?\\n\\nSELECT id\\nFROM Weather w1\\nWHERE w1.temperature >(\\nSELECT temperature\\nFROM Weather w2\\nWHERE DATEDIFF( day, w1.recordDate, w2.recordDate) =1\\n)"
                    },
                    {
                        "username": "brunomac",
                        "content": "that was my code\\nSELECT t1.id\\nFROM weather t1\\nJOIN weather t2 ON t1.id = t2.id + 1\\nWHERE t2.temperature < t1.temperature;\\n\\nthis was the result when i submit\\nWeather =\\n| id | recordDate | temperature |\\n| -- | ---------- | ----------- |\\n| 1  | 2000-12-16 | 3           |\\n| 2  | 2000-12-15 | -1          |\\nOutput\\n| id |\\n| -- |\\n\\nIts is running successfully but not able to submit!"
                    },
                    {
                        "username": "user8998lj",
                        "content": "can some one help me understand the iteration of the self join ? how the rows are considered?"
                    },
                    {
                        "username": "abhishekverma24",
                        "content": "Any hints why this solution is not working?  It works when I use dateDiff function\n`SELECT W2.id\nFROM Weather W1, Weather W2\nWHERE W2.temperature>W1.temperature AND DATE(W2.recordDate-1)=W1.recordDate;`"
                    },
                    {
                        "username": "zwan7415",
                        "content": "SELECT b.id as Id \\nFROM Weather a, Weather b \\nWHERE datediff(day,a.recordDate,b.recordDate)=1 \\nAND a.temperature < b.temperature "
                    },
                    {
                        "username": "jawad-shaikh",
                        "content": "`SELECT w1.id FROM Weather AS w1 INNER JOIN Weather AS w2\\nON w1.recordDate = DATE_ADD(w2.recordDate, INTERVAL 1 DAY) AND w1.temperature > w2.temperature`\\n\\nthis worked for me."
                    },
                    {
                        "username": "sanigo",
                        "content": "Can someone please let me know why the below solution does not satisfy all the test cases?\\nselect w1.id from weather w1 inner join weather w2 on w1.id!=w2.id\\nwhere\\nw1.recordDate=w2.recordDate+1 and\\nw1.temperature>w2.temperature"
                    }
                ]
            },
            {
                "id": 2008921,
                "content": [
                    {
                        "username": "i_0x6c1_i",
                        "content": "lot of answers here are using WHERE clause. But if you understand JOIN makes more sense here."
                    },
                    {
                        "username": "user0437YA",
                        "content": "better use this comment select id from weather where temperature = 25 or temperature = 30 "
                    },
                    {
                        "username": "prmems",
                        "content": "Haven\\'t seen anyone use this method:\\nSELECT id\\nFROM Weather w1\\nWHERE temperature > (SELECT temperature from Weather w2 WHERE w1.id = w2.id + 1)\\nIs there something wrong with it? it worked for me."
                    },
                    {
                        "username": "mr-xed",
                        "content": "it only works if you always insured the ids are sequential and there are no deleted rows, a simple example, think about a glitch that has removed a row of the id `3`, now the dependent next row will not be able to get the correct result hence `4` needs to know what `3` has but it doesn\\'t exist, if we really have a higher temp on either we can\\'t tell anymore."
                    },
                    {
                        "username": "superdrifter",
                        "content": "Hi guys, I used the following codes but it showed that the parameters inside DATEDIFF() are wrong, anyone knows why?\\n\\nSELECT id\\nFROM Weather w1\\nWHERE w1.temperature >(\\nSELECT temperature\\nFROM Weather w2\\nWHERE DATEDIFF( day, w1.recordDate, w2.recordDate) =1\\n)"
                    },
                    {
                        "username": "brunomac",
                        "content": "that was my code\\nSELECT t1.id\\nFROM weather t1\\nJOIN weather t2 ON t1.id = t2.id + 1\\nWHERE t2.temperature < t1.temperature;\\n\\nthis was the result when i submit\\nWeather =\\n| id | recordDate | temperature |\\n| -- | ---------- | ----------- |\\n| 1  | 2000-12-16 | 3           |\\n| 2  | 2000-12-15 | -1          |\\nOutput\\n| id |\\n| -- |\\n\\nIts is running successfully but not able to submit!"
                    },
                    {
                        "username": "user8998lj",
                        "content": "can some one help me understand the iteration of the self join ? how the rows are considered?"
                    },
                    {
                        "username": "abhishekverma24",
                        "content": "Any hints why this solution is not working?  It works when I use dateDiff function\n`SELECT W2.id\nFROM Weather W1, Weather W2\nWHERE W2.temperature>W1.temperature AND DATE(W2.recordDate-1)=W1.recordDate;`"
                    },
                    {
                        "username": "zwan7415",
                        "content": "SELECT b.id as Id \\nFROM Weather a, Weather b \\nWHERE datediff(day,a.recordDate,b.recordDate)=1 \\nAND a.temperature < b.temperature "
                    },
                    {
                        "username": "jawad-shaikh",
                        "content": "`SELECT w1.id FROM Weather AS w1 INNER JOIN Weather AS w2\\nON w1.recordDate = DATE_ADD(w2.recordDate, INTERVAL 1 DAY) AND w1.temperature > w2.temperature`\\n\\nthis worked for me."
                    },
                    {
                        "username": "sanigo",
                        "content": "Can someone please let me know why the below solution does not satisfy all the test cases?\\nselect w1.id from weather w1 inner join weather w2 on w1.id!=w2.id\\nwhere\\nw1.recordDate=w2.recordDate+1 and\\nw1.temperature>w2.temperature"
                    }
                ]
            },
            {
                "id": 1999490,
                "content": [
                    {
                        "username": "rejent",
                        "content": " `SELECT w2.Id FROM Weather w1, Weather w2 WHERE w2.Temperature > w1.Temperature`\\n`AND\\nDATEDIFF(day,w1.recordDate,w2.recordDate)=1`"
                    },
                    {
                        "username": "mohdriduan13",
                        "content": "WITH cte AS (\\nSELECT *, LAG(temperature) OVER (ORDER BY id) AS prev_temp\\nFROM Weather)\\nSELECT id\\nFROM cte\\nWHERE temperature - prev_temp  > 0\\n"
                    },
                    {
                        "username": "pranshunayak566",
                        "content": "why this does not work?\\n\\n `# Write your MySQL query statement below\\nselect w1.id \\nfrom Weather as w1\\nwhere exists (\\n    select w2.id \\n    from Weather as w2\\n    where YEAR(w1.recordDate)=YEAR(w2.recordDate) and MONTH(w1.recordDate)=MONTH(w2.recordDate) and DAY(w1.recordDate)-DAY(w2.recordDate)=1 and w1.temperature > w2.temperature\\n)`"
                    },
                    {
                        "username": "Gajanan_todeti",
                        "content": "solved using windows functions  \\nselect id\\nfrom \\n(select*,\\nlag(temperature)over(order by recordDate) as prev_temp\\nfrom Weather ) as tbl\\nwhere temperature > prev_temp"
                    },
                    {
                        "username": "akacool0744",
                        "content": "Most fastest way : \\n`Select w2.id from Weather w1, Weather w2  where w1.temperature < w2.temperature and w2.recordDate = DATEADD(day, 1, w1.recordDate);`"
                    },
                    {
                        "username": "akacool0744",
                        "content": "Fastest way :- MS SQL Server\\n\\n `Select w2.id from Weather w1, Weather w2  where w1.temperature < w2.temperature and w2.recordDate = DATEADD(day, 1, w1.recordDate);`"
                    },
                    {
                        "username": "adi031999",
                        "content": "what should be approach for problem if data given is not for consecutive dates."
                    },
                    {
                        "username": "Ra1242",
                        "content": "My code is:\\nselect a.id\\nfrom weather a,weather b\\nWhere datediff(day, b.recordDate, a.recordDate) = 1 and a.temperature > b.temperature"
                    },
                    {
                        "username": "ankush20386",
                        "content": "only 1 test case is left to pass what is wrong with this query?\\n\\n\\nwith \\ncte as(select id,recordDate,temperature,LAG(temperature,1)over(order by recordDate) as temp,LAG(recordDate,1)over(order by recordDate) as recordb  from weather)\\nselect id from cte where temperature>temp and (recordDate-recordb=1);\\n"
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS \n(SELECT id, LAG(recordDate) OVER (ORDER BY recordDate) AS YestDate, recordDate, \nLAG(temperature) OVER (ORDER BY recordDate) AS YestTemp, temperature\nFROM Weather)\n\nSELECT id \nFROM CTE \nWHERE temperature > YestTemp\nAND DATEDIFF(day, YestDate, recordDate) = 1"
                    }
                ]
            },
            {
                "id": 1997872,
                "content": [
                    {
                        "username": "rejent",
                        "content": " `SELECT w2.Id FROM Weather w1, Weather w2 WHERE w2.Temperature > w1.Temperature`\\n`AND\\nDATEDIFF(day,w1.recordDate,w2.recordDate)=1`"
                    },
                    {
                        "username": "mohdriduan13",
                        "content": "WITH cte AS (\\nSELECT *, LAG(temperature) OVER (ORDER BY id) AS prev_temp\\nFROM Weather)\\nSELECT id\\nFROM cte\\nWHERE temperature - prev_temp  > 0\\n"
                    },
                    {
                        "username": "pranshunayak566",
                        "content": "why this does not work?\\n\\n `# Write your MySQL query statement below\\nselect w1.id \\nfrom Weather as w1\\nwhere exists (\\n    select w2.id \\n    from Weather as w2\\n    where YEAR(w1.recordDate)=YEAR(w2.recordDate) and MONTH(w1.recordDate)=MONTH(w2.recordDate) and DAY(w1.recordDate)-DAY(w2.recordDate)=1 and w1.temperature > w2.temperature\\n)`"
                    },
                    {
                        "username": "Gajanan_todeti",
                        "content": "solved using windows functions  \\nselect id\\nfrom \\n(select*,\\nlag(temperature)over(order by recordDate) as prev_temp\\nfrom Weather ) as tbl\\nwhere temperature > prev_temp"
                    },
                    {
                        "username": "akacool0744",
                        "content": "Most fastest way : \\n`Select w2.id from Weather w1, Weather w2  where w1.temperature < w2.temperature and w2.recordDate = DATEADD(day, 1, w1.recordDate);`"
                    },
                    {
                        "username": "akacool0744",
                        "content": "Fastest way :- MS SQL Server\\n\\n `Select w2.id from Weather w1, Weather w2  where w1.temperature < w2.temperature and w2.recordDate = DATEADD(day, 1, w1.recordDate);`"
                    },
                    {
                        "username": "adi031999",
                        "content": "what should be approach for problem if data given is not for consecutive dates."
                    },
                    {
                        "username": "Ra1242",
                        "content": "My code is:\\nselect a.id\\nfrom weather a,weather b\\nWhere datediff(day, b.recordDate, a.recordDate) = 1 and a.temperature > b.temperature"
                    },
                    {
                        "username": "ankush20386",
                        "content": "only 1 test case is left to pass what is wrong with this query?\\n\\n\\nwith \\ncte as(select id,recordDate,temperature,LAG(temperature,1)over(order by recordDate) as temp,LAG(recordDate,1)over(order by recordDate) as recordb  from weather)\\nselect id from cte where temperature>temp and (recordDate-recordb=1);\\n"
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS \n(SELECT id, LAG(recordDate) OVER (ORDER BY recordDate) AS YestDate, recordDate, \nLAG(temperature) OVER (ORDER BY recordDate) AS YestTemp, temperature\nFROM Weather)\n\nSELECT id \nFROM CTE \nWHERE temperature > YestTemp\nAND DATEDIFF(day, YestDate, recordDate) = 1"
                    }
                ]
            },
            {
                "id": 1995452,
                "content": [
                    {
                        "username": "rejent",
                        "content": " `SELECT w2.Id FROM Weather w1, Weather w2 WHERE w2.Temperature > w1.Temperature`\\n`AND\\nDATEDIFF(day,w1.recordDate,w2.recordDate)=1`"
                    },
                    {
                        "username": "mohdriduan13",
                        "content": "WITH cte AS (\\nSELECT *, LAG(temperature) OVER (ORDER BY id) AS prev_temp\\nFROM Weather)\\nSELECT id\\nFROM cte\\nWHERE temperature - prev_temp  > 0\\n"
                    },
                    {
                        "username": "pranshunayak566",
                        "content": "why this does not work?\\n\\n `# Write your MySQL query statement below\\nselect w1.id \\nfrom Weather as w1\\nwhere exists (\\n    select w2.id \\n    from Weather as w2\\n    where YEAR(w1.recordDate)=YEAR(w2.recordDate) and MONTH(w1.recordDate)=MONTH(w2.recordDate) and DAY(w1.recordDate)-DAY(w2.recordDate)=1 and w1.temperature > w2.temperature\\n)`"
                    },
                    {
                        "username": "Gajanan_todeti",
                        "content": "solved using windows functions  \\nselect id\\nfrom \\n(select*,\\nlag(temperature)over(order by recordDate) as prev_temp\\nfrom Weather ) as tbl\\nwhere temperature > prev_temp"
                    },
                    {
                        "username": "akacool0744",
                        "content": "Most fastest way : \\n`Select w2.id from Weather w1, Weather w2  where w1.temperature < w2.temperature and w2.recordDate = DATEADD(day, 1, w1.recordDate);`"
                    },
                    {
                        "username": "akacool0744",
                        "content": "Fastest way :- MS SQL Server\\n\\n `Select w2.id from Weather w1, Weather w2  where w1.temperature < w2.temperature and w2.recordDate = DATEADD(day, 1, w1.recordDate);`"
                    },
                    {
                        "username": "adi031999",
                        "content": "what should be approach for problem if data given is not for consecutive dates."
                    },
                    {
                        "username": "Ra1242",
                        "content": "My code is:\\nselect a.id\\nfrom weather a,weather b\\nWhere datediff(day, b.recordDate, a.recordDate) = 1 and a.temperature > b.temperature"
                    },
                    {
                        "username": "ankush20386",
                        "content": "only 1 test case is left to pass what is wrong with this query?\\n\\n\\nwith \\ncte as(select id,recordDate,temperature,LAG(temperature,1)over(order by recordDate) as temp,LAG(recordDate,1)over(order by recordDate) as recordb  from weather)\\nselect id from cte where temperature>temp and (recordDate-recordb=1);\\n"
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS \n(SELECT id, LAG(recordDate) OVER (ORDER BY recordDate) AS YestDate, recordDate, \nLAG(temperature) OVER (ORDER BY recordDate) AS YestTemp, temperature\nFROM Weather)\n\nSELECT id \nFROM CTE \nWHERE temperature > YestTemp\nAND DATEDIFF(day, YestDate, recordDate) = 1"
                    }
                ]
            },
            {
                "id": 1994323,
                "content": [
                    {
                        "username": "rejent",
                        "content": " `SELECT w2.Id FROM Weather w1, Weather w2 WHERE w2.Temperature > w1.Temperature`\\n`AND\\nDATEDIFF(day,w1.recordDate,w2.recordDate)=1`"
                    },
                    {
                        "username": "mohdriduan13",
                        "content": "WITH cte AS (\\nSELECT *, LAG(temperature) OVER (ORDER BY id) AS prev_temp\\nFROM Weather)\\nSELECT id\\nFROM cte\\nWHERE temperature - prev_temp  > 0\\n"
                    },
                    {
                        "username": "pranshunayak566",
                        "content": "why this does not work?\\n\\n `# Write your MySQL query statement below\\nselect w1.id \\nfrom Weather as w1\\nwhere exists (\\n    select w2.id \\n    from Weather as w2\\n    where YEAR(w1.recordDate)=YEAR(w2.recordDate) and MONTH(w1.recordDate)=MONTH(w2.recordDate) and DAY(w1.recordDate)-DAY(w2.recordDate)=1 and w1.temperature > w2.temperature\\n)`"
                    },
                    {
                        "username": "Gajanan_todeti",
                        "content": "solved using windows functions  \\nselect id\\nfrom \\n(select*,\\nlag(temperature)over(order by recordDate) as prev_temp\\nfrom Weather ) as tbl\\nwhere temperature > prev_temp"
                    },
                    {
                        "username": "akacool0744",
                        "content": "Most fastest way : \\n`Select w2.id from Weather w1, Weather w2  where w1.temperature < w2.temperature and w2.recordDate = DATEADD(day, 1, w1.recordDate);`"
                    },
                    {
                        "username": "akacool0744",
                        "content": "Fastest way :- MS SQL Server\\n\\n `Select w2.id from Weather w1, Weather w2  where w1.temperature < w2.temperature and w2.recordDate = DATEADD(day, 1, w1.recordDate);`"
                    },
                    {
                        "username": "adi031999",
                        "content": "what should be approach for problem if data given is not for consecutive dates."
                    },
                    {
                        "username": "Ra1242",
                        "content": "My code is:\\nselect a.id\\nfrom weather a,weather b\\nWhere datediff(day, b.recordDate, a.recordDate) = 1 and a.temperature > b.temperature"
                    },
                    {
                        "username": "ankush20386",
                        "content": "only 1 test case is left to pass what is wrong with this query?\\n\\n\\nwith \\ncte as(select id,recordDate,temperature,LAG(temperature,1)over(order by recordDate) as temp,LAG(recordDate,1)over(order by recordDate) as recordb  from weather)\\nselect id from cte where temperature>temp and (recordDate-recordb=1);\\n"
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS \n(SELECT id, LAG(recordDate) OVER (ORDER BY recordDate) AS YestDate, recordDate, \nLAG(temperature) OVER (ORDER BY recordDate) AS YestTemp, temperature\nFROM Weather)\n\nSELECT id \nFROM CTE \nWHERE temperature > YestTemp\nAND DATEDIFF(day, YestDate, recordDate) = 1"
                    }
                ]
            },
            {
                "id": 1993458,
                "content": [
                    {
                        "username": "rejent",
                        "content": " `SELECT w2.Id FROM Weather w1, Weather w2 WHERE w2.Temperature > w1.Temperature`\\n`AND\\nDATEDIFF(day,w1.recordDate,w2.recordDate)=1`"
                    },
                    {
                        "username": "mohdriduan13",
                        "content": "WITH cte AS (\\nSELECT *, LAG(temperature) OVER (ORDER BY id) AS prev_temp\\nFROM Weather)\\nSELECT id\\nFROM cte\\nWHERE temperature - prev_temp  > 0\\n"
                    },
                    {
                        "username": "pranshunayak566",
                        "content": "why this does not work?\\n\\n `# Write your MySQL query statement below\\nselect w1.id \\nfrom Weather as w1\\nwhere exists (\\n    select w2.id \\n    from Weather as w2\\n    where YEAR(w1.recordDate)=YEAR(w2.recordDate) and MONTH(w1.recordDate)=MONTH(w2.recordDate) and DAY(w1.recordDate)-DAY(w2.recordDate)=1 and w1.temperature > w2.temperature\\n)`"
                    },
                    {
                        "username": "Gajanan_todeti",
                        "content": "solved using windows functions  \\nselect id\\nfrom \\n(select*,\\nlag(temperature)over(order by recordDate) as prev_temp\\nfrom Weather ) as tbl\\nwhere temperature > prev_temp"
                    },
                    {
                        "username": "akacool0744",
                        "content": "Most fastest way : \\n`Select w2.id from Weather w1, Weather w2  where w1.temperature < w2.temperature and w2.recordDate = DATEADD(day, 1, w1.recordDate);`"
                    },
                    {
                        "username": "akacool0744",
                        "content": "Fastest way :- MS SQL Server\\n\\n `Select w2.id from Weather w1, Weather w2  where w1.temperature < w2.temperature and w2.recordDate = DATEADD(day, 1, w1.recordDate);`"
                    },
                    {
                        "username": "adi031999",
                        "content": "what should be approach for problem if data given is not for consecutive dates."
                    },
                    {
                        "username": "Ra1242",
                        "content": "My code is:\\nselect a.id\\nfrom weather a,weather b\\nWhere datediff(day, b.recordDate, a.recordDate) = 1 and a.temperature > b.temperature"
                    },
                    {
                        "username": "ankush20386",
                        "content": "only 1 test case is left to pass what is wrong with this query?\\n\\n\\nwith \\ncte as(select id,recordDate,temperature,LAG(temperature,1)over(order by recordDate) as temp,LAG(recordDate,1)over(order by recordDate) as recordb  from weather)\\nselect id from cte where temperature>temp and (recordDate-recordb=1);\\n"
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS \n(SELECT id, LAG(recordDate) OVER (ORDER BY recordDate) AS YestDate, recordDate, \nLAG(temperature) OVER (ORDER BY recordDate) AS YestTemp, temperature\nFROM Weather)\n\nSELECT id \nFROM CTE \nWHERE temperature > YestTemp\nAND DATEDIFF(day, YestDate, recordDate) = 1"
                    }
                ]
            },
            {
                "id": 1993343,
                "content": [
                    {
                        "username": "rejent",
                        "content": " `SELECT w2.Id FROM Weather w1, Weather w2 WHERE w2.Temperature > w1.Temperature`\\n`AND\\nDATEDIFF(day,w1.recordDate,w2.recordDate)=1`"
                    },
                    {
                        "username": "mohdriduan13",
                        "content": "WITH cte AS (\\nSELECT *, LAG(temperature) OVER (ORDER BY id) AS prev_temp\\nFROM Weather)\\nSELECT id\\nFROM cte\\nWHERE temperature - prev_temp  > 0\\n"
                    },
                    {
                        "username": "pranshunayak566",
                        "content": "why this does not work?\\n\\n `# Write your MySQL query statement below\\nselect w1.id \\nfrom Weather as w1\\nwhere exists (\\n    select w2.id \\n    from Weather as w2\\n    where YEAR(w1.recordDate)=YEAR(w2.recordDate) and MONTH(w1.recordDate)=MONTH(w2.recordDate) and DAY(w1.recordDate)-DAY(w2.recordDate)=1 and w1.temperature > w2.temperature\\n)`"
                    },
                    {
                        "username": "Gajanan_todeti",
                        "content": "solved using windows functions  \\nselect id\\nfrom \\n(select*,\\nlag(temperature)over(order by recordDate) as prev_temp\\nfrom Weather ) as tbl\\nwhere temperature > prev_temp"
                    },
                    {
                        "username": "akacool0744",
                        "content": "Most fastest way : \\n`Select w2.id from Weather w1, Weather w2  where w1.temperature < w2.temperature and w2.recordDate = DATEADD(day, 1, w1.recordDate);`"
                    },
                    {
                        "username": "akacool0744",
                        "content": "Fastest way :- MS SQL Server\\n\\n `Select w2.id from Weather w1, Weather w2  where w1.temperature < w2.temperature and w2.recordDate = DATEADD(day, 1, w1.recordDate);`"
                    },
                    {
                        "username": "adi031999",
                        "content": "what should be approach for problem if data given is not for consecutive dates."
                    },
                    {
                        "username": "Ra1242",
                        "content": "My code is:\\nselect a.id\\nfrom weather a,weather b\\nWhere datediff(day, b.recordDate, a.recordDate) = 1 and a.temperature > b.temperature"
                    },
                    {
                        "username": "ankush20386",
                        "content": "only 1 test case is left to pass what is wrong with this query?\\n\\n\\nwith \\ncte as(select id,recordDate,temperature,LAG(temperature,1)over(order by recordDate) as temp,LAG(recordDate,1)over(order by recordDate) as recordb  from weather)\\nselect id from cte where temperature>temp and (recordDate-recordb=1);\\n"
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS \n(SELECT id, LAG(recordDate) OVER (ORDER BY recordDate) AS YestDate, recordDate, \nLAG(temperature) OVER (ORDER BY recordDate) AS YestTemp, temperature\nFROM Weather)\n\nSELECT id \nFROM CTE \nWHERE temperature > YestTemp\nAND DATEDIFF(day, YestDate, recordDate) = 1"
                    }
                ]
            },
            {
                "id": 1991781,
                "content": [
                    {
                        "username": "rejent",
                        "content": " `SELECT w2.Id FROM Weather w1, Weather w2 WHERE w2.Temperature > w1.Temperature`\\n`AND\\nDATEDIFF(day,w1.recordDate,w2.recordDate)=1`"
                    },
                    {
                        "username": "mohdriduan13",
                        "content": "WITH cte AS (\\nSELECT *, LAG(temperature) OVER (ORDER BY id) AS prev_temp\\nFROM Weather)\\nSELECT id\\nFROM cte\\nWHERE temperature - prev_temp  > 0\\n"
                    },
                    {
                        "username": "pranshunayak566",
                        "content": "why this does not work?\\n\\n `# Write your MySQL query statement below\\nselect w1.id \\nfrom Weather as w1\\nwhere exists (\\n    select w2.id \\n    from Weather as w2\\n    where YEAR(w1.recordDate)=YEAR(w2.recordDate) and MONTH(w1.recordDate)=MONTH(w2.recordDate) and DAY(w1.recordDate)-DAY(w2.recordDate)=1 and w1.temperature > w2.temperature\\n)`"
                    },
                    {
                        "username": "Gajanan_todeti",
                        "content": "solved using windows functions  \\nselect id\\nfrom \\n(select*,\\nlag(temperature)over(order by recordDate) as prev_temp\\nfrom Weather ) as tbl\\nwhere temperature > prev_temp"
                    },
                    {
                        "username": "akacool0744",
                        "content": "Most fastest way : \\n`Select w2.id from Weather w1, Weather w2  where w1.temperature < w2.temperature and w2.recordDate = DATEADD(day, 1, w1.recordDate);`"
                    },
                    {
                        "username": "akacool0744",
                        "content": "Fastest way :- MS SQL Server\\n\\n `Select w2.id from Weather w1, Weather w2  where w1.temperature < w2.temperature and w2.recordDate = DATEADD(day, 1, w1.recordDate);`"
                    },
                    {
                        "username": "adi031999",
                        "content": "what should be approach for problem if data given is not for consecutive dates."
                    },
                    {
                        "username": "Ra1242",
                        "content": "My code is:\\nselect a.id\\nfrom weather a,weather b\\nWhere datediff(day, b.recordDate, a.recordDate) = 1 and a.temperature > b.temperature"
                    },
                    {
                        "username": "ankush20386",
                        "content": "only 1 test case is left to pass what is wrong with this query?\\n\\n\\nwith \\ncte as(select id,recordDate,temperature,LAG(temperature,1)over(order by recordDate) as temp,LAG(recordDate,1)over(order by recordDate) as recordb  from weather)\\nselect id from cte where temperature>temp and (recordDate-recordb=1);\\n"
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS \n(SELECT id, LAG(recordDate) OVER (ORDER BY recordDate) AS YestDate, recordDate, \nLAG(temperature) OVER (ORDER BY recordDate) AS YestTemp, temperature\nFROM Weather)\n\nSELECT id \nFROM CTE \nWHERE temperature > YestTemp\nAND DATEDIFF(day, YestDate, recordDate) = 1"
                    }
                ]
            },
            {
                "id": 1987194,
                "content": [
                    {
                        "username": "rejent",
                        "content": " `SELECT w2.Id FROM Weather w1, Weather w2 WHERE w2.Temperature > w1.Temperature`\\n`AND\\nDATEDIFF(day,w1.recordDate,w2.recordDate)=1`"
                    },
                    {
                        "username": "mohdriduan13",
                        "content": "WITH cte AS (\\nSELECT *, LAG(temperature) OVER (ORDER BY id) AS prev_temp\\nFROM Weather)\\nSELECT id\\nFROM cte\\nWHERE temperature - prev_temp  > 0\\n"
                    },
                    {
                        "username": "pranshunayak566",
                        "content": "why this does not work?\\n\\n `# Write your MySQL query statement below\\nselect w1.id \\nfrom Weather as w1\\nwhere exists (\\n    select w2.id \\n    from Weather as w2\\n    where YEAR(w1.recordDate)=YEAR(w2.recordDate) and MONTH(w1.recordDate)=MONTH(w2.recordDate) and DAY(w1.recordDate)-DAY(w2.recordDate)=1 and w1.temperature > w2.temperature\\n)`"
                    },
                    {
                        "username": "Gajanan_todeti",
                        "content": "solved using windows functions  \\nselect id\\nfrom \\n(select*,\\nlag(temperature)over(order by recordDate) as prev_temp\\nfrom Weather ) as tbl\\nwhere temperature > prev_temp"
                    },
                    {
                        "username": "akacool0744",
                        "content": "Most fastest way : \\n`Select w2.id from Weather w1, Weather w2  where w1.temperature < w2.temperature and w2.recordDate = DATEADD(day, 1, w1.recordDate);`"
                    },
                    {
                        "username": "akacool0744",
                        "content": "Fastest way :- MS SQL Server\\n\\n `Select w2.id from Weather w1, Weather w2  where w1.temperature < w2.temperature and w2.recordDate = DATEADD(day, 1, w1.recordDate);`"
                    },
                    {
                        "username": "adi031999",
                        "content": "what should be approach for problem if data given is not for consecutive dates."
                    },
                    {
                        "username": "Ra1242",
                        "content": "My code is:\\nselect a.id\\nfrom weather a,weather b\\nWhere datediff(day, b.recordDate, a.recordDate) = 1 and a.temperature > b.temperature"
                    },
                    {
                        "username": "ankush20386",
                        "content": "only 1 test case is left to pass what is wrong with this query?\\n\\n\\nwith \\ncte as(select id,recordDate,temperature,LAG(temperature,1)over(order by recordDate) as temp,LAG(recordDate,1)over(order by recordDate) as recordb  from weather)\\nselect id from cte where temperature>temp and (recordDate-recordb=1);\\n"
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS \n(SELECT id, LAG(recordDate) OVER (ORDER BY recordDate) AS YestDate, recordDate, \nLAG(temperature) OVER (ORDER BY recordDate) AS YestTemp, temperature\nFROM Weather)\n\nSELECT id \nFROM CTE \nWHERE temperature > YestTemp\nAND DATEDIFF(day, YestDate, recordDate) = 1"
                    }
                ]
            },
            {
                "id": 1986790,
                "content": [
                    {
                        "username": "rejent",
                        "content": " `SELECT w2.Id FROM Weather w1, Weather w2 WHERE w2.Temperature > w1.Temperature`\\n`AND\\nDATEDIFF(day,w1.recordDate,w2.recordDate)=1`"
                    },
                    {
                        "username": "mohdriduan13",
                        "content": "WITH cte AS (\\nSELECT *, LAG(temperature) OVER (ORDER BY id) AS prev_temp\\nFROM Weather)\\nSELECT id\\nFROM cte\\nWHERE temperature - prev_temp  > 0\\n"
                    },
                    {
                        "username": "pranshunayak566",
                        "content": "why this does not work?\\n\\n `# Write your MySQL query statement below\\nselect w1.id \\nfrom Weather as w1\\nwhere exists (\\n    select w2.id \\n    from Weather as w2\\n    where YEAR(w1.recordDate)=YEAR(w2.recordDate) and MONTH(w1.recordDate)=MONTH(w2.recordDate) and DAY(w1.recordDate)-DAY(w2.recordDate)=1 and w1.temperature > w2.temperature\\n)`"
                    },
                    {
                        "username": "Gajanan_todeti",
                        "content": "solved using windows functions  \\nselect id\\nfrom \\n(select*,\\nlag(temperature)over(order by recordDate) as prev_temp\\nfrom Weather ) as tbl\\nwhere temperature > prev_temp"
                    },
                    {
                        "username": "akacool0744",
                        "content": "Most fastest way : \\n`Select w2.id from Weather w1, Weather w2  where w1.temperature < w2.temperature and w2.recordDate = DATEADD(day, 1, w1.recordDate);`"
                    },
                    {
                        "username": "akacool0744",
                        "content": "Fastest way :- MS SQL Server\\n\\n `Select w2.id from Weather w1, Weather w2  where w1.temperature < w2.temperature and w2.recordDate = DATEADD(day, 1, w1.recordDate);`"
                    },
                    {
                        "username": "adi031999",
                        "content": "what should be approach for problem if data given is not for consecutive dates."
                    },
                    {
                        "username": "Ra1242",
                        "content": "My code is:\\nselect a.id\\nfrom weather a,weather b\\nWhere datediff(day, b.recordDate, a.recordDate) = 1 and a.temperature > b.temperature"
                    },
                    {
                        "username": "ankush20386",
                        "content": "only 1 test case is left to pass what is wrong with this query?\\n\\n\\nwith \\ncte as(select id,recordDate,temperature,LAG(temperature,1)over(order by recordDate) as temp,LAG(recordDate,1)over(order by recordDate) as recordb  from weather)\\nselect id from cte where temperature>temp and (recordDate-recordb=1);\\n"
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS \n(SELECT id, LAG(recordDate) OVER (ORDER BY recordDate) AS YestDate, recordDate, \nLAG(temperature) OVER (ORDER BY recordDate) AS YestTemp, temperature\nFROM Weather)\n\nSELECT id \nFROM CTE \nWHERE temperature > YestTemp\nAND DATEDIFF(day, YestDate, recordDate) = 1"
                    }
                ]
            },
            {
                "id": 1984228,
                "content": [
                    {
                        "username": "rejent",
                        "content": " `SELECT w2.Id FROM Weather w1, Weather w2 WHERE w2.Temperature > w1.Temperature`\\n`AND\\nDATEDIFF(day,w1.recordDate,w2.recordDate)=1`"
                    },
                    {
                        "username": "mohdriduan13",
                        "content": "WITH cte AS (\\nSELECT *, LAG(temperature) OVER (ORDER BY id) AS prev_temp\\nFROM Weather)\\nSELECT id\\nFROM cte\\nWHERE temperature - prev_temp  > 0\\n"
                    },
                    {
                        "username": "pranshunayak566",
                        "content": "why this does not work?\\n\\n `# Write your MySQL query statement below\\nselect w1.id \\nfrom Weather as w1\\nwhere exists (\\n    select w2.id \\n    from Weather as w2\\n    where YEAR(w1.recordDate)=YEAR(w2.recordDate) and MONTH(w1.recordDate)=MONTH(w2.recordDate) and DAY(w1.recordDate)-DAY(w2.recordDate)=1 and w1.temperature > w2.temperature\\n)`"
                    },
                    {
                        "username": "Gajanan_todeti",
                        "content": "solved using windows functions  \\nselect id\\nfrom \\n(select*,\\nlag(temperature)over(order by recordDate) as prev_temp\\nfrom Weather ) as tbl\\nwhere temperature > prev_temp"
                    },
                    {
                        "username": "akacool0744",
                        "content": "Most fastest way : \\n`Select w2.id from Weather w1, Weather w2  where w1.temperature < w2.temperature and w2.recordDate = DATEADD(day, 1, w1.recordDate);`"
                    },
                    {
                        "username": "akacool0744",
                        "content": "Fastest way :- MS SQL Server\\n\\n `Select w2.id from Weather w1, Weather w2  where w1.temperature < w2.temperature and w2.recordDate = DATEADD(day, 1, w1.recordDate);`"
                    },
                    {
                        "username": "adi031999",
                        "content": "what should be approach for problem if data given is not for consecutive dates."
                    },
                    {
                        "username": "Ra1242",
                        "content": "My code is:\\nselect a.id\\nfrom weather a,weather b\\nWhere datediff(day, b.recordDate, a.recordDate) = 1 and a.temperature > b.temperature"
                    },
                    {
                        "username": "ankush20386",
                        "content": "only 1 test case is left to pass what is wrong with this query?\\n\\n\\nwith \\ncte as(select id,recordDate,temperature,LAG(temperature,1)over(order by recordDate) as temp,LAG(recordDate,1)over(order by recordDate) as recordb  from weather)\\nselect id from cte where temperature>temp and (recordDate-recordb=1);\\n"
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS \n(SELECT id, LAG(recordDate) OVER (ORDER BY recordDate) AS YestDate, recordDate, \nLAG(temperature) OVER (ORDER BY recordDate) AS YestTemp, temperature\nFROM Weather)\n\nSELECT id \nFROM CTE \nWHERE temperature > YestTemp\nAND DATEDIFF(day, YestDate, recordDate) = 1"
                    }
                ]
            },
            {
                "id": 1970540,
                "content": [
                    {
                        "username": "yangzx608",
                        "content": "i have struggling on self join operation, why is w1 table contains id 2 and 4 not w2 table?\\nand actually how is the theory of separate one table to two table w1 and w2?"
                    },
                    {
                        "username": "gkpani97",
                        "content": "Why does this doesnt work?\\n```\\nSELECT w1.id AS Id\\nFROM Weather w1 \\nLEFT JOIN Weather w2\\nON w1.recordDate = w2.recordDate + 1\\nWHERE w1.temperature > w2.temperature;\\n```\\n\\nAnd this does?\\n```\\nSELECT w1.id AS Id\\nFROM Weather w1 \\nLEFT JOIN Weather w2\\nON DATEDIFF (w1.recordDate, w2.recordDate) = 1\\nWHERE w1.temperature > w2.temperature ;\\n```"
                    },
                    {
                        "username": "suru1113",
                        "content": "is it possible with self join? i feel yes..\\nselect w1.id from Weather w1 inner join Weather w2 on w1.id=w2.id+1 where w1.temperature >w2.temperature\\nbut half of the test cases failed\\n"
                    },
                    {
                        "username": "shivajipoudel16",
                        "content": "Try this: \\n\\nselect a.id from weather a,\\nweather b\\nwhere datediff(a.recordDate,b.recordDate)=1\\nand a.temperature>b.temperature;"
                    },
                    {
                        "username": "manuatleet12195",
                        "content": "Can someone explain the expected  result here.\n\n `Weather =\n| id | recordDate | temperature |\n| -- | ---------- | ----------- |\n| 1  | 2000-12-14 | 3           |\n| 2  | 2000-12-16 | 5           |`\n \n\nWhy expected result is :\n\n\n`| Id |\n | -- |`\n\n\nShouldn't it be \n`| id |\n | -- |\n | 2  |`\n"
                    },
                    {
                        "username": "Zivko",
                        "content": "The issue is with dates, they are not consecutive, since you do not have temperature data for 2000-12-15."
                    },
                    {
                        "username": "edatheolo",
                        "content": "with cte as(\\n  select id, (temperature - lag(temperature,1) OVER()) AS temp_diff\\n  from Weather\\n)\\nselect id\\nfrom cte\\nwhere temp_diff >0;\\n\\nwhy is this returning empty output? but if I change select id to select *, the output is actually containing correct rows."
                    },
                    {
                        "username": "ahjimomo",
                        "content": "When you perform `SELECT *`, is the `temp_diff` correct? \n\nI am applying very similar technique as you but I am extracting both date and temperature, it works:\n```\nWITH ytd AS\n    (SELECT *,\n    LAG(temperature) OVER (ORDER BY recordDate) AS ytdTemp,\n    LAG(recordDate) OVER (ORDER BY recordDate) AS ytdDate\n    FROM Weather)\nSELECT id AS Id\nFROM ytd \n    WHERE temperature > ytdTemp\n    AND DATEDIFF(recordDate, ytdDate) = 1 \n```"
                    },
                    {
                        "username": "George125",
                        "content": "Where is problem?\\n\\n`SELECT id AS Id \\nFROM [Weather] AS W\\nWHERE W.temperature > (SELECT MAX(temperature)\\n                      FROM [Weather] AS SUBW\\n                      WHERE W.recordDate > SUBW.recordDate)`"
                    },
                    {
                        "username": "shubhamshiwarkar",
                        "content": "SELECT w2.id\nFROM Weather w1, Weather w2\nWHERE w2.recordDate - 1 = w1.recordDate \nAND w2.temperature > w1.temperature;"
                    },
                    {
                        "username": "IzumiProgrammer",
                        "content": "select id from\\n(\\nselect id  ,temperature,\\nlag(temperature) over(order by recordDate )as \\'prev\\'  from weather\\n) seq\\nwhere seq.temperature>seq.prev"
                    },
                    {
                        "username": "V1NAY8",
                        "content": "Solution with MS SQL Server -> Answer got submitted\\nWITH data_filter as (\\n  SELECT id, recordDate, temperature as temp, LAG(temperature) OVER (ORDER BY recordDate) as prev_temp, LAG(recordDate) OVER (ORDER BY recordDate) as prev_date from Weather\\n)\\n\\nselect id from data_filter  where temp > prev_temp and DATEDIFF(day, prev_date, recordDate) = 1"
                    }
                ]
            },
            {
                "id": 1959894,
                "content": [
                    {
                        "username": "yangzx608",
                        "content": "i have struggling on self join operation, why is w1 table contains id 2 and 4 not w2 table?\\nand actually how is the theory of separate one table to two table w1 and w2?"
                    },
                    {
                        "username": "gkpani97",
                        "content": "Why does this doesnt work?\\n```\\nSELECT w1.id AS Id\\nFROM Weather w1 \\nLEFT JOIN Weather w2\\nON w1.recordDate = w2.recordDate + 1\\nWHERE w1.temperature > w2.temperature;\\n```\\n\\nAnd this does?\\n```\\nSELECT w1.id AS Id\\nFROM Weather w1 \\nLEFT JOIN Weather w2\\nON DATEDIFF (w1.recordDate, w2.recordDate) = 1\\nWHERE w1.temperature > w2.temperature ;\\n```"
                    },
                    {
                        "username": "suru1113",
                        "content": "is it possible with self join? i feel yes..\\nselect w1.id from Weather w1 inner join Weather w2 on w1.id=w2.id+1 where w1.temperature >w2.temperature\\nbut half of the test cases failed\\n"
                    },
                    {
                        "username": "shivajipoudel16",
                        "content": "Try this: \\n\\nselect a.id from weather a,\\nweather b\\nwhere datediff(a.recordDate,b.recordDate)=1\\nand a.temperature>b.temperature;"
                    },
                    {
                        "username": "manuatleet12195",
                        "content": "Can someone explain the expected  result here.\n\n `Weather =\n| id | recordDate | temperature |\n| -- | ---------- | ----------- |\n| 1  | 2000-12-14 | 3           |\n| 2  | 2000-12-16 | 5           |`\n \n\nWhy expected result is :\n\n\n`| Id |\n | -- |`\n\n\nShouldn't it be \n`| id |\n | -- |\n | 2  |`\n"
                    },
                    {
                        "username": "Zivko",
                        "content": "The issue is with dates, they are not consecutive, since you do not have temperature data for 2000-12-15."
                    },
                    {
                        "username": "edatheolo",
                        "content": "with cte as(\\n  select id, (temperature - lag(temperature,1) OVER()) AS temp_diff\\n  from Weather\\n)\\nselect id\\nfrom cte\\nwhere temp_diff >0;\\n\\nwhy is this returning empty output? but if I change select id to select *, the output is actually containing correct rows."
                    },
                    {
                        "username": "ahjimomo",
                        "content": "When you perform `SELECT *`, is the `temp_diff` correct? \n\nI am applying very similar technique as you but I am extracting both date and temperature, it works:\n```\nWITH ytd AS\n    (SELECT *,\n    LAG(temperature) OVER (ORDER BY recordDate) AS ytdTemp,\n    LAG(recordDate) OVER (ORDER BY recordDate) AS ytdDate\n    FROM Weather)\nSELECT id AS Id\nFROM ytd \n    WHERE temperature > ytdTemp\n    AND DATEDIFF(recordDate, ytdDate) = 1 \n```"
                    },
                    {
                        "username": "George125",
                        "content": "Where is problem?\\n\\n`SELECT id AS Id \\nFROM [Weather] AS W\\nWHERE W.temperature > (SELECT MAX(temperature)\\n                      FROM [Weather] AS SUBW\\n                      WHERE W.recordDate > SUBW.recordDate)`"
                    },
                    {
                        "username": "shubhamshiwarkar",
                        "content": "SELECT w2.id\nFROM Weather w1, Weather w2\nWHERE w2.recordDate - 1 = w1.recordDate \nAND w2.temperature > w1.temperature;"
                    },
                    {
                        "username": "IzumiProgrammer",
                        "content": "select id from\\n(\\nselect id  ,temperature,\\nlag(temperature) over(order by recordDate )as \\'prev\\'  from weather\\n) seq\\nwhere seq.temperature>seq.prev"
                    },
                    {
                        "username": "V1NAY8",
                        "content": "Solution with MS SQL Server -> Answer got submitted\\nWITH data_filter as (\\n  SELECT id, recordDate, temperature as temp, LAG(temperature) OVER (ORDER BY recordDate) as prev_temp, LAG(recordDate) OVER (ORDER BY recordDate) as prev_date from Weather\\n)\\n\\nselect id from data_filter  where temp > prev_temp and DATEDIFF(day, prev_date, recordDate) = 1"
                    }
                ]
            },
            {
                "id": 1957370,
                "content": [
                    {
                        "username": "yangzx608",
                        "content": "i have struggling on self join operation, why is w1 table contains id 2 and 4 not w2 table?\\nand actually how is the theory of separate one table to two table w1 and w2?"
                    },
                    {
                        "username": "gkpani97",
                        "content": "Why does this doesnt work?\\n```\\nSELECT w1.id AS Id\\nFROM Weather w1 \\nLEFT JOIN Weather w2\\nON w1.recordDate = w2.recordDate + 1\\nWHERE w1.temperature > w2.temperature;\\n```\\n\\nAnd this does?\\n```\\nSELECT w1.id AS Id\\nFROM Weather w1 \\nLEFT JOIN Weather w2\\nON DATEDIFF (w1.recordDate, w2.recordDate) = 1\\nWHERE w1.temperature > w2.temperature ;\\n```"
                    },
                    {
                        "username": "suru1113",
                        "content": "is it possible with self join? i feel yes..\\nselect w1.id from Weather w1 inner join Weather w2 on w1.id=w2.id+1 where w1.temperature >w2.temperature\\nbut half of the test cases failed\\n"
                    },
                    {
                        "username": "shivajipoudel16",
                        "content": "Try this: \\n\\nselect a.id from weather a,\\nweather b\\nwhere datediff(a.recordDate,b.recordDate)=1\\nand a.temperature>b.temperature;"
                    },
                    {
                        "username": "manuatleet12195",
                        "content": "Can someone explain the expected  result here.\n\n `Weather =\n| id | recordDate | temperature |\n| -- | ---------- | ----------- |\n| 1  | 2000-12-14 | 3           |\n| 2  | 2000-12-16 | 5           |`\n \n\nWhy expected result is :\n\n\n`| Id |\n | -- |`\n\n\nShouldn't it be \n`| id |\n | -- |\n | 2  |`\n"
                    },
                    {
                        "username": "Zivko",
                        "content": "The issue is with dates, they are not consecutive, since you do not have temperature data for 2000-12-15."
                    },
                    {
                        "username": "edatheolo",
                        "content": "with cte as(\\n  select id, (temperature - lag(temperature,1) OVER()) AS temp_diff\\n  from Weather\\n)\\nselect id\\nfrom cte\\nwhere temp_diff >0;\\n\\nwhy is this returning empty output? but if I change select id to select *, the output is actually containing correct rows."
                    },
                    {
                        "username": "ahjimomo",
                        "content": "When you perform `SELECT *`, is the `temp_diff` correct? \n\nI am applying very similar technique as you but I am extracting both date and temperature, it works:\n```\nWITH ytd AS\n    (SELECT *,\n    LAG(temperature) OVER (ORDER BY recordDate) AS ytdTemp,\n    LAG(recordDate) OVER (ORDER BY recordDate) AS ytdDate\n    FROM Weather)\nSELECT id AS Id\nFROM ytd \n    WHERE temperature > ytdTemp\n    AND DATEDIFF(recordDate, ytdDate) = 1 \n```"
                    },
                    {
                        "username": "George125",
                        "content": "Where is problem?\\n\\n`SELECT id AS Id \\nFROM [Weather] AS W\\nWHERE W.temperature > (SELECT MAX(temperature)\\n                      FROM [Weather] AS SUBW\\n                      WHERE W.recordDate > SUBW.recordDate)`"
                    },
                    {
                        "username": "shubhamshiwarkar",
                        "content": "SELECT w2.id\nFROM Weather w1, Weather w2\nWHERE w2.recordDate - 1 = w1.recordDate \nAND w2.temperature > w1.temperature;"
                    },
                    {
                        "username": "IzumiProgrammer",
                        "content": "select id from\\n(\\nselect id  ,temperature,\\nlag(temperature) over(order by recordDate )as \\'prev\\'  from weather\\n) seq\\nwhere seq.temperature>seq.prev"
                    },
                    {
                        "username": "V1NAY8",
                        "content": "Solution with MS SQL Server -> Answer got submitted\\nWITH data_filter as (\\n  SELECT id, recordDate, temperature as temp, LAG(temperature) OVER (ORDER BY recordDate) as prev_temp, LAG(recordDate) OVER (ORDER BY recordDate) as prev_date from Weather\\n)\\n\\nselect id from data_filter  where temp > prev_temp and DATEDIFF(day, prev_date, recordDate) = 1"
                    }
                ]
            },
            {
                "id": 1950745,
                "content": [
                    {
                        "username": "yangzx608",
                        "content": "i have struggling on self join operation, why is w1 table contains id 2 and 4 not w2 table?\\nand actually how is the theory of separate one table to two table w1 and w2?"
                    },
                    {
                        "username": "gkpani97",
                        "content": "Why does this doesnt work?\\n```\\nSELECT w1.id AS Id\\nFROM Weather w1 \\nLEFT JOIN Weather w2\\nON w1.recordDate = w2.recordDate + 1\\nWHERE w1.temperature > w2.temperature;\\n```\\n\\nAnd this does?\\n```\\nSELECT w1.id AS Id\\nFROM Weather w1 \\nLEFT JOIN Weather w2\\nON DATEDIFF (w1.recordDate, w2.recordDate) = 1\\nWHERE w1.temperature > w2.temperature ;\\n```"
                    },
                    {
                        "username": "suru1113",
                        "content": "is it possible with self join? i feel yes..\\nselect w1.id from Weather w1 inner join Weather w2 on w1.id=w2.id+1 where w1.temperature >w2.temperature\\nbut half of the test cases failed\\n"
                    },
                    {
                        "username": "shivajipoudel16",
                        "content": "Try this: \\n\\nselect a.id from weather a,\\nweather b\\nwhere datediff(a.recordDate,b.recordDate)=1\\nand a.temperature>b.temperature;"
                    },
                    {
                        "username": "manuatleet12195",
                        "content": "Can someone explain the expected  result here.\n\n `Weather =\n| id | recordDate | temperature |\n| -- | ---------- | ----------- |\n| 1  | 2000-12-14 | 3           |\n| 2  | 2000-12-16 | 5           |`\n \n\nWhy expected result is :\n\n\n`| Id |\n | -- |`\n\n\nShouldn't it be \n`| id |\n | -- |\n | 2  |`\n"
                    },
                    {
                        "username": "Zivko",
                        "content": "The issue is with dates, they are not consecutive, since you do not have temperature data for 2000-12-15."
                    },
                    {
                        "username": "edatheolo",
                        "content": "with cte as(\\n  select id, (temperature - lag(temperature,1) OVER()) AS temp_diff\\n  from Weather\\n)\\nselect id\\nfrom cte\\nwhere temp_diff >0;\\n\\nwhy is this returning empty output? but if I change select id to select *, the output is actually containing correct rows."
                    },
                    {
                        "username": "ahjimomo",
                        "content": "When you perform `SELECT *`, is the `temp_diff` correct? \n\nI am applying very similar technique as you but I am extracting both date and temperature, it works:\n```\nWITH ytd AS\n    (SELECT *,\n    LAG(temperature) OVER (ORDER BY recordDate) AS ytdTemp,\n    LAG(recordDate) OVER (ORDER BY recordDate) AS ytdDate\n    FROM Weather)\nSELECT id AS Id\nFROM ytd \n    WHERE temperature > ytdTemp\n    AND DATEDIFF(recordDate, ytdDate) = 1 \n```"
                    },
                    {
                        "username": "George125",
                        "content": "Where is problem?\\n\\n`SELECT id AS Id \\nFROM [Weather] AS W\\nWHERE W.temperature > (SELECT MAX(temperature)\\n                      FROM [Weather] AS SUBW\\n                      WHERE W.recordDate > SUBW.recordDate)`"
                    },
                    {
                        "username": "shubhamshiwarkar",
                        "content": "SELECT w2.id\nFROM Weather w1, Weather w2\nWHERE w2.recordDate - 1 = w1.recordDate \nAND w2.temperature > w1.temperature;"
                    },
                    {
                        "username": "IzumiProgrammer",
                        "content": "select id from\\n(\\nselect id  ,temperature,\\nlag(temperature) over(order by recordDate )as \\'prev\\'  from weather\\n) seq\\nwhere seq.temperature>seq.prev"
                    },
                    {
                        "username": "V1NAY8",
                        "content": "Solution with MS SQL Server -> Answer got submitted\\nWITH data_filter as (\\n  SELECT id, recordDate, temperature as temp, LAG(temperature) OVER (ORDER BY recordDate) as prev_temp, LAG(recordDate) OVER (ORDER BY recordDate) as prev_date from Weather\\n)\\n\\nselect id from data_filter  where temp > prev_temp and DATEDIFF(day, prev_date, recordDate) = 1"
                    }
                ]
            },
            {
                "id": 1934655,
                "content": [
                    {
                        "username": "yangzx608",
                        "content": "i have struggling on self join operation, why is w1 table contains id 2 and 4 not w2 table?\\nand actually how is the theory of separate one table to two table w1 and w2?"
                    },
                    {
                        "username": "gkpani97",
                        "content": "Why does this doesnt work?\\n```\\nSELECT w1.id AS Id\\nFROM Weather w1 \\nLEFT JOIN Weather w2\\nON w1.recordDate = w2.recordDate + 1\\nWHERE w1.temperature > w2.temperature;\\n```\\n\\nAnd this does?\\n```\\nSELECT w1.id AS Id\\nFROM Weather w1 \\nLEFT JOIN Weather w2\\nON DATEDIFF (w1.recordDate, w2.recordDate) = 1\\nWHERE w1.temperature > w2.temperature ;\\n```"
                    },
                    {
                        "username": "suru1113",
                        "content": "is it possible with self join? i feel yes..\\nselect w1.id from Weather w1 inner join Weather w2 on w1.id=w2.id+1 where w1.temperature >w2.temperature\\nbut half of the test cases failed\\n"
                    },
                    {
                        "username": "shivajipoudel16",
                        "content": "Try this: \\n\\nselect a.id from weather a,\\nweather b\\nwhere datediff(a.recordDate,b.recordDate)=1\\nand a.temperature>b.temperature;"
                    },
                    {
                        "username": "manuatleet12195",
                        "content": "Can someone explain the expected  result here.\n\n `Weather =\n| id | recordDate | temperature |\n| -- | ---------- | ----------- |\n| 1  | 2000-12-14 | 3           |\n| 2  | 2000-12-16 | 5           |`\n \n\nWhy expected result is :\n\n\n`| Id |\n | -- |`\n\n\nShouldn't it be \n`| id |\n | -- |\n | 2  |`\n"
                    },
                    {
                        "username": "Zivko",
                        "content": "The issue is with dates, they are not consecutive, since you do not have temperature data for 2000-12-15."
                    },
                    {
                        "username": "edatheolo",
                        "content": "with cte as(\\n  select id, (temperature - lag(temperature,1) OVER()) AS temp_diff\\n  from Weather\\n)\\nselect id\\nfrom cte\\nwhere temp_diff >0;\\n\\nwhy is this returning empty output? but if I change select id to select *, the output is actually containing correct rows."
                    },
                    {
                        "username": "ahjimomo",
                        "content": "When you perform `SELECT *`, is the `temp_diff` correct? \n\nI am applying very similar technique as you but I am extracting both date and temperature, it works:\n```\nWITH ytd AS\n    (SELECT *,\n    LAG(temperature) OVER (ORDER BY recordDate) AS ytdTemp,\n    LAG(recordDate) OVER (ORDER BY recordDate) AS ytdDate\n    FROM Weather)\nSELECT id AS Id\nFROM ytd \n    WHERE temperature > ytdTemp\n    AND DATEDIFF(recordDate, ytdDate) = 1 \n```"
                    },
                    {
                        "username": "George125",
                        "content": "Where is problem?\\n\\n`SELECT id AS Id \\nFROM [Weather] AS W\\nWHERE W.temperature > (SELECT MAX(temperature)\\n                      FROM [Weather] AS SUBW\\n                      WHERE W.recordDate > SUBW.recordDate)`"
                    },
                    {
                        "username": "shubhamshiwarkar",
                        "content": "SELECT w2.id\nFROM Weather w1, Weather w2\nWHERE w2.recordDate - 1 = w1.recordDate \nAND w2.temperature > w1.temperature;"
                    },
                    {
                        "username": "IzumiProgrammer",
                        "content": "select id from\\n(\\nselect id  ,temperature,\\nlag(temperature) over(order by recordDate )as \\'prev\\'  from weather\\n) seq\\nwhere seq.temperature>seq.prev"
                    },
                    {
                        "username": "V1NAY8",
                        "content": "Solution with MS SQL Server -> Answer got submitted\\nWITH data_filter as (\\n  SELECT id, recordDate, temperature as temp, LAG(temperature) OVER (ORDER BY recordDate) as prev_temp, LAG(recordDate) OVER (ORDER BY recordDate) as prev_date from Weather\\n)\\n\\nselect id from data_filter  where temp > prev_temp and DATEDIFF(day, prev_date, recordDate) = 1"
                    }
                ]
            },
            {
                "id": 1925995,
                "content": [
                    {
                        "username": "yangzx608",
                        "content": "i have struggling on self join operation, why is w1 table contains id 2 and 4 not w2 table?\\nand actually how is the theory of separate one table to two table w1 and w2?"
                    },
                    {
                        "username": "gkpani97",
                        "content": "Why does this doesnt work?\\n```\\nSELECT w1.id AS Id\\nFROM Weather w1 \\nLEFT JOIN Weather w2\\nON w1.recordDate = w2.recordDate + 1\\nWHERE w1.temperature > w2.temperature;\\n```\\n\\nAnd this does?\\n```\\nSELECT w1.id AS Id\\nFROM Weather w1 \\nLEFT JOIN Weather w2\\nON DATEDIFF (w1.recordDate, w2.recordDate) = 1\\nWHERE w1.temperature > w2.temperature ;\\n```"
                    },
                    {
                        "username": "suru1113",
                        "content": "is it possible with self join? i feel yes..\\nselect w1.id from Weather w1 inner join Weather w2 on w1.id=w2.id+1 where w1.temperature >w2.temperature\\nbut half of the test cases failed\\n"
                    },
                    {
                        "username": "shivajipoudel16",
                        "content": "Try this: \\n\\nselect a.id from weather a,\\nweather b\\nwhere datediff(a.recordDate,b.recordDate)=1\\nand a.temperature>b.temperature;"
                    },
                    {
                        "username": "manuatleet12195",
                        "content": "Can someone explain the expected  result here.\n\n `Weather =\n| id | recordDate | temperature |\n| -- | ---------- | ----------- |\n| 1  | 2000-12-14 | 3           |\n| 2  | 2000-12-16 | 5           |`\n \n\nWhy expected result is :\n\n\n`| Id |\n | -- |`\n\n\nShouldn't it be \n`| id |\n | -- |\n | 2  |`\n"
                    },
                    {
                        "username": "Zivko",
                        "content": "The issue is with dates, they are not consecutive, since you do not have temperature data for 2000-12-15."
                    },
                    {
                        "username": "edatheolo",
                        "content": "with cte as(\\n  select id, (temperature - lag(temperature,1) OVER()) AS temp_diff\\n  from Weather\\n)\\nselect id\\nfrom cte\\nwhere temp_diff >0;\\n\\nwhy is this returning empty output? but if I change select id to select *, the output is actually containing correct rows."
                    },
                    {
                        "username": "ahjimomo",
                        "content": "When you perform `SELECT *`, is the `temp_diff` correct? \n\nI am applying very similar technique as you but I am extracting both date and temperature, it works:\n```\nWITH ytd AS\n    (SELECT *,\n    LAG(temperature) OVER (ORDER BY recordDate) AS ytdTemp,\n    LAG(recordDate) OVER (ORDER BY recordDate) AS ytdDate\n    FROM Weather)\nSELECT id AS Id\nFROM ytd \n    WHERE temperature > ytdTemp\n    AND DATEDIFF(recordDate, ytdDate) = 1 \n```"
                    },
                    {
                        "username": "George125",
                        "content": "Where is problem?\\n\\n`SELECT id AS Id \\nFROM [Weather] AS W\\nWHERE W.temperature > (SELECT MAX(temperature)\\n                      FROM [Weather] AS SUBW\\n                      WHERE W.recordDate > SUBW.recordDate)`"
                    },
                    {
                        "username": "shubhamshiwarkar",
                        "content": "SELECT w2.id\nFROM Weather w1, Weather w2\nWHERE w2.recordDate - 1 = w1.recordDate \nAND w2.temperature > w1.temperature;"
                    },
                    {
                        "username": "IzumiProgrammer",
                        "content": "select id from\\n(\\nselect id  ,temperature,\\nlag(temperature) over(order by recordDate )as \\'prev\\'  from weather\\n) seq\\nwhere seq.temperature>seq.prev"
                    },
                    {
                        "username": "V1NAY8",
                        "content": "Solution with MS SQL Server -> Answer got submitted\\nWITH data_filter as (\\n  SELECT id, recordDate, temperature as temp, LAG(temperature) OVER (ORDER BY recordDate) as prev_temp, LAG(recordDate) OVER (ORDER BY recordDate) as prev_date from Weather\\n)\\n\\nselect id from data_filter  where temp > prev_temp and DATEDIFF(day, prev_date, recordDate) = 1"
                    }
                ]
            },
            {
                "id": 1906305,
                "content": [
                    {
                        "username": "yangzx608",
                        "content": "i have struggling on self join operation, why is w1 table contains id 2 and 4 not w2 table?\\nand actually how is the theory of separate one table to two table w1 and w2?"
                    },
                    {
                        "username": "gkpani97",
                        "content": "Why does this doesnt work?\\n```\\nSELECT w1.id AS Id\\nFROM Weather w1 \\nLEFT JOIN Weather w2\\nON w1.recordDate = w2.recordDate + 1\\nWHERE w1.temperature > w2.temperature;\\n```\\n\\nAnd this does?\\n```\\nSELECT w1.id AS Id\\nFROM Weather w1 \\nLEFT JOIN Weather w2\\nON DATEDIFF (w1.recordDate, w2.recordDate) = 1\\nWHERE w1.temperature > w2.temperature ;\\n```"
                    },
                    {
                        "username": "suru1113",
                        "content": "is it possible with self join? i feel yes..\\nselect w1.id from Weather w1 inner join Weather w2 on w1.id=w2.id+1 where w1.temperature >w2.temperature\\nbut half of the test cases failed\\n"
                    },
                    {
                        "username": "shivajipoudel16",
                        "content": "Try this: \\n\\nselect a.id from weather a,\\nweather b\\nwhere datediff(a.recordDate,b.recordDate)=1\\nand a.temperature>b.temperature;"
                    },
                    {
                        "username": "manuatleet12195",
                        "content": "Can someone explain the expected  result here.\n\n `Weather =\n| id | recordDate | temperature |\n| -- | ---------- | ----------- |\n| 1  | 2000-12-14 | 3           |\n| 2  | 2000-12-16 | 5           |`\n \n\nWhy expected result is :\n\n\n`| Id |\n | -- |`\n\n\nShouldn't it be \n`| id |\n | -- |\n | 2  |`\n"
                    },
                    {
                        "username": "Zivko",
                        "content": "The issue is with dates, they are not consecutive, since you do not have temperature data for 2000-12-15."
                    },
                    {
                        "username": "edatheolo",
                        "content": "with cte as(\\n  select id, (temperature - lag(temperature,1) OVER()) AS temp_diff\\n  from Weather\\n)\\nselect id\\nfrom cte\\nwhere temp_diff >0;\\n\\nwhy is this returning empty output? but if I change select id to select *, the output is actually containing correct rows."
                    },
                    {
                        "username": "ahjimomo",
                        "content": "When you perform `SELECT *`, is the `temp_diff` correct? \n\nI am applying very similar technique as you but I am extracting both date and temperature, it works:\n```\nWITH ytd AS\n    (SELECT *,\n    LAG(temperature) OVER (ORDER BY recordDate) AS ytdTemp,\n    LAG(recordDate) OVER (ORDER BY recordDate) AS ytdDate\n    FROM Weather)\nSELECT id AS Id\nFROM ytd \n    WHERE temperature > ytdTemp\n    AND DATEDIFF(recordDate, ytdDate) = 1 \n```"
                    },
                    {
                        "username": "George125",
                        "content": "Where is problem?\\n\\n`SELECT id AS Id \\nFROM [Weather] AS W\\nWHERE W.temperature > (SELECT MAX(temperature)\\n                      FROM [Weather] AS SUBW\\n                      WHERE W.recordDate > SUBW.recordDate)`"
                    },
                    {
                        "username": "shubhamshiwarkar",
                        "content": "SELECT w2.id\nFROM Weather w1, Weather w2\nWHERE w2.recordDate - 1 = w1.recordDate \nAND w2.temperature > w1.temperature;"
                    },
                    {
                        "username": "IzumiProgrammer",
                        "content": "select id from\\n(\\nselect id  ,temperature,\\nlag(temperature) over(order by recordDate )as \\'prev\\'  from weather\\n) seq\\nwhere seq.temperature>seq.prev"
                    },
                    {
                        "username": "V1NAY8",
                        "content": "Solution with MS SQL Server -> Answer got submitted\\nWITH data_filter as (\\n  SELECT id, recordDate, temperature as temp, LAG(temperature) OVER (ORDER BY recordDate) as prev_temp, LAG(recordDate) OVER (ORDER BY recordDate) as prev_date from Weather\\n)\\n\\nselect id from data_filter  where temp > prev_temp and DATEDIFF(day, prev_date, recordDate) = 1"
                    }
                ]
            },
            {
                "id": 1904387,
                "content": [
                    {
                        "username": "yangzx608",
                        "content": "i have struggling on self join operation, why is w1 table contains id 2 and 4 not w2 table?\\nand actually how is the theory of separate one table to two table w1 and w2?"
                    },
                    {
                        "username": "gkpani97",
                        "content": "Why does this doesnt work?\\n```\\nSELECT w1.id AS Id\\nFROM Weather w1 \\nLEFT JOIN Weather w2\\nON w1.recordDate = w2.recordDate + 1\\nWHERE w1.temperature > w2.temperature;\\n```\\n\\nAnd this does?\\n```\\nSELECT w1.id AS Id\\nFROM Weather w1 \\nLEFT JOIN Weather w2\\nON DATEDIFF (w1.recordDate, w2.recordDate) = 1\\nWHERE w1.temperature > w2.temperature ;\\n```"
                    },
                    {
                        "username": "suru1113",
                        "content": "is it possible with self join? i feel yes..\\nselect w1.id from Weather w1 inner join Weather w2 on w1.id=w2.id+1 where w1.temperature >w2.temperature\\nbut half of the test cases failed\\n"
                    },
                    {
                        "username": "shivajipoudel16",
                        "content": "Try this: \\n\\nselect a.id from weather a,\\nweather b\\nwhere datediff(a.recordDate,b.recordDate)=1\\nand a.temperature>b.temperature;"
                    },
                    {
                        "username": "manuatleet12195",
                        "content": "Can someone explain the expected  result here.\n\n `Weather =\n| id | recordDate | temperature |\n| -- | ---------- | ----------- |\n| 1  | 2000-12-14 | 3           |\n| 2  | 2000-12-16 | 5           |`\n \n\nWhy expected result is :\n\n\n`| Id |\n | -- |`\n\n\nShouldn't it be \n`| id |\n | -- |\n | 2  |`\n"
                    },
                    {
                        "username": "Zivko",
                        "content": "The issue is with dates, they are not consecutive, since you do not have temperature data for 2000-12-15."
                    },
                    {
                        "username": "edatheolo",
                        "content": "with cte as(\\n  select id, (temperature - lag(temperature,1) OVER()) AS temp_diff\\n  from Weather\\n)\\nselect id\\nfrom cte\\nwhere temp_diff >0;\\n\\nwhy is this returning empty output? but if I change select id to select *, the output is actually containing correct rows."
                    },
                    {
                        "username": "ahjimomo",
                        "content": "When you perform `SELECT *`, is the `temp_diff` correct? \n\nI am applying very similar technique as you but I am extracting both date and temperature, it works:\n```\nWITH ytd AS\n    (SELECT *,\n    LAG(temperature) OVER (ORDER BY recordDate) AS ytdTemp,\n    LAG(recordDate) OVER (ORDER BY recordDate) AS ytdDate\n    FROM Weather)\nSELECT id AS Id\nFROM ytd \n    WHERE temperature > ytdTemp\n    AND DATEDIFF(recordDate, ytdDate) = 1 \n```"
                    },
                    {
                        "username": "George125",
                        "content": "Where is problem?\\n\\n`SELECT id AS Id \\nFROM [Weather] AS W\\nWHERE W.temperature > (SELECT MAX(temperature)\\n                      FROM [Weather] AS SUBW\\n                      WHERE W.recordDate > SUBW.recordDate)`"
                    },
                    {
                        "username": "shubhamshiwarkar",
                        "content": "SELECT w2.id\nFROM Weather w1, Weather w2\nWHERE w2.recordDate - 1 = w1.recordDate \nAND w2.temperature > w1.temperature;"
                    },
                    {
                        "username": "IzumiProgrammer",
                        "content": "select id from\\n(\\nselect id  ,temperature,\\nlag(temperature) over(order by recordDate )as \\'prev\\'  from weather\\n) seq\\nwhere seq.temperature>seq.prev"
                    },
                    {
                        "username": "V1NAY8",
                        "content": "Solution with MS SQL Server -> Answer got submitted\\nWITH data_filter as (\\n  SELECT id, recordDate, temperature as temp, LAG(temperature) OVER (ORDER BY recordDate) as prev_temp, LAG(recordDate) OVER (ORDER BY recordDate) as prev_date from Weather\\n)\\n\\nselect id from data_filter  where temp > prev_temp and DATEDIFF(day, prev_date, recordDate) = 1"
                    }
                ]
            },
            {
                "id": 1899985,
                "content": [
                    {
                        "username": "yangzx608",
                        "content": "i have struggling on self join operation, why is w1 table contains id 2 and 4 not w2 table?\\nand actually how is the theory of separate one table to two table w1 and w2?"
                    },
                    {
                        "username": "gkpani97",
                        "content": "Why does this doesnt work?\\n```\\nSELECT w1.id AS Id\\nFROM Weather w1 \\nLEFT JOIN Weather w2\\nON w1.recordDate = w2.recordDate + 1\\nWHERE w1.temperature > w2.temperature;\\n```\\n\\nAnd this does?\\n```\\nSELECT w1.id AS Id\\nFROM Weather w1 \\nLEFT JOIN Weather w2\\nON DATEDIFF (w1.recordDate, w2.recordDate) = 1\\nWHERE w1.temperature > w2.temperature ;\\n```"
                    },
                    {
                        "username": "suru1113",
                        "content": "is it possible with self join? i feel yes..\\nselect w1.id from Weather w1 inner join Weather w2 on w1.id=w2.id+1 where w1.temperature >w2.temperature\\nbut half of the test cases failed\\n"
                    },
                    {
                        "username": "shivajipoudel16",
                        "content": "Try this: \\n\\nselect a.id from weather a,\\nweather b\\nwhere datediff(a.recordDate,b.recordDate)=1\\nand a.temperature>b.temperature;"
                    },
                    {
                        "username": "manuatleet12195",
                        "content": "Can someone explain the expected  result here.\n\n `Weather =\n| id | recordDate | temperature |\n| -- | ---------- | ----------- |\n| 1  | 2000-12-14 | 3           |\n| 2  | 2000-12-16 | 5           |`\n \n\nWhy expected result is :\n\n\n`| Id |\n | -- |`\n\n\nShouldn't it be \n`| id |\n | -- |\n | 2  |`\n"
                    },
                    {
                        "username": "Zivko",
                        "content": "The issue is with dates, they are not consecutive, since you do not have temperature data for 2000-12-15."
                    },
                    {
                        "username": "edatheolo",
                        "content": "with cte as(\\n  select id, (temperature - lag(temperature,1) OVER()) AS temp_diff\\n  from Weather\\n)\\nselect id\\nfrom cte\\nwhere temp_diff >0;\\n\\nwhy is this returning empty output? but if I change select id to select *, the output is actually containing correct rows."
                    },
                    {
                        "username": "ahjimomo",
                        "content": "When you perform `SELECT *`, is the `temp_diff` correct? \n\nI am applying very similar technique as you but I am extracting both date and temperature, it works:\n```\nWITH ytd AS\n    (SELECT *,\n    LAG(temperature) OVER (ORDER BY recordDate) AS ytdTemp,\n    LAG(recordDate) OVER (ORDER BY recordDate) AS ytdDate\n    FROM Weather)\nSELECT id AS Id\nFROM ytd \n    WHERE temperature > ytdTemp\n    AND DATEDIFF(recordDate, ytdDate) = 1 \n```"
                    },
                    {
                        "username": "George125",
                        "content": "Where is problem?\\n\\n`SELECT id AS Id \\nFROM [Weather] AS W\\nWHERE W.temperature > (SELECT MAX(temperature)\\n                      FROM [Weather] AS SUBW\\n                      WHERE W.recordDate > SUBW.recordDate)`"
                    },
                    {
                        "username": "shubhamshiwarkar",
                        "content": "SELECT w2.id\nFROM Weather w1, Weather w2\nWHERE w2.recordDate - 1 = w1.recordDate \nAND w2.temperature > w1.temperature;"
                    },
                    {
                        "username": "IzumiProgrammer",
                        "content": "select id from\\n(\\nselect id  ,temperature,\\nlag(temperature) over(order by recordDate )as \\'prev\\'  from weather\\n) seq\\nwhere seq.temperature>seq.prev"
                    },
                    {
                        "username": "V1NAY8",
                        "content": "Solution with MS SQL Server -> Answer got submitted\\nWITH data_filter as (\\n  SELECT id, recordDate, temperature as temp, LAG(temperature) OVER (ORDER BY recordDate) as prev_temp, LAG(recordDate) OVER (ORDER BY recordDate) as prev_date from Weather\\n)\\n\\nselect id from data_filter  where temp > prev_temp and DATEDIFF(day, prev_date, recordDate) = 1"
                    }
                ]
            },
            {
                "id": 1899150,
                "content": [
                    {
                        "username": "yangzx608",
                        "content": "i have struggling on self join operation, why is w1 table contains id 2 and 4 not w2 table?\\nand actually how is the theory of separate one table to two table w1 and w2?"
                    },
                    {
                        "username": "gkpani97",
                        "content": "Why does this doesnt work?\\n```\\nSELECT w1.id AS Id\\nFROM Weather w1 \\nLEFT JOIN Weather w2\\nON w1.recordDate = w2.recordDate + 1\\nWHERE w1.temperature > w2.temperature;\\n```\\n\\nAnd this does?\\n```\\nSELECT w1.id AS Id\\nFROM Weather w1 \\nLEFT JOIN Weather w2\\nON DATEDIFF (w1.recordDate, w2.recordDate) = 1\\nWHERE w1.temperature > w2.temperature ;\\n```"
                    },
                    {
                        "username": "suru1113",
                        "content": "is it possible with self join? i feel yes..\\nselect w1.id from Weather w1 inner join Weather w2 on w1.id=w2.id+1 where w1.temperature >w2.temperature\\nbut half of the test cases failed\\n"
                    },
                    {
                        "username": "shivajipoudel16",
                        "content": "Try this: \\n\\nselect a.id from weather a,\\nweather b\\nwhere datediff(a.recordDate,b.recordDate)=1\\nand a.temperature>b.temperature;"
                    },
                    {
                        "username": "manuatleet12195",
                        "content": "Can someone explain the expected  result here.\n\n `Weather =\n| id | recordDate | temperature |\n| -- | ---------- | ----------- |\n| 1  | 2000-12-14 | 3           |\n| 2  | 2000-12-16 | 5           |`\n \n\nWhy expected result is :\n\n\n`| Id |\n | -- |`\n\n\nShouldn't it be \n`| id |\n | -- |\n | 2  |`\n"
                    },
                    {
                        "username": "Zivko",
                        "content": "The issue is with dates, they are not consecutive, since you do not have temperature data for 2000-12-15."
                    },
                    {
                        "username": "edatheolo",
                        "content": "with cte as(\\n  select id, (temperature - lag(temperature,1) OVER()) AS temp_diff\\n  from Weather\\n)\\nselect id\\nfrom cte\\nwhere temp_diff >0;\\n\\nwhy is this returning empty output? but if I change select id to select *, the output is actually containing correct rows."
                    },
                    {
                        "username": "ahjimomo",
                        "content": "When you perform `SELECT *`, is the `temp_diff` correct? \n\nI am applying very similar technique as you but I am extracting both date and temperature, it works:\n```\nWITH ytd AS\n    (SELECT *,\n    LAG(temperature) OVER (ORDER BY recordDate) AS ytdTemp,\n    LAG(recordDate) OVER (ORDER BY recordDate) AS ytdDate\n    FROM Weather)\nSELECT id AS Id\nFROM ytd \n    WHERE temperature > ytdTemp\n    AND DATEDIFF(recordDate, ytdDate) = 1 \n```"
                    },
                    {
                        "username": "George125",
                        "content": "Where is problem?\\n\\n`SELECT id AS Id \\nFROM [Weather] AS W\\nWHERE W.temperature > (SELECT MAX(temperature)\\n                      FROM [Weather] AS SUBW\\n                      WHERE W.recordDate > SUBW.recordDate)`"
                    },
                    {
                        "username": "shubhamshiwarkar",
                        "content": "SELECT w2.id\nFROM Weather w1, Weather w2\nWHERE w2.recordDate - 1 = w1.recordDate \nAND w2.temperature > w1.temperature;"
                    },
                    {
                        "username": "IzumiProgrammer",
                        "content": "select id from\\n(\\nselect id  ,temperature,\\nlag(temperature) over(order by recordDate )as \\'prev\\'  from weather\\n) seq\\nwhere seq.temperature>seq.prev"
                    },
                    {
                        "username": "V1NAY8",
                        "content": "Solution with MS SQL Server -> Answer got submitted\\nWITH data_filter as (\\n  SELECT id, recordDate, temperature as temp, LAG(temperature) OVER (ORDER BY recordDate) as prev_temp, LAG(recordDate) OVER (ORDER BY recordDate) as prev_date from Weather\\n)\\n\\nselect id from data_filter  where temp > prev_temp and DATEDIFF(day, prev_date, recordDate) = 1"
                    }
                ]
            },
            {
                "id": 1885698,
                "content": [
                    {
                        "username": "Tmakinde",
                        "content": "This works:\\n\\nselect id from \\n(\\nselect id, DATEDIFF(recordDate, lag(recordDate) over(order by recordDate)) as datedifference, temperature, lag(temperature) over(order by recordDate) as previousTemp, lag(recordDate) over(order by recordDate) as previousDate from Weather\\n) w\\nwhere temperature > previousTemp and datedifference = 1;"
                    },
                    {
                        "username": "user5079r",
                        "content": "SELECT t1.id\\nFROM Weather t1\\nINNER JOIN Weather t2\\nON t1.recordDate = DATE_ADD(t2.recordDate, INTERVAL 1 DAY)\\nWHERE t1.temperature > t2.temperature;\\n"
                    },
                    {
                        "username": "epetrarca5479",
                        "content": "My answer is accepted but I don\\'t get good feelings from it.\\nSELECT w2.id AS Id\\nFROM Weather w1 inner join Weather w2 on DATEADD(day, 1, w1.recordDate) = w2.recordDate\\nWHERE w2.temperature > w1.temperature"
                    },
                    {
                        "username": "hari_aravi",
                        "content": "why is the code below not running the 13th case?\\n\\n `select w.id from weather w left join weather ww on (w.recordDate=ww.recordDate+1) \\nwhere ww.temperature < w.temperature`"
                    },
                    {
                        "username": "shivakant012",
                        "content": "Would it be a possible approach to get the top 2 Id\\'s by ordering the temperature to descending ? As the table is going to hold the temperature for every single day."
                    },
                    {
                        "username": "prathams29",
                        "content": "Only the given example has temperature for every day. I\\'m sure that other test cases do not follow the same thing. \\nAlso, if we were to follow your suggestion, it may still give wrong answer. Suppose temperature is 47 on 1st, 48 on 2nd, 50 on 3rd and 49 on 4th. \\nYour suggestion would give 3rd and 4th as answers. However, correct answers would be 2nd and 3rd."
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select t2.id as Id from Weather t1,Weather t2\\n  WHERE dateDiff(t2.recordDate,t1.recordDate)=1 and t1.temperature<t2.temperature"
                    },
                    {
                        "username": "MaheshBabuMummalaneni",
                        "content": "I have attempted 6 queries so far and have faced 2 issues.\\n1. window functions row_number(), rank(), dense_rank() aren\\'t working \\n2. When i ran the code it shows as Accepted and showing expected output but when clicked on Submit it says Wrong Answer.\\n\\nBut the kind of challenges we could see here are really good."
                    },
                    {
                        "username": "har0101",
                        "content": "can anyone tell me why sometimes we use join in same table and some times , didn\\'t get the difference "
                    },
                    {
                        "username": "prathams29",
                        "content": "When we want to compare values of the column from the same table, we use self-join (join same table) \\nHere, we need to compare the dates as well as the temperature.\\n\\nHope this solves your doubt, Do upvote if it did ! "
                    },
                    {
                        "username": "Puneet72",
                        "content": "with cte as (select id,recordDate,temperature,lag(temperature) over (order by recordDate asc) as rnk from Weather)\\n\\nselect id,temperature,rnk from cte where temperature > rnk"
                    },
                    {
                        "username": "Avazbeka_dev",
                        "content": "SELECT a.id\\nFROM Weather as a,Weather as b\\nWHERE a.temperature>b.temperature\\nAND DATEDIFF(a,b)=1\\n\\nUnknown column \\'a\\' in \\'where clause\\'\\n\\nWhy my code doesn\\'t work ?"
                    },
                    {
                        "username": "prathams29",
                        "content": "In DATEDIFF(), you just wrote a and b, and did not specify which column of a and b. You need to write a.RecordDate and b.RecordDate \\nHope this solves your doubt. Do upvote if it did !"
                    }
                ]
            },
            {
                "id": 1874451,
                "content": [
                    {
                        "username": "Tmakinde",
                        "content": "This works:\\n\\nselect id from \\n(\\nselect id, DATEDIFF(recordDate, lag(recordDate) over(order by recordDate)) as datedifference, temperature, lag(temperature) over(order by recordDate) as previousTemp, lag(recordDate) over(order by recordDate) as previousDate from Weather\\n) w\\nwhere temperature > previousTemp and datedifference = 1;"
                    },
                    {
                        "username": "user5079r",
                        "content": "SELECT t1.id\\nFROM Weather t1\\nINNER JOIN Weather t2\\nON t1.recordDate = DATE_ADD(t2.recordDate, INTERVAL 1 DAY)\\nWHERE t1.temperature > t2.temperature;\\n"
                    },
                    {
                        "username": "epetrarca5479",
                        "content": "My answer is accepted but I don\\'t get good feelings from it.\\nSELECT w2.id AS Id\\nFROM Weather w1 inner join Weather w2 on DATEADD(day, 1, w1.recordDate) = w2.recordDate\\nWHERE w2.temperature > w1.temperature"
                    },
                    {
                        "username": "hari_aravi",
                        "content": "why is the code below not running the 13th case?\\n\\n `select w.id from weather w left join weather ww on (w.recordDate=ww.recordDate+1) \\nwhere ww.temperature < w.temperature`"
                    },
                    {
                        "username": "shivakant012",
                        "content": "Would it be a possible approach to get the top 2 Id\\'s by ordering the temperature to descending ? As the table is going to hold the temperature for every single day."
                    },
                    {
                        "username": "prathams29",
                        "content": "Only the given example has temperature for every day. I\\'m sure that other test cases do not follow the same thing. \\nAlso, if we were to follow your suggestion, it may still give wrong answer. Suppose temperature is 47 on 1st, 48 on 2nd, 50 on 3rd and 49 on 4th. \\nYour suggestion would give 3rd and 4th as answers. However, correct answers would be 2nd and 3rd."
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select t2.id as Id from Weather t1,Weather t2\\n  WHERE dateDiff(t2.recordDate,t1.recordDate)=1 and t1.temperature<t2.temperature"
                    },
                    {
                        "username": "MaheshBabuMummalaneni",
                        "content": "I have attempted 6 queries so far and have faced 2 issues.\\n1. window functions row_number(), rank(), dense_rank() aren\\'t working \\n2. When i ran the code it shows as Accepted and showing expected output but when clicked on Submit it says Wrong Answer.\\n\\nBut the kind of challenges we could see here are really good."
                    },
                    {
                        "username": "har0101",
                        "content": "can anyone tell me why sometimes we use join in same table and some times , didn\\'t get the difference "
                    },
                    {
                        "username": "prathams29",
                        "content": "When we want to compare values of the column from the same table, we use self-join (join same table) \\nHere, we need to compare the dates as well as the temperature.\\n\\nHope this solves your doubt, Do upvote if it did ! "
                    },
                    {
                        "username": "Puneet72",
                        "content": "with cte as (select id,recordDate,temperature,lag(temperature) over (order by recordDate asc) as rnk from Weather)\\n\\nselect id,temperature,rnk from cte where temperature > rnk"
                    },
                    {
                        "username": "Avazbeka_dev",
                        "content": "SELECT a.id\\nFROM Weather as a,Weather as b\\nWHERE a.temperature>b.temperature\\nAND DATEDIFF(a,b)=1\\n\\nUnknown column \\'a\\' in \\'where clause\\'\\n\\nWhy my code doesn\\'t work ?"
                    },
                    {
                        "username": "prathams29",
                        "content": "In DATEDIFF(), you just wrote a and b, and did not specify which column of a and b. You need to write a.RecordDate and b.RecordDate \\nHope this solves your doubt. Do upvote if it did !"
                    }
                ]
            },
            {
                "id": 1873968,
                "content": [
                    {
                        "username": "Tmakinde",
                        "content": "This works:\\n\\nselect id from \\n(\\nselect id, DATEDIFF(recordDate, lag(recordDate) over(order by recordDate)) as datedifference, temperature, lag(temperature) over(order by recordDate) as previousTemp, lag(recordDate) over(order by recordDate) as previousDate from Weather\\n) w\\nwhere temperature > previousTemp and datedifference = 1;"
                    },
                    {
                        "username": "user5079r",
                        "content": "SELECT t1.id\\nFROM Weather t1\\nINNER JOIN Weather t2\\nON t1.recordDate = DATE_ADD(t2.recordDate, INTERVAL 1 DAY)\\nWHERE t1.temperature > t2.temperature;\\n"
                    },
                    {
                        "username": "epetrarca5479",
                        "content": "My answer is accepted but I don\\'t get good feelings from it.\\nSELECT w2.id AS Id\\nFROM Weather w1 inner join Weather w2 on DATEADD(day, 1, w1.recordDate) = w2.recordDate\\nWHERE w2.temperature > w1.temperature"
                    },
                    {
                        "username": "hari_aravi",
                        "content": "why is the code below not running the 13th case?\\n\\n `select w.id from weather w left join weather ww on (w.recordDate=ww.recordDate+1) \\nwhere ww.temperature < w.temperature`"
                    },
                    {
                        "username": "shivakant012",
                        "content": "Would it be a possible approach to get the top 2 Id\\'s by ordering the temperature to descending ? As the table is going to hold the temperature for every single day."
                    },
                    {
                        "username": "prathams29",
                        "content": "Only the given example has temperature for every day. I\\'m sure that other test cases do not follow the same thing. \\nAlso, if we were to follow your suggestion, it may still give wrong answer. Suppose temperature is 47 on 1st, 48 on 2nd, 50 on 3rd and 49 on 4th. \\nYour suggestion would give 3rd and 4th as answers. However, correct answers would be 2nd and 3rd."
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select t2.id as Id from Weather t1,Weather t2\\n  WHERE dateDiff(t2.recordDate,t1.recordDate)=1 and t1.temperature<t2.temperature"
                    },
                    {
                        "username": "MaheshBabuMummalaneni",
                        "content": "I have attempted 6 queries so far and have faced 2 issues.\\n1. window functions row_number(), rank(), dense_rank() aren\\'t working \\n2. When i ran the code it shows as Accepted and showing expected output but when clicked on Submit it says Wrong Answer.\\n\\nBut the kind of challenges we could see here are really good."
                    },
                    {
                        "username": "har0101",
                        "content": "can anyone tell me why sometimes we use join in same table and some times , didn\\'t get the difference "
                    },
                    {
                        "username": "prathams29",
                        "content": "When we want to compare values of the column from the same table, we use self-join (join same table) \\nHere, we need to compare the dates as well as the temperature.\\n\\nHope this solves your doubt, Do upvote if it did ! "
                    },
                    {
                        "username": "Puneet72",
                        "content": "with cte as (select id,recordDate,temperature,lag(temperature) over (order by recordDate asc) as rnk from Weather)\\n\\nselect id,temperature,rnk from cte where temperature > rnk"
                    },
                    {
                        "username": "Avazbeka_dev",
                        "content": "SELECT a.id\\nFROM Weather as a,Weather as b\\nWHERE a.temperature>b.temperature\\nAND DATEDIFF(a,b)=1\\n\\nUnknown column \\'a\\' in \\'where clause\\'\\n\\nWhy my code doesn\\'t work ?"
                    },
                    {
                        "username": "prathams29",
                        "content": "In DATEDIFF(), you just wrote a and b, and did not specify which column of a and b. You need to write a.RecordDate and b.RecordDate \\nHope this solves your doubt. Do upvote if it did !"
                    }
                ]
            },
            {
                "id": 1873806,
                "content": [
                    {
                        "username": "Tmakinde",
                        "content": "This works:\\n\\nselect id from \\n(\\nselect id, DATEDIFF(recordDate, lag(recordDate) over(order by recordDate)) as datedifference, temperature, lag(temperature) over(order by recordDate) as previousTemp, lag(recordDate) over(order by recordDate) as previousDate from Weather\\n) w\\nwhere temperature > previousTemp and datedifference = 1;"
                    },
                    {
                        "username": "user5079r",
                        "content": "SELECT t1.id\\nFROM Weather t1\\nINNER JOIN Weather t2\\nON t1.recordDate = DATE_ADD(t2.recordDate, INTERVAL 1 DAY)\\nWHERE t1.temperature > t2.temperature;\\n"
                    },
                    {
                        "username": "epetrarca5479",
                        "content": "My answer is accepted but I don\\'t get good feelings from it.\\nSELECT w2.id AS Id\\nFROM Weather w1 inner join Weather w2 on DATEADD(day, 1, w1.recordDate) = w2.recordDate\\nWHERE w2.temperature > w1.temperature"
                    },
                    {
                        "username": "hari_aravi",
                        "content": "why is the code below not running the 13th case?\\n\\n `select w.id from weather w left join weather ww on (w.recordDate=ww.recordDate+1) \\nwhere ww.temperature < w.temperature`"
                    },
                    {
                        "username": "shivakant012",
                        "content": "Would it be a possible approach to get the top 2 Id\\'s by ordering the temperature to descending ? As the table is going to hold the temperature for every single day."
                    },
                    {
                        "username": "prathams29",
                        "content": "Only the given example has temperature for every day. I\\'m sure that other test cases do not follow the same thing. \\nAlso, if we were to follow your suggestion, it may still give wrong answer. Suppose temperature is 47 on 1st, 48 on 2nd, 50 on 3rd and 49 on 4th. \\nYour suggestion would give 3rd and 4th as answers. However, correct answers would be 2nd and 3rd."
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select t2.id as Id from Weather t1,Weather t2\\n  WHERE dateDiff(t2.recordDate,t1.recordDate)=1 and t1.temperature<t2.temperature"
                    },
                    {
                        "username": "MaheshBabuMummalaneni",
                        "content": "I have attempted 6 queries so far and have faced 2 issues.\\n1. window functions row_number(), rank(), dense_rank() aren\\'t working \\n2. When i ran the code it shows as Accepted and showing expected output but when clicked on Submit it says Wrong Answer.\\n\\nBut the kind of challenges we could see here are really good."
                    },
                    {
                        "username": "har0101",
                        "content": "can anyone tell me why sometimes we use join in same table and some times , didn\\'t get the difference "
                    },
                    {
                        "username": "prathams29",
                        "content": "When we want to compare values of the column from the same table, we use self-join (join same table) \\nHere, we need to compare the dates as well as the temperature.\\n\\nHope this solves your doubt, Do upvote if it did ! "
                    },
                    {
                        "username": "Puneet72",
                        "content": "with cte as (select id,recordDate,temperature,lag(temperature) over (order by recordDate asc) as rnk from Weather)\\n\\nselect id,temperature,rnk from cte where temperature > rnk"
                    },
                    {
                        "username": "Avazbeka_dev",
                        "content": "SELECT a.id\\nFROM Weather as a,Weather as b\\nWHERE a.temperature>b.temperature\\nAND DATEDIFF(a,b)=1\\n\\nUnknown column \\'a\\' in \\'where clause\\'\\n\\nWhy my code doesn\\'t work ?"
                    },
                    {
                        "username": "prathams29",
                        "content": "In DATEDIFF(), you just wrote a and b, and did not specify which column of a and b. You need to write a.RecordDate and b.RecordDate \\nHope this solves your doubt. Do upvote if it did !"
                    }
                ]
            },
            {
                "id": 1872507,
                "content": [
                    {
                        "username": "Tmakinde",
                        "content": "This works:\\n\\nselect id from \\n(\\nselect id, DATEDIFF(recordDate, lag(recordDate) over(order by recordDate)) as datedifference, temperature, lag(temperature) over(order by recordDate) as previousTemp, lag(recordDate) over(order by recordDate) as previousDate from Weather\\n) w\\nwhere temperature > previousTemp and datedifference = 1;"
                    },
                    {
                        "username": "user5079r",
                        "content": "SELECT t1.id\\nFROM Weather t1\\nINNER JOIN Weather t2\\nON t1.recordDate = DATE_ADD(t2.recordDate, INTERVAL 1 DAY)\\nWHERE t1.temperature > t2.temperature;\\n"
                    },
                    {
                        "username": "epetrarca5479",
                        "content": "My answer is accepted but I don\\'t get good feelings from it.\\nSELECT w2.id AS Id\\nFROM Weather w1 inner join Weather w2 on DATEADD(day, 1, w1.recordDate) = w2.recordDate\\nWHERE w2.temperature > w1.temperature"
                    },
                    {
                        "username": "hari_aravi",
                        "content": "why is the code below not running the 13th case?\\n\\n `select w.id from weather w left join weather ww on (w.recordDate=ww.recordDate+1) \\nwhere ww.temperature < w.temperature`"
                    },
                    {
                        "username": "shivakant012",
                        "content": "Would it be a possible approach to get the top 2 Id\\'s by ordering the temperature to descending ? As the table is going to hold the temperature for every single day."
                    },
                    {
                        "username": "prathams29",
                        "content": "Only the given example has temperature for every day. I\\'m sure that other test cases do not follow the same thing. \\nAlso, if we were to follow your suggestion, it may still give wrong answer. Suppose temperature is 47 on 1st, 48 on 2nd, 50 on 3rd and 49 on 4th. \\nYour suggestion would give 3rd and 4th as answers. However, correct answers would be 2nd and 3rd."
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select t2.id as Id from Weather t1,Weather t2\\n  WHERE dateDiff(t2.recordDate,t1.recordDate)=1 and t1.temperature<t2.temperature"
                    },
                    {
                        "username": "MaheshBabuMummalaneni",
                        "content": "I have attempted 6 queries so far and have faced 2 issues.\\n1. window functions row_number(), rank(), dense_rank() aren\\'t working \\n2. When i ran the code it shows as Accepted and showing expected output but when clicked on Submit it says Wrong Answer.\\n\\nBut the kind of challenges we could see here are really good."
                    },
                    {
                        "username": "har0101",
                        "content": "can anyone tell me why sometimes we use join in same table and some times , didn\\'t get the difference "
                    },
                    {
                        "username": "prathams29",
                        "content": "When we want to compare values of the column from the same table, we use self-join (join same table) \\nHere, we need to compare the dates as well as the temperature.\\n\\nHope this solves your doubt, Do upvote if it did ! "
                    },
                    {
                        "username": "Puneet72",
                        "content": "with cte as (select id,recordDate,temperature,lag(temperature) over (order by recordDate asc) as rnk from Weather)\\n\\nselect id,temperature,rnk from cte where temperature > rnk"
                    },
                    {
                        "username": "Avazbeka_dev",
                        "content": "SELECT a.id\\nFROM Weather as a,Weather as b\\nWHERE a.temperature>b.temperature\\nAND DATEDIFF(a,b)=1\\n\\nUnknown column \\'a\\' in \\'where clause\\'\\n\\nWhy my code doesn\\'t work ?"
                    },
                    {
                        "username": "prathams29",
                        "content": "In DATEDIFF(), you just wrote a and b, and did not specify which column of a and b. You need to write a.RecordDate and b.RecordDate \\nHope this solves your doubt. Do upvote if it did !"
                    }
                ]
            },
            {
                "id": 1864428,
                "content": [
                    {
                        "username": "Tmakinde",
                        "content": "This works:\\n\\nselect id from \\n(\\nselect id, DATEDIFF(recordDate, lag(recordDate) over(order by recordDate)) as datedifference, temperature, lag(temperature) over(order by recordDate) as previousTemp, lag(recordDate) over(order by recordDate) as previousDate from Weather\\n) w\\nwhere temperature > previousTemp and datedifference = 1;"
                    },
                    {
                        "username": "user5079r",
                        "content": "SELECT t1.id\\nFROM Weather t1\\nINNER JOIN Weather t2\\nON t1.recordDate = DATE_ADD(t2.recordDate, INTERVAL 1 DAY)\\nWHERE t1.temperature > t2.temperature;\\n"
                    },
                    {
                        "username": "epetrarca5479",
                        "content": "My answer is accepted but I don\\'t get good feelings from it.\\nSELECT w2.id AS Id\\nFROM Weather w1 inner join Weather w2 on DATEADD(day, 1, w1.recordDate) = w2.recordDate\\nWHERE w2.temperature > w1.temperature"
                    },
                    {
                        "username": "hari_aravi",
                        "content": "why is the code below not running the 13th case?\\n\\n `select w.id from weather w left join weather ww on (w.recordDate=ww.recordDate+1) \\nwhere ww.temperature < w.temperature`"
                    },
                    {
                        "username": "shivakant012",
                        "content": "Would it be a possible approach to get the top 2 Id\\'s by ordering the temperature to descending ? As the table is going to hold the temperature for every single day."
                    },
                    {
                        "username": "prathams29",
                        "content": "Only the given example has temperature for every day. I\\'m sure that other test cases do not follow the same thing. \\nAlso, if we were to follow your suggestion, it may still give wrong answer. Suppose temperature is 47 on 1st, 48 on 2nd, 50 on 3rd and 49 on 4th. \\nYour suggestion would give 3rd and 4th as answers. However, correct answers would be 2nd and 3rd."
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select t2.id as Id from Weather t1,Weather t2\\n  WHERE dateDiff(t2.recordDate,t1.recordDate)=1 and t1.temperature<t2.temperature"
                    },
                    {
                        "username": "MaheshBabuMummalaneni",
                        "content": "I have attempted 6 queries so far and have faced 2 issues.\\n1. window functions row_number(), rank(), dense_rank() aren\\'t working \\n2. When i ran the code it shows as Accepted and showing expected output but when clicked on Submit it says Wrong Answer.\\n\\nBut the kind of challenges we could see here are really good."
                    },
                    {
                        "username": "har0101",
                        "content": "can anyone tell me why sometimes we use join in same table and some times , didn\\'t get the difference "
                    },
                    {
                        "username": "prathams29",
                        "content": "When we want to compare values of the column from the same table, we use self-join (join same table) \\nHere, we need to compare the dates as well as the temperature.\\n\\nHope this solves your doubt, Do upvote if it did ! "
                    },
                    {
                        "username": "Puneet72",
                        "content": "with cte as (select id,recordDate,temperature,lag(temperature) over (order by recordDate asc) as rnk from Weather)\\n\\nselect id,temperature,rnk from cte where temperature > rnk"
                    },
                    {
                        "username": "Avazbeka_dev",
                        "content": "SELECT a.id\\nFROM Weather as a,Weather as b\\nWHERE a.temperature>b.temperature\\nAND DATEDIFF(a,b)=1\\n\\nUnknown column \\'a\\' in \\'where clause\\'\\n\\nWhy my code doesn\\'t work ?"
                    },
                    {
                        "username": "prathams29",
                        "content": "In DATEDIFF(), you just wrote a and b, and did not specify which column of a and b. You need to write a.RecordDate and b.RecordDate \\nHope this solves your doubt. Do upvote if it did !"
                    }
                ]
            },
            {
                "id": 1863766,
                "content": [
                    {
                        "username": "Tmakinde",
                        "content": "This works:\\n\\nselect id from \\n(\\nselect id, DATEDIFF(recordDate, lag(recordDate) over(order by recordDate)) as datedifference, temperature, lag(temperature) over(order by recordDate) as previousTemp, lag(recordDate) over(order by recordDate) as previousDate from Weather\\n) w\\nwhere temperature > previousTemp and datedifference = 1;"
                    },
                    {
                        "username": "user5079r",
                        "content": "SELECT t1.id\\nFROM Weather t1\\nINNER JOIN Weather t2\\nON t1.recordDate = DATE_ADD(t2.recordDate, INTERVAL 1 DAY)\\nWHERE t1.temperature > t2.temperature;\\n"
                    },
                    {
                        "username": "epetrarca5479",
                        "content": "My answer is accepted but I don\\'t get good feelings from it.\\nSELECT w2.id AS Id\\nFROM Weather w1 inner join Weather w2 on DATEADD(day, 1, w1.recordDate) = w2.recordDate\\nWHERE w2.temperature > w1.temperature"
                    },
                    {
                        "username": "hari_aravi",
                        "content": "why is the code below not running the 13th case?\\n\\n `select w.id from weather w left join weather ww on (w.recordDate=ww.recordDate+1) \\nwhere ww.temperature < w.temperature`"
                    },
                    {
                        "username": "shivakant012",
                        "content": "Would it be a possible approach to get the top 2 Id\\'s by ordering the temperature to descending ? As the table is going to hold the temperature for every single day."
                    },
                    {
                        "username": "prathams29",
                        "content": "Only the given example has temperature for every day. I\\'m sure that other test cases do not follow the same thing. \\nAlso, if we were to follow your suggestion, it may still give wrong answer. Suppose temperature is 47 on 1st, 48 on 2nd, 50 on 3rd and 49 on 4th. \\nYour suggestion would give 3rd and 4th as answers. However, correct answers would be 2nd and 3rd."
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select t2.id as Id from Weather t1,Weather t2\\n  WHERE dateDiff(t2.recordDate,t1.recordDate)=1 and t1.temperature<t2.temperature"
                    },
                    {
                        "username": "MaheshBabuMummalaneni",
                        "content": "I have attempted 6 queries so far and have faced 2 issues.\\n1. window functions row_number(), rank(), dense_rank() aren\\'t working \\n2. When i ran the code it shows as Accepted and showing expected output but when clicked on Submit it says Wrong Answer.\\n\\nBut the kind of challenges we could see here are really good."
                    },
                    {
                        "username": "har0101",
                        "content": "can anyone tell me why sometimes we use join in same table and some times , didn\\'t get the difference "
                    },
                    {
                        "username": "prathams29",
                        "content": "When we want to compare values of the column from the same table, we use self-join (join same table) \\nHere, we need to compare the dates as well as the temperature.\\n\\nHope this solves your doubt, Do upvote if it did ! "
                    },
                    {
                        "username": "Puneet72",
                        "content": "with cte as (select id,recordDate,temperature,lag(temperature) over (order by recordDate asc) as rnk from Weather)\\n\\nselect id,temperature,rnk from cte where temperature > rnk"
                    },
                    {
                        "username": "Avazbeka_dev",
                        "content": "SELECT a.id\\nFROM Weather as a,Weather as b\\nWHERE a.temperature>b.temperature\\nAND DATEDIFF(a,b)=1\\n\\nUnknown column \\'a\\' in \\'where clause\\'\\n\\nWhy my code doesn\\'t work ?"
                    },
                    {
                        "username": "prathams29",
                        "content": "In DATEDIFF(), you just wrote a and b, and did not specify which column of a and b. You need to write a.RecordDate and b.RecordDate \\nHope this solves your doubt. Do upvote if it did !"
                    }
                ]
            },
            {
                "id": 1854818,
                "content": [
                    {
                        "username": "Tmakinde",
                        "content": "This works:\\n\\nselect id from \\n(\\nselect id, DATEDIFF(recordDate, lag(recordDate) over(order by recordDate)) as datedifference, temperature, lag(temperature) over(order by recordDate) as previousTemp, lag(recordDate) over(order by recordDate) as previousDate from Weather\\n) w\\nwhere temperature > previousTemp and datedifference = 1;"
                    },
                    {
                        "username": "user5079r",
                        "content": "SELECT t1.id\\nFROM Weather t1\\nINNER JOIN Weather t2\\nON t1.recordDate = DATE_ADD(t2.recordDate, INTERVAL 1 DAY)\\nWHERE t1.temperature > t2.temperature;\\n"
                    },
                    {
                        "username": "epetrarca5479",
                        "content": "My answer is accepted but I don\\'t get good feelings from it.\\nSELECT w2.id AS Id\\nFROM Weather w1 inner join Weather w2 on DATEADD(day, 1, w1.recordDate) = w2.recordDate\\nWHERE w2.temperature > w1.temperature"
                    },
                    {
                        "username": "hari_aravi",
                        "content": "why is the code below not running the 13th case?\\n\\n `select w.id from weather w left join weather ww on (w.recordDate=ww.recordDate+1) \\nwhere ww.temperature < w.temperature`"
                    },
                    {
                        "username": "shivakant012",
                        "content": "Would it be a possible approach to get the top 2 Id\\'s by ordering the temperature to descending ? As the table is going to hold the temperature for every single day."
                    },
                    {
                        "username": "prathams29",
                        "content": "Only the given example has temperature for every day. I\\'m sure that other test cases do not follow the same thing. \\nAlso, if we were to follow your suggestion, it may still give wrong answer. Suppose temperature is 47 on 1st, 48 on 2nd, 50 on 3rd and 49 on 4th. \\nYour suggestion would give 3rd and 4th as answers. However, correct answers would be 2nd and 3rd."
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select t2.id as Id from Weather t1,Weather t2\\n  WHERE dateDiff(t2.recordDate,t1.recordDate)=1 and t1.temperature<t2.temperature"
                    },
                    {
                        "username": "MaheshBabuMummalaneni",
                        "content": "I have attempted 6 queries so far and have faced 2 issues.\\n1. window functions row_number(), rank(), dense_rank() aren\\'t working \\n2. When i ran the code it shows as Accepted and showing expected output but when clicked on Submit it says Wrong Answer.\\n\\nBut the kind of challenges we could see here are really good."
                    },
                    {
                        "username": "har0101",
                        "content": "can anyone tell me why sometimes we use join in same table and some times , didn\\'t get the difference "
                    },
                    {
                        "username": "prathams29",
                        "content": "When we want to compare values of the column from the same table, we use self-join (join same table) \\nHere, we need to compare the dates as well as the temperature.\\n\\nHope this solves your doubt, Do upvote if it did ! "
                    },
                    {
                        "username": "Puneet72",
                        "content": "with cte as (select id,recordDate,temperature,lag(temperature) over (order by recordDate asc) as rnk from Weather)\\n\\nselect id,temperature,rnk from cte where temperature > rnk"
                    },
                    {
                        "username": "Avazbeka_dev",
                        "content": "SELECT a.id\\nFROM Weather as a,Weather as b\\nWHERE a.temperature>b.temperature\\nAND DATEDIFF(a,b)=1\\n\\nUnknown column \\'a\\' in \\'where clause\\'\\n\\nWhy my code doesn\\'t work ?"
                    },
                    {
                        "username": "prathams29",
                        "content": "In DATEDIFF(), you just wrote a and b, and did not specify which column of a and b. You need to write a.RecordDate and b.RecordDate \\nHope this solves your doubt. Do upvote if it did !"
                    }
                ]
            },
            {
                "id": 1845173,
                "content": [
                    {
                        "username": "Tmakinde",
                        "content": "This works:\\n\\nselect id from \\n(\\nselect id, DATEDIFF(recordDate, lag(recordDate) over(order by recordDate)) as datedifference, temperature, lag(temperature) over(order by recordDate) as previousTemp, lag(recordDate) over(order by recordDate) as previousDate from Weather\\n) w\\nwhere temperature > previousTemp and datedifference = 1;"
                    },
                    {
                        "username": "user5079r",
                        "content": "SELECT t1.id\\nFROM Weather t1\\nINNER JOIN Weather t2\\nON t1.recordDate = DATE_ADD(t2.recordDate, INTERVAL 1 DAY)\\nWHERE t1.temperature > t2.temperature;\\n"
                    },
                    {
                        "username": "epetrarca5479",
                        "content": "My answer is accepted but I don\\'t get good feelings from it.\\nSELECT w2.id AS Id\\nFROM Weather w1 inner join Weather w2 on DATEADD(day, 1, w1.recordDate) = w2.recordDate\\nWHERE w2.temperature > w1.temperature"
                    },
                    {
                        "username": "hari_aravi",
                        "content": "why is the code below not running the 13th case?\\n\\n `select w.id from weather w left join weather ww on (w.recordDate=ww.recordDate+1) \\nwhere ww.temperature < w.temperature`"
                    },
                    {
                        "username": "shivakant012",
                        "content": "Would it be a possible approach to get the top 2 Id\\'s by ordering the temperature to descending ? As the table is going to hold the temperature for every single day."
                    },
                    {
                        "username": "prathams29",
                        "content": "Only the given example has temperature for every day. I\\'m sure that other test cases do not follow the same thing. \\nAlso, if we were to follow your suggestion, it may still give wrong answer. Suppose temperature is 47 on 1st, 48 on 2nd, 50 on 3rd and 49 on 4th. \\nYour suggestion would give 3rd and 4th as answers. However, correct answers would be 2nd and 3rd."
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select t2.id as Id from Weather t1,Weather t2\\n  WHERE dateDiff(t2.recordDate,t1.recordDate)=1 and t1.temperature<t2.temperature"
                    },
                    {
                        "username": "MaheshBabuMummalaneni",
                        "content": "I have attempted 6 queries so far and have faced 2 issues.\\n1. window functions row_number(), rank(), dense_rank() aren\\'t working \\n2. When i ran the code it shows as Accepted and showing expected output but when clicked on Submit it says Wrong Answer.\\n\\nBut the kind of challenges we could see here are really good."
                    },
                    {
                        "username": "har0101",
                        "content": "can anyone tell me why sometimes we use join in same table and some times , didn\\'t get the difference "
                    },
                    {
                        "username": "prathams29",
                        "content": "When we want to compare values of the column from the same table, we use self-join (join same table) \\nHere, we need to compare the dates as well as the temperature.\\n\\nHope this solves your doubt, Do upvote if it did ! "
                    },
                    {
                        "username": "Puneet72",
                        "content": "with cte as (select id,recordDate,temperature,lag(temperature) over (order by recordDate asc) as rnk from Weather)\\n\\nselect id,temperature,rnk from cte where temperature > rnk"
                    },
                    {
                        "username": "Avazbeka_dev",
                        "content": "SELECT a.id\\nFROM Weather as a,Weather as b\\nWHERE a.temperature>b.temperature\\nAND DATEDIFF(a,b)=1\\n\\nUnknown column \\'a\\' in \\'where clause\\'\\n\\nWhy my code doesn\\'t work ?"
                    },
                    {
                        "username": "prathams29",
                        "content": "In DATEDIFF(), you just wrote a and b, and did not specify which column of a and b. You need to write a.RecordDate and b.RecordDate \\nHope this solves your doubt. Do upvote if it did !"
                    }
                ]
            },
            {
                "id": 1844197,
                "content": [
                    {
                        "username": "Tmakinde",
                        "content": "This works:\\n\\nselect id from \\n(\\nselect id, DATEDIFF(recordDate, lag(recordDate) over(order by recordDate)) as datedifference, temperature, lag(temperature) over(order by recordDate) as previousTemp, lag(recordDate) over(order by recordDate) as previousDate from Weather\\n) w\\nwhere temperature > previousTemp and datedifference = 1;"
                    },
                    {
                        "username": "user5079r",
                        "content": "SELECT t1.id\\nFROM Weather t1\\nINNER JOIN Weather t2\\nON t1.recordDate = DATE_ADD(t2.recordDate, INTERVAL 1 DAY)\\nWHERE t1.temperature > t2.temperature;\\n"
                    },
                    {
                        "username": "epetrarca5479",
                        "content": "My answer is accepted but I don\\'t get good feelings from it.\\nSELECT w2.id AS Id\\nFROM Weather w1 inner join Weather w2 on DATEADD(day, 1, w1.recordDate) = w2.recordDate\\nWHERE w2.temperature > w1.temperature"
                    },
                    {
                        "username": "hari_aravi",
                        "content": "why is the code below not running the 13th case?\\n\\n `select w.id from weather w left join weather ww on (w.recordDate=ww.recordDate+1) \\nwhere ww.temperature < w.temperature`"
                    },
                    {
                        "username": "shivakant012",
                        "content": "Would it be a possible approach to get the top 2 Id\\'s by ordering the temperature to descending ? As the table is going to hold the temperature for every single day."
                    },
                    {
                        "username": "prathams29",
                        "content": "Only the given example has temperature for every day. I\\'m sure that other test cases do not follow the same thing. \\nAlso, if we were to follow your suggestion, it may still give wrong answer. Suppose temperature is 47 on 1st, 48 on 2nd, 50 on 3rd and 49 on 4th. \\nYour suggestion would give 3rd and 4th as answers. However, correct answers would be 2nd and 3rd."
                    },
                    {
                        "username": "awnishsingh",
                        "content": "select t2.id as Id from Weather t1,Weather t2\\n  WHERE dateDiff(t2.recordDate,t1.recordDate)=1 and t1.temperature<t2.temperature"
                    },
                    {
                        "username": "MaheshBabuMummalaneni",
                        "content": "I have attempted 6 queries so far and have faced 2 issues.\\n1. window functions row_number(), rank(), dense_rank() aren\\'t working \\n2. When i ran the code it shows as Accepted and showing expected output but when clicked on Submit it says Wrong Answer.\\n\\nBut the kind of challenges we could see here are really good."
                    },
                    {
                        "username": "har0101",
                        "content": "can anyone tell me why sometimes we use join in same table and some times , didn\\'t get the difference "
                    },
                    {
                        "username": "prathams29",
                        "content": "When we want to compare values of the column from the same table, we use self-join (join same table) \\nHere, we need to compare the dates as well as the temperature.\\n\\nHope this solves your doubt, Do upvote if it did ! "
                    },
                    {
                        "username": "Puneet72",
                        "content": "with cte as (select id,recordDate,temperature,lag(temperature) over (order by recordDate asc) as rnk from Weather)\\n\\nselect id,temperature,rnk from cte where temperature > rnk"
                    },
                    {
                        "username": "Avazbeka_dev",
                        "content": "SELECT a.id\\nFROM Weather as a,Weather as b\\nWHERE a.temperature>b.temperature\\nAND DATEDIFF(a,b)=1\\n\\nUnknown column \\'a\\' in \\'where clause\\'\\n\\nWhy my code doesn\\'t work ?"
                    },
                    {
                        "username": "prathams29",
                        "content": "In DATEDIFF(), you just wrote a and b, and did not specify which column of a and b. You need to write a.RecordDate and b.RecordDate \\nHope this solves your doubt. Do upvote if it did !"
                    }
                ]
            },
            {
                "id": 1841149,
                "content": [
                    {
                        "username": "Puneet72",
                        "content": "Its not accepting ..\\n\\nwith cte as (select id,temperature,lag(temperature) over (order by recordDate) as temp2 from Weather ),\\n\\ncte2 as (select id ,temperature,temp2 from cte )\\n\\nselect id from cte2 where temperature > temp2"
                    },
                    {
                        "username": "anmoltalshi1",
                        "content": "SELECT x.id \\nFROM(\\n    SELECT id ,recordDate ,temperature, LAG(temperature) OVER(ORDER BY recordDate) as temperature_LAG\\n    FROM Weather\\n) x\\nWHERE x.temperature > x.temperature_LAG;"
                    },
                    {
                        "username": "Echo_N1",
                        "content": "The easiest SQL for this case\\n\\nSELECT w.id AS Id\\nFROM Weather w\\n     INNER JOIN Weather pd ON pd.recordDate = DATEADD(DAY, -1, w.recordDate)\\nWHERE w.temperature > pd.temperature"
                    },
                    {
                        "username": "jjjho",
                        "content": "[passed]\\nwith temp as(\\nselect id, date_add(recorddate, interval 1 day) as date, temperature from weather \\n)\\n\\nselect a.id from weather a\\nleft join temp b on a.recorddate = b.date\\nwhere a.temperature > b.temperature"
                    },
                    {
                        "username": "vinayakam19",
                        "content": "Using CTE\\n\\n `with rising_temperature as (select we.id as Id, DATEDIFF(we.recordDate, w.recordDate) as days_diff from Weather w JOIN Weather we on w.id = we.id or w.temperature < we.temperature)\\n\\n\\nselect Id from rising_temperature where days_diff = 1;`"
                    },
                    {
                        "username": "PIYUSH310501",
                        "content": "SELECT w1.id\\nFROM Weather AS w1 , Weather AS w2\\nWHERE w1.Temperature > w2.Temperature AND DATEDIFF(w1.recordDate , w2.recordDate) = 1"
                    },
                    {
                        "username": "sakuramomo1005",
                        "content": "Why I got wrong answer? I think the expected answer is incorrect for one example: \\n\\nInput\\nWeather =\\n| id | recordDate | temperature |\\n| -- | ---------- | ----------- |\\n| 1  | 2000-12-14 | 3           |\\n| 2  | 2000-12-16 | 5           |\\n\\nExpected\\n| id |\\n| -- |\\n\\nI think the expected should be id = 2 since 12-16 does have higher temperature than 12-14, is that right?\\n"
                    },
                    {
                        "username": "siddhant_samal",
                        "content": "`select w1.id from\\nWeather w1 join Weather w2\\non\\nDATE_ADD(w1.recordDate , INTERVAL -1 DAY) = w2.recordDate \\nand\\nw1.temperature > w2.temperature ;`"
                    },
                    {
                        "username": "adityachatterjee",
                        "content": "SELECT w1.id FROM Weather w1 JOIN Weather w2\nON DATEDIFF(w1.recordDate, w2.recordDate) = 1\nAND w1.temperature > w2.temperature;\n\nHow does this query work when the difference between 2 dates is greater than 1. Where as this doesn't work for the same\n\nSELECT ID FROM (SELECT W.*,Z.TEMPERATURE AS PREVTEMP\nFROM WEATHER W\nLEFT JOIN\nWEATHER Z\nON W.RECORDDATE=(Z.RECORDDATE+1))A\nWHERE TEMPERATURE>PREVTEMP\n\n"
                    },
                    {
                        "username": "ashish_singh00",
                        "content": "If the difference between two dates is greater than 1 then, how it could be called the previous day so that kind of non consecutive dates and not included"
                    },
                    {
                        "username": "ashish_singh00",
                        "content": "select id from (select * , lag(temperature,1,NULL) over(order by recordDate)\\n as prev_temp,lag(recordDate,1,NULL) over(order by recordDate) as prev_date\\nfrom Weather\\n) x\\nwhere x.prev_temp is not null and x.temperature > x.prev_temp\\nand x.prev_date is not null and datediff(x.recordDate,x.prev_date) =1;\\n\\nIs this a good way to do this"
                    }
                ]
            },
            {
                "id": 1816034,
                "content": [
                    {
                        "username": "Puneet72",
                        "content": "Its not accepting ..\\n\\nwith cte as (select id,temperature,lag(temperature) over (order by recordDate) as temp2 from Weather ),\\n\\ncte2 as (select id ,temperature,temp2 from cte )\\n\\nselect id from cte2 where temperature > temp2"
                    },
                    {
                        "username": "anmoltalshi1",
                        "content": "SELECT x.id \\nFROM(\\n    SELECT id ,recordDate ,temperature, LAG(temperature) OVER(ORDER BY recordDate) as temperature_LAG\\n    FROM Weather\\n) x\\nWHERE x.temperature > x.temperature_LAG;"
                    },
                    {
                        "username": "Echo_N1",
                        "content": "The easiest SQL for this case\\n\\nSELECT w.id AS Id\\nFROM Weather w\\n     INNER JOIN Weather pd ON pd.recordDate = DATEADD(DAY, -1, w.recordDate)\\nWHERE w.temperature > pd.temperature"
                    },
                    {
                        "username": "jjjho",
                        "content": "[passed]\\nwith temp as(\\nselect id, date_add(recorddate, interval 1 day) as date, temperature from weather \\n)\\n\\nselect a.id from weather a\\nleft join temp b on a.recorddate = b.date\\nwhere a.temperature > b.temperature"
                    },
                    {
                        "username": "vinayakam19",
                        "content": "Using CTE\\n\\n `with rising_temperature as (select we.id as Id, DATEDIFF(we.recordDate, w.recordDate) as days_diff from Weather w JOIN Weather we on w.id = we.id or w.temperature < we.temperature)\\n\\n\\nselect Id from rising_temperature where days_diff = 1;`"
                    },
                    {
                        "username": "PIYUSH310501",
                        "content": "SELECT w1.id\\nFROM Weather AS w1 , Weather AS w2\\nWHERE w1.Temperature > w2.Temperature AND DATEDIFF(w1.recordDate , w2.recordDate) = 1"
                    },
                    {
                        "username": "sakuramomo1005",
                        "content": "Why I got wrong answer? I think the expected answer is incorrect for one example: \\n\\nInput\\nWeather =\\n| id | recordDate | temperature |\\n| -- | ---------- | ----------- |\\n| 1  | 2000-12-14 | 3           |\\n| 2  | 2000-12-16 | 5           |\\n\\nExpected\\n| id |\\n| -- |\\n\\nI think the expected should be id = 2 since 12-16 does have higher temperature than 12-14, is that right?\\n"
                    },
                    {
                        "username": "siddhant_samal",
                        "content": "`select w1.id from\\nWeather w1 join Weather w2\\non\\nDATE_ADD(w1.recordDate , INTERVAL -1 DAY) = w2.recordDate \\nand\\nw1.temperature > w2.temperature ;`"
                    },
                    {
                        "username": "adityachatterjee",
                        "content": "SELECT w1.id FROM Weather w1 JOIN Weather w2\nON DATEDIFF(w1.recordDate, w2.recordDate) = 1\nAND w1.temperature > w2.temperature;\n\nHow does this query work when the difference between 2 dates is greater than 1. Where as this doesn't work for the same\n\nSELECT ID FROM (SELECT W.*,Z.TEMPERATURE AS PREVTEMP\nFROM WEATHER W\nLEFT JOIN\nWEATHER Z\nON W.RECORDDATE=(Z.RECORDDATE+1))A\nWHERE TEMPERATURE>PREVTEMP\n\n"
                    },
                    {
                        "username": "ashish_singh00",
                        "content": "If the difference between two dates is greater than 1 then, how it could be called the previous day so that kind of non consecutive dates and not included"
                    },
                    {
                        "username": "ashish_singh00",
                        "content": "select id from (select * , lag(temperature,1,NULL) over(order by recordDate)\\n as prev_temp,lag(recordDate,1,NULL) over(order by recordDate) as prev_date\\nfrom Weather\\n) x\\nwhere x.prev_temp is not null and x.temperature > x.prev_temp\\nand x.prev_date is not null and datediff(x.recordDate,x.prev_date) =1;\\n\\nIs this a good way to do this"
                    }
                ]
            },
            {
                "id": 1809650,
                "content": [
                    {
                        "username": "Puneet72",
                        "content": "Its not accepting ..\\n\\nwith cte as (select id,temperature,lag(temperature) over (order by recordDate) as temp2 from Weather ),\\n\\ncte2 as (select id ,temperature,temp2 from cte )\\n\\nselect id from cte2 where temperature > temp2"
                    },
                    {
                        "username": "anmoltalshi1",
                        "content": "SELECT x.id \\nFROM(\\n    SELECT id ,recordDate ,temperature, LAG(temperature) OVER(ORDER BY recordDate) as temperature_LAG\\n    FROM Weather\\n) x\\nWHERE x.temperature > x.temperature_LAG;"
                    },
                    {
                        "username": "Echo_N1",
                        "content": "The easiest SQL for this case\\n\\nSELECT w.id AS Id\\nFROM Weather w\\n     INNER JOIN Weather pd ON pd.recordDate = DATEADD(DAY, -1, w.recordDate)\\nWHERE w.temperature > pd.temperature"
                    },
                    {
                        "username": "jjjho",
                        "content": "[passed]\\nwith temp as(\\nselect id, date_add(recorddate, interval 1 day) as date, temperature from weather \\n)\\n\\nselect a.id from weather a\\nleft join temp b on a.recorddate = b.date\\nwhere a.temperature > b.temperature"
                    },
                    {
                        "username": "vinayakam19",
                        "content": "Using CTE\\n\\n `with rising_temperature as (select we.id as Id, DATEDIFF(we.recordDate, w.recordDate) as days_diff from Weather w JOIN Weather we on w.id = we.id or w.temperature < we.temperature)\\n\\n\\nselect Id from rising_temperature where days_diff = 1;`"
                    },
                    {
                        "username": "PIYUSH310501",
                        "content": "SELECT w1.id\\nFROM Weather AS w1 , Weather AS w2\\nWHERE w1.Temperature > w2.Temperature AND DATEDIFF(w1.recordDate , w2.recordDate) = 1"
                    },
                    {
                        "username": "sakuramomo1005",
                        "content": "Why I got wrong answer? I think the expected answer is incorrect for one example: \\n\\nInput\\nWeather =\\n| id | recordDate | temperature |\\n| -- | ---------- | ----------- |\\n| 1  | 2000-12-14 | 3           |\\n| 2  | 2000-12-16 | 5           |\\n\\nExpected\\n| id |\\n| -- |\\n\\nI think the expected should be id = 2 since 12-16 does have higher temperature than 12-14, is that right?\\n"
                    },
                    {
                        "username": "siddhant_samal",
                        "content": "`select w1.id from\\nWeather w1 join Weather w2\\non\\nDATE_ADD(w1.recordDate , INTERVAL -1 DAY) = w2.recordDate \\nand\\nw1.temperature > w2.temperature ;`"
                    },
                    {
                        "username": "adityachatterjee",
                        "content": "SELECT w1.id FROM Weather w1 JOIN Weather w2\nON DATEDIFF(w1.recordDate, w2.recordDate) = 1\nAND w1.temperature > w2.temperature;\n\nHow does this query work when the difference between 2 dates is greater than 1. Where as this doesn't work for the same\n\nSELECT ID FROM (SELECT W.*,Z.TEMPERATURE AS PREVTEMP\nFROM WEATHER W\nLEFT JOIN\nWEATHER Z\nON W.RECORDDATE=(Z.RECORDDATE+1))A\nWHERE TEMPERATURE>PREVTEMP\n\n"
                    },
                    {
                        "username": "ashish_singh00",
                        "content": "If the difference between two dates is greater than 1 then, how it could be called the previous day so that kind of non consecutive dates and not included"
                    },
                    {
                        "username": "ashish_singh00",
                        "content": "select id from (select * , lag(temperature,1,NULL) over(order by recordDate)\\n as prev_temp,lag(recordDate,1,NULL) over(order by recordDate) as prev_date\\nfrom Weather\\n) x\\nwhere x.prev_temp is not null and x.temperature > x.prev_temp\\nand x.prev_date is not null and datediff(x.recordDate,x.prev_date) =1;\\n\\nIs this a good way to do this"
                    }
                ]
            },
            {
                "id": 1805159,
                "content": [
                    {
                        "username": "Puneet72",
                        "content": "Its not accepting ..\\n\\nwith cte as (select id,temperature,lag(temperature) over (order by recordDate) as temp2 from Weather ),\\n\\ncte2 as (select id ,temperature,temp2 from cte )\\n\\nselect id from cte2 where temperature > temp2"
                    },
                    {
                        "username": "anmoltalshi1",
                        "content": "SELECT x.id \\nFROM(\\n    SELECT id ,recordDate ,temperature, LAG(temperature) OVER(ORDER BY recordDate) as temperature_LAG\\n    FROM Weather\\n) x\\nWHERE x.temperature > x.temperature_LAG;"
                    },
                    {
                        "username": "Echo_N1",
                        "content": "The easiest SQL for this case\\n\\nSELECT w.id AS Id\\nFROM Weather w\\n     INNER JOIN Weather pd ON pd.recordDate = DATEADD(DAY, -1, w.recordDate)\\nWHERE w.temperature > pd.temperature"
                    },
                    {
                        "username": "jjjho",
                        "content": "[passed]\\nwith temp as(\\nselect id, date_add(recorddate, interval 1 day) as date, temperature from weather \\n)\\n\\nselect a.id from weather a\\nleft join temp b on a.recorddate = b.date\\nwhere a.temperature > b.temperature"
                    },
                    {
                        "username": "vinayakam19",
                        "content": "Using CTE\\n\\n `with rising_temperature as (select we.id as Id, DATEDIFF(we.recordDate, w.recordDate) as days_diff from Weather w JOIN Weather we on w.id = we.id or w.temperature < we.temperature)\\n\\n\\nselect Id from rising_temperature where days_diff = 1;`"
                    },
                    {
                        "username": "PIYUSH310501",
                        "content": "SELECT w1.id\\nFROM Weather AS w1 , Weather AS w2\\nWHERE w1.Temperature > w2.Temperature AND DATEDIFF(w1.recordDate , w2.recordDate) = 1"
                    },
                    {
                        "username": "sakuramomo1005",
                        "content": "Why I got wrong answer? I think the expected answer is incorrect for one example: \\n\\nInput\\nWeather =\\n| id | recordDate | temperature |\\n| -- | ---------- | ----------- |\\n| 1  | 2000-12-14 | 3           |\\n| 2  | 2000-12-16 | 5           |\\n\\nExpected\\n| id |\\n| -- |\\n\\nI think the expected should be id = 2 since 12-16 does have higher temperature than 12-14, is that right?\\n"
                    },
                    {
                        "username": "siddhant_samal",
                        "content": "`select w1.id from\\nWeather w1 join Weather w2\\non\\nDATE_ADD(w1.recordDate , INTERVAL -1 DAY) = w2.recordDate \\nand\\nw1.temperature > w2.temperature ;`"
                    },
                    {
                        "username": "adityachatterjee",
                        "content": "SELECT w1.id FROM Weather w1 JOIN Weather w2\nON DATEDIFF(w1.recordDate, w2.recordDate) = 1\nAND w1.temperature > w2.temperature;\n\nHow does this query work when the difference between 2 dates is greater than 1. Where as this doesn't work for the same\n\nSELECT ID FROM (SELECT W.*,Z.TEMPERATURE AS PREVTEMP\nFROM WEATHER W\nLEFT JOIN\nWEATHER Z\nON W.RECORDDATE=(Z.RECORDDATE+1))A\nWHERE TEMPERATURE>PREVTEMP\n\n"
                    },
                    {
                        "username": "ashish_singh00",
                        "content": "If the difference between two dates is greater than 1 then, how it could be called the previous day so that kind of non consecutive dates and not included"
                    },
                    {
                        "username": "ashish_singh00",
                        "content": "select id from (select * , lag(temperature,1,NULL) over(order by recordDate)\\n as prev_temp,lag(recordDate,1,NULL) over(order by recordDate) as prev_date\\nfrom Weather\\n) x\\nwhere x.prev_temp is not null and x.temperature > x.prev_temp\\nand x.prev_date is not null and datediff(x.recordDate,x.prev_date) =1;\\n\\nIs this a good way to do this"
                    }
                ]
            },
            {
                "id": 1804938,
                "content": [
                    {
                        "username": "Puneet72",
                        "content": "Its not accepting ..\\n\\nwith cte as (select id,temperature,lag(temperature) over (order by recordDate) as temp2 from Weather ),\\n\\ncte2 as (select id ,temperature,temp2 from cte )\\n\\nselect id from cte2 where temperature > temp2"
                    },
                    {
                        "username": "anmoltalshi1",
                        "content": "SELECT x.id \\nFROM(\\n    SELECT id ,recordDate ,temperature, LAG(temperature) OVER(ORDER BY recordDate) as temperature_LAG\\n    FROM Weather\\n) x\\nWHERE x.temperature > x.temperature_LAG;"
                    },
                    {
                        "username": "Echo_N1",
                        "content": "The easiest SQL for this case\\n\\nSELECT w.id AS Id\\nFROM Weather w\\n     INNER JOIN Weather pd ON pd.recordDate = DATEADD(DAY, -1, w.recordDate)\\nWHERE w.temperature > pd.temperature"
                    },
                    {
                        "username": "jjjho",
                        "content": "[passed]\\nwith temp as(\\nselect id, date_add(recorddate, interval 1 day) as date, temperature from weather \\n)\\n\\nselect a.id from weather a\\nleft join temp b on a.recorddate = b.date\\nwhere a.temperature > b.temperature"
                    },
                    {
                        "username": "vinayakam19",
                        "content": "Using CTE\\n\\n `with rising_temperature as (select we.id as Id, DATEDIFF(we.recordDate, w.recordDate) as days_diff from Weather w JOIN Weather we on w.id = we.id or w.temperature < we.temperature)\\n\\n\\nselect Id from rising_temperature where days_diff = 1;`"
                    },
                    {
                        "username": "PIYUSH310501",
                        "content": "SELECT w1.id\\nFROM Weather AS w1 , Weather AS w2\\nWHERE w1.Temperature > w2.Temperature AND DATEDIFF(w1.recordDate , w2.recordDate) = 1"
                    },
                    {
                        "username": "sakuramomo1005",
                        "content": "Why I got wrong answer? I think the expected answer is incorrect for one example: \\n\\nInput\\nWeather =\\n| id | recordDate | temperature |\\n| -- | ---------- | ----------- |\\n| 1  | 2000-12-14 | 3           |\\n| 2  | 2000-12-16 | 5           |\\n\\nExpected\\n| id |\\n| -- |\\n\\nI think the expected should be id = 2 since 12-16 does have higher temperature than 12-14, is that right?\\n"
                    },
                    {
                        "username": "siddhant_samal",
                        "content": "`select w1.id from\\nWeather w1 join Weather w2\\non\\nDATE_ADD(w1.recordDate , INTERVAL -1 DAY) = w2.recordDate \\nand\\nw1.temperature > w2.temperature ;`"
                    },
                    {
                        "username": "adityachatterjee",
                        "content": "SELECT w1.id FROM Weather w1 JOIN Weather w2\nON DATEDIFF(w1.recordDate, w2.recordDate) = 1\nAND w1.temperature > w2.temperature;\n\nHow does this query work when the difference between 2 dates is greater than 1. Where as this doesn't work for the same\n\nSELECT ID FROM (SELECT W.*,Z.TEMPERATURE AS PREVTEMP\nFROM WEATHER W\nLEFT JOIN\nWEATHER Z\nON W.RECORDDATE=(Z.RECORDDATE+1))A\nWHERE TEMPERATURE>PREVTEMP\n\n"
                    },
                    {
                        "username": "ashish_singh00",
                        "content": "If the difference between two dates is greater than 1 then, how it could be called the previous day so that kind of non consecutive dates and not included"
                    },
                    {
                        "username": "ashish_singh00",
                        "content": "select id from (select * , lag(temperature,1,NULL) over(order by recordDate)\\n as prev_temp,lag(recordDate,1,NULL) over(order by recordDate) as prev_date\\nfrom Weather\\n) x\\nwhere x.prev_temp is not null and x.temperature > x.prev_temp\\nand x.prev_date is not null and datediff(x.recordDate,x.prev_date) =1;\\n\\nIs this a good way to do this"
                    }
                ]
            },
            {
                "id": 1803938,
                "content": [
                    {
                        "username": "Puneet72",
                        "content": "Its not accepting ..\\n\\nwith cte as (select id,temperature,lag(temperature) over (order by recordDate) as temp2 from Weather ),\\n\\ncte2 as (select id ,temperature,temp2 from cte )\\n\\nselect id from cte2 where temperature > temp2"
                    },
                    {
                        "username": "anmoltalshi1",
                        "content": "SELECT x.id \\nFROM(\\n    SELECT id ,recordDate ,temperature, LAG(temperature) OVER(ORDER BY recordDate) as temperature_LAG\\n    FROM Weather\\n) x\\nWHERE x.temperature > x.temperature_LAG;"
                    },
                    {
                        "username": "Echo_N1",
                        "content": "The easiest SQL for this case\\n\\nSELECT w.id AS Id\\nFROM Weather w\\n     INNER JOIN Weather pd ON pd.recordDate = DATEADD(DAY, -1, w.recordDate)\\nWHERE w.temperature > pd.temperature"
                    },
                    {
                        "username": "jjjho",
                        "content": "[passed]\\nwith temp as(\\nselect id, date_add(recorddate, interval 1 day) as date, temperature from weather \\n)\\n\\nselect a.id from weather a\\nleft join temp b on a.recorddate = b.date\\nwhere a.temperature > b.temperature"
                    },
                    {
                        "username": "vinayakam19",
                        "content": "Using CTE\\n\\n `with rising_temperature as (select we.id as Id, DATEDIFF(we.recordDate, w.recordDate) as days_diff from Weather w JOIN Weather we on w.id = we.id or w.temperature < we.temperature)\\n\\n\\nselect Id from rising_temperature where days_diff = 1;`"
                    },
                    {
                        "username": "PIYUSH310501",
                        "content": "SELECT w1.id\\nFROM Weather AS w1 , Weather AS w2\\nWHERE w1.Temperature > w2.Temperature AND DATEDIFF(w1.recordDate , w2.recordDate) = 1"
                    },
                    {
                        "username": "sakuramomo1005",
                        "content": "Why I got wrong answer? I think the expected answer is incorrect for one example: \\n\\nInput\\nWeather =\\n| id | recordDate | temperature |\\n| -- | ---------- | ----------- |\\n| 1  | 2000-12-14 | 3           |\\n| 2  | 2000-12-16 | 5           |\\n\\nExpected\\n| id |\\n| -- |\\n\\nI think the expected should be id = 2 since 12-16 does have higher temperature than 12-14, is that right?\\n"
                    },
                    {
                        "username": "siddhant_samal",
                        "content": "`select w1.id from\\nWeather w1 join Weather w2\\non\\nDATE_ADD(w1.recordDate , INTERVAL -1 DAY) = w2.recordDate \\nand\\nw1.temperature > w2.temperature ;`"
                    },
                    {
                        "username": "adityachatterjee",
                        "content": "SELECT w1.id FROM Weather w1 JOIN Weather w2\nON DATEDIFF(w1.recordDate, w2.recordDate) = 1\nAND w1.temperature > w2.temperature;\n\nHow does this query work when the difference between 2 dates is greater than 1. Where as this doesn't work for the same\n\nSELECT ID FROM (SELECT W.*,Z.TEMPERATURE AS PREVTEMP\nFROM WEATHER W\nLEFT JOIN\nWEATHER Z\nON W.RECORDDATE=(Z.RECORDDATE+1))A\nWHERE TEMPERATURE>PREVTEMP\n\n"
                    },
                    {
                        "username": "ashish_singh00",
                        "content": "If the difference between two dates is greater than 1 then, how it could be called the previous day so that kind of non consecutive dates and not included"
                    },
                    {
                        "username": "ashish_singh00",
                        "content": "select id from (select * , lag(temperature,1,NULL) over(order by recordDate)\\n as prev_temp,lag(recordDate,1,NULL) over(order by recordDate) as prev_date\\nfrom Weather\\n) x\\nwhere x.prev_temp is not null and x.temperature > x.prev_temp\\nand x.prev_date is not null and datediff(x.recordDate,x.prev_date) =1;\\n\\nIs this a good way to do this"
                    }
                ]
            },
            {
                "id": 1798719,
                "content": [
                    {
                        "username": "Puneet72",
                        "content": "Its not accepting ..\\n\\nwith cte as (select id,temperature,lag(temperature) over (order by recordDate) as temp2 from Weather ),\\n\\ncte2 as (select id ,temperature,temp2 from cte )\\n\\nselect id from cte2 where temperature > temp2"
                    },
                    {
                        "username": "anmoltalshi1",
                        "content": "SELECT x.id \\nFROM(\\n    SELECT id ,recordDate ,temperature, LAG(temperature) OVER(ORDER BY recordDate) as temperature_LAG\\n    FROM Weather\\n) x\\nWHERE x.temperature > x.temperature_LAG;"
                    },
                    {
                        "username": "Echo_N1",
                        "content": "The easiest SQL for this case\\n\\nSELECT w.id AS Id\\nFROM Weather w\\n     INNER JOIN Weather pd ON pd.recordDate = DATEADD(DAY, -1, w.recordDate)\\nWHERE w.temperature > pd.temperature"
                    },
                    {
                        "username": "jjjho",
                        "content": "[passed]\\nwith temp as(\\nselect id, date_add(recorddate, interval 1 day) as date, temperature from weather \\n)\\n\\nselect a.id from weather a\\nleft join temp b on a.recorddate = b.date\\nwhere a.temperature > b.temperature"
                    },
                    {
                        "username": "vinayakam19",
                        "content": "Using CTE\\n\\n `with rising_temperature as (select we.id as Id, DATEDIFF(we.recordDate, w.recordDate) as days_diff from Weather w JOIN Weather we on w.id = we.id or w.temperature < we.temperature)\\n\\n\\nselect Id from rising_temperature where days_diff = 1;`"
                    },
                    {
                        "username": "PIYUSH310501",
                        "content": "SELECT w1.id\\nFROM Weather AS w1 , Weather AS w2\\nWHERE w1.Temperature > w2.Temperature AND DATEDIFF(w1.recordDate , w2.recordDate) = 1"
                    },
                    {
                        "username": "sakuramomo1005",
                        "content": "Why I got wrong answer? I think the expected answer is incorrect for one example: \\n\\nInput\\nWeather =\\n| id | recordDate | temperature |\\n| -- | ---------- | ----------- |\\n| 1  | 2000-12-14 | 3           |\\n| 2  | 2000-12-16 | 5           |\\n\\nExpected\\n| id |\\n| -- |\\n\\nI think the expected should be id = 2 since 12-16 does have higher temperature than 12-14, is that right?\\n"
                    },
                    {
                        "username": "siddhant_samal",
                        "content": "`select w1.id from\\nWeather w1 join Weather w2\\non\\nDATE_ADD(w1.recordDate , INTERVAL -1 DAY) = w2.recordDate \\nand\\nw1.temperature > w2.temperature ;`"
                    },
                    {
                        "username": "adityachatterjee",
                        "content": "SELECT w1.id FROM Weather w1 JOIN Weather w2\nON DATEDIFF(w1.recordDate, w2.recordDate) = 1\nAND w1.temperature > w2.temperature;\n\nHow does this query work when the difference between 2 dates is greater than 1. Where as this doesn't work for the same\n\nSELECT ID FROM (SELECT W.*,Z.TEMPERATURE AS PREVTEMP\nFROM WEATHER W\nLEFT JOIN\nWEATHER Z\nON W.RECORDDATE=(Z.RECORDDATE+1))A\nWHERE TEMPERATURE>PREVTEMP\n\n"
                    },
                    {
                        "username": "ashish_singh00",
                        "content": "If the difference between two dates is greater than 1 then, how it could be called the previous day so that kind of non consecutive dates and not included"
                    },
                    {
                        "username": "ashish_singh00",
                        "content": "select id from (select * , lag(temperature,1,NULL) over(order by recordDate)\\n as prev_temp,lag(recordDate,1,NULL) over(order by recordDate) as prev_date\\nfrom Weather\\n) x\\nwhere x.prev_temp is not null and x.temperature > x.prev_temp\\nand x.prev_date is not null and datediff(x.recordDate,x.prev_date) =1;\\n\\nIs this a good way to do this"
                    }
                ]
            },
            {
                "id": 1797021,
                "content": [
                    {
                        "username": "Puneet72",
                        "content": "Its not accepting ..\\n\\nwith cte as (select id,temperature,lag(temperature) over (order by recordDate) as temp2 from Weather ),\\n\\ncte2 as (select id ,temperature,temp2 from cte )\\n\\nselect id from cte2 where temperature > temp2"
                    },
                    {
                        "username": "anmoltalshi1",
                        "content": "SELECT x.id \\nFROM(\\n    SELECT id ,recordDate ,temperature, LAG(temperature) OVER(ORDER BY recordDate) as temperature_LAG\\n    FROM Weather\\n) x\\nWHERE x.temperature > x.temperature_LAG;"
                    },
                    {
                        "username": "Echo_N1",
                        "content": "The easiest SQL for this case\\n\\nSELECT w.id AS Id\\nFROM Weather w\\n     INNER JOIN Weather pd ON pd.recordDate = DATEADD(DAY, -1, w.recordDate)\\nWHERE w.temperature > pd.temperature"
                    },
                    {
                        "username": "jjjho",
                        "content": "[passed]\\nwith temp as(\\nselect id, date_add(recorddate, interval 1 day) as date, temperature from weather \\n)\\n\\nselect a.id from weather a\\nleft join temp b on a.recorddate = b.date\\nwhere a.temperature > b.temperature"
                    },
                    {
                        "username": "vinayakam19",
                        "content": "Using CTE\\n\\n `with rising_temperature as (select we.id as Id, DATEDIFF(we.recordDate, w.recordDate) as days_diff from Weather w JOIN Weather we on w.id = we.id or w.temperature < we.temperature)\\n\\n\\nselect Id from rising_temperature where days_diff = 1;`"
                    },
                    {
                        "username": "PIYUSH310501",
                        "content": "SELECT w1.id\\nFROM Weather AS w1 , Weather AS w2\\nWHERE w1.Temperature > w2.Temperature AND DATEDIFF(w1.recordDate , w2.recordDate) = 1"
                    },
                    {
                        "username": "sakuramomo1005",
                        "content": "Why I got wrong answer? I think the expected answer is incorrect for one example: \\n\\nInput\\nWeather =\\n| id | recordDate | temperature |\\n| -- | ---------- | ----------- |\\n| 1  | 2000-12-14 | 3           |\\n| 2  | 2000-12-16 | 5           |\\n\\nExpected\\n| id |\\n| -- |\\n\\nI think the expected should be id = 2 since 12-16 does have higher temperature than 12-14, is that right?\\n"
                    },
                    {
                        "username": "siddhant_samal",
                        "content": "`select w1.id from\\nWeather w1 join Weather w2\\non\\nDATE_ADD(w1.recordDate , INTERVAL -1 DAY) = w2.recordDate \\nand\\nw1.temperature > w2.temperature ;`"
                    },
                    {
                        "username": "adityachatterjee",
                        "content": "SELECT w1.id FROM Weather w1 JOIN Weather w2\nON DATEDIFF(w1.recordDate, w2.recordDate) = 1\nAND w1.temperature > w2.temperature;\n\nHow does this query work when the difference between 2 dates is greater than 1. Where as this doesn't work for the same\n\nSELECT ID FROM (SELECT W.*,Z.TEMPERATURE AS PREVTEMP\nFROM WEATHER W\nLEFT JOIN\nWEATHER Z\nON W.RECORDDATE=(Z.RECORDDATE+1))A\nWHERE TEMPERATURE>PREVTEMP\n\n"
                    },
                    {
                        "username": "ashish_singh00",
                        "content": "If the difference between two dates is greater than 1 then, how it could be called the previous day so that kind of non consecutive dates and not included"
                    },
                    {
                        "username": "ashish_singh00",
                        "content": "select id from (select * , lag(temperature,1,NULL) over(order by recordDate)\\n as prev_temp,lag(recordDate,1,NULL) over(order by recordDate) as prev_date\\nfrom Weather\\n) x\\nwhere x.prev_temp is not null and x.temperature > x.prev_temp\\nand x.prev_date is not null and datediff(x.recordDate,x.prev_date) =1;\\n\\nIs this a good way to do this"
                    }
                ]
            },
            {
                "id": 1790142,
                "content": [
                    {
                        "username": "Puneet72",
                        "content": "Its not accepting ..\\n\\nwith cte as (select id,temperature,lag(temperature) over (order by recordDate) as temp2 from Weather ),\\n\\ncte2 as (select id ,temperature,temp2 from cte )\\n\\nselect id from cte2 where temperature > temp2"
                    },
                    {
                        "username": "anmoltalshi1",
                        "content": "SELECT x.id \\nFROM(\\n    SELECT id ,recordDate ,temperature, LAG(temperature) OVER(ORDER BY recordDate) as temperature_LAG\\n    FROM Weather\\n) x\\nWHERE x.temperature > x.temperature_LAG;"
                    },
                    {
                        "username": "Echo_N1",
                        "content": "The easiest SQL for this case\\n\\nSELECT w.id AS Id\\nFROM Weather w\\n     INNER JOIN Weather pd ON pd.recordDate = DATEADD(DAY, -1, w.recordDate)\\nWHERE w.temperature > pd.temperature"
                    },
                    {
                        "username": "jjjho",
                        "content": "[passed]\\nwith temp as(\\nselect id, date_add(recorddate, interval 1 day) as date, temperature from weather \\n)\\n\\nselect a.id from weather a\\nleft join temp b on a.recorddate = b.date\\nwhere a.temperature > b.temperature"
                    },
                    {
                        "username": "vinayakam19",
                        "content": "Using CTE\\n\\n `with rising_temperature as (select we.id as Id, DATEDIFF(we.recordDate, w.recordDate) as days_diff from Weather w JOIN Weather we on w.id = we.id or w.temperature < we.temperature)\\n\\n\\nselect Id from rising_temperature where days_diff = 1;`"
                    },
                    {
                        "username": "PIYUSH310501",
                        "content": "SELECT w1.id\\nFROM Weather AS w1 , Weather AS w2\\nWHERE w1.Temperature > w2.Temperature AND DATEDIFF(w1.recordDate , w2.recordDate) = 1"
                    },
                    {
                        "username": "sakuramomo1005",
                        "content": "Why I got wrong answer? I think the expected answer is incorrect for one example: \\n\\nInput\\nWeather =\\n| id | recordDate | temperature |\\n| -- | ---------- | ----------- |\\n| 1  | 2000-12-14 | 3           |\\n| 2  | 2000-12-16 | 5           |\\n\\nExpected\\n| id |\\n| -- |\\n\\nI think the expected should be id = 2 since 12-16 does have higher temperature than 12-14, is that right?\\n"
                    },
                    {
                        "username": "siddhant_samal",
                        "content": "`select w1.id from\\nWeather w1 join Weather w2\\non\\nDATE_ADD(w1.recordDate , INTERVAL -1 DAY) = w2.recordDate \\nand\\nw1.temperature > w2.temperature ;`"
                    },
                    {
                        "username": "adityachatterjee",
                        "content": "SELECT w1.id FROM Weather w1 JOIN Weather w2\nON DATEDIFF(w1.recordDate, w2.recordDate) = 1\nAND w1.temperature > w2.temperature;\n\nHow does this query work when the difference between 2 dates is greater than 1. Where as this doesn't work for the same\n\nSELECT ID FROM (SELECT W.*,Z.TEMPERATURE AS PREVTEMP\nFROM WEATHER W\nLEFT JOIN\nWEATHER Z\nON W.RECORDDATE=(Z.RECORDDATE+1))A\nWHERE TEMPERATURE>PREVTEMP\n\n"
                    },
                    {
                        "username": "ashish_singh00",
                        "content": "If the difference between two dates is greater than 1 then, how it could be called the previous day so that kind of non consecutive dates and not included"
                    },
                    {
                        "username": "ashish_singh00",
                        "content": "select id from (select * , lag(temperature,1,NULL) over(order by recordDate)\\n as prev_temp,lag(recordDate,1,NULL) over(order by recordDate) as prev_date\\nfrom Weather\\n) x\\nwhere x.prev_temp is not null and x.temperature > x.prev_temp\\nand x.prev_date is not null and datediff(x.recordDate,x.prev_date) =1;\\n\\nIs this a good way to do this"
                    }
                ]
            },
            {
                "id": 1788745,
                "content": [
                    {
                        "username": "Puneet72",
                        "content": "Its not accepting ..\\n\\nwith cte as (select id,temperature,lag(temperature) over (order by recordDate) as temp2 from Weather ),\\n\\ncte2 as (select id ,temperature,temp2 from cte )\\n\\nselect id from cte2 where temperature > temp2"
                    },
                    {
                        "username": "anmoltalshi1",
                        "content": "SELECT x.id \\nFROM(\\n    SELECT id ,recordDate ,temperature, LAG(temperature) OVER(ORDER BY recordDate) as temperature_LAG\\n    FROM Weather\\n) x\\nWHERE x.temperature > x.temperature_LAG;"
                    },
                    {
                        "username": "Echo_N1",
                        "content": "The easiest SQL for this case\\n\\nSELECT w.id AS Id\\nFROM Weather w\\n     INNER JOIN Weather pd ON pd.recordDate = DATEADD(DAY, -1, w.recordDate)\\nWHERE w.temperature > pd.temperature"
                    },
                    {
                        "username": "jjjho",
                        "content": "[passed]\\nwith temp as(\\nselect id, date_add(recorddate, interval 1 day) as date, temperature from weather \\n)\\n\\nselect a.id from weather a\\nleft join temp b on a.recorddate = b.date\\nwhere a.temperature > b.temperature"
                    },
                    {
                        "username": "vinayakam19",
                        "content": "Using CTE\\n\\n `with rising_temperature as (select we.id as Id, DATEDIFF(we.recordDate, w.recordDate) as days_diff from Weather w JOIN Weather we on w.id = we.id or w.temperature < we.temperature)\\n\\n\\nselect Id from rising_temperature where days_diff = 1;`"
                    },
                    {
                        "username": "PIYUSH310501",
                        "content": "SELECT w1.id\\nFROM Weather AS w1 , Weather AS w2\\nWHERE w1.Temperature > w2.Temperature AND DATEDIFF(w1.recordDate , w2.recordDate) = 1"
                    },
                    {
                        "username": "sakuramomo1005",
                        "content": "Why I got wrong answer? I think the expected answer is incorrect for one example: \\n\\nInput\\nWeather =\\n| id | recordDate | temperature |\\n| -- | ---------- | ----------- |\\n| 1  | 2000-12-14 | 3           |\\n| 2  | 2000-12-16 | 5           |\\n\\nExpected\\n| id |\\n| -- |\\n\\nI think the expected should be id = 2 since 12-16 does have higher temperature than 12-14, is that right?\\n"
                    },
                    {
                        "username": "siddhant_samal",
                        "content": "`select w1.id from\\nWeather w1 join Weather w2\\non\\nDATE_ADD(w1.recordDate , INTERVAL -1 DAY) = w2.recordDate \\nand\\nw1.temperature > w2.temperature ;`"
                    },
                    {
                        "username": "adityachatterjee",
                        "content": "SELECT w1.id FROM Weather w1 JOIN Weather w2\nON DATEDIFF(w1.recordDate, w2.recordDate) = 1\nAND w1.temperature > w2.temperature;\n\nHow does this query work when the difference between 2 dates is greater than 1. Where as this doesn't work for the same\n\nSELECT ID FROM (SELECT W.*,Z.TEMPERATURE AS PREVTEMP\nFROM WEATHER W\nLEFT JOIN\nWEATHER Z\nON W.RECORDDATE=(Z.RECORDDATE+1))A\nWHERE TEMPERATURE>PREVTEMP\n\n"
                    },
                    {
                        "username": "ashish_singh00",
                        "content": "If the difference between two dates is greater than 1 then, how it could be called the previous day so that kind of non consecutive dates and not included"
                    },
                    {
                        "username": "ashish_singh00",
                        "content": "select id from (select * , lag(temperature,1,NULL) over(order by recordDate)\\n as prev_temp,lag(recordDate,1,NULL) over(order by recordDate) as prev_date\\nfrom Weather\\n) x\\nwhere x.prev_temp is not null and x.temperature > x.prev_temp\\nand x.prev_date is not null and datediff(x.recordDate,x.prev_date) =1;\\n\\nIs this a good way to do this"
                    }
                ]
            },
            {
                "id": 1785808,
                "content": [
                    {
                        "username": "DhruvitModi",
                        "content": "Is there any issue with Submit, because while Run the code it is accepted.\\nbut when I try to submit, it shows wrong answer, \\nalso I noticed that after submit, data set are different than question which leads to wrong answer.\\nIs anyone faced same problem, or any solution ?"
                    },
                    {
                        "username": "Stas_Hlova",
                        "content": "SELECT id\\nFROM Weather weather \\nWHERE weather.temperature > (SELECT w1.temperature\\n                            FROM Weather w1\\n                            WHERE w1.recordDate = SUBDATE(weather.recordDate, INTERVAL 1 DAY)\\n                            LIMIT 1);\\n"
                    },
                    {
                        "username": "Ravi_ranjan_itz",
                        "content": "Hey guys plz help\\nselect x.id from\\n    (select w.*,\\n    lag(temperature,1,0) over(order by id) as prev_temp\\n    from weather w) as x \\n    where x.temperature> x.prev_temp;\\n\\n"
                    },
                    {
                        "username": "tantheidiot",
                        "content": " `with cte AS (SELECT id, recordDate, temperature, LAG(recordDate, 1) OVER (ORDER BY recordDate ASC) pre_date, LAG(temperature, 1) OVER (ORDER BY recordDate ASC) t\\nFROM Weather)\\n\\nselect id FROM cte\\nWHERE temperature > t\\nAND DATE_SUB(recordDate, INTERVAL 1 DAY) = pre_date;`"
                    },
                    {
                        "username": "Chaudhary_Anmol",
                        "content": "try this one \\nselect id  from Weather w1 where temperature - (select temperature from weather where recordDate = w1.recordDate-1)>0 "
                    },
                    {
                        "username": "pinky_adhikari1996",
                        "content": "SELECT id\\nFROM\\n(\\nSELECT id, recordDate, temperature , LAG(temperature,1) OVER (ORDER BY recordDate) AS yesterday_temp, LAG(recordDate,1) OVER (ORDER BY recordDate) AS prev_date\\n\\nFROM Weather\\n) AS temp_table\\n\\nWHERE temperature>yesterday_temp AND DATEDIFF(day,prev_date,recordDate)=1"
                    },
                    {
                        "username": "Himanshu_sansanwal",
                        "content": "select matrix.id from (select Weather.*, lag(temperature,1,null) over(order by recordDate asc) as prev_temp from Weather) as matrix \\nwhere prev_temp is not null and temperature > prev_temp\\n\\n"
                    },
                    {
                        "username": "user1388JN",
                        "content": "Can anyone help ! \\n\\nwhy the below code is not working. \\nit is working for case1 and not for case2 \\n\\n\\n\\nwith table1 as \\n(select *, \\nlag(temperature) over (order by recordDate) as previoustemp\\nfrom Weather)\\n\\nselect id\\nfrom table1\\nwhere temperature > previoustemp;"
                    },
                    {
                        "username": "andrewlawrenceevans",
                        "content": "Beats 90%!\\n\\nSELECT w2.id\\nFROM (\\n    SELECT id, recordDate, temperature, \\n    ROW_NUMBER() OVER(ORDER BY recordDate) as row_id\\n    FROM Weather\\n) w1\\nINNER JOIN (\\n    SELECT id, recordDate, temperature, \\n    ROW_NUMBER() OVER(ORDER BY recordDate) as row_id\\n    FROM Weather\\n) w2\\nON w1.row_id+1 = w2.row_id\\nWHERE w1.temperature < w2.temperature AND DATEDIFF(w2.recordDate, w1.recordDate)=1\\n"
                    },
                    {
                        "username": "karthiknandiraju",
                        "content": "\nSELECT\n    weather.id AS 'Id'\nFROM\n    weather\n        JOIN\n    weather w ON DATEDIFF(day, weather.RecordDate, w.RecordDate) = -1\n        AND weather.Temperature > w.Temperature;\n\n/* Please do not use +1 but use -1 */"
                    }
                ]
            },
            {
                "id": 1785195,
                "content": [
                    {
                        "username": "DhruvitModi",
                        "content": "Is there any issue with Submit, because while Run the code it is accepted.\\nbut when I try to submit, it shows wrong answer, \\nalso I noticed that after submit, data set are different than question which leads to wrong answer.\\nIs anyone faced same problem, or any solution ?"
                    },
                    {
                        "username": "Stas_Hlova",
                        "content": "SELECT id\\nFROM Weather weather \\nWHERE weather.temperature > (SELECT w1.temperature\\n                            FROM Weather w1\\n                            WHERE w1.recordDate = SUBDATE(weather.recordDate, INTERVAL 1 DAY)\\n                            LIMIT 1);\\n"
                    },
                    {
                        "username": "Ravi_ranjan_itz",
                        "content": "Hey guys plz help\\nselect x.id from\\n    (select w.*,\\n    lag(temperature,1,0) over(order by id) as prev_temp\\n    from weather w) as x \\n    where x.temperature> x.prev_temp;\\n\\n"
                    },
                    {
                        "username": "tantheidiot",
                        "content": " `with cte AS (SELECT id, recordDate, temperature, LAG(recordDate, 1) OVER (ORDER BY recordDate ASC) pre_date, LAG(temperature, 1) OVER (ORDER BY recordDate ASC) t\\nFROM Weather)\\n\\nselect id FROM cte\\nWHERE temperature > t\\nAND DATE_SUB(recordDate, INTERVAL 1 DAY) = pre_date;`"
                    },
                    {
                        "username": "Chaudhary_Anmol",
                        "content": "try this one \\nselect id  from Weather w1 where temperature - (select temperature from weather where recordDate = w1.recordDate-1)>0 "
                    },
                    {
                        "username": "pinky_adhikari1996",
                        "content": "SELECT id\\nFROM\\n(\\nSELECT id, recordDate, temperature , LAG(temperature,1) OVER (ORDER BY recordDate) AS yesterday_temp, LAG(recordDate,1) OVER (ORDER BY recordDate) AS prev_date\\n\\nFROM Weather\\n) AS temp_table\\n\\nWHERE temperature>yesterday_temp AND DATEDIFF(day,prev_date,recordDate)=1"
                    },
                    {
                        "username": "Himanshu_sansanwal",
                        "content": "select matrix.id from (select Weather.*, lag(temperature,1,null) over(order by recordDate asc) as prev_temp from Weather) as matrix \\nwhere prev_temp is not null and temperature > prev_temp\\n\\n"
                    },
                    {
                        "username": "user1388JN",
                        "content": "Can anyone help ! \\n\\nwhy the below code is not working. \\nit is working for case1 and not for case2 \\n\\n\\n\\nwith table1 as \\n(select *, \\nlag(temperature) over (order by recordDate) as previoustemp\\nfrom Weather)\\n\\nselect id\\nfrom table1\\nwhere temperature > previoustemp;"
                    },
                    {
                        "username": "andrewlawrenceevans",
                        "content": "Beats 90%!\\n\\nSELECT w2.id\\nFROM (\\n    SELECT id, recordDate, temperature, \\n    ROW_NUMBER() OVER(ORDER BY recordDate) as row_id\\n    FROM Weather\\n) w1\\nINNER JOIN (\\n    SELECT id, recordDate, temperature, \\n    ROW_NUMBER() OVER(ORDER BY recordDate) as row_id\\n    FROM Weather\\n) w2\\nON w1.row_id+1 = w2.row_id\\nWHERE w1.temperature < w2.temperature AND DATEDIFF(w2.recordDate, w1.recordDate)=1\\n"
                    },
                    {
                        "username": "karthiknandiraju",
                        "content": "\nSELECT\n    weather.id AS 'Id'\nFROM\n    weather\n        JOIN\n    weather w ON DATEDIFF(day, weather.RecordDate, w.RecordDate) = -1\n        AND weather.Temperature > w.Temperature;\n\n/* Please do not use +1 but use -1 */"
                    }
                ]
            },
            {
                "id": 1782322,
                "content": [
                    {
                        "username": "DhruvitModi",
                        "content": "Is there any issue with Submit, because while Run the code it is accepted.\\nbut when I try to submit, it shows wrong answer, \\nalso I noticed that after submit, data set are different than question which leads to wrong answer.\\nIs anyone faced same problem, or any solution ?"
                    },
                    {
                        "username": "Stas_Hlova",
                        "content": "SELECT id\\nFROM Weather weather \\nWHERE weather.temperature > (SELECT w1.temperature\\n                            FROM Weather w1\\n                            WHERE w1.recordDate = SUBDATE(weather.recordDate, INTERVAL 1 DAY)\\n                            LIMIT 1);\\n"
                    },
                    {
                        "username": "Ravi_ranjan_itz",
                        "content": "Hey guys plz help\\nselect x.id from\\n    (select w.*,\\n    lag(temperature,1,0) over(order by id) as prev_temp\\n    from weather w) as x \\n    where x.temperature> x.prev_temp;\\n\\n"
                    },
                    {
                        "username": "tantheidiot",
                        "content": " `with cte AS (SELECT id, recordDate, temperature, LAG(recordDate, 1) OVER (ORDER BY recordDate ASC) pre_date, LAG(temperature, 1) OVER (ORDER BY recordDate ASC) t\\nFROM Weather)\\n\\nselect id FROM cte\\nWHERE temperature > t\\nAND DATE_SUB(recordDate, INTERVAL 1 DAY) = pre_date;`"
                    },
                    {
                        "username": "Chaudhary_Anmol",
                        "content": "try this one \\nselect id  from Weather w1 where temperature - (select temperature from weather where recordDate = w1.recordDate-1)>0 "
                    },
                    {
                        "username": "pinky_adhikari1996",
                        "content": "SELECT id\\nFROM\\n(\\nSELECT id, recordDate, temperature , LAG(temperature,1) OVER (ORDER BY recordDate) AS yesterday_temp, LAG(recordDate,1) OVER (ORDER BY recordDate) AS prev_date\\n\\nFROM Weather\\n) AS temp_table\\n\\nWHERE temperature>yesterday_temp AND DATEDIFF(day,prev_date,recordDate)=1"
                    },
                    {
                        "username": "Himanshu_sansanwal",
                        "content": "select matrix.id from (select Weather.*, lag(temperature,1,null) over(order by recordDate asc) as prev_temp from Weather) as matrix \\nwhere prev_temp is not null and temperature > prev_temp\\n\\n"
                    },
                    {
                        "username": "user1388JN",
                        "content": "Can anyone help ! \\n\\nwhy the below code is not working. \\nit is working for case1 and not for case2 \\n\\n\\n\\nwith table1 as \\n(select *, \\nlag(temperature) over (order by recordDate) as previoustemp\\nfrom Weather)\\n\\nselect id\\nfrom table1\\nwhere temperature > previoustemp;"
                    },
                    {
                        "username": "andrewlawrenceevans",
                        "content": "Beats 90%!\\n\\nSELECT w2.id\\nFROM (\\n    SELECT id, recordDate, temperature, \\n    ROW_NUMBER() OVER(ORDER BY recordDate) as row_id\\n    FROM Weather\\n) w1\\nINNER JOIN (\\n    SELECT id, recordDate, temperature, \\n    ROW_NUMBER() OVER(ORDER BY recordDate) as row_id\\n    FROM Weather\\n) w2\\nON w1.row_id+1 = w2.row_id\\nWHERE w1.temperature < w2.temperature AND DATEDIFF(w2.recordDate, w1.recordDate)=1\\n"
                    },
                    {
                        "username": "karthiknandiraju",
                        "content": "\nSELECT\n    weather.id AS 'Id'\nFROM\n    weather\n        JOIN\n    weather w ON DATEDIFF(day, weather.RecordDate, w.RecordDate) = -1\n        AND weather.Temperature > w.Temperature;\n\n/* Please do not use +1 but use -1 */"
                    }
                ]
            },
            {
                "id": 1779908,
                "content": [
                    {
                        "username": "DhruvitModi",
                        "content": "Is there any issue with Submit, because while Run the code it is accepted.\\nbut when I try to submit, it shows wrong answer, \\nalso I noticed that after submit, data set are different than question which leads to wrong answer.\\nIs anyone faced same problem, or any solution ?"
                    },
                    {
                        "username": "Stas_Hlova",
                        "content": "SELECT id\\nFROM Weather weather \\nWHERE weather.temperature > (SELECT w1.temperature\\n                            FROM Weather w1\\n                            WHERE w1.recordDate = SUBDATE(weather.recordDate, INTERVAL 1 DAY)\\n                            LIMIT 1);\\n"
                    },
                    {
                        "username": "Ravi_ranjan_itz",
                        "content": "Hey guys plz help\\nselect x.id from\\n    (select w.*,\\n    lag(temperature,1,0) over(order by id) as prev_temp\\n    from weather w) as x \\n    where x.temperature> x.prev_temp;\\n\\n"
                    },
                    {
                        "username": "tantheidiot",
                        "content": " `with cte AS (SELECT id, recordDate, temperature, LAG(recordDate, 1) OVER (ORDER BY recordDate ASC) pre_date, LAG(temperature, 1) OVER (ORDER BY recordDate ASC) t\\nFROM Weather)\\n\\nselect id FROM cte\\nWHERE temperature > t\\nAND DATE_SUB(recordDate, INTERVAL 1 DAY) = pre_date;`"
                    },
                    {
                        "username": "Chaudhary_Anmol",
                        "content": "try this one \\nselect id  from Weather w1 where temperature - (select temperature from weather where recordDate = w1.recordDate-1)>0 "
                    },
                    {
                        "username": "pinky_adhikari1996",
                        "content": "SELECT id\\nFROM\\n(\\nSELECT id, recordDate, temperature , LAG(temperature,1) OVER (ORDER BY recordDate) AS yesterday_temp, LAG(recordDate,1) OVER (ORDER BY recordDate) AS prev_date\\n\\nFROM Weather\\n) AS temp_table\\n\\nWHERE temperature>yesterday_temp AND DATEDIFF(day,prev_date,recordDate)=1"
                    },
                    {
                        "username": "Himanshu_sansanwal",
                        "content": "select matrix.id from (select Weather.*, lag(temperature,1,null) over(order by recordDate asc) as prev_temp from Weather) as matrix \\nwhere prev_temp is not null and temperature > prev_temp\\n\\n"
                    },
                    {
                        "username": "user1388JN",
                        "content": "Can anyone help ! \\n\\nwhy the below code is not working. \\nit is working for case1 and not for case2 \\n\\n\\n\\nwith table1 as \\n(select *, \\nlag(temperature) over (order by recordDate) as previoustemp\\nfrom Weather)\\n\\nselect id\\nfrom table1\\nwhere temperature > previoustemp;"
                    },
                    {
                        "username": "andrewlawrenceevans",
                        "content": "Beats 90%!\\n\\nSELECT w2.id\\nFROM (\\n    SELECT id, recordDate, temperature, \\n    ROW_NUMBER() OVER(ORDER BY recordDate) as row_id\\n    FROM Weather\\n) w1\\nINNER JOIN (\\n    SELECT id, recordDate, temperature, \\n    ROW_NUMBER() OVER(ORDER BY recordDate) as row_id\\n    FROM Weather\\n) w2\\nON w1.row_id+1 = w2.row_id\\nWHERE w1.temperature < w2.temperature AND DATEDIFF(w2.recordDate, w1.recordDate)=1\\n"
                    },
                    {
                        "username": "karthiknandiraju",
                        "content": "\nSELECT\n    weather.id AS 'Id'\nFROM\n    weather\n        JOIN\n    weather w ON DATEDIFF(day, weather.RecordDate, w.RecordDate) = -1\n        AND weather.Temperature > w.Temperature;\n\n/* Please do not use +1 but use -1 */"
                    }
                ]
            },
            {
                "id": 1778161,
                "content": [
                    {
                        "username": "DhruvitModi",
                        "content": "Is there any issue with Submit, because while Run the code it is accepted.\\nbut when I try to submit, it shows wrong answer, \\nalso I noticed that after submit, data set are different than question which leads to wrong answer.\\nIs anyone faced same problem, or any solution ?"
                    },
                    {
                        "username": "Stas_Hlova",
                        "content": "SELECT id\\nFROM Weather weather \\nWHERE weather.temperature > (SELECT w1.temperature\\n                            FROM Weather w1\\n                            WHERE w1.recordDate = SUBDATE(weather.recordDate, INTERVAL 1 DAY)\\n                            LIMIT 1);\\n"
                    },
                    {
                        "username": "Ravi_ranjan_itz",
                        "content": "Hey guys plz help\\nselect x.id from\\n    (select w.*,\\n    lag(temperature,1,0) over(order by id) as prev_temp\\n    from weather w) as x \\n    where x.temperature> x.prev_temp;\\n\\n"
                    },
                    {
                        "username": "tantheidiot",
                        "content": " `with cte AS (SELECT id, recordDate, temperature, LAG(recordDate, 1) OVER (ORDER BY recordDate ASC) pre_date, LAG(temperature, 1) OVER (ORDER BY recordDate ASC) t\\nFROM Weather)\\n\\nselect id FROM cte\\nWHERE temperature > t\\nAND DATE_SUB(recordDate, INTERVAL 1 DAY) = pre_date;`"
                    },
                    {
                        "username": "Chaudhary_Anmol",
                        "content": "try this one \\nselect id  from Weather w1 where temperature - (select temperature from weather where recordDate = w1.recordDate-1)>0 "
                    },
                    {
                        "username": "pinky_adhikari1996",
                        "content": "SELECT id\\nFROM\\n(\\nSELECT id, recordDate, temperature , LAG(temperature,1) OVER (ORDER BY recordDate) AS yesterday_temp, LAG(recordDate,1) OVER (ORDER BY recordDate) AS prev_date\\n\\nFROM Weather\\n) AS temp_table\\n\\nWHERE temperature>yesterday_temp AND DATEDIFF(day,prev_date,recordDate)=1"
                    },
                    {
                        "username": "Himanshu_sansanwal",
                        "content": "select matrix.id from (select Weather.*, lag(temperature,1,null) over(order by recordDate asc) as prev_temp from Weather) as matrix \\nwhere prev_temp is not null and temperature > prev_temp\\n\\n"
                    },
                    {
                        "username": "user1388JN",
                        "content": "Can anyone help ! \\n\\nwhy the below code is not working. \\nit is working for case1 and not for case2 \\n\\n\\n\\nwith table1 as \\n(select *, \\nlag(temperature) over (order by recordDate) as previoustemp\\nfrom Weather)\\n\\nselect id\\nfrom table1\\nwhere temperature > previoustemp;"
                    },
                    {
                        "username": "andrewlawrenceevans",
                        "content": "Beats 90%!\\n\\nSELECT w2.id\\nFROM (\\n    SELECT id, recordDate, temperature, \\n    ROW_NUMBER() OVER(ORDER BY recordDate) as row_id\\n    FROM Weather\\n) w1\\nINNER JOIN (\\n    SELECT id, recordDate, temperature, \\n    ROW_NUMBER() OVER(ORDER BY recordDate) as row_id\\n    FROM Weather\\n) w2\\nON w1.row_id+1 = w2.row_id\\nWHERE w1.temperature < w2.temperature AND DATEDIFF(w2.recordDate, w1.recordDate)=1\\n"
                    },
                    {
                        "username": "karthiknandiraju",
                        "content": "\nSELECT\n    weather.id AS 'Id'\nFROM\n    weather\n        JOIN\n    weather w ON DATEDIFF(day, weather.RecordDate, w.RecordDate) = -1\n        AND weather.Temperature > w.Temperature;\n\n/* Please do not use +1 but use -1 */"
                    }
                ]
            },
            {
                "id": 1772316,
                "content": [
                    {
                        "username": "DhruvitModi",
                        "content": "Is there any issue with Submit, because while Run the code it is accepted.\\nbut when I try to submit, it shows wrong answer, \\nalso I noticed that after submit, data set are different than question which leads to wrong answer.\\nIs anyone faced same problem, or any solution ?"
                    },
                    {
                        "username": "Stas_Hlova",
                        "content": "SELECT id\\nFROM Weather weather \\nWHERE weather.temperature > (SELECT w1.temperature\\n                            FROM Weather w1\\n                            WHERE w1.recordDate = SUBDATE(weather.recordDate, INTERVAL 1 DAY)\\n                            LIMIT 1);\\n"
                    },
                    {
                        "username": "Ravi_ranjan_itz",
                        "content": "Hey guys plz help\\nselect x.id from\\n    (select w.*,\\n    lag(temperature,1,0) over(order by id) as prev_temp\\n    from weather w) as x \\n    where x.temperature> x.prev_temp;\\n\\n"
                    },
                    {
                        "username": "tantheidiot",
                        "content": " `with cte AS (SELECT id, recordDate, temperature, LAG(recordDate, 1) OVER (ORDER BY recordDate ASC) pre_date, LAG(temperature, 1) OVER (ORDER BY recordDate ASC) t\\nFROM Weather)\\n\\nselect id FROM cte\\nWHERE temperature > t\\nAND DATE_SUB(recordDate, INTERVAL 1 DAY) = pre_date;`"
                    },
                    {
                        "username": "Chaudhary_Anmol",
                        "content": "try this one \\nselect id  from Weather w1 where temperature - (select temperature from weather where recordDate = w1.recordDate-1)>0 "
                    },
                    {
                        "username": "pinky_adhikari1996",
                        "content": "SELECT id\\nFROM\\n(\\nSELECT id, recordDate, temperature , LAG(temperature,1) OVER (ORDER BY recordDate) AS yesterday_temp, LAG(recordDate,1) OVER (ORDER BY recordDate) AS prev_date\\n\\nFROM Weather\\n) AS temp_table\\n\\nWHERE temperature>yesterday_temp AND DATEDIFF(day,prev_date,recordDate)=1"
                    },
                    {
                        "username": "Himanshu_sansanwal",
                        "content": "select matrix.id from (select Weather.*, lag(temperature,1,null) over(order by recordDate asc) as prev_temp from Weather) as matrix \\nwhere prev_temp is not null and temperature > prev_temp\\n\\n"
                    },
                    {
                        "username": "user1388JN",
                        "content": "Can anyone help ! \\n\\nwhy the below code is not working. \\nit is working for case1 and not for case2 \\n\\n\\n\\nwith table1 as \\n(select *, \\nlag(temperature) over (order by recordDate) as previoustemp\\nfrom Weather)\\n\\nselect id\\nfrom table1\\nwhere temperature > previoustemp;"
                    },
                    {
                        "username": "andrewlawrenceevans",
                        "content": "Beats 90%!\\n\\nSELECT w2.id\\nFROM (\\n    SELECT id, recordDate, temperature, \\n    ROW_NUMBER() OVER(ORDER BY recordDate) as row_id\\n    FROM Weather\\n) w1\\nINNER JOIN (\\n    SELECT id, recordDate, temperature, \\n    ROW_NUMBER() OVER(ORDER BY recordDate) as row_id\\n    FROM Weather\\n) w2\\nON w1.row_id+1 = w2.row_id\\nWHERE w1.temperature < w2.temperature AND DATEDIFF(w2.recordDate, w1.recordDate)=1\\n"
                    },
                    {
                        "username": "karthiknandiraju",
                        "content": "\nSELECT\n    weather.id AS 'Id'\nFROM\n    weather\n        JOIN\n    weather w ON DATEDIFF(day, weather.RecordDate, w.RecordDate) = -1\n        AND weather.Temperature > w.Temperature;\n\n/* Please do not use +1 but use -1 */"
                    }
                ]
            },
            {
                "id": 1761565,
                "content": [
                    {
                        "username": "DhruvitModi",
                        "content": "Is there any issue with Submit, because while Run the code it is accepted.\\nbut when I try to submit, it shows wrong answer, \\nalso I noticed that after submit, data set are different than question which leads to wrong answer.\\nIs anyone faced same problem, or any solution ?"
                    },
                    {
                        "username": "Stas_Hlova",
                        "content": "SELECT id\\nFROM Weather weather \\nWHERE weather.temperature > (SELECT w1.temperature\\n                            FROM Weather w1\\n                            WHERE w1.recordDate = SUBDATE(weather.recordDate, INTERVAL 1 DAY)\\n                            LIMIT 1);\\n"
                    },
                    {
                        "username": "Ravi_ranjan_itz",
                        "content": "Hey guys plz help\\nselect x.id from\\n    (select w.*,\\n    lag(temperature,1,0) over(order by id) as prev_temp\\n    from weather w) as x \\n    where x.temperature> x.prev_temp;\\n\\n"
                    },
                    {
                        "username": "tantheidiot",
                        "content": " `with cte AS (SELECT id, recordDate, temperature, LAG(recordDate, 1) OVER (ORDER BY recordDate ASC) pre_date, LAG(temperature, 1) OVER (ORDER BY recordDate ASC) t\\nFROM Weather)\\n\\nselect id FROM cte\\nWHERE temperature > t\\nAND DATE_SUB(recordDate, INTERVAL 1 DAY) = pre_date;`"
                    },
                    {
                        "username": "Chaudhary_Anmol",
                        "content": "try this one \\nselect id  from Weather w1 where temperature - (select temperature from weather where recordDate = w1.recordDate-1)>0 "
                    },
                    {
                        "username": "pinky_adhikari1996",
                        "content": "SELECT id\\nFROM\\n(\\nSELECT id, recordDate, temperature , LAG(temperature,1) OVER (ORDER BY recordDate) AS yesterday_temp, LAG(recordDate,1) OVER (ORDER BY recordDate) AS prev_date\\n\\nFROM Weather\\n) AS temp_table\\n\\nWHERE temperature>yesterday_temp AND DATEDIFF(day,prev_date,recordDate)=1"
                    },
                    {
                        "username": "Himanshu_sansanwal",
                        "content": "select matrix.id from (select Weather.*, lag(temperature,1,null) over(order by recordDate asc) as prev_temp from Weather) as matrix \\nwhere prev_temp is not null and temperature > prev_temp\\n\\n"
                    },
                    {
                        "username": "user1388JN",
                        "content": "Can anyone help ! \\n\\nwhy the below code is not working. \\nit is working for case1 and not for case2 \\n\\n\\n\\nwith table1 as \\n(select *, \\nlag(temperature) over (order by recordDate) as previoustemp\\nfrom Weather)\\n\\nselect id\\nfrom table1\\nwhere temperature > previoustemp;"
                    },
                    {
                        "username": "andrewlawrenceevans",
                        "content": "Beats 90%!\\n\\nSELECT w2.id\\nFROM (\\n    SELECT id, recordDate, temperature, \\n    ROW_NUMBER() OVER(ORDER BY recordDate) as row_id\\n    FROM Weather\\n) w1\\nINNER JOIN (\\n    SELECT id, recordDate, temperature, \\n    ROW_NUMBER() OVER(ORDER BY recordDate) as row_id\\n    FROM Weather\\n) w2\\nON w1.row_id+1 = w2.row_id\\nWHERE w1.temperature < w2.temperature AND DATEDIFF(w2.recordDate, w1.recordDate)=1\\n"
                    },
                    {
                        "username": "karthiknandiraju",
                        "content": "\nSELECT\n    weather.id AS 'Id'\nFROM\n    weather\n        JOIN\n    weather w ON DATEDIFF(day, weather.RecordDate, w.RecordDate) = -1\n        AND weather.Temperature > w.Temperature;\n\n/* Please do not use +1 but use -1 */"
                    }
                ]
            },
            {
                "id": 1760556,
                "content": [
                    {
                        "username": "DhruvitModi",
                        "content": "Is there any issue with Submit, because while Run the code it is accepted.\\nbut when I try to submit, it shows wrong answer, \\nalso I noticed that after submit, data set are different than question which leads to wrong answer.\\nIs anyone faced same problem, or any solution ?"
                    },
                    {
                        "username": "Stas_Hlova",
                        "content": "SELECT id\\nFROM Weather weather \\nWHERE weather.temperature > (SELECT w1.temperature\\n                            FROM Weather w1\\n                            WHERE w1.recordDate = SUBDATE(weather.recordDate, INTERVAL 1 DAY)\\n                            LIMIT 1);\\n"
                    },
                    {
                        "username": "Ravi_ranjan_itz",
                        "content": "Hey guys plz help\\nselect x.id from\\n    (select w.*,\\n    lag(temperature,1,0) over(order by id) as prev_temp\\n    from weather w) as x \\n    where x.temperature> x.prev_temp;\\n\\n"
                    },
                    {
                        "username": "tantheidiot",
                        "content": " `with cte AS (SELECT id, recordDate, temperature, LAG(recordDate, 1) OVER (ORDER BY recordDate ASC) pre_date, LAG(temperature, 1) OVER (ORDER BY recordDate ASC) t\\nFROM Weather)\\n\\nselect id FROM cte\\nWHERE temperature > t\\nAND DATE_SUB(recordDate, INTERVAL 1 DAY) = pre_date;`"
                    },
                    {
                        "username": "Chaudhary_Anmol",
                        "content": "try this one \\nselect id  from Weather w1 where temperature - (select temperature from weather where recordDate = w1.recordDate-1)>0 "
                    },
                    {
                        "username": "pinky_adhikari1996",
                        "content": "SELECT id\\nFROM\\n(\\nSELECT id, recordDate, temperature , LAG(temperature,1) OVER (ORDER BY recordDate) AS yesterday_temp, LAG(recordDate,1) OVER (ORDER BY recordDate) AS prev_date\\n\\nFROM Weather\\n) AS temp_table\\n\\nWHERE temperature>yesterday_temp AND DATEDIFF(day,prev_date,recordDate)=1"
                    },
                    {
                        "username": "Himanshu_sansanwal",
                        "content": "select matrix.id from (select Weather.*, lag(temperature,1,null) over(order by recordDate asc) as prev_temp from Weather) as matrix \\nwhere prev_temp is not null and temperature > prev_temp\\n\\n"
                    },
                    {
                        "username": "user1388JN",
                        "content": "Can anyone help ! \\n\\nwhy the below code is not working. \\nit is working for case1 and not for case2 \\n\\n\\n\\nwith table1 as \\n(select *, \\nlag(temperature) over (order by recordDate) as previoustemp\\nfrom Weather)\\n\\nselect id\\nfrom table1\\nwhere temperature > previoustemp;"
                    },
                    {
                        "username": "andrewlawrenceevans",
                        "content": "Beats 90%!\\n\\nSELECT w2.id\\nFROM (\\n    SELECT id, recordDate, temperature, \\n    ROW_NUMBER() OVER(ORDER BY recordDate) as row_id\\n    FROM Weather\\n) w1\\nINNER JOIN (\\n    SELECT id, recordDate, temperature, \\n    ROW_NUMBER() OVER(ORDER BY recordDate) as row_id\\n    FROM Weather\\n) w2\\nON w1.row_id+1 = w2.row_id\\nWHERE w1.temperature < w2.temperature AND DATEDIFF(w2.recordDate, w1.recordDate)=1\\n"
                    },
                    {
                        "username": "karthiknandiraju",
                        "content": "\nSELECT\n    weather.id AS 'Id'\nFROM\n    weather\n        JOIN\n    weather w ON DATEDIFF(day, weather.RecordDate, w.RecordDate) = -1\n        AND weather.Temperature > w.Temperature;\n\n/* Please do not use +1 but use -1 */"
                    }
                ]
            },
            {
                "id": 1759853,
                "content": [
                    {
                        "username": "DhruvitModi",
                        "content": "Is there any issue with Submit, because while Run the code it is accepted.\\nbut when I try to submit, it shows wrong answer, \\nalso I noticed that after submit, data set are different than question which leads to wrong answer.\\nIs anyone faced same problem, or any solution ?"
                    },
                    {
                        "username": "Stas_Hlova",
                        "content": "SELECT id\\nFROM Weather weather \\nWHERE weather.temperature > (SELECT w1.temperature\\n                            FROM Weather w1\\n                            WHERE w1.recordDate = SUBDATE(weather.recordDate, INTERVAL 1 DAY)\\n                            LIMIT 1);\\n"
                    },
                    {
                        "username": "Ravi_ranjan_itz",
                        "content": "Hey guys plz help\\nselect x.id from\\n    (select w.*,\\n    lag(temperature,1,0) over(order by id) as prev_temp\\n    from weather w) as x \\n    where x.temperature> x.prev_temp;\\n\\n"
                    },
                    {
                        "username": "tantheidiot",
                        "content": " `with cte AS (SELECT id, recordDate, temperature, LAG(recordDate, 1) OVER (ORDER BY recordDate ASC) pre_date, LAG(temperature, 1) OVER (ORDER BY recordDate ASC) t\\nFROM Weather)\\n\\nselect id FROM cte\\nWHERE temperature > t\\nAND DATE_SUB(recordDate, INTERVAL 1 DAY) = pre_date;`"
                    },
                    {
                        "username": "Chaudhary_Anmol",
                        "content": "try this one \\nselect id  from Weather w1 where temperature - (select temperature from weather where recordDate = w1.recordDate-1)>0 "
                    },
                    {
                        "username": "pinky_adhikari1996",
                        "content": "SELECT id\\nFROM\\n(\\nSELECT id, recordDate, temperature , LAG(temperature,1) OVER (ORDER BY recordDate) AS yesterday_temp, LAG(recordDate,1) OVER (ORDER BY recordDate) AS prev_date\\n\\nFROM Weather\\n) AS temp_table\\n\\nWHERE temperature>yesterday_temp AND DATEDIFF(day,prev_date,recordDate)=1"
                    },
                    {
                        "username": "Himanshu_sansanwal",
                        "content": "select matrix.id from (select Weather.*, lag(temperature,1,null) over(order by recordDate asc) as prev_temp from Weather) as matrix \\nwhere prev_temp is not null and temperature > prev_temp\\n\\n"
                    },
                    {
                        "username": "user1388JN",
                        "content": "Can anyone help ! \\n\\nwhy the below code is not working. \\nit is working for case1 and not for case2 \\n\\n\\n\\nwith table1 as \\n(select *, \\nlag(temperature) over (order by recordDate) as previoustemp\\nfrom Weather)\\n\\nselect id\\nfrom table1\\nwhere temperature > previoustemp;"
                    },
                    {
                        "username": "andrewlawrenceevans",
                        "content": "Beats 90%!\\n\\nSELECT w2.id\\nFROM (\\n    SELECT id, recordDate, temperature, \\n    ROW_NUMBER() OVER(ORDER BY recordDate) as row_id\\n    FROM Weather\\n) w1\\nINNER JOIN (\\n    SELECT id, recordDate, temperature, \\n    ROW_NUMBER() OVER(ORDER BY recordDate) as row_id\\n    FROM Weather\\n) w2\\nON w1.row_id+1 = w2.row_id\\nWHERE w1.temperature < w2.temperature AND DATEDIFF(w2.recordDate, w1.recordDate)=1\\n"
                    },
                    {
                        "username": "karthiknandiraju",
                        "content": "\nSELECT\n    weather.id AS 'Id'\nFROM\n    weather\n        JOIN\n    weather w ON DATEDIFF(day, weather.RecordDate, w.RecordDate) = -1\n        AND weather.Temperature > w.Temperature;\n\n/* Please do not use +1 but use -1 */"
                    }
                ]
            },
            {
                "id": 1756131,
                "content": [
                    {
                        "username": "DhruvitModi",
                        "content": "Is there any issue with Submit, because while Run the code it is accepted.\\nbut when I try to submit, it shows wrong answer, \\nalso I noticed that after submit, data set are different than question which leads to wrong answer.\\nIs anyone faced same problem, or any solution ?"
                    },
                    {
                        "username": "Stas_Hlova",
                        "content": "SELECT id\\nFROM Weather weather \\nWHERE weather.temperature > (SELECT w1.temperature\\n                            FROM Weather w1\\n                            WHERE w1.recordDate = SUBDATE(weather.recordDate, INTERVAL 1 DAY)\\n                            LIMIT 1);\\n"
                    },
                    {
                        "username": "Ravi_ranjan_itz",
                        "content": "Hey guys plz help\\nselect x.id from\\n    (select w.*,\\n    lag(temperature,1,0) over(order by id) as prev_temp\\n    from weather w) as x \\n    where x.temperature> x.prev_temp;\\n\\n"
                    },
                    {
                        "username": "tantheidiot",
                        "content": " `with cte AS (SELECT id, recordDate, temperature, LAG(recordDate, 1) OVER (ORDER BY recordDate ASC) pre_date, LAG(temperature, 1) OVER (ORDER BY recordDate ASC) t\\nFROM Weather)\\n\\nselect id FROM cte\\nWHERE temperature > t\\nAND DATE_SUB(recordDate, INTERVAL 1 DAY) = pre_date;`"
                    },
                    {
                        "username": "Chaudhary_Anmol",
                        "content": "try this one \\nselect id  from Weather w1 where temperature - (select temperature from weather where recordDate = w1.recordDate-1)>0 "
                    },
                    {
                        "username": "pinky_adhikari1996",
                        "content": "SELECT id\\nFROM\\n(\\nSELECT id, recordDate, temperature , LAG(temperature,1) OVER (ORDER BY recordDate) AS yesterday_temp, LAG(recordDate,1) OVER (ORDER BY recordDate) AS prev_date\\n\\nFROM Weather\\n) AS temp_table\\n\\nWHERE temperature>yesterday_temp AND DATEDIFF(day,prev_date,recordDate)=1"
                    },
                    {
                        "username": "Himanshu_sansanwal",
                        "content": "select matrix.id from (select Weather.*, lag(temperature,1,null) over(order by recordDate asc) as prev_temp from Weather) as matrix \\nwhere prev_temp is not null and temperature > prev_temp\\n\\n"
                    },
                    {
                        "username": "user1388JN",
                        "content": "Can anyone help ! \\n\\nwhy the below code is not working. \\nit is working for case1 and not for case2 \\n\\n\\n\\nwith table1 as \\n(select *, \\nlag(temperature) over (order by recordDate) as previoustemp\\nfrom Weather)\\n\\nselect id\\nfrom table1\\nwhere temperature > previoustemp;"
                    },
                    {
                        "username": "andrewlawrenceevans",
                        "content": "Beats 90%!\\n\\nSELECT w2.id\\nFROM (\\n    SELECT id, recordDate, temperature, \\n    ROW_NUMBER() OVER(ORDER BY recordDate) as row_id\\n    FROM Weather\\n) w1\\nINNER JOIN (\\n    SELECT id, recordDate, temperature, \\n    ROW_NUMBER() OVER(ORDER BY recordDate) as row_id\\n    FROM Weather\\n) w2\\nON w1.row_id+1 = w2.row_id\\nWHERE w1.temperature < w2.temperature AND DATEDIFF(w2.recordDate, w1.recordDate)=1\\n"
                    },
                    {
                        "username": "karthiknandiraju",
                        "content": "\nSELECT\n    weather.id AS 'Id'\nFROM\n    weather\n        JOIN\n    weather w ON DATEDIFF(day, weather.RecordDate, w.RecordDate) = -1\n        AND weather.Temperature > w.Temperature;\n\n/* Please do not use +1 but use -1 */"
                    }
                ]
            },
            {
                "id": 1753088,
                "content": [
                    {
                        "username": "muz97",
                        "content": "it fails in case 13\\n`SELECT id FROM Weather WHERE id IN (SELECT CASE\\nWHEN LAG(temperature) OVER (ORDER BY recordDate) < temperature\\nAND recordDate - LAG(recordDate) OVER (ORDER BY recordDate) = 1\\nTHEN id\\nEND as Id\\nFROM Weather ORDER BY recordDate) ORDER BY id` "
                    },
                    {
                        "username": "user5490oS",
                        "content": "SELECT w2.id from Weather w1 JOIN Weather w2\\nON w2.temperature > w1.temperature AND\\ndatediff(w2.recordDate,w1.recordDate) = 1;"
                    },
                    {
                        "username": "IamAJ22",
                        "content": "Use subdate(date,1) instead of date-1\\n `select w.id as id from weather w inner join weather ww on subdate(w.recorddate,1)=ww.recorddate\\nwhere w.temperature>ww.temperature;`"
                    },
                    {
                        "username": "user0556G",
                        "content": "lightning fast :)\\n `select a.id from weather a,weather b where date_sub(a.recordDate, interval 1 day) = b.recordDate and a.temperature>b.temperature`"
                    },
                    {
                        "username": "camellie",
                        "content": "Hi, the query below results in a Runtime Error: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \\'\\' at line 4\\n\\nSELECT today.id AS id\\nFROM weather yesterday, weather today\\nWHERE yesterday.recorddate + INTERVAL \\'1 DAY\\' =  today.recorddate \\nAND yesterday.temperature < today.temperature;\\n\\nBut it works as expected locally. I don\\'t understand why LeetCode doesn\\'t accept it. Please help"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "SELECT DISTINCT T2.id FROM Weather T1 inner join Weather T2 \\nWHERE T2.temperature>T1.temperature\\nAND DATEDIFF(T2.recordDate,T1.recordDate)=1\\nAND T2.id!=T1.id"
                    },
                    {
                        "username": "rishav4u7",
                        "content": "Why this code is not working for 14th test case?\\nselect w1.id from weather w1 join weather w2  on w1.recordDate=w2.recordDate+1 where w1.temperature>w2.temperature;\\n\\nBut the below code is working though both looks same except datediff\\n\\nselect w1.id from weather w1 join weather w2  on Datediff(w1.recordDate,w2.recordDate)=1 where w1.temperature>w2.temperature;\\n\\n"
                    },
                    {
                        "username": "andyjackson393",
                        "content": "Working Solution\\n\\n```\\nWITH CTE1(id, recordDate, temperature, lag_temp, lag_date) AS (\\n    SELECT *, lag(temperature) OVER(ORDER BY recordDate) lag_temp,\\n    lag(recordDate) OVER(ORDER BY recordDate) as lag_date\\n    FROM Weather\\n)\\nSELECT id\\nFROM CTE1\\nWHERE temperature > lag_temp and ABS(DATEDIFF(lag_date, recordDate)) = 1\\n```"
                    },
                    {
                        "username": "Srivastava_Swapnil",
                        "content": "select Id from weather w\\nwhere temperature > (select temperature from weather x\\nwhere x.id+1=w.id\\nlimit 1);\\nthis is much easier to understand"
                    },
                    {
                        "username": "navitadev22",
                        "content": "Why my query is  not recognizing the Weather Table..?\\n\\nSELECT w2.id \\nFROM Weather AS w1 JOIN Weather AS w2\\nON DATEDIFF(w1.recordDate, w2.recordDate) = -1\\nWHERE w2.temperature > w1.temperature;\\n\\nI\\'m getting Invalid Testcase\\n\\'Weather\\'"
                    }
                ]
            },
            {
                "id": 1751063,
                "content": [
                    {
                        "username": "muz97",
                        "content": "it fails in case 13\\n`SELECT id FROM Weather WHERE id IN (SELECT CASE\\nWHEN LAG(temperature) OVER (ORDER BY recordDate) < temperature\\nAND recordDate - LAG(recordDate) OVER (ORDER BY recordDate) = 1\\nTHEN id\\nEND as Id\\nFROM Weather ORDER BY recordDate) ORDER BY id` "
                    },
                    {
                        "username": "user5490oS",
                        "content": "SELECT w2.id from Weather w1 JOIN Weather w2\\nON w2.temperature > w1.temperature AND\\ndatediff(w2.recordDate,w1.recordDate) = 1;"
                    },
                    {
                        "username": "IamAJ22",
                        "content": "Use subdate(date,1) instead of date-1\\n `select w.id as id from weather w inner join weather ww on subdate(w.recorddate,1)=ww.recorddate\\nwhere w.temperature>ww.temperature;`"
                    },
                    {
                        "username": "user0556G",
                        "content": "lightning fast :)\\n `select a.id from weather a,weather b where date_sub(a.recordDate, interval 1 day) = b.recordDate and a.temperature>b.temperature`"
                    },
                    {
                        "username": "camellie",
                        "content": "Hi, the query below results in a Runtime Error: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \\'\\' at line 4\\n\\nSELECT today.id AS id\\nFROM weather yesterday, weather today\\nWHERE yesterday.recorddate + INTERVAL \\'1 DAY\\' =  today.recorddate \\nAND yesterday.temperature < today.temperature;\\n\\nBut it works as expected locally. I don\\'t understand why LeetCode doesn\\'t accept it. Please help"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "SELECT DISTINCT T2.id FROM Weather T1 inner join Weather T2 \\nWHERE T2.temperature>T1.temperature\\nAND DATEDIFF(T2.recordDate,T1.recordDate)=1\\nAND T2.id!=T1.id"
                    },
                    {
                        "username": "rishav4u7",
                        "content": "Why this code is not working for 14th test case?\\nselect w1.id from weather w1 join weather w2  on w1.recordDate=w2.recordDate+1 where w1.temperature>w2.temperature;\\n\\nBut the below code is working though both looks same except datediff\\n\\nselect w1.id from weather w1 join weather w2  on Datediff(w1.recordDate,w2.recordDate)=1 where w1.temperature>w2.temperature;\\n\\n"
                    },
                    {
                        "username": "andyjackson393",
                        "content": "Working Solution\\n\\n```\\nWITH CTE1(id, recordDate, temperature, lag_temp, lag_date) AS (\\n    SELECT *, lag(temperature) OVER(ORDER BY recordDate) lag_temp,\\n    lag(recordDate) OVER(ORDER BY recordDate) as lag_date\\n    FROM Weather\\n)\\nSELECT id\\nFROM CTE1\\nWHERE temperature > lag_temp and ABS(DATEDIFF(lag_date, recordDate)) = 1\\n```"
                    },
                    {
                        "username": "Srivastava_Swapnil",
                        "content": "select Id from weather w\\nwhere temperature > (select temperature from weather x\\nwhere x.id+1=w.id\\nlimit 1);\\nthis is much easier to understand"
                    },
                    {
                        "username": "navitadev22",
                        "content": "Why my query is  not recognizing the Weather Table..?\\n\\nSELECT w2.id \\nFROM Weather AS w1 JOIN Weather AS w2\\nON DATEDIFF(w1.recordDate, w2.recordDate) = -1\\nWHERE w2.temperature > w1.temperature;\\n\\nI\\'m getting Invalid Testcase\\n\\'Weather\\'"
                    }
                ]
            },
            {
                "id": 1750756,
                "content": [
                    {
                        "username": "muz97",
                        "content": "it fails in case 13\\n`SELECT id FROM Weather WHERE id IN (SELECT CASE\\nWHEN LAG(temperature) OVER (ORDER BY recordDate) < temperature\\nAND recordDate - LAG(recordDate) OVER (ORDER BY recordDate) = 1\\nTHEN id\\nEND as Id\\nFROM Weather ORDER BY recordDate) ORDER BY id` "
                    },
                    {
                        "username": "user5490oS",
                        "content": "SELECT w2.id from Weather w1 JOIN Weather w2\\nON w2.temperature > w1.temperature AND\\ndatediff(w2.recordDate,w1.recordDate) = 1;"
                    },
                    {
                        "username": "IamAJ22",
                        "content": "Use subdate(date,1) instead of date-1\\n `select w.id as id from weather w inner join weather ww on subdate(w.recorddate,1)=ww.recorddate\\nwhere w.temperature>ww.temperature;`"
                    },
                    {
                        "username": "user0556G",
                        "content": "lightning fast :)\\n `select a.id from weather a,weather b where date_sub(a.recordDate, interval 1 day) = b.recordDate and a.temperature>b.temperature`"
                    },
                    {
                        "username": "camellie",
                        "content": "Hi, the query below results in a Runtime Error: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \\'\\' at line 4\\n\\nSELECT today.id AS id\\nFROM weather yesterday, weather today\\nWHERE yesterday.recorddate + INTERVAL \\'1 DAY\\' =  today.recorddate \\nAND yesterday.temperature < today.temperature;\\n\\nBut it works as expected locally. I don\\'t understand why LeetCode doesn\\'t accept it. Please help"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "SELECT DISTINCT T2.id FROM Weather T1 inner join Weather T2 \\nWHERE T2.temperature>T1.temperature\\nAND DATEDIFF(T2.recordDate,T1.recordDate)=1\\nAND T2.id!=T1.id"
                    },
                    {
                        "username": "rishav4u7",
                        "content": "Why this code is not working for 14th test case?\\nselect w1.id from weather w1 join weather w2  on w1.recordDate=w2.recordDate+1 where w1.temperature>w2.temperature;\\n\\nBut the below code is working though both looks same except datediff\\n\\nselect w1.id from weather w1 join weather w2  on Datediff(w1.recordDate,w2.recordDate)=1 where w1.temperature>w2.temperature;\\n\\n"
                    },
                    {
                        "username": "andyjackson393",
                        "content": "Working Solution\\n\\n```\\nWITH CTE1(id, recordDate, temperature, lag_temp, lag_date) AS (\\n    SELECT *, lag(temperature) OVER(ORDER BY recordDate) lag_temp,\\n    lag(recordDate) OVER(ORDER BY recordDate) as lag_date\\n    FROM Weather\\n)\\nSELECT id\\nFROM CTE1\\nWHERE temperature > lag_temp and ABS(DATEDIFF(lag_date, recordDate)) = 1\\n```"
                    },
                    {
                        "username": "Srivastava_Swapnil",
                        "content": "select Id from weather w\\nwhere temperature > (select temperature from weather x\\nwhere x.id+1=w.id\\nlimit 1);\\nthis is much easier to understand"
                    },
                    {
                        "username": "navitadev22",
                        "content": "Why my query is  not recognizing the Weather Table..?\\n\\nSELECT w2.id \\nFROM Weather AS w1 JOIN Weather AS w2\\nON DATEDIFF(w1.recordDate, w2.recordDate) = -1\\nWHERE w2.temperature > w1.temperature;\\n\\nI\\'m getting Invalid Testcase\\n\\'Weather\\'"
                    }
                ]
            },
            {
                "id": 1748574,
                "content": [
                    {
                        "username": "muz97",
                        "content": "it fails in case 13\\n`SELECT id FROM Weather WHERE id IN (SELECT CASE\\nWHEN LAG(temperature) OVER (ORDER BY recordDate) < temperature\\nAND recordDate - LAG(recordDate) OVER (ORDER BY recordDate) = 1\\nTHEN id\\nEND as Id\\nFROM Weather ORDER BY recordDate) ORDER BY id` "
                    },
                    {
                        "username": "user5490oS",
                        "content": "SELECT w2.id from Weather w1 JOIN Weather w2\\nON w2.temperature > w1.temperature AND\\ndatediff(w2.recordDate,w1.recordDate) = 1;"
                    },
                    {
                        "username": "IamAJ22",
                        "content": "Use subdate(date,1) instead of date-1\\n `select w.id as id from weather w inner join weather ww on subdate(w.recorddate,1)=ww.recorddate\\nwhere w.temperature>ww.temperature;`"
                    },
                    {
                        "username": "user0556G",
                        "content": "lightning fast :)\\n `select a.id from weather a,weather b where date_sub(a.recordDate, interval 1 day) = b.recordDate and a.temperature>b.temperature`"
                    },
                    {
                        "username": "camellie",
                        "content": "Hi, the query below results in a Runtime Error: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \\'\\' at line 4\\n\\nSELECT today.id AS id\\nFROM weather yesterday, weather today\\nWHERE yesterday.recorddate + INTERVAL \\'1 DAY\\' =  today.recorddate \\nAND yesterday.temperature < today.temperature;\\n\\nBut it works as expected locally. I don\\'t understand why LeetCode doesn\\'t accept it. Please help"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "SELECT DISTINCT T2.id FROM Weather T1 inner join Weather T2 \\nWHERE T2.temperature>T1.temperature\\nAND DATEDIFF(T2.recordDate,T1.recordDate)=1\\nAND T2.id!=T1.id"
                    },
                    {
                        "username": "rishav4u7",
                        "content": "Why this code is not working for 14th test case?\\nselect w1.id from weather w1 join weather w2  on w1.recordDate=w2.recordDate+1 where w1.temperature>w2.temperature;\\n\\nBut the below code is working though both looks same except datediff\\n\\nselect w1.id from weather w1 join weather w2  on Datediff(w1.recordDate,w2.recordDate)=1 where w1.temperature>w2.temperature;\\n\\n"
                    },
                    {
                        "username": "andyjackson393",
                        "content": "Working Solution\\n\\n```\\nWITH CTE1(id, recordDate, temperature, lag_temp, lag_date) AS (\\n    SELECT *, lag(temperature) OVER(ORDER BY recordDate) lag_temp,\\n    lag(recordDate) OVER(ORDER BY recordDate) as lag_date\\n    FROM Weather\\n)\\nSELECT id\\nFROM CTE1\\nWHERE temperature > lag_temp and ABS(DATEDIFF(lag_date, recordDate)) = 1\\n```"
                    },
                    {
                        "username": "Srivastava_Swapnil",
                        "content": "select Id from weather w\\nwhere temperature > (select temperature from weather x\\nwhere x.id+1=w.id\\nlimit 1);\\nthis is much easier to understand"
                    },
                    {
                        "username": "navitadev22",
                        "content": "Why my query is  not recognizing the Weather Table..?\\n\\nSELECT w2.id \\nFROM Weather AS w1 JOIN Weather AS w2\\nON DATEDIFF(w1.recordDate, w2.recordDate) = -1\\nWHERE w2.temperature > w1.temperature;\\n\\nI\\'m getting Invalid Testcase\\n\\'Weather\\'"
                    }
                ]
            },
            {
                "id": 1745416,
                "content": [
                    {
                        "username": "muz97",
                        "content": "it fails in case 13\\n`SELECT id FROM Weather WHERE id IN (SELECT CASE\\nWHEN LAG(temperature) OVER (ORDER BY recordDate) < temperature\\nAND recordDate - LAG(recordDate) OVER (ORDER BY recordDate) = 1\\nTHEN id\\nEND as Id\\nFROM Weather ORDER BY recordDate) ORDER BY id` "
                    },
                    {
                        "username": "user5490oS",
                        "content": "SELECT w2.id from Weather w1 JOIN Weather w2\\nON w2.temperature > w1.temperature AND\\ndatediff(w2.recordDate,w1.recordDate) = 1;"
                    },
                    {
                        "username": "IamAJ22",
                        "content": "Use subdate(date,1) instead of date-1\\n `select w.id as id from weather w inner join weather ww on subdate(w.recorddate,1)=ww.recorddate\\nwhere w.temperature>ww.temperature;`"
                    },
                    {
                        "username": "user0556G",
                        "content": "lightning fast :)\\n `select a.id from weather a,weather b where date_sub(a.recordDate, interval 1 day) = b.recordDate and a.temperature>b.temperature`"
                    },
                    {
                        "username": "camellie",
                        "content": "Hi, the query below results in a Runtime Error: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \\'\\' at line 4\\n\\nSELECT today.id AS id\\nFROM weather yesterday, weather today\\nWHERE yesterday.recorddate + INTERVAL \\'1 DAY\\' =  today.recorddate \\nAND yesterday.temperature < today.temperature;\\n\\nBut it works as expected locally. I don\\'t understand why LeetCode doesn\\'t accept it. Please help"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "SELECT DISTINCT T2.id FROM Weather T1 inner join Weather T2 \\nWHERE T2.temperature>T1.temperature\\nAND DATEDIFF(T2.recordDate,T1.recordDate)=1\\nAND T2.id!=T1.id"
                    },
                    {
                        "username": "rishav4u7",
                        "content": "Why this code is not working for 14th test case?\\nselect w1.id from weather w1 join weather w2  on w1.recordDate=w2.recordDate+1 where w1.temperature>w2.temperature;\\n\\nBut the below code is working though both looks same except datediff\\n\\nselect w1.id from weather w1 join weather w2  on Datediff(w1.recordDate,w2.recordDate)=1 where w1.temperature>w2.temperature;\\n\\n"
                    },
                    {
                        "username": "andyjackson393",
                        "content": "Working Solution\\n\\n```\\nWITH CTE1(id, recordDate, temperature, lag_temp, lag_date) AS (\\n    SELECT *, lag(temperature) OVER(ORDER BY recordDate) lag_temp,\\n    lag(recordDate) OVER(ORDER BY recordDate) as lag_date\\n    FROM Weather\\n)\\nSELECT id\\nFROM CTE1\\nWHERE temperature > lag_temp and ABS(DATEDIFF(lag_date, recordDate)) = 1\\n```"
                    },
                    {
                        "username": "Srivastava_Swapnil",
                        "content": "select Id from weather w\\nwhere temperature > (select temperature from weather x\\nwhere x.id+1=w.id\\nlimit 1);\\nthis is much easier to understand"
                    },
                    {
                        "username": "navitadev22",
                        "content": "Why my query is  not recognizing the Weather Table..?\\n\\nSELECT w2.id \\nFROM Weather AS w1 JOIN Weather AS w2\\nON DATEDIFF(w1.recordDate, w2.recordDate) = -1\\nWHERE w2.temperature > w1.temperature;\\n\\nI\\'m getting Invalid Testcase\\n\\'Weather\\'"
                    }
                ]
            },
            {
                "id": 1745394,
                "content": [
                    {
                        "username": "muz97",
                        "content": "it fails in case 13\\n`SELECT id FROM Weather WHERE id IN (SELECT CASE\\nWHEN LAG(temperature) OVER (ORDER BY recordDate) < temperature\\nAND recordDate - LAG(recordDate) OVER (ORDER BY recordDate) = 1\\nTHEN id\\nEND as Id\\nFROM Weather ORDER BY recordDate) ORDER BY id` "
                    },
                    {
                        "username": "user5490oS",
                        "content": "SELECT w2.id from Weather w1 JOIN Weather w2\\nON w2.temperature > w1.temperature AND\\ndatediff(w2.recordDate,w1.recordDate) = 1;"
                    },
                    {
                        "username": "IamAJ22",
                        "content": "Use subdate(date,1) instead of date-1\\n `select w.id as id from weather w inner join weather ww on subdate(w.recorddate,1)=ww.recorddate\\nwhere w.temperature>ww.temperature;`"
                    },
                    {
                        "username": "user0556G",
                        "content": "lightning fast :)\\n `select a.id from weather a,weather b where date_sub(a.recordDate, interval 1 day) = b.recordDate and a.temperature>b.temperature`"
                    },
                    {
                        "username": "camellie",
                        "content": "Hi, the query below results in a Runtime Error: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \\'\\' at line 4\\n\\nSELECT today.id AS id\\nFROM weather yesterday, weather today\\nWHERE yesterday.recorddate + INTERVAL \\'1 DAY\\' =  today.recorddate \\nAND yesterday.temperature < today.temperature;\\n\\nBut it works as expected locally. I don\\'t understand why LeetCode doesn\\'t accept it. Please help"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "SELECT DISTINCT T2.id FROM Weather T1 inner join Weather T2 \\nWHERE T2.temperature>T1.temperature\\nAND DATEDIFF(T2.recordDate,T1.recordDate)=1\\nAND T2.id!=T1.id"
                    },
                    {
                        "username": "rishav4u7",
                        "content": "Why this code is not working for 14th test case?\\nselect w1.id from weather w1 join weather w2  on w1.recordDate=w2.recordDate+1 where w1.temperature>w2.temperature;\\n\\nBut the below code is working though both looks same except datediff\\n\\nselect w1.id from weather w1 join weather w2  on Datediff(w1.recordDate,w2.recordDate)=1 where w1.temperature>w2.temperature;\\n\\n"
                    },
                    {
                        "username": "andyjackson393",
                        "content": "Working Solution\\n\\n```\\nWITH CTE1(id, recordDate, temperature, lag_temp, lag_date) AS (\\n    SELECT *, lag(temperature) OVER(ORDER BY recordDate) lag_temp,\\n    lag(recordDate) OVER(ORDER BY recordDate) as lag_date\\n    FROM Weather\\n)\\nSELECT id\\nFROM CTE1\\nWHERE temperature > lag_temp and ABS(DATEDIFF(lag_date, recordDate)) = 1\\n```"
                    },
                    {
                        "username": "Srivastava_Swapnil",
                        "content": "select Id from weather w\\nwhere temperature > (select temperature from weather x\\nwhere x.id+1=w.id\\nlimit 1);\\nthis is much easier to understand"
                    },
                    {
                        "username": "navitadev22",
                        "content": "Why my query is  not recognizing the Weather Table..?\\n\\nSELECT w2.id \\nFROM Weather AS w1 JOIN Weather AS w2\\nON DATEDIFF(w1.recordDate, w2.recordDate) = -1\\nWHERE w2.temperature > w1.temperature;\\n\\nI\\'m getting Invalid Testcase\\n\\'Weather\\'"
                    }
                ]
            },
            {
                "id": 1744340,
                "content": [
                    {
                        "username": "muz97",
                        "content": "it fails in case 13\\n`SELECT id FROM Weather WHERE id IN (SELECT CASE\\nWHEN LAG(temperature) OVER (ORDER BY recordDate) < temperature\\nAND recordDate - LAG(recordDate) OVER (ORDER BY recordDate) = 1\\nTHEN id\\nEND as Id\\nFROM Weather ORDER BY recordDate) ORDER BY id` "
                    },
                    {
                        "username": "user5490oS",
                        "content": "SELECT w2.id from Weather w1 JOIN Weather w2\\nON w2.temperature > w1.temperature AND\\ndatediff(w2.recordDate,w1.recordDate) = 1;"
                    },
                    {
                        "username": "IamAJ22",
                        "content": "Use subdate(date,1) instead of date-1\\n `select w.id as id from weather w inner join weather ww on subdate(w.recorddate,1)=ww.recorddate\\nwhere w.temperature>ww.temperature;`"
                    },
                    {
                        "username": "user0556G",
                        "content": "lightning fast :)\\n `select a.id from weather a,weather b where date_sub(a.recordDate, interval 1 day) = b.recordDate and a.temperature>b.temperature`"
                    },
                    {
                        "username": "camellie",
                        "content": "Hi, the query below results in a Runtime Error: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \\'\\' at line 4\\n\\nSELECT today.id AS id\\nFROM weather yesterday, weather today\\nWHERE yesterday.recorddate + INTERVAL \\'1 DAY\\' =  today.recorddate \\nAND yesterday.temperature < today.temperature;\\n\\nBut it works as expected locally. I don\\'t understand why LeetCode doesn\\'t accept it. Please help"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "SELECT DISTINCT T2.id FROM Weather T1 inner join Weather T2 \\nWHERE T2.temperature>T1.temperature\\nAND DATEDIFF(T2.recordDate,T1.recordDate)=1\\nAND T2.id!=T1.id"
                    },
                    {
                        "username": "rishav4u7",
                        "content": "Why this code is not working for 14th test case?\\nselect w1.id from weather w1 join weather w2  on w1.recordDate=w2.recordDate+1 where w1.temperature>w2.temperature;\\n\\nBut the below code is working though both looks same except datediff\\n\\nselect w1.id from weather w1 join weather w2  on Datediff(w1.recordDate,w2.recordDate)=1 where w1.temperature>w2.temperature;\\n\\n"
                    },
                    {
                        "username": "andyjackson393",
                        "content": "Working Solution\\n\\n```\\nWITH CTE1(id, recordDate, temperature, lag_temp, lag_date) AS (\\n    SELECT *, lag(temperature) OVER(ORDER BY recordDate) lag_temp,\\n    lag(recordDate) OVER(ORDER BY recordDate) as lag_date\\n    FROM Weather\\n)\\nSELECT id\\nFROM CTE1\\nWHERE temperature > lag_temp and ABS(DATEDIFF(lag_date, recordDate)) = 1\\n```"
                    },
                    {
                        "username": "Srivastava_Swapnil",
                        "content": "select Id from weather w\\nwhere temperature > (select temperature from weather x\\nwhere x.id+1=w.id\\nlimit 1);\\nthis is much easier to understand"
                    },
                    {
                        "username": "navitadev22",
                        "content": "Why my query is  not recognizing the Weather Table..?\\n\\nSELECT w2.id \\nFROM Weather AS w1 JOIN Weather AS w2\\nON DATEDIFF(w1.recordDate, w2.recordDate) = -1\\nWHERE w2.temperature > w1.temperature;\\n\\nI\\'m getting Invalid Testcase\\n\\'Weather\\'"
                    }
                ]
            },
            {
                "id": 1738091,
                "content": [
                    {
                        "username": "muz97",
                        "content": "it fails in case 13\\n`SELECT id FROM Weather WHERE id IN (SELECT CASE\\nWHEN LAG(temperature) OVER (ORDER BY recordDate) < temperature\\nAND recordDate - LAG(recordDate) OVER (ORDER BY recordDate) = 1\\nTHEN id\\nEND as Id\\nFROM Weather ORDER BY recordDate) ORDER BY id` "
                    },
                    {
                        "username": "user5490oS",
                        "content": "SELECT w2.id from Weather w1 JOIN Weather w2\\nON w2.temperature > w1.temperature AND\\ndatediff(w2.recordDate,w1.recordDate) = 1;"
                    },
                    {
                        "username": "IamAJ22",
                        "content": "Use subdate(date,1) instead of date-1\\n `select w.id as id from weather w inner join weather ww on subdate(w.recorddate,1)=ww.recorddate\\nwhere w.temperature>ww.temperature;`"
                    },
                    {
                        "username": "user0556G",
                        "content": "lightning fast :)\\n `select a.id from weather a,weather b where date_sub(a.recordDate, interval 1 day) = b.recordDate and a.temperature>b.temperature`"
                    },
                    {
                        "username": "camellie",
                        "content": "Hi, the query below results in a Runtime Error: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \\'\\' at line 4\\n\\nSELECT today.id AS id\\nFROM weather yesterday, weather today\\nWHERE yesterday.recorddate + INTERVAL \\'1 DAY\\' =  today.recorddate \\nAND yesterday.temperature < today.temperature;\\n\\nBut it works as expected locally. I don\\'t understand why LeetCode doesn\\'t accept it. Please help"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "SELECT DISTINCT T2.id FROM Weather T1 inner join Weather T2 \\nWHERE T2.temperature>T1.temperature\\nAND DATEDIFF(T2.recordDate,T1.recordDate)=1\\nAND T2.id!=T1.id"
                    },
                    {
                        "username": "rishav4u7",
                        "content": "Why this code is not working for 14th test case?\\nselect w1.id from weather w1 join weather w2  on w1.recordDate=w2.recordDate+1 where w1.temperature>w2.temperature;\\n\\nBut the below code is working though both looks same except datediff\\n\\nselect w1.id from weather w1 join weather w2  on Datediff(w1.recordDate,w2.recordDate)=1 where w1.temperature>w2.temperature;\\n\\n"
                    },
                    {
                        "username": "andyjackson393",
                        "content": "Working Solution\\n\\n```\\nWITH CTE1(id, recordDate, temperature, lag_temp, lag_date) AS (\\n    SELECT *, lag(temperature) OVER(ORDER BY recordDate) lag_temp,\\n    lag(recordDate) OVER(ORDER BY recordDate) as lag_date\\n    FROM Weather\\n)\\nSELECT id\\nFROM CTE1\\nWHERE temperature > lag_temp and ABS(DATEDIFF(lag_date, recordDate)) = 1\\n```"
                    },
                    {
                        "username": "Srivastava_Swapnil",
                        "content": "select Id from weather w\\nwhere temperature > (select temperature from weather x\\nwhere x.id+1=w.id\\nlimit 1);\\nthis is much easier to understand"
                    },
                    {
                        "username": "navitadev22",
                        "content": "Why my query is  not recognizing the Weather Table..?\\n\\nSELECT w2.id \\nFROM Weather AS w1 JOIN Weather AS w2\\nON DATEDIFF(w1.recordDate, w2.recordDate) = -1\\nWHERE w2.temperature > w1.temperature;\\n\\nI\\'m getting Invalid Testcase\\n\\'Weather\\'"
                    }
                ]
            },
            {
                "id": 1734474,
                "content": [
                    {
                        "username": "muz97",
                        "content": "it fails in case 13\\n`SELECT id FROM Weather WHERE id IN (SELECT CASE\\nWHEN LAG(temperature) OVER (ORDER BY recordDate) < temperature\\nAND recordDate - LAG(recordDate) OVER (ORDER BY recordDate) = 1\\nTHEN id\\nEND as Id\\nFROM Weather ORDER BY recordDate) ORDER BY id` "
                    },
                    {
                        "username": "user5490oS",
                        "content": "SELECT w2.id from Weather w1 JOIN Weather w2\\nON w2.temperature > w1.temperature AND\\ndatediff(w2.recordDate,w1.recordDate) = 1;"
                    },
                    {
                        "username": "IamAJ22",
                        "content": "Use subdate(date,1) instead of date-1\\n `select w.id as id from weather w inner join weather ww on subdate(w.recorddate,1)=ww.recorddate\\nwhere w.temperature>ww.temperature;`"
                    },
                    {
                        "username": "user0556G",
                        "content": "lightning fast :)\\n `select a.id from weather a,weather b where date_sub(a.recordDate, interval 1 day) = b.recordDate and a.temperature>b.temperature`"
                    },
                    {
                        "username": "camellie",
                        "content": "Hi, the query below results in a Runtime Error: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \\'\\' at line 4\\n\\nSELECT today.id AS id\\nFROM weather yesterday, weather today\\nWHERE yesterday.recorddate + INTERVAL \\'1 DAY\\' =  today.recorddate \\nAND yesterday.temperature < today.temperature;\\n\\nBut it works as expected locally. I don\\'t understand why LeetCode doesn\\'t accept it. Please help"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "SELECT DISTINCT T2.id FROM Weather T1 inner join Weather T2 \\nWHERE T2.temperature>T1.temperature\\nAND DATEDIFF(T2.recordDate,T1.recordDate)=1\\nAND T2.id!=T1.id"
                    },
                    {
                        "username": "rishav4u7",
                        "content": "Why this code is not working for 14th test case?\\nselect w1.id from weather w1 join weather w2  on w1.recordDate=w2.recordDate+1 where w1.temperature>w2.temperature;\\n\\nBut the below code is working though both looks same except datediff\\n\\nselect w1.id from weather w1 join weather w2  on Datediff(w1.recordDate,w2.recordDate)=1 where w1.temperature>w2.temperature;\\n\\n"
                    },
                    {
                        "username": "andyjackson393",
                        "content": "Working Solution\\n\\n```\\nWITH CTE1(id, recordDate, temperature, lag_temp, lag_date) AS (\\n    SELECT *, lag(temperature) OVER(ORDER BY recordDate) lag_temp,\\n    lag(recordDate) OVER(ORDER BY recordDate) as lag_date\\n    FROM Weather\\n)\\nSELECT id\\nFROM CTE1\\nWHERE temperature > lag_temp and ABS(DATEDIFF(lag_date, recordDate)) = 1\\n```"
                    },
                    {
                        "username": "Srivastava_Swapnil",
                        "content": "select Id from weather w\\nwhere temperature > (select temperature from weather x\\nwhere x.id+1=w.id\\nlimit 1);\\nthis is much easier to understand"
                    },
                    {
                        "username": "navitadev22",
                        "content": "Why my query is  not recognizing the Weather Table..?\\n\\nSELECT w2.id \\nFROM Weather AS w1 JOIN Weather AS w2\\nON DATEDIFF(w1.recordDate, w2.recordDate) = -1\\nWHERE w2.temperature > w1.temperature;\\n\\nI\\'m getting Invalid Testcase\\n\\'Weather\\'"
                    }
                ]
            },
            {
                "id": 1733674,
                "content": [
                    {
                        "username": "muz97",
                        "content": "it fails in case 13\\n`SELECT id FROM Weather WHERE id IN (SELECT CASE\\nWHEN LAG(temperature) OVER (ORDER BY recordDate) < temperature\\nAND recordDate - LAG(recordDate) OVER (ORDER BY recordDate) = 1\\nTHEN id\\nEND as Id\\nFROM Weather ORDER BY recordDate) ORDER BY id` "
                    },
                    {
                        "username": "user5490oS",
                        "content": "SELECT w2.id from Weather w1 JOIN Weather w2\\nON w2.temperature > w1.temperature AND\\ndatediff(w2.recordDate,w1.recordDate) = 1;"
                    },
                    {
                        "username": "IamAJ22",
                        "content": "Use subdate(date,1) instead of date-1\\n `select w.id as id from weather w inner join weather ww on subdate(w.recorddate,1)=ww.recorddate\\nwhere w.temperature>ww.temperature;`"
                    },
                    {
                        "username": "user0556G",
                        "content": "lightning fast :)\\n `select a.id from weather a,weather b where date_sub(a.recordDate, interval 1 day) = b.recordDate and a.temperature>b.temperature`"
                    },
                    {
                        "username": "camellie",
                        "content": "Hi, the query below results in a Runtime Error: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \\'\\' at line 4\\n\\nSELECT today.id AS id\\nFROM weather yesterday, weather today\\nWHERE yesterday.recorddate + INTERVAL \\'1 DAY\\' =  today.recorddate \\nAND yesterday.temperature < today.temperature;\\n\\nBut it works as expected locally. I don\\'t understand why LeetCode doesn\\'t accept it. Please help"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "SELECT DISTINCT T2.id FROM Weather T1 inner join Weather T2 \\nWHERE T2.temperature>T1.temperature\\nAND DATEDIFF(T2.recordDate,T1.recordDate)=1\\nAND T2.id!=T1.id"
                    },
                    {
                        "username": "rishav4u7",
                        "content": "Why this code is not working for 14th test case?\\nselect w1.id from weather w1 join weather w2  on w1.recordDate=w2.recordDate+1 where w1.temperature>w2.temperature;\\n\\nBut the below code is working though both looks same except datediff\\n\\nselect w1.id from weather w1 join weather w2  on Datediff(w1.recordDate,w2.recordDate)=1 where w1.temperature>w2.temperature;\\n\\n"
                    },
                    {
                        "username": "andyjackson393",
                        "content": "Working Solution\\n\\n```\\nWITH CTE1(id, recordDate, temperature, lag_temp, lag_date) AS (\\n    SELECT *, lag(temperature) OVER(ORDER BY recordDate) lag_temp,\\n    lag(recordDate) OVER(ORDER BY recordDate) as lag_date\\n    FROM Weather\\n)\\nSELECT id\\nFROM CTE1\\nWHERE temperature > lag_temp and ABS(DATEDIFF(lag_date, recordDate)) = 1\\n```"
                    },
                    {
                        "username": "Srivastava_Swapnil",
                        "content": "select Id from weather w\\nwhere temperature > (select temperature from weather x\\nwhere x.id+1=w.id\\nlimit 1);\\nthis is much easier to understand"
                    },
                    {
                        "username": "navitadev22",
                        "content": "Why my query is  not recognizing the Weather Table..?\\n\\nSELECT w2.id \\nFROM Weather AS w1 JOIN Weather AS w2\\nON DATEDIFF(w1.recordDate, w2.recordDate) = -1\\nWHERE w2.temperature > w1.temperature;\\n\\nI\\'m getting Invalid Testcase\\n\\'Weather\\'"
                    }
                ]
            },
            {
                "id": 1728823,
                "content": [
                    {
                        "username": "la1kshman",
                        "content": "| id | recordDate | temperature |\n| -- | ---------- | ----------- |\n| 1  | 2000-12-14 | 3           |\n| 2  | 2000-12-16 | 5           |\n\nFor above, I got Id ,2 as answer, but expected answer is null , why?\n"
                    },
                    {
                        "username": "yigit148",
                        "content": "# Write your MySQL query statement below\\nSELECT id \\nFROM Weather F \\nWHERE temperature > (SELECT temperature FROM Weather S WHERE F.recordDate = (S.recordDate+1))\\n\\ncan someone tell me why this doesnt work on testcase 13\\n\\n"
                    },
                    {
                        "username": "niks_gpt",
                        "content": "why is test case 13 getting failed?\\n\\nselect distinct w2.id as Id\\nfrom weather w1, weather w2\\nwhere w1.temperature < w2.temperature and w2.recorddate-1=w1.recorddate"
                    },
                    {
                        "username": "pankaj_kumar_01",
                        "content": "RecordDate\\'s Type is DATE, not a INT, you should consider it"
                    },
                    {
                        "username": "aminbasiran",
                        "content": "Can you tell me why this code wouldn\\'t work? (it actually worked however it didnt pass 2 test cases)\\n\\n `select id from\\n(select *, lag(temperature) over() as prev_temp from weather order by recordDate asc) \\nas new_table where\\ntemperature  > new_table.prev_temp `"
                    },
                    {
                        "username": "karanpeshwani7",
                        "content": "Why is this nested query wrong?\\n `select w1.id\\nfrom Weather as w1\\nwhere \\nw1.temperature > (select w2.temperature from Weather as w2 where w2.recordDate = (w1.recordDate - 1))`"
                    },
                    {
                        "username": "ahjimomo",
                        "content": "## Intuition\\nWe know that we need to compare the temperature of the current day and it\\'s preceding day to determine if it\\'s warmer for the current day. \\n\\nBased on the `Weather` table, we can see that both the `recordDate` and `id` are in order but use of `recordDate` will likely be a better option.\\n\\n## Approach\\n<b>Solution 1:</b>\\n- Using the `LAG()` function allows us to get the preceding value\\n- Integrate this with the `WITH` query to generate a new table\\n- Query for `Id` that has higher temperature than their precedence, and ensuring the difference in day is just 1 with `DATEDIFF()` function\\n\\n<b>Solution 2:</b>\\n- Extract the `Id` by comparing 2 same `Weather` tables as today `tdy` and yesterday `ytd`\\n- Query WHERE difference of day is 1 with `DATEDIFF()`\\n- AND `tdy.temperature` is higher than `ytd.temperature`"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select sq.id\\nfrom\\n(Select w.*, \\nlag(temperature) over(order by recordDate, id) as prev_temp,\\nlag(recordDate) over(order by recordDate, id) as prev_date\\nfrom weather w) sq\\nwhere sq.temperature > sq.prev_temp and datediff(sq.recordDate, sq.prev_date) = 1"
                    },
                    {
                        "username": "liutsewei",
                        "content": "SELECT w1.id\nFROM Weather w1\nLEFT JOIN Weather w2 ON DATEDIFF(w1.recordDate, w2.recordDate) = 1\nWHERE w1.temperature > w2.temperature"
                    },
                    {
                        "username": "Pritam_ath",
                        "content": "please tell me ...why am I not getting the right output?//\\n\\nselect w2.id  as Id from weather w1 , weather w2 \\nwhere w1.temperature < w2.temperature and w1.recorddate = w2.recorddate+1;"
                    },
                    {
                        "username": "hongseongeun39",
                        "content": "RecordDate\\'s Type is DATE, not a INT, you should consider it"
                    },
                    {
                        "username": "hongseongeun39",
                        "content": "Following Query is running successfully but cannot submit, what can I do for this issue?\\n\\nSELECT A.id AS id\\nFROM Weather AS A\\nINNER JOIN Weather AS B ON A.id = (B.id + 1)\\nWHERE A.temperature > B.temperature"
                    },
                    {
                        "username": "hongseongeun39",
                        "content": "I solved it through following query\\nLeetCode\\'s Problems should be accepted not only the sample question but also in several test cases \\n\\nSELECT A.id AS Id\\nFROM Weather AS A\\nINNER JOIN weather AS B ON DATE_SUB(A.recordDate, INTERVAL 1 DAY) = B.recordDate\\nWHERE A.temperature > B.temperature "
                    }
                ]
            },
            {
                "id": 1722522,
                "content": [
                    {
                        "username": "la1kshman",
                        "content": "| id | recordDate | temperature |\n| -- | ---------- | ----------- |\n| 1  | 2000-12-14 | 3           |\n| 2  | 2000-12-16 | 5           |\n\nFor above, I got Id ,2 as answer, but expected answer is null , why?\n"
                    },
                    {
                        "username": "yigit148",
                        "content": "# Write your MySQL query statement below\\nSELECT id \\nFROM Weather F \\nWHERE temperature > (SELECT temperature FROM Weather S WHERE F.recordDate = (S.recordDate+1))\\n\\ncan someone tell me why this doesnt work on testcase 13\\n\\n"
                    },
                    {
                        "username": "niks_gpt",
                        "content": "why is test case 13 getting failed?\\n\\nselect distinct w2.id as Id\\nfrom weather w1, weather w2\\nwhere w1.temperature < w2.temperature and w2.recorddate-1=w1.recorddate"
                    },
                    {
                        "username": "pankaj_kumar_01",
                        "content": "RecordDate\\'s Type is DATE, not a INT, you should consider it"
                    },
                    {
                        "username": "aminbasiran",
                        "content": "Can you tell me why this code wouldn\\'t work? (it actually worked however it didnt pass 2 test cases)\\n\\n `select id from\\n(select *, lag(temperature) over() as prev_temp from weather order by recordDate asc) \\nas new_table where\\ntemperature  > new_table.prev_temp `"
                    },
                    {
                        "username": "karanpeshwani7",
                        "content": "Why is this nested query wrong?\\n `select w1.id\\nfrom Weather as w1\\nwhere \\nw1.temperature > (select w2.temperature from Weather as w2 where w2.recordDate = (w1.recordDate - 1))`"
                    },
                    {
                        "username": "ahjimomo",
                        "content": "## Intuition\\nWe know that we need to compare the temperature of the current day and it\\'s preceding day to determine if it\\'s warmer for the current day. \\n\\nBased on the `Weather` table, we can see that both the `recordDate` and `id` are in order but use of `recordDate` will likely be a better option.\\n\\n## Approach\\n<b>Solution 1:</b>\\n- Using the `LAG()` function allows us to get the preceding value\\n- Integrate this with the `WITH` query to generate a new table\\n- Query for `Id` that has higher temperature than their precedence, and ensuring the difference in day is just 1 with `DATEDIFF()` function\\n\\n<b>Solution 2:</b>\\n- Extract the `Id` by comparing 2 same `Weather` tables as today `tdy` and yesterday `ytd`\\n- Query WHERE difference of day is 1 with `DATEDIFF()`\\n- AND `tdy.temperature` is higher than `ytd.temperature`"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select sq.id\\nfrom\\n(Select w.*, \\nlag(temperature) over(order by recordDate, id) as prev_temp,\\nlag(recordDate) over(order by recordDate, id) as prev_date\\nfrom weather w) sq\\nwhere sq.temperature > sq.prev_temp and datediff(sq.recordDate, sq.prev_date) = 1"
                    },
                    {
                        "username": "liutsewei",
                        "content": "SELECT w1.id\nFROM Weather w1\nLEFT JOIN Weather w2 ON DATEDIFF(w1.recordDate, w2.recordDate) = 1\nWHERE w1.temperature > w2.temperature"
                    },
                    {
                        "username": "Pritam_ath",
                        "content": "please tell me ...why am I not getting the right output?//\\n\\nselect w2.id  as Id from weather w1 , weather w2 \\nwhere w1.temperature < w2.temperature and w1.recorddate = w2.recorddate+1;"
                    },
                    {
                        "username": "hongseongeun39",
                        "content": "RecordDate\\'s Type is DATE, not a INT, you should consider it"
                    },
                    {
                        "username": "hongseongeun39",
                        "content": "Following Query is running successfully but cannot submit, what can I do for this issue?\\n\\nSELECT A.id AS id\\nFROM Weather AS A\\nINNER JOIN Weather AS B ON A.id = (B.id + 1)\\nWHERE A.temperature > B.temperature"
                    },
                    {
                        "username": "hongseongeun39",
                        "content": "I solved it through following query\\nLeetCode\\'s Problems should be accepted not only the sample question but also in several test cases \\n\\nSELECT A.id AS Id\\nFROM Weather AS A\\nINNER JOIN weather AS B ON DATE_SUB(A.recordDate, INTERVAL 1 DAY) = B.recordDate\\nWHERE A.temperature > B.temperature "
                    }
                ]
            },
            {
                "id": 1718433,
                "content": [
                    {
                        "username": "la1kshman",
                        "content": "| id | recordDate | temperature |\n| -- | ---------- | ----------- |\n| 1  | 2000-12-14 | 3           |\n| 2  | 2000-12-16 | 5           |\n\nFor above, I got Id ,2 as answer, but expected answer is null , why?\n"
                    },
                    {
                        "username": "yigit148",
                        "content": "# Write your MySQL query statement below\\nSELECT id \\nFROM Weather F \\nWHERE temperature > (SELECT temperature FROM Weather S WHERE F.recordDate = (S.recordDate+1))\\n\\ncan someone tell me why this doesnt work on testcase 13\\n\\n"
                    },
                    {
                        "username": "niks_gpt",
                        "content": "why is test case 13 getting failed?\\n\\nselect distinct w2.id as Id\\nfrom weather w1, weather w2\\nwhere w1.temperature < w2.temperature and w2.recorddate-1=w1.recorddate"
                    },
                    {
                        "username": "pankaj_kumar_01",
                        "content": "RecordDate\\'s Type is DATE, not a INT, you should consider it"
                    },
                    {
                        "username": "aminbasiran",
                        "content": "Can you tell me why this code wouldn\\'t work? (it actually worked however it didnt pass 2 test cases)\\n\\n `select id from\\n(select *, lag(temperature) over() as prev_temp from weather order by recordDate asc) \\nas new_table where\\ntemperature  > new_table.prev_temp `"
                    },
                    {
                        "username": "karanpeshwani7",
                        "content": "Why is this nested query wrong?\\n `select w1.id\\nfrom Weather as w1\\nwhere \\nw1.temperature > (select w2.temperature from Weather as w2 where w2.recordDate = (w1.recordDate - 1))`"
                    },
                    {
                        "username": "ahjimomo",
                        "content": "## Intuition\\nWe know that we need to compare the temperature of the current day and it\\'s preceding day to determine if it\\'s warmer for the current day. \\n\\nBased on the `Weather` table, we can see that both the `recordDate` and `id` are in order but use of `recordDate` will likely be a better option.\\n\\n## Approach\\n<b>Solution 1:</b>\\n- Using the `LAG()` function allows us to get the preceding value\\n- Integrate this with the `WITH` query to generate a new table\\n- Query for `Id` that has higher temperature than their precedence, and ensuring the difference in day is just 1 with `DATEDIFF()` function\\n\\n<b>Solution 2:</b>\\n- Extract the `Id` by comparing 2 same `Weather` tables as today `tdy` and yesterday `ytd`\\n- Query WHERE difference of day is 1 with `DATEDIFF()`\\n- AND `tdy.temperature` is higher than `ytd.temperature`"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select sq.id\\nfrom\\n(Select w.*, \\nlag(temperature) over(order by recordDate, id) as prev_temp,\\nlag(recordDate) over(order by recordDate, id) as prev_date\\nfrom weather w) sq\\nwhere sq.temperature > sq.prev_temp and datediff(sq.recordDate, sq.prev_date) = 1"
                    },
                    {
                        "username": "liutsewei",
                        "content": "SELECT w1.id\nFROM Weather w1\nLEFT JOIN Weather w2 ON DATEDIFF(w1.recordDate, w2.recordDate) = 1\nWHERE w1.temperature > w2.temperature"
                    },
                    {
                        "username": "Pritam_ath",
                        "content": "please tell me ...why am I not getting the right output?//\\n\\nselect w2.id  as Id from weather w1 , weather w2 \\nwhere w1.temperature < w2.temperature and w1.recorddate = w2.recorddate+1;"
                    },
                    {
                        "username": "hongseongeun39",
                        "content": "RecordDate\\'s Type is DATE, not a INT, you should consider it"
                    },
                    {
                        "username": "hongseongeun39",
                        "content": "Following Query is running successfully but cannot submit, what can I do for this issue?\\n\\nSELECT A.id AS id\\nFROM Weather AS A\\nINNER JOIN Weather AS B ON A.id = (B.id + 1)\\nWHERE A.temperature > B.temperature"
                    },
                    {
                        "username": "hongseongeun39",
                        "content": "I solved it through following query\\nLeetCode\\'s Problems should be accepted not only the sample question but also in several test cases \\n\\nSELECT A.id AS Id\\nFROM Weather AS A\\nINNER JOIN weather AS B ON DATE_SUB(A.recordDate, INTERVAL 1 DAY) = B.recordDate\\nWHERE A.temperature > B.temperature "
                    }
                ]
            },
            {
                "id": 1717154,
                "content": [
                    {
                        "username": "la1kshman",
                        "content": "| id | recordDate | temperature |\n| -- | ---------- | ----------- |\n| 1  | 2000-12-14 | 3           |\n| 2  | 2000-12-16 | 5           |\n\nFor above, I got Id ,2 as answer, but expected answer is null , why?\n"
                    },
                    {
                        "username": "yigit148",
                        "content": "# Write your MySQL query statement below\\nSELECT id \\nFROM Weather F \\nWHERE temperature > (SELECT temperature FROM Weather S WHERE F.recordDate = (S.recordDate+1))\\n\\ncan someone tell me why this doesnt work on testcase 13\\n\\n"
                    },
                    {
                        "username": "niks_gpt",
                        "content": "why is test case 13 getting failed?\\n\\nselect distinct w2.id as Id\\nfrom weather w1, weather w2\\nwhere w1.temperature < w2.temperature and w2.recorddate-1=w1.recorddate"
                    },
                    {
                        "username": "pankaj_kumar_01",
                        "content": "RecordDate\\'s Type is DATE, not a INT, you should consider it"
                    },
                    {
                        "username": "aminbasiran",
                        "content": "Can you tell me why this code wouldn\\'t work? (it actually worked however it didnt pass 2 test cases)\\n\\n `select id from\\n(select *, lag(temperature) over() as prev_temp from weather order by recordDate asc) \\nas new_table where\\ntemperature  > new_table.prev_temp `"
                    },
                    {
                        "username": "karanpeshwani7",
                        "content": "Why is this nested query wrong?\\n `select w1.id\\nfrom Weather as w1\\nwhere \\nw1.temperature > (select w2.temperature from Weather as w2 where w2.recordDate = (w1.recordDate - 1))`"
                    },
                    {
                        "username": "ahjimomo",
                        "content": "## Intuition\\nWe know that we need to compare the temperature of the current day and it\\'s preceding day to determine if it\\'s warmer for the current day. \\n\\nBased on the `Weather` table, we can see that both the `recordDate` and `id` are in order but use of `recordDate` will likely be a better option.\\n\\n## Approach\\n<b>Solution 1:</b>\\n- Using the `LAG()` function allows us to get the preceding value\\n- Integrate this with the `WITH` query to generate a new table\\n- Query for `Id` that has higher temperature than their precedence, and ensuring the difference in day is just 1 with `DATEDIFF()` function\\n\\n<b>Solution 2:</b>\\n- Extract the `Id` by comparing 2 same `Weather` tables as today `tdy` and yesterday `ytd`\\n- Query WHERE difference of day is 1 with `DATEDIFF()`\\n- AND `tdy.temperature` is higher than `ytd.temperature`"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select sq.id\\nfrom\\n(Select w.*, \\nlag(temperature) over(order by recordDate, id) as prev_temp,\\nlag(recordDate) over(order by recordDate, id) as prev_date\\nfrom weather w) sq\\nwhere sq.temperature > sq.prev_temp and datediff(sq.recordDate, sq.prev_date) = 1"
                    },
                    {
                        "username": "liutsewei",
                        "content": "SELECT w1.id\nFROM Weather w1\nLEFT JOIN Weather w2 ON DATEDIFF(w1.recordDate, w2.recordDate) = 1\nWHERE w1.temperature > w2.temperature"
                    },
                    {
                        "username": "Pritam_ath",
                        "content": "please tell me ...why am I not getting the right output?//\\n\\nselect w2.id  as Id from weather w1 , weather w2 \\nwhere w1.temperature < w2.temperature and w1.recorddate = w2.recorddate+1;"
                    },
                    {
                        "username": "hongseongeun39",
                        "content": "RecordDate\\'s Type is DATE, not a INT, you should consider it"
                    },
                    {
                        "username": "hongseongeun39",
                        "content": "Following Query is running successfully but cannot submit, what can I do for this issue?\\n\\nSELECT A.id AS id\\nFROM Weather AS A\\nINNER JOIN Weather AS B ON A.id = (B.id + 1)\\nWHERE A.temperature > B.temperature"
                    },
                    {
                        "username": "hongseongeun39",
                        "content": "I solved it through following query\\nLeetCode\\'s Problems should be accepted not only the sample question but also in several test cases \\n\\nSELECT A.id AS Id\\nFROM Weather AS A\\nINNER JOIN weather AS B ON DATE_SUB(A.recordDate, INTERVAL 1 DAY) = B.recordDate\\nWHERE A.temperature > B.temperature "
                    }
                ]
            },
            {
                "id": 1716098,
                "content": [
                    {
                        "username": "la1kshman",
                        "content": "| id | recordDate | temperature |\n| -- | ---------- | ----------- |\n| 1  | 2000-12-14 | 3           |\n| 2  | 2000-12-16 | 5           |\n\nFor above, I got Id ,2 as answer, but expected answer is null , why?\n"
                    },
                    {
                        "username": "yigit148",
                        "content": "# Write your MySQL query statement below\\nSELECT id \\nFROM Weather F \\nWHERE temperature > (SELECT temperature FROM Weather S WHERE F.recordDate = (S.recordDate+1))\\n\\ncan someone tell me why this doesnt work on testcase 13\\n\\n"
                    },
                    {
                        "username": "niks_gpt",
                        "content": "why is test case 13 getting failed?\\n\\nselect distinct w2.id as Id\\nfrom weather w1, weather w2\\nwhere w1.temperature < w2.temperature and w2.recorddate-1=w1.recorddate"
                    },
                    {
                        "username": "pankaj_kumar_01",
                        "content": "RecordDate\\'s Type is DATE, not a INT, you should consider it"
                    },
                    {
                        "username": "aminbasiran",
                        "content": "Can you tell me why this code wouldn\\'t work? (it actually worked however it didnt pass 2 test cases)\\n\\n `select id from\\n(select *, lag(temperature) over() as prev_temp from weather order by recordDate asc) \\nas new_table where\\ntemperature  > new_table.prev_temp `"
                    },
                    {
                        "username": "karanpeshwani7",
                        "content": "Why is this nested query wrong?\\n `select w1.id\\nfrom Weather as w1\\nwhere \\nw1.temperature > (select w2.temperature from Weather as w2 where w2.recordDate = (w1.recordDate - 1))`"
                    },
                    {
                        "username": "ahjimomo",
                        "content": "## Intuition\\nWe know that we need to compare the temperature of the current day and it\\'s preceding day to determine if it\\'s warmer for the current day. \\n\\nBased on the `Weather` table, we can see that both the `recordDate` and `id` are in order but use of `recordDate` will likely be a better option.\\n\\n## Approach\\n<b>Solution 1:</b>\\n- Using the `LAG()` function allows us to get the preceding value\\n- Integrate this with the `WITH` query to generate a new table\\n- Query for `Id` that has higher temperature than their precedence, and ensuring the difference in day is just 1 with `DATEDIFF()` function\\n\\n<b>Solution 2:</b>\\n- Extract the `Id` by comparing 2 same `Weather` tables as today `tdy` and yesterday `ytd`\\n- Query WHERE difference of day is 1 with `DATEDIFF()`\\n- AND `tdy.temperature` is higher than `ytd.temperature`"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select sq.id\\nfrom\\n(Select w.*, \\nlag(temperature) over(order by recordDate, id) as prev_temp,\\nlag(recordDate) over(order by recordDate, id) as prev_date\\nfrom weather w) sq\\nwhere sq.temperature > sq.prev_temp and datediff(sq.recordDate, sq.prev_date) = 1"
                    },
                    {
                        "username": "liutsewei",
                        "content": "SELECT w1.id\nFROM Weather w1\nLEFT JOIN Weather w2 ON DATEDIFF(w1.recordDate, w2.recordDate) = 1\nWHERE w1.temperature > w2.temperature"
                    },
                    {
                        "username": "Pritam_ath",
                        "content": "please tell me ...why am I not getting the right output?//\\n\\nselect w2.id  as Id from weather w1 , weather w2 \\nwhere w1.temperature < w2.temperature and w1.recorddate = w2.recorddate+1;"
                    },
                    {
                        "username": "hongseongeun39",
                        "content": "RecordDate\\'s Type is DATE, not a INT, you should consider it"
                    },
                    {
                        "username": "hongseongeun39",
                        "content": "Following Query is running successfully but cannot submit, what can I do for this issue?\\n\\nSELECT A.id AS id\\nFROM Weather AS A\\nINNER JOIN Weather AS B ON A.id = (B.id + 1)\\nWHERE A.temperature > B.temperature"
                    },
                    {
                        "username": "hongseongeun39",
                        "content": "I solved it through following query\\nLeetCode\\'s Problems should be accepted not only the sample question but also in several test cases \\n\\nSELECT A.id AS Id\\nFROM Weather AS A\\nINNER JOIN weather AS B ON DATE_SUB(A.recordDate, INTERVAL 1 DAY) = B.recordDate\\nWHERE A.temperature > B.temperature "
                    }
                ]
            },
            {
                "id": 1715764,
                "content": [
                    {
                        "username": "la1kshman",
                        "content": "| id | recordDate | temperature |\n| -- | ---------- | ----------- |\n| 1  | 2000-12-14 | 3           |\n| 2  | 2000-12-16 | 5           |\n\nFor above, I got Id ,2 as answer, but expected answer is null , why?\n"
                    },
                    {
                        "username": "yigit148",
                        "content": "# Write your MySQL query statement below\\nSELECT id \\nFROM Weather F \\nWHERE temperature > (SELECT temperature FROM Weather S WHERE F.recordDate = (S.recordDate+1))\\n\\ncan someone tell me why this doesnt work on testcase 13\\n\\n"
                    },
                    {
                        "username": "niks_gpt",
                        "content": "why is test case 13 getting failed?\\n\\nselect distinct w2.id as Id\\nfrom weather w1, weather w2\\nwhere w1.temperature < w2.temperature and w2.recorddate-1=w1.recorddate"
                    },
                    {
                        "username": "pankaj_kumar_01",
                        "content": "RecordDate\\'s Type is DATE, not a INT, you should consider it"
                    },
                    {
                        "username": "aminbasiran",
                        "content": "Can you tell me why this code wouldn\\'t work? (it actually worked however it didnt pass 2 test cases)\\n\\n `select id from\\n(select *, lag(temperature) over() as prev_temp from weather order by recordDate asc) \\nas new_table where\\ntemperature  > new_table.prev_temp `"
                    },
                    {
                        "username": "karanpeshwani7",
                        "content": "Why is this nested query wrong?\\n `select w1.id\\nfrom Weather as w1\\nwhere \\nw1.temperature > (select w2.temperature from Weather as w2 where w2.recordDate = (w1.recordDate - 1))`"
                    },
                    {
                        "username": "ahjimomo",
                        "content": "## Intuition\\nWe know that we need to compare the temperature of the current day and it\\'s preceding day to determine if it\\'s warmer for the current day. \\n\\nBased on the `Weather` table, we can see that both the `recordDate` and `id` are in order but use of `recordDate` will likely be a better option.\\n\\n## Approach\\n<b>Solution 1:</b>\\n- Using the `LAG()` function allows us to get the preceding value\\n- Integrate this with the `WITH` query to generate a new table\\n- Query for `Id` that has higher temperature than their precedence, and ensuring the difference in day is just 1 with `DATEDIFF()` function\\n\\n<b>Solution 2:</b>\\n- Extract the `Id` by comparing 2 same `Weather` tables as today `tdy` and yesterday `ytd`\\n- Query WHERE difference of day is 1 with `DATEDIFF()`\\n- AND `tdy.temperature` is higher than `ytd.temperature`"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select sq.id\\nfrom\\n(Select w.*, \\nlag(temperature) over(order by recordDate, id) as prev_temp,\\nlag(recordDate) over(order by recordDate, id) as prev_date\\nfrom weather w) sq\\nwhere sq.temperature > sq.prev_temp and datediff(sq.recordDate, sq.prev_date) = 1"
                    },
                    {
                        "username": "liutsewei",
                        "content": "SELECT w1.id\nFROM Weather w1\nLEFT JOIN Weather w2 ON DATEDIFF(w1.recordDate, w2.recordDate) = 1\nWHERE w1.temperature > w2.temperature"
                    },
                    {
                        "username": "Pritam_ath",
                        "content": "please tell me ...why am I not getting the right output?//\\n\\nselect w2.id  as Id from weather w1 , weather w2 \\nwhere w1.temperature < w2.temperature and w1.recorddate = w2.recorddate+1;"
                    },
                    {
                        "username": "hongseongeun39",
                        "content": "RecordDate\\'s Type is DATE, not a INT, you should consider it"
                    },
                    {
                        "username": "hongseongeun39",
                        "content": "Following Query is running successfully but cannot submit, what can I do for this issue?\\n\\nSELECT A.id AS id\\nFROM Weather AS A\\nINNER JOIN Weather AS B ON A.id = (B.id + 1)\\nWHERE A.temperature > B.temperature"
                    },
                    {
                        "username": "hongseongeun39",
                        "content": "I solved it through following query\\nLeetCode\\'s Problems should be accepted not only the sample question but also in several test cases \\n\\nSELECT A.id AS Id\\nFROM Weather AS A\\nINNER JOIN weather AS B ON DATE_SUB(A.recordDate, INTERVAL 1 DAY) = B.recordDate\\nWHERE A.temperature > B.temperature "
                    }
                ]
            },
            {
                "id": 1713256,
                "content": [
                    {
                        "username": "la1kshman",
                        "content": "| id | recordDate | temperature |\n| -- | ---------- | ----------- |\n| 1  | 2000-12-14 | 3           |\n| 2  | 2000-12-16 | 5           |\n\nFor above, I got Id ,2 as answer, but expected answer is null , why?\n"
                    },
                    {
                        "username": "yigit148",
                        "content": "# Write your MySQL query statement below\\nSELECT id \\nFROM Weather F \\nWHERE temperature > (SELECT temperature FROM Weather S WHERE F.recordDate = (S.recordDate+1))\\n\\ncan someone tell me why this doesnt work on testcase 13\\n\\n"
                    },
                    {
                        "username": "niks_gpt",
                        "content": "why is test case 13 getting failed?\\n\\nselect distinct w2.id as Id\\nfrom weather w1, weather w2\\nwhere w1.temperature < w2.temperature and w2.recorddate-1=w1.recorddate"
                    },
                    {
                        "username": "pankaj_kumar_01",
                        "content": "RecordDate\\'s Type is DATE, not a INT, you should consider it"
                    },
                    {
                        "username": "aminbasiran",
                        "content": "Can you tell me why this code wouldn\\'t work? (it actually worked however it didnt pass 2 test cases)\\n\\n `select id from\\n(select *, lag(temperature) over() as prev_temp from weather order by recordDate asc) \\nas new_table where\\ntemperature  > new_table.prev_temp `"
                    },
                    {
                        "username": "karanpeshwani7",
                        "content": "Why is this nested query wrong?\\n `select w1.id\\nfrom Weather as w1\\nwhere \\nw1.temperature > (select w2.temperature from Weather as w2 where w2.recordDate = (w1.recordDate - 1))`"
                    },
                    {
                        "username": "ahjimomo",
                        "content": "## Intuition\\nWe know that we need to compare the temperature of the current day and it\\'s preceding day to determine if it\\'s warmer for the current day. \\n\\nBased on the `Weather` table, we can see that both the `recordDate` and `id` are in order but use of `recordDate` will likely be a better option.\\n\\n## Approach\\n<b>Solution 1:</b>\\n- Using the `LAG()` function allows us to get the preceding value\\n- Integrate this with the `WITH` query to generate a new table\\n- Query for `Id` that has higher temperature than their precedence, and ensuring the difference in day is just 1 with `DATEDIFF()` function\\n\\n<b>Solution 2:</b>\\n- Extract the `Id` by comparing 2 same `Weather` tables as today `tdy` and yesterday `ytd`\\n- Query WHERE difference of day is 1 with `DATEDIFF()`\\n- AND `tdy.temperature` is higher than `ytd.temperature`"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select sq.id\\nfrom\\n(Select w.*, \\nlag(temperature) over(order by recordDate, id) as prev_temp,\\nlag(recordDate) over(order by recordDate, id) as prev_date\\nfrom weather w) sq\\nwhere sq.temperature > sq.prev_temp and datediff(sq.recordDate, sq.prev_date) = 1"
                    },
                    {
                        "username": "liutsewei",
                        "content": "SELECT w1.id\nFROM Weather w1\nLEFT JOIN Weather w2 ON DATEDIFF(w1.recordDate, w2.recordDate) = 1\nWHERE w1.temperature > w2.temperature"
                    },
                    {
                        "username": "Pritam_ath",
                        "content": "please tell me ...why am I not getting the right output?//\\n\\nselect w2.id  as Id from weather w1 , weather w2 \\nwhere w1.temperature < w2.temperature and w1.recorddate = w2.recorddate+1;"
                    },
                    {
                        "username": "hongseongeun39",
                        "content": "RecordDate\\'s Type is DATE, not a INT, you should consider it"
                    },
                    {
                        "username": "hongseongeun39",
                        "content": "Following Query is running successfully but cannot submit, what can I do for this issue?\\n\\nSELECT A.id AS id\\nFROM Weather AS A\\nINNER JOIN Weather AS B ON A.id = (B.id + 1)\\nWHERE A.temperature > B.temperature"
                    },
                    {
                        "username": "hongseongeun39",
                        "content": "I solved it through following query\\nLeetCode\\'s Problems should be accepted not only the sample question but also in several test cases \\n\\nSELECT A.id AS Id\\nFROM Weather AS A\\nINNER JOIN weather AS B ON DATE_SUB(A.recordDate, INTERVAL 1 DAY) = B.recordDate\\nWHERE A.temperature > B.temperature "
                    }
                ]
            },
            {
                "id": 1710649,
                "content": [
                    {
                        "username": "la1kshman",
                        "content": "| id | recordDate | temperature |\n| -- | ---------- | ----------- |\n| 1  | 2000-12-14 | 3           |\n| 2  | 2000-12-16 | 5           |\n\nFor above, I got Id ,2 as answer, but expected answer is null , why?\n"
                    },
                    {
                        "username": "yigit148",
                        "content": "# Write your MySQL query statement below\\nSELECT id \\nFROM Weather F \\nWHERE temperature > (SELECT temperature FROM Weather S WHERE F.recordDate = (S.recordDate+1))\\n\\ncan someone tell me why this doesnt work on testcase 13\\n\\n"
                    },
                    {
                        "username": "niks_gpt",
                        "content": "why is test case 13 getting failed?\\n\\nselect distinct w2.id as Id\\nfrom weather w1, weather w2\\nwhere w1.temperature < w2.temperature and w2.recorddate-1=w1.recorddate"
                    },
                    {
                        "username": "pankaj_kumar_01",
                        "content": "RecordDate\\'s Type is DATE, not a INT, you should consider it"
                    },
                    {
                        "username": "aminbasiran",
                        "content": "Can you tell me why this code wouldn\\'t work? (it actually worked however it didnt pass 2 test cases)\\n\\n `select id from\\n(select *, lag(temperature) over() as prev_temp from weather order by recordDate asc) \\nas new_table where\\ntemperature  > new_table.prev_temp `"
                    },
                    {
                        "username": "karanpeshwani7",
                        "content": "Why is this nested query wrong?\\n `select w1.id\\nfrom Weather as w1\\nwhere \\nw1.temperature > (select w2.temperature from Weather as w2 where w2.recordDate = (w1.recordDate - 1))`"
                    },
                    {
                        "username": "ahjimomo",
                        "content": "## Intuition\\nWe know that we need to compare the temperature of the current day and it\\'s preceding day to determine if it\\'s warmer for the current day. \\n\\nBased on the `Weather` table, we can see that both the `recordDate` and `id` are in order but use of `recordDate` will likely be a better option.\\n\\n## Approach\\n<b>Solution 1:</b>\\n- Using the `LAG()` function allows us to get the preceding value\\n- Integrate this with the `WITH` query to generate a new table\\n- Query for `Id` that has higher temperature than their precedence, and ensuring the difference in day is just 1 with `DATEDIFF()` function\\n\\n<b>Solution 2:</b>\\n- Extract the `Id` by comparing 2 same `Weather` tables as today `tdy` and yesterday `ytd`\\n- Query WHERE difference of day is 1 with `DATEDIFF()`\\n- AND `tdy.temperature` is higher than `ytd.temperature`"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select sq.id\\nfrom\\n(Select w.*, \\nlag(temperature) over(order by recordDate, id) as prev_temp,\\nlag(recordDate) over(order by recordDate, id) as prev_date\\nfrom weather w) sq\\nwhere sq.temperature > sq.prev_temp and datediff(sq.recordDate, sq.prev_date) = 1"
                    },
                    {
                        "username": "liutsewei",
                        "content": "SELECT w1.id\nFROM Weather w1\nLEFT JOIN Weather w2 ON DATEDIFF(w1.recordDate, w2.recordDate) = 1\nWHERE w1.temperature > w2.temperature"
                    },
                    {
                        "username": "Pritam_ath",
                        "content": "please tell me ...why am I not getting the right output?//\\n\\nselect w2.id  as Id from weather w1 , weather w2 \\nwhere w1.temperature < w2.temperature and w1.recorddate = w2.recorddate+1;"
                    },
                    {
                        "username": "hongseongeun39",
                        "content": "RecordDate\\'s Type is DATE, not a INT, you should consider it"
                    },
                    {
                        "username": "hongseongeun39",
                        "content": "Following Query is running successfully but cannot submit, what can I do for this issue?\\n\\nSELECT A.id AS id\\nFROM Weather AS A\\nINNER JOIN Weather AS B ON A.id = (B.id + 1)\\nWHERE A.temperature > B.temperature"
                    },
                    {
                        "username": "hongseongeun39",
                        "content": "I solved it through following query\\nLeetCode\\'s Problems should be accepted not only the sample question but also in several test cases \\n\\nSELECT A.id AS Id\\nFROM Weather AS A\\nINNER JOIN weather AS B ON DATE_SUB(A.recordDate, INTERVAL 1 DAY) = B.recordDate\\nWHERE A.temperature > B.temperature "
                    }
                ]
            },
            {
                "id": 1708262,
                "content": [
                    {
                        "username": "la1kshman",
                        "content": "| id | recordDate | temperature |\n| -- | ---------- | ----------- |\n| 1  | 2000-12-14 | 3           |\n| 2  | 2000-12-16 | 5           |\n\nFor above, I got Id ,2 as answer, but expected answer is null , why?\n"
                    },
                    {
                        "username": "yigit148",
                        "content": "# Write your MySQL query statement below\\nSELECT id \\nFROM Weather F \\nWHERE temperature > (SELECT temperature FROM Weather S WHERE F.recordDate = (S.recordDate+1))\\n\\ncan someone tell me why this doesnt work on testcase 13\\n\\n"
                    },
                    {
                        "username": "niks_gpt",
                        "content": "why is test case 13 getting failed?\\n\\nselect distinct w2.id as Id\\nfrom weather w1, weather w2\\nwhere w1.temperature < w2.temperature and w2.recorddate-1=w1.recorddate"
                    },
                    {
                        "username": "pankaj_kumar_01",
                        "content": "RecordDate\\'s Type is DATE, not a INT, you should consider it"
                    },
                    {
                        "username": "aminbasiran",
                        "content": "Can you tell me why this code wouldn\\'t work? (it actually worked however it didnt pass 2 test cases)\\n\\n `select id from\\n(select *, lag(temperature) over() as prev_temp from weather order by recordDate asc) \\nas new_table where\\ntemperature  > new_table.prev_temp `"
                    },
                    {
                        "username": "karanpeshwani7",
                        "content": "Why is this nested query wrong?\\n `select w1.id\\nfrom Weather as w1\\nwhere \\nw1.temperature > (select w2.temperature from Weather as w2 where w2.recordDate = (w1.recordDate - 1))`"
                    },
                    {
                        "username": "ahjimomo",
                        "content": "## Intuition\\nWe know that we need to compare the temperature of the current day and it\\'s preceding day to determine if it\\'s warmer for the current day. \\n\\nBased on the `Weather` table, we can see that both the `recordDate` and `id` are in order but use of `recordDate` will likely be a better option.\\n\\n## Approach\\n<b>Solution 1:</b>\\n- Using the `LAG()` function allows us to get the preceding value\\n- Integrate this with the `WITH` query to generate a new table\\n- Query for `Id` that has higher temperature than their precedence, and ensuring the difference in day is just 1 with `DATEDIFF()` function\\n\\n<b>Solution 2:</b>\\n- Extract the `Id` by comparing 2 same `Weather` tables as today `tdy` and yesterday `ytd`\\n- Query WHERE difference of day is 1 with `DATEDIFF()`\\n- AND `tdy.temperature` is higher than `ytd.temperature`"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select sq.id\\nfrom\\n(Select w.*, \\nlag(temperature) over(order by recordDate, id) as prev_temp,\\nlag(recordDate) over(order by recordDate, id) as prev_date\\nfrom weather w) sq\\nwhere sq.temperature > sq.prev_temp and datediff(sq.recordDate, sq.prev_date) = 1"
                    },
                    {
                        "username": "liutsewei",
                        "content": "SELECT w1.id\nFROM Weather w1\nLEFT JOIN Weather w2 ON DATEDIFF(w1.recordDate, w2.recordDate) = 1\nWHERE w1.temperature > w2.temperature"
                    },
                    {
                        "username": "Pritam_ath",
                        "content": "please tell me ...why am I not getting the right output?//\\n\\nselect w2.id  as Id from weather w1 , weather w2 \\nwhere w1.temperature < w2.temperature and w1.recorddate = w2.recorddate+1;"
                    },
                    {
                        "username": "hongseongeun39",
                        "content": "RecordDate\\'s Type is DATE, not a INT, you should consider it"
                    },
                    {
                        "username": "hongseongeun39",
                        "content": "Following Query is running successfully but cannot submit, what can I do for this issue?\\n\\nSELECT A.id AS id\\nFROM Weather AS A\\nINNER JOIN Weather AS B ON A.id = (B.id + 1)\\nWHERE A.temperature > B.temperature"
                    },
                    {
                        "username": "hongseongeun39",
                        "content": "I solved it through following query\\nLeetCode\\'s Problems should be accepted not only the sample question but also in several test cases \\n\\nSELECT A.id AS Id\\nFROM Weather AS A\\nINNER JOIN weather AS B ON DATE_SUB(A.recordDate, INTERVAL 1 DAY) = B.recordDate\\nWHERE A.temperature > B.temperature "
                    }
                ]
            },
            {
                "id": 1706901,
                "content": [
                    {
                        "username": "la1kshman",
                        "content": "| id | recordDate | temperature |\n| -- | ---------- | ----------- |\n| 1  | 2000-12-14 | 3           |\n| 2  | 2000-12-16 | 5           |\n\nFor above, I got Id ,2 as answer, but expected answer is null , why?\n"
                    },
                    {
                        "username": "yigit148",
                        "content": "# Write your MySQL query statement below\\nSELECT id \\nFROM Weather F \\nWHERE temperature > (SELECT temperature FROM Weather S WHERE F.recordDate = (S.recordDate+1))\\n\\ncan someone tell me why this doesnt work on testcase 13\\n\\n"
                    },
                    {
                        "username": "niks_gpt",
                        "content": "why is test case 13 getting failed?\\n\\nselect distinct w2.id as Id\\nfrom weather w1, weather w2\\nwhere w1.temperature < w2.temperature and w2.recorddate-1=w1.recorddate"
                    },
                    {
                        "username": "pankaj_kumar_01",
                        "content": "RecordDate\\'s Type is DATE, not a INT, you should consider it"
                    },
                    {
                        "username": "aminbasiran",
                        "content": "Can you tell me why this code wouldn\\'t work? (it actually worked however it didnt pass 2 test cases)\\n\\n `select id from\\n(select *, lag(temperature) over() as prev_temp from weather order by recordDate asc) \\nas new_table where\\ntemperature  > new_table.prev_temp `"
                    },
                    {
                        "username": "karanpeshwani7",
                        "content": "Why is this nested query wrong?\\n `select w1.id\\nfrom Weather as w1\\nwhere \\nw1.temperature > (select w2.temperature from Weather as w2 where w2.recordDate = (w1.recordDate - 1))`"
                    },
                    {
                        "username": "ahjimomo",
                        "content": "## Intuition\\nWe know that we need to compare the temperature of the current day and it\\'s preceding day to determine if it\\'s warmer for the current day. \\n\\nBased on the `Weather` table, we can see that both the `recordDate` and `id` are in order but use of `recordDate` will likely be a better option.\\n\\n## Approach\\n<b>Solution 1:</b>\\n- Using the `LAG()` function allows us to get the preceding value\\n- Integrate this with the `WITH` query to generate a new table\\n- Query for `Id` that has higher temperature than their precedence, and ensuring the difference in day is just 1 with `DATEDIFF()` function\\n\\n<b>Solution 2:</b>\\n- Extract the `Id` by comparing 2 same `Weather` tables as today `tdy` and yesterday `ytd`\\n- Query WHERE difference of day is 1 with `DATEDIFF()`\\n- AND `tdy.temperature` is higher than `ytd.temperature`"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select sq.id\\nfrom\\n(Select w.*, \\nlag(temperature) over(order by recordDate, id) as prev_temp,\\nlag(recordDate) over(order by recordDate, id) as prev_date\\nfrom weather w) sq\\nwhere sq.temperature > sq.prev_temp and datediff(sq.recordDate, sq.prev_date) = 1"
                    },
                    {
                        "username": "liutsewei",
                        "content": "SELECT w1.id\nFROM Weather w1\nLEFT JOIN Weather w2 ON DATEDIFF(w1.recordDate, w2.recordDate) = 1\nWHERE w1.temperature > w2.temperature"
                    },
                    {
                        "username": "Pritam_ath",
                        "content": "please tell me ...why am I not getting the right output?//\\n\\nselect w2.id  as Id from weather w1 , weather w2 \\nwhere w1.temperature < w2.temperature and w1.recorddate = w2.recorddate+1;"
                    },
                    {
                        "username": "hongseongeun39",
                        "content": "RecordDate\\'s Type is DATE, not a INT, you should consider it"
                    },
                    {
                        "username": "hongseongeun39",
                        "content": "Following Query is running successfully but cannot submit, what can I do for this issue?\\n\\nSELECT A.id AS id\\nFROM Weather AS A\\nINNER JOIN Weather AS B ON A.id = (B.id + 1)\\nWHERE A.temperature > B.temperature"
                    },
                    {
                        "username": "hongseongeun39",
                        "content": "I solved it through following query\\nLeetCode\\'s Problems should be accepted not only the sample question but also in several test cases \\n\\nSELECT A.id AS Id\\nFROM Weather AS A\\nINNER JOIN weather AS B ON DATE_SUB(A.recordDate, INTERVAL 1 DAY) = B.recordDate\\nWHERE A.temperature > B.temperature "
                    }
                ]
            }
        ]
    }
]