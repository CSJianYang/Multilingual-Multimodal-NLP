[
    {
        "title": "Check Distances Between Same Letters",
        "question_content": "You are given a 0-indexed string s consisting of only lowercase English letters, where each letter in s appears exactly twice. You are also given a 0-indexed integer array distance of length 26.\nEach letter in the alphabet is numbered from 0 to 25 (i.e. 'a' -> 0, 'b' -> 1, 'c' -> 2, ... , 'z' -> 25).\nIn a well-spaced string, the number of letters between the two occurrences of the ith letter is distance[i]. If the ith letter does not appear in s, then distance[i] can be ignored.\nReturn true if s is a well-spaced string, otherwise return false.\n&nbsp;\nExample 1:\n\nInput: s = \"abaccb\", distance = [1,3,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\nOutput: true\nExplanation:\n- 'a' appears at indices 0 and 2 so it satisfies distance[0] = 1.\n- 'b' appears at indices 1 and 5 so it satisfies distance[1] = 3.\n- 'c' appears at indices 3 and 4 so it satisfies distance[2] = 0.\nNote that distance[3] = 5, but since 'd' does not appear in s, it can be ignored.\nReturn true because s is a well-spaced string.\n\nExample 2:\n\nInput: s = \"aa\", distance = [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\nOutput: false\nExplanation:\n- 'a' appears at indices 0 and 1 so there are zero letters between them.\nBecause distance[0] = 1, s is not a well-spaced string.\n\n&nbsp;\nConstraints:\n\n\t2 <= s.length <= 52\n\ts consists only of lowercase English letters.\n\tEach letter appears in s exactly twice.\n\tdistance.length == 26\n\t0 <= distance[i] <= 50",
        "solutions": [
            {
                "id": 2527292,
                "title": "track-first-vs-check-second",
                "content": "#### Track First Position\\n**C++**\\n```cpp\\nbool checkDistances(string s, vector<int>& distance) {\\n    int pos[26] = {};\\n    for (int i = 0; i < s.size(); ++i) {\\n        int n = s[i] - \\'a\\';\\n        if (pos[n] > 0 && distance[n] != i - pos[n])\\n            return false;\\n        pos[n] = i + 1;\\n    }\\n    return true;\\n}\\n```\\n\\n#### Check Second Position\\nThanks [SunnyvaleCA](https://leetcode.com/SunnyvaleCA/) for the idea. The approach above would not work if we change the problem to allow a single letter.\\n\\nInstead, when we encounter `s[i]` letter for the first time, we can check that `s[i] == s[i + d + 1]`, where `d` is the distance for that letter.\\n\\nAfter that, we set the distance to `-1`, so it would work for the second letter (it will be checked against itself). \\n\\n**Java**\\n```java\\npublic boolean checkDistances(String s, int[] dist) {\\n    for (int i = 0; i < s.length(); ++i) {\\n        int d = dist[s.charAt(i) - \\'a\\'];\\n        if (i + d + 1 >= s.length() || s.charAt(i + d + 1) != s.charAt(i))\\n            return false;\\n        dist[s.charAt(i) - \\'a\\'] = -1;\\n    }\\n    return true;        \\n}\\n```\\n**C++**\\n```cpp\\nbool checkDistances(string s, vector<int>& dist) {\\n    for (int i = 0; i < s.size(); ++i) {\\n        int d = dist[s[i] - \\'a\\'];\\n        if (i + d + 1 >= s.size() || s[i + d + 1] != s[i])\\n            return false;\\n        dist[s[i] - \\'a\\'] = -1;\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```cpp\\nbool checkDistances(string s, vector<int>& distance) {\\n    int pos[26] = {};\\n    for (int i = 0; i < s.size(); ++i) {\\n        int n = s[i] - \\'a\\';\\n        if (pos[n] > 0 && distance[n] != i - pos[n])\\n            return false;\\n        pos[n] = i + 1;\\n    }\\n    return true;\\n}\\n```\n```java\\npublic boolean checkDistances(String s, int[] dist) {\\n    for (int i = 0; i < s.length(); ++i) {\\n        int d = dist[s.charAt(i) - \\'a\\'];\\n        if (i + d + 1 >= s.length() || s.charAt(i + d + 1) != s.charAt(i))\\n            return false;\\n        dist[s.charAt(i) - \\'a\\'] = -1;\\n    }\\n    return true;        \\n}\\n```\n```cpp\\nbool checkDistances(string s, vector<int>& dist) {\\n    for (int i = 0; i < s.size(); ++i) {\\n        int d = dist[s[i] - \\'a\\'];\\n        if (i + d + 1 >= s.size() || s[i + d + 1] != s[i])\\n            return false;\\n        dist[s[i] - \\'a\\'] = -1;\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2531135,
                "title": "python3-3-lines-t-m-36ms-13-8mb",
                "content": "```\\nclass Solution:   # Pretty much explains itself.\\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\\n        \\n        d = defaultdict(list)\\n\\n        for i, ch in enumerate(s):\\n            d[ch].append(i)\\n\\n        return all(b-a-1 == distance[ord(ch)-97] for ch, (a,b) in d.items())",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:   # Pretty much explains itself.\\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\\n        \\n        d = defaultdict(list)\\n\\n        for i, ch in enumerate(s):\\n            d[ch].append(i)\\n\\n        return all(b-a-1 == distance[ord(ch)-97] for ch, (a,b) in d.items())",
                "codeTag": "Java"
            },
            {
                "id": 2527329,
                "title": "hashmap-explained-beginner-friendly",
                "content": "```\\n/*\\nUse map to store the character and the index of its first occurance\\nAnd when the second occurance found, count the elemnets in between\\nand check in distance[] whether the distance at the place is correct or not\\n*/\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        \\n        Map<Character,Integer> map = new HashMap<>();\\n        char[] arr = s.toCharArray();\\n        int len = arr.length;\\n        \\n        for(int i=0; i<len; i++){\\n            if(map.containsKey(arr[i])){\\n                int start = map.get(arr[i]);\\n                int diff = i - start - 1;\\n                if(distance[arr[i]-\\'a\\'] != diff) return false;\\n            }\\n            else map.put(arr[i], i);\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\nUse map to store the character and the index of its first occurance\\nAnd when the second occurance found, count the elemnets in between\\nand check in distance[] whether the distance at the place is correct or not\\n*/\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        \\n        Map<Character,Integer> map = new HashMap<>();\\n        char[] arr = s.toCharArray();\\n        int len = arr.length;\\n        \\n        for(int i=0; i<len; i++){\\n            if(map.containsKey(arr[i])){\\n                int start = map.get(arr[i]);\\n                int diff = i - start - 1;\\n                if(distance[arr[i]-\\'a\\'] != diff) return false;\\n            }\\n            else map.put(arr[i], i);\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527370,
                "title": "last-position-c-java",
                "content": "<iframe src=\"https://leetcode.com/playground/CRM7QX8D/shared\" frameBorder=\"0\" width=\"800\" height=\"300\"></iframe>",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "<iframe src=\"https://leetcode.com/playground/CRM7QX8D/shared\" frameBorder=\"0\" width=\"800\" height=\"300\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 2527308,
                "title": "c-map-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n        map<char, vector<int>> mpp;\\n\\n        for (int i = 0; i < s.size(); i++){\\n            mpp[s[i]].push_back(i);\\n        }\\n\\n        for (auto it : mpp)\\n        {    \\n            if (it.second[1] - it.second[0] - 1 != distance[it.first - \\'a\\']){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n**Don\\'t forget to Upvote the post, if it\\'s been any help to you**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n        map<char, vector<int>> mpp;\\n\\n        for (int i = 0; i < s.size(); i++){\\n            mpp[s[i]].push_back(i);\\n        }\\n\\n        for (auto it : mpp)\\n        {    \\n            if (it.second[1] - it.second[0] - 1 != distance[it.first - \\'a\\']){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2544726,
                "title": "python-98-faster-easy-solution",
                "content": "```\\ndef checkDistances(self, s: str, distance: List[int]) -> bool:\\n        unique = set(s)\\n        for letter in unique:\\n            index = s.index(letter) # get the first index of the letter\\n            dis = distance[ord(letter)-97]\\n            if index+dis+1 > len(s)-1 or s[index+dis+1] != letter:\\n                return False\\n        return True\\n```\\n![image](https://assets.leetcode.com/users/images/d6486748-ce21-4a8a-ac24-579004455e58_1662553681.887788.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef checkDistances(self, s: str, distance: List[int]) -> bool:\\n        unique = set(s)\\n        for letter in unique:\\n            index = s.index(letter) # get the first index of the letter\\n            dis = distance[ord(letter)-97]\\n            if index+dis+1 > len(s)-1 or s[index+dis+1] != letter:\\n                return False\\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3406284,
                "title": "easy-brute-force-approach-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOverall, this solution has a time complexity of O(n^2), where n is the length of the input string. This may not be efficient for very large input strings, but it is a straightforward approach to solve this problem.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach taken in this solution is a simple brute-force algorithm where we check every pair of characters in the string s. If we find two characters that are equal, we calculate the distance between them by subtracting their indices and subtracting 1. If the calculated distance does not match the corresponding value in the vector distance for that character, we return false because it means we cannot replace that character to get the desired distances.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2) as we are using two loops and traversing the whole string each time.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) is a constant time \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\t bool checkDistances(string s, vector<int>& distance) {\\n\\t\\tint n=s.size();\\n\\n\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\tfor(int j=i+1;j<n;j++){\\n\\t\\t\\t\\tif(s[i]==s[j]){\\n\\t\\t\\t\\t\\tif(j-i-1 != distance[s[i]-\\'a\\']){//(s[i]-\\'a\\' helps to access the particular character)\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\t bool checkDistances(string s, vector<int>& distance) {\\n\\t\\tint n=s.size();\\n\\n\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\tfor(int j=i+1;j<n;j++){\\n\\t\\t\\t\\tif(s[i]==s[j]){\\n\\t\\t\\t\\t\\tif(j-i-1 != distance[s[i]-\\'a\\']){//(s[i]-\\'a\\' helps to access the particular character)\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527598,
                "title": "python-dictionary-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def checkDistances(self, s: str, distance: List[int]) -> bool:        \\n        hashmap = {}\\n        for i in range(len(s)):\\n            if s[i] in hashmap and i - hashmap[s[i]] - 1 != distance[ord(s[i]) - ord(\\'a\\')]:\\n                return False\\n            hashmap[s[i]] = i                           \\n        return True\\n```\\n\\t\\t\\nTime Complexitiey: O(n)\\nSpace Complexitiey: O(n)\\n                \\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkDistances(self, s: str, distance: List[int]) -> bool:        \\n        hashmap = {}\\n        for i in range(len(s)):\\n            if s[i] in hashmap and i - hashmap[s[i]] - 1 != distance[ord(s[i]) - ord(\\'a\\')]:\\n                return False\\n            hashmap[s[i]] = i                           \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527546,
                "title": "easy-java-solution-map",
                "content": "# **Check Distances Between Same Letters**\\n\\n**Approach:**\\n1.) We iterate over the String and create a hashmap\\n2.) While iterating if the character is not in hashmap, we put it in hashmap\\n3.) If character is in hashmap we compute the number of letter between the two occurences by cuurIndex-ma.get(char)-1 and check if this matche with distance provided in the array\\n\\n**Time Complexity: O(n)**\\n\\n```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        //Creating a HashMap\\n        HashMap<Character,Integer> map=new HashMap<Character,Integer>();\\n        //Iterating over the String\\n        for(int i=0;i<s.length();i++){\\n            //If map doesn\\'t conatins Key then putting it in hashMap\\n            if(!map.containsKey(s.charAt(i))){\\n                map.put(s.charAt(i),i);\\n            }\\n            //If it contains Key then updating diatnce between the current and previous occurence\\n            else{\\n                int prev=map.get(s.charAt(i));\\n                int index=s.charAt(i)-\\'a\\';\\n                //Checking is the computed distance matches with the provided distance\\n                if(distance[index]!=i-prev-1){\\n                    return false;\\n                }\\n                \\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        //Creating a HashMap\\n        HashMap<Character,Integer> map=new HashMap<Character,Integer>();\\n        //Iterating over the String\\n        for(int i=0;i<s.length();i++){\\n            //If map doesn\\'t conatins Key then putting it in hashMap\\n            if(!map.containsKey(s.charAt(i))){\\n                map.put(s.charAt(i),i);\\n            }\\n            //If it contains Key then updating diatnce between the current and previous occurence\\n            else{\\n                int prev=map.get(s.charAt(i));\\n                int index=s.charAt(i)-\\'a\\';\\n                //Checking is the computed distance matches with the provided distance\\n                if(distance[index]!=i-prev-1){\\n                    return false;\\n                }\\n                \\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527507,
                "title": "cpp-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n        vector<int> v(26);\\n        int i=0;\\n        for(char c:s){\\n            if(v[c-\\'a\\'] && distance[c-\\'a\\']!=i-v[c-\\'a\\'])return false;\\n            v[c-\\'a\\']=++i;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n        vector<int> v(26);\\n        int i=0;\\n        for(char c:s){\\n            if(v[c-\\'a\\'] && distance[c-\\'a\\']!=i-v[c-\\'a\\'])return false;\\n            v[c-\\'a\\']=++i;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527275,
                "title": "c-easy-self-explanatory-bruteforce",
                "content": "**Do UPVOTE if it helps :)**\\n```\\nbool checkDistances(string s, vector<int>& distance) {\\n        int n =s.length();\\n        for(int i=0;i<n;i++)\\n            for(int j=i+1;j<n;j++)\\n                if(s[i]==s[j])\\n                    if(j-i-1 != distance[s[i]-\\'a\\']) return false;\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nbool checkDistances(string s, vector<int>& distance) {\\n        int n =s.length();\\n        for(int i=0;i<n;i++)\\n            for(int j=i+1;j<n;j++)\\n                if(s[i]==s[j])\\n                    if(j-i-1 != distance[s[i]-\\'a\\']) return false;\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2555730,
                "title": "beginner-friendly-java-javascript-python-solution",
                "content": "**Time Complexity : O(n)**\\n**Java**\\n```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        int[] arr = new int[26];\\n        for(int i=0; i<s.length(); i++){\\n            if(arr[s.charAt(i) - \\'a\\'] != 0 && i - arr[s.charAt(i) - \\'a\\'] != distance[s.charAt(i) - \\'a\\'])    \\n                return false;\\n            arr[s.charAt(i) - \\'a\\'] = i+1;\\n        }\\n        return true;\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nvar checkDistances = function(s, distance) {\\n    let arr = Array(26).fill(0)\\n    for(let i=0; i<s.length; i++){\\n        if(arr[s.charCodeAt(i) - 97] != 0 && i - arr[s.charCodeAt(i) - 97] != distance[s.charCodeAt(i) - 97])    \\n            return false\\n        arr[s.charCodeAt(i) - 97] = i+1\\n    }\\n    return true\\n};\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def checkDistances(self, s, distance):\\n        arr = [0]*26\\n        for i in range(len(s)):\\n            if arr[ord(s[i]) - 97] != 0 and i - arr[ord(s[i]) - 97] != distance[ord(s[i]) - 97]:\\n                return False\\n            arr[ord(s[i]) - 97] = i+1\\n        return True\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        int[] arr = new int[26];\\n        for(int i=0; i<s.length(); i++){\\n            if(arr[s.charAt(i) - \\'a\\'] != 0 && i - arr[s.charAt(i) - \\'a\\'] != distance[s.charAt(i) - \\'a\\'])    \\n                return false;\\n            arr[s.charAt(i) - \\'a\\'] = i+1;\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nvar checkDistances = function(s, distance) {\\n    let arr = Array(26).fill(0)\\n    for(let i=0; i<s.length; i++){\\n        if(arr[s.charCodeAt(i) - 97] != 0 && i - arr[s.charCodeAt(i) - 97] != distance[s.charCodeAt(i) - 97])    \\n            return false\\n        arr[s.charCodeAt(i) - 97] = i+1\\n    }\\n    return true\\n};\\n```\n```\\nclass Solution(object):\\n    def checkDistances(self, s, distance):\\n        arr = [0]*26\\n        for i in range(len(s)):\\n            if arr[ord(s[i]) - 97] != 0 and i - arr[ord(s[i]) - 97] != distance[ord(s[i]) - 97]:\\n                return False\\n            arr[ord(s[i]) - 97] = i+1\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527596,
                "title": "beginner-o-n-2-and-linear-solution-with-explanation",
                "content": "**O(N^2) Approach:** For each character `s[i]`, check for all other characters `s[j]` where `j` ranges from `i+1` to `n`. Compare the distance when `i th` and `j th` character is same.\\n```\\nbool checkDistances(string s, vector<int>& dist) {\\n\\tint n = s.size();\\n\\tfor(int i=0; i<n-1; i++)\\n\\t\\tfor(int j=i+1; j<n; j++)\\n\\t\\t\\tif(s[i] == s[j] && j-i-1 != dist[s[i]-\\'a\\'])\\n\\t\\t\\t\\treturn false;\\n\\treturn true;\\n}\\n```\\n**O(N) Approach:** Keep the index of the first occurrence of the element and compare the distance when we come across it the second time.\\n```\\nbool checkDistances(string s, vector<int>& dist) {\\n        int n = s.size();\\n        vector<int> v(26, -1);\\n        for(int i=0; i<n; i++){\\n            if(v[s[i]-\\'a\\'] == -1) v[s[i]-\\'a\\'] = i;\\n            else if(i-v[s[i]-\\'a\\']-1 != dist[s[i]-\\'a\\']) return false;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool checkDistances(string s, vector<int>& dist) {\\n\\tint n = s.size();\\n\\tfor(int i=0; i<n-1; i++)\\n\\t\\tfor(int j=i+1; j<n; j++)\\n\\t\\t\\tif(s[i] == s[j] && j-i-1 != dist[s[i]-\\'a\\'])\\n\\t\\t\\t\\treturn false;\\n\\treturn true;\\n}\\n```\n```\\nbool checkDistances(string s, vector<int>& dist) {\\n        int n = s.size();\\n        vector<int> v(26, -1);\\n        for(int i=0; i<n; i++){\\n            if(v[s[i]-\\'a\\'] == -1) v[s[i]-\\'a\\'] = i;\\n            else if(i-v[s[i]-\\'a\\']-1 != dist[s[i]-\\'a\\']) return false;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2527480,
                "title": "c-two-pointers",
                "content": "if you get the both position,\\n1. calculate distance\\n2. check if distance is equal in distance array.\\n3. if not return false\\n4. if yes mark as those elements are visited.\\n\\nsimple intitutioin behind this questin.\\n\\n```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n        for(int i = 0; i < s.size()-1; i++)\\n        {\\n            if(s[i] == \\'#\\')\\n                continue;\\n            int ct = 0;\\n            for(int j = i+1; j < s.size(); j++)\\n            {\\n                \\n                if(s[i] == s[j])\\n                {\\n                    s[j] = \\'#\\';\\n                    break;\\n                }\\n                else\\n                    ct++;\\n            }\\n            if(distance[s[i]-\\'a\\'] != ct)\\n                return false;\\n            s[i] = \\'#\\';\\n            \\n        }\\n        \\n        return true;\\n    }\\n};\\n``",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n        for(int i = 0; i < s.size()-1; i++)\\n        {\\n            if(s[i] == \\'#\\')\\n                continue;\\n            int ct = 0;\\n            for(int j = i+1; j < s.size(); j++)\\n            {\\n                \\n                if(s[i] == s[j])\\n                {\\n                    s[j] = \\'#\\';\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2527299,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] d) {\\n        for(int i=0;i<26;i++)\\n        {\\n            char c = (char)(\\'a\\'+i);\\n            if(s.contains(String.valueOf(c)))\\n            {\\n                int k = s.indexOf(c);\\n                int p = s.lastIndexOf(c);\\n                if(p-k-1!=d[i])\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "class Solution {\\n    public boolean checkDistances(String s, int[] d) {\\n        for(int i=0;i<26;i++)\\n        {\\n            char c = (char)(\\'a\\'+i);\\n            if(s.contains(String.valueOf(c)))\\n            {\\n                int k = s.indexOf(c);\\n                int p = s.lastIndexOf(c);\\n                if(p-k-1!=d[i])\\n                    return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3793068,
                "title": "beats-in-runtime-beginner-friendly-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        HashSet<Character> set = new HashSet<>();\\n        for(int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            int ind = 0;\\n            if(set.contains(c)) {\\n                continue;\\n            }\\n            for(int j = i+1; j < s.length(); j++){ \\n                if(s.charAt(j) == c) {\\n                    ind = j;\\n                }\\n            }\\n            set.add(c);\\n            if(ind-i-1 != distance[c - \\'a\\']){ \\n                return false;\\n            }\\n        }\\n        return true;\\n       // if it is helpful, pls upvote it.\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        HashSet<Character> set = new HashSet<>();\\n        for(int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            int ind = 0;\\n            if(set.contains(c)) {\\n                continue;\\n            }\\n            for(int j = i+1; j < s.length(); j++){ \\n                if(s.charAt(j) == c) {\\n                    ind = j;\\n                }\\n            }\\n            set.add(c);\\n            if(ind-i-1 != distance[c - \\'a\\']){ \\n                return false;\\n            }\\n        }\\n        return true;\\n       // if it is helpful, pls upvote it.\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2920995,
                "title": "100-faster-python-solution",
                "content": "![Screenshot 2022-12-17 at 13.49.53.png](https://assets.leetcode.com/users/images/868b2314-1f18-407b-88fa-b8b358c3f4be_1671267032.841997.png)\\n\\n- In the loop, we need to find and divide the index of the next letter of the letter `s[i]`, and if the difference between these two values is not equal to each other, then we just set the result as `False`. If there is no `False` result, then the answer is `True`. Inside the loop I used `try` and `except` because inside s a letter is repeated twice or 0 times, so when we get a letter the second time it comes and no similar letter comes after it, we have index an error occurs because we use the function.\\n# Code\\n```\\nclass Solution:\\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\\n        for i in range(len(s)):\\n            try:\\n                if s[i+1:].index(s[i])!=distance[ord(s[i])-97]: return False\\n            except: pass\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\\n        for i in range(len(s)):\\n            try:\\n                if s[i+1:].index(s[i])!=distance[ord(s[i])-97]: return False\\n            except: pass\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2530395,
                "title": "c-keep-an-index-of-the-first-occurrence-clean-code-easy-to-understand-fast-0ms",
                "content": "### Solution 1: keep an index of the first occurrence\\n\\nWe actually keep track of the first occurrence plus one, with that we can just initialize the index with zeros and we would need to substract this one when checking the distance anyway. We are using an ```array<>``` here as it has less overhead than ```vector```. A ```vector``` would have the benefit that we could conveniently initialize with -1s, for the ```array<int, 26>``` we would need to call ```fill(begin(pos), end(pos), -1)```. \\n\\n```\\n    bool checkDistances(const string& s, const vector<int>& distance) {\\n        array<int, 26> pos = {};\\n        for (int i = 0; i < size(s); ++i) {\\n            const char ch = s[i] - \\'a\\';\\n            if (pos[ch]) {\\n                if (i - pos[ch] != distance[ch]) return false;\\n            } else {\\n                pos[ch] = i + 1;\\n            }\\n        }\\n        return true;\\n    }\\n```\\t\\n\\n**Complexity Analysis**\\n  * Time Complexity: O(size(s)), we need to look at each charter once\\n  * Space Complexity: O(1), the ```pos``` is always of size 26 * sizeof(int) regardless of the size of the input.",
                "solutionTags": [
                    "C"
                ],
                "code": "```array<>```\n```vector```\n```vector```\n```array<int, 26>```\n```fill(begin(pos), end(pos), -1)```\n```\\n    bool checkDistances(const string& s, const vector<int>& distance) {\\n        array<int, 26> pos = {};\\n        for (int i = 0; i < size(s); ++i) {\\n            const char ch = s[i] - \\'a\\';\\n            if (pos[ch]) {\\n                if (i - pos[ch] != distance[ch]) return false;\\n            } else {\\n                pos[ch] = i + 1;\\n            }\\n        }\\n        return true;\\n    }\\n```\n```pos```",
                "codeTag": "Unknown"
            },
            {
                "id": 2529820,
                "title": "easy-solution-using-string-functions",
                "content": "class Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& v) {\\n        \\n        int n=26;\\n        for(int i=0;i<26;i++)\\n        {\\n            int t=97+i;\\n            char ch=t;\\n            int x=s.find(t);\\n            int y=s.rfind(t);\\n            if(y==-1)continue;\\n            if((y-x-1)!=v[i])return false;\\n        }\\n        return true;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& v) {\\n        \\n        int n=26;\\n        for(int i=0;i<26;i++)\\n        {\\n            int t=97+i;\\n            char ch=t;\\n            int x=s.find(t);\\n            int y=s.rfind(t);\\n            if(y==-1)continue;\\n            if((y-x-1)!=v[i])return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2527713,
                "title": "c-faster-than-100-two-approaches",
                "content": "To get index of distance for current string element, we need to substract \\n\\t\\tcurr element from \\'a\\'.\\n\\t\\t* cur = a, it\\'s corresponding distance index ==  a - a = 0\\n\\t\\t* cur = b, b - a = 1\\n\\t\\t* cur = c, c - a = 2\\n\\nApproach 1:  SC -> O(1)\\n\\t \\n ```\\nbool checkDistances(string s, vector<int>& distance) {\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            char cur = s[i];\\n            for (int j = i+1; j < s.size(); j++)\\n            {\\n                if (s[i] == s[j])\\n                {\\n                   int dist = j - i - 1; \\n                   if (distance[cur - \\'a\\'] != dist)\\n                       return false;\\n                }\\n            }\\n        }\\n```\\n\\nApproach 2: using map , SC -> O(n)\\n\\n```\\nbool checkDistances(string s, vector<int>& distance) {\\n        map<char,bool> marked;\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            if (marked[s[i]] == 0)\\n            {\\n                marked[s[i]] = 1;\\n                char curr = s[i];\\n                int cnt = 0;\\n                for (int j = i+1; (s[j] != s[i]) && j < s.size(); j++)\\n                {\\n                        cnt++;\\n                }\\n                if (distance[curr - \\'a\\'] != cnt)\\n                    return false;\\n                }\\n        }\\n        return true;\\n    }\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nbool checkDistances(string s, vector<int>& distance) {\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            char cur = s[i];\\n            for (int j = i+1; j < s.size(); j++)\\n            {\\n                if (s[i] == s[j])\\n                {\\n                   int dist = j - i - 1; \\n                   if (distance[cur - \\'a\\'] != dist)\\n                       return false;\\n                }\\n            }\\n        }\\n```\n```\\nbool checkDistances(string s, vector<int>& distance) {\\n        map<char,bool> marked;\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            if (marked[s[i]] == 0)\\n            {\\n                marked[s[i]] = 1;\\n                char curr = s[i];\\n                int cnt = 0;\\n                for (int j = i+1; (s[j] != s[i]) && j < s.size(); j++)\\n                {\\n                        cnt++;\\n                }\\n                if (distance[curr - \\'a\\'] != cnt)\\n                    return false;\\n                }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2527669,
                "title": "c-solution-constant-space",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n        int n=s.length();\\n    for(int i=0;i<n;i++){\\n        if(distance[s[i]-\\'a\\']==-1){\\n\\t\\t//marked as not valid in the previous visit so return false \\n            return false;\\n        }\\n       \\n            \\n            int next=distance[s[i]-\\'a\\']+1+i;\\n            if(next<n&&s[next]==s[i]){\\n                //do nothing because another occurance present at next \\n            }\\n            else{\\n                distance[s[i]-\\'a\\']=-1;\\n\\t\\t\\t\\t//second visit or next occurance not present \\n\\t\\t\\t\\t//next time if accessed again return false;\\n            }\\n        \\n\\n    }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n        int n=s.length();\\n    for(int i=0;i<n;i++){\\n        if(distance[s[i]-\\'a\\']==-1){\\n\\t\\t//marked as not valid in the previous visit so return false \\n            return false;\\n        }\\n       \\n            \\n            int next=distance[s[i]-\\'a\\']+1+i;\\n            if(next<n&&s[next]==s[i]){\\n                //do nothing because another occurance present at next \\n            }\\n            else{\\n                distance[s[i]-\\'a\\']=-1;\\n\\t\\t\\t\\t//second visit or next occurance not present \\n\\t\\t\\t\\t//next time if accessed again return false;\\n            }\\n        \\n\\n    }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527372,
                "title": "javascript-map-tc-o-n-sc-o-n",
                "content": "```\\n/**\\n * @param {string} s\\n * @param {number[]} distance\\n * @return {boolean}\\n */\\nvar checkDistances = function(s, distance) {\\n    const map = {};\\n    \\n    for (let i = 0; i < s.length; i++) {\\n        if (map[s[i]] !== undefined) {\\n            const diff = i - map[s[i]] - 1;\\n            const charCode = s[i].charCodeAt() - 97;\\n            if (distance[charCode] !== diff) {\\n                return false;\\n            }\\n        } else {\\n            map[s[i]] = i;\\n        }\\n    }\\n    \\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {number[]} distance\\n * @return {boolean}\\n */\\nvar checkDistances = function(s, distance) {\\n    const map = {};\\n    \\n    for (let i = 0; i < s.length; i++) {\\n        if (map[s[i]] !== undefined) {\\n            const diff = i - map[s[i]] - 1;\\n            const charCode = s[i].charCodeAt() - 97;\\n            if (distance[charCode] !== diff) {\\n                return false;\\n            }\\n        } else {\\n            map[s[i]] = i;\\n        }\\n    }\\n    \\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2527301,
                "title": "find-left-and-right-index-explained",
                "content": "We know that there are only 2 occurences of the same character in S if it exists.\\nAnd it must be distanced distance[char] from each other.\\n\\nWe can find the index on the left and right side and check whether the distance is distance[char].\\nIf the character doesn\\'t exist we ignore.\\n\\n```\\nclass Solution:\\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\\n        for char in range(26):\\n            c = chr(char + ord(\\'a\\'))\\n            left = s.find(c)\\n            right = s.rfind(c)\\n            \\n            # Ignore if character doesn\\'t exist\\n            if left == -1: continue\\n\\n            if right - left - 1 != distance[char]:\\n                return False\\n        \\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\\n        for char in range(26):\\n            c = chr(char + ord(\\'a\\'))\\n            left = s.find(c)\\n            right = s.rfind(c)\\n            \\n            # Ignore if character doesn\\'t exist\\n            if left == -1: continue\\n\\n            if right - left - 1 != distance[char]:\\n                return False\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776721,
                "title": "js-very-easy-solution-with-o-n",
                "content": "# Code\\n```\\n/**\\n * @param {string} s\\n * @param {number[]} distance\\n * @return {boolean}\\n */\\nvar checkDistances = function(s, distance) {\\n    const hashmap = new Map();\\n\\n    for (let i = 0; i < s.length; i++) {\\n        const character = s[i];\\n        if (hashmap.has(character)) {\\n            if (i - hashmap.get(character) - 1 !== distance[s.charCodeAt(i) - 97]) return false;\\n        } else {\\n            hashmap.set(character, i);\\n        }\\n    }\\n\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {number[]} distance\\n * @return {boolean}\\n */\\nvar checkDistances = function(s, distance) {\\n    const hashmap = new Map();\\n\\n    for (let i = 0; i < s.length; i++) {\\n        const character = s[i];\\n        if (hashmap.has(character)) {\\n            if (i - hashmap.get(character) - 1 !== distance[s.charCodeAt(i) - 97]) return false;\\n        } else {\\n            hashmap.set(character, i);\\n        }\\n    }\\n\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2776449,
                "title": "java-6-liner-easy-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n      HashMap<Character, Integer> map = new HashMap<>();\\n      for(int i = 0; i < s.length(); i ++) {\\n          if(! map.containsKey(s.charAt(i)))\\n           map.put(s.charAt(i), i + 1);\\n\\n          else if(distance[s.charAt(i)-\\'a\\'] != i-map.get(s.charAt(i)))\\n           return false; \\n      }\\n      return true;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n      HashMap<Character, Integer> map = new HashMap<>();\\n      for(int i = 0; i < s.length(); i ++) {\\n          if(! map.containsKey(s.charAt(i)))\\n           map.put(s.charAt(i), i + 1);\\n\\n          else if(distance[s.charAt(i)-\\'a\\'] != i-map.get(s.charAt(i)))\\n           return false; \\n      }\\n      return true;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724133,
                "title": "easiest-c-solution-o-n-solution-o-1-space",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n        for(int i=0;i<s.length();i++){\\n            if(distance[s[i]-97]!=-1){\\n                int next=i+(distance[s[i]-97]+1);\\n\\n                if((next>=s.length())||(next<s.length() && s[next]!=s[i])){\\n                    return false;\\n                }\\n                distance[s[i]-97]=-1;\\n            }\\n\\n        }\\n        return true;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n        for(int i=0;i<s.length();i++){\\n            if(distance[s[i]-97]!=-1){\\n                int next=i+(distance[s[i]-97]+1);\\n\\n                if((next>=s.length())||(next<s.length() && s[next]!=s[i])){\\n                    return false;\\n                }\\n                distance[s[i]-97]=-1;\\n            }\\n\\n        }\\n        return true;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2667547,
                "title": "c-solution-easy-to-understand",
                "content": "\\t******Please Upvote if you like my solution !!!! :)******\\n\\t\\n\\t     unordered_map<int,int>mp;\\n\\t\\t \\n        for(int i=0;i<s.size();i++)\\n        {\\n \\n            if(mp.find(s[i]-\\'a\\')==mp.end())\\n            {\\n                mp[(s[i]-\\'a\\')]=i;\\n            }\\n            else\\n            {\\n                int dist=(i-mp[(s[i]-\\'a\\')])-1;\\n                if(dist!=distance[(s[i]-\\'a\\')])\\n                    return false;\\n            }\\n            \\n        }\\n        return true;\\n\\t\\t\\n\\t\\t\\n\\t\\tWe need to keep track of first occurence of the letter in the map ,\\n\\t\\tthen if we come across the same letter while iterating over the string , \\n\\t\\twe calculate the distance between the current and the same letter in the map\\n\\t\\tas (currIndex-indexInMap)-1 , this gives the number of characters in between . \\n\\t\\tIf this distance is not equal to the value in distance array we return false else true.\\n",
                "solutionTags": [],
                "code": "\\t******Please Upvote if you like my solution !!!! :)******\\n\\t\\n\\t     unordered_map<int,int>mp;\\n\\t\\t \\n        for(int i=0;i<s.size();i++)\\n        {\\n \\n            if(mp.find(s[i]-\\'a\\')==mp.end())\\n            {\\n                mp[(s[i]-\\'a\\')]=i;\\n            }\\n            else\\n            {\\n                int dist=(i-mp[(s[i]-\\'a\\')])-1;\\n                if(dist!=distance[(s[i]-\\'a\\')])\\n                    return false;\\n            }\\n            \\n        }\\n        return true;\\n\\t\\t\\n\\t\\t\\n\\t\\tWe need to keep track of first occurence of the letter in the map ,\\n\\t\\tthen if we come across the same letter while iterating over the string , \\n\\t\\twe calculate the distance between the current and the same letter in the map\\n\\t\\tas (currIndex-indexInMap)-1 , this gives the number of characters in between . \\n\\t\\tIf this distance is not equal to the value in distance array we return false else true.\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2667291,
                "title": "easy-and-simple-python-solution",
                "content": "```\\nclass Solution:\\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\\n        dic={}\\n        letter=97\\n        for i in distance:\\n            dic[chr(letter)]=i\\n            letter+=1\\n\\n        for i in set(s):\\n            first=s.index(i)\\n            last=s.rindex(i)\\n            diff=last-first-1\\n            if dic[i]!=diff:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\\n        dic={}\\n        letter=97\\n        for i in distance:\\n            dic[chr(letter)]=i\\n            letter+=1\\n\\n        for i in set(s):\\n            first=s.index(i)\\n            last=s.rindex(i)\\n            diff=last-first-1\\n            if dic[i]!=diff:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2664918,
                "title": "tracking-first-occurrences",
                "content": "##### Java\\n```java\\npublic boolean checkDistances(String s, int[] distance) {\\n        int[] firstOccurrences = new int[26];\\n        Arrays.fill(firstOccurrences, -1);\\n\\n        for (int i = 0; i < s.length(); ++i) {\\n            int letterNumber = s.charAt(i) - \\'a\\';\\n            if (firstOccurrences[letterNumber] == -1)\\n                firstOccurrences[letterNumber] = i;\\n            else\\n                if (distance[letterNumber] != i - firstOccurrences[letterNumber] - 1)\\n                    return false;\\n        }\\n        return true;\\n    }\\n```\\n\\n##### C++\\n```c++\\npublic:\\n    bool checkDistances(string s, vector<int> &distance) {\\n        vector<int> firstOccurrences(26, -1);\\n\\n        for (int i = 0; i < s.size(); ++i) {\\n            int letterNumber = s[i] - \\'a\\';\\n            if (firstOccurrences[letterNumber] == -1)\\n                firstOccurrences[letterNumber] = i;\\n            else\\n                if (distance[letterNumber] != i - firstOccurrences[letterNumber] - 1)\\n                    return false;\\n        }\\n\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```java\\npublic boolean checkDistances(String s, int[] distance) {\\n        int[] firstOccurrences = new int[26];\\n        Arrays.fill(firstOccurrences, -1);\\n\\n        for (int i = 0; i < s.length(); ++i) {\\n            int letterNumber = s.charAt(i) - \\'a\\';\\n            if (firstOccurrences[letterNumber] == -1)\\n                firstOccurrences[letterNumber] = i;\\n            else\\n                if (distance[letterNumber] != i - firstOccurrences[letterNumber] - 1)\\n                    return false;\\n        }\\n        return true;\\n    }\\n```\n```c++\\npublic:\\n    bool checkDistances(string s, vector<int> &distance) {\\n        vector<int> firstOccurrences(26, -1);\\n\\n        for (int i = 0; i < s.size(); ++i) {\\n            int letterNumber = s[i] - \\'a\\';\\n            if (firstOccurrences[letterNumber] == -1)\\n                firstOccurrences[letterNumber] = i;\\n            else\\n                if (distance[letterNumber] != i - firstOccurrences[letterNumber] - 1)\\n                    return false;\\n        }\\n\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2647563,
                "title": "java-using-indexof-with-comments",
                "content": "```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        // for each char in s to char array\\n        for (char c : s.toCharArray()) {\\n            // init first to s index of char\\n            int first = s.indexOf(c);\\n            // init second to s last index of char\\n            int second = s.lastIndexOf(c);\\n\\n            // if distance at char - \\'a\\' is not equal to second minus first minus 1\\n            if (distance[c - \\'a\\'] != second - first - 1) {\\n                // return false\\n                return false;\\n            }\\n        }\\n        \\n        // return true\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        // for each char in s to char array\\n        for (char c : s.toCharArray()) {\\n            // init first to s index of char\\n            int first = s.indexOf(c);\\n            // init second to s last index of char\\n            int second = s.lastIndexOf(c);\\n\\n            // if distance at char - \\'a\\' is not equal to second minus first minus 1\\n            if (distance[c - \\'a\\'] != second - first - 1) {\\n                // return false\\n                return false;\\n            }\\n        }\\n        \\n        // return true\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2531810,
                "title": "simple-solution-keeps-track-of-first-and-last-position",
                "content": "Time complexity: O(N) length of the string\\nSpace complexity: O(1) hashmap with constant length 26\\n```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n        unordered_map<int, vector<int>> hash(26);\\n        for (int i = 0; i < s.size(); ++ i) hash[s[i] - \\'a\\'].emplace_back(i);\\n        for (int i = 0; i < 26; ++ i) {\\n            if (hash.count(i)) {\\n                int d = hash[i][1] - hash[i][0] - 1;\\n                if (distance[i] != d) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n        unordered_map<int, vector<int>> hash(26);\\n        for (int i = 0; i < s.size(); ++ i) hash[s[i] - \\'a\\'].emplace_back(i);\\n        for (int i = 0; i < 26; ++ i) {\\n            if (hash.count(i)) {\\n                int d = hash[i][1] - hash[i][0] - 1;\\n                if (distance[i] != d) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2529718,
                "title": "c-unordered-map-easy-solution",
                "content": "```\\nbool checkDistances(string s, vector<int>& distance) {\\n        unordered_map<char,int>m;\\n        for(int i=0;i<s.length();i++){\\n            int j=s[i]-\\'a\\';\\n            if(m.find(s[i])==m.end())\\n                m.insert({s[i],i});\\n            else if(i-m[s[i]]-1!=distance[j])\\n                return false;\\n        }\\n        return true;\\n    }\\n```\\t",
                "solutionTags": [],
                "code": "```\\nbool checkDistances(string s, vector<int>& distance) {\\n        unordered_map<char,int>m;\\n        for(int i=0;i<s.length();i++){\\n            int j=s[i]-\\'a\\';\\n            if(m.find(s[i])==m.end())\\n                m.insert({s[i],i});\\n            else if(i-m[s[i]]-1!=distance[j])\\n                return false;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2529388,
                "title": "python-iterative-easy",
                "content": "# Simple approch\\n## Time -> O(n^2)   {n <= 32}\\n## Space -> O(1)\\n```\\nclass Solution:\\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\\n        n = len(s)\\n        for i in range(n-1):\\n            for j in range(i+1,n):\\n                if s[i] == s[j]:\\n                    if distance[ord(s[i]) - 97]  != (j - i - 1):\\n                        return False\\n                    else:\\n                        break\\n        return True\\n```\\n\\n### \\uD83D\\uDE02 Random Dev Meme\\n<img src=\"https://random-memer.herokuapp.com/\" width=\"400px\"/>\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\\n        n = len(s)\\n        for i in range(n-1):\\n            for j in range(i+1,n):\\n                if s[i] == s[j]:\\n                    if distance[ord(s[i]) - 97]  != (j - i - 1):\\n                        return False\\n                    else:\\n                        break\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2529015,
                "title": "swift-o-n-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    func checkDistances(_ s: String, _ distance: [Int]) -> Bool {\\n        var lettersMap: [Character: Int] = [:]\\n        for (i, c) in s.enumerated() {\\n            if let letter = lettersMap[c] {\\n                lettersMap[c] = i - letter - 1\\n            } else {\\n                lettersMap[c] = i\\n            }\\n        }\\n        \\n        for letter in lettersMap {\\n            if letter.value != distance[Int(letter.key.asciiValue! - Character(\"a\").asciiValue!)] {\\n                return false\\n            }\\n        }\\n        \\n        return true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func checkDistances(_ s: String, _ distance: [Int]) -> Bool {\\n        var lettersMap: [Character: Int] = [:]\\n        for (i, c) in s.enumerated() {\\n            if let letter = lettersMap[c] {\\n                lettersMap[c] = i - letter - 1\\n            } else {\\n                lettersMap[c] = i\\n            }\\n        }\\n        \\n        for letter in lettersMap {\\n            if letter.value != distance[Int(letter.key.asciiValue! - Character(\"a\").asciiValue!)] {\\n                return false\\n            }\\n        }\\n        \\n        return true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2528150,
                "title": "java-easy-set-linear-time-fast-solution",
                "content": "```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        char[] str = s.toCharArray();\\n        boolean set[] = new boolean[26];\\n        Integer start[] = new Integer[26],end[] = new Integer[26];\\n        int i,j,res,n=str.length,ind;\\n        for(i=0;i<n;i++){\\n            ind = str[i]-\\'a\\';\\n            if(start[ind]==null) start[ind]=i;\\n            else end[ind]=i;\\n            set[ind]=true;\\n        }\\n        for(i=0;i<26;i++){\\n            if(set[i] && distance[i]!=(end[i]-start[i]-1)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        char[] str = s.toCharArray();\\n        boolean set[] = new boolean[26];\\n        Integer start[] = new Integer[26],end[] = new Integer[26];\\n        int i,j,res,n=str.length,ind;\\n        for(i=0;i<n;i++){\\n            ind = str[i]-\\'a\\';\\n            if(start[ind]==null) start[ind]=i;\\n            else end[ind]=i;\\n            set[ind]=true;\\n        }\\n        for(i=0;i<26;i++){\\n            if(set[i] && distance[i]!=(end[i]-start[i]-1)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2528079,
                "title": "c-track-position-very-easy-code",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n        vector<int> a(26,-1);\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int t=a[s[i]-\\'a\\'];\\n            if(t==-1)\\n                a[s[i]-\\'a\\']=i;\\n            else\\n            {\\n                t=i-t-1;\\n                if(distance[s[i]-\\'a\\']!=t)\\n                    return 0;\\n            }\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n        vector<int> a(26,-1);\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int t=a[s[i]-\\'a\\'];\\n            if(t==-1)\\n                a[s[i]-\\'a\\']=i;\\n            else\\n            {\\n                t=i-t-1;\\n                if(distance[s[i]-\\'a\\']!=t)\\n                    return 0;\\n            }\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527700,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Hashmap***\\n\\n* ***Time Complexity :- O(N * Constant)***\\n\\n* ***Space Complexity :- O(Constant)***\\n\\n```\\nclass Solution {\\npublic:\\n    bool checkDistances(string str, vector<int>& distance) {\\n        \\n        int n = str.size();\\n        \\n        vector<int> dist(26, 0);\\n        \\n        for(char ch = \\'a\\'; ch <= \\'z\\'; ch++)\\n        {\\n            int first = -1;\\n            \\n            int second = -1;\\n            \\n            // find the first and last index of ch\\n            \\n            for(int i = 0; i < n; i++)\\n            {\\n                if(str[i] == ch && first == -1)\\n                {\\n                    first = i;\\n                }\\n                else if(str[i] == ch && first != -1)\\n                {\\n                    second = i;\\n                }\\n            }\\n            \\n            if(first != -1 && second != -1)\\n            {\\n                dist[ch - \\'a\\'] = abs(second - first) - 1;\\n                \\n                if(dist[ch - \\'a\\'] != distance[ch - \\'a\\'])\\n                    return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkDistances(string str, vector<int>& distance) {\\n        \\n        int n = str.size();\\n        \\n        vector<int> dist(26, 0);\\n        \\n        for(char ch = \\'a\\'; ch <= \\'z\\'; ch++)\\n        {\\n            int first = -1;\\n            \\n            int second = -1;\\n            \\n            // find the first and last index of ch\\n            \\n            for(int i = 0; i < n; i++)\\n            {\\n                if(str[i] == ch && first == -1)\\n                {\\n                    first = i;\\n                }\\n                else if(str[i] == ch && first != -1)\\n                {\\n                    second = i;\\n                }\\n            }\\n            \\n            if(first != -1 && second != -1)\\n            {\\n                dist[ch - \\'a\\'] = abs(second - first) - 1;\\n                \\n                if(dist[ch - \\'a\\'] != distance[ch - \\'a\\'])\\n                    return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527633,
                "title": "two-c-solutions-linear-complexity",
                "content": "1. O(n) time, O(n) space, n = s.length\\n```cpp\\nclass Solution {\\npublic:\\n    bool checkDistances(string &s, vector<int> &dist) {\\n        unordered_map<char, vector<int>> mp;\\n        for (int i = 0; i < s.size(); i++) {\\n            mp[s[i]].push_back(i);\\n        }\\n        for (auto &[key, val] : mp) {\\n            if (dist[key - \\'a\\'] != abs(val[1] - val[0] - 1)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n<br>\\n\\n2. O(n) time, O(1) space, n = s.length\\n```cpp\\nclass Solution {\\npublic:\\n    bool checkDistances(string &s, vector<int> &dist) {\\n        int pos[26]{0};\\n        for (int i = 0; i < s.size(); ++i) {\\n            int n = s[i] - \\'a\\';\\n            if (pos[n] > 0 && dist[n] + pos[n] != i) {\\n                return false;\\n            }\\n            pos[n] = i + 1;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\nPlease do **upvote/share** if you like it.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool checkDistances(string &s, vector<int> &dist) {\\n        unordered_map<char, vector<int>> mp;\\n        for (int i = 0; i < s.size(); i++) {\\n            mp[s[i]].push_back(i);\\n        }\\n        for (auto &[key, val] : mp) {\\n            if (dist[key - \\'a\\'] != abs(val[1] - val[0] - 1)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    bool checkDistances(string &s, vector<int> &dist) {\\n        int pos[26]{0};\\n        for (int i = 0; i < s.size(); ++i) {\\n            int n = s[i] - \\'a\\';\\n            if (pos[n] > 0 && dist[n] + pos[n] != i) {\\n                return false;\\n            }\\n            pos[n] = i + 1;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527276,
                "title": "c-easily-understandable-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) \\n    {\\n        int n = s.length();\\n        char tmp;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            tmp = s[i];                                 // first occurance of letter\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(tmp==s[j])                        // second occurance of letter\\n                {\\n\\t\\t\\t\\t    // if we don\\'t have same diff then return false\\n                    if((j-i-1)!=distance[tmp-\\'a\\']) return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) \\n    {\\n        int n = s.length();\\n        char tmp;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            tmp = s[i];                                 // first occurance of letter\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(tmp==s[j])                        // second occurance of letter\\n                {\\n\\t\\t\\t\\t    // if we don\\'t have same diff then return false\\n                    if((j-i-1)!=distance[tmp-\\'a\\']) return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3857409,
                "title": "easiest-approach-java-100-beats",
                "content": "# Code\\n```\\nclass Solution{\\n    public boolean checkDistances(String s, int[] distance){\\n        int[] ar1 = new int[26];\\n        Arrays.fill(ar1, -1);\\n        int[] ar2 = new int[26];\\n        Arrays.fill(ar2, -1);\\n        for(int i=0; i<s.length(); i++){\\n            if(ar1[s.charAt(i)-\\'a\\']!=-1) ar2[s.charAt(i)-\\'a\\'] = i;\\n            else ar1[s.charAt(i)-\\'a\\'] = i;\\n        }\\n        for(int i=0; i<26; i++){\\n            if(ar1[i]!=-1 && ar2[i]-ar1[i]-1!=distance[i]) return false;\\n        }\\n        return true;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution{\\n    public boolean checkDistances(String s, int[] distance){\\n        int[] ar1 = new int[26];\\n        Arrays.fill(ar1, -1);\\n        int[] ar2 = new int[26];\\n        Arrays.fill(ar2, -1);\\n        for(int i=0; i<s.length(); i++){\\n            if(ar1[s.charAt(i)-\\'a\\']!=-1) ar2[s.charAt(i)-\\'a\\'] = i;\\n            else ar1[s.charAt(i)-\\'a\\'] = i;\\n        }\\n        for(int i=0; i<26; i++){\\n            if(ar1[i]!=-1 && ar2[i]-ar1[i]-1!=distance[i]) return false;\\n        }\\n        return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835503,
                "title": "simple-dictionary-c-solution-and-self-explanatory",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n    public bool CheckDistances(string s, int[] distance) {\\n        Dictionary<char, int> dc = new Dictionary<char, int>();\\n        for(int i = 0 ; i < s.Length ; i++)\\n        {\\n            if(!dc.ContainsKey(s[i]))\\n                dc.Add(s[i], i);\\n            else\\n                dc[s[i]] = i - dc[s[i]] - 1;\\n        }\\n\\n        for(int i = 0; i < 26 ; i++)\\n        {\\n            if(s.Contains((char)(i + \\'a\\')))\\n            {\\n                if(dc[(char)(i + \\'a\\')] != distance[i])\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool CheckDistances(string s, int[] distance) {\\n        Dictionary<char, int> dc = new Dictionary<char, int>();\\n        for(int i = 0 ; i < s.Length ; i++)\\n        {\\n            if(!dc.ContainsKey(s[i]))\\n                dc.Add(s[i], i);\\n            else\\n                dc[s[i]] = i - dc[s[i]] - 1;\\n        }\\n\\n        for(int i = 0; i < 26 ; i++)\\n        {\\n            if(s.Contains((char)(i + \\'a\\')))\\n            {\\n                if(dc[(char)(i + \\'a\\')] != distance[i])\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663221,
                "title": "check-distance-between-same-letters",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n        int val=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            for(int j=i+1;j<s.size();j++)\\n            {\\n                 if(s[j]==s[i])\\n                {\\n                    val=(int)s[i]-97;\\n                    if((j-i-1)!=distance[val])\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n        int val=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            for(int j=i+1;j<s.size();j++)\\n            {\\n                 if(s[j]==s[i])\\n                {\\n                    val=(int)s[i]-97;\\n                    if((j-i-1)!=distance[val])\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3479424,
                "title": "java-simple-o-n-solution",
                "content": "```java\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        int[] range = new int[distance.length];\\n        Arrays.fill(range, -1);\\n\\n        for(int i = 0; i < s.length(); ++i) {\\n            int index = s.charAt(i) - \\'a\\';\\n\\n            if(range[index] != -1 && Math.abs(range[index] - i) != distance[index] + 1)\\n                return false;\\n\\n            range[index] = i;\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        int[] range = new int[distance.length];\\n        Arrays.fill(range, -1);\\n\\n        for(int i = 0; i < s.length(); ++i) {\\n            int index = s.charAt(i) - \\'a\\';\\n\\n            if(range[index] != -1 && Math.abs(range[index] - i) != distance[index] + 1)\\n                return false;\\n\\n            range[index] = i;\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444986,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\\n        d = s[::-1]\\n        if len(s)%2!=0:\\n            return False\\n        else:\\n            for i in s:\\n                #print((len(s)-d.index(i))-s.index(i)-1)\\n                if (len(s)-d.index(i)-1)-s.index(i)-1 != distance[ord(i)-ord(\\'a\\')]:\\n                    return False\\n            return True\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\\n        d = s[::-1]\\n        if len(s)%2!=0:\\n            return False\\n        else:\\n            for i in s:\\n                #print((len(s)-d.index(i))-s.index(i)-1)\\n                if (len(s)-d.index(i)-1)-s.index(i)-1 != distance[ord(i)-ord(\\'a\\')]:\\n                    return False\\n            return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3377486,
                "title": "easy-c-solution-using-hashmaps",
                "content": "# Intuition\\nOur goal is to check if the given string s is well-spaced according to the given distances. We will iterate through the string and record the first and second occurrences of each character. Then, we will compare the recorded distances to the given distance vector to determine if the string is well-spaced.\\n\\n# Approach\\n- Initialize an unordered_map check to store the first and second occurrences of each character in the string. Set initial values to -1.\\n- Iterate through the string, and for each character, update its first and second occurrence in check.\\n- Iterate through the check unordered_map and compare the recorded distances for each character to the given distance vector. If any character\\'s distance does not match, return false.\\n- If all characters have matching distances, return true.\\n\\n\\n# Complexity\\n- Time complexity:\\nTime complexity: O(n), where n is the length of the string s. We iterate through the string once to update occurrences and once more to check distances.\\n\\n- Space complexity:\\nSpace complexity: O(1), as we are using a fixed-size unordered_map for the 26 lowercase English letters.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n    unordered_map<char, pair<int, int>> check;\\n       for (char c = \\'a\\'; c <= \\'z\\'; ++c) \\n           check[c] = make_pair(-1, -1);\\n        for(int i = 0 ; i < s.size() ; i++){\\n            if(check[s[i]].first==-1){\\n            check[s[i]].first = i;\\n        }\\n            else if(check[s[i]].second==-1){\\n            check[s[i]].second = i;\\n        }\\n    }\\n        for(auto p : check) {\\n            if(distance[p.first-\\'a\\']!=p.second.second-p.second.first-1 && p.second.first!=-1) \\n                    return false;\\n        } \\n        return true;\\n        }\\n};\\n```\\n\\nPlease upvote if you find this helpful",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n    unordered_map<char, pair<int, int>> check;\\n       for (char c = \\'a\\'; c <= \\'z\\'; ++c) \\n           check[c] = make_pair(-1, -1);\\n        for(int i = 0 ; i < s.size() ; i++){\\n            if(check[s[i]].first==-1){\\n            check[s[i]].first = i;\\n        }\\n            else if(check[s[i]].second==-1){\\n            check[s[i]].second = i;\\n        }\\n    }\\n        for(auto p : check) {\\n            if(distance[p.first-\\'a\\']!=p.second.second-p.second.first-1 && p.second.first!=-1) \\n                    return false;\\n        } \\n        return true;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327778,
                "title": "check-distances-between-same-letters-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n        int i, j, d, flag=0, k;\\n        for(i=0 ; i<s.length() ; i++)\\n        {\\n            for(j=i+1 ; j<s.length() ; j++)\\n            {\\n                if(s[i]==s[j])\\n                {\\n                    d = j-i-1;\\n                    k = (int)s[i]-97;\\n                    if(distance[k]!=d)\\n                    {\\n                        return false;\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n        int i, j, d, flag=0, k;\\n        for(i=0 ; i<s.length() ; i++)\\n        {\\n            for(j=i+1 ; j<s.length() ; j++)\\n            {\\n                if(s[i]==s[j])\\n                {\\n                    d = j-i-1;\\n                    k = (int)s[i]-97;\\n                    if(distance[k]!=d)\\n                    {\\n                        return false;\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281841,
                "title": "python3-easy-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkDistances(self, s: str, dis: List[int]) -> bool:\\n        d = {}\\n        for i in range(len(s)):\\n            if s[i] not in d:\\n                d[s[i]] = i + 1\\n            else:\\n                if dis[ord(s[i])-ord(\\'a\\')] != i - d[s[i]]:\\n                    return False\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def checkDistances(self, s: str, dis: List[int]) -> bool:\\n        d = {}\\n        for i in range(len(s)):\\n            if s[i] not in d:\\n                d[s[i]] = i + 1\\n            else:\\n                if dis[ord(s[i])-ord(\\'a\\')] != i - d[s[i]]:\\n                    return False\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3099005,
                "title": "hashmap-full-approach-explained-java",
                "content": "# **Check Distances Between Same Letters\\n# ***Approach:*****\\n1.) We iterate over the String and create a hashmap\\n2.) While iterating if the character is not in hashmap, we put it in hashmap\\n3.) If character is in hashmap we compute the number of letter between the two occurences by cuurIndex-ma.get(char)-1 and check if this matche with distance provided in the array\\n\\n# ***Time Complexity:** O(n)*\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        HashMap<Character, Integer> map=new HashMap<Character, Integer>();\\n        for(int i=0; i<s.length(); i++){\\n            if(!map.containsKey(s.charAt(i))){\\n                map.put(s.charAt(i), i);\\n            }\\n            // Updating the distnace between the current and previous occourence of key if it contains it \\n            else{\\n                int prev = map.get(s.charAt(i));\\n                int index = s.charAt(i)-\\'a\\';\\n                // Checking is the computed distance matches with provided distance\\n                if(distance[index]!=i-prev-1){\\n                    return false;\\n                }\\n            }\\n        }\\n          return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        HashMap<Character, Integer> map=new HashMap<Character, Integer>();\\n        for(int i=0; i<s.length(); i++){\\n            if(!map.containsKey(s.charAt(i))){\\n                map.put(s.charAt(i), i);\\n            }\\n            // Updating the distnace between the current and previous occourence of key if it contains it \\n            else{\\n                int prev = map.get(s.charAt(i));\\n                int index = s.charAt(i)-\\'a\\';\\n                // Checking is the computed distance matches with provided distance\\n                if(distance[index]!=i-prev-1){\\n                    return false;\\n                }\\n            }\\n        }\\n          return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3089380,
                "title": "not-the-best-but-just-one-liner-solution",
                "content": "# Code\\n```\\n/**\\n * @param {string} s\\n * @param {number[]} distance\\n * @return {boolean}\\n */\\nconst aCode = \\'a\\'.codePointAt(0);\\nvar checkDistances = function(s, distance) {\\n    return [...s]\\n        .reduce((acc, char, i) => {\\n            acc[char.codePointAt(0) - aCode].push(i);\\n            return acc;\\n        }, Array(26).fill().map(() => []))\\n        .every((charIndicies, i) => {\\n            for (let j = 1; j < charIndicies.length; j++) {\\n                if (charIndicies[j] - charIndicies[j - 1] - 1 !== distance[i]) {\\n                    return false;\\n                }\\n            }\\n            return true;\\n        });\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {number[]} distance\\n * @return {boolean}\\n */\\nconst aCode = \\'a\\'.codePointAt(0);\\nvar checkDistances = function(s, distance) {\\n    return [...s]\\n        .reduce((acc, char, i) => {\\n            acc[char.codePointAt(0) - aCode].push(i);\\n            return acc;\\n        }, Array(26).fill().map(() => []))\\n        .every((charIndicies, i) => {\\n            for (let j = 1; j < charIndicies.length; j++) {\\n                if (charIndicies[j] - charIndicies[j - 1] - 1 !== distance[i]) {\\n                    return false;\\n                }\\n            }\\n            return true;\\n        });\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3036682,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n        map<char,int> m,temp;\\n        map<char,vector<int>> dist;\\n        int ch=0;\\n        for(int i=0;i<distance.size();i++){\\n            m[\\'a\\'+ch]=distance[i];\\n            ch++;\\n        }\\n        for(int i=0;i<s.size();i++){\\n            dist[s[i]].push_back(i);\\n        }\\n        for(auto value:dist){\\n            temp[value.first]=(value.second[1]-value.second[0])-1;\\n        }\\n        map<char,int>::iterator it1 = m.begin();\\n        map<char,int>::iterator it2 = temp.begin();\\n        while(it2!=temp.end()){\\n            if(it1->first==it2->second){\\n                if(it1->second==it2->second){\\n                    it1++;\\n                    it2++;\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n            else{\\n                while(it1->first!=it2->first){\\n                    it1++;\\n                }\\n                 if(it1->second==it2->second){\\n                    it1++;\\n                    it2++;\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n        map<char,int> m,temp;\\n        map<char,vector<int>> dist;\\n        int ch=0;\\n        for(int i=0;i<distance.size();i++){\\n            m[\\'a\\'+ch]=distance[i];\\n            ch++;\\n        }\\n        for(int i=0;i<s.size();i++){\\n            dist[s[i]].push_back(i);\\n        }\\n        for(auto value:dist){\\n            temp[value.first]=(value.second[1]-value.second[0])-1;\\n        }\\n        map<char,int>::iterator it1 = m.begin();\\n        map<char,int>::iterator it2 = temp.begin();\\n        while(it2!=temp.end()){\\n            if(it1->first==it2->second){\\n                if(it1->second==it2->second){\\n                    it1++;\\n                    it2++;\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n            else{\\n                while(it1->first!=it2->first){\\n                    it1++;\\n                }\\n                 if(it1->second==it2->second){\\n                    it1++;\\n                    it2++;\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812612,
                "title": "kotlin-o-n-no-extra-space-used",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    fun checkDistances(s: String, a: IntArray): Boolean {\\n        for (i in 0..s.length - 1) {\\n            var p = s[i].toInt() - 97\\n            if (a[p] >= 1000) {\\n                var prevPos = (a[p] / 1000) - 1\\n                var prevValue = a[p] - ((prevPos + 1) * 1000)\\n                if (i - prevPos - 1 != prevValue) return false\\n            } else {\\n                a[p] += (i + 1) * 1000 // remember position\\n            }\\n        }\\n\\n        return true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun checkDistances(s: String, a: IntArray): Boolean {\\n        for (i in 0..s.length - 1) {\\n            var p = s[i].toInt() - 97\\n            if (a[p] >= 1000) {\\n                var prevPos = (a[p] / 1000) - 1\\n                var prevValue = a[p] - ((prevPos + 1) * 1000)\\n                if (i - prevPos - 1 != prevValue) return false\\n            } else {\\n                a[p] += (i + 1) * 1000 // remember position\\n            }\\n        }\\n\\n        return true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2642444,
                "title": "c-brute-force-optimised-solution",
                "content": "Optimised Solution -:\\nTime Complexity -> O(n)\\nSpace Complexity -> O(1)\\n\\n\\tbool checkDistances(string s, vector<int>& distance) {\\n\\n\\t\\tunordered_map<char,int> mpp;\\n        \\n        for(int i=0;i<s.size();i++){\\n            if(mpp[s[i]]==0){\\n                mpp[s[i]]=i+1;\\n            }\\n            else{\\n                if(distance[s[i]-\\'a\\'] != i-mpp[s[i]]){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\t\\n\\t\\n\\n  Brute Solution:-\\n  Time Complexity -> O(n^2)\\n  Space Complexity -> O(1)\\n\\t\\n    \\n\\t\\t bool checkDistances(string s, vector<int>& distance) {\\n\\t\\t\\tint n=s.size();\\n\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tfor(int j=i+1;j<n;j++){\\n\\t\\t\\t\\t\\tif(s[i]==s[j]){\\n\\t\\t\\t\\t\\t\\tif(j-i-1 != distance[s[i]-\\'a\\']){\\n\\t\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}",
                "solutionTags": [
                    "Array",
                    "String"
                ],
                "code": "Optimised Solution -:\\nTime Complexity -> O(n)\\nSpace Complexity -> O(1)\\n\\n\\tbool checkDistances(string s, vector<int>& distance) {\\n\\n\\t\\tunordered_map<char,int> mpp;\\n        \\n        for(int i=0;i<s.size();i++){\\n            if(mpp[s[i]]==0){\\n                mpp[s[i]]=i+1;\\n            }\\n            else{\\n                if(distance[s[i]-\\'a\\'] != i-mpp[s[i]]){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\t\\n\\t\\n\\n  Brute Solution:-\\n  Time Complexity -> O(n^2)\\n  Space Complexity -> O(1)\\n\\t\\n    \\n\\t\\t bool checkDistances(string s, vector<int>& distance) {\\n\\t\\t\\tint n=s.size();\\n\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tfor(int j=i+1;j<n;j++){\\n\\t\\t\\t\\t\\tif(s[i]==s[j]){\\n\\t\\t\\t\\t\\t\\tif(j-i-1 != distance[s[i]-\\'a\\']){\\n\\t\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2624656,
                "title": "java-using-lastindexof",
                "content": "```\\n public static boolean checkDistances(String s, int[] distance) {\\n\\n        for (int i = 0; i < s.length(); i++) {\\n\\n            char c = s.charAt(i);\\n            int x = s.lastIndexOf(c);\\n\\n            if (i != x) {\\n                int distanceValue = x - i - 1;\\n                if (distance[c - \\'a\\'] != distanceValue) return false;\\n            }\\n            \\n        }\\n\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public static boolean checkDistances(String s, int[] distance) {\\n\\n        for (int i = 0; i < s.length(); i++) {\\n\\n            char c = s.charAt(i);\\n            int x = s.lastIndexOf(c);\\n\\n            if (i != x) {\\n                int distanceValue = x - i - 1;\\n                if (distance[c - \\'a\\'] != distanceValue) return false;\\n            }\\n            \\n        }\\n\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2618147,
                "title": "java-solution-in-2-ms-no-hashmap-o-n",
                "content": "\\n```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        boolean[] booleans = new boolean[26];\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            int idx = i + distance[c - \\'a\\'] + 1;\\n            if (idx < s.length() && !booleans[c - \\'a\\'] && s.charAt(idx) != c || idx > s.length() - 1 && !booleans[c - \\'a\\']) {\\n                return false;\\n            } else {\\n                booleans[c - \\'a\\'] = true;\\n            }\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        boolean[] booleans = new boolean[26];\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            int idx = i + distance[c - \\'a\\'] + 1;\\n            if (idx < s.length() && !booleans[c - \\'a\\'] && s.charAt(idx) != c || idx > s.length() - 1 && !booleans[c - \\'a\\']) {\\n                return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2616542,
                "title": "java-solution-1ms-runtime-faster-than-99-87",
                "content": "### *Method 1*\\n```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        int[] list = new int[26];\\n      \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(list[s.charAt(i)-\\'a\\']==0)\\n                list[s.charAt(i)-\\'a\\']=i+1;\\n\\t\\t\\t\\t\\n            else if(i-list[s.charAt(i)-\\'a\\']!=distance[s.charAt(i)-\\'a\\'])\\n                    return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n\\n###  *Method 2*\\n```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        ArrayList<Integer>[] list = new ArrayList[26];   //can also use int[26][2]\\n        for(int i=0;i<26;i++)\\n            list[i] = new ArrayList<Integer>();\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            list[s.charAt(i)-\\'a\\'].add(i);\\n        }\\n        \\n        int i=0;\\n        for(ArrayList<Integer> temp: list)\\n        {\\n            if(temp.size()==2)\\n            {\\n                if(distance[i]!=(temp.get(1)-temp.get(0)-1))\\n                    return false;\\n            }\\n            i++;\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        int[] list = new int[26];\\n      \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(list[s.charAt(i)-\\'a\\']==0)\\n                list[s.charAt(i)-\\'a\\']=i+1;\\n\\t\\t\\t\\t\\n            else if(i-list[s.charAt(i)-\\'a\\']!=distance[s.charAt(i)-\\'a\\'])\\n                    return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2608814,
                "title": "no-extra-space-100-faster-easy-solution-tc-o-n-sc-o-1",
                "content": "```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        for(int i = 0 ; i < s.length() ; i++){\\n            int dis = distance[s.charAt(i)-\\'a\\'];\\n            if(i+dis+1<s.length() && s.charAt(i+dis+1)==s.charAt(i)){\\n                continue;\\n            }else if(i-dis-1>=0){\\n                if(s.charAt(i-dis-1)==s.charAt(i)){\\n                    continue;\\n                }\\n            }else{\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        for(int i = 0 ; i < s.length() ; i++){\\n            int dis = distance[s.charAt(i)-\\'a\\'];\\n            if(i+dis+1<s.length() && s.charAt(i+dis+1)==s.charAt(i)){\\n                continue;\\n            }else if(i-dis-1>=0){\\n                if(s.charAt(i-dis-1)==s.charAt(i)){\\n                    continue;\\n                }\\n            }else{\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2604602,
                "title": "python-easy-solution-95-faster-less-than-47ms",
                "content": "\\tclass Solution:\\n\\t\\tdef checkDistances(self, s: str, distance: List[int]) -> bool:\\n\\n\\t\\t\\tfor x in set(s):\\n\\t\\t\\t\\tres=[i for i,k in enumerate(s) if k==x]\\n\\t\\t\\t\\tif res[1]-res[0]-1 != distance[ord(x)-97]:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\treturn True\\n",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef checkDistances(self, s: str, distance: List[int]) -> bool:\\n\\n\\t\\t\\tfor x in set(s):\\n\\t\\t\\t\\tres=[i for i,k in enumerate(s) if k==x]\\n\\t\\t\\t\\tif res[1]-res[0]-1 != distance[ord(x)-97]:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\treturn True\\n",
                "codeTag": "Java"
            },
            {
                "id": 2601338,
                "title": "php-11ms",
                "content": "![image](https://assets.leetcode.com/users/images/b0aa6af2-37e8-4b65-9c12-32771c605664_1663680245.8317466.png)\\n\\n```\\nclass Solution {\\n\\n    /**\\n     * @param String $s\\n     * @param Integer[] $distance\\n     * @return Boolean\\n     */\\n    function checkDistances($s, $distance) {\\n        $firstPos = array();\\n        $strParts = str_split($s);\\n        $matched = true;\\n\\n        foreach($strParts as $key => $val) {\\n            if(!isset($firstPos[$val])) {\\n                $firstPos[$val] = $key;\\n            } else {\\n                $charDist = ($key - $firstPos[$val] - 1);\\n                $charIndex = ord($val) - 97;\\n                if($distance[$charIndex] != $charDist) {\\n                    $matched = false;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return $matched;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param String $s\\n     * @param Integer[] $distance\\n     * @return Boolean\\n     */\\n    function checkDistances($s, $distance) {\\n        $firstPos = array();\\n        $strParts = str_split($s);\\n        $matched = true;\\n\\n        foreach($strParts as $key => $val) {\\n            if(!isset($firstPos[$val])) {\\n                $firstPos[$val] = $key;\\n            } else {\\n                $charDist = ($key - $firstPos[$val] - 1);\\n                $charIndex = ord($val) - 97;\\n                if($distance[$charIndex] != $charDist) {\\n                    $matched = false;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return $matched;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2596604,
                "title": "python-solution-easy-understanding",
                "content": "```\\nclass Solution:\\n    def mapper(self, s):  # finds difference of indices\\n        result = dict()\\n        for letter in set(s):\\n            indices = []\\n            for idx, value in enumerate(s):\\n                if value == letter:\\n                    indices.append(idx)\\n            result[letter] = indices[1] - indices[0] - 1\\n        return result  # dict like {\\'a\\':1, \\'b\\':0}\\n\\n    def checkDistances(self, s, distance) -> bool:\\n        alphabet = \\'abcdefghijklmnopqrstuvwxyz\\'\\n        for key, value in self.mapper(s).items():\\n            if distance[alphabet.index(key)] != value:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mapper(self, s):  # finds difference of indices\\n        result = dict()\\n        for letter in set(s):\\n            indices = []\\n            for idx, value in enumerate(s):\\n                if value == letter:\\n                    indices.append(idx)\\n            result[letter] = indices[1] - indices[0] - 1\\n        return result  # dict like {\\'a\\':1, \\'b\\':0}\\n\\n    def checkDistances(self, s, distance) -> bool:\\n        alphabet = \\'abcdefghijklmnopqrstuvwxyz\\'\\n        for key, value in self.mapper(s).items():\\n            if distance[alphabet.index(key)] != value:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2577777,
                "title": "swift-one-liner",
                "content": "**One-Liner, terse (accepted answer)**\\n```\\nclass Solution {\\n    func checkDistances(_ s: String, _ distance: [Int]) -> Bool {\\n        [Int:Int](s.enumerated().map {(Int(exactly: $0.1.asciiValue!)!-97, $0.0)}, uniquingKeysWith: { abs($1-$0)-1 }).reduce(true) { $0 && distance[$1.0] == $1.1 }\\n    }\\n}\\n```\\n**NOTE:** This is technically a one-liner, since the `return` keyword was omitted.\\n\\n---\\n\\n**One-Liner expanded and annotated (accepted answer)**\\n```\\nclass Solution {\\n    func checkDistances(_ s: String, _ distance: [Int]) -> Bool {\\n        // convert `s` to [Int], and map \\'a\\' ... \\'z\\' -> 0 ... 25\\n        let s = Array(s).map { Int(exactly: $0.asciiValue! - Character(\"a\").asciiValue!)! }\\n\\n        // create hashMap mapping letters (as Int) to distance between instances of letters\\n        let hashMap = [Int:Int](s.enumerated().map {($0.1, $0.0)}, uniquingKeysWith: { abs($1-$0)-1 })\\n        \\n        // compare all calculated distances with expected distances, return false if discrepancy found \\n        return hashMap.reduce(true) { result, tuple in\\n            let (letter, calculatedDistance) = tuple\\n            return result && distance[letter] == calculatedDistance \\n        }\\n    }\\n}\\n```\\n\\n---\\n\\n**For-loop, using Array for storage (accepted answer)**\\n```\\nclass Solution {\\n    func checkDistances(_ s: String, _ distance: [Int]) -> Bool {\\n        let s = Array(s).map { Int(exactly: $0.asciiValue! - Character(\"a\").asciiValue!)! }\\n        var prev = Array(repeating: -1, count: 26)\\n        for (i, ch) in s.enumerated() {\\n            if prev[ch] < 0 {\\n                prev[ch] = i \\n            } else if distance[ch] != i - prev[ch] - 1 {\\n                 return false\\n            }\\n        }\\n        return true\\n    }\\n}\\n```\\n\\n---\\n\\n**For-loop, using Hashmap for storage (accepted answer)**\\n```\\nclass Solution {\\n    func checkDistances(_ s: String, _ distance: [Int]) -> Bool {\\n        let s = Array(s).map { Int(exactly: $0.asciiValue! - Character(\"a\").asciiValue!)! }\\n        var prev = [Int:Int]()\\n        for (i, ch) in s.enumerated() {\\n            if prev[ch] == nil {\\n                prev[ch] = i \\n            } else if distance[ch] != i - prev[ch]! - 1 {\\n                 return false\\n            }\\n        }\\n        return true\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func checkDistances(_ s: String, _ distance: [Int]) -> Bool {\\n        [Int:Int](s.enumerated().map {(Int(exactly: $0.1.asciiValue!)!-97, $0.0)}, uniquingKeysWith: { abs($1-$0)-1 }).reduce(true) { $0 && distance[$1.0] == $1.1 }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func checkDistances(_ s: String, _ distance: [Int]) -> Bool {\\n        // convert `s` to [Int], and map \\'a\\' ... \\'z\\' -> 0 ... 25\\n        let s = Array(s).map { Int(exactly: $0.asciiValue! - Character(\"a\").asciiValue!)! }\\n\\n        // create hashMap mapping letters (as Int) to distance between instances of letters\\n        let hashMap = [Int:Int](s.enumerated().map {($0.1, $0.0)}, uniquingKeysWith: { abs($1-$0)-1 })\\n        \\n        // compare all calculated distances with expected distances, return false if discrepancy found \\n        return hashMap.reduce(true) { result, tuple in\\n            let (letter, calculatedDistance) = tuple\\n            return result && distance[letter] == calculatedDistance \\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func checkDistances(_ s: String, _ distance: [Int]) -> Bool {\\n        let s = Array(s).map { Int(exactly: $0.asciiValue! - Character(\"a\").asciiValue!)! }\\n        var prev = Array(repeating: -1, count: 26)\\n        for (i, ch) in s.enumerated() {\\n            if prev[ch] < 0 {\\n                prev[ch] = i \\n            } else if distance[ch] != i - prev[ch] - 1 {\\n                 return false\\n            }\\n        }\\n        return true\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func checkDistances(_ s: String, _ distance: [Int]) -> Bool {\\n        let s = Array(s).map { Int(exactly: $0.asciiValue! - Character(\"a\").asciiValue!)! }\\n        var prev = [Int:Int]()\\n        for (i, ch) in s.enumerated() {\\n            if prev[ch] == nil {\\n                prev[ch] = i \\n            } else if distance[ch] != i - prev[ch]! - 1 {\\n                 return false\\n            }\\n        }\\n        return true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2571412,
                "title": "c-96-o-n-with-explanation",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        bool checkDistances(string s, vector<int> &distance)\\n        {\\n    \\n            //making use of set because don\\'t want to iterate already calculated results\\n            \\n            unordered_set<char>ch;\\n            for (int i = 0; i < s.size(); i++)\\n            {\\n                // i.e if the character is already been calculated earlier\\n                if(ch.find(s[i])!=ch.end()){\\n                    continue;\\n                }\\n            \\n                // 1-condition - if the value of distance makes the size go out of bounds then false\\n                // 2-condition - check if the character is present at the location by adding the given distance+1\\n                // Here s[i]-\\'a\\' will give 0 if s[i] = a and 1 if s[i] = b and so on.\\n                \\n                if (distance[s[i] - \\'a\\'] + i + 1 > s.size() || s[i] != s[distance[s[i] - \\'a\\'] + i + 1]){\\n                    return false;\\n                }\\n                \\n                //insert into the set because we calculated it and it was fine.\\n                \\n                else{\\n                   ch.insert(s[i]); \\n                }\\n            }\\n            return true;\\n        }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        bool checkDistances(string s, vector<int> &distance)\\n        {\\n    \\n            //making use of set because don\\'t want to iterate already calculated results\\n            \\n            unordered_set<char>ch;\\n            for (int i = 0; i < s.size(); i++)\\n            {\\n                // i.e if the character is already been calculated earlier\\n                if(ch.find(s[i])!=ch.end()){\\n                    continue;\\n                }\\n            \\n                // 1-condition - if the value of distance makes the size go out of bounds then false\\n                // 2-condition - check if the character is present at the location by adding the given distance+1\\n                // Here s[i]-\\'a\\' will give 0 if s[i] = a and 1 if s[i] = b and so on.\\n                \\n                if (distance[s[i] - \\'a\\'] + i + 1 > s.size() || s[i] != s[distance[s[i] - \\'a\\'] + i + 1]){\\n                    return false;\\n                }\\n                \\n                //insert into the set because we calculated it and it was fine.\\n                \\n                else{\\n                   ch.insert(s[i]); \\n                }\\n            }\\n            return true;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2565504,
                "title": "c-keep-track-of-previous-occurence",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n        vector<int> prev(26,-1) ; //stores the previous index of any charater encountered\\n        for(int i = 0 ; i < s.size() ; ++i ){\\n            if(prev[s[i]-\\'a\\'] == -1) prev[s[i]-\\'a\\'] = i ;\\n            else if(distance[s[i]-\\'a\\'] != i - prev[s[i]-\\'a\\'] - 1) return false ;\\n        }\\n        return true ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n        vector<int> prev(26,-1) ; //stores the previous index of any charater encountered\\n        for(int i = 0 ; i < s.size() ; ++i ){\\n            if(prev[s[i]-\\'a\\'] == -1) prev[s[i]-\\'a\\'] = i ;\\n            else if(distance[s[i]-\\'a\\'] != i - prev[s[i]-\\'a\\'] - 1) return false ;\\n        }\\n        return true ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2555939,
                "title": "java-solution-array-self-explanatory",
                "content": "```\\n    public boolean checkDistances(String s, int[] distance) {\\n        int[] freq = new int[26];\\n        Arrays.fill(freq, -1);\\n        \\n        for(int i=0; i<s.length(); i++) {\\n            freq[s.charAt(i) - \\'a\\'] = i - freq[s.charAt(i) - \\'a\\']; \\n        }\\n        \\n        for(int i=0; i<s.length(); i++) {\\n            if(freq[s.charAt(i) - \\'a\\'] != -1 && freq[s.charAt(i) - \\'a\\'] != distance[s.charAt(i) - \\'a\\']) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n    public boolean checkDistances(String s, int[] distance) {\\n        int[] freq = new int[26];\\n        Arrays.fill(freq, -1);\\n        \\n        for(int i=0; i<s.length(); i++) {\\n            freq[s.charAt(i) - \\'a\\'] = i - freq[s.charAt(i) - \\'a\\']; \\n        }\\n        \\n        for(int i=0; i<s.length(); i++) {\\n            if(freq[s.charAt(i) - \\'a\\'] != -1 && freq[s.charAt(i) - \\'a\\'] != distance[s.charAt(i) - \\'a\\']) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2552245,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\\n        d = defaultdict(list)\\n        for i, c in enumerate(s):\\n            d[c].append(i)\\n        return all(distance[ord(c) - ord(\"a\")] == d[c][1] - d[c][0] - 1 for c in d)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\\n        d = defaultdict(list)\\n        for i, c in enumerate(s):\\n            d[c].append(i)\\n        return all(distance[ord(c) - ord(\"a\")] == d[c][1] - d[c][0] - 1 for c in d)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2549960,
                "title": "o-n-single-traversal-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] dist) {\\n        for (int i = 0; i < s.length(); i++) {\\n            int idx = s.charAt(i) - 97;\\n            if (i + dist[idx]+1 < s.length() && s.charAt(i + dist[idx]+1) == s.charAt(i)) continue;\\n            else if (i - dist[idx]-1 >= 0 && s.charAt(i - dist[idx]-1) == s.charAt(i)) continue;\\n            else return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] dist) {\\n        for (int i = 0; i < s.length(); i++) {\\n            int idx = s.charAt(i) - 97;\\n            if (i + dist[idx]+1 < s.length() && s.charAt(i + dist[idx]+1) == s.charAt(i)) continue;\\n            else if (i - dist[idx]-1 >= 0 && s.charAt(i - dist[idx]-1) == s.charAt(i)) continue;\\n            else return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2549655,
                "title": "js-javascript-easy-to-understand",
                "content": "```\\n// Time complexity: O(n), where n is length of input string.\\n// Space complexity: O(1)\\n\\nvar checkDistances = function(s, distance) {\\n    const firstIndex = Array(26).fill(-1);\\n\\t\\n\\tfor(let index = 0; index < s.length; index++) {\\n\\t\\tconst charCode = s[index].charCodeAt(0) - \\'a\\'.charCodeAt(0);\\n\\t\\t\\n\\t\\tif(firstIndex[charCode] !== -1)\\n\\t\\t\\tif(index - firstIndex[charCode] - 1 !== distance[charCode])\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\n\\t\\tfirstIndex[charCode] = index;\\n\\t}\\n\\t\\n\\treturn true;\\n};\\n```\\n\\n**Please upvote if you find this solution useful. Happy Coding!**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// Time complexity: O(n), where n is length of input string.\\n// Space complexity: O(1)\\n\\nvar checkDistances = function(s, distance) {\\n    const firstIndex = Array(26).fill(-1);\\n\\t\\n\\tfor(let index = 0; index < s.length; index++) {\\n\\t\\tconst charCode = s[index].charCodeAt(0) - \\'a\\'.charCodeAt(0);\\n\\t\\t\\n\\t\\tif(firstIndex[charCode] !== -1)\\n\\t\\t\\tif(index - firstIndex[charCode] - 1 !== distance[charCode])\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\n\\t\\tfirstIndex[charCode] = index;\\n\\t}\\n\\t\\n\\treturn true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2547367,
                "title": "easy-1ms-soln",
                "content": "HashMap<Character,Integer> hm = new HashMap<>();\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            char ch = s.charAt(i);\\n            if(hm.containsKey(ch))\\n            {\\n                int diff = i-hm.get(ch)-1;\\n                int val = distance[ch-\\'a\\'];\\n                if(diff!=val)\\n                {\\n                    return false;\\n                }\\n            }\\n            else\\n            {\\n                hm.put(ch,i);\\n            }\\n        }\\n        \\n        return true;",
                "solutionTags": [],
                "code": "HashMap<Character,Integer> hm = new HashMap<>();\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            char ch = s.charAt(i);\\n            if(hm.containsKey(ch))\\n            {\\n                int diff = i-hm.get(ch)-1;\\n                int val = distance[ch-\\'a\\'];\\n                if(diff!=val)\\n                {\\n                    return false;\\n                }\\n            }\\n            else\\n            {\\n                hm.put(ch,i);\\n            }\\n        }\\n        \\n        return true;",
                "codeTag": "Unknown"
            },
            {
                "id": 2541982,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\\n        visited = \"\"\\n        \\n        for alpha in s:\\n            if alpha not in visited:\\n                visited += alpha\\n                if s.rindex(alpha) - s.index(alpha) - 1 != distance[ord(alpha) - 97]:\\n                    return False\\n        \\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\\n        visited = \"\"\\n        \\n        for alpha in s:\\n            if alpha not in visited:\\n                visited += alpha\\n                if s.rindex(alpha) - s.index(alpha) - 1 != distance[ord(alpha) - 97]:\\n                    return False\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2540187,
                "title": "typescript-100-one-pass-in-place-solution-with-detailed-comments",
                "content": "This [solution](https://leetcode.com/submissions/detail/793015446/) checks the correctness of distances in one pass by performing in-place operations. It demonstrated **59 ms runtime (100.00%)** and used **45.1 MB memory (70.59%)**. Detailed comments are provided.\\n\\n**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n```\\n// [1] we will not allocate additional storage for indices, but\\n//     rather use \\'distance\\' in a clever way\\nfunction checkDistances(s: string, distance: number[]): boolean \\n{\\n    let letter: number;\\n    const a = \\'a\\'.charCodeAt(0);\\n    for (let pos = 0; pos < s.length; pos++)\\n    {\\n        letter = s[pos].charCodeAt(0) - a;\\n\\n        // [2] provided that elements in \\'distance\\' are initially >= 0, \\n        //     we can manage two states for first and second occurences of each letter;\\n        //     this will allow us to ensure that, for correct distances, the following holds:\\n        //     \\'second\\' - \\'first\\' + 1 - \\'distance\\' = 0\\n        if (distance[letter] >= 0)\\n        {\\n            // [3] state 1: first occurence of the letter;\\n            //     we put \\'-1\\' to guarantee that distance[letter] < 0 for correct distance\\n            //     (namely, the state will be switched to \\'letter was encountered once\\')\\n            distance[letter] = - distance[letter] - pos - 1;\\n        }\\n        else\\n        {\\n            // [4] state 2: second occurence of the letter\\n            //     if we\\'d put \\'+1\\' here (instead of \\'-1\\' in the previous block) \\n            //     then the algorithm will fail changing the state for distance[letter] = pos = 0\\n            distance[letter] += pos;\\n\\n            // [5] once wrong distance is found, return false\\n            if (distance[letter] != 0) return false;\\n        }\\n    }\\n\\n    // [6] if no wrong distance was found, return true\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\n// [1] we will not allocate additional storage for indices, but\\n//     rather use \\'distance\\' in a clever way\\nfunction checkDistances(s: string, distance: number[]): boolean \\n{\\n    let letter: number;\\n    const a = \\'a\\'.charCodeAt(0);\\n    for (let pos = 0; pos < s.length; pos++)\\n    {\\n        letter = s[pos].charCodeAt(0) - a;\\n\\n        // [2] provided that elements in \\'distance\\' are initially >= 0, \\n        //     we can manage two states for first and second occurences of each letter;\\n        //     this will allow us to ensure that, for correct distances, the following holds:\\n        //     \\'second\\' - \\'first\\' + 1 - \\'distance\\' = 0\\n        if (distance[letter] >= 0)\\n        {\\n            // [3] state 1: first occurence of the letter;\\n            //     we put \\'-1\\' to guarantee that distance[letter] < 0 for correct distance\\n            //     (namely, the state will be switched to \\'letter was encountered once\\')\\n            distance[letter] = - distance[letter] - pos - 1;\\n        }\\n        else\\n        {\\n            // [4] state 2: second occurence of the letter\\n            //     if we\\'d put \\'+1\\' here (instead of \\'-1\\' in the previous block) \\n            //     then the algorithm will fail changing the state for distance[letter] = pos = 0\\n            distance[letter] += pos;\\n\\n            // [5] once wrong distance is found, return false\\n            if (distance[letter] != 0) return false;\\n        }\\n    }\\n\\n    // [6] if no wrong distance was found, return true\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2534993,
                "title": "c-100-success-using-unordered-map-easy-solution",
                "content": "**Explanation**: My intitution is by travesing the whole string , to store the initial occurance of the element in ```unordered_map``` if the elment is not present in the map, otherwise check if the distance between the 1st & 2nd occurances of the element is **equal** or **not** with the distance of element in given vector.\\n\\n**Code :**\\n\\n```\\n\\t\\tclass Solution {\\n\\t\\t\\tpublic:\\n\\t\\t\\t\\tbool checkDistances(string s, vector<int>& distance) {\\n\\t\\t\\t\\t\\tunordered_map<char,int> mp;\\n\\t\\t\\t\\t\\tfor(int i=0;i<s.length();i++){\\n\\t\\t\\t\\t\\t\\tif(mp.find(s[i])==mp.end()){\\n\\t\\t\\t\\t\\t\\t\\tmp[s[i]]=i;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\t\\tif((i-mp[s[i]]-1) != distance[s[i]-\\'a\\']) return false;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```unordered_map```\n```\\n\\t\\tclass Solution {\\n\\t\\t\\tpublic:\\n\\t\\t\\t\\tbool checkDistances(string s, vector<int>& distance) {\\n\\t\\t\\t\\t\\tunordered_map<char,int> mp;\\n\\t\\t\\t\\t\\tfor(int i=0;i<s.length();i++){\\n\\t\\t\\t\\t\\t\\tif(mp.find(s[i])==mp.end()){\\n\\t\\t\\t\\t\\t\\t\\tmp[s[i]]=i;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\t\\tif((i-mp[s[i]]-1) != distance[s[i]-\\'a\\']) return false;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2533120,
                "title": "java-hashmap-easy",
                "content": "```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        Map<Character,Integer> m = new HashMap<>();\\n        \\n        for(int i=0;i<s.length();i++){\\n            if(m.containsKey(s.charAt(i))){\\n                if(i-m.get(s.charAt(i))-1!=distance[s.charAt(i)-\\'a\\']) return false;\\n            }else{\\n                m.put(s.charAt(i),i);\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        Map<Character,Integer> m = new HashMap<>();\\n        \\n        for(int i=0;i<s.length();i++){\\n            if(m.containsKey(s.charAt(i))){\\n                if(i-m.get(s.charAt(i))-1!=distance[s.charAt(i)-\\'a\\']) return false;\\n            }else{\\n                m.put(s.charAt(i),i);\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2530129,
                "title": "o-n-100-faster-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n        vector<int> A(26,0);\\n        vector<int> B(26,0);\\n        for(int i=0;i<s.size();i++){\\n            if(A[s[i]-\\'a\\']!=0){\\n                B[s[i]-\\'a\\']=i+1;\\n            }\\n            else{\\n                A[s[i]-\\'a\\']=i+1;\\n            }\\n        }\\n        for(int i=0;i<26;i++){\\n            if((B[i]-A[i])!=0){\\n                if((B[i]-A[i]-1)!=distance[i]){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n        vector<int> A(26,0);\\n        vector<int> B(26,0);\\n        for(int i=0;i<s.size();i++){\\n            if(A[s[i]-\\'a\\']!=0){\\n                B[s[i]-\\'a\\']=i+1;\\n            }\\n            else{\\n                A[s[i]-\\'a\\']=i+1;\\n            }\\n        }\\n        for(int i=0;i<26;i++){\\n            if((B[i]-A[i])!=0){\\n                if((B[i]-A[i]-1)!=distance[i]){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2529913,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn check_distances(s: String, mut distance: Vec<i32>) -> bool {\\n        for (b, pos) in s.bytes().zip(0..) {\\n            let dist = &mut distance[(b - b\\'a\\') as usize];\\n            match *dist >= 0 {\\n                true => *dist = -(*dist + pos + 1), // set next pos with negative flag\\n                false if *dist != -pos => return false, // check wrong distance\\n                _ => (),\\n            }\\n        }\\n        true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn check_distances(s: String, mut distance: Vec<i32>) -> bool {\\n        for (b, pos) in s.bytes().zip(0..) {\\n            let dist = &mut distance[(b - b\\'a\\') as usize];\\n            match *dist >= 0 {\\n                true => *dist = -(*dist + pos + 1), // set next pos with negative flag\\n                false if *dist != -pos => return false, // check wrong distance\\n                _ => (),\\n            }\\n        }\\n        true\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2529026,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n        vector<bool> vis(26,false);\\n        int n = s.size();\\n        for(int i=0;i<n;i++){\\n            if(vis[s[i]-\\'a\\'])   continue;\\n            if(i+distance[s[i]-\\'a\\']+1<n && s[i+distance[s[i]-\\'a\\']+1]==s[i]){\\n                vis[s[i]-\\'a\\']=true; continue;\\n            }\\n            else\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n        vector<bool> vis(26,false);\\n        int n = s.size();\\n        for(int i=0;i<n;i++){\\n            if(vis[s[i]-\\'a\\'])   continue;\\n            if(i+distance[s[i]-\\'a\\']+1<n && s[i+distance[s[i]-\\'a\\']+1]==s[i]){\\n                vis[s[i]-\\'a\\']=true; continue;\\n            }\\n            else\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2528610,
                "title": "100-00-of-c-beginner-friendly-without-using-hashmap-o-1-space-complexity",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me, if you have some queries or some improvements please feel free to comment and share your views.**\\n\\n```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n        \\n        int n = s.size();\\n        for(int i=0;i<n;i++){\\n            \\n            if(s[i]!=\\'A\\'){\\n                char c = s[i];\\n                size_t f = s.find(c , i+1);\\n                \\n                if(distance[s[i]-\\'a\\']==(f-i-1)){\\n                    s[f]=\\'A\\';\\n                    j++;\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n         return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n        \\n        int n = s.size();\\n        for(int i=0;i<n;i++){\\n            \\n            if(s[i]!=\\'A\\'){\\n                char c = s[i];\\n                size_t f = s.find(c , i+1);\\n                \\n                if(distance[s[i]-\\'a\\']==(f-i-1)){\\n                    s[f]=\\'A\\';\\n                    j++;\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n         return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2528596,
                "title": "simple-c-bruteforce-100-fast",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& d) {\\n        map<char,vector<int>> m;\\n        for(int i=0;i<s.length();i++){\\n            m[s[i]].push_back(i);\\n        }   \\n        for(auto it:m){\\n            int u = it.second[0],v=it.second[1];\\n            int a = d[it.first - \\'a\\'];\\n            if(a != v-u-1 ) return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& d) {\\n        map<char,vector<int>> m;\\n        for(int i=0;i<s.length();i++){\\n            m[s[i]].push_back(i);\\n        }   \\n        for(auto it:m){\\n            int u = it.second[0],v=it.second[1];\\n            int a = d[it.first - \\'a\\'];\\n            if(a != v-u-1 ) return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2528489,
                "title": "java-solution-two-approaches",
                "content": "### **Please Upvote !!!**\\n```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        int[] arr = new int[26];\\n        Arrays.fill(arr, -1);\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            int index = s.charAt(i) - \\'a\\';\\n            int inBetween = i - arr[index] - 1;\\n            if (arr[index] > -1 && inBetween != distance[index]) return false;\\n            arr[index] = i;\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n\\n// -----------------------------------------------------------------------------------\\n\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            int firstIdx =  s.indexOf(c);\\n            int lastIdx = s.lastIndexOf(c);\\n            int inBetween = lastIdx - firstIdx - 1;\\n            if (inBetween != distance[c - \\'a\\']) return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        int[] arr = new int[26];\\n        Arrays.fill(arr, -1);\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            int index = s.charAt(i) - \\'a\\';\\n            int inBetween = i - arr[index] - 1;\\n            if (arr[index] > -1 && inBetween != distance[index]) return false;\\n            arr[index] = i;\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n\\n// -----------------------------------------------------------------------------------\\n\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            int firstIdx =  s.indexOf(c);\\n            int lastIdx = s.lastIndexOf(c);\\n            int inBetween = lastIdx - firstIdx - 1;\\n            if (inBetween != distance[c - \\'a\\']) return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527980,
                "title": "python-simple-and-efficient-solution",
                "content": "Time - complexity = O(n)\\nSpace complexity = O(1)\\n```\\nclass Solution:\\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\\n        \\n        dist = [-1] * (len(distance))\\n        \\n        n = len(s)\\n        \\n        for i in range(n):\\n            index = ord(s[i]) - ord(\\'a\\')\\n            \\n            if dist[index] == -1:\\n                dist[index] = i\\n            else:\\n                if distance[index] != (i - dist[index] - 1):\\n                    return False\\n                \\n        return True\\n        \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "Time - complexity = O(n)\\nSpace complexity = O(1)\\n```\\nclass Solution:\\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\\n        \\n        dist = [-1] * (len(distance))\\n        \\n        n = len(s)\\n        \\n        for i in range(n):\\n            index = ord(s[i]) - ord(\\'a\\')\\n            \\n            if dist[index] == -1:\\n                dist[index] = i\\n            else:\\n                if distance[index] != (i - dist[index] - 1):\\n                    return False\\n                \\n        return True\\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 2527653,
                "title": "easy-solution-ascii-value-logic",
                "content": "```\\nclass Solution:\\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\\n        hashmap=dict()\\n        for i in range(len(s)):\\n            if ord(s[i]) not in hashmap:\\n                hashmap[ord(s[i])]=[i]\\n            else:\\n                hashmap[ord(s[i])].append(i)\\n        \\n        \\n        for i in hashmap:\\n            if hashmap[i][1]-hashmap[i][0]-1!=distance[i-97]:\\n                return False\\n        return True\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\\n        hashmap=dict()\\n        for i in range(len(s)):\\n            if ord(s[i]) not in hashmap:\\n                hashmap[ord(s[i])]=[i]\\n            else:\\n                hashmap[ord(s[i])].append(i)\\n        \\n        \\n        for i in hashmap:\\n            if hashmap[i][1]-hashmap[i][0]-1!=distance[i-97]:\\n                return False\\n        return True\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527604,
                "title": "c-unordered-map-hindi-video-explanation",
                "content": "It can be solved using unordered map for storing index of character last seen\\nC++ Code and Hindi Video explanation in case anyone\\'s interested.\\nhttps://youtu.be/0_TdytWLHfE\\n\\n```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n      vector<int> char_index(26, -1);\\n      int n = s.size();\\n      for (int i = 0; i < n; ++i) {\\n        int current_char = s[i] - \\'a\\';\\n        if (char_index[current_char] != -1 && i - char_index[current_char]-1 != distance[current_char]) {\\n          return false;\\n        }\\n        char_index[current_char] = i;\\n      }\\n      return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n      vector<int> char_index(26, -1);\\n      int n = s.size();\\n      for (int i = 0; i < n; ++i) {\\n        int current_char = s[i] - \\'a\\';\\n        if (char_index[current_char] != -1 && i - char_index[current_char]-1 != distance[current_char]) {\\n          return false;\\n        }\\n        char_index[current_char] = i;\\n      }\\n      return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527577,
                "title": "rust-map-with-comments",
                "content": "EDIT 2022-09-04: I had to come back and do a nicer solution with the excellent tips from [BigMih](https://leetcode.com/BigMih/) regarding `.zip(0..)` and `.bytes()`. Thanks!\\n\\n```\\nimpl Solution {\\n    pub fn check_distances(s: String, distance: Vec<i32>) -> bool {\\n        (0..).zip(s.bytes()).scan(vec![-1; 26], |v, (i, c)| {\\n            match &mut v[(c - b\\'a\\') as usize] {\\n                entry @ &mut -1 => {\\n                    *entry = i;\\n                    Some(true)\\n                },\\n                entry => Some(*entry == i - distance[(c - b\\'a\\') as usize]),\\n            }\\n        }).all(|b| b)\\n    }\\n}\\n```\\n\\n**Original Post**\\n\\nThis is my unaltered submission for the 2022-09-04 Weekly Contest 309. I record the first and last occurrence of each letter. I used the sentinel -1 here to signal that we didn\\'t encounter the letter in question. Then I just check that the recorded distances of the encountered letters match those in `distance`.\\n\\nTime: O(n)\\nSpace: O(n)\\n\\nComments: My second contest. I tried to code faster and do less of \"clean and functional-style\", so this solution was in line with my goals. :)\\n\\n```\\nimpl Solution {\\n    pub fn check_distances(s: String, distance: Vec<i32>) -> bool {\\n        let mut map = vec![(-1, -1); 26];\\n        for (i, c) in s.as_bytes().iter().enumerate() {\\n            let entry = &mut map[(*c - b\\'a\\') as usize];\\n            if entry.0 == -1 {\\n                entry.0 = i as i32;\\n            } else {\\n                entry.1 = i as i32;\\n            }\\n        }\\n        map.into_iter().enumerate().all(|(i, (first, second))| first == -1 || second - first - 1 == distance[i])\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn check_distances(s: String, distance: Vec<i32>) -> bool {\\n        (0..).zip(s.bytes()).scan(vec![-1; 26], |v, (i, c)| {\\n            match &mut v[(c - b\\'a\\') as usize] {\\n                entry @ &mut -1 => {\\n                    *entry = i;\\n                    Some(true)\\n                },\\n                entry => Some(*entry == i - distance[(c - b\\'a\\') as usize]),\\n            }\\n        }).all(|b| b)\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn check_distances(s: String, distance: Vec<i32>) -> bool {\\n        let mut map = vec![(-1, -1); 26];\\n        for (i, c) in s.as_bytes().iter().enumerate() {\\n            let entry = &mut map[(*c - b\\'a\\') as usize];\\n            if entry.0 == -1 {\\n                entry.0 = i as i32;\\n            } else {\\n                entry.1 = i as i32;\\n            }\\n        }\\n        map.into_iter().enumerate().all(|(i, (first, second))| first == -1 || second - first - 1 == distance[i])\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2527561,
                "title": "easy-solution-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n        string t=\"\";\\n        for(int i=0 ; i<s.length()-1 ; i++){\\n            if(t.find(s[i])!=-1){\\n                continue;\\n            }\\n            else if((s.find(s[i],i+1)-i-1)!=distance[s[i]-\\'a\\']){\\n                return false;\\n            }\\n            else{\\n                t.push_back(s[i]);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n        string t=\"\";\\n        for(int i=0 ; i<s.length()-1 ; i++){\\n            if(t.find(s[i])!=-1){\\n                continue;\\n            }\\n            else if((s.find(s[i],i+1)-i-1)!=distance[s[i]-\\'a\\']){\\n                return false;\\n            }\\n            else{\\n                t.push_back(s[i]);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527558,
                "title": "2-for-loops-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& d) {\\n        bool flag=1;\\n        for(int i=0;i<s.length();i++){\\n            for(int j=i+1;j<s.length();j++){\\n                if(s[i]==s[j]){\\n                    if(d[s[i]-\\'a\\']==(j-i-1)){continue;}\\n                    else {flag=0;break;}\\n                }\\n            }\\n        }\\n        return flag;\\n    }\\n};  \\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& d) {\\n        bool flag=1;\\n        for(int i=0;i<s.length();i++){\\n            for(int j=i+1;j<s.length();j++){\\n                if(s[i]==s[j]){\\n                    if(d[s[i]-\\'a\\']==(j-i-1)){continue;}\\n                    else {flag=0;break;}\\n                }\\n            }\\n        }\\n        return flag;\\n    }\\n};  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527386,
                "title": "map-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n        unordered_map<int,int>mp;\\n        for(int i = 0 ; i < s.size();i++){\\n            if(mp.find(s[i]-\\'a\\') == mp.end()){\\n                mp[s[i] - \\'a\\'] = i;\\n            }\\n            else{\\n                mp[s[i]-\\'a\\'] = i - mp[s[i] - \\'a\\']-1;\\n            }\\n        }\\n      \\n        for(int i = 0 ; i < 26;i++){\\n            if(mp.find(i)!=mp.end()){\\n                if(mp[i] != distance[i]) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n        unordered_map<int,int>mp;\\n        for(int i = 0 ; i < s.size();i++){\\n            if(mp.find(s[i]-\\'a\\') == mp.end()){\\n                mp[s[i] - \\'a\\'] = i;\\n            }\\n            else{\\n                mp[s[i]-\\'a\\'] = i - mp[s[i] - \\'a\\']-1;\\n            }\\n        }\\n      \\n        for(int i = 0 ; i < 26;i++){\\n            if(mp.find(i)!=mp.end()){\\n                if(mp[i] != distance[i]) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527341,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\n    typedef long long ll;\\npublic:\\n    bool checkDistances(string& s, vector<int>& v) {\\n        ll sz = s.size();\\n        vector<ll>ump(26, -1);\\n        for (ll i = 0;i < sz;++i) {\\n            if (ump[s[i] - \\'a\\'] == -1) {\\n                ump[s[i] - \\'a\\'] = i;\\n            }\\n            else if (i - ump[s[i] - \\'a\\'] -1 != v[s[i] - \\'a\\']) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    typedef long long ll;\\npublic:\\n    bool checkDistances(string& s, vector<int>& v) {\\n        ll sz = s.size();\\n        vector<ll>ump(26, -1);\\n        for (ll i = 0;i < sz;++i) {\\n            if (ump[s[i] - \\'a\\'] == -1) {\\n                ump[s[i] - \\'a\\'] = i;\\n            }\\n            else if (i - ump[s[i] - \\'a\\'] -1 != v[s[i] - \\'a\\']) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527338,
                "title": "js-javascript-brute-force",
                "content": "# Any feedback would be apprecieated \\uD83D\\uDE0A \\n\\n```\\nconst checkDistances = function(s, distance) {\\n  for (let i = 0; i < s.length; i++) {\\n    for (let j = i + 1; j < s.length; j++) {\\n      if (s[i] === s[j]) {\\n        if (distance[s[i].charCodeAt() - 97] !== j - i - 1) return false;\\n        break;\\n      }\\n    }\\n  }\\n  return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst checkDistances = function(s, distance) {\\n  for (let i = 0; i < s.length; i++) {\\n    for (let j = i + 1; j < s.length; j++) {\\n      if (s[i] === s[j]) {\\n        if (distance[s[i].charCodeAt() - 97] !== j - i - 1) return false;\\n        break;\\n      }\\n    }\\n  }\\n  return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4090557,
                "title": "simple-solution",
                "content": "```\\nclass Solution:\\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\\n        dic = {}\\n        for i, ch in enumerate(s):\\n            if ch in dic and i-dic[ch]-1 != distance[ord(ch)-97]:\\n                return False\\n            dic[ch] = i\\n        return True     \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\\n        dic = {}\\n        for i, ch in enumerate(s):\\n            if ch in dic and i-dic[ch]-1 != distance[ord(ch)-97]:\\n                return False\\n            dic[ch] = i\\n        return True     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072057,
                "title": "beats-100-00-of-users-with-python",
                "content": "# Intuition\\n![Screen Shot 2566-09-21 at 15.26.48.png](https://assets.leetcode.com/users/images/43e29f53-fbec-4ee1-af80-9e0615f9b225_1695292029.7515926.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def checkDistances(self, s, distance):\\n        dic={}\\n        letter=97\\n        for i in distance:\\n            dic[chr(letter)]=i\\n            letter+=1\\n\\n        for i in set(s):\\n            first=s.index(i)\\n            last=s.rindex(i)\\n            diff=last-first-1\\n            if dic[i]!=diff:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def checkDistances(self, s, distance):\\n        dic={}\\n        letter=97\\n        for i in distance:\\n            dic[chr(letter)]=i\\n            letter+=1\\n\\n        for i in set(s):\\n            first=s.index(i)\\n            last=s.rindex(i)\\n            diff=last-first-1\\n            if dic[i]!=diff:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4067743,
                "title": "using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\\n        d={}\\n        ans=0\\n        Flag=False\\n        for i in range(len(s)):\\n            char=s[i]\\n            if char not in d:\\n                d[char]=[i]\\n            else:\\n                d[char].append(i)\\n        k=list(d.values())\\n        l=list(d.keys())\\n        \\n        for i in range(len(k)):\\n            if abs(k[i][0]-k[i][1])-1==distance[ord(l[i])-ord(\\'a\\')]:\\n                ans+=1\\n            else:\\n                return False\\n       \\n        \\n        if ans==len(k):\\n            \\n            return True\\n        else:\\n            return False\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\\n        d={}\\n        ans=0\\n        Flag=False\\n        for i in range(len(s)):\\n            char=s[i]\\n            if char not in d:\\n                d[char]=[i]\\n            else:\\n                d[char].append(i)\\n        k=list(d.values())\\n        l=list(d.keys())\\n        \\n        for i in range(len(k)):\\n            if abs(k[i][0]-k[i][1])-1==distance[ord(l[i])-ord(\\'a\\')]:\\n                ans+=1\\n            else:\\n                return False\\n       \\n        \\n        if ans==len(k):\\n            \\n            return True\\n        else:\\n            return False\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066535,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n        for (int i = 0; i < s.length(); i++)\\n        {\\n            int idx = s[i] - \\'a\\';\\n            if (distance[idx] == -1)\\n            {\\n                continue;\\n            }\\n            if (((i + distance[idx] + 1) > s.length()) || \\n                (s[i] != s[i + distance[idx] + 1]))\\n            {\\n                return false;\\n            }\\n            distance[idx] = -1;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n        for (int i = 0; i < s.length(); i++)\\n        {\\n            int idx = s[i] - \\'a\\';\\n            if (distance[idx] == -1)\\n            {\\n                continue;\\n            }\\n            if (((i + distance[idx] + 1) > s.length()) || \\n                (s[i] != s[i + distance[idx] + 1]))\\n            {\\n                return false;\\n            }\\n            distance[idx] = -1;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4064694,
                "title": "c-solution-6-line-solution-easy-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n        int dis=0,nextIndex=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]!=\\'*\\'){\\n            dis=distance[s[i]-\\'a\\'];\\n            nextIndex=(i+dis+1);\\n            if(nextIndex>=s.length()) return false;\\n            if(s[nextIndex]!=s[i]) return false;\\n            s[nextIndex]=\\'*\\';\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n        int dis=0,nextIndex=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]!=\\'*\\'){\\n            dis=distance[s[i]-\\'a\\'];\\n            nextIndex=(i+dis+1);\\n            if(nextIndex>=s.length()) return false;\\n            if(s[nextIndex]!=s[i]) return false;\\n            s[nextIndex]=\\'*\\';\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063071,
                "title": "java-simple-solution-beginner-friendly-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        for(int i=0;i<s.length()-1;i++){\\n            int val1=s.indexOf(s.charAt(i),i+1);\\n            if(val1>0){\\n                int  val2=s.charAt(i)-97;\\n                if(distance[val2]!=val1-i-1){\\n                    return false;\\n                }\\n            }\\n           \\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        for(int i=0;i<s.length()-1;i++){\\n            int val1=s.indexOf(s.charAt(i),i+1);\\n            if(val1>0){\\n                int  val2=s.charAt(i)-97;\\n                if(distance[val2]!=val1-i-1){\\n                    return false;\\n                }\\n            }\\n           \\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4050654,
                "title": "easy-solution-using-leetcode-hint",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   \\t bool checkDistances(string s, vector<int>& distance) {\\n\\t\\tint n=s.size();\\n\\n\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\tfor(int j=i+1;j<n;j++){\\n\\t\\t\\t\\tif(s[i]==s[j]){\\n\\t\\t\\t\\t\\tif(j-i-1 != distance[s[i]-\\'a\\']){\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\t bool checkDistances(string s, vector<int>& distance) {\\n\\t\\tint n=s.size();\\n\\n\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\tfor(int j=i+1;j<n;j++){\\n\\t\\t\\t\\tif(s[i]==s[j]){\\n\\t\\t\\t\\t\\tif(j-i-1 != distance[s[i]-\\'a\\']){\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047712,
                "title": "solution-in-java",
                "content": "```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        \\n        int j=0;\\n        for(int i=0;i<s.length();i++){\\n            j=i+1;\\n            while(j<s.length() && s.charAt(i)!=s.charAt(j)){\\n                j++;\\n            }\\n            if(j<s.length()){\\n                if(distance[s.charAt(i)-\\'a\\'] != Math.abs(j-i-1)){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        \\n        int j=0;\\n        for(int i=0;i<s.length();i++){\\n            j=i+1;\\n            while(j<s.length() && s.charAt(i)!=s.charAt(j)){\\n                j++;\\n            }\\n            if(j<s.length()){\\n                if(distance[s.charAt(i)-\\'a\\'] != Math.abs(j-i-1)){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4030116,
                "title": "beginner-friendly-beats-98-runtime-beats-98-memory-no-extra-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        for(int i=0; i<s.length(); i++){\\n            if(s.indexOf(s.charAt(i),i+1) > -1){\\n                if(distance[s.charAt(i)-\\'a\\'] != (s.indexOf(s.charAt(i),i+1)-i-1))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        for(int i=0; i<s.length(); i++){\\n            if(s.indexOf(s.charAt(i),i+1) > -1){\\n                if(distance[s.charAt(i)-\\'a\\'] != (s.indexOf(s.charAt(i),i+1)-i-1))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010961,
                "title": "python-concise-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def checkDistances(self, s, distance):\\n        \"\"\"\\n        :type s: str\\n        :type distance: List[int]\\n        :rtype: bool\\n        \"\"\"\\n\\n\\n\\n        for i in range(len(s)):\\n            ind = ord(s[i]) - ord(\\'a\\')\\n            #find the next occurence\\n            for j in range(i + 1, len(s)):\\n                if s[j] == s[i]:\\n                    if j - i - 1 != distance[ind]:\\n                        return False\\n        return True\\n\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def checkDistances(self, s, distance):\\n        \"\"\"\\n        :type s: str\\n        :type distance: List[int]\\n        :rtype: bool\\n        \"\"\"\\n\\n\\n\\n        for i in range(len(s)):\\n            ind = ord(s[i]) - ord(\\'a\\')\\n            #find the next occurence\\n            for j in range(i + 1, len(s)):\\n                if s[j] == s[i]:\\n                    if j - i - 1 != distance[ind]:\\n                        return False\\n        return True\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999962,
                "title": "java-hashset-easy-java-solution-easy-understanding",
                "content": "``` class Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        int index = 0;\\n        HashSet <Integer> visited = new HashSet();\\n        while(s.length()>index){\\n            char ch = s.charAt(index);\\n            int next = index+(distance[ch-97])+1;    \\n            if(!visited.contains(index)){\\n                if(next >= s.length() || ch != s.charAt(next)) return false;\\n                visited.add(next);\\n            }\\n\\n            index++;\\n        }\\n        return true;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "class Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        int index = 0;\\n        HashSet <Integer> visited = new HashSet();\\n        while(s.length()>index){\\n            char ch = s.charAt(index);\\n            int next = index+(distance[ch-97])+1;    \\n            if(!visited.contains(index)){\\n                if(next >= s.length() || ch != s.charAt(next)) return false;\\n                visited.add(next);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3997669,
                "title": "simple-solution",
                "content": "# Complexity\\n- Time complexity:  O(n)\\n- Space complexity: O(1)\\n# Code\\n```\\nclass Solution:\\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\\n        i = -1\\n        for alphabet in string.ascii_lowercase:\\n            first_occurrence = s.find(alphabet)\\n            second_occurrence = s.rfind(alphabet)\\n            i += 1\\n            if first_occurrence == second_occurrence == -1: \\n                continue\\n            if second_occurrence - first_occurrence -1 != distance[i]: \\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\\n        i = -1\\n        for alphabet in string.ascii_lowercase:\\n            first_occurrence = s.find(alphabet)\\n            second_occurrence = s.rfind(alphabet)\\n            i += 1\\n            if first_occurrence == second_occurrence == -1: \\n                continue\\n            if second_occurrence - first_occurrence -1 != distance[i]: \\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3997019,
                "title": "rate-my-beginner-solution-10-no-hashes-no-ord-method-solely-lists-and-indexing",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\\n        #convert alphabetstring to alphabetlist\\n        alphastring=\\'abcdefghijklmnopqrstuvwxyz\\'\\n        alphalist=[]\\n        for i in alphastring:\\n            alphalist.append(i)\\n\\n        #convert string to list\\n        stringlist_org=[]\\n        for i in s:\\n            stringlist_org.append(i)\\n\\n        indexdistance=[]\\n        for i in range(len(alphalist)): #iterate through each index letter of alphabet\\n            if alphalist[i] in stringlist_org: #if a letter exists in string then iterate\\n                stringlist=stringlist_org.copy() #restart the string again as original string \\n                inner_diff=[]\\n                for j in stringlist_org: #we need to iterate across the original list, if we iterate across the list that keeps changing (by removing characters)\\n            #then we miss out on elements, since the for loop only iterates through an index 0,1,2,3,4.. if we remove an element and we\\'re on the third iteration, it starts by iterating the 4th element until list end instead of..\\n                    if j==alphalist[i]:\\n                        pos=stringlist.index(j)\\n                        stringlist.remove(j)\\n                        inner_diff.append(pos)\\n                indexdistance.append((inner_diff[1]-inner_diff[0]))\\n        \\n        increment=0\\n        for i in range(len(alphalist)): #iterate over the alphabet list in its entirety\\n            if alphalist[i] in s: #we only care about letters in the string\\n                if distance[i]!=indexdistance[increment]:\\n                    return False\\n                    break\\n                increment+=1\\n        else:\\n            return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\\n        #convert alphabetstring to alphabetlist\\n        alphastring=\\'abcdefghijklmnopqrstuvwxyz\\'\\n        alphalist=[]\\n        for i in alphastring:\\n            alphalist.append(i)\\n\\n        #convert string to list\\n        stringlist_org=[]\\n        for i in s:\\n            stringlist_org.append(i)\\n\\n        indexdistance=[]\\n        for i in range(len(alphalist)): #iterate through each index letter of alphabet\\n            if alphalist[i] in stringlist_org: #if a letter exists in string then iterate\\n                stringlist=stringlist_org.copy() #restart the string again as original string \\n                inner_diff=[]\\n                for j in stringlist_org: #we need to iterate across the original list, if we iterate across the list that keeps changing (by removing characters)\\n            #then we miss out on elements, since the for loop only iterates through an index 0,1,2,3,4.. if we remove an element and we\\'re on the third iteration, it starts by iterating the 4th element until list end instead of..\\n                    if j==alphalist[i]:\\n                        pos=stringlist.index(j)\\n                        stringlist.remove(j)\\n                        inner_diff.append(pos)\\n                indexdistance.append((inner_diff[1]-inner_diff[0]))\\n        \\n        increment=0\\n        for i in range(len(alphalist)): #iterate over the alphabet list in its entirety\\n            if alphalist[i] in s: #we only care about letters in the string\\n                if distance[i]!=indexdistance[increment]:\\n                    return False\\n                    break\\n                increment+=1\\n        else:\\n            return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990526,
                "title": "o-1-space",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution:\\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\\n        for i in range(len(s)):\\n            letter = ord(s[i]) - ord(\\'a\\')\\n            if distance[letter] != -1 and (i + distance[letter] + 1 >= len(s) or s[i] != s[i + distance[letter] + 1]):\\n                return False\\n            distance[letter] = -1\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\\n        for i in range(len(s)):\\n            letter = ord(s[i]) - ord(\\'a\\')\\n            if distance[letter] != -1 and (i + distance[letter] + 1 >= len(s) or s[i] != s[i + distance[letter] + 1]):\\n                return False\\n            distance[letter] = -1\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990314,
                "title": "typescript-simple-solution-o-n",
                "content": "# Code (O(N))\\n- Initializes a map to store each character from string s and its last encountered index.\\n- Iterates over the string s, checking the index of each character.\\n- If a character is not in the map, stores its index. Otherwise, computes the distance from the previously stored index.\\n- Retrieves the expected distance for the character from the distance array.\\n- Compares the expected and actual distances. If they don\\'t match, returns false.\\n- If all distances match expectations, returns true.\\n```ts\\nfunction checkDistances(s: string, distance: number[]): boolean {\\n    const map = new Map<string, number>() // character, index\\n    for (let i = 0; i < s.length; i++) {\\n        const c = s[i]\\n        const gotIndex = map.get(c)\\n        if (gotIndex === undefined) {\\n            map.set(c, i)\\n            continue\\n        }\\n\\n        const charIndex = c.charCodeAt(0) - \"a\".charCodeAt(0)\\n        const actualDistance = i - gotIndex - 1\\n        if (distance[charIndex] !== actualDistance) return false\\n    }\\n    return true\\n};\\n```\\n\\n# Thank you\\nUpvote if you like \\u2B06\\uFE0F\\nIf you have any questions, please let me know in the comment section.",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```ts\\nfunction checkDistances(s: string, distance: number[]): boolean {\\n    const map = new Map<string, number>() // character, index\\n    for (let i = 0; i < s.length; i++) {\\n        const c = s[i]\\n        const gotIndex = map.get(c)\\n        if (gotIndex === undefined) {\\n            map.set(c, i)\\n            continue\\n        }\\n\\n        const charIndex = c.charCodeAt(0) - \"a\".charCodeAt(0)\\n        const actualDistance = i - gotIndex - 1\\n        if (distance[charIndex] !== actualDistance) return false\\n    }\\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3984162,
                "title": "bruteforce-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        for(int i=0; i<s.length()-1; i++){\\n            for(int j=i+1; j<s.length(); j++){\\n                if(s.charAt(i) == s.charAt(j)){\\n                    if(j-i-1 != distance[s.charAt(i)-\\'a\\']){\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        for(int i=0; i<s.length()-1; i++){\\n            for(int j=i+1; j<s.length(); j++){\\n                if(s.charAt(i) == s.charAt(j)){\\n                    if(j-i-1 != distance[s.charAt(i)-\\'a\\']){\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977103,
                "title": "beats-easy-beginner-friendly-solution-simple-and-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] d) {\\n        HashMap<Character,Integer>h=new HashMap();\\n        for(int i=0;i<s.length();i++){\\n            \\n            if(!h.containsKey(s.charAt(i))){\\n                h.put(s.charAt(i),i);\\n            }\\n            else{\\n                if((i-h.get(s.charAt(i)))!=(d[s.charAt(i)-\\'a\\']+1)){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] d) {\\n        HashMap<Character,Integer>h=new HashMap();\\n        for(int i=0;i<s.length();i++){\\n            \\n            if(!h.containsKey(s.charAt(i))){\\n                h.put(s.charAt(i),i);\\n            }\\n            else{\\n                if((i-h.get(s.charAt(i)))!=(d[s.charAt(i)-\\'a\\']+1)){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973744,
                "title": "super-duper-easy-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) \\n    {\\n        const size_t LEN = s.size();\\n\\n        for (size_t i = 0; i < LEN; ++i) {\\n            for (size_t j = i + 1; j < LEN; ++j) {\\n                if (s[i] == s[j] and j - i - 1 != distance[s[i] - \\'a\\']) {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}; \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) \\n    {\\n        const size_t LEN = s.size();\\n\\n        for (size_t i = 0; i < LEN; ++i) {\\n            for (size_t j = i + 1; j < LEN; ++j) {\\n                if (s[i] == s[j] and j - i - 1 != distance[s[i] - \\'a\\']) {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957081,
                "title": "easy-o-n-solution-in-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @param {number[]} distance\\n * @return {boolean}\\n */\\nvar checkDistances = function(s, distance) {\\n    const hash = {};\\n    for(let i=0,len=s.length;i<len;i++){\\n        if(hash[s[i]]==undefined){\\n            hash[s[i]] = i;\\n        }else{\\n            const d = distance[s.charCodeAt(i)-97];\\n            if(i-hash[s[i]] -1 != d) return false;\\n            hash[s[i]] = i;\\n        }\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {number[]} distance\\n * @return {boolean}\\n */\\nvar checkDistances = function(s, distance) {\\n    const hash = {};\\n    for(let i=0,len=s.length;i<len;i++){\\n        if(hash[s[i]]==undefined){\\n            hash[s[i]] = i;\\n        }else{\\n            const d = distance[s.charCodeAt(i)-97];\\n            if(i-hash[s[i]] -1 != d) return false;\\n            hash[s[i]] = i;\\n        }\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3951366,
                "title": "very-basic-java-soln-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        for(int i=0;i<26;i++){\\n            if(s.indexOf((char)(i+97))!=-1&&(s.lastIndexOf((char)(i+97))-s.indexOf((char)(i+97))-1)!=distance[i])\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        for(int i=0;i<26;i++){\\n            if(s.indexOf((char)(i+97))!=-1&&(s.lastIndexOf((char)(i+97))-s.indexOf((char)(i+97))-1)!=distance[i])\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950575,
                "title": "easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\\n        d={}\\n        \"\"\"for finding the indexes of elements\"\"\"\\n        for c,i in enumerate(s):\\n            if i not in d:\\n                d[i]=[c]\\n            else:\\n                d[i].append(c)\\n        \"\"\"now checking whether the diff of places is same as the distance or not\"\"\"\\n        for i in d:\\n            k=d[i][1]-d[i][0]-1\\n            if k!=distance[ord(i)-97]:\\n                return False\\n        return True\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\\n        d={}\\n        \"\"\"for finding the indexes of elements\"\"\"\\n        for c,i in enumerate(s):\\n            if i not in d:\\n                d[i]=[c]\\n            else:\\n                d[i].append(c)\\n        \"\"\"now checking whether the diff of places is same as the distance or not\"\"\"\\n        for i in d:\\n            k=d[i][1]-d[i][0]-1\\n            if k!=distance[ord(i)-97]:\\n                return False\\n        return True\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947101,
                "title": "1ms-java-99-no-data-structure",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        int[]arr = new int[26];\\n\\n        Arrays.fill(arr,-1);\\n        int idx=0;\\n        char c=\\' \\';\\n\\n        for(int i=0; i<s.length(); i++){\\n            c = s.charAt(i);\\n            idx = c - \\'a\\';\\n\\n            if(arr[idx]==-1) arr[idx]=i;\\n            else arr[idx] = i - arr[idx] - 1 ;            \\n        }\\n        for(int i=0; i<26; i++){\\n            if(arr[i]!=-1 && arr[i]!=distance[i]) return false;\\n        }\\n\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        int[]arr = new int[26];\\n\\n        Arrays.fill(arr,-1);\\n        int idx=0;\\n        char c=\\' \\';\\n\\n        for(int i=0; i<s.length(); i++){\\n            c = s.charAt(i);\\n            idx = c - \\'a\\';\\n\\n            if(arr[idx]==-1) arr[idx]=i;\\n            else arr[idx] = i - arr[idx] - 1 ;            \\n        }\\n        for(int i=0; i<26; i++){\\n            if(arr[i]!=-1 && arr[i]!=distance[i]) return false;\\n        }\\n\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946385,
                "title": "ruby-iterate-string-match-with-distances-count",
                "content": "# Intuition\\nFocus on string `s`, because we ignore characters not in `s`\\n# Approach\\nCount and compare matches of two character distances against `distance`, and compare the count of matches to the number of unique characters in `s`\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\ndef check_distances(s, distance)\\n  n = 0\\n  s = s.chars\\n  u = s.uniq.size\\n  s.size.times do\\n    c = s.shift\\n    i = c.ord-97\\n    n += 1 if s.index(c) == distance[i]\\n  end\\n  n == u\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef check_distances(s, distance)\\n  n = 0\\n  s = s.chars\\n  u = s.uniq.size\\n  s.size.times do\\n    c = s.shift\\n    i = c.ord-97\\n    n += 1 if s.index(c) == distance[i]\\n  end\\n  n == u\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3945049,
                "title": "java-easy-and-simple-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe iterate through the distance array and validate the distances with actual distances between characters.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n\\n        for(int i=0; i<distance.length; i++) {\\n                int first = s.indexOf(\\'a\\'+i);\\n                int second = s.indexOf(\\'a\\'+i, first+1);\\n                if(first == -1 || second == -1) {\\n                    continue;\\n                }\\n                if(distance[i] != second-first-1) {\\n                    return false;\\n                }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n\\n        for(int i=0; i<distance.length; i++) {\\n                int first = s.indexOf(\\'a\\'+i);\\n                int second = s.indexOf(\\'a\\'+i, first+1);\\n                if(first == -1 || second == -1) {\\n                    continue;\\n                }\\n                if(distance[i] != second-first-1) {\\n                    return false;\\n                }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943927,
                "title": "check-distances-between-same-letters-simple-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        Set<Character> inp =  new HashSet<>();\\n        for (char c : s.toCharArray()) inp.add(c);\\n        for(char c: inp){\\n            int first = s.indexOf(c);\\n            int last = s.lastIndexOf(c);\\n            if(Math.abs(first-(last-1))!=distance[(int)c-97]) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        Set<Character> inp =  new HashSet<>();\\n        for (char c : s.toCharArray()) inp.add(c);\\n        for(char c: inp){\\n            int first = s.indexOf(c);\\n            int last = s.lastIndexOf(c);\\n            if(Math.abs(first-(last-1))!=distance[(int)c-97]) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942418,
                "title": "python3-solution-beginner-friendlt",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\\n        d = {}\\n        for i, char in enumerate(s):\\n            if char in d:\\n                d[char] = i - d[char] - 1\\n            else:\\n                d[char] = i\\n        \\n        for key in d:\\n            index = ord(key) - ord(\\'a\\')\\n\\n            if distance[index] != d[key]:\\n                return False\\n        \\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\\n        d = {}\\n        for i, char in enumerate(s):\\n            if char in d:\\n                d[char] = i - d[char] - 1\\n            else:\\n                d[char] = i\\n        \\n        for key in d:\\n            index = ord(key) - ord(\\'a\\')\\n\\n            if distance[index] != d[key]:\\n                return False\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933807,
                "title": "beginner-s-approach-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn this approach we try to find the ith alphabet(according to the distance array example:-0th index is \\'a\\' , 1st index is \\'b\\') in the string(it is given that every alphabet appears twice)\\nAfter that we find the distance(here distance means the number of alphabet that appear between these two similar alphabet) between the two same alphabet.Now check this distance you found with the distance[i],if it does not match then it is false.\\n\\nNow clarifying the distance part if you subtract the index of first occurance and the second occurance then you will the distance it will need to reach the second occurance but if you subtract 1 from this you will get what you desire (abs(i-j-1)).\\nPlease upvote if liked.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dist(char c,string s){\\n        int flag=0;\\n        int start=0;\\n        int end=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==c){\\n                if(flag==0){\\n                    start=i;\\n                    flag=1;\\n                }\\n                else{\\n                    end=i;\\n                }\\n            }\\n        }\\n        \\n        if(flag==0){\\n            return -1;\\n        }\\n        return abs(end-start-1);\\n    }\\n    bool checkDistances(string s, vector<int>& distance) {\\n        for(int i=0;i<distance.size();i++){\\n            char c=\\'a\\'+i;\\n            \\n            int d=dist(c,s);\\n            if(d==-1){\\n               //Not present in the string\\n                continue;\\n            }\\n\\n            if(d!=distance[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dist(char c,string s){\\n        int flag=0;\\n        int start=0;\\n        int end=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==c){\\n                if(flag==0){\\n                    start=i;\\n                    flag=1;\\n                }\\n                else{\\n                    end=i;\\n                }\\n            }\\n        }\\n        \\n        if(flag==0){\\n            return -1;\\n        }\\n        return abs(end-start-1);\\n    }\\n    bool checkDistances(string s, vector<int>& distance) {\\n        for(int i=0;i<distance.size();i++){\\n            char c=\\'a\\'+i;\\n            \\n            int d=dist(c,s);\\n            if(d==-1){\\n               //Not present in the string\\n                continue;\\n            }\\n\\n            if(d!=distance[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3918874,
                "title": "easy-solution-using-java",
                "content": "\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        int[] a = new int[26];\\n        for(int i = 0; i < s.length(); i++){\\n            char c = s.charAt(i);\\n            if(a[c - \\'a\\'] == 0){\\n                a[c - \\'a\\'] = i + 1;\\n            }\\n            else if(distance[c - \\'a\\'] != (i + 1 - a[c - \\'a\\'] - 1)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        int[] a = new int[26];\\n        for(int i = 0; i < s.length(); i++){\\n            char c = s.charAt(i);\\n            if(a[c - \\'a\\'] == 0){\\n                a[c - \\'a\\'] = i + 1;\\n            }\\n            else if(distance[c - \\'a\\'] != (i + 1 - a[c - \\'a\\'] - 1)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916662,
                "title": "without-using-map-beats-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: \\u0398(n) , where n is the length of the string s.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: \\u0398(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int forwardIndex = i+1+distance[s.charAt(i)-\\'a\\'];\\n            int backwardIndex = i-1-distance[s.charAt(i)-\\'a\\'];\\n            if(forwardIndex<s.length() && s.charAt(forwardIndex)==s.charAt(i))continue;\\n            if(backwardIndex>=0 && s.charAt(backwardIndex)==s.charAt(i)) continue;\\n            return false;\\n           \\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int forwardIndex = i+1+distance[s.charAt(i)-\\'a\\'];\\n            int backwardIndex = i-1-distance[s.charAt(i)-\\'a\\'];\\n            if(forwardIndex<s.length() && s.charAt(forwardIndex)==s.charAt(i))continue;\\n            if(backwardIndex>=0 && s.charAt(backwardIndex)==s.charAt(i)) continue;\\n            return false;\\n           \\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3910528,
                "title": "easy-java-solution-1ms-beats-99-77",
                "content": "# Approach:\\n for each unique character, checking if another similar character is present at a given distance[i]\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        char[] carr = s.toCharArray();\\n        boolean[] processed = new boolean[26];\\n        int len = s.length();\\n        char ch;\\n        for(int i = 0; i<len; i++) {\\n            ch = carr[i];\\n            if(!processed[ch-97]) {\\n                if((1+ i + distance[ch-97] >= len) || carr[i+distance[ch-97] + 1] != ch) {\\n                    return false;\\n                }\\n                processed[ch-97] = true;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        char[] carr = s.toCharArray();\\n        boolean[] processed = new boolean[26];\\n        int len = s.length();\\n        char ch;\\n        for(int i = 0; i<len; i++) {\\n            ch = carr[i];\\n            if(!processed[ch-97]) {\\n                if((1+ i + distance[ch-97] >= len) || carr[i+distance[ch-97] + 1] != ch) {\\n                    return false;\\n                }\\n                processed[ch-97] = true;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3893917,
                "title": "rust",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn check_distances(s: String, distance: Vec<i32>) -> bool {\\n        let mut arr = vec![0i32;26];\\n        let mut hs:HashSet<char> = HashSet::new();\\n        for c in s.chars().into_iter(){\\n            hs.insert(c);\\n        }\\n        \\n        for h in hs.iter(){\\n            let f = s.chars().into_iter().enumerate()\\n                .filter(|p| p.1 == *h)\\n                .map(|m| m).collect::<Vec<_>>();\\n            arr[(f[0].1 as u8 - 97) as usize] = (f[1].0 - f[0].0 - 1) as i32;\\n        }\\n        let mut a = vec![0i32;26];\\n        let mut b = vec![0i32;26];\\n        for h in hs.iter(){\\n            a[(*h as u8 - 97) as usize] = arr[(*h as u8 - 97) as usize];\\n            b[(*h as u8 - 97) as usize] = distance[(*h as u8 - 97) as usize];\\n        }\\n        a == b\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn check_distances(s: String, distance: Vec<i32>) -> bool {\\n        let mut arr = vec![0i32;26];\\n        let mut hs:HashSet<char> = HashSet::new();\\n        for c in s.chars().into_iter(){\\n            hs.insert(c);\\n        }\\n        \\n        for h in hs.iter(){\\n            let f = s.chars().into_iter().enumerate()\\n                .filter(|p| p.1 == *h)\\n                .map(|m| m).collect::<Vec<_>>();\\n            arr[(f[0].1 as u8 - 97) as usize] = (f[1].0 - f[0].0 - 1) as i32;\\n        }\\n        let mut a = vec![0i32;26];\\n        let mut b = vec![0i32;26];\\n        for h in hs.iter(){\\n            a[(*h as u8 - 97) as usize] = arr[(*h as u8 - 97) as usize];\\n            b[(*h as u8 - 97) as usize] = distance[(*h as u8 - 97) as usize];\\n        }\\n        a == b\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3862285,
                "title": "extremely-simple-c-solution-using-hash-table-map-o-n-3ms",
                "content": "# Intuition\\nThis solution approach by is using hash table.\\n\\n# Approach\\n1. Create a hash table with <int> key and vector<int> key value pair.\\n2. Iterate over string and convert character into integer and keep that as key , push the character position in vector of the hash.\\n3. iterate over the hash and compare distance with vector[1]-vector[0]-1 for each hash. if it does not match return false.\\n4. return true if all distance match. \\n\\n# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n        unordered_map<int,vector<int>> ht;\\n        for(auto i=0;i<s.size();i++)\\n        {\\n            ht[int(s[i])-97].push_back(i);\\n        }\\n        for(auto i:ht)\\n        {\\n            //cout<<i.second[1]<<\":\"<<i.second[0]<<\":\"<<i.first<<\":\"<<distance[i.first]<<\":\"<<(i.second[1]) - (i.second[0])<<\";;\";\\n            if((i.second[1]) - (i.second[0])-1 != distance[i.first])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n        unordered_map<int,vector<int>> ht;\\n        for(auto i=0;i<s.size();i++)\\n        {\\n            ht[int(s[i])-97].push_back(i);\\n        }\\n        for(auto i:ht)\\n        {\\n            //cout<<i.second[1]<<\":\"<<i.second[0]<<\":\"<<i.first<<\":\"<<distance[i.first]<<\":\"<<(i.second[1]) - (i.second[0])<<\";;\";\\n            if((i.second[1]) - (i.second[0])-1 != distance[i.first])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3845160,
                "title": "easy-cpp-solution-beats-100-in-runtime-brute-force-solution",
                "content": "![image.png](https://assets.leetcode.com/users/images/c947b005-b033-48cf-b413-16c1e3d040e3_1690846519.0281508.png)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n\\n        vector<pair<int, int>> ind(26, {-1, -1});\\n\\n        for(int i=0; i<s.size(); i++){\\n            if(ind[s[i] - \\'a\\'].first == -1)\\n                ind[s[i] - \\'a\\'].first = i;\\n            else if(ind[s[i] - \\'a\\'].second == -1)\\n                ind[s[i] - \\'a\\'].second = i;\\n        }\\n\\n        for(int i=0; i<26; i++){\\n            if(ind[i].first != -1 && ind[i].second != -1){\\n                if(ind[i].second - (ind[i].first+1) != distance[i])\\n                     return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n\\n        vector<pair<int, int>> ind(26, {-1, -1});\\n\\n        for(int i=0; i<s.size(); i++){\\n            if(ind[s[i] - \\'a\\'].first == -1)\\n                ind[s[i] - \\'a\\'].first = i;\\n            else if(ind[s[i] - \\'a\\'].second == -1)\\n                ind[s[i] - \\'a\\'].second = i;\\n        }\\n\\n        for(int i=0; i<26; i++){\\n            if(ind[i].first != -1 && ind[i].second != -1){\\n                if(ind[i].second - (ind[i].first+1) != distance[i])\\n                     return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843920,
                "title": "python-3-beats-100-very-simple",
                "content": "\\n![image.png](https://assets.leetcode.com/users/images/f0d166f5-796e-4b3b-8dc7-d115dba366c3_1690822091.6792593.png)\\n\\n\\n# Approach\\nOnly search the unique values set(s)\\n\\nSimply use pythons in-built index method on the string to find the first and second (last) instance of the character within the string. \\n\\nWork out the distance between them\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\\n        for c in set(s):\\n            first = s.index(c)\\n            second = s.index(c, first+1)\\n            \\n            if ((second - 1) - first) != distance[ord(c)-97]:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\\n        for c in set(s):\\n            first = s.index(c)\\n            second = s.index(c, first+1)\\n            \\n            if ((second - 1) - first) != distance[ord(c)-97]:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842753,
                "title": "the-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        for (int i = 0; i < distance.length; i++) {\\n            int result = s.lastIndexOf(97 + i) - s.indexOf(97 + i) - 1;\\n            if (result < 0) {\\n                continue;\\n            }\\n            if (result != distance[i]) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        for (int i = 0; i < distance.length; i++) {\\n            int result = s.lastIndexOf(97 + i) - s.indexOf(97 + i) - 1;\\n            if (result < 0) {\\n                continue;\\n            }\\n            if (result != distance[i]) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827915,
                "title": "hashmap-solution-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n      Map<Character,Integer> map = new HashMap<>();\\n      for(int i = 0; i< s.length();i++){\\n          char ch = s.charAt(i);\\n        //Storing the index of 1st occurrence of a character\\n          if(!map.containsKey(ch))\\n          map.put(ch,i);\\n          else{\\n              int index = map.get(ch);\\n              int space = i - index - 1;\\n              if(distance[ch-\\'a\\'] != space)\\n              return false;\\n          }\\n      } \\n      return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n      Map<Character,Integer> map = new HashMap<>();\\n      for(int i = 0; i< s.length();i++){\\n          char ch = s.charAt(i);\\n        //Storing the index of 1st occurrence of a character\\n          if(!map.containsKey(ch))\\n          map.put(ch,i);\\n          else{\\n              int index = map.get(ch);\\n              int space = i - index - 1;\\n              if(distance[ch-\\'a\\'] != space)\\n              return false;\\n          }\\n      } \\n      return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827350,
                "title": "best-ans-most-simple-c-solution-for-beginners-pls-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince, all the letters occur only twice we cannot move through all the letters of the string as it will count even after the second occurence and the value will be updated.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo solve this problem we make use of a set which will only contain all the letters present in the string once in order.\\n\\n1. Now find the first and second occurenceof each letter of the set in the string and calculate the distance between them\\n2. Check whether distance[char] has the same value as the distance calculated\\n3. If it is same continue by checking for all entires in the set and return true if it does\\'nt match. \\n4. After traversing through the whole loop return true \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) : Since we have used set\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n        set <char> st;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            st.insert(s[i]);\\n        }\\n        for(auto i:st)\\n        {\\n            int start = s.find(i);\\n            int end = s.find(i,start+1);\\n            int dist = end-start-1;\\n            if(distance[i-97]==dist)\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n        set <char> st;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            st.insert(s[i]);\\n        }\\n        for(auto i:st)\\n        {\\n            int start = s.find(i);\\n            int end = s.find(i,start+1);\\n            int dist = end-start-1;\\n            if(distance[i-97]==dist)\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3825557,
                "title": "swift-o-n-time-o-n-space-beats-100-no-hashmap-dictionary",
                "content": "# Approach\\nThis solution differs from the other Swift solutions \\u2013 at least at the time of writing \\u2013 that all use Swift\\'s `Dictionary`.\\n\\nSince the number of possible letters is small, we can efficiently use an array instead of a dictionary. The array has 26 elements that are initialized to `-1` to indicate a letter has not been seen. When we first see a letter we replace the `-1` with the index the letter was seen at. When we next encounter the letter we can check the distance against the `distance` array.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ - we only iterate through the input string `s` once\\n\\n- Space complexity: $$O(n)$$ - the `codes` array and the temporary array created by `codes.enumerated()` both require $$O(n)$$ space. The `seen` array is $$O(1)$$.\\n\\n# Code\\n```\\nclass Solution {\\n    func checkDistances(_ s: String, _ distance: [Int]) -> Bool {\\n        let codes = s.map { Int($0.asciiValue! - Character(\"a\").asciiValue!) }\\n        var seen = [Int](repeating: -1, count: 26)\\n        for (index, code) in codes.enumerated() {\\n            if seen[code] == -1 {\\n                seen[code] = index\\n                continue\\n            }\\n            let actualDistance = index - seen[code] - 1\\n            if actualDistance != distance[code] {\\n                return false\\n            }\\n        }\\n        return true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func checkDistances(_ s: String, _ distance: [Int]) -> Bool {\\n        let codes = s.map { Int($0.asciiValue! - Character(\"a\").asciiValue!) }\\n        var seen = [Int](repeating: -1, count: 26)\\n        for (index, code) in codes.enumerated() {\\n            if seen[code] == -1 {\\n                seen[code] = index\\n                continue\\n            }\\n            let actualDistance = index - seen[code] - 1\\n            if actualDistance != distance[code] {\\n                return false\\n            }\\n        }\\n        return true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819975,
                "title": "typescript-readable",
                "content": "# Intuition\\nJust thought to create a code which is more readable and understandable\\n\\n# Approach\\n1. Create a alphabet-distance mapping\\n2. Create a map to store the calculated distance\\n3. Compare the alphabet-distance mapping with the map which is created to store the calculated distance\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nfunction checkDistances(s: string, distance: number[]): boolean {\\n    const alphabetsArray = \"abcdefghijklmnopqrstuvwxyz\".split(\\'\\')\\n    const distanceMappingbyChar = {}\\n    const distanceMappeingWithAlphabet = new Map<string, number>();\\n\\n    // mapping of distance array with the alphabets\\n    alphabetsArray.forEach((alphabet, index) => {\\n        distanceMappeingWithAlphabet.set(alphabet, distance[index])\\n    })\\n\\n\\n    // calculating the distance between the repeating alphabet\\n    s.split(\\'\\').forEach((alphabet, index) => {\\n        if(distanceMappingbyChar[alphabet]?.toString()) {\\n            distanceMappingbyChar[alphabet] = (index) - distanceMappingbyChar[alphabet]\\n        } else {\\n            distanceMappingbyChar[alphabet] = index + 1\\n        }\\n    })\\n \\n    // check the calculated distance and the expected distance\\n    for(let alphabet of Object.keys(distanceMappingbyChar)) {\\n        if(distanceMappingbyChar[alphabet] !== distanceMappeingWithAlphabet.get(alphabet)) {\\n            return false;\\n        }\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction checkDistances(s: string, distance: number[]): boolean {\\n    const alphabetsArray = \"abcdefghijklmnopqrstuvwxyz\".split(\\'\\')\\n    const distanceMappingbyChar = {}\\n    const distanceMappeingWithAlphabet = new Map<string, number>();\\n\\n    // mapping of distance array with the alphabets\\n    alphabetsArray.forEach((alphabet, index) => {\\n        distanceMappeingWithAlphabet.set(alphabet, distance[index])\\n    })\\n\\n\\n    // calculating the distance between the repeating alphabet\\n    s.split(\\'\\').forEach((alphabet, index) => {\\n        if(distanceMappingbyChar[alphabet]?.toString()) {\\n            distanceMappingbyChar[alphabet] = (index) - distanceMappingbyChar[alphabet]\\n        } else {\\n            distanceMappingbyChar[alphabet] = index + 1\\n        }\\n    })\\n \\n    // check the calculated distance and the expected distance\\n    for(let alphabet of Object.keys(distanceMappingbyChar)) {\\n        if(distanceMappingbyChar[alphabet] !== distanceMappeingWithAlphabet.get(alphabet)) {\\n            return false;\\n        }\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3810833,
                "title": "easy-and-fast-javascript-solution-with-explanation-line-by-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @param {number[]} distance\\n * @return {boolean}\\n */\\nvar checkDistances = function(s, distance) {\\n\\n    for(let i=0; i<s.length; i++){ // loop through the every element of string s\\n        let firstIndex = s.indexOf(s[i]); // find firstIndex of ith character of s\\n        let lastIndex = s.lastIndexOf(s[i]); // find lastIndex of ith character of s\\n        if(lastIndex > i){ // if lastIndex is greater than i\\n            let diff = lastIndex - firstIndex - 1; // find difference between lastIndex and firsIndex and subtract from 1\\n            if(diff !== distance[s.charCodeAt(i) - 97]){ // if diff is not equal to every element of distance then return false\\n               return false;\\n            }\\n        }\\n    }\\n    return true; // return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {number[]} distance\\n * @return {boolean}\\n */\\nvar checkDistances = function(s, distance) {\\n\\n    for(let i=0; i<s.length; i++){ // loop through the every element of string s\\n        let firstIndex = s.indexOf(s[i]); // find firstIndex of ith character of s\\n        let lastIndex = s.lastIndexOf(s[i]); // find lastIndex of ith character of s\\n        if(lastIndex > i){ // if lastIndex is greater than i\\n            let diff = lastIndex - firstIndex - 1; // find difference between lastIndex and firsIndex and subtract from 1\\n            if(diff !== distance[s.charCodeAt(i) - 97]){ // if diff is not equal to every element of distance then return false\\n               return false;\\n            }\\n        }\\n    }\\n    return true; // return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3793058,
                "title": "beats-in-runtime-easy-solution-using-loops",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        HashSet<Character> set = new HashSet<>();\\n        for(int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            int ind = 0;\\n            if(set.contains(c)) {\\n                continue;\\n            }\\n            for(int j = i+1; j < s.length(); j++){ \\n                if(s.charAt(j) == c) {\\n                    ind = j;\\n                }\\n            }\\n            set.add(c);\\n            if(ind-i-1 != distance[c - \\'a\\']){ \\n                return false;\\n            }\\n        }\\n        // if it is helpful, upvote it pls.\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        HashSet<Character> set = new HashSet<>();\\n        for(int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            int ind = 0;\\n            if(set.contains(c)) {\\n                continue;\\n            }\\n            for(int j = i+1; j < s.length(); j++){ \\n                if(s.charAt(j) == c) {\\n                    ind = j;\\n                }\\n            }\\n            set.add(c);\\n            if(ind-i-1 != distance[c - \\'a\\']){ \\n                return false;\\n            }\\n        }\\n        // if it is helpful, upvote it pls.\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793057,
                "title": "beats-in-runtime-easy-solution-using-loops",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        HashSet<Character> set = new HashSet<>();\\n        for(int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            int ind = 0;\\n            if(set.contains(c)) {\\n                continue;\\n            }\\n            for(int j = i+1; j < s.length(); j++){ \\n                if(s.charAt(j) == c) {\\n                    ind = j;\\n                }\\n            }\\n            set.add(c);\\n            if(ind-i-1 != distance[c - \\'a\\']){ \\n                return false;\\n            }\\n        }\\n        // if it is helpful, upvote it pls.\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        HashSet<Character> set = new HashSet<>();\\n        for(int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            int ind = 0;\\n            if(set.contains(c)) {\\n                continue;\\n            }\\n            for(int j = i+1; j < s.length(); j++){ \\n                if(s.charAt(j) == c) {\\n                    ind = j;\\n                }\\n            }\\n            set.add(c);\\n            if(ind-i-1 != distance[c - \\'a\\']){ \\n                return false;\\n            }\\n        }\\n        // if it is helpful, upvote it pls.\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793056,
                "title": "beats-in-runtime-easy-solution-using-loops",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        HashSet<Character> set = new HashSet<>();\\n        for(int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            int ind = 0;\\n            if(set.contains(c)) {\\n                continue;\\n            }\\n            for(int j = i+1; j < s.length(); j++){ \\n                if(s.charAt(j) == c) {\\n                    ind = j;\\n                }\\n            }\\n            set.add(c);\\n            if(ind-i-1 != distance[c - \\'a\\']){ \\n                return false;\\n            }\\n        }\\n        // if it is helpful, upvote it pls.\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        HashSet<Character> set = new HashSet<>();\\n        for(int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            int ind = 0;\\n            if(set.contains(c)) {\\n                continue;\\n            }\\n            for(int j = i+1; j < s.length(); j++){ \\n                if(s.charAt(j) == c) {\\n                    ind = j;\\n                }\\n            }\\n            set.add(c);\\n            if(ind-i-1 != distance[c - \\'a\\']){ \\n                return false;\\n            }\\n        }\\n        // if it is helpful, upvote it pls.\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793055,
                "title": "beats-in-runtime-easy-solution-using-loops",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        HashSet<Character> set = new HashSet<>();\\n        for(int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            int ind = 0;\\n            if(set.contains(c)) {\\n                continue;\\n            }\\n            for(int j = i+1; j < s.length(); j++){ \\n                if(s.charAt(j) == c) {\\n                    ind = j;\\n                }\\n            }\\n            set.add(c);\\n            if(ind-i-1 != distance[c - \\'a\\']){ \\n                return false;\\n            }\\n        }\\n        // if it is helpful, upvote it pls.\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        HashSet<Character> set = new HashSet<>();\\n        for(int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            int ind = 0;\\n            if(set.contains(c)) {\\n                continue;\\n            }\\n            for(int j = i+1; j < s.length(); j++){ \\n                if(s.charAt(j) == c) {\\n                    ind = j;\\n                }\\n            }\\n            set.add(c);\\n            if(ind-i-1 != distance[c - \\'a\\']){ \\n                return false;\\n            }\\n        }\\n        // if it is helpful, upvote it pls.\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3792452,
                "title": "java-easy-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        for(int i=1; i<s.length(); i++){\\n            if(s.indexOf(s.charAt(i))!=i){\\n                if(distance[s.charAt(i)-\\'a\\']!=i-s.indexOf(s.charAt(i))-1)\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        for(int i=1; i<s.length(); i++){\\n            if(s.indexOf(s.charAt(i))!=i){\\n                if(distance[s.charAt(i)-\\'a\\']!=i-s.indexOf(s.charAt(i))-1)\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3787002,
                "title": "easy-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @param {number[]} distance\\n * @return {boolean}\\n */\\nvar checkDistances = function(s, distance) {\\n    let wellSpaced = false;\\n\\n    for (let i=0; i< s.length; i++) {\\n       let idx = s.indexOf(s[i], i+1);\\n       if(idx > -1) {\\n           let diff = idx - i -1;\\n           let code = s.charCodeAt(i) -97;\\n            if(distance[code] === diff) {\\n                wellSpaced = true;\\n            } else {\\n                wellSpaced = false;\\n                return wellSpaced;\\n            }\\n       }\\n    }\\n    \\n    return wellSpaced;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {number[]} distance\\n * @return {boolean}\\n */\\nvar checkDistances = function(s, distance) {\\n    let wellSpaced = false;\\n\\n    for (let i=0; i< s.length; i++) {\\n       let idx = s.indexOf(s[i], i+1);\\n       if(idx > -1) {\\n           let diff = idx - i -1;\\n           let code = s.charCodeAt(i) -97;\\n            if(distance[code] === diff) {\\n                wellSpaced = true;\\n            } else {\\n                wellSpaced = false;\\n                return wellSpaced;\\n            }\\n       }\\n    }\\n    \\n    return wellSpaced;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3755359,
                "title": "easy-c-using-2-for-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n            for(int i=0;i<s.size()-1;i++){\\n                for(int j=i+1;j<s.size();j++){\\n                    if(s[i] == s[j]){\\n                        if( (j - i -1 ) != distance[s[i] - \\'a\\'] ){\\n                            return false;\\n                        }\\n                    }\\n                }\\n            }    \\n            return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n            for(int i=0;i<s.size()-1;i++){\\n                for(int j=i+1;j<s.size();j++){\\n                    if(s[i] == s[j]){\\n                        if( (j - i -1 ) != distance[s[i] - \\'a\\'] ){\\n                            return false;\\n                        }\\n                    }\\n                }\\n            }    \\n            return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741597,
                "title": "c-easy-and-simple-map-o-n-m-logm",
                "content": "# Complexity\\n- Time complexity: O(N + M*LogM)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m) \\nm == 26 (max)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n        map<char,vector<int>> mp;\\n        for(int i = 0; i<s.size(); i++){\\n            mp[s[i]].push_back(i);\\n        }\\n        \\n        vector<int> temp;\\n        for(auto i = \\'a\\'; i<=\\'z\\'; i++){\\n            if(mp.find(i) != mp.end()){\\n                auto it = mp[i];\\n                temp.push_back(it[1] - it[0] -1);\\n            }\\n        }\\n        \\n        // store the value of each char of s from distance \\n        vector<int> arr;\\n        for(auto it : mp){\\n            int a = it.first-\\'a\\';\\n            arr.push_back(distance[a]);\\n        }\\n        \\n        for(int i = 0; i<arr.size(); i++){\\n            if(arr[i] != temp[i])\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n        map<char,vector<int>> mp;\\n        for(int i = 0; i<s.size(); i++){\\n            mp[s[i]].push_back(i);\\n        }\\n        \\n        vector<int> temp;\\n        for(auto i = \\'a\\'; i<=\\'z\\'; i++){\\n            if(mp.find(i) != mp.end()){\\n                auto it = mp[i];\\n                temp.push_back(it[1] - it[0] -1);\\n            }\\n        }\\n        \\n        // store the value of each char of s from distance \\n        vector<int> arr;\\n        for(auto it : mp){\\n            int a = it.first-\\'a\\';\\n            arr.push_back(distance[a]);\\n        }\\n        \\n        for(int i = 0; i<arr.size(); i++){\\n            if(arr[i] != temp[i])\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741500,
                "title": "2-solutions-brute-force-hash-map",
                "content": "# Intuition\\nTrack both the values of i in hash map and then compare it with the given distance array.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& dist) {\\n        \\n       unordered_map<char,vector<int>> mp;\\n       int n=s.size();\\n       for(int i=0;i<n;i++)\\n       {\\n           mp[s[i]].push_back(i);\\n       }\\n\\n       for(auto &[key,val] : mp)\\n       {\\n           if(dist[key-\\'a\\']!=abs(val[1]-val[0]-1))\\n           return false;\\n       }\\n\\n       return true;\\n    }\\n};\\n//BRUTE FORCE\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& dist) {\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            char ch=s[i];\\n            for(int j=i+1;j<s.length();j++)\\n            {\\n              if(s[j]==s[i])\\n              {\\n                  if(dist[s[i]-\\'a\\']!=(j-i-1))\\n                  {\\n                      return false;\\n                  }\\n              }\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& dist) {\\n        \\n       unordered_map<char,vector<int>> mp;\\n       int n=s.size();\\n       for(int i=0;i<n;i++)\\n       {\\n           mp[s[i]].push_back(i);\\n       }\\n\\n       for(auto &[key,val] : mp)\\n       {\\n           if(dist[key-\\'a\\']!=abs(val[1]-val[0]-1))\\n           return false;\\n       }\\n\\n       return true;\\n    }\\n};\\n//BRUTE FORCE\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& dist) {\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            char ch=s[i];\\n            for(int j=i+1;j<s.length();j++)\\n            {\\n              if(s[j]==s[i])\\n              {\\n                  if(dist[s[i]-\\'a\\']!=(j-i-1))\\n                  {\\n                      return false;\\n                  }\\n              }\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738087,
                "title": "simple-and-easy-without-nesting-of-loops",
                "content": "# Approach\\nInitialize an array positions of size 26 with all elements set to -1. This array will store the last index of each letter encountered in s.\\nIterate through the characters of s using a loop and update the positions array accordingly:\\na. Calculate the index of the current character by subtracting the ASCII value of \\'a\\' from the character\\'s ASCII value.\\nb. If the character\\'s index is within the valid range of 0 to 25, update the corresponding element in positions to the current index.\\nIterate through the positions array and check if any element is still set to -1. If so, it means that a letter is missing from s, and we can ignore its corresponding distance.\\nIterate through the positions array and calculate the distance between the two occurrences of each letter:\\na. If the element in positions is not -1, calculate the distance by subtracting the current index from the stored index in positions.\\nb. Compare the calculated distance with the corresponding distance from the distance array. If they are not equal, return false.\\nIf all the distances match, return true as the string s is well-spaced.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n       std::vector<int> positions(26, -1);\\n\\n    for (int i = 0; i < s.length(); ++i) {\\n        int index = s[i] - \\'a\\';\\n        if (index >= 0 && index < 26) {\\n            if (positions[index] == -1) {\\n                positions[index] = i;\\n            } else {\\n                int calculatedDistance = i - positions[index] - 1;\\n                if (calculatedDistance != distance[index]) {\\n                    return false;\\n                }\\n            }\\n        }\\n    }\\n\\n    return true;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n       std::vector<int> positions(26, -1);\\n\\n    for (int i = 0; i < s.length(); ++i) {\\n        int index = s[i] - \\'a\\';\\n        if (index >= 0 && index < 26) {\\n            if (positions[index] == -1) {\\n                positions[index] = i;\\n            } else {\\n                int calculatedDistance = i - positions[index] - 1;\\n                if (calculatedDistance != distance[index]) {\\n                    return false;\\n                }\\n            }\\n        }\\n    }\\n\\n    return true;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736219,
                "title": "using-string-functions-direct-usage",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n        for(auto i:s){\\n            int a=s.find(i);\\n            int b=s.rfind(i);\\n            if(distance[i-\\'a\\']!=(b-a-1))\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n        for(auto i:s){\\n            int a=s.find(i);\\n            int b=s.rfind(i);\\n            if(distance[i-\\'a\\']!=(b-a-1))\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3733828,
                "title": "simple-straightforward-java-one-pass-scan-beat-100",
                "content": "# Intuition\\nevery char will apear twice\\nand only 26 chars\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can store the location in a array. when the second char shows up, check with the first char distance\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n       int[] loc = new int[26];\\n       for (int i=0; i<loc.length; i++) loc[i]=-1;\\n       char[] arr = s.toCharArray();\\n       for(int i=0; i<arr.length; i++){\\n           int inx = arr[i]-\\'a\\';\\n          // System.out.println(distance[inx])\\n          // System.out.println(distance[inx])\\n           if(loc[inx]!=-1 && i-loc[inx]-1 != distance[inx]) return false;\\n           loc[inx]=i;\\n       }\\n       return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n       int[] loc = new int[26];\\n       for (int i=0; i<loc.length; i++) loc[i]=-1;\\n       char[] arr = s.toCharArray();\\n       for(int i=0; i<arr.length; i++){\\n           int inx = arr[i]-\\'a\\';\\n          // System.out.println(distance[inx])\\n          // System.out.println(distance[inx])\\n           if(loc[inx]!=-1 && i-loc[inx]-1 != distance[inx]) return false;\\n           loc[inx]=i;\\n       }\\n       return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712781,
                "title": "easy-java-solution-beats-100-1ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.HashSet;\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        int i,j,x=0;\\n        boolean f=false;\\n        int a[]=new int[s.length()/2];\\n            for(i=0;i<s.length()-1;i++){\\n                int c=0;\\n                int ch1=(int)(s.charAt(i));\\n               for(j=i+1;j<s.length();j++){\\n                  if(s.charAt(i)==s.charAt(j)){\\n                      c=1;\\n                      break;\\n                  }\\n                    }\\n                    if(c==1){\\n                    if(distance[ch1-97]==(j-i-1))\\n                 f=true;\\n               else{\\n                   f=false;\\n                   break;\\n               }\\n                    }\\n               }\\n              \\n           return f;\\n        }\\n    }\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.HashSet;\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        int i,j,x=0;\\n        boolean f=false;\\n        int a[]=new int[s.length()/2];\\n            for(i=0;i<s.length()-1;i++){\\n                int c=0;\\n                int ch1=(int)(s.charAt(i));\\n               for(j=i+1;j<s.length();j++){\\n                  if(s.charAt(i)==s.charAt(j)){\\n                      c=1;\\n                      break;\\n                  }\\n                    }\\n                    if(c==1){\\n                    if(distance[ch1-97]==(j-i-1))\\n                 f=true;\\n               else{\\n                   f=false;\\n                   break;\\n               }\\n                    }\\n               }\\n              \\n           return f;\\n        }\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712603,
                "title": "1-pass-no-hashmap-beg-friendly-100",
                "content": "# Approach\\n***when encounter any character for the first time we are checking the second occurence of that character is at index , mentioned in distance array.if not for any one case we returning false.And when we encounter a second occurence of any char while traversal , we won\\'t enter the if condition as its marked as visited for its prev one***\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity: $$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        int n =s.length();\\n        boolean [] visited = new boolean[26];\\n        char [] chars= s.toCharArray();char curr;\\n        for(int i=0;i<n;i++)\\n        {\\n            curr =chars[i];\\n            if(!visited[curr-\\'0\\'-49]) \\n            {\\n                visited[curr-\\'0\\'-49] = true;\\n                if(i+1+distance[curr-\\'0\\'-49]>=n || chars[i+1+distance[curr-\\'0\\'-49]] != curr) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        int n =s.length();\\n        boolean [] visited = new boolean[26];\\n        char [] chars= s.toCharArray();char curr;\\n        for(int i=0;i<n;i++)\\n        {\\n            curr =chars[i];\\n            if(!visited[curr-\\'0\\'-49]) \\n            {\\n                visited[curr-\\'0\\'-49] = true;\\n                if(i+1+distance[curr-\\'0\\'-49]>=n || chars[i+1+distance[curr-\\'0\\'-49]] != curr) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703790,
                "title": "easy-c-solution",
                "content": "# Approach\\n- Use `Dictionary` to keep track of the first occurrence of each letter (alternatevely you can create an integer array of size 26).\\n- The number of letters between indices `i` and `j` is `j - i - 1`.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public bool CheckDistances(string s, int[] distance)\\n    {\\n        var indexes = new Dictionary<char, int>();\\n\\n        for (var i = 0; i < s.Length; i++)\\n        {\\n            var ch = s[i];\\n\\n            if (indexes.TryGetValue(ch, out var first))\\n            {\\n                if (i - first - 1 != distance[ch - \\'a\\'])\\n                {\\n                    return false;\\n                }\\n            }\\n            else\\n            {\\n                indexes.Add(ch, i);\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public bool CheckDistances(string s, int[] distance)\\n    {\\n        var indexes = new Dictionary<char, int>();\\n\\n        for (var i = 0; i < s.Length; i++)\\n        {\\n            var ch = s[i];\\n\\n            if (indexes.TryGetValue(ch, out var first))\\n            {\\n                if (i - first - 1 != distance[ch - \\'a\\'])\\n                {\\n                    return false;\\n                }\\n            }\\n            else\\n            {\\n                indexes.Add(ch, i);\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703199,
                "title": "very-very-eassy-method",
                "content": "# \\uD83D\\uDE09Don\\'t just watch & move away, also give an Upvote.\\uD83D\\uDE09\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n        int visited[26] = {0};\\n        int val = 0;//no. of letters b/w 2 selected alphabets.\\n\\n        for(int i=0; i<s.size(); i++)\\n        {\\n            //The below \\'if\\' condn. checks whether s[i] alphabet has been visited earlier or not, if visited jump one iteration. \\n            if(visited[int(s[i])-97] == 1)\\n            {\\n                continue;//this code skips 1 iteration.\\n            }\\n\\n            visited[int(s[i])-97] = 1;//mark the s[i] alphabet as visited.\\n            for(int j=i+1 ;j<s.size(); j++)\\n            {\\n                if(s[i] == s[j])\\n                {\\n                    val = j-i-1;\\n                    //comparing the val with distance array at particular index, if not equal the return false.\\n                    if(distance[(int(s[i])-97)] != val)\\n                        return false;\\n                }\\n            }\\n        }\\n\\n        //if the above for loop went good then return true.\\n<!-- \\u2705Well before returning answer don\\'t forget to UPVOTE.\\u2705 -->\\n        return true;\\n    }\\n};\\n```\\n![Leetcode Upvote.gif](https://assets.leetcode.com/users/images/674abcda-5acc-4376-b206-c685c1f8e9d7_1688196251.4341676.gif)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n        int visited[26] = {0};\\n        int val = 0;//no. of letters b/w 2 selected alphabets.\\n\\n        for(int i=0; i<s.size(); i++)\\n        {\\n            //The below \\'if\\' condn. checks whether s[i] alphabet has been visited earlier or not, if visited jump one iteration. \\n            if(visited[int(s[i])-97] == 1)\\n            {\\n                continue;//this code skips 1 iteration.\\n            }\\n\\n            visited[int(s[i])-97] = 1;//mark the s[i] alphabet as visited.\\n            for(int j=i+1 ;j<s.size(); j++)\\n            {\\n                if(s[i] == s[j])\\n                {\\n                    val = j-i-1;\\n                    //comparing the val with distance array at particular index, if not equal the return false.\\n                    if(distance[(int(s[i])-97)] != val)\\n                        return false;\\n                }\\n            }\\n        }\\n\\n        //if the above for loop went good then return true.\\n<!-- \\u2705Well before returning answer don\\'t forget to UPVOTE.\\u2705 -->\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696306,
                "title": "go-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport \"fmt\"\\nfunc checkDistances(s string, distance []int) bool {\\n    m1:=make(map[rune][]int)\\n    for i,ch:=range s{\\n        m1[ch]=append(m1[ch],i)\\n    }\\n    for index,i:=range distance{\\n        temp:=m1[rune(index+97)]\\n        if len(temp)==2{\\n            if temp[1]-temp[0]-1!=i{\\n                return false\\n        }\\n        }\\n    }\\n    return true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nimport \"fmt\"\\nfunc checkDistances(s string, distance []int) bool {\\n    m1:=make(map[rune][]int)\\n    for i,ch:=range s{\\n        m1[ch]=append(m1[ch],i)\\n    }\\n    for index,i:=range distance{\\n        temp:=m1[rune(index+97)]\\n        if len(temp)==2{\\n            if temp[1]-temp[0]-1!=i{\\n                return false\\n        }\\n        }\\n    }\\n    return true\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3687638,
                "title": "beats-100-o-n-time-o-1-space",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n    O(26*N) ~ O(N)\\n\\n- Space complexity:\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        for(int i =0 ;i<26;i++)\\n        {\\n            int prev = -1;\\n            char c = (char)((int)\\'a\\'+i);\\n            for(int j = 0;j<s.length();j++)\\n            {\\n                if(s.charAt(j) == c)\\n                {\\n                    if(prev == -1)\\n                    {\\n                        prev = j;\\n                    }\\n                    else\\n                    {\\n                        if(j-prev-1!=distance[i])\\n                        {\\n                            return false;\\n                        }\\n                        else\\n                        {\\n                            prev = j;\\n                        }\\n                    }   \\n                }\\n            }\\n            \\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        for(int i =0 ;i<26;i++)\\n        {\\n            int prev = -1;\\n            char c = (char)((int)\\'a\\'+i);\\n            for(int j = 0;j<s.length();j++)\\n            {\\n                if(s.charAt(j) == c)\\n                {\\n                    if(prev == -1)\\n                    {\\n                        prev = j;\\n                    }\\n                    else\\n                    {\\n                        if(j-prev-1!=distance[i])\\n                        {\\n                            return false;\\n                        }\\n                        else\\n                        {\\n                            prev = j;\\n                        }\\n                    }   \\n                }\\n            }\\n            \\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686540,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n        for (int i=0 ; i<s.length()-1 ; i++){\\n            for (int j=i+1 ; j<s.length() ; j++){\\n                if (s[i] == s[j]){\\n                    if (distance[s[i]-\\'a\\'] != j-i-1)\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n        for (int i=0 ; i<s.length()-1 ; i++){\\n            for (int j=i+1 ; j<s.length() ; j++){\\n                if (s[i] == s[j]){\\n                    if (distance[s[i]-\\'a\\'] != j-i-1)\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685730,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        HashMap<Character, Integer> map = new HashMap<>();\\n        for(int i=0; i<s.length(); i++) {\\n            char curr = s.charAt(i);\\n            if(map.containsKey(curr)) {\\n                map.put(curr, i-map.get(curr)-1);\\n                if(distance[curr-\\'a\\']!=map.get(curr)) {\\n                    return false;\\n                }\\n            }\\n            else {\\n                map.put(curr, i);\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        HashMap<Character, Integer> map = new HashMap<>();\\n        for(int i=0; i<s.length(); i++) {\\n            char curr = s.charAt(i);\\n            if(map.containsKey(curr)) {\\n                map.put(curr, i-map.get(curr)-1);\\n                if(distance[curr-\\'a\\']!=map.get(curr)) {\\n                    return false;\\n                }\\n            }\\n            else {\\n                map.put(curr, i);\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676369,
                "title": "java-easy-solution-beats-100-faster",
                "content": "```\\npublic boolean checkDistances(String s, int[] distance) {\\n        boolean res = true;\\n        int[] indices = new int[26];\\n        Arrays.fill(indices, -1);\\n        for (int i = 0; i < s.length(); i++) {\\n            int index = s.charAt(i) - 97;\\n            if (indices[index] == -1) {\\n                indices[index] = i;\\n            } else {\\n                indices[index] = i - indices[index] - 1;\\n            }\\n        }\\n        for (int i = 0; i < distance.length; i++) {\\n            if (indices[i] > -1 && indices[i] != distance[i]) {\\n                res = false;\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean checkDistances(String s, int[] distance) {\\n        boolean res = true;\\n        int[] indices = new int[26];\\n        Arrays.fill(indices, -1);\\n        for (int i = 0; i < s.length(); i++) {\\n            int index = s.charAt(i) - 97;\\n            if (indices[index] == -1) {\\n                indices[index] = i;\\n            } else {\\n                indices[index] = i - indices[index] - 1;\\n            }\\n        }\\n        for (int i = 0; i < distance.length; i++) {\\n            if (indices[i] > -1 && indices[i] != distance[i]) {\\n                res = false;\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3670988,
                "title": "easy-solution-in-java-runtime-100-beats-memory-99-77-beats",
                "content": "# Approach\\n\\n1. Create an integer array called `lastIndex` of size 26 to store the last index of each letter encountered in the string. Each element is initially set to 0.\\n2. Iterate over the characters of the string `s` using a loop variable `i` from 0 to the length of `s` - 1.\\n3. Inside the loop, retrieve the current character `c` at index `i`.\\n4. Calculate the index of the character by subtracting the ASCII value of `\\'a\\'` from `c`. This gives a value in the range 0-25, representing the corresponding letter.\\n5. Check if the `lastIndex` of the current letter is not 0. This indicates that the letter has occurred before in the string.\\n6. If the above condition is true, calculate the distance between the current index `i` and the last index of the letter by subtracting `lastIndex[index]` from `i`. If this distance is not equal to the expected distance `distance[index]` for the letter, return `false` immediately. The string is not well-spaced.\\n7. If the above condition is false, update the `lastIndex` of the current letter with the current index `i + 1` (adding 1 to handle 0-indexing).\\n8. Repeat steps 3-7 for each character in the string.\\n9. If the loop completes without returning `false`, it means all letters in the string satisfy the well-spaced condition. Return `true`.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        int[] lastIndex = new int[26]; // Store the last index of each letter\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            int index = c - \\'a\\';\\n\\n            if (lastIndex[index] != 0 && i - lastIndex[index] != distance[index])\\n                return false;\\n\\n            lastIndex[index] = i + 1; // Store the current index (adding 1 to handle 0-indexing)\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkDistances(String s, int[] distance) {\\n        int[] lastIndex = new int[26]; // Store the last index of each letter\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            int index = c - \\'a\\';\\n\\n            if (lastIndex[index] != 0 && i - lastIndex[index] != distance[index])\\n                return false;\\n\\n            lastIndex[index] = i + 1; // Store the current index (adding 1 to handle 0-indexing)\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3646163,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n        int x=0,y=0;\\n        for(int i=0;i<s.length();i++){\\n            for(int j=0;j<s.length();j++){\\n                x=i;\\n                if(i!=j){\\n                    if(s[i]==s[j]){\\n                        y=j;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(y-x>0){\\n                if(y-x-1!=distance[s[i]-\\'a\\']){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n        int x=0,y=0;\\n        for(int i=0;i<s.length();i++){\\n            for(int j=0;j<s.length();j++){\\n                x=i;\\n                if(i!=j){\\n                    if(s[i]==s[j]){\\n                        y=j;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(y-x>0){\\n                if(y-x-1!=distance[s[i]-\\'a\\']){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3644604,
                "title": "simple-easy-begineer-friendly-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n        for(int i=0;i<s.length();i++){\\n\\t\\t\\t\\t\\tfor(int j=i+1;j<s.length();j++){\\n\\t\\t\\t\\t\\t\\tif(s[i]==s[j]){\\n\\t\\t\\t\\t\\t\\t\\tif(j-i-1 != distance[s[i]-\\'a\\']) return false;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n    return true;\\n\\t\\t}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkDistances(string s, vector<int>& distance) {\\n        for(int i=0;i<s.length();i++){\\n\\t\\t\\t\\t\\tfor(int j=i+1;j<s.length();j++){\\n\\t\\t\\t\\t\\t\\tif(s[i]==s[j]){\\n\\t\\t\\t\\t\\t\\t\\tif(j-i-1 != distance[s[i]-\\'a\\']) return false;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n    return true;\\n\\t\\t}\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1761604,
                "content": [
                    {
                        "username": "miracomel",
                        "content": "I dont understand the question and the examples"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "1. consider that each alphabet is associated with numbers from 0 to 25\\n2. for every letter in this dictionary\\nif its ith letter exists in s, check if the distance between its two occurrence in s is same as distance[i]\\n3. if this rule applies for each letter that is common between the dictionary and s, it is a well spaced string\\n4. for letters in the dictionary that are not present in s, ignore them"
                    },
                    {
                        "username": "dastankg",
                        "content": "zz why false?"
                    },
                    {
                        "username": "avanalitekin",
                        "content": "I understood by cheking the solutions, zz actual distance is 0, but distance for z in the array is the last one which is 1, that is why. d[25] should be 0 to be true but it is 1."
                    },
                    {
                        "username": "Sharan3011",
                        "content": "[@devansh2805](/devansh2805) [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1]"
                    },
                    {
                        "username": "devansh2805",
                        "content": "[@Dastan Sazanov](/dastankg) what is the distance array input?"
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "# Intuition\n\nDescribtion Created by --\nhttps://leetcode.com/ThakurBallary/\n\nSo, basically we're given a string s\n\ns consists only of lowercase English letters.\n1. Each letter appears in s exactly twice.\n2. And we're also given an array distance of length 26,\ndistance[0] = difference between first and second occurrence of 'a'\n.\n. so on,\n.\ndistance[25] = difference between first and second occurrence of 'z'\n\n## another word---\ndistance[0] ------------------for a\ndistance[1] ------------------for b\ndistance[2] ------------------for c\n.\n.\n.\n..\n.\n.\ndistance[25] ------------------for z\n\nif a letter doesn't exists in s, we can ignore the distance associated to it.\n\nSo now our task is to,\n\n1. return true, if the difference between first and second occurrence of each letter in s is equal to distance of that letter.\n2. else return false\n\n\n\nJavaScript programmer can follow -\nhttps://leetcode.com/problems/check-distances-between-same-letters/solutions/3305867/description-with-two-approach/"
                    },
                    {
                        "username": "user6608CC",
                        "content": "s =\\n\"zz\"\\ndistance =\\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1]\\nOutput\\ntrue\\nExpected\\nfalse\\n\\n\\nwhy??"
                    },
                    {
                        "username": "iambhumik",
                        "content": "The distance[25] == 1 means there should be exactly 1 letter in between the two z's. In \"zz\", there is none so the answer is False"
                    },
                    {
                        "username": "datalinx",
                        "content": "I personally think this is not easy for beginners although experienced ones can find optimal solutions , also i cant find optimal solution"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "Here\\'s what this question means:\\n1. consider that each alphabet is associated with numbers from 0 to 25\\n2. for every letter in this dictionary\\nif its ith letter exists in s, check if the distance between its two occurrence in s is same as distance[i]\\n3. if this rule applies for each letter that is common between the dictionary and s, it is a well spaced string\\n4. for letters in the dictionary that are not present in s, ignore them"
                    },
                    {
                        "username": "abhijeet_mavi",
                        "content": "Can we solve this O(n) ?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "yup"
                    },
                    {
                        "username": "ia0726",
                        "content": "who can help fix my solution \n `class Solution:\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\n        has = {}\n        for i,c in enumerate(s):\n            if c in has:\n                if distance[ord(c)-97] >= i + 1 - has[c]:\n                    \n                    return False\n            has[c] = i + 1 \n\n        return True` "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/upload/main"
                    }
                ]
            },
            {
                "id": 1637974,
                "content": [
                    {
                        "username": "miracomel",
                        "content": "I dont understand the question and the examples"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "1. consider that each alphabet is associated with numbers from 0 to 25\\n2. for every letter in this dictionary\\nif its ith letter exists in s, check if the distance between its two occurrence in s is same as distance[i]\\n3. if this rule applies for each letter that is common between the dictionary and s, it is a well spaced string\\n4. for letters in the dictionary that are not present in s, ignore them"
                    },
                    {
                        "username": "dastankg",
                        "content": "zz why false?"
                    },
                    {
                        "username": "avanalitekin",
                        "content": "I understood by cheking the solutions, zz actual distance is 0, but distance for z in the array is the last one which is 1, that is why. d[25] should be 0 to be true but it is 1."
                    },
                    {
                        "username": "Sharan3011",
                        "content": "[@devansh2805](/devansh2805) [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1]"
                    },
                    {
                        "username": "devansh2805",
                        "content": "[@Dastan Sazanov](/dastankg) what is the distance array input?"
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "# Intuition\n\nDescribtion Created by --\nhttps://leetcode.com/ThakurBallary/\n\nSo, basically we're given a string s\n\ns consists only of lowercase English letters.\n1. Each letter appears in s exactly twice.\n2. And we're also given an array distance of length 26,\ndistance[0] = difference between first and second occurrence of 'a'\n.\n. so on,\n.\ndistance[25] = difference between first and second occurrence of 'z'\n\n## another word---\ndistance[0] ------------------for a\ndistance[1] ------------------for b\ndistance[2] ------------------for c\n.\n.\n.\n..\n.\n.\ndistance[25] ------------------for z\n\nif a letter doesn't exists in s, we can ignore the distance associated to it.\n\nSo now our task is to,\n\n1. return true, if the difference between first and second occurrence of each letter in s is equal to distance of that letter.\n2. else return false\n\n\n\nJavaScript programmer can follow -\nhttps://leetcode.com/problems/check-distances-between-same-letters/solutions/3305867/description-with-two-approach/"
                    },
                    {
                        "username": "user6608CC",
                        "content": "s =\\n\"zz\"\\ndistance =\\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1]\\nOutput\\ntrue\\nExpected\\nfalse\\n\\n\\nwhy??"
                    },
                    {
                        "username": "iambhumik",
                        "content": "The distance[25] == 1 means there should be exactly 1 letter in between the two z's. In \"zz\", there is none so the answer is False"
                    },
                    {
                        "username": "datalinx",
                        "content": "I personally think this is not easy for beginners although experienced ones can find optimal solutions , also i cant find optimal solution"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "Here\\'s what this question means:\\n1. consider that each alphabet is associated with numbers from 0 to 25\\n2. for every letter in this dictionary\\nif its ith letter exists in s, check if the distance between its two occurrence in s is same as distance[i]\\n3. if this rule applies for each letter that is common between the dictionary and s, it is a well spaced string\\n4. for letters in the dictionary that are not present in s, ignore them"
                    },
                    {
                        "username": "abhijeet_mavi",
                        "content": "Can we solve this O(n) ?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "yup"
                    },
                    {
                        "username": "ia0726",
                        "content": "who can help fix my solution \n `class Solution:\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\n        has = {}\n        for i,c in enumerate(s):\n            if c in has:\n                if distance[ord(c)-97] >= i + 1 - has[c]:\n                    \n                    return False\n            has[c] = i + 1 \n\n        return True` "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/upload/main"
                    }
                ]
            },
            {
                "id": 1834632,
                "content": [
                    {
                        "username": "miracomel",
                        "content": "I dont understand the question and the examples"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "1. consider that each alphabet is associated with numbers from 0 to 25\\n2. for every letter in this dictionary\\nif its ith letter exists in s, check if the distance between its two occurrence in s is same as distance[i]\\n3. if this rule applies for each letter that is common between the dictionary and s, it is a well spaced string\\n4. for letters in the dictionary that are not present in s, ignore them"
                    },
                    {
                        "username": "dastankg",
                        "content": "zz why false?"
                    },
                    {
                        "username": "avanalitekin",
                        "content": "I understood by cheking the solutions, zz actual distance is 0, but distance for z in the array is the last one which is 1, that is why. d[25] should be 0 to be true but it is 1."
                    },
                    {
                        "username": "Sharan3011",
                        "content": "[@devansh2805](/devansh2805) [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1]"
                    },
                    {
                        "username": "devansh2805",
                        "content": "[@Dastan Sazanov](/dastankg) what is the distance array input?"
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "# Intuition\n\nDescribtion Created by --\nhttps://leetcode.com/ThakurBallary/\n\nSo, basically we're given a string s\n\ns consists only of lowercase English letters.\n1. Each letter appears in s exactly twice.\n2. And we're also given an array distance of length 26,\ndistance[0] = difference between first and second occurrence of 'a'\n.\n. so on,\n.\ndistance[25] = difference between first and second occurrence of 'z'\n\n## another word---\ndistance[0] ------------------for a\ndistance[1] ------------------for b\ndistance[2] ------------------for c\n.\n.\n.\n..\n.\n.\ndistance[25] ------------------for z\n\nif a letter doesn't exists in s, we can ignore the distance associated to it.\n\nSo now our task is to,\n\n1. return true, if the difference between first and second occurrence of each letter in s is equal to distance of that letter.\n2. else return false\n\n\n\nJavaScript programmer can follow -\nhttps://leetcode.com/problems/check-distances-between-same-letters/solutions/3305867/description-with-two-approach/"
                    },
                    {
                        "username": "user6608CC",
                        "content": "s =\\n\"zz\"\\ndistance =\\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1]\\nOutput\\ntrue\\nExpected\\nfalse\\n\\n\\nwhy??"
                    },
                    {
                        "username": "iambhumik",
                        "content": "The distance[25] == 1 means there should be exactly 1 letter in between the two z's. In \"zz\", there is none so the answer is False"
                    },
                    {
                        "username": "datalinx",
                        "content": "I personally think this is not easy for beginners although experienced ones can find optimal solutions , also i cant find optimal solution"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "Here\\'s what this question means:\\n1. consider that each alphabet is associated with numbers from 0 to 25\\n2. for every letter in this dictionary\\nif its ith letter exists in s, check if the distance between its two occurrence in s is same as distance[i]\\n3. if this rule applies for each letter that is common between the dictionary and s, it is a well spaced string\\n4. for letters in the dictionary that are not present in s, ignore them"
                    },
                    {
                        "username": "abhijeet_mavi",
                        "content": "Can we solve this O(n) ?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "yup"
                    },
                    {
                        "username": "ia0726",
                        "content": "who can help fix my solution \n `class Solution:\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\n        has = {}\n        for i,c in enumerate(s):\n            if c in has:\n                if distance[ord(c)-97] >= i + 1 - has[c]:\n                    \n                    return False\n            has[c] = i + 1 \n\n        return True` "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/upload/main"
                    }
                ]
            },
            {
                "id": 1850160,
                "content": [
                    {
                        "username": "miracomel",
                        "content": "I dont understand the question and the examples"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "1. consider that each alphabet is associated with numbers from 0 to 25\\n2. for every letter in this dictionary\\nif its ith letter exists in s, check if the distance between its two occurrence in s is same as distance[i]\\n3. if this rule applies for each letter that is common between the dictionary and s, it is a well spaced string\\n4. for letters in the dictionary that are not present in s, ignore them"
                    },
                    {
                        "username": "dastankg",
                        "content": "zz why false?"
                    },
                    {
                        "username": "avanalitekin",
                        "content": "I understood by cheking the solutions, zz actual distance is 0, but distance for z in the array is the last one which is 1, that is why. d[25] should be 0 to be true but it is 1."
                    },
                    {
                        "username": "Sharan3011",
                        "content": "[@devansh2805](/devansh2805) [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1]"
                    },
                    {
                        "username": "devansh2805",
                        "content": "[@Dastan Sazanov](/dastankg) what is the distance array input?"
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "# Intuition\n\nDescribtion Created by --\nhttps://leetcode.com/ThakurBallary/\n\nSo, basically we're given a string s\n\ns consists only of lowercase English letters.\n1. Each letter appears in s exactly twice.\n2. And we're also given an array distance of length 26,\ndistance[0] = difference between first and second occurrence of 'a'\n.\n. so on,\n.\ndistance[25] = difference between first and second occurrence of 'z'\n\n## another word---\ndistance[0] ------------------for a\ndistance[1] ------------------for b\ndistance[2] ------------------for c\n.\n.\n.\n..\n.\n.\ndistance[25] ------------------for z\n\nif a letter doesn't exists in s, we can ignore the distance associated to it.\n\nSo now our task is to,\n\n1. return true, if the difference between first and second occurrence of each letter in s is equal to distance of that letter.\n2. else return false\n\n\n\nJavaScript programmer can follow -\nhttps://leetcode.com/problems/check-distances-between-same-letters/solutions/3305867/description-with-two-approach/"
                    },
                    {
                        "username": "user6608CC",
                        "content": "s =\\n\"zz\"\\ndistance =\\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1]\\nOutput\\ntrue\\nExpected\\nfalse\\n\\n\\nwhy??"
                    },
                    {
                        "username": "iambhumik",
                        "content": "The distance[25] == 1 means there should be exactly 1 letter in between the two z's. In \"zz\", there is none so the answer is False"
                    },
                    {
                        "username": "datalinx",
                        "content": "I personally think this is not easy for beginners although experienced ones can find optimal solutions , also i cant find optimal solution"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "Here\\'s what this question means:\\n1. consider that each alphabet is associated with numbers from 0 to 25\\n2. for every letter in this dictionary\\nif its ith letter exists in s, check if the distance between its two occurrence in s is same as distance[i]\\n3. if this rule applies for each letter that is common between the dictionary and s, it is a well spaced string\\n4. for letters in the dictionary that are not present in s, ignore them"
                    },
                    {
                        "username": "abhijeet_mavi",
                        "content": "Can we solve this O(n) ?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "yup"
                    },
                    {
                        "username": "ia0726",
                        "content": "who can help fix my solution \n `class Solution:\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\n        has = {}\n        for i,c in enumerate(s):\n            if c in has:\n                if distance[ord(c)-97] >= i + 1 - has[c]:\n                    \n                    return False\n            has[c] = i + 1 \n\n        return True` "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/upload/main"
                    }
                ]
            },
            {
                "id": 2038927,
                "content": [
                    {
                        "username": "miracomel",
                        "content": "I dont understand the question and the examples"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "1. consider that each alphabet is associated with numbers from 0 to 25\\n2. for every letter in this dictionary\\nif its ith letter exists in s, check if the distance between its two occurrence in s is same as distance[i]\\n3. if this rule applies for each letter that is common between the dictionary and s, it is a well spaced string\\n4. for letters in the dictionary that are not present in s, ignore them"
                    },
                    {
                        "username": "dastankg",
                        "content": "zz why false?"
                    },
                    {
                        "username": "avanalitekin",
                        "content": "I understood by cheking the solutions, zz actual distance is 0, but distance for z in the array is the last one which is 1, that is why. d[25] should be 0 to be true but it is 1."
                    },
                    {
                        "username": "Sharan3011",
                        "content": "[@devansh2805](/devansh2805) [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1]"
                    },
                    {
                        "username": "devansh2805",
                        "content": "[@Dastan Sazanov](/dastankg) what is the distance array input?"
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "# Intuition\n\nDescribtion Created by --\nhttps://leetcode.com/ThakurBallary/\n\nSo, basically we're given a string s\n\ns consists only of lowercase English letters.\n1. Each letter appears in s exactly twice.\n2. And we're also given an array distance of length 26,\ndistance[0] = difference between first and second occurrence of 'a'\n.\n. so on,\n.\ndistance[25] = difference between first and second occurrence of 'z'\n\n## another word---\ndistance[0] ------------------for a\ndistance[1] ------------------for b\ndistance[2] ------------------for c\n.\n.\n.\n..\n.\n.\ndistance[25] ------------------for z\n\nif a letter doesn't exists in s, we can ignore the distance associated to it.\n\nSo now our task is to,\n\n1. return true, if the difference between first and second occurrence of each letter in s is equal to distance of that letter.\n2. else return false\n\n\n\nJavaScript programmer can follow -\nhttps://leetcode.com/problems/check-distances-between-same-letters/solutions/3305867/description-with-two-approach/"
                    },
                    {
                        "username": "user6608CC",
                        "content": "s =\\n\"zz\"\\ndistance =\\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1]\\nOutput\\ntrue\\nExpected\\nfalse\\n\\n\\nwhy??"
                    },
                    {
                        "username": "iambhumik",
                        "content": "The distance[25] == 1 means there should be exactly 1 letter in between the two z's. In \"zz\", there is none so the answer is False"
                    },
                    {
                        "username": "datalinx",
                        "content": "I personally think this is not easy for beginners although experienced ones can find optimal solutions , also i cant find optimal solution"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "Here\\'s what this question means:\\n1. consider that each alphabet is associated with numbers from 0 to 25\\n2. for every letter in this dictionary\\nif its ith letter exists in s, check if the distance between its two occurrence in s is same as distance[i]\\n3. if this rule applies for each letter that is common between the dictionary and s, it is a well spaced string\\n4. for letters in the dictionary that are not present in s, ignore them"
                    },
                    {
                        "username": "abhijeet_mavi",
                        "content": "Can we solve this O(n) ?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "yup"
                    },
                    {
                        "username": "ia0726",
                        "content": "who can help fix my solution \n `class Solution:\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\n        has = {}\n        for i,c in enumerate(s):\n            if c in has:\n                if distance[ord(c)-97] >= i + 1 - has[c]:\n                    \n                    return False\n            has[c] = i + 1 \n\n        return True` "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/upload/main"
                    }
                ]
            },
            {
                "id": 1894714,
                "content": [
                    {
                        "username": "miracomel",
                        "content": "I dont understand the question and the examples"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "1. consider that each alphabet is associated with numbers from 0 to 25\\n2. for every letter in this dictionary\\nif its ith letter exists in s, check if the distance between its two occurrence in s is same as distance[i]\\n3. if this rule applies for each letter that is common between the dictionary and s, it is a well spaced string\\n4. for letters in the dictionary that are not present in s, ignore them"
                    },
                    {
                        "username": "dastankg",
                        "content": "zz why false?"
                    },
                    {
                        "username": "avanalitekin",
                        "content": "I understood by cheking the solutions, zz actual distance is 0, but distance for z in the array is the last one which is 1, that is why. d[25] should be 0 to be true but it is 1."
                    },
                    {
                        "username": "Sharan3011",
                        "content": "[@devansh2805](/devansh2805) [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1]"
                    },
                    {
                        "username": "devansh2805",
                        "content": "[@Dastan Sazanov](/dastankg) what is the distance array input?"
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "# Intuition\n\nDescribtion Created by --\nhttps://leetcode.com/ThakurBallary/\n\nSo, basically we're given a string s\n\ns consists only of lowercase English letters.\n1. Each letter appears in s exactly twice.\n2. And we're also given an array distance of length 26,\ndistance[0] = difference between first and second occurrence of 'a'\n.\n. so on,\n.\ndistance[25] = difference between first and second occurrence of 'z'\n\n## another word---\ndistance[0] ------------------for a\ndistance[1] ------------------for b\ndistance[2] ------------------for c\n.\n.\n.\n..\n.\n.\ndistance[25] ------------------for z\n\nif a letter doesn't exists in s, we can ignore the distance associated to it.\n\nSo now our task is to,\n\n1. return true, if the difference between first and second occurrence of each letter in s is equal to distance of that letter.\n2. else return false\n\n\n\nJavaScript programmer can follow -\nhttps://leetcode.com/problems/check-distances-between-same-letters/solutions/3305867/description-with-two-approach/"
                    },
                    {
                        "username": "user6608CC",
                        "content": "s =\\n\"zz\"\\ndistance =\\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1]\\nOutput\\ntrue\\nExpected\\nfalse\\n\\n\\nwhy??"
                    },
                    {
                        "username": "iambhumik",
                        "content": "The distance[25] == 1 means there should be exactly 1 letter in between the two z's. In \"zz\", there is none so the answer is False"
                    },
                    {
                        "username": "datalinx",
                        "content": "I personally think this is not easy for beginners although experienced ones can find optimal solutions , also i cant find optimal solution"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "Here\\'s what this question means:\\n1. consider that each alphabet is associated with numbers from 0 to 25\\n2. for every letter in this dictionary\\nif its ith letter exists in s, check if the distance between its two occurrence in s is same as distance[i]\\n3. if this rule applies for each letter that is common between the dictionary and s, it is a well spaced string\\n4. for letters in the dictionary that are not present in s, ignore them"
                    },
                    {
                        "username": "abhijeet_mavi",
                        "content": "Can we solve this O(n) ?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "yup"
                    },
                    {
                        "username": "ia0726",
                        "content": "who can help fix my solution \n `class Solution:\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\n        has = {}\n        for i,c in enumerate(s):\n            if c in has:\n                if distance[ord(c)-97] >= i + 1 - has[c]:\n                    \n                    return False\n            has[c] = i + 1 \n\n        return True` "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/upload/main"
                    }
                ]
            },
            {
                "id": 1807957,
                "content": [
                    {
                        "username": "miracomel",
                        "content": "I dont understand the question and the examples"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "1. consider that each alphabet is associated with numbers from 0 to 25\\n2. for every letter in this dictionary\\nif its ith letter exists in s, check if the distance between its two occurrence in s is same as distance[i]\\n3. if this rule applies for each letter that is common between the dictionary and s, it is a well spaced string\\n4. for letters in the dictionary that are not present in s, ignore them"
                    },
                    {
                        "username": "dastankg",
                        "content": "zz why false?"
                    },
                    {
                        "username": "avanalitekin",
                        "content": "I understood by cheking the solutions, zz actual distance is 0, but distance for z in the array is the last one which is 1, that is why. d[25] should be 0 to be true but it is 1."
                    },
                    {
                        "username": "Sharan3011",
                        "content": "[@devansh2805](/devansh2805) [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1]"
                    },
                    {
                        "username": "devansh2805",
                        "content": "[@Dastan Sazanov](/dastankg) what is the distance array input?"
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "# Intuition\n\nDescribtion Created by --\nhttps://leetcode.com/ThakurBallary/\n\nSo, basically we're given a string s\n\ns consists only of lowercase English letters.\n1. Each letter appears in s exactly twice.\n2. And we're also given an array distance of length 26,\ndistance[0] = difference between first and second occurrence of 'a'\n.\n. so on,\n.\ndistance[25] = difference between first and second occurrence of 'z'\n\n## another word---\ndistance[0] ------------------for a\ndistance[1] ------------------for b\ndistance[2] ------------------for c\n.\n.\n.\n..\n.\n.\ndistance[25] ------------------for z\n\nif a letter doesn't exists in s, we can ignore the distance associated to it.\n\nSo now our task is to,\n\n1. return true, if the difference between first and second occurrence of each letter in s is equal to distance of that letter.\n2. else return false\n\n\n\nJavaScript programmer can follow -\nhttps://leetcode.com/problems/check-distances-between-same-letters/solutions/3305867/description-with-two-approach/"
                    },
                    {
                        "username": "user6608CC",
                        "content": "s =\\n\"zz\"\\ndistance =\\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1]\\nOutput\\ntrue\\nExpected\\nfalse\\n\\n\\nwhy??"
                    },
                    {
                        "username": "iambhumik",
                        "content": "The distance[25] == 1 means there should be exactly 1 letter in between the two z's. In \"zz\", there is none so the answer is False"
                    },
                    {
                        "username": "datalinx",
                        "content": "I personally think this is not easy for beginners although experienced ones can find optimal solutions , also i cant find optimal solution"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "Here\\'s what this question means:\\n1. consider that each alphabet is associated with numbers from 0 to 25\\n2. for every letter in this dictionary\\nif its ith letter exists in s, check if the distance between its two occurrence in s is same as distance[i]\\n3. if this rule applies for each letter that is common between the dictionary and s, it is a well spaced string\\n4. for letters in the dictionary that are not present in s, ignore them"
                    },
                    {
                        "username": "abhijeet_mavi",
                        "content": "Can we solve this O(n) ?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "yup"
                    },
                    {
                        "username": "ia0726",
                        "content": "who can help fix my solution \n `class Solution:\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\n        has = {}\n        for i,c in enumerate(s):\n            if c in has:\n                if distance[ord(c)-97] >= i + 1 - has[c]:\n                    \n                    return False\n            has[c] = i + 1 \n\n        return True` "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/upload/main"
                    }
                ]
            },
            {
                "id": 1770616,
                "content": [
                    {
                        "username": "miracomel",
                        "content": "I dont understand the question and the examples"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "1. consider that each alphabet is associated with numbers from 0 to 25\\n2. for every letter in this dictionary\\nif its ith letter exists in s, check if the distance between its two occurrence in s is same as distance[i]\\n3. if this rule applies for each letter that is common between the dictionary and s, it is a well spaced string\\n4. for letters in the dictionary that are not present in s, ignore them"
                    },
                    {
                        "username": "dastankg",
                        "content": "zz why false?"
                    },
                    {
                        "username": "avanalitekin",
                        "content": "I understood by cheking the solutions, zz actual distance is 0, but distance for z in the array is the last one which is 1, that is why. d[25] should be 0 to be true but it is 1."
                    },
                    {
                        "username": "Sharan3011",
                        "content": "[@devansh2805](/devansh2805) [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1]"
                    },
                    {
                        "username": "devansh2805",
                        "content": "[@Dastan Sazanov](/dastankg) what is the distance array input?"
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "# Intuition\n\nDescribtion Created by --\nhttps://leetcode.com/ThakurBallary/\n\nSo, basically we're given a string s\n\ns consists only of lowercase English letters.\n1. Each letter appears in s exactly twice.\n2. And we're also given an array distance of length 26,\ndistance[0] = difference between first and second occurrence of 'a'\n.\n. so on,\n.\ndistance[25] = difference between first and second occurrence of 'z'\n\n## another word---\ndistance[0] ------------------for a\ndistance[1] ------------------for b\ndistance[2] ------------------for c\n.\n.\n.\n..\n.\n.\ndistance[25] ------------------for z\n\nif a letter doesn't exists in s, we can ignore the distance associated to it.\n\nSo now our task is to,\n\n1. return true, if the difference between first and second occurrence of each letter in s is equal to distance of that letter.\n2. else return false\n\n\n\nJavaScript programmer can follow -\nhttps://leetcode.com/problems/check-distances-between-same-letters/solutions/3305867/description-with-two-approach/"
                    },
                    {
                        "username": "user6608CC",
                        "content": "s =\\n\"zz\"\\ndistance =\\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1]\\nOutput\\ntrue\\nExpected\\nfalse\\n\\n\\nwhy??"
                    },
                    {
                        "username": "iambhumik",
                        "content": "The distance[25] == 1 means there should be exactly 1 letter in between the two z's. In \"zz\", there is none so the answer is False"
                    },
                    {
                        "username": "datalinx",
                        "content": "I personally think this is not easy for beginners although experienced ones can find optimal solutions , also i cant find optimal solution"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "Here\\'s what this question means:\\n1. consider that each alphabet is associated with numbers from 0 to 25\\n2. for every letter in this dictionary\\nif its ith letter exists in s, check if the distance between its two occurrence in s is same as distance[i]\\n3. if this rule applies for each letter that is common between the dictionary and s, it is a well spaced string\\n4. for letters in the dictionary that are not present in s, ignore them"
                    },
                    {
                        "username": "abhijeet_mavi",
                        "content": "Can we solve this O(n) ?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "yup"
                    },
                    {
                        "username": "ia0726",
                        "content": "who can help fix my solution \n `class Solution:\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\n        has = {}\n        for i,c in enumerate(s):\n            if c in has:\n                if distance[ord(c)-97] >= i + 1 - has[c]:\n                    \n                    return False\n            has[c] = i + 1 \n\n        return True` "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/upload/main"
                    }
                ]
            },
            {
                "id": 1766088,
                "content": [
                    {
                        "username": "miracomel",
                        "content": "I dont understand the question and the examples"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "1. consider that each alphabet is associated with numbers from 0 to 25\\n2. for every letter in this dictionary\\nif its ith letter exists in s, check if the distance between its two occurrence in s is same as distance[i]\\n3. if this rule applies for each letter that is common between the dictionary and s, it is a well spaced string\\n4. for letters in the dictionary that are not present in s, ignore them"
                    },
                    {
                        "username": "dastankg",
                        "content": "zz why false?"
                    },
                    {
                        "username": "avanalitekin",
                        "content": "I understood by cheking the solutions, zz actual distance is 0, but distance for z in the array is the last one which is 1, that is why. d[25] should be 0 to be true but it is 1."
                    },
                    {
                        "username": "Sharan3011",
                        "content": "[@devansh2805](/devansh2805) [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1]"
                    },
                    {
                        "username": "devansh2805",
                        "content": "[@Dastan Sazanov](/dastankg) what is the distance array input?"
                    },
                    {
                        "username": "sajjadbhuiyan",
                        "content": "# Intuition\n\nDescribtion Created by --\nhttps://leetcode.com/ThakurBallary/\n\nSo, basically we're given a string s\n\ns consists only of lowercase English letters.\n1. Each letter appears in s exactly twice.\n2. And we're also given an array distance of length 26,\ndistance[0] = difference between first and second occurrence of 'a'\n.\n. so on,\n.\ndistance[25] = difference between first and second occurrence of 'z'\n\n## another word---\ndistance[0] ------------------for a\ndistance[1] ------------------for b\ndistance[2] ------------------for c\n.\n.\n.\n..\n.\n.\ndistance[25] ------------------for z\n\nif a letter doesn't exists in s, we can ignore the distance associated to it.\n\nSo now our task is to,\n\n1. return true, if the difference between first and second occurrence of each letter in s is equal to distance of that letter.\n2. else return false\n\n\n\nJavaScript programmer can follow -\nhttps://leetcode.com/problems/check-distances-between-same-letters/solutions/3305867/description-with-two-approach/"
                    },
                    {
                        "username": "user6608CC",
                        "content": "s =\\n\"zz\"\\ndistance =\\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1]\\nOutput\\ntrue\\nExpected\\nfalse\\n\\n\\nwhy??"
                    },
                    {
                        "username": "iambhumik",
                        "content": "The distance[25] == 1 means there should be exactly 1 letter in between the two z's. In \"zz\", there is none so the answer is False"
                    },
                    {
                        "username": "datalinx",
                        "content": "I personally think this is not easy for beginners although experienced ones can find optimal solutions , also i cant find optimal solution"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "Here\\'s what this question means:\\n1. consider that each alphabet is associated with numbers from 0 to 25\\n2. for every letter in this dictionary\\nif its ith letter exists in s, check if the distance between its two occurrence in s is same as distance[i]\\n3. if this rule applies for each letter that is common between the dictionary and s, it is a well spaced string\\n4. for letters in the dictionary that are not present in s, ignore them"
                    },
                    {
                        "username": "abhijeet_mavi",
                        "content": "Can we solve this O(n) ?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "yup"
                    },
                    {
                        "username": "ia0726",
                        "content": "who can help fix my solution \n `class Solution:\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\n        has = {}\n        for i,c in enumerate(s):\n            if c in has:\n                if distance[ord(c)-97] >= i + 1 - has[c]:\n                    \n                    return False\n            has[c] = i + 1 \n\n        return True` "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/upload/main"
                    }
                ]
            }
        ]
    }
]