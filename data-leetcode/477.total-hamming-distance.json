[
    {
        "title": "Number Complement",
        "question_content": "The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's to 0's in its binary representation.\n\n\tFor example, The integer 5 is \"101\" in binary and its complement is \"010\" which is the integer 2.\n\nGiven an integer num, return its complement.\n&nbsp;\nExample 1:\n\nInput: num = 5\nOutput: 2\nExplanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.\n\nExample 2:\n\nInput: num = 1\nOutput: 0\nExplanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.\n\n&nbsp;\nConstraints:\n\n\t1 <= num < 231\n\n&nbsp;\nNote: This question is the same as 1009: https://leetcode.com/problems/complement-of-base-10-integer/",
        "solutions": [
            {
                "id": 96017,
                "title": "3-line-1-line-c",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1.\\n\\n```\\n// OJ: https://leetcode.com/problems/number-complement/\\n// Author: github.com/lzl124631x\\n// Time: O(1) as there are at most 32 bits to move\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        unsigned mask = ~0;\\n        while (num & mask) mask <<= 1;\\n        return ~mask & ~num;\\n    }\\n};\\n```\\n\\nFor example,\\n```\\nnum          = 00000101\\nmask         = 11111000\\n~mask & ~num = 00000010\\n```\\n\\n## Solution 2. \\n\\n```cpp\\n// OJ: https://leetcode.com/problems/number-complement/\\n// Author: github.com/lzl124631x\\n// Time: O(1)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int findComplement(int n) {\\n        return (unsigned)~0 >> __builtin_clz(n) ^ n;\\n    }\\n};\\n```\\n\\nFor example:\\n\\n```\\nn                                    = 00000101\\n(unsigned)~0 >> __builtin_clz(n)     = 00000111\\n(unsigned)~0 >> __builtin_clz(n) ^ n = 00000010\\n```\\n",
                "solutionTags": [],
                "code": "```\\n// OJ: https://leetcode.com/problems/number-complement/\\n// Author: github.com/lzl124631x\\n// Time: O(1) as there are at most 32 bits to move\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        unsigned mask = ~0;\\n        while (num & mask) mask <<= 1;\\n        return ~mask & ~num;\\n    }\\n};\\n```\n```\\nnum          = 00000101\\nmask         = 11111000\\n~mask & ~num = 00000010\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/number-complement/\\n// Author: github.com/lzl124631x\\n// Time: O(1)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int findComplement(int n) {\\n        return (unsigned)~0 >> __builtin_clz(n) ^ n;\\n    }\\n};\\n```\n```\\nn                                    = 00000101\\n(unsigned)~0 >> __builtin_clz(n)     = 00000111\\n(unsigned)~0 >> __builtin_clz(n) ^ n = 00000010\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96018,
                "title": "java-very-simple-code-and-self-evident-explanation",
                "content": "for example:\\n100110, its complement is 011001, the sum is 111111. So we only need get the min number large or equal to num, then do substraction\\n```\\n    public int findComplement(int num) \\n    {\\n        int i = 0;\\n        int j = 0;\\n        \\n        while (i < num)\\n        {\\n            i += Math.pow(2, j);\\n            j++;\\n        }\\n        \\n        return i - num;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int findComplement(int num) \\n    {\\n        int i = 0;\\n        int j = 0;\\n        \\n        while (i < num)\\n        {\\n            i += Math.pow(2, j);\\n            j++;\\n        }\\n        \\n        return i - num;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 96009,
                "title": "simple-python",
                "content": "```\\nclass Solution(object):\\n    def findComplement(self, num):\\n        i = 1\\n        while i <= num:\\n            i = i << 1\\n        return (i - 1) ^ num\\n```\\n\\nFYI: pomodoro timer helps to obtain higher time ROI:  [e-tomato.online](http://e-tomato.online)",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findComplement(self, num):\\n        i = 1\\n        while i <= num:\\n            i = i << 1\\n        return (i - 1) ^ num\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95992,
                "title": "java-1-line-bit-manipulation-solution",
                "content": "I post solution first and then give out explanation. Please think why does it work before read my explanation.\\n\\n```\\npublic class Solution {\\n    public int findComplement(int num) {\\n        return ~num & ((Integer.highestOneBit(num) << 1) - 1);\\n    }\\n}\\n```\\n\\nAccording to the problem, the result is\\n1. The ```flipped``` version of the original ```input``` but\\n2. Only flip ```N``` bits within the range from ```LEFTMOST``` bit of ```1``` to ```RIGHTMOST```. \\nFor example input = ```5``` (the binary representation is ```101```), the ```LEFTMOST``` bit of ```1``` is the third one from ```RIGHTMOST``` (```100```, ```N``` =  3). Then we need to flip 3 bits from ```RIGHTMOST``` and the answer is ```010```\\n\\nTo achieve above algorithm, we need to do 3 steps:\\n1. Create a bit mask which has ```N``` bits of ```1``` from ```RIGHTMOST```. In above example, the mask is ```111```. And we can use the decent Java built-in function ```Integer.highestOneBit``` to get the ```LEFTMOST``` bit of ```1```, left shift one, and then minus one. Please remember this wonderful trick to create bit masks with ```N``` ones at ```RIGHTMOST```, you will be able to use it later.\\n2. Negate the whole input number.\\n3. ```Bit AND``` numbers in step ```1``` and ```2```.\\n\\nThree line solution if you think one line solution is too confusing:\\n```\\npublic class Solution {\\n    public int findComplement(int num) {\\n        int mask = (Integer.highestOneBit(num) << 1) - 1;\\n        num = ~num;\\n        return num & mask;\\n    }\\n}\\n```\\n\\n```UPDATE```\\nAs several people pointed out, we don't need to left shift 1. That's true because the highest ```1``` bit will always become ```0``` in the ```Complement``` result. So we don't need to take care of that bit.\\n\\n```\\npublic class Solution {\\n    public int findComplement(int num) {\\n        return ~num & (Integer.highestOneBit(num) - 1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int findComplement(int num) {\\n        return ~num & ((Integer.highestOneBit(num) << 1) - 1);\\n    }\\n}\\n```\n```flipped```\n```input```\n```N```\n```LEFTMOST```\n```1```\n```RIGHTMOST```\n```5```\n```101```\n```LEFTMOST```\n```1```\n```RIGHTMOST```\n```100```\n```N```\n```RIGHTMOST```\n```010```\n```N```\n```1```\n```RIGHTMOST```\n```111```\n```Integer.highestOneBit```\n```LEFTMOST```\n```1```\n```N```\n```RIGHTMOST```\n```Bit AND```\n```1```\n```2```\n```\\npublic class Solution {\\n    public int findComplement(int num) {\\n        int mask = (Integer.highestOneBit(num) << 1) - 1;\\n        num = ~num;\\n        return num & mask;\\n    }\\n}\\n```\n```UPDATE```\n```1```\n```0```\n```Complement```\n```\\npublic class Solution {\\n    public int findComplement(int num) {\\n        return ~num & (Integer.highestOneBit(num) - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96103,
                "title": "maybe-fewest-operations",
                "content": "Spread the highest 1-bit onto all the lower bits. Then xor with that.\\n```\\nint findComplement(int num) {\\n    int mask = num;\\n    mask |= mask >> 1;\\n    mask |= mask >> 2;\\n    mask |= mask >> 4;\\n    mask |= mask >> 8;\\n    mask |= mask >> 16;\\n    return num ^ mask;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint findComplement(int num) {\\n    int mask = num;\\n    mask |= mask >> 1;\\n    mask |= mask >> 2;\\n    mask |= mask >> 4;\\n    mask |= mask >> 8;\\n    mask |= mask >> 16;\\n    return num ^ mask;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1649574,
                "title": "c-easy-to-solve-different-variations-of-code-with-detailed-exaplanations",
                "content": "Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation.\\n\\n**Intuition:-**\\nThere is not much of a intuition in this question as the question is loud and clear about it\\'s use of bit manipulation .\\n\\nTo make things a bit more interesting let\\'s do this question with and wihout bit manipulation\\n\\n* **Using Bit Manipulations:---**\\n\\n**Bit masking can be summarized with this image (^_^)**\\n![image](https://assets.leetcode.com/users/images/d478c8d2-3fbb-49fd-956a-ae31a014a926_1640579005.4899502.jpeg) \\nThus, we can conclude that masking means to keep/change/remove a desired part of information.\\n\\n**Dry run of bitmasking:-**\\n![image](https://assets.leetcode.com/users/images/face3402-7526-4282-becd-7564dc8b4a95_1640574890.4955626.png)\\n\\n**Code1[Using bitmasking]:-**\\n```\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        unsigned mask = ~0;\\n        while( mask & num ) mask = mask << 1;\\n        return ~num ^ mask;\\n    }\\n};\\n```\\n**Time Complexity:** *`O(log(num)) = O(since we will be moving at most 32bits only) = O(1)`*\\n**Space Complexity:** *`O(1)`*\\n\\n**Code2[Using xor]:-**\\nBasic idea is to find the smallest power of 2 that is larger than the `input number num`, and output the difference between `powerof2s` and `num` . \\n\\n**Dry run:-**\\n```\\nFor example let\\'s the example from description of the question:-\\nInput: num = 5(101) ,\\nThus the smallest power of 2 (and larger than 5) is 8 (1000)\\nThe output should be 8 - 5 - 1 = 2 (010).\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        long powerof2s = 2, temp = num;\\n        \\n        while(temp>>1) {\\n            temp >>= 1;\\n            powerof2s <<= 1;\\n        }\\n        \\n        return powerof2s - num - 1;\\n    }\\n};\\n```\\n.\\n\\n* **Without using Bit manipulation:-**\\n\\n***Code:-***\\n```\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        vector<int> temp; \\n\\t\\t// convert to binary representation\\n        while( num != 0 ){\\n            temp.push_back( num % 2 );\\n            num /= 2;\\n        } \\n\\t\\t// make complement\\n        for(int i=0; i<temp.size(); i++){\\n            if( temp[i] == 1 ) temp[i] = 0;\\n            else if( temp[i] == 0 ) temp[i] = 1;\\n        } int res = 0;\\n        for(int i=temp.size()-1; i>-1; i--) res = res * 2 + temp[i];\\n        return res;\\n    }\\n};\\n```\\n\\n***\\n\\n**[My Github Repo](https://github.com/Jatin-Shihora/LeetCode-Solutions) where I keep track of my solutions :)))**\\n\\n***\\n\\n......*Continuation from previous posts..\\nTill now in Dr.Cheems ancient ruins arc, JThree,Doggo,Dogenderous,Dogelina and yomru all of them reached the crystal white ceiling of the Dr Cheems ancient laboratory . When they were just above the ceiling everyone saw some black texts at all 4 directions . Once they landed on the ceiling. JThree,Doggo,yomru and Dogelina all of them started moving in those directions to find those texts that were present on the ceiling . All of them found the texts .\\nTo be Continued in the next post* ......\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        unsigned mask = ~0;\\n        while( mask & num ) mask = mask << 1;\\n        return ~num ^ mask;\\n    }\\n};\\n```\n```\\nFor example let\\'s the example from description of the question:-\\nInput: num = 5(101) ,\\nThus the smallest power of 2 (and larger than 5) is 8 (1000)\\nThe output should be 8 - 5 - 1 = 2 (010).\\n```\n```\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        long powerof2s = 2, temp = num;\\n        \\n        while(temp>>1) {\\n            temp >>= 1;\\n            powerof2s <<= 1;\\n        }\\n        \\n        return powerof2s - num - 1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        vector<int> temp; \\n\\t\\t// convert to binary representation\\n        while( num != 0 ){\\n            temp.push_back( num % 2 );\\n            num /= 2;\\n        } \\n\\t\\t// make complement\\n        for(int i=0; i<temp.size(); i++){\\n            if( temp[i] == 1 ) temp[i] = 0;\\n            else if( temp[i] == 0 ) temp[i] = 1;\\n        } int res = 0;\\n        for(int i=temp.size()-1; i>-1; i--) res = res * 2 + temp[i];\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96026,
                "title": "python-4-ways",
                "content": "1. Flip bit by bit.\\n```\\nclass Solution(object):\\n    def findComplement(self, num):\\n        i = 1\\n        while num >= i:\\n            num ^= i\\n            i <<= 1\\n        return num\\n```\\n2. Find the bit length (say L) and flip num by **num ^ 11...1**   (L ones).\\n```\\n    def findComplement(self, num):\\n        return num ^ ((1<<num.bit_length())-1)\\n```\\n3. Again find the bit length first.\\n```\\n    def findComplement(self, num):\\n        return num ^ ((1 << len(bin(num)) - 2) - 1)\\n```\\n4.\\n```\\ndef findComplement(self, num):\\n        return num ^ ((2<<int(math.log(num, 2)))-1)\\n```\\nWe can also flip num first (including the leading zeros) using ```~num``` and then get the last L bits by ```& 11...1``` (L ones).\\n\\nFor example,\\n```\\n    def findComplement(self, num):\\n        return ~num & ((1<<num.bit_length())-1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findComplement(self, num):\\n        i = 1\\n        while num >= i:\\n            num ^= i\\n            i <<= 1\\n        return num\\n```\n```\\n    def findComplement(self, num):\\n        return num ^ ((1<<num.bit_length())-1)\\n```\n```\\n    def findComplement(self, num):\\n        return num ^ ((1 << len(bin(num)) - 2) - 1)\\n```\n```\\ndef findComplement(self, num):\\n        return num ^ ((2<<int(math.log(num, 2)))-1)\\n```\n```~num```\n```& 11...1```\n```\\n    def findComplement(self, num):\\n        return ~num & ((1<<num.bit_length())-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1650035,
                "title": "c-python-simple-solutions-w-explanation-brute-force-bit-manipulation-tricks-in-built",
                "content": "We are given an integer `num` and we need to return its complement\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - I (Brute-Force)***\\n\\nWe can simply iterate and find the leftmost bit (MSB) that is set. From that point onwards, we flip every bit till we reach the rightmost bit (LSB). To flip a bit, we can use `^ 1` (XOR 1) operation. This will flip a bit to 0 if it is set and flip to 1 if it is unset.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        int i = 31;\\n        while((num & 1 << i) == 0) i--;   // skip the left 0 bits till we reach the 1st set bit from left\\n        while(i >= 0)\\n            num ^= 1 << i--;              // flip all bits by XORing with 1\\n        return num;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def findComplement(self, num):\\n        i = 31\\n        while (num & 1 << i) == 0: \\n            i -= 1\\n        while i >= 0:\\n            num ^= 1 << i\\n            i -= 1\\n        return num\\n```\\n\\n***Time Complexity :*** <code>O(N)</code>, where `N` is the number of bits. In this case, since we are starting from `i=31`, it should be constant but I am denoting time complexity of this approach as generalized `O(N)`\\n***Space Complexity :*** `O(1)`\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Bit-Manipulation Tricks)***\\n\\nThe above method basically finds the leftmost set bit and XORs the remaining bits with 1. A more efficient way to do the same would be to simply XOR `num` with another number having all bits to the right of nums\\'s 1st set bit as 1 and rest bit to left as 0. This would achieve the same thing as above.\\n\\n```py\\nFor eg. num = 13\\n=>  num  = 13  (1101)\\n=>  mask = 15  (1111)\\n--------------------\\n   ^       2   (0010)    We got all the bits flipped\\n```\\n\\n* **But how to get `mask`?** \\n\\t* A simple way would be  to initialize `mask = 0` and keep flipping bits of it to 1 starting from the rightmost bit (LSB) till we reach the leftmost set bit of `num`. \\n\\n* **Now, how do we know that we reached the leftmost set bit in `num`?**\\n\\t* We use another variable `tmp = num`. Each time, we will rightshift tmp essentially removing the rightmost bit. When we remove the leftmost set bit from it, it will become 0. Thus, we loop till `tmp` is not 0.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        int mask = 0;                                 // all bits in mask are initially 0\\n        for(int tmp = num; tmp; tmp >>= 1)            // set bits in mask to 1 till we reach leftmost set bit in num\\n            mask = (mask << 1) | 1;                   // leftshifts and sets the rightmost bit to 1\\n\\t\\t\\t\\n        return mask ^ num;                            // finally XORing with mask will flip all bits in num\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def findComplement(self, num):\\n        mask, tmp = 0, num\\n        while tmp:\\n            mask = (mask << 1) | 1\\n            tmp >>= 1\\n        return mask ^ num\\n```\\n\\t\\nAnother way to do the same would be to the other way around and start with mask with all bits as 1. Then we keep setting rightmost bits in `mask` to 0 one by one till there are no common set bits left in `num` and `mask` (`num & mask == 0` when no common set bits are present).\\n\\n```py\\nFor eg. num = 13 (1101)  and  mask = -1 (111...1111)  [all 32 set bits are set in -1 binary representation]\\n \\n1. num =  000...1101 \\n   mask = 111...1110   => we still have common set bits\\n   \\n2. num =  000...1101 \\n   mask = 111...1100   => we still have common set bits   \\n  \\n3. num =  000...1101\\n   mask = 111...1000   => we still have common set bits  \\n   \\n4. num =  000...1101 \\n   mask = 111...0000   => no more common bits left\\n```\\n\\n* **Now what?**\\n\\n\\t* Now we can simply flip all bits in `mask` (using `~` operator). It will now have all rightmost bits set to one starting from leftmost set bit in `num`, i.e, we now have the same `mask` that we had in previous approach.\\n\\t* Now, we can XOR it with `num` and we get the flipped result\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        uint mask = -1;                             // -1 is represented in binary as all bits set to 1\\n        while(mask & num) mask <<= 1;               // remove rightmost bits 1 by 1 till no common bits are left\\n        return ~mask ^ num;                         // XORs with 1 & flips all bits in num starting from the leftmost set bit \\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def findComplement(self, num):\\n        mask = -1\\n        while mask & num: mask <<= 1\\n        return ~mask ^ num\\n```\\n\\nThis approach used 1 less operation inside loop (1st approach used 3 operations: right-shift `>>` on tmp, left-shift `<<` on mask and `|` with 1 to set rightmost bit. This one uses 2: `&` to check if there are common bits in `mask` and `num` and left-shift `<<` to remove the right set bits one by one)\\n\\n***Time Complexity :*** <code>O(P) / O(log num)</code>, where `P` is the position of leftmost set bit in `num`. <code>O(P) ~ O(log<sub>2</sub>(num))</code>\\n***Space Complexity :*** `O(1)`\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Flip Bits from Right to Left)***\\n\\nWe can start from the right-end and flip bits one by one. This is somewhat similar to 1st solution in above appraoch. But here we will not use mask but rather a bit starting with `i=1` and just directly XOR it with `num`, then left-shift it & repeat thus flipping the bits in `num` one by one. \\n\\nSo, how do we know when to stop? We stop as soon `i > num`. This denotes that we have passed the leftmost set bit in `num` and thus we have flipped all the bits that needed to be flipped.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        int i = 1;\\n        while(i <= num)\\n            num ^= i,\\n            i <<= 1;\\n        return num;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution():\\n    def findComplement(self, num):\\n        i = 1\\n        while i <= num:\\n            num ^= i\\n            i <<= 1\\n        return num    \\n```\\n\\n***Time Complexity :*** <code>O(P) / O(log num)</code>\\n***Space Complexity :*** `O(1)`\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - IV (Built-in Methods)***\\n\\nThere are built-in methods provided by languages such as `__builtin_clz` in C++ which counts leading zeros, `highestOneBit` in Java which returns the number with only its leftmost bit set and so on... These methods can be used to solve this problem as well using the same logic as above.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        return ~(-1u << (32 - __builtin_clz(num))) ^ num;\\n// or:  return ~(-1u << int(log2(num))+1) ^ num; \\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution():\\n    def findComplement(self, num):\\n        return ~(-1 << int(log2(num))+1) ^ num\\n```\\n\\n\\n***Time Complexity :*** <code>O(1)</code>, `__builtin_clz` usually translates to single machine instruction and should be considered constant. The `log` complexity might be implementation dependent but should atleast be costlier by some factor than `__builtin_clz`\\n***Space Complexity :*** `O(1)`\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        int i = 31;\\n        while((num & 1 << i) == 0) i--;   // skip the left 0 bits till we reach the 1st set bit from left\\n        while(i >= 0)\\n            num ^= 1 << i--;              // flip all bits by XORing with 1\\n        return num;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def findComplement(self, num):\\n        i = 31\\n        while (num & 1 << i) == 0: \\n            i -= 1\\n        while i >= 0:\\n            num ^= 1 << i\\n            i -= 1\\n        return num\\n```\n```py\\nFor eg. num = 13\\n=>  num  = 13  (1101)\\n=>  mask = 15  (1111)\\n--------------------\\n   ^       2   (0010)    We got all the bits flipped\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        int mask = 0;                                 // all bits in mask are initially 0\\n        for(int tmp = num; tmp; tmp >>= 1)            // set bits in mask to 1 till we reach leftmost set bit in num\\n            mask = (mask << 1) | 1;                   // leftshifts and sets the rightmost bit to 1\\n\\t\\t\\t\\n        return mask ^ num;                            // finally XORing with mask will flip all bits in num\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def findComplement(self, num):\\n        mask, tmp = 0, num\\n        while tmp:\\n            mask = (mask << 1) | 1\\n            tmp >>= 1\\n        return mask ^ num\\n```\n```py\\nFor eg. num = 13 (1101)  and  mask = -1 (111...1111)  [all 32 set bits are set in -1 binary representation]\\n \\n1. num =  000...1101 \\n   mask = 111...1110   => we still have common set bits\\n   \\n2. num =  000...1101 \\n   mask = 111...1100   => we still have common set bits   \\n  \\n3. num =  000...1101\\n   mask = 111...1000   => we still have common set bits  \\n   \\n4. num =  000...1101 \\n   mask = 111...0000   => no more common bits left\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        uint mask = -1;                             // -1 is represented in binary as all bits set to 1\\n        while(mask & num) mask <<= 1;               // remove rightmost bits 1 by 1 till no common bits are left\\n        return ~mask ^ num;                         // XORs with 1 & flips all bits in num starting from the leftmost set bit \\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def findComplement(self, num):\\n        mask = -1\\n        while mask & num: mask <<= 1\\n        return ~mask ^ num\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        int i = 1;\\n        while(i <= num)\\n            num ^= i,\\n            i <<= 1;\\n        return num;\\n    }\\n};\\n```\n```python\\nclass Solution():\\n    def findComplement(self, num):\\n        i = 1\\n        while i <= num:\\n            num ^= i\\n            i <<= 1\\n        return num    \\n```\n```cpp\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        return ~(-1u << (32 - __builtin_clz(num))) ^ num;\\n// or:  return ~(-1u << int(log2(num))+1) ^ num; \\n    }\\n};\\n```\n```python\\nclass Solution():\\n    def findComplement(self, num):\\n        return ~(-1 << int(log2(num))+1) ^ num\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96022,
                "title": "3-line-pure-c",
                "content": "```\\nint findComplement(long num) {\\n    long i;\\n    for(i=1;i<=num;i*=2) num^=i; \\n    return num;\\n}\\n```\\nI basically check every bit of number by XOR'ing it with appropriate power of 2 which leads to its invertion.\\nFor example:\\n```\\nEntered: 4=>100;\\n100 ^ 001 = 101;\\n101 ^ 010 = 111;\\n111 ^ 100 = 011;\\nOut:     011=>3;\\n```",
                "solutionTags": [],
                "code": "```\\nint findComplement(long num) {\\n    long i;\\n    for(i=1;i<=num;i*=2) num^=i; \\n    return num;\\n}\\n```\n```\\nEntered: 4=>100;\\n100 ^ 001 = 101;\\n101 ^ 010 = 111;\\n111 ^ 100 = 011;\\nOut:     011=>3;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1649516,
                "title": "java-0-ms-1-liner-explained",
                "content": "**Idea:**\\n* Flip all bits using negation operator (~) [[read more here](https://www.ibm.com/docs/en/i/7.1?topic=expressions-bitwise-negation-operator)]\\n* Bitwise AND (&) with a bit mask of size n whose all bits are set, where n = number of bits in `num`\\n**Example:**\\n```\\nnum = 5\\n  num binary = 0...0101\\n ~num binary = 1...1010\\n\\n* Now we\\'ve flipped all the bits but it also flipped previously insignificant bits (0s), \\nso to revert them back to 0s, we need to only keep the significant bits and turn off the insignificant bits\\n* This can be done by using mask of 1s having size equal to number of bits in num. This mask is (1 << nBits) - 1\\n* This is a standard mask in bit manipulation problems\\n\\n~num binary & mask = (1...1010) & (0...0111) = 0...0010 [Ans]\\n```\\n>**T/S:** O(1)/O(1)\\n```\\npublic int findComplement(int num) {\\n\\tvar nBits = (int) Math.floor((Math.log(num) / Math.log(2)) + 1);\\n\\tvar mask = (1 << nBits) - 1;\\n\\treturn ~num & mask;\\n}\\n```\\n**Variation 2:** 1 liner variation of above method\\n```\\npublic int findComplement(int num) {\\n\\treturn ~num & (Integer.highestOneBit(num) - 1);\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nnum = 5\\n  num binary = 0...0101\\n ~num binary = 1...1010\\n\\n* Now we\\'ve flipped all the bits but it also flipped previously insignificant bits (0s), \\nso to revert them back to 0s, we need to only keep the significant bits and turn off the insignificant bits\\n* This can be done by using mask of 1s having size equal to number of bits in num. This mask is (1 << nBits) - 1\\n* This is a standard mask in bit manipulation problems\\n\\n~num binary & mask = (1...1010) & (0...0111) = 0...0010 [Ans]\\n```\n```\\npublic int findComplement(int num) {\\n\\tvar nBits = (int) Math.floor((Math.log(num) / Math.log(2)) + 1);\\n\\tvar mask = (1 << nBits) - 1;\\n\\treturn ~num & mask;\\n}\\n```\n```\\npublic int findComplement(int num) {\\n\\treturn ~num & (Integer.highestOneBit(num) - 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 612511,
                "title": "python3-easy-one-line-code-with-explanation",
                "content": "Here\\'s the code:\\n```python\\nclass Solution:\\n    def findComplement(self, num: int) -> int:\\n        return num^(2**(len(bin(num)[2:]))-1)\\n```\\nWhat does it mean?\\nThe complement of a number is computable by \"flipping\" all the bits in his binary form.\\nIn other words, that\\'s nothing more than a **bitwise XOR with all 1**.\\n\\nFollowing the truth table:\\n\\n![image](https://assets.leetcode.com/users/xhon9/image_1588579305.png)\\n\\nWe can easily notice what I said before.\\n\\nSo, now?\\nNow the idea is to **transform in binary** form the input number, taking the number of bit necessary for his representation. That\\'s done with `len(bin(num)[2:])`, [2:] cause the bin() function in Python3 add also an initial \\'0b\\' (ex: `bin(5) = \\'0b101\\'`, but `bin(5)[2:] = \\'101\\'`).\\n\\nAfter taking the len, **compute** `2**len` taking the first pow of 2 that is >= our number, and finally compute the `-1`.\\nReasoning: doing `2**len` we get a number with leading 1 and all zeros, subtracting 1 we finally get the number with the same len of our input, formed by all 1.\\n\\nReturn the XOR of input and this number, and **win**!\\n\\n-That\\'s my first post, feel free to ask and upvote :D",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def findComplement(self, num: int) -> int:\\n        return num^(2**(len(bin(num)[2:]))-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 158120,
                "title": "detailed-explanation-java-xor-method-easy-to-understand",
                "content": "Let\\'s say the input is num = 5 = 101 in binary\\nOur mask needs to be 111 and then we will perform a XOR operation. The XOR operation says return TRUE (1) only if one of the bits is true, else return FALSE (0). This means that when we XOR a 1 and a 1 bit, we will get 0. If we XOR a 1 and 0 bit, we will get 1. Thus effectively flipping the bits.\\n\\nThe way we get the mask to be 111 is to first get the DECIMAL VALUE OF THE FURTHER LEFT BIT of num, so in this case the furthest left bit of num represents 4. In binary this is 100. We do a single left shift, thus we get 1000 which is 8 in decimal. Then we subtract 1 to get 7 in decimal, or 111. This is the mask value we need to XOR to our original input num.\\n\\n```\\npublic class Solution {\\n    public int findComplement(int num) {\\n        int mask = (Integer.highestOneBit(num) << 1) - 1;\\n        return num ^ mask;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int findComplement(int num) {\\n        int mask = (Integer.highestOneBit(num) << 1) - 1;\\n        return num ^ mask;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1650071,
                "title": "one-line-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        return (pow(2,floor(log2(num))+1)-1)-num;\\n    }\\n};\\n```\\n\\nHere, **floor(log2(num))+1** gives us the number of bits in integer **num**.\\nThe maximum value obtained with this number of bits is **pow(2,no of bits)-1**.\\nWhen we **subtract from maximum value to the given input** will gives the complement of the given input.\\n\\nHope it helps:) \\nHappy coding.",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        return (pow(2,floor(log2(num))+1)-1)-num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 920813,
                "title": "java-bit-masking-100-faster",
                "content": "```\\nclass Solution {\\n    public int findComplement(int num) {\\n        int c = 0, t = num;\\n\\t\\t//First, you need to find how many bits are present in the given number.\\n        while(t>0) {\\n            t = t>>1;\\n            c++;\\n        }\\n\\t\\t//Now after that, create a mask of 1\\'s about the size of num.\\n\\t\\t//eg: if num = 5(101) then mask = 7(111) \\n        int mask = (1<<(c))-1;\\n\\t\\t//now this mask can be used to flip all the bits in num using XOR.\\n        return num^mask;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findComplement(int num) {\\n        int c = 0, t = num;\\n\\t\\t//First, you need to find how many bits are present in the given number.\\n        while(t>0) {\\n            t = t>>1;\\n            c++;\\n        }\\n\\t\\t//Now after that, create a mask of 1\\'s about the size of num.\\n\\t\\t//eg: if num = 5(101) then mask = 7(111) \\n        int mask = (1<<(c))-1;\\n\\t\\t//now this mask can be used to flip all the bits in num using XOR.\\n        return num^mask;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 613363,
                "title": "javascript-solution-without-converting-to-binary",
                "content": "Let\\'s look to rundom binary number, for example: `10011`.\\nReverse of this number = `01100`.\\nLook, it\\'s equal: `100000 - 10011 - 1`.\\n\\n**Idea:** find the minimum nearest number greater than `num` (power of 2)\\n\\n```\\n/**\\n * @param {number} num\\n * @return {number}\\n */\\nvar findComplement = function(num) {    \\n    let d = 2;\\n    while (d <= num) {\\n        d *= 2;\\n    }    \\n    return d - num - 1;\\n};\\n```\\n\\nThe number of actions does not exceed 32.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} num\\n * @return {number}\\n */\\nvar findComplement = function(num) {    \\n    let d = 2;\\n    while (d <= num) {\\n        d *= 2;\\n    }    \\n    return d - num - 1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 488055,
                "title": "python-o-lg-n-sol-by-xor-masking-85-with-explanation",
                "content": "Python O( log n ) sol. based on XOR masking. \\n\\n---\\n\\nExample explanation\\n\\n---\\nExample_#1\\n\\ninput: **5**\\n\\n5 = 0b **101**\\n**bits length** of 5 = **3**\\n**masking** = **2^3 -1** = 8 - 1 = **7** = 0b **111**\\n\\n5 = 0b **101**\\n3 = 0b **111** ( **XOR** )\\n\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\n**2** = 0b **010**\\n\\noutput: **2**\\n\\n---\\nExample_#2\\n\\ninput: **9**\\n\\n9 = 0b **1001**\\n**bits length** of 2 = **4**\\n**masking** = **2^4 -1** = 16 - 1 = **15** = 0b **1111**\\n\\n09 = 0b **1001**\\n15 = 0b **1111** ( **XOR** )\\n\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\n**06** = 0b **0110**\\n\\noutput: **6**\\n\\n---\\n**Implementation** with bit length calculation:\\n```\\nfrom math import floor\\nfrom math import log\\n\\nclass Solution:\\n    def findComplement(self, num: int) -> int:\\n        \\n        bits_length = floor( log(num, 2) + 1)\\n        \\n        return num^( 2**bits_length - 1 )\\n```\\n\\n---\\n\\n**Implementation** with python built-in method, **[.bit_length()](https://docs.python.org/3/library/stdtypes.html#int.bit_length)**,of integer:\\n\\n```\\nclass Solution:\\n    def findComplement(self, num: int) -> int:\\n        \\n        bit_mask = 2**num.bit_length() -1 \\n        \\n        return ( num ^ bit_mask )\\n```\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #1009 Complement of Base 10 Integer](https://leetcode.com/problems/complement-of-base-10-integer/)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nfrom math import floor\\nfrom math import log\\n\\nclass Solution:\\n    def findComplement(self, num: int) -> int:\\n        \\n        bits_length = floor( log(num, 2) + 1)\\n        \\n        return num^( 2**bits_length - 1 )\\n```\n```\\nclass Solution:\\n    def findComplement(self, num: int) -> int:\\n        \\n        bit_mask = 2**num.bit_length() -1 \\n        \\n        return ( num ^ bit_mask )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96126,
                "title": "java-one-line-solution-without-using-and-or-xor",
                "content": "To find complement of ```num = 5``` which is ```101``` in binary.\\nFirst ```~num``` gives ```...11111010``` but we only care about the rightmost 3 bits.\\nThen to erase the ```1```s before ```010``` we can add ```1000```\\n\\n```\\n    public int findComplement(int num) {\\n        return ~num + (Integer.highestOneBit(num) << 1);\\n    }\\n```",
                "solutionTags": [],
                "code": "```num = 5```\n```101```\n```~num```\n```...11111010```\n```1```\n```010```\n```1000```\n```\\n    public int findComplement(int num) {\\n        return ~num + (Integer.highestOneBit(num) << 1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 560754,
                "title": "explained-easy-to-understand-faster-than-99-58-simple-bit-manipulation-python-solution",
                "content": "##### Later I found that this solution correponds to the second approach mentioned in the solution\\n\\nHere, in this soution, we are just making another bit variable to be full of 1\\'s upto the length of bits in num and then simply returning the XOR of two\\nnum = 5 = 101\\nbit ===== 111\\nAns ==== 010 = 2\\n\\n```\\ndef findComplement(self, num: int) -> int:\\n        bit = 0\\n        todo = num\\n        while todo:\\n            bit = bit << 1\\n            bit = bit ^ 1\\n            todo = todo >> 1\\n        return bit ^ num\\n```\\n\\n**I hope that you\\'ve found the solution useful.**\\n*In that case, please do upvote and encourage me to on my quest to document all leetcode problems\\uD83D\\uDE03*\\nPS: Search for **mrmagician** tag in the discussion, if I have solved it, You will find it there\\uD83D\\uDE38",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\ndef findComplement(self, num: int) -> int:\\n        bit = 0\\n        todo = num\\n        while todo:\\n            bit = bit << 1\\n            bit = bit ^ 1\\n            todo = todo >> 1\\n        return bit ^ num\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 96143,
                "title": "easy-c",
                "content": "Thought process is that you have to keep one number shift to left until it can no longer be shifted. At the same time, you can right shift by 1 for a number i and take the XOR, which leads to the opposite complement.\\n\\n```\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        int copy = num;\\n        int i = 0;\\n\\n        while(copy != 0) {\\n            copy >>= 1;\\n            num ^= (1<<i);\\n            i += 1;\\n        }\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        int copy = num;\\n        int i = 0;\\n\\n        while(copy != 0) {\\n            copy >>= 1;\\n            num ^= (1<<i);\\n            i += 1;\\n        }\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96130,
                "title": "oneline-c-solution",
                "content": "~~For some strange reason when I submit it fails the last test case,but if you run that test on its own in the custom testcase it passes. So I think something is wrong with the testing.~~\\n\\n```class Solution {\\npublic:\\n    int findComplement(int num) {\\n        return ~num & ((1 <<(int)log2(num))-1);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findComplement(int num) {\\n        return ~num & ((1 <<(int)log2(num))-1);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 612411,
                "title": "c-o-1-using-bitwise-operator-with-explanation",
                "content": "```\\n/*\\nnum          = 00000110\\nmask         = 00000111\\n~num         = 11111001\\nmask & ~num  = 00000001\\n*/\\nint findComplement( int num ) {\\n\\tint mask = 0, tmp=num;\\n\\twhile( tmp ) {\\n\\t\\ttmp = tmp >> 1;\\n\\t\\tmask = mask << 1;\\n\\t\\tmask = mask | 1;\\n\\t}\\n\\treturn ~num & mask;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nnum          = 00000110\\nmask         = 00000111\\n~num         = 11111001\\nmask & ~num  = 00000001\\n*/\\nint findComplement( int num ) {\\n\\tint mask = 0, tmp=num;\\n\\twhile( tmp ) {\\n\\t\\ttmp = tmp >> 1;\\n\\t\\tmask = mask << 1;\\n\\t\\tmask = mask | 1;\\n\\t}\\n\\treturn ~num & mask;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 324332,
                "title": "python-xor-one-line-no-loops",
                "content": "```\\nreturn num ^ (2**num.bit_length() - 1)\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nreturn num ^ (2**num.bit_length() - 1)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 612357,
                "title": "c-solution-using-xor",
                "content": "```\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        int count=0;\\n        int j=num;\\n        while(j!=0){\\n            j=j/2;\\n            count++;\\n        }\\n        int ans = pow(2,count) - 1;\\n        return num ^ ans;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findComplement(int num) {\\n        int count=0;\\n        int j=num;\\n        while(j!=0){\\n            j=j/2;\\n            count++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1650084,
                "title": "python-o-1-solution-explained",
                "content": "There is very smart solution, where we spread the highest 1-bit onto all the lower bits. Try to do the following operations, see https://leetcode.com/problems/number-of-1-bits/discuss/1044775/python-n-and-(n-1)-trick-explained for more details, idea is similar.\\n\\n#### Complexity\\nIt is just `5` operations we need to do here.\\n\\n#### Code\\n```python\\nclass Solution(object):\\n    def findComplement(self, num):\\n        mask = num\\n        mask |= mask >> 1\\n        mask |= mask >> 2\\n        mask |= mask >> 4\\n        mask |= mask >> 8\\n        mask |= mask >> 16\\n        return num ^ mask\\n```\\n\\n#### Remark\\nAnother solutions:\\n\\nWe can just find length of number `k` and subtract number from `2^k-1`.\\n\\nWe can also use `x & (x-1)` trick, and delete ones from the end one by one until we reach power of two (we need to make step if `x & (x-1)` is not equal to zero). When we reached power of two `s`, we evaluate \\n`(2s+1) ^ num`. Complexity is `O(q)`, where `q` is number of non-zero bits.\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```python\\nclass Solution(object):\\n    def findComplement(self, num):\\n        mask = num\\n        mask |= mask >> 1\\n        mask |= mask >> 2\\n        mask |= mask >> 4\\n        mask |= mask >> 8\\n        mask |= mask >> 16\\n        return num ^ mask\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1649436,
                "title": "python3-bitwise-operators-explained",
                "content": "The idea is to shift all bits of the given integer to the right in the loop until it turns into `0`. Every time we do a shift we use a mask to check what is in the right-most bit of the number. If bit is `0` we add `2**n` to the result where `n` is the current number of shifts. Example:\\n```\\nn=0, num=1010, bit=0 => res += 2**0\\nn=1, num=0101, bit=1 => res += 0\\nn=2, num=0010, bit=0 => res += 2**2\\nn=3, num=0001, bit=1 => res += 0\\n     num=0000 => break the loop\\n```\\n\\nRuntime: 24 ms, faster than **94.85%** of Python3 online submissions for Number Complement.\\nMemory Usage: 14.2 MB, less than **68.47%** of Python3 online submissions for Number Complement.\\n\\n```\\nclass Solution:\\n    def findComplement(self, num: int) -> int:\\n        res, n = 0, 0\\n        while num:\\n            if not num & 1:\\n                res += 2**n\\n                \\n            num >>= 1\\n            n += 1\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nn=0, num=1010, bit=0 => res += 2**0\\nn=1, num=0101, bit=1 => res += 0\\nn=2, num=0010, bit=0 => res += 2**2\\nn=3, num=0001, bit=1 => res += 0\\n     num=0000 => break the loop\\n```\n```\\nclass Solution:\\n    def findComplement(self, num: int) -> int:\\n        res, n = 0, 0\\n        while num:\\n            if not num & 1:\\n                res += 2**n\\n                \\n            num >>= 1\\n            n += 1\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1481678,
                "title": "short-fast-java-solution-w-explanation",
                "content": "**Algorithm:**\\n```\\npublic int findComplement(int num) {\\n\\tint mask = -1;\\n\\twhile ((num & mask) != 0) {\\n\\t\\tmask <<= 1;\\n\\t}\\n\\treturn ~num & ~mask; // Also equal to ~(num ^ mask)\\n}\\n```\\n**Explanation:**\\nLets take this step by step. For the sake of my sanity, lets assume that  integers are only 8-bits long. In our example, we will say that the bit representation of num is `00001101`.\\n1. This sets mask to be an integer with ALL of its bits set to 1.\\n\\n\\t```\\n\\tint mask = -1;\\n\\t```\\n\\tNote the current state of the variables:\\n\\t```\\n\\tnum:         00001101\\n\\tmask:        11111111\\n\\t```\\n2. This while condition shifts the mask until it lines up with the leading zeroes in num. \\n\\t```\\n\\twhile ((num & mask) != 0) {\\n\\t\\tmask <<= 1;\\n\\t}\\n\\t```\\n\\tNote that shifting the mask left will drop the first bit, and append a 0 to the end. (`11111111` shifted  once would be `11111110`). Also, it is only once there are no more 1s in num that their bitwise-and would equal 0. Here is the state after this code is run:\\n\\t```\\n\\tnum:         00001101\\n\\tmask:        11110000\\n\\tnum & mask:  00000000\\n\\t```\\n3. Finally, we need to invert the bits of num and only return the bits that were not part of the leading zeroes.\\n\\t```\\n\\treturn ~num & ~mask;\\n\\t```\\n\\tWe invert (flip 1s to 0s and vice versa) num because that is the thing we want to return. However, the leading zeroes need to be factored out, so we invert the mask and \"cancel\" out the leading zeroes. Note the following:\\n\\t```\\n\\t~num:         11110010\\n\\t~mask:        00001111\\n\\t~num & ~mask: 00000010\\n\\t```\\nSo, we end up returning the correct value of `00000010`.\\n\\nLet me know if anything does not make sense!",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic int findComplement(int num) {\\n\\tint mask = -1;\\n\\twhile ((num & mask) != 0) {\\n\\t\\tmask <<= 1;\\n\\t}\\n\\treturn ~num & ~mask; // Also equal to ~(num ^ mask)\\n}\\n```\n```\\n\\tint mask = -1;\\n\\t```\n```\\n\\tnum:         00001101\\n\\tmask:        11111111\\n\\t```\n```\\n\\twhile ((num & mask) != 0) {\\n\\t\\tmask <<= 1;\\n\\t}\\n\\t```\n```\\n\\tnum:         00001101\\n\\tmask:        11110000\\n\\tnum & mask:  00000000\\n\\t```\n```\\n\\treturn ~num & ~mask;\\n\\t```\n```\\n\\t~num:         11110010\\n\\t~mask:        00001111\\n\\t~num & ~mask: 00000010\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 160210,
                "title": "easy-solution-in-java",
                "content": "    public int findComplement(int num) {\\n       int x=1,i=1;\\n        while(x<=num && i<32)\\n        {\\n            num=num^x;\\n            x=x<<1;\\n            i++;\\n        }\\n    \\n        return num;\\n    }",
                "solutionTags": [],
                "code": "    public int findComplement(int num) {\\n       int x=1,i=1;\\n        while(x<=num && i<32)\\n        {\\n            num=num^x;\\n            x=x<<1;\\n            i++;\\n        }\\n    \\n        return num;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3993385,
                "title": "easy-solution-with-explanation-2-approaches-without-bit-manipulation-beats-100",
                "content": "See the pattern?\\n\\n```\\nNumber   Binary     Complement  Complement Value\\n1       =  1      ->    0     =     0\\n\\n2       =  10     ->    01    =     1\\n3       =  11     ->    00    =     0\\n\\n4       =  100    ->    011   =     3\\n5       =  101    ->    010   =     2\\n6       =  110    ->    001   =     1\\n7       =  111    ->    000   =     0\\n\\n8       =  1000   ->    0111  =     7\\n9       =  1001   ->    0110  =     6\\n10      =  1010   ->    0101  =     5\\n11      =  1011   ->    0100  =     4\\n12      =  1100   ->    0011  =     3\\n13      =  1101   ->    0010  =     2\\n14      =  1110   ->    0001  =     1\\n15      =  1111   ->    0000  =     0\\n.\\n.\\n.\\n```\\nThe range of binary numbers for n bits is from 0 to ($$2^n - 1$$). For example, with 1 bit we can represent 1, with 2 bits we can represent 2 (10) and 3 (11), with 3 bits we can represent 4 (100), 5 (101), 6 (110), 7 (111), and so on. The complement of a binary number can be found by subtracting the number itself from the maximum value in its binary representation, which is ($$2^n - 1$$).\\n\\nTo represent 1 we need at least 1 bit so, n  = 1\\n1 = ($$2^n -1$$) - number itself => 1 - 1 = 0 (Complement value)\\n\\nTo represent 2 and 3 we need at least 2 bits so, n  = 2\\n2 = ($$2^n -1$$) - number itself => 3 - 2 = 1 (Complement value)\\n3 = ($$2^n -1$$) - number itself => 3 - 3 = 0 (Complement value)\\n.\\n.\\n.\\nsimilarly, To represent 15 we need at least 4 bits so, n  = 4\\n15 = ($$2^n -1$$) - number itself => 15 - 15 = 0 (Complement value)\\n.\\n.\\n.\\nand so on.\\n\\n\\nThe max range value can be calculated with this `int tmp = (int) (Math.pow(2,digits(num))-1);`\\n\\nNow subtract the number from which we need to find the complement. `int res = tmp - num;` This will give us the complement of the number.\\n\\n\\n# Approach 1: Using Binary Number Range, Without Bit Manipulation \\n\\n- Time complexity: O(log n)\\n- Space complexity: O(1)\\n\\n```\\nclass Solution {\\n    public int findComplement(int num) {\\n        int tmp = (int) (Math.pow(2,digits(num))-1);\\n        return tmp - num;\\n    }\\n\\n    static int digits(int n){\\n        int count = 0;\\n        while(n > 0){\\n            n = n/2;\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n\\n# Approach 2: Bit Manipulation\\n\\n- Time complexity: O(1)\\n- Space complexity: O(1)\\n\\n```\\nclass Solution {\\n    public int findComplement(int num) {\\n\\t    return ~num & (Integer.highestOneBit(num) - 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nNumber   Binary     Complement  Complement Value\\n1       =  1      ->    0     =     0\\n\\n2       =  10     ->    01    =     1\\n3       =  11     ->    00    =     0\\n\\n4       =  100    ->    011   =     3\\n5       =  101    ->    010   =     2\\n6       =  110    ->    001   =     1\\n7       =  111    ->    000   =     0\\n\\n8       =  1000   ->    0111  =     7\\n9       =  1001   ->    0110  =     6\\n10      =  1010   ->    0101  =     5\\n11      =  1011   ->    0100  =     4\\n12      =  1100   ->    0011  =     3\\n13      =  1101   ->    0010  =     2\\n14      =  1110   ->    0001  =     1\\n15      =  1111   ->    0000  =     0\\n.\\n.\\n.\\n```\n```\\nclass Solution {\\n    public int findComplement(int num) {\\n        int tmp = (int) (Math.pow(2,digits(num))-1);\\n        return tmp - num;\\n    }\\n\\n    static int digits(int n){\\n        int count = 0;\\n        while(n > 0){\\n            n = n/2;\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findComplement(int num) {\\n\\t    return ~num & (Integer.highestOneBit(num) - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1650442,
                "title": "c-brute-force-0ms-worst-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n       vector<int> val;\\n        while(num > 0){\\n            val.push_back(num % 2);\\n            num /= 2;\\n        }\\n        reverse(val.begin(), val.end());\\n        for(int i = 0; i < val.size(); i++)\\n            if(val[i] == 0) val[i] = 1;\\n            else val[i] = 0;\\n        \\n        int ans = 0;\\n        long int base = 1;\\n        for(int i = val.size()-1; i >= 0; i--){\\n            if(val[i] == 1) ans += val[i]*base;\\n            base *= 2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n       vector<int> val;\\n        while(num > 0){\\n            val.push_back(num % 2);\\n            num /= 2;\\n        }\\n        reverse(val.begin(), val.end());\\n        for(int i = 0; i < val.size(); i++)\\n            if(val[i] == 0) val[i] = 1;\\n            else val[i] = 0;\\n        \\n        int ans = 0;\\n        long int base = 1;\\n        for(int i = val.size()-1; i >= 0; i--){\\n            if(val[i] == 1) ans += val[i]*base;\\n            base *= 2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1203432,
                "title": "99-20-faster-python-much-easy-solution",
                "content": "```\\nclass Solution:\\n    def findComplement(self, num: int) -> int:\\n        complement=\"\"\\n        for i in bin(num)[2:]:\\n            if i is \"0\":\\n                complement+=\"1\"\\n            else:\\n                complement+=\"0\"\\n                \\n        return int(complement,2)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findComplement(self, num: int) -> int:\\n        complement=\"\"\\n        for i in bin(num)[2:]:\\n            if i is \"0\":\\n                complement+=\"1\"\\n            else:\\n                complement+=\"0\"\\n                \\n        return int(complement,2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1019691,
                "title": "c-python-3-line-with-explanation-faster-than-100",
                "content": "#### C++\\n```\\nint findComplement(int num) {\\n\\tint k = int(log2(num));\\n\\tint mask = pow(2,k+1) - 1;\\n\\treturn num^mask;\\n}\\n```\\n#### Python3\\n```\\ndef findComplement(self, num: int) -> int:\\n\\tk = int(log2(num))\\n\\tmask = int(2**(k+1) - 1)\\n\\treturn num^mask;\\n```\\n#### Explanation\\nWe want to flip every bit. One way to flip a bit is by taking its xor with 1. Because\\n```\\n0 xor 1 = 1\\n1 xor 1 = 0\\n```\\n\\n\\nWith this in mind, all we have to do is take the XOR of all bits with 1.\\nLet\\'s say our number is 5 ,ie, 101\\nso we need to take the xor with 111\\nSince\\n```\\n1   0   1  xor\\n1   1   1\\n_________\\n0   1   0     \\n```\\n\\nHow to generate 111 ?\\nAs you can observe, 111 is the number 7, which is 8 - 1, or 2^3 - 1.\\nTo get the desired number with all bits as 1,\\n\\n1) Take the log of that number, say k (Eg: (```log2(5)  = 2```))\\n2) Take Power of ```2``` raised to ```k+1``` (2^3=8 or ```1000```) and subtract 1 (7 or ```111```)\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nint findComplement(int num) {\\n\\tint k = int(log2(num));\\n\\tint mask = pow(2,k+1) - 1;\\n\\treturn num^mask;\\n}\\n```\n```\\ndef findComplement(self, num: int) -> int:\\n\\tk = int(log2(num))\\n\\tmask = int(2**(k+1) - 1)\\n\\treturn num^mask;\\n```\n```\\n0 xor 1 = 1\\n1 xor 1 = 0\\n```\n```\\n1   0   1  xor\\n1   1   1\\n_________\\n0   1   0     \\n```\n```log2(5)  = 2```\n```2```\n```k+1```\n```1000```\n```111```",
                "codeTag": "Python3"
            },
            {
                "id": 616420,
                "title": "possibly-the-easiest-way-java",
                "content": "Just replace and that\\'s it\\n```\\nclass Solution {\\n    public int findComplement(int num) {\\n        String binary = Integer.toBinaryString(num);\\n        binary = binary\\n                .replace(\"0\", \"2\")\\n                .replace(\"1\", \"0\")\\n                .replace(\"2\", \"1\");\\n        return Integer.parseInt(binary, 2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findComplement(int num) {\\n        String binary = Integer.toBinaryString(num);\\n        binary = binary\\n                .replace(\"0\", \"2\")\\n                .replace(\"1\", \"0\")\\n                .replace(\"2\", \"1\");\\n        return Integer.parseInt(binary, 2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96070,
                "title": "javascript-solutions-bits-and-strings",
                "content": "The bit version:\\n```\\nvar findComplement = function(num) {\\n    let mask = 1;\\n    while (mask < num) mask = (mask << 1) | 1;\\n    return num ^ mask;\\n};\\n```\\nThe string version:\\n```\\nvar findComplement = function(num) {\\n    return parseInt(num.toString(2).split('').map(d => +!+d).join(''), 2);\\n};\\n```\\nA combination of bits and strings that is fast:\\n```\\nvar findComplement = function(num) {\\n    return parseInt((~num ^ 1 << 31).toString(2).substr(-num.toString(2).length), 2);\\n};\\n```\\nIn the last solution we negate the bits, including leading zeros, and get rid of the sign bit. Then we take the right side that we need which has the same number of digits as `num`.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findComplement = function(num) {\\n    let mask = 1;\\n    while (mask < num) mask = (mask << 1) | 1;\\n    return num ^ mask;\\n};\\n```\n```\\nvar findComplement = function(num) {\\n    return parseInt(num.toString(2).split('').map(d => +!+d).join(''), 2);\\n};\\n```\n```\\nvar findComplement = function(num) {\\n    return parseInt((~num ^ 1 << 31).toString(2).substr(-num.toString(2).length), 2);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 612327,
                "title": "c-solution-explained-fully",
                "content": "Approach  : \\n1. First we will find the number of bits in the given integer \\n2. Then we will find the maximum number having same number of bits.(call it x )\\n3. Then we will XOR the given integer with x\\n\\nFor example : If input is 5 ,Binary Rep = 101 the number of bits = 3\\n\\t\\t\\t\\t\\tMax number , x = pow(2,number of bits) - 1 = pow(2,3) - 1  = 7\\n\\t\\t\\t\\t\\tBinary Rep of x = 111\\n\\t\\t\\t\\t\\tOur ans = XOR of ( given num and x ) = 101 XOR 111 = 010 = 2 (in decimal )\\n\\n\\n\\n\\n```\\n\\n```public:\\n    int findComplement(int num) {\\n        if(num == 0)\\n            return 1 ;\\n        int p = log2(num)+  1 ;\\n        int x = pow(2, p) - 1 ; \\n        return num ^ x ;\\n        }\\n};\\n```\\nNote : log2(num) returns 1 less than total number of bits , so we add 1 .\\n\\nFeel free to comment  :)",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 240760,
                "title": "layman-s-conversion-method-decimal-to-binary-complement-and-back-to-decimal",
                "content": "Long approach.\\nNot used any Math.func , XOR, Bit manipulation.\\n1.Convert Decimal to binary.\\n2.Take its compliment\\n3.Convert back to equivalent Decimal.\\n\\n```\\nclass Solution {\\n    public int findComplement(int num) {\\n        int sum=0;\\n        List<Integer> n = new ArrayList<Integer>();\\n        //Convert Decimal to Binary\\n        while(num!=0)\\n        {\\n            n.add(num%2);\\n            num = num/2;\\n            if(num==1)\\n            {\\n                n.add(num);\\n                num=0;\\n            }       \\n        }\\n        //Complement it\\n        for(int i=0;i<n.size();i++)\\n        {\\n            if(n.get(i)==1)\\n            {\\n                n.set(i,0);\\n            }else\\n            {\\n                n.set(i,1);\\n            }\\n        }\\n        //Convert back to decimal\\n        int count=1;\\n        for(int i=0;i<n.size();i++)\\n        {\\n             sum += n.get(i)*count;\\n             count *= 2;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findComplement(int num) {\\n        int sum=0;\\n        List<Integer> n = new ArrayList<Integer>();\\n        //Convert Decimal to Binary\\n        while(num!=0)\\n        {\\n            n.add(num%2);\\n            num = num/2;\\n            if(num==1)\\n            {\\n                n.add(num);\\n                num=0;\\n            }       \\n        }\\n        //Complement it\\n        for(int i=0;i<n.size();i++)\\n        {\\n            if(n.get(i)==1)\\n            {\\n                n.set(i,0);\\n            }else\\n            {\\n                n.set(i,1);\\n            }\\n        }\\n        //Convert back to decimal\\n        int count=1;\\n        for(int i=0;i<n.size();i++)\\n        {\\n             sum += n.get(i)*count;\\n             count *= 2;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96113,
                "title": "0-ms-c-code-without-xor-or-not",
                "content": "Basic idea is to find the smallest power of 2 `idx` that is larger than the input number `num`, and output the difference between `idx` and `num` . For example, input `5 (101)` , the smallest power of 2 (and larger than `5`) is `8 (1000)`, the output should be `8 - 5 - 1 = 2 (010)`. \\n\\n```\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        int idx = 2, tmp = num;\\n        \\n        while(tmp>>1) {\\n            tmp >>= 1;\\n            idx <<= 1;\\n        }\\n        \\n        return idx - num - 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        int idx = 2, tmp = num;\\n        \\n        while(tmp>>1) {\\n            tmp >>= 1;\\n            idx <<= 1;\\n        }\\n        \\n        return idx - num - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96206,
                "title": "share-my-java-solution-with-explanation",
                "content": "```\\npublic int findComplement(int num) {\\n        // find highest one bit\\n\\tint id = 31, mask = 1<<id;\\n\\twhile ((num & mask)==0) mask = 1<<--id;\\n\\t\\t\\n\\t// make mask\\n\\tmask = (mask<<1) - 1;\\n\\t\\t\\n\\treturn (~num) & mask;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int findComplement(int num) {\\n        // find highest one bit\\n\\tint id = 31, mask = 1<<id;\\n\\twhile ((num & mask)==0) mask = 1<<--id;\\n\\t\\t\\n\\t// make mask\\n\\tmask = (mask<<1) - 1;\\n\\t\\t\\n\\treturn (~num) & mask;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 96212,
                "title": "straightforward-python",
                "content": "This is not the shortest solution, but I believe straightforward solutions are more instructive.\\n\\nConsider the binary representation of the number.\\nEvery 0 at the ith position from the right. adds 2**i to the result.\\n\\n```\\ndef findComplement(self, N):\\n    binary = bin(N)[2:]\\n    ans = 0\\n    for i, u in enumerate(binary[::-1]):\\n        if u == '0':\\n            ans += 2 ** i\\n    return ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef findComplement(self, N):\\n    binary = bin(N)[2:]\\n    ans = 0\\n    for i, u in enumerate(binary[::-1]):\\n        if u == '0':\\n            ans += 2 ** i\\n    return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3565107,
                "title": "c-100-beats-full-explanation-476-number-complement",
                "content": "# :) Please Upvote If You Like the Solution :)\\n\\n# Approach\\n1. We know that we need to complement. For that we need to change `0` to `1` and `1` to `0`.\\n\\n2. We need to think, what can we use here from our bitwise operators `(i.e &, |, ^, ~)`.\\n\\n3. Suppose we have,\\n\\n```\\nEx. n = 10, binary-> 1010\\n    1 0 1 0\\n    x x x x\\n  -----------\\n    0 1 0 1\\n\\n```\\n4. Think if we `xor` the `n` with `1111 (mask)`, we will get our desired answer. Like, \\n\\n```\\n    1 0 1 0\\n    1 1 1 1   ==> mask\\n  ----------- ==> XOR\\n    0 1 0 1\\n```\\n\\n5. Now we just need to make `mask`, for that we can take `1` and do `(left shit + add one)` to make it `1111`. Like, \\n\\n```\\nmask -> 0 0 0 1 \\n        0 0 1 0 ==> left shift (mask << 1)\\n        0 0 1 1 ==> add 1 (mask + 1)\\n```\\n\\n6. we know that if we do `&` of `n` with `1111` then we will get that `n` itself.\\n\\n7. so we will do the `5th step` until `((mask & n) != n)`.\\n\\n8. At last we can able to make `1111 (mask)` and now return `(mask ^ n)`, see `4th step`. \\n\\n# Complexity\\n- Time complexity: O(ceil(log(n)))\\n- Space complexity: O(1)\\n\\n**Why Time complexity: O(ceil(log(n)))???**\\n\\n1. we are running the while loop for the number of bit of n. \\n n = 2^x ==> (x = number of bits).\\n Ex. n = 10, binary -> 1 0 1 0 (4 bits)\\n    10 = 2^x\\n    log2(10) = x\\n    ceil (log2(10)) = x, \\n\\n2. log2(10) == 3.322, but we represent 10 in 4 bits so take ceil value.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        int mask = 1;\\n        \\n        while((mask & num) != num){\\n            mask = mask << 1;\\n            mask += 1;\\n        }\\n        return mask ^ num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nEx. n = 10, binary-> 1010\\n    1 0 1 0\\n    x x x x\\n  -----------\\n    0 1 0 1\\n\\n```\n```\\n    1 0 1 0\\n    1 1 1 1   ==> mask\\n  ----------- ==> XOR\\n    0 1 0 1\\n```\n```\\nmask -> 0 0 0 1 \\n        0 0 1 0 ==> left shift (mask << 1)\\n        0 0 1 1 ==> add 1 (mask + 1)\\n```\n```\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        int mask = 1;\\n        \\n        while((mask & num) != num){\\n            mask = mask << 1;\\n            mask += 1;\\n        }\\n        return mask ^ num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1649622,
                "title": "java-beginner-friendly-runtime-1ms",
                "content": "```\\nclass Solution {\\n    public int findComplement(int num) {\\n\\t\\tString binary = Integer.toBinaryString(num);\\n\\t\\tString complement = \"\";\\n\\t\\tfor(int i = 0; i < binary.length(); i++) {\\n\\t\\t\\tif(binary.charAt(i) == \\'1\\') {\\n\\t\\t\\t\\tcomplement += \\'0\\';\\n\\t\\t\\t}\\n\\t\\t\\telse if(binary.charAt(i) == \\'0\\') {\\n\\t\\t\\t\\tcomplement += \\'1\\';\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint decimal = Integer.parseInt(complement, 2); \\n\\t\\treturn decimal;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findComplement(int num) {\\n\\t\\tString binary = Integer.toBinaryString(num);\\n\\t\\tString complement = \"\";\\n\\t\\tfor(int i = 0; i < binary.length(); i++) {\\n\\t\\t\\tif(binary.charAt(i) == \\'1\\') {\\n\\t\\t\\t\\tcomplement += \\'0\\';\\n\\t\\t\\t}\\n\\t\\t\\telse if(binary.charAt(i) == \\'0\\') {\\n\\t\\t\\t\\tcomplement += \\'1\\';\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint decimal = Integer.parseInt(complement, 2); \\n\\t\\treturn decimal;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1649513,
                "title": "java-easier-bitmask-solution",
                "content": "Upvote if you find this easier than the editorial.\\n```\\npublic int findComplement(int num) {\\n\\tint mask= 1;\\n\\twhile(num>mask) mask= (mask<<1) | 1;\\n\\treturn num^mask;\\n}",
                "solutionTags": [],
                "code": "Upvote if you find this easier than the editorial.\\n```\\npublic int findComplement(int num) {\\n\\tint mask= 1;\\n\\twhile(num>mask) mask= (mask<<1) | 1;\\n\\treturn num^mask;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1649479,
                "title": "c-simple-approaches-w-explanation-faster-than-100",
                "content": "**Brute Force Approach :**\\n\\n* The Brute force approach to solve the problem would be to first convert the given number into its binary representation and then flip every bit in the binary representation. \\n* After changing all 0\\u2019s and 1\\u2019s convert the binary representation to number.\\n\\nTime Complexity :  O(n) - n = no. of bits in ```num```\\n\\nAuxiliary Space : O(n) \\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n\\t\\tvector<int> v;\\n\\t\\twhile (n != 0) {    //convert the number to it\\'s binary form & store the bits in \"v\"\\n\\t\\t\\tv.push_back(num%2);\\n\\t\\t\\tnum = num / 2;\\n\\t\\t}\\n\\t\\treverse(v.begin(), v.end());\\n\\t\\tfor (int i = 0; i < v.size(); i++) v[i] = (v[i]==0) ? 1 : 0;    //Flip the bits in the binary form\\n\\t\\t// convert back to number representation\\n\\t\\tint two = 1;\\n\\t\\tfor (int i = v.size() - 1; i >= 0; i--) {\\n\\t\\t\\tnum = num + v[i] * two;\\n\\t\\t\\ttwo = two * 2;\\n\\t\\t}\\n    return num;\\n    }\\n};\\n```\\n\\n**XOR Approach :**\\n* The only operation that can reverse the bits of a number (say : ```101``` to ```010``` is XOR (```^```) operation. \\n* So we need to XOR the given number with a number that has the same no. of bits & all bits set to 1 (here, ```111```).\\n* **How to count the number of bits in the given number ?**\\n1. Initialize 2 variables ```ans = 1``` & ```n = num```.\\n2. Until n is <= 1, do ```n >>= 1``` (decrementing 1 bit in ```n```), ```ans <<= 1``` (incerementing 1 bit in ```ans```) and ```ans |= 1``` (Setting the last bit of ```ans```).\\n\\n* Now that we have obtained a number that has as many bits as the input, perform **XOR** between the 2 numbers to flip all the bits of the input number.\\n\\nTime Complexity : O(logn) (Each time we\\'re doing n = n/2) - Where n = ```num```\\n\\nSpace Complexity : O(1) - No extra space used\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        int n = num, ans = 1;\\n        while(n != 1){\\n            n >>= 1;\\n            ans <<= 1;\\n            ans |= 1;\\n        }\\n        \\n        ans ^= num;\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nIf you like my solutions & explanation; please upvote :)\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```num```\n```\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n\\t\\tvector<int> v;\\n\\t\\twhile (n != 0) {    //convert the number to it\\'s binary form & store the bits in \"v\"\\n\\t\\t\\tv.push_back(num%2);\\n\\t\\t\\tnum = num / 2;\\n\\t\\t}\\n\\t\\treverse(v.begin(), v.end());\\n\\t\\tfor (int i = 0; i < v.size(); i++) v[i] = (v[i]==0) ? 1 : 0;    //Flip the bits in the binary form\\n\\t\\t// convert back to number representation\\n\\t\\tint two = 1;\\n\\t\\tfor (int i = v.size() - 1; i >= 0; i--) {\\n\\t\\t\\tnum = num + v[i] * two;\\n\\t\\t\\ttwo = two * 2;\\n\\t\\t}\\n    return num;\\n    }\\n};\\n```\n```101```\n```010```\n```^```\n```111```\n```ans = 1```\n```n = num```\n```n >>= 1```\n```n```\n```ans <<= 1```\n```ans```\n```ans |= 1```\n```ans```\n```num```\n```\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        int n = num, ans = 1;\\n        while(n != 1){\\n            n >>= 1;\\n            ans <<= 1;\\n            ans |= 1;\\n        }\\n        \\n        ans ^= num;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 614121,
                "title": "python-fastest-one-liner-timed",
                "content": "# Fastest Method Code\\n```\\nclass Solution:\\n    def findComplement(self, num: int) -> int:        \\n        return ~num + (1<<len(bin(num))-2)\\n```\\n\\n# Analysis\\nThis line adds the complement of num (```~num```) with 2^n, where n = the number of bits in the binary representation of num. Let\\'s take a look at why this works:\\n\\n## Brute Force Method\\nThe straightforward method would be to convert ```num``` to a binary string, flip all the bits, and then convert that back to binary:\\n```\\nbinaryNum = bin(num)[2:]\\nbinaryNumFlipped = \\'\\'\\nfor i in binaryNum:\\n\\tbinaryNumFlipped += \\'1\\' if i == 0 else \\'0\\'\\nreturn int(binaryNumFlipped, 2)\\n```\\n\\n## Complement Method\\nIn programming, the two\\'s complement of a number (```~num```) is defined as ```-(num+1)```. So, the two\\'s complement of 5 would be -6. The complement is with respect to 2^N\\u2014that is, ```num + ~num = 2^N``` where N is the number of bits in our representation. In binary, this can be calculated by flipping all the bits and adding one. So if we convert 5 to binary, flip all the bits, and add them together, we should get 2^N-1.\\n```\\n  101 (5)\\n+ 010 (2)\\n  ---\\n  111 (7)\\n+   1 (1)\\n  ---\\n 1000 (8)\\n ```\\n From this, we can easily see that in order to find the complement of 5, we simply need to use the formula ```2^N - 1 - num```, where N = the number of bits in 5 (in this case, 3). In code:\\n ```\\n 2**(len(bin(num))-2) - 1 - num\\n ```\\n*Note that since Python uses the ```\\'0b\\'``` prefix to represent a binary number, we subtract that from the length of the binary string for 5, which Python presents as ```\\'0b101\\'```.*\\n\\n## Faster Complement with Bitshift\\nWe can calculate 2^N much faster by bitshifting a 1. Since 2^N in binary is just 1 followed by N zeroes (same as in decimal, where 10^N is just 1 followed by N zeroes), we can replace 2^N with 1<<. So now we have:\\n```\\n(1<<(len(bin(num))-2)) - 1 - num\\n```\\nAnd finally, as noted before, ```~num = -(num+1)```, so we can replace this term in our code for elegance.\\n```\\n(1<<(len(bin(num))-2)) + ~num\\n```\\n\\n# Time Comparison\\nI used Python\\'s ```timeit``` module to compare the various methods. For this test, I set it up with 500 random integers sampled from [0,100000000] and ran it 5000 times, repeating each test 5 times. Results:\\n* Brute Force: **33.0518s**\\n* 2^N Complement: **5.8786s**\\n* Bitshift Complement: **3.7803s**\\n\\n*I also compared using ```~num``` vs ```-num-1```, but the results were roughly equal.*\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def findComplement(self, num: int) -> int:        \\n        return ~num + (1<<len(bin(num))-2)\\n```\n```~num```\n```num```\n```\\nbinaryNum = bin(num)[2:]\\nbinaryNumFlipped = \\'\\'\\nfor i in binaryNum:\\n\\tbinaryNumFlipped += \\'1\\' if i == 0 else \\'0\\'\\nreturn int(binaryNumFlipped, 2)\\n```\n```~num```\n```-(num+1)```\n```num + ~num = 2^N```\n```\\n  101 (5)\\n+ 010 (2)\\n  ---\\n  111 (7)\\n+   1 (1)\\n  ---\\n 1000 (8)\\n ```\n```2^N - 1 - num```\n```\\n 2**(len(bin(num))-2) - 1 - num\\n ```\n```\\'0b\\'```\n```\\'0b101\\'```\n```\\n(1<<(len(bin(num))-2)) - 1 - num\\n```\n```~num = -(num+1)```\n```\\n(1<<(len(bin(num))-2)) + ~num\\n```\n```timeit```\n```~num```\n```-num-1```",
                "codeTag": "Java"
            },
            {
                "id": 612432,
                "title": "java-100-faster-with-comments",
                "content": "```\\nclass Solution {\\n    public int findComplement(int num) {\\n        int result = 0;\\n        //use set to set the value of result in each bit\\n        int set = 1;\\n        while(num != 0) {\\n            //if last bit is 0 , set corresponding position of result to 1\\n            if((num&1)== 0) {\\n                result |= set;\\n            }\\n            //if last bit of num is 1, then do not need to set result\\n            set <<= 1; // left shift 1 bit\\n            num >>= 1;//right shift num, move right 1 bit\\n        }\\n        return result;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int findComplement(int num) {\\n        int result = 0;\\n        //use set to set the value of result in each bit\\n        int set = 1;\\n        while(num != 0) {\\n            //if last bit is 0 , set corresponding position of result to 1\\n            if((num&1)== 0) {\\n                result |= set;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 359201,
                "title": "one-line-javascript-solution",
                "content": "```javascript\\n// One-line solution\\nvar findComplement = function(num) {\\n    return num ^ parseInt(\\'1\\'.repeat(num.toString(2).length), 2)\\n};\\n\\n// Two-line solution\\nvar findComplement = function(num) {\\n\\tconst mask = \\'1\\'.repeat(num.toString(2).length)\\n    return num ^ parseInt(mask, 2)\\n};\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n// One-line solution\\nvar findComplement = function(num) {\\n    return num ^ parseInt(\\'1\\'.repeat(num.toString(2).length), 2)\\n};\\n\\n// Two-line solution\\nvar findComplement = function(num) {\\n\\tconst mask = \\'1\\'.repeat(num.toString(2).length)\\n    return num ^ parseInt(mask, 2)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 136131,
                "title": "javascript-solution-beats-100-using-string",
                "content": "```\\nvar findComplement = function(num) {\\n    var str = num.toString(2);\\n    var result = \\'\\';\\n    for (var i of str) {\\n      result += i === \\'1\\'?  \\'0\\': \\'1\\';\\n    }\\n    return parseInt(result, 2);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar findComplement = function(num) {\\n    var str = num.toString(2);\\n    var result = \\'\\';\\n    for (var i of str) {\\n      result += i === \\'1\\'?  \\'0\\': \\'1\\';\\n    }\\n    return parseInt(result, 2);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 96180,
                "title": "java-o-n-solution-easy-to-understand-with-detailed-explanation-and-comments",
                "content": "idea is simple, check each bit from right to leftmost bit 1, if bit is 1, continue, if bit is 0, set result's corresponding bit to 1\\n```\\npublic class Solution {\\n    public int findComplement(int num) {\\n        int result = 0;\\n        //use set to set the value of result in each bit\\n        int set = 1;\\n        while(num != 0) {\\n            //if last bit is 0 , set corresponding position of result to 1\\n            if((num&1)== 0) {\\n                result |= set;\\n            }\\n            //if last bit of num is 1, then do not need to set result\\n            set <<= 1; // left shift 1 bit\\n            num >>= 1;//right shift num, move right 1 bit\\n        }\\n        return result;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n    public int findComplement(int num) {\\n        int result = 0;\\n        //use set to set the value of result in each bit\\n        int set = 1;\\n        while(num != 0) {\\n            //if last bit is 0 , set corresponding position of result to 1\\n            if((num&1)== 0) {\\n                result |= set;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 96194,
                "title": "c-3-lines-o-highest-set-bit",
                "content": "\\nthe complexity will be the number of digits up to the highest set bit.\\n\\n```\\n    public int FindComplement(int num) \\n    {\\n        int mask = 1;\\n        while (mask < num) mask = (mask << 1) | 1;\\n        return ~num & mask;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int FindComplement(int num) \\n    {\\n        int mask = 1;\\n        while (mask < num) mask = (mask << 1) | 1;\\n        return ~num & mask;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3281191,
                "title": "476-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Convert the given integer \\'num\\' to its binary string representation using the built-in \\'bin()\\' function in Python.\\n2. Flip all bits in the binary string obtained in step 1 to obtain the binary string representation of its complement. This can be done by iterating over each bit in the binary string and replacing each \\'0\\' with \\'1\\' and vice versa.\\n3. Convert the binary string obtained in step 2 back to its decimal integer representation using the built-in \\'int()\\' function in Python with base 2.\\n4. Return the integer obtained in step 3 as the result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findComplement(self, num: int) -> int:\\n        # Convert num to binary string\\n        binary = bin(num)[2:]\\n\\n        # Flip all bits in the binary string\\n        flipped_binary = \\'\\'.join([\\'0\\' if bit == \\'1\\' else \\'1\\' for bit in binary])\\n\\n        # Convert the flipped binary string back to an integer\\n        if flipped_binary:\\n            return int(flipped_binary, 2)\\n        else:\\n            return 1\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def findComplement(self, num: int) -> int:\\n        # Convert num to binary string\\n        binary = bin(num)[2:]\\n\\n        # Flip all bits in the binary string\\n        flipped_binary = \\'\\'.join([\\'0\\' if bit == \\'1\\' else \\'1\\' for bit in binary])\\n\\n        # Convert the flipped binary string back to an integer\\n        if flipped_binary:\\n            return int(flipped_binary, 2)\\n        else:\\n            return 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898287,
                "title": "java-2-line-with-explanation-bit-manipulation-0ms",
                "content": "Num + Complement = All 1\\'s\\nSo, Complement = All 1\\'s - Num\\n\\n**Example :**\\nnum = 5 = 101\\ncomplement = 2 = 010\\n\\n101 + 010 = 111\\n**101 + complement = 111\\nSo, complement = 111 - 101\\n               = 010**\\n\\n# Code\\n```\\nclass Solution {\\n    public int findComplement(int num) {\\n    int n = 0;\\n        while (n < num) {\\n            n = (n << 1) | 1;\\n        }\\n        return n - num;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int findComplement(int num) {\\n    int n = 0;\\n        while (n < num) {\\n            n = (n << 1) | 1;\\n        }\\n        return n - num;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744263,
                "title": "python-simple-solution-faster-than-97-39",
                "content": "```\\nclass Solution:\\n    def findComplement(self, num: int) -> int:\\n        s=bin(num).replace(\\'0b\\',\\'\\')\\n        t=\\'\\'\\n        for i in s:\\n            if i==\\'0\\':\\n                t+=\\'1\\'\\n            else:\\n                t+=\\'0\\'\\n        return int(t,2)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findComplement(self, num: int) -> int:\\n        s=bin(num).replace(\\'0b\\',\\'\\')\\n        t=\\'\\'\\n        for i in s:\\n            if i==\\'0\\':\\n                t+=\\'1\\'\\n            else:\\n                t+=\\'0\\'\\n        return int(t,2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2120835,
                "title": "easy-solution-using-bitwise-operators",
                "content": "```\\nclass Solution {\\n    public static int findComplement(int num) {\\n        //Q476\\n        //Ex for 5\\n        //Using XOR operator - 0-->1 and 1-->0 that is what we need(Complement)\\n        //101 ^ 111 = 010 i.e., the ans. \\n        // 111 is the required mask in this case\\n        //For calculating mask, we take the value of highest one bit\\n        //5 = 101 in binary. Highest one bit = 100\\n        //If we left-shift this it will become 1000\\n        //1000 - 1 = 111 in binary that is the required mask\\n        int mask = (Integer.highestOneBit(num)<<1) - 1;\\n        return num ^ mask;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public static int findComplement(int num) {\\n        //Q476\\n        //Ex for 5\\n        //Using XOR operator - 0-->1 and 1-->0 that is what we need(Complement)\\n        //101 ^ 111 = 010 i.e., the ans. \\n        // 111 is the required mask in this case\\n        //For calculating mask, we take the value of highest one bit\\n        //5 = 101 in binary. Highest one bit = 100\\n        //If we left-shift this it will become 1000\\n        //1000 - 1 = 111 in binary that is the required mask\\n        int mask = (Integer.highestOneBit(num)<<1) - 1;\\n        return num ^ mask;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1131017,
                "title": "c-xor-solution-with-detail-explain",
                "content": "Consider the 32-bit int number representing as follow:\\n* 0000 0000 0000 0000 0000 0000 0000 0101  **---->** **num**\\n* 0111 1111 1111 1111 1111 1111 1111 1111  **---->** **mask** **---->** *key problem to calculate the mask*\\n* 0111 1111 1111 1111 1111 1111 1111 1010  **---->** **complement = num XOR mask**\\n\\t\\n```\\n    int findComplement(int num) {\\n\\t    //First calculate the bit counts of num using log2()\\n        unsigned int bits = floor(log2(num)) + 1;\\n\\t\\t//Create a mask of pow(2, bits) - 1.\\n\\t\\t//XOR the mask and the original num will get the complement number.\\n        return ((unsigned int)(1 << bits) - 1) ^ num;\\n    }\\n```\\n\\nIf you like it, please upvote.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\n    int findComplement(int num) {\\n\\t    //First calculate the bit counts of num using log2()\\n        unsigned int bits = floor(log2(num)) + 1;\\n\\t\\t//Create a mask of pow(2, bits) - 1.\\n\\t\\t//XOR the mask and the original num will get the complement number.\\n        return ((unsigned int)(1 << bits) - 1) ^ num;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1106166,
                "title": "java-simple-solution-100",
                "content": "```\\nclass Solution {\\n    public int findComplement(int num) {\\n        int ans = 0;\\n        int p = 0;\\n        while(num!=0){\\n            if(num%2==0) ans += Math.pow(2, p);\\n            p++;\\n            num /= 2;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findComplement(int num) {\\n        int ans = 0;\\n        int p = 0;\\n        while(num!=0){\\n            if(num%2==0) ans += Math.pow(2, p);\\n            p++;\\n            num /= 2;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 939193,
                "title": "c-100-bitset",
                "content": "```\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        bitset<32> b(num);\\n        int pos=32;\\n        while(!b[--pos]);\\n        while(pos>-1) b.flip(pos--);\\n        return b.to_ulong();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        bitset<32> b(num);\\n        int pos=32;\\n        while(!b[--pos]);\\n        while(pos>-1) b.flip(pos--);\\n        return b.to_ulong();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 852225,
                "title": "easy-java-stringbuilder-solution",
                "content": "class Solution {\\n    public int findComplement(int num) {\\n        String s=Integer.toBinaryString(num);\\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'1\\'){\\n                sb.append(\\'0\\');\\n            }\\n            else{\\n                sb.append(\\'1\\');\\n            }\\n        }\\n        return (Integer.parseInt(sb.toString(),2));\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int findComplement(int num) {\\n        String s=Integer.toBinaryString(num);\\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'1\\'){\\n                sb.append(\\'0\\');\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 613703,
                "title": "c-simple-solution-without-using-math-functions",
                "content": "```\\npublic int FindComplement(int num) {\\n    int k = 1;\\n    for (int i = num; i > 0; i >>= 1)\\n        k <<= 1;\\n    return k - num - 1;\\n}\\n```\\n\\nif num = 101\\nk will be 1000\\nk - 1 = 111\\nk - num - 1 = 010\\n",
                "solutionTags": [],
                "code": "```\\npublic int FindComplement(int num) {\\n    int k = 1;\\n    for (int i = num; i > 0; i >>= 1)\\n        k <<= 1;\\n    return k - num - 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 441969,
                "title": "c-simple-easy-naive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        \\n        int x =0;\\n        int d=0;\\n        string s=\"\";\\n        while(num){\\n            s=to_string(num&1) +s;\\n            num/=2;\\n        }\\n        int i = 0;\\n        while(i<s.length()){\\n            s[i]=s[i]==\\'1\\'?\\'0\\':\\'1\\';\\n            i++;\\n        }\\n        i=s.length()-1;\\n        while(i>-1){\\n            x+=(s[i]-\\'0\\')*pow(2,d);\\n            i--;\\n            d++;\\n        }\\n        return x;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        \\n        int x =0;\\n        int d=0;\\n        string s=\"\";\\n        while(num){\\n            s=to_string(num&1) +s;\\n            num/=2;\\n        }\\n        int i = 0;\\n        while(i<s.length()){\\n            s[i]=s[i]==\\'1\\'?\\'0\\':\\'1\\';\\n            i++;\\n        }\\n        i=s.length()-1;\\n        while(i>-1){\\n            x+=(s[i]-\\'0\\')*pow(2,d);\\n            i--;\\n            d++;\\n        }\\n        return x;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 272794,
                "title": "javascript",
                "content": "```\\nvar findComplement = function(num) {\\n    var number = num.toString(2);\\n    var str = \\'\\';\\n    for(let i of number) {\\n        str += +!(i-0);\\n    }\\n    return parseInt(str, 2)\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar findComplement = function(num) {\\n    var number = num.toString(2);\\n    var str = \\'\\';\\n    for(let i of number) {\\n        str += +!(i-0);\\n    }\\n    return parseInt(str, 2)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 178598,
                "title": "cpp-o-lgn-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        long long t=1;\\n        while(t<=num)\\n            t=t<<1;\\n        return (t-1)^num;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        long long t=1;\\n        while(t<=num)\\n            t=t<<1;\\n        return (t-1)^num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96215,
                "title": "trivial-ruby-one-liner",
                "content": "```\\ndef find_complement(num)\\n  num.to_s(2).tr('01', '10').to_i(2)\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef find_complement(num)\\n  num.to_s(2).tr('01', '10').to_i(2)\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3374718,
                "title": "java-simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int findComplement(int num) {\\n        String bin = Integer.toBinaryString(num);\\n        String res = \"\";\\n        for(char c :bin.toCharArray())\\n        {\\n            if( c == \\'1\\')\\n            res += \"0\";\\n            else\\n            res += \"1\";\\n        }\\n        return Integer.parseInt(res, 2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findComplement(int num) {\\n        String bin = Integer.toBinaryString(num);\\n        String res = \"\";\\n        for(char c :bin.toCharArray())\\n        {\\n            if( c == \\'1\\')\\n            res += \"0\";\\n            else\\n            res += \"1\";\\n        }\\n        return Integer.parseInt(res, 2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2938200,
                "title": "easiest-approach-only-3-steps-beginner-friendly-easiest-c-solution",
                "content": "# 3 Steps\\n1. Convert to binary representation\\n2. Change 1\\'s to 0 and 0\\'s to 1\\n3. Convert back to number representation\\n```\\nclass Solution {\\npublic:\\n    unsigned int onesComplement(unsigned int n)\\n{\\n    vector<int> v;\\n    // convert to binary representation\\n    while (n != 0) {\\n        v.push_back(n % 2);\\n        n = n / 2;\\n    }\\n    reverse(v.begin(), v.end());\\n    // change 1\\'s to 0 and 0\\'s to 1\\n    for (int i = 0; i < v.size(); i++) {\\n        if (v[i] == 0)\\n            v[i] = 1;\\n        else\\n            v[i] = 0;\\n    }\\n    // convert back to number representation\\n    long long int two = 1;\\n    for (int i = v.size() - 1; i >= 0; i--) {\\n        n = n + v[i] * two;\\n        two = two * 2;\\n    }\\n    return n;\\n}\\n    int findComplement(int num) {\\n        return onesComplement(num);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unsigned int onesComplement(unsigned int n)\\n{\\n    vector<int> v;\\n    // convert to binary representation\\n    while (n != 0) {\\n        v.push_back(n % 2);\\n        n = n / 2;\\n    }\\n    reverse(v.begin(), v.end());\\n    // change 1\\'s to 0 and 0\\'s to 1\\n    for (int i = 0; i < v.size(); i++) {\\n        if (v[i] == 0)\\n            v[i] = 1;\\n        else\\n            v[i] = 0;\\n    }\\n    // convert back to number representation\\n    long long int two = 1;\\n    for (int i = v.size() - 1; i >= 0; i--) {\\n        n = n + v[i] * two;\\n        two = two * 2;\\n    }\\n    return n;\\n}\\n    int findComplement(int num) {\\n        return onesComplement(num);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2860565,
                "title": "beats-99-python-solution",
                "content": "```\\nclass Solution:\\n    def findComplement(self, num: int) -> int:\\n        binary = \"\"\\n        while num != 0:\\n            binary = str(num % 2) + binary\\n            num = num // 2\\n        answer = \"\"\\n        for digit in binary:\\n            if digit == \"0\":\\n                answer += \"1\"\\n            else:\\n                answer += \"0\"\\n        addition = 0\\n        count = len(answer) - 1\\n        for i in range(0, len(answer)):\\n            addition += int(answer[i]) * (2 ** count)\\n            count -= 1\\n        return addition\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findComplement(self, num: int) -> int:\\n        binary = \"\"\\n        while num != 0:\\n            binary = str(num % 2) + binary\\n            num = num // 2\\n        answer = \"\"\\n        for digit in binary:\\n            if digit == \"0\":\\n                answer += \"1\"\\n            else:\\n                answer += \"0\"\\n        addition = 0\\n        count = len(answer) - 1\\n        for i in range(0, len(answer)):\\n            addition += int(answer[i]) * (2 ** count)\\n            count -= 1\\n        return addition\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2700428,
                "title": "python-3-lines",
                "content": "Python solution written in 3mins under test conditions:\\n\\n```python\\nclass Solution:\\n    def findComplement(self, num: int) -> int:\\n        \"\"\"\\n        This solution uses list comprehension and binary operators. Firstly, the \\n        bit_out is assigned as empty, then the list comprehension is used to fill the \\n        bit_out, where the opposite value in binary is used, for each value in the binary\\n        representation of the input num. Finally, the list is joined and returned as an\\n        integer reperesentation of the binary string.\\n        \\n        :param num: the number to collect the binary complement of. (int)\\n        :return: outcome: the outcome complement integer. (int)\\n        \"\"\"\\n        bit_out = []\\n        [bit_out.append(\"0\") if x == \"1\" else bit_out.append(\"1\") for x in list(format(num, \"b\"))]\\n        return int(\"\".join(bit_out), 2)",
                "solutionTags": [
                    "Python"
                ],
                "code": "Python solution written in 3mins under test conditions:\\n\\n```python\\nclass Solution:\\n    def findComplement(self, num: int) -> int:\\n        \"\"\"\\n        This solution uses list comprehension and binary operators. Firstly, the \\n        bit_out is assigned as empty, then the list comprehension is used to fill the \\n        bit_out, where the opposite value in binary is used, for each value in the binary\\n        representation of the input num. Finally, the list is joined and returned as an\\n        integer reperesentation of the binary string.\\n        \\n        :param num: the number to collect the binary complement of. (int)\\n        :return: outcome: the outcome complement integer. (int)\\n        \"\"\"\\n        bit_out = []\\n        [bit_out.append(\"0\") if x == \"1\" else bit_out.append(\"1\") for x in list(format(num, \"b\"))]\\n        return int(\"\".join(bit_out), 2)",
                "codeTag": "Java"
            },
            {
                "id": 2399404,
                "title": "c-solution-basic-for-loop-easy-to-understand-100-efficient-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        int ans = 0;\\n        for (int i = 0; num > 0; i++){\\n            ans += !(num % 2) * pow(2,i);\\n            num /= 2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        int ans = 0;\\n        for (int i = 0; num > 0; i++){\\n            ans += !(num % 2) * pow(2,i);\\n            num /= 2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1970049,
                "title": "c-solution-3-line-code-100-faster-0ms",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        int mask = 0;\\n        \\n        while(mask < num) {\\n            mask = ( mask << 1 ) | 1;\\n        }\\n        \\n        return ~num &mask;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        int mask = 0;\\n        \\n        while(mask < num) {\\n            mask = ( mask << 1 ) | 1;\\n        }\\n        \\n        return ~num &mask;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1650225,
                "title": "easy-xor-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        //xor with 1111...11111\\n        \\n        //finding highest power of 2 in num\\n        int i=31;\\n        for (; i>=0; i--){\\n            if (pow(2, i) <= num) break; \\n        }\\n        \\n        \\n        //making decimal representation of 111....1111\\n        int xorOp=0; \\n        for (int j=i; j>=0; j--) xorOp += pow(2, j);\\n        \\n        \\n        return num^xorOp;\\n    }\\n};\\n```\\n\\nxor a bit 1 with 1 will give 0\\nxor a bit 0 with 1 will give 1 \\nthis is exactly what we want. \\n\\n",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        //xor with 1111...11111\\n        \\n        //finding highest power of 2 in num\\n        int i=31;\\n        for (; i>=0; i--){\\n            if (pow(2, i) <= num) break; \\n        }\\n        \\n        \\n        //making decimal representation of 111....1111\\n        int xorOp=0; \\n        for (int j=i; j>=0; j--) xorOp += pow(2, j);\\n        \\n        \\n        return num^xorOp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1650185,
                "title": "c-o-1-oneliner-0ms-using-builtin-clz",
                "content": "If we accept the use of built in functions, we can do something like:\\n\\n```\\n    int findComplement(int num) {\\n        return ~num & (0xffffffff >> __builtin_clz(num));        \\n    }\\n```\\n\\nIt always amazes me what the compiler generates out of it:\\n\\n```ass\\nfindComplement(int):                    # @findComplement(int)\\n        mov     eax, edi\\n        bsr     ecx, edi\\n        not     eax\\n        xor     ecx, 31\\n        shl     eax, cl\\n        shr     eax, cl\\n        ret\\n```\\n\\nAnother variant could be:\\n\\n```\\n   int findComplement(int num) {\\n        const int lz = __builtin_clz(num);\\n        return (~num << lz) >> lz;\\n    }\\n```\\n\\nwhich generates similar assembly code, but not the same:\\n\\n```asm\\nfindComplement(int):                    # @findComplement(int)\\n        mov     eax, edi\\n        bsr     ecx, edi\\n        xor     ecx, 31\\n        not     eax\\n        shl     eax, cl\\n        sar     eax, cl\\n        ret\\n```\\n\\nIf we change the signature to ```int findComplement(unsigned int num)``` the compiler will generate the same instructions, module the ordering of a ```xor ecx, 31``` and ```not eax``` which are independent and the CPU will maybe exucute out of order anyway.\\n",
                "solutionTags": [],
                "code": "```\\n    int findComplement(int num) {\\n        return ~num & (0xffffffff >> __builtin_clz(num));        \\n    }\\n```\n```ass\\nfindComplement(int):                    # @findComplement(int)\\n        mov     eax, edi\\n        bsr     ecx, edi\\n        not     eax\\n        xor     ecx, 31\\n        shl     eax, cl\\n        shr     eax, cl\\n        ret\\n```\n```\\n   int findComplement(int num) {\\n        const int lz = __builtin_clz(num);\\n        return (~num << lz) >> lz;\\n    }\\n```\n```asm\\nfindComplement(int):                    # @findComplement(int)\\n        mov     eax, edi\\n        bsr     ecx, edi\\n        xor     ecx, 31\\n        not     eax\\n        shl     eax, cl\\n        sar     eax, cl\\n        ret\\n```\n```int findComplement(unsigned int num)```\n```xor ecx, 31```\n```not eax```",
                "codeTag": "Unknown"
            },
            {
                "id": 1649907,
                "title": "number-complement-100-bit-manipulation-approach-java",
                "content": "class Solution {\\n\\n    public int findComplement(int n) {\\n        int number_of_bits = (int) (Math.floor(Math.log(n) / Math.log(2))) + 1;\\n        return ((1 << number_of_bits) - 1) ^ n;\\n    }\\n}\\n\\n**Please help to UPVOTE if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\nHAPPY CODING :)\\nLOVE CODING :)**",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n\\n    public int findComplement(int n) {\\n        int number_of_bits = (int) (Math.floor(Math.log(n) / Math.log(2))) + 1;\\n        return ((1 << number_of_bits) - 1) ^ n;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1649805,
                "title": "python3-1-liner-xor-logic",
                "content": "First solved it with the array/list approach to individually inverse the elements. Then, thought of how to implement a not gate using other bitwise operators and realised A xor 1 = not A.\\n1*len(bin(num) is for creating the same length of 1\\'s to xor each element with and [2:] slicing is to discard the \\'0b\\' representing that the string is a binary of a number.\\n```\\nclass Solution:\\n    def findComplement(self, num: int) -> int:\\n        return num^int(\\'1\\'*len(bin(num)[2:]), 2)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findComplement(self, num: int) -> int:\\n        return num^int(\\'1\\'*len(bin(num)[2:]), 2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1649786,
                "title": "java-4-solutions-o-n-o-1-bit-manipulation",
                "content": "The first solution I came up with involves using an integer to build up the result in. Along with another integer to indicate the shift needed at the current bit being inspected.\\n\\nOn each iteration of the loop, check if the bit in the ones place is set. If so you will OR that bit shifted by the needed amount for that iteration to the result. Then you will shift the overall number to the right and increment the shift count for the next iteration.\\n\\nThe loop will then terminate once the number has reached 0. So the loop will execute once for each bit up until the most significant bit. Meaning it is O(n) in time complexity relative to MSB.\\n```\\npublic int findComplement(int num) {\\n    int a = 0;\\n    int pow = 0;\\n    while(num > 0){\\n        if((num & 1) == 0)\\n            a |= 1 << pow;\\n        num >>= 1;\\n        pow++;\\n    }\\n    return a;\\n}\\n```\\n\\n\\nThe next solution I came up with relies on the fact that you can create the mask for the bits based on the length of the binary representation. Since Java provides a toBinaryString method the string can be used to find the binary length.\\n\\nOnce the length is known you can raise 2 to the power of the length. Then subtract one to create an integer mask with all bits set up to the most significant bit.\\n\\nThen the XOR operator can be used to flip all bits that aren\\'t alike in the mask and the number. Which is what the problem is asking for (since the mask is set to all ones).\\n\\nJava\\'s Integer.toBinaryString method runs in O(n) relative to the most significant bit. Similar in the way that the first solution was implemented. So therefore this also executes in O(n) overall time (however it can easily be made into a nice 1 liner).\\n\\n```\\npublic int findComplement(int num){\\n    int xor = (int) (Math.pow(2, Integer.toBinaryString(num).length()) - 1);\\n    return num ^ xor;\\n}\\n```\\n\\n\\nAfter this I began to realize this could easily turn into O(1) time complexity. Due to the maximum number of bits in an Integer is 32.\\n\\nTo do this I OR\\'d the number shifted to the right by 0 to 31. Resulting in a mask that contained all bits set from the most significant down. This time it executed exacly 32 times leading to O(32) = O(1) time complexity.\\n\\nTo get the result I then XOR the number to the mask. Which gets the resulting integer where all bits weren\\'t set in the number given\\n\\n```\\npublic int findComplement(int num){\\n    int mask = 0;\\n    for(int i = 0; i < 32; i++)\\n        mask |= num >> i;\\n    return num ^ mask;\\n\\t}\\n```\\n\\n\\nLastly I realized that by starting the mask equal to the number. The most significant bit of the number would also be the most significant in the mask.\\n\\nFrom there I could shift the mask to the right by 1 and OR it on. This makes each set bit in the original number and the one to its immediate right set in the mask.\\n\\nNow you can shift the bits in the mask by 2 to the right and OR it on. Thus making the original bit and the next 3 to its right set as well.\\n\\nThis doubling of set bits repeats up until the last shift of 16. Which will guarantee that all bits from the most significant down are set.\\n\\nOnce the mask has been created. The result is the found by XORing the mask to the original number as in the previous example.\\n\\n```\\npublic int findComplement(int num){\\n    int mask = num;\\n    mask |= mask >> 1;\\n    mask |= mask >> 2;\\n    mask |= mask >> 4;\\n    mask |= mask >> 8;\\n    mask |= mask >> 16;\\n    return num ^ mask;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\npublic int findComplement(int num) {\\n    int a = 0;\\n    int pow = 0;\\n    while(num > 0){\\n        if((num & 1) == 0)\\n            a |= 1 << pow;\\n        num >>= 1;\\n        pow++;\\n    }\\n    return a;\\n}\\n```\n```\\npublic int findComplement(int num){\\n    int xor = (int) (Math.pow(2, Integer.toBinaryString(num).length()) - 1);\\n    return num ^ xor;\\n}\\n```\n```\\npublic int findComplement(int num){\\n    int mask = 0;\\n    for(int i = 0; i < 32; i++)\\n        mask |= num >> i;\\n    return num ^ mask;\\n\\t}\\n```\n```\\npublic int findComplement(int num){\\n    int mask = num;\\n    mask |= mask >> 1;\\n    mask |= mask >> 2;\\n    mask |= mask >> 4;\\n    mask |= mask >> 8;\\n    mask |= mask >> 16;\\n    return num ^ mask;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1649764,
                "title": "number-complement",
                "content": "```\\nclass Solution {\\n    public int findComplement(int num) {\\n        String str=Integer.toBinaryString(num);\\n        StringBuilder sb=new StringBuilder(str);\\n        StringBuilder sb1=new StringBuilder();\\n        for(int i=0;i<sb.length();i++){\\n            if(sb.charAt(i)==\\'0\\')\\n                sb1.append(\"1\");\\n            else\\n                sb1.append(\"0\");\\n            }\\n        int res=Integer.parseInt(sb1.toString(),2);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findComplement(int num) {\\n        String str=Integer.toBinaryString(num);\\n        StringBuilder sb=new StringBuilder(str);\\n        StringBuilder sb1=new StringBuilder();\\n        for(int i=0;i<sb.length();i++){\\n            if(sb.charAt(i)==\\'0\\')\\n                sb1.append(\"1\");\\n            else\\n                sb1.append(\"0\");\\n            }\\n        int res=Integer.parseInt(sb1.toString(),2);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1649763,
                "title": "python-one-liner-with-xor-itself",
                "content": "all we have to do xor the number with it all ones bits \\n\\nclass Solution:\\n\\tdef findComplement(self, num: int) -> int:\\n\\t\\treturn num ^ int( ( \\'1\\' *  len(bin(num).replace( \\'0b\\' , \\'\\' ) ) ) , 2 )",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "all we have to do xor the number with it all ones bits \\n\\nclass Solution:\\n\\tdef findComplement(self, num: int) -> int:\\n\\t\\treturn num ^ int( ( \\'1\\' *  len(bin(num).replace( \\'0b\\' , \\'\\' ) ) ) , 2 )",
                "codeTag": "Java"
            },
            {
                "id": 1649400,
                "title": "6-lines-easy-java-solution-100-faster",
                "content": "**Upvote if you LIKE** \\uD83D\\uDE42\\n\\nExplanation: Using XOR operation with any bit reverses it. So here I am masking the number by doing XOR with each bit of the number.\\n\\nclass Solution {\\n\\n    public int findComplement(int num) {\\n        int cou = num;\\n        int mask = 1;\\n        while(cou!=0){\\n            num = num^mask;\\n            mask = mask<<1;\\n            cou = cou>>1;\\n        }\\n        return num;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n\\n    public int findComplement(int num) {\\n        int cou = num;\\n        int mask = 1;\\n        while(cou!=0){\\n            num = num^mask;\\n            mask = mask<<1;\\n            cou = cou>>1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1643019,
                "title": "golang-solution",
                "content": "```\\nfunc findComplement(num int) int {\\n    //count digits of the incoming number\\n    count := 0\\n\\tfor x := num; x!=0; x = x>>1 {\\n\\t\\tcount++\\n\\t}\\n\\tvar mask int\\n\\tfor i := 0; i<count; i++ {\\n\\t\\tmask = mask << 1 + 1\\n\\t}\\n\\treturn num^mask\\n}\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nfunc findComplement(num int) int {\\n    //count digits of the incoming number\\n    count := 0\\n\\tfor x := num; x!=0; x = x>>1 {\\n\\t\\tcount++\\n\\t}\\n\\tvar mask int\\n\\tfor i := 0; i<count; i++ {\\n\\t\\tmask = mask << 1 + 1\\n\\t}\\n\\treturn num^mask\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1639725,
                "title": "easy-c-0ms-code",
                "content": "\\n```\\nclass Solution {\\npublic:\\n  int findComplement(int num)\\n  {\\n    u_int ans = 0, i=1;\\n    while(num)\\n    {\\n        if(!(num&1))\\n            ans+=i;\\n        num = num>>1;\\n        i*=2;\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int findComplement(int num)\\n  {\\n    u_int ans = 0, i=1;\\n    while(num)\\n    {\\n        if(!(num&1))\\n            ans+=i;\\n        num = num>>1;\\n        i*=2;\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1557605,
                "title": "1-line-go-solution",
                "content": "```\\nfunc findComplement(num int) int {\\n\\treturn (1<<(bits.Len(uint(num))) - 1) ^ num\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc findComplement(num int) int {\\n\\treturn (1<<(bits.Len(uint(num))) - 1) ^ num\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1425210,
                "title": "simple-c-100",
                "content": "```\\nint findComplement(int num){\\n    int temp = num, c = 0;\\n    while(temp>0)\\n    {\\n        c = (c<<1)|1;\\n        temp >>= 1;\\n    }  \\n    return num ^ c;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint findComplement(int num){\\n    int temp = num, c = 0;\\n    while(temp>0)\\n    {\\n        c = (c<<1)|1;\\n        temp >>= 1;\\n    }  \\n    return num ^ c;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1004951,
                "title": "c-100-faster-with-comments",
                "content": "class Solution {\\npublic:\\n\\n    int findComplement(int num) {\\n        //just have to shift each bit\\n        //first find the first non zero bit\\n        int f = log2(num);\\n        for(int i = f; i>=0;i--){\\n            //now flip the ith bit\\n            //take xor of the ith bit with 1\\n            // 0^1 = 1 and 1^1 = 0 hence bit is flipped, other bits remain the same\\n            \\n            num = (num^(1<<i) );\\n        }\\n        return num;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int findComplement(int num) {\\n        //just have to shift each bit\\n        //first find the first non zero bit\\n        int f = log2(num);\\n        for(int i = f; i>=0;i--){\\n            //now flip the ith bit\\n            //take xor of the ith bit with 1\\n            // 0^1 = 1 and 1^1 = 0 hence bit is flipped, other bits remain the same\\n            \\n            num = (num^(1<<i) );\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 942852,
                "title": "java-easy-solution-beat-100",
                "content": "If you like this solution, please vote up.\\n```\\nclass Solution {\\n    \\n    public int findComplement(int num) {\\n        // count the bit length\\n        // e.g. \\n        // 5  (101) return 3\\n        // 10 (1010) return 4\\n        int n = bitLen(num);\\n        \\n        // flip each bit\\n        //\\n        // xor\\n        // -------\\n        // 0 0 | 0 \\n        // 0 1 | 1   <-\\n        // 1 0 | 1\\n        // 1 1 | 0   <-\\n        // -------\\n        //\\n        // 0 ^ 1 = 1\\n        // 1 ^ 1 = 0\\n        //\\n        for (int i = 0; i < n; i++) {\\n            // where i is the bit that is to be flip\\n            num ^= 1 << i;\\n        }\\n        \\n        return num;\\n    }\\n    \\n    private int bitLen(int a) {\\n        return 32 - Integer.numberOfLeadingZeros(a);\\n    }\\n}\\n```\\n\\nUpdate: Flip it all at once\\n\\n```\\nclass Solution {\\n    \\n     public int findComplement(int num) {\\n        /*\\n          00000...00101\\n        ^ 00000...00111   <- How to find these bits to do xor operation\\n        ---------------\\n          00000...00010\\n\\n\\n        Let\\'s think about this\\n\\n          111\\n        + 001\\n        -----\\n         1000\\n\\n        You see, to get 111 we only need 1000 and then just subtract it by 1\\n        So do:\\n        \\n        Integer.highestOneBit(5)\\n        => 00000...00100\\n        \\n        Integer.highestOneBit(5) << 1\\n        => 00000...01000\\n        \\n        Integer.highestOneBit(5) << 1 - 1\\n        => 00000...00111\\n        */\\n        \\n        int mask = (Integer.highestOneBit(num) << 1) - 1;\\n        return num ^ mask;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int findComplement(int num) {\\n        // count the bit length\\n        // e.g. \\n        // 5  (101) return 3\\n        // 10 (1010) return 4\\n        int n = bitLen(num);\\n        \\n        // flip each bit\\n        //\\n        // xor\\n        // -------\\n        // 0 0 | 0 \\n        // 0 1 | 1   <-\\n        // 1 0 | 1\\n        // 1 1 | 0   <-\\n        // -------\\n        //\\n        // 0 ^ 1 = 1\\n        // 1 ^ 1 = 0\\n        //\\n        for (int i = 0; i < n; i++) {\\n            // where i is the bit that is to be flip\\n            num ^= 1 << i;\\n        }\\n        \\n        return num;\\n    }\\n    \\n    private int bitLen(int a) {\\n        return 32 - Integer.numberOfLeadingZeros(a);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    \\n     public int findComplement(int num) {\\n        /*\\n          00000...00101\\n        ^ 00000...00111   <- How to find these bits to do xor operation\\n        ---------------\\n          00000...00010\\n\\n\\n        Let\\'s think about this\\n\\n          111\\n        + 001\\n        -----\\n         1000\\n\\n        You see, to get 111 we only need 1000 and then just subtract it by 1\\n        So do:\\n        \\n        Integer.highestOneBit(5)\\n        => 00000...00100\\n        \\n        Integer.highestOneBit(5) << 1\\n        => 00000...01000\\n        \\n        Integer.highestOneBit(5) << 1 - 1\\n        => 00000...00111\\n        */\\n        \\n        int mask = (Integer.highestOneBit(num) << 1) - 1;\\n        return num ^ mask;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 892043,
                "title": "beat-100-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        int ans = 0, temp = 0, count = 0;\\n        while(num){\\n            temp = !(num & 1);\\n            num >>= 1;\\n            ans |= (temp << count++);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/986a0485-7cde-4325-9e7f-c8b4c65650e2_1602552287.2616305.png)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        int ans = 0, temp = 0, count = 0;\\n        while(num){\\n            temp = !(num & 1);\\n            num >>= 1;\\n            ans |= (temp << count++);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 881362,
                "title": "java-one-line",
                "content": "Here I am converting the input number into binary string. The value obtained when 2 is raised to the number of characters in the binary string subtracted by 1 is the maximum possible value with that length of binary string (when all the characters are \\'1\\'). Since we need the complement, the input is subtracted from this value. \\n\\n```\\nclass Solution {\\n    public int bitwiseComplement(int N) {        \\n        return (int)Math.pow(2, Integer.toBinaryString(N).length())-N-1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int bitwiseComplement(int N) {        \\n        return (int)Math.pow(2, Integer.toBinaryString(N).length())-N-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 613362,
                "title": "python-short-bit-solution-clean-concise",
                "content": "```python\\nclass Solution:\\n    def findComplement(self, num: int) -> int:\\n        i = 0\\n        ans = 0\\n        while num > 0:\\n            if (num & 1) == 0:\\n                ans |= 1 << i\\n            i += 1\\n            num >>= 1\\n            \\n        return ans\\n```\\n**Complexity**\\n- Time: `O(logNum)`\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def findComplement(self, num: int) -> int:\\n        i = 0\\n        ans = 0\\n        while num > 0:\\n            if (num & 1) == 0:\\n                ans |= 1 << i\\n            i += 1\\n            num >>= 1\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 612591,
                "title": "rust-simple-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn find_complement(num: i32) -> i32 {\\n        let mut n = 1;\\n        while n < num {\\n            n = (n << 1) + 1;\\n        }\\n        n - num\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn find_complement(num: i32) -> i32 {\\n        let mut n = 1;\\n        while n < num {\\n            n = (n << 1) + 1;\\n        }\\n        n - num\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 612374,
                "title": "simple-and-fast-python3-one-liner-beats-96-98",
                "content": "It\\'s easy to see that all we have to do is XOR (`^` in Python) with a mask of all `1` that is the same number of binary digits as our input number.\\n\\nPerusing the Python docs, I see there is a `bit_length()` method on `int` that gives us an easy shortcut on constructing that mask.\\n\\n```\\nclass Solution:\\n  def findComplement(self, num: int) -> int:\\n    return ((1 << num.bit_length()) - 1) ^ num\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n  def findComplement(self, num: int) -> int:\\n    return ((1 << num.bit_length()) - 1) ^ num\\n```",
                "codeTag": "Java"
            },
            {
                "id": 395911,
                "title": "c-solution-0-ms-6-8-mb-memory-100-faster-than-all-solutions-7-lines",
                "content": "This solution is probably the simplest amongst all others. \\n\\nint findComplement(int num){\\n\\tint mask = 1;\\n    while(mask < num){\\n        mask = (mask << 1) | 1; /* Prepares the mask of all 1s for XOR */\\n    }\\n    num = num ^ mask; /* This uses the XOR function to flip bits */\\n\\treturn num;\\n}\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "This solution is probably the simplest amongst all others. \\n\\nint findComplement(int num){\\n\\tint mask = 1;\\n    while(mask < num){\\n        mask = (mask << 1) | 1; /* Prepares the mask of all 1s for XOR */\\n    }\\n    num = num ^ mask; /* This uses the XOR function to flip bits */\\n\\treturn num;\\n}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 343534,
                "title": "python-with-xor-with-explanation",
                "content": "We want to get a complement which is simply accomplished by doing and XOR with all 1s.\\nFor example: 0b1010 ^ 0b1111 = 0b0101.  The key is to generate the right number of 1s. So...\\n\\nFirst, convert number to binary.  Conveniently, Python leaves off leading zeroes.\\nHowever, it does add a \"0b\" in front we need to account for when we take the length so subtract 2.\\nNow we take 2 to the power of the length and subtract 1 to generate our all 1s number.\\nExample: \\n4=0b100 so length is  5, but subtract 2 to account for the \"0b\" to get 3.  Then 2**3 gives 8=0b1000 and \\nsubtracting 1 gives 7=0b111  and finish with our XOR 0b100^0b111 to get 3=0b011\\n\\n```\\nreturn num^(2**(len(bin(num))-2)-1)\\n```",
                "solutionTags": [],
                "code": "```\\nreturn num^(2**(len(bin(num))-2)-1)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 281148,
                "title": "java-one-line",
                "content": "```java\\nclass Solution {\\n    public int findComplement(int num) {\\n        return ((Integer.highestOneBit(num) << 1) - 1) - num;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int findComplement(int num) {\\n        return ((Integer.highestOneBit(num) << 1) - 1) - num;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 277409,
                "title": "o-1-solution-with-explanation-doesn-t-use-loops-conditions-or-logarithm-beats-100",
                "content": "```\\npublic int FindComplement(int num) {\\n        int m=num;\\n        m |= m>>1;\\n        m |= m>>2;\\n        m |= m>>4;\\n        m |= m>>8;\\n        m |= m>>16;\\n        return num^m;\\n    }\\n\\t\\nExplanation: \\n1) create a mask that will have all bits (starting with most significant bit) set to 1s. For example, for number 10010 mask would be 11111.\\n2) XOR the number with the mask.",
                "solutionTags": [],
                "code": "```\\npublic int FindComplement(int num) {\\n        int m=num;\\n        m |= m>>1;\\n        m |= m>>2;\\n        m |= m>>4;\\n        m |= m>>8;\\n        m |= m>>16;\\n        return num^m;\\n    }\\n\\t\\nExplanation: \\n1) create a mask that will have all bits (starting with most significant bit) set to 1s. For example, for number 10010 mask would be 11111.\\n2) XOR the number with the mask.",
                "codeTag": "Unknown"
            },
            {
                "id": 173062,
                "title": "java-solution-for-people-scared-of-bit-manipulation",
                "content": "```java\\npublic int findComplement(int num) {\\n    int sum = 1, pow = 1;\\n\\n    while (sum < num) {\\n        pow *= 2;\\n        sum += pow;   \\n    }\\n\\n    return sum - num;\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic int findComplement(int num) {\\n    int sum = 1, pow = 1;\\n\\n    while (sum < num) {\\n        pow *= 2;\\n        sum += pow;   \\n    }\\n\\n    return sum - num;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 96008,
                "title": "javascript-1-line",
                "content": "```\\nvar findComplement = function(num) {\\n   return num ^ parseInt(num.toString(2).replace(/\\\\d/g, '1'), 2);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findComplement = function(num) {\\n   return num ^ parseInt(num.toString(2).replace(/\\\\d/g, '1'), 2);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 96027,
                "title": "3-line-c-solution",
                "content": "````  \\nint findComplement(int num) {\\n        int revert = ~0;\\n        while(revert & num ) revert <<= 1;\\n        return revert ^ (~num);\\n    }\\n````",
                "solutionTags": [],
                "code": "````  \\nint findComplement(int num) {\\n        int revert = ~0;\\n        while(revert & num ) revert <<= 1;\\n        return revert ^ (~num);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 96213,
                "title": "java-solutions-o-size-int-time",
                "content": "Using std library:\\n\\n```\\npublic int findComplement(int num) {\\n     return num ^ (Integer.highestOneBit(num) << 1) - 1;\\n}\\n```\\n\\nWithout using std library:\\n\\n```\\npublic int findComplement(int num) {\\n    int copy = num, i=0;\\n    while (copy != 0) {\\n        copy >>= 1;\\n        num ^= (1<<i++);\\n    }\\n    return num;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int findComplement(int num) {\\n     return num ^ (Integer.highestOneBit(num) << 1) - 1;\\n}\\n```\n```\\npublic int findComplement(int num) {\\n    int copy = num, i=0;\\n    while (copy != 0) {\\n        copy >>= 1;\\n        num ^= (1<<i++);\\n    }\\n    return num;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3867481,
                "title": "java-fastest-and-easiest-ever-linear-t-s-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to flip the bits, i.e. we have to find compliment, thus I think ~n is a really good option, but we have a problem over here, it flips all the bits  that is if an integer only takes 7 bits and rest in front are zeros, it will flip them too which is not required! Thus let\\'s find the number of bits in which a number can fit in, suppose we have 20 only, it\\'s binary representation is 10100 and  by this formula: \\n\\n##### nBits = (Math.log(num) / Math.log(2)) + 1\\n\\nWe can get the number of bits in which our number will definitely fit in, thus now let\\'s prevent our prefix zeros to flip, thus create a mask \\n\\n##### mask = (1 << nBits) - 1;\\n\\nThis will make sure all prefix zeros are preserved, thus let\\'s save our zeros now! I hope & will work as it will make 1-0 = 0 and 1-1 = 0, thus & our ~num with our mask\\n\\n##### ans = ~num & mask\\n\\nHERE WE GO! LINEAR TIME AND SPACE!\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findComplement(int num) {\\n        int nBits = (int)Math.floor((Math.log(num) / Math.log(2)) + 1);\\n        int mask = (1 << nBits) - 1;\\n        return ~num & mask;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int findComplement(int num) {\\n        int nBits = (int)Math.floor((Math.log(num) / Math.log(2)) + 1);\\n        int mask = (1 << nBits) - 1;\\n        return ~num & mask;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596215,
                "title": "beats-100-bitwise",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        int dup = num, c = 1;\\n        while(dup!=0){\\n            num=num^c;\\n            c = c << 1;\\n            dup = dup >> 1;\\n        }\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        int dup = num, c = 1;\\n        while(dup!=0){\\n            num=num^c;\\n            c = c << 1;\\n            dup = dup >> 1;\\n        }\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466403,
                "title": "simple-bit-manipulation-c",
                "content": "# Intuition\\nEvery bit of number toggles on taking its 1\\'s complement. Similar to taking xor with 1.\\n# Approach\\n**1^1 = 0**\\n    **1^0 = 1**\\n  **0^1 = 1**\\n    **0^0 = 0**\\n\\nLets look at an example:\\n5 = 101,\\n~5 = 010\\nWe can clearly see that every bit flips in 1\\'s complement so if we take xor of number with a number where all digits are one then we\\'ll get the answer.\\n\\n101^111 = 010.\\n\\n**How to get 111?**\\n111 = 7 = 8 - 1 = 2**3 - 1.\\nJust find the next greatest power of two and subtract 1 to get a number where all bits are set.\\n\\nAlternatively: num^(~num) = 2**n -1; where n = ceil(log(num)).\\n\\n# Complexity\\n- Time complexity:\\nO(ceil(log(num)))\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        long powerof2s = 1, temp = num;\\n        \\n        while( temp ) {\\n            temp >>= 1;\\n            powerof2s <<= 1;\\n        }\\n        \\n        return (powerof2s - 1)^num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        long powerof2s = 1, temp = num;\\n        \\n        while( temp ) {\\n            temp >>= 1;\\n            powerof2s <<= 1;\\n        }\\n        \\n        return (powerof2s - 1)^num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3373529,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        int n = 0;\\n        int a = num;\\n        while(num > 0){\\n            num >>= 1;\\n            n ++;\\n        }\\n        cout << n;\\n        n = pow(2, n ) - 1;\\n        return n - a;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def findComplement(self, num: int) -> int:\\n        count = 0\\n        temp = num\\n        while temp > 0:\\n            count += 1\\n            temp >>= 1\\n        return num ^ (2**count - 1)\\n```\\n\\n```Java []\\nclass Solution {\\n    public int findComplement(int num) {\\n        int s=0;\\n        int i=0;\\n        while(num!=0)\\n        {\\n            if((num&1)!=1)\\n            {\\n                s=s + (int)Math.pow(2,i);\\n            }\\n            i++;\\n            num=(num>>1);   \\n        }\\n        return s;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        int n = 0;\\n        int a = num;\\n        while(num > 0){\\n            num >>= 1;\\n            n ++;\\n        }\\n        cout << n;\\n        n = pow(2, n ) - 1;\\n        return n - a;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def findComplement(self, num: int) -> int:\\n        count = 0\\n        temp = num\\n        while temp > 0:\\n            count += 1\\n            temp >>= 1\\n        return num ^ (2**count - 1)\\n```\n```Java []\\nclass Solution {\\n    public int findComplement(int num) {\\n        int s=0;\\n        int i=0;\\n        while(num!=0)\\n        {\\n            if((num&1)!=1)\\n            {\\n                s=s + (int)Math.pow(2,i);\\n            }\\n            i++;\\n            num=(num>>1);   \\n        }\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3355886,
                "title": "simple-and-easy-to-understand-c-solution-tc-o-n-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n    long long ans=1;\\n\\twhile(num>=ans){\\n\\t\\tans*=2;\\n\\t}\\n\\treturn ans-num-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n    long long ans=1;\\n\\twhile(num>=ans){\\n\\t\\tans*=2;\\n\\t}\\n\\treturn ans-num-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347779,
                "title": "easy-solution-using-bit-manipulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findComplement(int num) {\\n        int n = num;\\n        int k=0;    //bits\\n        while(n>0){\\n            k++;\\n            n>>=1;\\n        }\\n        int mask = (1<<k)-1;\\n        return num^mask;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findComplement(int num) {\\n        int n = num;\\n        int k=0;    //bits\\n        while(n>0){\\n            k++;\\n            n>>=1;\\n        }\\n        int mask = (1<<k)-1;\\n        return num^mask;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203086,
                "title": "c-solution-runtime-0ms-beats-100",
                "content": "# Complexity\\n- Time complexity: O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n\\n    int ans=0;\\n    int i=0;\\n    if(num==0)\\n        ans=1;\\n    else\\n    {\\n        while (num != 0)\\n        {\\n            int lastBit = !(num & 1);\\n            ans = ans + lastBit * pow(2, i);\\n            num = num >> 1;\\n            i++;\\n        }\\n    }\\n    return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n\\n    int ans=0;\\n    int i=0;\\n    if(num==0)\\n        ans=1;\\n    else\\n    {\\n        while (num != 0)\\n        {\\n            int lastBit = !(num & 1);\\n            ans = ans + lastBit * pow(2, i);\\n            num = num >> 1;\\n            i++;\\n        }\\n    }\\n    return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3198278,
                "title": "100-beates-solution-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        int bit;\\n        int result = 0;\\n        int i = 0;\\n        while(num!=0){\\n            bit = num & 1;\\n            if(bit==1)\\n            bit = 0;\\n            else\\n            bit = 1;\\n            //if(result > INT_MAX/10 || result < INT_MIN )\\n            //return 0\\n                \\n            result+= (bit) * pow(2,i)  ;\\n            i++;\\n            num = num >> 1;\\n            \\n        }\\n        return result ;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        int bit;\\n        int result = 0;\\n        int i = 0;\\n        while(num!=0){\\n            bit = num & 1;\\n            if(bit==1)\\n            bit = 0;\\n            else\\n            bit = 1;\\n            //if(result > INT_MAX/10 || result < INT_MIN )\\n            //return 0\\n                \\n            result+= (bit) * pow(2,i)  ;\\n            i++;\\n            num = num >> 1;\\n            \\n        }\\n        return result ;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2997678,
                "title": "c-solution-beats-100-math-approach-1-line",
                "content": "```c\\nint findComplement(int num){\\n    return pow(2, (int)(log2(num) / log2(2)) + 1) - 1 - num;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```c\\nint findComplement(int num){\\n    return pow(2, (int)(log2(num) / log2(2)) + 1) - 1 - num;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2960952,
                "title": "easy-java-solution-using-bit-manipulation-beats-100",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBit Manipulation\\n\\nHope this helps.\\nDo Upvote if you like it !!\\n\\nThanks :)\\n# Code\\n```\\nclass Solution {\\n    public int findComplement(int num) {\\n        int c=0;\\n        c=(int)(Math.log(num)/Math.log(2));\\n        num=~num; \\n        num =num & (int)((Math.pow(2,c))-1); \\n        return(num);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int findComplement(int num) {\\n        int c=0;\\n        c=(int)(Math.log(num)/Math.log(2));\\n        num=~num; \\n        num =num & (int)((Math.pow(2,c))-1); \\n        return(num);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779565,
                "title": "typescript-easy-solution",
                "content": "\\n# Approach\\n-  Converting number to Binary\\n- Converting binary number to array\\n- complementing the result in \"res\" array\\n- Converting \"res\" into number and return it\\n\\n\\n# Code\\n```\\nfunction findComplement(num: number): number {\\n\\n\\n    let res : string[] = []\\n    let rev = (num >>> 0).toString(2).split(\\'\\')\\n\\n    rev.forEach(n => {\\n        (n == \\'1\\') ? res.push(\\'0\\') : res.push(\\'1\\')\\n    })\\n\\n    return parseInt(res.join(\\'\\'), 2)\\n\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction findComplement(num: number): number {\\n\\n\\n    let res : string[] = []\\n    let rev = (num >>> 0).toString(2).split(\\'\\')\\n\\n    rev.forEach(n => {\\n        (n == \\'1\\') ? res.push(\\'0\\') : res.push(\\'1\\')\\n    })\\n\\n    return parseInt(res.join(\\'\\'), 2)\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2693666,
                "title": "java-python-solution-easiest-solution",
                "content": "**JAVA Solution**\\n```\\nclass Solution {\\n    public int findComplement(int num) {\\n        int result = 0;\\n        int set = 1;\\n        while(num != 0) {\\n            if((num&1)== 0) {\\n                result |= set;\\n            }\\n            set <<= 1;\\n            num >>= 1;\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n**Python Solution**\\n```\\nclass Solution:\\n    def findComplement(self, num: int) -> int:\\n        complement=\"\"\\n        for i in bin(num)[2:]:\\n            if i is \"0\":\\n                complement+=\"1\"\\n            else:\\n                complement+=\"0\"\\n        return int(complement,2)\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int findComplement(int num) {\\n        int result = 0;\\n        int set = 1;\\n        while(num != 0) {\\n            if((num&1)== 0) {\\n                result |= set;\\n            }\\n            set <<= 1;\\n            num >>= 1;\\n        }\\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def findComplement(self, num: int) -> int:\\n        complement=\"\"\\n        for i in bin(num)[2:]:\\n            if i is \"0\":\\n                complement+=\"1\"\\n            else:\\n                complement+=\"0\"\\n        return int(complement,2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2548233,
                "title": "0ms-c-easy-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int findComplement(int &num) {\\n        int ans = 0;\\n        int i = 0;\\n        while(num){\\n            ans += (((num&1)^1)<<i);\\n            i++;\\n            num = num >> 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findComplement(int &num) {\\n        int ans = 0;\\n        int i = 0;\\n        while(num){\\n            ans += (((num&1)^1)<<i);\\n            i++;\\n            num = num >> 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2512805,
                "title": "java-string-simple-solution",
                "content": "```\\nclass Solution {\\n    public int findComplement(int n) {\\n        String str = Integer.toBinaryString(n);\\n        str=str.replace(\"0\",\"*\");\\n        str=str.replace(\"1\",\"0\");\\n        str=str.replace(\"*\",\"1\");\\n        return Integer.parseInt(str,2);\\n    }\\n}\\n```\\nKindly upvote if you like the code.",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int findComplement(int n) {\\n        String str = Integer.toBinaryString(n);\\n        str=str.replace(\"0\",\"*\");\\n        str=str.replace(\"1\",\"0\");\\n        str=str.replace(\"*\",\"1\");\\n        return Integer.parseInt(str,2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2447953,
                "title": "python-simple-original-solution-o-n-complexity",
                "content": "The idea is to find the closest number to n that can be writen as power of two: `2^x`. Let\\'s call it `total`. The answer to the problem is: `total - n - 1`. \\nFor example: \\n- The complement of 3 is 4 - 3 - 1 = 0\\n- The complement of 5 is 8 - 5 - 1 = 2\\n\\n```\\ndef findComplement(self, n: int) -> int:\\n        if n < 2: return int(not n)\\n        \\n        total = 1\\n        while total <= n:\\n            total *= 2\\n            \\n        return total - n - 1",
                "solutionTags": [],
                "code": "The idea is to find the closest number to n that can be writen as power of two: `2^x`. Let\\'s call it `total`. The answer to the problem is: `total - n - 1`. \\nFor example: \\n- The complement of 3 is 4 - 3 - 1 = 0\\n- The complement of 5 is 8 - 5 - 1 = 2\\n\\n```\\ndef findComplement(self, n: int) -> int:\\n        if n < 2: return int(not n)\\n        \\n        total = 1\\n        while total <= n:\\n            total *= 2\\n            \\n        return total - n - 1",
                "codeTag": "Python3"
            },
            {
                "id": 2331368,
                "title": "c-100-faster-math-very-easy-code",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        long n=1;\\n        while(n-1<num)\\n        {\\n            n<<=1;\\n        }\\n        n--;\\n        return n-num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        long n=1;\\n        while(n-1<num)\\n        {\\n            n<<=1;\\n        }\\n        n--;\\n        return n-num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2044291,
                "title": "simple-and-basic-approach-in-java-0ms",
                "content": "**Algorithm**\\n* Convert the decimal number to binary. But add complement number immediately.\\n* Convert the decimal string back to integer number.\\n```\\npublic int findComplement(int num) {\\n        String comp = \"\";\\n        while(num != 0){\\n            if(num%2 == 1) comp = \\'0\\'+comp;\\n            else comp = \\'1\\'+comp;\\n            num/= 2;\\n        }\\n        \\n        int res = 0;\\n        for(int i=comp.length()-1; i>=0; i--){\\n            int temp = comp.charAt(i)-\\'0\\';\\n            res+= temp*Math.pow(2, comp.length()-i-1);\\n        }\\n        return res;\\n    }\\n```\\n**Please upvote if you liked the solution**\\n*Feel free to ask any questions in the comment section*",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int findComplement(int num) {\\n        String comp = \"\";\\n        while(num != 0){\\n            if(num%2 == 1) comp = \\'0\\'+comp;\\n            else comp = \\'1\\'+comp;\\n            num/= 2;\\n        }\\n        \\n        int res = 0;\\n        for(int i=comp.length()-1; i>=0; i--){\\n            int temp = comp.charAt(i)-\\'0\\';\\n            res+= temp*Math.pow(2, comp.length()-i-1);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1881157,
                "title": "python-normal-solution",
                "content": "```\\nclass Solution:\\n    def findComplement(self, num: int) -> int:\\n        i = 1\\n        while i <= num:\\n            i = i*2\\n        return (i - 1) ^ num\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findComplement(self, num: int) -> int:\\n        i = 1\\n        while i <= num:\\n            i = i*2\\n        return (i - 1) ^ num\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875598,
                "title": "number-complement-solution-java",
                "content": "class Solution {\\n  public int findComplement(int num) {\\n    for (long i = 1; i <= num; i <<= 1)\\n      num ^= i;\\n    return num;\\n  }\\n}\\n",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n  public int findComplement(int num) {\\n    for (long i = 1; i <= num; i <<= 1)\\n      num ^= i;\\n    return num;\\n  }",
                "codeTag": "Java"
            },
            {
                "id": 1739817,
                "title": "number-complement-java-solution",
                "content": "```\\nclass Solution {\\n    public int findComplement(int num) {\\n        String bit=Integer.toBinaryString(num);   \\n        String binaryNumber=\"\";\\n        for(int i=0;i<bit.length();i++){\\n            if(bit.charAt(i)==\\'0\\')\\n                binaryNumber+=\\'1\\';\\n            else\\n                binaryNumber+=\\'0\\';\\n        }\\n        return Integer.parseInt(binaryNumber, 2);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findComplement(int num) {\\n        String bit=Integer.toBinaryString(num);   \\n        String binaryNumber=\"\";\\n        for(int i=0;i<bit.length();i++){\\n            if(bit.charAt(i)==\\'0\\')\\n                binaryNumber+=\\'1\\';\\n            else\\n                binaryNumber+=\\'0\\';\\n        }\\n        return Integer.parseInt(binaryNumber, 2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1666793,
                "title": "java-easy-solution",
                "content": "Upvote if you like it!\\n```\\nclass Solution {\\n    public int findComplement(int n) {\\n        int ans=0;\\n        int count=1;\\n        while(n>0){\\n            ans+=count*(n%2==0?1:0);\\n            count*=2;\\n            n/=2;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findComplement(int n) {\\n        int ans=0;\\n        int count=1;\\n        while(n>0){\\n            ans+=count*(n%2==0?1:0);\\n            count*=2;\\n            n/=2;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1666063,
                "title": "2ms-100-faster-c",
                "content": "```\\nint findComplement(int num) {\\n        int msb = (int)(log2(num));\\n        if(num ==0){return 1;}\\n        int sum = 0;\\n        for(int i=msb; i>=0;i--){\\n            if(num &(1<<i)){\\n                continue;\\n            }else{\\n                sum+=pow(2,i);\\n            }\\n        }\\n        return sum;\\n        \\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint findComplement(int num) {\\n        int msb = (int)(log2(num));\\n        if(num ==0){return 1;}\\n        int sum = 0;\\n        for(int i=msb; i>=0;i--){\\n            if(num &(1<<i)){\\n                continue;\\n            }else{\\n                sum+=pow(2,i);\\n            }\\n        }\\n        return sum;\\n        \\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1654194,
                "title": "simple-c-solution-without-bitmasking",
                "content": "Learning points:\\n1. xor with one is used to toggle the bits.\\n2. All bits of  2^n -1 will be set i.e. one. \\n```\\nclass Solution {\\npublic:\\n    int numberOfDigit(int num){\\n        int cnt =0;\\n        while(num){\\n            cnt++;\\n            num/=2;\\n        } \\n        return cnt;\\n    }\\n    int findComplement(int num) {\\n        int n = numberOfDigit(num);\\n        long long int x = pow(2,n);// long long int is taken to avoid overflow\\n        x--;\\n        return num^x;\\n    }\\n};\\n```\\n\\nCaution point: negation will not work because it will toggle the left zero bits to one. Since the input is signed int, so negation operation will also change the the number into negative.\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfDigit(int num){\\n        int cnt =0;\\n        while(num){\\n            cnt++;\\n            num/=2;\\n        } \\n        return cnt;\\n    }\\n    int findComplement(int num) {\\n        int n = numberOfDigit(num);\\n        long long int x = pow(2,n);// long long int is taken to avoid overflow\\n        x--;\\n        return num^x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1650286,
                "title": "c-100-faster-easiest-solution",
                "content": "![image](https://assets.leetcode.com/users/images/d713c768-34da-4f17-927c-48b00c676932_1640600822.565753.png)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    long long getNxtPowOf2(int n) {\\n        if((int)log2(n) == log2(n)) return n*2;\\n        long long pow = 1;\\n        while(pow<n) pow *= 2;\\n        return pow;\\n    }\\n            \\n    long long findComplement(int num) {\\n        return getNxtPowOf2(num) - num -1; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long getNxtPowOf2(int n) {\\n        if((int)log2(n) == log2(n)) return n*2;\\n        long long pow = 1;\\n        while(pow<n) pow *= 2;\\n        return pow;\\n    }\\n            \\n    long long findComplement(int num) {\\n        return getNxtPowOf2(num) - num -1; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1649973,
                "title": "python-simple-and-easy-solution",
                "content": "```\\nclass Solution:\\n    def findComplement(self, num: int) -> int:\\n        binary = list(bin(num))\\n        for i in range(2,len(binary)):\\n            if binary[i] == \"1\":\\n                binary[i] = \"0\"\\n            else:\\n                binary[i] = \"1\"\\n        res = \\'\\'.join(binary)\\n        return int(res,2)\\n            \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findComplement(self, num: int) -> int:\\n        binary = list(bin(num))\\n        for i in range(2,len(binary)):\\n            if binary[i] == \"1\":\\n                binary[i] = \"0\"\\n            else:\\n                binary[i] = \"1\"\\n        res = \\'\\'.join(binary)\\n        return int(res,2)\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1605240,
                "title": "easy-python-solution",
                "content": "```\\ndef findComplement(self, num: int) -> int:\\n        s=bin(num)[2:]\\n        binary=\"\"\\n        for i in range(len(s)):\\n            if s[i]==\"0\":\\n                binary+=\"1\"\\n            else:\\n                binary+=\"0\"\\n        return int(binary, 2)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef findComplement(self, num: int) -> int:\\n        s=bin(num)[2:]\\n        binary=\"\"\\n        for i in range(len(s)):\\n            if s[i]==\"0\":\\n                binary+=\"1\"\\n            else:\\n                binary+=\"0\"\\n        return int(binary, 2)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1450726,
                "title": "c-faster-than-100-00-space-lesser-than-97",
                "content": "Complement of any number can be found by subtracting it from 1111...(no of digits)\\n\\n```\\n int findComplement(int num) {\\n        if(!num)                //base case when num==0, ans=1\\n            return 1;\\n        \\n        int x=1;\\n        while(num>x)            //creating 1111........111\\n            x=(1+2*x);\\n        \\n        return abs(num-x);\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "Complement of any number can be found by subtracting it from 1111...(no of digits)\\n\\n```\\n int findComplement(int num) {\\n        if(!num)                //base case when num==0, ans=1\\n            return 1;\\n        \\n        int x=1;\\n        while(num>x)            //creating 1111........111\\n            x=(1+2*x);\\n        \\n        return abs(num-x);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1332396,
                "title": "easy-c-bit-manipulation",
                "content": "class Solution {\\npublic:\\n    int findComplement(int num) {\\n       int k = log2(num);\\n        for(int i = k ; i >= 0; i--){\\n            num = (num ^ (1 << i));\\n        }\\n        return num;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findComplement(int num) {\\n       int k = log2(num);\\n        for(int i = k ; i >= 0; i--){\\n            num = (num ^ (1 << i));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1265078,
                "title": "rust",
                "content": "```\\nimpl Solution {\\n    pub fn find_complement(num: i32) -> i32 {\\n        let mut bits = 0;\\n        for i in 0..((num as f64).log2().ceil() as i32) {\\n            bits |= (1 << i);\\n        }\\n        \\n        !num & bits\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn find_complement(num: i32) -> i32 {\\n        let mut bits = 0;\\n        for i in 0..((num as f64).log2().ceil() as i32) {\\n            bits |= (1 << i);\\n        }\\n        \\n        !num & bits\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1227505,
                "title": "java-100-faster-solution",
                "content": "```\\nclass Solution {\\n    public int findComplement(int num) {\\n        int k = (int) (Math.log(num) / Math.log(2));\\n        for (int i = 0; i <= k; i++) {\\n            int x = 1 << i;\\n            num = num ^ x;\\n        }\\n        return num;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findComplement(int num) {\\n        int k = (int) (Math.log(num) / Math.log(2));\\n        for (int i = 0; i <= k; i++) {\\n            int x = 1 << i;\\n            num = num ^ x;\\n        }\\n        return num;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1222016,
                "title": "python-solution",
                "content": "**Solution 1:**\\n\\n    def findComplement(self, num: int) -> int:\\n        import math\\n        bits = (int)(math.floor(math.log(num) / math.log(2))) + 1;\\n        return ((1 << bits) - 1) ^ num;\\n\\n**Solution 2:**\\n\\n    def findComplement(self, num: int) -> int:\\n        complement=\"\"\\n        for i in bin(num)[2:]:\\n            if i is \"0\":\\n                complement+=\"1\"\\n            else:\\n                complement+=\"0\"\\n                \\n        return int(complement,2)",
                "solutionTags": [],
                "code": "**Solution 1:**\\n\\n    def findComplement(self, num: int) -> int:\\n        import math\\n        bits = (int)(math.floor(math.log(num) / math.log(2))) + 1;\\n        return ((1 << bits) - 1) ^ num;\\n\\n**Solution 2:**\\n\\n    def findComplement(self, num: int) -> int:\\n        complement=\"\"\\n        for i in bin(num)[2:]:\\n            if i is \"0\":\\n                complement+=\"1\"\\n            else:\\n                complement+=\"0\"\\n                \\n        return int(complement,2)",
                "codeTag": "Python3"
            },
            {
                "id": 1211688,
                "title": "100-memory-and-100-space-better-than-all-c-solutions-o-1-time-and-o-1-space",
                "content": "```\\npublic class Solution {\\n    public int FindComplement(int num) {\\n        for(int i = 1; 0 < i && i <= num; i <<= 1) {\\n            num ^= i;\\n        }\\n        return num;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int FindComplement(int num) {\\n        for(int i = 1; 0 < i && i <= num; i <<= 1) {\\n            num ^= i;\\n        }\\n        return num;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1179737,
                "title": "fast-java-solution",
                "content": "```\\nint numOfBits = (int)(Math.log(num)/Math.log(2)+1);\\n        for(int i = 0; i < numOfBits; i++){\\n          num= num ^ 1 << i ;\\n        }\\n        return num;\\n```",
                "solutionTags": [],
                "code": "```\\nint numOfBits = (int)(Math.log(num)/Math.log(2)+1);\\n        for(int i = 0; i < numOfBits; i++){\\n          num= num ^ 1 << i ;\\n        }\\n        return num;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1101585,
                "title": "python3-xor-based-solution",
                "content": "simple series of 3 operations - get number of bits (n) in binary rep of num, use that to find the number of form [1....1] with binary rep length = n, xor both.\\n```\\ndef findComplement(self, num: int) -> int:\\n        #the xor of a num and its complement = 1 for each digit in binary rep of num\\n        #therefore xor of a num and the number with the same number of digits as num in binary rep\\n        #but with all digits equal to 1 will give complement.\\n        #should be close to constant time\\n        \\n        #find number of digits in num\\'s binary rep\\n        binlength = floor(log(num, 2)) + 1\\n        #find number corresponding to binary string of that length\\n        onestring = pow(2, binlength) - 1\\n        #xor \\n        return onestring ^ num\\n\\t```",
                "solutionTags": [],
                "code": "```\\ndef findComplement(self, num: int) -> int:\\n        #the xor of a num and its complement = 1 for each digit in binary rep of num\\n        #therefore xor of a num and the number with the same number of digits as num in binary rep\\n        #but with all digits equal to 1 will give complement.\\n        #should be close to constant time\\n        \\n        #find number of digits in num\\'s binary rep\\n        binlength = floor(log(num, 2)) + 1\\n        #find number corresponding to binary string of that length\\n        onestring = pow(2, binlength) - 1\\n        #xor \\n        return onestring ^ num\\n\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 1059500,
                "title": "golang-solution-faster-than-100-bit-manipulation",
                "content": "```\\nfunc findComplement(num int) int {\\n\\tif num == 0 {\\n\\t\\treturn 1\\n\\t}\\n\\tres := 0\\n\\tg := 1\\n\\tfor num > 0 {\\n\\t\\tif num&1 == 0 {\\n\\t\\t\\tres += g\\n\\t\\t}\\n\\t\\tg <<= 1\\n\\t\\tnum >>= 1\\n\\t}\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Bit Manipulation"
                ],
                "code": "```\\nfunc findComplement(num int) int {\\n\\tif num == 0 {\\n\\t\\treturn 1\\n\\t}\\n\\tres := 0\\n\\tg := 1\\n\\tfor num > 0 {\\n\\t\\tif num&1 == 0 {\\n\\t\\t\\tres += g\\n\\t\\t}\\n\\t\\tg <<= 1\\n\\t\\tnum >>= 1\\n\\t}\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 990492,
                "title": "python-one-line-solution-without-list-comprehension-92-faster",
                "content": "```\\nclass Solution:\\n    def findComplement(self, num: int) -> int:\\n        return (1<<len(bin(num))-2) -1 - num  \\n```\\nIf you get it please Upvote\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findComplement(self, num: int) -> int:\\n        return (1<<len(bin(num))-2) -1 - num  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 889679,
                "title": "java-0-ms-faster-than-100-00-with-video-explanation",
                "content": "Video Explanation:\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/6bp5V-O3zts\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\\n\\n**JAVA**\\n\\n```\\nclass Solution {\\n    public int findComplement(int num) {\\n        \\n        int numberOfBits = numberOfBits(num);\\n        \\n        return num ^ ((1 << numberOfBits) - 1);\\n    }\\n    \\n    /**\\n    * Method to find out the total number of bits in a number.\\n    **/\\n    public static int numberOfBits(int num){\\n        int countOfBits = 0;\\n        \\n        while(num != 0){\\n            num = num >> 1;\\n            countOfBits++;\\n        }\\n        \\n        return countOfBits;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findComplement(int num) {\\n        \\n        int numberOfBits = numberOfBits(num);\\n        \\n        return num ^ ((1 << numberOfBits) - 1);\\n    }\\n    \\n    /**\\n    * Method to find out the total number of bits in a number.\\n    **/\\n    public static int numberOfBits(int num){\\n        int countOfBits = 0;\\n        \\n        while(num != 0){\\n            num = num >> 1;\\n            countOfBits++;\\n        }\\n        \\n        return countOfBits;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 880155,
                "title": "simple-c-o-1-solution",
                "content": "Lets take a example. Num is 10 => 0b1010\\nwe now need to invert the 1s to 0s\\nactually , the number is stored as \"0b0000000......0001010\" in unint32_t.\\nif we directly invert the number , we will also shift the preceeding 0s to 1s.\\nwe can flip only the bits in our number if we have some kind of mask that is \\'0b0000000000...0001111\\'\\nto get the mask , we can calculate the MSB position as floor(log2(num)) . here , msb position is 4 \\nthen,to create the mask , we do left shift opertation on \"0b1111111111...1111\" to get \"0b0000000...1111\"\\n\\nnow we invert the original Number and then perform And operation with the mask to set the preceeding 1s to 0\\n0b0000000....1111 & 0b111111....0101 = 0b00000000......0101\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(uint32_t N) {\\n        if(N==0)\\n            return 1;\\n        uint32_t msbPos = log2(N); //get msb 1 position \\n        uint32_t mask = INT_MAX>>(31-msbPos); //get 1s mask on the required number\\n        uint32_t invert = ~N;  //Flip all the bits in original number\\n        return invert&mask;  //set the preceeding 1s to 0s using mask\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int bitwiseComplement(uint32_t N) {\\n        if(N==0)\\n            return 1;\\n        uint32_t msbPos = log2(N); //get msb 1 position \\n        uint32_t mask = INT_MAX>>(31-msbPos); //get 1s mask on the required number\\n        uint32_t invert = ~N;  //Flip all the bits in original number\\n        return invert&mask;  //set the preceeding 1s to 0s using mask\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 872872,
                "title": "algorithm-with-python",
                "content": "```\\ndef findComplement(self, a: int) -> int:\\n        return int(\\'0b\\'+\\'\\'.join([str(int(x)^1) for x in bin(a)[2:]]), 2)\\n```\\nStep 1 : Convert input number to binary => bin(a)\\nStep 2: XOR each of bit with 1 => int(x)^1 ( 1^1=0 and 0^1=1)\\nStep 3: Sum string in list with \\'\\'.join(list)\\nStep 4. Convert binary string to integer: int(<binary_string>, 2)\\n=> DONE !",
                "solutionTags": [],
                "code": "```\\ndef findComplement(self, a: int) -> int:\\n        return int(\\'0b\\'+\\'\\'.join([str(int(x)^1) for x in bin(a)[2:]]), 2)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 871191,
                "title": "3-line-solution-c-0-ms",
                "content": "```\\n        int totalBits = std::floor(log2(num) + 1);\\n        int mask = (1 << (totalBits-1));\\n        return (num ^ (mask | (mask - 1)));\\n```\\n\\nLets understand this with an example:\\n\\nExample: \\n\\t\\t\\t\\t\\tint n = 5;\\n\\t\\t\\t\\t\\tBinary (5) = 1 0 1;\\n\\t\\t\\t\\t\\t\\nFirst line count total number of bits...\\n\\ntotalBits = 3;            // 1, 0, 1 total 3 bits\\n\\n\\nSecond line makes a mask which will help in XOR\\n\\nmask = ( 1 << (3 - 1) ) \\n\\t\\t\\t=> ( 1 << 2 )\\n\\t\\t\\t=> 1 0 0\\n\\nThird line XOR ( Binary(n) with ( mask | mask - 1 )\\n\\nmask - 1 = ( 1 0 0 - 1 )\\n\\t\\t\\t\\t  => 0 1 1\\n\\t\\t\\t\\t  \\nso, finally answer will be:\\n1 0 1 ^ ( 1 0 0 | 0 1 1)\\n=> 1 0 1 ^ 1 1 1\\n=> 0 1 0 (Answer)",
                "solutionTags": [],
                "code": "```\\n        int totalBits = std::floor(log2(num) + 1);\\n        int mask = (1 << (totalBits-1));\\n        return (num ^ (mask | (mask - 1)));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 867037,
                "title": "easy-solution-with-explanation-without-bit-manipulation",
                "content": "This might not be as fast as bit manipulation, but it is easier to understand for those who are not that good with binary (like me).\\n```\\nclass Solution {\\n    public int findComplement(int num) {\\n        StringBuilder sb = new StringBuilder();\\n        while (num > 0) {\\n            int lsb = num % 2; // get the least significant bit (LSB) of the number\\n            if (lsb == 1) sb.append(0); // switch values\\n            if (lsb == 0) sb.append(1);\\n            num /= 2; // divide by 2 to remove the current LSB\\n        }\\n        return Integer.parseInt(sb.reverse().toString(), 2); // since we\\'re \\'appending\\' and not \\'prepending\\' we need to reverse the String\\n    }\\n}\\n```\\n\\nThe two conditions where we check for `1` or `0` can be replaced with `sb.append((lsb == 1) ? 0 : 1);`.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findComplement(int num) {\\n        StringBuilder sb = new StringBuilder();\\n        while (num > 0) {\\n            int lsb = num % 2; // get the least significant bit (LSB) of the number\\n            if (lsb == 1) sb.append(0); // switch values\\n            if (lsb == 0) sb.append(1);\\n            num /= 2; // divide by 2 to remove the current LSB\\n        }\\n        return Integer.parseInt(sb.reverse().toString(), 2); // since we\\'re \\'appending\\' and not \\'prepending\\' we need to reverse the String\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 842161,
                "title": "javascript-one-liner",
                "content": "```\\n/**\\n * @param {number} num\\n * @return {number}\\n */\\nvar findComplement = function(num) {\\n    return parseInt(num.toString(2).split(\\'\\').reduce((curr, acc) => {\\n        curr += acc === \\'1\\' ? \\'0\\' : \\'1\\'\\n        return curr\\n    },\\'\\'), 2)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} num\\n * @return {number}\\n */\\nvar findComplement = function(num) {\\n    return parseInt(num.toString(2).split(\\'\\').reduce((curr, acc) => {\\n        curr += acc === \\'1\\' ? \\'0\\' : \\'1\\'\\n        return curr\\n    },\\'\\'), 2)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 819989,
                "title": "simple-python-beats-99",
                "content": "```\\ndef solution(num):\\n        closest_p_two = int(math.log2(num))+1\\n        return num ^ ((2**closest_p_two) -1)\\n```",
                "solutionTags": [],
                "code": "```\\ndef solution(num):\\n        closest_p_two = int(math.log2(num))+1\\n        return num ^ ((2**closest_p_two) -1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 761642,
                "title": "c-easy-solution-faster-than-100",
                "content": "class Solution {\\npublic:\\n    int findComplement(int num) {\\n        int power=(log(num)/log(2))+1;\\n        return (pow(2,power)-1-num);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findComplement(int num) {\\n        int power=(log(num)/log(2))+1;\\n        return (pow(2,power)-1-num);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 701750,
                "title": "python-simple-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def findComplement(self, num: int) -> int:\\n        ## RC ##\\n\\t\\t## APPROACH : BIT MANIPULATION ##\\n\\t\\t## LOGIC ##\\n\\t\\t#\\t1. 1 xor 1 = 0 and 0 or 1 = 1, from these we can say that XORing with 1 will give its complement bit\\n\\t\\t#\\t2. so, for 5 ==> 101, bitmask is 111, for 6 ==> 110, bitmask is 111, so bitmask is (length number of 1\\'s)\\n\\t\\t#\\t3. How do we length of given bit ? we use log function\\n\\t\\t#\\t4. (ex: for 5), we take 1 and left shift by length obtained from 3, i.e (1000) now, substract 1, it will give (111) ==> bitmask\\n\\t\\t\\n        ## TIME COMPLEXICITY : O(1) ## (coz make n= 32)\\n\\t\\t## SPACE COMPLEXICITY : O(1) ##\\n        \\n        n = floor(log2(num)) + 1        # n is a length of num in binary representation\\n        bitmask = (1 << n) - 1          # bitmask has the same length as num and contains only ones 1...1\\n        return bitmask ^ num\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findComplement(self, num: int) -> int:\\n        ## RC ##\\n\\t\\t## APPROACH : BIT MANIPULATION ##\\n\\t\\t## LOGIC ##\\n\\t\\t#\\t1. 1 xor 1 = 0 and 0 or 1 = 1, from these we can say that XORing with 1 will give its complement bit\\n\\t\\t#\\t2. so, for 5 ==> 101, bitmask is 111, for 6 ==> 110, bitmask is 111, so bitmask is (length number of 1\\'s)\\n\\t\\t#\\t3. How do we length of given bit ? we use log function\\n\\t\\t#\\t4. (ex: for 5), we take 1 and left shift by length obtained from 3, i.e (1000) now, substract 1, it will give (111) ==> bitmask\\n\\t\\t\\n        ## TIME COMPLEXICITY : O(1) ## (coz make n= 32)\\n\\t\\t## SPACE COMPLEXICITY : O(1) ##\\n        \\n        n = floor(log2(num)) + 1        # n is a length of num in binary representation\\n        bitmask = (1 << n) - 1          # bitmask has the same length as num and contains only ones 1...1\\n        return bitmask ^ num\\n```",
                "codeTag": "Java"
            },
            {
                "id": 695878,
                "title": "java-with-detailed-comments-100-time-98-space",
                "content": "```\\nclass Solution {\\n    public int findComplement(int num) {\\n        int result = 0;\\n        int power = 1;\\n        while(num > 0){ \\n            //you flip the bit by xor-ing with 1. \\n            //Ex: 1011 ^ 1111 = 0100\\n            result += (num%2 ^ 1)*power; //last bit ^ 1 * 2Power\\n            power <<= 1; //shifting bit to left, equivalent to multiplying by 2. \\n            num >>= 1; //shifting bit to right, equivalent to dividing by 2. we already compared last bit. \\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int findComplement(int num) {\\n        int result = 0;\\n        int power = 1;\\n        while(num > 0){ \\n            //you flip the bit by xor-ing with 1. \\n            //Ex: 1011 ^ 1111 = 0100\\n            result += (num%2 ^ 1)*power; //last bit ^ 1 * 2Power\\n            power <<= 1; //shifting bit to left, equivalent to multiplying by 2. \\n            num >>= 1; //shifting bit to right, equivalent to dividing by 2. we already compared last bit. \\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 614057,
                "title": "c-no-loop-solution-with-detailed-explanation",
                "content": "You can basically use logical negation operator `~` to invert bits, the only challenge is to mask the bits that you want, here\\'s a solution:\\n```\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n\\t\\t// 1) Find number of bits in input\\n         int bitCount = log2(abs(num)) + 1;\\n\\t\\t \\n\\t\\t // 2) Create a mask that should be all 1s\\n\\t\\t // e.g. if bitCount is 3, we want it to be 111 (aka 7 in decimal)\\n\\t\\t // to create mask you can left shift bits by bits count then subtract 1\\n\\t\\t // only issue is it will cause signed integer overflow if bit count is 31 becuase it will be INT_MIN - 1\\n\\t\\t // so we account for this case\\n         if(bitCount == 31) return INT_MAX - num;\\n\\t\\t \\n\\t\\t // create the mask as descriped above\\n         int mask = (1 << bitCount) - 1;\\n\\t\\t \\n\\t\\t // 3) Negate number and apply mask\\n         return (~num) & mask;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n\\t\\t// 1) Find number of bits in input\\n         int bitCount = log2(abs(num)) + 1;\\n\\t\\t \\n\\t\\t // 2) Create a mask that should be all 1s\\n\\t\\t // e.g. if bitCount is 3, we want it to be 111 (aka 7 in decimal)\\n\\t\\t // to create mask you can left shift bits by bits count then subtract 1\\n\\t\\t // only issue is it will cause signed integer overflow if bit count is 31 becuase it will be INT_MIN - 1\\n\\t\\t // so we account for this case\\n         if(bitCount == 31) return INT_MAX - num;\\n\\t\\t \\n\\t\\t // create the mask as descriped above\\n         int mask = (1 << bitCount) - 1;\\n\\t\\t \\n\\t\\t // 3) Negate number and apply mask\\n         return (~num) & mask;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 613550,
                "title": "c-4-lines-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        int res = 0;\\n        for(int shift = 0; num; ++shift, num >>= 1)\\n            res |= !(num & 1) << shift;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        int res = 0;\\n        for(int shift = 0; num; ++shift, num >>= 1)\\n            res |= !(num & 1) << shift;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 613002,
                "title": "no-bit-manipulation-0-ms-easy-solution",
                "content": "```\\n int findComplement(int num) {\\n        if(num==0) return 1;\\n        if(num==1) return 0;\\n        if(num==INT_MAX) return 0;\\n        int i=0;\\n       int complement=0;\\n        while(num)\\n        {\\n            if(num%2==0) complement+=pow(2,i);\\n            num/=2;\\n            i++;\\n        }\\n        return complement;\\n    }\\n\\t",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n int findComplement(int num) {\\n        if(num==0) return 1;\\n        if(num==1) return 0;\\n        if(num==INT_MAX) return 0;\\n        int i=0;\\n       int complement=0;\\n        while(num)\\n        {\\n            if(num%2==0) complement+=pow(2,i);\\n            num/=2;\\n            i++;\\n        }\\n        return complement;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 612922,
                "title": "java-1-line-code-100-fast",
                "content": "```\\nclass Solution {\\n    public int findComplement(int num) {\\n        return num ^ ((1 << Integer.toBinaryString(num).length()) -1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findComplement(int num) {\\n        return num ^ ((1 << Integer.toBinaryString(num).length()) -1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 612510,
                "title": "c-with-xor",
                "content": "```\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        if (num == 0)\\n            return 1;\\n\\n        for (long i = 1; i <= num; i *= 2)\\n        {\\n            num ^= i;\\n        }\\n        return num;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        if (num == 0)\\n            return 1;\\n\\n        for (long i = 1; i <= num; i *= 2)\\n        {\\n            num ^= i;\\n        }\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 612417,
                "title": "2-java-simple-solutions-with-comments-100-runtime",
                "content": "```\\n1st solution:-\\n\\nclass Solution {\\n    public int findComplement(int num) {\\n        int i = 0, res = 0;\\n        while(num > 0){\\n            // if last bit of num is 0, then we need to take complement of it\\n            // so, add corresponding pow to res.\\n            if((1 & num) == 0) res += Math.pow(2, i);\\n            i++;\\n            num = num >> 1;\\n        }\\n        return res;\\n    }\\n}\\n\\n2nd solution:-\\n// same logic as above solution. but different implementation\\nclass Solution {\\n    public int findComplement(int num) {\\n        int power = 1, res = 0;\\n        while(num > 0){\\n            res += ((1 & num) ^ 1) * power;\\n            power <<= 1;\\n            num >>= 1;\\n        }\\n        return res;\\n    }\\n}\\n```\\n**If you have any doubts, feel free to ask.\\n   if you understand, don\\'t forget to upvote \\u25C9\\u203F\\u25C9**",
                "solutionTags": [],
                "code": "```\\n1st solution:-\\n\\nclass Solution {\\n    public int findComplement(int num) {\\n        int i = 0, res = 0;\\n        while(num > 0){\\n            // if last bit of num is 0, then we need to take complement of it\\n            // so, add corresponding pow to res.\\n            if((1 & num) == 0) res += Math.pow(2, i);\\n            i++;\\n            num = num >> 1;\\n        }\\n        return res;\\n    }\\n}\\n\\n2nd solution:-\\n// same logic as above solution. but different implementation\\nclass Solution {\\n    public int findComplement(int num) {\\n        int power = 1, res = 0;\\n        while(num > 0){\\n            res += ((1 & num) ^ 1) * power;\\n            power <<= 1;\\n            num >>= 1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 611150,
                "title": "simple-python-solution-one-liner",
                "content": "```\\nreturn num ^ (1 << num.bit_length())-1\\n```\\n\\nFor the case of num=5, binary \\'101\\',\\n1 << num.bit_length() gives 2 to the power of bit length, which equals to 16 or \\'1000\\' in binary representation, taking this number - 1 gives \\'111\\' in binary representation.\\n\\n\\'101\\' XOR \\'111\\' = \\'010\\'\\n",
                "solutionTags": [],
                "code": "```\\nreturn num ^ (1 << num.bit_length())-1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 481005,
                "title": "c",
                "content": "```\\npublic int FindComplement(int num)\\n\\t=> num ^ ((int)Math.Pow(2, (int)Math.Log(num, 2) + 1) - 1);\\n```",
                "solutionTags": [],
                "code": "```\\npublic int FindComplement(int num)\\n\\t=> num ^ ((int)Math.Pow(2, (int)Math.Log(num, 2) + 1) - 1);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 453137,
                "title": "java-easy-solution-with-explanation-beats-100",
                "content": "```\\npublic int findComplement(int num) {\\n\\tint n = 0;                 // this will be the solution\\n\\tint shifts = 0;\\n\\twhile(num!=0) {\\n\\t\\tint cur = num&1;       //Least significant digit\\n\\t\\tif (cur == 0)          //Only need to add one when get 0 as least significant digit\\n\\t\\t\\tn += (1<<shifts);  //Shift 1 by number of shifts before adding to result\\n\\t\\tshifts++;              //Increment shifts for each digit in the number\\n\\t\\tnum >>= 1;             // Right shift the number or divide it by 2 to get the next digit in next iteration.\\n\\t}\\n\\treturn n;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int findComplement(int num) {\\n\\tint n = 0;                 // this will be the solution\\n\\tint shifts = 0;\\n\\twhile(num!=0) {\\n\\t\\tint cur = num&1;       //Least significant digit\\n\\t\\tif (cur == 0)          //Only need to add one when get 0 as least significant digit\\n\\t\\t\\tn += (1<<shifts);  //Shift 1 by number of shifts before adding to result\\n\\t\\tshifts++;              //Increment shifts for each digit in the number\\n\\t\\tnum >>= 1;             // Right shift the number or divide it by 2 to get the next digit in next iteration.\\n\\t}\\n\\treturn n;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 450983,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def findComplement(self, num: int) -> int:\\n        if num==0 or num==1:\\n            return abs(num-1)\\n        s = int(\"1\"*num.bit_length(),2)\\n        return num^s\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findComplement(self, num: int) -> int:\\n        if num==0 or num==1:\\n            return abs(num-1)\\n        s = int(\"1\"*num.bit_length(),2)\\n        return num^s\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565131,
                "content": [
                    {
                        "username": "ammarshareef",
                        "content": "Alright, I really want you to first understand the basic concepts and then I will try my best to break down the problem and explain step by step.\\n\\nMy aim is to make you understand the problem so that you can learn and CODE yourself.\\n\\n**Understanding the Problem Statement**\\n\\n**INPUT**      1 0 1  - 5\\n**OUTPUT**    0 1 0 - 2 *just flipping the bits as you can see. 1 transforms to 0 and 0 to 1. thats it!*\\n\\n\\n**STEPS**\\n\\n1. The first thing that should come to your mind when you want the opposite of any bit is the great XOR operation. Remember the simple rule of XOR. Whenever there is a bit say 1 ^ 0 , 0 ^ 1 then you will always get 1. Rest everytime you get 0.\\n2. Next, you need to figure the bit mask to get the result. Lets take the example of the input - 101 and output 010.\\nso if you XOR these two number then you get your mask required.  Example - (101) ^ (010) = 111 which is 7.\\nSo, if you do 101 ^ 111 = 010 and thats the answer or the output we want! So this is how you got your ** mask**\\n3. Now that you have the mask you just have to convert this logic into meaningful code so that it works for any input.\\none simple formula is. (2Power3)- 1. This will give you 8 AND THEN -1 WILL GIVE YOU **7**. Notice that 3 is the number of bits in the number.\\n4. Just do 101 ^ (2Power3)-1 and thats your output answer.\\n\\n**TASK 1**\\n1. Our first task is to find the number of bits a number has. For this we will run a while  loop till the number becomes 0.\\nYou can do this by taking the MSB (the first bit from the left side) and shift it one time. You can also take the LSB.\\n2. something like this while(num!-0) we do num = (num>>1) and COUNT THE NUMBER OF ITERATIONS, THAT WILL BE THE NUMBER OF BITS IN A NUMBER. THIS WILL GIVE US THE POWER.\\n\\n**TASK 2**\\n1. Now you know what the power is going to be for your number (2(Power)count)-1. Is what you have to do.\\n\\n**TASK 3**\\n1. Just XOR NUM with (2(Power)count) -1 and you will get the result.\\n\\nNOTE: YOU NEED TO SAVE THE NUM IN A TEMP VARIABLE BECASUE THE VALUE OF NUM WILL CHANGE TO 0 UPON DOING THE RIGHT SHIFT OPERATION. SO AT THE END JUST DO RESULT  = (TEMP ^ (2(POWER)COUNT)-1).\\n\\n2 POWER Count is basically 2 being the base and count being the Exponent. I could have used 2^3 to explain but this alsoc could confuse you between the XOR operation.\\n\\n**PRO TIP**\\n\\n2(Power)COUNT IS SAME AS (1<<COUNT)\\nSO BASICALLY YOU HAVE TO DO RESULT  = TEMP ^ (1<<COUNT) - 1;\\n\\nRETURN TEMP AND YOUR DONE.\\nCHEERS!\\n\\n\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-complement/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flip Bit by Bit\n\n  \n**Approach 2:** Compute Bit Length and Construct 1-bits Bitmask\n\n  \n**Approach 3:** Built-in Functions to Construct 1-bits Bitmask\n\n  \n**Approach 4:** highestOneBit OpenJDK algorithm from Hacker's Delight\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "LTKJ",
                        "content": "My solution to Number Complement was judged wrongly.\\n[Here is my submission result.](https://leetcode.com/contest/leetcode-weekly-contest-14/submissions/detail/88323029/) However, when I copied my code and test case to the problem, I got the correct answer.\\n\\n**UPD:** Fixed, thanks Leetcode Team."
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "int findComplement(int num) {\\n        \\n        if(num == 0) return 1;\\n\\n        int ans = 0;\\n        int i = 0;\\n\\n        while(num) {\\n\\n            if(num % 2 == 0) {\\n                ans += pow(2, i);\\n            }\\n\\n            i++;\\n            num /= 2;\\n        }\\n\\n        return ans;\\n}"
                    },
                    {
                        "username": "JoshDev",
                        "content": "num ^ ((Integer.highestOneBit(num) << 1) - 1);"
                    },
                    {
                        "username": "SagaciousB",
                        "content": "Please do not post solutions in the discussion."
                    },
                    {
                        "username": "W.S.YangGuang",
                        "content": "return (((unsigned)1 << (32 - __builtin_clz(num))) - 1) ^ num;\\n\\nusing g++ built in function to count the number of leading zeros."
                    },
                    {
                        "username": "pa-one55",
                        "content": "used vector for storing bits, negate bits, re construct\\n"
                    },
                    {
                        "username": "sonergonul",
                        "content": "For Turkish users, if you have a trouble to understand, here is the explanation;\\n\\nhttps://youtu.be/dHmcZidc37g"
                    },
                    {
                        "username": "justyy",
                        "content": "Nearly the same as https://leetcode.com/problems/complement-of-base-10-integer/\\njust need to handle the case when N=0"
                    },
                    {
                        "username": "kille6525",
                        "content": "'''return ~num & ((1 << (int)Math.Log(num,2)) - 1);'''"
                    }
                ]
            },
            {
                "id": 1565642,
                "content": [
                    {
                        "username": "ammarshareef",
                        "content": "Alright, I really want you to first understand the basic concepts and then I will try my best to break down the problem and explain step by step.\\n\\nMy aim is to make you understand the problem so that you can learn and CODE yourself.\\n\\n**Understanding the Problem Statement**\\n\\n**INPUT**      1 0 1  - 5\\n**OUTPUT**    0 1 0 - 2 *just flipping the bits as you can see. 1 transforms to 0 and 0 to 1. thats it!*\\n\\n\\n**STEPS**\\n\\n1. The first thing that should come to your mind when you want the opposite of any bit is the great XOR operation. Remember the simple rule of XOR. Whenever there is a bit say 1 ^ 0 , 0 ^ 1 then you will always get 1. Rest everytime you get 0.\\n2. Next, you need to figure the bit mask to get the result. Lets take the example of the input - 101 and output 010.\\nso if you XOR these two number then you get your mask required.  Example - (101) ^ (010) = 111 which is 7.\\nSo, if you do 101 ^ 111 = 010 and thats the answer or the output we want! So this is how you got your ** mask**\\n3. Now that you have the mask you just have to convert this logic into meaningful code so that it works for any input.\\none simple formula is. (2Power3)- 1. This will give you 8 AND THEN -1 WILL GIVE YOU **7**. Notice that 3 is the number of bits in the number.\\n4. Just do 101 ^ (2Power3)-1 and thats your output answer.\\n\\n**TASK 1**\\n1. Our first task is to find the number of bits a number has. For this we will run a while  loop till the number becomes 0.\\nYou can do this by taking the MSB (the first bit from the left side) and shift it one time. You can also take the LSB.\\n2. something like this while(num!-0) we do num = (num>>1) and COUNT THE NUMBER OF ITERATIONS, THAT WILL BE THE NUMBER OF BITS IN A NUMBER. THIS WILL GIVE US THE POWER.\\n\\n**TASK 2**\\n1. Now you know what the power is going to be for your number (2(Power)count)-1. Is what you have to do.\\n\\n**TASK 3**\\n1. Just XOR NUM with (2(Power)count) -1 and you will get the result.\\n\\nNOTE: YOU NEED TO SAVE THE NUM IN A TEMP VARIABLE BECASUE THE VALUE OF NUM WILL CHANGE TO 0 UPON DOING THE RIGHT SHIFT OPERATION. SO AT THE END JUST DO RESULT  = (TEMP ^ (2(POWER)COUNT)-1).\\n\\n2 POWER Count is basically 2 being the base and count being the Exponent. I could have used 2^3 to explain but this alsoc could confuse you between the XOR operation.\\n\\n**PRO TIP**\\n\\n2(Power)COUNT IS SAME AS (1<<COUNT)\\nSO BASICALLY YOU HAVE TO DO RESULT  = TEMP ^ (1<<COUNT) - 1;\\n\\nRETURN TEMP AND YOUR DONE.\\nCHEERS!\\n\\n\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-complement/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flip Bit by Bit\n\n  \n**Approach 2:** Compute Bit Length and Construct 1-bits Bitmask\n\n  \n**Approach 3:** Built-in Functions to Construct 1-bits Bitmask\n\n  \n**Approach 4:** highestOneBit OpenJDK algorithm from Hacker's Delight\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "LTKJ",
                        "content": "My solution to Number Complement was judged wrongly.\\n[Here is my submission result.](https://leetcode.com/contest/leetcode-weekly-contest-14/submissions/detail/88323029/) However, when I copied my code and test case to the problem, I got the correct answer.\\n\\n**UPD:** Fixed, thanks Leetcode Team."
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "int findComplement(int num) {\\n        \\n        if(num == 0) return 1;\\n\\n        int ans = 0;\\n        int i = 0;\\n\\n        while(num) {\\n\\n            if(num % 2 == 0) {\\n                ans += pow(2, i);\\n            }\\n\\n            i++;\\n            num /= 2;\\n        }\\n\\n        return ans;\\n}"
                    },
                    {
                        "username": "JoshDev",
                        "content": "num ^ ((Integer.highestOneBit(num) << 1) - 1);"
                    },
                    {
                        "username": "SagaciousB",
                        "content": "Please do not post solutions in the discussion."
                    },
                    {
                        "username": "W.S.YangGuang",
                        "content": "return (((unsigned)1 << (32 - __builtin_clz(num))) - 1) ^ num;\\n\\nusing g++ built in function to count the number of leading zeros."
                    },
                    {
                        "username": "pa-one55",
                        "content": "used vector for storing bits, negate bits, re construct\\n"
                    },
                    {
                        "username": "sonergonul",
                        "content": "For Turkish users, if you have a trouble to understand, here is the explanation;\\n\\nhttps://youtu.be/dHmcZidc37g"
                    },
                    {
                        "username": "justyy",
                        "content": "Nearly the same as https://leetcode.com/problems/complement-of-base-10-integer/\\njust need to handle the case when N=0"
                    },
                    {
                        "username": "kille6525",
                        "content": "'''return ~num & ((1 << (int)Math.Log(num,2)) - 1);'''"
                    }
                ]
            },
            {
                "id": 1566513,
                "content": [
                    {
                        "username": "ammarshareef",
                        "content": "Alright, I really want you to first understand the basic concepts and then I will try my best to break down the problem and explain step by step.\\n\\nMy aim is to make you understand the problem so that you can learn and CODE yourself.\\n\\n**Understanding the Problem Statement**\\n\\n**INPUT**      1 0 1  - 5\\n**OUTPUT**    0 1 0 - 2 *just flipping the bits as you can see. 1 transforms to 0 and 0 to 1. thats it!*\\n\\n\\n**STEPS**\\n\\n1. The first thing that should come to your mind when you want the opposite of any bit is the great XOR operation. Remember the simple rule of XOR. Whenever there is a bit say 1 ^ 0 , 0 ^ 1 then you will always get 1. Rest everytime you get 0.\\n2. Next, you need to figure the bit mask to get the result. Lets take the example of the input - 101 and output 010.\\nso if you XOR these two number then you get your mask required.  Example - (101) ^ (010) = 111 which is 7.\\nSo, if you do 101 ^ 111 = 010 and thats the answer or the output we want! So this is how you got your ** mask**\\n3. Now that you have the mask you just have to convert this logic into meaningful code so that it works for any input.\\none simple formula is. (2Power3)- 1. This will give you 8 AND THEN -1 WILL GIVE YOU **7**. Notice that 3 is the number of bits in the number.\\n4. Just do 101 ^ (2Power3)-1 and thats your output answer.\\n\\n**TASK 1**\\n1. Our first task is to find the number of bits a number has. For this we will run a while  loop till the number becomes 0.\\nYou can do this by taking the MSB (the first bit from the left side) and shift it one time. You can also take the LSB.\\n2. something like this while(num!-0) we do num = (num>>1) and COUNT THE NUMBER OF ITERATIONS, THAT WILL BE THE NUMBER OF BITS IN A NUMBER. THIS WILL GIVE US THE POWER.\\n\\n**TASK 2**\\n1. Now you know what the power is going to be for your number (2(Power)count)-1. Is what you have to do.\\n\\n**TASK 3**\\n1. Just XOR NUM with (2(Power)count) -1 and you will get the result.\\n\\nNOTE: YOU NEED TO SAVE THE NUM IN A TEMP VARIABLE BECASUE THE VALUE OF NUM WILL CHANGE TO 0 UPON DOING THE RIGHT SHIFT OPERATION. SO AT THE END JUST DO RESULT  = (TEMP ^ (2(POWER)COUNT)-1).\\n\\n2 POWER Count is basically 2 being the base and count being the Exponent. I could have used 2^3 to explain but this alsoc could confuse you between the XOR operation.\\n\\n**PRO TIP**\\n\\n2(Power)COUNT IS SAME AS (1<<COUNT)\\nSO BASICALLY YOU HAVE TO DO RESULT  = TEMP ^ (1<<COUNT) - 1;\\n\\nRETURN TEMP AND YOUR DONE.\\nCHEERS!\\n\\n\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-complement/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flip Bit by Bit\n\n  \n**Approach 2:** Compute Bit Length and Construct 1-bits Bitmask\n\n  \n**Approach 3:** Built-in Functions to Construct 1-bits Bitmask\n\n  \n**Approach 4:** highestOneBit OpenJDK algorithm from Hacker's Delight\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "LTKJ",
                        "content": "My solution to Number Complement was judged wrongly.\\n[Here is my submission result.](https://leetcode.com/contest/leetcode-weekly-contest-14/submissions/detail/88323029/) However, when I copied my code and test case to the problem, I got the correct answer.\\n\\n**UPD:** Fixed, thanks Leetcode Team."
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "int findComplement(int num) {\\n        \\n        if(num == 0) return 1;\\n\\n        int ans = 0;\\n        int i = 0;\\n\\n        while(num) {\\n\\n            if(num % 2 == 0) {\\n                ans += pow(2, i);\\n            }\\n\\n            i++;\\n            num /= 2;\\n        }\\n\\n        return ans;\\n}"
                    },
                    {
                        "username": "JoshDev",
                        "content": "num ^ ((Integer.highestOneBit(num) << 1) - 1);"
                    },
                    {
                        "username": "SagaciousB",
                        "content": "Please do not post solutions in the discussion."
                    },
                    {
                        "username": "W.S.YangGuang",
                        "content": "return (((unsigned)1 << (32 - __builtin_clz(num))) - 1) ^ num;\\n\\nusing g++ built in function to count the number of leading zeros."
                    },
                    {
                        "username": "pa-one55",
                        "content": "used vector for storing bits, negate bits, re construct\\n"
                    },
                    {
                        "username": "sonergonul",
                        "content": "For Turkish users, if you have a trouble to understand, here is the explanation;\\n\\nhttps://youtu.be/dHmcZidc37g"
                    },
                    {
                        "username": "justyy",
                        "content": "Nearly the same as https://leetcode.com/problems/complement-of-base-10-integer/\\njust need to handle the case when N=0"
                    },
                    {
                        "username": "kille6525",
                        "content": "'''return ~num & ((1 << (int)Math.Log(num,2)) - 1);'''"
                    }
                ]
            },
            {
                "id": 1663138,
                "content": [
                    {
                        "username": "ammarshareef",
                        "content": "Alright, I really want you to first understand the basic concepts and then I will try my best to break down the problem and explain step by step.\\n\\nMy aim is to make you understand the problem so that you can learn and CODE yourself.\\n\\n**Understanding the Problem Statement**\\n\\n**INPUT**      1 0 1  - 5\\n**OUTPUT**    0 1 0 - 2 *just flipping the bits as you can see. 1 transforms to 0 and 0 to 1. thats it!*\\n\\n\\n**STEPS**\\n\\n1. The first thing that should come to your mind when you want the opposite of any bit is the great XOR operation. Remember the simple rule of XOR. Whenever there is a bit say 1 ^ 0 , 0 ^ 1 then you will always get 1. Rest everytime you get 0.\\n2. Next, you need to figure the bit mask to get the result. Lets take the example of the input - 101 and output 010.\\nso if you XOR these two number then you get your mask required.  Example - (101) ^ (010) = 111 which is 7.\\nSo, if you do 101 ^ 111 = 010 and thats the answer or the output we want! So this is how you got your ** mask**\\n3. Now that you have the mask you just have to convert this logic into meaningful code so that it works for any input.\\none simple formula is. (2Power3)- 1. This will give you 8 AND THEN -1 WILL GIVE YOU **7**. Notice that 3 is the number of bits in the number.\\n4. Just do 101 ^ (2Power3)-1 and thats your output answer.\\n\\n**TASK 1**\\n1. Our first task is to find the number of bits a number has. For this we will run a while  loop till the number becomes 0.\\nYou can do this by taking the MSB (the first bit from the left side) and shift it one time. You can also take the LSB.\\n2. something like this while(num!-0) we do num = (num>>1) and COUNT THE NUMBER OF ITERATIONS, THAT WILL BE THE NUMBER OF BITS IN A NUMBER. THIS WILL GIVE US THE POWER.\\n\\n**TASK 2**\\n1. Now you know what the power is going to be for your number (2(Power)count)-1. Is what you have to do.\\n\\n**TASK 3**\\n1. Just XOR NUM with (2(Power)count) -1 and you will get the result.\\n\\nNOTE: YOU NEED TO SAVE THE NUM IN A TEMP VARIABLE BECASUE THE VALUE OF NUM WILL CHANGE TO 0 UPON DOING THE RIGHT SHIFT OPERATION. SO AT THE END JUST DO RESULT  = (TEMP ^ (2(POWER)COUNT)-1).\\n\\n2 POWER Count is basically 2 being the base and count being the Exponent. I could have used 2^3 to explain but this alsoc could confuse you between the XOR operation.\\n\\n**PRO TIP**\\n\\n2(Power)COUNT IS SAME AS (1<<COUNT)\\nSO BASICALLY YOU HAVE TO DO RESULT  = TEMP ^ (1<<COUNT) - 1;\\n\\nRETURN TEMP AND YOUR DONE.\\nCHEERS!\\n\\n\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-complement/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flip Bit by Bit\n\n  \n**Approach 2:** Compute Bit Length and Construct 1-bits Bitmask\n\n  \n**Approach 3:** Built-in Functions to Construct 1-bits Bitmask\n\n  \n**Approach 4:** highestOneBit OpenJDK algorithm from Hacker's Delight\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "LTKJ",
                        "content": "My solution to Number Complement was judged wrongly.\\n[Here is my submission result.](https://leetcode.com/contest/leetcode-weekly-contest-14/submissions/detail/88323029/) However, when I copied my code and test case to the problem, I got the correct answer.\\n\\n**UPD:** Fixed, thanks Leetcode Team."
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "int findComplement(int num) {\\n        \\n        if(num == 0) return 1;\\n\\n        int ans = 0;\\n        int i = 0;\\n\\n        while(num) {\\n\\n            if(num % 2 == 0) {\\n                ans += pow(2, i);\\n            }\\n\\n            i++;\\n            num /= 2;\\n        }\\n\\n        return ans;\\n}"
                    },
                    {
                        "username": "JoshDev",
                        "content": "num ^ ((Integer.highestOneBit(num) << 1) - 1);"
                    },
                    {
                        "username": "SagaciousB",
                        "content": "Please do not post solutions in the discussion."
                    },
                    {
                        "username": "W.S.YangGuang",
                        "content": "return (((unsigned)1 << (32 - __builtin_clz(num))) - 1) ^ num;\\n\\nusing g++ built in function to count the number of leading zeros."
                    },
                    {
                        "username": "pa-one55",
                        "content": "used vector for storing bits, negate bits, re construct\\n"
                    },
                    {
                        "username": "sonergonul",
                        "content": "For Turkish users, if you have a trouble to understand, here is the explanation;\\n\\nhttps://youtu.be/dHmcZidc37g"
                    },
                    {
                        "username": "justyy",
                        "content": "Nearly the same as https://leetcode.com/problems/complement-of-base-10-integer/\\njust need to handle the case when N=0"
                    },
                    {
                        "username": "kille6525",
                        "content": "'''return ~num & ((1 << (int)Math.Log(num,2)) - 1);'''"
                    }
                ]
            },
            {
                "id": 1571747,
                "content": [
                    {
                        "username": "ammarshareef",
                        "content": "Alright, I really want you to first understand the basic concepts and then I will try my best to break down the problem and explain step by step.\\n\\nMy aim is to make you understand the problem so that you can learn and CODE yourself.\\n\\n**Understanding the Problem Statement**\\n\\n**INPUT**      1 0 1  - 5\\n**OUTPUT**    0 1 0 - 2 *just flipping the bits as you can see. 1 transforms to 0 and 0 to 1. thats it!*\\n\\n\\n**STEPS**\\n\\n1. The first thing that should come to your mind when you want the opposite of any bit is the great XOR operation. Remember the simple rule of XOR. Whenever there is a bit say 1 ^ 0 , 0 ^ 1 then you will always get 1. Rest everytime you get 0.\\n2. Next, you need to figure the bit mask to get the result. Lets take the example of the input - 101 and output 010.\\nso if you XOR these two number then you get your mask required.  Example - (101) ^ (010) = 111 which is 7.\\nSo, if you do 101 ^ 111 = 010 and thats the answer or the output we want! So this is how you got your ** mask**\\n3. Now that you have the mask you just have to convert this logic into meaningful code so that it works for any input.\\none simple formula is. (2Power3)- 1. This will give you 8 AND THEN -1 WILL GIVE YOU **7**. Notice that 3 is the number of bits in the number.\\n4. Just do 101 ^ (2Power3)-1 and thats your output answer.\\n\\n**TASK 1**\\n1. Our first task is to find the number of bits a number has. For this we will run a while  loop till the number becomes 0.\\nYou can do this by taking the MSB (the first bit from the left side) and shift it one time. You can also take the LSB.\\n2. something like this while(num!-0) we do num = (num>>1) and COUNT THE NUMBER OF ITERATIONS, THAT WILL BE THE NUMBER OF BITS IN A NUMBER. THIS WILL GIVE US THE POWER.\\n\\n**TASK 2**\\n1. Now you know what the power is going to be for your number (2(Power)count)-1. Is what you have to do.\\n\\n**TASK 3**\\n1. Just XOR NUM with (2(Power)count) -1 and you will get the result.\\n\\nNOTE: YOU NEED TO SAVE THE NUM IN A TEMP VARIABLE BECASUE THE VALUE OF NUM WILL CHANGE TO 0 UPON DOING THE RIGHT SHIFT OPERATION. SO AT THE END JUST DO RESULT  = (TEMP ^ (2(POWER)COUNT)-1).\\n\\n2 POWER Count is basically 2 being the base and count being the Exponent. I could have used 2^3 to explain but this alsoc could confuse you between the XOR operation.\\n\\n**PRO TIP**\\n\\n2(Power)COUNT IS SAME AS (1<<COUNT)\\nSO BASICALLY YOU HAVE TO DO RESULT  = TEMP ^ (1<<COUNT) - 1;\\n\\nRETURN TEMP AND YOUR DONE.\\nCHEERS!\\n\\n\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-complement/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flip Bit by Bit\n\n  \n**Approach 2:** Compute Bit Length and Construct 1-bits Bitmask\n\n  \n**Approach 3:** Built-in Functions to Construct 1-bits Bitmask\n\n  \n**Approach 4:** highestOneBit OpenJDK algorithm from Hacker's Delight\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "LTKJ",
                        "content": "My solution to Number Complement was judged wrongly.\\n[Here is my submission result.](https://leetcode.com/contest/leetcode-weekly-contest-14/submissions/detail/88323029/) However, when I copied my code and test case to the problem, I got the correct answer.\\n\\n**UPD:** Fixed, thanks Leetcode Team."
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "int findComplement(int num) {\\n        \\n        if(num == 0) return 1;\\n\\n        int ans = 0;\\n        int i = 0;\\n\\n        while(num) {\\n\\n            if(num % 2 == 0) {\\n                ans += pow(2, i);\\n            }\\n\\n            i++;\\n            num /= 2;\\n        }\\n\\n        return ans;\\n}"
                    },
                    {
                        "username": "JoshDev",
                        "content": "num ^ ((Integer.highestOneBit(num) << 1) - 1);"
                    },
                    {
                        "username": "SagaciousB",
                        "content": "Please do not post solutions in the discussion."
                    },
                    {
                        "username": "W.S.YangGuang",
                        "content": "return (((unsigned)1 << (32 - __builtin_clz(num))) - 1) ^ num;\\n\\nusing g++ built in function to count the number of leading zeros."
                    },
                    {
                        "username": "pa-one55",
                        "content": "used vector for storing bits, negate bits, re construct\\n"
                    },
                    {
                        "username": "sonergonul",
                        "content": "For Turkish users, if you have a trouble to understand, here is the explanation;\\n\\nhttps://youtu.be/dHmcZidc37g"
                    },
                    {
                        "username": "justyy",
                        "content": "Nearly the same as https://leetcode.com/problems/complement-of-base-10-integer/\\njust need to handle the case when N=0"
                    },
                    {
                        "username": "kille6525",
                        "content": "'''return ~num & ((1 << (int)Math.Log(num,2)) - 1);'''"
                    }
                ]
            },
            {
                "id": 1569126,
                "content": [
                    {
                        "username": "ammarshareef",
                        "content": "Alright, I really want you to first understand the basic concepts and then I will try my best to break down the problem and explain step by step.\\n\\nMy aim is to make you understand the problem so that you can learn and CODE yourself.\\n\\n**Understanding the Problem Statement**\\n\\n**INPUT**      1 0 1  - 5\\n**OUTPUT**    0 1 0 - 2 *just flipping the bits as you can see. 1 transforms to 0 and 0 to 1. thats it!*\\n\\n\\n**STEPS**\\n\\n1. The first thing that should come to your mind when you want the opposite of any bit is the great XOR operation. Remember the simple rule of XOR. Whenever there is a bit say 1 ^ 0 , 0 ^ 1 then you will always get 1. Rest everytime you get 0.\\n2. Next, you need to figure the bit mask to get the result. Lets take the example of the input - 101 and output 010.\\nso if you XOR these two number then you get your mask required.  Example - (101) ^ (010) = 111 which is 7.\\nSo, if you do 101 ^ 111 = 010 and thats the answer or the output we want! So this is how you got your ** mask**\\n3. Now that you have the mask you just have to convert this logic into meaningful code so that it works for any input.\\none simple formula is. (2Power3)- 1. This will give you 8 AND THEN -1 WILL GIVE YOU **7**. Notice that 3 is the number of bits in the number.\\n4. Just do 101 ^ (2Power3)-1 and thats your output answer.\\n\\n**TASK 1**\\n1. Our first task is to find the number of bits a number has. For this we will run a while  loop till the number becomes 0.\\nYou can do this by taking the MSB (the first bit from the left side) and shift it one time. You can also take the LSB.\\n2. something like this while(num!-0) we do num = (num>>1) and COUNT THE NUMBER OF ITERATIONS, THAT WILL BE THE NUMBER OF BITS IN A NUMBER. THIS WILL GIVE US THE POWER.\\n\\n**TASK 2**\\n1. Now you know what the power is going to be for your number (2(Power)count)-1. Is what you have to do.\\n\\n**TASK 3**\\n1. Just XOR NUM with (2(Power)count) -1 and you will get the result.\\n\\nNOTE: YOU NEED TO SAVE THE NUM IN A TEMP VARIABLE BECASUE THE VALUE OF NUM WILL CHANGE TO 0 UPON DOING THE RIGHT SHIFT OPERATION. SO AT THE END JUST DO RESULT  = (TEMP ^ (2(POWER)COUNT)-1).\\n\\n2 POWER Count is basically 2 being the base and count being the Exponent. I could have used 2^3 to explain but this alsoc could confuse you between the XOR operation.\\n\\n**PRO TIP**\\n\\n2(Power)COUNT IS SAME AS (1<<COUNT)\\nSO BASICALLY YOU HAVE TO DO RESULT  = TEMP ^ (1<<COUNT) - 1;\\n\\nRETURN TEMP AND YOUR DONE.\\nCHEERS!\\n\\n\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-complement/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flip Bit by Bit\n\n  \n**Approach 2:** Compute Bit Length and Construct 1-bits Bitmask\n\n  \n**Approach 3:** Built-in Functions to Construct 1-bits Bitmask\n\n  \n**Approach 4:** highestOneBit OpenJDK algorithm from Hacker's Delight\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "LTKJ",
                        "content": "My solution to Number Complement was judged wrongly.\\n[Here is my submission result.](https://leetcode.com/contest/leetcode-weekly-contest-14/submissions/detail/88323029/) However, when I copied my code and test case to the problem, I got the correct answer.\\n\\n**UPD:** Fixed, thanks Leetcode Team."
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "int findComplement(int num) {\\n        \\n        if(num == 0) return 1;\\n\\n        int ans = 0;\\n        int i = 0;\\n\\n        while(num) {\\n\\n            if(num % 2 == 0) {\\n                ans += pow(2, i);\\n            }\\n\\n            i++;\\n            num /= 2;\\n        }\\n\\n        return ans;\\n}"
                    },
                    {
                        "username": "JoshDev",
                        "content": "num ^ ((Integer.highestOneBit(num) << 1) - 1);"
                    },
                    {
                        "username": "SagaciousB",
                        "content": "Please do not post solutions in the discussion."
                    },
                    {
                        "username": "W.S.YangGuang",
                        "content": "return (((unsigned)1 << (32 - __builtin_clz(num))) - 1) ^ num;\\n\\nusing g++ built in function to count the number of leading zeros."
                    },
                    {
                        "username": "pa-one55",
                        "content": "used vector for storing bits, negate bits, re construct\\n"
                    },
                    {
                        "username": "sonergonul",
                        "content": "For Turkish users, if you have a trouble to understand, here is the explanation;\\n\\nhttps://youtu.be/dHmcZidc37g"
                    },
                    {
                        "username": "justyy",
                        "content": "Nearly the same as https://leetcode.com/problems/complement-of-base-10-integer/\\njust need to handle the case when N=0"
                    },
                    {
                        "username": "kille6525",
                        "content": "'''return ~num & ((1 << (int)Math.Log(num,2)) - 1);'''"
                    }
                ]
            },
            {
                "id": 2007769,
                "content": [
                    {
                        "username": "ammarshareef",
                        "content": "Alright, I really want you to first understand the basic concepts and then I will try my best to break down the problem and explain step by step.\\n\\nMy aim is to make you understand the problem so that you can learn and CODE yourself.\\n\\n**Understanding the Problem Statement**\\n\\n**INPUT**      1 0 1  - 5\\n**OUTPUT**    0 1 0 - 2 *just flipping the bits as you can see. 1 transforms to 0 and 0 to 1. thats it!*\\n\\n\\n**STEPS**\\n\\n1. The first thing that should come to your mind when you want the opposite of any bit is the great XOR operation. Remember the simple rule of XOR. Whenever there is a bit say 1 ^ 0 , 0 ^ 1 then you will always get 1. Rest everytime you get 0.\\n2. Next, you need to figure the bit mask to get the result. Lets take the example of the input - 101 and output 010.\\nso if you XOR these two number then you get your mask required.  Example - (101) ^ (010) = 111 which is 7.\\nSo, if you do 101 ^ 111 = 010 and thats the answer or the output we want! So this is how you got your ** mask**\\n3. Now that you have the mask you just have to convert this logic into meaningful code so that it works for any input.\\none simple formula is. (2Power3)- 1. This will give you 8 AND THEN -1 WILL GIVE YOU **7**. Notice that 3 is the number of bits in the number.\\n4. Just do 101 ^ (2Power3)-1 and thats your output answer.\\n\\n**TASK 1**\\n1. Our first task is to find the number of bits a number has. For this we will run a while  loop till the number becomes 0.\\nYou can do this by taking the MSB (the first bit from the left side) and shift it one time. You can also take the LSB.\\n2. something like this while(num!-0) we do num = (num>>1) and COUNT THE NUMBER OF ITERATIONS, THAT WILL BE THE NUMBER OF BITS IN A NUMBER. THIS WILL GIVE US THE POWER.\\n\\n**TASK 2**\\n1. Now you know what the power is going to be for your number (2(Power)count)-1. Is what you have to do.\\n\\n**TASK 3**\\n1. Just XOR NUM with (2(Power)count) -1 and you will get the result.\\n\\nNOTE: YOU NEED TO SAVE THE NUM IN A TEMP VARIABLE BECASUE THE VALUE OF NUM WILL CHANGE TO 0 UPON DOING THE RIGHT SHIFT OPERATION. SO AT THE END JUST DO RESULT  = (TEMP ^ (2(POWER)COUNT)-1).\\n\\n2 POWER Count is basically 2 being the base and count being the Exponent. I could have used 2^3 to explain but this alsoc could confuse you between the XOR operation.\\n\\n**PRO TIP**\\n\\n2(Power)COUNT IS SAME AS (1<<COUNT)\\nSO BASICALLY YOU HAVE TO DO RESULT  = TEMP ^ (1<<COUNT) - 1;\\n\\nRETURN TEMP AND YOUR DONE.\\nCHEERS!\\n\\n\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-complement/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flip Bit by Bit\n\n  \n**Approach 2:** Compute Bit Length and Construct 1-bits Bitmask\n\n  \n**Approach 3:** Built-in Functions to Construct 1-bits Bitmask\n\n  \n**Approach 4:** highestOneBit OpenJDK algorithm from Hacker's Delight\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "LTKJ",
                        "content": "My solution to Number Complement was judged wrongly.\\n[Here is my submission result.](https://leetcode.com/contest/leetcode-weekly-contest-14/submissions/detail/88323029/) However, when I copied my code and test case to the problem, I got the correct answer.\\n\\n**UPD:** Fixed, thanks Leetcode Team."
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "int findComplement(int num) {\\n        \\n        if(num == 0) return 1;\\n\\n        int ans = 0;\\n        int i = 0;\\n\\n        while(num) {\\n\\n            if(num % 2 == 0) {\\n                ans += pow(2, i);\\n            }\\n\\n            i++;\\n            num /= 2;\\n        }\\n\\n        return ans;\\n}"
                    },
                    {
                        "username": "JoshDev",
                        "content": "num ^ ((Integer.highestOneBit(num) << 1) - 1);"
                    },
                    {
                        "username": "SagaciousB",
                        "content": "Please do not post solutions in the discussion."
                    },
                    {
                        "username": "W.S.YangGuang",
                        "content": "return (((unsigned)1 << (32 - __builtin_clz(num))) - 1) ^ num;\\n\\nusing g++ built in function to count the number of leading zeros."
                    },
                    {
                        "username": "pa-one55",
                        "content": "used vector for storing bits, negate bits, re construct\\n"
                    },
                    {
                        "username": "sonergonul",
                        "content": "For Turkish users, if you have a trouble to understand, here is the explanation;\\n\\nhttps://youtu.be/dHmcZidc37g"
                    },
                    {
                        "username": "justyy",
                        "content": "Nearly the same as https://leetcode.com/problems/complement-of-base-10-integer/\\njust need to handle the case when N=0"
                    },
                    {
                        "username": "kille6525",
                        "content": "'''return ~num & ((1 << (int)Math.Log(num,2)) - 1);'''"
                    }
                ]
            },
            {
                "id": 1574822,
                "content": [
                    {
                        "username": "ammarshareef",
                        "content": "Alright, I really want you to first understand the basic concepts and then I will try my best to break down the problem and explain step by step.\\n\\nMy aim is to make you understand the problem so that you can learn and CODE yourself.\\n\\n**Understanding the Problem Statement**\\n\\n**INPUT**      1 0 1  - 5\\n**OUTPUT**    0 1 0 - 2 *just flipping the bits as you can see. 1 transforms to 0 and 0 to 1. thats it!*\\n\\n\\n**STEPS**\\n\\n1. The first thing that should come to your mind when you want the opposite of any bit is the great XOR operation. Remember the simple rule of XOR. Whenever there is a bit say 1 ^ 0 , 0 ^ 1 then you will always get 1. Rest everytime you get 0.\\n2. Next, you need to figure the bit mask to get the result. Lets take the example of the input - 101 and output 010.\\nso if you XOR these two number then you get your mask required.  Example - (101) ^ (010) = 111 which is 7.\\nSo, if you do 101 ^ 111 = 010 and thats the answer or the output we want! So this is how you got your ** mask**\\n3. Now that you have the mask you just have to convert this logic into meaningful code so that it works for any input.\\none simple formula is. (2Power3)- 1. This will give you 8 AND THEN -1 WILL GIVE YOU **7**. Notice that 3 is the number of bits in the number.\\n4. Just do 101 ^ (2Power3)-1 and thats your output answer.\\n\\n**TASK 1**\\n1. Our first task is to find the number of bits a number has. For this we will run a while  loop till the number becomes 0.\\nYou can do this by taking the MSB (the first bit from the left side) and shift it one time. You can also take the LSB.\\n2. something like this while(num!-0) we do num = (num>>1) and COUNT THE NUMBER OF ITERATIONS, THAT WILL BE THE NUMBER OF BITS IN A NUMBER. THIS WILL GIVE US THE POWER.\\n\\n**TASK 2**\\n1. Now you know what the power is going to be for your number (2(Power)count)-1. Is what you have to do.\\n\\n**TASK 3**\\n1. Just XOR NUM with (2(Power)count) -1 and you will get the result.\\n\\nNOTE: YOU NEED TO SAVE THE NUM IN A TEMP VARIABLE BECASUE THE VALUE OF NUM WILL CHANGE TO 0 UPON DOING THE RIGHT SHIFT OPERATION. SO AT THE END JUST DO RESULT  = (TEMP ^ (2(POWER)COUNT)-1).\\n\\n2 POWER Count is basically 2 being the base and count being the Exponent. I could have used 2^3 to explain but this alsoc could confuse you between the XOR operation.\\n\\n**PRO TIP**\\n\\n2(Power)COUNT IS SAME AS (1<<COUNT)\\nSO BASICALLY YOU HAVE TO DO RESULT  = TEMP ^ (1<<COUNT) - 1;\\n\\nRETURN TEMP AND YOUR DONE.\\nCHEERS!\\n\\n\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-complement/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flip Bit by Bit\n\n  \n**Approach 2:** Compute Bit Length and Construct 1-bits Bitmask\n\n  \n**Approach 3:** Built-in Functions to Construct 1-bits Bitmask\n\n  \n**Approach 4:** highestOneBit OpenJDK algorithm from Hacker's Delight\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "LTKJ",
                        "content": "My solution to Number Complement was judged wrongly.\\n[Here is my submission result.](https://leetcode.com/contest/leetcode-weekly-contest-14/submissions/detail/88323029/) However, when I copied my code and test case to the problem, I got the correct answer.\\n\\n**UPD:** Fixed, thanks Leetcode Team."
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "int findComplement(int num) {\\n        \\n        if(num == 0) return 1;\\n\\n        int ans = 0;\\n        int i = 0;\\n\\n        while(num) {\\n\\n            if(num % 2 == 0) {\\n                ans += pow(2, i);\\n            }\\n\\n            i++;\\n            num /= 2;\\n        }\\n\\n        return ans;\\n}"
                    },
                    {
                        "username": "JoshDev",
                        "content": "num ^ ((Integer.highestOneBit(num) << 1) - 1);"
                    },
                    {
                        "username": "SagaciousB",
                        "content": "Please do not post solutions in the discussion."
                    },
                    {
                        "username": "W.S.YangGuang",
                        "content": "return (((unsigned)1 << (32 - __builtin_clz(num))) - 1) ^ num;\\n\\nusing g++ built in function to count the number of leading zeros."
                    },
                    {
                        "username": "pa-one55",
                        "content": "used vector for storing bits, negate bits, re construct\\n"
                    },
                    {
                        "username": "sonergonul",
                        "content": "For Turkish users, if you have a trouble to understand, here is the explanation;\\n\\nhttps://youtu.be/dHmcZidc37g"
                    },
                    {
                        "username": "justyy",
                        "content": "Nearly the same as https://leetcode.com/problems/complement-of-base-10-integer/\\njust need to handle the case when N=0"
                    },
                    {
                        "username": "kille6525",
                        "content": "'''return ~num & ((1 << (int)Math.Log(num,2)) - 1);'''"
                    }
                ]
            },
            {
                "id": 1572571,
                "content": [
                    {
                        "username": "ammarshareef",
                        "content": "Alright, I really want you to first understand the basic concepts and then I will try my best to break down the problem and explain step by step.\\n\\nMy aim is to make you understand the problem so that you can learn and CODE yourself.\\n\\n**Understanding the Problem Statement**\\n\\n**INPUT**      1 0 1  - 5\\n**OUTPUT**    0 1 0 - 2 *just flipping the bits as you can see. 1 transforms to 0 and 0 to 1. thats it!*\\n\\n\\n**STEPS**\\n\\n1. The first thing that should come to your mind when you want the opposite of any bit is the great XOR operation. Remember the simple rule of XOR. Whenever there is a bit say 1 ^ 0 , 0 ^ 1 then you will always get 1. Rest everytime you get 0.\\n2. Next, you need to figure the bit mask to get the result. Lets take the example of the input - 101 and output 010.\\nso if you XOR these two number then you get your mask required.  Example - (101) ^ (010) = 111 which is 7.\\nSo, if you do 101 ^ 111 = 010 and thats the answer or the output we want! So this is how you got your ** mask**\\n3. Now that you have the mask you just have to convert this logic into meaningful code so that it works for any input.\\none simple formula is. (2Power3)- 1. This will give you 8 AND THEN -1 WILL GIVE YOU **7**. Notice that 3 is the number of bits in the number.\\n4. Just do 101 ^ (2Power3)-1 and thats your output answer.\\n\\n**TASK 1**\\n1. Our first task is to find the number of bits a number has. For this we will run a while  loop till the number becomes 0.\\nYou can do this by taking the MSB (the first bit from the left side) and shift it one time. You can also take the LSB.\\n2. something like this while(num!-0) we do num = (num>>1) and COUNT THE NUMBER OF ITERATIONS, THAT WILL BE THE NUMBER OF BITS IN A NUMBER. THIS WILL GIVE US THE POWER.\\n\\n**TASK 2**\\n1. Now you know what the power is going to be for your number (2(Power)count)-1. Is what you have to do.\\n\\n**TASK 3**\\n1. Just XOR NUM with (2(Power)count) -1 and you will get the result.\\n\\nNOTE: YOU NEED TO SAVE THE NUM IN A TEMP VARIABLE BECASUE THE VALUE OF NUM WILL CHANGE TO 0 UPON DOING THE RIGHT SHIFT OPERATION. SO AT THE END JUST DO RESULT  = (TEMP ^ (2(POWER)COUNT)-1).\\n\\n2 POWER Count is basically 2 being the base and count being the Exponent. I could have used 2^3 to explain but this alsoc could confuse you between the XOR operation.\\n\\n**PRO TIP**\\n\\n2(Power)COUNT IS SAME AS (1<<COUNT)\\nSO BASICALLY YOU HAVE TO DO RESULT  = TEMP ^ (1<<COUNT) - 1;\\n\\nRETURN TEMP AND YOUR DONE.\\nCHEERS!\\n\\n\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-complement/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flip Bit by Bit\n\n  \n**Approach 2:** Compute Bit Length and Construct 1-bits Bitmask\n\n  \n**Approach 3:** Built-in Functions to Construct 1-bits Bitmask\n\n  \n**Approach 4:** highestOneBit OpenJDK algorithm from Hacker's Delight\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "LTKJ",
                        "content": "My solution to Number Complement was judged wrongly.\\n[Here is my submission result.](https://leetcode.com/contest/leetcode-weekly-contest-14/submissions/detail/88323029/) However, when I copied my code and test case to the problem, I got the correct answer.\\n\\n**UPD:** Fixed, thanks Leetcode Team."
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "int findComplement(int num) {\\n        \\n        if(num == 0) return 1;\\n\\n        int ans = 0;\\n        int i = 0;\\n\\n        while(num) {\\n\\n            if(num % 2 == 0) {\\n                ans += pow(2, i);\\n            }\\n\\n            i++;\\n            num /= 2;\\n        }\\n\\n        return ans;\\n}"
                    },
                    {
                        "username": "JoshDev",
                        "content": "num ^ ((Integer.highestOneBit(num) << 1) - 1);"
                    },
                    {
                        "username": "SagaciousB",
                        "content": "Please do not post solutions in the discussion."
                    },
                    {
                        "username": "W.S.YangGuang",
                        "content": "return (((unsigned)1 << (32 - __builtin_clz(num))) - 1) ^ num;\\n\\nusing g++ built in function to count the number of leading zeros."
                    },
                    {
                        "username": "pa-one55",
                        "content": "used vector for storing bits, negate bits, re construct\\n"
                    },
                    {
                        "username": "sonergonul",
                        "content": "For Turkish users, if you have a trouble to understand, here is the explanation;\\n\\nhttps://youtu.be/dHmcZidc37g"
                    },
                    {
                        "username": "justyy",
                        "content": "Nearly the same as https://leetcode.com/problems/complement-of-base-10-integer/\\njust need to handle the case when N=0"
                    },
                    {
                        "username": "kille6525",
                        "content": "'''return ~num & ((1 << (int)Math.Log(num,2)) - 1);'''"
                    }
                ]
            },
            {
                "id": 1571746,
                "content": [
                    {
                        "username": "ammarshareef",
                        "content": "Alright, I really want you to first understand the basic concepts and then I will try my best to break down the problem and explain step by step.\\n\\nMy aim is to make you understand the problem so that you can learn and CODE yourself.\\n\\n**Understanding the Problem Statement**\\n\\n**INPUT**      1 0 1  - 5\\n**OUTPUT**    0 1 0 - 2 *just flipping the bits as you can see. 1 transforms to 0 and 0 to 1. thats it!*\\n\\n\\n**STEPS**\\n\\n1. The first thing that should come to your mind when you want the opposite of any bit is the great XOR operation. Remember the simple rule of XOR. Whenever there is a bit say 1 ^ 0 , 0 ^ 1 then you will always get 1. Rest everytime you get 0.\\n2. Next, you need to figure the bit mask to get the result. Lets take the example of the input - 101 and output 010.\\nso if you XOR these two number then you get your mask required.  Example - (101) ^ (010) = 111 which is 7.\\nSo, if you do 101 ^ 111 = 010 and thats the answer or the output we want! So this is how you got your ** mask**\\n3. Now that you have the mask you just have to convert this logic into meaningful code so that it works for any input.\\none simple formula is. (2Power3)- 1. This will give you 8 AND THEN -1 WILL GIVE YOU **7**. Notice that 3 is the number of bits in the number.\\n4. Just do 101 ^ (2Power3)-1 and thats your output answer.\\n\\n**TASK 1**\\n1. Our first task is to find the number of bits a number has. For this we will run a while  loop till the number becomes 0.\\nYou can do this by taking the MSB (the first bit from the left side) and shift it one time. You can also take the LSB.\\n2. something like this while(num!-0) we do num = (num>>1) and COUNT THE NUMBER OF ITERATIONS, THAT WILL BE THE NUMBER OF BITS IN A NUMBER. THIS WILL GIVE US THE POWER.\\n\\n**TASK 2**\\n1. Now you know what the power is going to be for your number (2(Power)count)-1. Is what you have to do.\\n\\n**TASK 3**\\n1. Just XOR NUM with (2(Power)count) -1 and you will get the result.\\n\\nNOTE: YOU NEED TO SAVE THE NUM IN A TEMP VARIABLE BECASUE THE VALUE OF NUM WILL CHANGE TO 0 UPON DOING THE RIGHT SHIFT OPERATION. SO AT THE END JUST DO RESULT  = (TEMP ^ (2(POWER)COUNT)-1).\\n\\n2 POWER Count is basically 2 being the base and count being the Exponent. I could have used 2^3 to explain but this alsoc could confuse you between the XOR operation.\\n\\n**PRO TIP**\\n\\n2(Power)COUNT IS SAME AS (1<<COUNT)\\nSO BASICALLY YOU HAVE TO DO RESULT  = TEMP ^ (1<<COUNT) - 1;\\n\\nRETURN TEMP AND YOUR DONE.\\nCHEERS!\\n\\n\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-complement/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flip Bit by Bit\n\n  \n**Approach 2:** Compute Bit Length and Construct 1-bits Bitmask\n\n  \n**Approach 3:** Built-in Functions to Construct 1-bits Bitmask\n\n  \n**Approach 4:** highestOneBit OpenJDK algorithm from Hacker's Delight\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "LTKJ",
                        "content": "My solution to Number Complement was judged wrongly.\\n[Here is my submission result.](https://leetcode.com/contest/leetcode-weekly-contest-14/submissions/detail/88323029/) However, when I copied my code and test case to the problem, I got the correct answer.\\n\\n**UPD:** Fixed, thanks Leetcode Team."
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "int findComplement(int num) {\\n        \\n        if(num == 0) return 1;\\n\\n        int ans = 0;\\n        int i = 0;\\n\\n        while(num) {\\n\\n            if(num % 2 == 0) {\\n                ans += pow(2, i);\\n            }\\n\\n            i++;\\n            num /= 2;\\n        }\\n\\n        return ans;\\n}"
                    },
                    {
                        "username": "JoshDev",
                        "content": "num ^ ((Integer.highestOneBit(num) << 1) - 1);"
                    },
                    {
                        "username": "SagaciousB",
                        "content": "Please do not post solutions in the discussion."
                    },
                    {
                        "username": "W.S.YangGuang",
                        "content": "return (((unsigned)1 << (32 - __builtin_clz(num))) - 1) ^ num;\\n\\nusing g++ built in function to count the number of leading zeros."
                    },
                    {
                        "username": "pa-one55",
                        "content": "used vector for storing bits, negate bits, re construct\\n"
                    },
                    {
                        "username": "sonergonul",
                        "content": "For Turkish users, if you have a trouble to understand, here is the explanation;\\n\\nhttps://youtu.be/dHmcZidc37g"
                    },
                    {
                        "username": "justyy",
                        "content": "Nearly the same as https://leetcode.com/problems/complement-of-base-10-integer/\\njust need to handle the case when N=0"
                    },
                    {
                        "username": "kille6525",
                        "content": "'''return ~num & ((1 << (int)Math.Log(num,2)) - 1);'''"
                    }
                ]
            },
            {
                "id": 1565131,
                "content": [
                    {
                        "username": "ammarshareef",
                        "content": "Alright, I really want you to first understand the basic concepts and then I will try my best to break down the problem and explain step by step.\\n\\nMy aim is to make you understand the problem so that you can learn and CODE yourself.\\n\\n**Understanding the Problem Statement**\\n\\n**INPUT**      1 0 1  - 5\\n**OUTPUT**    0 1 0 - 2 *just flipping the bits as you can see. 1 transforms to 0 and 0 to 1. thats it!*\\n\\n\\n**STEPS**\\n\\n1. The first thing that should come to your mind when you want the opposite of any bit is the great XOR operation. Remember the simple rule of XOR. Whenever there is a bit say 1 ^ 0 , 0 ^ 1 then you will always get 1. Rest everytime you get 0.\\n2. Next, you need to figure the bit mask to get the result. Lets take the example of the input - 101 and output 010.\\nso if you XOR these two number then you get your mask required.  Example - (101) ^ (010) = 111 which is 7.\\nSo, if you do 101 ^ 111 = 010 and thats the answer or the output we want! So this is how you got your ** mask**\\n3. Now that you have the mask you just have to convert this logic into meaningful code so that it works for any input.\\none simple formula is. (2Power3)- 1. This will give you 8 AND THEN -1 WILL GIVE YOU **7**. Notice that 3 is the number of bits in the number.\\n4. Just do 101 ^ (2Power3)-1 and thats your output answer.\\n\\n**TASK 1**\\n1. Our first task is to find the number of bits a number has. For this we will run a while  loop till the number becomes 0.\\nYou can do this by taking the MSB (the first bit from the left side) and shift it one time. You can also take the LSB.\\n2. something like this while(num!-0) we do num = (num>>1) and COUNT THE NUMBER OF ITERATIONS, THAT WILL BE THE NUMBER OF BITS IN A NUMBER. THIS WILL GIVE US THE POWER.\\n\\n**TASK 2**\\n1. Now you know what the power is going to be for your number (2(Power)count)-1. Is what you have to do.\\n\\n**TASK 3**\\n1. Just XOR NUM with (2(Power)count) -1 and you will get the result.\\n\\nNOTE: YOU NEED TO SAVE THE NUM IN A TEMP VARIABLE BECASUE THE VALUE OF NUM WILL CHANGE TO 0 UPON DOING THE RIGHT SHIFT OPERATION. SO AT THE END JUST DO RESULT  = (TEMP ^ (2(POWER)COUNT)-1).\\n\\n2 POWER Count is basically 2 being the base and count being the Exponent. I could have used 2^3 to explain but this alsoc could confuse you between the XOR operation.\\n\\n**PRO TIP**\\n\\n2(Power)COUNT IS SAME AS (1<<COUNT)\\nSO BASICALLY YOU HAVE TO DO RESULT  = TEMP ^ (1<<COUNT) - 1;\\n\\nRETURN TEMP AND YOUR DONE.\\nCHEERS!\\n\\n\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-complement/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flip Bit by Bit\n\n  \n**Approach 2:** Compute Bit Length and Construct 1-bits Bitmask\n\n  \n**Approach 3:** Built-in Functions to Construct 1-bits Bitmask\n\n  \n**Approach 4:** highestOneBit OpenJDK algorithm from Hacker's Delight\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "LTKJ",
                        "content": "My solution to Number Complement was judged wrongly.\\n[Here is my submission result.](https://leetcode.com/contest/leetcode-weekly-contest-14/submissions/detail/88323029/) However, when I copied my code and test case to the problem, I got the correct answer.\\n\\n**UPD:** Fixed, thanks Leetcode Team."
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "int findComplement(int num) {\\n        \\n        if(num == 0) return 1;\\n\\n        int ans = 0;\\n        int i = 0;\\n\\n        while(num) {\\n\\n            if(num % 2 == 0) {\\n                ans += pow(2, i);\\n            }\\n\\n            i++;\\n            num /= 2;\\n        }\\n\\n        return ans;\\n}"
                    },
                    {
                        "username": "JoshDev",
                        "content": "num ^ ((Integer.highestOneBit(num) << 1) - 1);"
                    },
                    {
                        "username": "SagaciousB",
                        "content": "Please do not post solutions in the discussion."
                    },
                    {
                        "username": "W.S.YangGuang",
                        "content": "return (((unsigned)1 << (32 - __builtin_clz(num))) - 1) ^ num;\\n\\nusing g++ built in function to count the number of leading zeros."
                    },
                    {
                        "username": "pa-one55",
                        "content": "used vector for storing bits, negate bits, re construct\\n"
                    },
                    {
                        "username": "sonergonul",
                        "content": "For Turkish users, if you have a trouble to understand, here is the explanation;\\n\\nhttps://youtu.be/dHmcZidc37g"
                    },
                    {
                        "username": "justyy",
                        "content": "Nearly the same as https://leetcode.com/problems/complement-of-base-10-integer/\\njust need to handle the case when N=0"
                    },
                    {
                        "username": "kille6525",
                        "content": "'''return ~num & ((1 << (int)Math.Log(num,2)) - 1);'''"
                    }
                ]
            },
            {
                "id": 1565642,
                "content": [
                    {
                        "username": "ammarshareef",
                        "content": "Alright, I really want you to first understand the basic concepts and then I will try my best to break down the problem and explain step by step.\\n\\nMy aim is to make you understand the problem so that you can learn and CODE yourself.\\n\\n**Understanding the Problem Statement**\\n\\n**INPUT**      1 0 1  - 5\\n**OUTPUT**    0 1 0 - 2 *just flipping the bits as you can see. 1 transforms to 0 and 0 to 1. thats it!*\\n\\n\\n**STEPS**\\n\\n1. The first thing that should come to your mind when you want the opposite of any bit is the great XOR operation. Remember the simple rule of XOR. Whenever there is a bit say 1 ^ 0 , 0 ^ 1 then you will always get 1. Rest everytime you get 0.\\n2. Next, you need to figure the bit mask to get the result. Lets take the example of the input - 101 and output 010.\\nso if you XOR these two number then you get your mask required.  Example - (101) ^ (010) = 111 which is 7.\\nSo, if you do 101 ^ 111 = 010 and thats the answer or the output we want! So this is how you got your ** mask**\\n3. Now that you have the mask you just have to convert this logic into meaningful code so that it works for any input.\\none simple formula is. (2Power3)- 1. This will give you 8 AND THEN -1 WILL GIVE YOU **7**. Notice that 3 is the number of bits in the number.\\n4. Just do 101 ^ (2Power3)-1 and thats your output answer.\\n\\n**TASK 1**\\n1. Our first task is to find the number of bits a number has. For this we will run a while  loop till the number becomes 0.\\nYou can do this by taking the MSB (the first bit from the left side) and shift it one time. You can also take the LSB.\\n2. something like this while(num!-0) we do num = (num>>1) and COUNT THE NUMBER OF ITERATIONS, THAT WILL BE THE NUMBER OF BITS IN A NUMBER. THIS WILL GIVE US THE POWER.\\n\\n**TASK 2**\\n1. Now you know what the power is going to be for your number (2(Power)count)-1. Is what you have to do.\\n\\n**TASK 3**\\n1. Just XOR NUM with (2(Power)count) -1 and you will get the result.\\n\\nNOTE: YOU NEED TO SAVE THE NUM IN A TEMP VARIABLE BECASUE THE VALUE OF NUM WILL CHANGE TO 0 UPON DOING THE RIGHT SHIFT OPERATION. SO AT THE END JUST DO RESULT  = (TEMP ^ (2(POWER)COUNT)-1).\\n\\n2 POWER Count is basically 2 being the base and count being the Exponent. I could have used 2^3 to explain but this alsoc could confuse you between the XOR operation.\\n\\n**PRO TIP**\\n\\n2(Power)COUNT IS SAME AS (1<<COUNT)\\nSO BASICALLY YOU HAVE TO DO RESULT  = TEMP ^ (1<<COUNT) - 1;\\n\\nRETURN TEMP AND YOUR DONE.\\nCHEERS!\\n\\n\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-complement/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flip Bit by Bit\n\n  \n**Approach 2:** Compute Bit Length and Construct 1-bits Bitmask\n\n  \n**Approach 3:** Built-in Functions to Construct 1-bits Bitmask\n\n  \n**Approach 4:** highestOneBit OpenJDK algorithm from Hacker's Delight\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "LTKJ",
                        "content": "My solution to Number Complement was judged wrongly.\\n[Here is my submission result.](https://leetcode.com/contest/leetcode-weekly-contest-14/submissions/detail/88323029/) However, when I copied my code and test case to the problem, I got the correct answer.\\n\\n**UPD:** Fixed, thanks Leetcode Team."
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "int findComplement(int num) {\\n        \\n        if(num == 0) return 1;\\n\\n        int ans = 0;\\n        int i = 0;\\n\\n        while(num) {\\n\\n            if(num % 2 == 0) {\\n                ans += pow(2, i);\\n            }\\n\\n            i++;\\n            num /= 2;\\n        }\\n\\n        return ans;\\n}"
                    },
                    {
                        "username": "JoshDev",
                        "content": "num ^ ((Integer.highestOneBit(num) << 1) - 1);"
                    },
                    {
                        "username": "SagaciousB",
                        "content": "Please do not post solutions in the discussion."
                    },
                    {
                        "username": "W.S.YangGuang",
                        "content": "return (((unsigned)1 << (32 - __builtin_clz(num))) - 1) ^ num;\\n\\nusing g++ built in function to count the number of leading zeros."
                    },
                    {
                        "username": "pa-one55",
                        "content": "used vector for storing bits, negate bits, re construct\\n"
                    },
                    {
                        "username": "sonergonul",
                        "content": "For Turkish users, if you have a trouble to understand, here is the explanation;\\n\\nhttps://youtu.be/dHmcZidc37g"
                    },
                    {
                        "username": "justyy",
                        "content": "Nearly the same as https://leetcode.com/problems/complement-of-base-10-integer/\\njust need to handle the case when N=0"
                    },
                    {
                        "username": "kille6525",
                        "content": "'''return ~num & ((1 << (int)Math.Log(num,2)) - 1);'''"
                    }
                ]
            },
            {
                "id": 1566513,
                "content": [
                    {
                        "username": "ammarshareef",
                        "content": "Alright, I really want you to first understand the basic concepts and then I will try my best to break down the problem and explain step by step.\\n\\nMy aim is to make you understand the problem so that you can learn and CODE yourself.\\n\\n**Understanding the Problem Statement**\\n\\n**INPUT**      1 0 1  - 5\\n**OUTPUT**    0 1 0 - 2 *just flipping the bits as you can see. 1 transforms to 0 and 0 to 1. thats it!*\\n\\n\\n**STEPS**\\n\\n1. The first thing that should come to your mind when you want the opposite of any bit is the great XOR operation. Remember the simple rule of XOR. Whenever there is a bit say 1 ^ 0 , 0 ^ 1 then you will always get 1. Rest everytime you get 0.\\n2. Next, you need to figure the bit mask to get the result. Lets take the example of the input - 101 and output 010.\\nso if you XOR these two number then you get your mask required.  Example - (101) ^ (010) = 111 which is 7.\\nSo, if you do 101 ^ 111 = 010 and thats the answer or the output we want! So this is how you got your ** mask**\\n3. Now that you have the mask you just have to convert this logic into meaningful code so that it works for any input.\\none simple formula is. (2Power3)- 1. This will give you 8 AND THEN -1 WILL GIVE YOU **7**. Notice that 3 is the number of bits in the number.\\n4. Just do 101 ^ (2Power3)-1 and thats your output answer.\\n\\n**TASK 1**\\n1. Our first task is to find the number of bits a number has. For this we will run a while  loop till the number becomes 0.\\nYou can do this by taking the MSB (the first bit from the left side) and shift it one time. You can also take the LSB.\\n2. something like this while(num!-0) we do num = (num>>1) and COUNT THE NUMBER OF ITERATIONS, THAT WILL BE THE NUMBER OF BITS IN A NUMBER. THIS WILL GIVE US THE POWER.\\n\\n**TASK 2**\\n1. Now you know what the power is going to be for your number (2(Power)count)-1. Is what you have to do.\\n\\n**TASK 3**\\n1. Just XOR NUM with (2(Power)count) -1 and you will get the result.\\n\\nNOTE: YOU NEED TO SAVE THE NUM IN A TEMP VARIABLE BECASUE THE VALUE OF NUM WILL CHANGE TO 0 UPON DOING THE RIGHT SHIFT OPERATION. SO AT THE END JUST DO RESULT  = (TEMP ^ (2(POWER)COUNT)-1).\\n\\n2 POWER Count is basically 2 being the base and count being the Exponent. I could have used 2^3 to explain but this alsoc could confuse you between the XOR operation.\\n\\n**PRO TIP**\\n\\n2(Power)COUNT IS SAME AS (1<<COUNT)\\nSO BASICALLY YOU HAVE TO DO RESULT  = TEMP ^ (1<<COUNT) - 1;\\n\\nRETURN TEMP AND YOUR DONE.\\nCHEERS!\\n\\n\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-complement/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flip Bit by Bit\n\n  \n**Approach 2:** Compute Bit Length and Construct 1-bits Bitmask\n\n  \n**Approach 3:** Built-in Functions to Construct 1-bits Bitmask\n\n  \n**Approach 4:** highestOneBit OpenJDK algorithm from Hacker's Delight\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "LTKJ",
                        "content": "My solution to Number Complement was judged wrongly.\\n[Here is my submission result.](https://leetcode.com/contest/leetcode-weekly-contest-14/submissions/detail/88323029/) However, when I copied my code and test case to the problem, I got the correct answer.\\n\\n**UPD:** Fixed, thanks Leetcode Team."
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "int findComplement(int num) {\\n        \\n        if(num == 0) return 1;\\n\\n        int ans = 0;\\n        int i = 0;\\n\\n        while(num) {\\n\\n            if(num % 2 == 0) {\\n                ans += pow(2, i);\\n            }\\n\\n            i++;\\n            num /= 2;\\n        }\\n\\n        return ans;\\n}"
                    },
                    {
                        "username": "JoshDev",
                        "content": "num ^ ((Integer.highestOneBit(num) << 1) - 1);"
                    },
                    {
                        "username": "SagaciousB",
                        "content": "Please do not post solutions in the discussion."
                    },
                    {
                        "username": "W.S.YangGuang",
                        "content": "return (((unsigned)1 << (32 - __builtin_clz(num))) - 1) ^ num;\\n\\nusing g++ built in function to count the number of leading zeros."
                    },
                    {
                        "username": "pa-one55",
                        "content": "used vector for storing bits, negate bits, re construct\\n"
                    },
                    {
                        "username": "sonergonul",
                        "content": "For Turkish users, if you have a trouble to understand, here is the explanation;\\n\\nhttps://youtu.be/dHmcZidc37g"
                    },
                    {
                        "username": "justyy",
                        "content": "Nearly the same as https://leetcode.com/problems/complement-of-base-10-integer/\\njust need to handle the case when N=0"
                    },
                    {
                        "username": "kille6525",
                        "content": "'''return ~num & ((1 << (int)Math.Log(num,2)) - 1);'''"
                    }
                ]
            },
            {
                "id": 1663138,
                "content": [
                    {
                        "username": "ammarshareef",
                        "content": "Alright, I really want you to first understand the basic concepts and then I will try my best to break down the problem and explain step by step.\\n\\nMy aim is to make you understand the problem so that you can learn and CODE yourself.\\n\\n**Understanding the Problem Statement**\\n\\n**INPUT**      1 0 1  - 5\\n**OUTPUT**    0 1 0 - 2 *just flipping the bits as you can see. 1 transforms to 0 and 0 to 1. thats it!*\\n\\n\\n**STEPS**\\n\\n1. The first thing that should come to your mind when you want the opposite of any bit is the great XOR operation. Remember the simple rule of XOR. Whenever there is a bit say 1 ^ 0 , 0 ^ 1 then you will always get 1. Rest everytime you get 0.\\n2. Next, you need to figure the bit mask to get the result. Lets take the example of the input - 101 and output 010.\\nso if you XOR these two number then you get your mask required.  Example - (101) ^ (010) = 111 which is 7.\\nSo, if you do 101 ^ 111 = 010 and thats the answer or the output we want! So this is how you got your ** mask**\\n3. Now that you have the mask you just have to convert this logic into meaningful code so that it works for any input.\\none simple formula is. (2Power3)- 1. This will give you 8 AND THEN -1 WILL GIVE YOU **7**. Notice that 3 is the number of bits in the number.\\n4. Just do 101 ^ (2Power3)-1 and thats your output answer.\\n\\n**TASK 1**\\n1. Our first task is to find the number of bits a number has. For this we will run a while  loop till the number becomes 0.\\nYou can do this by taking the MSB (the first bit from the left side) and shift it one time. You can also take the LSB.\\n2. something like this while(num!-0) we do num = (num>>1) and COUNT THE NUMBER OF ITERATIONS, THAT WILL BE THE NUMBER OF BITS IN A NUMBER. THIS WILL GIVE US THE POWER.\\n\\n**TASK 2**\\n1. Now you know what the power is going to be for your number (2(Power)count)-1. Is what you have to do.\\n\\n**TASK 3**\\n1. Just XOR NUM with (2(Power)count) -1 and you will get the result.\\n\\nNOTE: YOU NEED TO SAVE THE NUM IN A TEMP VARIABLE BECASUE THE VALUE OF NUM WILL CHANGE TO 0 UPON DOING THE RIGHT SHIFT OPERATION. SO AT THE END JUST DO RESULT  = (TEMP ^ (2(POWER)COUNT)-1).\\n\\n2 POWER Count is basically 2 being the base and count being the Exponent. I could have used 2^3 to explain but this alsoc could confuse you between the XOR operation.\\n\\n**PRO TIP**\\n\\n2(Power)COUNT IS SAME AS (1<<COUNT)\\nSO BASICALLY YOU HAVE TO DO RESULT  = TEMP ^ (1<<COUNT) - 1;\\n\\nRETURN TEMP AND YOUR DONE.\\nCHEERS!\\n\\n\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-complement/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flip Bit by Bit\n\n  \n**Approach 2:** Compute Bit Length and Construct 1-bits Bitmask\n\n  \n**Approach 3:** Built-in Functions to Construct 1-bits Bitmask\n\n  \n**Approach 4:** highestOneBit OpenJDK algorithm from Hacker's Delight\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "LTKJ",
                        "content": "My solution to Number Complement was judged wrongly.\\n[Here is my submission result.](https://leetcode.com/contest/leetcode-weekly-contest-14/submissions/detail/88323029/) However, when I copied my code and test case to the problem, I got the correct answer.\\n\\n**UPD:** Fixed, thanks Leetcode Team."
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "int findComplement(int num) {\\n        \\n        if(num == 0) return 1;\\n\\n        int ans = 0;\\n        int i = 0;\\n\\n        while(num) {\\n\\n            if(num % 2 == 0) {\\n                ans += pow(2, i);\\n            }\\n\\n            i++;\\n            num /= 2;\\n        }\\n\\n        return ans;\\n}"
                    },
                    {
                        "username": "JoshDev",
                        "content": "num ^ ((Integer.highestOneBit(num) << 1) - 1);"
                    },
                    {
                        "username": "SagaciousB",
                        "content": "Please do not post solutions in the discussion."
                    },
                    {
                        "username": "W.S.YangGuang",
                        "content": "return (((unsigned)1 << (32 - __builtin_clz(num))) - 1) ^ num;\\n\\nusing g++ built in function to count the number of leading zeros."
                    },
                    {
                        "username": "pa-one55",
                        "content": "used vector for storing bits, negate bits, re construct\\n"
                    },
                    {
                        "username": "sonergonul",
                        "content": "For Turkish users, if you have a trouble to understand, here is the explanation;\\n\\nhttps://youtu.be/dHmcZidc37g"
                    },
                    {
                        "username": "justyy",
                        "content": "Nearly the same as https://leetcode.com/problems/complement-of-base-10-integer/\\njust need to handle the case when N=0"
                    },
                    {
                        "username": "kille6525",
                        "content": "'''return ~num & ((1 << (int)Math.Log(num,2)) - 1);'''"
                    }
                ]
            },
            {
                "id": 1571747,
                "content": [
                    {
                        "username": "ammarshareef",
                        "content": "Alright, I really want you to first understand the basic concepts and then I will try my best to break down the problem and explain step by step.\\n\\nMy aim is to make you understand the problem so that you can learn and CODE yourself.\\n\\n**Understanding the Problem Statement**\\n\\n**INPUT**      1 0 1  - 5\\n**OUTPUT**    0 1 0 - 2 *just flipping the bits as you can see. 1 transforms to 0 and 0 to 1. thats it!*\\n\\n\\n**STEPS**\\n\\n1. The first thing that should come to your mind when you want the opposite of any bit is the great XOR operation. Remember the simple rule of XOR. Whenever there is a bit say 1 ^ 0 , 0 ^ 1 then you will always get 1. Rest everytime you get 0.\\n2. Next, you need to figure the bit mask to get the result. Lets take the example of the input - 101 and output 010.\\nso if you XOR these two number then you get your mask required.  Example - (101) ^ (010) = 111 which is 7.\\nSo, if you do 101 ^ 111 = 010 and thats the answer or the output we want! So this is how you got your ** mask**\\n3. Now that you have the mask you just have to convert this logic into meaningful code so that it works for any input.\\none simple formula is. (2Power3)- 1. This will give you 8 AND THEN -1 WILL GIVE YOU **7**. Notice that 3 is the number of bits in the number.\\n4. Just do 101 ^ (2Power3)-1 and thats your output answer.\\n\\n**TASK 1**\\n1. Our first task is to find the number of bits a number has. For this we will run a while  loop till the number becomes 0.\\nYou can do this by taking the MSB (the first bit from the left side) and shift it one time. You can also take the LSB.\\n2. something like this while(num!-0) we do num = (num>>1) and COUNT THE NUMBER OF ITERATIONS, THAT WILL BE THE NUMBER OF BITS IN A NUMBER. THIS WILL GIVE US THE POWER.\\n\\n**TASK 2**\\n1. Now you know what the power is going to be for your number (2(Power)count)-1. Is what you have to do.\\n\\n**TASK 3**\\n1. Just XOR NUM with (2(Power)count) -1 and you will get the result.\\n\\nNOTE: YOU NEED TO SAVE THE NUM IN A TEMP VARIABLE BECASUE THE VALUE OF NUM WILL CHANGE TO 0 UPON DOING THE RIGHT SHIFT OPERATION. SO AT THE END JUST DO RESULT  = (TEMP ^ (2(POWER)COUNT)-1).\\n\\n2 POWER Count is basically 2 being the base and count being the Exponent. I could have used 2^3 to explain but this alsoc could confuse you between the XOR operation.\\n\\n**PRO TIP**\\n\\n2(Power)COUNT IS SAME AS (1<<COUNT)\\nSO BASICALLY YOU HAVE TO DO RESULT  = TEMP ^ (1<<COUNT) - 1;\\n\\nRETURN TEMP AND YOUR DONE.\\nCHEERS!\\n\\n\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-complement/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flip Bit by Bit\n\n  \n**Approach 2:** Compute Bit Length and Construct 1-bits Bitmask\n\n  \n**Approach 3:** Built-in Functions to Construct 1-bits Bitmask\n\n  \n**Approach 4:** highestOneBit OpenJDK algorithm from Hacker's Delight\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "LTKJ",
                        "content": "My solution to Number Complement was judged wrongly.\\n[Here is my submission result.](https://leetcode.com/contest/leetcode-weekly-contest-14/submissions/detail/88323029/) However, when I copied my code and test case to the problem, I got the correct answer.\\n\\n**UPD:** Fixed, thanks Leetcode Team."
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "int findComplement(int num) {\\n        \\n        if(num == 0) return 1;\\n\\n        int ans = 0;\\n        int i = 0;\\n\\n        while(num) {\\n\\n            if(num % 2 == 0) {\\n                ans += pow(2, i);\\n            }\\n\\n            i++;\\n            num /= 2;\\n        }\\n\\n        return ans;\\n}"
                    },
                    {
                        "username": "JoshDev",
                        "content": "num ^ ((Integer.highestOneBit(num) << 1) - 1);"
                    },
                    {
                        "username": "SagaciousB",
                        "content": "Please do not post solutions in the discussion."
                    },
                    {
                        "username": "W.S.YangGuang",
                        "content": "return (((unsigned)1 << (32 - __builtin_clz(num))) - 1) ^ num;\\n\\nusing g++ built in function to count the number of leading zeros."
                    },
                    {
                        "username": "pa-one55",
                        "content": "used vector for storing bits, negate bits, re construct\\n"
                    },
                    {
                        "username": "sonergonul",
                        "content": "For Turkish users, if you have a trouble to understand, here is the explanation;\\n\\nhttps://youtu.be/dHmcZidc37g"
                    },
                    {
                        "username": "justyy",
                        "content": "Nearly the same as https://leetcode.com/problems/complement-of-base-10-integer/\\njust need to handle the case when N=0"
                    },
                    {
                        "username": "kille6525",
                        "content": "'''return ~num & ((1 << (int)Math.Log(num,2)) - 1);'''"
                    }
                ]
            },
            {
                "id": 1569126,
                "content": [
                    {
                        "username": "ammarshareef",
                        "content": "Alright, I really want you to first understand the basic concepts and then I will try my best to break down the problem and explain step by step.\\n\\nMy aim is to make you understand the problem so that you can learn and CODE yourself.\\n\\n**Understanding the Problem Statement**\\n\\n**INPUT**      1 0 1  - 5\\n**OUTPUT**    0 1 0 - 2 *just flipping the bits as you can see. 1 transforms to 0 and 0 to 1. thats it!*\\n\\n\\n**STEPS**\\n\\n1. The first thing that should come to your mind when you want the opposite of any bit is the great XOR operation. Remember the simple rule of XOR. Whenever there is a bit say 1 ^ 0 , 0 ^ 1 then you will always get 1. Rest everytime you get 0.\\n2. Next, you need to figure the bit mask to get the result. Lets take the example of the input - 101 and output 010.\\nso if you XOR these two number then you get your mask required.  Example - (101) ^ (010) = 111 which is 7.\\nSo, if you do 101 ^ 111 = 010 and thats the answer or the output we want! So this is how you got your ** mask**\\n3. Now that you have the mask you just have to convert this logic into meaningful code so that it works for any input.\\none simple formula is. (2Power3)- 1. This will give you 8 AND THEN -1 WILL GIVE YOU **7**. Notice that 3 is the number of bits in the number.\\n4. Just do 101 ^ (2Power3)-1 and thats your output answer.\\n\\n**TASK 1**\\n1. Our first task is to find the number of bits a number has. For this we will run a while  loop till the number becomes 0.\\nYou can do this by taking the MSB (the first bit from the left side) and shift it one time. You can also take the LSB.\\n2. something like this while(num!-0) we do num = (num>>1) and COUNT THE NUMBER OF ITERATIONS, THAT WILL BE THE NUMBER OF BITS IN A NUMBER. THIS WILL GIVE US THE POWER.\\n\\n**TASK 2**\\n1. Now you know what the power is going to be for your number (2(Power)count)-1. Is what you have to do.\\n\\n**TASK 3**\\n1. Just XOR NUM with (2(Power)count) -1 and you will get the result.\\n\\nNOTE: YOU NEED TO SAVE THE NUM IN A TEMP VARIABLE BECASUE THE VALUE OF NUM WILL CHANGE TO 0 UPON DOING THE RIGHT SHIFT OPERATION. SO AT THE END JUST DO RESULT  = (TEMP ^ (2(POWER)COUNT)-1).\\n\\n2 POWER Count is basically 2 being the base and count being the Exponent. I could have used 2^3 to explain but this alsoc could confuse you between the XOR operation.\\n\\n**PRO TIP**\\n\\n2(Power)COUNT IS SAME AS (1<<COUNT)\\nSO BASICALLY YOU HAVE TO DO RESULT  = TEMP ^ (1<<COUNT) - 1;\\n\\nRETURN TEMP AND YOUR DONE.\\nCHEERS!\\n\\n\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-complement/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flip Bit by Bit\n\n  \n**Approach 2:** Compute Bit Length and Construct 1-bits Bitmask\n\n  \n**Approach 3:** Built-in Functions to Construct 1-bits Bitmask\n\n  \n**Approach 4:** highestOneBit OpenJDK algorithm from Hacker's Delight\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "LTKJ",
                        "content": "My solution to Number Complement was judged wrongly.\\n[Here is my submission result.](https://leetcode.com/contest/leetcode-weekly-contest-14/submissions/detail/88323029/) However, when I copied my code and test case to the problem, I got the correct answer.\\n\\n**UPD:** Fixed, thanks Leetcode Team."
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "int findComplement(int num) {\\n        \\n        if(num == 0) return 1;\\n\\n        int ans = 0;\\n        int i = 0;\\n\\n        while(num) {\\n\\n            if(num % 2 == 0) {\\n                ans += pow(2, i);\\n            }\\n\\n            i++;\\n            num /= 2;\\n        }\\n\\n        return ans;\\n}"
                    },
                    {
                        "username": "JoshDev",
                        "content": "num ^ ((Integer.highestOneBit(num) << 1) - 1);"
                    },
                    {
                        "username": "SagaciousB",
                        "content": "Please do not post solutions in the discussion."
                    },
                    {
                        "username": "W.S.YangGuang",
                        "content": "return (((unsigned)1 << (32 - __builtin_clz(num))) - 1) ^ num;\\n\\nusing g++ built in function to count the number of leading zeros."
                    },
                    {
                        "username": "pa-one55",
                        "content": "used vector for storing bits, negate bits, re construct\\n"
                    },
                    {
                        "username": "sonergonul",
                        "content": "For Turkish users, if you have a trouble to understand, here is the explanation;\\n\\nhttps://youtu.be/dHmcZidc37g"
                    },
                    {
                        "username": "justyy",
                        "content": "Nearly the same as https://leetcode.com/problems/complement-of-base-10-integer/\\njust need to handle the case when N=0"
                    },
                    {
                        "username": "kille6525",
                        "content": "'''return ~num & ((1 << (int)Math.Log(num,2)) - 1);'''"
                    }
                ]
            },
            {
                "id": 2007769,
                "content": [
                    {
                        "username": "ammarshareef",
                        "content": "Alright, I really want you to first understand the basic concepts and then I will try my best to break down the problem and explain step by step.\\n\\nMy aim is to make you understand the problem so that you can learn and CODE yourself.\\n\\n**Understanding the Problem Statement**\\n\\n**INPUT**      1 0 1  - 5\\n**OUTPUT**    0 1 0 - 2 *just flipping the bits as you can see. 1 transforms to 0 and 0 to 1. thats it!*\\n\\n\\n**STEPS**\\n\\n1. The first thing that should come to your mind when you want the opposite of any bit is the great XOR operation. Remember the simple rule of XOR. Whenever there is a bit say 1 ^ 0 , 0 ^ 1 then you will always get 1. Rest everytime you get 0.\\n2. Next, you need to figure the bit mask to get the result. Lets take the example of the input - 101 and output 010.\\nso if you XOR these two number then you get your mask required.  Example - (101) ^ (010) = 111 which is 7.\\nSo, if you do 101 ^ 111 = 010 and thats the answer or the output we want! So this is how you got your ** mask**\\n3. Now that you have the mask you just have to convert this logic into meaningful code so that it works for any input.\\none simple formula is. (2Power3)- 1. This will give you 8 AND THEN -1 WILL GIVE YOU **7**. Notice that 3 is the number of bits in the number.\\n4. Just do 101 ^ (2Power3)-1 and thats your output answer.\\n\\n**TASK 1**\\n1. Our first task is to find the number of bits a number has. For this we will run a while  loop till the number becomes 0.\\nYou can do this by taking the MSB (the first bit from the left side) and shift it one time. You can also take the LSB.\\n2. something like this while(num!-0) we do num = (num>>1) and COUNT THE NUMBER OF ITERATIONS, THAT WILL BE THE NUMBER OF BITS IN A NUMBER. THIS WILL GIVE US THE POWER.\\n\\n**TASK 2**\\n1. Now you know what the power is going to be for your number (2(Power)count)-1. Is what you have to do.\\n\\n**TASK 3**\\n1. Just XOR NUM with (2(Power)count) -1 and you will get the result.\\n\\nNOTE: YOU NEED TO SAVE THE NUM IN A TEMP VARIABLE BECASUE THE VALUE OF NUM WILL CHANGE TO 0 UPON DOING THE RIGHT SHIFT OPERATION. SO AT THE END JUST DO RESULT  = (TEMP ^ (2(POWER)COUNT)-1).\\n\\n2 POWER Count is basically 2 being the base and count being the Exponent. I could have used 2^3 to explain but this alsoc could confuse you between the XOR operation.\\n\\n**PRO TIP**\\n\\n2(Power)COUNT IS SAME AS (1<<COUNT)\\nSO BASICALLY YOU HAVE TO DO RESULT  = TEMP ^ (1<<COUNT) - 1;\\n\\nRETURN TEMP AND YOUR DONE.\\nCHEERS!\\n\\n\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-complement/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flip Bit by Bit\n\n  \n**Approach 2:** Compute Bit Length and Construct 1-bits Bitmask\n\n  \n**Approach 3:** Built-in Functions to Construct 1-bits Bitmask\n\n  \n**Approach 4:** highestOneBit OpenJDK algorithm from Hacker's Delight\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "LTKJ",
                        "content": "My solution to Number Complement was judged wrongly.\\n[Here is my submission result.](https://leetcode.com/contest/leetcode-weekly-contest-14/submissions/detail/88323029/) However, when I copied my code and test case to the problem, I got the correct answer.\\n\\n**UPD:** Fixed, thanks Leetcode Team."
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "int findComplement(int num) {\\n        \\n        if(num == 0) return 1;\\n\\n        int ans = 0;\\n        int i = 0;\\n\\n        while(num) {\\n\\n            if(num % 2 == 0) {\\n                ans += pow(2, i);\\n            }\\n\\n            i++;\\n            num /= 2;\\n        }\\n\\n        return ans;\\n}"
                    },
                    {
                        "username": "JoshDev",
                        "content": "num ^ ((Integer.highestOneBit(num) << 1) - 1);"
                    },
                    {
                        "username": "SagaciousB",
                        "content": "Please do not post solutions in the discussion."
                    },
                    {
                        "username": "W.S.YangGuang",
                        "content": "return (((unsigned)1 << (32 - __builtin_clz(num))) - 1) ^ num;\\n\\nusing g++ built in function to count the number of leading zeros."
                    },
                    {
                        "username": "pa-one55",
                        "content": "used vector for storing bits, negate bits, re construct\\n"
                    },
                    {
                        "username": "sonergonul",
                        "content": "For Turkish users, if you have a trouble to understand, here is the explanation;\\n\\nhttps://youtu.be/dHmcZidc37g"
                    },
                    {
                        "username": "justyy",
                        "content": "Nearly the same as https://leetcode.com/problems/complement-of-base-10-integer/\\njust need to handle the case when N=0"
                    },
                    {
                        "username": "kille6525",
                        "content": "'''return ~num & ((1 << (int)Math.Log(num,2)) - 1);'''"
                    }
                ]
            },
            {
                "id": 1574822,
                "content": [
                    {
                        "username": "ammarshareef",
                        "content": "Alright, I really want you to first understand the basic concepts and then I will try my best to break down the problem and explain step by step.\\n\\nMy aim is to make you understand the problem so that you can learn and CODE yourself.\\n\\n**Understanding the Problem Statement**\\n\\n**INPUT**      1 0 1  - 5\\n**OUTPUT**    0 1 0 - 2 *just flipping the bits as you can see. 1 transforms to 0 and 0 to 1. thats it!*\\n\\n\\n**STEPS**\\n\\n1. The first thing that should come to your mind when you want the opposite of any bit is the great XOR operation. Remember the simple rule of XOR. Whenever there is a bit say 1 ^ 0 , 0 ^ 1 then you will always get 1. Rest everytime you get 0.\\n2. Next, you need to figure the bit mask to get the result. Lets take the example of the input - 101 and output 010.\\nso if you XOR these two number then you get your mask required.  Example - (101) ^ (010) = 111 which is 7.\\nSo, if you do 101 ^ 111 = 010 and thats the answer or the output we want! So this is how you got your ** mask**\\n3. Now that you have the mask you just have to convert this logic into meaningful code so that it works for any input.\\none simple formula is. (2Power3)- 1. This will give you 8 AND THEN -1 WILL GIVE YOU **7**. Notice that 3 is the number of bits in the number.\\n4. Just do 101 ^ (2Power3)-1 and thats your output answer.\\n\\n**TASK 1**\\n1. Our first task is to find the number of bits a number has. For this we will run a while  loop till the number becomes 0.\\nYou can do this by taking the MSB (the first bit from the left side) and shift it one time. You can also take the LSB.\\n2. something like this while(num!-0) we do num = (num>>1) and COUNT THE NUMBER OF ITERATIONS, THAT WILL BE THE NUMBER OF BITS IN A NUMBER. THIS WILL GIVE US THE POWER.\\n\\n**TASK 2**\\n1. Now you know what the power is going to be for your number (2(Power)count)-1. Is what you have to do.\\n\\n**TASK 3**\\n1. Just XOR NUM with (2(Power)count) -1 and you will get the result.\\n\\nNOTE: YOU NEED TO SAVE THE NUM IN A TEMP VARIABLE BECASUE THE VALUE OF NUM WILL CHANGE TO 0 UPON DOING THE RIGHT SHIFT OPERATION. SO AT THE END JUST DO RESULT  = (TEMP ^ (2(POWER)COUNT)-1).\\n\\n2 POWER Count is basically 2 being the base and count being the Exponent. I could have used 2^3 to explain but this alsoc could confuse you between the XOR operation.\\n\\n**PRO TIP**\\n\\n2(Power)COUNT IS SAME AS (1<<COUNT)\\nSO BASICALLY YOU HAVE TO DO RESULT  = TEMP ^ (1<<COUNT) - 1;\\n\\nRETURN TEMP AND YOUR DONE.\\nCHEERS!\\n\\n\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-complement/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flip Bit by Bit\n\n  \n**Approach 2:** Compute Bit Length and Construct 1-bits Bitmask\n\n  \n**Approach 3:** Built-in Functions to Construct 1-bits Bitmask\n\n  \n**Approach 4:** highestOneBit OpenJDK algorithm from Hacker's Delight\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "LTKJ",
                        "content": "My solution to Number Complement was judged wrongly.\\n[Here is my submission result.](https://leetcode.com/contest/leetcode-weekly-contest-14/submissions/detail/88323029/) However, when I copied my code and test case to the problem, I got the correct answer.\\n\\n**UPD:** Fixed, thanks Leetcode Team."
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "int findComplement(int num) {\\n        \\n        if(num == 0) return 1;\\n\\n        int ans = 0;\\n        int i = 0;\\n\\n        while(num) {\\n\\n            if(num % 2 == 0) {\\n                ans += pow(2, i);\\n            }\\n\\n            i++;\\n            num /= 2;\\n        }\\n\\n        return ans;\\n}"
                    },
                    {
                        "username": "JoshDev",
                        "content": "num ^ ((Integer.highestOneBit(num) << 1) - 1);"
                    },
                    {
                        "username": "SagaciousB",
                        "content": "Please do not post solutions in the discussion."
                    },
                    {
                        "username": "W.S.YangGuang",
                        "content": "return (((unsigned)1 << (32 - __builtin_clz(num))) - 1) ^ num;\\n\\nusing g++ built in function to count the number of leading zeros."
                    },
                    {
                        "username": "pa-one55",
                        "content": "used vector for storing bits, negate bits, re construct\\n"
                    },
                    {
                        "username": "sonergonul",
                        "content": "For Turkish users, if you have a trouble to understand, here is the explanation;\\n\\nhttps://youtu.be/dHmcZidc37g"
                    },
                    {
                        "username": "justyy",
                        "content": "Nearly the same as https://leetcode.com/problems/complement-of-base-10-integer/\\njust need to handle the case when N=0"
                    },
                    {
                        "username": "kille6525",
                        "content": "'''return ~num & ((1 << (int)Math.Log(num,2)) - 1);'''"
                    }
                ]
            },
            {
                "id": 1572571,
                "content": [
                    {
                        "username": "ammarshareef",
                        "content": "Alright, I really want you to first understand the basic concepts and then I will try my best to break down the problem and explain step by step.\\n\\nMy aim is to make you understand the problem so that you can learn and CODE yourself.\\n\\n**Understanding the Problem Statement**\\n\\n**INPUT**      1 0 1  - 5\\n**OUTPUT**    0 1 0 - 2 *just flipping the bits as you can see. 1 transforms to 0 and 0 to 1. thats it!*\\n\\n\\n**STEPS**\\n\\n1. The first thing that should come to your mind when you want the opposite of any bit is the great XOR operation. Remember the simple rule of XOR. Whenever there is a bit say 1 ^ 0 , 0 ^ 1 then you will always get 1. Rest everytime you get 0.\\n2. Next, you need to figure the bit mask to get the result. Lets take the example of the input - 101 and output 010.\\nso if you XOR these two number then you get your mask required.  Example - (101) ^ (010) = 111 which is 7.\\nSo, if you do 101 ^ 111 = 010 and thats the answer or the output we want! So this is how you got your ** mask**\\n3. Now that you have the mask you just have to convert this logic into meaningful code so that it works for any input.\\none simple formula is. (2Power3)- 1. This will give you 8 AND THEN -1 WILL GIVE YOU **7**. Notice that 3 is the number of bits in the number.\\n4. Just do 101 ^ (2Power3)-1 and thats your output answer.\\n\\n**TASK 1**\\n1. Our first task is to find the number of bits a number has. For this we will run a while  loop till the number becomes 0.\\nYou can do this by taking the MSB (the first bit from the left side) and shift it one time. You can also take the LSB.\\n2. something like this while(num!-0) we do num = (num>>1) and COUNT THE NUMBER OF ITERATIONS, THAT WILL BE THE NUMBER OF BITS IN A NUMBER. THIS WILL GIVE US THE POWER.\\n\\n**TASK 2**\\n1. Now you know what the power is going to be for your number (2(Power)count)-1. Is what you have to do.\\n\\n**TASK 3**\\n1. Just XOR NUM with (2(Power)count) -1 and you will get the result.\\n\\nNOTE: YOU NEED TO SAVE THE NUM IN A TEMP VARIABLE BECASUE THE VALUE OF NUM WILL CHANGE TO 0 UPON DOING THE RIGHT SHIFT OPERATION. SO AT THE END JUST DO RESULT  = (TEMP ^ (2(POWER)COUNT)-1).\\n\\n2 POWER Count is basically 2 being the base and count being the Exponent. I could have used 2^3 to explain but this alsoc could confuse you between the XOR operation.\\n\\n**PRO TIP**\\n\\n2(Power)COUNT IS SAME AS (1<<COUNT)\\nSO BASICALLY YOU HAVE TO DO RESULT  = TEMP ^ (1<<COUNT) - 1;\\n\\nRETURN TEMP AND YOUR DONE.\\nCHEERS!\\n\\n\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-complement/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flip Bit by Bit\n\n  \n**Approach 2:** Compute Bit Length and Construct 1-bits Bitmask\n\n  \n**Approach 3:** Built-in Functions to Construct 1-bits Bitmask\n\n  \n**Approach 4:** highestOneBit OpenJDK algorithm from Hacker's Delight\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "LTKJ",
                        "content": "My solution to Number Complement was judged wrongly.\\n[Here is my submission result.](https://leetcode.com/contest/leetcode-weekly-contest-14/submissions/detail/88323029/) However, when I copied my code and test case to the problem, I got the correct answer.\\n\\n**UPD:** Fixed, thanks Leetcode Team."
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "int findComplement(int num) {\\n        \\n        if(num == 0) return 1;\\n\\n        int ans = 0;\\n        int i = 0;\\n\\n        while(num) {\\n\\n            if(num % 2 == 0) {\\n                ans += pow(2, i);\\n            }\\n\\n            i++;\\n            num /= 2;\\n        }\\n\\n        return ans;\\n}"
                    },
                    {
                        "username": "JoshDev",
                        "content": "num ^ ((Integer.highestOneBit(num) << 1) - 1);"
                    },
                    {
                        "username": "SagaciousB",
                        "content": "Please do not post solutions in the discussion."
                    },
                    {
                        "username": "W.S.YangGuang",
                        "content": "return (((unsigned)1 << (32 - __builtin_clz(num))) - 1) ^ num;\\n\\nusing g++ built in function to count the number of leading zeros."
                    },
                    {
                        "username": "pa-one55",
                        "content": "used vector for storing bits, negate bits, re construct\\n"
                    },
                    {
                        "username": "sonergonul",
                        "content": "For Turkish users, if you have a trouble to understand, here is the explanation;\\n\\nhttps://youtu.be/dHmcZidc37g"
                    },
                    {
                        "username": "justyy",
                        "content": "Nearly the same as https://leetcode.com/problems/complement-of-base-10-integer/\\njust need to handle the case when N=0"
                    },
                    {
                        "username": "kille6525",
                        "content": "'''return ~num & ((1 << (int)Math.Log(num,2)) - 1);'''"
                    }
                ]
            },
            {
                "id": 1571746,
                "content": [
                    {
                        "username": "ammarshareef",
                        "content": "Alright, I really want you to first understand the basic concepts and then I will try my best to break down the problem and explain step by step.\\n\\nMy aim is to make you understand the problem so that you can learn and CODE yourself.\\n\\n**Understanding the Problem Statement**\\n\\n**INPUT**      1 0 1  - 5\\n**OUTPUT**    0 1 0 - 2 *just flipping the bits as you can see. 1 transforms to 0 and 0 to 1. thats it!*\\n\\n\\n**STEPS**\\n\\n1. The first thing that should come to your mind when you want the opposite of any bit is the great XOR operation. Remember the simple rule of XOR. Whenever there is a bit say 1 ^ 0 , 0 ^ 1 then you will always get 1. Rest everytime you get 0.\\n2. Next, you need to figure the bit mask to get the result. Lets take the example of the input - 101 and output 010.\\nso if you XOR these two number then you get your mask required.  Example - (101) ^ (010) = 111 which is 7.\\nSo, if you do 101 ^ 111 = 010 and thats the answer or the output we want! So this is how you got your ** mask**\\n3. Now that you have the mask you just have to convert this logic into meaningful code so that it works for any input.\\none simple formula is. (2Power3)- 1. This will give you 8 AND THEN -1 WILL GIVE YOU **7**. Notice that 3 is the number of bits in the number.\\n4. Just do 101 ^ (2Power3)-1 and thats your output answer.\\n\\n**TASK 1**\\n1. Our first task is to find the number of bits a number has. For this we will run a while  loop till the number becomes 0.\\nYou can do this by taking the MSB (the first bit from the left side) and shift it one time. You can also take the LSB.\\n2. something like this while(num!-0) we do num = (num>>1) and COUNT THE NUMBER OF ITERATIONS, THAT WILL BE THE NUMBER OF BITS IN A NUMBER. THIS WILL GIVE US THE POWER.\\n\\n**TASK 2**\\n1. Now you know what the power is going to be for your number (2(Power)count)-1. Is what you have to do.\\n\\n**TASK 3**\\n1. Just XOR NUM with (2(Power)count) -1 and you will get the result.\\n\\nNOTE: YOU NEED TO SAVE THE NUM IN A TEMP VARIABLE BECASUE THE VALUE OF NUM WILL CHANGE TO 0 UPON DOING THE RIGHT SHIFT OPERATION. SO AT THE END JUST DO RESULT  = (TEMP ^ (2(POWER)COUNT)-1).\\n\\n2 POWER Count is basically 2 being the base and count being the Exponent. I could have used 2^3 to explain but this alsoc could confuse you between the XOR operation.\\n\\n**PRO TIP**\\n\\n2(Power)COUNT IS SAME AS (1<<COUNT)\\nSO BASICALLY YOU HAVE TO DO RESULT  = TEMP ^ (1<<COUNT) - 1;\\n\\nRETURN TEMP AND YOUR DONE.\\nCHEERS!\\n\\n\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-complement/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flip Bit by Bit\n\n  \n**Approach 2:** Compute Bit Length and Construct 1-bits Bitmask\n\n  \n**Approach 3:** Built-in Functions to Construct 1-bits Bitmask\n\n  \n**Approach 4:** highestOneBit OpenJDK algorithm from Hacker's Delight\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "LTKJ",
                        "content": "My solution to Number Complement was judged wrongly.\\n[Here is my submission result.](https://leetcode.com/contest/leetcode-weekly-contest-14/submissions/detail/88323029/) However, when I copied my code and test case to the problem, I got the correct answer.\\n\\n**UPD:** Fixed, thanks Leetcode Team."
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "int findComplement(int num) {\\n        \\n        if(num == 0) return 1;\\n\\n        int ans = 0;\\n        int i = 0;\\n\\n        while(num) {\\n\\n            if(num % 2 == 0) {\\n                ans += pow(2, i);\\n            }\\n\\n            i++;\\n            num /= 2;\\n        }\\n\\n        return ans;\\n}"
                    },
                    {
                        "username": "JoshDev",
                        "content": "num ^ ((Integer.highestOneBit(num) << 1) - 1);"
                    },
                    {
                        "username": "SagaciousB",
                        "content": "Please do not post solutions in the discussion."
                    },
                    {
                        "username": "W.S.YangGuang",
                        "content": "return (((unsigned)1 << (32 - __builtin_clz(num))) - 1) ^ num;\\n\\nusing g++ built in function to count the number of leading zeros."
                    },
                    {
                        "username": "pa-one55",
                        "content": "used vector for storing bits, negate bits, re construct\\n"
                    },
                    {
                        "username": "sonergonul",
                        "content": "For Turkish users, if you have a trouble to understand, here is the explanation;\\n\\nhttps://youtu.be/dHmcZidc37g"
                    },
                    {
                        "username": "justyy",
                        "content": "Nearly the same as https://leetcode.com/problems/complement-of-base-10-integer/\\njust need to handle the case when N=0"
                    },
                    {
                        "username": "kille6525",
                        "content": "'''return ~num & ((1 << (int)Math.Log(num,2)) - 1);'''"
                    }
                ]
            }
        ]
    },
    {
        "title": "Total Hamming Distance",
        "question_content": "<p>The <a href=\"https://en.wikipedia.org/wiki/Hamming_distance\" target=\"_blank\">Hamming distance</a> between two integers is the number of positions at which the corresponding bits are different.</p>\n\n<p>Given an integer array <code>nums</code>, return <em>the sum of <strong>Hamming distances</strong> between all the pairs of the integers in</em> <code>nums</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [4,14,2]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just\nshowing the four bits relevant in this case).\nThe answer will be:\nHammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [4,14,4]\n<strong>Output:</strong> 4\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li>The answer for the given input will fit in a <strong>32-bit</strong> integer.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 96226,
                "title": "java-o-n-time-o-1-space",
                "content": "For each bit position 1-32 in a 32-bit integer, we count the number of integers in the array which have that bit set. Then, if there are n integers in the array and k of them have a particular bit set and (n-k) do not, then that bit contributes k*(n-k) hamming distance to the total.\\n\\n```\\npublic int totalHammingDistance(int[] nums) {\\n    int total = 0, n = nums.length;\\n    for (int j=0;j<32;j++) {\\n        int bitCount = 0;\\n        for (int i=0;i<n;i++) \\n            bitCount += (nums[i] >> j) & 1;\\n        total += bitCount*(n - bitCount);\\n    }\\n    return total;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int totalHammingDistance(int[] nums) {\\n    int total = 0, n = nums.length;\\n    for (int j=0;j<32;j++) {\\n        int bitCount = 0;\\n        for (int i=0;i<n;i++) \\n            bitCount += (nums[i] >> j) & 1;\\n        total += bitCount*(n - bitCount);\\n    }\\n    return total;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 96243,
                "title": "share-my-o-n-c-bitwise-solution-with-thinking-process-and-explanation",
                "content": "---\\n## 1. Problem\\n\\n---\\nThe problem is to find the total Hamming distance between all pairs of the given numbers.\\n\\n---\\n## 2. Thinking process\\n\\n---\\n#### 2.1 For one pair\\n\\n---\\nWhen you calculate Hamming distance between x and y, you just\\n\\n---\\n1. calculate p = x ^ y;\\n2. count the number of 1's in p\\n\\n---\\n**The distance from x to y is as same as y to x.**\\n\\n---\\n#### 2.2 Trivial approach\\n\\n---\\nFor a series of number: a1, a2, a3,..., an\\n\\nUse the approach in 2.1\\n(suppose distance(x, y) is the Hamming distance between x and y):\\n\\nFor a1, calculate S(1) = distance(a1, a2)+distance(a1, a3)+ ... +distance(a1, an)\\nFor a2, calculate S(2) = distance(a2, a3)+distance(a2, a4)+ ... +distance(a2, an)\\n......\\nFor a(n - 1), calculate S(n - 1) = distance(a(n - 1), a(n))\\n\\nFinally , **S = S(1) + S(2) + ... + S(n - 1)**.\\n\\nThe function distance is called **1 + 2 + ... + (n - 1) = n(n - 1)/2** times! That's too much!\\n\\n---\\n#### 2.3 New idea\\n\\n---\\nThe total Hamming distance is constructed **bit by bit** in this approach.\\n\\nLet's take a series of number: **a1, a2, a3,..., an**\\n\\nJust think about all the **Least Significant Bit (LSB)** of a(k) (1 \\u2264 k \\u2264 n).\\n\\n**How many Hamming distance will they bring to the total?**\\n\\n1. If a pair of number has same LSB, the total distance will get 0.\\n\\n2. If a pair of number has different LSB, the total distance will get 1.\\n\\n---\\nFor all number **a1, a2, a3,..., a(n)**, if there are **p** numbers have **0 as LSB (put in set M)**, and **q** numbers have **1 for LSB (put in set N)**. \\n\\nThere are **2 situations**:\\n\\n**Situation 1**. If the **2 number in a pair both comes from M (or N)**, the total will get **0**.\\n\\n**Situation 2**. If the **1 number in a pair comes from M, the other comes from N**, the total will get **1**.\\n\\nSince **Situation 1** will add **NOTHING** to the total, we only need to think about **Situation 2**\\n\\n**How many pairs are there in Situation 2?** \\n\\nWe choose **1 number from M (p possibilities)**, and **1 number from N (q possibilities)**.\\n\\nThe total possibilities is **p \\xd7 q = pq**, which means\\n\\n>#### **The total Hamming distance will get pq from LSB.**\\n\\n---\\nIf we **remove the LSB of all numbers (right logical shift)**, the same idea can be used **again and again until all numbers becomes zero**\\n\\n---\\n#### 2.4 Time complexity\\n\\n---\\nIn each loop, we need to **visit all numbers in nums** to **calculate how many numbers has 0 (or 1) as LSB**.\\n\\nIf the biggest number in nums[] is K, **the total number of loop is [logK] + 1**.\\n\\nSo, **the total time complexity of this approach is O(n)**.\\n\\n---\\n## 3. Code\\n---\\n```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        int size = nums.size();\\n        if(size < 2) return 0;\\n        int ans = 0;\\n        int *zeroOne = new int[2];\\n        while(true)\\n        {\\n            int zeroCount = 0;\\n            zeroOne[0] = 0;\\n            zeroOne[1] = 0;\\n            for(int i = 0; i < nums.size(); i++)\\n            {\\n                if(nums[i] == 0) zeroCount++;\\n                zeroOne[nums[i] % 2]++;\\n                nums[i] = nums[i] >> 1;\\n            }\\n            ans += zeroOne[0] * zeroOne[1];\\n            if(zeroCount == nums.size()) return ans;\\n        }\\n    }\\n};\\n```\\n---",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        int size = nums.size();\\n        if(size < 2) return 0;\\n        int ans = 0;\\n        int *zeroOne = new int[2];\\n        while(true)\\n        {\\n            int zeroCount = 0;\\n            zeroOne[0] = 0;\\n            zeroOne[1] = 0;\\n            for(int i = 0; i < nums.size(); i++)\\n            {\\n                if(nums[i] == 0) zeroCount++;\\n                zeroOne[nums[i] % 2]++;\\n                nums[i] = nums[i] >> 1;\\n            }\\n            ans += zeroOne[0] * zeroOne[1];\\n            if(zeroCount == nums.size()) return ans;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96229,
                "title": "python-via-strings",
                "content": "\\n    def totalHammingDistance(self, nums):\\n        return sum(b.count('0') * b.count('1') for b in zip(*map('{:032b}'.format, nums)))",
                "solutionTags": [],
                "code": "\\n    def totalHammingDistance(self, nums):\\n        return sum(b.count('0') * b.count('1') for b in zip(*map('{:032b}'.format, nums)))",
                "codeTag": "Python3"
            },
            {
                "id": 96228,
                "title": "python-explanation",
                "content": "Notice the total hamming distance is the sum of the total hamming distance for each of the i-th bits separately.\\n\\nSo, let's consider the i-th column, which consists of numbers chosen from {0, 1}.  The total hamming distance would be the number of pairs of numbers that are different.  That is, \\n\\nTotal hamming distance for the i-th bit = \\n (the number of zeros in the i-th position) * \\n (the number of ones in the i-th position).\\n\\nWe then add all of these together to get our answer.\\n\\nCode:\\n```\\nbits = [ [0,0] for _ in xrange(32) ]\\nfor x in A:\\n  for i in xrange(32):\\n    bits[i][x%2] += 1\\n    x /= 2\\nreturn sum( x*y for x,y in bits )\\n```",
                "solutionTags": [],
                "code": "```\\nbits = [ [0,0] for _ in xrange(32) ]\\nfor x in A:\\n  for i in xrange(32):\\n    bits[i][x%2] += 1\\n    x /= 2\\nreturn sum( x*y for x,y in bits )\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 96222,
                "title": "java-solution-with-explanation",
                "content": "The first solution came to my mind is brute forcely iterate through each pair, then sum all ```Integer.bitCount(x ^ y)``` like what I mentioned here https://discuss.leetcode.com/topic/72093/java-1-line-solution-d But as you can imagine, it TLE...\\n\\nLet's think about this problem another way. We can separate the calculation to do one bit at a time. For example, look at the rightmost bit of all the numbers in ```nums```. Suppose that ```i``` numbers have a rightmost ```0```-bit, and ```j``` numbers have a ```1```-bit. Then out of the pairs, ```i * j``` of them will have 1 in the rightmost bit of the ```XOR```. This is because there are ```i * j``` ways to choose one number that has a ```0```-bit and one that has a ```1```-bit. These bits will therefore contribute ```i * j``` towards the total of all the XORs.\\n\\nApply above algorithm to each bit (```31``` bits in total as specified in the problem), sum them together then we get the answer.\\n\\nReference: http://stackoverflow.com/questions/21388448/sum-of-xor-values-of-all-pairs\\n\\n```\\npublic class Solution {\\n    public int totalHammingDistance(int[] nums) {\\n        int n = 31;\\n        int len = nums.length;\\n        int[] countOfOnes = new int[n];\\n        for (int i = 0; i < len; i++) {\\n            for (int j = 0; j < n; j++) {\\n                countOfOnes[j] += (nums[i] >> j) & 1;\\n            }\\n        }\\n        int sum = 0;\\n        for (int count: countOfOnes) {\\n            sum += count * (len - count);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Integer.bitCount(x ^ y)```\n```nums```\n```i```\n```0```\n```j```\n```1```\n```i * j```\n```XOR```\n```i * j```\n```0```\n```1```\n```i * j```\n```31```\n```\\npublic class Solution {\\n    public int totalHammingDistance(int[] nums) {\\n        int n = 31;\\n        int len = nums.length;\\n        int[] countOfOnes = new int[n];\\n        for (int i = 0; i < len; i++) {\\n            for (int j = 0; j < n; j++) {\\n                countOfOnes[j] += (nums[i] >> j) & 1;\\n            }\\n        }\\n        int sum = 0;\\n        for (int count: countOfOnes) {\\n            sum += count * (len - count);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1585848,
                "title": "c-easy-and-concise-solutions",
                "content": "**Thanks for refering to my solution, in advance :)**\\n\\n\\u274C**APPROACH -1 :** Using XOR - Time limit exceeded\\n\\nTo understand this method, see : 461. Hamming Distance\\n(Solution link : https://leetcode.com/problems/hamming-distance/discuss/1585568/C%2B%2B-2-liner-Faster-than-100)\\n\\nTraverse the array using 2 loops and form all the pairs possible. For each pair, compute XOR and count the no. of bits set and add them to the answer.\\n\\n*   **Time Complexity :** O(n^2*x*k); where k is the no. of bits set in the XOR of each pair.\\n*   **Space Complexity :** O(1)\\n\\n    **Code :**\\n```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                int xOR = nums[i]^nums[j];\\n                ans += __builtin_popcount(xOR);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\u2714\\uFE0FAPPROACH - 2 : \\n* For each bit position 1-32 in a 32-bit integer belonging to the array, we count the number of integers in the array which have that bit set. \\n* Then, if there are n integers in the array and k of them have a particular bit set and (n-k) do not, then that bit contributes n*x*(n-k) to the hamming distance. (Because for each of the \\'k\\' numbers, we have 1 of the (n-k) numbers, that have a different bit and the number of ways to select 1 from k and (n-k) numbers is (kC1)*x*((n-k)C1)\\n\\n*   **Time Complexity :** O(n)\\n*   **Space Complexity :** O(1)\\n  \\n    **Code :**\\n```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        int n=nums.size(), ans=0;\\n        for(int i=0;i<32;i++){\\n            int count=0; //Count of the no.of elements that have the \\'i\\'th bit set\\n            for(int k=0;k<n;k++){\\n                count += (nums[k]>>i)&1;\\n            }\\n            ans += count*(n-count);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nIf you like my solution and explanation; **please UPVOTE!!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                int xOR = nums[i]^nums[j];\\n                ans += __builtin_popcount(xOR);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        int n=nums.size(), ans=0;\\n        for(int i=0;i<32;i++){\\n            int count=0; //Count of the no.of elements that have the \\'i\\'th bit set\\n            for(int k=0;k<n;k++){\\n                count += (nums[k]>>i)&1;\\n            }\\n            ans += count*(n-count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96250,
                "title": "c-o-n-runtime-o-1-space",
                "content": "My approach is counting the hamming distance bitwise. If you generate all possible pairs of input array, there will be three kinds of pairs\\n* LSB is `1/0` for both numbers - for these kind of pairs they will not contribute in the final result\\n* LSB is different - these pairs will contribute at final result\\n\\nDivide all the numbers into two groups `p` & `q`.\\n`p` - contains numbers whose LSB is `1`\\n`q` - numbers whose LSB is `0`\\n\\nThe pairs obtained from elements of only `p` or only `q` will be the pairs of the first type given above.\\nSo only the pairs obtained from combination of `p` and `q` will contribute at the result. And the contribution will be \\n`\\n|p| * |q| = |p| * (|n| - |p|); \\n|p| = size of set p, \\n|q| = size of set q,\\n|n| = size of input array,\\n`\\n\\nAnd we need to do the same process for all the `8 * sizeof(int)` bits of all numbers and sum the each bits hamming contribution. \\n\\nRuntime will be `O(8 * sizeof(int) *n) = O(n) `\\n```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        if (nums.size() <= 0) return 0;\\n        \\n        int res = 0;\\n        \\n        for(int i=0;i<32;i++) {\\n            int setCount = 0;\\n            for(int j=0;j<nums.size();j++) {\\n                if ( nums[j] & (1 << i) ) setCount++;\\n            }\\n            \\n            res += setCount * (nums.size() - setCount);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        if (nums.size() <= 0) return 0;\\n        \\n        int res = 0;\\n        \\n        for(int i=0;i<32;i++) {\\n            int setCount = 0;\\n            for(int j=0;j<nums.size();j++) {\\n                if ( nums[j] & (1 << i) ) setCount++;\\n            }\\n            \\n            res += setCount * (nums.size() - setCount);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 851194,
                "title": "python-3-bit-manipulation-o-n-explanations",
                "content": "### Explanation\\n- For each bit, count how many numbers have 0 or 1 on that bit; the total difference on that bit is `zero * one`\\n\\t- `zero`: the amount of numbers which have `0` on bit `i`\\n\\t- `one`: the amount of numbers which have `1` on bit `i`\\n- Sum up each bit, then we got the answer\\n- Time Complexity: `O(32*N) -> O(N)`\\n\\n### Implementation\\n```\\nclass Solution:\\n    def totalHammingDistance(self, nums: List[int]) -> int:\\n        ans = 0\\n        for i in range(32):\\n            zero = one = 0\\n            mask = 1 << i\\n            for num in nums:\\n                if mask & num: one += 1\\n                else: zero += 1    \\n            ans += one * zero        \\n        return ans    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def totalHammingDistance(self, nums: List[int]) -> int:\\n        ans = 0\\n        for i in range(32):\\n            zero = one = 0\\n            mask = 1 << i\\n            for num in nums:\\n                if mask & num: one += 1\\n                else: zero += 1    \\n            ans += one * zero        \\n        return ans    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 720409,
                "title": "python-bit-manipulation-explanation-with-diagram",
                "content": "1. Let\\'s consider an array of `[0, 0, 0, 1, 1]`, and let\\'s assume we only have **1 BIT**. These are the possible combinations that **add to our count**.\\n<br>\\n\\n**Option 1 (2 ways)**\\n![image](https://assets.leetcode.com/users/images/9e6d0bf5-37cd-4528-8cd2-2abe1dc0c4b2_1593928514.1350749.png)\\n<br>\\n**Option 2 (2 ways)**\\n![image](https://assets.leetcode.com/users/images/671398c0-487e-4e05-97d2-ea0fd24755ba_1593928551.4181516.png)\\n<br>\\n**Option 3 (2 ways)**\\n![image](https://assets.leetcode.com/users/images/7c5003d4-9438-45c1-8e1e-63e06abe060b_1593928568.362975.png)\\n<br>\\n\\n2. The brute-force way would be to compute **every pairwise combination** of the numbers, then add them = ***2 + 2 + 2 = 6*** giving us O(N^2)\\n<br>\\n\\n3. Alternative, we can simply **count the 0\\'s (3 of them) and the 1\\'s (2 of them),** then multiply them = ***3  * 2 = 6*** giving us O(N)\\n<br>\\n\\n4. Now, if you get this, it\\'s simply a matter of **repeating this at EVERY BIT POSITION**, you can assume 32 or 64 bits, doesn\\'t matter.\\n\\n\\n```\\n```",
                "solutionTags": [],
                "code": "```\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2174168,
                "title": "c-bit-manipulation-o-n-time-complexity-concise-solution",
                "content": "![image](https://assets.leetcode.com/users/images/ee9e8eb9-0b38-4661-8d64-9f484703c0a1_1655721777.8817985.jpeg)\\n![image](https://assets.leetcode.com/users/images/7252925a-ee1e-46aa-8a4a-7f44998af127_1655721784.1028585.jpeg)\\n```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        int ans=0;\\n        for(int pos=0;pos<32;pos++){\\n            int ones=0,zeros=0;\\n            for(int i=0;i<nums.size();i++){\\n                if((nums[i]>>pos)&1){\\n                    ones++;\\n                } else {\\n                    zeros++;\\n                }\\n            }\\n            ans+=ones*zeros;\\n        }\\n        return ans;\\n    }\\n};\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation",
                    "Iterator"
                ],
                "code": "class Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        int ans=0;\\n        for(int pos=0;pos<32;pos++){\\n            int ones=0,zeros=0;\\n            for(int i=0;i<nums.size();i++){\\n                if((nums[i]>>pos)&1){\\n                    ones++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 96253,
                "title": "simple-example-for-the-java-o-n-time-o-1-space-solution",
                "content": "The idea is same as https://discuss.leetcode.com/topic/72092/java-o-n-time-o-1-space \\nAssuming we have an array of five integers ```a, b, c, d, e``` as follow. \\nWe examine the digits one by one from the last digit. \\nCount the number of integers whose last digit is 1, assign the value to ```ones```\\n```\\n    a = 0 0 0 1 0\\n    b = 1 0 0 1 1\\n    c = 0 1 0 0 1\\n    d = 1 0 0 1 0\\n    e = 0 0 0 1 0\\n                \\u2191\\n    ones: b, c\\n    zeros: a, d, e\\n    \\n    pairs that make distance are:\\n    b: a, d, e\\n    c: a, d, e\\n\\n    So we have 2 ones and 5 - 2 = 3 zeros\\n    Total distance = 2 * 3\\n    then we move the pointer one position left, i.e. all the numbers right shift by 1 (num >>> 1)\\n```\\nThe code is as follows.\\n```\\npublic int totalHammingDistance(int[] nums) {\\n        int res = 0, len = nums.length;\\n        for(int i = 0; i < 32; i++) { //32 digits in integers\\n            int ones = 0; \\n            for(int j = 0; j < len; j++) {\\n                if((nums[j] & 1) == 1) ones++;\\n                nums[j] = nums[j] >>> 1;\\n            }\\n            res = res + ones * (len - ones);\\n        }\\n        return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```a, b, c, d, e```\n```ones```\n```\\n    a = 0 0 0 1 0\\n    b = 1 0 0 1 1\\n    c = 0 1 0 0 1\\n    d = 1 0 0 1 0\\n    e = 0 0 0 1 0\\n                \\u2191\\n    ones: b, c\\n    zeros: a, d, e\\n    \\n    pairs that make distance are:\\n    b: a, d, e\\n    c: a, d, e\\n\\n    So we have 2 ones and 5 - 2 = 3 zeros\\n    Total distance = 2 * 3\\n    then we move the pointer one position left, i.e. all the numbers right shift by 1 (num >>> 1)\\n```\n```\\npublic int totalHammingDistance(int[] nums) {\\n        int res = 0, len = nums.length;\\n        for(int i = 0; i < 32; i++) { //32 digits in integers\\n            int ones = 0; \\n            for(int j = 0; j < len; j++) {\\n                if((nums[j] & 1) == 1) ones++;\\n                nums[j] = nums[j] >>> 1;\\n            }\\n            res = res + ones * (len - ones);\\n        }\\n        return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 795407,
                "title": "c-solution-full-detailed-explanation",
                "content": "Here, the task is to find the sum of all set bits in all XOR pairs of the numbers.\\nSo, if you apply Brute Force, it obviously gives TLE.\\n\\nNow, lets suppose there are 5 numbers in which 3 numbers have ith bit (i=0,1,....,31) as 0 and rest (i.e. 5-3=2) have ith bit as 0.\\n\\nSo, if we take XOR of these numbers in pairs, we get 5 * 4=20 numbers and from these 20 numbers, at the ith bit we get (3 * 2=6) numbers where the ith bit is set (or equal to 1).\\n\\nThis is because the combinations to get XOR equal to 1 is just 0 of one number and 1 of the other and the total combinations of such are **(no. of ones * no. of zeroes)**.\\n\\n```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        int n=nums.size(),i=0,ans=0,cnt=0;\\n        for(i=31;i>=0;i--)\\n        {\\n            cnt=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                 if(nums[j]&(1<<i))\\n                    cnt++;\\n            }\\n            ans+=(cnt*(n-cnt));\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nPlease upvote if you like the explanation.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        int n=nums.size(),i=0,ans=0,cnt=0;\\n        for(i=31;i>=0;i--)\\n        {\\n            cnt=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                 if(nums[j]&(1<<i))\\n                    cnt++;\\n            }\\n            ans+=(cnt*(n-cnt));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3661335,
                "title": "c-from-brute-force-to-most-optimal-solution-detailed-explaination",
                "content": "# Intuition\\nWe have to find for ith bit, what is the number of bits which are different.\\nFor example :- \\nLet we have 1001 & 1110, so for i=0, or 0th position we have differing bits equals to 1 similarly for i=3 we have differing bits equals to 0,\\n \\n# Approach 1 - Brute Force\\nBrute force is to generate all pairs and find the different bits for each pair and add the sum to the answer.\\n\\nFor getting all different bits of two numbers, we can do it in two ways : -\\n1. Iterating through each bit and finding diffener bits count\\n```\\nFor two numbers \\nn -> first number \\nm -> second number\\n\\nint cnt = 0;\\nfor(int i = 0 ; i < 32 ; i++) if((n&(1<<i)) != (m&(1<<i)))cnt++;\\n```\\nfor this we would be haing time complexity as log(max(n,m));\\n\\n2. Using XOR property that xor of two different bits is 1, i.e. 1^0 = 1\\n\\n```\\nint cnt = 0;\\nint k = n^m;\\nfor(int i = 0 ; i < 32 ; i++)if(k&(1<<i))cnt++;\\n            or\\ncnt = __builtin_popcountll(k);\\n```\\n\\n\\n **Complexity of first approach**\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(1)\\n\\n\\n# Approach 2 - Optimised solution\\n\\nLet we have 3 numbers whose binary representation are:-\\n1. 0100\\n2. 1110\\n3. 0010\\n\\nThan total number of bits is 6.\\n\\nThis can be calculated by having the count of given integers whose ith it is set (or not-set, can go for any).\\n\\nNow suppose x of them has ith bit as set, than total numer of differentt bits can be calculated as :-\\n \\n```\\n1*(n-x) + 1*(n-x)+........x times.\\n```\\n\\nwhich is equals to x*(n-x) or total_set_bits*total_unset_bits.\\n\\n**Please Upvote if you are here \\u2705\\u2705**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        int ans = 0;\\n        for(int i = 0 ; i < 31 ; i++){\\n            int cnt1 = 0;\\n            for(int j = 0 ; j < nums.size() ; j++){\\n                if(nums[j]&(1<<i))cnt1++;\\n            }\\n            ans+=(cnt1*(nums.size()-cnt1));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nFor two numbers \\nn -> first number \\nm -> second number\\n\\nint cnt = 0;\\nfor(int i = 0 ; i < 32 ; i++) if((n&(1<<i)) != (m&(1<<i)))cnt++;\\n```\n```\\nint cnt = 0;\\nint k = n^m;\\nfor(int i = 0 ; i < 32 ; i++)if(k&(1<<i))cnt++;\\n            or\\ncnt = __builtin_popcountll(k);\\n```\n```\\n1*(n-x) + 1*(n-x)+........x times.\\n```\n```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        int ans = 0;\\n        for(int i = 0 ; i < 31 ; i++){\\n            int cnt1 = 0;\\n            for(int j = 0 ; j < nums.size() ; j++){\\n                if(nums[j]&(1<<i))cnt1++;\\n            }\\n            ans+=(cnt1*(nums.size()-cnt1));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 603952,
                "title": "java-99-70-faster-simple-easy-solution",
                "content": "```\\nclass Solution {\\n    public int totalHammingDistance(int[] nums) {\\n        if (nums == null) {\\n            return 0;\\n        }\\n        int distance = 0;\\n        for (int i = 0; i < 32; i++) {\\n            int one_count = 0;\\n            for (int j = 0; j < nums.length; j++) {\\n                one_count += (nums[j] >> i) & 1;\\n            }\\n            distance += one_count * (nums.length - one_count);\\n        }\\n        return distance;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n    public int totalHammingDistance(int[] nums) {\\n        if (nums == null) {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2665345,
                "title": "c-easiest-solution-0ms-100",
                "content": "```\\nint totalHammingDistance(vector<int>& nums) {\\n        int total = 0;\\n        \\n        for(int i = 0; i < 32; i++){\\n            int ones = 0, zeros = 0;\\n            \\n            for(auto n: nums){\\n                if(n& (1<<i)){\\n                    ones++;\\n                }\\n                else{\\n                    zeros++;\\n                }\\n            }\\n            \\n            total += (ones* zeros);\\n        }\\n        \\n        return total;\\n    }\\n```\\n\\n**Please upvote if You like the solution :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nint totalHammingDistance(vector<int>& nums) {\\n        int total = 0;\\n        \\n        for(int i = 0; i < 32; i++){\\n            int ones = 0, zeros = 0;\\n            \\n            for(auto n: nums){\\n                if(n& (1<<i)){\\n                    ones++;\\n                }\\n                else{\\n                    zeros++;\\n                }\\n            }\\n            \\n            total += (ones* zeros);\\n        }\\n        \\n        return total;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 770198,
                "title": "python-o-n-solution-with-explanation",
                "content": "We can process each \"bit column\" to figure out how much distance that column contributes. For example if i have 2,4,14:\\n1110\\n0010\\n0100\\n\\nI can see that the first column has all 0\\'s so it doesn\\'t contribute anything to the hamming distance. However, for the second column, there are 2 1\\'s and 1 0. That means there are 2 x 1 = 2 different pairings of 0 and 1 I can make, which means that column contributes a distance of 2. For each column, we need to know how many pairs of bits we can make, where those pairs have different bits. So we can just count the numbers of 1\\'s and 0\\'s for each column and multiply them to determine this:\\n\\n```\\nclass Solution(object):\\n    def totalHammingDistance(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        total_ham_dist = 0\\n        \\n        for i in xrange(32):\\n            one_cnt = 0\\n            zero_cnt = 0\\n            \\n            for num in nums:\\n                extract_i_bit = (1 << i) & num\\n                if extract_i_bit == 0:\\n                    zero_cnt += 1\\n                else:\\n                    one_cnt += 1\\n                    \\n            total_ham_dist += one_cnt * zero_cnt\\n            \\n        return total_ham_dist",
                "solutionTags": [],
                "code": "We can process each \"bit column\" to figure out how much distance that column contributes. For example if i have 2,4,14:\\n1110\\n0010\\n0100\\n\\nI can see that the first column has all 0\\'s so it doesn\\'t contribute anything to the hamming distance. However, for the second column, there are 2 1\\'s and 1 0. That means there are 2 x 1 = 2 different pairings of 0 and 1 I can make, which means that column contributes a distance of 2. For each column, we need to know how many pairs of bits we can make, where those pairs have different bits. So we can just count the numbers of 1\\'s and 0\\'s for each column and multiply them to determine this:\\n\\n```\\nclass Solution(object):\\n    def totalHammingDistance(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        total_ham_dist = 0\\n        \\n        for i in xrange(32):\\n            one_cnt = 0\\n            zero_cnt = 0\\n            \\n            for num in nums:\\n                extract_i_bit = (1 << i) & num\\n                if extract_i_bit == 0:\\n                    zero_cnt += 1\\n                else:\\n                    one_cnt += 1\\n                    \\n            total_ham_dist += one_cnt * zero_cnt\\n            \\n        return total_ham_dist",
                "codeTag": "Java"
            },
            {
                "id": 807404,
                "title": "java-solution-explaination-bit-manipulation-runtime-4ms",
                "content": "**CONCEPT TO REMEMBER: The Hamming distance between two integers is the number of positions at which the corresponding bits are different.**\\nSo to calculate the difference (distance ), we must check if at a specific position the the bit of 2 numbers are different or same, if same then the difference is 0, else 1 , just like xor operation(gives 1 when bits are different else gives 0).\\n1.count no. of 1\\'s , subtract no. of 1\\'s from total length of the array, which gives total no. of integers with 0 at that position,i.e., count of 0\\'s at that specific position.\\n2.multiply count of 0\\'s and count of 1\\'s at specific postion, to get hamming distance of that particular position.\\n3.now repeat the above 2 steps and sum all of the hamming distances, to obtain total hamming distance \\n```\\nclass Solution {\\n    public int totalHammingDistance(int[] nums) {\\n         int result = 0;\\n        for(int i = 0; i<32; i++){\\n              int count_ones= 0;\\n            for(int j = 0; j<nums.length; j++){\\n                count_ones+=(nums[j]>>i)&1; //count no. of 1\\'s at a specific position\\n            }\\n            result +=(count_ones*(nums.length-count_ones));\\n        }\\n        return result;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int totalHammingDistance(int[] nums) {\\n         int result = 0;\\n        for(int i = 0; i<32; i++){\\n              int count_ones= 0;\\n            for(int j = 0; j<nums.length; j++){\\n                count_ones+=(nums[j]>>i)&1; //count no. of 1\\'s at a specific position\\n            }\\n            result +=(count_ones*(nums.length-count_ones));\\n        }\\n        return result;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 426677,
                "title": "java-bruce-force-o-n-2-to-o-n-solution",
                "content": "Bruce force O(n^2) : Time Limit\\n```\\nclass Solution {\\n    public int totalHammingDistance(int[] nums) {\\n        int count = 0;\\n        for(int i = 0; i< nums.length; i++){\\n            for(int j = i+1; j< nums.length; j++){\\n                count += diff(nums[i], nums[j]);\\n            }\\n        }\\n        return count;\\n    }\\n\\n    public int diff(int a, int b){\\n        int count = 0;\\n        while(a != 0 || b != 0){\\n            if((a &1) != (b&1)) count ++;\\n            a >>= 1;\\n            b >>= 1;\\n        }\\n        return count;\\n    }\\n}\\n\\n```\\n\\nO(n) Solution: Accepted\\n\\n```\\nclass Solution {\\n    public int totalHammingDistance(int[] nums) {\\n        int count = 0;\\n        for(int i = 0; i< 32; i++){\\n            int one = 0; // number of bits is one\\n            for(int j = 0; j< nums.length; j++){\\n                if(((nums[j] >> i) &1) == 1) one ++;\\n            }\\n            count += one * (nums.length - one); // one * zero\\n        }\\n        return count;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int totalHammingDistance(int[] nums) {\\n        int count = 0;\\n        for(int i = 0; i< nums.length; i++){\\n            for(int j = i+1; j< nums.length; j++){\\n                count += diff(nums[i], nums[j]);\\n            }\\n        }\\n        return count;\\n    }\\n\\n    public int diff(int a, int b){\\n        int count = 0;\\n        while(a != 0 || b != 0){\\n            if((a &1) != (b&1)) count ++;\\n            a >>= 1;\\n            b >>= 1;\\n        }\\n        return count;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public int totalHammingDistance(int[] nums) {\\n        int count = 0;\\n        for(int i = 0; i< 32; i++){\\n            int one = 0; // number of bits is one\\n            for(int j = 0; j< nums.length; j++){\\n                if(((nums[j] >> i) &1) == 1) one ++;\\n            }\\n            count += one * (nums.length - one); // one * zero\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 198437,
                "title": "python-o-n-with-explanation",
                "content": "Intuition: total distance = sum(distance from each digit)\\n       \\nalgorithm: record the number of 1s in each digit\\nfor example, 2,4,14 has string representation as\\n0010\\n0100\\n1110\\nthe counts of 1 in each digit is [1,2,2,0]\\n\\nNow, assume there is less 0 than 1 in current digit, we need to change every 0 to 1 for [number of 1] times\\nwith [1,2,2,0], the total distance = (3-1) * 1 + (3-2) * 2 + (3-2) * 2 + (3-0) * 0 = 6\\n\\n\\tdef totalHammingDistance(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        n = len(nums)\\n        if n <= 1:\\n            return 0\\n        \\n        numStrs = []\\n        maxL = 0    # maximum number of digits\\n        for num in nums:\\n            numStr = \"{0:b}\".format(num)\\n            numStrs.append(numStr)\\n            maxL = max(maxL,len(numStr))\\n        \\n        count1 = [0] * maxL # each element indicates how many 1 in current digit\\n        for numStr in numStrs:\\n            for i in range(len(numStr)): #4 -> \\'100\\'\\n                if numStr[i] == \\'1\\':\\n                    count1[len(numStr)-1-i] += 1\\n                    \\n        ans = 0\\n        for count in count1:\\n            if count == 0 or count == n:\\n                continue\\n            ans += count * (n-count) \\n        return ans\\n",
                "solutionTags": [],
                "code": "Intuition: total distance = sum(distance from each digit)\\n       \\nalgorithm: record the number of 1s in each digit\\nfor example, 2,4,14 has string representation as\\n0010\\n0100\\n1110\\nthe counts of 1 in each digit is [1,2,2,0]\\n\\nNow, assume there is less 0 than 1 in current digit, we need to change every 0 to 1 for [number of 1] times\\nwith [1,2,2,0], the total distance = (3-1) * 1 + (3-2) * 2 + (3-2) * 2 + (3-0) * 0 = 6\\n\\n\\tdef totalHammingDistance(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        n = len(nums)\\n        if n <= 1:\\n            return 0\\n        \\n        numStrs = []\\n        maxL = 0    # maximum number of digits\\n        for num in nums:\\n            numStr = \"{0:b}\".format(num)\\n            numStrs.append(numStr)\\n            maxL = max(maxL,len(numStr))\\n        \\n        count1 = [0] * maxL # each element indicates how many 1 in current digit\\n        for numStr in numStrs:\\n            for i in range(len(numStr)): #4 -> \\'100\\'\\n                if numStr[i] == \\'1\\':\\n                    count1[len(numStr)-1-i] += 1\\n                    \\n        ans = 0\\n        for count in count1:\\n            if count == 0 or count == n:\\n                continue\\n            ans += count * (n-count) \\n        return ans\\n",
                "codeTag": "Python3"
            },
            {
                "id": 96245,
                "title": "javascript-3-lines",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar totalHammingDistance = function(nums) {\\n    return Array.from(Array(32), (_,i)=>1<<i)\\n      .map(mask=>nums.filter(n=>(n&mask)!=0).length)\\n      .reduce((v,cnt)=>v+(nums.length-cnt)*cnt,0);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar totalHammingDistance = function(nums) {\\n    return Array.from(Array(32), (_,i)=>1<<i)\\n      .map(mask=>nums.filter(n=>(n&mask)!=0).length)\\n      .reduce((v,cnt)=>v+(nums.length-cnt)*cnt,0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 96252,
                "title": "python-o-nlogv-time",
                "content": "Just calculate combinations vertically.\\n```\\nclass Solution(object):\\n    def totalHammingDistance(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        ans = 0\\n        mask = 1\\n        for j in range(0, 32):\\n            ones = zeros = 0\\n            for num in nums:\\n                if num & mask:\\n                    ones += 1\\n                else:\\n                    zeros += 1\\n            ans += ones * zeros\\n            mask = mask << 1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def totalHammingDistance(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        ans = 0\\n        mask = 1\\n        for j in range(0, 32):\\n            ones = zeros = 0\\n            for num in nums:\\n                if num & mask:\\n                    ones += 1\\n                else:\\n                    zeros += 1\\n            ans += ones * zeros\\n            mask = mask << 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688376,
                "title": "most-optimied-c-ans-set-unset-bit-ith-possition",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        vector<int> v(32,0);\\n        int j,n=nums.size();\\n        for(auto &i: nums){\\n            for(j=0;j<32;j++){\\n                if(i&(1<<j)){\\n                    v[j]++;\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(auto &i: v){\\n            ans += (i*(n-i));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        vector<int> v(32,0);\\n        int j,n=nums.size();\\n        for(auto &i: nums){\\n            for(j=0;j<32;j++){\\n                if(i&(1<<j)){\\n                    v[j]++;\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(auto &i: v){\\n            ans += (i*(n-i));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3110557,
                "title": "easy-python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def totalHammingDistance(self, nums: List[int]) -> int:\\n        ans=0\\n        for i in range(32):\\n            cnt=0\\n            for j in range(len(nums)):\\n                cnt+=(nums[j]>>i&1)\\n            ans+=(len(nums)-cnt)*cnt\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def totalHammingDistance(self, nums: List[int]) -> int:\\n        ans=0\\n        for i in range(32):\\n            cnt=0\\n            for j in range(len(nums)):\\n                cnt+=(nums[j]>>i&1)\\n            ans+=(len(nums)-cnt)*cnt\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2304438,
                "title": "full-approach-explained-with-diagrams-c",
                "content": "![image](https://assets.leetcode.com/users/images/ca4f6e08-3a69-4353-b7b5-7034cff2f495_1658240110.4114728.jpeg)\\n\\n\\nIn Constraints it is given that ** The answer for the given input will fit in a 32-bit integer.**\\nso we will iterate for 32 positions.\\n\\n\\n```\\nint totalHammingDistance(vector<int>& nums) {\\n        int ans=0;\\n        for(int pos=0; pos<32; pos++){ \\n            int one=0;\\n            int zero =0;  \\n            for(int &i: nums){\\n                if(i & 1) one++;\\n                else zero++;\\n                i>>=1;\\n                \\n            }\\n            ans+= (one*zero);\\n        }\\n        return ans;\\n    }\\n```\\n\\nThank You, have a great day.",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nint totalHammingDistance(vector<int>& nums) {\\n        int ans=0;\\n        for(int pos=0; pos<32; pos++){ \\n            int one=0;\\n            int zero =0;  \\n            for(int &i: nums){\\n                if(i & 1) one++;\\n                else zero++;\\n                i>>=1;\\n                \\n            }\\n            ans+= (one*zero);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2075019,
                "title": "c-easy-to-understand-fully-explained",
                "content": "We can solve this problem in O(n) time using the fact that all numbers are represented using 32 bits (or some fixed number of bits). The idea is to count differences at individual bit positions. We traverse from 0 to 31 and count numbers with i\\u2019th bit set. Let this count be **\\u2018c\\'**. There would be **\\u201Cn-c\\u201D** numbers with i\\u2019th bit not set. So count of differences at i\\u2019th bit would be **\\u201Ccount * (n-count)\\u201D**, the reason for this formula is as every pair having one element which has set bit at i\\u2019th position and second element having unset bit at i\\u2019th position contributes exactly 1 to sum.\\n```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        int ans=0;\\n        int n=nums.size();\\n        for(int i=0;i<32;i++){\\n            int c=0;\\n            for(int j=0;j<n;j++){\\n\\t\\t\\t\\t\\tif((nums[j]&(1<<i)))c++;     //Checking if i\\'th bit is set ot not.\\n            }\\n            ans+=(c*(n-c));      //Adding count of differences\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please Upvote if the solution helps in any way.**\\n**Feel free to ask any doubt.**",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        int ans=0;\\n        int n=nums.size();\\n        for(int i=0;i<32;i++){\\n            int c=0;\\n            for(int j=0;j<n;j++){\\n\\t\\t\\t\\t\\tif((nums[j]&(1<<i)))c++;     //Checking if i\\'th bit is set ot not.\\n            }\\n            ans+=(c*(n-c));      //Adding count of differences\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 155471,
                "title": "java-easiest-simplest-short-solution",
                "content": "```\\n public int totalHammingDistance(int[] nums) {\\n        int dist=0;\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            for(int j=i+1;j<nums.length;j++)\\n            {\\n                dist+=Integer.bitCount(nums[i] ^ nums[j]);\\n            }\\n        }\\n        return dist;\\n    }",
                "solutionTags": [],
                "code": "```\\n public int totalHammingDistance(int[] nums) {\\n        int dist=0;\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            for(int j=i+1;j<nums.length;j++)\\n            {\\n                dist+=Integer.bitCount(nums[i] ^ nums[j]);\\n            }\\n        }\\n        return dist;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3208996,
                "title": "c-o-n-time-and-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        vector<int> v(32,0);\\n        int j;\\n        for(auto &i: nums){\\n            for(j = 0; j <= 31; j++){\\n                if(i&(1<<j)){\\n                    v[j]++;\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(auto &i: v){\\n            ans += (i*(nums.size()-i));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        vector<int> v(32,0);\\n        int j;\\n        for(auto &i: nums){\\n            for(j = 0; j <= 31; j++){\\n                if(i&(1<<j)){\\n                    v[j]++;\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(auto &i: v){\\n            ans += (i*(nums.size()-i));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979090,
                "title": "python-bit-counting-approach-explanation-and-comments",
                "content": "We could try naive approach considering each pair from teh array and counting distance. That would give us an ``n^2`` approach which results in TLE.\\n\\nAs an alternative we could check all distances for each bit at the same time. We iterate out bitmask over the whole array and check number of ones ``n1`` and zeros ``n0`` at current mask position. Total number of different bits would be ``n0 * n1``. Summing up number of different bits for each position would give us teh result:\\n\\n```\\nclass Solution:\\n    def totalHammingDistance(self, nums: List[int]) -> int:\\n        result = 0\\n        n = len(nums)\\n\\t\\t# Determining the highest bit\\n        mx = max(nums)\\n        mask = 1\\n        while mask < mx:\\n            mask <<= 1\\n        while mask:\\n            n1 = 0\\n\\t\\t\\t# Counting the number of ones on each position accross all the numbers in the array\\n            for i in range(n):\\n                if nums[i] & mask:\\n                    n1 += 1\\n\\t\\t\\t# Number of zeros would be the total count of numbers in the array excluding teh number of ones\\n\\t\\t\\t# Note that if all numbers have the same bit value, the number conbtributing into total Hamming \\n\\t\\t\\t# distance for current bit would be zero.\\n\\t\\t\\t# For n1 numbers having one and n0 numbers having zero at the current bit \\n\\t\\t\\t# the distance value for this bit would be the total distance for this bit, which is\\n\\t\\t\\t# the distance between n1 numbers and n0 numbers differing in one bit, which is\\n\\t\\t\\t# n1*n0 - conbsider making all the numbers the same we would need to change n1 ones to zeros \\n\\t\\t\\t# thus eliminating the difference of n0 bit distance for each of n1 number.\\n            result += n1 * (n - n1)\\n            mask >>= 1\\n\\n        return result\\n```\\n\\nComplexity: ``O(n*log(max(arr)))``\\n\\nShall you have any questions please feel free to ask and upvote!",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def totalHammingDistance(self, nums: List[int]) -> int:\\n        result = 0\\n        n = len(nums)\\n\\t\\t# Determining the highest bit\\n        mx = max(nums)\\n        mask = 1\\n        while mask < mx:\\n            mask <<= 1\\n        while mask:\\n            n1 = 0\\n\\t\\t\\t# Counting the number of ones on each position accross all the numbers in the array\\n            for i in range(n):\\n                if nums[i] & mask:\\n                    n1 += 1\\n\\t\\t\\t# Number of zeros would be the total count of numbers in the array excluding teh number of ones\\n\\t\\t\\t# Note that if all numbers have the same bit value, the number conbtributing into total Hamming \\n\\t\\t\\t# distance for current bit would be zero.\\n\\t\\t\\t# For n1 numbers having one and n0 numbers having zero at the current bit \\n\\t\\t\\t# the distance value for this bit would be the total distance for this bit, which is\\n\\t\\t\\t# the distance between n1 numbers and n0 numbers differing in one bit, which is\\n\\t\\t\\t# n1*n0 - conbsider making all the numbers the same we would need to change n1 ones to zeros \\n\\t\\t\\t# thus eliminating the difference of n0 bit distance for each of n1 number.\\n            result += n1 * (n - n1)\\n            mask >>= 1\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1760613,
                "title": "this-question-can-also-done-with-trie-leetcode-c-trie-solution-accepted",
                "content": "class Solution {\\npublic:\\n    \\n    struct Node{\\n        Node* link;\\n        int value[2]= {0};\\n        \\n        bool containsKey(){\\n            return (link != NULL);\\n        }\\n        \\n        void put(Node* node){\\n            link = node;\\n        }\\n        \\n        Node* get(){\\n            return link;\\n        }\\n        \\n        void putvalue(char ch){\\n            ++value[ch - \\'0\\'];\\n        }\\n        \\n        int getvalue(char ch){\\n            return (ch == \\'0\\')?value[1]:value[0];\\n        }\\n    };\\n    \\n    class Trie{\\n        Node* root;\\n        public:\\n        \\n        Trie(){\\n            root = new Node();\\n        }\\n        \\n        void insert(string word){\\n            Node* node = root;\\n            for(int i = 0 ; i < word.size() ; i++){\\n                if(!node->containsKey()){\\n                    node->put(new Node());\\n                }\\n                node->putvalue(word[i]);\\n                node = node->get();\\n            }\\n        }\\n        \\n        int totalvalue(string word){\\n            Node* node = root;\\n            int total = 0;\\n            for(int i=0 ; i<word.size() ; i++){\\n                total += node->getvalue(word[i]);\\n                node = node->get();\\n            }\\n            return total;\\n        }\\n        \\n    };\\n    \\n    int totalHammingDistance(vector<int>& nums) {\\n        Trie *obj = new Trie();\\n        int n = nums.size();\\n        vector<string>v;\\n        for(int i = 0 ; i < n ; i++){\\n            string temp = \"\";\\n            int val = nums[i];\\n            while(val > 0){\\n                int value = val % 2;\\n                temp += (\\'0\\' + value);\\n                val = val / 2;\\n            }\\n            // cout<<temp<<\" \";\\n            while(temp.size() < 32){\\n                temp += \\'0\\';\\n            }\\n            v.push_back(temp);\\n            // cout<<temp<<endl;\\n        }\\n        \\n        for(int i=0 ; i<v.size() ; i++){\\n            obj->insert(v[i]);\\n        }\\n        \\n        int ans = 0;\\n        for(int i=0 ; i<v.size() ; i++){\\n            int val = obj->totalvalue(v[i]);\\n            ans += val;\\n        }\\n        \\n        return ans/2;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "String",
                    "Bit Manipulation",
                    "Trie"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    struct Node{\\n        Node* link;\\n        int value[2]= {0}",
                "codeTag": "Java"
            },
            {
                "id": 1675245,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int totalHammingDistance(int[] nums) {\\n        int sum=0;\\n        for(int i =0;i<nums.length;i++){\\n            for(int j=i+1;j<nums.length;j++){\\n                sum+=HammingDistance(nums[i],nums[j]);\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n    \\n    public int HammingDistance(int a ,int b ){\\n        return Integer.bitCount(a^b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int totalHammingDistance(int[] nums) {\\n        int sum=0;\\n        for(int i =0;i<nums.length;i++){\\n            for(int j=i+1;j<nums.length;j++){\\n                sum+=HammingDistance(nums[i],nums[j]);\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n    \\n    public int HammingDistance(int a ,int b ){\\n        return Integer.bitCount(a^b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1494458,
                "title": "java-bitwise-operation-solution-o-32n-with-explanation",
                "content": "```\\n/**\\n * Bitwise Solution:\\n *\\n *     0 0 1 0 (2)\\n *     1 1 0 1 (13)\\n *     1 0 0 0 (8)\\n *     1 0 1 1 (11)\\n *           ^ Num of 1\\'s = 2, Num of 0\\'s = 2, HammingDistance = 2 * 2 = 4\\n *         ^ Num of 1\\'s = 2, Num of 0\\'s = 2, HammingDistance = 2 * 2 = 4\\n *       ^ Num of 1\\'s = 1, Num of 0\\'s = 3, HammingDistance = 1 * 3 = 3\\n *     ^ Num of 1\\'s = 3, Num of 0\\'s = 1, HammingDistance = 3 * 1 = 3\\n *\\n *   Total = 4 + 4 + 3 + 3 = 14\\n*/\\n\\nclass Solution {\\n    public int totalHammingDistance(int[] nums) {\\n        \\n        int oneCnt;\\n        int result = 0;\\n        for(int i=0; i<32; i++){\\n            oneCnt = 0;\\n            for(int j=0; j<nums.length; j++){\\n                //Java Bitwise Operator\\n                // nums[j] >> i:  (Bitwise shift) shift i bit to the right\\n                //                  1110 >> 0 = 1110\\n                //                  1110 >> 1 = 0111\\n                //                  \\n                // & 1: (Bitwise And) check the last bit is 1\\n                //                  1110 & 1 is actually 1110 & 0001 = 0000 = 0\\n                //                  0111 & 1 is actually 0111 & 0001 = 0001 = 1\\n                \\n                oneCnt += (nums[j] >> i) & 1;\\n            }\\n            result += oneCnt * (nums.length - oneCnt);\\n        }\\n        \\n        return result;\\n        \\n    }\\n    \\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Bitwise Solution:\\n *\\n *     0 0 1 0 (2)\\n *     1 1 0 1 (13)\\n *     1 0 0 0 (8)\\n *     1 0 1 1 (11)\\n *           ^ Num of 1\\'s = 2, Num of 0\\'s = 2, HammingDistance = 2 * 2 = 4\\n *         ^ Num of 1\\'s = 2, Num of 0\\'s = 2, HammingDistance = 2 * 2 = 4\\n *       ^ Num of 1\\'s = 1, Num of 0\\'s = 3, HammingDistance = 1 * 3 = 3\\n *     ^ Num of 1\\'s = 3, Num of 0\\'s = 1, HammingDistance = 3 * 1 = 3\\n *\\n *   Total = 4 + 4 + 3 + 3 = 14\\n*/\\n\\nclass Solution {\\n    public int totalHammingDistance(int[] nums) {\\n        \\n        int oneCnt;\\n        int result = 0;\\n        for(int i=0; i<32; i++){\\n            oneCnt = 0;\\n            for(int j=0; j<nums.length; j++){\\n                //Java Bitwise Operator\\n                // nums[j] >> i:  (Bitwise shift) shift i bit to the right\\n                //                  1110 >> 0 = 1110\\n                //                  1110 >> 1 = 0111\\n                //                  \\n                // & 1: (Bitwise And) check the last bit is 1\\n                //                  1110 & 1 is actually 1110 & 0001 = 0000 = 0\\n                //                  0111 & 1 is actually 0111 & 0001 = 0001 = 1\\n                \\n                oneCnt += (nums[j] >> i) & 1;\\n            }\\n            result += oneCnt * (nums.length - oneCnt);\\n        }\\n        \\n        return result;\\n        \\n    }\\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1299994,
                "title": "python-count-zero-one-every-bit-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def totalHammingDistance(self, nums: List[int]) -> int:\\n        \"\"\"\\n            0100\\n            1110\\n            0001\\n            1111\\n            ....\\n             |||\\n             ||there are 2 \\'0\\' and 2 \\'1\\' .total 2*2 = 4 combinations\\n             ||\\n             |same here 2 \\'0\\' and 2 \\'1\\'. total 2*2=4\\n             |\\n             3 \\'1\\' and 1 \\'0\\'. total 3*1 =3\\n            so ,for evey digit. count the num of zero and one .do a multiply then sum \\n        \"\"\"\\n        bit_strs = [bin(n)[2:].rjust(32,\\'0\\') for n in nums] # convert to binary str and fill left with zeros\\n        res = 0\\n        for i in range(0, 32): # loop through each str every bit\\n            zeros = 0\\n            ones = 0\\n            for s in bit_strs:\\n                if s[i] == \\'0\\':\\n                    zeros+=1\\n                else:\\n                    ones+=1\\n            res += zeros*ones\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def totalHammingDistance(self, nums: List[int]) -> int:\\n        \"\"\"\\n            0100\\n            1110\\n            0001\\n            1111\\n            ....\\n             |||\\n             ||there are 2 \\'0\\' and 2 \\'1\\' .total 2*2 = 4 combinations\\n             ||\\n             |same here 2 \\'0\\' and 2 \\'1\\'. total 2*2=4\\n             |\\n             3 \\'1\\' and 1 \\'0\\'. total 3*1 =3\\n            so ,for evey digit. count the num of zero and one .do a multiply then sum \\n        \"\"\"\\n        bit_strs = [bin(n)[2:].rjust(32,\\'0\\') for n in nums] # convert to binary str and fill left with zeros\\n        res = 0\\n        for i in range(0, 32): # loop through each str every bit\\n            zeros = 0\\n            ones = 0\\n            for s in bit_strs:\\n                if s[i] == \\'0\\':\\n                    zeros+=1\\n                else:\\n                    ones+=1\\n            res += zeros*ones\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238307,
                "title": "c-bit-manipulation-trick",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        vector<int> count(32, 0);\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<32; j++)\\n            {\\n\\t\\t\\t// we are just storing every set bit of each number in the count array.\\n                if((nums[i]&(1<<j)) != 0)\\n                count[j] += 1;\\n            }\\n        }\\n\\t\\t// after saving all set bits in count array, we have got the count \\n\\t\\t// of all set bits of every number\\n\\t\\t// like in example nums[] = {4, 14, 2}\\n\\t\\t// count array will be like {0, 2, 2, 1, 0 ... }\\n\\t\\t// means for every bit,\\n\\t\\t// count[i] numbers will make pair with the n-count[i] numbers\\n        int ans=0;\\n        for(int i=0; i<32; i++)\\n        {\\n            ans += count[i] * (n-count[i]);\\n        }\\n        return ans;\\n\\t\\t// Hope it helps you ;)\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        vector<int> count(32, 0);\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<32; j++)\\n            {\\n\\t\\t\\t// we are just storing every set bit of each number in the count array.\\n                if((nums[i]&(1<<j)) != 0)\\n                count[j] += 1;\\n            }\\n        }\\n\\t\\t// after saving all set bits in count array, we have got the count \\n\\t\\t// of all set bits of every number\\n\\t\\t// like in example nums[] = {4, 14, 2}\\n\\t\\t// count array will be like {0, 2, 2, 1, 0 ... }\\n\\t\\t// means for every bit,\\n\\t\\t// count[i] numbers will make pair with the n-count[i] numbers\\n        int ans=0;\\n        for(int i=0; i<32; i++)\\n        {\\n            ans += count[i] * (n-count[i]);\\n        }\\n        return ans;\\n\\t\\t// Hope it helps you ;)\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1212487,
                "title": "python-implementation",
                "content": "Perform hamming distance for each bit by couning zero and one bit for each bit position and sum it to get the total hamming distance.\\n\\n```\\ndef totalHammingDistance(self, nums: List[int]) -> int:\\n        bits = [[0,0] for _ in range(32)]\\n        for num in nums:\\n            for bit in bits:\\n                bit[num&1] += 1\\n                num>>=1    \\n        return sum([x*y for (x,y) in bits])\\n```\\n\\n\\t\\t\\n\\t\\tcredits @awice",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\ndef totalHammingDistance(self, nums: List[int]) -> int:\\n        bits = [[0,0] for _ in range(32)]\\n        for num in nums:\\n            for bit in bits:\\n                bit[num&1] += 1\\n                num>>=1    \\n        return sum([x*y for (x,y) in bits])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1051620,
                "title": "scala-one-liners",
                "content": "```\\nobject Solution {\\n    def totalHammingDistance(nums: Array[Int]): Int = {\\n        nums.map{n => f\"${n.toBinaryString}%30s\".toArray}.transpose.map(_.count(_ == \\'1\\')).map{c => c * (nums.size - c)}.sum\\n    }\\n}\\n```\\n\\n```\\nobject Solution {\\n    def totalHammingDistance(nums: Array[Int]): Int = {\\n        nums.map(\"%30s\" format _.toBinaryString).map(_.toArray).transpose.map(_.count(_ == \\'1\\')).map{c => c * (nums.size - c)}.sum\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def totalHammingDistance(nums: Array[Int]): Int = {\\n        nums.map{n => f\"${n.toBinaryString}%30s\".toArray}.transpose.map(_.count(_ == \\'1\\')).map{c => c * (nums.size - c)}.sum\\n    }\\n}\\n```\n```\\nobject Solution {\\n    def totalHammingDistance(nums: Array[Int]): Int = {\\n        nums.map(\"%30s\" format _.toBinaryString).map(_.toArray).transpose.map(_.count(_ == \\'1\\')).map{c => c * (nums.size - c)}.sum\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 766802,
                "title": "clean-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        int ans = 0;\\n      \\n        for(int i = 0; i<31; i++){\\n        int countZeros = 0;\\t  \\n        int countOnes = 0;\\n            for(int j = 0; j<nums.size(); j++){\\n                if(((nums[j]>>i)&1)==1)\\n\\t\\t\\t\\t{\\n                    countZeros++;\\n                }\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n                    countOnes++;\\n                }\\n            }\\n            ans = ( ans + ( countZeros*countOnes ) );\\n        }\\n        return ans;   \\n\\t\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        int ans = 0;\\n      \\n        for(int i = 0; i<31; i++){\\n        int countZeros = 0;\\t  \\n        int countOnes = 0;\\n            for(int j = 0; j<nums.size(); j++){\\n                if(((nums[j]>>i)&1)==1)\\n\\t\\t\\t\\t{\\n                    countZeros++;\\n                }\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n                    countOnes++;\\n                }\\n            }\\n            ans = ( ans + ( countZeros*countOnes ) );\\n        }\\n        return ans;   \\n\\t\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 755612,
                "title": "java-brutal-force-vs-o-n",
                "content": "version 1, O(n^2), TLE\\nbrutal force using xor.\\n```\\n    public int totalHammingDistance(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int n : nums) map.put(n, map.getOrDefault(n, 0) + 1);\\n        List<Integer> keys = new ArrayList<>();\\n        keys.addAll(map.keySet());\\n        int res = 0, n = keys.size();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                res += map.get(keys.get(i)) * map.get(keys.get(j)) * Integer.bitCount(keys.get(i) ^ keys.get(j));\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\nversion 2, O(n) \\ncalculate based on digits;\\n\\n```\\n    public int totalHammingDistance(int[] nums) {\\n        int res = 0;\\n        for (int i = 0; i < 32; i++) {\\n            int count = 0;\\n            for (int n : nums) count += (n >> i) & 1;\\n            res += count * (nums.length - count);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int totalHammingDistance(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int n : nums) map.put(n, map.getOrDefault(n, 0) + 1);\\n        List<Integer> keys = new ArrayList<>();\\n        keys.addAll(map.keySet());\\n        int res = 0, n = keys.size();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                res += map.get(keys.get(i)) * map.get(keys.get(j)) * Integer.bitCount(keys.get(i) ^ keys.get(j));\\n            }\\n        }\\n        return res;\\n    }\\n```\n```\\n    public int totalHammingDistance(int[] nums) {\\n        int res = 0;\\n        for (int i = 0; i < 32; i++) {\\n            int count = 0;\\n            for (int n : nums) count += (n >> i) & 1;\\n            res += count * (nums.length - count);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 733466,
                "title": "cpp-solution-with-detailed-explained-easy-to-understand",
                "content": "**The idea behind is that int will come in 32 bit , so we will run loop i=0 to 32 times  \\nand will count number of elements having set bit on ith index.**\\n\\nLet say for i= 0 , number of elements having set bit is c\\nSo. this set bit will generate total hamming distance **(nums.size()-c) * c**.\\n\\n**Like if array given {1,2,3,4,5}={ 001 , 010 , 011 , 100 , 101 }**\\nso at 0th index, number of elements having **set bit at 0th index is 3**\\nAnd **2 elements having unset at 0th index.**\\nSo total hamming distace **for i=0 will be 3 * 2=6**\\nSame we can go for i=1,2,3,...31 and add all the distance and return final distance \\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n \\n    int totalHammingDistance(vector<int>& nums) {\\n        int res=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            int c=0;\\n            for(int j=0;j<nums.size();j++)\\n            {\\n                if((1<<i)&nums[j]) c++;  //checking ith bit set or not\\n            }\\n            res+=(nums.size()-c)*c;\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n \\n    int totalHammingDistance(vector<int>& nums) {\\n        int res=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            int c=0;\\n            for(int j=0;j<nums.size();j++)\\n            {\\n                if((1<<i)&nums[j]) c++;  //checking ith bit set or not\\n            }\\n            res+=(nums.size()-c)*c;\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 726078,
                "title": "c-solution-easy-to-understand",
                "content": "I solved this question by taking one bit of all the numbers at once. The approach is very simple.\\n```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) \\n    {\\n        int ans=0, n=nums.size();\\n        if(n<=1) return 0;\\n        for(int i=0; i<32; i++)\\n        {\\n            int one=0, zero=0;\\n            for(int j=0; j<n; j++)\\n            {\\n                if(nums[j]==0) \\n                {\\n                    zero++; \\n                    continue;\\n                }\\n                int t=nums[j]%2;\\n                (t==1)? one++: zero++;\\n                nums[j] /= 2;\\n            }\\n            ans += one*zero;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) \\n    {\\n        int ans=0, n=nums.size();\\n        if(n<=1) return 0;\\n        for(int i=0; i<32; i++)\\n        {\\n            int one=0, zero=0;\\n            for(int j=0; j<n; j++)\\n            {\\n                if(nums[j]==0) \\n                {\\n                    zero++; \\n                    continue;\\n                }\\n                int t=nums[j]%2;\\n                (t==1)? one++: zero++;\\n                nums[j] /= 2;\\n            }\\n            ans += one*zero;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 693689,
                "title": "easy-to-understand-bit-mask-technique-c",
                "content": "Idea is to used the frequency of each bit . Storing the freqency of bits at each position  and then subtracting it from total number of arraysize will give us the number of elemnts that have bit set to zero therefore product of both will give us to overall hamming distance at that poition and doing sa,e thing for all 32 bit will give us total hamming distance.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int totalHammingDistance(vector<int>& nums) {\\n        int sum=0,n=nums.size();\\n        if(n==1)\\n            return 0;\\n        vector<int> bits(32,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            int j=0;\\n            int k=nums[i];\\n             while(k)\\n            {\\n               if(k%2)\\n                 bits[j]++;\\n                  j++;\\n                 k/=2;\\n            }\\n        }\\n       long ans=0;\\n        for(auto k:bits)\\n        {\\n            long z=(n-k);\\n            ans+=(z*k);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int totalHammingDistance(vector<int>& nums) {\\n        int sum=0,n=nums.size();\\n        if(n==1)\\n            return 0;\\n        vector<int> bits(32,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            int j=0;\\n            int k=nums[i];\\n             while(k)\\n            {\\n               if(k%2)\\n                 bits[j]++;\\n                  j++;\\n                 k/=2;\\n            }\\n        }\\n       long ans=0;\\n        for(auto k:bits)\\n        {\\n            long z=(n-k);\\n            ans+=(z*k);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 293903,
                "title": "real-o-n-not-o-32-n-16ms-beat-100-c",
                "content": "for the analysis, see https://github.com/hqztrue/LeetCodeSolutions/blob/master/477.%20Total%20Hamming%20Distance.pdf.\\n```\\nconst int L=16,W=32;\\nclass Solution {\\npublic:\\n    void add(int *a,int *b,int m){\\n        int t=0;\\n        for (int i=0;i<m;++i){\\n            int t1=a[i]^b[i]^t;\\n            t=a[i]&(b[i]|t)|b[i]&t;\\n            a[i]=t1;b[i]=0;\\n        }\\n        a[m]=t;\\n    }\\n    int totalHammingDistance(vector<int>& a){\\n        static int c_[L*L*2]; memset(c_,0,sizeof(c_));\\n        int *c[L],*c1=c_;\\n        for (int i=0;i<L;++i)c[i]=c1,c1+=i+2;\\n        int n=a.size();\\n        for (int i=0;i<n;++i){\\n            add(c[0],&a[i],1);\\n            for (int j=0;((i+1)&(1<<j))==0;++j)add(c[j+1],c[j],j+2);\\n        }\\n        for (int i=0;i<L-1;++i)add(c[i+1],c[i],i+2);\\n        int ans=0;\\n        for (int i=0;i<W-1;++i){\\n            int s=0;\\n            for (int j=0;j<L;++j)s+=((c[L-1][j]>>i)&1)<<j;\\n            ans+=s*(n-s);\\n        }\\n        return ans;\\n    }\\n};\\n\\n//beat 95.95% without IO\\nint _IO=[](){\\n    std::ios::sync_with_stdio(0);\\n    cin.tie(0); cout.tie(0);\\n    return 0;\\n}();\\n```",
                "solutionTags": [],
                "code": "```\\nconst int L=16,W=32;\\nclass Solution {\\npublic:\\n    void add(int *a,int *b,int m){\\n        int t=0;\\n        for (int i=0;i<m;++i){\\n            int t1=a[i]^b[i]^t;\\n            t=a[i]&(b[i]|t)|b[i]&t;\\n            a[i]=t1;b[i]=0;\\n        }\\n        a[m]=t;\\n    }\\n    int totalHammingDistance(vector<int>& a){\\n        static int c_[L*L*2]; memset(c_,0,sizeof(c_));\\n        int *c[L],*c1=c_;\\n        for (int i=0;i<L;++i)c[i]=c1,c1+=i+2;\\n        int n=a.size();\\n        for (int i=0;i<n;++i){\\n            add(c[0],&a[i],1);\\n            for (int j=0;((i+1)&(1<<j))==0;++j)add(c[j+1],c[j],j+2);\\n        }\\n        for (int i=0;i<L-1;++i)add(c[i+1],c[i],i+2);\\n        int ans=0;\\n        for (int i=0;i<W-1;++i){\\n            int s=0;\\n            for (int j=0;j<L;++j)s+=((c[L-1][j]>>i)&1)<<j;\\n            ans+=s*(n-s);\\n        }\\n        return ans;\\n    }\\n};\\n\\n//beat 95.95% without IO\\nint _IO=[](){\\n    std::ios::sync_with_stdio(0);\\n    cin.tie(0); cout.tie(0);\\n    return 0;\\n}();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 240755,
                "title": "8-lines-python-solution",
                "content": "```python\\nclass Solution:\\n    def totalHammingDistance(self, nums: \\'List[int]\\') -> \\'int\\':\\n        res = 0\\n        for i in range(31, -1, -1):\\n            a, b = 0, 0\\n            for n in nums:\\n                if n & 1 << i: a += 1\\n                else: b += 1\\n            res += a * b\\n        return res\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def totalHammingDistance(self, nums: \\'List[int]\\') -> \\'int\\':\\n        res = 0\\n        for i in range(31, -1, -1):\\n            a, b = 0, 0\\n            for n in nums:\\n                if n & 1 << i: a += 1\\n                else: b += 1\\n            res += a * b\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 171762,
                "title": "java-o-31-n-time-complexity-o-1-space-solution",
                "content": "```\\nclass Solution {\\n    public int totalHammingDistance(int[] nums) {\\n        int res = 0;\\n        for (int i = 0; i < 31; i++) {\\n            int one = 0;\\n            int zero = 0;\\n            for (int num : nums) {\\n                if (((num >> i) & 1) == 1) {\\n                    one++;\\n                } else {\\n                    zero++;\\n                }\\n            }\\n            res += (one * zero);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int totalHammingDistance(int[] nums) {\\n        int res = 0;\\n        for (int i = 0; i < 31; i++) {\\n            int one = 0;\\n            int zero = 0;\\n            for (int num : nums) {\\n                if (((num >> i) & 1) == 1) {\\n                    one++;\\n                } else {\\n                    zero++;\\n                }\\n            }\\n            res += (one * zero);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 154662,
                "title": "go-divide-and-conquer-step-size-1-beats-100",
                "content": "```\\nfunc totalHammingDistance(nums []int) int {\\n    ret := 0\\n    n := len(nums)\\n    for i := 0; i < 32; i++ {\\n        ones := 0\\n        for i := range nums {\\n            ones += nums[i] & 1\\n            nums[i] = nums[i] >> 1\\n        }\\n        ret += ones * (n - ones)\\n    }\\n    return ret\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc totalHammingDistance(nums []int) int {\\n    ret := 0\\n    n := len(nums)\\n    for i := 0; i < 32; i++ {\\n        ones := 0\\n        for i := range nums {\\n            ones += nums[i] & 1\\n            nums[i] = nums[i] >> 1\\n        }\\n        ret += ones * (n - ones)\\n    }\\n    return ret\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 96276,
                "title": "easy-to-under-stand-java-solution-bit-manipulation",
                "content": "Key word: Hamming distance, Array of numbers, Hamming distance between each pair.\\nRequirement: Find the total hamming distance.\\nBrute force: For each pair of number, calculate their hamming distance, Time complexity is O(n^2).\\nImproved method:\\n1. **Vertically** take a look at the bits at a given position across all the numbers.\\n2. Every bit is either one or zero, let`s say we have x set bits and y unset bits, the total pairs that can generate a distance of 1 at this position is x*y. \\n3. Apply the above calculation to all bits and sum up the total distance.\\n4. Time complexity is O(n) and space complexity is O(1).\\n```java\\npublic class Solution {\\n    public int totalHammingDistance(int[] nums) {\\n        int total = 0;\\n        int mask = 1;\\n        for (int i = 0; i < 32; i++) {\\n            int setBit = 0;\\n            for (int j : nums) {\\n                setBit += (j & mask) == 0 ? 0 : 1;\\n            }\\n            total += setBit * (nums.length - setBit);\\n            mask <<= 1;\\n        }\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Iterator"
                ],
                "code": "```java\\npublic class Solution {\\n    public int totalHammingDistance(int[] nums) {\\n        int total = 0;\\n        int mask = 1;\\n        for (int i = 0; i < 32; i++) {\\n            int setBit = 0;\\n            for (int j : nums) {\\n                setBit += (j & mask) == 0 ? 0 : 1;\\n            }\\n            total += setBit * (nums.length - setBit);\\n            mask <<= 1;\\n        }\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96284,
                "title": "8-lines-dp-solution-by-one-pass-with-explanation",
                "content": " It's really a straight forward method. To sum the distances of every pair, you can make it with element one by one. For example, you check first element and second one, then check the coming third one with first and second element as: (1,2), (1,3), (2,3)...So the only thing you need to do is check how many more distances come with a new element nums[k] with passed elements nums[0],nums[1],...,nums[k-1].\\n\\nI used a matrix(O(1) space) to store total amounts of 0's and 1's at every bit of already passed numbers.\\n**(x>>i)&1** gets the ith bit of current number.\\n**((x>>i)&1)^1** gets the opposite of ith bit of current number, which makes the total Hamming distances between current number and passed numbers.\\n```\\n    public int totalHammingDistance(int[] nums) {\\n        int[][] dp = new int[31][2];\\n        int res = 0;\\n        for (int x : nums)\\n            for (int i=0; i<31; ++i) {\\n                ++dp[i][(x>>i)&1];\\n                res += dp[i][((x>>i)&1)^1];\\n            }\\n        return res;\\n    }\\n````",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int totalHammingDistance(int[] nums) {\\n        int[][] dp = new int[31][2];\\n        int res = 0;\\n        for (int x : nums)\\n            for (int i=0; i<31; ++i) {\\n                ++dp[i][(x>>i)&1];\\n                res += dp[i][((x>>i)&1)^1];\\n            }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3903566,
                "title": "c-optimal-and-easy-solution-detailed-explanation-provided-o-n",
                "content": "# Intuition\\nThe intuition behind solving this problem is to calculate the Hamming distance for each bit position (from 0 to 31) between all pairs of elements in the given array. The Hamming distance between two numbers at a specific bit position is the count of elements with that bit set (1) multiplied by the count of elements with that bit unset (0) at that position.\\n\\n# Approach\\nTo achieve this, we iterate through each bit position (from 0 to 31) and maintain a count of elements with the current bit set. We then calculate the Hamming distance for the current bit position and accumulate it. Finally, we return the total accumulated Hamming distance as the result.\\n\\n1. Initialize `totalDistance` to keep track of the sum of Hamming distances for all bit positions.\\n\\n2. Loop through each bit position (from 0 to 31):\\n\\n   a. Initialize `countSetBits` to 0. This variable will count the number of elements that have the current bit position set (1).\\n\\n   b. Loop through each element in the input array:\\n\\n      - Right shift the current element by the current bit position and perform bitwise AND with 1 to check if the bit is set.\\n      - If the bit is set, increment `countSetBits`.\\n\\n   c. Calculate the count of elements with the current bit position unset (0) as `totalElements - countSetBits`.\\n\\n   d. Calculate the Hamming distance for the current bit position as `countSetBits * (totalElements - countSetBits)`.\\n\\n   e. Add the calculated Hamming distance for the current bit position to the `totalDistance`.\\n\\n3. After looping through all 32 bit positions, `totalDistance` will contain the sum of Hamming distances for all pairs of elements in the array.\\n\\n4. Return `totalDistance` as the final result.\\n\\n# Complexity\\n- Time complexity: $$O(n * 32)$$, where `n` is the number of elements in the input array. We iterate through each bit position for each element in the array.\\n- Space complexity: $$O(1)$$, as we are using a constant amount of extra space to store variables like `totalDistance`, `countSetBits`, and the loop counters.\\n\\nThis approach ensures a linear runtime complexity and uses only constant extra space.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        int n = nums.size(); // Get the total number of elements in the array\\n        int totalDistance = 0; // Initialize the total Hamming distance to 0\\n        \\n        // Iterate through each bit position (from 0 to 31)\\n        for (int i = 0; i < 32; i++) {\\n            int countSetBits = 0; // Count of elements with \\'i\\'th bit set (1)\\n            \\n            // Count the number of elements that have the \\'i\\'th bit set (1)\\n            for (int k = 0; k < n; k++) {\\n                // Right shift the k-th element by \\'i\\' positions and check the least significant bit\\n                // If it\\'s 1, increment the count of set bits\\n                countSetBits += (nums[k] >> i) & 1;\\n            }\\n            \\n            // The number of elements with \\'i\\'th bit unset (0) is \\'n - countSetBits\\'\\n            // Therefore, the Hamming distance for this bit position is \\'countSetBits * (n - countSetBits)\\'\\n            totalDistance += countSetBits * (n - countSetBits);\\n        }\\n        \\n        return totalDistance; // Return the calculated total Hamming distance\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        int n = nums.size(); // Get the total number of elements in the array\\n        int totalDistance = 0; // Initialize the total Hamming distance to 0\\n        \\n        // Iterate through each bit position (from 0 to 31)\\n        for (int i = 0; i < 32; i++) {\\n            int countSetBits = 0; // Count of elements with \\'i\\'th bit set (1)\\n            \\n            // Count the number of elements that have the \\'i\\'th bit set (1)\\n            for (int k = 0; k < n; k++) {\\n                // Right shift the k-th element by \\'i\\' positions and check the least significant bit\\n                // If it\\'s 1, increment the count of set bits\\n                countSetBits += (nums[k] >> i) & 1;\\n            }\\n            \\n            // The number of elements with \\'i\\'th bit unset (0) is \\'n - countSetBits\\'\\n            // Therefore, the Hamming distance for this bit position is \\'countSetBits * (n - countSetBits)\\'\\n            totalDistance += countSetBits * (n - countSetBits);\\n        }\\n        \\n        return totalDistance; // Return the calculated total Hamming distance\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701621,
                "title": "c-solution-clean-and-easy-to-understand-code-with-explanation",
                "content": "The intuition of this approach is to found the number of ones and zeroes in the LSB (least significant bit) of every number. If the pair of elements both have same LSB then its ok, else if they have different LSB then we increment the count. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int> &nums){\\n    int sum = 0, n = nums.size();\\n    for (int i = 0; i < 32; i++)\\n    {\\n        int ones = 0, zeroes = 0;\\n        for (int j = 0; j < n; j++)\\n        {\\n            if (nums[j] % 2 == 0)\\n                zeroes++;\\n            else if (nums[j] % 1 == 0)\\n                ones++;\\n            nums[j] /= 2;\\n        }\\n        if (ones == n || zeroes == n)\\n            sum += 0;\\n        else\\n            sum += (ones * zeroes);\\n    }\\n    return sum;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int> &nums){\\n    int sum = 0, n = nums.size();\\n    for (int i = 0; i < 32; i++)\\n    {\\n        int ones = 0, zeroes = 0;\\n        for (int j = 0; j < n; j++)\\n        {\\n            if (nums[j] % 2 == 0)\\n                zeroes++;\\n            else if (nums[j] % 1 == 0)\\n                ones++;\\n            nums[j] /= 2;\\n        }\\n        if (ones == n || zeroes == n)\\n            sum += 0;\\n        else\\n            sum += (ones * zeroes);\\n    }\\n    return sum;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3666871,
                "title": "bit-manipulation-easy-c-solution",
                "content": "# Intuition\\nWe iterate through each and every bit and count no of values having zero and ones at that position respectively.\\nLet these be \"z\" and \"o\". Then for every bit we add (z * o) to our answer.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        int n = nums.size();\\n        int ans = 0;\\n        for(int j=0;j<32;j++){\\n            int one = 0, z = 0;\\n            for(int i=0;i<n;i++){\\n                int bit = (nums[i] >> j) & 1;\\n                if(bit == 1)one++;\\n                \\n                else z++;\\n            }\\n            ans += one * z;\\n        }   \\n\\n        return ans;\\n    }\\n};\\n```\\n\\n\\nIf you find this helpful, please UPVOTE : )\\n\\n![11.jpg](https://assets.leetcode.com/users/images/9bf9fd83-4aae-4434-9342-49cbf63887c9_1687374759.1307895.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        int n = nums.size();\\n        int ans = 0;\\n        for(int j=0;j<32;j++){\\n            int one = 0, z = 0;\\n            for(int i=0;i<n;i++){\\n                int bit = (nums[i] >> j) & 1;\\n                if(bit == 1)one++;\\n                \\n                else z++;\\n            }\\n            ans += one * z;\\n        }   \\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281204,
                "title": "477-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Define a function named totalHammingDistance that takes a list of integers nums as input and returns an integer as output.\\n2. Get the length of the nums list and store it in a variable n.\\n3. Initialize a variable result to zero.\\n4. Loop through each bit position i from 0 to 29:\\n    1. Initialize a variable count to zero.\\n    2. Loop through each integer num in nums:\\n        1. Right-shift num by i positions and bitwise AND the result with 1 to get the value of the bit at position i.\\n        2. If the value is 1, increment count by 1.\\n    3. Compute the Hamming distance for position i by multiplying count by (n - count) and add the result to result.\\n5. Return the final value of result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def totalHammingDistance(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        result = 0\\n        for i in range(30):\\n            count = 0\\n            for num in nums:\\n                count += (num >> i) & 1\\n            result += count * (n - count)\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def totalHammingDistance(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        result = 0\\n        for i in range(30):\\n            count = 0\\n            for num in nums:\\n                count += (num >> i) & 1\\n            result += count * (n - count)\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046559,
                "title": "one-line-python-solution-beats-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first thought on how to solve this problem was to find the Hamming Distance between each pair of integers in the given list. The Hamming Distance between two integers is the number of positions at which the corresponding bits are different.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMy approach to solving this problem is to first convert each integer in the given list to its binary representation, which will be a string of 32 characters. Then use zip() function and map() function to pair each bit of the integers, count the number of \\'0\\' and \\'1\\' in each pair. Multiply the count of \\'0\\' and \\'1\\' and sum them up, this will give the total Hamming distance between all integers.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def totalHammingDistance(self, nums: List[int]) -> int:\\n        return sum(b.count(\\'0\\')*b.count(\\'1\\') for b in zip(*map(\\'{:032b}\\'.format,nums)))\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def totalHammingDistance(self, nums: List[int]) -> int:\\n        return sum(b.count(\\'0\\')*b.count(\\'1\\') for b in zip(*map(\\'{:032b}\\'.format,nums)))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767569,
                "title": "bruteforce-to-optimal-java-time-o-n",
                "content": "```\\nclass Solution {\\n    public int totalHammingDistance(int[] nums) {\\n        //brute force time o(n^2)\\n        //algo - iterate through every posible pairs and find their onbits \\n        //by xor and then bitcount\\n        int sum=0;\\n        int n = nums.length;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                int bitcount =0;\\n                int xor = nums[i] ^ nums[j];\\n                int mask = 1;\\n                //or we can use Integer.bitCount(xor)\\n                while(mask!=0)\\n                {\\n                    int d = xor & mask;\\n                    if(d != 0)\\n                        bitcount++;\\n                    mask = mask << 1;\\n                }\\n                sum+=bitcount;\\n            }\\n        }\\n        return sum;\\n        \\n        //---------\\n        \\n        //time o(32*n) = o(n)\\n        //as we are checking every pair why not check at the same time for \\n        //every element.\\n        //so we will check every bit of every elem same time then find the\\n        //on bit and off bit and the difference will be multiple of on and \\n        //off bit.\\n        //example 1 - 0100 - 4\\n        //            1110 - 14\\n        //            0010 - 2\\n        //starting from rightmost(3) bit all bits are same.\\n        //then for(2) only one bit is different and that is 0 other s are 1\\n        //here on bit count is 2 and off bit count is 1 so total difference \\n        //will be 2*1 = 2 , bcz both 2 and 14 can be pair with 4.\\n        //repeate this for all bits then sum the diff.\\n        int n = nums.length;\\n        int sum = 0;\\n        for(int i=0;i<32;i++){\\n            int countbiton =0 , countbitoff = 0 , diff = 0;\\n            for(int elm:nums){\\n                if((elm & (1<<i)) != 0 ) // check on or off with bitmask\\n                    countbiton++;\\n            }\\n            countbitoff = n-countbiton;\\n            diff = countbitoff*countbiton;\\n            sum+=diff;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    public int totalHammingDistance(int[] nums) {\\n        //brute force time o(n^2)\\n        //algo - iterate through every posible pairs and find their onbits \\n        //by xor and then bitcount\\n        int sum=0;\\n        int n = nums.length;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                int bitcount =0;\\n                int xor = nums[i] ^ nums[j];\\n                int mask = 1;\\n                //or we can use Integer.bitCount(xor)\\n                while(mask!=0)\\n                {\\n                    int d = xor & mask;\\n                    if(d != 0)\\n                        bitcount++;\\n                    mask = mask << 1;\\n                }\\n                sum+=bitcount;\\n            }\\n        }\\n        return sum;\\n        \\n        //---------\\n        \\n        //time o(32*n) = o(n)\\n        //as we are checking every pair why not check at the same time for \\n        //every element.\\n        //so we will check every bit of every elem same time then find the\\n        //on bit and off bit and the difference will be multiple of on and \\n        //off bit.\\n        //example 1 - 0100 - 4\\n        //            1110 - 14\\n        //            0010 - 2\\n        //starting from rightmost(3) bit all bits are same.\\n        //then for(2) only one bit is different and that is 0 other s are 1\\n        //here on bit count is 2 and off bit count is 1 so total difference \\n        //will be 2*1 = 2 , bcz both 2 and 14 can be pair with 4.\\n        //repeate this for all bits then sum the diff.\\n        int n = nums.length;\\n        int sum = 0;\\n        for(int i=0;i<32;i++){\\n            int countbiton =0 , countbitoff = 0 , diff = 0;\\n            for(int elm:nums){\\n                if((elm & (1<<i)) != 0 ) // check on or off with bitmask\\n                    countbiton++;\\n            }\\n            countbitoff = n-countbiton;\\n            diff = countbitoff*countbiton;\\n            sum+=diff;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1586104,
                "title": "simple-python-solution-with-comments-time-o-n-space-o-1",
                "content": "```\\nclass Solution:\\n    def totalHammingDistance(self, nums: List[int]) -> int:\\n        \\n        # bits stores the count of numbers in nums for which the ith bit is set\\n        \\n        bits = [0]*32\\n        \\n        # consider [4,14,2]\\n        # \\n        #   3 2 1 0 (ith bit)\\n        # ---------------\\n        #   0 1 0 0 -> 4 \\n        #   1 1 1 0 -> 14\\n        #   0 0 1 0 -> 2\\n        # ---------------\\n        #   1 2 2 0 -> bits[]\\n        #\\n        # if the ith bit of a number is zero then \\n        # the sum of its XOR at ith bit with every number in nums will be bits[i] \\n    \\n        \\n        for num in nums:\\n            i = 0\\n            while num:\\n                bits[i] += num&1\\n                num = num >>1\\n\\t\\t\\t\\ti+=1\\n        \\n        total = 0\\n        for num in nums:\\n            for i in range(32):\\n                if not num&1:\\n                    total += bits[i]\\n                num = num >>1\\n             \\n        return total\\n\\n\\n# UPDATE: \\n        \\n        ans = 0\\n        n = len(nums)\\n        \\n        # the sum of pair wise XOR at ith bit is\\n        # the product of number of set bits and unset bits\\n        \\n        \\n        for i in range(32):\\n            ones = 0\\n            for num in nums:\\n                ones += (num>>i)&1\\n            # (n - ones) is the number of zeroes\\n            ans += ones*(n-ones)\\n        return ans\\n    \\n        \\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def totalHammingDistance(self, nums: List[int]) -> int:\\n        \\n        # bits stores the count of numbers in nums for which the ith bit is set\\n        \\n        bits = [0]*32\\n        \\n        # consider [4,14,2]\\n        # \\n        #   3 2 1 0 (ith bit)\\n        # ---------------\\n        #   0 1 0 0 -> 4 \\n        #   1 1 1 0 -> 14\\n        #   0 0 1 0 -> 2\\n        # ---------------\\n        #   1 2 2 0 -> bits[]\\n        #\\n        # if the ith bit of a number is zero then \\n        # the sum of its XOR at ith bit with every number in nums will be bits[i] \\n    \\n        \\n        for num in nums:\\n            i = 0\\n            while num:\\n                bits[i] += num&1\\n                num = num >>1\\n\\t\\t\\t\\ti+=1\\n        \\n        total = 0\\n        for num in nums:\\n            for i in range(32):\\n                if not num&1:\\n                    total += bits[i]\\n                num = num >>1\\n             \\n        return total\\n\\n\\n# UPDATE: \\n        \\n        ans = 0\\n        n = len(nums)\\n        \\n        # the sum of pair wise XOR at ith bit is\\n        # the product of number of set bits and unset bits\\n        \\n        \\n        for i in range(32):\\n            ones = 0\\n            for num in nums:\\n                ones += (num>>i)&1\\n            # (n - ones) is the number of zeroes\\n            ans += ones*(n-ones)\\n        return ans\\n    \\n        \\n\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1539629,
                "title": "c-bit-manipulation-o-32-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n      int ans=0;\\n       for(int i=0; i<32; i++){\\n           int no_of_zeros=0;\\n           int no_of_ones=0;\\n           for(int j=0; j<nums.size(); j++){\\n               if(nums[j]&(1<<i)) no_of_ones++;\\n               else no_of_zeros++;\\n           }\\n             if(no_of_ones == nums.size() || no_of_zeros == nums.size()) continue;\\n           else ans+=(no_of_ones*no_of_zeros);\\n       }\\n         return ans;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n      int ans=0;\\n       for(int i=0; i<32; i++){\\n           int no_of_zeros=0;\\n           int no_of_ones=0;\\n           for(int j=0; j<nums.size(); j++){\\n               if(nums[j]&(1<<i)) no_of_ones++;\\n               else no_of_zeros++;\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 1456186,
                "title": "java-bitwise-operation-solution",
                "content": "```\\n// Bitwise Operation Solution\\n// For each bit, the hamming distance = num of 1\\'s * num of 0\\'s in this bit.\\n// Time complexity: O(N)\\n// Space complexity: O(1)\\nclass Solution {\\n    public int totalHammingDistance(int[] nums) {\\n        final int N = nums.length;\\n        int res = 0;\\n        for (int bit = 0; bit < 32; bit++) {\\n            int bitCount = 0;\\n            for (int i = 0; i < N; i++) {\\n                bitCount += (nums[i] >> bit) & 1;\\n            }\\n            res += bitCount * (N - bitCount);  // num of 1\\'s * num of 0\\'s in this bit.\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Bitwise Operation Solution\\n// For each bit, the hamming distance = num of 1\\'s * num of 0\\'s in this bit.\\n// Time complexity: O(N)\\n// Space complexity: O(1)\\nclass Solution {\\n    public int totalHammingDistance(int[] nums) {\\n        final int N = nums.length;\\n        int res = 0;\\n        for (int bit = 0; bit < 32; bit++) {\\n            int bitCount = 0;\\n            for (int i = 0; i < N; i++) {\\n                bitCount += (nums[i] >> bit) & 1;\\n            }\\n            res += bitCount * (N - bitCount);  // num of 1\\'s * num of 0\\'s in this bit.\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1432557,
                "title": "simple-c-solution-with-easy-explaination",
                "content": "**Optimal solution**\\n  Complexity O(n)\\n```\\n//Brute force approach\\n\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                int a=nums[i]^nums[j];\\n                ans+= __builtin_popcount(a);  // C++ stl function to count number of set bits\\n            }\\n        }\\n        return ans;\\n\\t\\t}\\n\\t\\t};\\n   \\n /*Better O(n) Linear time solution\\n        eg-[2,4,6]\\n        \\n        we have 2 in binary as 010\\n        4 in binary 100\\n        and 6 in binary is 110\\n        \\n        We can observe that to count pairs of different bits at a particular position we just need \\n        bits of that position like comapring ones digit of each number with ones digit of other.\\n        \\n        So we have in above example 1st bit[0,0,0]-0 pair of distinct digits.\\n        2nd bit [1,0,1] - 2 pairs of different digits.\\n        3rd bit [0,1,1] - 2 pairs of different digits.\\n        \\n        This shows that we count the number of different pairs of digit for each position and add them up \\n        to get the the expected answer.\\n        \\n        To find pairs of distinct digits we just need count of set bits(1) and count of unsetbit(0)\\n        The total number of possible distinct pairs will be count of 0 * countof 1.\\n*/        \\n        //The implementation of above approach is as follows\\n    class Solution {\\n    public:\\n        int totalHammingDistance(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=0;\\n        for(int i=0;i<32;i++)//Since integer have 32 bits we just need to find the number of distinct pairs for each  postion upto 32\\n        {\\n            int countSetBitsInIthPosition = 0;\\n            int countUnsetBitsInIthPostion = 0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if((nums[j]&1<<i)>0) //Check whether ith bit is set or not\\n                    countSetBitsInIthPosition++;\\n                else\\n                   countUnsetBitsInIthPostion++;\\n           }\\n            \\n            ans+=(countSetBitsInIthPosition*countUnsetBitsInIthPostion);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                int a=nums[i]^nums[j];\\n                ans+= __builtin_popcount(a);  // C++ stl function to count number of set bits\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1283227,
                "title": "c-simple-solution-with-explanation-100-run-time",
                "content": "**Analysis:**\\n\\nPerhaps the easiest approach that comes to mind at the very beginning is to iterate through all pairs of elements in the array, compute their Hamming distance, and add it to the result. The run time complexitiy of this approach is of course `O(N^2)`.\\n\\nHow can we do better than that? Observe that in the naive approach above, for each element, we have to iterate through every element after it to be able to iterate through every pair. So, for a particular element, we only care about the total number of `1`s and `0`s at each bit position after this element.\\n\\nSo the intuition to reduce the run time complexity from `O(N^2)` to `O(N)` is that **by keep tracking the number of `1`s and `0`s at each bit position at and after index `i`, that\\'s all the information we need to compute the total Hamming distances at index `i-1`.**\\n\\n**Solution:**\\n\\n```\\npublic:\\n    int totalHammingDistance(std::vector<int>& nums) {\\n        const auto n = nums.size();\\n\\n        if ( n < 2 )\\n            return 0;\\n\\n        int bits[32][2] = { 0 };\\n\\n        for ( int b = 0; b < 32; ++b ) {\\n            auto bit = ( ( nums[0] & ( 1 << b ) ) == 0 ? 0 : 1 );\\n            bits[b][bit]++;\\n        }\\n\\n        int res = 0;\\n\\n        for ( int i = 1; i < n; ++i ) {\\n            const auto v = nums[i];\\n            for ( int b = 0; b < 32; ++b ) {\\n                auto bit = ( ( v & ( 1 << b ) ) == 0 ? 0 : 1 );\\n                res += bits[b][bit^1];\\n                bits[b][bit]++;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\npublic:\\n    int totalHammingDistance(std::vector<int>& nums) {\\n        const auto n = nums.size();\\n\\n        if ( n < 2 )\\n            return 0;\\n\\n        int bits[32][2] = { 0 };\\n\\n        for ( int b = 0; b < 32; ++b ) {\\n            auto bit = ( ( nums[0] & ( 1 << b ) ) == 0 ? 0 : 1 );\\n            bits[b][bit]++;\\n        }\\n\\n        int res = 0;\\n\\n        for ( int i = 1; i < n; ++i ) {\\n            const auto v = nums[i];\\n            for ( int b = 0; b < 32; ++b ) {\\n                auto bit = ( ( v & ( 1 << b ) ) == 0 ? 0 : 1 );\\n                res += bits[b][bit^1];\\n                bits[b][bit]++;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1053873,
                "title": "descriptive-easy-to-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n    { \\n        int n = nums.size();   \\n        int ans = 0; // Initialize result\\n            //int z=0,o=0;\\n  \\n    // traverse over all bits \\n    for (int i = 0; i < 32; i++) { \\n        // count number of elements with i\\'th bit set \\n        int count = 0; \\n        for (int j = 0; j < n; j++) \\n            if ((nums[j] & (1 << i))) \\n                count++; \\n  \\n        // Add \"count * (n - count) * 2\" to the answer \\n        //count of one\\'s is \\'count\\'->o & so count of zeroes id \\'n-count\\'->Z\\n        //so number of different bits are o*Z \\n        \\n        ans += (count * (n - count)); \\n    }return ans;\\n    }}\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n    { \\n        int n = nums.size();   \\n        int ans = 0; // Initialize result\\n            //int z=0,o=0;\\n  \\n    // traverse over all bits \\n    for (int i = 0; i < 32; i++) { \\n        // count number of elements with i\\'th bit set \\n        int count = 0; \\n        for (int j = 0; j < n; j++) \\n            if ((nums[j] & (1 << i))) \\n                count++; \\n  \\n        // Add \"count * (n - count) * 2\" to the answer \\n        //count of one\\'s is \\'count\\'->o & so count of zeroes id \\'n-count\\'->Z\\n        //so number of different bits are o*Z \\n        \\n        ans += (count * (n - count)); \\n    }return ans;\\n    }}\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 976266,
                "title": "c-o-n-simple-solution-bit-manipulation",
                "content": "We just need to calculate the number of ones and zeros for a particular position of that bit. And then we will multiply the number of ones and zeros and will add them for all the positions.\\n```\\nint totalHammingDistance(vector<int>& nums) {\\n        int ones = 0, total = 0;\\n        \\n        for(int i = 0; i < 32; i++){\\n            ones = 0;\\n            for(auto x: nums){\\n                x = x >> i;\\n                if((x & 1) == 1) ones++;   \\n            }\\n            \\n            total += ones * (nums.size() - ones);\\n        }\\n        return total;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint totalHammingDistance(vector<int>& nums) {\\n        int ones = 0, total = 0;\\n        \\n        for(int i = 0; i < 32; i++){\\n            ones = 0;\\n            for(auto x: nums){\\n                x = x >> i;\\n                if((x & 1) == 1) ones++;   \\n            }\\n            \\n            total += ones * (nums.size() - ones);\\n        }\\n        return total;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 884105,
                "title": "python-count-number-of-bits-at-each-position",
                "content": "Compare all nums at the `j`th bit. If there are `bitCnt` number of bits is `1`, the total distance is `bitCnt * (n -bitCnt)`, because only `(0, 1)` pair contribue to disitance, other pairs `(0, 0)`, `(1, 1)` contribute `0` distance.\\n\\n\\n```\\nclass Solution:\\n    def totalHammingDistance(self, nums: List[int]) -> int:\\n        dist = 0\\n        for j in range(32):\\n            bitCnt = 0\\n            for x in nums:\\n                bitCnt += ((x >> j) & 1)\\n            dist += bitCnt * (len(nums)-bitCnt)\\n        return dist\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def totalHammingDistance(self, nums: List[int]) -> int:\\n        dist = 0\\n        for j in range(32):\\n            bitCnt = 0\\n            for x in nums:\\n                bitCnt += ((x >> j) & 1)\\n            dist += bitCnt * (len(nums)-bitCnt)\\n        return dist\\n```",
                "codeTag": "Java"
            },
            {
                "id": 853198,
                "title": "python3-o-n",
                "content": "Algo\\nDefine frequency table `freq` to count number of set bit in each bit. Then, the answer is the sum of product of number of set bit and number of unset bit at each bit. \\n\\n```\\nclass Solution:\\n    def totalHammingDistance(self, nums: List[int]) -> int:\\n        freq = [0]*32 # count of \"1\" (32-bit \"overkill\")\\n        for x in nums: \\n            x = bin(x)[2:].zfill(32) # 32-bit binary  \\n            for i in range(32): freq[i] += x[i] == \"1\"  # count of 1 \\n        return sum(freq[i] * (len(nums) - freq[i]) for i in range(32))\\n```\\n\\nAlternative implementation via prefix frequency table \\n```\\nclass Solution:\\n    def totalHammingDistance(self, nums: List[int]) -> int:\\n        ans = 0\\n        freq = [0]*32 # count of \"1\" (32-bit \"overkill\")\\n        for k, x in enumerate(nums): \\n            x = bin(x)[2:].zfill(32) # 32-bit binary  \\n            for i in range(32): \\n                if x[i] == \"0\": ans += freq[i] # count of 1 \\n                else: # x[i] == \"1\"\\n                    ans += k - freq[i] # count of 0\\n                    freq[i] += 1 # update count \\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def totalHammingDistance(self, nums: List[int]) -> int:\\n        freq = [0]*32 # count of \"1\" (32-bit \"overkill\")\\n        for x in nums: \\n            x = bin(x)[2:].zfill(32) # 32-bit binary  \\n            for i in range(32): freq[i] += x[i] == \"1\"  # count of 1 \\n        return sum(freq[i] * (len(nums) - freq[i]) for i in range(32))\\n```\n```\\nclass Solution:\\n    def totalHammingDistance(self, nums: List[int]) -> int:\\n        ans = 0\\n        freq = [0]*32 # count of \"1\" (32-bit \"overkill\")\\n        for k, x in enumerate(nums): \\n            x = bin(x)[2:].zfill(32) # 32-bit binary  \\n            for i in range(32): \\n                if x[i] == \"0\": ans += freq[i] # count of 1 \\n                else: # x[i] == \"1\"\\n                    ans += k - freq[i] # count of 0\\n                    freq[i] += 1 # update count \\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 849986,
                "title": "javascript-2-solutions-o-n-time-o-1-space",
                "content": "```\\nconst totalHammingDistance = nums => {\\n    let t = 0\\n    let mask = 1\\n    \\n    for ( let i = 0; i < 32; i++ ) {\\n        let c = nums.reduce( ( a, n ) => a + ( n & mask ? 1 : 0 ), 0 )\\n        \\n        t += c * ( nums.length - c )\\n\\n        mask <<= 1\\n    }\\n\\n    return t\\n}\\n\\nconst totalHammingDistance = nums => {\\n    const bits = []\\n    let num, mask, d\\n    \\n    for ( let i = 0; i < nums.length; i++ ) {\\n        mask = 1\\n        d = 0\\n        \\n        while ( mask <= nums[i] ) {\\n            if ( mask & nums[i] ) {\\n                bits[d] = 1 + ( bits[d] || 0 )\\n            }\\n            mask <<= 1\\n            d++\\n        }\\n    }\\n\\n    return bits.reduce( ( a, x ) => a + x * ( nums.length - x ), 0 )\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst totalHammingDistance = nums => {\\n    let t = 0\\n    let mask = 1\\n    \\n    for ( let i = 0; i < 32; i++ ) {\\n        let c = nums.reduce( ( a, n ) => a + ( n & mask ? 1 : 0 ), 0 )\\n        \\n        t += c * ( nums.length - c )\\n\\n        mask <<= 1\\n    }\\n\\n    return t\\n}\\n\\nconst totalHammingDistance = nums => {\\n    const bits = []\\n    let num, mask, d\\n    \\n    for ( let i = 0; i < nums.length; i++ ) {\\n        mask = 1\\n        d = 0\\n        \\n        while ( mask <= nums[i] ) {\\n            if ( mask & nums[i] ) {\\n                bits[d] = 1 + ( bits[d] || 0 )\\n            }\\n            mask <<= 1\\n            d++\\n        }\\n    }\\n\\n    return bits.reduce( ( a, x ) => a + x * ( nums.length - x ), 0 )\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 702110,
                "title": "c-o-n-counting-bits-in-each-bit-position",
                "content": "Total Hamming distance = sum of Hamming distances for each of 32 bit positions.\\nIf you write down a few binary numbers on the whiteboard and look at each bit position, you\\'ll notice that hamming distance for each bit position is equal to `ones * zeroes` in that bit position\\nThen the algorithm becomes clear.\\n\\n``` \\nint totalHammingDistance(vector<int>& nums) {\\n        int n=nums.size();\\n        int res=0;\\n        for(int bit=0; bit<32; bit++){\\n            int ones=0;\\n            for(int i=0; i<n; i++)\\n                ones+=(nums[i] & (1<<bit))?1:0;\\n            \\n            res+=ones*(n-ones);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "``` \\nint totalHammingDistance(vector<int>& nums) {\\n        int n=nums.size();\\n        int res=0;\\n        for(int bit=0; bit<32; bit++){\\n            int ones=0;\\n            for(int i=0; i<n; i++)\\n                ones+=(nums[i] & (1<<bit))?1:0;\\n            \\n            res+=ones*(n-ones);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 677672,
                "title": "python-solution",
                "content": "class Solution:\\n    def totalHammingDistance(self, nums: List[int]) -> int:\\n        \\n        n = len(nums)\\n        s = 0\\n        for i in range(32):\\n            c = 0\\n            for j in range(n):\\n                c += (nums[j]>>i) & 1\\n                \\n            s+= c *(n-c)\\n        return s\\n                \\n                \\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "class Solution:\\n    def totalHammingDistance(self, nums: List[int]) -> int:\\n        \\n        n = len(nums)\\n        s = 0\\n        for i in range(32):\\n            c = 0\\n            for j in range(n):\\n                c += (nums[j]>>i) & 1\\n                \\n            s+= c *(n-c)\\n        return s\\n                \\n                \\n",
                "codeTag": "Java"
            },
            {
                "id": 669353,
                "title": "clean-and-simple-solutions-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        \\n        int ans=0; int n=nums.size();\\n        \\n        for(int i=0;i<32;i++)\\n        {\\n            int set=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if((1<<i)&nums[j]) set++; // the ones having ith bit set\\n            }\\n            \\n            ans+=set*(n-set); //n-set are the ones that don\\'t have the ith bit set\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        \\n        int ans=0; int n=nums.size();\\n        \\n        for(int i=0;i<32;i++)\\n        {\\n            int set=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if((1<<i)&nums[j]) set++; // the ones having ith bit set\\n            }\\n            \\n            ans+=set*(n-set); //n-set are the ones that don\\'t have the ith bit set\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 538599,
                "title": "clean-java-solution",
                "content": "```\\nclass Solution {\\n    \\n    public int totalHammingDistance(int[] nums) {\\n        \\n        int sum = 0;\\n        \\n        for (int i = 0; i<32; i++) {\\n            int mask = (1 << i);\\n            \\n            int count = 0;\\n            \\n            for (int n : nums) {\\n                if ((n & mask) != 0)\\n                    count++;\\n            }\\n            sum += count * (nums.length - count);\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int totalHammingDistance(int[] nums) {\\n        \\n        int sum = 0;\\n        \\n        for (int i = 0; i<32; i++) {\\n            int mask = (1 << i);\\n            \\n            int count = 0;\\n            \\n            for (int n : nums) {\\n                if ((n & mask) != 0)\\n                    count++;\\n            }\\n            sum += count * (nums.length - count);\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 493747,
                "title": "java-clean-sol",
                "content": "```\\nclass Solution {\\n    public int totalHammingDistance(int[] nums) {\\n        int ans=0; //0100 1110 0010\\n        for(int i=0;i<32;i++){\\n            int one=0;int zero=0;\\n            for(int j=0;j<nums.length;j++){\\n                int n=nums[j];\\n                if((n&1)==0){\\n                    zero++;\\n                }else{\\n                    one++;\\n                }\\n                nums[j]=nums[j]>>1;\\n            }\\n            ans+=(one*zero);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int totalHammingDistance(int[] nums) {\\n        int ans=0; //0100 1110 0010\\n        for(int i=0;i<32;i++){\\n            int one=0;int zero=0;\\n            for(int j=0;j<nums.length;j++){\\n                int n=nums[j];\\n                if((n&1)==0){\\n                    zero++;\\n                }else{\\n                    one++;\\n                }\\n                nums[j]=nums[j]>>1;\\n            }\\n            ans+=(one*zero);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 402149,
                "title": "c-bits-operation-with-o-n-time-complexity-and-o-1-space-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        int res = 0;\\n        int N = nums.size();\\n        for (int bit = 0; bit < 32; bit++) {\\n            int bits_1 = 0;\\n            for (int num : nums) {\\n                if ((num >> bit) & 1 == 1)\\n                    bits_1++;\\n            }\\n            res += bits_1 * (N - bits_1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        int res = 0;\\n        int N = nums.size();\\n        for (int bit = 0; bit < 32; bit++) {\\n            int bits_1 = 0;\\n            for (int num : nums) {\\n                if ((num >> bit) & 1 == 1)\\n                    bits_1++;\\n            }\\n            res += bits_1 * (N - bits_1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 365584,
                "title": "c-o-n-solution-with-good-explanation",
                "content": "It\\'s easy to think about O(n^2) solution, but it has 99% chance to fail an interview. We have to find a better way. \\n\\nWe know that hamming distance is a bitwise operation, if we can find a way to do those bitwise operation together instead of separate, we are good. \\n\\nWe can use a 32 size array to reocrd number of occurance for each bits at index i (Because int type has 32 bits). we define an array dp, which means if we represent every number in binary, there are dp[i] numbers at index i is 1. For example, if input is (0100) (1110) (0010), then dp[0] = 1, dp[1] = 2, dp[2] = 2 and d[3] = 0. \\n\\nBecause totally there are n numbers, we know at index i, there are dp[i] number is 1 and n - dp[i] number is 0. Thus for each j belongs to dp[i] and each k belongs to n - dp[i], the hamming distance of pair {j,k} at position i must be 1, and there are (n - dp[i]) * dp[i] pairs in total. If we repeat the process for each position i, we then find out the total hamming distance, which equals to sum of (n-dp[i]) * dp[i] for i = 0 : 31.\\n\\nHere is the c++ codes. \\n```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        int dp[32] = {};\\n        for(int x : nums){\\n            bitset<32> b(x);\\n            for(int i = 0;i<b.size();i++){\\n                if(b[i]){\\n                    dp[i] += 1;\\n                }\\n            }\\n        }\\n        int ret = 0;\\n        int n = nums.size();\\n        for(auto x: dp){\\n            ret += (n - x) * x;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        int dp[32] = {};\\n        for(int x : nums){\\n            bitset<32> b(x);\\n            for(int i = 0;i<b.size();i++){\\n                if(b[i]){\\n                    dp[i] += 1;\\n                }\\n            }\\n        }\\n        int ret = 0;\\n        int n = nums.size();\\n        for(auto x: dp){\\n            ret += (n - x) * x;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 337447,
                "title": "c-32-ms-96-solution-o-n-time-o-1-space",
                "content": "The idea behind this algorithm is that instead of comparing eah pair of numbers, we calculate the total hamming distance one bit at a time. The hamming distance is 1 only if the bits are different.  Thus, we can calculate the total hamming distance by finding out the number of 1s and 0s in that bit position, and multiply them together. The intuition is that say if there are 4 numbers, and for a specific bit there are 3 zeros and 1 one, then the hamming distance includes first zero + one, second zero + one, thid zero + one. So the total hamming distance from that bit is 3 * 1 = 3.\\n\\nThus, we can iterate through all the bits, and then calculate the number of zeros and ones in the bit, and multiply them together to get the total hamming distance for all bits.\\n\\nThe run-time is O(32n) = O(n), and the space complexity is O(1).\\n\\n```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        int dist = 0, size = nums.size();\\n        for(int i = 0; i < 32; ++i) {\\n            int count = 0, mask = 1 << i;\\n            for(const auto &n: nums)\\n                if(n & mask) ++count; // If mask not zero, we have a 1 bit\\n            dist += count * (size-count); // All other bits are zero, so size-count = 0 bits\\n        }\\n        return dist;\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        int dist = 0, size = nums.size();\\n        for(int i = 0; i < 32; ++i) {\\n            int count = 0, mask = 1 << i;\\n            for(const auto &n: nums)\\n                if(n & mask) ++count; // If mask not zero, we have a 1 bit\\n            dist += count * (size-count); // All other bits are zero, so size-count = 0 bits\\n        }\\n        return dist;\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 271095,
                "title": "thinking-process",
                "content": "Hamming distance is the number of positions at which the corresponding bits are different.\\n\\nIntuitively, we calculate distance between each two numbers and count the total.\\n```\\nn = nums.length\\nFor i 0..n\\n  For j i+1..n\\n    count += hamming distance of nums[i], nums[j]\\nreturn count\\n```\\n\\nLet\\'s think about it in other way, there are 32 bits in total, for each bit, we calculate number of 1s, and construct the total.\\n```\\nFor i 0..32\\n  For each num,\\n    count += (num >> i )& 1\\nreturn count\\n```\\n****\\n```\\n    public int totalHammingDistance(int[] nums) {\\n        int count = 0;\\n        for (int i = 0; i < 32; i++) { // Bit i\\n            // Count k numbers with 1 at bit i\\n            int k = 0;\\n            for (int num : nums) {\\n                k += (num >> i) & 1;\\n            }\\n            count += (nums.length - k) * k;\\n        }      \\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nn = nums.length\\nFor i 0..n\\n  For j i+1..n\\n    count += hamming distance of nums[i], nums[j]\\nreturn count\\n```\n```\\nFor i 0..32\\n  For each num,\\n    count += (num >> i )& 1\\nreturn count\\n```\n```\\n    public int totalHammingDistance(int[] nums) {\\n        int count = 0;\\n        for (int i = 0; i < 32; i++) { // Bit i\\n            // Count k numbers with 1 at bit i\\n            int k = 0;\\n            for (int num : nums) {\\n                k += (num >> i) & 1;\\n            }\\n            count += (nums.length - k) * k;\\n        }      \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 247217,
                "title": "java-solutions",
                "content": "**Solution 1: Brute-Force Algorithm**\\n\\n- Here we iterate through each pair to find the bitCount of `XOR` of each pair `(x, y)`\\n\\nTime complexity: O(n<sup>2</sup>)\\nSpace complexity: `O(1)`\\n\\n```\\nclass Solution\\n{\\n\\tpublic int totalHammingDistance(int[] A)\\n\\t{\\n        int total = 0;\\n\\t\\t\\n        for(int i = 0; i < A.length - 1; i++)\\n        {\\n            for(int j = i + 1; j < A.length; j++)\\n            {\\n                total += Integer.bitCount(A[i] ^ A[j]);\\n            }\\n        }\\n        return total;\\n    }\\n}\\n```\\n\\n**Solution 2: Optimized Approach**\\n\\n- Here we can separate the calculation to do one bit at a time.\\n- For each bit position `1-32` in a `32-bit` integer, we count the number of integers in the array which have that bit set. \\n- Then, if there are `n` integers in the array and `k` of them have a particular bit set and so `n - k` do not, then that bit contributes `k * (n - k)` hamming distance to the total.\\n- For example, look at the rightmost bit of all the numbers in the array. Suppose that `i` numbers have a rightmost `0-bit`, and `j` numbers have a `1-bit`. Then out of the pairs, `i * j` of them will have `1` in the rightmost bit of the `XOR`. This is because there are `i * j` ways to choose one number that has a `0-bit` and one that has a `1-bit`. These bits will therefore contribute `i * j` towards the total of all the `XORs`. Apply this algorithm to each bit and add them together.\\n- This can be done in `O(k * n)` time, where `k` is the number of bits in the given values.\\n\\nTime complexity: `O(n)`\\nSpace complexity: `O(1)`\\n\\n```\\nclass Solution\\n{\\n\\tpublic int totalHammingDistance(int[] A)\\n\\t{\\n\\t\\tint total = 0;\\n        int n = A.length;\\n        \\n\\t\\tfor(int i = 0; i < 32; i++)\\n\\t\\t{\\n\\t\\t\\tint bitCount = 0;\\n\\t\\t\\t\\n\\t\\t\\tfor(int x : A)\\n\\t\\t\\t{\\n\\t\\t\\t\\tbitCount += (x >> i) & 1;\\n\\t\\t\\t} \\n\\t\\t\\ttotal += bitCount * (n - bitCount);\\n\\t\\t}\\n\\t\\treturn total;\\n\\t}\\n}\\n```\\n**OR**\\n```\\nclass Solution\\n{\\n\\tpublic int totalHammingDistance(int[] A)\\n\\t{\\n\\t\\tint total = 0;\\n        \\n\\t\\tfor(int i = 0; i < 32; i++)\\n\\t\\t{\\n\\t\\t\\tint countOnes = 0;\\n            int countZeros = 0;\\n\\n\\t\\t\\tfor(int x : A)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif((x >> i & 1) == 1)\\n                    countOnes++;\\n                else\\n                    countZeros++;\\n\\t\\t\\t} \\n\\t\\t\\ttotal += countOnes * countZeros;\\n\\t\\t}\\n\\t\\treturn total;\\n\\t}\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n\\tpublic int totalHammingDistance(int[] A)\\n\\t{\\n        int total = 0;\\n\\t\\t\\n        for(int i = 0; i < A.length - 1; i++)\\n        {\\n            for(int j = i + 1; j < A.length; j++)\\n            {\\n                total += Integer.bitCount(A[i] ^ A[j]);\\n            }\\n        }\\n        return total;\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n\\tpublic int totalHammingDistance(int[] A)\\n\\t{\\n\\t\\tint total = 0;\\n        int n = A.length;\\n        \\n\\t\\tfor(int i = 0; i < 32; i++)\\n\\t\\t{\\n\\t\\t\\tint bitCount = 0;\\n\\t\\t\\t\\n\\t\\t\\tfor(int x : A)\\n\\t\\t\\t{\\n\\t\\t\\t\\tbitCount += (x >> i) & 1;\\n\\t\\t\\t} \\n\\t\\t\\ttotal += bitCount * (n - bitCount);\\n\\t\\t}\\n\\t\\treturn total;\\n\\t}\\n}\\n```\n```\\nclass Solution\\n{\\n\\tpublic int totalHammingDistance(int[] A)\\n\\t{\\n\\t\\tint total = 0;\\n        \\n\\t\\tfor(int i = 0; i < 32; i++)\\n\\t\\t{\\n\\t\\t\\tint countOnes = 0;\\n            int countZeros = 0;\\n\\n\\t\\t\\tfor(int x : A)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif((x >> i & 1) == 1)\\n                    countOnes++;\\n                else\\n                    countZeros++;\\n\\t\\t\\t} \\n\\t\\t\\ttotal += countOnes * countZeros;\\n\\t\\t}\\n\\t\\treturn total;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96232,
                "title": "7-lines-c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        int distance = 0;\\n        for(int i = 0; i < 32; i++){\\n            int one = 0, zero = 0;\\n            for(auto x: nums) (x & (1 << i)) ? one++ : zero++;\\n            distance += one * zero;\\n        }\\n        return distance;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        int distance = 0;\\n        for(int i = 0; i < 32; i++){\\n            int one = 0, zero = 0;\\n            for(auto x: nums) (x & (1 << i)) ? one++ : zero++;\\n            distance += one * zero;\\n        }\\n        return distance;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96255,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Total Hamming Distance** https://leetcode.com/problems/total-hamming-distance/\\n\\n**Count 1s in each position: Time: O(N) and Space: O(1)**\\n* There are 32 bit positions in a 32 bit integer.\\n* We use a mask and for a bit position i, we count the number of ones in that bit position acoss all elements in nums. Then number of zeroes is len(nums)-ones.\\n* The contribution to hamming distance for this position will be ones * zeroes.\\n* Total time complexity: O(32N) ~32N\\n```\\nclass Solution(object):\\n    def count(self, nums, mask):\\n        ones = 0\\n        for x in nums:\\n            ones = ones + 1 if x & mask else ones\\n        return ones\\n    \\n    def totalHammingDistance(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        hamming, mask = 0, 1\\n        for i in range(32):\\n            ones = self.count(nums, mask << i)\\n            hamming += ones*(len(nums)-ones)\\n        return hamming\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def count(self, nums, mask):\\n        ones = 0\\n        for x in nums:\\n            ones = ones + 1 if x & mask else ones\\n        return ones\\n    \\n    def totalHammingDistance(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        hamming, mask = 0, 1\\n        for i in range(32):\\n            ones = self.count(nums, mask << i)\\n            hamming += ones*(len(nums)-ones)\\n        return hamming\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96263,
                "title": "share-my-easy-understanding-java-solution-counting-amount-of-1-in-different-position-and-calculate",
                "content": "```\\npublic class Solution {\\n\\t    public int totalHammingDistance(int[] nums) {\\n\\t    \\tint length = nums.length;\\n\\t        int[] hammSum = new int[32];\\n\\t        for(int n : nums){//count the amount of 1s in each position\\n\\t        \\tfor(int i = 0; i < 32 && n != 0; i++){\\n\\t        \\t\\tif((n & 1) == 1) hammSum[i]++;\\n\\t        \\t\\tn >>>=1;\\n\\t        \\t}\\n\\t        }\\n\\t        int total = 0;\\n\\t        for(int n : hammSum){//for each position, 1s and 0s combine as the hamming distance at this spot\\n\\t        \\ttotal += n * (length-n);\\n\\t        }\\n\\t        return total;\\n\\t    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n\\t    public int totalHammingDistance(int[] nums) {\\n\\t    \\tint length = nums.length;\\n\\t        int[] hammSum = new int[32];\\n\\t        for(int n : nums){//count the amount of 1s in each position\\n\\t        \\tfor(int i = 0; i < 32 && n != 0; i++){\\n\\t        \\t\\tif((n & 1) == 1) hammSum[i]++;\\n\\t        \\t\\tn >>>=1;\\n\\t        \\t}\\n\\t        }\\n\\t        int total = 0;\\n\\t        for(int n : hammSum){//for each position, 1s and 0s combine as the hamming distance at this spot\\n\\t        \\ttotal += n * (length-n);\\n\\t        }\\n\\t        return total;\\n\\t    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96285,
                "title": "golang-solution-with-explanation",
                "content": "If a integer has 1 bit different than another integer, that will contribute to the hamming distance. But if we calculate the hamming distance the hard way brute force, that will lead to TLE\\n\\nThe better way is to think of each bit position as either occupied by 1 or 0. All the 32 bit position for each input number can have the total count of 1s summed up. If you add the number input array total length minus the 1s sum, you will get the 0s count. If we multiply the 1s count and 0s count, that will give us the sum for that bit position. Why do we multiply? Because we have to take into account each and every integer in the input array pairing possibility.\\n\\nFollowing is golang code for this:\\n\\n\\n```\\nfunc totalHammingDistance(nums []int) int {\\n    sum := 0\\n    for i:= 0; i < 32; i++ {\\n        var ones uint\\n        ones = 0\\n        for _, c := range nums {\\n            v := uint(c)\\n            j := uint(i)\\n            ones += ((v >> j) & 0x01)\\n        }\\n        zeros:=(len(nums) - int(ones))\\n        sum += zeros * int(ones)\\n    } \\n    return sum\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc totalHammingDistance(nums []int) int {\\n    sum := 0\\n    for i:= 0; i < 32; i++ {\\n        var ones uint\\n        ones = 0\\n        for _, c := range nums {\\n            v := uint(c)\\n            j := uint(i)\\n            ones += ((v >> j) & 0x01)\\n        }\\n        zeros:=(len(nums) - int(ones))\\n        sum += zeros * int(ones)\\n    } \\n    return sum\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 96287,
                "title": "java-easy-solution-with-explanation",
                "content": "Hi there! Here the strightforward idea is to calculate haming distances between each pair and then sum them up. But that algorithm runs for O(31 * n^2). We have to make it faster. \\n``` ```Actually we don't need to consider each pair. Let's simplify the problem, such that each number consists of single bit. How could we solve then? This case we know, that haming distance between two numbers can be either 1 or 0. Well, 1 if bits are different and 0 otherwise. It means, the answer is the number of pairs with different bits. The latter is equals to the product of # of zero bits and # of set bits. \\n``` ```Our problem is the same. You can prove by yourselves that sum of haming distances is equals to the sum of pairs with different bits for each bit position from 1 to 31. Thus we come up with solution that works for O(1) space and O(31*n) time.\\n```\\npublic class Solution {\\n    public int totalHammingDistance(int[] nums) {\\n        int ans= 0 ;\\n        int bit = 1;\\n        for(int i = 0;i<31;i++){\\n            int zero = 0, one = 0;\\n            for(int j =  0;j<nums.length;j++){\\n                if((nums[j]&bit) == 0){\\n                    zero++;\\n                } else {\\n                    one++;\\n                }\\n            }\\n            ans+=zero*one;\\n            bit<<=1;\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "``` ```\n``` ```",
                "codeTag": "Unknown"
            },
            {
                "id": 3607411,
                "title": "easy-java-solution-o-32-n-detail-explanation-both-approaches",
                "content": "# Intuition \\nlogic : \\nthere are 2 options either follow what ques saying blindly and get higher complexity \\n1) make all pairs that will take you itself n^2 time and then for each pair going 32 times for bits :( TC : O(n^2)\\n2) better one is to only run outer loop for each bit and find distance among all numbers at that bit. only in O(n) time thus total O(32*n) time\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n/for example goin for 1st bit, find out how many ones are there(say k) from n and remaing zeroes will be n-k for 1st bit. now the hamming distance we will get from this 1st bit is ? \\nIt is (number of times we get 1s) * (no of zeroes) i.e. = k *(n-k) why?\\ncoz 1s bit is giving hamming distance from each 0s bit, so k 1s will give distance to ( (n-k) times k ) which is =  k*(n-k)\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(32*n) ~ O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\n    public int totalHammingDistance(int[] nums) {\\n        int hammingD = 0;\\n        for( int i = 0 ; i < 32 ; i++)\\n        {\\n            int count1s = 0;\\n            for( int j = 0; j < nums.length; j++)\\n            {\\n                count1s += (nums[j] >>> i)&1 ;// unsigned right shift to jth postiion then and with 1\\n                //to check bit is 1 or not.\\n            }\\n            hammingD += (count1s)*(nums.length - count1s);\\n        }\\n        return hammingD;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int totalHammingDistance(int[] nums) {\\n        int hammingD = 0;\\n        for( int i = 0 ; i < 32 ; i++)\\n        {\\n            int count1s = 0;\\n            for( int j = 0; j < nums.length; j++)\\n            {\\n                count1s += (nums[j] >>> i)&1 ;// unsigned right shift to jth postiion then and with 1\\n                //to check bit is 1 or not.\\n            }\\n            hammingD += (count1s)*(nums.length - count1s);\\n        }\\n        return hammingD;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3373531,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& A) {\\n        int res = 0, n = A.size(), m = *max_element(A.begin(), A.end());\\n        for(int i = 1; i <= m; i <<= 1)\\n        {\\n            int k = 0;\\n            for(int a : A)\\n                k += (a & i) == 0;\\n            res += k * (n - k);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def totalHammingDistance(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        r = 0\\n        for b in zip(*map(\\'{:032b}\\'.format, nums)):\\n            x = b.count(\\'0\\')\\n            r += x *(n-x)\\n        return r\\n```\\n\\n```Java []\\nclass Solution {\\n    public int totalHammingDistance(int[] nums) {\\n        int totalDist = 0;\\n        int n = nums.length;\\n        for (int i = 0; i < 32; i++) { \\n            int count = 0;\\n            for (int j = 0; j < n; j++) { \\n                count += (nums[j] >> i) & 1;\\n            }\\n            totalDist += count * (n - count); \\n        }\\n        return totalDist;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& A) {\\n        int res = 0, n = A.size(), m = *max_element(A.begin(), A.end());\\n        for(int i = 1; i <= m; i <<= 1)\\n        {\\n            int k = 0;\\n            for(int a : A)\\n                k += (a & i) == 0;\\n            res += k * (n - k);\\n        }\\n        return res;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def totalHammingDistance(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        r = 0\\n        for b in zip(*map(\\'{:032b}\\'.format, nums)):\\n            x = b.count(\\'0\\')\\n            r += x *(n-x)\\n        return r\\n```\n```Java []\\nclass Solution {\\n    public int totalHammingDistance(int[] nums) {\\n        int totalDist = 0;\\n        int n = nums.length;\\n        for (int i = 0; i < 32; i++) { \\n            int count = 0;\\n            for (int j = 0; j < n; j++) { \\n                count += (nums[j] >> i) & 1;\\n            }\\n            totalDist += count * (n - count); \\n        }\\n        return totalDist;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3078353,
                "title": "easy-solution-in-java-bitwise",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:O(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int totalHammingDistance(int[] nums) {\\n        int sum=0;\\n        for(int i=0;i<=nums.length-2;i++)\\n        {\\n            for(int j=i+1;j<=nums.length-1;j++)\\n            {\\n                sum=sum + Integer.bitCount(nums[i] ^ nums[j]);\\n            }\\n        }\\n        return sum;\\n        \\n    }\\n  \\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int totalHammingDistance(int[] nums) {\\n        int sum=0;\\n        for(int i=0;i<=nums.length-2;i++)\\n        {\\n            for(int j=i+1;j<=nums.length-1;j++)\\n            {\\n                sum=sum + Integer.bitCount(nums[i] ^ nums[j]);\\n            }\\n        }\\n        return sum;\\n        \\n    }\\n  \\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2940510,
                "title": "easy-and-clear-solution-python-3",
                "content": "```\\nclass Solution:\\n    def totalHammingDistance(self, nums: List[int]) -> int:\\n        res=0\\n        getbinary = lambda x, n: format(x, \\'b\\').zfill(n)\\n        bi=[]\\n        for i in range(len(nums)):\\n            a=getbinary(nums[i], 32)\\n            bi.append(a)\\n        for i in range (32):\\n            zero=0\\n            one=0\\n            for b in bi:\\n                if b[i]==\\'1\\':\\n                    one+=1\\n                else:\\n                    zero+=1\\n            res=res+ zero*one\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def totalHammingDistance(self, nums: List[int]) -> int:\\n        res=0\\n        getbinary = lambda x, n: format(x, \\'b\\').zfill(n)\\n        bi=[]\\n        for i in range(len(nums)):\\n            a=getbinary(nums[i], 32)\\n            bi.append(a)\\n        for i in range (32):\\n            zero=0\\n            one=0\\n            for b in bi:\\n                if b[i]==\\'1\\':\\n                    one+=1\\n                else:\\n                    zero+=1\\n            res=res+ zero*one\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2639906,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int totalHammingDistance(int[] nums) {\\n        int len=nums.length;\\n        int ans=0;\\n        \\n        for(int idx=0;idx<32;idx++){\\n            int countOne=0;\\n            int countZero=0;\\n            int mask=(1<<idx);\\n            \\n            for(int value=0;value<len;value++){\\n                \\n                if(( (nums[value] & mask) == 0 )){\\n                    countZero++;\\n                }else{\\n                    countOne++;\\n                }\\n                \\n            }\\n            ans= ans+ countOne*countZero;\\n        }\\n        return ans;\\n    }\\n}\\n\\n// TC: O(32) * O(N)\\n/*\\nwe have to find all the bits combi with all\\nso we are finding the no of once present and no of zero present \\nlater we are taking the mul, of them so we get all the combinations\\nand then we add up everything \\n*/\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int totalHammingDistance(int[] nums) {\\n        int len=nums.length;\\n        int ans=0;\\n        \\n        for(int idx=0;idx<32;idx++){\\n            int countOne=0;\\n            int countZero=0;\\n            int mask=(1<<idx);\\n            \\n            for(int value=0;value<len;value++){\\n                \\n                if(( (nums[value] & mask) == 0 )){\\n                    countZero++;\\n                }else{\\n                    countOne++;\\n                }\\n                \\n            }\\n            ans= ans+ countOne*countZero;\\n        }\\n        return ans;\\n    }\\n}\\n\\n// TC: O(32) * O(N)\\n/*\\nwe have to find all the bits combi with all\\nso we are finding the no of once present and no of zero present \\nlater we are taking the mul, of them so we get all the combinations\\nand then we add up everything \\n*/\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2485497,
                "title": "c-bit-manipulation-count-vector-faster-than-91",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        vector<int> count(32,0);\\n        int n = nums.size();\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int bit = 31; bit >= 0; bit--)\\n            {\\n                if((nums[i] & (1 << bit)))\\n                {\\n                    count[bit]++;\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        int flag = 0;\\n        for(int bit = 31; bit >= 0; bit--)\\n        {\\n            if(count[bit] == 0 && flag == 0)\\n                continue;\\n            else\\n            {\\n                if(count[bit] != 0 && count[bit] != n)\\n                {\\n                    ans += (n - count[bit])*count[bit];\\n                    flag = 1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        vector<int> count(32,0);\\n        int n = nums.size();\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int bit = 31; bit >= 0; bit--)\\n            {\\n                if((nums[i] & (1 << bit)))\\n                {\\n                    count[bit]++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2424795,
                "title": "c-bit-manipulation",
                "content": "```\\nint totalHammingDistance(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> bit(32);\\n        int mask;\\n        for(int i = 0; i < 32; i++) {\\n            mask = 1 << i;\\n            for(int num: nums) {\\n                if(mask & num) bit[i]++;\\n            }\\n        }\\n        int dist = 0;\\n        for(int i = 0; i < 32; i++) {\\n            dist += bit[i] * (n - bit[i]);\\n        }\\n        \\n        return dist;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nint totalHammingDistance(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> bit(32);\\n        int mask;\\n        for(int i = 0; i < 32; i++) {\\n            mask = 1 << i;\\n            for(int num: nums) {\\n                if(mask & num) bit[i]++;\\n            }\\n        }\\n        int dist = 0;\\n        for(int i = 0; i < 32; i++) {\\n            dist += bit[i] * (n - bit[i]);\\n        }\\n        \\n        return dist;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2386439,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def totalHammingDistance(self, nums: List[int]) -> int:\\n        ans = 0\\n        for i in range(0,31):\\n            c=0     \\n            for j in nums:\\n                c+=(j>>i )&1\\n            ans+=c*(len(nums)-c)\\n        return(ans)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def totalHammingDistance(self, nums: List[int]) -> int:\\n        ans = 0\\n        for i in range(0,31):\\n            c=0     \\n            for j in nums:\\n                c+=(j>>i )&1\\n            ans+=c*(len(nums)-c)\\n        return(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2349832,
                "title": "sharing-my-intitial-intutions-what-i-saw-in-this-question",
                "content": "# Intutions\\nBasic intution says, **what if I get the count of opposite bits on the curr index** then I will add all for 32 bits and get the result\\n\\nthat\\'s what I just coded here;\\n\\nif 1 then look into how many zeros are present on that index\\nif 0 then look into how many one are present on that index\\n\\nAlso it will be helpful if I remove curr_bit as it is not going to play a role to ans;\\n```\\n\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        int n=nums.size();\\n        int zeroCnt[32];\\n        int oneCnt[32];\\n        memset(zeroCnt, 0, sizeof(zeroCnt));\\n        memset(oneCnt, 0, sizeof(oneCnt));\\n\\n        //counting the total zero and one in bit of number; eg,. 5-> 101 , one:2, zero:1\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<32;j++){\\n                if((nums[i] & (1<<j)) ==0 ){\\n                    zeroCnt[j]++;\\n                } else oneCnt[j]++;\\n            }\\n        }\\n        \\n        //if 0 then look into how many 1 we currently have also remove the curr bit ie 0 from the zeroCnt;\\n \\xA0 \\xA0 \\xA0 \\xA0//if 1 then look into how many 0 we currently have also remove the curr bit ie 1 from the onCnt;\\n        \\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<32;j++){\\n                if((nums[i] & (1<<j))==0) { //look in oneCnt;\\n                    ans+= oneCnt[j];\\n                    zeroCnt[j]--;\\n                } else{ //look in zeroCnt;\\n                    ans+= zeroCnt[j];\\n                    oneCnt[j]--;\\n                }\\n            }\\n        }\\n        \\n        //TC-> O(32*N)=O(N),  32 bits and n diff number\\n        //SC-> O(32+32)=O(1), using only 32+32 extra space;\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        int n=nums.size();\\n        int zeroCnt[32];\\n        int oneCnt[32];\\n        memset(zeroCnt, 0, sizeof(zeroCnt));\\n        memset(oneCnt, 0, sizeof(oneCnt));\\n\\n        //counting the total zero and one in bit of number; eg,. 5-> 101 , one:2, zero:1\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<32;j++){\\n                if((nums[i] & (1<<j)) ==0 ){\\n                    zeroCnt[j]++;\\n                } else oneCnt[j]++;\\n            }\\n        }\\n        \\n        //if 0 then look into how many 1 we currently have also remove the curr bit ie 0 from the zeroCnt;\\n \\xA0 \\xA0 \\xA0 \\xA0//if 1 then look into how many 0 we currently have also remove the curr bit ie 1 from the onCnt;\\n        \\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<32;j++){\\n                if((nums[i] & (1<<j))==0) { //look in oneCnt;\\n                    ans+= oneCnt[j];\\n                    zeroCnt[j]--;\\n                } else{ //look in zeroCnt;\\n                    ans+= zeroCnt[j];\\n                    oneCnt[j]--;\\n                }\\n            }\\n        }\\n        \\n        //TC-> O(32*N)=O(N),  32 bits and n diff number\\n        //SC-> O(32+32)=O(1), using only 32+32 extra space;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2258268,
                "title": "easy-solution-using-js",
                "content": "we need to count the 0s and 1s at the ith bit and multiply both to count all the combinations.\\n\\n\\tTC    O(32 * N)\\n\\tSC    O(1)\\n\\n\\n\\n```\\nvar totalHammingDistance = function(nums) {\\n    let n = nums.length, ans = 0;\\n    for(let bit = 0; bit < 32; bit++) {\\n        let zeros = 0, ones = 0;\\n        for(let i = 0; i < n; i++) {\\n            ((nums[i] >> bit) & 1) ? ones++ : zeros++;\\n        }\\n        ans += zeros * ones;\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\nvar totalHammingDistance = function(nums) {\\n    let n = nums.length, ans = 0;\\n    for(let bit = 0; bit < 32; bit++) {\\n        let zeros = 0, ones = 0;\\n        for(let i = 0; i < n; i++) {\\n            ((nums[i] >> bit) & 1) ? ones++ : zeros++;\\n        }\\n        ans += zeros * ones;\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2242124,
                "title": "faster-than-100-set-bits-count-approach-cpp-solution",
                "content": "Idea - total hamming distance = sum of the products of number of set and unset bits at each index.\\n\\n```\\nint totalHammingDistance(vector<int> &nums) {\\n        int totalHamming = 0, l = nums.size();\\n        for (int i = 0; i < 32; i++) {\\n            int setCount = 0, unSetCount = 0;\\n            for (auto num : nums)\\n                if (num & (1 << i)) setCount++;\\n            unSetCount = l - setCount;\\n            totalHamming += (setCount * unSetCount);\\n        }\\n        return totalHamming;\\n\\t\\t}",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "Idea - total hamming distance = sum of the products of number of set and unset bits at each index.\\n\\n```\\nint totalHammingDistance(vector<int> &nums) {\\n        int totalHamming = 0, l = nums.size();\\n        for (int i = 0; i < 32; i++) {\\n            int setCount = 0, unSetCount = 0;\\n            for (auto num : nums)\\n                if (num & (1 << i)) setCount++;\\n            unSetCount = l - setCount;\\n            totalHamming += (setCount * unSetCount);\\n        }\\n        return totalHamming;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2105350,
                "title": "please-help",
                "content": "the answer will be right ONLY IF i change the \"for (int n: nums) {\" to \"for(int j = 0; j < nums.length; j++) {\"\\nwhy can\\'t i use the \"for (int n: nums)\"? isn\\'t this suppose to be the same?\\n\\n\\n```\\nclass Solution {\\n    public int totalHammingDistance(int[] nums) {\\n        \\n        int res = 0;\\n        \\n        for (int i = 0; i < 32; i++) {\\n            int onecount = 0;\\n            int zerocount = 0;\\n            \\n            for (int n: nums) {\\n                // starting from last digit\\n                // check 1\\'s amount and 0\\'s amount\\n\\n                if ((n & 1) == 1) {\\n\\n                    onecount++;\\n              \\n                }\\n                else {\\n                    zerocount++;\\n                 \\n                }\\n                \\n                n >>= 1;\\n            }\\n\\n            res += zerocount * onecount;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int totalHammingDistance(int[] nums) {\\n        \\n        int res = 0;\\n        \\n        for (int i = 0; i < 32; i++) {\\n            int onecount = 0;\\n            int zerocount = 0;\\n            \\n            for (int n: nums) {\\n                // starting from last digit\\n                // check 1\\'s amount and 0\\'s amount\\n\\n                if ((n & 1) == 1) {\\n\\n                    onecount++;\\n              \\n                }\\n                else {\\n                    zerocount++;\\n                 \\n                }\\n                \\n                n >>= 1;\\n            }\\n\\n            res += zerocount * onecount;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2077041,
                "title": "java-o-n-solution-easy",
                "content": "```\\nclass Solution {\\n    public int totalHammingDistance(int[] nums) {\\n        int ans=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            int c1=0,c0=0;\\n            for(int j=0;j<nums.length;j++)\\n            {\\n                if((nums[j]&(1<<i))!=0) c1++;\\n                else c0++;\\n            }\\n            ans+=c0*c1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int totalHammingDistance(int[] nums) {\\n        int ans=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            int c1=0,c0=0;\\n            for(int j=0;j<nums.length;j++)\\n            {\\n                if((nums[j]&(1<<i))!=0) c1++;\\n                else c0++;\\n            }\\n            ans+=c0*c1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2074569,
                "title": "java-simple-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int totalHammingDistance(int[] nums) {\\n        int ans = 0;\\n        for(int i=0; i<nums.length-1; i++){\\n            for(int j=i+1; j<nums.length; j++){\\n                ans+=Integer.bitCount(nums[i] ^ nums[j]);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int totalHammingDistance(int[] nums) {\\n        int ans = 0;\\n        for(int i=0; i<nums.length-1; i++){\\n            for(int j=i+1; j<nums.length; j++){\\n                ans+=Integer.bitCount(nums[i] ^ nums[j]);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2059074,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution(object):\\n    def totalHammingDistance(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        n = len(nums)\\n        result = 0\\n        #Count the number of 1\\'s present in each bit for every number\\n        for i in range(32):\\n            count = 0\\n            for j in range(n): # Bitwise and op with i\\'th bit left shift \\n                                 # => number of 1\\'s\\n                if nums[j] & (1 << i):\\n                    count += 1\\n                    #no. of 1\\'s * no. of 0\\'s => possible hamming pairs\\n            result += (count * (n - count))\\n            \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def totalHammingDistance(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        n = len(nums)\\n        result = 0\\n        #Count the number of 1\\'s present in each bit for every number\\n        for i in range(32):\\n            count = 0\\n            for j in range(n): # Bitwise and op with i\\'th bit left shift \\n                                 # => number of 1\\'s\\n                if nums[j] & (1 << i):\\n                    count += 1\\n                    #no. of 1\\'s * no. of 0\\'s => possible hamming pairs\\n            result += (count * (n - count))\\n            \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2028284,
                "title": "c-solution-56ms-faster-than-76",
                "content": "Runtime: 56 ms, faster than 76.13% of C++ online submissions for Total Hamming Distance.\\nMemory Usage: 19 MB, less than 55.48% of C++ online submissions for Total Hamming Distance.\\n\\n```\\nclass Solution \\n{\\npublic:\\n    int totalHammingDistance(vector<int>& nums) \\n    {\\n        int res = 0;\\n        for (int ib = 0; ib <= 31; ib++)\\n        {\\n            int count = 0;\\n            for (const int& n : nums)\\n            {\\n                if (n & (1 << ib))\\n                {\\n                    count++;\\n                }\\n            }\\n            res += (count * (nums.size() - count));\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int totalHammingDistance(vector<int>& nums) \\n    {\\n        int res = 0;\\n        for (int ib = 0; ib <= 31; ib++)\\n        {\\n            int count = 0;\\n            for (const int& n : nums)\\n            {\\n                if (n & (1 << ib))\\n                {\\n                    count++;\\n                }\\n            }\\n            res += (count * (nums.size() - count));\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1951091,
                "title": "36-ms-faster-than-100-00-of-c-online-submissions",
                "content": "```\\nint totalHammingDistance(int* nums, int numsSize){\\n\\n    int total_dist = 0;\\n    int bits = 0;\\n    for (int i = 0; i < 32; i++) {\\n        for (int j = 0; j < numsSize; j++) {\\n            bits += (nums[j] >> i) &1;\\n        }\\n        total_dist += bits*(numsSize-bits);\\n        bits = 0;\\n    }\\n    return total_dist;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nint totalHammingDistance(int* nums, int numsSize){\\n\\n    int total_dist = 0;\\n    int bits = 0;\\n    for (int i = 0; i < 32; i++) {\\n        for (int j = 0; j < numsSize; j++) {\\n            bits += (nums[j] >> i) &1;\\n        }\\n        total_dist += bits*(numsSize-bits);\\n        bits = 0;\\n    }\\n    return total_dist;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1816557,
                "title": "python3-o-n-bit-manipulation",
                "content": "```\\nclass Solution:\\n    def totalHammingDistance(self, nums: List[int]) -> int:\\n        res=0\\n        for i in range(32):\\n            one=zero=0\\n            for el in nums:\\n                val=el>>i&1\\n                if val==0: zero+=1\\n                else: one+=1\\n            res+=one*zero\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def totalHammingDistance(self, nums: List[int]) -> int:\\n        res=0\\n        for i in range(32):\\n            one=zero=0\\n            for el in nums:\\n                val=el>>i&1\\n                if val==0: zero+=1\\n                else: one+=1\\n            res+=one*zero\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1804312,
                "title": "very-easy-c-solution-using-bit-manipulation",
                "content": "count the contribution of each bit  \\n for each bit ,contribution will be (count of zero * count of one) in corresponding bit\\n```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        int ans = 0;\\n            for(int i = 0; i < 31; i++){\\n              int cz = 0, co = 0;\\n                    for(int j = 0; j < nums.size(); j++){\\n                     if((nums[j])&(1<<i))co++;\\n                        else cz++;\\n                    }\\n                    ans +=(cz*co);\\n            }\\n            return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        int ans = 0;\\n            for(int i = 0; i < 31; i++){\\n              int cz = 0, co = 0;\\n                    for(int j = 0; j < nums.size(); j++){\\n                     if((nums[j])&(1<<i))co++;\\n                        else cz++;\\n                    }\\n                    ans +=(cz*co);\\n            }\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1765408,
                "title": "c-o-32n",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        int cnt[2][32] = {0};\\n        for (int i = 0; i < nums.size(); ++i) {\\n            for (int j = 0; j < 32; ++j) {\\n                ++cnt[!!(nums[i] & (1 << j))][j];\\n            }\\n        }\\n        \\n        int res = 0;\\n        for (int i = 0; i < 32; ++i) {\\n            res += cnt[0][i] * cnt[1][i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        int cnt[2][32] = {0};\\n        for (int i = 0; i < nums.size(); ++i) {\\n            for (int j = 0; j < 32; ++j) {\\n                ++cnt[!!(nums[i] & (1 << j))][j];\\n            }\\n        }\\n        \\n        int res = 0;\\n        for (int i = 0; i < 32; ++i) {\\n            res += cnt[0][i] * cnt[1][i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1753709,
                "title": "fast-c-bitwise-solution-o-n-time-and-o-1-space",
                "content": "**The solution is as follows:**\\n\\nDirectly count the number of different bits across all bit positions.\\n\\nFirst off keep track of the number of occurences of each bit values in each bit position using a frequency array its dimensions is (32, 2) (32 for each bit position, 2 for each bit value). \\n\\nFor each bit position you can get the number of times this particular bit appears in the result is the number of occurences of bit value 0 multiplied by the number of occurences of bit value 1 and summing that up across all bit positions.\\n\\n```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        vector<vector<int>> util(32, vector<int>(2, 0));\\n        for (int i = 0; i < 32; ++i) {\\n            for (auto n : nums) {\\n                auto tmp = (n & (1 << i));\\n                util[i][tmp != 0]++;\\n            }\\n        }\\n        \\n        int nt = 0;\\n        \\n        for (auto tmp : util) {\\n            nt += tmp[0] * tmp[1];\\n        }\\n        \\n        return nt;\\n    }\\n};\\n```\\n\\n**Another approach:**\\n\\n1. Assume all the bits are different accross all the numbers and store the value in the answer variable.\\n2. Create a frequency array (same one as that in approach 1).\\n3. If a bit is repeated ```n``` times it is included in the answer ```n * (n - 1) / 2``` so we have to decrement that value from the answer variable.\\n\\nNote: Use long long instead of int to prevent any overflow errors.\\n```\\nusing ll = long long int;\\n\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        vector<vector<int>> util(32, vector<int>(2, 0));\\n        for (int i = 0; i < 32; ++i) {\\n            for (auto n : nums) {\\n                auto tmp = (n & (1 << i));\\n                util[i][tmp != 0]++;\\n            }\\n        }\\n        \\n        ll n = nums.size(), nt = 32 * n * (n - 1) / 2;\\n        \\n        for (auto tmp : util) {\\n            nt -= tmp[0] * (tmp[0] - 1) / 2;\\n            nt -= tmp[1] * (tmp[1] - 1) / 2;\\n        }\\n        \\n        return int(nt);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        vector<vector<int>> util(32, vector<int>(2, 0));\\n        for (int i = 0; i < 32; ++i) {\\n            for (auto n : nums) {\\n                auto tmp = (n & (1 << i));\\n                util[i][tmp != 0]++;\\n            }\\n        }\\n        \\n        int nt = 0;\\n        \\n        for (auto tmp : util) {\\n            nt += tmp[0] * tmp[1];\\n        }\\n        \\n        return nt;\\n    }\\n};\\n```\n```n```\n```n * (n - 1) / 2```\n```\\nusing ll = long long int;\\n\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        vector<vector<int>> util(32, vector<int>(2, 0));\\n        for (int i = 0; i < 32; ++i) {\\n            for (auto n : nums) {\\n                auto tmp = (n & (1 << i));\\n                util[i][tmp != 0]++;\\n            }\\n        }\\n        \\n        ll n = nums.size(), nt = 32 * n * (n - 1) / 2;\\n        \\n        for (auto tmp : util) {\\n            nt -= tmp[0] * (tmp[0] - 1) / 2;\\n            nt -= tmp[1] * (tmp[1] - 1) / 2;\\n        }\\n        \\n        return int(nt);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1723633,
                "title": "n-31-time-complexity-solution-basic",
                "content": "Just Iterating over every bit and checking whether that bit is set or not\\n```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        int c=0;\\n        for(int j=31;j>=0;j--){\\n            int o=0,z=0;\\n            for(int i=0;i<nums.size();i++){\\n                if(nums[i] & (1<<j)){\\n                    o++;\\n                }else{\\n                    z++;\\n                }\\n            }\\n            if(o!=0 && z!=0){\\n                c+=(o*z);\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        int c=0;\\n        for(int j=31;j>=0;j--){\\n            int o=0,z=0;\\n            for(int i=0;i<nums.size();i++){\\n                if(nums[i] & (1<<j)){\\n                    o++;\\n                }else{\\n                    z++;\\n                }\\n            }\\n            if(o!=0 && z!=0){\\n                c+=(o*z);\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1586818,
                "title": "easy-solution-using-bitwise-tc-o-n-as-o-1-c",
                "content": "* Easy to understand, must upvote! \\uD83D\\uDE43\\n\\n```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        int totalDis = 0, count0 = 0, count1 = 0;\\n        for(int i = 0; i < 32; i++){\\n            for(int j = 0; j < nums.size(); j++){\\n                nums[j]&1? count1++: count0++;\\n                nums[j] >>= 1;\\n            }\\n            totalDis += count0 * count1;\\n            count0 = count1 = 0;\\n        }\\n        return totalDis;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        int totalDis = 0, count0 = 0, count1 = 0;\\n        for(int i = 0; i < 32; i++){\\n            for(int j = 0; j < nums.size(); j++){\\n                nums[j]&1? count1++: count0++;\\n                nums[j] >>= 1;\\n            }\\n            totalDis += count0 * count1;\\n            count0 = count1 = 0;\\n        }\\n        return totalDis;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1536408,
                "title": "easy-c-solution",
                "content": "```\\nint totalHammingDistance(vector<int>& nums) {\\n        vector<int>ar(32);  // array to store count of set bit for the numbers in nums at respective position\\n        for(auto x: nums){\\n\\t\\t\\tint i=0;// starting with LSB\\n            while(x>0){\\n                ar[i++]+=x&1;   // increase the count of bit at ith position.\\n                x>>=1; \\n            }\\n        }\\n        int ans=0;\\n        for(auto x: ar)\\n            ans+=((nums.size()-x)*x); // product of set bit and unset bit\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nint totalHammingDistance(vector<int>& nums) {\\n        vector<int>ar(32);  // array to store count of set bit for the numbers in nums at respective position\\n        for(auto x: nums){\\n\\t\\t\\tint i=0;// starting with LSB\\n            while(x>0){\\n                ar[i++]+=x&1;   // increase the count of bit at ith position.\\n                x>>=1; \\n            }\\n        }\\n        int ans=0;\\n        for(auto x: ar)\\n            ans+=((nums.size()-x)*x); // product of set bit and unset bit\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1430397,
                "title": "c-easily-explained",
                "content": "Instead of looking number by number, we will look bit by bit because Hamming distance only depends on position of bits.\\n5--->  0101\\n14--> 1110\\n2--->  0010\\nIntially, answer is zero\\nans=0\\nLook at i\\'th bit in all number, \\nLets denote,\\nCount[i][1]=Count of number of ones in i\\'th bit from all numbers\\nCount[i][0]=Count of number of zeroes in i\\'th bit from all numbers\\nans=ans+(Count[i][1]*Count[i][0]) for all i from 0 to 31\\n\\nIn the above example:\\n ans=Count[0][1]*Count[0][0]+Count[1][1]*Count[1][0]+Count[2][1]*Count[2][0]+Count[3][1]*Count[3][0]+.......Count[31][1]*Count[31][0]\\n ans=(1x2)+(2x1)+(2x1)+(1x2)+(0x3)+(0x3)+.........+(0x3)=8\\n\\n```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        int Count[32][2];\\n        memset(Count,0,sizeof Count);\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=0;j<32;j++)\\n            {\\n                if(nums[i]&(1<<j))\\n                    Count[j][1]++;\\n                else\\n                    Count[j][0]++;\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            ans+=(Count[i][1]*Count[i][0]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        int Count[32][2];\\n        memset(Count,0,sizeof Count);\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=0;j<32;j++)\\n            {\\n                if(nums[i]&(1<<j))\\n                    Count[j][1]++;\\n                else\\n                    Count[j][0]++;\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            ans+=(Count[i][1]*Count[i][0]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1363968,
                "title": "c-solution-with-explanation",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n\\t/* we can store the value of all bit in O(n*32) ->you can use( O(n*log(max(nums)))\\n\\tthen we can iterate over all 32 bit  and find the numbers of zero and one.\\n\\thamming distance will be found when there are alteast 1 one and atleast \\n\\t1 zero */\\n\\t\\n        int n=nums.size();\\n        vector<vector<int>>dp(n,vector<int>(32,0));\\n        for(int i=0;i<n;i++){\\n            int flag=31;\\n            int cp=nums[i];\\n            while(cp>0){\\n                dp[i][flag]=(cp%2);\\n                flag--;\\n                cp>>=1;\\n            }\\n        }\\n        int ans=0;\\n        for(int j=0;j<32;j++){\\n            int o=0,z=0;\\n            for(int i=0;i<n;i++){\\n                dp[i][j]==1?o++:z++;\\n            }\\n            ans+=(o*z);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1341047,
                "title": "python-o-n-bit-manipulation-explanation",
                "content": "Hamming distance between two non-negative integers is defined as the number of positions at which the corresponding bits are different.\\n\\nFor example,\\n\\nHammingDistance(2, 7) = 2, as only the first and the third bit differs in the binary representation of 2 (010) and 7 (111).\\n\\n\\nExample\\n\\nLet f(x, y) be the hamming distance defined above.\\n\\nA=[2, 4, 6]\\n\\nWe return,\\n f(2, 4) + f(2, 6) +  f(4, 6)  = 2+1+1=4\\n\\n## Hint 1\\nSuppose the given array contains only binary numbers, i.e A[i] belongs to [0, 1].\\n\\nYou only need to find the number of pairs having different bits.\\n\\nTry to combine this approach if we have array of integers instead of binary numbers containing multiple bits.\\n\\n## Solution Approach\\nSuppose the given array contains only binary numbers, i.e A[i] belongs to [0, 1].\\n\\nLet X be the number of elements equal to 0, and Y be the number of elements equals to 1.\\n\\nThen, sum of hamming distance of all pair of elements equals 2XY, as every pair containing one element from X and one element from Y contribute 1 to the sum.\\n\\nAs A[i] belongs to [0, 2^30 - 1] and we are counting number of different bits in each pair, we can consider all the 30 bit positions independent.\\n\\nFor example: A = [2, 4, 6] = [010, 100, 110]\\n\\nAt bit position 0 (LSB): x = 3, y = 0\\nAt bit position 1: x = 1, y = 2\\nAt bit position 2(MSB): x = 1, y = 2\\nTotal sum = number of pairs having different bit at each bit-position = (3 * 0) + (1 * 2) + (1 * 2) = 4\\n\\n\\n```\\nclass Solution:\\n    def totalHammingDistance(self, nums: List[int]) -> int:\\n        \\n        distance = 0                  #hamming distance\\n        for i in range(30):\\n            \\n            mask = 1 << i             #mask will be power ith power of 2\\n            one , zero = 0 , 0\\n            for num in nums:\\n                \\n                if (num & mask):      #a bit manupulation technique to check whether the ith bit is set \\n                    one +=1\\n                else:\\n                    zero +=1\\n            distance += (one * zero)      \\n            \\n            \\n        return distance\\n                \\n                \\n```\\n\\nCheckout https://www.hackerearth.com/practice/notes/bit-manipulation/ for more understand more bit manupulation techniques in detail\\n\\nTime complexity: O(N)\\nWe are using a loop of 32 because the maximum value in the array is 10 ^ 9 which is approcimately 2 ^ 30 but the complexity remains O(n) as O(32n) = O(n)\\n\\nSpace complexity: O(1)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def totalHammingDistance(self, nums: List[int]) -> int:\\n        \\n        distance = 0                  #hamming distance\\n        for i in range(30):\\n            \\n            mask = 1 << i             #mask will be power ith power of 2\\n            one , zero = 0 , 0\\n            for num in nums:\\n                \\n                if (num & mask):      #a bit manupulation technique to check whether the ith bit is set \\n                    one +=1\\n                else:\\n                    zero +=1\\n            distance += (one * zero)      \\n            \\n            \\n        return distance\\n                \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1336959,
                "title": "java-bit-manipulation-100-faster-solution",
                "content": "\\n\\n**Brute Force Approach - > Time Limit Exceed**\\nCalculate the difference in bits of every pair by XOR and then calculating the number of set bits by Kernighan\\'s Formula and adding up the hamming distance to the total hamming distance.\\n\\n```\\nclass Solution {\\n    public static int distance(int a,int b)\\n    {\\n        int n=a^b;\\n        int count=0;\\n        while(n>0)\\n        {\\n            int rmsb=n&-n;\\n            count++;\\n            n=n-rmsb;\\n        }\\n        return count;\\n    }\\n    public int totalHammingDistance(int[] nums) {\\n        int total=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=i+1;j<nums.length;j++)\\n                total+=distance(nums[i],nums[j]);\\n        }\\n        return total;\\n    }\\n}\\n```\\n\\n**Better Approach ->**\\n\\nMotive behind the solution is to check number of different bits at each digit of the numbers and Multiply the number of ones and zeros at that very point to calculate the contribution of that very position to the overall answer and then adding up the all possible outcomes at every position.\\n\\n```\\nclass Solution {\\n    public int totalHammingDistance(int[] nums) {\\n        int ans=0;\\n        int n=nums.length;\\n        for(int i=0;i<32;i++)\\n        {\\n            int ones=0;\\n            for(int k : nums)\\n                ones+=((k>>i)&1);\\n            ans=ans+(ones*(n-ones));\\n        }\\n        return ans;\\n        }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public static int distance(int a,int b)\\n    {\\n        int n=a^b;\\n        int count=0;\\n        while(n>0)\\n        {\\n            int rmsb=n&-n;\\n            count++;\\n            n=n-rmsb;\\n        }\\n        return count;\\n    }\\n    public int totalHammingDistance(int[] nums) {\\n        int total=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=i+1;j<nums.length;j++)\\n                total+=distance(nums[i],nums[j]);\\n        }\\n        return total;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int totalHammingDistance(int[] nums) {\\n        int ans=0;\\n        int n=nums.length;\\n        for(int i=0;i<32;i++)\\n        {\\n            int ones=0;\\n            for(int k : nums)\\n                ones+=((k>>i)&1);\\n            ans=ans+(ones*(n-ones));\\n        }\\n        return ans;\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1271069,
                "title": "3-different-approach-last-is-100-faster-4ms",
                "content": "**Brute-force:**\\n# \\n```\\nclass Solution {\\n    public int totalHammingDistance(int[] nums) {\\n         int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i+1;j<nums.length;j++){\\n                int tmp=nums[i]^nums[j];\\n                while(tmp>0){\\n                    count++;\\n                    tmp=tmp&(tmp-1);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\nTime : O(n^2)\\nSpace : O(1)\\n**Imlemented-solution:**\\n# \\n```\\nclass Solution {\\n    public int totalHammingDistance(int[] nums) {\\n        int count=0;\\n         int bits[][]=new int[32][2];\\n        for(int num : nums){\\n            int tmp=num;\\n            for(int i=0;i<32;i++){\\n                int x=(num&1);\\n                num=num>>1;\\n                int w=x==0 ? 1 : 0;\\n                count+=bits[i][w];      \\n            }\\n            for(int i=0;i<32;i++){\\n                  int x=(tmp&1);\\n                ++bits[i][x];\\n                tmp=tmp>>1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\nTime : O(n)\\nSpace : O(n)\\n**best-solution:**\\nrun-time : 4ms 100% Faster solution\\n# \\n```\\nclass Solution {\\n    public int totalHammingDistance(int[] nums) {\\n        int count=0;\\n        for(int i=0;i<32;i++){\\n            int onebits=0;\\n            for(int num : nums)\\n                onebits+=((num>>i)&1);\\n            count+=(onebits*(nums.length-onebits));\\n        }\\n        return count;\\n    }\\n}\\n```\\n**Time:** O(n)\\n**Space:** O(1)\\n**Please,Upvote if this is helpful**",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int totalHammingDistance(int[] nums) {\\n         int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i+1;j<nums.length;j++){\\n                int tmp=nums[i]^nums[j];\\n                while(tmp>0){\\n                    count++;\\n                    tmp=tmp&(tmp-1);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int totalHammingDistance(int[] nums) {\\n        int count=0;\\n         int bits[][]=new int[32][2];\\n        for(int num : nums){\\n            int tmp=num;\\n            for(int i=0;i<32;i++){\\n                int x=(num&1);\\n                num=num>>1;\\n                int w=x==0 ? 1 : 0;\\n                count+=bits[i][w];      \\n            }\\n            for(int i=0;i<32;i++){\\n                  int x=(tmp&1);\\n                ++bits[i][x];\\n                tmp=tmp>>1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int totalHammingDistance(int[] nums) {\\n        int count=0;\\n        for(int i=0;i<32;i++){\\n            int onebits=0;\\n            for(int num : nums)\\n                onebits+=((num>>i)&1);\\n            count+=(onebits*(nums.length-onebits));\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1261150,
                "title": "c-simple-easy-to-understand-bit-manipulation-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        int n=nums.size(),sum=0;\\n\\t\\tfor(int i=0;i<32;i++){\\n            int num = 1<<i;\\n            int ones=0,zero=0;\\n            for(int j=0;j<n;j++){\\n                if(nums[j]&num){\\n                    ones++;\\n                }else{\\n                    zero++;\\n                }\\n            }\\n            sum += (ones*zero);\\n        }    \\n        return sum;\\n\\t\\t}\\n\\t};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        int n=nums.size(),sum=0;\\n\\t\\tfor(int i=0;i<32;i++){\\n            int num = 1<<i;\\n            int ones=0,zero=0;\\n            for(int j=0;j<n;j++){\\n                if(nums[j]&num){\\n                    ones++;\\n                }else{\\n                    zero++;\\n                }\\n            }\\n            sum += (ones*zero);\\n        }    \\n        return sum;\\n\\t\\t}\\n\\t};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1247715,
                "title": "java-easy-faster-than-100-o-n-solution",
                "content": "\\tclass Solution {\\n\\t\\tpublic int totalHammingDistance(int[] nums) {\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tfor(int shift=0;shift<32;shift++){\\n\\t\\t\\t\\tint setBits=0;\\n\\t\\t\\t\\tfor(int i:nums)     setBits+=((i>>shift)&1);\\n\\t\\t\\t\\tans+=setBits*(nums.length-setBits);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int totalHammingDistance(int[] nums) {\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tfor(int shift=0;shift<32;shift++){\\n\\t\\t\\t\\tint setBits=0;\\n\\t\\t\\t\\tfor(int i:nums)     setBits+=((i>>shift)&1);\\n\\t\\t\\t\\tans+=setBits*(nums.length-setBits);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1244181,
                "title": "one-line-solution",
                "content": "```\\nclass Solution:\\n    def totalHammingDistance(self, nums: List[int]) -> int:\\n        return sum(sum(num >> shift & 1 for num in nums) * sum((num >> shift & 1 ^ 1 for num in nums)) for shift in range(30))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def totalHammingDistance(self, nums: List[int]) -> int:\\n        return sum(sum(num >> shift & 1 for num in nums) * sum((num >> shift & 1 ^ 1 for num in nums)) for shift in range(30))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1237258,
                "title": "easy-c-soln-97-fastest-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    //just at every bit count total combination possible\\n    int totalHammingDistance(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=30;i>=0;i--){\\n            int no_of_1=0;\\n            for(auto &n:nums){no_of_1+=(n&(1<<i))?1:0;}\\n            ans+=no_of_1*((int)nums.size()-no_of_1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //just at every bit count total combination possible\\n    int totalHammingDistance(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=30;i>=0;i--){\\n            int no_of_1=0;\\n            for(auto &n:nums){no_of_1+=(n&(1<<i))?1:0;}\\n            ans+=no_of_1*((int)nums.size()-no_of_1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1124382,
                "title": "python-o-n-solution-with-explanation",
                "content": "For each bit position in the 32 bits, we count the number of integers in the array which have that bit set (equal to 1). Then, if x integers have that bit set and y integers do not, then that bit contributes (x * y) hamming distance to the total.\\n\\nFor example:\\narr = [0, 0, 0, 1, 1]\\nTotal number of 1\\'s = 2\\nTotal number of 0\\'s = 3\\nTherefore, the total hamming distance will be (2 * 3) = 6\\n```\\n    def totalHammingDistance(self, nums: List[int]) -> int:\\n        total = 0\\n        for i in range(32):\\n            ones = 0\\n            zeros = 0\\n            for num in nums:\\n                if num & (1 << i):\\n                    ones += 1\\n                else:\\n                    zeros += 1\\n                    \\n            total += (ones * zeros)\\n            \\n        return total\\n```",
                "solutionTags": [],
                "code": "```\\n    def totalHammingDistance(self, nums: List[int]) -> int:\\n        total = 0\\n        for i in range(32):\\n            ones = 0\\n            zeros = 0\\n            for num in nums:\\n                if num & (1 << i):\\n                    ones += 1\\n                else:\\n                    zeros += 1\\n                    \\n            total += (ones * zeros)\\n            \\n        return total\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1100993,
                "title": "python-nice-1-liner",
                "content": "```\\ndef totalHammingDistance(self, nums: List[int]) -> int:\\n        return sum(sum(n&(2**i)<1 for n in nums)*sum(n&(2**i)>0 for n in nums) for i in range(30))\\n```",
                "solutionTags": [],
                "code": "```\\ndef totalHammingDistance(self, nums: List[int]) -> int:\\n        return sum(sum(n&(2**i)<1 for n in nums)*sum(n&(2**i)>0 for n in nums) for i in range(30))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1100781,
                "title": "c-bit-magic-48ms",
                "content": "```\\nint totalHammingDistance(vector<int>& nums) {\\n        \\n        int ans=0;\\n        for(int i=0;i<32;i++)            //iterating each bit of every number\\n        {\\n            int cnt=0;\\n            for(int j=0;j<nums.size();j++)\\n            {\\n                if(nums[j]&(1<<i))         //counting total number of set bits\\n                    ++cnt;\\n            }\\n            ans+=cnt*(nums.size()-cnt);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint totalHammingDistance(vector<int>& nums) {\\n        \\n        int ans=0;\\n        for(int i=0;i<32;i++)            //iterating each bit of every number\\n        {\\n            int cnt=0;\\n            for(int j=0;j<nums.size();j++)\\n            {\\n                if(nums[j]&(1<<i))         //counting total number of set bits\\n                    ++cnt;\\n            }\\n            ans+=cnt*(nums.size()-cnt);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1092016,
                "title": "c-bit-manipulation-logic",
                "content": "Idea is to find the MSB from the largest number and then count the number of ones and zeroes and their multiplication gives us the number of pairs where it is different at a given bit position. Repeat this for every bit from MSB.\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n    \\n        int msb = 0, mx = 0, n = nums.size(), ans = 0;\\n        for(auto num : nums)\\n            mx = max(mx,num);\\n        \\n        for(int i=0;i<32;i++)\\n        {\\n            if(mx & 1)\\n                msb = i;\\n            mx>>=1;\\n        }\\n        \\n        for(int i=msb;i>=0;i--)\\n        {\\n            int ones = 0, zero = 0;\\n            for(auto num : nums)\\n                ones+=((num>>i) & 1);\\n            zero = n-ones;\\n            ans+=(ones * zero);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n    \\n        int msb = 0, mx = 0, n = nums.size(), ans = 0;\\n        for(auto num : nums)\\n            mx = max(mx,num);\\n        \\n        for(int i=0;i<32;i++)\\n        {\\n            if(mx & 1)\\n                msb = i;\\n            mx>>=1;\\n        }\\n        \\n        for(int i=msb;i>=0;i--)\\n        {\\n            int ones = 0, zero = 0;\\n            for(auto num : nums)\\n                ones+=((num>>i) & 1);\\n            zero = n-ones;\\n            ans+=(ones * zero);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1043232,
                "title": "easy-to-understand-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    /*          0 1 2 3\\n        4 =     0 1 0 0\\n        14 =    1 1 1 0\\n        2 =     0 0 1 0\\n        \\n        \\n        At pos = 0, we have 3 zeros and 0 ones = 3*0 = 0\\n        At pos = 1, we have 2 one\\'s and 1 zero = 2 *1 = 2\\n        At pos = 2, we have 2 one\\'s and 1 zero = 2*1 = 2\\n        At pos=3, we have 2 zero\\'s and 1 one = 2*1 = 2\\n        \\n    \\n    */\\n    int totalHammingDistance(vector<int>& nums)\\n    {\\n        int res = 0;\\n        \\n        for(int i=0;i<32;i++)\\n        {\\n            int setbit = 0; //represents number of ones\\n            for(int x:nums)\\n            {\\n                if(x & 1<<i)\\n                    setbit++;\\n            }\\n            res += setbit * (nums.size()-setbit); //(size-setbit) represent number of zeros  \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    /*          0 1 2 3\\n        4 =     0 1 0 0\\n        14 =    1 1 1 0\\n        2 =     0 0 1 0\\n        \\n        \\n        At pos = 0, we have 3 zeros and 0 ones = 3*0 = 0\\n        At pos = 1, we have 2 one\\'s and 1 zero = 2 *1 = 2\\n        At pos = 2, we have 2 one\\'s and 1 zero = 2*1 = 2\\n        At pos=3, we have 2 zero\\'s and 1 one = 2*1 = 2\\n        \\n    \\n    */\\n    int totalHammingDistance(vector<int>& nums)\\n    {\\n        int res = 0;\\n        \\n        for(int i=0;i<32;i++)\\n        {\\n            int setbit = 0; //represents number of ones\\n            for(int x:nums)\\n            {\\n                if(x & 1<<i)\\n                    setbit++;\\n            }\\n            res += setbit * (nums.size()-setbit); //(size-setbit) represent number of zeros  \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 893974,
                "title": "java-2-solutions-look-up-table-and-bitwise-o-n",
                "content": "```\\nhttps://leetcode.com/problems/total-hamming-distance/\\n```\\n//Brute Force (Look up table)\\nclass Solution {\\n    public int totalHammingDistance(int[] nums) {\\n        int bit_array[]=new int[256];\\n        for(int index=1;index<256;index++)\\n        {\\n            bit_array[index]=bit_array[index>>1] + (index & 1);\\n        }\\n        int len=nums.length;\\n        int answer=0;\\n        for(int index_outer=0;index_outer<len;index_outer++)\\n        {\\n            for(int index_inner=index_outer+1;index_inner<len;index_inner++)\\n            {\\n                int xor_value=nums[index_outer]^nums[index_inner];\\n                answer=answer+bit_array[xor_value & 0xFF];\\n                // xor_value=xor_value>>8;\\n                answer=answer+bit_array[xor_value>>8 & 0xFF];\\n                // xor_value=xor_value>>8;\\n                answer=answer+bit_array[xor_value>>16 & 0xFF];\\n                // xor_value=xor_value>>8;\\n                answer=answer+bit_array[xor_value>>24 & 0xFF];\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```\\n\\n```\\nExplanation :\\nInstead of checking every pair we will consider all number bitwise\\nMaximum bits in every integer is 32 so\\nwe will check set bit in every position in every integer\\nbasically we are calculating haming distance bitwise for all numbers not numberwise\\nsuppose 20 numbers are there, so we will consider all 32 bits in 20 numbers individually\\ncount set bits (1) for all number in LSB first \\nthen haming distance for that particular bit for all numbers will (set bit)*(unset bit)\\ni.e. (set bit)(n-set bit)\\nwe will add above to answer\\nrepeat this process for all 32 bits\\n```\\n```\\n//optimal\\nclass Solution {\\n    public int totalHammingDistance(int[] nums) {\\n        int answer=0;\\n        int len=nums.length;\\n        for(int index=0;index<32;index++)\\n        {\\n            int bit_count=0;\\n            for(int num_index=0;num_index<len;num_index++)\\n            {\\n                bit_count=bit_count+((nums[num_index]>>index) & 1);\\n            }\\n            answer=answer+(bit_count*(len-bit_count));\\n        }\\n        return answer;\\n    }\\n}\\n```\\n```",
                "solutionTags": [],
                "code": "```\\nhttps://leetcode.com/problems/total-hamming-distance/\\n```\n```\\n\\n```\n```\\n```\n```\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 865629,
                "title": "o-n-simple-solution",
                "content": "```python\\nclass Solution:\\n    def totalHammingDistance(self, nums: List[int]) -> int:\\n        counts, N = [0] * 31, len(nums)\\n        for n in nums:\\n            for i in range(0, 31):\\n                counts[i] += ((n >> i) & 1) == 1\\n        diff = 0\\n        for i, c in enumerate(counts):\\n            diff += c * (N - c)\\n        return diff\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def totalHammingDistance(self, nums: List[int]) -> int:\\n        counts, N = [0] * 31, len(nums)\\n        for n in nums:\\n            for i in range(0, 31):\\n                counts[i] += ((n >> i) & 1) == 1\\n        diff = 0\\n        for i, c in enumerate(counts):\\n            diff += c * (N - c)\\n        return diff\\n```",
                "codeTag": "Java"
            },
            {
                "id": 767197,
                "title": "need-help-timelimit-exceeded",
                "content": "```\\nclass Solution {\\n    public int hamm(int x,int y)\\n    { int count=0;\\n        int z=x^y;\\n        while(z>0)\\n        {\\n            count+=(z&1);\\n            z>>=1;\\n        }\\n        return count;\\n    }\\n    public int totalHammingDistance(int[] nums) {\\n        int i,j,x=0;\\n        if(nums.length<1)\\n            return 0;\\n        for(i=0;i<nums.length-1;i++)\\n        {\\n            for(j=i+1;j<nums.length;j++)\\n            {\\n                x=x+hamm(nums[i],nums[j]);\\n            }\\n        }\\n        return x;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int hamm(int x,int y)\\n    { int count=0;\\n        int z=x^y;\\n        while(z>0)\\n        {\\n            count+=(z&1);\\n            z>>=1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 760813,
                "title": "c-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& A) {\\n        int n=A.size();\\n        long long int ans=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            long long int count_0=0;\\n            long long int count_1=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if((A[j] & 1<<i)>0)\\n                {\\n                    count_1++;\\n                }\\n                else\\n                {\\n                    count_0++;\\n                }\\n            }\\n            ans=ans+(count_0*count_1);\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& A) {\\n        int n=A.size();\\n        long long int ans=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            long long int count_0=0;\\n            long long int count_1=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if((A[j] & 1<<i)>0)\\n                {\\n                    count_1++;\\n                }\\n                else\\n                {\\n                    count_0++;\\n                }\\n            }\\n            ans=ans+(count_0*count_1);\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 724198,
                "title": "short-c-solution-explained",
                "content": "```\\n/*\\n\\tThe idea is simple :- At each bit in range of 32 we find the number of elements that have a 0 there.\\n\\tLet\\'s say number of elements that have 0 at bit 4 is cnt then the number of elements that have 1 at 4th bit \\n\\twill be (n-cnt) and we have to find the number of pairs in which one element is from cnt and other is from (n-cnt)\\n\\tthe total no. of pairs = n*(n-cnt)\\n\\tDo this for all the bits and update the global sum variable(which is the answer)\\n*/\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        int n=nums.size(),ans=0;\\n        for(int i=0 ; i<32 ; i++)\\n        {\\n            int cnt0=0;\\n            for(int j=0 ; j<n ; j++)\\n            {\\n                int x=nums[j]&(1<<i);\\n                if(x==0) cnt0++;\\n            }\\n            ans+=cnt0*(n-cnt0);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n\\tThe idea is simple :- At each bit in range of 32 we find the number of elements that have a 0 there.\\n\\tLet\\'s say number of elements that have 0 at bit 4 is cnt then the number of elements that have 1 at 4th bit \\n\\twill be (n-cnt) and we have to find the number of pairs in which one element is from cnt and other is from (n-cnt)\\n\\tthe total no. of pairs = n*(n-cnt)\\n\\tDo this for all the bits and update the global sum variable(which is the answer)\\n*/\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        int n=nums.size(),ans=0;\\n        for(int i=0 ; i<32 ; i++)\\n        {\\n            int cnt0=0;\\n            for(int j=0 ; j<n ; j++)\\n            {\\n                int x=nums[j]&(1<<i);\\n                if(x==0) cnt0++;\\n            }\\n            ans+=cnt0*(n-cnt0);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 711073,
                "title": "python3-with-chinese-explaination",
                "content": "\\'\\'\\'\\n        \\u89E3\\u91CA\\uFF1A\\n        \\u6784\\u5EFA\\u4E00\\u4E2A\\u4E8C\\u7EF4\\u77E9\\u9635\\n        \\u7B2C\\u4E00\\u7EF4\\u957F\\u5EA6\\u4E3A31\\uFF0C\\u56E0\\u4E3A\\u6700\\u5927\\u6570\\u5B5710^9\\u7684\\u4E8C\\u8FDB\\u5236\\u8868\\u8FBE\\u4E3A31\\u4F4D\\n        \\u904D\\u5386\\u6BCF\\u4E00\\u4E2Anums\\u91CC\\u7684\\u6570\\u5B57\\uFF0C\\u5BF9\\u5176\\u8FDB\\u884C\\u4E0E1\\u7684\\u6309\\u4F4D\\u4E0E\\u64CD\\u4F5C\\uFF0C\\u4E0D\\u8BB0\\u5F55\\u6BCF\\u4E00\\u4E2A\\u7ED3\\u679C\\uFF0C\\n        \\u4E8C\\u7EF4\\u6570\\u7EC4\\u7684\\u4E00\\u5217\\u8868\\u793A\\u4E86\\u6BCF\\u4E00\\u4E2ANum\\u4E0E1\\u6309\\u4F4D\\u4E0E\\u64CD\\u4F5C\\u7684\\u7ED3\\u679C\\uFF0C\\u5C06\\u6240\\u67091&1\\u76F8\\u52A0\\uFF0C\\u8BB0\\u5F55\\u603B\\u548C\\n        \\u4E8C\\u7EF4\\u6570\\u7EC4\\u904D\\u5386\\uFF0C\\u751F\\u6210\\u4E00\\u7EF4\\u6570\\u7EC4\\u8BB0\\u5F55\\u6240\\u6709\\u7684\\u548C\\n        1\\u7684\\u4E2A\\u6570\\u8868\\u793A\\u4E86\\u8BE5\\u4F4D\\u7F6E\\u76F8\\u7B49\\u7684Num\\u7684\\u4E2A\\u6570\\uFF0C\\u800Clen(nums)-rec_1\\u5219\\u8868\\u793A\\u8BE5\\u4F4D\\u7F6E\\u4E3A0\\u7684\\u4E2A\\u6570\\n        \\u6BCF\\u4E2A\\u4F4D\\u7F6E\\u7684hamming_distance\\u7ED3\\u679C\\u5373\\u4E3A \\u4E00\\u4E2A\\u4F4D\\u7F6E1\\u7684\\u4E2A\\u6570 * 0\\u7684\\u4E2A\\u6570\\n        \\'\\'\\'\\n\\t\\t\\n        record_ones = [0] * 31\\n        for num in nums:\\n            for i in range(len(record_ones)):\\n                record_ones[i] += 1 if num & 1 else 0\\n                num >>= 1\\n        res = 0\\n        for rec_1 in record_ones:\\n            res += rec_1 * (len(nums) - rec_1)\\n        return res",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n        \\u89E3\\u91CA\\uFF1A\\n        \\u6784\\u5EFA\\u4E00\\u4E2A\\u4E8C\\u7EF4\\u77E9\\u9635\\n        \\u7B2C\\u4E00\\u7EF4\\u957F\\u5EA6\\u4E3A31\\uFF0C\\u56E0\\u4E3A\\u6700\\u5927\\u6570\\u5B5710^9\\u7684\\u4E8C\\u8FDB\\u5236\\u8868\\u8FBE\\u4E3A31\\u4F4D\\n        \\u904D\\u5386\\u6BCF\\u4E00\\u4E2Anums\\u91CC\\u7684\\u6570\\u5B57\\uFF0C\\u5BF9\\u5176\\u8FDB\\u884C\\u4E0E1\\u7684\\u6309\\u4F4D\\u4E0E\\u64CD\\u4F5C\\uFF0C\\u4E0D\\u8BB0\\u5F55\\u6BCF\\u4E00\\u4E2A\\u7ED3\\u679C\\uFF0C\\n        \\u4E8C\\u7EF4\\u6570\\u7EC4\\u7684\\u4E00\\u5217\\u8868\\u793A\\u4E86\\u6BCF\\u4E00\\u4E2ANum\\u4E0E1\\u6309\\u4F4D\\u4E0E\\u64CD\\u4F5C\\u7684\\u7ED3\\u679C\\uFF0C\\u5C06\\u6240\\u67091&1\\u76F8\\u52A0\\uFF0C\\u8BB0\\u5F55\\u603B\\u548C\\n        \\u4E8C\\u7EF4\\u6570\\u7EC4\\u904D\\u5386\\uFF0C\\u751F\\u6210\\u4E00\\u7EF4\\u6570\\u7EC4\\u8BB0\\u5F55\\u6240\\u6709\\u7684\\u548C\\n        1\\u7684\\u4E2A\\u6570\\u8868\\u793A\\u4E86\\u8BE5\\u4F4D\\u7F6E\\u76F8\\u7B49\\u7684Num\\u7684\\u4E2A\\u6570\\uFF0C\\u800Clen(nums)-rec_1\\u5219\\u8868\\u793A\\u8BE5\\u4F4D\\u7F6E\\u4E3A0\\u7684\\u4E2A\\u6570\\n        \\u6BCF\\u4E2A\\u4F4D\\u7F6E\\u7684hamming_distance\\u7ED3\\u679C\\u5373\\u4E3A \\u4E00\\u4E2A\\u4F4D\\u7F6E1\\u7684\\u4E2A\\u6570 * 0\\u7684\\u4E2A\\u6570\\n        \\'\\'\\'\\n\\t\\t\\n        record_ones = [0] * 31\\n        for num in nums:\\n            for i in range(len(record_ones)):\\n                record_ones[i] += 1 if num & 1 else 0\\n                num >>= 1\\n        res = 0\\n        for rec_1 in record_ones:\\n            res += rec_1 * (len(nums) - rec_1)\\n        return res",
                "codeTag": "Unknown"
            },
            {
                "id": 666871,
                "title": "java-o-n-beats-100",
                "content": "Count the number of set bits and unset bits at a particular position and add its contribution to the result.\\n\\nclass Solution {\\n\\n    public int totalHammingDistance(int[] nums) {\\n        int n = nums.length;\\n        int res = 0, oneCount = 0;\\n        for (int i = 0; i < 32; i++) {\\n            oneCount = 0;\\n            for (int j = 0; j < n; j++) {\\n                oneCount += nums[j] >> i & 1;\\n            }\\n            res += oneCount * (n - oneCount);\\n        }\\n        return res;\\n    }\\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int totalHammingDistance(int[] nums) {\\n        int n = nums.length;\\n        int res = 0, oneCount = 0;\\n        for (int i = 0; i < 32; i++) {\\n            oneCount = 0;\\n            for (int j = 0; j < n; j++) {\\n                oneCount += nums[j] >> i & 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 648179,
                "title": "bit-manipulation-simple-solution",
                "content": "```\\nclass Solution:\\n    def totalHammingDistance(self, nums: List[int]) -> int:\\n        ans=0\\n        for i in range(32):\\n            c1,c2=0,0\\n            for j in range(len(nums)):\\n                c1+=int(nums[j]%2==1)    # increment c1 if there is odd bit.\\n                c2+=int(nums[j]%2==0)    # increment c2 if there is even bit.\\n                nums[j]//=2\\n            ans+=c1*c2\\n        return ans    \\n```\\n\\t\\t",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def totalHammingDistance(self, nums: List[int]) -> int:\\n        ans=0\\n        for i in range(32):\\n            c1,c2=0,0\\n            for j in range(len(nums)):\\n                c1+=int(nums[j]%2==1)    # increment c1 if there is odd bit.\\n                c2+=int(nums[j]%2==0)    # increment c2 if there is even bit.\\n                nums[j]//=2\\n            ans+=c1*c2\\n        return ans    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 631257,
                "title": "python-o-n-time-easy-to-understand-code",
                "content": "```\\nclass Solution(object):\\n    def totalHammingDistance(self, nums):\\n        result=0\\n        for i in range(32):\\n            count1=0\\n            count0=0\\n            for j in nums:\\n                if (j>>i)&1:\\n                    count1 +=1\\n                else:\\n                    count0 +=1\\n                    \\n            result +=(count1*count0)\\n        return result\\n            \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def totalHammingDistance(self, nums):\\n        result=0\\n        for i in range(32):\\n            count1=0\\n            count0=0\\n            for j in nums:\\n                if (j>>i)&1:\\n                    count1 +=1\\n                else:\\n                    count0 +=1\\n                    \\n            result +=(count1*count0)\\n        return result\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 517307,
                "title": "simple-python-o-n-solution-with-explanation",
                "content": "Explanaion:\\n\\n1. assuming there are N number in the array, at the k-th bit, m of  the N numbers are \\'1\\'  and the rest N-m are zero. So there are m*(N-m) combination of numbers that the k-th bit are different. So the k-th bit contribute m*(N-m) to the total result.\\n\\n```\\nimport collections\\nclass Solution:\\n    def totalHammingDistance(self, nums: List[int]) -> int:\\n        N = len(nums)\\n        \\n        dic = collections.defaultdict(int)\\n        \\n        for a in nums:\\n            b = bin(a)[2:]\\n            l = len(b)\\n            for i in range(l):\\n                if b[i]==\\'1\\':\\n                    dic[l-1-i] += 1\\n                    \\n        res = 0\\n        for m in dic.values():\\n            res += m*(N-m)\\n            \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nimport collections\\nclass Solution:\\n    def totalHammingDistance(self, nums: List[int]) -> int:\\n        N = len(nums)\\n        \\n        dic = collections.defaultdict(int)\\n        \\n        for a in nums:\\n            b = bin(a)[2:]\\n            l = len(b)\\n            for i in range(l):\\n                if b[i]==\\'1\\':\\n                    dic[l-1-i] += 1\\n                    \\n        res = 0\\n        for m in dic.values():\\n            res += m*(N-m)\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 454538,
                "title": "o-n-solution-in-c-accepted",
                "content": "```\\nint totalHammingDistance(int* nums, int numsSize){\\n    int ct[30] = {0};\\n    for (int i = 0; i < numsSize; i++) {\\n        int tmp = nums[i];\\n        int count = 0;\\n        while (tmp) {\\n            ct[count] += tmp & 0b1;\\n            tmp=tmp>>1;\\n            count++;\\n        }\\n    }\\n    int res = 0;\\n    for (int i = 0; i < 30; i++) {\\n        res += ct[i]*(numsSize-ct[i]);\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint totalHammingDistance(int* nums, int numsSize){\\n    int ct[30] = {0};\\n    for (int i = 0; i < numsSize; i++) {\\n        int tmp = nums[i];\\n        int count = 0;\\n        while (tmp) {\\n            ct[count] += tmp & 0b1;\\n            tmp=tmp>>1;\\n            count++;\\n        }\\n    }\\n    int res = 0;\\n    for (int i = 0; i < 30; i++) {\\n        res += ct[i]*(numsSize-ct[i]);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 435151,
                "title": "time-limit-exceeded-unaccepted-answers",
                "content": "This solution works, yet returns time limit exceeded, which I don\\'t think it should:\\n\\n```\\nfrom itertools import combinations\\n\\nclass Solution:\\n    def totalHammingDistance(self, nums: List[int]) -> int:\\n\\n        diff = 0\\n        for p in combinations(nums, r=2):\\n            bit_0, bit_1 = bin(p[0])[2:].zfill(32), bin(p[1])[2:].zfill(32)\\n\\n            for i in range(32):\\n                if bit_0[i] != bit_1[i]:\\n                    diff += 1\\n\\n        return diff\\n```\\n\\nThis might be a valid solution, with same time-limt exceed issue:\\n\\n```\\nfrom itertools import combinations\\nimport numpy as np\\n\\n\\nclass Solution:\\n    def totalHammingDistance(self, nums: List[int]) -> int:\\n\\n        diff = 0\\n        h = {}\\n        for p in combinations(nums, r=2):\\n            if p[0] not in h:\\n                h[p[0]] = bin(p[0])[2:].zfill(32)\\n\\n            if p[1] not in h:\\n                h[p[1]] = bin(p[1])[2:].zfill(32)\\n\\n            add = np.array(list(map(int, h[p[0]]))) + np.array(list(map(int, h[p[1]])))\\n            diff += len(add[add == 1])\\n\\n        return diff\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom itertools import combinations\\n\\nclass Solution:\\n    def totalHammingDistance(self, nums: List[int]) -> int:\\n\\n        diff = 0\\n        for p in combinations(nums, r=2):\\n            bit_0, bit_1 = bin(p[0])[2:].zfill(32), bin(p[1])[2:].zfill(32)\\n\\n            for i in range(32):\\n                if bit_0[i] != bit_1[i]:\\n                    diff += 1\\n\\n        return diff\\n```\n```\\nfrom itertools import combinations\\nimport numpy as np\\n\\n\\nclass Solution:\\n    def totalHammingDistance(self, nums: List[int]) -> int:\\n\\n        diff = 0\\n        h = {}\\n        for p in combinations(nums, r=2):\\n            if p[0] not in h:\\n                h[p[0]] = bin(p[0])[2:].zfill(32)\\n\\n            if p[1] not in h:\\n                h[p[1]] = bin(p[1])[2:].zfill(32)\\n\\n            add = np.array(list(map(int, h[p[0]]))) + np.array(list(map(int, h[p[1]])))\\n            diff += len(add[add == 1])\\n\\n        return diff\\n```",
                "codeTag": "Java"
            },
            {
                "id": 388938,
                "title": "python-o-n-time-and-o-1-space-intuitive",
                "content": "Find number of 0\\'s and 1\\'s different for each bit in the nums list while shifting the numbers by 1 on each iteration. \\n```\\ndef totalHammingDistance(self, nums: List[int]) -> int:\\n        count = 0\\n        while any(nums):\\n            lastVals = [num%2 for num in nums]\\n            count += lastVals.count(0) * lastVals.count(1)\\n            nums = [num >> 1 for num in nums]\\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\ndef totalHammingDistance(self, nums: List[int]) -> int:\\n        count = 0\\n        while any(nums):\\n            lastVals = [num%2 for num in nums]\\n            count += lastVals.count(0) * lastVals.count(1)\\n            nums = [num >> 1 for num in nums]\\n        return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 380230,
                "title": "modern-c-neatest-solution",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    static constexpr int L = 32;\\n    int totalHammingDistance(vector<int>& nums)\\n    {           \\n        vector<int> b(L, 0);\\n        for (auto v : nums)\\n        {   \\n            int i = -1;\\n            while (++i < L)                          \\n             if (v & 1 << i)\\n                ++b[i];                             \\n        }        \\n        \\n        int N = nums.size();\\n        return accumulate(b.begin(), b.end(), 0, \\n            [&](auto r, auto k) { r += k *(N-k); return r; });\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    static constexpr int L = 32;\\n    int totalHammingDistance(vector<int>& nums)\\n    {           \\n        vector<int> b(L, 0);\\n        for (auto v : nums)\\n        {   \\n            int i = -1;\\n            while (++i < L)                          \\n             if (v & 1 << i)\\n                ++b[i];                             \\n        }        \\n        \\n        int N = nums.size();\\n        return accumulate(b.begin(), b.end(), 0, \\n            [&](auto r, auto k) { r += k *(N-k); return r; });\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 334212,
                "title": "python-simple-intuitive-solution",
                "content": "```\\nclass Solution(object):\\n    def totalHammingDistance(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        n = len(nums)\\n        digits = [0 for _ in xrange(32)]\\n        for i,num in enumerate(nums):\\n            for j in xrange(32):\\n                if (1 << j) & num:\\n                    digits[j] += 1\\n        \\n        res = 0\\n        for i,digit in enumerate(digits):\\n            res += digit * (n - digit)\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def totalHammingDistance(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        n = len(nums)\\n        digits = [0 for _ in xrange(32)]\\n        for i,num in enumerate(nums):\\n            for j in xrange(32):\\n                if (1 << j) & num:\\n                    digits[j] += 1\\n        \\n        res = 0\\n        for i,digit in enumerate(digits):\\n            res += digit * (n - digit)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 318222,
                "title": "concise-java-o-n-solution-with-examples",
                "content": "Thinking process:\\n1. Brute force: calculate each number with other number\\'s distance. Sum all up.\\n2. There are duplicate calculations, how to avoid?\\n3. Calculate each position\\'s distance across all numbers, then add all the bits\\' distances up. \\n\\nExample:\\n```\\n0100\\n0010\\n1110\\nFor the first bit, there are two 0s and one 1. The distance is 0-1, 0-1 which is 2. \\n\\n0100\\n0010\\n1110\\n1110\\n1110\\nFor the first bit, there are two 0s and three 1s. \\nThe distances are 0-1, 0-1, 0-1; 0-1, 0-1, 0-1 which is 6. Which can be calculated as combination between 0 and 1 is 2 * 3  = 6. \\n\\nAs as result, we need to  calculate each bit potision\\'s number of 0 and number of 1. Multiply these two number we get the current bit\\'s total distance. \\n\\nThe whole distance is added by each bit\\'s total distance. \\n\\n```\\n\\nSee the code below: \\n```java\\nclass Solution {\\n    public int totalHammingDistance(int[] nums) {\\n        // Bit manipulation\\n        // Edge case\\n        if(nums == null || nums.length == 0) return 0;\\n        \\n        int res = 0;\\n        //1. For each position, count all the nums 0s and 1s\\n        for(int i = 0; i < 32; i++) {\\n            int zero = 0, one = 0;\\n            for(int j = 0; j < nums.length; j++) {\\n                int check = nums[j] & (1 << i);\\n                if(check == 0) zero ++;\\n                else    one ++;\\n            }\\n            res += (zero * one);     //2. num of 0 * num of 1 = distance of this position\\n        }\\n        \\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n0100\\n0010\\n1110\\nFor the first bit, there are two 0s and one 1. The distance is 0-1, 0-1 which is 2. \\n\\n0100\\n0010\\n1110\\n1110\\n1110\\nFor the first bit, there are two 0s and three 1s. \\nThe distances are 0-1, 0-1, 0-1; 0-1, 0-1, 0-1 which is 6. Which can be calculated as combination between 0 and 1 is 2 * 3  = 6. \\n\\nAs as result, we need to  calculate each bit potision\\'s number of 0 and number of 1. Multiply these two number we get the current bit\\'s total distance. \\n\\nThe whole distance is added by each bit\\'s total distance. \\n\\n```\n```java\\nclass Solution {\\n    public int totalHammingDistance(int[] nums) {\\n        // Bit manipulation\\n        // Edge case\\n        if(nums == null || nums.length == 0) return 0;\\n        \\n        int res = 0;\\n        //1. For each position, count all the nums 0s and 1s\\n        for(int i = 0; i < 32; i++) {\\n            int zero = 0, one = 0;\\n            for(int j = 0; j < nums.length; j++) {\\n                int check = nums[j] & (1 << i);\\n                if(check == 0) zero ++;\\n                else    one ++;\\n            }\\n            res += (zero * one);     //2. num of 0 * num of 1 = distance of this position\\n        }\\n        \\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 312587,
                "title": "for-folks-who-are-not-comfortable-with-bit-manipulation-o-nlogk-time-o-1-space",
                "content": "Hamming distance between a even and odd number is at least 1 because the last bit is always different (even number has 0 and odd number has 1).\\n\\nSo just find the number of even and odd numbers in the array. If there are 2 even numbers and 3 odd numbers, the minimum total hamming distance is 6.\\n\\nDoing it once will give the minimum hamming distance of the last bits in all the numbers. To find for the remaining bits, divide all the numbers by 2 and continue doing it.\\n\\nKeep continuing this till all the numbers in the array are 0.\\n\\nSince our terminating point is when all the numbers are 0, and we move towards the terminating point by dividing all the numbers by 2, the highest number will be the last number to reach 0 and we would have divided the numbers log(highestNumber) times to reach 0.\\n\\nSo the complexity is O(nlogk) where k is the highest number in the array.\\n\\n```\\nclass Solution {\\n    public int totalHammingDistance(int[] nums) {\\n        int count = 0;\\n        \\n        while(true){\\n            int numEven = 0;\\n            int numOdd = 0;\\n            int numZero = 0;\\n            for(int i=0; i<nums.length; i++) {\\n                if(nums[i] == 0) numZero++;\\n                if(nums[i] % 2 == 0) {\\n                    numEven++;\\n                } else {\\n                    numOdd++;\\n                }\\n                nums[i] = nums[i]/2;\\n            }\\n\\n            if(numZero == nums.length) break;\\n\\n            count += numEven*numOdd;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int totalHammingDistance(int[] nums) {\\n        int count = 0;\\n        \\n        while(true){\\n            int numEven = 0;\\n            int numOdd = 0;\\n            int numZero = 0;\\n            for(int i=0; i<nums.length; i++) {\\n                if(nums[i] == 0) numZero++;\\n                if(nums[i] % 2 == 0) {\\n                    numEven++;\\n                } else {\\n                    numOdd++;\\n                }\\n                nums[i] = nums[i]/2;\\n            }\\n\\n            if(numZero == nums.length) break;\\n\\n            count += numEven*numOdd;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 254634,
                "title": "c-easy-to-understand",
                "content": "Calculate how many ones and zeroes we have in a certain position while traversing the array.\\n\\n```\\n    int totalHammingDistance(vector<int>& nums) {\\n        int ones[32] = {0};\\n        int zeroes[32] = {0};\\n        int r = 0;\\n        for (int n: nums){\\n            int b = 0;\\n            for(int i=0;i<32;++i){\\n                if(n&1){\\n                    // bit is set\\n                    r += zeroes[b];\\n                    ones[b]++;\\n                }\\n                else{\\n                    r += ones[b];\\n                    zeroes[b]++;\\n                }\\n                b ++;\\n                n = n >> 1;\\n            }\\n        }\\n        return r;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n    int totalHammingDistance(vector<int>& nums) {\\n        int ones[32] = {0};\\n        int zeroes[32] = {0};\\n        int r = 0;\\n        for (int n: nums){\\n            int b = 0;\\n            for(int i=0;i<32;++i){\\n                if(n&1){\\n                    // bit is set\\n                    r += zeroes[b];\\n                    ones[b]++;\\n                }\\n                else{\\n                    r += ones[b];\\n                    zeroes[b]++;\\n                }\\n                b ++;\\n                n = n >> 1;\\n            }\\n        }\\n        return r;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 244831,
                "title": "bits-trick-very-simple-solution-approach",
                "content": "Make a array of 32 size( because all the numbers are less than 10^9).\\n\\nbit[32]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};\\n\\nNow for every element of given array, find its all set bits and add these bits to corresponding bit array index.\\n\\nfor example given array is {13, 5, 6}. \\n\\n13(1101) has 0th, 2nd and 3rd bit set.\\n\\tbit={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1};\\n\\t\\n5(101) has 0th, 2nd bit set.\\n    bit={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,0,2};\\n\\t\\n6(110) has 1st, 2nd bit set.\\n\\tbit={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,3,1,2};\\n\\nnow some maths part.\\n\\n**every set bit can make pair with every unset bit of that position.**\\n\\n0th bit is set on two numbers and total numbers are 3.\\nso hamming distance with 0th bit will be = bit[0] * ( n- bit[0])\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t = 2 * 1 = 2\\n1st bit is set on one number and total numbers are 3.\\nso hamming distance with 1st bit will be = bit[1] * ( n- bit[1])\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t = 1 * 2 = 2\\n2nd bit is set on three numbers and total numbers are 3.\\nso hamming distance with 2nd bit will be = bit[2] * ( n- bit[2])\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t = 3 * 0 = 0\\n3rd bit is set on one number and total numbers are 3.\\nso hamming distance with 3rd bit will be = bit[3] * ( n- bit[3])\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t = 1 * 2 = 2\\n\\nso total hamming distance is sum of hamming distance of individual bits.( 2+2+0+2= 6)\\n\\n```\\nint totalHammingDistance(vector<int>& nums) {\\n        int bit[32]={0};\\n        int n = nums.size();\\n        for( int i=0;i<n;i++){\\n            int j=0;\\n            while( nums[i]){\\n                if( nums[i] & 1)\\n                    bit[j]++;\\n                j++;\\n                nums[i]>>=1;\\n            }\\n        }\\n        int ans=0;\\n        for( int i=0;i<32;i++){\\n            ans+=(bit[i]*(n-bit[i]));\\n        }\\n        return ans;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\nint totalHammingDistance(vector<int>& nums) {\\n        int bit[32]={0};\\n        int n = nums.size();\\n        for( int i=0;i<n;i++){\\n            int j=0;\\n            while( nums[i]){\\n                if( nums[i] & 1)\\n                    bit[j]++;\\n                j++;\\n                nums[i]>>=1;\\n            }\\n        }\\n        int ans=0;\\n        for( int i=0;i<32;i++){\\n            ans+=(bit[i]*(n-bit[i]));\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 232703,
                "title": "python-solution-with-strings",
                "content": "Thans guys for all your solutions, there are a lot of interesting variants but I tryied to reinvent wheel by myself.\\n```\\nclass Solution(object):\\n    def totalHammingDistance(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        result=0\\n        if nums == []:\\n            return 0\\n        nums_len = len(nums)\\n        for i in range(nums_len):\\n            for n in range (i+1,nums_len):\\n                result += bin(nums[i]^nums[n]).count(\\'1\\')\\n        return result\\n```\\n\\nUnfortunately this solution is faling with Time Limit Exceeded on 36/47 test (10k items). I could suggest that `.count(\\'1\\')` operation is taking too much time but I have no idea how to optimize it to pass all the tests. \\nI will be very appriciated for any suggestion how to optimize that solution (when we\\'re XORing two numbers).\\nBest regards,\\nMaks",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def totalHammingDistance(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        result=0\\n        if nums == []:\\n            return 0\\n        nums_len = len(nums)\\n        for i in range(nums_len):\\n            for n in range (i+1,nums_len):\\n                result += bin(nums[i]^nums[n]).count(\\'1\\')\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 221760,
                "title": "python-easy-to-understand-brute-force-solution",
                "content": "Let us analyze the example for some insight. Let the Hamming distance to be DH. For the array nums = [4, 14, 2], it is easy to see\\nInput,    binary representation\\n4  --->          0100\\n14--->        1110\\n2  --->           0010\\nAs HD(4, 14) = 2, HD(4, 2) = 2, HD(14, 2) = 2, the total HD for the array nums will be 2 + 2 + 2 = 6. This is one way of computing the HD for the array, which requires computing n*(n+1)/2 Hamming distances for n = len(nums).\\n\\nAnother way to compute the total Hamming distance for the array is that we add together the contributions of each digit in binary representation. Assume the i-th digits of the numbers in the array are 1, 1, 0, 1, 0.  For the 0-th number, there are two numbers with different binary digit from 1, similar for 1st, and 3rd numbers; for 2nd number, there are three numbers (0th, 1st, 3rd) with different binary digit different from 0, similar for the 4th number.Hence,  the contribution of i-th digit of the number in the array to the final HD is (number of 1s)*(number of 0s). Note that (number of 1s) + (number of 0s) = n, the length of the array.\\n\\nFor the example, we have total HD = 1* 2 + 2* 1 + 2* 1 + 0* 3 = 6.\\n```\\nclass Solution:\\n    def totalHammingDistance(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        f = [[0]*30 for i in range(len(nums))] # log(10**9, 2) = 29.9\\n        for i in range(len(nums)):\\n            num = nums[i]\\n            aux_list =[]\\n            while num > 0:\\n                aux_list.append(num%2)\\n                num //= 2\\n            for j in range(len(aux_list)):\\n                f[i][j] = aux_list[j]\\n        res = 0\\n        for j in range(30):\\n            aux_col = [f[i][j] for i in range(len(nums))]\\n            if 0 < aux_col.count(1) < len(nums):\\n                res += aux_col.count(1) * (len(nums) - aux_col.count(1))\\n        return res\\n```\\nor a simplified version:\\n```\\nclass Solution:\\n    def totalHammingDistance(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        bits = [[0,0] for _ in range(30)]\\n        for x in nums:\\n            for i in range(30):\\n                bits[i][x%2] += 1\\n                x //= 2\\n        return sum( x*y for x, y in bits )\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def totalHammingDistance(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        f = [[0]*30 for i in range(len(nums))] # log(10**9, 2) = 29.9\\n        for i in range(len(nums)):\\n            num = nums[i]\\n            aux_list =[]\\n            while num > 0:\\n                aux_list.append(num%2)\\n                num //= 2\\n            for j in range(len(aux_list)):\\n                f[i][j] = aux_list[j]\\n        res = 0\\n        for j in range(30):\\n            aux_col = [f[i][j] for i in range(len(nums))]\\n            if 0 < aux_col.count(1) < len(nums):\\n                res += aux_col.count(1) * (len(nums) - aux_col.count(1))\\n        return res\\n```\n```\\nclass Solution:\\n    def totalHammingDistance(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        bits = [[0,0] for _ in range(30)]\\n        for x in nums:\\n            for i in range(30):\\n                bits[i][x%2] += 1\\n                x //= 2\\n        return sum( x*y for x, y in bits )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 181580,
                "title": "c-bit-ops-easy-to-explain-and-impl-in-5mins-cheers",
                "content": "```\\n#include <vector>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        int n = nums.size();\\n        int res = 0;\\n        for (int i = 0; i < 32; ++i) {\\n            int cnt0 = 0;\\n            int cnt1 = 0;\\n            for (int j = 0; j < n; ++j) {\\n                if (((nums[j] >> i) & 1) == 1) {\\n                    ++cnt1;\\n                } else {\\n                    ++cnt0;\\n                }\\n            }\\n\\n            res += (cnt1 * cnt0);\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n#if DEBUG\\nint main(int argc, char** argv) {\\n    return 0;\\n}\\n#endif\\n\\n```",
                "solutionTags": [],
                "code": "```\\n#include <vector>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        int n = nums.size();\\n        int res = 0;\\n        for (int i = 0; i < 32; ++i) {\\n            int cnt0 = 0;\\n            int cnt1 = 0;\\n            for (int j = 0; j < n; ++j) {\\n                if (((nums[j] >> i) & 1) == 1) {\\n                    ++cnt1;\\n                } else {\\n                    ++cnt0;\\n                }\\n            }\\n\\n            res += (cnt1 * cnt0);\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n#if DEBUG\\nint main(int argc, char** argv) {\\n    return 0;\\n}\\n#endif\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 169581,
                "title": "python-o-n-time-o-1-space",
                "content": "loop through bits\\n```\\nclass Solution(object):\\n    def totalHammingDistance(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if not nums or len(nums) == 1:\\n            return 0\\n        \\n        n = len(nums)\\n        maxx = max(nums)\\n        ans = 0\\n        m = 1\\n        while m <= maxx:\\n            ones = 0\\n            for num in nums:\\n                if m & num:\\n                    ones += 1\\n            zeros = n - ones\\n            ans += ones * zeros\\n            m <<= 1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def totalHammingDistance(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if not nums or len(nums) == 1:\\n            return 0\\n        \\n        n = len(nums)\\n        maxx = max(nums)\\n        ans = 0\\n        m = 1\\n        while m <= maxx:\\n            ones = 0\\n            for num in nums:\\n                if m & num:\\n                    ones += 1\\n            zeros = n - ones\\n            ans += ones * zeros\\n            m <<= 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 142367,
                "title": "c-two-solutions-1-bruteforce-and-2-optimized-solution-with-explanation",
                "content": "**Solution 1:** Brute Force\\n```\\npublic class Solution {\\n    public int TotalHammingDistance(int[] nums)\\n    {\\n        List<int[]> pairs = GetPairs(nums);\\n        int totalHammingDistance = 0;\\n        foreach (int[] pair in pairs)\\n            totalHammingDistance += GetHammingDistance(pair[0], pair[1]);\\n        return totalHammingDistance;\\n    }\\n\\n    private static List<int[]> GetPairs(int[] nums)\\n    {\\n        List<int[]> pairs = new List<int[]>();\\n        for (int i = 0; i < nums.Length-1; i++)\\n            for (int j = i + 1; j < nums.Length; j++)\\n                pairs.Add(new int[]{nums[i], nums[j]});            \\n        return pairs;\\n    }\\n    \\n     private static int GetHammingDistance(int a, int b)\\n     {\\n        int hammingDistance = 0;\\n        int xor = a ^ b;\\n        string binaryRep = Convert.ToString(xor, 2);\\n        foreach (char bit in binaryRep)\\n            if (bit == \\'1\\') hammingDistance++;\\n        return hammingDistance;\\n     }\\n}\\n```\\n**Solution 2:**\\n* We can separate the calculation to do one bit at a time. \\n* For example, look at the rightmost bit of all the numbers in nums.\\n* Suppose that i numbers have a rightmost 0-bit, and j numbers have a 1-bit. \\n* Then out of the pairs, i * j of them will have 1 in the rightmost bit of the XOR. \\n* This is because there are i * j ways to choose one number that has a 0-bit and one that has a 1-bit. \\n* These bits will therefore contribute i * j towards the total of all the XORs.\\n```\\npublic class Solution {\\n    public int TotalHammingDistance(int[] nums)\\n    {\\n        int[] countOfOnes = new int[32];\\n        for (int i = 0; i < nums.Length; i++)\\n            for (int j = 0; j < 32; j++)\\n                countOfOnes[j] += (nums[i] >> j) & 1;\\n\\n        int sum = 0;\\n        for (int i = 0; i < 32; i++)\\n            sum += countOfOnes[i] * (nums.Length - countOfOnes[i]);    //nums.Length - countOfOnes[i] = countOfZeroes[i]\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int TotalHammingDistance(int[] nums)\\n    {\\n        List<int[]> pairs = GetPairs(nums);\\n        int totalHammingDistance = 0;\\n        foreach (int[] pair in pairs)\\n            totalHammingDistance += GetHammingDistance(pair[0], pair[1]);\\n        return totalHammingDistance;\\n    }\\n\\n    private static List<int[]> GetPairs(int[] nums)\\n    {\\n        List<int[]> pairs = new List<int[]>();\\n        for (int i = 0; i < nums.Length-1; i++)\\n            for (int j = i + 1; j < nums.Length; j++)\\n                pairs.Add(new int[]{nums[i], nums[j]});            \\n        return pairs;\\n    }\\n    \\n     private static int GetHammingDistance(int a, int b)\\n     {\\n        int hammingDistance = 0;\\n        int xor = a ^ b;\\n        string binaryRep = Convert.ToString(xor, 2);\\n        foreach (char bit in binaryRep)\\n            if (bit == \\'1\\') hammingDistance++;\\n        return hammingDistance;\\n     }\\n}\\n```\n```\\npublic class Solution {\\n    public int TotalHammingDistance(int[] nums)\\n    {\\n        int[] countOfOnes = new int[32];\\n        for (int i = 0; i < nums.Length; i++)\\n            for (int j = 0; j < 32; j++)\\n                countOfOnes[j] += (nums[i] >> j) & 1;\\n\\n        int sum = 0;\\n        for (int i = 0; i < 32; i++)\\n            sum += countOfOnes[i] * (nums.Length - countOfOnes[i]);    //nums.Length - countOfOnes[i] = countOfZeroes[i]\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 142265,
                "title": "c-bitmasking",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        int count = 0;\\n        for(int i = 0;i < 32;i++){\\n            int zs = 0, os = 0;\\n            for(int j = 0;j < nums.size();j++){\\n                if((nums[j]&(1<<i))!=0)\\n                    os++;\\n                else\\n                    zs++;\\n            }\\n            count+=(os*zs);\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        int count = 0;\\n        for(int i = 0;i < 32;i++){\\n            int zs = 0, os = 0;\\n            for(int j = 0;j < nums.size();j++){\\n                if((nums[j]&(1<<i))!=0)\\n                    os++;\\n                else\\n                    zs++;\\n            }\\n            count+=(os*zs);\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 140391,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def totalHammingDistance(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        size, count = 32, 0\\n        for _ in xrange(0, size):\\n            zeros, ones = 0, 0\\n            for i in xrange(0, len(nums)):\\n                if nums[i] & 1 == 1:\\n                    ones += 1\\n                else:\\n                    zeros += 1\\n                nums[i] >>= 1\\n            count += zeros * ones\\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def totalHammingDistance(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        size, count = 32, 0\\n        for _ in xrange(0, size):\\n            zeros, ones = 0, 0\\n            for i in xrange(0, len(nums)):\\n                if nums[i] & 1 == 1:\\n                    ones += 1\\n                else:\\n                    zeros += 1\\n                nums[i] >>= 1\\n            count += zeros * ones\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 114102,
                "title": "a-simple-c-solution-accepted",
                "content": "```\\nint totalHammingDistance(int* nums, int numsSize) {\\n    int ret=0;\\n    int temp=0;\\n    for(int i=0;i<32;i++){\\n        temp=0;\\n        for(int j=0;j<numsSize;j++){\\n            if((nums[j]&1)==1){temp++;}\\n            nums[j]=nums[j]>>1;\\n        }\\n        ret=ret+temp*(numsSize-temp);\\n    }\\n    return ret;\\n}\\n// Time Limit Exceeded\\n/*int  HammingDistance(int num1,int num2){\\n    int ret=0;\\n    while(num1!=0&&num2!=0){\\n        if((num1&1)!=(num2&1)){\\n            ret++;\\n        }\\n        num1=num1>>1;\\n        num2=num2>>1;\\n    }\\n    while(num1!=0){\\n        if((num1&1)==1){\\n            ret++;\\n        }\\n        num1=num1>>1;\\n    }\\n    while(num2!=0){\\n        if((num2&1)==1){\\n            ret++;\\n        }\\n        num2=num2>>1;\\n    }\\n    return ret;\\n}\\nint totalHammingDistance(int* nums, int numsSize) {\\n    int ret=0;\\n    for(int i=0;i<numsSize-1;i++){\\n        for(int j=i+1;j<numsSize;j++){\\n            ret=ret+HammingDistance(nums[i],nums[j]);\\n        }\\n    }\\n    return ret;\\n}*/\\n````",
                "solutionTags": [],
                "code": "```\\nint totalHammingDistance(int* nums, int numsSize) {\\n    int ret=0;\\n    int temp=0;\\n    for(int i=0;i<32;i++){\\n        temp=0;\\n        for(int j=0;j<numsSize;j++){\\n            if((nums[j]&1)==1){temp++;}\\n            nums[j]=nums[j]>>1;\\n        }\\n        ret=ret+temp*(numsSize-temp);\\n    }\\n    return ret;\\n}\\n// Time Limit Exceeded\\n/*int  HammingDistance(int num1,int num2){\\n    int ret=0;\\n    while(num1!=0&&num2!=0){\\n        if((num1&1)!=(num2&1)){\\n            ret++;\\n        }\\n        num1=num1>>1;\\n        num2=num2>>1;\\n    }\\n    while(num1!=0){\\n        if((num1&1)==1){\\n            ret++;\\n        }\\n        num1=num1>>1;\\n    }\\n    while(num2!=0){\\n        if((num2&1)==1){\\n            ret++;\\n        }\\n        num2=num2>>1;\\n    }\\n    return ret;\\n}\\nint totalHammingDistance(int* nums, int numsSize) {\\n    int ret=0;\\n    for(int i=0;i<numsSize-1;i++){\\n        for(int j=i+1;j<numsSize;j++){\\n            ret=ret+HammingDistance(nums[i],nums[j]);\\n        }\\n    }\\n    return ret;\\n}*/\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 112111,
                "title": "scala-functional-programming-1-liner-o-n",
                "content": "1. Let A[i] be the number of array elements with bit i set to 1.\\n2. The total hamming distance is the sum of all A[i]*(n - A[i]), where n is the size of the array.\\n\\n```\\n def totalHammingDistance(nums: Array[Int]): Int = \\n     (0 to 31).map(i => nums.fold(0)((b, c) => b + (c>>i & 1))).fold(0)((d, f) => d + f*(nums.size-f))\\n```\\nExpanded for clarity:\\n\\n```\\n def totalHammingDistance(nums: Array[Int]): Int = \\n     (0 to 31)\\n      .map(i => \\n           nums.fold(0)((b, c) => b + (c>>i & 1)))\\n      .fold(0)((d, f) => d + f*(nums.size-f))\\n```",
                "solutionTags": [
                    "Scala",
                    "Bit Manipulation"
                ],
                "code": "```\\n def totalHammingDistance(nums: Array[Int]): Int = \\n     (0 to 31).map(i => nums.fold(0)((b, c) => b + (c>>i & 1))).fold(0)((d, f) => d + f*(nums.size-f))\\n```\n```\\n def totalHammingDistance(nums: Array[Int]): Int = \\n     (0 to 31)\\n      .map(i => \\n           nums.fold(0)((b, c) => b + (c>>i & 1)))\\n      .fold(0)((d, f) => d + f*(nums.size-f))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 96220,
                "title": "javascript-100ms-solution",
                "content": "```\\nvar totalHammingDistance = function(nums) {\\n    var result = 0;\\n    for(var i = 0; i < 32; i++){\\n        var one = 0;\\n        for(var j = 0; j < nums.length; j++){\\n            one += nums[j] >> i & 1;\\n        }\\n        result += one * (nums.length - one);\\n    }\\n    return result;\\n};",
                "solutionTags": [],
                "code": "```\\nvar totalHammingDistance = function(nums) {\\n    var result = 0;\\n    for(var i = 0; i < 32; i++){\\n        var one = 0;\\n        for(var j = 0; j < nums.length; j++){\\n            one += nums[j] >> i & 1;\\n        }\\n        result += one * (nums.length - one);\\n    }\\n    return result;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 96225,
                "title": "passes-37-out-of-the-47-test-cases-and-errors-does-anyone-have-a-clue-how-to-fix-it-c",
                "content": "'''\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        /* we should go through all the pairs of elements in nums and caculate the distance between each two and then we sum up all the sums to find the            total hamming distance */\\n        \\n        if(nums.size()==1 || nums.size()==0){\\n            return 0;\\n        }\\n        \\n        int global_distance=0;\\n        for(std::vector<int>::iterator it1=nums.begin(); it1!=nums.end()-1; ++it1){\\n            for(std::vector<int>::iterator it2=it1+1; it2!=nums.end(); ++it2){\\n                \\n                /* xor both elements*/\\n                int x= *it1^*it2;\\n                int local_distance = 0;\\n                while(x!=0){\\n                    if(x&1==1){\\n                        local_distance+=1;\\n                    }\\n                    x=x>>1;\\n                }\\n                \\n                global_distance += local_distance;\\n            }\\n            \\n        }\\n    \\n    return global_distance;\\n\\n    }\\n};\\n'''",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        /* we should go through all the pairs of elements in nums and caculate the distance between each two and then we sum up all the sums to find the            total hamming distance */\\n        \\n        if(nums.size()==1 || nums.size()==0){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 96238,
                "title": "python-time-limit-exceeded",
                "content": "It says run time limit exceeded. I'm new to python and coding. Does my code have run time n~2? \\n\\n'''\\nclass Solution(object):\\n    def totalHammingDistance(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        total=0\\n        for i in range (0,len(nums)-1):\\n            for j in range (i,len(nums)-1):\\n                total=total+bin(nums[i]^nums[j+1]).count(\"1\")\\n        return total\\n'''",
                "solutionTags": [],
                "code": "It says run time limit exceeded. I'm new to python and coding. Does my code have run time n~2? \\n\\n'''\\nclass Solution(object):\\n    def totalHammingDistance(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        total=0\\n        for i in range (0,len(nums)-1):\\n            for j in range (i,len(nums)-1):\\n                total=total+bin(nums[i]^nums[j+1]).count(\"1\")\\n        return total\\n'''",
                "codeTag": "Java"
            },
            {
                "id": 96251,
                "title": "easy-java-solution",
                "content": "```\\npublic class Solution {\\n    public int totalHammingDistance(int[] nums) {\\n        int res = 0;\\n        for (int i = 0; i < 31; i++) {\\n            int zero = 0, one = 0;\\n            for (int n : nums) {\\n                if ((n >>> i & 1) == 0) { // count zeros\\n                    zero++;\\n                } else { // count ones\\n                    one++;\\n                }\\n            }\\n            // \\u6240\\u6709\\u6570\\u540c\\u4f4d\\u4e0a\\u76840\\u7684\\u6570\\u91cf \\uff0a 1\\u7684\\u6570\\u91cf \\uff1d \\u8be5\\u4f4d\\u4e0a\\u7684total hamming dist\\n            res += zero * one;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int totalHammingDistance(int[] nums) {\\n        int res = 0;\\n        for (int i = 0; i < 31; i++) {\\n            int zero = 0, one = 0;\\n            for (int n : nums) {\\n                if ((n >>> i & 1) == 0) { // count zeros\\n                    zero++;\\n                } else { // count ones\\n                    one++;\\n                }\\n            }\\n            // \\u6240\\u6709\\u6570\\u540c\\u4f4d\\u4e0a\\u76840\\u7684\\u6570\\u91cf \\uff0a 1\\u7684\\u6570\\u91cf \\uff1d \\u8be5\\u4f4d\\u4e0a\\u7684total hamming dist\\n            res += zero * one;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96256,
                "title": "cpp-solution",
                "content": "### Trivial Solution:\\n**Time Complexity**: O(n ^ 2), n is the length of array.\\n```cpp\\nclass Solution {\\n    int getNumXOR(int l, int r)  {\\n        int k = l ^ r, res = 0;\\n        while(k) {\\n            res += k & 1;\\n            k >>= 1;\\n        }\\n        return res;\\n    }\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        int res = 0;\\n        const int len = nums.size();\\n        for (int i = 0; i < len; ++i) {\\n            for (int j = i + 1; j < len; ++j) {\\n                res += getNumXOR(nums[i], nums[j]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\nIt cannot pass the big test case.\\n### Optimized Solution:\\n**Time Complexity:** O(n), n is the length of array.\\n\\nWe don't really need to compare every two pair of integers. In the trivial solution, it actually collects more information than we need: it gives us the number of different bits for every pair of integers. And we only need to know the total number of different bits for all pairs of integers.\\n\\nTo get rid of the redundant information, we can **multiple** the number of ones and zeros for every bit from 1 to 32 instead of comparing every pair of integers.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        int ones = 0, sum = 0;\\n        const int len = nums.size();\\n        for (int i = 0; i < 32; ++i) {\\n            ones = 0;\\n            for (int val: nums)\\n                ones += val >> i & 1;\\n            sum += (len - ones) * ones;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\n    int getNumXOR(int l, int r)  {\\n        int k = l ^ r, res = 0;\\n        while(k) {\\n            res += k & 1;\\n            k >>= 1;\\n        }\\n        return res;\\n    }\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        int res = 0;\\n        const int len = nums.size();\\n        for (int i = 0; i < len; ++i) {\\n            for (int j = i + 1; j < len; ++j) {\\n                res += getNumXOR(nums[i], nums[j]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int totalHammingDistance(vector<int>& nums) {\\n        int ones = 0, sum = 0;\\n        const int len = nums.size();\\n        for (int i = 0; i < 32; ++i) {\\n            ones = 0;\\n            for (int val: nums)\\n                ones += val >> i & 1;\\n            sum += (len - ones) * ones;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96277,
                "title": "share-my-straightforward-java-solution",
                "content": "```\\npublic class Solution {\\n    public int totalHammingDistance(int[] nums) {\\n        int n = nums.length;\\n        int sum = 0;\\n        int[][] pair = new int[32][2];\\n        for (int num : nums) {\\n            int k = 0;\\n            while (k < 32) {\\n                int cur = (num & 1);\\n                if (cur == 0) {\\n                    sum += pair[k][1];\\n                } else {\\n                    sum += pair[k][0];\\n                }\\n                pair[k][cur]++;\\n                k++;\\n                num >>= 1;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int totalHammingDistance(int[] nums) {\\n        int n = nums.length;\\n        int sum = 0;\\n        int[][] pair = new int[32][2];\\n        for (int num : nums) {\\n            int k = 0;\\n            while (k < 32) {\\n                int cur = (num & 1);\\n                if (cur == 0) {\\n                    sum += pair[k][1];\\n                } else {\\n                    sum += pair[k][0];\\n                }\\n                pair[k][cur]++;\\n                k++;\\n                num >>= 1;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96278,
                "title": "java-o-n-solution-and-explanation",
                "content": "Use a size 32 array to store the counts of '1' of each binary digit for each number. (Constant space)\\nFor each digit, the product of count of '0's and '1's is the hamming distance of that digit since if both of 2 numbers have one or zero on the same digit.\\nThen, the sum of all the 32 digits is the answer.  \\n\\n    public int totalHammingDistance(int[] nums) {\\n        int[] digitcounts = new int [32];//count how many ones.\\n        for(int num:nums){\\n            for(int i = 0;i<32;i++){\\n                if(((num>>i)&1)==0){\\n                    digitcounts[i]++;\\n                }\\n            }\\n        }\\n        int numbercount = nums.length;\\n        int sum = 0;\\n        for(int i = 0;i<32;i++){\\n            sum+=digitcounts[i]*(numbercount-digitcounts[i]); //count of '1's * count of '0's.\\n        }\\n        return sum;\\n    }",
                "solutionTags": [],
                "code": "Use a size 32 array to store the counts of '1' of each binary digit for each number. (Constant space)\\nFor each digit, the product of count of '0's and '1's is the hamming distance of that digit since if both of 2 numbers have one or zero on the same digit.\\nThen, the sum of all the 32 digits is the answer.  \\n\\n    public int totalHammingDistance(int[] nums) {\\n        int[] digitcounts = new int [32];//count how many ones.\\n        for(int num:nums){\\n            for(int i = 0;i<32;i++){\\n                if(((num>>i)&1)==0){\\n                    digitcounts[i]++;\\n                }\\n            }\\n        }\\n        int numbercount = nums.length;\\n        int sum = 0;\\n        for(int i = 0;i<32;i++){\\n            sum+=digitcounts[i]*(numbercount-digitcounts[i]); //count of '1's * count of '0's.\\n        }\\n        return sum;\\n    }",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1569725,
                "content": [
                    {
                        "username": "huowa222",
                        "content": "\\ni don\\'t see any point and significant of this nonsense question."
                    },
                    {
                        "username": "ebram96",
                        "content": "If you think that way, you\\'ll be saying the same for many many question on this site and other sites two."
                    },
                    {
                        "username": "vishal100403",
                        "content": "is their any way of solving this question in O(n) time complexity?"
                    },
                    {
                        "username": "anantmakkar",
                        "content": "just this how to implement Xor here"
                    },
                    {
                        "username": "Ajantharajah",
                        "content": "Why this code gives error. it run on csse 1 &2.\\n\\nint hammingDistance(int x, int y) {\\n        return bitset<32>(x^y).count();\\n    }\\n\\n    int totalHammingDistance(vector<int>& nums) {\\n        return  hammingDistance(nums[0],nums[1]) + hammingDistance(nums[1],nums[2]) + hammingDistance(nums[0],nums[2]);\\n    }"
                    },
                    {
                        "username": "Navneet27",
                        "content": "Apart from your code only catering towards the only two visible test cases.\\nThe logic of making pairs and adding their hamming distance is the brute force approach which results in o(N^2) time complexity. You need to build a code for that applies to other test cases as well even if you are going with the brute force approach. Once you achieve it then you try to optimize. "
                    }
                ]
            },
            {
                "id": 2033459,
                "content": [
                    {
                        "username": "huowa222",
                        "content": "\\ni don\\'t see any point and significant of this nonsense question."
                    },
                    {
                        "username": "ebram96",
                        "content": "If you think that way, you\\'ll be saying the same for many many question on this site and other sites two."
                    },
                    {
                        "username": "vishal100403",
                        "content": "is their any way of solving this question in O(n) time complexity?"
                    },
                    {
                        "username": "anantmakkar",
                        "content": "just this how to implement Xor here"
                    },
                    {
                        "username": "Ajantharajah",
                        "content": "Why this code gives error. it run on csse 1 &2.\\n\\nint hammingDistance(int x, int y) {\\n        return bitset<32>(x^y).count();\\n    }\\n\\n    int totalHammingDistance(vector<int>& nums) {\\n        return  hammingDistance(nums[0],nums[1]) + hammingDistance(nums[1],nums[2]) + hammingDistance(nums[0],nums[2]);\\n    }"
                    },
                    {
                        "username": "Navneet27",
                        "content": "Apart from your code only catering towards the only two visible test cases.\\nThe logic of making pairs and adding their hamming distance is the brute force approach which results in o(N^2) time complexity. You need to build a code for that applies to other test cases as well even if you are going with the brute force approach. Once you achieve it then you try to optimize. "
                    }
                ]
            },
            {
                "id": 1965421,
                "content": [
                    {
                        "username": "huowa222",
                        "content": "\\ni don\\'t see any point and significant of this nonsense question."
                    },
                    {
                        "username": "ebram96",
                        "content": "If you think that way, you\\'ll be saying the same for many many question on this site and other sites two."
                    },
                    {
                        "username": "vishal100403",
                        "content": "is their any way of solving this question in O(n) time complexity?"
                    },
                    {
                        "username": "anantmakkar",
                        "content": "just this how to implement Xor here"
                    },
                    {
                        "username": "Ajantharajah",
                        "content": "Why this code gives error. it run on csse 1 &2.\\n\\nint hammingDistance(int x, int y) {\\n        return bitset<32>(x^y).count();\\n    }\\n\\n    int totalHammingDistance(vector<int>& nums) {\\n        return  hammingDistance(nums[0],nums[1]) + hammingDistance(nums[1],nums[2]) + hammingDistance(nums[0],nums[2]);\\n    }"
                    },
                    {
                        "username": "Navneet27",
                        "content": "Apart from your code only catering towards the only two visible test cases.\\nThe logic of making pairs and adding their hamming distance is the brute force approach which results in o(N^2) time complexity. You need to build a code for that applies to other test cases as well even if you are going with the brute force approach. Once you achieve it then you try to optimize. "
                    }
                ]
            },
            {
                "id": 1751740,
                "content": [
                    {
                        "username": "huowa222",
                        "content": "\\ni don\\'t see any point and significant of this nonsense question."
                    },
                    {
                        "username": "ebram96",
                        "content": "If you think that way, you\\'ll be saying the same for many many question on this site and other sites two."
                    },
                    {
                        "username": "vishal100403",
                        "content": "is their any way of solving this question in O(n) time complexity?"
                    },
                    {
                        "username": "anantmakkar",
                        "content": "just this how to implement Xor here"
                    },
                    {
                        "username": "Ajantharajah",
                        "content": "Why this code gives error. it run on csse 1 &2.\\n\\nint hammingDistance(int x, int y) {\\n        return bitset<32>(x^y).count();\\n    }\\n\\n    int totalHammingDistance(vector<int>& nums) {\\n        return  hammingDistance(nums[0],nums[1]) + hammingDistance(nums[1],nums[2]) + hammingDistance(nums[0],nums[2]);\\n    }"
                    },
                    {
                        "username": "Navneet27",
                        "content": "Apart from your code only catering towards the only two visible test cases.\\nThe logic of making pairs and adding their hamming distance is the brute force approach which results in o(N^2) time complexity. You need to build a code for that applies to other test cases as well even if you are going with the brute force approach. Once you achieve it then you try to optimize. "
                    }
                ]
            }
        ]
    }
]