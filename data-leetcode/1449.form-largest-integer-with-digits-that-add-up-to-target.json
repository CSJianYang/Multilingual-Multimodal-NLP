[
    {
        "title": "Minimum Number of K Consecutive Bit Flips",
        "question_content": "You are given a binary array nums and an integer k.\nA k-bit flip is choosing a subarray of length k from nums and simultaneously changing every 0 in the subarray to 1, and every 1 in the subarray to 0.\nReturn the minimum number of k-bit flips required so that there is no 0 in the array. If it is not possible, return -1.\nA subarray is a contiguous part of an array.\n&nbsp;\nExample 1:\n\nInput: nums = [0,1,0], k = 1\nOutput: 2\nExplanation: Flip nums[0], then flip nums[2].\n\nExample 2:\n\nInput: nums = [1,1,0], k = 2\nOutput: -1\nExplanation: No matter how we flip subarrays of size 2, we cannot make the array become [1,1,1].\n\nExample 3:\n\nInput: nums = [0,0,0,1,0,1,1,0], k = 3\nOutput: 3\nExplanation: \nFlip nums[0],nums[1],nums[2]: nums becomes [1,1,1,1,0,1,1,0]\nFlip nums[4],nums[5],nums[6]: nums becomes [1,1,1,1,1,0,0,0]\nFlip nums[5],nums[6],nums[7]: nums becomes [1,1,1,1,1,1,1,1]\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 105\n\t1 <= k <= nums.length",
        "solutions": [
            {
                "id": 238609,
                "title": "java-c-python-one-pass-and-o-1-space",
                "content": "## **Intuition**:\\nThere is only one way to filp `A[0]`,\\nand `A[0]` will tell us if we need to filp the range `A[0] ~ A[K -1]`.\\nSo we start from the leftmost one by one using a greedy idea to solve this problem.\\n\\n<br>\\n\\n## Solution 1\\n\\n**Explanation**\\nCreate a new array `isFlipped[n]`.\\n`isFlipped[i] = 1` iff we flip `K` consecutive bits starting at `A[i]`.\\n\\nWe maintain a variable `flipped` and `flipped = 1` iff the current bit is flipped.\\n\\nIf `flipped = 0` and `A[i] = 0`, we need to flip at `A[i]`.\\nIf `flipped = 1` and `A[i] = 1`, we need to flip at `A[i]`.\\n\\n**Complexity**\\n`O(N)` time for one pass\\n`O(N)` extra space for `isFlipped[n]`.\\n\\n\\n**Java**\\n```\\n    public int minKBitFlips(int[] A, int K) {\\n        int n = A.length, flipped = 0, res = 0;\\n        int[] isFlipped = new int[n];\\n        for (int i = 0; i < A.length; ++i) {\\n            if (i >= K)\\n                flipped ^= isFlipped[i - K];\\n            if (flipped == A[i]) {\\n                if (i + K > A.length)\\n                    return -1;\\n                isFlipped[i] = 1;\\n                flipped ^= 1;\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n<br>\\n\\n## Solution 2\\n\\n**Explanation**\\nInstead an array `isFlipped` of size `n`,\\nuse a deque to maintain the state of a sliding window of size `k`.\\n\\n**Complexity**\\n`O(N)` time for one pass\\n`O(K)` extra space for `isFlipped[n]`.\\n\\n\\n<br>\\n\\n## Solution 3\\n\\n**Explanation**:\\nOne pass.\\n`cur` means the number of flips in the current sliding window of size `K`.\\nIf `cur` is even and A[i] is `0`, we need to flip.\\nIf `cur` is odd and A[i] is `1`, we need to flip.\\n\\nIf we want to flip `A[i]`, we add `2` to it.\\nThe flipped 0 is 2 and flipped 1 is 3 now.\\nWhen they go out of the window, we will change them back.\\nSo no worries if we change the input.\\n\\n**Complexity**:\\n`O(N)` time for one pass\\n`O(1)` extra space.\\n\\n**Java:**\\n```\\n    public int minKBitFlips(int[] A, int K) {\\n        int cur = 0, res = 0, n = A.length;\\n        for (int i = 0; i < n; ++i) {\\n            if (i >= K && A[i - K] > 1) {\\n                cur--;\\n                A[i - K] -= 2;\\n            }\\n            if (cur % 2 == A[i]) {\\n                if (i + K > n) return -1;\\n                A[i] += 2;\\n                cur++;\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++:**\\n```\\n    int minKBitFlips(vector<int>& A, int K) {\\n        int cur = 0, res = 0, n = A.size();\\n        for (int i = 0; i < n; ++i) {\\n            if (i >= K && A[i - K] > 1) {\\n                cur--;\\n                A[i - K] -= 2;\\n            }\\n            if (cur % 2 == A[i]) {\\n                if (i + K > n) return -1;\\n                A[i] += 2;\\n                cur++;\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python:**\\n```\\n    def minKBitFlips(self, A, K):\\n        cur, res, n = 0, 0, len(A)\\n        for i in xrange(len(A)):\\n            if i >= K and A[i - K] > 1:\\n                A[i - K] -= 2\\n                cur -= 1\\n            if cur & 1 ^ A[i] == 0:\\n                if i + K > len(A):\\n                    return -1\\n                A[i] += 2\\n                cur += 1\\n                res += 1\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public int minKBitFlips(int[] A, int K) {\\n        int n = A.length, flipped = 0, res = 0;\\n        int[] isFlipped = new int[n];\\n        for (int i = 0; i < A.length; ++i) {\\n            if (i >= K)\\n                flipped ^= isFlipped[i - K];\\n            if (flipped == A[i]) {\\n                if (i + K > A.length)\\n                    return -1;\\n                isFlipped[i] = 1;\\n                flipped ^= 1;\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n```\n```\\n    public int minKBitFlips(int[] A, int K) {\\n        int cur = 0, res = 0, n = A.length;\\n        for (int i = 0; i < n; ++i) {\\n            if (i >= K && A[i - K] > 1) {\\n                cur--;\\n                A[i - K] -= 2;\\n            }\\n            if (cur % 2 == A[i]) {\\n                if (i + K > n) return -1;\\n                A[i] += 2;\\n                cur++;\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n```\n```\\n    int minKBitFlips(vector<int>& A, int K) {\\n        int cur = 0, res = 0, n = A.size();\\n        for (int i = 0; i < n; ++i) {\\n            if (i >= K && A[i - K] > 1) {\\n                cur--;\\n                A[i - K] -= 2;\\n            }\\n            if (cur % 2 == A[i]) {\\n                if (i + K > n) return -1;\\n                A[i] += 2;\\n                cur++;\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n```\n```\\n    def minKBitFlips(self, A, K):\\n        cur, res, n = 0, 0, len(A)\\n        for i in xrange(len(A)):\\n            if i >= K and A[i - K] > 1:\\n                A[i - K] -= 2\\n                cur -= 1\\n            if cur & 1 ^ A[i] == 0:\\n                if i + K > len(A):\\n                    return -1\\n                A[i] += 2\\n                cur += 1\\n                res += 1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 239284,
                "title": "c-greedy-stack-and-o-1-memory",
                "content": "This is a cool problem that sounds very hard by becomes easy with two intuition sparks (and a little twinkle).\\n<!--\\n# Description\\nIn an array ```A``` containing only 0s and 1s, a *```K```-bit flip* consists of choosing a (contiguous) subarray of length ```K``` and simultaneously changing every 0 in the subarray to 1, and every 1 in the subarray to 0.\\n\\nReturn the minimum number of ```K```-bit flips required so that there is no 0 in the array.  If it is not possible, return ```-1```.\\n## Example\\n```\\nInput: A = [0,0,0,1,0,1,1,0], K = 3\\nOutput: 3\\n```\\n![image](https://assets.leetcode.com/users/votrubac/image_1550551964.png)\\n# Coding Practice\\nTry solving this problem before moving on to the solutions. It is available on LeetCode Online Judge: [Minimum Number of K Consecutive Bit Flips](https://leetcode.com/problems/minimum-number-of-k-consecutive-bit-flips/). Also, as you read through a solution, try implementing it yourself.\\n\\nLeetCode is my favorite destinations for algorithmic problems. It has 987 problems and counting, with test cases to validate the correctness, as well as computational and memory complexity. There is also a large community discussing different approaches, tips and tricks. \\n-->\\n# Intuition 1\\nJust want to share my thought process; I am sure that there is a formal proof somewhere.\\n1. Since K is fixed, it does not make sense to do the flip for any given index more than once. It\\'s a XOR operation, even flips will be equal to zero flips, odd flips will be equal to one flip. So, there could be up to ```n - K``` flips.\\n2. Since it\\'s a XOR operation, we can do flips in any order.\\n3. Say we start do flips left to right. That means that, when we encounter zero, we have no choice but flip.\\n\\nAt this point, this intuition is sound enough to try a greedy approach.\\n## Na\\xEFve Greedy Solution\\nGo through the array and flip K elements when encounter zero. Return ```-1``` if you cannot do K flips.\\n```\\nint minKBitFlips(vector<int>& A, int K, int res = 0) {\\n  for (auto i = 0; i < A.size(); ++i) {\\n    if (A[i] != 1) {\\n      if (i + K - 1 >= A.size()) return -1;\\n      for (auto j = i; j < i + K; ++j) A[j] = !A[j];\\n      ++res;\\n    }\\n  }\\n  return res;\\n}\\n```\\n### Complexity Analysis\\nThe time complexity of this solution is *O(n * K)*, where *n* is the length of ```A```. This solution is not accepted by the online judge.\\n\\n**Update:** this solution is accepted by OJ with the ~5,000 ms runtime (vs. < 100 ms for the solutions below). So, I could have gotten lucky during the contest!\\n# Intuition 2\\nSince we are doing XOR operation, even flips will be equal to zero flips, odd flips will be equal to one flip. So, instead of modifying K bits every time we encounter zero, we can just track the current number of flips.\\n## Linear Solution\\nHere, we are using a queue to track flips. When we \\'flip\\', we put the end index of our flip (```i + K - 1```) into our queue. The size of the queue will indicate number of flips; we also remove past \\'flips\\' from our queue.\\n```\\nint minKBitFlips(vector<int>& A, int K, int res = 0) {\\n  queue<int> flips;\\n  for (auto i = 0; i < A.size(); ++i) {\\n    if (A[i] != (flips.size() % 2 ? 0 : 1)) {\\n      ++res;\\n      flips.push(i + K - 1);\\n    }\\n    if (!flips.empty() && flips.front() <= i) flips.pop();\\n  }\\n  return flips.empty() ? res : -1;\\n}\\n```\\n### Complexity Analysis\\nThe time complexity of this solution is *O(n)*, and the memory complexity is *O(K)*.\\n## Constant Memory Solution\\nInstead of using the queue, we can track the total number of flips, and use the source array to mark flips with negative values.\\n\\nNote that we restore original values after the processing, so the source array is not changed.\\n```\\nint minKBitFlips(vector<int>& A, int K, int res = 0, int flips = 0) {\\n  for (auto i = 0; i < A.size(); ++i) {\\n    if (A[i] == flips % 2) {\\n      if (i > A.size() - K) return -1;\\n      ++res, ++flips, A[i] -= 2;\\n    }\\n    if (i >= K - 1 && A[i - K + 1] < 0) --flips, A[i - K + 1] += 2;\\n  }\\n  return res;\\n}\\n```\\n### Complexity Analysis\\nThe time complexity of this solution is *O(n)*, and the memory complexity is *O(1)*.",
                "solutionTags": [],
                "code": "```A```\n```K```\n```K```\n```K```\n```-1```\n```\\nInput: A = [0,0,0,1,0,1,1,0], K = 3\\nOutput: 3\\n```\n```n - K```\n```-1```\n```\\nint minKBitFlips(vector<int>& A, int K, int res = 0) {\\n  for (auto i = 0; i < A.size(); ++i) {\\n    if (A[i] != 1) {\\n      if (i + K - 1 >= A.size()) return -1;\\n      for (auto j = i; j < i + K; ++j) A[j] = !A[j];\\n      ++res;\\n    }\\n  }\\n  return res;\\n}\\n```\n```A```\n```i + K - 1```\n```\\nint minKBitFlips(vector<int>& A, int K, int res = 0) {\\n  queue<int> flips;\\n  for (auto i = 0; i < A.size(); ++i) {\\n    if (A[i] != (flips.size() % 2 ? 0 : 1)) {\\n      ++res;\\n      flips.push(i + K - 1);\\n    }\\n    if (!flips.empty() && flips.front() <= i) flips.pop();\\n  }\\n  return flips.empty() ? res : -1;\\n}\\n```\n```\\nint minKBitFlips(vector<int>& A, int K, int res = 0, int flips = 0) {\\n  for (auto i = 0; i < A.size(); ++i) {\\n    if (A[i] == flips % 2) {\\n      if (i > A.size() - K) return -1;\\n      ++res, ++flips, A[i] -= 2;\\n    }\\n    if (i >= K - 1 && A[i - K + 1] < 0) --flips, A[i - K + 1] += 2;\\n  }\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 240086,
                "title": "share-my-o-n-c-solution-with-proof-and-explanation",
                "content": "---\\n## 1. Problem\\n\\n---\\nIn an array ```A``` containing only 0s and 1s, a *```K```*-bit flip consists of choosing a (contiguous) subarray of length ```K``` and simultaneously changing every 0 in the subarray to 1, and every 1 in the subarray to 0.\\n\\nReturn the minimum number of ```K```-bit flips required so that there is no 0 in the array.  If it is not possible, return ```-1```.\\n\\n**Example 1:**\\n```\\nInput: A = [0,1,0], K = 1\\nOutput: 2\\nExplanation: Flip A[0], then flip A[2].\\n```\\n\\n**Example 2:**\\n```\\nInput: A = [1,1,0], K = 2\\nOutput: -1\\nExplanation: No matter how we flip subarrays of size 2, we can\\'t make the array become [1,1,1].\\n```\\n\\n**Example 3:**\\n```\\nInput: A = [0,0,0,1,0,1,1,0], K = 3\\nOutput: 3\\nExplanation:\\nFlip A[0],A[1],A[2]: A becomes [1,1,1,1,0,1,1,0]\\nFlip A[4],A[5],A[6]: A becomes [1,1,1,1,1,0,0,0]\\nFlip A[5],A[6],A[7]: A becomes [1,1,1,1,1,1,1,1]\\n```\\n**Note:**\\n* 1 <= A.length <= 30000\\n* 1 <= K <= A.length\\n\\n---\\n## 2. Thinking process\\n\\n---\\n#### 2.1 Analysis\\n\\n---\\n\\nThe problem is complicated at first glance.\\nAs a ```K```-bit flip is applied on a length-K contiguous subarray of A, if the size of array A is **N**, and the **subarray starts at index i (0 \\u2264 i \\u2264 N- K)**, **i** can be used for specifying such a flip.\\n\\nIn this way, \\n>#### **A flip sequence can be defined by an index sequence**.\\n\\nIn **Example 3**, \\n```\\nFlip A[0],A[1],A[2]: A becomes [1,1,1,1,0,1,1,0]\\nFlip A[4],A[5],A[6]: A becomes [1,1,1,1,1,0,0,0]\\nFlip A[5],A[6],A[7]: A becomes [1,1,1,1,1,1,1,1]\\n```\\nthe sequence of index is **{0, 4, 5}**.\\n\\n---\\n#### 2.2 Order invariance\\n\\n---\\nIn **Example 3**, if the sequence of index is changed to **{4, 0, 5}**, what will happen?\\n```\\nFlip A[4],A[5],A[6]: A becomes [0,0,0,1,1,0,0,0]\\nFlip A[0],A[1],A[2]: A becomes [1,1,1,1,1,0,0,0]\\nFlip A[5],A[6],A[7]: A becomes [1,1,1,1,1,1,1,1]\\n```\\nThe final result is as same as the one with sequence **{0, 4, 5}**!\\n\\n---\\n**Property A:**\\n>#### **The result is independent of the order of the flip sequence.**\\n\\n\\n**Proof:**\\n\\nIf the flip sequence is **{a0, a1, a2, ... , ap}**, and the original array A is changed to A\\',\\n\\nFor **any A[i] (0 \\u2264 i \\u2264 N - K)** in A, if the **total count of flip on A[i] is c[i]**, when the order of flip sequence changes, **c[i] won\\'t change**.\\n\\nThat is to say\\n\\n>#### The corresponding A\\'[i] and the array A\\' will not change. Proved!\\n\\n---\\n#### 2.3 Parity invariance\\n\\n---\\nIn **Example 3**, if the sequence of index is changed to **{0, 1, 1, 4, 4, 4, 5}**, what will happen?\\n```\\nFlip A[0],A[1],A[2]: A becomes [1,1,1,1,0,1,1,0]\\nFlip A[1],A[2],A[3]: A becomes [1,0,0,0,0,1,1,0]\\nFlip A[1],A[2],A[3]: A becomes [1,1,1,1,0,1,1,0]\\nFlip A[4],A[5],A[6]: A becomes [1,1,1,1,1,0,0,0]\\nFlip A[4],A[5],A[6]: A becomes [1,1,1,1,0,1,1,0]\\nFlip A[4],A[5],A[6]: A becomes [1,1,1,1,1,0,0,0]\\nFlip A[5],A[6],A[7]: A becomes [1,1,1,1,1,1,1,1]\\n```\\nThe final result is as same as the one with sequence **{0, 4, 5}**!\\n\\n---\\n**Property B:**\\n>#### In the flip sequence, the result is **ONLY** related to the **parity of count of index\\'s appearance**.\\n\\n**Proof:**\\nIf an **index p (0 \\u2264 i \\u2264 N - K) appears in the flip sequence q times**, and the **total count of flip on A[i] is c[i]**, \\n**q will be added to the total count of flip c[i] (p \\u2264 i < p + K).**\\n\\nIn a single flip,\\n>#### If A[i] = 0, it will be flipped to 1.\\n>#### If A[i] = 1, it will be flipped to 0.\\n\\nSo, after **q flips on index p**,\\n>#### If q is even , A[i] will keep its value.\\n>#### If q is odd , A[i] will be flipped.\\n\\n---\\n#### 2.4 Minimization\\n\\n---\\nThe problem is to find the minimum size of the flip sequence that removes all zeros in A.\\n\\nIf such a flip sequence exists, \\n\\nby applying **Property A in Section 2.2**,\\n>#### The sequence can be **sorted by index in ascending order**.\\n\\nAfter sorting, in order to **minimize the sequence\\'s size**, by applying **Property B in Section 2.3**,\\n\\n>#### There are only 2 choices on each index - **appear ONLY once or don\\'t appear**.\\n\\nNow, every index in the sequence is **unique**.\\n\\n---\\n#### 2.5 Generate the sequence\\n\\n---\\nAs mentioned in Section 2.4, every index sequence **S** can be simplified to a new sequence **S\\'**.\\n\\n>#### All indexes in S\\' are **in ascending order and unique**.\\n\\nAs indexes are in ascending order, \\n> #### **The later flip with larger index can\\'t change the value at current index.**\\n\\nwhich means,\\n\\nIf **A[0] = 0**, and **0 is NOT in the sequence**, **A[0] MUST equals to 0 in the final result**.\\n\\nIf **A[0] = 1**, and **0 is in the sequence**, **A[0] MUST equals to 0 in the final result**.\\n\\n---\\nSince **the result MUST contains no 0**, when **processing index 0**\\n\\n* **If A[0] = 0**, **0 MUST be in the sequence**, **A[0], A[1], ..., A[K - 1]** is **flipped**.\\n* **If A[0] = 1**, **0 MUST NOT be in the sequence**, **A[0], A[1], ..., A[K - 1]** is **NOT flipped**.\\n\\n**After index 0 is processed, index 1 should be processed similarly**.\\n\\n---\\n## 3. Algorithm\\n\\n---\\n#### 3.1 Trivial solution\\n\\n---\\nAs discussed in Section 2.5, the algorithm is a dual-cycle.\\n\\n**Initially, the total flip count c equals to 0.**\\n- **Outer Loop:** iterate **index i** from **0 to N - K**.\\n   - If **A[i] = 0**, \\n       - **Inner Loop:** **flip A[i], A[i + 1], ..., A[i + K - 1]**. \\n       - **Set c = c + 1**.\\n   - Else, ignore.\\n- **After processing**, check the **remain elements in A**,\\n  - If **all elements are 1**, **return c**.\\n  - **Else**, **return -1**.\\n\\nFor example,\\n```\\nInput: A = [0,1,0,0,0,0,0,0], K = 3\\ni = 0, A[i] = 0, flip, A = [1,0,1,0,0,0,0,0].\\ni = 1, A[i] = 0, flip, A = [1,1,0,1,0,0,0,0].\\ni = 2, A[i] = 0, flip, A = [1,1,1,0,1,0,0,0].\\ni = 3, A[i] = 0, flip, A = [1,1,1,1,0,1,0,0].\\ni = 4, A[i] = 0, flip, A = [1,1,1,1,1,0,1,0].\\ni = 5, A[i] = 0, flip, A = [1,1,1,1,1,1,0,1].\\noutput: -1\\n```\\nAs shown above, the time complexity is O(NK) in the worst case.\\n\\n---\\n3.2 Optimized solution\\n\\n---\\n\\nIn Section 3.1, there are too many flip operations in the trivial solution.\\n\\nAs proved in Section 2.3, since the indexes are processed in ascending order, \\n\\n>#### **the final value of A[i]** is **ONLY determined by the parity of flip count on A[i]**.\\n\\nTo optimize the solution, \\na queue is used to save the biggest index of the flipped contiguous subarray.\\n\\nThe queue\\'s size is the flip count of A[i].\\n\\n---\\n\\nThe algorithm is optimized to a one-pass solution.\\n**Initially, the total flip count c equals to 0. The queue Q is empty.**\\n- **Loop:** iterate index i from **0 to N - 1**.\\n   - If **Q\\'s size** is **even**, **change A[i] (0 to 1, 1 to 0)**.\\n   - Else, **DON\\'T change A[i]**.\\n   - If **A[i] = 0, put i + K - 1 to Q**. **Set c = c + 1**.\\n   - Else, ignore.\\n   - If **Q is NOT empty and A[i] = the front element in Q**, **pop from Q**.\\n- **After processing**,\\n  - **If Q is empty, return c**.\\n  - **Else, return -1**.\\n\\n---\\n## 4. Complexity Analysis\\n\\n---\\n\\n#### 4.1 Time complexity\\n\\n---\\n\\nAs shown in Section 3.2, the number of iteration is **N**.\\n\\n>#### The time complexity is **O(N)**.\\n\\n---\\n\\n#### 4.2 Space complexity\\n\\n---\\n\\nA queue is used to save the indexes, \\n\\n>#### The space complexity is **O(N)**.\\n\\n---\\n## 5. Code\\n\\n---\\n```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& A, int K) {\\n        int ans = 0;\\n        int size = A.size();\\n        queue<int> record;\\n        for(int i = 0; i < size; i++)\\n        {\\n            int pivot = record.size() % 2 == 0 ? A[i] : 1 - A[i];\\n            if(pivot == 0)\\n            {\\n                ans++;\\n                record.push(i + K - 1);\\n            }\\n            if(!record.empty() && i == record.front()) record.pop();\\n        }\\n        return record.empty() ? ans : -1;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```A```\n```K```\n```K```\n```K```\n```-1```\n```\\nInput: A = [0,1,0], K = 1\\nOutput: 2\\nExplanation: Flip A[0], then flip A[2].\\n```\n```\\nInput: A = [1,1,0], K = 2\\nOutput: -1\\nExplanation: No matter how we flip subarrays of size 2, we can\\'t make the array become [1,1,1].\\n```\n```\\nInput: A = [0,0,0,1,0,1,1,0], K = 3\\nOutput: 3\\nExplanation:\\nFlip A[0],A[1],A[2]: A becomes [1,1,1,1,0,1,1,0]\\nFlip A[4],A[5],A[6]: A becomes [1,1,1,1,1,0,0,0]\\nFlip A[5],A[6],A[7]: A becomes [1,1,1,1,1,1,1,1]\\n```\n```K```\n```\\nFlip A[0],A[1],A[2]: A becomes [1,1,1,1,0,1,1,0]\\nFlip A[4],A[5],A[6]: A becomes [1,1,1,1,1,0,0,0]\\nFlip A[5],A[6],A[7]: A becomes [1,1,1,1,1,1,1,1]\\n```\n```\\nFlip A[4],A[5],A[6]: A becomes [0,0,0,1,1,0,0,0]\\nFlip A[0],A[1],A[2]: A becomes [1,1,1,1,1,0,0,0]\\nFlip A[5],A[6],A[7]: A becomes [1,1,1,1,1,1,1,1]\\n```\n```\\nFlip A[0],A[1],A[2]: A becomes [1,1,1,1,0,1,1,0]\\nFlip A[1],A[2],A[3]: A becomes [1,0,0,0,0,1,1,0]\\nFlip A[1],A[2],A[3]: A becomes [1,1,1,1,0,1,1,0]\\nFlip A[4],A[5],A[6]: A becomes [1,1,1,1,1,0,0,0]\\nFlip A[4],A[5],A[6]: A becomes [1,1,1,1,0,1,1,0]\\nFlip A[4],A[5],A[6]: A becomes [1,1,1,1,1,0,0,0]\\nFlip A[5],A[6],A[7]: A becomes [1,1,1,1,1,1,1,1]\\n```\n```\\nInput: A = [0,1,0,0,0,0,0,0], K = 3\\ni = 0, A[i] = 0, flip, A = [1,0,1,0,0,0,0,0].\\ni = 1, A[i] = 0, flip, A = [1,1,0,1,0,0,0,0].\\ni = 2, A[i] = 0, flip, A = [1,1,1,0,1,0,0,0].\\ni = 3, A[i] = 0, flip, A = [1,1,1,1,0,1,0,0].\\ni = 4, A[i] = 0, flip, A = [1,1,1,1,1,0,1,0].\\ni = 5, A[i] = 0, flip, A = [1,1,1,1,1,1,0,1].\\noutput: -1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 238538,
                "title": "python-o-n-using-queue-and-how-to-get-rid-of-the-queue",
                "content": "The idea is, as we move through the array, everytime I see a 0, I need to do a k-flip. \\nAs a result of a single k-flip, the k-1 elements to the right are also affected.\\nI use a queue, to keep track of how many valid flips have been executed for the current index.\\nBy maintaining the last index for which a flip is valid, I can easily pop it off, when I pass that index.\\nEssentially this makes, the current size of queue equal to the number of flips the current index has undergone and can determine if its 0 or 1, based on that.\\nSo, if the number of flips is even, and my a[i] == 0, then I need to do one more flip. I add that flip\\'s last index to the queue\\nIn a similar way, if the number of flips is odd, and mu a[i] == 1, then i need to do one more flip.\\n\\nWhen to return -1 ?\\nIf at any point, we see that a necessary k-flip extends beyond the length of the array, we know that this flip cant happen. Hence we can return -1 at that instant.\\n```\\ndef minKBitFlips(self, a: \\'List[int]\\', k: \\'int\\') -> \\'int\\':\\n        q = deque()\\n        res = 0\\n        for i in range(len(a)):\\n            if len(q) % 2 != 0:\\n                if a[i] == 1:\\n                    res += 1\\n                    q.append(i+k-1)\\n            else:\\n                if a[i] == 0:\\n                    res += 1\\n                    q.append(i+k-1)\\n            if q and q[0] == i: q.popleft()\\n            if q and q[-1] >= len(a): return -1\\n        return res\\n```\\n\\n<b>O(1) space: </b>\\nNow that we have the solution using queue, how do we get rid of the queue, and use only O(1) space.\\nThe logic is exactly the same.\\nBut instead of the queue storing the indexes which are endpoints to a k-flip, we use the array itself and use some addon value > 1, that we add to the value at the indexes which were earlier stored in the queue. \\nBecause we dont have the queue, we need an explicit variable flips (this is equivalent to the length of the queue in the previous version).\\nNow, whenever we encounter an a[i] that is >1 , we know that this is an endpoint to a k-flip and reduce the number of flips accordingly.\\n\\nHere is the code, which resemblems the previous version as close as possible, but replaces the portion using the queue with flips and addon\\n\\n[I didnot implement this O(1) version in the contest, but based on other\\'s posted solutions, realized, we can easily get rid of the queue in my original version]\\n\\n```\\ndef minKBitFlips(self, a: \\'List[int]\\', k: \\'int\\') -> \\'int\\':\\n        res = 0\\n        flips = 0\\n        addon = 10\\n        for i in range(len(a)):\\n            if flips % 2 != 0:\\n                if (a[i] - addon) % 2 == 1:\\n                    res += 1\\n                    if i+k-1 >= len(a): return -1\\n                    a[i+k-1] += addon\\n                    flips += 1\\n            else:\\n                if (a[i] - addon) % 2 == 0:\\n                    res += 1\\n                    if i+k-1 >= len(a): return -1\\n                    a[i+k-1] += addon\\n                    flips += 1\\n            if a[i] > 1: \\n                flips -= 1\\n                a[i] -= addon #Restore the array value back\\n        return res\\n```\\n\\nThe same solution, with combining if conditions:\\n\\n```\\ndef minKBitFlips(self, a: \\'List[int]\\', k: \\'int\\') -> \\'int\\':\\n        res = 0\\n        flips = 0\\n        addon = 10\\n        for i in range(len(a)):\\n            if (flips % 2 != 0 and (a[i] - addon) % 2 == 1) or (flips % 2 == 0 and (a[i] - addon) % 2 == 0):\\n                    res += 1\\n                    if i+k-1 >= len(a): return -1\\n                    a[i+k-1] += addon\\n                    flips += 1\\n            if a[i] > 1: \\n                flips -= 1\\n                a[i] -= addon\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\ndef minKBitFlips(self, a: \\'List[int]\\', k: \\'int\\') -> \\'int\\':\\n        q = deque()\\n        res = 0\\n        for i in range(len(a)):\\n            if len(q) % 2 != 0:\\n                if a[i] == 1:\\n                    res += 1\\n                    q.append(i+k-1)\\n            else:\\n                if a[i] == 0:\\n                    res += 1\\n                    q.append(i+k-1)\\n            if q and q[0] == i: q.popleft()\\n            if q and q[-1] >= len(a): return -1\\n        return res\\n```\n```\\ndef minKBitFlips(self, a: \\'List[int]\\', k: \\'int\\') -> \\'int\\':\\n        res = 0\\n        flips = 0\\n        addon = 10\\n        for i in range(len(a)):\\n            if flips % 2 != 0:\\n                if (a[i] - addon) % 2 == 1:\\n                    res += 1\\n                    if i+k-1 >= len(a): return -1\\n                    a[i+k-1] += addon\\n                    flips += 1\\n            else:\\n                if (a[i] - addon) % 2 == 0:\\n                    res += 1\\n                    if i+k-1 >= len(a): return -1\\n                    a[i+k-1] += addon\\n                    flips += 1\\n            if a[i] > 1: \\n                flips -= 1\\n                a[i] -= addon #Restore the array value back\\n        return res\\n```\n```\\ndef minKBitFlips(self, a: \\'List[int]\\', k: \\'int\\') -> \\'int\\':\\n        res = 0\\n        flips = 0\\n        addon = 10\\n        for i in range(len(a)):\\n            if (flips % 2 != 0 and (a[i] - addon) % 2 == 1) or (flips % 2 == 0 and (a[i] - addon) % 2 == 0):\\n                    res += 1\\n                    if i+k-1 >= len(a): return -1\\n                    a[i+k-1] += addon\\n                    flips += 1\\n            if a[i] > 1: \\n                flips -= 1\\n                a[i] -= addon\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1052752,
                "title": "java-o-n-solution-step-by-step-explanation",
                "content": "## Idea behind the solution\\nWe approach the solution in a Greedy way, **that is as soon as we see a 0 we will flip it to 1 and we will skip if we encounter a 1**.\\n\\nLet\\'s say we flip `A[i]=0` to 1, this means the next K-1 elements `A[i+1], A[i+2]....A[i+k-1]` will be flipped as well. \\nNow lets say after the flip, `A[i+4]=0  (K>4)`. It would mean it was initially 1 and now it needs to be flipped again.  So, as we make the second flip at `A[i+4]` \\xA0the elements`A[i+4+1], A[i+4+2]....A[i+4+k-1]` will be flipped. \\nAs we observe, elements  `A[i+4]` to `A[i+k-1]` will undergo two flips. \\n\\nAnd if an element that was initially 0 undergoes two flips it will need to be flipped again to make it 1. If an element that was initially 1 undergoes one flip it will need to be flipped once more to make it 1. So extending this further,\\n\\n**if number of flips for 0 is even, we require a flip \\n& if number of flips for 1 is odd, we require a flip**\\n\\n*Next, we need to know the number of flips for a given index*. To do this we maintain a queue and we keep adding the index where the last element is to be flipped. As we reach that index, we remove the index from the queue. \\n\\nLets say for `k=6`, and at `i=3` we are doing a flip, queue will contain `[8]`\\nNext at `i=6` we are doing a flip the queue becomes `[8, 11]`\\n8 will be popped from the queue when the iteration counter reaches at index 8 and likewise for 12, this means for `i=6` to `i=8` there will be two flips one which was started at `i=3` and another at `i=6`.\\n**This indicates, the length of queue will hold the number of flips for any index.**\\n\\n## Algorithm:\\n1. We declare a queue which is the flip queue\\n2. The `res` variable will hold the number of total flips done at any point\\n3. We iterate from 0 till the length of the Array, and do the following\\n\\t3.1 If we encounter a 0 and the no. of flips is even OR we encounter a 1 and the no. of flips is odd we \\n           increment the result and mark the end `i+k-1` in the queue\\n\\t3.2 If the last index of the flip > n we return  -1 because then its not possible to achieve the final result \\n           as dont have enough values to flip\\n\\t3.3 We remove the head of the queue as we reach the last index of the flip\\n\\n## Code:\\n```\\n    public int minKBitFlips(int[] A, int K) {\\n        int n = A.length;\\n        Queue<Integer> fq = new LinkedList<>();\\n        int res = 0;\\n        \\n        for(int i=0; i<n; i++) {\\n            if ((A[i] == 0 && fq.size()%2 == 0) || (A[i]==1 && fq.size()%2 == 1)) {\\n                res++;\\n                if (i+K > n) return -1;\\n                fq.add(i+K-1);\\n            } //fi\\n            if (fq.size() > 0 && fq.peek() == i) {\\n                fq.remove();\\n            }\\n        }//for\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int minKBitFlips(int[] A, int K) {\\n        int n = A.length;\\n        Queue<Integer> fq = new LinkedList<>();\\n        int res = 0;\\n        \\n        for(int i=0; i<n; i++) {\\n            if ((A[i] == 0 && fq.size()%2 == 0) || (A[i]==1 && fq.size()%2 == 1)) {\\n                res++;\\n                if (i+K > n) return -1;\\n                fq.add(i+K-1);\\n            } //fi\\n            if (fq.size() > 0 && fq.peek() == i) {\\n                fq.remove();\\n            }\\n        }//for\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 238972,
                "title": "backtracking-logical-thinking",
                "content": "For an non-one element, we must flip it.\\nWe won\\'t do the same type of flip for twice. And the order of flips doesn\\'t matter, that is, they are commutative.\\nSo we always start with the first non-one element.\\n\\nThe problem is similar to [465. Optimal Account Balancing](https://leetcode.com/problems/optimal-account-balancing/discuss/130895/Recursion-Logical-Thinking)\\n****\\n```\\n    public int minKBitFlips(int[] A, int K) {\\n        return minKBitFlipsAfter(getFirstNonOne(A), A, K);\\n    }\\n\\n    private int minKBitFlipsAfter(int start, int[] A, int K) {\\n        if (start == A.length) return 0; // Flip all 0s.\\n        if (start + K > A.length) return -1; // Not enough elements to flip.\\n\\n        // Flip [start, start + k - 1].\\n        for (int i = start; i < start + K; i++) {\\n            A[i] = 1 - A[i];\\n        }\\n\\n        int firstNonOne = getFirstNonOne(A);\\n        int rest = minKBitFlipsAfter(firstNonOne, A, K);\\n        if (rest == -1) return -1; // Cannot flip.\\n        else return 1 + rest;\\n    }\\n\\n    private int getFirstNonOne(int[] A) {\\n        for (int i = 0; i < A.length; i++) {\\n            if (A[i] != 1) return i;\\n        }\\n        return A.length;\\n    }\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!\\n",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\n    public int minKBitFlips(int[] A, int K) {\\n        return minKBitFlipsAfter(getFirstNonOne(A), A, K);\\n    }\\n\\n    private int minKBitFlipsAfter(int start, int[] A, int K) {\\n        if (start == A.length) return 0; // Flip all 0s.\\n        if (start + K > A.length) return -1; // Not enough elements to flip.\\n\\n        // Flip [start, start + k - 1].\\n        for (int i = start; i < start + K; i++) {\\n            A[i] = 1 - A[i];\\n        }\\n\\n        int firstNonOne = getFirstNonOne(A);\\n        int rest = minKBitFlipsAfter(firstNonOne, A, K);\\n        if (rest == -1) return -1; // Cannot flip.\\n        else return 1 + rest;\\n    }\\n\\n    private int getFirstNonOne(int[] A) {\\n        for (int i = 0; i < A.length; i++) {\\n            if (A[i] != 1) return i;\\n        }\\n        return A.length;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 846869,
                "title": "python-greedy-queue",
                "content": "```html5\\n<b>Time Complexity: O(n)\\nSpace Complexity: O(k)</b>\\n```\\n\\uD83E\\uDD14 **Intuition**\\nConsider reading array **A** from left to right.  \\nWhenever **A[i] == 0** we have to flip **A[i:k]** otherwise we end up having a zero at **A[i]**.  \\nWhenever **A[i] == 1** we do not flip any bits, otherwise we end up having a zero at **A[i]**.  \\nThis means that if a solution exists, we can find the minimum number of bit flips by greedily flipping **A[i:k]** any time **A[i] == 0**.  \\n\\n\\uD83D\\uDCAA**Brute Force Approach O(k&middot;n) - TLE**\\n```python\\ndef minKBitFlips(self, A: List[int], k: int) -> int:\\n\\n\\tflips = 0\\n\\tfor i in range(len(A)-k+1):\\n\\t\\tif A[i] == 0:\\n\\t\\t\\tflips += 1\\n\\t\\t\\tfor j in range(i, i+k): # time consuming\\n\\t\\t\\t\\tA[j] = 1 - A[j]\\n\\n\\treturn flips if all(A[j] == 1 for j in range(i,len(A))) else -1\\n```\\n\\uD83D\\uDC22**Why TLE?**\\nThe inner for-loop updates bits **i** to **i+k** every time bit **i** is flipped.  This is unnecessarily time consuming.  \\nConsider the case where **k = 1000** and **A = [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, ...]**.  \\nWe would have to update 1000 bits every step resulting in **O(k&middot;n)** time complexity.   \\n\\nIt is not necessary to update **A** every time we flip a bit.  \\nWe do not care that every bit in **A** is correctly marked as a **1** or a **0** at every step.  \\nWhat we do care about is knowing how many times bit **i** was flipped.  \\nIf **i** was flipped an **even** number of times, then **A[i]** remains the same, but if **i** was flipped an **odd** number of times **A[i] = 1 - A[i]**.  \\n\\n\\u2714\\uFE0F**Optimization: Use a queue to keep track of how many times each bit was flipped.**\\n*Numbers match the annotations in code.*\\n**(#1)** Every time a bit is flipped, append **i+k-1** to the queue.  This tells us that all bits from **i** to **i+k-1** (inclusive) have been flipped.  \\n**(#2)** To determine if a bit has been flipped, **check if the length of the queue is odd**.  The length of the queue tells us how many times bit **i** was flipped.\\n**(#3)** Remove all flips that occurred before **i** from the queue.  \\n**(#4)** It is impossible to not flip any bits that occur after **len(A) - k**.\\n\\n```python\\ndef minKBitFlips(self, A: List[int], k: int) -> int:\\n\\n\\tlatest_possible_flip = len(A) - k       # 4\\n\\tflipped = collections.deque()\\n\\tflips = 0\\n\\tfor i in range(len(A)):\\n\\t\\tif flipped and (flipped[0] < i):    # 3\\n\\t\\t\\tflipped.popleft()\\n\\t\\tif len(flipped)&1 == A[i]:          # 2\\n\\t\\t\\tif i <= latest_possible_flip:   # 4\\n\\t\\t\\t\\tflips += 1\\n\\t\\t\\t\\tflipped.append(i+k-1)       # 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn -1\\n\\treturn flips\\n```\\n",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```html5\\n<b>Time Complexity: O(n)\\nSpace Complexity: O(k)</b>\\n```\n```python\\ndef minKBitFlips(self, A: List[int], k: int) -> int:\\n\\n\\tflips = 0\\n\\tfor i in range(len(A)-k+1):\\n\\t\\tif A[i] == 0:\\n\\t\\t\\tflips += 1\\n\\t\\t\\tfor j in range(i, i+k): # time consuming\\n\\t\\t\\t\\tA[j] = 1 - A[j]\\n\\n\\treturn flips if all(A[j] == 1 for j in range(i,len(A))) else -1\\n```\n```python\\ndef minKBitFlips(self, A: List[int], k: int) -> int:\\n\\n\\tlatest_possible_flip = len(A) - k       # 4\\n\\tflipped = collections.deque()\\n\\tflips = 0\\n\\tfor i in range(len(A)):\\n\\t\\tif flipped and (flipped[0] < i):    # 3\\n\\t\\t\\tflipped.popleft()\\n\\t\\tif len(flipped)&1 == A[i]:          # 2\\n\\t\\t\\tif i <= latest_possible_flip:   # 4\\n\\t\\t\\t\\tflips += 1\\n\\t\\t\\t\\tflipped.append(i+k-1)       # 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn -1\\n\\treturn flips\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 238557,
                "title": "java-clean-o-n-k-greedy-solution",
                "content": "This solution use a function flip() to literally flip array for K bits.\\nApplying Greedy algorithm, we go through the array, and once we see a \"0\", will perform a flip.\\n```\\nclass Solution {\\n    private void flip(int[]A,int K,int i){\\n        for(int j=i;j<i+K;j++){\\n            A[j]=1-A[j];\\n        }\\n    }\\n    public int minKBitFlips(int[] A, int K) {\\n        int cnt=0;\\n        for(int i=0;i<A.length;i++){\\n            if(A[i]==0){\\n                if(i+K>A.length)return -1;\\n                flip(A,K,i);\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private void flip(int[]A,int K,int i){\\n        for(int j=i;j<i+K;j++){\\n            A[j]=1-A[j];\\n        }\\n    }\\n    public int minKBitFlips(int[] A, int K) {\\n        int cnt=0;\\n        for(int i=0;i<A.length;i++){\\n            if(A[i]==0){\\n                if(i+K>A.length)return -1;\\n                flip(A,K,i);\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1751931,
                "title": "c-using-queue-solution-explained-clrearly-inutuitions-explained",
                "content": "\\n            \\n           \\n\\t\\t    int minKBitFlips(vector<int>& A, int K) {\\n            int n = A.size();\\n           /*Keeps track of the last index of a k-window flip\\n            The size of the queue at anytime gives us the total number of flips that\\n            have happened within any k-interval*/\\n            queue<int> isflipped; //Space is O(K) max\\n            int count = 0; //min k-bit flips\\n\\t\\t   for(int i = 0; i < n; i++){ //O(N)\\n              //If current index is 0, then we need to process it/do sth about it\\n              if(A[i] == 0){\\n                \\n                /*If our queue is empty or queue is even size\\n                (i.e our current index has been flipped even # of times , thus ending back at state 0), \\n                then we need to flip this 0 to a 1*/\\n                if(isflipped.empty() || isflipped.size() % 2 == 0){\\n                  count++; //Flip it\\n                  /*Populate the queue with the index of the end of this k interval that was flipped*/\\n                  isflipped.push(i + K - 1);\\n                }\\n                /*Lets say we are here, that means our original element is a zero and the queu size is\\n                odd sized which means that this 0 has been flipped odd # of times, giving us the result 1.\\n                So we do nothing since we know the element has been flipped to 1 already*/\\n              }else{ //A[i] == 1\\n                /*If A[i] == 1, we need to process it only in one case*/\\n                if(isflipped.size() % 2 != 0){\\n                  /*this means a \\'1\\' has been flipped odd # of times , thus ending at state \\'0\\', \\n                  we need to flip this then*/\\n                  count++;\\n\\n                  /*Populate the queue with the index of the end of this k interval that was flipped*/\\n                  isflipped.push(i + K - 1);\\n                }\\n              }\\n              \\n              //Anytime we are done with a interval, we pop the index out of the queue\\n              //MISTAKE: Make sure to check the q is emoty or not before popping off the value\\n              if(!isflipped.empty() && i >= isflipped.front()) isflipped.pop();\\n            }\\n            \\n            /*Return the minimum number of K-bit flips required so that there is no 0 in the array.  If it is not possible, return -1*/\\n            return isflipped.empty() ? count : -1;\\n          }",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "\\n            \\n           \\n\\t\\t    int minKBitFlips(vector<int>& A, int K) {\\n            int n = A.size();\\n           /*Keeps track of the last index of a k-window flip\\n            The size of the queue at anytime gives us the total number of flips that\\n            have happened within any k-interval*/\\n            queue<int> isflipped; //Space is O(K) max\\n            int count = 0; //min k-bit flips\\n\\t\\t   for(int i = 0; i < n; i++){ //O(N)\\n              //If current index is 0, then we need to process it/do sth about it\\n              if(A[i] == 0){\\n                \\n                /*If our queue is empty or queue is even size\\n                (i.e our current index has been flipped even # of times , thus ending back at state 0), \\n                then we need to flip this 0 to a 1*/\\n                if(isflipped.empty() || isflipped.size() % 2 == 0){\\n                  count++; //Flip it\\n                  /*Populate the queue with the index of the end of this k interval that was flipped*/\\n                  isflipped.push(i + K - 1);\\n                }\\n                /*Lets say we are here, that means our original element is a zero and the queu size is\\n                odd sized which means that this 0 has been flipped odd # of times, giving us the result 1.\\n                So we do nothing since we know the element has been flipped to 1 already*/\\n              }else{ //A[i] == 1\\n                /*If A[i] == 1, we need to process it only in one case*/\\n                if(isflipped.size() % 2 != 0){\\n                  /*this means a \\'1\\' has been flipped odd # of times , thus ending at state \\'0\\', \\n                  we need to flip this then*/\\n                  count++;\\n\\n                  /*Populate the queue with the index of the end of this k interval that was flipped*/\\n                  isflipped.push(i + K - 1);\\n                }\\n              }\\n              \\n              //Anytime we are done with a interval, we pop the index out of the queue\\n              //MISTAKE: Make sure to check the q is emoty or not before popping off the value\\n              if(!isflipped.empty() && i >= isflipped.front()) isflipped.pop();\\n            }\\n            \\n            /*Return the minimum number of K-bit flips required so that there is no 0 in the array.  If it is not possible, return -1*/\\n            return isflipped.empty() ? count : -1;\\n          }",
                "codeTag": "Unknown"
            },
            {
                "id": 3659634,
                "title": "c-sliding-window-range-addition-explained",
                "content": "# Pre-requisite\\n- Print modified array after multiple array range increment operations\\n- Range addition (Leetcode)\\n\\n# Intuition\\n- We will process given array window by window of length k. \\n- We iterate the given array from left to right and at any point of time, at ith index if we encouter current bit to be 0, then it should flip from 0 to 1. So we have to flip whole window starting from i and ending at i + k - 1.\\n\\n---\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- After Applying all operation on valid windows (starting from `0th index` till `(n - k)th index`). \\n- We will check that all bits are transferred to 1 or not. If all bit are transferred to 1 then answer will be `ans` or else ans will be `-1`.\\n\\n---\\n# Code Walkthrough\\n- Gives the final bit after \\'flips\\' flips on the bit\\n    - Example: bit = 0, flips = 5 => ans = 1\\n    - Example: bit = 1, flips = 5 => ans = 0\\n    - Example: bit = 0, flips = 4 => ans = 0\\n    - Example: bit = 1, flips = 4 => ans = 1\\n```\\nint finalbit(int bit, int flips)\\n{\\n    if (flips % 2 == 0)\\n        return bit;\\n    return !bit;\\n}\\n```\\n---\\n- pref[i] = for ith index, how many flips we have made\\n```\\nvector<int> pref(n + 1);\\n```\\n---\\n- For any index i, first of all we calculate the flips made on ith index from previous operations\\n- Now, if we have sufficient window (because we can only flip whole window of size \\'k\\' according to given in question), then\\n    - after applying all flips on current bit, if current bit is 1. then we don\\'t need to do any operation.\\n    - if current bit is 0. then we have to apply one operation. And though we have to flip whole window of size k starting from ith index, we will increment flip count in the range i to i + k - 1.\\n\\n```\\n\\nfor (int i = 0; i < n; i++)\\n{\\n    if (i)\\n        pref[i] += pref[i - 1];\\n\\n    if (i < n - y + 1)\\n    {\\n        int flips = pref[i];\\n        int bit = finalbit(v[i], flips);\\n\\n        if (bit == 1)\\n            continue;\\n\\n        ans++;\\n        pref[i]++;\\n        pref[i + y]--;\\n    }\\n}\\n```\\n---\\n- After applying neccesary operations, we finally check the all bit. \\n- If all bits are 1 then we return ans otherwise it is not possible to make array of all ones, so we return -1.\\n- This portion of the code is not neccesary neither the after vector, it can be computed in the above loop itself. But for the sack of simplicity of the code, i have done it separately.\\n```\\nint cnt = 0;\\nvector<int> after(n);\\nfor (int i = 0; i < n; i++)\\n{\\n    after[i] = finalbit(v[i], pref[i]);\\n    cnt += (after[i] == 1);\\n}\\nreturn cnt == n ? ans : -1;\\n```\\n\\n---\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n---\\n# Full Code\\n```\\nclass Solution {\\npublic:\\n    int finalbit(int bit, int flips)\\n    {\\n        if (flips % 2 == 0)\\n            return bit;\\n        return !bit;\\n    }\\n\\n    int minKBitFlips(vector<int>& v, int y) {\\n        int n = v.size();\\n        vector<int> pref(n + 1);\\n\\n        int ans = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (i)\\n                pref[i] += pref[i - 1];\\n\\n            if (i < n - y + 1)\\n            {\\n                int flips = pref[i];\\n                int bit = finalbit(v[i], flips);\\n\\n                if (bit == 1)\\n                    continue;\\n\\n                ans++;\\n                pref[i]++;\\n                pref[i + y]--;\\n            }\\n        }\\n\\n        int cnt = 0;\\n        vector<int> after(n);\\n        for (int i = 0; i < n; i++)\\n        {\\n            after[i] = finalbit(v[i], pref[i]);\\n            cnt += (after[i] == 1);\\n        }\\n        \\n        return cnt == n ? ans : -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nint finalbit(int bit, int flips)\\n{\\n    if (flips % 2 == 0)\\n        return bit;\\n    return !bit;\\n}\\n```\n```\\nvector<int> pref(n + 1);\\n```\n```\\n\\nfor (int i = 0; i < n; i++)\\n{\\n    if (i)\\n        pref[i] += pref[i - 1];\\n\\n    if (i < n - y + 1)\\n    {\\n        int flips = pref[i];\\n        int bit = finalbit(v[i], flips);\\n\\n        if (bit == 1)\\n            continue;\\n\\n        ans++;\\n        pref[i]++;\\n        pref[i + y]--;\\n    }\\n}\\n```\n```\\nint cnt = 0;\\nvector<int> after(n);\\nfor (int i = 0; i < n; i++)\\n{\\n    after[i] = finalbit(v[i], pref[i]);\\n    cnt += (after[i] == 1);\\n}\\nreturn cnt == n ? ans : -1;\\n```\n```\\nclass Solution {\\npublic:\\n    int finalbit(int bit, int flips)\\n    {\\n        if (flips % 2 == 0)\\n            return bit;\\n        return !bit;\\n    }\\n\\n    int minKBitFlips(vector<int>& v, int y) {\\n        int n = v.size();\\n        vector<int> pref(n + 1);\\n\\n        int ans = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (i)\\n                pref[i] += pref[i - 1];\\n\\n            if (i < n - y + 1)\\n            {\\n                int flips = pref[i];\\n                int bit = finalbit(v[i], flips);\\n\\n                if (bit == 1)\\n                    continue;\\n\\n                ans++;\\n                pref[i]++;\\n                pref[i + y]--;\\n            }\\n        }\\n\\n        int cnt = 0;\\n        vector<int> after(n);\\n        for (int i = 0; i < n; i++)\\n        {\\n            after[i] = finalbit(v[i], pref[i]);\\n            cnt += (after[i] == 1);\\n        }\\n        \\n        return cnt == n ? ans : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 238975,
                "title": "slide-window-o-n-time-o-1-space-no-bit-manipulation-detailed-explanation",
                "content": "Assuming `flippedTime` denotes the flipped time of `A[i]`, if `flippedTime` is even and `A[i]` is 0, or `flippedTime` is odd and `A[i]` is 1, `A[i]` needs to be flipped.\\nSo if `flippedTime%2==A[i]`, `A[i]` needs to be flipped.\\n\\nAssuming that we have a window from `i-K` to `i-1` closed interval (when i<K, just [0, K-1] ), we use `flippedTime` to caculate the flipped time inside this window, i.e. [ i-K, i-1 ]\\n\\nWhen `i>=K`, the elements which can influence `A[i]` is elements whoes index is from i-K-1 to  i-1, so if A[i-k] has flipped, we make `flippedTime` -1, now `flippedTime` denotes the flipped time of elements in [i-K+1, i-1], which is also the flipped time of A[i].\\n\\nIn the code, I make A[j]=2 if A[j] should flip, therefore it is easy to check whether A[i-K] flipped when it comes to A[i].\\n\\n----\\n\\u5047\\u8BBE\\u7528 flippedTime \\u6765\\u8868\\u793A A[i] \\u88AB\\u4E4B\\u524D\\u5143\\u7D20\\u7FFB\\u8F6C\\u6240\\u5F71\\u54CD\\u7684\\u6B21\\u6570\\uFF0C \\u90A3\\u4E48\\u5982\\u679C flippedTime \\u662F\\u5076\\u6570\\u4E14 A[i]=0, \\u6216\\u8005 flippedTime \\u662F\\u5947\\u6570\\u4E14 A[i]=1\\uFF0C\\u90A3\\u4E48 A[i] \\u5C31\\u9700\\u8981\\u88AB\\u7FFB\\u8F6C\\u3002\\n\\u7528\\u4EE3\\u7801\\u8868\\u793A\\u4E3A\\u5982\\u679C `flippedTime%2==A[i]`\\uFF0C\\u90A3\\u4E48 A[i] \\u9700\\u8981\\u88AB\\u7FFB\\u8F6C\\u3002\\n\\n\\u56E0\\u4E3A\\u6211\\u4EEC\\u6BCF\\u6B21\\u90FD\\u8981\\u5BF9\\u957F\\u5EA6\\u4E3A K \\u7684\\u533A\\u95F4\\u8FDB\\u884C\\u7FFB\\u8F6C\\uFF0C\\u5047\\u8BBE\\u5B58\\u5728\\u4E00\\u4E2A window \\u5728\\u95ED\\u533A\\u95F4 [i-K, i-1]\\uFF0C\\u5F53 i<K \\u65F6\\uFF0C\\u5373\\u4E3A [0, K-1]\\u3002\\u7528 flippedTime \\u8BA1\\u7B97\\u5728\\u8BE5 window \\u91CC\\u53D1\\u751F\\u7FFB\\u8F6C\\u7684\\u6B21\\u6570\\u3002\\n\\n\\u5F53 i>=K \\u65F6\\uFF0C\\u5BF9 A[i] \\u662F\\u5426\\u7FFB\\u8F6C\\u4EA7\\u751F\\u5F71\\u54CD\\u7684\\u5E94\\u8BE5\\u662F\\u5728\\u533A\\u95F4 [i-K+1, i-1]\\u5185\\u7684\\u3002\\u6240\\u4EE5\\u6211\\u4EEC\\u68C0\\u6D4B A[i-k]\\u662F\\u5426\\u53D1\\u751F\\u7FFB\\u8F6C\\uFF0C\\u5982\\u679C A[i-K] \\u7FFB\\u8F6C\\u4E86\\uFF0C\\u90A3\\u4E48\\u5C31\\u628A flippedTime-1\\uFF0C\\u6B64\\u65F6 flippedTime \\u5373\\u4E3A A[i]\\u5728\\u6B64\\u4E4B\\u524D\\u88AB\\u7FFB\\u8F6C\\u7684\\u6B21\\u6570\\u3002\\u8FD9\\u65F6\\u518D\\u5224\\u65AD A[i] \\u662F\\u5426\\u8981\\u88AB\\u7FFB\\u8F6C\\u3002\\n\\n\\u5728\\u4EE3\\u7801\\u4E2D\\uFF0C\\u5982\\u679C A[j] \\u88AB\\u7FFB\\u8F6C\\u4E86\\uFF0C\\u5C31\\u628A\\u5176\\u503C\\u8BBE\\u4E3A2\\uFF0C\\u4FBF\\u4E8E\\u4E4B\\u540E\\u7684\\u68C0\\u6D4B\\u3002\\n\\n----\\n\\u89E3\\u91CA2\\uFF1A\\n1. \\u5728A[i]\\u4E2D\\uFF0C\\u6BCF\\u4E2A\\u5143\\u7D20\\u88AB\\u53CD\\u8F6C\\u7684\\u6B21\\u6570\\u53D7\\u5230\\u5B83\\u4E4B\\u524DK-1\\u4E2A\\u5143\\u7D20\\u7684\\u5F71\\u54CD\\uFF0C\\u6211\\u4EEC\\u8003\\u8651\\u4E00\\u4E2A\\u957F\\u5EA6\\u4E3AK\\u7684window\\uFF0C\\n\\u7528flippedTime\\u8BB0\\u5F55window\\u4E2D\\u7684\\u524DK-1\\u4E2A\\u5143\\u7D20\\u9020\\u6210\\u7684\\u5F71\\u54CD\\u7D2F\\u79EF\\u5230\\u6700\\u540E\\u4E00\\u4E2A\\u5143\\u7D20\\uFF0C\\u5BFC\\u81F4\\u5B83\\u9700\\u8981\\u53CD\\u8F6C\\u7684\\u6B21\\u6570\\u3002\\n\\u7279\\u522B\\u7684\\uFF0C\\u5982\\u679Ci < K\\u65F6\\uFF0C\\u6211\\u4EEC\\u5219\\u8003\\u8651\\u4ECE0\\u5230i\\u7684window\\u3002\\n2. \\u53EF\\u4EE5\\u901A\\u8FC7A[i]\\u548C\\u76F8\\u5E94\\u7684flippedTime\\u5224\\u65AD\\u662F\\u5426\\u9700\\u8981\\u5728A[i]\\u5904\\u8FDB\\u884C\\u53CD\\u8F6C\\u3002\\u5F53A[i] = 0\\u4E14flippedTime\\u5076\\u6570\\uFF0C\\u6216\\u8005\\nA[i] = 1\\u4E14flippedTime\\u5947\\u6570\\uFF0C\\u4EE3\\u8868\\u6B64\\u65F6A[i] = 0\\u3002\\u4EE4A[i] = 2\\u6807\\u8BB0\\u8FD9\\u6B21\\u53CD\\u8F6C\\u3002\\n\\u7528\\u4EE3\\u7801\\u8868\\u793A\\u4E3A\\u5982\\u679C flippedTime%2==A[i]\\uFF0C\\u90A3\\u4E48 A[i] \\u9700\\u8981\\u88AB\\u7FFB\\u8F6C\\u3002\\n3. \\u8BBE\\u7F6Ei\\u4ECE0\\u5F00\\u59CB\\u904D\\u5386\\u5230\\u6700\\u540E\\u4E00\\u4E2A\\u5143\\u7D20\\uFF0C\\u5F53i >= K\\u65F6\\u5411\\u53F3\\u79FB\\u52A8window\\uFF0C\\u5982\\u679CA[i-k]\\u5904\\u6709\\u53CD\\u8F6C\\u6807\\u8BB02\\uFF0C\\nflippedTime\\u9700\\u8981\\u51CF1\\u3002\\n\\n```python\\nclass Solution:\\n    def minKBitFlips(self, A: \\'List[int]\\', K: \\'int\\') -> \\'int\\':\\n        flippedTime=0\\n        count=0 # count the total flipped time\\n        for i in range(len(A)):\\n            if i>=K and A[i-K]==2: \\n                flippedTime-=1\\n                \\n            if (flippedTime %2) == A[i]:\\n                if i+K>len(A):\\n                    return -1\\n                A[i]=2\\n                flippedTime+=1\\n                count+=1\\n                \\n        return count\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minKBitFlips(self, A: \\'List[int]\\', K: \\'int\\') -> \\'int\\':\\n        flippedTime=0\\n        count=0 # count the total flipped time\\n        for i in range(len(A)):\\n            if i>=K and A[i-K]==2: \\n                flippedTime-=1\\n                \\n            if (flippedTime %2) == A[i]:\\n                if i+K>len(A):\\n                    return -1\\n                A[i]=2\\n                flippedTime+=1\\n                count+=1\\n                \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1383003,
                "title": "c-o-n-time-using-line-sweep",
                "content": "Approach:\\nThe approach is very similar to:\\nQuestion: https://leetcode.com/problems/jump-game-vii/\\nSolution: https://leetcode.com/problems/jump-game-vii/discuss/1382916/c%2B%2B-or-O(n)-time-or-using-line-sweep\\nIf we encounter a \\'0\\', it MUST be flipped and hence we  increase `ans` by 1.\\nIf we don\\'t get `k` elements including this element, that means we can\\'t change this element from 0 to 1 and we have to return -1.\\n\\tif `flip[i]%2==0` it means `i` th element has been flipped even number of times and is in the same state as mentioned in `ar[i]`.\\n\\tFlipping is done when `ar[i]` has 0 and `ar[i]` is in original state of when `ar[i]` is 1 and `ar[i]` is in flipped state.\\n```\\nclass Solution {\\npublic:\\nint minKBitFlips(vector<int>& ar, int k) {\\n    int n=ar.size(),ans=0;\\n    vector<int> flip(n,0); //  flip[i] stores how many times current index(i) is flipped\\n    for(int i=0;i<n;i++){\\n        if(i) flip[i]+=flip[i-1];\\n        if((flip[i]%2 && ar[i]) || (flip[i]%2==0 && !ar[i])){\\n            ans++;\\n            // ar[i] MUST be flipped\\n            // ar[i+k] is not flipped\\n            flip[i]++;\\n            if(i+k>n) return -1;\\n            if(i+k<n) flip[i+k]--;\\n        }\\n    }\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\nint minKBitFlips(vector<int>& ar, int k) {\\n    int n=ar.size(),ans=0;\\n    vector<int> flip(n,0); //  flip[i] stores how many times current index(i) is flipped\\n    for(int i=0;i<n;i++){\\n        if(i) flip[i]+=flip[i-1];\\n        if((flip[i]%2 && ar[i]) || (flip[i]%2==0 && !ar[i])){\\n            ans++;\\n            // ar[i] MUST be flipped\\n            // ar[i+k] is not flipped\\n            flip[i]++;\\n            if(i+k>n) return -1;\\n            if(i+k<n) flip[i+k]--;\\n        }\\n    }\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 592961,
                "title": "java-o-n-greedy-sliding-window",
                "content": "It\\'s easy to come up with an `O(nk)` solution in which we change the `k` successors everytime we meet a zero.\\n```java\\nclass Solution {\\n    public int minKBitFlips(int[] A, int K) {\\n        int i = 0, res = 0;\\n        while (i < A.length) {\\n            if (A[i] == 0) {\\n                if (i + K > A.length)\\n                    return -1;\\n                for (int j = i; j < i + K; j++) {\\n                    A[j] ^= 1;\\n                }\\n                res++;\\n            } else {\\n                i++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\nDue to the scale, we need to find an `O(n)` solution. Let\\'s try to maintain a k-length sliding windows. Maybe a little ambiguous. `target` is the value we want to flip and intially it\\'s set to zero. When we find a value equals to target, we \"flip\" all the elements in current sliding window. However, we won\\'t actually do the filpping immediately, we just filp the `target` instead. When expending the sliding window, we change the forwarding elements simultaneously (according to `target`). \\n```java\\nclass Solution {\\n\\n    int target = 0;\\n    \\n    public int minKBitFlips(int[] A, int K) {\\n        int lo = 0, hi = K, res = 0;\\n        while (hi < A.length) {\\n            if (A[lo] == target) {\\n                target ^= 1;\\n                res++;\\n            } else {\\n                A[hi] ^= target;\\n                lo++;\\n                hi++;\\n            }\\n        }\\n        int cnt = (int) IntStream.range(lo, hi).filter(i -> A[i] == target).count();\\n        return cnt == K ? res + 1 : cnt == 0 ? res : -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int minKBitFlips(int[] A, int K) {\\n        int i = 0, res = 0;\\n        while (i < A.length) {\\n            if (A[i] == 0) {\\n                if (i + K > A.length)\\n                    return -1;\\n                for (int j = i; j < i + K; j++) {\\n                    A[j] ^= 1;\\n                }\\n                res++;\\n            } else {\\n                i++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n\\n    int target = 0;\\n    \\n    public int minKBitFlips(int[] A, int K) {\\n        int lo = 0, hi = K, res = 0;\\n        while (hi < A.length) {\\n            if (A[lo] == target) {\\n                target ^= 1;\\n                res++;\\n            } else {\\n                A[hi] ^= target;\\n                lo++;\\n                hi++;\\n            }\\n        }\\n        int cnt = (int) IntStream.range(lo, hi).filter(i -> A[i] == target).count();\\n        return cnt == K ? res + 1 : cnt == 0 ? res : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 240127,
                "title": "995-minimum-number-of-k-consecutive-bit-flips-analysis",
                "content": "<h2>Minimum Number of K Consecutive Bit Flips</h2>\\nIn an array A containing only 0s and 1s, a K-bit flip consists of choosing a (contiguous) subarray of length K and simultaneously changing every 0 in the subarray to 1, and every 1 in the subarray to 0.\\n\\nReturn the minimum number of K-bit flips required so that there is no 0 in the array.  If it is not possible, return -1.\\n\\n<h2 id=\"solution\">Solution</h2>\\n<hr>\\n<h4>Approach 1: Greedy</h4>\\n<strong>Intuition and Algorithm</strong>\\n\\n<p>\\nThis problem is similar to <a href=\"https://codejam.withgoogle.com/codejam/contest/3264486/dashboard#s=p0&a=0\">Qualification\\'s Codejam 2017.</a> (check Contest Analysis).\\n\\nThe idea is simple,  from left to right ,we find the first occurrence index <code>i</code>  with value <code>0</code>, now the unique way to change it, consists in flip from <code>[i ,i+K-1] </code>\\n\\nWhy?\\nImagine you have a solution, which performs flips in index starting in <code>i1, i2, i3, i4 where i1 < i2 < i3 < i4 </code>. \\n\\n<b>Observation:</b>\\n* At most we perform one flip in the same subarray, (because the operation is reversible).\\n* The order doesn\\'t matter.  <code> (i1,i2,i3,i4) = (i3,i2,i1,i4) </code> \\n* If the solution is <code>(i1,i2,i3,i4) </code> then  <code>A[i1]</code> must to be <code>0</code>  after performed this operation, flip <code>[i1 , i1+K-1]</code>, <code>A[i2]</code> must to be <code>0</code>, and so on.\\n\\n</p>\\n<code>\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minKBitFlips(vector<int>& A, int K) {\\n\\t\\t\\tint n= A.size();\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor(int i=0;i+K-1<n;i++)\\n\\t\\t\\t\\tif(A[i]==0){\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tfor(int j=i;j<i+K;j++)\\n\\t\\t\\t\\t\\t\\tA[j]^=1;\\n\\t\\t\\t\\t}\\n        \\n\\t\\t\\tif(A!=vector<int>(n,1))return -1;\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t};\\n</code>\\n\\n<p><strong>Complexity Analysis</strong></p>\\n<ul>\\n<li>\\n<p>Time Complexity:  <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N*K</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O(N*K)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">N*K</span><span class=\"mclose\">)</span></span></span></span>, where <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>N*K</mi></mrow><annotation encoding=\"application/x-tex\">N*K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">N</span></span></span></span> is length of <code>A</code>.</p>\\n</li>\\n<li>\\n<p>Space Complexity:  <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>1</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">1</span><span class=\"mclose\">)</span></span></span></span>.\\n<br>\\n<br></p>\\n</li>\\n</ul>\\n\\n\\n<hr>\\n<h4>Approach 2: Greedy + Binary Indexed Trees</h4>\\n<strong>Algorithm</strong>\\n<p>\\nIn contest, I thought that the previous algorithm could get TLE.\\n</p>\\n<p>\\nI thought of creating a data structure that added a value in a subarray (<code>A</code>) and get a specific value (<code>A[i]</code>) in logaritmic time. (Binary indexed Trees)\\n\\n<a href=\"https://apps.topcoder.com/forums/?module=Thread&threadID=715842&start=0&mc=8#1406845\">Range Update - Point query</a>\\n- Add v to [a..b] --> Update(a,v) and Update(b+1,-v) on the BIT\\n\\n</p>\\n\\nWhy add a value in a subarray?\\nIf I have   <code>A = [1,0,1,1,1,1,0] , K = 3</code> , then, I flip from index 1,\\n<code> A\\' = [1,1,0,0,1,1,0] </code>, It\\'s possible to add 1 from index 1, and get,\\n<code> A\\'\\' = [1,1,2,2,1,1,0] </code>, I will check each value modulo 2. \\n\\n<code>\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint tree[60002];\\n\\t\\tint MaxVal=60001;\\n\\t\\t\\n\\t\\tvoid update(int idx ,int val){\\n\\t\\t\\twhile (idx <= MaxVal){\\n\\t\\t\\t\\ttree[idx] += val;\\n\\t\\t\\t\\tidx += (idx & -idx);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t  \\n\\t\\tint read(int idx){\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\twhile (idx > 0){\\n\\t\\t\\t\\tsum += tree[idx];\\n\\t\\t\\t\\tidx -= (idx & -idx);\\n\\t\\t\\t}\\n\\t\\t\\treturn sum;\\n\\t\\t}    \\n\\t\\t\\n\\t\\tint minKBitFlips(vector<int>& A, int K) {\\n\\t\\t\\tmemset(tree,0,sizeof(tree));\\n\\t\\t\\tint count=0;\\n\\t\\t\\t\\n\\t\\t\\tfor(int i=0;i+K-1<A.size();i++){\\n\\t\\t\\t\\tint val=read(i+1)+(A[i]);\\n\\t\\t\\t\\tif(val%2==0){\\n\\t\\t\\t\\t\\tupdate(i+1,1);\\n\\t\\t\\t\\t\\tupdate(i+K+1,-1);\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tfor(int i=0;i<A.size();i++){\\n\\t\\t\\t\\tint val=read(i+1)+(A[i]);\\n\\t\\t\\t\\tif(val%2==0)return -1;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t};\\n</code>\\n\\n\\n<p><strong>Complexity Analysis</strong></p>\\n<ul>\\n<li>\\n<p>Time Complexity:  <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N*log(N)</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O(N*log(N))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">N*log(N)</span><span class=\"mclose\">)</span></span></span></span>, where <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>N*log(N)</mi></mrow><annotation encoding=\"application/x-tex\">N*log(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">N</span></span></span></span> is length of <code>A</code>.</p>\\n</li>\\n<li>\\n<p>Space Complexity:  <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span>.\\n<br>\\n<br></p>\\n</li>\\n</ul>\\n\\n\\n<hr>\\n<h4>Approach 3: Greedy + Events</h4>\\n<strong>Algorithm</strong>\\n<p>\\nWe will use a similar idea that \"Approach 2\", without BIT, (the reason is that we go from leftmost to rightmost, and it\\'s possible to get every value in constant time).\\n\\nFlip(a,b), from a to b  --> x[a]^1 and x[b+1]^1   .. O(1) operation.\\nquery(a)  --->    x[0]^x[1]^....^x[a]    .. we get this accumulate in O(1) because we go from left to right.. \\n</p>\\n\\n<code>\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minKBitFlips(vector<int>& A, int K) {\\n\\t\\t\\tint count=0;\\n\\t\\t\\tint n= A.size();\\n\\t\\t\\tint xxor = 0;\\n\\t\\t\\tint update[n+1];\\n\\t\\t\\tmemset(update,0,sizeof(update));\\n\\t\\t\\t// xxor always have update[0]^....^update[i]\\n\\t\\t\\t\\n\\t\\t\\tfor(int i=0; i+K-1 < n;i++){\\n\\t\\t\\t\\tint val = (xxor^update[i]) +A[i];\\n\\t\\t\\t\\tif(val%2==0){\\n\\t\\t\\t\\t\\tupdate[i] ^= 1;\\n\\t\\t\\t\\t\\tupdate[i+K] ^= 1;\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\t\\n\\t\\t\\t\\txxor ^= update[i];\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\txxor = 0;\\n\\t\\t\\tfor(int i=0;i<A.size();i++){\\n\\t\\t\\t\\txxor ^= update[i];\\n\\t\\t\\t\\tint val = xxor + A[i];\\n\\t\\t\\t\\tif(val%2==0)return -1;\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t};\\n\\n</code>\\n\\n<p><strong>Complexity Analysis</strong></p>\\n<ul>\\n<li>\\n<p>Time Complexity:  <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span>, where <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">N</span></span></span></span> is length of <code>A</code>.</p>\\n</li>\\n<li>\\n<p>Space Complexity:  <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span>.\\n<br>\\n<br></p>\\n</li>\\n</ul>",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint minKBitFlips(vector<int>& A, int K) {\\n\\t\\t\\tint n= A.size();\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor(int i=0;i+K-1<n;i++)\\n\\t\\t\\t\\tif(A[i]==0){\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tfor(int j=i;j<i+K;j++)\\n\\t\\t\\t\\t\\t\\tA[j]^=1;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 552438,
                "title": "java-o-n-sliding-window-queue-with-explannation",
                "content": "\\n\\n```\\nclass Solution {\\n    public int minKBitFlips(int[] A, int K) {\\n        //flipIndex: store previous flip events\\n        Queue<Integer> flipIndex = new LinkedList<>();\\n        int ans = 0;\\n        for(int i = 0;i<A.length;i++){\\n            // remove an itme which is out range of window.\\n            if(!flipIndex.isEmpty()&&(i-flipIndex.peek()>=K)){\\n                flipIndex.poll();\\n            }\\n            /**\\n             0 (even number) -> flip  twice (even number) -> 0 (need to be fliped)\\n                             -> flip  once (odd number)   -> 1 (don\\'t need)\\n                             \\n             1 (odd number)  -> flip  once (odd number)   -> 0 (need to be fliped)\\n                             -> flip  twice (even number) -> 1 (don\\'t need)\\n             Summary:                \\n             In a window,  if A[i] is a even number with even times fliped, it need to be fliped again.\\n             On other hand,if A[i] is a odd number with odd times fliped, it need to be fliped again.\\n            */\\n            \\n            if(A[i]%2 == flipIndex.size()%2){\\n                if(i+K-1>=A.length){\\n                    return -1;\\n                }\\n                flipIndex.offer(i);\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minKBitFlips(int[] A, int K) {\\n        //flipIndex: store previous flip events\\n        Queue<Integer> flipIndex = new LinkedList<>();\\n        int ans = 0;\\n        for(int i = 0;i<A.length;i++){\\n            // remove an itme which is out range of window.\\n            if(!flipIndex.isEmpty()&&(i-flipIndex.peek()>=K)){\\n                flipIndex.poll();\\n            }\\n            /**\\n             0 (even number) -> flip  twice (even number) -> 0 (need to be fliped)\\n                             -> flip  once (odd number)   -> 1 (don\\'t need)\\n                             \\n             1 (odd number)  -> flip  once (odd number)   -> 0 (need to be fliped)\\n                             -> flip  twice (even number) -> 1 (don\\'t need)\\n             Summary:                \\n             In a window,  if A[i] is a even number with even times fliped, it need to be fliped again.\\n             On other hand,if A[i] is a odd number with odd times fliped, it need to be fliped again.\\n            */\\n            \\n            if(A[i]%2 == flipIndex.size()%2){\\n                if(i+K-1>=A.length){\\n                    return -1;\\n                }\\n                flipIndex.offer(i);\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 238621,
                "title": "screencast-of-leetcode-weekly-contest-124",
                "content": "https://www.youtube.com/watch?v=ZK9NhAmN8C0\\n\\nI can\\'t figure out how to gracefully solve problem 3 during contest. After like 5+ mins thinking, I gave up and started implementing Segment Tree.",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=ZK9NhAmN8C0\\n\\nI can\\'t figure out how to gracefully solve problem 3 during contest. After like 5+ mins thinking, I gave up and started implementing Segment Tree.",
                "codeTag": "Unknown"
            },
            {
                "id": 239117,
                "title": "java-o-n-sliding-window-solution-using-queue",
                "content": "```\\npublic int minKBitFlips(int[] A, int K) {\\n        int result = 0;\\n        Queue<Integer> queue = new LinkedList<>();\\n        \\n        for (int i=0; i<A.length; i++) {\\n            if (!queue.isEmpty() && i>=queue.peek()+K) queue.poll();  // i is beyond the affected range of the flip at queue.peek()\\n            if ((A[i] + queue.size()) % 2 == 0) { // A[i]+queue.size()==odd => A[i] is actually already 1\\n                if (i > A.length - K) return -1; \\n                queue.offer(i);\\n                result++;\\n            }\\n        }\\n        return result;\\n    }\\n```\\n^^ \\u53EF\\u4F5C\\u4E3Adiscuss\\u6700\\u9AD8\\u7968\\u4E2DSolution 2\\u7684\\u89E3",
                "solutionTags": [],
                "code": "```\\npublic int minKBitFlips(int[] A, int K) {\\n        int result = 0;\\n        Queue<Integer> queue = new LinkedList<>();\\n        \\n        for (int i=0; i<A.length; i++) {\\n            if (!queue.isEmpty() && i>=queue.peek()+K) queue.poll();  // i is beyond the affected range of the flip at queue.peek()\\n            if ((A[i] + queue.size()) % 2 == 0) { // A[i]+queue.size()==odd => A[i] is actually already 1\\n                if (i > A.length - K) return -1; \\n                queue.offer(i);\\n                result++;\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3103263,
                "title": "python-3-8-lines-accumulate-w-explanation-t-m-98-100",
                "content": "Here\\'s the plan:\\n\\nAs we iterate`nums`, we want to change zeros to ones and leave ones unchanged.  Let\\'s call zero the *change-digit* in this case.\\n\\nWhen we flip digits in the  *flip interval*`nums[i:i+k]`, those digits that were initially one are now zero, and or equivalently, if we treat one as the change-digit (call it`toggle`) in the flip-interval we can avoid actually flipping the digits and just keep track of flip-intervals and the current change-digit.\\n\\nWhat makes it interesting is that when we hit a change-digit in in a flip-interval, we have to switch the change-digit again, and so on until we hit the end of`nums`.\\n\\nThus, the problem is reduced to counting the number of times the change-digit flips, which we do in`acc`. It\\'s much like a`prefix`or`accumulate`structure.\\n```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n\\n        acc, toggle = [0] * len(nums), 0\\n\\n        for idx, num in enumerate(nums):\\n            \\n            if idx >= k: toggle ^= acc[idx -k]      # <-- toggle change-digit if we leave a flip interval\\n\\n            if toggle != num: continue              # <-- num is not a change digit\\n\\n            if k > len(nums)-idx: return -1         # <-- num is a change digit but we can\\'t flip anymore\\n\\n            toggle ^= 1                             # <-- num is a change-digit we can flip, so toggle\\n            acc[idx] = 1                            #     the change-digit and record it in acc.\\n\\n        return sum(acc)                             # <-- return the number of flips\\n```\\n[https://leetcode.com/problems/minimum-number-of-k-consecutive-bit-flips/submissions/885902920/](http://)\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(N).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n\\n        acc, toggle = [0] * len(nums), 0\\n\\n        for idx, num in enumerate(nums):\\n            \\n            if idx >= k: toggle ^= acc[idx -k]      # <-- toggle change-digit if we leave a flip interval\\n\\n            if toggle != num: continue              # <-- num is not a change digit\\n\\n            if k > len(nums)-idx: return -1         # <-- num is a change digit but we can\\'t flip anymore\\n\\n            toggle ^= 1                             # <-- num is a change-digit we can flip, so toggle\\n            acc[idx] = 1                            #     the change-digit and record it in acc.\\n\\n        return sum(acc)                             # <-- return the number of flips\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2148914,
                "title": "c-o-n-explained-with-comments",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        \\n        int flips = 0;                  // flips on current positions\\n        vector<int> flip(n+1,0);        // to set end pointer for a flip i.e i+k ->-1\\n        int ops = 0;                    // answer\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            flips +=flip[i];            // update flips for current position\\n                                       \\n            // even flips on 1 okay\\n            if(nums[i]==1 && (flips)%2==0){\\n                continue;\\n            }\\n            \\n            // odd flips on 0 okay\\n            \\n            if(nums[i]==0 && (flips)%2!=0){\\n                continue;\\n            }\\n            \\n            // margin error as k bits flips is must\\n            \\n            if(i+k > n){\\n                return -1;\\n            }\\n            \\n            ops++;           //increment ans\\n            flips++;         // do flip at this position\\n            flip[i+k] = -1;  // set poiter where current flip ends\\n            \\n        }\\n        \\n        return ops;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        \\n        int flips = 0;                  // flips on current positions\\n        vector<int> flip(n+1,0);        // to set end pointer for a flip i.e i+k ->-1\\n        int ops = 0;                    // answer\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            flips +=flip[i];            // update flips for current position\\n                                       \\n            // even flips on 1 okay\\n            if(nums[i]==1 && (flips)%2==0){\\n                continue;\\n            }\\n            \\n            // odd flips on 0 okay\\n            \\n            if(nums[i]==0 && (flips)%2!=0){\\n                continue;\\n            }\\n            \\n            // margin error as k bits flips is must\\n            \\n            if(i+k > n){\\n                return -1;\\n            }\\n            \\n            ops++;           //increment ans\\n            flips++;         // do flip at this position\\n            flip[i+k] = -1;  // set poiter where current flip ends\\n            \\n        }\\n        \\n        return ops;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3302547,
                "title": "intuitive-from-o-n-k-and-optimization-to-o-n",
                "content": "# Intuition\\nObservation 1: bit flips are commutative. It doesn\\'t matter in which order you flip the subarrays, the end result should be same.\\n\\nSo there must be a valid sequence of bit flips in an increasing order through the array.\\n\\nWe must find this increasing order of flips.\\n\\nObservation 2: when we do a pass to find these flips, if our sliding window of size $$k$$ has a $$0$$ in beginning, it must be flipped. Because we are going in increasing order and it\\'s our last chance to flip that integer.\\n\\nObservation 3: If the bit at the beginning of sliding window is 1, we must __not__ flip that bit, because we can\\'t flip that ever again.\\n\\nFrom (2) and (3), whether we flip a certain sliding window depends only on the first bit.\\n\\n# Approach\\nStraightforward $$O(n*k)$$ approach: keep a sliding window of size $$k$$, if it\\'s first bit is 0, flip all subsequent bits in that window.\\n\\nThis actually passes 110/113 test cases!\\n\\nTo not actually have to flip the bits for every single window, we can lazily compute the state of each cell when we encounter it. I do it by marking some points as \"turning points\" (my own term).\\n\\nIn particular, when I encounter a window I want to flip, I\\'d rather invert a boolean state `flip`, and mark the end of this window (actually one past the end), as turning point. (I use queue to remember turning points, but you can use any kind of linear DS.)\\n\\nWhen I see a turning point at a future position, I pop that turning point from queue, flip the current state and continue the usual logic.\\n\\n# Complexity\\n- Time complexity: O(n*k), O(n) respectively\\n\\n- Space complexity: There can be at most `k` turning points in queue at a time, (haven\\'t calculated more precisely). so O(k).\\n\\n# Code\\n\\n## Unoptimized `O(n*k)`\\n\\nThis passed 110/113 test cases, if I remember correctly.\\n\\n```\\nclass Solution {\\n    public int minKBitFlips(int[] nums, int k) {\\n        int ans = 0;\\n        for (int i = 0; i < nums.length - k + 1; i++) {\\n            int bit = nums[i];\\n            if (bit == 0) {\\n                // mark [i, i+k) as flipped\\n                for (int j = 0; j < k; j++) {\\n                    nums[i+j] = 1 - nums[i+j];\\n                }\\n                ans++;\\n            }\\n        }\\n        for (int i = nums.length - k + 1; i < nums.length; i++) {\\n            if (nums[i] == 0) return -1;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n## Optimized `O(n)`\\n\\n```\\nclass Solution {\\n    public int minKBitFlips(int[] nums, int k) {\\n        int ans = 0;\\n        boolean flip = false;\\n        Queue<Integer> turns = new ArrayDeque<Integer>();\\n        for (int i = 0; i < nums.length - k + 1; i++) {\\n            int bit = nums[i];\\n\\n            if (!turns.isEmpty() && i == turns.peek()) {\\n                flip = !flip;\\n                turns.remove();\\n            }\\n\\n            if (flip) {\\n                bit = 1 - bit;\\n            }\\n\\n            if (bit == 0) {\\n                turns.add(i+k);\\n                flip = !flip;\\n                ans++;\\n            }\\n        }\\n\\n        for (int i = nums.length - k + 1; i < nums.length; i++) {\\n            int bit = nums[i];\\n\\n            if (!turns.isEmpty() && i == turns.peek()) {\\n                flip = !flip;\\n                turns.remove();\\n            }\\n\\n            if (flip) bit = 1 - bit;\\n            if (bit == 0) return -1;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minKBitFlips(int[] nums, int k) {\\n        int ans = 0;\\n        for (int i = 0; i < nums.length - k + 1; i++) {\\n            int bit = nums[i];\\n            if (bit == 0) {\\n                // mark [i, i+k) as flipped\\n                for (int j = 0; j < k; j++) {\\n                    nums[i+j] = 1 - nums[i+j];\\n                }\\n                ans++;\\n            }\\n        }\\n        for (int i = nums.length - k + 1; i < nums.length; i++) {\\n            if (nums[i] == 0) return -1;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minKBitFlips(int[] nums, int k) {\\n        int ans = 0;\\n        boolean flip = false;\\n        Queue<Integer> turns = new ArrayDeque<Integer>();\\n        for (int i = 0; i < nums.length - k + 1; i++) {\\n            int bit = nums[i];\\n\\n            if (!turns.isEmpty() && i == turns.peek()) {\\n                flip = !flip;\\n                turns.remove();\\n            }\\n\\n            if (flip) {\\n                bit = 1 - bit;\\n            }\\n\\n            if (bit == 0) {\\n                turns.add(i+k);\\n                flip = !flip;\\n                ans++;\\n            }\\n        }\\n\\n        for (int i = nums.length - k + 1; i < nums.length; i++) {\\n            int bit = nums[i];\\n\\n            if (!turns.isEmpty() && i == turns.peek()) {\\n                flip = !flip;\\n                turns.remove();\\n            }\\n\\n            if (flip) bit = 1 - bit;\\n            if (bit == 0) return -1;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1840244,
                "title": "c-queue-one-pass-solution-easy-to-understand",
                "content": "* Idea is to keep track of the indexes on which flips have been made. And this is done with the help of queue data structure. \\n\\n* Whenever coming on a ith index pop all the indexes which cannot flip the ith index i.e. indexes<=i-k and now the current nums[i] will be equal to the original value if size of queue is even, otherwise gets flipped. \\n \\n*   If now its value is 0 then we gotta do the flip so push i into the queue and do ans++.\\n\\n```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        queue<int>q;\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n           while(!q.empty() && q.front()<=i-k)\\n               q.pop();\\n            int siz=q.size();\\n            int val=(nums[i]+siz%2)%2;\\n            if(!val)\\n            {\\n                ans++;\\n                if(i+k<=n)\\n                    q.push(i);\\n                else\\n                    return -1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "class Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        queue<int>q;\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n           while(!q.empty() && q.front()<=i-k)\\n               q.pop();\\n            int siz=q.size();\\n            int val=(nums[i]+siz%2)%2;\\n            if(!val)\\n            {\\n                ans++;\\n                if(i+k<=n)\\n                    q.push(i);\\n                else\\n                    return -1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1433426,
                "title": "c-very-easy-implementation-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>lag(n+1,0);\\n        int i=0;\\n        int count=0;\\n        while(i<=n-k)\\n        {\\n            if(i!=0)\\n            lag[i]+=lag[i-1];\\n            if((nums[i]+lag[i])%2==0)\\n            {\\n                count++;\\n                lag[i+k]--;\\n                lag[i]++;\\n            }\\n            i++;\\n        }\\n        for(int i=n-k+1;i<n;i++)\\n        {\\n            lag[i]+=lag[i-1];\\n            if((nums[i]+lag[i])%2==0)\\n                return -1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>lag(n+1,0);\\n        int i=0;\\n        int count=0;\\n        while(i<=n-k)\\n        {\\n            if(i!=0)\\n            lag[i]+=lag[i-1];\\n            if((nums[i]+lag[i])%2==0)\\n            {\\n                count++;\\n                lag[i+k]--;\\n                lag[i]++;\\n            }\\n            i++;\\n        }\\n        for(int i=n-k+1;i<n;i++)\\n        {\\n            lag[i]+=lag[i-1];\\n            if((nums[i]+lag[i])%2==0)\\n                return -1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1266081,
                "title": "c-995-minimum-number-of-k-consecutive-bit-flips",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        deque<int> dq; \\n        int ans = 0, flip = 0; \\n        \\n        for (int i = 0; i < size(nums); ++i) {\\n            if (size(dq) && dq.front() == i) {\\n                dq.pop_front(); \\n                flip ^= 1; \\n            }\\n            if (nums[i] == flip) {\\n                if (size(nums)-i < k) return -1; \\n                ++ans; \\n                flip ^= 1; \\n                dq.push_back(i+k); \\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        deque<int> dq; \\n        int ans = 0, flip = 0; \\n        \\n        for (int i = 0; i < size(nums); ++i) {\\n            if (size(dq) && dq.front() == i) {\\n                dq.pop_front(); \\n                flip ^= 1; \\n            }\\n            if (nums[i] == flip) {\\n                if (size(nums)-i < k) return -1; \\n                ++ans; \\n                flip ^= 1; \\n                dq.push_back(i+k); \\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1116235,
                "title": "java-greedy-approach-o-n",
                "content": "```\\nclass Solution {\\n    public int minKBitFlips(int[] A, int K) {\\n        // use an count to check how many times current element has been fliped\\n        int out = 0, count=0;\\n        // use an boolean array to track till what array element you will flip\\n        boolean[] checkFlip = new boolean[A.length];\\n        for(int i=0; i<A.length; i++){\\n            // You need to flip only if A[i] == 0 and you haven\\u2019t fliped it or all the flips have been Canceled due even number of flips\\n            // You will also need to flip if you have fliped A[i]==1 odd number of times.\\n            if( (A[i]==0 && count%2==0) || (A[i]==1 && count%2!=0)){\\n                count++;\\n                out++;\\n                if(i+K-1>=A.length){\\n                    // You will return -1 as you encountered an element which needs flip but there aren\\'t enough elements to flip ahead and all the previous elements are 1.\\n                    return -1;\\n                }else{\\n                    // If you flip a current elements use checkFlip to keep track till which element current flip has effect.\\n                    checkFlip[i+K-1] = true;\\n                }\\n            }\\n            if(checkFlip[i]){\\n                // Decrement the count as you are passing a element till which certain flip was active\\n                count--;\\n            }\\n        }\\n        return out;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minKBitFlips(int[] A, int K) {\\n        // use an count to check how many times current element has been fliped\\n        int out = 0, count=0;\\n        // use an boolean array to track till what array element you will flip\\n        boolean[] checkFlip = new boolean[A.length];\\n        for(int i=0; i<A.length; i++){\\n            // You need to flip only if A[i] == 0 and you haven\\u2019t fliped it or all the flips have been Canceled due even number of flips\\n            // You will also need to flip if you have fliped A[i]==1 odd number of times.\\n            if( (A[i]==0 && count%2==0) || (A[i]==1 && count%2!=0)){\\n                count++;\\n                out++;\\n                if(i+K-1>=A.length){\\n                    // You will return -1 as you encountered an element which needs flip but there aren\\'t enough elements to flip ahead and all the previous elements are 1.\\n                    return -1;\\n                }else{\\n                    // If you flip a current elements use checkFlip to keep track till which element current flip has effect.\\n                    checkFlip[i+K-1] = true;\\n                }\\n            }\\n            if(checkFlip[i]){\\n                // Decrement the count as you are passing a element till which certain flip was active\\n                count--;\\n            }\\n        }\\n        return out;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 924640,
                "title": "easiest-and-most-understandable-explanation-o-1-solution",
                "content": "Basically, this is a sliding window of **k** size and 0-1 task.\\nI prefer to use bit manipulation because it is more straightforward for 0-1 task.\\n\\nThere are only two points:\\n1. we need a variable **flipped** to record whether next index was flipped before.\\n2. we need to record whether **current index** is flipped or not for later check. \\nWe can mark array[i] = -1, if it has been flipped.\\n\\nBit manipulation is more straightforward \\nbecasuse if we initialize flipped = 0, 0 ^ 1 = 1 and 1 ^ 1 = 0.\\nIn other words, \\n**flipping twice is equivalently flipping back to original state of current index.**\\n\\nTake array = [0,1,0,1,0,1,1,0], k = 3, flipped = 0 for example.\\n```\\nif i = 0, array[0] = 0\\nflipped ^= 1; array[0] = -1 >> flipped = 1\\n```\\n```\\nif i = 1, array[1] = 1\\narray[1] was in sliding window [0, 1, 2] and flipped == 1,\\nso it actually became 0 and needs to be flipped. \\nflipped ^= 1; array[1] = -1 >> flipped = 0\\n```\\n```\\nif i = 2, array[2] = 0\\narray[2] was in sliding window [0, 1, 2] and [1, 2, 3] and flipped == 0,\\nso it is still 0 and needs to be flipped. \\nflipped ^= 1; array[2] = -1 >> flipped = 1\\n```\\n```\\n# Notice:\\nif i = 3, array[3] = 1\\narray[3] was not in sliding window [0, 1, 2],\\nbut flipped involves array[0]\\'s flip, \\nwe need to use flipped ^= 1 first to revise it for array[3] and continue the same operation\\n```\\nAs a result, \\nwe can know **if flipped and array[i] are the same value, array[i] needs flip**.\\nWe also can **use operator ^ to check whether flipped and array[i] are the same or not**.\\n\\nhope the explanation helpful!\\n\\n```\\nclass Solution: # best 732 ms\\n    def minKBitFlips(self, array, k):\\n        flipped = 0; length = len(array)\\n        res = 0\\n\\n        for i in range(length):\\n\\t\\t    # revise flipped which didn\\'t affect current index\\n            if i >= k and array[i-k] < 0:\\n                flipped ^= 1\\n\\n\\t\\t\\t# use ^ to know whether array[i] needs to be flipped or not\\n            if not flipped ^ array[i]:\\n\\t\\t\\t    # if current index still needs flip, \\n\\t\\t\\t\\t# the sliding window will be over the length\\n                if i + k > length: return -1   \\n\\t\\t\\t\\t\\n                array[i] = -1; flipped ^= 1\\n                res += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nif i = 0, array[0] = 0\\nflipped ^= 1; array[0] = -1 >> flipped = 1\\n```\n```\\nif i = 1, array[1] = 1\\narray[1] was in sliding window [0, 1, 2] and flipped == 1,\\nso it actually became 0 and needs to be flipped. \\nflipped ^= 1; array[1] = -1 >> flipped = 0\\n```\n```\\nif i = 2, array[2] = 0\\narray[2] was in sliding window [0, 1, 2] and [1, 2, 3] and flipped == 0,\\nso it is still 0 and needs to be flipped. \\nflipped ^= 1; array[2] = -1 >> flipped = 1\\n```\n```\\n# Notice:\\nif i = 3, array[3] = 1\\narray[3] was not in sliding window [0, 1, 2],\\nbut flipped involves array[0]\\'s flip, \\nwe need to use flipped ^= 1 first to revise it for array[3] and continue the same operation\\n```\n```\\nclass Solution: # best 732 ms\\n    def minKBitFlips(self, array, k):\\n        flipped = 0; length = len(array)\\n        res = 0\\n\\n        for i in range(length):\\n\\t\\t    # revise flipped which didn\\'t affect current index\\n            if i >= k and array[i-k] < 0:\\n                flipped ^= 1\\n\\n\\t\\t\\t# use ^ to know whether array[i] needs to be flipped or not\\n            if not flipped ^ array[i]:\\n\\t\\t\\t    # if current index still needs flip, \\n\\t\\t\\t\\t# the sliding window will be over the length\\n                if i + k > length: return -1   \\n\\t\\t\\t\\t\\n                array[i] = -1; flipped ^= 1\\n                res += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3784150,
                "title": "c-solution-easy-to-understand",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int ans=0,flip=0;\\n        for(int i=0;i<n;i++){\\n            if(flip%2==nums[i]){\\n                if(i>n-k) return -1;\\n                ans++;\\n                flip++;\\n                nums[i]-=2;\\n                \\n            }\\n            if(i>=k-1 && nums[i-k+1]<0){\\n                flip++;\\n                nums[i-k+1]+=2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int ans=0,flip=0;\\n        for(int i=0;i<n;i++){\\n            if(flip%2==nums[i]){\\n                if(i>n-k) return -1;\\n                ans++;\\n                flip++;\\n                nums[i]-=2;\\n                \\n            }\\n            if(i>=k-1 && nums[i-k+1]<0){\\n                flip++;\\n                nums[i-k+1]+=2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729212,
                "title": "hard-made-easy-o-n-greedy-solution-sliding-window-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStart making the value 1 from the first index of the array and if the value is 0 means we have to flip the value to 1 and consequently we have to flip next K-1 values as well.\\n\\nBut instead of flipping next K-1 value as well, we will keep a counter which says how many times the values need to alter because of previous operation and mark the (i+k)th index of the reset vector to -1.\\n\\n**For ex:** \\nInput: nums = [0,0,0,1,0,1,1,0], k = 3\\nTake a reset vector [0,0,0,0,0,0,0,0] and a counter  = 0\\n\\n**For every values from 0th index to (N-k)th index:**\\n\\n**At nums[0],** we need to flip the nums[0], so we increase the counter by 1 and mark the (0+3)th index of reset vector as -1\\n**nums is [1,0,0,1,0,1,1,0]\\nreset vector is [0,0,0,-1,0,0,0,0] and counter  = 1**\\n\\n**At nums[1],** the values is \\'0\\' but the counter variable says we need to flip the nums[1] one times, so you can observe that it will eventually become \\'1\\'. Hence, nothing to do.\\n**nums is [1,0,0,1,0,1,1,0]\\nreset vector is [0,0,0,-1,0,0,0,0] and counter  = 1**\\n\\n**At nums[2],** the values is \\'0\\' but the counter variable says we need to flip the nums[2] one times, so you can observe that it will eventually become \\'1\\'. Hence, nothing to do.\\n**nums is [1,1,1,1,0,1,1,0]\\nreset vector is [0,0,0,-1,0,0,0,0] and counter  = 1**\\n\\n**At nums[3],** we need to **pay attention**, reset vector at this position is -1, that ,means we have to reduce the effect of one of the operation that had made earlier. Hence , count value gets updated to count = count + rest[3] = 1 + (-1) = 0. Hence no flips made to nums[3]\\nNow, the values at nums[3] is \\'1\\' so no operation is required.\\n**nums is [1,1,1,1,0,1,1,0]\\nreset vector is [0,0,0,-1,0,0,0,0] and counter  = 1**\\n\\n\\n**At nums[4],** the counter variable remains \\'0\\' as counter  + reset[4] = 0 + 0 = 0.\\nBut the values at nums[4] is \\'1\\'. Hence we need to perform one operation of K-flip again. So,we increase the counter by 1 and mark the (4+3)th index of reset vector as -1.\\n**nums is [1,1,1,1,1,1,1,0]\\nreset vector is [0,0,0,-1,0,0,0,-1] and counter  = 1**\\n\\n**At nums[5],** the counter variable is updated as counter  + reset[5] = 1 + 0 = 1.\\nand the values at nums[5] is \\'1\\' and we need to flip the value one time, so value becomes \\'0\\'.\\nHence we need to perform one operation of K-flip again. So,we increase the counter by 1 and mark the (5+3)th index of reset vector as -1. \\n**The reset vector index goes out of bound so we can ignore, but its a valid K-flip.**\\n**nums is [1,1,1,1,1,1,1,0]\\nreset vector is [0,0,0,-1,0,0,0,-1] and counter  = 2**\\n\\n**At nums[6],** the counter variable is updated as counter  + reset[6] = 2 + 0 = 2.\\nand the values at nums[6] is \\'1\\' and we need to flip the value two times, so no change in value and it is still \\'1\\'.\\nHence we don\\'tneed to perform oany operation of K-flip again.\\n**nums is [1,1,1,1,1,1,1,0]\\nreset vector is [0,0,0,-1,0,0,0,-1] and counter  = 2**\\n\\n**At nums[7],** the counter variable is updated as counter  + reset[7] = 2 + -1 = 1.\\nand the values at nums[7] is \\'0\\' and we need to flip the value one time, so value becomes \\'1\\'.\\nHence we need to perform any K-flip operation.\\n**nums is [1,1,1,1,1,1,1,1]\\nreset vector is [0,0,0,-1,0,0,0,-1] and counter  = 1\\n**\\n\\nIf you have understood the above implementation you will observe that \\nif counter values is **even** means we don\\'t have to flip the value\\nif its **odd** we have to flip the value\\n**So I have taken flag instead of counter variable and same did with the reset vector.**\\n\\nPlease refer the code.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int ans = 0;\\n\\n        int i = 0, j = 0;\\n        int n = nums.size();\\n        vector<int> reset(n,0);\\n        \\n        int flag = 1;\\n        while(i<=(n-k)){\\n            flag = flag^reset[i];\\n            if(nums[i]^flag){\\n                ans++;\\n                if(i+k<n){\\n                    reset[i+k] = 1;\\n                }\\n                flag = !flag;\\n            }\\n            i++;\\n        }\\n\\n        while(i<n){\\n            flag = flag^reset[i];\\n            if(nums[i]^flag){\\n                return -1;\\n            }\\n            i++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int ans = 0;\\n\\n        int i = 0, j = 0;\\n        int n = nums.size();\\n        vector<int> reset(n,0);\\n        \\n        int flag = 1;\\n        while(i<=(n-k)){\\n            flag = flag^reset[i];\\n            if(nums[i]^flag){\\n                ans++;\\n                if(i+k<n){\\n                    reset[i+k] = 1;\\n                }\\n                flag = !flag;\\n            }\\n            i++;\\n        }\\n\\n        while(i<n){\\n            flag = flag^reset[i];\\n            if(nums[i]^flag){\\n                return -1;\\n            }\\n            i++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061620,
                "title": "c-key-observation-diff-arrary",
                "content": "```\\n// key observation:\\n// 1. only one ops can affect the 1st bit.\\n// 2. once 1st bit is settled, only one ops can affect the 2nd bit\\n// 3. so on ... \\n\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        vector<int> diff(n + 1);\\n        int cnt = 0;\\n        for (int i = 0; i < n; ++ i)\\n        {\\n            if (i) diff[i] += diff[i - 1];\\n            if (arr[i] ^ (diff[i] % 2) == 0 && i + k - 1 < n)\\n            {\\n                diff[i] += 1;\\n                diff[i + k] -= 1;\\n                cnt ++ ;\\n            }\\n            \\n            if (arr[i] ^ (diff[i] % 2) == 0) return -1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// key observation:\\n// 1. only one ops can affect the 1st bit.\\n// 2. once 1st bit is settled, only one ops can affect the 2nd bit\\n// 3. so on ... \\n\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        vector<int> diff(n + 1);\\n        int cnt = 0;\\n        for (int i = 0; i < n; ++ i)\\n        {\\n            if (i) diff[i] += diff[i - 1];\\n            if (arr[i] ^ (diff[i] % 2) == 0 && i + k - 1 < n)\\n            {\\n                diff[i] += 1;\\n                diff[i + k] -= 1;\\n                cnt ++ ;\\n            }\\n            \\n            if (arr[i] ^ (diff[i] % 2) == 0) return -1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1131369,
                "title": "c-o-n-time-o-1-space",
                "content": "For each idx,\\n(number of flip + A[idx]) % 2 should be 1.\\n\\nThen, how to calculate number of flip?\\n\\nif (number of flip + A[idx]) % 2 is even, increase number of flip.\\nAlso, we need to detect whether any of flipped segments is ended or not.\\nTo check this, whenever flip occurs, update A[idx+K] += 2.\\n\\nThen, for each index, idx, exactly one segment is over if A[idx] >= 2.\\nCheck this for each start of an index.\\n\\n```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& A, int K) {\\n        int flipped = 0;\\n        const int n = A.size();\\n        int ret = 0;\\n        for(int i = 0; i < n; i++) {\\n\\t\\t\\t// If one flipped segment is over, decrease flipped.\\n            if(A[i] > 1)    flipped -= 1;\\n\\t\\t\\t// If we need to flip this index,\\n            if((A[i]+flipped)%2 == 0) {\\n\\t\\t\\t\\t// segment out of range.\\n                if(i + K > n)   return -1;\\n                flipped += 1;\\n\\t\\t\\t\\t// we do not need to check the case, i + K == n \\n                if(i + K < n)   A[i+K] += 2;\\n                ret++;\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& A, int K) {\\n        int flipped = 0;\\n        const int n = A.size();\\n        int ret = 0;\\n        for(int i = 0; i < n; i++) {\\n\\t\\t\\t// If one flipped segment is over, decrease flipped.\\n            if(A[i] > 1)    flipped -= 1;\\n\\t\\t\\t// If we need to flip this index,\\n            if((A[i]+flipped)%2 == 0) {\\n\\t\\t\\t\\t// segment out of range.\\n                if(i + K > n)   return -1;\\n                flipped += 1;\\n\\t\\t\\t\\t// we do not need to check the case, i + K == n \\n                if(i + K < n)   A[i+K] += 2;\\n                ret++;\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1048996,
                "title": "c-greedy-queue-one-pass-solution-with-intuitive-explanation",
                "content": "Keep a queue to track the index where flip was initiated. At each node, first check whether the oldest flip is expired or not. Then if there\\'s odd number of flip and current element value is 1, it will initiate another flip. If there\\'s an even number of flip and current value is 0, it will initiate another flip as well.\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& A, int K) {\\n        int cnt = 0;\\n        queue<int> flipIdx; // idx where a flip started\\n        for (int i = 0; i < A.size(); ++i) {\\n            if (flipIdx.size() > 0 && i - flipIdx.front() >= K) {\\n                flipIdx.pop();\\n            }\\n            if ((flipIdx.size() % 2 == 1 && A[i] == 1) || (flipIdx.size() % 2 == 0 && A[i] == 0)) {\\n                flipIdx.push(i);\\n                ++cnt;\\n            }\\n        }\\n        if (flipIdx.size() == 0 || (flipIdx.size() == 1 && flipIdx.front() == A.size() - K))\\n            return cnt;\\n        else \\n            return -1;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& A, int K) {\\n        int cnt = 0;\\n        queue<int> flipIdx; // idx where a flip started\\n        for (int i = 0; i < A.size(); ++i) {\\n            if (flipIdx.size() > 0 && i - flipIdx.front() >= K) {\\n                flipIdx.pop();\\n            }\\n            if ((flipIdx.size() % 2 == 1 && A[i] == 1) || (flipIdx.size() % 2 == 0 && A[i] == 0)) {\\n                flipIdx.push(i);\\n                ++cnt;\\n            }\\n        }\\n        if (flipIdx.size() == 0 || (flipIdx.size() == 1 && flipIdx.front() == A.size() - K))\\n            return cnt;\\n        else \\n            return -1;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1000760,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& A, int K) {\\n        int flip = 0, ans = 0, n = A.size();\\n        vector<int> flipped(n, 0);\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (i >= K) { //cancel the influnce of last window\\n                flip ^= flipped[i-K];\\n            }\\n            if (A[i] ^ flip == 0) { //if this bit need flip\\n                if (i + K > n) return -1;\\n                flipped[i] = 1;\\n                ans++;\\n                flip ^= 1; \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& A, int K) {\\n        int flip = 0, ans = 0, n = A.size();\\n        vector<int> flipped(n, 0);\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (i >= K) { //cancel the influnce of last window\\n                flip ^= flipped[i-K];\\n            }\\n            if (A[i] ^ flip == 0) { //if this bit need flip\\n                if (i + K > n) return -1;\\n                flipped[i] = 1;\\n                ans++;\\n                flip ^= 1; \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 881737,
                "title": "c-detailed-comments",
                "content": "```\\n// Naive greedy solution, whenever we see a 0, flip the numbers [i, i+k-1]\\n// So that all numbers to the left of i are all 1.\\n// O(n*k)\\n// **Optimized**\\n// Intuition: If we flip 0 or 1 even number of times, the number will remain the same\\n// the value will only change if we flip them odd number of times\\n// So if the index where the original value was 0 has been flipped odd number of times (bcaus it was within the K range from an index), we have a value of 1 and we dont need to do anything\\n// if even, then we need to flip it\\n// Same for 1, if the index has been flipped even number of times, we are all good else we need to flip\\n// So instead of flipping each 0 and the next K digits, we just need to track if an index has been flipped even or odd number of times\\n// and if the number at index i, is 0 and count is even, we increase the step, and if the number is 1 and count is odd, we increase the steps else continue\\n// We need a data structure which will tell us the current flip count of the current index\\n// i.e. when ever we flip a index, we need to increment the flip count of the indexes from [i.. i+k-1]\\n// We can use queue to store the last index which was flipped as part of current continues K flip effort\\n// e.g. If we flipped index i, then queue will store i-k+1\\n// The count of elements in the queue will tell how many times the current index has been flipped\\n// when the top element of the queue is less than i i.e the last index flipped as part of K lenght is before i, pop out \\n// as that flip will not effect any indexes from i and forward\\n// so we are using queue essentially as dual purpose\\n// 1. The flip count for current index\\n// 2. Last index range that was flipped  \\n// O(n), Space: O(K)\\npublic class Solution {\\n    public int MinKBitFlips(int[] A, int K)\\n        {\\n            var len = A.Length;\\n            if (len == 0 || K <= 0)\\n                return -1;\\n\\n        //return Greedy(A, K);\\n        // return GreedyWithQueue(A, K);\\n        \\n        // We dont really need queue, \\n        // we need to track total number of flips so far\\n        // and we need to track the index within K range, so that when we cross that range, we reduce the total flipped count\\n        var steps = 0;\\n        var flippedCount = 0;\\n        for(var i = 0; i < len; i++)\\n        {\\n            if(A[i] == 0 &&  flippedCount % 2 == 0)\\n            {\\n                if(i + K > len) return -1;\\n                \\n                steps++;\\n                flippedCount++;\\n                A[i] += -2; // Record the flip\\n            }\\n            \\n            if(A[i] == 1 &&  flippedCount % 2 == 1)\\n            {\\n                if(i + K > len) return -1;\\n                \\n                steps++;\\n                flippedCount++;                \\n                A[i] += -2; // Record the flip\\n            }\\n            \\n            if(i >= (K - 1) && A[i - K + 1] < 0)\\n            {\\n                flippedCount--;\\n                A[i-K + 1] += 2; // Restore the value\\n            } \\n        }\\n        \\n        return steps;\\n       \\n    }\\n    \\n    private static int GreedyWithQueue(int[] A, int K)\\n    {   var len = A.Length;\\n     \\n        // For details read **Optimized** Section above\\n        var q = new Queue<int>();\\n        var steps = 0;\\n        for(var i = 0; i < len; i++)\\n        {\\n            if(A[i] == 0 &&  q.Count % 2 == 0)\\n            {\\n                steps++;\\n                q.Enqueue(i + K - 1);\\n            }\\n            \\n            if(A[i] == 1 &&  q.Count % 2 == 1)\\n            {\\n                steps++;\\n                q.Enqueue(i + K - 1);\\n            }\\n            \\n            if(q.Count > 0 && i >= q.Peek()) q.Dequeue();\\n        }\\n        \\n        return q.Count > 0 ? -1 : steps;\\n    }\\n    \\n    private static int Greedy(int[] A, int K)\\n    {\\n        var len = A.Length;\\n        // Greedy approach\\n        // find the first 0, flip and continue.\\n        // All elements left of i will be 1 now\\n        // Repeat\\n        var steps = 0;\\n        for(var i = 0; i < len; i++)\\n        {\\n            if(A[i] == 1)\\n                continue;\\n            \\n            if(i + K > len)\\n                return -1;\\n            \\n            for(var j = i; j < i + K; j++)\\n            {\\n                A[j] = A[j] ^ 1;\\n            }\\n            \\n            steps++;\\n        }\\n            \\n        return steps;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// Naive greedy solution, whenever we see a 0, flip the numbers [i, i+k-1]\\n// So that all numbers to the left of i are all 1.\\n// O(n*k)\\n// **Optimized**\\n// Intuition: If we flip 0 or 1 even number of times, the number will remain the same\\n// the value will only change if we flip them odd number of times\\n// So if the index where the original value was 0 has been flipped odd number of times (bcaus it was within the K range from an index), we have a value of 1 and we dont need to do anything\\n// if even, then we need to flip it\\n// Same for 1, if the index has been flipped even number of times, we are all good else we need to flip\\n// So instead of flipping each 0 and the next K digits, we just need to track if an index has been flipped even or odd number of times\\n// and if the number at index i, is 0 and count is even, we increase the step, and if the number is 1 and count is odd, we increase the steps else continue\\n// We need a data structure which will tell us the current flip count of the current index\\n// i.e. when ever we flip a index, we need to increment the flip count of the indexes from [i.. i+k-1]\\n// We can use queue to store the last index which was flipped as part of current continues K flip effort\\n// e.g. If we flipped index i, then queue will store i-k+1\\n// The count of elements in the queue will tell how many times the current index has been flipped\\n// when the top element of the queue is less than i i.e the last index flipped as part of K lenght is before i, pop out \\n// as that flip will not effect any indexes from i and forward\\n// so we are using queue essentially as dual purpose\\n// 1. The flip count for current index\\n// 2. Last index range that was flipped  \\n// O(n), Space: O(K)\\npublic class Solution {\\n    public int MinKBitFlips(int[] A, int K)\\n        {\\n            var len = A.Length;\\n            if (len == 0 || K <= 0)\\n                return -1;\\n\\n        //return Greedy(A, K);\\n        // return GreedyWithQueue(A, K);\\n        \\n        // We dont really need queue, \\n        // we need to track total number of flips so far\\n        // and we need to track the index within K range, so that when we cross that range, we reduce the total flipped count\\n        var steps = 0;\\n        var flippedCount = 0;\\n        for(var i = 0; i < len; i++)\\n        {\\n            if(A[i] == 0 &&  flippedCount % 2 == 0)\\n            {\\n                if(i + K > len) return -1;\\n                \\n                steps++;\\n                flippedCount++;\\n                A[i] += -2; // Record the flip\\n            }\\n            \\n            if(A[i] == 1 &&  flippedCount % 2 == 1)\\n            {\\n                if(i + K > len) return -1;\\n                \\n                steps++;\\n                flippedCount++;                \\n                A[i] += -2; // Record the flip\\n            }\\n            \\n            if(i >= (K - 1) && A[i - K + 1] < 0)\\n            {\\n                flippedCount--;\\n                A[i-K + 1] += 2; // Restore the value\\n            } \\n        }\\n        \\n        return steps;\\n       \\n    }\\n    \\n    private static int GreedyWithQueue(int[] A, int K)\\n    {   var len = A.Length;\\n     \\n        // For details read **Optimized** Section above\\n        var q = new Queue<int>();\\n        var steps = 0;\\n        for(var i = 0; i < len; i++)\\n        {\\n            if(A[i] == 0 &&  q.Count % 2 == 0)\\n            {\\n                steps++;\\n                q.Enqueue(i + K - 1);\\n            }\\n            \\n            if(A[i] == 1 &&  q.Count % 2 == 1)\\n            {\\n                steps++;\\n                q.Enqueue(i + K - 1);\\n            }\\n            \\n            if(q.Count > 0 && i >= q.Peek()) q.Dequeue();\\n        }\\n        \\n        return q.Count > 0 ? -1 : steps;\\n    }\\n    \\n    private static int Greedy(int[] A, int K)\\n    {\\n        var len = A.Length;\\n        // Greedy approach\\n        // find the first 0, flip and continue.\\n        // All elements left of i will be 1 now\\n        // Repeat\\n        var steps = 0;\\n        for(var i = 0; i < len; i++)\\n        {\\n            if(A[i] == 1)\\n                continue;\\n            \\n            if(i + K > len)\\n                return -1;\\n            \\n            for(var j = i; j < i + K; j++)\\n            {\\n                A[j] = A[j] ^ 1;\\n            }\\n            \\n            steps++;\\n        }\\n            \\n        return steps;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 238819,
                "title": "c-queue-based-method-o-n",
                "content": "THe idea is simple : we scan each element from left to right. Whenever we find an element 0, we have to flip a K-length subarray. Thus a naive method works in O(NK) complexity.\\nThis is not acceptable if both N and K are large.\\n\\nThe workaround is simple as well. Whenever we find an element is 0, we push its index i into the queue. The question is how to know whether A[i] is 0 or not after having many flips? If originally A[i]==0, and we have flipped even number times, then A[i] will still be 0. On the other hand, if A[i]==1, and we have flipped odd number times, then A[i] will be 0. So the condition is (A[i]+q.size())%2==0).\\n\\n\\n    int helper_queue(vector<int> & A, int K){\\n        int res = 0;\\n        const int m = A.size();\\n        queue<int> q;\\n        for(int i = 0; i < m; i++){\\n            if(!q.empty()&&i+q.front()>=K)\\n                q.pop();\\n            if((A[i]+q.size())%2==0){\\n                if(i>m-K)\\n                    return -1;\\n                q.push(-i);\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n",
                "solutionTags": [],
                "code": "THe idea is simple : we scan each element from left to right. Whenever we find an element 0, we have to flip a K-length subarray. Thus a naive method works in O(NK) complexity.\\nThis is not acceptable if both N and K are large.\\n\\nThe workaround is simple as well. Whenever we find an element is 0, we push its index i into the queue. The question is how to know whether A[i] is 0 or not after having many flips? If originally A[i]==0, and we have flipped even number times, then A[i] will still be 0. On the other hand, if A[i]==1, and we have flipped odd number times, then A[i] will be 0. So the condition is (A[i]+q.size())%2==0).\\n\\n\\n    int helper_queue(vector<int> & A, int K){\\n        int res = 0;\\n        const int m = A.size();\\n        queue<int> q;\\n        for(int i = 0; i < m; i++){\\n            if(!q.empty()&&i+q.front()>=K)\\n                q.pop();\\n            if((A[i]+q.size())%2==0){\\n                if(i>m-K)\\n                    return -1;\\n                q.push(-i);\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2629720,
                "title": "python-o-n-solution-explained",
                "content": "I tried the brute force way to take each subarray that starts with 0 and flip each number manually from 0 to 1 and 1 to 0 but to no surprise, it showed TLE for large inputs.\\n\\nCouldn\\'t think of an optimized solution so had to head over to the discussion section and came across this - https://leetcode.com/problems/minimum-number-of-k-consecutive-bit-flips/discuss/239284/C%2B%2B-greedy-stack-and-O(1)-memory\\n\\nIf you take a look at the first comment under this post, that explains everything in detail so you get a clear idea what exactly the code is doing.\\n\\nHere is my explanation of it - \\n\\nWe only flip a window if it starts with a 0 because we want the whole array to have only 1s. So we are not concered with 1s here. The main motive is to convert all 0 to 1 (If it is possible).\\n\\nThe brute force way is to check each window and then for each window, if it starts with 0, take each element and flip it. But ofcourse that is not efficient way because we will do repeatitive work.\\n\\n\\te.g. suppose nums = [0,1,0,1,0,1] and k = 3\\n\\tSo it we take the first 3 length subarray we get [0,1,0]\\n\\n\\tAnd since it starts with 0, we flip each element to get [1,0,1] and so array becomes \\n\\t\\t\\t[1,0,1,1,0,1]\\n\\t\\t\\t\\n\\tNow when we go to next subarray of size 3, we get [0,1,1]\\n\\tAnd again for the same reason, we flip it to get [1,0,0] and array becomes \\n\\t\\t\\t\\n\\t\\t\\t[1,1,0,0,0,1]\\n\\t\\t\\t\\nBut did you notice that we flipped the second number in original array twice which resulted in it becoming the same as it was in the beginning. So first we flipped 1 to 0 and then we flipped 0 to 1. Eventually, we got the same number back. So our flipping is of no use for some cases.\\n\\nIn Simple words -\\n\\n\\t\\tFlipping 1 or 0 Even Number of times will give us the same number\\n\\t\\tFlipping 1 or 0 Odd Number of times will give us the opposite\\n\\t\\t\\nAnd since we want to convert all 0 to 1 and do not want to convert 1 to 0, we can say \\n\\n\\t  If a number is 0, flip it once if it has already been flipped even number of times\\n\\t  If a number is 1, flip is once if it has already been flipped odd number of times\\n\\t  \\nBecause in both cases, we will get back 1. Which is our main motive here.\\n\\nAnd now the main thing is to have a way to check if a current index has been flipped before? If yes, then how many times - Even number of times or Odd number of times.\\n\\nAnd that\\'s where Queue comes into the picture.  We will use the queue to keep track of all the k-length windows that have been flipped. And as we complete traversing a k length window, we will also remove it from queue as we no longer need to keep track of it.\\n\\nThe reason why we have to keep track is because of the same reason I explained above where we were flipping a 1 twice, just to get back 1 which was of no use. \\n\\n\\t\\t\\te.g. [0,0,0,1,0,1,1,0], k = 3\\n\\t\\t\\t\\nIf we take a subarray of size k, we get [0,0,0]\\nBecause it starts with a 0 we can flip it. But we also need to check if it has already been flipped even number of times or not. Because only then we know it was 0 and again it became 0 after even flips. Since currently queue is empty or length is 0, it basically means even flips because 0 % 2 == 0 So we can flip this window.\\n\\t\\nAnd to track the flips for this window, we will also put the last index of this window in a queue. The last index is 2 i.e., (i + k - 1)\\n\\t\\n\\t\\tnums =  [0,0,0,1,0,1,1,0]\\n\\t\\tqueue = [2]\\n\\t\\tflips = 1\\n\\nSo now you can see that this queue basically tells how many times any element till index = 2 has been flipped. Since length of queue is 1, that means each element was flipped once. \\n\\n\\t\\tNext window of size = 3 is [0,0,1] from index 1 to 3\\n\\t\\nHere, as it starts with a 0, we check is the length of queue even i.e., has this 0 been flipped even times? NO! Length of queue is 1 that means, this 0 has been flipped once so we do not need to flip it again as one flip has already turned it into a 1.\\n\\n\\t\\tNext window of size 3 = [0,1,0] from index 2 to 4\\n\\t\\t\\nAgain, it starts from a 0. And for the same reason as above, we do nothing as length of queue is odd so this 0 has been flipped odd times so it is already 1. \\n\\nAnd now, we move to index = 3 which means we are done with the window from index 0 to 2 of length 3. So we no longer need to track it in the queue and so, we remove the last index of previous window from the queue.\\n\\n\\t\\tnums =  [0,0,0,1,0,1,1,0]\\n\\t\\tqueue = []\\n\\t\\tflips = 1\\n\\n\\tWe are now at index = 3 and the window of size k is [1,0,1]\\n\\nWe see that at index = 3, we have 1. We know that we will flip a 1 only if it has been flipped odd number of times because only in that case this 1 would\\'ve converted to 0. Here, length of queue = 0 which is even. So no need to flip. \\n\\nDo note that we only add the index of last window element if we flip this window. Here we did not flip the window [1,0,1] from index = 3 to 5\\n\\n\\tNext window is [0,1,1] from index = 4 to 6\\n\\nWe see that at index = 4, we have 0. We check if this window has been flipped even times before. We see that length of queue == 0 which is even. So yes, we have to flip this window to convert this 0 to 1. And so, we also add the last index of this window in the queue to keep track of flips.\\n\\t\\t\\n\\t\\tnums =  [0,0,0,1,0,1,1,0]\\n\\t\\tqueue = [6]\\n\\t\\tflips = 2\\n\\nNext window is [1,1,0] from index = 5 to 7\\n\\nSince the first element is 1, we check the length of queue. Length is 1, which is odd. So it means, this 1 has been flipped odd number of times before which means it should be 0 right now (if we had manually flipped). So to turn it back to 1, it needs to be flipped one more time. Hence, we flip this window and so, we also put the last index of this window in the queue.\\n\\t\\t\\n\\t\\tnums =  [0,0,0,1,0,1,1,0]\\n\\t\\tqueue = [6,7]\\n\\t\\tflips = 3\\n\\t\\t\\nNext, we reach the index = 6. And we see that at index = 6, we have 1. Since length of queue is even, it means that this 1 has not changed to 0 after all the previous flips. So we do not flip it.\\n\\nBut since we are done with index 6, we can safely remove it from queue.\\n\\n\\t\\tnums =  [0,0,0,1,0,1,1,0]\\n\\t\\tqueue = [7]\\n\\t\\tflips = 3\\n\\t\\t\\nAnd finally, we are at index = 7. We have 0. Since queue is of odd length now, it means 0 has been flipped odd times and so it has become 1. So no need to flip. And as we are done with index = 7, we can remove it from queue.\\n\\n\\t\\tnums =  [0,0,0,1,0,1,1,0]\\n\\t\\tqueue = []\\n\\t\\tflips = 3\\n\\t\\t\\nAnd loop ends and we see that since queue is empty, that means, we did 3 k-bit flips to convert all elements to 1.\\n\\n# **WHEN CAN WE NOT CONVERT ALL 0 TO 1?**\\nThe above example was for a valid array in which we can do 3 k-bit flips to turn all 0 to 1. What about invalid cases. How to check those?\\n\\n\\tLets take - nums = [1,1,0], k = 2\\n\\tq = []\\n\\t\\nWe start with first index. As it is 1 and length of q is even, that means we don\\'t need to flip it.\\nWe come to the index = 1. Here again, we have 1 and length of q is even. So no flips.\\nThen we come to index = 2. Here we have 0. Since length of queue is even, that means we need to flip it. And also we store the last index of this window in the queue i.e., i + k - 1 => 2 + 2 - 1 => 3\\n\\nSo, \\n\\t\\n\\tnums = [1,1,0], k = 2\\n\\tflips = 1\\n\\tq = [3]\\n\\t\\nBut now our loop ends. And our queue is not empty. This means No matter how we flip subarrays of size 2, we cannot make the array become [1,1,1].\\n\\nIt the array was [1,1,0,0] then we would be able to flip the last two zeros to 1 and in that case, queue would be empty.\\n\\nIn simple words - \\n\\n\\t\\tIf queue is empty, we can do some or 0 k-bit flips to get all 1s in the array\\n\\t\\tIf queue is not empty, there is no way to get all 1s by doing k-bit flips\\n\\n\\n```\\ndef minKBitFlips(self, nums: List[int], k: int) -> int:\\n        flips = 0\\n        q = deque()\\n        \\n        for i,num in enumerate(nums):\\n            # Number of Items in queue = how many times current index has been flipped\\n            # So if 0 is flipped even times, it will be 0 again. That means, we need to flip it again\\n            # Similarly, if 1 is flipped odd times, it will be 0 again. So we need to again flip it to get 1 back\\n            \\n            condition1 = num == 0 and len(q) % 2 == 0\\n            condition2 = num == 1 and len(q) % 2 != 0\\n            \\n            # If any of the two conditions are true, that means we need to flip this k-length window\\n            # So put the last index of this window in queue to keep track of flips\\n            if condition1 or condition2: \\n                flips += 1\\n                q.append(i + k - 1)\\n            \\n            # Remove the index from queue if we are done traversing the k-length window\\n            if q and i >= q[0]: q.popleft()\\n        \\n        return -1 if q else flips\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef minKBitFlips(self, nums: List[int], k: int) -> int:\\n        flips = 0\\n        q = deque()\\n        \\n        for i,num in enumerate(nums):\\n            # Number of Items in queue = how many times current index has been flipped\\n            # So if 0 is flipped even times, it will be 0 again. That means, we need to flip it again\\n            # Similarly, if 1 is flipped odd times, it will be 0 again. So we need to again flip it to get 1 back\\n            \\n            condition1 = num == 0 and len(q) % 2 == 0\\n            condition2 = num == 1 and len(q) % 2 != 0\\n            \\n            # If any of the two conditions are true, that means we need to flip this k-length window\\n            # So put the last index of this window in queue to keep track of flips\\n            if condition1 or condition2: \\n                flips += 1\\n                q.append(i + k - 1)\\n            \\n            # Remove the index from queue if we are done traversing the k-length window\\n            if q and i >= q[0]: q.popleft()\\n        \\n        return -1 if q else flips\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2415713,
                "title": "c-modular-solution-thought-process",
                "content": "I had no idea how to solve it just by thinking alone, so I wrote some examples to observe if there\\'re any patterns. Let\\'s think reversely from a vector with all 1 and flip some random indexes:\\n\\n```plaintext\\n// 1 1 1 1 1 1 1 1, k=3\\n// 1 0 0 0 1 1 1 1\\n//   ^^^^^ flip\\n// 1 0 0 1 0 0 1 1\\n//       ^^^^^ flip\\n// 1 1 1 0 0 0 1 1\\n//   ^^^^^ flip\\n```\\n\\n**Observation 1**: Flipping at the same index `i=1` will cancel out the effects for bit `i`. Flipping 3,5,7,... times is equal to flipping 1 time. Flipping 2,4,6,... times is equal to not flipping at all. So we only need to decide whether to flip at index `i`. There are `n-k+1` indexes to decide. If we brute-force our way that means there\\'re `2^(n-k+1)` combinations which is too big.\\n\\nThen I wrote the second example:\\n\\n```plaintext\\n// 1 1 1 1 1 1 1 1, k=3\\n// 1 0 0 0 1 1 1 1\\n//   ^^^^^ flip\\n// 1 0 1 1 0 1 1 1\\n//     ^^^^^ flip\\n// 1 0 1 0 1 0 1 1\\n//       ^^^^^ flip\\n```\\n\\nWe know the answer requires 3 flips. What if we don\\'t know the answer? We could scan from left to right and decide whether we want to flip k bits from the index `i`. Here\\'s another observation I made at this point:\\n\\n**Observation 2**: If we scan from left to right, we must flip from index `i` if the current bit is `0`, otherwise the answer would be false if we skip to the next index. Similarly, we must not flip from index `i` if the current bit is `1`.\\n\\nIn the above example, we must flip at `i==1`, otherwise the bit `0` will be left behind and we\\'ll never have a chance to have every bit as 1.\\n\\n**Time complexity analysis (naive)**: So it looks like we can use greedy approach, simply scan from left to right and flip bits from `i` to `i+k-1`. Why is this problem hard? It left me scratching my head. But I soon realized why when I tried to analyze the time complexity. If we flip `k` bits from each index, there\\'re `n-k+1` possible indexes to flip, so we have `k*(n-k+1)` operations to do. If `k==n/2` it will be `n/2 * (n - n/2 + 1)` which is approximately `n/2 * n/2 == n^2/4`. It will definitely TLE with `n == 10^5`.\\n\\nScanning from left to right is critical for greedy algorithm to work, so it looks like we need to look for other places to optimize. What about the flipping `k` bits operation at each index `i`? It\\'s still hard for me to think any optimization tips, so I wrote the third example with `k == n/2` and a larger `n == 10`:\\n\\n```plaintext\\n// 1 1 1 1 1 1 1 1 1 1, k=5\\n// 0 0 0 0 0 1 1 1 1 1\\n// ^^^^^^^^^ range=[0,4]\\n// 0 1 1 1 1 0 1 1 1 1\\n//   ^^^^^^^^^ range=[1,5]\\n// 0 1 0 0 0 1 0 1 1 1\\n//     ^^^^^^^^^ range=[2,6]\\n// 0 1 0 1 1 0 1 0 1 1\\n//       ^^^^^^^^^ range=[3,7]\\n// 0 1 0 1 0 1 0 1 0 1\\n//         ^^^^^^^^^ range=[4,8]\\n// 0 1 0 1 0 0 1 0 1 0\\n//           ^^^^^^^^^ range=[5,9]\\n```\\n\\nSuppose if the current `i==2`, the original bit is `0`, but it will be affected by the previous 2 flips with ranges `[0,4]` and `[1,5]`. Simiarly, if the current `i==5`, it will not be affected by range `[0,4]` since `5` doesn\\'t fall under the range. So we only need to check the ending number in each range. We can also observe that the ending numbers form a strictly increasing array. To get the correct bit value, we can count the number of ranges that affect the current index. If the number of ranges is 0,2,4,6,... it means the original bit is not affected, otherwise the bit is affected (0->1, 1->0).\\n\\n**Optimization**: When flipping the bit at index `i`, we push back the ending number of the affecting range `[i, i+k-1]` to an array. And later when we are at another higher index `j` we check if the oldest range in the array doesn\\'t affect the current index `j` anymore, if so, we remove the front ending number from the array. Then we calculate the corrected bit at the current index by counting the number of ranges.\\n\\n**Time complexity (optimized)**: We still iterate from left to right, but we only push/pop from the ending number array with at most 1 operation, so the overall time complexity is `O(n)`\\n\\nAfter writing down the examples, the approach and the time complexity analysis, it took just a few minutes to implement the idea and got accepted:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        deque<int> flipRangeEnds; // inclusive\\n        int numFlips = 0;\\n        for (int i = 0; i < nums.size() - k + 1; i++) {\\n            removeUnaffectedRanges(i, flipRangeEnds);\\n            if (getBit(nums, i, flipRangeEnds) == 0) {\\n                numFlips++;\\n                // Add the range, it will affect indexes [i, i+k-1]\\n                flipRangeEnds.push_back(i + k - 1);\\n            }\\n        }\\n        return isRemainingBitsAllOne(nums, k, flipRangeEnds) ? numFlips : -1;\\n    }\\n    \\n    bool isRemainingBitsAllOne(const vector<int>& nums, const int k, deque<int> &flipRangeEnds) {\\n        for (int i = nums.size() - k + 1; i < nums.size(); i++) {\\n            removeUnaffectedRanges(i, flipRangeEnds);\\n            if (getBit(nums, i, flipRangeEnds) == 0) return false;\\n        }\\n        return true;\\n    }\\n    \\n    void removeUnaffectedRanges(const int i, deque<int> &flipRangeEnds) {\\n        if (flipRangeEnds.empty()) return;\\n        if (flipRangeEnds.front() < i) {\\n            flipRangeEnds.pop_front();\\n        }\\n    }\\n    \\n    int getBit(const vector<int>& nums, const int i, const deque<int> &flipRangeEnds) {\\n        const int numFlips = flipRangeEnds.size();\\n        return (nums[i] + numFlips) % 2;\\n    }\\n};\\n```\\n\\nI was stuggling whether to merge the main `for` loop with `isRemainingBitsAllOne`, but separating them would make the code more readable so I just kept it as it is.\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```plaintext\\n// 1 1 1 1 1 1 1 1, k=3\\n// 1 0 0 0 1 1 1 1\\n//   ^^^^^ flip\\n// 1 0 0 1 0 0 1 1\\n//       ^^^^^ flip\\n// 1 1 1 0 0 0 1 1\\n//   ^^^^^ flip\\n```\n```plaintext\\n// 1 1 1 1 1 1 1 1, k=3\\n// 1 0 0 0 1 1 1 1\\n//   ^^^^^ flip\\n// 1 0 1 1 0 1 1 1\\n//     ^^^^^ flip\\n// 1 0 1 0 1 0 1 1\\n//       ^^^^^ flip\\n```\n```plaintext\\n// 1 1 1 1 1 1 1 1 1 1, k=5\\n// 0 0 0 0 0 1 1 1 1 1\\n// ^^^^^^^^^ range=[0,4]\\n// 0 1 1 1 1 0 1 1 1 1\\n//   ^^^^^^^^^ range=[1,5]\\n// 0 1 0 0 0 1 0 1 1 1\\n//     ^^^^^^^^^ range=[2,6]\\n// 0 1 0 1 1 0 1 0 1 1\\n//       ^^^^^^^^^ range=[3,7]\\n// 0 1 0 1 0 1 0 1 0 1\\n//         ^^^^^^^^^ range=[4,8]\\n// 0 1 0 1 0 0 1 0 1 0\\n//           ^^^^^^^^^ range=[5,9]\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        deque<int> flipRangeEnds; // inclusive\\n        int numFlips = 0;\\n        for (int i = 0; i < nums.size() - k + 1; i++) {\\n            removeUnaffectedRanges(i, flipRangeEnds);\\n            if (getBit(nums, i, flipRangeEnds) == 0) {\\n                numFlips++;\\n                // Add the range, it will affect indexes [i, i+k-1]\\n                flipRangeEnds.push_back(i + k - 1);\\n            }\\n        }\\n        return isRemainingBitsAllOne(nums, k, flipRangeEnds) ? numFlips : -1;\\n    }\\n    \\n    bool isRemainingBitsAllOne(const vector<int>& nums, const int k, deque<int> &flipRangeEnds) {\\n        for (int i = nums.size() - k + 1; i < nums.size(); i++) {\\n            removeUnaffectedRanges(i, flipRangeEnds);\\n            if (getBit(nums, i, flipRangeEnds) == 0) return false;\\n        }\\n        return true;\\n    }\\n    \\n    void removeUnaffectedRanges(const int i, deque<int> &flipRangeEnds) {\\n        if (flipRangeEnds.empty()) return;\\n        if (flipRangeEnds.front() < i) {\\n            flipRangeEnds.pop_front();\\n        }\\n    }\\n    \\n    int getBit(const vector<int>& nums, const int i, const deque<int> &flipRangeEnds) {\\n        const int numFlips = flipRangeEnds.size();\\n        return (nums[i] + numFlips) % 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1921449,
                "title": "python-o-1",
                "content": "Credit to: https://leetcode.com/problems/minimum-number-of-k-consecutive-bit-flips/discuss/238609/JavaC%2B%2BPython-One-Pass-and-O(1)-Space\\n\\u597D\\u9AD8\\u7EA7\\u7684\\u5199\\u6CD5\\n```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        \\n        # even fliped = no flip\\n        # odd fliped = flip once\\n        \\n        fliped = 0\\n        ans = 0\\n        n = len(nums)\\n        \\n        for i in range(n):\\n            if i >= k and nums[i-k]>1: #\\u5F53win size\\u8D85\\u51FA\\u8303\\u56F4\\uFF0C\\u800C\\u4E14\\u90A3\\u4E2A\\u6570\\u662F\\u4E4B\\u524D\\u7FFB\\u8F6C\\u8FC7\\u7684\\u6570\\uFF0C\\u91CD\\u7F6Efliped(\\u51C6\\u786E\\u8BA1\\u7B97\\u4E0B\\u4E00\\u6570flip\\u7684\\u4E2A\\u6570)\\n                fliped -= 1\\n                nums[i-k] -= 2  # \\u628Aflip\\u540E\\u6807\\u8BB0\\u7684\\u6570\\u53D8\\u56DE\\u539F\\u6765\\u7684\\u6570\\u5B57\\n            if fliped%2 == nums[i]: # 0 flip even time is 0, 1 flip odd time is 0,\\u8FD9\\u79CD\\u60C5\\u51B5\\u9700\\u8981\\u7FFB\\u8F6C\\n                if i + k > n:\\n                    return -1\\n                ans += 1\\n                fliped += 1\\n                nums[i] += 2\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        \\n        # even fliped = no flip\\n        # odd fliped = flip once\\n        \\n        fliped = 0\\n        ans = 0\\n        n = len(nums)\\n        \\n        for i in range(n):\\n            if i >= k and nums[i-k]>1: #\\u5F53win size\\u8D85\\u51FA\\u8303\\u56F4\\uFF0C\\u800C\\u4E14\\u90A3\\u4E2A\\u6570\\u662F\\u4E4B\\u524D\\u7FFB\\u8F6C\\u8FC7\\u7684\\u6570\\uFF0C\\u91CD\\u7F6Efliped(\\u51C6\\u786E\\u8BA1\\u7B97\\u4E0B\\u4E00\\u6570flip\\u7684\\u4E2A\\u6570)\\n                fliped -= 1\\n                nums[i-k] -= 2  # \\u628Aflip\\u540E\\u6807\\u8BB0\\u7684\\u6570\\u53D8\\u56DE\\u539F\\u6765\\u7684\\u6570\\u5B57\\n            if fliped%2 == nums[i]: # 0 flip even time is 0, 1 flip odd time is 0,\\u8FD9\\u79CD\\u60C5\\u51B5\\u9700\\u8981\\u7FFB\\u8F6C\\n                if i + k > n:\\n                    return -1\\n                ans += 1\\n                fliped += 1\\n                nums[i] += 2\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1751996,
                "title": "c-beginner-friendly-explained-solution-easy-understandable",
                "content": "\\n\\n         Note that we dont actually flip the values in the array. \\n\\t\\t Since all possible values are 0 and 1, we can simply use a knowledge of \\n\\t\\t \"how many times\" any given index has been flipped to know the whats the current \\n\\t\\t state of the value is.\\n\\t\\t \\n\\t\\t We can use our queue to keep track of how many times the window/interval has been\\n\\t\\t flipped and whats the last index (end of any k -window) of a current interval that was \\n\\t\\t flipped and keep popping off these indexes from the queue when we are done\\n\\t\\t with traversing that k-interval. Thus , as you can see our queue is a dual-purpose queue\\n        \\n\\t\\t  int minKBitFlips(vector<int>& nums, int k) {\\n            int n=nums.size();\\n            int count=0;\\n            queue<int> q;\\n            for(int i=0;i<n;i++)\\n            {\\n                    if(nums[i]==0)\\n                    {\\n                      if(q.empty() || q.size()%2==0)\\n                      {\\n                        count++;\\n                              q.push(i+k-1);\\n                      }\\n                            \\n                    }\\n                    else\\n                    {\\n                            if(q.size()%2!=0)\\n                            {\\n                                    count++;\\n                                    q.push(i+k-1);\\n                            }\\n                    }\\n                    // k length  window if i >= window\\'s end pop it \\n                    if(!q.empty() && i>=q.front())\\n                    {\\n                            q.pop();\\n                    }\\n            }\\n            if(q.empty())\\n            return count;\\n            else\\n            {\\n                    return -1;\\n            }\\n            \\n    }",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "\\n\\n         Note that we dont actually flip the values in the array. \\n\\t\\t Since all possible values are 0 and 1, we can simply use a knowledge of \\n\\t\\t \"how many times\" any given index has been flipped to know the whats the current \\n\\t\\t state of the value is.\\n\\t\\t \\n\\t\\t We can use our queue to keep track of how many times the window/interval has been\\n\\t\\t flipped and whats the last index (end of any k -window) of a current interval that was \\n\\t\\t flipped and keep popping off these indexes from the queue when we are done\\n\\t\\t with traversing that k-interval. Thus , as you can see our queue is a dual-purpose queue\\n        \\n\\t\\t  int minKBitFlips(vector<int>& nums, int k) {\\n            int n=nums.size();\\n            int count=0;\\n            queue<int> q;\\n            for(int i=0;i<n;i++)\\n            {\\n                    if(nums[i]==0)\\n                    {\\n                      if(q.empty() || q.size()%2==0)\\n                      {\\n                        count++;\\n                              q.push(i+k-1);\\n                      }\\n                            \\n                    }\\n                    else\\n                    {\\n                            if(q.size()%2!=0)\\n                            {\\n                                    count++;\\n                                    q.push(i+k-1);\\n                            }\\n                    }\\n                    // k length  window if i >= window\\'s end pop it \\n                    if(!q.empty() && i>=q.front())\\n                    {\\n                            q.pop();\\n                    }\\n            }\\n            if(q.empty())\\n            return count;\\n            else\\n            {\\n                    return -1;\\n            }\\n            \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1683054,
                "title": "java-pref-sum",
                "content": "```\\nclass Solution {\\n    public int minKBitFlips(int[] nums, int k) {\\n        int n=nums.length;\\n        int[] pref=new int[n];\\n        for(int i=0; i<n; i++){\\n            if(i==0){\\n                if(nums[i]==0){\\n                    pref[i]++;\\n                }\\n            }else{\\n                pref[i]=pref[i-1];\\n                int flips=pref[i]-((i-k)>=0?pref[i-k]:0);\\n                if(flips%2==nums[i]){\\n                    if(i+k>n){\\n                        return -1;\\n                    }\\n                    pref[i]++;\\n                }\\n            }\\n        }\\n        return pref[n-1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minKBitFlips(int[] nums, int k) {\\n        int n=nums.length;\\n        int[] pref=new int[n];\\n        for(int i=0; i<n; i++){\\n            if(i==0){\\n                if(nums[i]==0){\\n                    pref[i]++;\\n                }\\n            }else{\\n                pref[i]=pref[i-1];\\n                int flips=pref[i]-((i-k)>=0?pref[i-k]:0);\\n                if(flips%2==nums[i]){\\n                    if(i+k>n){\\n                        return -1;\\n                    }\\n                    pref[i]++;\\n                }\\n            }\\n        }\\n        return pref[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1460036,
                "title": "greedy-odd-even-logic",
                "content": "```\\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\\nclass Solution {\\n    int ans;\\npublic:\\n    int solver(vector<int>& a,int k){\\n        int n=a.size(),i=0,cnt=0;\\n        int p[n+k+2];\\n        memset(p,0,sizeof(p));\\n        \\n\\t\\t// if 1st element is 0 we flip it and store that a flip was made in the prefix function\\n        if(a[0]==0){\\n            p[0]++;\\n            p[k]--;\\n            cnt++;\\n        }\\n        \\n        for(i=1;i<n;i++){\\n\\t\\t\\t// this tell us inside how many flipped windows ith element has fallen i.e no of times ith element has been flipped\\n            p[i]+=p[i-1];\\n\\t\\t\\t\\n\\t\\t\\t// if element is 1 and has been flipped odd times we need to flip it again to make it 0\\n            if(a[i]==1){\\n                if(p[i]&1){\\n                    p[i]++;\\n                    cnt++;\\n\\t\\t\\t\\t\\t// if choosing a flipping window some part of window falls outside the range then return NOT POSSIBLE\\n                    if(i+k>n){\\n                        cnt=INT_MAX;\\n                        break;\\n                    }\\n                    p[i+k]--;\\n                }\\n            }\\n            else{ // similar logic to flip 0->1\\n                if(p[i]%2==0){\\n                    p[i]++;\\n                    cnt++;\\n                    if(i+k>n){\\n                        cnt=INT_MAX;\\n                        break;\\n                    }\\n                    p[i+k]--;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n    \\n    int minKBitFlips(vector<int>& a, int k) {\\n        IOS;\\n\\t\\t// perform same operation on both original array as well as reversed version of array\\n        ans=solver(a,k);\\n        reverse(a.begin(),a.end());\\n        ans=min(ans,solver(a,k));\\n        if(ans==INT_MAX)\\n            return -1;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "```\\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\\nclass Solution {\\n    int ans;\\npublic:\\n    int solver(vector<int>& a,int k){\\n        int n=a.size(),i=0,cnt=0;\\n        int p[n+k+2];\\n        memset(p,0,sizeof(p));\\n        \\n\\t\\t// if 1st element is 0 we flip it and store that a flip was made in the prefix function\\n        if(a[0]==0){\\n            p[0]++;\\n            p[k]--;\\n            cnt++;\\n        }\\n        \\n        for(i=1;i<n;i++){\\n\\t\\t\\t// this tell us inside how many flipped windows ith element has fallen i.e no of times ith element has been flipped\\n            p[i]+=p[i-1];\\n\\t\\t\\t\\n\\t\\t\\t// if element is 1 and has been flipped odd times we need to flip it again to make it 0\\n            if(a[i]==1){\\n                if(p[i]&1){\\n                    p[i]++;\\n                    cnt++;\\n\\t\\t\\t\\t\\t// if choosing a flipping window some part of window falls outside the range then return NOT POSSIBLE\\n                    if(i+k>n){\\n                        cnt=INT_MAX;\\n                        break;\\n                    }\\n                    p[i+k]--;\\n                }\\n            }\\n            else{ // similar logic to flip 0->1\\n                if(p[i]%2==0){\\n                    p[i]++;\\n                    cnt++;\\n                    if(i+k>n){\\n                        cnt=INT_MAX;\\n                        break;\\n                    }\\n                    p[i+k]--;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n    \\n    int minKBitFlips(vector<int>& a, int k) {\\n        IOS;\\n\\t\\t// perform same operation on both original array as well as reversed version of array\\n        ans=solver(a,k);\\n        reverse(a.begin(),a.end());\\n        ans=min(ans,solver(a,k));\\n        if(ans==INT_MAX)\\n            return -1;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1090692,
                "title": "java-greedy-o-n-k",
                "content": "\\n    // O(A.length*K)\\n\\tpublic int minKBitFlips(int[] A, int K) {\\n\\n\\t\\tint ans = 0, len = A.length;\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tif (A[i] == 0) {\\n\\t\\t\\t\\tif (len - i < K)\\n\\t\\t\\t\\t\\treturn -1;\\n\\t\\t\\t\\ttoggleKBits(A, K, i);\\n\\t\\t\\t\\tans++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// O(K)\\n\\tpublic void toggleKBits(int[] A, int K, int idx) {\\n\\t\\tfor (int i = 0; i < K; i++) {\\n\\t\\t\\tA[idx] = A[idx] ^ 1;\\n\\t\\t\\tidx++;\\n\\t\\t}\\n\\t}\\n    \\n",
                "solutionTags": [],
                "code": "\\n    // O(A.length*K)\\n\\tpublic int minKBitFlips(int[] A, int K) {\\n\\n\\t\\tint ans = 0, len = A.length;\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tif (A[i] == 0) {\\n\\t\\t\\t\\tif (len - i < K)\\n\\t\\t\\t\\t\\treturn -1;\\n\\t\\t\\t\\ttoggleKBits(A, K, i);\\n\\t\\t\\t\\tans++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// O(K)\\n\\tpublic void toggleKBits(int[] A, int K, int idx) {\\n\\t\\tfor (int i = 0; i < K; i++) {\\n\\t\\t\\tA[idx] = A[idx] ^ 1;\\n\\t\\t\\tidx++;\\n\\t\\t}\\n\\t}\\n    \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1051312,
                "title": "swift-solution-with-inline-explanation",
                "content": "```\\nclass Solution {\\n    func minKBitFlips(_ A: [Int], _ K: Int) -> Int {\\n        var count = A.count\\n        \\n        // Keeps track of number the flips that affect the element at the current index\\n        var flipCount = 0\\n        var res = 0\\n        \\n        // Whether a flip was done at an index\\n        var isFlippedAt = Array(repeating: 0, count: count)\\n        \\n        for i in 0..<A.count {\\n            if i >= K {\\n                // at index i the flip the happened at index i-K does not affect it\\n                // so we need to remove that flip\\n                flipCount -= isFlippedAt[i-K]\\n            } \\n            \\n            if A[i] == 0 && flipCount % 2 == 1 {\\n                // if the flip count is odd that means the current bit is flipped\\n                // and if the current bit is 0 it is flipped to a 1\\n                // which is what we want\\n                // so do nothing\\n                continue\\n            } else if A[i] == 1 && flipCount % 2 == 0 {\\n                // if the flip count is 0\\n                // that means the current element stays the same\\n                // which is what we want if the current element is 1\\n                continue\\n            } else {\\n                // we get here if the flipCount is odd and current element is 1\\n                // or if the flipCount is even and the current element is 0\\n                // in which case 1 turned into a 0 or a 0 stayed as a 0\\n                // and we need to perform a flip at the current index\\n                // affecting elements from i to i+K-1\\n                \\n                // NOTE: the flip on effects the K elements starting from the current index\\n                // no elements before it are affected by this flip\\n                \\n                if (i+K) > count {\\n                    // we can possibly flip starting at this index\\n                    return -1\\n                }\\n                \\n                isFlippedAt[i] = 1\\n                flipCount += 1\\n                res += 1\\n            }\\n        }\\n        \\n        return res\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    func minKBitFlips(_ A: [Int], _ K: Int) -> Int {\\n        var count = A.count\\n        \\n        // Keeps track of number the flips that affect the element at the current index\\n        var flipCount = 0\\n        var res = 0\\n        \\n        // Whether a flip was done at an index\\n        var isFlippedAt = Array(repeating: 0, count: count)\\n        \\n        for i in 0..<A.count {\\n            if i >= K {\\n                // at index i the flip the happened at index i-K does not affect it\\n                // so we need to remove that flip\\n                flipCount -= isFlippedAt[i-K]\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 752515,
                "title": "simple-c-o-n",
                "content": "```\\nint minKBitFlips(vector<int>& A, int K) {\\n\\tvector<int> flip(A.size(), 0);\\n\\tint f = 0;\\n\\tint tot = 0;\\n\\tfor (int i = 0; i < A.size(); ++i) {\\n\\t\\tif ((f & 1) == A[i]) {\\n\\t\\t\\t++tot;\\n\\t\\t\\t++f;\\n\\n\\t\\t\\tif (i + K - 1 >= A.size()) return -1;\\n\\t\\t\\tflip[i + K - 1] = 1;\\n\\t\\t}\\n\\t\\tf -= flip[i];\\n\\t}\\n\\treturn tot;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint minKBitFlips(vector<int>& A, int K) {\\n\\tvector<int> flip(A.size(), 0);\\n\\tint f = 0;\\n\\tint tot = 0;\\n\\tfor (int i = 0; i < A.size(); ++i) {\\n\\t\\tif ((f & 1) == A[i]) {\\n\\t\\t\\t++tot;\\n\\t\\t\\t++f;\\n\\n\\t\\t\\tif (i + K - 1 >= A.size()) return -1;\\n\\t\\t\\tflip[i + K - 1] = 1;\\n\\t\\t}\\n\\t\\tf -= flip[i];\\n\\t}\\n\\treturn tot;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 545584,
                "title": "easy-to-understand-and-clean-c-code",
                "content": "inserting last element in queue which will be affected if toogles are made on ith index i.e i+k-1 and then checking for each index what is the size of queue if it is even then it emplies even number of toggles are made uptill now on that index and therefore complexity reduces to O(n);\\n```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& a, int k) {\\n       int n=a.size(),count=0;\\n    queue<int> flip;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]==1)\\n            {\\n                if((flip.size()%2))\\n                    count++,flip.push(i+k-1);\\n            }\\n            if(a[i]==0)\\n            {\\n                if(!(flip.size()%2))\\n                    count++,flip.push(i+k-1);\\n            }\\n            if(!flip.empty()&&flip.front()<=i)\\n                flip.pop();\\n        }\\n        if(flip.empty())\\n            return count;\\n        else\\n            return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& a, int k) {\\n       int n=a.size(),count=0;\\n    queue<int> flip;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]==1)\\n            {\\n                if((flip.size()%2))\\n                    count++,flip.push(i+k-1);\\n            }\\n            if(a[i]==0)\\n            {\\n                if(!(flip.size()%2))\\n                    count++,flip.push(i+k-1);\\n            }\\n            if(!flip.empty()&&flip.front()<=i)\\n                flip.pop();\\n        }\\n        if(flip.empty())\\n            return count;\\n        else\\n            return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 517280,
                "title": "detailed-explanation-on-the-o-n-time-and-o-n-space-solution-with-bit-operation",
                "content": "### greedy mind \\nThe question asks how many consecutive flips are needed, so we can use a greedy concept to solve. The intuition is that, thinking of the very first element, look rightwards by k step, if the A[0] ==0, we definitely need to flip this position, then for every other elements in this k size window, if it has been flipped to, or is originally 1, we should skip and keep moving rightwards. Thus, we need to have a for loop, and each i index denotes the **start position** of this k length window. The -1 case is that, if at the index that i+k>total length, but we also find this indexed position needs to be flipped, then its game over, return -1, as the window would be out of the array range. \\n\\n\\n\\n### when does this position need a flip?\\n- if the arr(i)==0 and this position is never flipped, so obviously we need 1 flip. \\n- - if the arr(i)==0 and this position has been flipped once (or any odd times),  we dont need to touch here anymore. \\n- if the arr(i) ==1 and  this position is never flipped, as per the greedy mind, we can continue, so dont need flip at all \\n- if the arr(i) ==1 and  this position has been ever flipped once (or any odd times), this position value must be 0, so we need to have another flip. \\n\\nSo we can have a global variable *prevFlippedState* to denote **for how many times this position has been filpped before**. If the prevFlippedState is even or 0, this means that this position has been never, or reset to its original value, otherwise, this position has been flipped to the value that is opposite to its original value. Plus, we dont need to accumulate the times, instead, we just keep XOR on prevFlippedState to get even/odd indicator. Hence we can reach the following assumption. \\n```\\nif (arr(i)==prevFlippedState) then this position\\'s current value must be 0, then we need flip \\ne.g.,\\nif (arr(i)==prevFlippedState ==1 ), then means the original value on arr(i)==1, and it has been flipped for odd times, then current value must be 0 \\nif (arr(i)==prevFlippedState ==0 ), then means the original value on arr(i)==0, and it has been flipped for even times or just never, then current value must be 0 \\nif (arr(i)==1 and prevFlippedState ==0 ), then means the original value on arr(i)==1, and it has been flipped for even times or just never, then current value must be 1, so we dont need to flip\\nif (arr(i)==0 and prevFlippedState ==1 ), then means the original value on arr(i)==0, and it has been flipped for odd times, then current value must be 1, so we dont need to flip\\n```\\n\\nSo, just to recap, everytime when we need to flip, we need to XOR on the prevFlippedState with 1, and we iterate over the loop and i denotes the start of the window. \\n\\n### when a start index can be impacted by previous window? (i.e., i>=k)\\nThere can be four possibilities as follows, when a start index depends on all previous window operation. The reason that we need to consider this is that, the prevFlippedState denotes the state when we just reach i-index, but it does not mean anything when we finish the check on the i-index. Plus, as the i index denotes the start postion, so the current i-index could be also impacted by every single indexs (j) before it, as long as i and j are in the same k windwo.  \\n\\n**Therefore, the *prevFlippedState* value may not be correct if the i-index can be impacted by the previous windows, hence we need to correct this value.**\\n\\n*Lets look at the index i-k, from which the the leftest window starts and can also impact the prevFlippedState value (after we check the index i-1, and right reach index i )*\\n\\n- prevFlippedState ==0, which means here i-index has been flipped for even times or just never (==a, an even or 0 number) when we reach here, thus the value is for sure equal to its original value. if the value indexed at i-k ==0 as well (means an even or 0 number flip, denoted by b), then for sure the  prevFlippedState at the index i must be an even or 0 times, as a+-b opearion must yield an even value. \\n- prevFlippedState ==0, which means here i-index has been flipped for even times or just never (==a, an even or 0 number) when we reach here, thus the value is for sure equal to its original value. if the value indexed at i-k ==1 instead, (means an odd number flip, denoted by b), then for sure the  prevFlippedState at the index i must be an odd times flip, as a+-b opearion must yield an odd value. \\n- prevFlippedState ==1, which means here i-index has been flipped for odd times (==a, an odd number) when we reach here, thus the value is for sure equal to its original value. if the value indexed at i-k ==0 instead, (means an even or 0 number flip, denoted by b), then for sure the  prevFlippedState at the index i must be an odd times flip, as a+-b opearion must yield an odd value. \\n- prevFlippedState ==1, which means here i-index has been flipped for odd times (==a, an odd number) when we reach here, thus the value is for sure equal to its original value. if the value indexed at i-k ==1 as well, (means an odd number flip, denoted by b), then for sure the  prevFlippedState at the index i must be an even times flip, as a+-b opearion must yield an even value. \\n\\nAbove all, therefore, we can reach an induction to correct the value prevFlippedState before we begin to check the status of index i \\n```\\nif(i>=k) // means there must be a(many) windows before i \\nthen prevFlippedState  = prevFlippedState XOR hasBeenFlippedStateHere(i-k)\\n\\nwhere we use an array hasBeenFlippedStateHere for recording all flip history.\\n```\\n\\n### Code \\n```Scala\\n def minKBitFlips(arr: Array[Int], k: Int): Int = {\\n    var res, prevFlippedState = 0\\n    val len = arr.length\\n    val hasBeenFlippedStateHere = Array.ofDim[Int](len)\\n    for (i <- 0 until len) {\\n      if (i >= k) prevFlippedState ^= hasBeenFlippedStateHere(i - k)\\n      if ((arr(i) ^ prevFlippedState) == 0) {\\n        if (i + k > len) return -1\\n        res += 1\\n        hasBeenFlippedStateHere(i) = 1\\n        prevFlippedState ^= 1\\n      }\\n    }\\n    res\\n  }\\n  ```",
                "solutionTags": [],
                "code": "```\\nif (arr(i)==prevFlippedState) then this position\\'s current value must be 0, then we need flip \\ne.g.,\\nif (arr(i)==prevFlippedState ==1 ), then means the original value on arr(i)==1, and it has been flipped for odd times, then current value must be 0 \\nif (arr(i)==prevFlippedState ==0 ), then means the original value on arr(i)==0, and it has been flipped for even times or just never, then current value must be 0 \\nif (arr(i)==1 and prevFlippedState ==0 ), then means the original value on arr(i)==1, and it has been flipped for even times or just never, then current value must be 1, so we dont need to flip\\nif (arr(i)==0 and prevFlippedState ==1 ), then means the original value on arr(i)==0, and it has been flipped for odd times, then current value must be 1, so we dont need to flip\\n```\n```\\nif(i>=k) // means there must be a(many) windows before i \\nthen prevFlippedState  = prevFlippedState XOR hasBeenFlippedStateHere(i-k)\\n\\nwhere we use an array hasBeenFlippedStateHere for recording all flip history.\\n```\n```Scala\\n def minKBitFlips(arr: Array[Int], k: Int): Int = {\\n    var res, prevFlippedState = 0\\n    val len = arr.length\\n    val hasBeenFlippedStateHere = Array.ofDim[Int](len)\\n    for (i <- 0 until len) {\\n      if (i >= k) prevFlippedState ^= hasBeenFlippedStateHere(i - k)\\n      if ((arr(i) ^ prevFlippedState) == 0) {\\n        if (i + k > len) return -1\\n        res += 1\\n        hasBeenFlippedStateHere(i) = 1\\n        prevFlippedState ^= 1\\n      }\\n    }\\n    res\\n  }\\n  ```",
                "codeTag": "Python3"
            },
            {
                "id": 498756,
                "title": "java-o-n-sliding-window-used-queue-which-you-can-change-to-2-pointer-tagging",
                "content": "```\\nclass Solution {\\n    public int minKBitFlips(int[] nums, int K) { \\n        int ans=0;int sum=0;\\n        Queue<Integer>queue=new LinkedList<>();\\n        int startTag[]=new int[nums.length];int endTag[]=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            queue.add(i);\\n            if(queue.size()<K){\\n                continue;\\n            }\\n            int end=0;\\n            if(queue.peek()-1>=0){\\n                end=endTag[queue.peek()-1];\\n            }\\n            if((nums[queue.peek()]+sum+startTag[queue.peek()]-end)%2==0)\\n            {\\n                ans++;\\n                while(queue.size()!=0){\\n                    end=0;\\n                    if(queue.peek()-1>=0){\\n                        end=endTag[queue.peek()-1];\\n                    }\\n                    if((nums[queue.peek()]+sum+startTag[queue.peek()]-end)%2==0){\\n                        int index=queue.poll();\\n                        sum+=startTag[index];\\n                        if(index-1>=0){\\n                            sum-=endTag[index-1];\\n                        }\\n                        nums[index]=1;\\n                    }else{\\n                        break;\\n                    }\\n                }\\n                if(queue.size()!=0){\\n                    startTag[queue.peek()]++;\\n                    endTag[i]++;\\n                }\\n            }\\n            else if((nums[queue.peek()]+sum+startTag[queue.peek()]-end)%2==1)\\n            {\\n                while(queue.size()!=0){\\n                    end=0;\\n                    if(queue.peek()-1>=0){\\n                        end=endTag[queue.peek()-1];\\n                    }\\n                    if((nums[queue.peek()]+sum+startTag[queue.peek()]-end)%2==1){\\n                        int index=queue.poll();\\n                        sum+=startTag[index];\\n                        if(index-1>=0){\\n                            sum-=endTag[index-1];\\n                        }\\n                    }else{\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        while(queue.size()!=0){\\n            int index=queue.poll();\\n            sum+=startTag[index];\\n            if(index-1>=0){\\n                sum-=endTag[index-1];\\n            }\\n            if((sum+nums[index])%2==0){\\n                nums[index]=0;\\n            }else{\\n                nums[index]=1;\\n            }\\n        }\\n        if(!check(nums)){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n    \\n    public boolean check(int nums[]){\\n        int count=0;\\n        for(int n:nums)count+=n;\\n        return count==nums.length;\\n    }\\n}\\n```\\n\\nHere is the TLE solution, it is ued to help you to understand the idea for this problem, the tagging technique is used to optimize the run time complexity\\n```\\nclass Solution {\\n    public int minKBitFlips(int[] nums, int K) {\\n        int ans=0;\\n        Queue<Integer>queue=new LinkedList<>();\\n        for(int i=0;i<nums.length;i++){\\n            queue.add(i);\\n            if(queue.size()<K){\\n                continue;\\n            }\\n            if(nums[queue.peek()]==1){\\n                while(queue.size()>0&&nums[queue.peek()]==1){\\n                    queue.poll();\\n                }\\n            }else{\\n                ans++;\\n                while(queue.size()>0&&nums[queue.peek()]==0){\\n                    int index=queue.poll();\\n                    nums[index]=1;\\n                    i=index;\\n                }\\n                while(queue.size()!=0){\\n                    int index=queue.poll();\\n                    if(nums[index]==1){\\n                        nums[index]=0;\\n                    }else{\\n                       nums[index]=1; \\n                    }\\n                }\\n                \\n            }\\n        }\\n        if(!check(nums)){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n    \\n    public boolean check(int nums[]){\\n        int count=0;\\n        for(int n:nums)count+=n;\\n        return count==nums.length;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minKBitFlips(int[] nums, int K) { \\n        int ans=0;int sum=0;\\n        Queue<Integer>queue=new LinkedList<>();\\n        int startTag[]=new int[nums.length];int endTag[]=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            queue.add(i);\\n            if(queue.size()<K){\\n                continue;\\n            }\\n            int end=0;\\n            if(queue.peek()-1>=0){\\n                end=endTag[queue.peek()-1];\\n            }\\n            if((nums[queue.peek()]+sum+startTag[queue.peek()]-end)%2==0)\\n            {\\n                ans++;\\n                while(queue.size()!=0){\\n                    end=0;\\n                    if(queue.peek()-1>=0){\\n                        end=endTag[queue.peek()-1];\\n                    }\\n                    if((nums[queue.peek()]+sum+startTag[queue.peek()]-end)%2==0){\\n                        int index=queue.poll();\\n                        sum+=startTag[index];\\n                        if(index-1>=0){\\n                            sum-=endTag[index-1];\\n                        }\\n                        nums[index]=1;\\n                    }else{\\n                        break;\\n                    }\\n                }\\n                if(queue.size()!=0){\\n                    startTag[queue.peek()]++;\\n                    endTag[i]++;\\n                }\\n            }\\n            else if((nums[queue.peek()]+sum+startTag[queue.peek()]-end)%2==1)\\n            {\\n                while(queue.size()!=0){\\n                    end=0;\\n                    if(queue.peek()-1>=0){\\n                        end=endTag[queue.peek()-1];\\n                    }\\n                    if((nums[queue.peek()]+sum+startTag[queue.peek()]-end)%2==1){\\n                        int index=queue.poll();\\n                        sum+=startTag[index];\\n                        if(index-1>=0){\\n                            sum-=endTag[index-1];\\n                        }\\n                    }else{\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        while(queue.size()!=0){\\n            int index=queue.poll();\\n            sum+=startTag[index];\\n            if(index-1>=0){\\n                sum-=endTag[index-1];\\n            }\\n            if((sum+nums[index])%2==0){\\n                nums[index]=0;\\n            }else{\\n                nums[index]=1;\\n            }\\n        }\\n        if(!check(nums)){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n    \\n    public boolean check(int nums[]){\\n        int count=0;\\n        for(int n:nums)count+=n;\\n        return count==nums.length;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minKBitFlips(int[] nums, int K) {\\n        int ans=0;\\n        Queue<Integer>queue=new LinkedList<>();\\n        for(int i=0;i<nums.length;i++){\\n            queue.add(i);\\n            if(queue.size()<K){\\n                continue;\\n            }\\n            if(nums[queue.peek()]==1){\\n                while(queue.size()>0&&nums[queue.peek()]==1){\\n                    queue.poll();\\n                }\\n            }else{\\n                ans++;\\n                while(queue.size()>0&&nums[queue.peek()]==0){\\n                    int index=queue.poll();\\n                    nums[index]=1;\\n                    i=index;\\n                }\\n                while(queue.size()!=0){\\n                    int index=queue.poll();\\n                    if(nums[index]==1){\\n                        nums[index]=0;\\n                    }else{\\n                       nums[index]=1; \\n                    }\\n                }\\n                \\n            }\\n        }\\n        if(!check(nums)){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n    \\n    public boolean check(int nums[]){\\n        int count=0;\\n        for(int n:nums)count+=n;\\n        return count==nums.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 471713,
                "title": "c-solution",
                "content": "```\\npublic class Solution \\n{\\n    public int MinKBitFlips(int[] A, int K) \\n    {\\n        int result = 0;\\n        var queue = new Queue<int>();\\n        for (int i = 0; i < A.Length; i++) \\n        {\\n            if (queue.Any() && queue.Peek() <= i) \\n                queue.Dequeue();\\n            \\n            if ((A[i] + queue.Count) % 2 == 0) \\n            { \\n                result++;\\n                if (i + K > A.Length) return -1; \\n                queue.Enqueue(i + K);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int MinKBitFlips(int[] A, int K) \\n    {\\n        int result = 0;\\n        var queue = new Queue<int>();\\n        for (int i = 0; i < A.Length; i++) \\n        {\\n            if (queue.Any() && queue.Peek() <= i) \\n                queue.Dequeue();\\n            \\n            if ((A[i] + queue.Count) % 2 == 0) \\n            { \\n                result++;\\n                if (i + K > A.Length) return -1; \\n                queue.Enqueue(i + K);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 238887,
                "title": "100-time-space-python3-bit-manipulation",
                "content": "```python\\ndef minKBitFlips(self, A: \\'List[int]\\', K: \\'int\\') -> \\'int\\':\\n\\tidx = 0\\n\\tnum_digits = len(A)\\n\\tA_bitrep = int(\\'1\\' + \\'\\'.join(map(lambda i: str(i), A)), 2)\\n\\n\\tK_bitrep = 2 ** K - 1\\n\\tnum_flips = 0\\n\\twhile A_bitrep > K_bitrep:\\n\\t\\tif A_bitrep & 1 == 0:\\n\\t\\t\\tnum_flips += 1\\n\\t\\t\\tA_bitrep ^= K_bitrep\\n\\t\\tA_bitrep >>= 1\\n\\n\\treturn num_flips if A_bitrep == K_bitrep else -1\\n```\\n\\nGreedy algorithm is used here: we strive to turn every bit into `1` in order of left to right. Let `n` = length of A.\\n1. For `idx = 0` to `n - k - 1`, if `A[idx] == 0`, flip the bits in `A[idx : idx + k]` and increment `num_flips`\\n2. For `idx = n - k` to `n - 1`, if `A[idx] == 0`, then return -1. If not, return `num_flips`\\n\\nThe above algorithm will require O(n * k) time in the worst case (where a flip is performed on every iteration).\\nUsing binary representations of A and K, however, every flip requires O(1) time and hence time complexity is reduced to O(n).",
                "solutionTags": [
                    "Greedy",
                    "Bit Manipulation"
                ],
                "code": "```python\\ndef minKBitFlips(self, A: \\'List[int]\\', K: \\'int\\') -> \\'int\\':\\n\\tidx = 0\\n\\tnum_digits = len(A)\\n\\tA_bitrep = int(\\'1\\' + \\'\\'.join(map(lambda i: str(i), A)), 2)\\n\\n\\tK_bitrep = 2 ** K - 1\\n\\tnum_flips = 0\\n\\twhile A_bitrep > K_bitrep:\\n\\t\\tif A_bitrep & 1 == 0:\\n\\t\\t\\tnum_flips += 1\\n\\t\\t\\tA_bitrep ^= K_bitrep\\n\\t\\tA_bitrep >>= 1\\n\\n\\treturn num_flips if A_bitrep == K_bitrep else -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3746701,
                "title": "queues-simple-bit-manipulation-sliding-window-xor-operation-salesforce",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach 1\\n\\n---\\n\\n\\nIterate on the array , and if we encounter any zero we can apply the flip operation from i -> i+k.\\n\\n```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& A, int K, int res = 0) {\\n       for (auto i = 0; i < A.size(); ++i) {\\n         if (A[i] != 1) {\\n           if (i + K - 1 >= A.size()) return -1;\\n              for (auto j = i; j < i + K; ++j) A[j] = !A[j];\\n           ++res;\\n          }\\n        }\\n    return res;\\n    }\\n};\\n```\\n```\\nTime complexity\\n```\\n- The time complexity of this solution is O(n*k), and it will give time limit exceeded eror.\\n# Approach 1\\n\\n---\\n```\\nObservations\\n```\\n\\n**1st observation**\\n\\n\\nLet\\'s say we are performing x number of operations on any ith index,\\n- If x == odd, if we apply one operation on ith index, it will become zero\\n- if x == even, if we apply two operations on ith index, it would remain same.\\n\\nSo we can observe at any index, any operation can be applied atmost once. Because if we apply oeration again, all element of that subarray will become same again.\\n\\n**2nd observation**\\n\\nWe can count the total operations applied on each index. So our problem reduces to how to do this thing efficiently in O(1). \\n\\nWe can use Queue data structure to store the required result. When we apply the flip operation on ith index, we would push i+k-1 in the queue. (i+k-1) would tell us the end index of our flip.\\nAt any index, the size of queue will tell us how many times flip operation has to be applied on it. We will also remove past flips from the queue, so that it can\\'t effect our result. \\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n```\\n Code\\n```\\n```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        queue<int>q;\\n        int ans = 0;\\n        for(int i = 0; i<nums.size(); i++)\\n        {\\n            while(q.size() && q.front() < i) q.pop();\\n            int x = q.size()%2;\\n            nums[i] ^=x;\\n            if(nums[i] == 0)\\n            {\\n                if(i+k > nums.size()) return -1;\\n                q.push(i+k-1);\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```\\nTime complexity\\n```\\nThe time complexity of this solution is O(N) and this would be accepted by the online judge.\\n\\n\\n---\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Queue",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& A, int K, int res = 0) {\\n       for (auto i = 0; i < A.size(); ++i) {\\n         if (A[i] != 1) {\\n           if (i + K - 1 >= A.size()) return -1;\\n              for (auto j = i; j < i + K; ++j) A[j] = !A[j];\\n           ++res;\\n          }\\n        }\\n    return res;\\n    }\\n};\\n```\n```\\nTime complexity\\n```\n```\\nObservations\\n```\n```\\n Code\\n```\n```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        queue<int>q;\\n        int ans = 0;\\n        for(int i = 0; i<nums.size(); i++)\\n        {\\n            while(q.size() && q.front() < i) q.pop();\\n            int x = q.size()%2;\\n            nums[i] ^=x;\\n            if(nums[i] == 0)\\n            {\\n                if(i+k > nums.size()) return -1;\\n                q.push(i+k-1);\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nTime complexity\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3536533,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& A, int K) {\\n        int cur = 0, res = 0, n = A.size();\\n        for (int i = 0; i < n; ++i) {\\n            if (i >= K && A[i - K] > 1) {\\n                cur--;\\n                A[i - K] -= 2;\\n            }\\n            if (cur % 2 == A[i]) {\\n                if (i + K > n) return -1;\\n                A[i] += 2;\\n                cur++;\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        n=len(nums)\\n        x=0\\n        f=[0]*n\\n\\n        for idx,val in enumerate(nums):\\n            if idx>=k:\\n                x^=f[idx-k]\\n            if x!=val:\\n                continue\\n            if k>n-idx:\\n                return -1\\n            x^=1\\n            f[idx]=1\\n        \\n        return sum(f)\\n```\\n\\n```Java []\\nclass Solution {\\n        public int minKBitFlips(int[] A, int K) {\\n            int n = A.length, flipped = 0, res = 0;\\n            int[] isFlipped = new int[n];\\n            for (int i = 0; i < A.length; ++i) {\\n                if (i >= K)\\n                    flipped ^= isFlipped[i - K];\\n                if (flipped == A[i]) {\\n                    if (i + K > A.length)\\n                        return -1;\\n                    isFlipped[i] = 1;\\n                    flipped ^= 1;\\n                    res++;\\n                }\\n            }\\n            return res;\\n        }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& A, int K) {\\n        int cur = 0, res = 0, n = A.size();\\n        for (int i = 0; i < n; ++i) {\\n            if (i >= K && A[i - K] > 1) {\\n                cur--;\\n                A[i - K] -= 2;\\n            }\\n            if (cur % 2 == A[i]) {\\n                if (i + K > n) return -1;\\n                A[i] += 2;\\n                cur++;\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        n=len(nums)\\n        x=0\\n        f=[0]*n\\n\\n        for idx,val in enumerate(nums):\\n            if idx>=k:\\n                x^=f[idx-k]\\n            if x!=val:\\n                continue\\n            if k>n-idx:\\n                return -1\\n            x^=1\\n            f[idx]=1\\n        \\n        return sum(f)\\n```\n```Java []\\nclass Solution {\\n        public int minKBitFlips(int[] A, int K) {\\n            int n = A.length, flipped = 0, res = 0;\\n            int[] isFlipped = new int[n];\\n            for (int i = 0; i < A.length; ++i) {\\n                if (i >= K)\\n                    flipped ^= isFlipped[i - K];\\n                if (flipped == A[i]) {\\n                    if (i + K > A.length)\\n                        return -1;\\n                    isFlipped[i] = 1;\\n                    flipped ^= 1;\\n                    res++;\\n                }\\n            }\\n            return res;\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2221973,
                "title": "java-greedy-o-n",
                "content": "- Whenever we encounter our target bit, we flip it. \\n- To keep track of what target is (1 or 0), we will use a boolean array to note the end of the `k` length.\\n- Flip between 0 and 1 by doing `1^=1` and `0^=1`\\n- Flip between true and false by doing `false^=true` and `true^=true`\\n\\n```Java\\nclass Solution {\\n    public int minKBitFlips(int[] nums, int k) {\\n        int target = 0, ans = 0;;\\n        boolean[] flip = new boolean[nums.length+1];\\n        for (int i = 0; i < nums.length; i++){\\n            if (flip[i]){\\n                target^=1;\\n            }\\n            if (i<nums.length-k+1&&nums[i]==target){\\n                target^=1;\\n                flip[i+k]^=true;\\n                ans++;\\n            }\\n            if (i>nums.length-k&&nums[i]==target){\\n                return -1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```Java\\nclass Solution {\\n    public int minKBitFlips(int[] nums, int k) {\\n        int target = 0, ans = 0;;\\n        boolean[] flip = new boolean[nums.length+1];\\n        for (int i = 0; i < nums.length; i++){\\n            if (flip[i]){\\n                target^=1;\\n            }\\n            if (i<nums.length-k+1&&nums[i]==target){\\n                target^=1;\\n                flip[i+k]^=true;\\n                ans++;\\n            }\\n            if (i>nums.length-k&&nums[i]==target){\\n                return -1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2144636,
                "title": "python-with-explanation-o-n",
                "content": "The easiest, most straightforward solution would look something like this:\\n```\\nclass Solution:\\n    def minKBitFlips(self, nums, k: int) -> int:\\n        res = 0\\n        for i in range(len(nums) - k + 1):\\n            if nums[i] == 0:\\n                res += 1\\n                for j in range(i, i + k):  # flip all from i to i + k - 1\\n                    if nums[j] == 0:\\n                        nums[j] = 1\\n                    elif nums[j] == 1:\\n                        nums[j] = 0\\n        return res if sum(nums[-k:]) == k else -1  # check if all are equal to one with sum(nums[-k:]) == k\\n```\\nThe key observation as noted [here](https://leetcode.com/problems/minimum-number-of-k-consecutive-bit-flips/discuss/2061620/C%2B%2B-key-observation-%2B-diff-arrary) is that\\n 1. only one k-bit flip can affect the 1st bit.\\n 2. once 1st bit is settled, only one k-bit flip can affect the 2nd bit\\n 3. so on ... \\n \\nBut this solution is too slow and results in Time Limit Exceeded. No wonder: for large k\\'s we have to do a lot of flipping. We can mitigate it by doing \"virtual flipping\". With \"virtual flipping\" we do not actually flip the bits, we just start treating 1 as 0 and 0 as 1 and we remember the index when we have to spot doing that.\\n\\nConsider the following solution (faster than 90%):\\n```\\nclass Solution:\\n    def minKBitFlips(self, nums, k: int) -> int:\\n        min_flips = 0  # final result\\n        norm_mod = True  # if norm_mod is True we treat 1 as 1 and 0 as 0, if False 1 as 0, 0 as 1\\n        chmod = set()  # set of indexes where to change norm_mod\\n        \\n        for i in range(len(nums) - k + 1):  # do all virtual flipping\\n            if i in chmod:\\n                norm_mod = not norm_mod\\n            if (nums[i] == 0 and norm_mod) or (nums[i] == 1 and not norm_mod):\\n                min_flips += 1\\n                chmod.add(i + k)\\n                norm_mod = not norm_mod\\n\\n        for i in range(len(nums) - k + 1, len(nums)):  # check if possible\\n            if i in chmod:\\n                norm_mod = not norm_mod\\n            if (nums[i] == 0 and norm_mod) or (nums[i] == 1 and not norm_mod):\\n                return -1\\n\\n        return min_flips\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minKBitFlips(self, nums, k: int) -> int:\\n        res = 0\\n        for i in range(len(nums) - k + 1):\\n            if nums[i] == 0:\\n                res += 1\\n                for j in range(i, i + k):  # flip all from i to i + k - 1\\n                    if nums[j] == 0:\\n                        nums[j] = 1\\n                    elif nums[j] == 1:\\n                        nums[j] = 0\\n        return res if sum(nums[-k:]) == k else -1  # check if all are equal to one with sum(nums[-k:]) == k\\n```\n```\\nclass Solution:\\n    def minKBitFlips(self, nums, k: int) -> int:\\n        min_flips = 0  # final result\\n        norm_mod = True  # if norm_mod is True we treat 1 as 1 and 0 as 0, if False 1 as 0, 0 as 1\\n        chmod = set()  # set of indexes where to change norm_mod\\n        \\n        for i in range(len(nums) - k + 1):  # do all virtual flipping\\n            if i in chmod:\\n                norm_mod = not norm_mod\\n            if (nums[i] == 0 and norm_mod) or (nums[i] == 1 and not norm_mod):\\n                min_flips += 1\\n                chmod.add(i + k)\\n                norm_mod = not norm_mod\\n\\n        for i in range(len(nums) - k + 1, len(nums)):  # check if possible\\n            if i in chmod:\\n                norm_mod = not norm_mod\\n            if (nums[i] == 0 and norm_mod) or (nums[i] == 1 and not norm_mod):\\n                return -1\\n\\n        return min_flips\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2122927,
                "title": "python-o-n-s-n-queue-solution",
                "content": "```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        ans = 0\\n        q = []\\n        for i in range(len(nums)):\\n            if len(q) % 2 == 0:\\n                if nums[i] == 0:\\n                    if i+k-1 <= len(nums)-1:\\n                        ans += 1\\n                        q.append(i+k-1)\\n                    else:\\n                        return -1\\n            else:\\n                if nums[i] == 1:\\n                    if i+k-1 <= len(nums)-1:\\n                        ans += 1\\n                        q.append(i+k-1)\\n                    else:\\n                        return -1\\n            if q:\\n                if q[0] == i:\\n                    q.pop(0)\\n        return ans\\n",
                "solutionTags": [
                    "Python3",
                    "Greedy",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        ans = 0\\n        q = []\\n        for i in range(len(nums)):\\n            if len(q) % 2 == 0:\\n                if nums[i] == 0:\\n                    if i+k-1 <= len(nums)-1:\\n                        ans += 1\\n                        q.append(i+k-1)\\n                    else:\\n                        return -1\\n            else:\\n                if nums[i] == 1:\\n                    if i+k-1 <= len(nums)-1:\\n                        ans += 1\\n                        q.append(i+k-1)\\n                    else:\\n                        return -1\\n            if q:\\n                if q[0] == i:\\n                    q.pop(0)\\n        return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 1975230,
                "title": "python-intuitive-solution-o-n",
                "content": "```\\nclass Solution:\\n    def minKBitFlips(self, A: List[int], k: int) -> int:\\n        flipped = collections.deque()  # queue to store window end indexes\\n        flips = 0\\n        n = len(A)\\n        for i in range(n):\\n            if flipped and (flipped[0] < i):    # if we have crossed the window remove from queue\\n                flipped.popleft()\\n            if len(flipped)%2 == 0:  # if len of queue is even then 1 will be 1 after even flips\\n                if A[i] == 1:\\n                    continue  # so we continue\\n                else:\\n                    if (k + i -1) >= n:  # can we apply k window sized flip here?\\n                        return -1\\n                    flipped.append(k+i-1)  # if we can we store the last index of the window\\n                    flips += 1  # increase our flip counter\\n            else:\\n                if A[i] == 0:  # if our queue is odd sized then our 0 will be converted to 1 so we continue\\n                    continue\\n                else:  # if its a 1 then it would be flipped to 0 so we try to apply flip operation\\n                    if (k + i -1) >= n:  # can we apply k window sized flip here?\\n                        return -1\\n                    flipped.append(k+i-1)  # if we can we store the last index of the window\\n                    flips += 1  # increase our flip counter\\n        return flips\\n```",
                "solutionTags": [
                    "Python",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def minKBitFlips(self, A: List[int], k: int) -> int:\\n        flipped = collections.deque()  # queue to store window end indexes\\n        flips = 0\\n        n = len(A)\\n        for i in range(n):\\n            if flipped and (flipped[0] < i):    # if we have crossed the window remove from queue\\n                flipped.popleft()\\n            if len(flipped)%2 == 0:  # if len of queue is even then 1 will be 1 after even flips\\n                if A[i] == 1:\\n                    continue  # so we continue\\n                else:\\n                    if (k + i -1) >= n:  # can we apply k window sized flip here?\\n                        return -1\\n                    flipped.append(k+i-1)  # if we can we store the last index of the window\\n                    flips += 1  # increase our flip counter\\n            else:\\n                if A[i] == 0:  # if our queue is odd sized then our 0 will be converted to 1 so we continue\\n                    continue\\n                else:  # if its a 1 then it would be flipped to 0 so we try to apply flip operation\\n                    if (k + i -1) >= n:  # can we apply k window sized flip here?\\n                        return -1\\n                    flipped.append(k+i-1)  # if we can we store the last index of the window\\n                    flips += 1  # increase our flip counter\\n        return flips\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1852826,
                "title": "javascript-sliding-window-approach",
                "content": "```\\nvar minKBitFlips = function (nums, k) {\\n  let result = 0,\\n    windowStart = 0,\\n    flip = 0;\\n  for (let windowEnd = 0; windowEnd < nums.length; windowEnd++) {\\n    // remove our current windows first number\\n    // check if windows first number is equal to 2, if so subtract flip\\n    // and shrink the window\\n    if (windowEnd - windowStart + 1 >= k && nums[windowEnd - k] === 2) {\\n      flip -= 1;\\n      windowStart += 1;\\n    }\\n    if (flip % 2 === nums[windowEnd]) {\\n      if (windowEnd + k > nums.length) return -1;\\n      result += 1;\\n      flip += 1;\\n      nums[windowEnd] = 2;\\n    }\\n  }\\n  return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\nvar minKBitFlips = function (nums, k) {\\n  let result = 0,\\n    windowStart = 0,\\n    flip = 0;\\n  for (let windowEnd = 0; windowEnd < nums.length; windowEnd++) {\\n    // remove our current windows first number\\n    // check if windows first number is equal to 2, if so subtract flip\\n    // and shrink the window\\n    if (windowEnd - windowStart + 1 >= k && nums[windowEnd - k] === 2) {\\n      flip -= 1;\\n      windowStart += 1;\\n    }\\n    if (flip % 2 === nums[windowEnd]) {\\n      if (windowEnd + k > nums.length) return -1;\\n      result += 1;\\n      flip += 1;\\n      nums[windowEnd] = 2;\\n    }\\n  }\\n  return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1848407,
                "title": "python-o-nk-to-o-n-queue-and-sliding-window-explained-well",
                "content": "The O(NK) solution is very easy. In a window, we flip whenever count of 0s > 0, and the first element of the window is 0. This is because if the first element in the window is 1, and we flip it to 0, and slide the window forward, we will never be able to flip it back to 1. Here\\'s the solution:\\n```\\nclass Solution(object):\\n    def minKBitFlips(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"        \\n\\t\\t# Initializing here\\n        cnts = {0:0, 1:0}\\n        if k>=2:\\n            for i in range(0, k-1):\\n                cnts[nums[i]]+=1\\n        num_flips = 0\\n        st = 0\\n        for en in range(k-1, len(nums)):\\n            #update cnts for en\\n            cnts[nums[en]]+=1\\n            # should we flip?\\n            if (cnts[0]>0) and (nums[st]==0):\\n                # yes flip\\n                nums[st:en+1] = [((v-1)*-1) for v in nums[st:en+1]]  # This is the problem! We\\'ll get TIME LIMIT EXCEEDED IF K IS VERY BIG!\\n                cnts[0], cnts[1] = cnts[1], cnts[0]\\n                num_flips += 1\\n            ## move window forward\\n            if nums[st]==0: # checks every element except elements after st in the last window\\n                return -1\\n            cnts[nums[st]]-=1\\n            st+=1\\n        if cnts[0]>0: # check the last window\\n            return -1\\n        return num_flips\\n```\\n\\nTo optimize the code, we clearly need to replace the following O(K) code with something that\\'s O(1)\\n```\\n                nums[st:en+1] = [((v-1)*-1) for v in nums[st:en+1]] \\n```\\n\\nHow can we do this?\\n\\nTo get the current value of nums[i] for any i, we need to know the initial nums[i] value and ***how many times i was flipped***. We cannot easily track how many times each i was flipped, but we can easily track which windows were flipped by adding the starting or ending index of that flipped window to a list or queue. ***Once our window slides past the last element of a flipped window, the fact that that window was flipped no longer has an effect on the first element of the next window.*** For example, in [a,b,c,d,e,f,g,h] and k=3, say we flip window [a,b,c], while b and d will be effected by this flip, d will not. This shows us, that we need to track the last element of the flipped windows (en) until the window slides past that element. \\n\\nSo, as a solution, we create a queue q. Every time a window a flipped, we append the last element (en) of that window to q. When the first element of the sliding window (st) becomes greater that q[0], we popleft to remove the en of that old flipped window that will have no effect on the next sliding window (starting with st+1).\\n\\nUsing this, I was able to come up with the following O(N) solution:\\n```\\nfrom collections import deque\\nclass Solution(object):\\n    def minKBitFlips(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        q = deque()\\n        cnts = {0:0, 1:0}\\n        if k>=2:\\n            for i in range(0, k-1):\\n                cnts[nums[i]]+=1\\n        num_flips = 0\\n        st = 0\\n        for en in range(k-1, len(nums)):\\n            #update cnts for en\\n            cnts[nums[en]]+=1 # as we expand window, en is never flipped\\n            # should we flip?\\n            if (cnts[0]>0) and ((nums[st]+(len(q)%2)) in [0,2]):\\n                # yes flip\\n                #nums[st:en+1] = [((v-1)*-1) for v in nums[st:en+1]]\\n                cnts[0], cnts[1] = cnts[1], cnts[0]\\n                num_flips += 1\\n                q.append(en)\\n            ## move window forward\\n            if ((nums[st]+(len(q)%2)) in [0,2]): # checks every element outside the last window\\n                return -1\\n            if ((nums[st]+(len(q)%2)) in [0,2]):\\n                cnts[0]-=1\\n            else:\\n                cnts[1]-=1\\n            if (len(q)>0) and (q[0]==st):\\n                q.popleft()\\n            st+=1\\n        # check the last window\\n        if cnts[0]>0:\\n            return -1\\n        return num_flips\\n```\\n\\nRuntime: 1369 ms, faster than 43.48% of Python online submissions for Minimum Number of K Consecutive Bit Flips.\\nMemory Usage: 17.5 MB, less than 78.26% of Python online submissions for Minimum Number of K Consecutive Bit Flips.",
                "solutionTags": [
                    "Python",
                    "Queue",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution(object):\\n    def minKBitFlips(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"        \\n\\t\\t# Initializing here\\n        cnts = {0:0, 1:0}\\n        if k>=2:\\n            for i in range(0, k-1):\\n                cnts[nums[i]]+=1\\n        num_flips = 0\\n        st = 0\\n        for en in range(k-1, len(nums)):\\n            #update cnts for en\\n            cnts[nums[en]]+=1\\n            # should we flip?\\n            if (cnts[0]>0) and (nums[st]==0):\\n                # yes flip\\n                nums[st:en+1] = [((v-1)*-1) for v in nums[st:en+1]]  # This is the problem! We\\'ll get TIME LIMIT EXCEEDED IF K IS VERY BIG!\\n                cnts[0], cnts[1] = cnts[1], cnts[0]\\n                num_flips += 1\\n            ## move window forward\\n            if nums[st]==0: # checks every element except elements after st in the last window\\n                return -1\\n            cnts[nums[st]]-=1\\n            st+=1\\n        if cnts[0]>0: # check the last window\\n            return -1\\n        return num_flips\\n```\n```\\n                nums[st:en+1] = [((v-1)*-1) for v in nums[st:en+1]] \\n```\n```\\nfrom collections import deque\\nclass Solution(object):\\n    def minKBitFlips(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        q = deque()\\n        cnts = {0:0, 1:0}\\n        if k>=2:\\n            for i in range(0, k-1):\\n                cnts[nums[i]]+=1\\n        num_flips = 0\\n        st = 0\\n        for en in range(k-1, len(nums)):\\n            #update cnts for en\\n            cnts[nums[en]]+=1 # as we expand window, en is never flipped\\n            # should we flip?\\n            if (cnts[0]>0) and ((nums[st]+(len(q)%2)) in [0,2]):\\n                # yes flip\\n                #nums[st:en+1] = [((v-1)*-1) for v in nums[st:en+1]]\\n                cnts[0], cnts[1] = cnts[1], cnts[0]\\n                num_flips += 1\\n                q.append(en)\\n            ## move window forward\\n            if ((nums[st]+(len(q)%2)) in [0,2]): # checks every element outside the last window\\n                return -1\\n            if ((nums[st]+(len(q)%2)) in [0,2]):\\n                cnts[0]-=1\\n            else:\\n                cnts[1]-=1\\n            if (len(q)>0) and (q[0]==st):\\n                q.popleft()\\n            st+=1\\n        # check the last window\\n        if cnts[0]>0:\\n            return -1\\n        return num_flips\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766215,
                "title": "c-solution",
                "content": "**Inutition**\\nUse difference array technique to mark the ```start``` position and ```end``` position of a range that all the elements need flip. This can avoid to flip every element. \\n\\nSimilar problems:\\n- 1893 Check if All the Integers in a Range Are Covered\\n- 370 Range Addition\\n- 1381 Design a Stack With Increment Operation\\n- 2021 Brightest Position on Street\\n- 1094 Car Pooling\\n- 995 Minimum Number of K Consecutive Bit Flips\\n\\n**Complexity**\\n- Time: O(n)\\n- Space: O(1)\\n\\n**Implementation**\\n```\\npublic class Solution {\\n    public int MinKBitFlips(int[] nums, int k) {\\n        \\n        if(nums == null || nums.Length == 0)\\n            throw new ArgumentException(\"Invalid Input.\");\\n        \\n        int n = nums.Length, flipCnt = 0;\\n\\n        // diff[i]: diffience of total flips between index i and i - 1\\n        int[] diff = new int[n + 1];\\n        \\n        // totalFlip: total flip count before index i\\n        int totalFlip = 0;\\n          \\n        for(int i = 0; i < n; i++)\\n        {\\n            // totalFlip + diff[i] = actual flip at index i\\n            totalFlip += diff[i];\\n            \\n            // if num[i] + totalFlip is even, then nums[i] = 0\\n            // otherwise, nums[i] = 1\\n            if((nums[i] + totalFlip) % 2 == 0)\\n            {\\n                // (i + k - 1) last index where need a flip\\n                if(i + k - 1 >= n)\\n                    return -1;\\n                \\n                // all the positions within range of [i, i + k - 1] will flip once\\n                totalFlip++;\\n                // starting from index (i+k), we should stop flipping, so cancel the flips that shouldn\\'t happen \\n                diff[i + k] -= 1;\\n                \\n                // flip count\\n                flipCnt++;\\n            }\\n        }\\n\\n        return flipCnt;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```start```\n```end```\n```\\npublic class Solution {\\n    public int MinKBitFlips(int[] nums, int k) {\\n        \\n        if(nums == null || nums.Length == 0)\\n            throw new ArgumentException(\"Invalid Input.\");\\n        \\n        int n = nums.Length, flipCnt = 0;\\n\\n        // diff[i]: diffience of total flips between index i and i - 1\\n        int[] diff = new int[n + 1];\\n        \\n        // totalFlip: total flip count before index i\\n        int totalFlip = 0;\\n          \\n        for(int i = 0; i < n; i++)\\n        {\\n            // totalFlip + diff[i] = actual flip at index i\\n            totalFlip += diff[i];\\n            \\n            // if num[i] + totalFlip is even, then nums[i] = 0\\n            // otherwise, nums[i] = 1\\n            if((nums[i] + totalFlip) % 2 == 0)\\n            {\\n                // (i + k - 1) last index where need a flip\\n                if(i + k - 1 >= n)\\n                    return -1;\\n                \\n                // all the positions within range of [i, i + k - 1] will flip once\\n                totalFlip++;\\n                // starting from index (i+k), we should stop flipping, so cancel the flips that shouldn\\'t happen \\n                diff[i + k] -= 1;\\n                \\n                // flip count\\n                flipCnt++;\\n            }\\n        }\\n\\n        return flipCnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1658419,
                "title": "lazy-seg-tree",
                "content": "The idea is to maintain a lazy seg tree on the array consisting of the bulbs. We then traverse the array from left to right. Note that it never makes sense to flip a range more than once. Thus, as we move from left to right, if we see an element of the array which is 0 mod 2, then we must add 1 to the range of length k starting at that point. We keep track of how many range updates we make. At the end, we simply check of the elements in the final k positions are 1 mod 2. Each range update and range query takes logN time, so overall run time is O(NlogN), and space complexity if O(N) for the tree. Note that if we did not use a Lazy seg tree for range updates, the runtime would be O(NK), which could be as bad as O(N^2)\\n```\\nconst int MAX_ARR_SIZE = 200005;\\nconst int MAX_TREE_SIZE = 4*MAX_ARR_SIZE;\\n\\nstruct node {\\n    int64_t sum;\\n    int lazy;\\n    \\n    node(): sum(0), lazy(0)  {}\\n    node(int sum, int lazy_val): sum(sum), lazy(lazy_val) {}\\n\\n\\n    node operator+(const node& other) {\\n        return node(sum + other.sum, 0); \\n    }\\n};\\n\\nvoid push(int k, int l, int r, node(&tree)[MAX_TREE_SIZE], int (&arr)[MAX_ARR_SIZE]) {\\n    tree[k].sum += tree[k].lazy*(r- l + 1);\\n    tree[2*k].lazy += tree[k].lazy;\\n    tree[2*k + 1].lazy += tree[k].lazy;\\n    tree[k].lazy = 0; \\n}\\n\\nvoid update(int ul, int ur, int val, int k, int l, int r, node (&tree)[MAX_TREE_SIZE], int (&arr)[MAX_ARR_SIZE]) {\\n    \\n    push(k, l, r, tree, arr);\\n\\n    if(ur < l || r < ul) {return;}\\n\\n    if(ul <= l && r <= ur) {\\n        tree[k].lazy += val;\\n        return;\\n    }\\n\\n \\n    tree[k].sum += val*(min(ur, r) - max(ul, l) + 1);\\n    int mid = (l + r)/2;\\n    update(ul, ur, val, 2*k, l, mid,  tree, arr);\\n    update(ul, ur, val, 2*k + 1, mid + 1, r, tree, arr);\\n}\\n\\nnode query(int ql, int qr, int k, int l, int r, node (&tree)[MAX_TREE_SIZE], int (&arr)[MAX_ARR_SIZE]) {\\n    \\n    push(k, l, r, tree, arr);\\n\\n    if(ql > r|| qr < l) {\\n        return node(); \\n    }\\n    if(ql <= l && r <= qr) {\\n        return tree[k];\\n    }\\n    int mid = (l + r)/2;\\n    node query_left = query(ql, qr, 2*k, l, mid, tree, arr);\\n    node query_right = query(ql, qr, 2*k + 1, mid + 1, r, tree, arr);\\n    return query_left + query_right;\\n}\\n\\nvoid build(int k, int l, int r, node (&tree)[MAX_TREE_SIZE], int (&arr)[MAX_ARR_SIZE]) {\\n    \\n    if(l == r) {\\n        tree[k] = node(arr[l], 0); \\n        return;\\n    }\\n    int m = (l + r)/2;\\n\\n   \\n    build(2*k, l, m, tree, arr);\\n    build(2*k + 1, m + 1, r, tree, arr);\\n    tree[k] = tree[2*k] + tree[2*k + 1]; \\n}\\n\\n\\n\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        node tree[MAX_TREE_SIZE];\\n        int A[MAX_ARR_SIZE];\\n        int n = nums.size();\\n        for(int i = 0; i < n; i++) {\\n            A[i] = nums[i];\\n        }\\n        build(1,0,n-1,tree,A);\\n        int num_flips = 0;\\n        \\n        for(int i = 0; i + k - 1 < n; i++) {\\n            if(query(i,i,1,0,n-1,tree,A).sum%2 == 0) {\\n                num_flips++;\\n                update(i, i + k - 1, 1, 1, 0, n - 1, tree, A);\\n            }\\n        }\\n        for(int i = n - k; i < n; i++) {\\n            if(query(i,i,1,0,n-1,tree,A).sum%2 == 0) {\\n                return -1;\\n            }\\n        }\\n        \\n        return num_flips;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst int MAX_ARR_SIZE = 200005;\\nconst int MAX_TREE_SIZE = 4*MAX_ARR_SIZE;\\n\\nstruct node {\\n    int64_t sum;\\n    int lazy;\\n    \\n    node(): sum(0), lazy(0)  {}\\n    node(int sum, int lazy_val): sum(sum), lazy(lazy_val) {}\\n\\n\\n    node operator+(const node& other) {\\n        return node(sum + other.sum, 0); \\n    }\\n};\\n\\nvoid push(int k, int l, int r, node(&tree)[MAX_TREE_SIZE], int (&arr)[MAX_ARR_SIZE]) {\\n    tree[k].sum += tree[k].lazy*(r- l + 1);\\n    tree[2*k].lazy += tree[k].lazy;\\n    tree[2*k + 1].lazy += tree[k].lazy;\\n    tree[k].lazy = 0; \\n}\\n\\nvoid update(int ul, int ur, int val, int k, int l, int r, node (&tree)[MAX_TREE_SIZE], int (&arr)[MAX_ARR_SIZE]) {\\n    \\n    push(k, l, r, tree, arr);\\n\\n    if(ur < l || r < ul) {return;}\\n\\n    if(ul <= l && r <= ur) {\\n        tree[k].lazy += val;\\n        return;\\n    }\\n\\n \\n    tree[k].sum += val*(min(ur, r) - max(ul, l) + 1);\\n    int mid = (l + r)/2;\\n    update(ul, ur, val, 2*k, l, mid,  tree, arr);\\n    update(ul, ur, val, 2*k + 1, mid + 1, r, tree, arr);\\n}\\n\\nnode query(int ql, int qr, int k, int l, int r, node (&tree)[MAX_TREE_SIZE], int (&arr)[MAX_ARR_SIZE]) {\\n    \\n    push(k, l, r, tree, arr);\\n\\n    if(ql > r|| qr < l) {\\n        return node(); \\n    }\\n    if(ql <= l && r <= qr) {\\n        return tree[k];\\n    }\\n    int mid = (l + r)/2;\\n    node query_left = query(ql, qr, 2*k, l, mid, tree, arr);\\n    node query_right = query(ql, qr, 2*k + 1, mid + 1, r, tree, arr);\\n    return query_left + query_right;\\n}\\n\\nvoid build(int k, int l, int r, node (&tree)[MAX_TREE_SIZE], int (&arr)[MAX_ARR_SIZE]) {\\n    \\n    if(l == r) {\\n        tree[k] = node(arr[l], 0); \\n        return;\\n    }\\n    int m = (l + r)/2;\\n\\n   \\n    build(2*k, l, m, tree, arr);\\n    build(2*k + 1, m + 1, r, tree, arr);\\n    tree[k] = tree[2*k] + tree[2*k + 1]; \\n}\\n\\n\\n\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        node tree[MAX_TREE_SIZE];\\n        int A[MAX_ARR_SIZE];\\n        int n = nums.size();\\n        for(int i = 0; i < n; i++) {\\n            A[i] = nums[i];\\n        }\\n        build(1,0,n-1,tree,A);\\n        int num_flips = 0;\\n        \\n        for(int i = 0; i + k - 1 < n; i++) {\\n            if(query(i,i,1,0,n-1,tree,A).sum%2 == 0) {\\n                num_flips++;\\n                update(i, i + k - 1, 1, 1, 0, n - 1, tree, A);\\n            }\\n        }\\n        for(int i = n - k; i < n; i++) {\\n            if(query(i,i,1,0,n-1,tree,A).sum%2 == 0) {\\n                return -1;\\n            }\\n        }\\n        \\n        return num_flips;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1618329,
                "title": "python-difference-array-with-thought-process-when-being-asked-during-interviews",
                "content": "### Greedy + Difference Array\\nSimilarly with problem [Bulb Switcher IV](https://leetcode.com/problems/bulb-switcher-iv/), the key idea is that once we know the current bit/number is `1`, then we need no longer consider it, but only when the current number is `0` otherwise. \\n\\nFor example, we have `nums` as `[0, 1, 0, 0, 1]` and `2` as `k`. We iterate each number and see if we need flip it. The first number is `0`, so we need flip, then `nums` is changed to `[1,0,0,0,1]`. Then we don\\'t need to consider the first flipped `1` any more, we move on to the second number `0` and keep flipping the `nums` to `[1,1,1,0,1]`. We do the same thing for the third number that is `1` already, then we do nothing and move on to the next.\\n\\nOkey, then what\\'s next? do we need simulate the flipping consecutive `k` numbers each time? No, because it denotes to time complexity of *O(NK)*, or *O(N^2)* in worst case. \\n\\nCan we do better? With the binary property of flipping, it indicates that the final number has only 2 cases, flipped for the odd times flipping, and remained for the even times flipping. So we can simply just record the number of flipping for each number, so that we can quickly calculate the final state on the fly without simulation.\\n\\nThen we can convert the problem to range update and query problem as we need update consecutive k range of flipping times array and query the final state/number for each element.\\n\\nFinally, return `-1` when we find need to flip but the remaining range is smaller than `k`.\\n\\n```python\\ndef minKBitFlips(self, nums: List[int], k: int) -> int:\\n\\tn = len(nums)\\n    diff = [0] * (n + 1) \\n    flip = curr = 0\\n    for i, num in enumerate(nums): \\n\\t\\tcurr += diff[i]\\n        if not (num ^ +(curr % 2)):\\n\\t\\t\\tif n - i < k:\\n\\t\\t\\t\\treturn -1\\n\\t\\t\\tcurr += 1\\n            diff[i + k] -= 1\\n            flip += 1\\n\\treturn flip\\n```\\n*Time Complexity*= **O(N)**\\n*Space Complexit* = **O(N)**\\n",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```python\\ndef minKBitFlips(self, nums: List[int], k: int) -> int:\\n\\tn = len(nums)\\n    diff = [0] * (n + 1) \\n    flip = curr = 0\\n    for i, num in enumerate(nums): \\n\\t\\tcurr += diff[i]\\n        if not (num ^ +(curr % 2)):\\n\\t\\t\\tif n - i < k:\\n\\t\\t\\t\\treturn -1\\n\\t\\t\\tcurr += 1\\n            diff[i + k] -= 1\\n            flip += 1\\n\\treturn flip\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1364521,
                "title": "easy-peasy-o-n-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int n=nums.size();int c=0;\\n        int r=0;\\n            \\n        for(int i=0;i<n;i++)\\n        {\\n            if(i>=k&&nums[i-k]>1)\\n            {\\n                c--;\\n                nums[i-k]-=2;\\n            }\\n            if(c%2==nums[i])\\n            {\\n                if(i+k>n)return -1;\\n                nums[i]+=2;\\n                c++;\\n                r++;\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int n=nums.size();int c=0;\\n        int r=0;\\n            \\n        for(int i=0;i<n;i++)\\n        {\\n            if(i>=k&&nums[i-k]>1)\\n            {\\n                c--;\\n                nums[i-k]-=2;\\n            }\\n            if(c%2==nums[i])\\n            {\\n                if(i+k>n)return -1;\\n                nums[i]+=2;\\n                c++;\\n                r++;\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1356552,
                "title": "javascript-flip-every-first-0-bit-explanation",
                "content": "Pass the array with a sliding window of k size. If the first element of the window is 0 we need to apply the flip.\\nIf at the end of the pass we saw that all the elements are 1 we return the number of flip. Otherwise we return -1\\n```\\nvar minKBitFlips = function(nums, k) {\\n    let count = 0\\n    \\n    for(let i=0; i<nums.length; i++){\\n        if (nums[i] == 0){\\n            for(let j=0; j<k && i+k <= nums.length; j++){\\n                nums[i+j] = 1 - nums[i+j]\\n            }\\n            count++\\n        }\\n    }\\n        \\n    return nums.every(n => n ==1) ? count : -1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minKBitFlips = function(nums, k) {\\n    let count = 0\\n    \\n    for(let i=0; i<nums.length; i++){\\n        if (nums[i] == 0){\\n            for(let j=0; j<k && i+k <= nums.length; j++){\\n                nums[i+j] = 1 - nums[i+j]\\n            }\\n            count++\\n        }\\n    }\\n        \\n    return nums.every(n => n ==1) ? count : -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1350691,
                "title": "c-easy-to-understand-greedy-simulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int arr[n+2];\\n        memset(arr,0,sizeof arr);\\n        int curr=0;\\n        int res=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(curr%2!=0)\\n                nums[i]=nums[i]^1;\\n            if(nums[i]==0)\\n            {\\n                if( i+k-1>=n )\\n                    return -1;\\n                arr[i+k-1]+=-1;\\n                arr[i]+=1;\\n                res++;\\n            }\\n            if(i>0)arr[i]+=arr[i-1];\\n            curr=arr[i];\\n                \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int arr[n+2];\\n        memset(arr,0,sizeof arr);\\n        int curr=0;\\n        int res=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(curr%2!=0)\\n                nums[i]=nums[i]^1;\\n            if(nums[i]==0)\\n            {\\n                if( i+k-1>=n )\\n                    return -1;\\n                arr[i+k-1]+=-1;\\n                arr[i]+=1;\\n                res++;\\n            }\\n            if(i>0)arr[i]+=arr[i-1];\\n            curr=arr[i];\\n                \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1334215,
                "title": "c-two-pass-greedy-solution-slow-with-thinking-process",
                "content": "This post is only to share how I approached this problem, definitely not the optimal solutions. Please check the most voted posts for really smart and neat solutions.\\n\\ninitial idea is to try greedy, end up a TLE solution.\\n```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int istart = 0, iend = 0, ans = 0, sum = 0;\\n        while (iend < nums.size()) {\\n            sum += nums[iend];\\n            if (iend-istart+1 < k) {\\n                ++iend;\\n                continue;\\n            }\\n            if (sum == k) {\\n                istart = ++iend; sum = 0; continue;\\n            }\\n            if (nums[istart] == 1) {\\n                ++istart; --sum; ++iend; continue;\\n            }\\n            sum = 0;\\n            for (int j = istart; j <= iend; ++j) {\\n                nums[j] = !nums[j];\\n                sum += nums[j];\\n            }\\n            ++istart; --sum; ++ans; ++iend; continue;\\n        }\\n        return sum == nums.size()-istart ? ans : -1;\\n    }\\n};\\n```\\n\\nsecond idea is to store the previously flipped bits, and check how many affect current one, end up with a slow O(NlogK) time, O(N) space solution\\n```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int istart = 0, iend = 0, ans = 0, sum = 0, nflips = 0;\\n        while (iend < nums.size()) {\\n            sum += nums[iend];\\n            if (iend-istart+1 < k) {\\n                ++iend;\\n                continue;\\n            }\\n            if (sum == k) {\\n                istart = ++iend; sum = 0; nflips = 0; continue;\\n            }\\n            if (getBit(nums, istart, k) == 1) {\\n                ++istart; --sum; ++iend; continue;\\n            }\\n            flip_start_bits_.push_back(istart);\\n            flip_start_bits_pos_[istart] = flip_start_bits_.size()-1;\\n            \\n            ++nflips;\\n            sum = k-sum;\\n            ++istart; --sum; ++ans; ++iend; continue;\\n        }\\n        return sum == nums.size()-istart ? ans : -1;\\n    }\\n    \\n    vector<int> flip_start_bits_;   \\n    std::map<int, int> flip_start_bits_pos_;\\n    \\n    int getBit(vector<int>& nums, int i, int k) {\\n        int left_most = i-k+1 >= 0? i-k+1 : 0;\\n        if (flip_start_bits_pos_.empty()) return nums[i];\\n        auto left_most_begin_iter = flip_start_bits_pos_.lower_bound(left_most);\\n        if (left_most_begin_iter == flip_start_bits_pos_.end()) {\\n            flip_start_bits_.clear();\\n            flip_start_bits_pos_.clear();\\n            return nums[i];\\n        }\\n        int nflips = flip_start_bits_.size() - left_most_begin_iter->second;\\n        if (nflips%2 == 0) return nums[i];\\n        return !nums[i];\\n    }\\n};\\n```\\n\\nmy final idea is based on the second one, simply using a deque/queue to store previousely flipped bits (since the orber will be increasing, so no map needed), this ends up with a O(N) time, O(K) space solution.\\n```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int istart = 0, iend = 0, ans = 0, sum = 0;\\n        while (iend < nums.size()) {\\n            sum += nums[iend];\\n            if (iend-istart+1 < k) {\\n                ++iend;\\n                continue;\\n            }\\n            if (sum == k) {\\n                flip_start_bits_.clear();\\n                istart = ++iend; sum = 0; continue;\\n            }\\n            while (flip_start_bits_.size() && flip_start_bits_.front() < istart-k+1) flip_start_bits_.pop_front();\\n            if ((flip_start_bits_.size()%2 == 0? nums[istart] : !nums[istart]) == 1) {\\n                ++istart; --sum; ++iend; continue;\\n            }\\n            flip_start_bits_.push_back(istart);\\n            sum = k-sum;\\n            ++istart; --sum; ++ans; ++iend; continue;\\n        }\\n        return sum == nums.size()-istart ? ans : -1;\\n    }\\n\\n    deque<int> flip_start_bits_;\\n};\\n```\\n\\nThis solution is based on top voted posts, to optimize O(1) space.\\n```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int istart = 0, iend = 0, ans = 0, sum = 0, nflips = 0;\\n        while (iend < nums.size()) {\\n            sum += nums[iend];\\n            if (iend-istart+1 < k) {\\n                ++iend;\\n                continue;\\n            }\\n            if (sum == k) {\\n                istart = ++iend; sum = 0; nflips = 0; continue;\\n            }\\n            if (istart-k >= 0 && nums[istart-k] < 0) {\\n                --nflips;\\n                nums[istart-k] += 2;\\n            } \\n            if ((nflips%2 == 0? nums[istart] : !nums[istart]) == 1) {\\n                ++istart; --sum; ++iend; continue;\\n            }\\n            sum = k-sum;\\n            ++nflips;\\n            nums[istart] -= 2;\\n            ++istart; --sum; ++ans; ++iend; continue;\\n        }\\n        return sum == nums.size()-istart ? ans : -1;\\n    }\\n};\\n```\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int istart = 0, iend = 0, ans = 0, sum = 0;\\n        while (iend < nums.size()) {\\n            sum += nums[iend];\\n            if (iend-istart+1 < k) {\\n                ++iend;\\n                continue;\\n            }\\n            if (sum == k) {\\n                istart = ++iend; sum = 0; continue;\\n            }\\n            if (nums[istart] == 1) {\\n                ++istart; --sum; ++iend; continue;\\n            }\\n            sum = 0;\\n            for (int j = istart; j <= iend; ++j) {\\n                nums[j] = !nums[j];\\n                sum += nums[j];\\n            }\\n            ++istart; --sum; ++ans; ++iend; continue;\\n        }\\n        return sum == nums.size()-istart ? ans : -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int istart = 0, iend = 0, ans = 0, sum = 0, nflips = 0;\\n        while (iend < nums.size()) {\\n            sum += nums[iend];\\n            if (iend-istart+1 < k) {\\n                ++iend;\\n                continue;\\n            }\\n            if (sum == k) {\\n                istart = ++iend; sum = 0; nflips = 0; continue;\\n            }\\n            if (getBit(nums, istart, k) == 1) {\\n                ++istart; --sum; ++iend; continue;\\n            }\\n            flip_start_bits_.push_back(istart);\\n            flip_start_bits_pos_[istart] = flip_start_bits_.size()-1;\\n            \\n            ++nflips;\\n            sum = k-sum;\\n            ++istart; --sum; ++ans; ++iend; continue;\\n        }\\n        return sum == nums.size()-istart ? ans : -1;\\n    }\\n    \\n    vector<int> flip_start_bits_;   \\n    std::map<int, int> flip_start_bits_pos_;\\n    \\n    int getBit(vector<int>& nums, int i, int k) {\\n        int left_most = i-k+1 >= 0? i-k+1 : 0;\\n        if (flip_start_bits_pos_.empty()) return nums[i];\\n        auto left_most_begin_iter = flip_start_bits_pos_.lower_bound(left_most);\\n        if (left_most_begin_iter == flip_start_bits_pos_.end()) {\\n            flip_start_bits_.clear();\\n            flip_start_bits_pos_.clear();\\n            return nums[i];\\n        }\\n        int nflips = flip_start_bits_.size() - left_most_begin_iter->second;\\n        if (nflips%2 == 0) return nums[i];\\n        return !nums[i];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int istart = 0, iend = 0, ans = 0, sum = 0;\\n        while (iend < nums.size()) {\\n            sum += nums[iend];\\n            if (iend-istart+1 < k) {\\n                ++iend;\\n                continue;\\n            }\\n            if (sum == k) {\\n                flip_start_bits_.clear();\\n                istart = ++iend; sum = 0; continue;\\n            }\\n            while (flip_start_bits_.size() && flip_start_bits_.front() < istart-k+1) flip_start_bits_.pop_front();\\n            if ((flip_start_bits_.size()%2 == 0? nums[istart] : !nums[istart]) == 1) {\\n                ++istart; --sum; ++iend; continue;\\n            }\\n            flip_start_bits_.push_back(istart);\\n            sum = k-sum;\\n            ++istart; --sum; ++ans; ++iend; continue;\\n        }\\n        return sum == nums.size()-istart ? ans : -1;\\n    }\\n\\n    deque<int> flip_start_bits_;\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int istart = 0, iend = 0, ans = 0, sum = 0, nflips = 0;\\n        while (iend < nums.size()) {\\n            sum += nums[iend];\\n            if (iend-istart+1 < k) {\\n                ++iend;\\n                continue;\\n            }\\n            if (sum == k) {\\n                istart = ++iend; sum = 0; nflips = 0; continue;\\n            }\\n            if (istart-k >= 0 && nums[istart-k] < 0) {\\n                --nflips;\\n                nums[istart-k] += 2;\\n            } \\n            if ((nflips%2 == 0? nums[istart] : !nums[istart]) == 1) {\\n                ++istart; --sum; ++iend; continue;\\n            }\\n            sum = k-sum;\\n            ++nflips;\\n            nums[istart] -= 2;\\n            ++istart; --sum; ++ans; ++iend; continue;\\n        }\\n        return sum == nums.size()-istart ? ans : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1319513,
                "title": "c-o-n-queue-10-lines",
                "content": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& A, int k) {\\n        int ans=0;\\n        queue<int>q;\\n        for(int i=0;i<A.size();i++){\\n            int len=q.size();\\n            if((len%2 && A[i]==1)|| (len%2==0 && A[i]==0)){\\n                if(i+k-1>=A.size())return -1;\\n                q.push(i+k-1);\\n                ans++;\\n            }\\n            if(q.size() && i==q.front())q.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& A, int k) {\\n        int ans=0;\\n        queue<int>q;\\n        for(int i=0;i<A.size();i++){\\n            int len=q.size();\\n            if((len%2 && A[i]==1)|| (len%2==0 && A[i]==0)){\\n                if(i+k-1>=A.size())return -1;\\n                q.push(i+k-1);\\n                ans++;\\n            }\\n            if(q.size() && i==q.front())q.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1266069,
                "title": "python3-greedy",
                "content": "\\n```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        ans = flip = 0 \\n        queue = deque()\\n        for i, x in enumerate(nums):\\n            if queue and i == queue[0]: \\n                flip ^= 1\\n                queue.popleft()\\n            if x == flip: \\n                if len(nums) - i < k: return -1\\n                ans += 1\\n                flip ^= 1\\n                queue.append(i+k)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        ans = flip = 0 \\n        queue = deque()\\n        for i, x in enumerate(nums):\\n            if queue and i == queue[0]: \\n                flip ^= 1\\n                queue.popleft()\\n            if x == flip: \\n                if len(nums) - i < k: return -1\\n                ans += 1\\n                flip ^= 1\\n                queue.append(i+k)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1099871,
                "title": "python-easy-to-understand-solution",
                "content": "```\\nclass Solution:\\n    def minKBitFlips(self, A: List[int], K: int) -> int:\\n        n=len(A)\\n        ans=0\\n        if A[0]==0:\\n            ans+=1\\n            for i in range(K):\\n                A[i]= int(not A[i])\\n        B=[0]*(n-1)\\n        for i in range(n-1):\\n            B[i]=int(A[i] != A[i+1])\\n        for i in range(n):\\n            if i+K<=n-1:\\n                if B[i]==1:\\n                    ans+=1\\n                    B[i] = int(not B[i])\\n                    if i+K<n-1:\\n                        B[i+K] = int(not B[i+K]) \\n        if B==[0]*(n-1):\\n            return ans\\n        return -1\\n        \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minKBitFlips(self, A: List[int], K: int) -> int:\\n        n=len(A)\\n        ans=0\\n        if A[0]==0:\\n            ans+=1\\n            for i in range(K):\\n                A[i]= int(not A[i])\\n        B=[0]*(n-1)\\n        for i in range(n-1):\\n            B[i]=int(A[i] != A[i+1])\\n        for i in range(n):\\n            if i+K<=n-1:\\n                if B[i]==1:\\n                    ans+=1\\n                    B[i] = int(not B[i])\\n                    if i+K<n-1:\\n                        B[i+K] = int(not B[i+K]) \\n        if B==[0]*(n-1):\\n            return ans\\n        return -1\\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 684592,
                "title": "o-n-time-space-c-solution-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& A, int K) {\\n        vector<int> isflipped(A.size(),0);\\n        int ans=0;\\n        for(int i=0;i<A.size();i++){\\n            if(i>0){\\n                isflipped[i]+=isflipped[i-1];\\n                isflipped[i]%=2;\\n            }\\n            if(A[i]==0 && !isflipped[i]){\\n                if((A.size()-i+1)<=K){\\n                    return -1;\\n                }\\n                ans++;\\n                isflipped[i]++;\\n                if((i+K)<A.size()){\\n                    isflipped[i+K]--;\\n                }\\n            }\\n            else if(A[i]==1 && isflipped[i]){\\n                if((A.size()-i+1)<=K){\\n                    return -1;\\n                }\\n                ans++;\\n                isflipped[i]++;\\n                if((i+K)<A.size()){\\n                    isflipped[i+K]--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};// \\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& A, int K) {\\n        vector<int> isflipped(A.size(),0);\\n        int ans=0;\\n        for(int i=0;i<A.size();i++){\\n            if(i>0){\\n                isflipped[i]+=isflipped[i-1];\\n                isflipped[i]%=2;\\n            }\\n            if(A[i]==0 && !isflipped[i]){\\n                if((A.size()-i+1)<=K){\\n                    return -1;\\n                }\\n                ans++;\\n                isflipped[i]++;\\n                if((i+K)<A.size()){\\n                    isflipped[i+K]--;\\n                }\\n            }\\n            else if(A[i]==1 && isflipped[i]){\\n                if((A.size()-i+1)<=K){\\n                    return -1;\\n                }\\n                ans++;\\n                isflipped[i]++;\\n                if((i+K)<A.size()){\\n                    isflipped[i+K]--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};// \\n```",
                "codeTag": "Java"
            },
            {
                "id": 619498,
                "title": "scala-fenwick-tree-o-nlgn",
                "content": "```\\nobject Solution {\\n  val MAGIC: Int = 300000\\n  def minKBitFlips(A: Array[Int], K: Int): Int = {\\n    val len: Int = A.length\\n    val pLen: Int = len - K + 1\\n    val ops: Array[Int] = Array.fill(1 + pLen)(0) // 1 based\\n    var ans: Int = 0\\n    if(A(0) == 0) {\\n      ans += 1\\n      add(1, 1, ops, pLen)\\n    }\\n    \\n    for {\\n      i <- 1 until pLen\\n    } {\\n      if((A(i) + rangeSum(Math.max(1, i - K + 2), i, ops, pLen)) % 2 == 0) {\\n        ans += 1\\n        add(i + 1, 1, ops, pLen)\\n      }\\n    }\\n    for {\\n        i <- pLen until len\\n    } {\\n        if((A(i) + rangeSum(Math.max(1, i - K + 2), Math.min(i, pLen), ops, pLen)) % 2 == 0) {\\n            return -1\\n        }\\n    }\\n    return ans\\n  }\\n\\n  def add(i: Int, v: Int, arr: Array[Int], len: Int): Unit = {\\n    var ind: Int = i\\n    while(ind <= len) {\\n      arr(ind) += v\\n      ind += ind & (-ind)\\n    }\\n  }\\n\\n  def queryPreSum(n: Int, arr: Array[Int], len: Int): Int = {\\n    var ind = n\\n    var ans: Int = 0\\n    while(ind > 0) {\\n      ans += arr(ind)\\n      ind -= ind & (-ind)\\n    }\\n    ans\\n  }\\n\\n  def rangeSum(l: Int, r: Int, arr: Array[Int], len: Int): Int = {\\n    queryPreSum(r, arr, len) - queryPreSum(l - 1, arr, len)\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nobject Solution {\\n  val MAGIC: Int = 300000\\n  def minKBitFlips(A: Array[Int], K: Int): Int = {\\n    val len: Int = A.length\\n    val pLen: Int = len - K + 1\\n    val ops: Array[Int] = Array.fill(1 + pLen)(0) // 1 based\\n    var ans: Int = 0\\n    if(A(0) == 0) {\\n      ans += 1\\n      add(1, 1, ops, pLen)\\n    }\\n    \\n    for {\\n      i <- 1 until pLen\\n    } {\\n      if((A(i) + rangeSum(Math.max(1, i - K + 2), i, ops, pLen)) % 2 == 0) {\\n        ans += 1\\n        add(i + 1, 1, ops, pLen)\\n      }\\n    }\\n    for {\\n        i <- pLen until len\\n    } {\\n        if((A(i) + rangeSum(Math.max(1, i - K + 2), Math.min(i, pLen), ops, pLen)) % 2 == 0) {\\n            return -1\\n        }\\n    }\\n    return ans\\n  }\\n\\n  def add(i: Int, v: Int, arr: Array[Int], len: Int): Unit = {\\n    var ind: Int = i\\n    while(ind <= len) {\\n      arr(ind) += v\\n      ind += ind & (-ind)\\n    }\\n  }\\n\\n  def queryPreSum(n: Int, arr: Array[Int], len: Int): Int = {\\n    var ind = n\\n    var ans: Int = 0\\n    while(ind > 0) {\\n      ans += arr(ind)\\n      ind -= ind & (-ind)\\n    }\\n    ans\\n  }\\n\\n  def rangeSum(l: Int, r: Int, arr: Array[Int], len: Int): Int = {\\n    queryPreSum(r, arr, len) - queryPreSum(l - 1, arr, len)\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 373717,
                "title": "greedy-python-solution-w-detailed-comments",
                "content": "##### Python 3:\\n```py\\nclass Solution:\\n    def minKBitFlips(self, A: List[int], K: int) -> int:\\n        # status: record whether current character has been flipped already or not\\n        # 0: not flipped\\n        # 1: flipped\\n        flipped = 0\\n\\n        # record whether index i, as the start of substring of length K, has been\\n        # flipped or not\\n        # 0: not flipped\\n        # 1: flipped\\n        has_flipped = [0] * len(A)\\n\\n        min_flips = 0\\n\\n        for idx, num in enumerate(A):\\n            # get the ACTUAL FLIPPED STATUS for current num by removing the flipped\\n            # status of values that are out of window\\n            if idx >= K:\\n                flipped ^= has_flipped[idx - K]\\n\\n            # we will need to flip current value iff\\n            # 1) current value is 1 and it has been flipped (i.e. flipped == 1)\\n            # 2) current value is 0 and it hasn\\'t been flipped (i.e. flipped == 0)\\n            # which can be concluded by (flipped ^ num == 0)\\n            if (flipped ^ num) == 0:\\n                # in case there is no way for us to flip current value\\n                if idx + K - 1 >= len(A):\\n                    return -1\\n\\n                # flip\\n                flipped ^= 1\\n                has_flipped[idx] = 1\\n                min_flips += 1\\n\\n        return min_flips\\n```\\n##### JavaScript:\\n```js\\nvar minKBitFlips = function(A, K) {\\n  if (!A || !A.length) return [];\\n\\n  // flipped: keep track of total flipped status\\n  // 0: not flipped\\n  // 1: flipped\\n  let flips = 0, flipped = 0;\\n  // indicate whether A[i] is truly flipped or not\\n  const hasFlipped = Array(A.length).fill(0);\\n\\n  for (const [i, num] of A.entries()) {\\n    // IMPORTANT: to determine whether at this pointer, the current value has been\\n    // flipped or not, we need to find it based on flipped and hasFlipped[i - k]\\n    if (i >= K) {\\n      flipped ^= hasFlipped[i - K];\\n    }\\n\\n    // if num == 0 and current value has not been flipped yet (flipped == 0)\\n    // if num == 1 and current value has been flipped yet (flipped == 1)\\n    // for any of the two above cases, we need to flip the value\\n    if (flipped === num) {\\n      // if the window which starts from current value cannot fit into the array\\n      if (i + K - 1 >= A.length) return -1;\\n\\n      // flip current value\\n      flipped ^= 1;\\n\\n      // record it\\n      hasFlipped[i] = 1;\\n\\n      ++flips;\\n    }\\n  }\\n  return flips;\\n};\\n```\\nHappy Coding~\\n",
                "solutionTags": [],
                "code": "```py\\nclass Solution:\\n    def minKBitFlips(self, A: List[int], K: int) -> int:\\n        # status: record whether current character has been flipped already or not\\n        # 0: not flipped\\n        # 1: flipped\\n        flipped = 0\\n\\n        # record whether index i, as the start of substring of length K, has been\\n        # flipped or not\\n        # 0: not flipped\\n        # 1: flipped\\n        has_flipped = [0] * len(A)\\n\\n        min_flips = 0\\n\\n        for idx, num in enumerate(A):\\n            # get the ACTUAL FLIPPED STATUS for current num by removing the flipped\\n            # status of values that are out of window\\n            if idx >= K:\\n                flipped ^= has_flipped[idx - K]\\n\\n            # we will need to flip current value iff\\n            # 1) current value is 1 and it has been flipped (i.e. flipped == 1)\\n            # 2) current value is 0 and it hasn\\'t been flipped (i.e. flipped == 0)\\n            # which can be concluded by (flipped ^ num == 0)\\n            if (flipped ^ num) == 0:\\n                # in case there is no way for us to flip current value\\n                if idx + K - 1 >= len(A):\\n                    return -1\\n\\n                # flip\\n                flipped ^= 1\\n                has_flipped[idx] = 1\\n                min_flips += 1\\n\\n        return min_flips\\n```\n```js\\nvar minKBitFlips = function(A, K) {\\n  if (!A || !A.length) return [];\\n\\n  // flipped: keep track of total flipped status\\n  // 0: not flipped\\n  // 1: flipped\\n  let flips = 0, flipped = 0;\\n  // indicate whether A[i] is truly flipped or not\\n  const hasFlipped = Array(A.length).fill(0);\\n\\n  for (const [i, num] of A.entries()) {\\n    // IMPORTANT: to determine whether at this pointer, the current value has been\\n    // flipped or not, we need to find it based on flipped and hasFlipped[i - k]\\n    if (i >= K) {\\n      flipped ^= hasFlipped[i - K];\\n    }\\n\\n    // if num == 0 and current value has not been flipped yet (flipped == 0)\\n    // if num == 1 and current value has been flipped yet (flipped == 1)\\n    // for any of the two above cases, we need to flip the value\\n    if (flipped === num) {\\n      // if the window which starts from current value cannot fit into the array\\n      if (i + K - 1 >= A.length) return -1;\\n\\n      // flip current value\\n      flipped ^= 1;\\n\\n      // record it\\n      hasFlipped[i] = 1;\\n\\n      ++flips;\\n    }\\n  }\\n  return flips;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 277018,
                "title": "python-very-very-easy-solution-beats-78-o-n",
                "content": "# Code\\n```python\\nclass Solution:\\n    def minKBitFlips(self, A, K: int) -> int:\\n        a = []\\n        for i in range(len(A) - K):\\n            if A[i] == 0:\\n                A[i] = 1\\n                A[i + K] ^= 1\\n                if len(a) > 0  and a[-1] == i:\\n                    a.pop()\\n                else:\\n                    a.append(i)\\n                a.append(i+1)\\n        if sum(A[len(A) - K:]) == 0:\\n            if (len(A) - K) in a:\\n                a.remove(len(A) - K)\\n            else:\\n                a.append(len(A) - K)\\n\\t\\treturn len(a) if  if sum(A[len(A) - K:]) == (0 or K) else -1\\n\\n\\n```\\n\\n\\n# Explanation:\\n\\nset = { }\\n\\nstep 0 \\uFF1AA = 0 0 0 1 0 1 1 0 K = 3\\nset = { }\\n\\nstep 1 \\uFF1AA = **1** 0 0 **0** 0 1 1 0        \\nset={0,1}\\n\\nstep 2 \\uFF1AA = 1 **1** 0 0 **1** 1 1 0      \\nset={0,2}\\n\\nstep 3 \\uFF1AA = 1 1 **1** 0 1 **0** 1 0   \\nset = {0,3}\\n\\nstep 4 \\uFF1AA = 1 1 1 **1** 1 0 **0** 0  \\nset = {0,4}\\n\\nstep 5 \\uFF1AA = 1 1 1 1 1 **1 1 1**\\nset = {0,4,5}\\n\\n\\nres = len()\\n\\n\\nIn every operation, flip the **i** th and (**i + K**)th\\n\\n### eg: in step 0\\n\\t\\t\\t\\t\\t flip the       0 0 0 1 0 1 1 0    to   1 1 1 1 0 1 1 0 \\n\\t\\t\\t\\t\\t then flip     1 1 1 1 0 1 1 0    to   1 0 0 0 0 1 1 0\\n\\t\\t\\t\\t\\t record 0 and 1 in a set {0, 1}\\n\\n# \\u4E2D\\u6587\\u89E3\\u91CA\\n\\n### \\u4ECE\\u6700\\u5DE6\\u8FB9\\u5F00\\u59CB\\uFF0C\\u5728\\u7B2C i \\u4F4D\\u9047\\u5230\\u96F6\\u4E4B\\u540E\\uFF0C\\u5206\\u522B\\u4ECE\\u7B2C i \\u4F4D\\u548C \\u7B2C i+1 \\u4F4D\\u5F00\\u59CB\\u7FFB\\u8F6C\\u4E24\\u6B21\\uFF0C\\u6BD4\\u5982step 0 \\u4E2D\\uFF0C\\u4ECE0\\u7FFB\\u8F6C\\u4E09\\u4E2A\\u6570\\uFF0C\\u53C8\\u4ECE1\\u7FFB\\u8F6C\\u4E09\\u4E2A\\u6570\\n\\n### \\u5C31\\u7B49\\u4EF7\\u4E8E\\u53EA\\u7FFB\\u8F6C\\u4E86 i \\u548C i+K \\u4E24\\u4F4D\\uFF08\\u7528\\u4E00\\u4E2A\\u96C6\\u5408\\u8BB0\\u5F55\\u4E0B\\u6765i\\u548Ci+1\\u4E24\\u4E2A\\u7FFB\\u8F6C\\u8D77\\u59CB\\u4F4D\\uFF0C\\u6BD4\\u5982step 0 \\u4E2D\\u7684 {0,1}\\uFF09\\n\\n### \\u7136\\u540E\\u4ECE\\u6700\\u5DE6\\u8FB9\\u5F00\\u59CB\\u4F9D\\u6B21\\u628A\\u96F6\\u4F4D\\u7FFB\\u8FC7\\u6765\\n\\n### \\u7528\\u4E00\\u4E2A\\u96C6\\u5408\\u8BB0\\u5F55\\u4E0B\\u6765 \\u5F00\\u59CB\\u7FFB\\u8F6C\\u7684\\u4F4D\\u7F6E\\uFF0C\\u53BB\\u6389\\u6240\\u6709\\u91CD\\u590D\\u7684\\n\\n## \\u91CC\\u9762\\u8FD8\\u6709\\u4E00\\u4E9B\\u7EC6\\u8282\\u7684\\u5730\\u65B9\\u5C31\\u4E0D\\u5199\\u4E86",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minKBitFlips(self, A, K: int) -> int:\\n        a = []\\n        for i in range(len(A) - K):\\n            if A[i] == 0:\\n                A[i] = 1\\n                A[i + K] ^= 1\\n                if len(a) > 0  and a[-1] == i:\\n                    a.pop()\\n                else:\\n                    a.append(i)\\n                a.append(i+1)\\n        if sum(A[len(A) - K:]) == 0:\\n            if (len(A) - K) in a:\\n                a.remove(len(A) - K)\\n            else:\\n                a.append(len(A) - K)\\n\\t\\treturn len(a) if  if sum(A[len(A) - K:]) == (0 or K) else -1\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 251356,
                "title": "o-nk-solution-but-easy-to-understand",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& A, int K) {\\n        int ans=0;\\n        for(int i=0;i<=A.size()-K;i++){\\n            if(A[i]==1)continue;\\n            ans++;\\n            for(int j=0;j<K;j++){\\n                A[i+j]^=1;\\n            }\\n            \\n        }\\n        for(int i=A.size()-K+1;i<A.size();i++)\\n            if(A[i]==0)return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& A, int K) {\\n        int ans=0;\\n        for(int i=0;i<=A.size()-K;i++){\\n            if(A[i]==1)continue;\\n            ans++;\\n            for(int j=0;j<K;j++){\\n                A[i+j]^=1;\\n            }\\n            \\n        }\\n        for(int i=A.size()-K+1;i<A.size();i++)\\n            if(A[i]==0)return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 240945,
                "title": "c-o-n-use-queue",
                "content": "```\\n    int minKBitFlips(vector<int>& A, int K) {\\n        queue<int> q;\\n        int cnt = 0;\\n        for(int i=0;i<A.size();i++){\\n            while(!q.empty() && q.front() + K - 1 < i) q.pop();\\n            if((A[i] - q.size()) % 2 == 1) continue;\\n            if(i+K > A.size()) return -1;\\n            cnt++;\\n            q.push(i);\\n        }\\n        return cnt;\\n    }",
                "solutionTags": [],
                "code": "```\\n    int minKBitFlips(vector<int>& A, int K) {\\n        queue<int> q;\\n        int cnt = 0;\\n        for(int i=0;i<A.size();i++){\\n            while(!q.empty() && q.front() + K - 1 < i) q.pop();\\n            if((A[i] - q.size()) % 2 == 1) continue;\\n            if(i+K > A.size()) return -1;\\n            cnt++;\\n            q.push(i);\\n        }\\n        return cnt;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 240748,
                "title": "swift-solution-and-explanation",
                "content": "**Explanation:**\\n***\\nWhether we should flip current number or not depends on the number value and the current flip count. When the number is 0 and current flip count is an even number, or the number is 1 and current flip count is an odd number, we will flip it. \\n\\n> e.g. \\n0 1 0 1 (k = 2)\\nfirst we should flip  \"0\" as the value is 0 and current flip count is 0 (Even), after flip, current flip count become 1\\nthen we should flip  \"1\" as the value is 1 and current flip count is 1 (Odd), after flip, current flip count become 2\\nwhen we try to flip next  \"0\", we should  reduce the flip count of the first \"0\", so the value is 0 and current flip count is 1 (Odd), we won\\'t flip it.\\n\\n**Solution**\\n***\\n```\\nclass Solution {\\n    func minKBitFlips(_ A: [Int], _ K: Int) -> Int {\\n        let count = A.count\\n        \\n        var needReduceCurFlipCount = Array.init(repeating: false, count: count + 1)\\n        var curFlipCountIsEven = true\\n        var totalFlipCount = 0\\n        \\n        for i in A.indices {\\n            if needReduceCurFlipCount[i] {\\n                curFlipCountIsEven.toggle()\\n            }\\n            \\n            if A[i] == (curFlipCountIsEven ? 0 : 1) {\\n                if i + K - 1 < count {\\n\\t\\t\\t\\t    // reduce flip count when i + K (change odd even)\\n                    needReduceCurFlipCount[i + K] = true\\n\\n                    curFlipCountIsEven.toggle()\\n                    totalFlipCount += 1\\n                } else {\\n                    return -1\\n                }\\n            }\\n        }\\n        \\n        return totalFlipCount\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func minKBitFlips(_ A: [Int], _ K: Int) -> Int {\\n        let count = A.count\\n        \\n        var needReduceCurFlipCount = Array.init(repeating: false, count: count + 1)\\n        var curFlipCountIsEven = true\\n        var totalFlipCount = 0\\n        \\n        for i in A.indices {\\n            if needReduceCurFlipCount[i] {\\n                curFlipCountIsEven.toggle()\\n            }\\n            \\n            if A[i] == (curFlipCountIsEven ? 0 : 1) {\\n                if i + K - 1 < count {\\n\\t\\t\\t\\t    // reduce flip count when i + K (change odd even)\\n                    needReduceCurFlipCount[i + K] = true\\n\\n                    curFlipCountIsEven.toggle()\\n                    totalFlipCount += 1\\n                } else {\\n                    return -1\\n                }\\n            }\\n        }\\n        \\n        return totalFlipCount\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 239489,
                "title": "proof-of-the-greedy-solution",
                "content": "First, we define a family of functions ```[f1(K, A), f2(K, A), ..., fn-K+1(K, A)]``` w.r.t an array ```A``` with ```n``` elements, where ```fi(K, A)``` applies a ```K```-bit flip to ```A``` with the ```i```th element as the first flipped element. Second, we define ```(fi1, fi2, ..., fim)``` as the composition of these ```m``` functions, which can be applied to ```A``` to get ```fim(K, fim-1(K, ...fi1(K, A)...))```. We can find that ```fi(K, fj(K, A)) == fj(K, fi(K, A))```, and it\\'s obvious that ```(fi1, fi2, ..., fim)``` is equivalent to any permutation of these functions, e.g. ```fim(K, fim-1(K, ...fi1(K, A)...)) == fim-1(K, fim(K, ...fi1(K, A)...))```. Then, we will prove the correctness of the greedy solution.\\n\\nGiven an array ```A```, we assume that there exists ```(fi1, fi2, ..., fim)``` which flips the elements of ```A``` to get an array consisting of 1s with ```m``` as the minimum number of the functions required. Without loss of generality, we assume ```i1 <= i2 <= ... <= im```. And we will prove that ```ix != iy``` for any ```x, y``` at first. We assume there exist ```x, y``` such that ```ix == iy```. Then, we exchange the order of ```fix+1``` and ```fiy```, and we can find that the composition of ```fix``` and ```fiy``` is an identity mapping. Thus, the exchange will lead to the composition of ```m-2``` functions that is equivalent to ```(fi1, fi2, ..., fim)```. However, ```m``` is the minimum number of the ```K```-bit flips required. Therefore ```ix != iy``` for any ```x, y```.\\n\\nThen, we compare ```(fj1, fj2, ..., fjk)``` in which each function is obtained by the greedy algorithm, with ```(fi1, fi2, ..., fim)```. It\\'s obvious that ```k >= m``` and ```j1 < j2 < ... < jk``` (considering the greedy selection). Thus, we need to prove ```k == m``` and ```j1 == i1, j2 == i2, ..., jm == im```. Actually, we can find that the proof of ```k == m``` can be derived from ```j1 == i1, j2 == i2, ..., jm == im```. Thus, we will prove ```j1 == i1, j2 == i2, ..., jm == im```. \\n\\nWithout loss of generality, we assume that there exists at least one ```0``` in ```A```. By induction, we prove ```j1 == i1``` at first. Let ```A[k1]``` be the first ```0``` in ```A```. Thus, ```j1 == k1``` due to the greedy selection. In terms of ```(fi1, fi2, ..., fim)```, if ```k1 < i1```, ```A[k1]``` will not be flipped. And if ```k1 > i1```, ```A[i1]``` will be ```0``` after applying all the functions to ```A```.  Thus, ```i1 == k1 == j1```. Then, we assume ```jx == ix``` for ```x < y <= m```, and we will prove ```jy == iy```. Note that ```A[i] == 1``` for ```i < jy``` after applying the ```y-1``` functions to ```A```, which is determined by the greedy selection. Considering ```(fi1, fi2, ..., fim)```, if ```iy < jy```, ```A[iy]``` will be ```0``` after the flips. And if ```iy > jy```, ```A[jy]``` will not be flipped (```A[jy] == 0``` due to the greedy selection). Thus, ```jy == iy```, and we conclude the proof.\\n",
                "solutionTags": [],
                "code": "```[f1(K, A), f2(K, A), ..., fn-K+1(K, A)]```\n```A```\n```n```\n```fi(K, A)```\n```K```\n```A```\n```i```\n```(fi1, fi2, ..., fim)```\n```m```\n```A```\n```fim(K, fim-1(K, ...fi1(K, A)...))```\n```fi(K, fj(K, A)) == fj(K, fi(K, A))```\n```(fi1, fi2, ..., fim)```\n```fim(K, fim-1(K, ...fi1(K, A)...)) == fim-1(K, fim(K, ...fi1(K, A)...))```\n```A```\n```(fi1, fi2, ..., fim)```\n```A```\n```m```\n```i1 <= i2 <= ... <= im```\n```ix != iy```\n```x, y```\n```x, y```\n```ix == iy```\n```fix+1```\n```fiy```\n```fix```\n```fiy```\n```m-2```\n```(fi1, fi2, ..., fim)```\n```m```\n```K```\n```ix != iy```\n```x, y```\n```(fj1, fj2, ..., fjk)```\n```(fi1, fi2, ..., fim)```\n```k >= m```\n```j1 < j2 < ... < jk```\n```k == m```\n```j1 == i1, j2 == i2, ..., jm == im```\n```k == m```\n```j1 == i1, j2 == i2, ..., jm == im```\n```j1 == i1, j2 == i2, ..., jm == im```\n```0```\n```A```\n```j1 == i1```\n```A[k1]```\n```0```\n```A```\n```j1 == k1```\n```(fi1, fi2, ..., fim)```\n```k1 < i1```\n```A[k1]```\n```k1 > i1```\n```A[i1]```\n```0```\n```A```\n```i1 == k1 == j1```\n```jx == ix```\n```x < y <= m```\n```jy == iy```\n```A[i] == 1```\n```i < jy```\n```y-1```\n```A```\n```(fi1, fi2, ..., fim)```\n```iy < jy```\n```A[iy]```\n```0```\n```iy > jy```\n```A[jy]```\n```A[jy] == 0```\n```jy == iy```",
                "codeTag": "Unknown"
            },
            {
                "id": 238797,
                "title": "greedy-solution-with-bitset",
                "content": "# Concept\\n1. bitwise operation is fast\\n2. sliding window with size K\\n3. when the current bit is 0, we only need to flip all bits in sliding window\\n4. shift the sliding window\\n\\n\\'\\'\\'\\n\\n    int minKBitFlips(vector<int>& A, int K) {\\n        int size = A.size();\\n        int len = 30001;\\n        string ks = \"\";\\n        A.push_back(0);\\n        for(int i=K-1;i>=0;i--){\\n            if(A[i]==0) {\\n                ks+=\"0\";\\n            }\\n            else{\\n                ks+=\"1\";\\n            }\\n        }\\n        bitset<30001> kb(ks);\\n        int count = 0;\\n        for(int i=0;i<size-K+1;i++){\\n            if(kb[0]==0 ){\\n                kb.flip();\\n                count ++;\\n            }\\n            if(A[i+K])\\n                kb.set(K);\\n            else\\n                kb.reset(K);\\n            kb>>=1;\\n        }\\n        for(int i=0;i<K-1;i++){\\n            if(kb[i]==0) {\\n                count = -1;\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n\\t\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "# Concept\\n1. bitwise operation is fast\\n2. sliding window with size K\\n3. when the current bit is 0, we only need to flip all bits in sliding window\\n4. shift the sliding window\\n\\n\\'\\'\\'\\n\\n    int minKBitFlips(vector<int>& A, int K) {\\n        int size = A.size();\\n        int len = 30001;\\n        string ks = \"\";\\n        A.push_back(0);\\n        for(int i=K-1;i>=0;i--){\\n            if(A[i]==0) {\\n                ks+=\"0\";\\n            }\\n            else{\\n                ks+=\"1\";\\n            }\\n        }\\n        bitset<30001> kb(ks);\\n        int count = 0;\\n        for(int i=0;i<size-K+1;i++){\\n            if(kb[0]==0 ){\\n                kb.flip();\\n                count ++;\\n            }\\n            if(A[i+K])\\n                kb.set(K);\\n            else\\n                kb.reset(K);\\n            kb>>=1;\\n        }\\n        for(int i=0;i<K-1;i++){\\n            if(kb[i]==0) {\\n                count = -1;\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n\\t\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 238544,
                "title": "python-solution-using-bisect-o-nlogn",
                "content": "the key is flip the `left most 0`, for the `left most 0`, we use it as the first element to flip.\\n\\nbut flip will influence the next k element, here I use a list to store the right most index in each flip. Then I use bisect to find `now index` whether be influenced by previous operation or not.\\n\\n```python\\nclass Solution:\\n    def minKBitFlips(self, A, K):\\n        res = 0\\n        s = []\\n        for i in range(len(A)):\\n            index = bisect.bisect_right(s, i)\\n            # if influenced, flip it and then judge\\n            if (len(s) - index) % 2 == 1:\\n                A[i] = 1 - A[i]\\n            # only consider it when A[i] == 0\\n            if A[i] == 1: continue\\n            if len(A)-i < K: return -1\\n            res += 1\\n            s.append(i + K)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minKBitFlips(self, A, K):\\n        res = 0\\n        s = []\\n        for i in range(len(A)):\\n            index = bisect.bisect_right(s, i)\\n            # if influenced, flip it and then judge\\n            if (len(s) - index) % 2 == 1:\\n                A[i] = 1 - A[i]\\n            # only consider it when A[i] == 0\\n            if A[i] == 1: continue\\n            if len(A)-i < K: return -1\\n            res += 1\\n            s.append(i + K)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3914666,
                "title": "c-easy-simple-explanation-greedy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n  As we have to make the array equal to 1  , So reverse the problem  Let\\'s we have given Array of same size and all elements are 1 and now we have to make array to nums and minimum no. of operation for both problem is same.\\n1. create dp array with store the prefix sum of all operations till now. But remember   i^th element only effected by previous k-1 elements so, to count the no. of operation for ith element is:\\n  dp[i-1] - dp[i-k]\\n2. so, to find the current value of ith element is (1-temp[i]) if(dp[i-1] - dp[i-k] is not even) else current value remain same as temp[i].\\n3. Then compare every ith element value with nums[i] if there is a mismatch then increment ans by 1 and update dp[i] = dp[i-1] + 1; , if the match is equal then dp[i] = dp[i-1];\\n4. After applying the above operation on n - k element then check for remaining elements if there is a mismatch then return -1 . else return ans;\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   \\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int n= nums.size();\\n        vector<int>dp(n+1,0);\\n        vector<int>temp(n+1,1);\\n        int ans =0;\\n        for(int i = 0;i<=n-k;i++){\\n             int ind = i-k;\\n             int prev;\\n             if(ind<0){\\n                  prev = 0;\\n             }else{\\n                  prev = dp[i-k];\\n             }\\n            if(i-1>=0)\\n             prev = dp[i-1] - prev;\\n             int val = (prev%2==0) ? temp[i] : 1 - temp[i];\\n           // cout<<prev<<\" \"<<i<<endl;\\n             if(nums[i] != val){\\n                  ans++;\\n                \\n                if(i-1>=0)\\n                  dp[i] = dp[i-1] + 1;\\n                else\\n                  dp[i] += 1;\\n             }else{\\n                if(i-1>=0)\\n                 dp[i] =dp[i-1];\\n             }\\n        }\\n        for(int i = n-k+1;i<n;i++){\\n             dp[i] =dp[i-1];\\n        }\\n        for(int i = n-k+1;i<n;i++){\\n            int prev;\\n         if((i-k)>=0)\\n              prev = dp[i-1] - dp[i-k];\\n         else\\n             prev = dp[i-1];\\n           //   cout<<prev<<\" \"<<i<<endl;\\n             int val = (prev%2==0) ? temp[i] : 1 - temp[i];\\n             if(nums[i] != val){\\n                  return -1;\\n             }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int n= nums.size();\\n        vector<int>dp(n+1,0);\\n        vector<int>temp(n+1,1);\\n        int ans =0;\\n        for(int i = 0;i<=n-k;i++){\\n             int ind = i-k;\\n             int prev;\\n             if(ind<0){\\n                  prev = 0;\\n             }else{\\n                  prev = dp[i-k];\\n             }\\n            if(i-1>=0)\\n             prev = dp[i-1] - prev;\\n             int val = (prev%2==0) ? temp[i] : 1 - temp[i];\\n           // cout<<prev<<\" \"<<i<<endl;\\n             if(nums[i] != val){\\n                  ans++;\\n                \\n                if(i-1>=0)\\n                  dp[i] = dp[i-1] + 1;\\n                else\\n                  dp[i] += 1;\\n             }else{\\n                if(i-1>=0)\\n                 dp[i] =dp[i-1];\\n             }\\n        }\\n        for(int i = n-k+1;i<n;i++){\\n             dp[i] =dp[i-1];\\n        }\\n        for(int i = n-k+1;i<n;i++){\\n            int prev;\\n         if((i-k)>=0)\\n              prev = dp[i-1] - dp[i-k];\\n         else\\n             prev = dp[i-1];\\n           //   cout<<prev<<\" \"<<i<<endl;\\n             int val = (prev%2==0) ? temp[i] : 1 - temp[i];\\n             if(nums[i] != val){\\n                  return -1;\\n             }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3880677,
                "title": "python-concise-o-n-solution-using-queue-to-track-numbers-of-flip",
                "content": "If we have to manipulate the list for every flip, we need O(K) additional runtime for each flip. However, we can store flip information in queue and use the length of the queue for determining if the current element we look at needs to be flipped or not.\\n\\n```\\nfrom collections import deque\\n\\n\\nclass Solution:\\n    def minKBitFlips(self, nums: list[int], k: int) -> int:\\n        dp = [-1] * len(nums)\\n        flips = deque()\\n        ans = 0\\n        for i in range(len(nums) - k + 1):\\n            while flips and flips[0] < i:\\n                flips.popleft()\\n            if nums[i] == len(flips) % 2:\\n                ans += 1\\n                flips.append(i + k - 1)\\n        for i in range(len(nums) - k, len(nums)):\\n            while flips and flips[0] < i:\\n                flips.popleft()\\n            if nums[i] == len(flips) % 2:\\n                return -1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Queue"
                ],
                "code": "```\\nfrom collections import deque\\n\\n\\nclass Solution:\\n    def minKBitFlips(self, nums: list[int], k: int) -> int:\\n        dp = [-1] * len(nums)\\n        flips = deque()\\n        ans = 0\\n        for i in range(len(nums) - k + 1):\\n            while flips and flips[0] < i:\\n                flips.popleft()\\n            if nums[i] == len(flips) % 2:\\n                ans += 1\\n                flips.append(i + k - 1)\\n        for i in range(len(nums) - k, len(nums)):\\n            while flips and flips[0] < i:\\n                flips.popleft()\\n            if nums[i] == len(flips) % 2:\\n                return -1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3722203,
                "title": "o-n-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int high=0,temp,res=0,count;\\n        queue<int> q;\\n        while(high<nums.size()){\\n            if(nums[high]==0){\\n               q.push(high+k-1);\\n               temp=k;\\n               count=1;\\n               res+=1;\\n               while(temp){\\n                   if(nums.size()-high<temp)return -1;\\n                   if(count%2==1)nums[high]==0?nums[high]=1:nums[high]=0;\\n                   if(nums[high]==0){\\n                       temp=k;res++;nums[high]=1;\\n                       q.push(high+k-1);\\n                       count++;\\n                   }\\n                   temp--;\\n                   if(q.size()>0 && q.front()==high)count--,q.pop();\\n                   high++;\\n               }\\n            }\\n            else\\n            high++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int high=0,temp,res=0,count;\\n        queue<int> q;\\n        while(high<nums.size()){\\n            if(nums[high]==0){\\n               q.push(high+k-1);\\n               temp=k;\\n               count=1;\\n               res+=1;\\n               while(temp){\\n                   if(nums.size()-high<temp)return -1;\\n                   if(count%2==1)nums[high]==0?nums[high]=1:nums[high]=0;\\n                   if(nums[high]==0){\\n                       temp=k;res++;nums[high]=1;\\n                       q.push(high+k-1);\\n                       count++;\\n                   }\\n                   temp--;\\n                   if(q.size()>0 && q.front()==high)count--,q.pop();\\n                   high++;\\n               }\\n            }\\n            else\\n            high++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3715068,
                "title": "python-brute-force-optimization-with-queue-and-more",
                "content": "**Brute-force is easy**\\nAt each index with `0` invert `k` items.\\nCount number of invert calls.\\nCheck that inverted `nums` has all `1`. Return `count` otherwise return -1.\\n```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        count = 0\\n        N = len(nums)\\n        for i in range(N - k + 1):\\n            if nums[i] == 0:\\n                count += 1\\n                for j in range(i, i + k):\\n                    nums[j] = 1 - nums[j] # nums[j] ^ 1\\n        \\n        return count if all(num == 1 for num in nums) else -1\\n```\\n`O(N\\\\*k)`, kinda slow, let\\'s move on to optimization.\\n\\nWhat can be optimizad here? What\\'s slow?\\nWe need to go over the array at least once (to check if it\\'s all `1`), so we cannot get rid of `N`.\\nLet\\'s work on `k`.\\n\\n**Optimizing `O(k)` -> `O(1)`**\\n```\\nfor j in range(i, i + k):\\n    nums[j] = 1 - nums[j] # nums[j] ^ 1\\n```\\nWhat do we do here?\\nWe go over next `k` elements and invert them.\\n\\nHow can we combine going over `k` and going over `N` loops???\\n\\nA few observations from brute-force:\\n1. we need to know when to stop inverting\\n2. we need to do inverting and going over `N` and `k` at the same time.\\n\\n**Approach 1.5**\\nQ: How to track when to stop inverting???\\nA: We can use some kind of DS (list/queue???) and keep tracking k-invert ends.\\n\\nQ: What if we need to invert inside of another currently running k-invert???\\nA: So we need to track current inver count. It can be that we started one invert, then next element needs another invert and the next need another request. Kind of enveloping. We can just have a `invert-times` counter or reuse `inver-ends` DS and loop over each invert-end and do `XOR`.\\n\\n```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        count = 0\\n        N = len(nums)\\n        inv_ends = deque() # track invert-ends\\n        for i in range(N):\\n            if inv_ends and inv_ends[0] == i:\\n                inv_ends.popleft() # remove invert-end that is not active anymore\\n            if inv_ends:\\n                for _ in inv_ends: # if we need to invert, just invert as many times as we need (=number of currently running invert procedures)\\n                    nums[i] ^= 1\\n\\n            if nums[i] == 0 and i <= N - k: # can invert only when possible - i <= N - k and when [i] == 0\\n                count += 1 # count inverts\\n                nums[i] = 1 # set it to 1\\n                inv_ends.append(i + k) # append new k-invert end\\n        \\n        return count if all(num == 1 for num in nums) else -1 # all ones -> we good, else -1\\n```\\nStill `O(N*k)`, but now we know what we\\'re doing.\\nWe replaced **horizontal** k-inverts with **vertical** k-inverts.\\n\\n**Optimizing `O(N*k)` to O(N)**\\nIn the last approach we see that our `k` loop is still there.\\nWhat do we do in the loop? We flip `1->0` or `0->1` `k` times.\\n\\nQ: How can we optimize it?\\nA: if you do **even** number of flips, you get the same number you had before\\nIf you do **odd**, you get the opposite one.\\n\\nSo we can replace this `O(k)`\\n```\\n                for _ in inv_ends:\\n                    nums[i] ^= 1\\n```\\nwith this `O(1)`\\n```\\n                if len(inv_ends) % 2:\\n                    nums[i] ^= 1\\n```\\nand have the same outcome!\\n\\n```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        count = 0\\n        ones = 0\\n        N = len(nums)\\n        inv_ends = deque()\\n        for i in range(N):\\n            if inv_ends and inv_ends[0] == i:\\n                inv_ends.popleft()\\n            if inv_ends:\\n                if len(inv_ends) % 2:\\n                    nums[i] ^= 1\\n\\n            if nums[i] == 0 and i <= N - k:\\n                count += 1\\n                nums[i] = 1\\n                inv_ends.append(i + k)\\n            if nums[i]:\\n                ones += 1\\n        \\n        return count if ones == N else -1\\n```\\n\\nNow a bit of clean up so that we don\\'t modify the `nums` array.\\n```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        N = len(nums)\\n        count = 0\\n        ones = 0\\n        inv_ends = deque()\\n        for i in range(N):\\n            one = nums[i] == 1\\n            if inv_ends and inv_ends[0] == i:\\n                inv_ends.popleft()\\n            if inv_ends:\\n                if len(inv_ends) % 2:\\n                    one = not one\\n            if not one and i <= N - k:\\n                count += 1\\n                one = True\\n                inv_ends.append(i + k)\\n            ones += one        \\n        return count if ones == N else -1\\n```\\n\\n**Optimize space `O(k)` to `O(1)`**\\nThis is not exactly `O(1)` constant space as I wish it was. This is `O(1)` extra space with `nums` modification, which is not the best, but you inline information from the queue in the `nums` and get rid of queue.\\n\\n`\\xAF\\\\_(\\u30C4)_/\\xAF`\\n\\nKeep track `inv_ends` in `nums`.\\nAs `nums` contains only `0` or `1`, we can `-2` from each k-invert start position instead of using `inv_end` marker.\\nAs we cannot modify future elements (guess why?), we\\'ll have to modify past elements and use `[inv_start] -= 2` now and check from the current element if we get ouf of one of the currently running k-invert procedures ([i - k] < 0 ? -> found marker).\\n```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        N = len(nums)\\n        ones = 0\\n        count = 0\\n        invert_ops = 0\\n        for i in range(N):\\n            one = nums[i] == 1\\n            if i >= k and nums[i - k] < 0:\\n                nums[i - k] += 2 # restore original array\\n                invert_ops -= 1\\n            if invert_ops % 2:\\n                one = not one\\n            if not one and i <= N - k:\\n                count += 1\\n                one = True\\n                invert_ops += 1\\n                nums[i] -= 2 # modify original array\\n            ones += one        \\n        return count if ones == N else -1\\n```\\n\\nP.S. it\\'s not that bad with the approach: we can restore the original `nums` if needed by iterating over the array and `+2` at marker positions to restore the original `nums`.\\n\\nCheers!",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        count = 0\\n        N = len(nums)\\n        for i in range(N - k + 1):\\n            if nums[i] == 0:\\n                count += 1\\n                for j in range(i, i + k):\\n                    nums[j] = 1 - nums[j] # nums[j] ^ 1\\n        \\n        return count if all(num == 1 for num in nums) else -1\\n```\n```\\nfor j in range(i, i + k):\\n    nums[j] = 1 - nums[j] # nums[j] ^ 1\\n```\n```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        count = 0\\n        N = len(nums)\\n        inv_ends = deque() # track invert-ends\\n        for i in range(N):\\n            if inv_ends and inv_ends[0] == i:\\n                inv_ends.popleft() # remove invert-end that is not active anymore\\n            if inv_ends:\\n                for _ in inv_ends: # if we need to invert, just invert as many times as we need (=number of currently running invert procedures)\\n                    nums[i] ^= 1\\n\\n            if nums[i] == 0 and i <= N - k: # can invert only when possible - i <= N - k and when [i] == 0\\n                count += 1 # count inverts\\n                nums[i] = 1 # set it to 1\\n                inv_ends.append(i + k) # append new k-invert end\\n        \\n        return count if all(num == 1 for num in nums) else -1 # all ones -> we good, else -1\\n```\n```\\n                for _ in inv_ends:\\n                    nums[i] ^= 1\\n```\n```\\n                if len(inv_ends) % 2:\\n                    nums[i] ^= 1\\n```\n```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        count = 0\\n        ones = 0\\n        N = len(nums)\\n        inv_ends = deque()\\n        for i in range(N):\\n            if inv_ends and inv_ends[0] == i:\\n                inv_ends.popleft()\\n            if inv_ends:\\n                if len(inv_ends) % 2:\\n                    nums[i] ^= 1\\n\\n            if nums[i] == 0 and i <= N - k:\\n                count += 1\\n                nums[i] = 1\\n                inv_ends.append(i + k)\\n            if nums[i]:\\n                ones += 1\\n        \\n        return count if ones == N else -1\\n```\n```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        N = len(nums)\\n        count = 0\\n        ones = 0\\n        inv_ends = deque()\\n        for i in range(N):\\n            one = nums[i] == 1\\n            if inv_ends and inv_ends[0] == i:\\n                inv_ends.popleft()\\n            if inv_ends:\\n                if len(inv_ends) % 2:\\n                    one = not one\\n            if not one and i <= N - k:\\n                count += 1\\n                one = True\\n                inv_ends.append(i + k)\\n            ones += one        \\n        return count if ones == N else -1\\n```\n```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        N = len(nums)\\n        ones = 0\\n        count = 0\\n        invert_ops = 0\\n        for i in range(N):\\n            one = nums[i] == 1\\n            if i >= k and nums[i - k] < 0:\\n                nums[i - k] += 2 # restore original array\\n                invert_ops -= 1\\n            if invert_ops % 2:\\n                one = not one\\n            if not one and i <= N - k:\\n                count += 1\\n                one = True\\n                invert_ops += 1\\n                nums[i] -= 2 # modify original array\\n            ones += one        \\n        return count if ones == N else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649225,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def minKBitFlips(nums: Array[Int], k: Int): Int = {\\n      val n = nums.length\\n      val diff = Array.fill(n + 1)(0)\\n      var ans = 0\\n      var revCnt = 0\\n      var i = 0\\n      while (i < n) {\\n        revCnt += diff(i)\\n        if ((nums(i) + revCnt) % 2 == 0) {\\n          if (i + k > n) {\\n            ans = -1\\n            i = n\\n          } else {\\n            ans += 1\\n            revCnt += 1\\n            diff(i + k) -= 1\\n          }\\n        }\\n        i += 1\\n      }\\n      ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def minKBitFlips(nums: Array[Int], k: Int): Int = {\\n      val n = nums.length\\n      val diff = Array.fill(n + 1)(0)\\n      var ans = 0\\n      var revCnt = 0\\n      var i = 0\\n      while (i < n) {\\n        revCnt += diff(i)\\n        if ((nums(i) + revCnt) % 2 == 0) {\\n          if (i + k > n) {\\n            ans = -1\\n            i = n\\n          } else {\\n            ans += 1\\n            revCnt += 1\\n            diff(i + k) -= 1\\n          }\\n        }\\n        i += 1\\n      }\\n      ans\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3576679,
                "title": "python-o-n-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        f = [0] * len(nums)\\n        psum = 0\\n        for i in range(len(nums)-k+1):\\n            if (psum + nums[i])%2 == 0:\\n                f[i] = 1\\n            psum += f[i]\\n            if i-k+1 >= 0:\\n                psum -= f[i-k+1]\\n        for i in range(len(nums)-k+1, len(nums)):\\n            if (psum+nums[i])%2 == 0:\\n                return -1\\n            if i-k+1 >= 0:\\n                psum -= f[i-k+1]  \\n        return sum(f)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        f = [0] * len(nums)\\n        psum = 0\\n        for i in range(len(nums)-k+1):\\n            if (psum + nums[i])%2 == 0:\\n                f[i] = 1\\n            psum += f[i]\\n            if i-k+1 >= 0:\\n                psum -= f[i-k+1]\\n        for i in range(len(nums)-k+1, len(nums)):\\n            if (psum+nums[i])%2 == 0:\\n                return -1\\n            if i-k+1 >= 0:\\n                psum -= f[i-k+1]  \\n        return sum(f)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566350,
                "title": "easy-solution-with-multiple-proofs-intuition-for-greedy-when-impossible",
                "content": "# Greedy Intuition + Proof\\n-Our greedy strategy is to iterate from beginning to end of the array. If we encounter a bit that is a 0 it needs to be flipped so we flip a \\'window\\' of k elements starting at thi current element.\\n\\n-Invariant of this strategy: All elements currently iterated through are 1s\\n\\nInductive proof on the optimality of this strategy:\\n\\nLet i be the current index we have iterated through\\n\\nBase Case (i = 0):\\n-there are two cases when i = 0.\\n\\narr[0] = 1: in this case no flip is neccesary hence optimal\\narr[0] = 0: in this case we MUST flip because the start of the flip window is strictly increasing hence this is the only possible starting flip index to flip this 0 to a 1 hence it is part of the optimal sequence of flips.\\n\\nInductive Hypothesis: arr[0:n] is a subarray of consecutive 1s achieved int eh optimal set of flips.\\n\\nInductive Case (i = n + 1):\\n\\nWe assume the inductive hypothesis\\n\\n-there are two cases\\n\\narr[n + 1] = 1: In this case no flip is neccesary hence optimal\\narr[n + 1] = 0: In this case I must flip a window starting at this index because no other flip going forward can turbn this 0 into a 1. Hence it is optimal.\\n\\n\\n# Optimal Substructure\\n-For me, the least intutive part of this problem is understanding why there is an optimal substructure (ie. making a locally optimal flip leads to a global optimum). When determining flips from left to right we have established an invariant holds that all previously processed elements are 1s. If we want to flip the current element flipping a window starting before i (the current index), assuming it fits, will convert some number of 1s back to 0s, this will lead the array to have the following structure: [1, ... , 1, 0, ... , 0, 1, ...] such that the current index is the last (farthest left) 1. In order to convert this sequence to 1s we must use at least 2 more flips, one to convert the 0s to 1s and 1 to convert the 0s this flip creates to ones (more flips may be neccesary based on how we choose them), hence choosing a flip window starting at the current index is optimal since it only requires 1 flip starting to convert to prefix array to all 1s. \\n\\n-One concern I had was that flipping at the current index greedily may arrange future bits to be processed to requrie more flips than a different strategy. I have shown that when encountering a 0 bit, flipping it with a window starting before it requires at least two flips while flipping starting at the index requires just one flip. Assume that our greedy strategy happens to flip future 1s to 0s that the other hypothetical strategy doesn\\'t. Well we can convert all of these 1s back to 0s in just 1 additional future flip because they will all be reachable from the window starting at the next 1. Hence the hypothetical strategy globally contributes at least 2 flips at each 0 it processes while the greedy strategy globally contributes at most 2 flips at each 0 it processes, thus there is an optimal substructure.\\n\\n# Proof of Impossible State\\n\\nWhen our algorithm produces a state in which our array is all ones followed by all 0s (arr = [1, ... ,1,0, ... ,0]) such that the number of 0s is less than k it is impossible to achieve an array with no 0s. \\n\\nI will prove this by contradiction.\\n\\nProof: Assume it is possible to turn an array of the aforementioned state into an array with no 0s using valid operations. Then it is possible to do this is an optimal number of steps. An optimal number of steps must not repear any flipping steps since repeating flips of the same window cancels itself out (hence doing so an even number of times does nothing while doing so an odd number of times is equivelenat to performing just a single flip). \\n\\nIn order to turn this array into an array of all 1s we must perform at least one flip of the 0s. Since there are less than k 0s the beginning of this flip window must begin before the first 0 (at some index that currently has a 1). I will denote this starting index of the window j. This means the element at j is initially a 1 and is flipped into a 0. In order for this index to be flipped back to a 1 another flip must take place at or before this index. If a flip takes place at this index a duplicate operation must be performed hence we have a contradiction. If the flip takes place before we have a new index j, the farthest left 0 that must have another flip at or to the left of it. The same two cases apply before. If we keep flipping before eventually we end up pushing j back until j = 0 (the first index) and it can no longer be pushed back. Once here the only flip that can turn it back into a 1 is a flip starting at index 0 which duplicates the flip that turned it from a 1 back into a 0, hence our optimal solution must have a duplicate, hence a contradiction. QED\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int flips = 0;\\n        queue<int> filters; //queue of \\'filters\\' used to simulate bit flips\\n        int cur = 0; //current filter\\n        for (int i = 0; i < nums.size(); i++) {\\n            //assume invariant that all previous elements are 1\\n            if ((nums[i] ^ cur) == 0 && (nums.size() - i) < k) return -1; //impossible case\\n            if ((nums[i] ^ cur) == 0) {\\n                flips++;\\n                filters.push(i + k - 1);\\n                cur = 1 - cur;\\n            } \\n            if (!filters.empty() && filters.front() == i) { //process filters queue\\n                filters.pop();\\n                cur = 1 - cur;\\n            }\\n        }\\n        return flips;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Bit Manipulation",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int flips = 0;\\n        queue<int> filters; //queue of \\'filters\\' used to simulate bit flips\\n        int cur = 0; //current filter\\n        for (int i = 0; i < nums.size(); i++) {\\n            //assume invariant that all previous elements are 1\\n            if ((nums[i] ^ cur) == 0 && (nums.size() - i) < k) return -1; //impossible case\\n            if ((nums[i] ^ cur) == 0) {\\n                flips++;\\n                filters.push(i + k - 1);\\n                cur = 1 - cur;\\n            } \\n            if (!filters.empty() && filters.front() == i) { //process filters queue\\n                filters.pop();\\n                cur = 1 - cur;\\n            }\\n        }\\n        return flips;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3489859,
                "title": "c-very-easy-to-understand-o-n-solution-beats-100-memory-and-runtime",
                "content": "# Intuition\\nIt is given that we need to convert all 0s to 1s in the array. We are given `k` which is the size of window in which we can flip the bits.\\nIf we take the example - `[0,1,0]` and `k = 2` we can see that we can solve this by flipping window of size `k` from index 0 and also index 1. So we see that if we are flipping for element 0 and 1 is encountered in the window, we need to start a window for 1 when it is encountered in the previous window. \\n\\n# Approach\\n- We maintain a `ans` variable for counting the number of windows that need to be flipped.  \\n- We maintain a variable whichToFlip which essentially tells us when to start the flipping window (when current element is 0 or it is 1). It is initialized to 0 as we need to flip all 0s to 1s initially when no window is there. \\n- Start traversing the array and check 2 conditions.\\n    - If the window to the left of the current element is flipped or no. In that case it changes the `whichToFlip` to `!whichToFlip`.\\n    - If the element to be flipped (`whichToFlip`) is equal to the current element. \\n        - We also check if making a window of size `k` is possible from the current position (`i+k > n`). If it returns true then return -1 as it is not possible to create a window from that position.\\n        - Else start a window from the current element and mark the element as a starting point of the window. We do this by incrementing `nums[i]` by 10. We also increment answer and change whichToFlip.\\n# Complexity\\n    \\nTime complexity:\\n\\n    O(n)    \\n\\nSpace complexity:\\n\\n    O(1)    \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int ans=0;\\n        int whichToFlip = 0;\\n\\n        for(int i=0;i<n;i++){\\n            if(i>=k && nums[i-k] > 1){ // Checks if previous subarray of length k is flipped\\n                whichToFlip = !whichToFlip;\\n            }\\n\\n            if(whichToFlip == nums[i]){\\n                if(k+i >n)return -1; // If flipping is required but not enough elements available\\n                ans++;\\n                // If flipping window has not ended and the opposite element is \\n                // encountered then another window should start flipping from that element.\\n                whichToFlip = !whichToFlip;  \\n                nums[i] += 10;\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int ans=0;\\n        int whichToFlip = 0;\\n\\n        for(int i=0;i<n;i++){\\n            if(i>=k && nums[i-k] > 1){ // Checks if previous subarray of length k is flipped\\n                whichToFlip = !whichToFlip;\\n            }\\n\\n            if(whichToFlip == nums[i]){\\n                if(k+i >n)return -1; // If flipping is required but not enough elements available\\n                ans++;\\n                // If flipping window has not ended and the opposite element is \\n                // encountered then another window should start flipping from that element.\\n                whichToFlip = !whichToFlip;  \\n                nums[i] += 10;\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3430942,
                "title": "greedy-approch-in-javascript-49-9-mb-less-than-100-00",
                "content": "![image](https://assets.leetcode.com/users/images/4d790763-1b20-4907-b57e-395e127aeccb_1681821707.122669.png)\\n\\n```\\nvar minKBitFlips = function(nums, k) {\\n    let count = 0;\\n    \\n    function flip(pos){\\n         for(let i=0 ;i<k;i++){\\n            nums[i+pos] = 1- nums[i+pos] ;\\n        }\\n    }\\n\\n     for(let i=0; i<nums.length; i++){\\n        if(nums[i] === 0 && (i+k)<= nums.length){\\n            flip(i)\\n            count++\\n            }\\n     }\\n    \\n   return !nums.includes(0) ? count : -1;\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/4d790763-1b20-4907-b57e-395e127aeccb_1681821707.122669.png)\\n\\n```\\nvar minKBitFlips = function(nums, k) {\\n    let count = 0;\\n    \\n    function flip(pos){\\n         for(let i=0 ;i<k;i++){\\n            nums[i+pos] = 1- nums[i+pos] ;\\n        }\\n    }\\n\\n     for(let i=0; i<nums.length; i++){\\n        if(nums[i] === 0 && (i+k)<= nums.length){\\n            flip(i)\\n            count++\\n            }\\n     }\\n    \\n   return !nums.includes(0) ? count : -1;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3380470,
                "title": "python",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        flips = 0\\n        if nums[0] == 0:\\n            for i in range(k):\\n                nums[i] = 1 - nums[i]\\n            flips += 1\\n        \\n        diff = [abs(nums[i+1] - nums[i]) for i in range(n-1)]\\n\\n        for i in range(n-k):\\n            if diff[i] == 1:\\n                flips += 1\\n                \\n                if i < n-k-1:\\n                    diff[i+k] = 1- diff[i+k]\\n        \\n\\n        if 1 in diff[n-k:]:\\n            return -1\\n        return flips\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        flips = 0\\n        if nums[0] == 0:\\n            for i in range(k):\\n                nums[i] = 1 - nums[i]\\n            flips += 1\\n        \\n        diff = [abs(nums[i+1] - nums[i]) for i in range(n-1)]\\n\\n        for i in range(n-k):\\n            if diff[i] == 1:\\n                flips += 1\\n                \\n                if i < n-k-1:\\n                    diff[i+k] = 1- diff[i+k]\\n        \\n\\n        if 1 in diff[n-k:]:\\n            return -1\\n        return flips\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3357098,
                "title": "rust-fast-and-simple-15ms",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(k)$$ \\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn min_k_bit_flips(nums: Vec<i32>, k: i32) -> i32 {\\n        let k = k as usize; \\n        let n = nums.len(); \\n        let mut res = 0;\\n        let mut q = std::collections::VecDeque::with_capacity(k);\\n        for (i, v) in nums.iter().enumerate() {\\n            if let Some(&j) = q.front() { \\n                if j == i {\\n                    q.pop_front();\\n                }\\n            }\\n            if (v + q.len() as i32) & 1 == 0 {\\n                if i > n - k {\\n                    return -1\\n                } else {\\n                    q.push_back(i + k);\\n                    res += 1;\\n                }\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_k_bit_flips(nums: Vec<i32>, k: i32) -> i32 {\\n        let k = k as usize; \\n        let n = nums.len(); \\n        let mut res = 0;\\n        let mut q = std::collections::VecDeque::with_capacity(k);\\n        for (i, v) in nums.iter().enumerate() {\\n            if let Some(&j) = q.front() { \\n                if j == i {\\n                    q.pop_front();\\n                }\\n            }\\n            if (v + q.len() as i32) & 1 == 0 {\\n                if i > n - k {\\n                    return -1\\n                } else {\\n                    q.push_back(i + k);\\n                    res += 1;\\n                }\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3313761,
                "title": "python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n\\n        acc, toggle = [0] * len(nums), 0\\n\\n        for idx, num in enumerate(nums):\\n            \\n            if idx >= k: toggle ^= acc[idx -k]      # <-- toggle change-digit if we leave a flip interval\\n\\n            if toggle != num: continue              # <-- num is not a change digit\\n\\n            if k > len(nums)-idx: return -1         # <-- num is a change digit but we can\\'t flip anymore\\n\\n            toggle ^= 1                             # <-- num is a change-digit we can flip, so toggle\\n            acc[idx] = 1                            #     the change-digit and record it in acc.\\n\\n        return sum(acc)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n\\n        acc, toggle = [0] * len(nums), 0\\n\\n        for idx, num in enumerate(nums):\\n            \\n            if idx >= k: toggle ^= acc[idx -k]      # <-- toggle change-digit if we leave a flip interval\\n\\n            if toggle != num: continue              # <-- num is not a change digit\\n\\n            if k > len(nums)-idx: return -1         # <-- num is a change digit but we can\\'t flip anymore\\n\\n            toggle ^= 1                             # <-- num is a change-digit we can flip, so toggle\\n            acc[idx] = 1                            #     the change-digit and record it in acc.\\n\\n        return sum(acc)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3310574,
                "title": "easy-solution-for-a-hard-problem-simple-c-queue",
                "content": "0(N) : Solution\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        queue<int> q;\\n        const int n = nums.size();\\n        int cnt = 0;\\n        for(int i = 0; i < n; ++i) {\\n            int bit = nums[i];\\n            while(!q.empty() && q.front() < i) {\\n                q.pop();\\n            }\\n            if(q.size() % 2) {\\n                bit ^= 1;\\n            }\\n            if(!bit) {\\n                if(i + k - 1 >= n) {\\n                    return -1;\\n                }\\n                q.push(i + k - 1);\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        queue<int> q;\\n        const int n = nums.size();\\n        int cnt = 0;\\n        for(int i = 0; i < n; ++i) {\\n            int bit = nums[i];\\n            while(!q.empty() && q.front() < i) {\\n                q.pop();\\n            }\\n            if(q.size() % 2) {\\n                bit ^= 1;\\n            }\\n            if(!bit) {\\n                if(i + k - 1 >= n) {\\n                    return -1;\\n                }\\n                q.push(i + k - 1);\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3255409,
                "title": "javascript-995-minimum-number-of-k-consecutive-bit-flips",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n1\\n```\\nvar minKBitFlips = function (a, k) {\\n    function flip(a, s, e) {\\n        if (e >= a.length) {\\n            return false;\\n        }\\n        for (let i = s; i <= e; i++) {\\n            a[i] = 1 - a[i];\\n        }\\n        return true;\\n    }\\n\\n    let n = a.length;\\n    let cc = 0;\\n    for (let i = 0; i < n; i++) {\\n        if (a[i] === 0) {\\n            if (!flip(a, i, i + k - 1)) {\\n                return -1;\\n            }\\n            cc++;\\n        }\\n    }\\n    return cc;\\n};\\n```\\n\\n2\\n```\\nvar minKBitFlips = function (a, k) {\\n    let n = a.length;\\n    let cc = 0;\\n\\n    let q_prev_flip_end_idx = [];\\n    for (let i = 0; i < n; i++) {\\n        a[i] += q_prev_flip_end_idx.length;\\n        a[i] %= 2;\\n\\n        if (a[i] === 0) {\\n            cc += 1;\\n            q_prev_flip_end_idx.push(i + k - 1);\\n        }\\n        if (q_prev_flip_end_idx[0] === i) {\\n            q_prev_flip_end_idx.shift();\\n        }\\n    }\\n    if (q_prev_flip_end_idx.at(-1) >= n) {\\n        return -1;\\n    }\\n    return cc;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minKBitFlips = function (a, k) {\\n    function flip(a, s, e) {\\n        if (e >= a.length) {\\n            return false;\\n        }\\n        for (let i = s; i <= e; i++) {\\n            a[i] = 1 - a[i];\\n        }\\n        return true;\\n    }\\n\\n    let n = a.length;\\n    let cc = 0;\\n    for (let i = 0; i < n; i++) {\\n        if (a[i] === 0) {\\n            if (!flip(a, i, i + k - 1)) {\\n                return -1;\\n            }\\n            cc++;\\n        }\\n    }\\n    return cc;\\n};\\n```\n```\\nvar minKBitFlips = function (a, k) {\\n    let n = a.length;\\n    let cc = 0;\\n\\n    let q_prev_flip_end_idx = [];\\n    for (let i = 0; i < n; i++) {\\n        a[i] += q_prev_flip_end_idx.length;\\n        a[i] %= 2;\\n\\n        if (a[i] === 0) {\\n            cc += 1;\\n            q_prev_flip_end_idx.push(i + k - 1);\\n        }\\n        if (q_prev_flip_end_idx[0] === i) {\\n            q_prev_flip_end_idx.shift();\\n        }\\n    }\\n    if (q_prev_flip_end_idx.at(-1) >= n) {\\n        return -1;\\n    }\\n    return cc;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3245571,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        N=len(nums)\\n        if k==1:\\n            return nums.count(0)\\n        elif k==N:\\n            cnt=nums.count(1)\\n            if cnt==N:return 0\\n            if cnt==0:return 1\\n            return -1\\n        \\n        st=[0]*N\\n        for i in range(k-1):\\n            st[i]=nums[i]\\n        ret=one=0\\n        for i in range(N-k+1):\\n            K=i+k-1\\n            st[K]=nums[K]^one\\n            if not st[i]^one:\\n                ret+=1\\n                one^=1\\n        for i in range(N-k+1,N):\\n            if not st[i]^one:return -1\\n        return ret\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        N=len(nums)\\n        if k==1:\\n            return nums.count(0)\\n        elif k==N:\\n            cnt=nums.count(1)\\n            if cnt==N:return 0\\n            if cnt==0:return 1\\n            return -1\\n        \\n        st=[0]*N\\n        for i in range(k-1):\\n            st[i]=nums[i]\\n        ret=one=0\\n        for i in range(N-k+1):\\n            K=i+k-1\\n            st[K]=nums[K]^one\\n            if not st[i]^one:\\n                ret+=1\\n                one^=1\\n        for i in range(N-k+1,N):\\n            if not st[i]^one:return -1\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3201709,
                "title": "simulation-got-tle-so-i-redefined-what-is-one",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nInstead of toggling `k` elements every time, I chose to toggle `one` and set a reminder to untoggle it `k - 1` steps later.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGreedy \\xD7 { Simulation, Bit Manipulation + Toggling `one` }\\n\\n# Complexity\\n| | Gr + Sim | Gr + BitM + Tog |\\n|-|:-:|:-:|\\n|time|$$O((n-k)k)$$|$$O(n)$$|\\n|space|$$O(1)$$|$$O(1)$$|\\n\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nGreedy + Simulation\\n\\u26A0**TLE**\\u2757\\n```\\nclass Solution:\\n    def minKBitFlips(self, A: List[int], k: int) -> int:\\n        n = 0\\n        for i in range(len(A)-k):\\n            if A[i] == 0:\\n                n += 1\\n                for j in range(i, i+k):\\n                    A[j] ^= 1\\n        tail = sum(A[-k:])\\n        if tail == 0:\\n            return n + 1\\n        elif tail == k:\\n            return n\\n        return -1\\n```\\n\\n\\u2193 Greedy + Bit Manipulation + Toggling `one` \\u2193\\n```\\nclass Solution:\\n    def minKBitFlips(self, A: List[int], k: int) -> int:\\n        n = 0\\n        one = 1\\n\\n        t = k - 1\\n        for i in range(I := len(A)-t):\\n            if A[i]&1 != one:\\n                n += 1\\n                one ^= 1\\n                A[i+t] |= 2\\n            if A[i] & 2:\\n                one ^= 1\\n\\n        for i in range(I, len(A)):\\n            if A[i]&1 != one:\\n                return -1\\n            if A[i] & 2:\\n                one ^= 1\\n\\n        return n\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy",
                    "Bit Manipulation",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def minKBitFlips(self, A: List[int], k: int) -> int:\\n        n = 0\\n        for i in range(len(A)-k):\\n            if A[i] == 0:\\n                n += 1\\n                for j in range(i, i+k):\\n                    A[j] ^= 1\\n        tail = sum(A[-k:])\\n        if tail == 0:\\n            return n + 1\\n        elif tail == k:\\n            return n\\n        return -1\\n```\n```\\nclass Solution:\\n    def minKBitFlips(self, A: List[int], k: int) -> int:\\n        n = 0\\n        one = 1\\n\\n        t = k - 1\\n        for i in range(I := len(A)-t):\\n            if A[i]&1 != one:\\n                n += 1\\n                one ^= 1\\n                A[i+t] |= 2\\n            if A[i] & 2:\\n                one ^= 1\\n\\n        for i in range(I, len(A)):\\n            if A[i]&1 != one:\\n                return -1\\n            if A[i] & 2:\\n                one ^= 1\\n\\n        return n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3090153,
                "title": "c-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nflipping a 1 bit is waste of time start flipping where we first encounter 0 bit\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nmaintaining the no of flips on the current ind\\nmaintain queue to keep flip\\'s last index till their its effect is realised\\n if flips ona ind are odd we should find for 1 bit bcz that would get converted to 0 and vice versa for even no of flips\\nflips are not possible if its range goes out of n.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(k)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int j=0;\\n        int count=0;\\n        queue<int> q;\\n        while(j<nums.size()){\\n            \\n            while(q.size() && q.front()<j)  q.pop();\\n            if(q.size()%2==0 && nums[j]==0){\\n                if((j+k-1)>=nums.size()) return -1;\\n                q.push(j+k-1);\\n                count++;\\n            }\\n            else if(q.size()&1 && nums[j]){\\n                if((j+k-1)>=nums.size()) return -1;\\n                q.push((j+k-1));\\n                count++;\\n            }\\n            j++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int j=0;\\n        int count=0;\\n        queue<int> q;\\n        while(j<nums.size()){\\n            \\n            while(q.size() && q.front()<j)  q.pop();\\n            if(q.size()%2==0 && nums[j]==0){\\n                if((j+k-1)>=nums.size()) return -1;\\n                q.push(j+k-1);\\n                count++;\\n            }\\n            else if(q.size()&1 && nums[j]){\\n                if((j+k-1)>=nums.size()) return -1;\\n                q.push((j+k-1));\\n                count++;\\n            }\\n            j++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3055428,
                "title": "very-simple-using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minKBitFlips(int[] A, int K) {\\n        // use an count to check how many times current element has been fliped\\n        int out = 0, count=0;\\n        // use an boolean array to track till what array element you will flip\\n        boolean[] checkFlip = new boolean[A.length];\\n        for(int i=0; i<A.length; i++){\\n            // You need to flip only if A[i] == 0 and you haven\\u2019t fliped it or all the flips have been Canceled due even number of flips\\n            // You will also need to flip if you have fliped A[i]==1 odd number of times.\\n            if( (A[i]==0 && count%2==0) || (A[i]==1 && count%2!=0)){\\n                count++;\\n                out++;\\n                if(i+K-1>=A.length){\\n                    // You will return -1 as you encountered an element which needs flip but there aren\\'t enough elements to flip ahead and all the previous elements are 1.\\n                    return -1;\\n                }else{\\n                    // If you flip a current elements use checkFlip to keep track till which element current flip has effect.\\n                    checkFlip[i+K-1] = true;\\n                }\\n            }\\n            if(checkFlip[i]){\\n                // Decrement the count as you are passing a element till which certain flip was active\\n                count--;\\n            }\\n        }\\n        return out;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minKBitFlips(int[] A, int K) {\\n        // use an count to check how many times current element has been fliped\\n        int out = 0, count=0;\\n        // use an boolean array to track till what array element you will flip\\n        boolean[] checkFlip = new boolean[A.length];\\n        for(int i=0; i<A.length; i++){\\n            // You need to flip only if A[i] == 0 and you haven\\u2019t fliped it or all the flips have been Canceled due even number of flips\\n            // You will also need to flip if you have fliped A[i]==1 odd number of times.\\n            if( (A[i]==0 && count%2==0) || (A[i]==1 && count%2!=0)){\\n                count++;\\n                out++;\\n                if(i+K-1>=A.length){\\n                    // You will return -1 as you encountered an element which needs flip but there aren\\'t enough elements to flip ahead and all the previous elements are 1.\\n                    return -1;\\n                }else{\\n                    // If you flip a current elements use checkFlip to keep track till which element current flip has effect.\\n                    checkFlip[i+K-1] = true;\\n                }\\n            }\\n            if(checkFlip[i]){\\n                // Decrement the count as you are passing a element till which certain flip was active\\n                count--;\\n            }\\n        }\\n        return out;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3013769,
                "title": "c-very-easy-o-n-detailed-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int ans=0,n=nums.size(),cnt=0;\\n        queue<int>q; // for storing the index of element which is needed to flip so that we can count the flip in given window size i.e. k\\n        for(int i=0;i<n;i++){\\n            if(!q.empty() && i-q.front()>=k){  // if window length is greater than k\\n                q.pop();\\n                cnt--;\\n            }\\n            if((nums[i]+cnt)%2==0){  // checking the current value of nums[i] to make sure whether current element needs to flip or not\\n                if(n-i<k) return -1;  // if there is any element needs to flip but the remaining window size is less than k than it will not be possible to make all 1 so we will return -1\\n                 cnt++;\\n                 q.push(i);\\n                 ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int ans=0,n=nums.size(),cnt=0;\\n        queue<int>q; // for storing the index of element which is needed to flip so that we can count the flip in given window size i.e. k\\n        for(int i=0;i<n;i++){\\n            if(!q.empty() && i-q.front()>=k){  // if window length is greater than k\\n                q.pop();\\n                cnt--;\\n            }\\n            if((nums[i]+cnt)%2==0){  // checking the current value of nums[i] to make sure whether current element needs to flip or not\\n                if(n-i<k) return -1;  // if there is any element needs to flip but the remaining window size is less than k than it will not be possible to make all 1 so we will return -1\\n                 cnt++;\\n                 q.push(i);\\n                 ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3002923,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn min_k_bit_flips(nums: Vec<i32>, k: i32) -> i32 {\\n        let mut nums = nums;\\n        let k = k as usize;\\n        let mut cur = 0;\\n        let mut res = 0;\\n        let n = nums.len();\\n\\n        for i in 0..n {\\n            if i >= k && nums[i - k] > 1 {\\n                cur -= 1;\\n                nums[i - k] -= 2;\\n            }\\n            if cur % 2 == nums[i] as usize {\\n                if i + k > n {\\n                    return -1;\\n                }\\n                nums[i] += 2;\\n                cur += 1;\\n                res += 1;\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_k_bit_flips(nums: Vec<i32>, k: i32) -> i32 {\\n        let mut nums = nums;\\n        let k = k as usize;\\n        let mut cur = 0;\\n        let mut res = 0;\\n        let n = nums.len();\\n\\n        for i in 0..n {\\n            if i >= k && nums[i - k] > 1 {\\n                cur -= 1;\\n                nums[i - k] -= 2;\\n            }\\n            if cur % 2 == nums[i] as usize {\\n                if i + k > n {\\n                    return -1;\\n                }\\n                nums[i] += 2;\\n                cur += 1;\\n                res += 1;\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2969460,
                "title": "python3-concise-solution-beats-99",
                "content": "# Code\\n```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        ans = flip = 0 \\n        queue = deque()\\n        for i, x in enumerate(nums):\\n            if queue and i == queue[0]: \\n                flip ^= 1\\n                queue.popleft()\\n            if x == flip: \\n                if len(nums) - i < k: return -1\\n                ans += 1\\n                flip ^= 1\\n                queue.append(i+k)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        ans = flip = 0 \\n        queue = deque()\\n        for i, x in enumerate(nums):\\n            if queue and i == queue[0]: \\n                flip ^= 1\\n                queue.popleft()\\n            if x == flip: \\n                if len(nums) - i < k: return -1\\n                ans += 1\\n                flip ^= 1\\n                queue.append(i+k)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2957312,
                "title": "segment-tree-to-count-intervals",
                "content": "```\\nclass Node:\\n    def __init__(self, start, end, sum = 0):\\n        self.start = start\\n        self.end = end\\n        self.left = None\\n        self.right = None\\n        self.sum = sum\\n\\nclass SegTree:\\n    def __init__(self, nums):\\n        n = len(nums)\\n        self.start = 0\\n        self.end = n - 1\\n        self.root = self.createTree(0, n - 1, nums)\\n        \\n    def createTree(self, start, end, nums):\\n        if start > end:\\n            return None\\n        root = Node(start, end)\\n        if start == end:\\n            root.sum = nums[start]\\n            return root\\n        mid = (start + end) // 2\\n        root.left = self.createTree(start, mid, nums)\\n        root.right = self.createTree(mid + 1, end, nums)\\n        root.sum = root.left.sum + root.right.sum\\n        return root\\n    \\n    def _update(self, root, start, end, i, val):\\n        if not root:\\n            return\\n        if start == end:\\n            root.sum += val\\n            return\\n        mid = (start + end) // 2\\n        if i <= mid:\\n            self._update(root.left, start, mid, i, val)\\n        else:\\n            self._update(root.right, mid + 1, end, i, val)\\n        root.sum = root.left.sum + root.right.sum\\n    \\n    def update(self, index, val):\\n        self._update(self.root, self.start, self.end, index, val)\\n    \\n    def _sumRange(self, root, start, end):\\n        if not root:\\n            return 0\\n        if root.start == start and root.end == end:\\n            return root.sum\\n        mid = (root.start + root.end) // 2\\n        if end <= mid:\\n            return self._sumRange(root.left, start, end)\\n        elif start >= mid + 1:\\n            return self._sumRange(root.right, start, end)\\n        else:\\n            return self._sumRange(root.left, start, mid) + self._sumRange(root.right, mid + 1, end)\\n    \\n    def sumRange(self, left, right):\\n        return self._sumRange(self.root, left, right)\\n\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        res = 0\\n        segtree = SegTree([0] * (n + 1))\\n        for i in range(n - k + 1):\\n            curr = nums[i]\\n            if segtree.sumRange(0, i) % 2 == 1:\\n                curr = 1 - curr\\n            if curr == 0:\\n                res += 1\\n                segtree.update(i, 1)\\n                segtree.update(min(i + k, n), -1)\\n        for i in range(n - k + 1, n):\\n            curr = nums[i]\\n            if segtree.sumRange(0, i) % 2 == 1:\\n                curr = 1 - curr\\n            if curr == 0:\\n                return -1\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Node:\\n    def __init__(self, start, end, sum = 0):\\n        self.start = start\\n        self.end = end\\n        self.left = None\\n        self.right = None\\n        self.sum = sum\\n\\nclass SegTree:\\n    def __init__(self, nums):\\n        n = len(nums)\\n        self.start = 0\\n        self.end = n - 1\\n        self.root = self.createTree(0, n - 1, nums)\\n        \\n    def createTree(self, start, end, nums):\\n        if start > end:\\n            return None\\n        root = Node(start, end)\\n        if start == end:\\n            root.sum = nums[start]\\n            return root\\n        mid = (start + end) // 2\\n        root.left = self.createTree(start, mid, nums)\\n        root.right = self.createTree(mid + 1, end, nums)\\n        root.sum = root.left.sum + root.right.sum\\n        return root\\n    \\n    def _update(self, root, start, end, i, val):\\n        if not root:\\n            return\\n        if start == end:\\n            root.sum += val\\n            return\\n        mid = (start + end) // 2\\n        if i <= mid:\\n            self._update(root.left, start, mid, i, val)\\n        else:\\n            self._update(root.right, mid + 1, end, i, val)\\n        root.sum = root.left.sum + root.right.sum\\n    \\n    def update(self, index, val):\\n        self._update(self.root, self.start, self.end, index, val)\\n    \\n    def _sumRange(self, root, start, end):\\n        if not root:\\n            return 0\\n        if root.start == start and root.end == end:\\n            return root.sum\\n        mid = (root.start + root.end) // 2\\n        if end <= mid:\\n            return self._sumRange(root.left, start, end)\\n        elif start >= mid + 1:\\n            return self._sumRange(root.right, start, end)\\n        else:\\n            return self._sumRange(root.left, start, mid) + self._sumRange(root.right, mid + 1, end)\\n    \\n    def sumRange(self, left, right):\\n        return self._sumRange(self.root, left, right)\\n\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        res = 0\\n        segtree = SegTree([0] * (n + 1))\\n        for i in range(n - k + 1):\\n            curr = nums[i]\\n            if segtree.sumRange(0, i) % 2 == 1:\\n                curr = 1 - curr\\n            if curr == 0:\\n                res += 1\\n                segtree.update(i, 1)\\n                segtree.update(min(i + k, n), -1)\\n        for i in range(n - k + 1, n):\\n            curr = nums[i]\\n            if segtree.sumRange(0, i) % 2 == 1:\\n                curr = 1 - curr\\n            if curr == 0:\\n                return -1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2910357,
                "title": "c-greedy-o-n-using-queue-to-manage-flip-history",
                "content": "# Intuition\\nThis solution relies on 2 important observations:\\n* The order of operation does not matter, e.g flip $[1,5] \\\\rightarrow [3,10]$ is equivalent to $[3,10] \\\\rightarrow [1,5]$\\n  * So, when we found a $0$ at $i$, we should flip the range $[i,i+k-1]$ because sooner or later we will have to do it anyway\\n* Given range $[0,i]$ that already in good state (i.e $A[0,i] = [1,1,1,1...1]$) we should not modify $[0,i]$\\n  * Because if we modify an item that already is $1$, we have to make another move to make it $0$, at best it would be a waste of time, at worst it would ruin the good result on the right\\n\\n\\n# Approach\\n* Move from left to right, as soon as we see a $0$, we flip\\n* To avoid looping to update the range $[i,i+k-1]$, we maintain a queue to track how many flip we have made that affect current element so far. If the flip count is even, the value stay the same, if odd the value has to be flipped\\n\\n# Complexity\\n- Time complexity:\\n$O(n)$ to travel through array once\\n\\n- Space complexity:\\n$O(n)$ to maintain a queue\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int flipCount = 0;\\n        queue<int> flipHistory;\\n        for(int i = 0;i<n;i++) {\\n            bool v = nums[i];\\n            if(!flipHistory.empty() && flipHistory.front() < i) {\\n                flipHistory.pop();\\n            }\\n            if(flipHistory.size()%2) {\\n                v = !v;\\n            }\\n            bool shouldFlip = v == 0;\\n            bool canFlip = i+k-1 < n;\\n            if(!shouldFlip) {\\n                continue;\\n            }\\n            if(!canFlip) {\\n                return -1;\\n            }\\n            flipCount++;\\n            flipHistory.push(i+k-1);\\n        }\\n        return flipCount;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int flipCount = 0;\\n        queue<int> flipHistory;\\n        for(int i = 0;i<n;i++) {\\n            bool v = nums[i];\\n            if(!flipHistory.empty() && flipHistory.front() < i) {\\n                flipHistory.pop();\\n            }\\n            if(flipHistory.size()%2) {\\n                v = !v;\\n            }\\n            bool shouldFlip = v == 0;\\n            bool canFlip = i+k-1 < n;\\n            if(!shouldFlip) {\\n                continue;\\n            }\\n            if(!canFlip) {\\n                return -1;\\n            }\\n            flipCount++;\\n            flipHistory.push(i+k-1);\\n        }\\n        return flipCount;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2896763,
                "title": "python-o-n-solution-easy-to-follow",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        queue, res = deque(), 0\\n        for idx in range(len(nums)):\\n            if len(queue) % 2:\\n                if nums[idx] == 1:\\n                    res += 1\\n                    queue.append(idx + k - 1)\\n            else:\\n                if nums[idx] == 0:\\n                    res += 1\\n                    queue.append(idx + k - 1)\\n            if queue and queue[0] == idx: \\n                queue.popleft()\\n            if queue and queue[-1] >= len(nums): \\n                return -1\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Queue",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        queue, res = deque(), 0\\n        for idx in range(len(nums)):\\n            if len(queue) % 2:\\n                if nums[idx] == 1:\\n                    res += 1\\n                    queue.append(idx + k - 1)\\n            else:\\n                if nums[idx] == 0:\\n                    res += 1\\n                    queue.append(idx + k - 1)\\n            if queue and queue[0] == idx: \\n                queue.popleft()\\n            if queue and queue[-1] >= len(nums): \\n                return -1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875792,
                "title": "easy-c-o-n-solution-o-n-space-commented-92-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> flips(n,0);\\n        //represents curr flips for a index i\\n        int curr=0;\\n        int res=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            int val=nums[i];\\n            curr+=flips[i];\\n            if(curr%2)\\n            {\\n                //flip \\n                val=(val==0) ?  1 : 0;\\n            }\\n            if(val==0)\\n            {\\n                //we need a flip of sub array size k\\n                if(i-k+1<0)\\n                {\\n                    //we dont have subarray of size k\\n                    return -1;\\n                }\\n                //we dont want to flip the values <= i-k\\n                if(i-k>=0)\\n                    flips[i-k]-=1;\\n                curr++;\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> flips(n,0);\\n        //represents curr flips for a index i\\n        int curr=0;\\n        int res=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            int val=nums[i];\\n            curr+=flips[i];\\n            if(curr%2)\\n            {\\n                //flip \\n                val=(val==0) ?  1 : 0;\\n            }\\n            if(val==0)\\n            {\\n                //we need a flip of sub array size k\\n                if(i-k+1<0)\\n                {\\n                    //we dont have subarray of size k\\n                    return -1;\\n                }\\n                //we dont want to flip the values <= i-k\\n                if(i-k>=0)\\n                    flips[i-k]-=1;\\n                curr++;\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2860445,
                "title": "python-sliding-window-solution-o-n-time-o-1-space",
                "content": "```\\ndef minKBitFlips(self, nums: List[int], k: int) -> int:\\n\\tcur, count = 0, 0 \\n\\t# cur means the number of flip IN the window BEGINNING at index i\\n\\tfor i in range(len(nums)):            \\n\\t\\tif cur%2==nums[i]%2:\\n\\t\\t\\tif i+k>len(nums):\\n\\t\\t\\t\\treturn -1\\n\\t\\t\\tcur += 1\\n\\t\\t\\tcount += 1\\n\\t\\t\\tnums[i+k-1] += 2\\n\\t\\tif nums[i]>1:\\n\\t\\t\\tcur -= 1\\n\\t\\t# nums[i] > 1 means the beginning element has been flipped, so we need to decrement \\'cur\\'\\n\\treturn count\\n```",
                "solutionTags": [],
                "code": "```\\ndef minKBitFlips(self, nums: List[int], k: int) -> int:\\n\\tcur, count = 0, 0 \\n\\t# cur means the number of flip IN the window BEGINNING at index i\\n\\tfor i in range(len(nums)):            \\n\\t\\tif cur%2==nums[i]%2:\\n\\t\\t\\tif i+k>len(nums):\\n\\t\\t\\t\\treturn -1\\n\\t\\t\\tcur += 1\\n\\t\\t\\tcount += 1\\n\\t\\t\\tnums[i+k-1] += 2\\n\\t\\tif nums[i]>1:\\n\\t\\t\\tcur -= 1\\n\\t\\t# nums[i] > 1 means the beginning element has been flipped, so we need to decrement \\'cur\\'\\n\\treturn count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2855808,
                "title": "c-dp-easy-implemention",
                "content": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& A, int k) {\\n        // queue<int> q;\\n        int n=A.size();\\n        vector<int> dp(n,0);\\n        int flip=0;\\n        int start=0;\\n        int ans=0;\\n        for(int i=0;i<A.size();i++){\\n            \\n            \\n            if((A[i]-flip)==0){\\n                // cout<<i<<\" \"<<flip<<\" \"<<ans<<\"\\\\n\";\\n                if(i+k-1>=n){\\n                    return -1;\\n                }\\n                dp[i+k-1]++;\\n                flip=1-flip;\\n                ans++;\\n            }\\n            if(dp[i]){\\n                flip=1-flip;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& A, int k) {\\n        // queue<int> q;\\n        int n=A.size();\\n        vector<int> dp(n,0);\\n        int flip=0;\\n        int start=0;\\n        int ans=0;\\n        for(int i=0;i<A.size();i++){\\n            \\n            \\n            if((A[i]-flip)==0){\\n                // cout<<i<<\" \"<<flip<<\" \"<<ans<<\"\\\\n\";\\n                if(i+k-1>=n){\\n                    return -1;\\n                }\\n                dp[i+k-1]++;\\n                flip=1-flip;\\n                ans++;\\n            }\\n            if(dp[i]){\\n                flip=1-flip;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2800054,
                "title": "java-o-n-time-and-space-complexity-code-with-explanation",
                "content": "# Code\\n\\n```\\n    // TLE, O (n^2)\\n    public int minKBitFlips(int[] nums, int k) {\\n        if (k > nums.length) return -1;\\n\\n        int count = 0;\\n        for (int i=0; i<nums.length; i++) {\\n            if (nums[i] == 0) {\\n                if (i+k > nums.length) return -1;\\n\\n                count++;\\n                flipNextK(nums, i, k); \\n                // this is problem, we need to update next k elements every time.\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    private void flipNextK(int[] nums, int index, int k) {\\n        for (int i=index; i<index+k; i++) {\\n            nums[i] = nums[i] ^ 1;\\n        }\\n    }\\n```\\n\\n```\\n    // Same algorithm as above, but optimized.\\n    public int minKBitFlips(int[] nums, int k) {\\n        if (k > nums.length) return -1;\\n\\n        int count = 0;\\n\\n        // instead of updating next queue elements, we can add last index of flip int this queue.\\n        Queue<Integer> flipQueue = new LinkedList<>();\\n\\n        for (int i=0; i<nums.length; i++) {\\n            // queue size is even, num[i] remains same\\n            // queue size is odd, num[i] changes.\\n            if ((flipQueue.size() & 1) != 0) {\\n                nums[i] = nums[i] ^ 1;\\n            }\\n\\n            if (nums[i] == 0) {\\n                if (i+k > nums.length) return -1;\\n\\n                count++;\\n                flipQueue.add(i+k-1);\\n            }\\n\\n            if (!flipQueue.isEmpty() && flipQueue.peek() == i) flipQueue.poll();\\n        }\\n\\n        return count;\\n    }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\n    // TLE, O (n^2)\\n    public int minKBitFlips(int[] nums, int k) {\\n        if (k > nums.length) return -1;\\n\\n        int count = 0;\\n        for (int i=0; i<nums.length; i++) {\\n            if (nums[i] == 0) {\\n                if (i+k > nums.length) return -1;\\n\\n                count++;\\n                flipNextK(nums, i, k); \\n                // this is problem, we need to update next k elements every time.\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    private void flipNextK(int[] nums, int index, int k) {\\n        for (int i=index; i<index+k; i++) {\\n            nums[i] = nums[i] ^ 1;\\n        }\\n    }\\n```\n```\\n    // Same algorithm as above, but optimized.\\n    public int minKBitFlips(int[] nums, int k) {\\n        if (k > nums.length) return -1;\\n\\n        int count = 0;\\n\\n        // instead of updating next queue elements, we can add last index of flip int this queue.\\n        Queue<Integer> flipQueue = new LinkedList<>();\\n\\n        for (int i=0; i<nums.length; i++) {\\n            // queue size is even, num[i] remains same\\n            // queue size is odd, num[i] changes.\\n            if ((flipQueue.size() & 1) != 0) {\\n                nums[i] = nums[i] ^ 1;\\n            }\\n\\n            if (nums[i] == 0) {\\n                if (i+k > nums.length) return -1;\\n\\n                count++;\\n                flipQueue.add(i+k-1);\\n            }\\n\\n            if (!flipQueue.isEmpty() && flipQueue.peek() == i) flipQueue.poll();\\n        }\\n\\n        return count;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2775933,
                "title": "java-very-easy-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    public int minKBitFlips(int[] nums, int k) {\\n        final int n = nums.length;\\n        int[] promises = new int[n + 1];\\n        int flip = 0, res = 0;\\n        for(int i = 0; i < n; i++){\\n            flip += promises[i];\\n            int actual = flip % 2 == 1 ? 1 - nums[i] : nums[i];\\n            if(i <= n - k){\\n                if(actual == 1) continue;\\n                flip++;\\n                promises[i + k]--;\\n                res++;\\n            }\\n            else{\\n                if(actual == 0) return -1;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n// Idea:->\\n// ----\\n// 1. Starting from the left\\n// 2. if the current index element is 1 then we don\\'t do anything\\n// 3. else if it\\'s a 0, then flip all the k elements from that position\\n// 4. repeat the above from 0 to nums.length - K.\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int minKBitFlips(int[] nums, int k) {\\n        final int n = nums.length;\\n        int[] promises = new int[n + 1];\\n        int flip = 0, res = 0;\\n        for(int i = 0; i < n; i++){\\n            flip += promises[i];\\n            int actual = flip % 2 == 1 ? 1 - nums[i] : nums[i];\\n            if(i <= n - k){\\n                if(actual == 1) continue;\\n                flip++;\\n                promises[i + k]--;\\n                res++;\\n            }\\n            else{\\n                if(actual == 0) return -1;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n// Idea:->\\n// ----\\n// 1. Starting from the left\\n// 2. if the current index element is 1 then we don\\'t do anything\\n// 3. else if it\\'s a 0, then flip all the k elements from that position\\n// 4. repeat the above from 0 to nums.length - K.\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2757750,
                "title": "c",
                "content": "Runtime: 153 ms, faster than 100.00% of C online submissions for Minimum Number of K Consecutive Bit Flips.\\nMemory Usage: 18 MB, less than 40.00% of C online submissions for Minimum Number of K Consecutive Bit Flips.\\n```\\nint minKBitFlips(int* nums, int numsSize, int k){\\n    int ans = 0;\\n    int n = numsSize;\\n    //head and tail keep k position for overflow\\n    int* dp  = calloc( (n+2*k), sizeof(int));\\n    for(int i = 0 ; i < n; i++){\\n        dp[i+k] = dp[i+k] + dp[i+k-1];\\n        if(nums[i] == 0 && dp[i+k] % 2 == 0){\\n            if((n-i) < k)\\n                return -1;\\n            ans++;\\n            dp[i+k]++;\\n            dp[i+k+k]--;\\n        }\\n        else if(nums[i] == 1 && dp[i+k]%2 == 1){\\n            if((n-i) < k)\\n                return -1;\\n            ans++;\\n            dp[i+k]++;\\n            dp[i+k+k]--;\\n        }\\n    }\\n\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nint minKBitFlips(int* nums, int numsSize, int k){\\n    int ans = 0;\\n    int n = numsSize;\\n    //head and tail keep k position for overflow\\n    int* dp  = calloc( (n+2*k), sizeof(int));\\n    for(int i = 0 ; i < n; i++){\\n        dp[i+k] = dp[i+k] + dp[i+k-1];\\n        if(nums[i] == 0 && dp[i+k] % 2 == 0){\\n            if((n-i) < k)\\n                return -1;\\n            ans++;\\n            dp[i+k]++;\\n            dp[i+k+k]--;\\n        }\\n        else if(nums[i] == 1 && dp[i+k]%2 == 1){\\n            if((n-i) < k)\\n                return -1;\\n            ans++;\\n            dp[i+k]++;\\n            dp[i+k+k]--;\\n        }\\n    }\\n\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2745741,
                "title": "o-n-soln-using-queue-and-sliding-window",
                "content": "```\\nclass Solution {\\n    public int minKBitFlips(int[] nums, int k) {\\n        int n = nums.length;\\n        Queue<Integer> queue = new LinkedList<>();\\n        int noFlips = 0;\\n        for(int i = 0 ; i < n ; ++i){\\n            if(!queue.isEmpty() && queue.peek() <= i-k){\\n                queue.poll();\\n            }\\n            int val =  nums[i];\\n            int size = ((queue.size() & 1) == 0 ? 0 : 1);\\n            //If flip is required we add it to queue\\n            if((val ^ size) == 0){\\n                queue.add(i);\\n                noFlips++;\\n            }\\n            //If bit is outside the last window and it required a flip\\n            if(i >= n-k+1 && ((val^size) == 0)){\\n                return -1;\\n            }\\n        }\\n        return noFlips;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Queue",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int minKBitFlips(int[] nums, int k) {\\n        int n = nums.length;\\n        Queue<Integer> queue = new LinkedList<>();\\n        int noFlips = 0;\\n        for(int i = 0 ; i < n ; ++i){\\n            if(!queue.isEmpty() && queue.peek() <= i-k){\\n                queue.poll();\\n            }\\n            int val =  nums[i];\\n            int size = ((queue.size() & 1) == 0 ? 0 : 1);\\n            //If flip is required we add it to queue\\n            if((val ^ size) == 0){\\n                queue.add(i);\\n                noFlips++;\\n            }\\n            //If bit is outside the last window and it required a flip\\n            if(i >= n-k+1 && ((val^size) == 0)){\\n                return -1;\\n            }\\n        }\\n        return noFlips;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2709492,
                "title": "go-golang-java-python-o-n-time-o-1-space",
                "content": "```\\nfunc minKBitFlips(nums []int, k int) int {\\n    // how many time we should flip current number\\n    c := 0\\n    // overall flips\\n    res := 0\\n    \\n    for i := range nums {\\n        if (nums[i]  + c) % 2 != 1{\\n            c++\\n            res++\\n            // if we have to flip invalid index return -1\\n            if i + k  > len(nums){\\n                return -1\\n            }\\n            // store in num end of flip row[it can be 2 or 3]\\n            nums[i + k - 1] += 2\\n        }\\n        if nums[i] >1 {\\n            c--\\n        }\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc minKBitFlips(nums []int, k int) int {\\n    // how many time we should flip current number\\n    c := 0\\n    // overall flips\\n    res := 0\\n    \\n    for i := range nums {\\n        if (nums[i]  + c) % 2 != 1{\\n            c++\\n            res++\\n            // if we have to flip invalid index return -1\\n            if i + k  > len(nums){\\n                return -1\\n            }\\n            // store in num end of flip row[it can be 2 or 3]\\n            nums[i + k - 1] += 2\\n        }\\n        if nums[i] >1 {\\n            c--\\n        }\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2690739,
                "title": "c-one-pass-in-o-n-time-complexity",
                "content": "# Please Upvote if Usefull.\\n\\n**Intution**\\n\\n* **Idea is to keep track of the indexes on which flips have been made. And this is done with the help of queue data structure.**\\n\\n* **Whenever coming on a ith index pop all the indexes which cannot flip the ith index i.e. indexes<=i-k and now the current nums[i] will be equal to the original value if size of queue is even, otherwise gets flipped.** \\n\\n* **Now if Size of queue %2 is   is Same as a[i]**\\n\\t*  sz=size of Queue ,       sz%2 == a[i]    then we need to Flip.\\n```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& a, int k) {\\n        \\n        int n=a.size();\\n        queue<int>q;\\n        int ans=0;\\n        \\n        for(int i=0;i<n;i++){\\n           while(!q.empty() && q.front()<=i-k) q.pop();\\n            \\n            if( q.size()%2 == a[i]%2){\\n                ans++;\\n                if(i+k<=n) q.push(i);\\n                else return -1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& a, int k) {\\n        \\n        int n=a.size();\\n        queue<int>q;\\n        int ans=0;\\n        \\n        for(int i=0;i<n;i++){\\n           while(!q.empty() && q.front()<=i-k) q.pop();\\n            \\n            if( q.size()%2 == a[i]%2){\\n                ans++;\\n                if(i+k<=n) q.push(i);\\n                else return -1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2666477,
                "title": "c",
                "content": "(```)  class Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n      \\n        int n = nums.size();\\n        \\n        vector<int> pointer(n+1,0);\\n        \\n        int flips = 0, ans = 0;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            flips += pointer[i];\\n            \\n            if(nums[i] == 1 && (flips % 2)== 0)\\n            {\\n                continue;\\n            }\\n            \\n            if(nums[i] == 0 && (flips % 2 == 1))\\n            {\\n                continue;\\n            }\\n            \\n            if(i+k > n)\\n            {\\n                return -1;\\n            }\\n            \\n            ans++;\\n            \\n            flips++;\\n            \\n            pointer[i+k] = -1;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n      \\n        int n = nums.size();\\n        \\n        vector<int> pointer(n+1,0);\\n        \\n        int flips = 0, ans = 0;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            flips += pointer[i];\\n            \\n            if(nums[i] == 1 && (flips % 2)== 0)\\n            {\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2626012,
                "title": "minimum-number-of-k-consecutive-bit-flips-solution-java",
                "content": "class Solution {\\n  public int minKBitFlips(int[] A, int K) {\\n    int ans = 0;\\n    int flippedTime = 0;\\n\\n    for (int r = 0; r < A.length; ++r) {\\n      if (r >= K && A[r - K] == 2)\\n        --flippedTime;\\n      if (flippedTime % 2 == A[r]) {\\n        if (r + K > A.length)\\n          return -1;\\n        ++ans;\\n        ++flippedTime;\\n        A[r] = 2;\\n      }\\n    }\\n\\n    return ans;\\n  }\\n}\\n",
                "solutionTags": [
                    "Array",
                    "Bit Manipulation",
                    "Queue",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n  public int minKBitFlips(int[] A, int K) {\\n    int ans = 0;\\n    int flippedTime = 0;\\n\\n    for (int r = 0; r < A.length; ++r) {\\n      if (r >= K && A[r - K] == 2)\\n        --flippedTime;\\n      if (flippedTime % 2 == A[r]) {\\n        if (r + K > A.length)\\n          return -1;\\n        ++ans;\\n        ++flippedTime;\\n        A[r] = 2;\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 2568791,
                "title": "java-clean-soln-using-constant-space",
                "content": "```\\nclass Solution {\\n    public int minKBitFlips(int[] nums, int k) {\\n        int n = nums.length;\\n        int noFlips = 0;\\n        int spanCnt = 0;\\n        for(int i = 0 ; i < n ; ++i){\\n\\t\\t   / /Removal from old window\\n            if(i-k>=0 && nums[i-k] == 2){\\n                spanCnt ^= 1;\\n            }\\n            int val =  nums[i];\\n            int size = spanCnt;\\n            //If flip is required we add it to queue\\n            if((val ^ size) == 0){\\n                nums[i] = 2;\\n                spanCnt ^= 1;\\n                noFlips++;\\n            }\\n            //If bit is outside the last window and it required a flip\\n            if(i >= n-k+1 && ((val^size) == 0)){\\n                return -1;\\n            }\\n        }\\n        return noFlips;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int minKBitFlips(int[] nums, int k) {\\n        int n = nums.length;\\n        int noFlips = 0;\\n        int spanCnt = 0;\\n        for(int i = 0 ; i < n ; ++i){\\n\\t\\t   / /Removal from old window\\n            if(i-k>=0 && nums[i-k] == 2){\\n                spanCnt ^= 1;\\n            }\\n            int val =  nums[i];\\n            int size = spanCnt;\\n            //If flip is required we add it to queue\\n            if((val ^ size) == 0){\\n                nums[i] = 2;\\n                spanCnt ^= 1;\\n                noFlips++;\\n            }\\n            //If bit is outside the last window and it required a flip\\n            if(i >= n-k+1 && ((val^size) == 0)){\\n                return -1;\\n            }\\n        }\\n        return noFlips;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2552770,
                "title": "c-using-greedy-sliding-window",
                "content": "\\n\\n    int TOGGLE(int k, bool t)\\n    {\\n        if(!t) return k;\\n        return k == 0 ? 1 : 0;\\n    }\\n    \\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int ans = 0, n = nums.size(); \\n        bool toggle = false;\\n        vector<bool> T(n+1, false);\\n        \\n        for(int i=0; i<=n-k; i++)\\n        {\\n            if(T[i] == true) toggle = !toggle;\\n            if(TOGGLE(nums[i], toggle) == 1) continue;\\n            else\\n            {\\n                ans++;\\n                toggle = !toggle;\\n                T[i+k] = true;\\n            }\\n        }\\n        \\n        for(int i=n-k+1; i<n; i++)\\n        {\\n            if(T[i] == true) toggle = !toggle;\\n            if(TOGGLE(nums[i], toggle) == 1) continue;\\n            else return -1;\\n        }\\n        return ans;\\n    }\\n",
                "solutionTags": [
                    "Greedy",
                    "Sliding Window"
                ],
                "code": "\\n\\n    int TOGGLE(int k, bool t)\\n    {\\n        if(!t) return k;\\n        return k == 0 ? 1 : 0;\\n    }\\n    \\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int ans = 0, n = nums.size(); \\n        bool toggle = false;\\n        vector<bool> T(n+1, false);\\n        \\n        for(int i=0; i<=n-k; i++)\\n        {\\n            if(T[i] == true) toggle = !toggle;\\n            if(TOGGLE(nums[i], toggle) == 1) continue;\\n            else\\n            {\\n                ans++;\\n                toggle = !toggle;\\n                T[i+k] = true;\\n            }\\n        }\\n        \\n        for(int i=n-k+1; i<n; i++)\\n        {\\n            if(T[i] == true) toggle = !toggle;\\n            if(TOGGLE(nums[i], toggle) == 1) continue;\\n            else return -1;\\n        }\\n        return ans;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2537527,
                "title": "python-clean-sliding-window-o-1-space",
                "content": "```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        # Total number of flips\\n        res = 0\\n        # Total times the iteration index has been flipped\\n        flippedCount = 0\\n\\n        for i, num in enumerate(nums):\\n          # Decrement flipped count for the current index when previous flips \\n          # are outside of the window\\n          if i >= k and nums[i - k] > 1:\\n            nums[i - k] -= 2\\n            flippedCount -= 1\\n          \\n          # An even flipped count means that after all the previous flips, if \\n          # any, the current number is now 0, which needs to be flipped\\n          if flippedCount % 2 == num:\\n            # K-bit flip is not possible if additional bits need to be flipped \\n            # at the end of all valid window flips\\n            if i > len(nums) - k:\\n              return -1\\n\\n            # Flip the current number and increment flipped count\\n            nums[i] += 2\\n            flippedCount += 1\\n            res += 1\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        # Total number of flips\\n        res = 0\\n        # Total times the iteration index has been flipped\\n        flippedCount = 0\\n\\n        for i, num in enumerate(nums):\\n          # Decrement flipped count for the current index when previous flips \\n          # are outside of the window\\n          if i >= k and nums[i - k] > 1:\\n            nums[i - k] -= 2\\n            flippedCount -= 1\\n          \\n          # An even flipped count means that after all the previous flips, if \\n          # any, the current number is now 0, which needs to be flipped\\n          if flippedCount % 2 == num:\\n            # K-bit flip is not possible if additional bits need to be flipped \\n            # at the end of all valid window flips\\n            if i > len(nums) - k:\\n              return -1\\n\\n            # Flip the current number and increment flipped count\\n            nums[i] += 2\\n            flippedCount += 1\\n            res += 1\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2522013,
                "title": "simple-clean-solution",
                "content": "```\\nclass Solution {\\n    typedef long long ll;\\npublic:\\n    int minKBitFlips(vector<int>& v, int k) {\\n        map<ll, ll>mp;\\n        ll res = 0, sz = v.size(), ts = 1; // TimeStamp\\n        for (ll i = 0;i <= sz - k;++i) {\\n            bool flip = 0;\\n            auto it = mp.lower_bound(i);\\n            if (it != mp.end()) {\\n                flip = (mp.rbegin()->second - it->second + 1) & 1; // if odd no. of changes commited\\n            }\\n            if (flip) {\\n                v[i] = !v[i];\\n            }\\n            if (v[i] == 0) {\\n                ++res;\\n                mp[i + k - 1] = ts++; // diff of two timestamps gives the no. of changes commited to a particular index\\n            }\\n        }\\n\\t\\tin last sz-k indices, no k size subarray can be formed. So they must already be all zero in final form now, that is if there does exist a solution.\\n        for (ll i = sz - k + 1;i < sz;++i) {\\n            bool flip = 0;\\n            auto it = mp.lower_bound(i);\\n            if (it != mp.end()) {\\n                flip = (mp.rbegin()->second - it->second + 1) & 1;\\n            }\\n            if (flip) {\\n                v[i] = !v[i];\\n            }\\n\\t\\t\\t// brought to the actual state\\n            if (v[i] == 0) {\\n                return -1; //  here goes nothing m.f.\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    typedef long long ll;\\npublic:\\n    int minKBitFlips(vector<int>& v, int k) {\\n        map<ll, ll>mp;\\n        ll res = 0, sz = v.size(), ts = 1; // TimeStamp\\n        for (ll i = 0;i <= sz - k;++i) {\\n            bool flip = 0;\\n            auto it = mp.lower_bound(i);\\n            if (it != mp.end()) {\\n                flip = (mp.rbegin()->second - it->second + 1) & 1; // if odd no. of changes commited\\n            }\\n            if (flip) {\\n                v[i] = !v[i];\\n            }\\n            if (v[i] == 0) {\\n                ++res;\\n                mp[i + k - 1] = ts++; // diff of two timestamps gives the no. of changes commited to a particular index\\n            }\\n        }\\n\\t\\tin last sz-k indices, no k size subarray can be formed. So they must already be all zero in final form now, that is if there does exist a solution.\\n        for (ll i = sz - k + 1;i < sz;++i) {\\n            bool flip = 0;\\n            auto it = mp.lower_bound(i);\\n            if (it != mp.end()) {\\n                flip = (mp.rbegin()->second - it->second + 1) & 1;\\n            }\\n            if (flip) {\\n                v[i] = !v[i];\\n            }\\n\\t\\t\\t// brought to the actual state\\n            if (v[i] == 0) {\\n                return -1; //  here goes nothing m.f.\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2497119,
                "title": "python-o-n-time-o-1-space-in-place-commented-solution",
                "content": "```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        \\n        # How many time have we flipped?\\n        count = 0\\n        # How many past flips have ended?\\n        unwind = 0\\n        # We cannot flip past this point:\\n        max_flip = len(nums)-k+1\\n        \\n        # nums[i] is overwritten as we go, because we never revisit past elements.\\n        #\\n        # (count - unwind) is the number of \"active\" flips\\n        #\\n        # (count - unwind) % 2 == 0 means we are currently not flipping elements\\n        \\n        for i in range(len(nums)):\\n            \\n            # A flip endeding now was performed at i-k\\n            if i >= k and nums[i-k]:\\n                unwind += 1\\n            \\n            # Do we need to flip the current element?\\n            if (nums[i] + count - unwind) % 2 == 0:\\n                # We can\\'t flip because we are close to the end.\\n                if i >= max_flip:\\n                    return -1\\n                # Excute the flip\\n                count += 1\\n                # Signal the flip location\\n                nums[i] = 1\\n            else:\\n                # Signal a non-flip location\\n                nums[i] = 0\\n                \\n        return count\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        \\n        # How many time have we flipped?\\n        count = 0\\n        # How many past flips have ended?\\n        unwind = 0\\n        # We cannot flip past this point:\\n        max_flip = len(nums)-k+1\\n        \\n        # nums[i] is overwritten as we go, because we never revisit past elements.\\n        #\\n        # (count - unwind) is the number of \"active\" flips\\n        #\\n        # (count - unwind) % 2 == 0 means we are currently not flipping elements\\n        \\n        for i in range(len(nums)):\\n            \\n            # A flip endeding now was performed at i-k\\n            if i >= k and nums[i-k]:\\n                unwind += 1\\n            \\n            # Do we need to flip the current element?\\n            if (nums[i] + count - unwind) % 2 == 0:\\n                # We can\\'t flip because we are close to the end.\\n                if i >= max_flip:\\n                    return -1\\n                # Excute the flip\\n                count += 1\\n                # Signal the flip location\\n                nums[i] = 1\\n            else:\\n                # Signal a non-flip location\\n                nums[i] = 0\\n                \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2489204,
                "title": "c-solution-using-deque",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        //Where did I miss?\\n        //I thought of how to update nums of length k\\n        //Insteand of this I could have thought of is there a necessacity to update\\n        \\n        deque<int>q;\\n        int ans = 0;\\n        for(int i = 0;i<nums.size();i++){\\n            while(q.size()&&i - q.front() + 1 > k) q.pop_front();\\n            if(nums[i] == 0 && q.size()%2 == 0 || nums[i] == 1 && q.size()%2 == 1){\\n                if(i + k > nums.size()) return -1;\\n                ans++;\\n                q.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        //Where did I miss?\\n        //I thought of how to update nums of length k\\n        //Insteand of this I could have thought of is there a necessacity to update\\n        \\n        deque<int>q;\\n        int ans = 0;\\n        for(int i = 0;i<nums.size();i++){\\n            while(q.size()&&i - q.front() + 1 > k) q.pop_front();\\n            if(nums[i] == 0 && q.size()%2 == 0 || nums[i] == 1 && q.size()%2 == 1){\\n                if(i + k > nums.size()) return -1;\\n                ans++;\\n                q.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2478082,
                "title": "c-short-and-simple-o-n-video-tutorial-paperba1l",
                "content": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        \\n        int f = 0;\\n        int n = nums.size();\\n        int flips[n+1];\\n        memset(flips, 0, sizeof(flips));\\n        \\n        int cur = 0; \\n\\t\\t// if you flip a bit 3 times, is as good as fliping it ones. \\n\\t\\t// flip_count % 2 is same as parity of cur variable \\n\\t\\t\\n        for(int i=0; i<n; i++) {\\n\\t\\t\\n\\t\\t\\t// superimpose multiple segment on one another \\n\\t\\t\\t// ith bit will flip multiple times, let say c times\\n\\t\\t\\t// c%2 will decide if we want to flip it or not.\\n\\t\\t\\t//  cur^=1 does the same thing\\n            if(flips[i] == 1) {\\n                cur^=1;\\n            }\\n            \\n\\t\\t\\t// just want to check if ith bit after fliping goes to zero\\n            if((nums[i]^cur) == 0) {\\n                f++;\\n                cur^=1;\\n                \\n                if((i+k) > n) {\\n                    return -1;\\n                }\\n                \\n\\t\\t\\t\\t// last index if the block of size k [i, i+k] is fliped correctly\\n                flips[i+k] = 1;\\n            }\\n        }\\n        \\n        return f;\\n        \\n    }\\n};\\n```\\npaperba1l\\nhttps://www.youtube.com/watch?v=tbNpHv2HDXo&ab_channel=HappyCoding",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        \\n        int f = 0;\\n        int n = nums.size();\\n        int flips[n+1];\\n        memset(flips, 0, sizeof(flips));\\n        \\n        int cur = 0; \\n\\t\\t// if you flip a bit 3 times, is as good as fliping it ones. \\n\\t\\t// flip_count % 2 is same as parity of cur variable \\n\\t\\t\\n        for(int i=0; i<n; i++) {\\n\\t\\t\\n\\t\\t\\t// superimpose multiple segment on one another \\n\\t\\t\\t// ith bit will flip multiple times, let say c times\\n\\t\\t\\t// c%2 will decide if we want to flip it or not.\\n\\t\\t\\t//  cur^=1 does the same thing\\n            if(flips[i] == 1) {\\n                cur^=1;\\n            }\\n            \\n\\t\\t\\t// just want to check if ith bit after fliping goes to zero\\n            if((nums[i]^cur) == 0) {\\n                f++;\\n                cur^=1;\\n                \\n                if((i+k) > n) {\\n                    return -1;\\n                }\\n                \\n\\t\\t\\t\\t// last index if the block of size k [i, i+k] is fliped correctly\\n                flips[i+k] = 1;\\n            }\\n        }\\n        \\n        return f;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2460092,
                "title": "java-o-n",
                "content": "Runtime: 5 ms, faster than 97.85% of Java online submissions for Minimum Number of K Consecutive Bit Flips.\\nMemory Usage: 51.1 MB, less than 93.13% of Java online submissions for Minimum Number of K Consecutive Bit Flips.\\n\\n```\\nclass Solution {  \\n    \\n    public int minKBitFlips(int[] nums, int k) {\\n        int minFlipCount = 0;        \\n        boolean fliped = false;\\n        boolean[] cancelFlip = new boolean[nums.length];        \\n        for(int i = 0, len = nums.length; i < len; i++) {\\n            int n = nums[i];            \\n            if(n == 1 && fliped || n == 0 && !fliped) {\\n                minFlipCount++;\\n                fliped = fliped ? false : true;\\n                if(i + k - 1 >= len) return -1;                \\n                cancelFlip[i + k - 1] = true;                \\n            }            \\n            if(cancelFlip[i]) fliped = fliped ? false : true;\\n        }        \\n        return minFlipCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {  \\n    \\n    public int minKBitFlips(int[] nums, int k) {\\n        int minFlipCount = 0;        \\n        boolean fliped = false;\\n        boolean[] cancelFlip = new boolean[nums.length];        \\n        for(int i = 0, len = nums.length; i < len; i++) {\\n            int n = nums[i];            \\n            if(n == 1 && fliped || n == 0 && !fliped) {\\n                minFlipCount++;\\n                fliped = fliped ? false : true;\\n                if(i + k - 1 >= len) return -1;                \\n                cancelFlip[i + k - 1] = true;                \\n            }            \\n            if(cancelFlip[i]) fliped = fliped ? false : true;\\n        }        \\n        return minFlipCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2310439,
                "title": "python-simple-one-pass-sliding-window",
                "content": "```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        flips = [0]*len(nums)\\n        csum = 0\\n        \\n        for left in range(0, len(nums)-k+1):\\n            if (nums[left] + csum) % 2 == 0:\\n                flips[left] += 1\\n                csum += 1\\n            if left >= k-1:\\n                csum -= flips[left-k+1]\\n        \\n        for check in range(len(nums)-k+1, len(nums)):\\n            if (nums[check] + csum) % 2 == 0:\\n                return -1\\n            if check >= k-1:\\n                csum -= flips[check-k+1]\\n        \\n        return sum(flips)\\n            \\n ```\\n \\n The first loop looks for if the bit in that position is equal to zero, keeping track of the number of flips within in the window k-1. The second checks to see if the last few bits (inside the window k) became ones from the flips done to that point. Then you return the sum of flips that you made to that point.",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        flips = [0]*len(nums)\\n        csum = 0\\n        \\n        for left in range(0, len(nums)-k+1):\\n            if (nums[left] + csum) % 2 == 0:\\n                flips[left] += 1\\n                csum += 1\\n            if left >= k-1:\\n                csum -= flips[left-k+1]\\n        \\n        for check in range(len(nums)-k+1, len(nums)):\\n            if (nums[check] + csum) % 2 == 0:\\n                return -1\\n            if check >= k-1:\\n                csum -= flips[check-k+1]\\n        \\n        return sum(flips)\\n            \\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2263972,
                "title": "python-simple-maths",
                "content": "\\n    def minKBitFlips(self, nums, k):\\n        n, ans, total, cur = len(nums), [False]*len(nums), 0, 0\\n        \\n        for i in range(n):\\n            if i >= k:\\n                cur -= ans[i-k] == True\\n                \\n            if (nums[i] + cur)%2 == 0:\\n                if i + k > n:\\n                    return -1\\n                \\n                total += 1\\n                cur += 1\\n                ans[i] = True\\n                \\n        return total",
                "solutionTags": [],
                "code": "\\n    def minKBitFlips(self, nums, k):\\n        n, ans, total, cur = len(nums), [False]*len(nums), 0, 0\\n        \\n        for i in range(n):\\n            if i >= k:\\n                cur -= ans[i-k] == True\\n                \\n            if (nums[i] + cur)%2 == 0:\\n                if i + k > n:\\n                    return -1\\n                \\n                total += 1\\n                cur += 1\\n                ans[i] = True\\n                \\n        return total",
                "codeTag": "Python3"
            },
            {
                "id": 2251526,
                "title": "bit-based-python-solution",
                "content": "```\\ndef minKBitFlips(self, nums: List[int], k: int) -> int:\\n        \\n        mask = 0\\n        setMask = 0\\n        \\n        for i in range(k-1):\\n            setMask = setMask^(1<<i)\\n        count = 0\\n        for i,num in enumerate(nums):\\n            isFlipped = mask & 1\\n            mask = mask >> 1\\n            if ((num == 0) and (isFlipped == False)) or ((num==1) and isFlipped):\\n                if i > len(nums)-k:\\n                    return -1\\n                mask = mask^setMask\\n                count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\ndef minKBitFlips(self, nums: List[int], k: int) -> int:\\n        \\n        mask = 0\\n        setMask = 0\\n        \\n        for i in range(k-1):\\n            setMask = setMask^(1<<i)\\n        count = 0\\n        for i,num in enumerate(nums):\\n            isFlipped = mask & 1\\n            mask = mask >> 1\\n            if ((num == 0) and (isFlipped == False)) or ((num==1) and isFlipped):\\n                if i > len(nums)-k:\\n                    return -1\\n                mask = mask^setMask\\n                count+=1\\n        return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2235183,
                "title": "constant-range-sliding-window",
                "content": "```\\nclass Solution(object):\\n    \\n    def minKBitFlips(self, A, K):\\n        flip_or_not = [False for _ in range(len(A))]\\n        flip = 0\\n        total = 0\\n        \\n        for i in range(len(A)):\\n            if K <= i:\\n                if flip_or_not[i - K]: total -= 1\\n            if i <= len(A) - K:\\n                if (A[i] + total) % 2 == 0:\\n                    total += 1\\n                    flip += 1\\n                    flip_or_not[i] = True\\n            else:\\n                if (A[i] + total) % 2 == 0:\\n                    return -1\\n                \\n        return flip\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    \\n    def minKBitFlips(self, A, K):\\n        flip_or_not = [False for _ in range(len(A))]\\n        flip = 0\\n        total = 0\\n        \\n        for i in range(len(A)):\\n            if K <= i:\\n                if flip_or_not[i - K]: total -= 1\\n            if i <= len(A) - K:\\n                if (A[i] + total) % 2 == 0:\\n                    total += 1\\n                    flip += 1\\n                    flip_or_not[i] = True\\n            else:\\n                if (A[i] + total) % 2 == 0:\\n                    return -1\\n                \\n        return flip\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2179196,
                "title": "python3-o-n-solution",
                "content": "```\\nimport collections\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        dq=collections.deque()\\n        flipped=0\\n        ans=0\\n        for i in range(len(nums)):\\n            if not len(dq)%2:\\n                flipped=0\\n            else:\\n                flipped=1\\n            if nums[i]==0:\\n                if not flipped:\\n                    if i+k-1>=len(nums):\\n                        return -1\\n                    else:\\n                        dq.append(i+k-1)\\n                        ans+=1\\n            else:\\n                if flipped:\\n                    if i+k-1>=len(nums):\\n                        return -1\\n                    else:\\n                        dq.append(i+k-1)\\n                        ans+=1\\n            if dq and dq[0]<=i:\\n                dq.popleft()\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nimport collections\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        dq=collections.deque()\\n        flipped=0\\n        ans=0\\n        for i in range(len(nums)):\\n            if not len(dq)%2:\\n                flipped=0\\n            else:\\n                flipped=1\\n            if nums[i]==0:\\n                if not flipped:\\n                    if i+k-1>=len(nums):\\n                        return -1\\n                    else:\\n                        dq.append(i+k-1)\\n                        ans+=1\\n            else:\\n                if flipped:\\n                    if i+k-1>=len(nums):\\n                        return -1\\n                    else:\\n                        dq.append(i+k-1)\\n                        ans+=1\\n            if dq and dq[0]<=i:\\n                dq.popleft()\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2130795,
                "title": "c-greedy-binary-search-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        vector<int>v;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int x=lower_bound(v.begin(),v.end(),i-k+1)-v.begin();\\n            x=v.size()-x;\\n            if(x%2)\\n            {\\n                nums[i]=1-nums[i];\\n            }\\n            if(nums[i]==0&&i<=nums.size()-k)\\n                v.push_back(i),nums[i]=1;\\n            else if(nums[i]==0)\\n                return -1;\\n        }\\n        return v.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        vector<int>v;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int x=lower_bound(v.begin(),v.end(),i-k+1)-v.begin();\\n            x=v.size()-x;\\n            if(x%2)\\n            {\\n                nums[i]=1-nums[i];\\n            }\\n            if(nums[i]==0&&i<=nums.size()-k)\\n                v.push_back(i),nums[i]=1;\\n            else if(nums[i]==0)\\n                return -1;\\n        }\\n        return v.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039052,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int len = nums.size();\\n        int i, j;\\n        int ans = 0;\\n        deque<int> indexQ;\\n        for(i = 0; i < len - k + 1; i++){\\n            while(!indexQ.empty() && i - indexQ.front() >= k){\\n                indexQ.pop_front();\\n            }\\n            \\n            if(indexQ.size() % 2 == 0 && nums[i] == 0){\\n                indexQ.push_back(i);\\n                ans++;\\n            }\\n            else if(indexQ.size() % 2 != 0 && nums[i] == 1){\\n                indexQ.push_back(i);\\n                ans++;\\n            }\\n        }\\n        \\n        for(; i < len; i++){\\n            while(!indexQ.empty() && i - indexQ.front() >= k){\\n                indexQ.pop_front();\\n            }\\n            if(indexQ.size() % 2 == 0 && nums[i] == 0){\\n                return -1;\\n            }\\n            else if(indexQ.size() % 2 != 0 && nums[i] == 1){\\n                return -1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        int len = nums.size();\\n        int i, j;\\n        int ans = 0;\\n        deque<int> indexQ;\\n        for(i = 0; i < len - k + 1; i++){\\n            while(!indexQ.empty() && i - indexQ.front() >= k){\\n                indexQ.pop_front();\\n            }\\n            \\n            if(indexQ.size() % 2 == 0 && nums[i] == 0){\\n                indexQ.push_back(i);\\n                ans++;\\n            }\\n            else if(indexQ.size() % 2 != 0 && nums[i] == 1){\\n                indexQ.push_back(i);\\n                ans++;\\n            }\\n        }\\n        \\n        for(; i < len; i++){\\n            while(!indexQ.empty() && i - indexQ.front() >= k){\\n                indexQ.pop_front();\\n            }\\n            if(indexQ.size() % 2 == 0 && nums[i] == 0){\\n                return -1;\\n            }\\n            else if(indexQ.size() % 2 != 0 && nums[i] == 1){\\n                return -1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2010454,
                "title": "java-sliding-window-o-n",
                "content": "Consider any ith bit, we put a k-sized sliding window so that the ith bit is at the back of the window.\\n![image](https://assets.leetcode.com/users/images/7968954d-4298-4db1-9b0b-3b4320ea147e_1651751229.2535677.png)\\n\\nAll the flips happen in this window will be accountable for flipping the ith bit.\\nWe could store a flag, namely flipped, such that it will accumulate all the flips.\\nWhen i < k, this flag will be reflecting all the flips done within the sliding windows.\\nStarting from i = k, one bit will be taken out from this sliding window when we move along, and therefore we need to negate the flip triggered by the (i-k)th bit.\\nIn order to know whether the (i-k)th bit is triggering a flip in linear time, we could use a boolean array to help, and set it the true when any ith bit is tiggerring a flip.\\nOnce we know whether the ith bit is flipped by the preceeding bits in the sliding window, we could match it with the value to see if we need to trigger a flip.\\nWhen i > len - k, no flipping is allowed, so we could return -1 if a flip is needed.\\n\\nTime complexity: O(n)\\nWe loopped n times and each iteration is linear time\\n\\nSpace complexity: O(n)\\nThe boolean array is n-sized\\n**notes: we could eliminate the use of the boolean array with the given int array to make it O(1), consider we have 32 bits per element and only the least significant bit is currently occupied*\\n\\n```\\nclass Solution {\\n    public int minKBitFlips(int[] nums, int k) {\\n        int len = nums.length, count = 0;\\n        boolean[] flip = new boolean[len];\\n        boolean flipped = false;\\n        for (int i = 0; i < len; i++) {\\n            if (i >= k && flip[i - k]) flipped = !flipped;\\n            if ((flipped?1:0) == nums[i]){\\n                if (i + k > len) return -1;\\n                count++;\\n                flip[i] = true;\\n                flipped = !flipped;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minKBitFlips(int[] nums, int k) {\\n        int len = nums.length, count = 0;\\n        boolean[] flip = new boolean[len];\\n        boolean flipped = false;\\n        for (int i = 0; i < len; i++) {\\n            if (i >= k && flip[i - k]) flipped = !flipped;\\n            if ((flipped?1:0) == nums[i]){\\n                if (i + k > len) return -1;\\n                count++;\\n                flip[i] = true;\\n                flipped = !flipped;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2007762,
                "title": "simple-greedy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int find(vector<int>& nums, int n, int k, vector<int>& flips, int ind, int change)\\n    {\\n        if(ind >= nums.size())\\n            return 0;\\n        \\n        change += flips[ind];\\n        change %= 2;\\n        \\n        if(change == 0)\\n        {\\n            if(nums[ind] == 1)\\n                return find(nums, n, k, flips, ind + 1, change);\\n            else\\n            {\\n                if(ind + k > nums.size())\\n                    return 1e7;\\n                \\n                flips[ind + k ]++;\\n                return find(nums, n, k, flips, ind + 1, !change) + 1;\\n            }\\n        }\\n        else\\n        {\\n            if(nums[ind] == 0)\\n                return find(nums, n, k, flips, ind + 1, change);\\n            else\\n            {\\n                if(ind + k > nums.size())\\n                    return 1e7;\\n                \\n                flips[ind + k]++;\\n                return find(nums, n, k, flips, ind + 1, !change) + 1;\\n            }\\n        }\\n    }\\n    int minKBitFlips(vector<int>& nums, int k) \\n    {\\n        int n = nums.size();\\n        vector<int> flips(n + 2 , 0);\\n        \\n        int ans = find(nums, n, k, flips, 0, 0);\\n        \\n        if(ans >= 1e7)\\n            return -1;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(vector<int>& nums, int n, int k, vector<int>& flips, int ind, int change)\\n    {\\n        if(ind >= nums.size())\\n            return 0;\\n        \\n        change += flips[ind];\\n        change %= 2;\\n        \\n        if(change == 0)\\n        {\\n            if(nums[ind] == 1)\\n                return find(nums, n, k, flips, ind + 1, change);\\n            else\\n            {\\n                if(ind + k > nums.size())\\n                    return 1e7;\\n                \\n                flips[ind + k ]++;\\n                return find(nums, n, k, flips, ind + 1, !change) + 1;\\n            }\\n        }\\n        else\\n        {\\n            if(nums[ind] == 0)\\n                return find(nums, n, k, flips, ind + 1, change);\\n            else\\n            {\\n                if(ind + k > nums.size())\\n                    return 1e7;\\n                \\n                flips[ind + k]++;\\n                return find(nums, n, k, flips, ind + 1, !change) + 1;\\n            }\\n        }\\n    }\\n    int minKBitFlips(vector<int>& nums, int k) \\n    {\\n        int n = nums.size();\\n        vector<int> flips(n + 2 , 0);\\n        \\n        int ans = find(nums, n, k, flips, 0, 0);\\n        \\n        if(ans >= 1e7)\\n            return -1;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2000070,
                "title": "python-another-solution-use-bit-this-is-slower-just-for-a-reference",
                "content": "Every time we found a zero at i, we must flip the number i ~ (i+k -1),\\nWe can use BIT to store the flip count.\\nKnowing the flip count for the ith number, we can decide wheather to flip it or not.\\n\\n```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        N = len(nums)\\n        BIT = [0]*(N+1)\\n        def update(x):\\n            while x <= N:\\n                BIT[x]+=1\\n                x += x&(-x)\\n        def query(x):\\n            res = 0\\n            while x > 0:\\n                res += BIT[x]\\n                x -= x&(-x)\\n            return res\\n        flip = 0\\n        for i in range(N-k+1):\\n            if (nums[N-i-1] + query(N-i))%2 == 0:\\n                flip+=1\\n                update(N-i-k+1)\\n        for i in range(N-k+1,N):\\n            if (nums[N-i-1] + query(N-i))%2 == 0:\\n                return -1\\n        return flip\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        N = len(nums)\\n        BIT = [0]*(N+1)\\n        def update(x):\\n            while x <= N:\\n                BIT[x]+=1\\n                x += x&(-x)\\n        def query(x):\\n            res = 0\\n            while x > 0:\\n                res += BIT[x]\\n                x -= x&(-x)\\n            return res\\n        flip = 0\\n        for i in range(N-k+1):\\n            if (nums[N-i-1] + query(N-i))%2 == 0:\\n                flip+=1\\n                update(N-i-k+1)\\n        for i in range(N-k+1,N):\\n            if (nums[N-i-1] + query(N-i))%2 == 0:\\n                return -1\\n        return flip\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866324,
                "title": "java-n-2-solution-tle-o-n-accept-o-1-space",
                "content": "```\\nclass Solution {\\n    public int minKBitFlips(int[] nums, int k) {\\n        return dfs(nums, 0, k);\\n    }\\n    \\n    private int dfs(int[] nums, int start, int k) {\\n        int next = nums.length;\\n        for (int i = start; i < nums.length; i++) {\\n            if (nums[i] == 0) {\\n                next = i;\\n                break;\\n            }\\n        }\\n        if (next == nums.length) {\\n            return 0;\\n        }\\n        if (next + k > nums.length) {\\n            return -1;\\n        }\\n        start = next + k;\\n        for (int i = next ; i < next + k; i++) {\\n            nums[i] ^= 1;\\n            if (nums[i] == 0) {\\n                start = Math.min(start, i);\\n            }\\n        }\\n        int temp = dfs(nums, start, k);\\n        return temp == -1 ? -1 : temp + 1;\\n    }\\n}\\n```\\n\\n```\\nclass Solution {\\n    public int minKBitFlips(int[] nums, int k) {\\n        int ans = 0;\\n        int flag = 0;\\n        int[] flags = new int[nums.length];\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == flag % 2) {\\n                if (i + k > nums.length) {\\n                    return -1;\\n                }\\n                ans++;\\n                flags[i] += 1;\\n                flags[i + k - 1] -= 1;\\n            }\\n            flag += flags[i];\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n```\\nclass Solution {\\n    public int minKBitFlips(int[] nums, int k) {\\n        int ans = 0;\\n        int flag = 0;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == flag % 2) {\\n                if (i + k > nums.length) {\\n                    return -1;\\n                }\\n                ans++;\\n                flag++;\\n                nums[i] = -1;\\n            }\\n            if (i >= k - 1 && nums[i - k + 1] == -1) {\\n                flag--;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minKBitFlips(int[] nums, int k) {\\n        return dfs(nums, 0, k);\\n    }\\n    \\n    private int dfs(int[] nums, int start, int k) {\\n        int next = nums.length;\\n        for (int i = start; i < nums.length; i++) {\\n            if (nums[i] == 0) {\\n                next = i;\\n                break;\\n            }\\n        }\\n        if (next == nums.length) {\\n            return 0;\\n        }\\n        if (next + k > nums.length) {\\n            return -1;\\n        }\\n        start = next + k;\\n        for (int i = next ; i < next + k; i++) {\\n            nums[i] ^= 1;\\n            if (nums[i] == 0) {\\n                start = Math.min(start, i);\\n            }\\n        }\\n        int temp = dfs(nums, start, k);\\n        return temp == -1 ? -1 : temp + 1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minKBitFlips(int[] nums, int k) {\\n        int ans = 0;\\n        int flag = 0;\\n        int[] flags = new int[nums.length];\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == flag % 2) {\\n                if (i + k > nums.length) {\\n                    return -1;\\n                }\\n                ans++;\\n                flags[i] += 1;\\n                flags[i + k - 1] -= 1;\\n            }\\n            flag += flags[i];\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minKBitFlips(int[] nums, int k) {\\n        int ans = 0;\\n        int flag = 0;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == flag % 2) {\\n                if (i + k > nums.length) {\\n                    return -1;\\n                }\\n                ans++;\\n                flag++;\\n                nums[i] = -1;\\n            }\\n            if (i >= k - 1 && nums[i - k + 1] == -1) {\\n                flag--;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1854374,
                "title": "python-o-nlogn-greedy-binary-search-bisect",
                "content": "Approach :-\\nAt each index i check whether this index was flipped odd number of times or even number of times.\\nThis can be done by storing the index where effect of flipping current k elements will vanish.\\n\\n```\\nimport bisect \\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        res = 0\\n        L = []\\n        for i in range(len(nums)):\\n            j,n = bisect.bisect_right(L,i),len(L)\\n            if ((n-j)%2==0 and nums[i]==0) or ((n-j)%2!=0 and nums[i]==1):\\n                if i+k>len(nums):\\n                    return -1 \\n                res+=1\\n                bisect.insort_left(L,i+k)\\n            nums[i]=1\\n        return res \\n```",
                "solutionTags": [
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nimport bisect \\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        res = 0\\n        L = []\\n        for i in range(len(nums)):\\n            j,n = bisect.bisect_right(L,i),len(L)\\n            if ((n-j)%2==0 and nums[i]==0) or ((n-j)%2!=0 and nums[i]==1):\\n                if i+k>len(nums):\\n                    return -1 \\n                res+=1\\n                bisect.insort_left(L,i+k)\\n            nums[i]=1\\n        return res \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1816115,
                "title": "golang-solution-with-comments",
                "content": "```go\\nfunc minKBitFlips(nums []int, k int) int {\\n\\tminFlips1 := lc995Helper(nums, k)\\n\\treverse(nums)\\n\\tminFlips2 := lc995Helper(nums, k)\\n\\tif min(minFlips1, minFlips2) == math.MaxInt32 {\\n\\t\\treturn -1\\n\\t}\\n\\treturn min(minFlips1, minFlips2)\\n}\\n\\nfunc lc995Helper(nums []int, k int) int {\\n\\ttotalFlips, currFlips := 0, 0\\n\\t// flipEndIndexes, inclusive\\n\\tflipEndIndexes := make([]int, 0, len(nums))\\n\\tcurrentIndex := 0\\n\\tfor i, v := range nums {\\n\\t\\tif currFlips > 0 {\\n\\t\\t\\t// if i > flipEndIndexes[currentIndex], we need decrease currFlips by 1\\n\\t\\t\\tif i > flipEndIndexes[currentIndex] {\\n\\t\\t\\t\\tcurrentIndex++\\n\\t\\t\\t\\tcurrFlips--\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif currFlips%2 != 0 {\\n\\t\\t\\t// odd flip, 0->1, 1->0\\n\\t\\t\\tv = v ^ 1\\n\\t\\t}\\n\\t\\tif v == 0 {\\n\\t\\t\\t// we need flip once\\n\\t\\t\\tif i+k-1 >= len(nums) {\\n\\t\\t\\t\\t// invalid flip\\n\\t\\t\\t\\treturn math.MaxInt32\\n\\t\\t\\t}\\n\\t\\t\\ttotalFlips++\\n\\t\\t\\tcurrFlips++\\n\\t\\t\\tflipEndIndexes = append(flipEndIndexes, i+k-1)\\n\\t\\t}\\n\\t}\\n\\treturn totalFlips\\n}\\n\\nfunc reverse(A []int) {\\n\\tfor i := 0; i < len(A)/2; i++ {\\n\\t\\tA[i], A[len(A)-1-i] = A[len(A)-1-i], A[i]\\n\\t}\\n}\\n\\nfunc min(values ...int) int {\\n\\tminValue := math.MaxInt64\\n\\tfor _, v := range values {\\n\\t\\tif v < minValue {\\n\\t\\t\\tminValue = v\\n\\t\\t}\\n\\t}\\n\\treturn minValue\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc minKBitFlips(nums []int, k int) int {\\n\\tminFlips1 := lc995Helper(nums, k)\\n\\treverse(nums)\\n\\tminFlips2 := lc995Helper(nums, k)\\n\\tif min(minFlips1, minFlips2) == math.MaxInt32 {\\n\\t\\treturn -1\\n\\t}\\n\\treturn min(minFlips1, minFlips2)\\n}\\n\\nfunc lc995Helper(nums []int, k int) int {\\n\\ttotalFlips, currFlips := 0, 0\\n\\t// flipEndIndexes, inclusive\\n\\tflipEndIndexes := make([]int, 0, len(nums))\\n\\tcurrentIndex := 0\\n\\tfor i, v := range nums {\\n\\t\\tif currFlips > 0 {\\n\\t\\t\\t// if i > flipEndIndexes[currentIndex], we need decrease currFlips by 1\\n\\t\\t\\tif i > flipEndIndexes[currentIndex] {\\n\\t\\t\\t\\tcurrentIndex++\\n\\t\\t\\t\\tcurrFlips--\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif currFlips%2 != 0 {\\n\\t\\t\\t// odd flip, 0->1, 1->0\\n\\t\\t\\tv = v ^ 1\\n\\t\\t}\\n\\t\\tif v == 0 {\\n\\t\\t\\t// we need flip once\\n\\t\\t\\tif i+k-1 >= len(nums) {\\n\\t\\t\\t\\t// invalid flip\\n\\t\\t\\t\\treturn math.MaxInt32\\n\\t\\t\\t}\\n\\t\\t\\ttotalFlips++\\n\\t\\t\\tcurrFlips++\\n\\t\\t\\tflipEndIndexes = append(flipEndIndexes, i+k-1)\\n\\t\\t}\\n\\t}\\n\\treturn totalFlips\\n}\\n\\nfunc reverse(A []int) {\\n\\tfor i := 0; i < len(A)/2; i++ {\\n\\t\\tA[i], A[len(A)-1-i] = A[len(A)-1-i], A[i]\\n\\t}\\n}\\n\\nfunc min(values ...int) int {\\n\\tminValue := math.MaxInt64\\n\\tfor _, v := range values {\\n\\t\\tif v < minValue {\\n\\t\\t\\tminValue = v\\n\\t\\t}\\n\\t}\\n\\treturn minValue\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1811873,
                "title": "subtract-in-tricky-way",
                "content": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) \\n    {\\n         int total = 0;\\n         int a[100001] = {0};\\n         int sum = 0;\\n         for(int i = 0;i < nums.size();i++)\\n         {\\n                 sum -= a[i];\\n                 if(nums[i] != (sum%2))\\n                 continue;\\n                 else\\n                 {\\n                     if(i + k > nums.size())\\n                     return -1;\\n                     a[i+k] += 1;\\n                     sum += 1;\\n                     total += 1;\\n                 }\\n         }\\n         return total;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) \\n    {\\n         int total = 0;\\n         int a[100001] = {0};\\n         int sum = 0;\\n         for(int i = 0;i < nums.size();i++)\\n         {\\n                 sum -= a[i];\\n                 if(nums[i] != (sum%2))\\n                 continue;\\n                 else\\n                 {\\n                     if(i + k > nums.size())\\n                     return -1;\\n                     a[i+k] += 1;\\n                     sum += 1;\\n                     total += 1;\\n                 }\\n         }\\n         return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1791315,
                "title": "greedy-dp",
                "content": "int minKBitFlips(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        int count1 = 0;\\n        \\n        vector<int> dp(n,0);\\n        int ans = 0;\\n        \\n        for(int i = 0;i<n;i++)\\n        {\\n            if(i+k<=n)\\n            {\\n                if(nums[i] == 0)\\n                {\\n                    int buf = (i>=k)?dp[i-k]:0;\\n                    if((count1-buf)%2 == 0)\\n                    {\\n                        count1++;\\n                        ans++;\\n                    }\\n                    dp[i] = count1;\\n                    nums[i] = 1;\\n                }\\n                else\\n                {\\n                    int buf = (i>=k)?dp[i-k]:0;\\n                    if((count1-buf)%2 != 0)\\n                    {\\n                        ans++;\\n                        count1++;\\n                    }\\n                    dp[i] = count1;\\n                    \\n                    \\n                }\\n                \\n                \\n            }\\n            else\\n            {\\n                \\n                if(nums[i] == 0)\\n                {\\n                    int buf = (i>=k)?dp[i-k]:0;\\n                    if((count1-buf)%2 == 0)\\n                        return -1;\\n                    \\n                }\\n                else\\n                {\\n                    int buf = (i>=k)?dp[i-k]:0;\\n                    if((count1-buf)%2 != 0)\\n                        return -1;\\n                }\\n                \\n            }\\n        \\n            \\n            \\n        }\\n        \\n        \\n        \\n        return ans;\\n        \\n        \\n    }",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "int minKBitFlips(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        int count1 = 0;\\n        \\n        vector<int> dp(n,0);\\n        int ans = 0;\\n        \\n        for(int i = 0;i<n;i++)\\n        {\\n            if(i+k<=n)\\n            {\\n                if(nums[i] == 0)\\n                {\\n                    int buf = (i>=k)?dp[i-k]:0;\\n                    if((count1-buf)%2 == 0)\\n                    {\\n                        count1++;\\n                        ans++;\\n                    }\\n                    dp[i] = count1;\\n                    nums[i] = 1;\\n                }\\n                else\\n                {\\n                    int buf = (i>=k)?dp[i-k]:0;\\n                    if((count1-buf)%2 != 0)\\n                    {\\n                        ans++;\\n                        count1++;\\n                    }\\n                    dp[i] = count1;\\n                    \\n                    \\n                }\\n                \\n                \\n            }\\n            else\\n            {\\n                \\n                if(nums[i] == 0)\\n                {\\n                    int buf = (i>=k)?dp[i-k]:0;\\n                    if((count1-buf)%2 == 0)\\n                        return -1;\\n                    \\n                }\\n                else\\n                {\\n                    int buf = (i>=k)?dp[i-k]:0;\\n                    if((count1-buf)%2 != 0)\\n                        return -1;\\n                }\\n                \\n            }\\n        \\n            \\n            \\n        }\\n        \\n        \\n        \\n        return ans;\\n        \\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1659474,
                "title": "greedy-queue-solution-typescript",
                "content": "\\n```\\nfunction minKBitFlips(nums: number[], k: number): number {\\n    if (nums.length < k) return -1;\\n    \\n    let queue: number[] = [];\\n    \\n    let flips = 0;\\n    \\n    const lastPossibleFlip = nums.length - k;\\n    \\n    for (let i = 0; i < nums.length; i++){\\n        if (queue.length && queue[0] < i) queue.shift();\\n        \\n        if (queue.length % 2 == nums[i]){ // Requires flip\\n            if (i > lastPossibleFlip) return -1;\\n            \\n            flips++;\\n            queue.push(i + k - 1);\\n        }\\n    }\\n    \\n    \\n    return flips;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction minKBitFlips(nums: number[], k: number): number {\\n    if (nums.length < k) return -1;\\n    \\n    let queue: number[] = [];\\n    \\n    let flips = 0;\\n    \\n    const lastPossibleFlip = nums.length - k;\\n    \\n    for (let i = 0; i < nums.length; i++){\\n        if (queue.length && queue[0] < i) queue.shift();\\n        \\n        if (queue.length % 2 == nums[i]){ // Requires flip\\n            if (i > lastPossibleFlip) return -1;\\n            \\n            flips++;\\n            queue.push(i + k - 1);\\n        }\\n    }\\n    \\n    \\n    return flips;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1568109,
                "title": "short-python",
                "content": "Keep track of indexes you flip, by that count using bisect how many flips of length k cover your current bit and including information about its current value decide whether you need to flip it.\\n\\n```\\nfrom bisect import bisect_left\\n\\nclass Solution:\\n    def minKBitFlips(self, nums, k):\\n        n, arr = len(nums), []\\n        for i in range(n):\\n            if (len(arr) - bisect_left(arr, i - k + 1) + nums[i]) % 2 == 0:\\n                arr.append(i)\\n                if i > n - k:\\n                    return -1\\n        return len(arr)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom bisect import bisect_left\\n\\nclass Solution:\\n    def minKBitFlips(self, nums, k):\\n        n, arr = len(nums), []\\n        for i in range(n):\\n            if (len(arr) - bisect_left(arr, i - k + 1) + nums[i]) % 2 == 0:\\n                arr.append(i)\\n                if i > n - k:\\n                    return -1\\n        return len(arr)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1511201,
                "title": "use-the-length-of-the-queue-to-keep-track-of-number-of-flips",
                "content": "```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        dq = collections.deque()\\n        flips = 0\\n        for i in range(len(nums)):\\n            l = len(dq)\\n            if (nums[i] == 0 and not l & 1) or (nums[i] == 1 and l & 1):\\n                right = i + k - 1\\n                if right < len(nums):\\n                    dq.append(right)\\n                    flips += 1\\n                else:\\n                    return -1\\n            if dq and dq[0] == i:\\n                dq.popleft()\\n        return flips\\n```\\nyou can come to this solution by trying this test case [0,1,0,1,0,1,0,1...]\\nyou will notice that when you flip, all numbers in the range are flipped. when you move to the next index and flip again, all the numbers in the window -1 are flipped again except for the last element which is flipped only once. so you only need to store the right side of flips since everything to the left of that will be the same number of flips which also happens to be the length of the queue. then when you reach the index in which you added the element to the queue, pop it off",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minKBitFlips(self, nums: List[int], k: int) -> int:\\n        dq = collections.deque()\\n        flips = 0\\n        for i in range(len(nums)):\\n            l = len(dq)\\n            if (nums[i] == 0 and not l & 1) or (nums[i] == 1 and l & 1):\\n                right = i + k - 1\\n                if right < len(nums):\\n                    dq.append(right)\\n                    flips += 1\\n                else:\\n                    return -1\\n            if dq and dq[0] == i:\\n                dq.popleft()\\n        return flips\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1448792,
                "title": "javascript-2-solutions",
                "content": "**1. Queue - Time O(n), Space O(k)**\\n```\\nvar minKBitFlips = function(nums, k) {\\n    let n = nums.length, list = [], flips = 0;\\n    \\n    for (let i = 0; i < n; i++) {\\n        if (list.length && list[0] < i)\\n            list.shift();\\n\\n        if (nums[i] === list.length % 2) {\\n            if (i + k > nums.length)\\n                return -1;\\n\\n            list.push(i + k - 1);\\n            flips++;\\n        }\\n    }\\n\\n    return flips;\\n};\\n```\\n**2. Using Queue length alone - Time O(n), SpaceO(1)**\\n```\\nvar minKBitFlips = function(nums, k) {\\n    let n = nums.length, list = 0, flips = 0;\\n    \\n    for (let i = 0; i < n; i++) {\\n        if (i >= k && nums[i - k] === 2)\\n            list--;\\n\\n        if (nums[i] === list % 2) {\\n            if (i + k > nums.length)\\n                return -1;\\n            nums[i] = 2;\\n            list++;\\n            flips++;\\n        }\\n    }\\n\\n    return flips;\\n};",
                "solutionTags": [],
                "code": "```\\nvar minKBitFlips = function(nums, k) {\\n    let n = nums.length, list = [], flips = 0;\\n    \\n    for (let i = 0; i < n; i++) {\\n        if (list.length && list[0] < i)\\n            list.shift();\\n\\n        if (nums[i] === list.length % 2) {\\n            if (i + k > nums.length)\\n                return -1;\\n\\n            list.push(i + k - 1);\\n            flips++;\\n        }\\n    }\\n\\n    return flips;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1405013,
                "title": "c-simple-queue-implementation-queue",
                "content": "Make a `queue ` that will keep track of the first indices of  `k`-bitflips from left to right.\\nThese first indices of `k`-bitflips must be in the range `[0, nums.size() - k ]`.\\n\\nFor index `i`, if we flipped `n` bits out of  range `[i - k + 1, i - 1]` , the bit at `i` is now `nums[i] + n` modulo 2.\\n\\nIf `nums[i] + n` is even, the bit at index `i` is `0`, so flip `k`-bits starting at index`i`. (i,e `push` `i` to the `queue`.) \\nif  `nums[i] + n` is odd, the bit at index `i` is `1`. So don\\'t` push` `i` to the queue.\\n\\n\\n\\n**Algorithm: **\\n\\n1. if the `front `of the `queue` is more than `k` distance away from index `i`, pop it.\\n2. count the size of the queue. (this determines how many flips were made on the bit at index `i`.)\\n3. if `i` is not one of the very last `k - 1` indices and `nums[i] + q.size()` is an even number, push index `i` to the queue (we flip the bit at index `i`)\\n4. if `i` is one of the very last `k - 1` indices and `nums[i] + q.size()` is an even number, return `-1`.\\n5. Return the total number of `push` operations. (# of flips)\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n\\n        int count = 0;\\n \\n        queue<int> q;\\n        for (int i = 0; i < nums.size(); i++) {\\n         \\n            if (!q.empty() && i - q.front() >= k) {\\n                q.pop();\\n            }\\n            \\n            if (i <= nums.size() - k) {\\n\\t\\n                if ((nums[i] + q.size()) % 2 == 0) {\\n                    q.push(i);\\n                    count++;\\n                } \\n                \\n            } else {\\n                if ((nums[i] + q.size()) % 2 != 1) return -1;\\n            }\\n            \\n        }  \\n       \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n\\n        int count = 0;\\n \\n        queue<int> q;\\n        for (int i = 0; i < nums.size(); i++) {\\n         \\n            if (!q.empty() && i - q.front() >= k) {\\n                q.pop();\\n            }\\n            \\n            if (i <= nums.size() - k) {\\n\\t\\n                if ((nums[i] + q.size()) % 2 == 0) {\\n                    q.push(i);\\n                    count++;\\n                } \\n                \\n            } else {\\n                if ((nums[i] + q.size()) % 2 != 1) return -1;\\n            }\\n            \\n        }  \\n       \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1301099,
                "title": "moving-from-the-basic-to-the-hard-solution",
                "content": "Like any hard problem, first an initial solution has to be thought up which has to be refined. The HARD part of this problem is in refining this problem for an interview ready solution. \\n\\nOn observing the test cases and with some thinking one can observe that whenever a 0 is encountered, it must be flipped, for the least number of flips. This suggests the greedy approach, iterating over the array and flipping k bits on encountering 0. For an array of size n and window size of k, there are k*(n-k+1) operations possible (considering we actually flip the bits). This solution gives TLE.\\n\\nThe observation which gives the efficient solution is that one does not have to carry out the flips to setup the rest of the array. If a count of all the flips that can affect an index is maintained, the count determines the state of an array.\\n\\nConsider that **making a flip at index i means flipping the bits from i to i+k-1**. \\n\\nThen if 0 is encountered at index i, a flip affects indices upto i+k-1. The same greedy approach is followed but instead of flipping in the case of a zero, a queue is used and on flipping at an index the last index affected by the flip is pushed onto the queue. Flipping is done whenever the number of flips is such that the state of an index is 0. \\n\\nOnce the last index is reached the index is popped from the queue. So, for any index the size of the queue determines the number of flips which have already taken place which involve the bit at that index. Using this the actual state of the flip 0/1 can be determined using the original state which is already present in the array itself. \\n\\nSince a given index can be affected by at most k flips, the queue has a length of at most k. Now, a flip has to be made in this strategy when \\n\\n* The original value is 0 and an even number of flips have taken place so far\\n* The original value is 1 and an odd number of flips have taken place so far\\n\\nIn concise solutions, these are combined into a single condition A[i] == flips%2, although writing them separately is more logical to think about. \\n\\nNote that since flips are removed from the queue when the last index to be affected by the flip is traversed, the only case in which -1 is returned is if the queue is non-empty after all the indices are traversed, i.e. an index beyond the addressible range has been pushed onto the queue, or that a 0 exists at a location where there are less than k bits to flip.\\n\\nFor the O(1) space solution which might be asked, the count of the flips can be updated as in the queue solution, however, instead of using a queue, flip indices are indicated by making the numbers at those positions negative. Then, when the iteration reaches the limit of an old flip, checking whether the beginning of the old flip is negative allows to maintain the count of the flips (subtracting 1 if indeed it is negative). However, a separate count is required only to count the times the flip counter is incremented, for the total k bit flips. (The flip counter itself is used to check only the flips that can affect a particular index, but we need to count every flip.)\\n\\nThe pattern that comes out of learning the solution is that for binary values/states, only a count of switches is sufficient to track the state. The k-bit restriction suggests queue as an effective way of tracking this count.",
                "solutionTags": [],
                "code": "Like any hard problem, first an initial solution has to be thought up which has to be refined. The HARD part of this problem is in refining this problem for an interview ready solution. \\n\\nOn observing the test cases and with some thinking one can observe that whenever a 0 is encountered, it must be flipped, for the least number of flips. This suggests the greedy approach, iterating over the array and flipping k bits on encountering 0. For an array of size n and window size of k, there are k*(n-k+1) operations possible (considering we actually flip the bits). This solution gives TLE.\\n\\nThe observation which gives the efficient solution is that one does not have to carry out the flips to setup the rest of the array. If a count of all the flips that can affect an index is maintained, the count determines the state of an array.\\n\\nConsider that **making a flip at index i means flipping the bits from i to i+k-1**. \\n\\nThen if 0 is encountered at index i, a flip affects indices upto i+k-1. The same greedy approach is followed but instead of flipping in the case of a zero, a queue is used and on flipping at an index the last index affected by the flip is pushed onto the queue. Flipping is done whenever the number of flips is such that the state of an index is 0. \\n\\nOnce the last index is reached the index is popped from the queue. So, for any index the size of the queue determines the number of flips which have already taken place which involve the bit at that index. Using this the actual state of the flip 0/1 can be determined using the original state which is already present in the array itself. \\n\\nSince a given index can be affected by at most k flips, the queue has a length of at most k. Now, a flip has to be made in this strategy when \\n\\n* The original value is 0 and an even number of flips have taken place so far\\n* The original value is 1 and an odd number of flips have taken place so far\\n\\nIn concise solutions, these are combined into a single condition A[i] == flips%2, although writing them separately is more logical to think about. \\n\\nNote that since flips are removed from the queue when the last index to be affected by the flip is traversed, the only case in which -1 is returned is if the queue is non-empty after all the indices are traversed, i.e. an index beyond the addressible range has been pushed onto the queue, or that a 0 exists at a location where there are less than k bits to flip.\\n\\nFor the O(1) space solution which might be asked, the count of the flips can be updated as in the queue solution, however, instead of using a queue, flip indices are indicated by making the numbers at those positions negative. Then, when the iteration reaches the limit of an old flip, checking whether the beginning of the old flip is negative allows to maintain the count of the flips (subtracting 1 if indeed it is negative). However, a separate count is required only to count the times the flip counter is incremented, for the total k bit flips. (The flip counter itself is used to check only the flips that can affect a particular index, but we need to count every flip.)\\n\\nThe pattern that comes out of learning the solution is that for binary values/states, only a count of switches is sufficient to track the state. The k-bit restriction suggests queue as an effective way of tracking this count.",
                "codeTag": "Unknown"
            },
            {
                "id": 1258842,
                "title": "100-solution-simple-solution-clean-cpp-code",
                "content": "```\\nTime Used       : [48ms~64ms]\\nTime            :  O(N)\\nSpace           :  O(K)  \\nAdditional Space:  O(c) //we reuse original vector to save history of flips\\n```\\n\\nThe algorithm:\\nActually, it is quite straightforward. \\n1. We scan from left to right, and cout flippings  for the most recently K bits as \"sum\".\\n2. For each \"bit\", we cout all flippings that will change the value of the current bit. Additional flipping is required as long as nums[i]!=(sum&1) or !(nums[i]-(sum&1)).\\n3. Step 2  should stop at the (N-k+1)-th bit. The tricky part is M=min(k, N-k+1) for small value of N.\\n4. We should check the rest of bits left, as long as that one bit is 0, return -1. Again, the tricky part is M for small value of N.\\n\\n```\\n//C++ code\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        int ans, sum=0, N=nums.size(), i=0, flip;\\n        int M=min(k, N-k+1);\\n        for(; i<M; ++i) {\\n            nums[i] = !(nums[i]-(sum&1));\\n            //nums[i]=flip;\\n            sum+=nums[i];\\n        }\\n        ans=sum;\\n        if(N>2*k-1) {\\n            for(; i<N-k+1; ++i) {\\n                sum-=nums[i-k];\\n                nums[i] = !(nums[i]-(sum&1));\\n                //nums[i]=nums[i];\\n                sum+=nums[i];\\n                ans+=nums[i];\\n            }\\n        }\\n        for(; i<k; ++i) {\\n            if(!(nums[i]-(sum&1))) {\\n                return -1;\\n            }\\n        }\\n        for(; i<N; ++i) {\\n            sum-=nums[i-k];\\n            if(!(nums[i]-(sum&1))) {\\n                return -1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nTime Used       : [48ms~64ms]\\nTime            :  O(N)\\nSpace           :  O(K)  \\nAdditional Space:  O(c) //we reuse original vector to save history of flips\\n```\n```\\n//C++ code\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& nums, int k) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        int ans, sum=0, N=nums.size(), i=0, flip;\\n        int M=min(k, N-k+1);\\n        for(; i<M; ++i) {\\n            nums[i] = !(nums[i]-(sum&1));\\n            //nums[i]=flip;\\n            sum+=nums[i];\\n        }\\n        ans=sum;\\n        if(N>2*k-1) {\\n            for(; i<N-k+1; ++i) {\\n                sum-=nums[i-k];\\n                nums[i] = !(nums[i]-(sum&1));\\n                //nums[i]=nums[i];\\n                sum+=nums[i];\\n                ans+=nums[i];\\n            }\\n        }\\n        for(; i<k; ++i) {\\n            if(!(nums[i]-(sum&1))) {\\n                return -1;\\n            }\\n        }\\n        for(; i<N; ++i) {\\n            sum-=nums[i-k];\\n            if(!(nums[i]-(sum&1))) {\\n                return -1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1219403,
                "title": "c-with-queue-easy-understanding",
                "content": "public class Solution {\\n    public int MinKBitFlips(int[] nums, int k) \\n    {\\n        int result = 0;\\n        Queue<int> qu = new Queue<int>();\\n        \\n        for(int a = 0;a<nums.Length;a++)\\n        {            \\n            while(qu.Count()>0&&qu.Peek()<a)\\n            {\\n                qu.Dequeue();\\n            }\\n            \\n            if((nums[a]+qu.Count())%2==1)\\n            {\\n                continue;\\n            }\\n            if(a>nums.Length-k)\\n            {\\n                return -1;\\n            }\\n            result++;\\n            qu.Enqueue(a+k-1);\\n        }\\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int MinKBitFlips(int[] nums, int k) \\n    {\\n        int result = 0;\\n        Queue<int> qu = new Queue<int>();\\n        \\n        for(int a = 0;a<nums.Length;a++)\\n        {            \\n            while(qu.Count()>0&&qu.Peek()<a)\\n            {\\n                qu.Dequeue();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1217788,
                "title": "scala-solution",
                "content": "```\\ndef minKBitFlips(nums: Array[Int], k: Int): Int = {\\n        val n = nums.length\\n        val isFlipped = Array.ofDim[Int](n)\\n        (0 until n).foldLeft(0/*flipped*/,0/*res*/)((b,a)=>{\\n          var temp = b._1\\n          if(a >= k){temp ^= isFlipped(a - k)}\\n          if(temp == nums(a)){\\n            if(a + k > n){return  -1}\\n            isFlipped(a) = 1\\n            (temp^1, b._2 + 1)\\n          }else (temp,b._2)\\n        })._2\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\ndef minKBitFlips(nums: Array[Int], k: Int): Int = {\\n        val n = nums.length\\n        val isFlipped = Array.ofDim[Int](n)\\n        (0 until n).foldLeft(0/*flipped*/,0/*res*/)((b,a)=>{\\n          var temp = b._1\\n          if(a >= k){temp ^= isFlipped(a - k)}\\n          if(temp == nums(a)){\\n            if(a + k > n){return  -1}\\n            isFlipped(a) = 1\\n            (temp^1, b._2 + 1)\\n          }else (temp,b._2)\\n        })._2\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1193680,
                "title": "c-very-simple-code-no-stack3",
                "content": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& v, int k) {\\n        int ans[60001]={0};\\n        int cnt=0;\\n        if(v[0]==0)\\n        {\\n            cnt++;\\n            ans[0]=1;\\n            ans[k]=-1;\\n        }\\n        for(int i=1;i<=v.size()-k;i++)\\n        {\\n            ans[i]+=ans[i-1];\\n            if(v[i]==0&&ans[i]%2==0)\\n            {\\n                cnt++;\\n                ans[i]+=1;\\n                ans[i+k]-=1;\\n            }\\n            else if(v[i]==1&&ans[i]%2)\\n            {\\n                cnt++;\\n                ans[i]+=1;\\n                ans[i+k]-=1;\\n            }\\n            \\n        }\\n        for(int j=v.size()-k+1;j<v.size();j++)\\n        {\\n            ans[j]+=ans[j-1];\\n            if(v[j]==0&&ans[j]%2==0)\\n                return -1;\\n            if(v[j]==1&&ans[j]%2)\\n                return -1;\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\nFeel free to ask in comments.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& v, int k) {\\n        int ans[60001]={0};\\n        int cnt=0;\\n        if(v[0]==0)\\n        {\\n            cnt++;\\n            ans[0]=1;\\n            ans[k]=-1;\\n        }\\n        for(int i=1;i<=v.size()-k;i++)\\n        {\\n            ans[i]+=ans[i-1];\\n            if(v[i]==0&&ans[i]%2==0)\\n            {\\n                cnt++;\\n                ans[i]+=1;\\n                ans[i+k]-=1;\\n            }\\n            else if(v[i]==1&&ans[i]%2)\\n            {\\n                cnt++;\\n                ans[i]+=1;\\n                ans[i+k]-=1;\\n            }\\n            \\n        }\\n        for(int j=v.size()-k+1;j<v.size();j++)\\n        {\\n            ans[j]+=ans[j-1];\\n            if(v[j]==0&&ans[j]%2==0)\\n                return -1;\\n            if(v[j]==1&&ans[j]%2)\\n                return -1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1188034,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def minKBitFlips(self, A: List[int], K: int) -> int:\\n        \"\"\"\\n        WLOG, since the bit flip operations are commutative we can assume\\n        that flip_i happens before flip_j when i < j \\n        (flip_i denotes flippings bits i thru i + K - 1)\\n        \"\"\"\\n        N = len(A)\\n        flips = 0\\n        \\n        if not A[0]:\\n            for i in range(K):\\n                A[i] = 1 - A[i]\\n            flips += 1\\n        \\n        diffs = [abs(A[i+1] - A[i]) for i in range(N-1)]\\n        for i in range(N-K):\\n            if diffs[i]:\\n                flips += 1\\n                if i < N - K - 1:\\n                    diffs[i+K] = 1 - diffs[i+K]\\n                \\n        return flips if not any(diffs[N-K:]) else -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minKBitFlips(self, A: List[int], K: int) -> int:\\n        \"\"\"\\n        WLOG, since the bit flip operations are commutative we can assume\\n        that flip_i happens before flip_j when i < j \\n        (flip_i denotes flippings bits i thru i + K - 1)\\n        \"\"\"\\n        N = len(A)\\n        flips = 0\\n        \\n        if not A[0]:\\n            for i in range(K):\\n                A[i] = 1 - A[i]\\n            flips += 1\\n        \\n        diffs = [abs(A[i+1] - A[i]) for i in range(N-1)]\\n        for i in range(N-K):\\n            if diffs[i]:\\n                flips += 1\\n                if i < N - K - 1:\\n                    diffs[i+K] = 1 - diffs[i+K]\\n                \\n        return flips if not any(diffs[N-K:]) else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1159778,
                "title": "javascript-super-easy",
                "content": "```\\n/**\\n * @param {number[]} A\\n * @param {number} K\\n * @return {number}\\n */\\nvar minKBitFlips = function(A, K) {\\n    let r = 0;\\n    for(let i = 0; i<A.length; i++) {\\n\\t// if we come across 0 we  want to alter it (so we alter also K-1 following values \\n        if(A[i] === 0 && i<A.length - K + 1) {\\n            for(let j = i; j< i + K; j++) {\\n                A[j] = +!A[j];\\n            }\\n            r++;\\n        }\\n\\t//we check if we are left with any 0. If so, then there is no valid combination and we can return 0\\n        if(A[i] === 0) return -1;\\n    }\\n    return r;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} A\\n * @param {number} K\\n * @return {number}\\n */\\nvar minKBitFlips = function(A, K) {\\n    let r = 0;\\n    for(let i = 0; i<A.length; i++) {\\n\\t// if we come across 0 we  want to alter it (so we alter also K-1 following values \\n        if(A[i] === 0 && i<A.length - K + 1) {\\n            for(let j = i; j< i + K; j++) {\\n                A[j] = +!A[j];\\n            }\\n            r++;\\n        }\\n\\t//we check if we are left with any 0. If so, then there is no valid combination and we can return 0\\n        if(A[i] === 0) return -1;\\n    }\\n    return r;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1151016,
                "title": "c-simple-solution-using-deque-with-comments-o-n-time-o-k-space",
                "content": "We use a deque to records the indexes where a flip is needed. When evaluating the the situation at i-th position, only the flips that with k -distance have impact.   \\n\\n~~~\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int> &a, int k) {\\n        int ret = 0;\\n        \\n        // holds the indexes at them a flip is needed\\n        deque<int> data;\\n        for (int i = 0; i < a.size(); ++i) {\\n            // phase out the the flips that have no\\n            // impact on i or further\\n            while (data.empty() == false && data.front() <= i - k) {\\n                data.pop_front();\\n            }\\n            \\n            if (i > a.size() - k) { // no flip is allowed (less that k spaces) \\n                if (data.size() % 2 == a[i]) return -1;\\n            } else if (data.size() % 2 == a[i]) {\\n                //  need a flip\\n                data.push_back(i);\\n                ++ret;\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n~~~",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minKBitFlips(vector<int> &a, int k) {\\n        int ret = 0;\\n        \\n        // holds the indexes at them a flip is needed\\n        deque<int> data;\\n        for (int i = 0; i < a.size(); ++i) {\\n            // phase out the the flips that have no\\n            // impact on i or further\\n            while (data.empty() == false && data.front() <= i - k) {\\n                data.pop_front();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1112206,
                "title": "easy-one",
                "content": "```\\n// pseudo-code\\n//     [----------------------------]\\n//         [-------]\\n//            [--------]\\n//               [---------]\\n              \\n// queue \\n//         check front of queue\\n//             queue pop\\n        \\n//         if queue size%2 and val is not okay\\n//             queue insert\\n//             flip++\\n        \\n        \\n        \\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& A, int K) {\\n        queue<int> flipIndex;\\n        int minFlips=0;\\n        int i;\\n        \\n        for(i=0;i<A.size();i++){\\n            if(!flipIndex.empty()&&flipIndex.front()+K<=i){\\n                flipIndex.pop();\\n            }\\n            if(A[i]==1&&flipIndex.size()%2==0||A[i]==0&&flipIndex.size()%2==1){\\n                continue;\\n            }\\n            minFlips++;\\n            flipIndex.push(i);    \\n        }\\n        if(!flipIndex.empty()&&flipIndex.front()+K<=i){\\n                flipIndex.pop();\\n        }\\n        \\n        if(flipIndex.empty()){\\n            return minFlips;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// pseudo-code\\n//     [----------------------------]\\n//         [-------]\\n//            [--------]\\n//               [---------]\\n              \\n// queue \\n//         check front of queue\\n//             queue pop\\n        \\n//         if queue size%2 and val is not okay\\n//             queue insert\\n//             flip++\\n        \\n        \\n        \\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& A, int K) {\\n        queue<int> flipIndex;\\n        int minFlips=0;\\n        int i;\\n        \\n        for(i=0;i<A.size();i++){\\n            if(!flipIndex.empty()&&flipIndex.front()+K<=i){\\n                flipIndex.pop();\\n            }\\n            if(A[i]==1&&flipIndex.size()%2==0||A[i]==0&&flipIndex.size()%2==1){\\n                continue;\\n            }\\n            minFlips++;\\n            flipIndex.push(i);    \\n        }\\n        if(!flipIndex.empty()&&flipIndex.front()+K<=i){\\n                flipIndex.pop();\\n        }\\n        \\n        if(flipIndex.empty()){\\n            return minFlips;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1072210,
                "title": "go-greedy",
                "content": "```\\nfunc minKBitFlips(nums []int, k int) int {\\n    var prefix = make([]int, len(nums) + 1);\\n    var cnt int = 0;\\n    var res int = 0;\\n    \\n    for i := 0; i < len(nums); i++ {\\n        cnt += prefix[i];\\n        num := (nums[i] + (cnt % 2)) % 2;\\n        if num == 0 {\\n            if i + k > len(nums) {return -1;}\\n            cnt++;\\n            res++;\\n            prefix[i + k]--;\\n        }\\n    }\\n    \\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc minKBitFlips(nums []int, k int) int {\\n    var prefix = make([]int, len(nums) + 1);\\n    var cnt int = 0;\\n    var res int = 0;\\n    \\n    for i := 0; i < len(nums); i++ {\\n        cnt += prefix[i];\\n        num := (nums[i] + (cnt % 2)) % 2;\\n        if num == 0 {\\n            if i + k > len(nums) {return -1;}\\n            cnt++;\\n            res++;\\n            prefix[i + k]--;\\n        }\\n    }\\n    \\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1025072,
                "title": "python-3-sliding-window",
                "content": "```\\ndef minKBitFlips(self, A: List[int], K: int) -> int:\\n        n = len(A)\\n        f = [0] * (n + 1)\\n        ans = 0\\n        cur = 0 \\n        for x in range(n - K + 1):\\n            cur += f[x]\\n            if (A[x] + cur) % 2 == 1:\\n                continue\\n            else:\\n                ans += 1\\n                cur += 1\\n                f[x + K] -= 1\\n        for idx in range(x + 1, n):\\n            cur += f[idx]\\n            if (A[idx] + cur) % 2 == 0:\\n                return -1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef minKBitFlips(self, A: List[int], K: int) -> int:\\n        n = len(A)\\n        f = [0] * (n + 1)\\n        ans = 0\\n        cur = 0 \\n        for x in range(n - K + 1):\\n            cur += f[x]\\n            if (A[x] + cur) % 2 == 1:\\n                continue\\n            else:\\n                ans += 1\\n                cur += 1\\n                f[x + K] -= 1\\n        for idx in range(x + 1, n):\\n            cur += f[idx]\\n            if (A[idx] + cur) % 2 == 0:\\n                return -1\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1023113,
                "title": "c-o-n-and-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int minKBitFlips(vector<int>& A, int k) {\\n        \\n        int n = A.size();\\n        int flip = 0,cnt = 0;\\n        \\n        for(int i=0;i<=A.size()-k;i++){\\n            if(A[i] > 1){\\n                A[i]-=2;\\n                flip--;\\n            }\\n            if((A[i] ^ flip & 1)) continue;\\n            cnt++;\\n            if(i + k < A.size()){\\n                A[i+k] += 2;\\n            }\\n            ++flip;\\n        }\\n        \\n        for(int i=A.size()-k+1;i<A.size();i++){\\n            if(A[i] > 1){\\n                A[i]-=2;\\n                flip--;\\n            }\\n            if((A[i] ^ flip & 1)) continue;\\n            return -1;\\n        }\\n        \\n        \\n        return cnt;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minKBitFlips(vector<int>& A, int k) {\\n        \\n        int n = A.size();\\n        int flip = 0,cnt = 0;\\n        \\n        for(int i=0;i<=A.size()-k;i++){\\n            if(A[i] > 1){\\n                A[i]-=2;\\n                flip--;\\n            }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565102,
                "content": [
                    {
                        "username": "kaiwensun",
                        "content": "## Greedy claim\\n\\n- before and after any flip, any bit in the sequence of 1 starting from the left-most bit should not be flipped anymore.\\n\\n---\\n## Proof by contradiction:\\n\\nThe _greedy claim_ gives a solution `S`. Without loss of generality, let the i-th bit be the first 0 bit. Suppose the _greedy claim_ above is false, then there must be a better (better means less flips) solution `S\\'` in which bits in range `[J , J + K - 1]` are flipped and `J < i`. There could be multiple `J`. Let `j` be the smallest possible `J`. Since `A[j]` now is 1 (why? because `j<i`), if we flip it, `A[j]` becomes 0. `A[j]` finally should be 1, so `S\\'` must flips `A[j]` again sometime later. As `j` is the smallest of `J`, `S\\'` can\\'t flip anything left to `A[j]`, which means only flipping the range `[j , j + K - 1]` can flip `A[j]` back to 1. See? we flipped `[j , j + K - 1]`, then again `[j , j + K - 1]`. `S\\'` wasts flips. If `S\\'` exists, we can find a third solution `S\\'\\'` that is strictly even better than `S\\'`. And we can do this induction infinitely and find a solution needs only 0 or even negative number of flips. -- That is of course impossible. Actually, the induction of finding even better solutions will eventually give you `S`. `S` is strictly better than `S`? Of course not!\\n-- So the _greedy claim_ above is NOT false.\\nSo, the _greedy claim_ is true.\\n\\n\\n---\\n## OK...I know I shouldn\\'t flip the left-most 1s. What should I flip next?\\nSo everything left to the i-th bit should not be flipped. But `A[i]` now is 0. `S` will flip it to 1 sometime. Since from then on `S` can\\'t flip anything left to `A[i]`, it must flip `A[i...i + K - 1]` to flip `A[i]`."
                    },
                    {
                        "username": "zhiying_qian",
                        "content": "At first glance, I came up with a dynamic programming idea. But sooner I found that it does not work. And then, intuitively, I realized that greedy seems to work in this problem. But I don\\'t know why. Would anyone please to explain this? Thanks!"
                    },
                    {
                        "username": "a_tough_man",
                        "content": "Problem feels medium."
                    },
                    {
                        "username": "user0724fL",
                        "content": "maybe because u are a_tough_man :/"
                    },
                    {
                        "username": "pansari",
                        "content": "I solved it but I am getting TLE. I am not able to understand how can I optimize it. "
                    },
                    {
                        "username": "Finesse",
                        "content": "A simple brute solution, where you actually flip `k` numbers each time, passes in Python when the `nums` array is represented as a big binary integer, and a full `k` range is flipped using a single bit-xor operation. The time is `O(n)`, but still fast enough."
                    },
                    {
                        "username": "adityakhare863",
                        "content": "how can i use big binary integer in c++?"
                    }
                ]
            },
            {
                "id": 1566108,
                "content": [
                    {
                        "username": "kaiwensun",
                        "content": "## Greedy claim\\n\\n- before and after any flip, any bit in the sequence of 1 starting from the left-most bit should not be flipped anymore.\\n\\n---\\n## Proof by contradiction:\\n\\nThe _greedy claim_ gives a solution `S`. Without loss of generality, let the i-th bit be the first 0 bit. Suppose the _greedy claim_ above is false, then there must be a better (better means less flips) solution `S\\'` in which bits in range `[J , J + K - 1]` are flipped and `J < i`. There could be multiple `J`. Let `j` be the smallest possible `J`. Since `A[j]` now is 1 (why? because `j<i`), if we flip it, `A[j]` becomes 0. `A[j]` finally should be 1, so `S\\'` must flips `A[j]` again sometime later. As `j` is the smallest of `J`, `S\\'` can\\'t flip anything left to `A[j]`, which means only flipping the range `[j , j + K - 1]` can flip `A[j]` back to 1. See? we flipped `[j , j + K - 1]`, then again `[j , j + K - 1]`. `S\\'` wasts flips. If `S\\'` exists, we can find a third solution `S\\'\\'` that is strictly even better than `S\\'`. And we can do this induction infinitely and find a solution needs only 0 or even negative number of flips. -- That is of course impossible. Actually, the induction of finding even better solutions will eventually give you `S`. `S` is strictly better than `S`? Of course not!\\n-- So the _greedy claim_ above is NOT false.\\nSo, the _greedy claim_ is true.\\n\\n\\n---\\n## OK...I know I shouldn\\'t flip the left-most 1s. What should I flip next?\\nSo everything left to the i-th bit should not be flipped. But `A[i]` now is 0. `S` will flip it to 1 sometime. Since from then on `S` can\\'t flip anything left to `A[i]`, it must flip `A[i...i + K - 1]` to flip `A[i]`."
                    },
                    {
                        "username": "zhiying_qian",
                        "content": "At first glance, I came up with a dynamic programming idea. But sooner I found that it does not work. And then, intuitively, I realized that greedy seems to work in this problem. But I don\\'t know why. Would anyone please to explain this? Thanks!"
                    },
                    {
                        "username": "a_tough_man",
                        "content": "Problem feels medium."
                    },
                    {
                        "username": "user0724fL",
                        "content": "maybe because u are a_tough_man :/"
                    },
                    {
                        "username": "pansari",
                        "content": "I solved it but I am getting TLE. I am not able to understand how can I optimize it. "
                    },
                    {
                        "username": "Finesse",
                        "content": "A simple brute solution, where you actually flip `k` numbers each time, passes in Python when the `nums` array is represented as a big binary integer, and a full `k` range is flipped using a single bit-xor operation. The time is `O(n)`, but still fast enough."
                    },
                    {
                        "username": "adityakhare863",
                        "content": "how can i use big binary integer in c++?"
                    }
                ]
            },
            {
                "id": 1794134,
                "content": [
                    {
                        "username": "kaiwensun",
                        "content": "## Greedy claim\\n\\n- before and after any flip, any bit in the sequence of 1 starting from the left-most bit should not be flipped anymore.\\n\\n---\\n## Proof by contradiction:\\n\\nThe _greedy claim_ gives a solution `S`. Without loss of generality, let the i-th bit be the first 0 bit. Suppose the _greedy claim_ above is false, then there must be a better (better means less flips) solution `S\\'` in which bits in range `[J , J + K - 1]` are flipped and `J < i`. There could be multiple `J`. Let `j` be the smallest possible `J`. Since `A[j]` now is 1 (why? because `j<i`), if we flip it, `A[j]` becomes 0. `A[j]` finally should be 1, so `S\\'` must flips `A[j]` again sometime later. As `j` is the smallest of `J`, `S\\'` can\\'t flip anything left to `A[j]`, which means only flipping the range `[j , j + K - 1]` can flip `A[j]` back to 1. See? we flipped `[j , j + K - 1]`, then again `[j , j + K - 1]`. `S\\'` wasts flips. If `S\\'` exists, we can find a third solution `S\\'\\'` that is strictly even better than `S\\'`. And we can do this induction infinitely and find a solution needs only 0 or even negative number of flips. -- That is of course impossible. Actually, the induction of finding even better solutions will eventually give you `S`. `S` is strictly better than `S`? Of course not!\\n-- So the _greedy claim_ above is NOT false.\\nSo, the _greedy claim_ is true.\\n\\n\\n---\\n## OK...I know I shouldn\\'t flip the left-most 1s. What should I flip next?\\nSo everything left to the i-th bit should not be flipped. But `A[i]` now is 0. `S` will flip it to 1 sometime. Since from then on `S` can\\'t flip anything left to `A[i]`, it must flip `A[i...i + K - 1]` to flip `A[i]`."
                    },
                    {
                        "username": "zhiying_qian",
                        "content": "At first glance, I came up with a dynamic programming idea. But sooner I found that it does not work. And then, intuitively, I realized that greedy seems to work in this problem. But I don\\'t know why. Would anyone please to explain this? Thanks!"
                    },
                    {
                        "username": "a_tough_man",
                        "content": "Problem feels medium."
                    },
                    {
                        "username": "user0724fL",
                        "content": "maybe because u are a_tough_man :/"
                    },
                    {
                        "username": "pansari",
                        "content": "I solved it but I am getting TLE. I am not able to understand how can I optimize it. "
                    },
                    {
                        "username": "Finesse",
                        "content": "A simple brute solution, where you actually flip `k` numbers each time, passes in Python when the `nums` array is represented as a big binary integer, and a full `k` range is flipped using a single bit-xor operation. The time is `O(n)`, but still fast enough."
                    },
                    {
                        "username": "adityakhare863",
                        "content": "how can i use big binary integer in c++?"
                    }
                ]
            },
            {
                "id": 2050720,
                "content": [
                    {
                        "username": "kaiwensun",
                        "content": "## Greedy claim\\n\\n- before and after any flip, any bit in the sequence of 1 starting from the left-most bit should not be flipped anymore.\\n\\n---\\n## Proof by contradiction:\\n\\nThe _greedy claim_ gives a solution `S`. Without loss of generality, let the i-th bit be the first 0 bit. Suppose the _greedy claim_ above is false, then there must be a better (better means less flips) solution `S\\'` in which bits in range `[J , J + K - 1]` are flipped and `J < i`. There could be multiple `J`. Let `j` be the smallest possible `J`. Since `A[j]` now is 1 (why? because `j<i`), if we flip it, `A[j]` becomes 0. `A[j]` finally should be 1, so `S\\'` must flips `A[j]` again sometime later. As `j` is the smallest of `J`, `S\\'` can\\'t flip anything left to `A[j]`, which means only flipping the range `[j , j + K - 1]` can flip `A[j]` back to 1. See? we flipped `[j , j + K - 1]`, then again `[j , j + K - 1]`. `S\\'` wasts flips. If `S\\'` exists, we can find a third solution `S\\'\\'` that is strictly even better than `S\\'`. And we can do this induction infinitely and find a solution needs only 0 or even negative number of flips. -- That is of course impossible. Actually, the induction of finding even better solutions will eventually give you `S`. `S` is strictly better than `S`? Of course not!\\n-- So the _greedy claim_ above is NOT false.\\nSo, the _greedy claim_ is true.\\n\\n\\n---\\n## OK...I know I shouldn\\'t flip the left-most 1s. What should I flip next?\\nSo everything left to the i-th bit should not be flipped. But `A[i]` now is 0. `S` will flip it to 1 sometime. Since from then on `S` can\\'t flip anything left to `A[i]`, it must flip `A[i...i + K - 1]` to flip `A[i]`."
                    },
                    {
                        "username": "zhiying_qian",
                        "content": "At first glance, I came up with a dynamic programming idea. But sooner I found that it does not work. And then, intuitively, I realized that greedy seems to work in this problem. But I don\\'t know why. Would anyone please to explain this? Thanks!"
                    },
                    {
                        "username": "a_tough_man",
                        "content": "Problem feels medium."
                    },
                    {
                        "username": "user0724fL",
                        "content": "maybe because u are a_tough_man :/"
                    },
                    {
                        "username": "pansari",
                        "content": "I solved it but I am getting TLE. I am not able to understand how can I optimize it. "
                    },
                    {
                        "username": "Finesse",
                        "content": "A simple brute solution, where you actually flip `k` numbers each time, passes in Python when the `nums` array is represented as a big binary integer, and a full `k` range is flipped using a single bit-xor operation. The time is `O(n)`, but still fast enough."
                    },
                    {
                        "username": "adityakhare863",
                        "content": "how can i use big binary integer in c++?"
                    }
                ]
            },
            {
                "id": 1856086,
                "content": [
                    {
                        "username": "kaiwensun",
                        "content": "## Greedy claim\\n\\n- before and after any flip, any bit in the sequence of 1 starting from the left-most bit should not be flipped anymore.\\n\\n---\\n## Proof by contradiction:\\n\\nThe _greedy claim_ gives a solution `S`. Without loss of generality, let the i-th bit be the first 0 bit. Suppose the _greedy claim_ above is false, then there must be a better (better means less flips) solution `S\\'` in which bits in range `[J , J + K - 1]` are flipped and `J < i`. There could be multiple `J`. Let `j` be the smallest possible `J`. Since `A[j]` now is 1 (why? because `j<i`), if we flip it, `A[j]` becomes 0. `A[j]` finally should be 1, so `S\\'` must flips `A[j]` again sometime later. As `j` is the smallest of `J`, `S\\'` can\\'t flip anything left to `A[j]`, which means only flipping the range `[j , j + K - 1]` can flip `A[j]` back to 1. See? we flipped `[j , j + K - 1]`, then again `[j , j + K - 1]`. `S\\'` wasts flips. If `S\\'` exists, we can find a third solution `S\\'\\'` that is strictly even better than `S\\'`. And we can do this induction infinitely and find a solution needs only 0 or even negative number of flips. -- That is of course impossible. Actually, the induction of finding even better solutions will eventually give you `S`. `S` is strictly better than `S`? Of course not!\\n-- So the _greedy claim_ above is NOT false.\\nSo, the _greedy claim_ is true.\\n\\n\\n---\\n## OK...I know I shouldn\\'t flip the left-most 1s. What should I flip next?\\nSo everything left to the i-th bit should not be flipped. But `A[i]` now is 0. `S` will flip it to 1 sometime. Since from then on `S` can\\'t flip anything left to `A[i]`, it must flip `A[i...i + K - 1]` to flip `A[i]`."
                    },
                    {
                        "username": "zhiying_qian",
                        "content": "At first glance, I came up with a dynamic programming idea. But sooner I found that it does not work. And then, intuitively, I realized that greedy seems to work in this problem. But I don\\'t know why. Would anyone please to explain this? Thanks!"
                    },
                    {
                        "username": "a_tough_man",
                        "content": "Problem feels medium."
                    },
                    {
                        "username": "user0724fL",
                        "content": "maybe because u are a_tough_man :/"
                    },
                    {
                        "username": "pansari",
                        "content": "I solved it but I am getting TLE. I am not able to understand how can I optimize it. "
                    },
                    {
                        "username": "Finesse",
                        "content": "A simple brute solution, where you actually flip `k` numbers each time, passes in Python when the `nums` array is represented as a big binary integer, and a full `k` range is flipped using a single bit-xor operation. The time is `O(n)`, but still fast enough."
                    },
                    {
                        "username": "adityakhare863",
                        "content": "how can i use big binary integer in c++?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Form Largest Integer With Digits That Add up to Target",
        "question_content": "<p>Given an array of integers <code>cost</code> and an integer <code>target</code>, return <em>the <strong>maximum</strong> integer you can paint under the following rules</em>:</p>\n\n<ul>\n\t<li>The cost of painting a digit <code>(i + 1)</code> is given by <code>cost[i]</code> (<strong>0-indexed</strong>).</li>\n\t<li>The total cost used must be equal to <code>target</code>.</li>\n\t<li>The integer does not have <code>0</code> digits.</li>\n</ul>\n\n<p>Since the answer may be very large, return it as a string. If there is no way to paint any integer given the condition, return <code>&quot;0&quot;</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> cost = [4,3,2,5,6,7,2,5,5], target = 9\n<strong>Output:</strong> &quot;7772&quot;\n<strong>Explanation:</strong> The cost to paint the digit &#39;7&#39; is 2, and the digit &#39;2&#39; is 3. Then cost(&quot;7772&quot;) = 2*3+ 3*1 = 9. You could also paint &quot;977&quot;, but &quot;7772&quot; is the largest number.\n<strong>Digit    cost</strong>\n  1  -&gt;   4\n  2  -&gt;   3\n  3  -&gt;   2\n  4  -&gt;   5\n  5  -&gt;   6\n  6  -&gt;   7\n  7  -&gt;   2\n  8  -&gt;   5\n  9  -&gt;   5\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> cost = [7,6,5,5,5,6,8,7,8], target = 12\n<strong>Output:</strong> &quot;85&quot;\n<strong>Explanation:</strong> The cost to paint the digit &#39;8&#39; is 7, and the digit &#39;5&#39; is 5. Then cost(&quot;85&quot;) = 7 + 5 = 12.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> cost = [2,4,6,2,4,6,4,4,4], target = 5\n<strong>Output:</strong> &quot;0&quot;\n<strong>Explanation:</strong> It is impossible to paint any integer with total cost equal to target.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>cost.length == 9</code></li>\n\t<li><code>1 &lt;= cost[i], target &lt;= 5000</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 654490,
                "title": "dp-is-easy-5-step-dp-thinking-process-explained",
                "content": "# DP is Easy!\\n*Disclaimer: I\\'m not writing optimal bottom up, tabulated DP here. For simplicity, I didn\\'t even memoize the code in this tutorial. My goal is to teach you how to THINK through these problems - not memorize.*\\n\\nToday I\\'ll show you in 4 simple steps why, DP is Easy! \\n\\n**DP Framework:**\\n```\\ndef dp(state variables):\\n\\t# base case\\n\\t# decision1, decision2 \\n\\t# return max(decision1, decision2)\\n```\\n\\n**Step 1. What type of DP problem can I frame this as?**\\nFirst I thought of optimization, because the problem asks us to find min or max. Next, I thought of knapsack because \"target\" or \"remain\" means knapsack to me. So 0/1 or unbounded? Well since we can choose element more than once, we know it\\'s unbounded. \\n\\nSo we know this problem is an optimization, unbounded knapsack problem. \\n\\n**Step 2. What are our state variables?**\\nThink about what we need to keep track of at every function call? Easy! The current number (aka `index`) and how much of the target value we have left (aka `remain`).\\n\\nNotes:\\n1. **Index:** We need a way to iterate over the numbers we are going to choose. Plus we can use this to check how much this number costs us.\\n2. **Remain:** We know that it\\'s important to keep track of how much cost we have incurred so far. We\\'ll use remaining to track how much cost we have left at this point in time. \\n\\nHonestly, as soon I realized this was 0/1 or unbounded knapsack I knew the state variables would be index and remain. This is just from repeated practice. Always remember, PRACTICE makes perfect.\\n\\nGreat. Now we know our function will look like\\n```\\ndef dp(index, remain):\\n\\t# base case\\n\\t# decision1,  decision2 \\n\\t# return max(decision1, decision2)\\n```\\n\\n**Step 3. What are our base cases?**\\nFor DP problems, we\\'ll need a case to catch a success AND failure. \\n\\n1. Success Case: `if remain == 0`\\n2. Failure Case: `if remain < 0 or index == len(costs)+1`\\n\\nNotes:\\n- **Success:** Our problem states our maximum optimal number MUST equal target. We keep track of that target state by using `remain`. So anytime remain == 0, we know our number is valid aka successful. \\n- **Fail #1:** Similarly, If the remaining target value is less than 0, we know FORSURE that the answer will never be valid because we can never \"gain\" remain. So we failed.\\n- **Fail #2:** Lastly, if we run out of numbers to see aka index ever becomes equal to 10, we know we have failed because our earlier success case of  `remain==0` didn\\'t return. \\n\\nSweet. So we know that our function will look like\\n\\n```\\ndef dp(index, remain):\\n\\t# base cases\\n\\tif target == 0:\\n\\t\\treturn Success \\n\\telif target < 0 or index == len(costs) + 1:\\n\\t\\treturn Failure \\n\\t# decision1, decision2 \\n\\t# return max(decision1, decision2) \\n```\\n\\n**Step 4. What are our decisions?**\\n1. Take this Number: `str(index) + dp(1, remain-cost[index-1])`\\n2. Continue to the next Number:  `dp(index+1, remain)`\\n \\nNotes:\\n- **Eliminate Infinite Recurision:** Notice, both of our decisions take us closer to either a fail/success base case.\\n- **Take:** There are a few things at play here. (1) We add the current number to our answer aka we choose it, (2) We subtract the cost of the number we just took from our remaining value, (3) We reset the index back to 1 in order to choose from the whole slate of 1-9 numbers again. \\n- **Continue:** This is a standard case. We simply increment the index aka try the next number. Because we didn\\'t \"take\" a number, we don\\'t edit our remaining value. \\n\\nAgain, practice makes perfect here. It\\'s standard knapsack framework to increment index and subtract from remain. \\n\\nNow our framework is done. \\n```\\ndef dp(index, remain):\\n\\t# base cases\\n\\tif target == 0:\\n\\t\\treturn Success \\n\\telif target < 0 or index == len(costs) + 1:\\n\\t\\treturn Failure \\n\\t\\t\\n\\t# decision1, decision2 \\n\\ttakeThisNumber = str(index) + dp(1, remain-cost[index-1])\\n\\tskipThisNumber = dp(index+1, remain)\\n\\t\\n\\t# return max(decision1, decision2) \\n\\treturn max(takeThisNumber, skipThisNumber) \\n```\\n\\n**Step 5. Code It**\\nYou\\'ve done all the work. It\\'s trivial to actually code the solution now. You can add a `self.memo={}` to optimize it. I\\'m keeping it simple and ignoring the memoization. It\\'s trivial as well. \\n\\nNote on the failure and success base cases. If there is a \\'0\\' in my answer, I know the answer is not valid. So any failure cases, I add \\'0\\' to the answer we are building. And on any success cases, I just add an empty string. It\\'s a bit convoluted but it\\'s the best I came up with after forgetting we can simply multiple the answer and add the current number. Oh well. Hope you enjoyed this! \\n```\\nclass Solution(object):\\n    def largestNumber(self, cost, target):\\n        ans = self.dfs(cost, 1, target)\\n        return ans if \\'0\\' not in ans else \\'0\\'\\n    \\n    def dfs(self, cost, index, remain):\\n\\t\\t# base cases\\n        if remain == 0:\\n            return \\'\\'\\n        elif remain < 0 or index == len(cost)+1:\\n            return \\'0\\'\\n        \\n\\t\\t# decisions \\n        take = str(index) + self.dfs(cost, 1, remain-cost[index-1]) \\n        skip = self.dfs(cost, index+1, remain) \\n\\t\\t\\n\\t\\t# memoize and return the max of decisions\\n        return self.getBigger(take, skip) \\n    \\n    def getBigger(self, num1, num2):\\n        if \\'0\\' in num2:\\n            return num1\\n        elif \\'0\\' in num1:\\n            return num2\\n        elif int(num1)>int(num2):\\n            return num1 \\n        else:\\n            return num2\\n\\n```",
                "solutionTags": [],
                "code": "```\\ndef dp(state variables):\\n\\t# base case\\n\\t# decision1, decision2 \\n\\t# return max(decision1, decision2)\\n```\n```\\ndef dp(index, remain):\\n\\t# base case\\n\\t# decision1,  decision2 \\n\\t# return max(decision1, decision2)\\n```\n```\\ndef dp(index, remain):\\n\\t# base cases\\n\\tif target == 0:\\n\\t\\treturn Success \\n\\telif target < 0 or index == len(costs) + 1:\\n\\t\\treturn Failure \\n\\t# decision1, decision2 \\n\\t# return max(decision1, decision2) \\n```\n```\\ndef dp(index, remain):\\n\\t# base cases\\n\\tif target == 0:\\n\\t\\treturn Success \\n\\telif target < 0 or index == len(costs) + 1:\\n\\t\\treturn Failure \\n\\t\\t\\n\\t# decision1, decision2 \\n\\ttakeThisNumber = str(index) + dp(1, remain-cost[index-1])\\n\\tskipThisNumber = dp(index+1, remain)\\n\\t\\n\\t# return max(decision1, decision2) \\n\\treturn max(takeThisNumber, skipThisNumber) \\n```\n```\\nclass Solution(object):\\n    def largestNumber(self, cost, target):\\n        ans = self.dfs(cost, 1, target)\\n        return ans if \\'0\\' not in ans else \\'0\\'\\n    \\n    def dfs(self, cost, index, remain):\\n\\t\\t# base cases\\n        if remain == 0:\\n            return \\'\\'\\n        elif remain < 0 or index == len(cost)+1:\\n            return \\'0\\'\\n        \\n\\t\\t# decisions \\n        take = str(index) + self.dfs(cost, 1, remain-cost[index-1]) \\n        skip = self.dfs(cost, index+1, remain) \\n\\t\\t\\n\\t\\t# memoize and return the max of decisions\\n        return self.getBigger(take, skip) \\n    \\n    def getBigger(self, num1, num2):\\n        if \\'0\\' in num2:\\n            return num1\\n        elif \\'0\\' in num1:\\n            return num2\\n        elif int(num1)>int(num2):\\n            return num1 \\n        else:\\n            return num2\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 635267,
                "title": "c-java-python-strict-o-target",
                "content": "I was asked if any solution in linear time.\\nWell, I didn\\'t see any strict linear time solutions.\\nSo I\\'ll add this one myself.\\n\\n\\n# Solution 1\\nTake all value as 1 first.\\nWe find out how many digits we can get.\\nTime strict `O(target)`\\nSpace `O(target)`\\n\\n**Java**\\n```java\\n    public String largestNumber(int[] cost, int target) {\\n        int[] dp = new int[target + 1];\\n        for (int t = 1; t <= target; ++t) {\\n            dp[t] = -10000;\\n            for (int i = 0; i < 9; ++i) {\\n                if (t >= cost[i])\\n                    dp[t] = Math.max(dp[t], 1 + dp[t - cost[i]]);\\n            }\\n        }\\n        if (dp[target] < 0) return \"0\";\\n        StringBuilder res = new StringBuilder();\\n        for (int i = 8; i >= 0; --i) {\\n            while (target >= cost[i] && dp[target] == dp[target - cost[i]] + 1) {\\n                res.append(1 + i);\\n                target -= cost[i];\\n            }\\n        }\\n        return res.toString();\\n    }\\n```\\n**C++**\\n```cpp\\n    string largestNumber(vector<int>& cost, int target) {\\n        vector<int> dp(target + 1, -10000);\\n        dp[0] = 0;\\n        for (int t = 1; t <= target; ++t) {\\n            for (int i = 0; i < 9; ++i) {\\n                dp[t] = max(dp[t], t >= cost[i] ? 1 + dp[t - cost[i]] : -10000);\\n            }\\n        }\\n        if (dp[target] < 0) return \"0\";\\n        string res = \"\";\\n        for (int i = 8; i >= 0; --i) {\\n            while (target >= cost[i] && dp[target] == dp[target - cost[i]] + 1) {\\n                res.push_back(\\'1\\' + i);\\n                target -= cost[i];\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n# Solution 2\\nVery standard Knapsack problem.\\nSome black magic here:\\n1. I initial the impossible number with -1,\\nso that the all imporssible negative value will be impossible.\\n2. We can always add the digit to tail.\\nBecause we already add the bigger digits first.\\n\\n**Python:**\\n```py\\n    def largestNumber(self, cost, target):\\n        dp = [0] + [-1] * (target + 5000)\\n        for t in xrange(1, target + 1):\\n            dp[t] = max(dp[t - c] * 10 + i + 1 for i, c in enumerate(cost))\\n        return str(max(dp[t], 0))\\n```\\n<br>",
                "solutionTags": [],
                "code": "```java\\n    public String largestNumber(int[] cost, int target) {\\n        int[] dp = new int[target + 1];\\n        for (int t = 1; t <= target; ++t) {\\n            dp[t] = -10000;\\n            for (int i = 0; i < 9; ++i) {\\n                if (t >= cost[i])\\n                    dp[t] = Math.max(dp[t], 1 + dp[t - cost[i]]);\\n            }\\n        }\\n        if (dp[target] < 0) return \"0\";\\n        StringBuilder res = new StringBuilder();\\n        for (int i = 8; i >= 0; --i) {\\n            while (target >= cost[i] && dp[target] == dp[target - cost[i]] + 1) {\\n                res.append(1 + i);\\n                target -= cost[i];\\n            }\\n        }\\n        return res.toString();\\n    }\\n```\n```cpp\\n    string largestNumber(vector<int>& cost, int target) {\\n        vector<int> dp(target + 1, -10000);\\n        dp[0] = 0;\\n        for (int t = 1; t <= target; ++t) {\\n            for (int i = 0; i < 9; ++i) {\\n                dp[t] = max(dp[t], t >= cost[i] ? 1 + dp[t - cost[i]] : -10000);\\n            }\\n        }\\n        if (dp[target] < 0) return \"0\";\\n        string res = \"\";\\n        for (int i = 8; i >= 0; --i) {\\n            while (target >= cost[i] && dp[target] == dp[target - cost[i]] + 1) {\\n                res.push_back(\\'1\\' + i);\\n                target -= cost[i];\\n            }\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def largestNumber(self, cost, target):\\n        dp = [0] + [-1] * (target + 5000)\\n        for t in xrange(1, target + 1):\\n            dp[t] = max(dp[t - c] * 10 + i + 1 for i, c in enumerate(cost))\\n        return str(max(dp[t], 0))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 635389,
                "title": "java-top-down-dp-greedy-clean-code-o-9-target",
                "content": "**Idea**\\n- Use `dp` approach to find possible answers with `maxLength`\\n- In our `dp`, we greedy from `d = 9..1`, so the first `maxLength` number will be the bigger number overall.\\n\\n**Solution 1: Create New Strings (Straightforward)**\\n```java\\nclass Solution {\\n    public String largestNumber(int[] cost, int target) {\\n        String[] dp = new String[target + 1];\\n        return dfs(cost, target, dp);\\n    }\\n    String dfs(int[] cost, int target, String[] dp) {\\n        if (target < 0) return \"0\"; // not found\\n        if (target == 0) return \"\";\\n        if (dp[target] != null) return dp[target];\\n        String ans = \"0\";\\n        for(int d = 9; d >= 1; d--) {\\n            String curr = dfs(cost, target - cost[d - 1], dp);\\n            if (curr.equals(\"0\")) continue; // skip if can\\'t solve sub-problem\\n            curr = d + curr;\\n            if (ans.equals(\"0\") || curr.length() > ans.length()) {\\n                ans = curr;\\n            }\\n        }\\n        return dp[target] = ans;\\n    }\\n}\\n```\\n**Complexity**\\n- Time: `O(9 * target^2)`, the time for creating new string in line `curr = d + curr;` can cost up to `O(target)`\\n- Space: `O(target^2)`, because we store total `target` strings, each string up to `target` chars.\\n\\n**Solution 2: Use Trace Array (Optimized) ~ 4ms**\\n```java\\nclass Solution {\\n    public String largestNumber(int[] cost, int target) {\\n        Integer[] dp = new Integer[target + 1];\\n        Integer[] trace = new Integer[target + 1];\\n        int ans = dfs(cost, target, dp, trace);\\n        if (ans <= 0) return \"0\";\\n        StringBuilder sb = new StringBuilder();\\n        while (target > 0) { // trace back to get the result\\n            sb.append(trace[target]);\\n            target -= cost[trace[target] - 1];\\n        }\\n        return sb.toString();\\n    }\\n    int dfs(int[] cost, int target, Integer[] dp, Integer[] trace) {\\n        if (target < 0) return -1; // not found\\n        if (target == 0) return 0;\\n        if (dp[target] != null) return dp[target];\\n        int ans = -1;\\n        for(int d = 9; d >= 1; d--) {\\n            int curr = dfs(cost, target - cost[d - 1], dp, trace);\\n            if (curr == -1) continue; // skip if can\\'t solve sub-problem\\n            if (curr + 1 > ans) {\\n                ans = curr + 1;\\n                trace[target] = d;\\n            }\\n        }\\n        return dp[target] = ans;\\n    }\\n}\\n```\\n**Complexity**\\n- Time: `O(9 * target)`\\n- Space: `O(target)`",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public String largestNumber(int[] cost, int target) {\\n        String[] dp = new String[target + 1];\\n        return dfs(cost, target, dp);\\n    }\\n    String dfs(int[] cost, int target, String[] dp) {\\n        if (target < 0) return \"0\"; // not found\\n        if (target == 0) return \"\";\\n        if (dp[target] != null) return dp[target];\\n        String ans = \"0\";\\n        for(int d = 9; d >= 1; d--) {\\n            String curr = dfs(cost, target - cost[d - 1], dp);\\n            if (curr.equals(\"0\")) continue; // skip if can\\'t solve sub-problem\\n            curr = d + curr;\\n            if (ans.equals(\"0\") || curr.length() > ans.length()) {\\n                ans = curr;\\n            }\\n        }\\n        return dp[target] = ans;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public String largestNumber(int[] cost, int target) {\\n        Integer[] dp = new Integer[target + 1];\\n        Integer[] trace = new Integer[target + 1];\\n        int ans = dfs(cost, target, dp, trace);\\n        if (ans <= 0) return \"0\";\\n        StringBuilder sb = new StringBuilder();\\n        while (target > 0) { // trace back to get the result\\n            sb.append(trace[target]);\\n            target -= cost[trace[target] - 1];\\n        }\\n        return sb.toString();\\n    }\\n    int dfs(int[] cost, int target, Integer[] dp, Integer[] trace) {\\n        if (target < 0) return -1; // not found\\n        if (target == 0) return 0;\\n        if (dp[target] != null) return dp[target];\\n        int ans = -1;\\n        for(int d = 9; d >= 1; d--) {\\n            int curr = dfs(cost, target - cost[d - 1], dp, trace);\\n            if (curr == -1) continue; // skip if can\\'t solve sub-problem\\n            if (curr + 1 > ans) {\\n                ans = curr + 1;\\n                trace[target] = d;\\n            }\\n        }\\n        return dp[target] = ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 635190,
                "title": "c-top-down-bottom-up-o-n",
                "content": "The first solution - top-down DP with memoisation - is the easiest to come up with, so I used it in the contest. After you figured it out, that solution can be converted to bottom-up tabulation.\\n\\nThe bottom-up solution is still O(n ^ 2), because we build *n* strings, and a string can be up to *n* characters.\\n\\nSo, for O(n) solution below, I used a vector that tracks the current character, and the size of the string. In the end, we can construct the final string by back-tracking.\\n\\n**Top-Down**\\n```cpp\\nstring dp[5001] = {};\\nstring largestNumber(vector<int>& cost, int t) {\\n    if (t <= 0)\\n        return t == 0 ? \"\" : \"0\";\\n    if (dp[t].empty()) {\\n        dp[t] = \"0\";\\n        for (int n = 1; n <= 9; ++n) {\\n            auto res = largestNumber(cost, t - cost[n - 1]);\\n            if (res != \"0\" && res.size() + 1 >= dp[t].size())\\n                dp[t] = to_string(n) + res;\\n        }\\n    }\\n    return dp[t];\\n}\\n```\\n**Bottom-Up**\\n```cpp\\nstring largestNumber(vector<int>& cost, int t) {\\n    vector<string> dp(t + 1, \"0\");\\n    dp[t] = \"\";\\n    for (int i = t - 1; i >= 0; --i) {\\n        for (int n = 1; n <= 9; ++n) {\\n            int val = i + cost[n - 1];\\n            if (val <= t && dp[val] != \"0\")\\n                if (dp[val].size() + 1 >= dp[i].size())\\n                    dp[i] = to_string(n) + dp[val];\\n        }\\n    }\\n    return dp[0];\\n}\\n```\\n**O(n)**\\n```cpp\\nstring largestNumber(vector<int>& cost, int t) {\\n    vector<pair<int, int>> dp(t + 1);\\n    dp[t].second = 1;\\n    for (int i = t - 1; i >= 0; --i)\\n        for (int n = 0; n <= 8; ++n) {\\n            int val = i + cost[n];\\n            if (val <= t && dp[val].second != 0)\\n                if (dp[val].second + 1 >= dp[i].second)\\n                    dp[i] = { n, dp[val].second + 1};\\n        }\\n    if (dp[0].second == 0)\\n        return \"0\";\\n    string res;\\n    for (auto i = 0; i < t; i += cost[dp[i].first])\\n        res.push_back(dp[i].first + \\'1\\');\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nstring dp[5001] = {};\\nstring largestNumber(vector<int>& cost, int t) {\\n    if (t <= 0)\\n        return t == 0 ? \"\" : \"0\";\\n    if (dp[t].empty()) {\\n        dp[t] = \"0\";\\n        for (int n = 1; n <= 9; ++n) {\\n            auto res = largestNumber(cost, t - cost[n - 1]);\\n            if (res != \"0\" && res.size() + 1 >= dp[t].size())\\n                dp[t] = to_string(n) + res;\\n        }\\n    }\\n    return dp[t];\\n}\\n```\n```cpp\\nstring largestNumber(vector<int>& cost, int t) {\\n    vector<string> dp(t + 1, \"0\");\\n    dp[t] = \"\";\\n    for (int i = t - 1; i >= 0; --i) {\\n        for (int n = 1; n <= 9; ++n) {\\n            int val = i + cost[n - 1];\\n            if (val <= t && dp[val] != \"0\")\\n                if (dp[val].size() + 1 >= dp[i].size())\\n                    dp[i] = to_string(n) + dp[val];\\n        }\\n    }\\n    return dp[0];\\n}\\n```\n```cpp\\nstring largestNumber(vector<int>& cost, int t) {\\n    vector<pair<int, int>> dp(t + 1);\\n    dp[t].second = 1;\\n    for (int i = t - 1; i >= 0; --i)\\n        for (int n = 0; n <= 8; ++n) {\\n            int val = i + cost[n];\\n            if (val <= t && dp[val].second != 0)\\n                if (dp[val].second + 1 >= dp[i].second)\\n                    dp[i] = { n, dp[val].second + 1};\\n        }\\n    if (dp[0].second == 0)\\n        return \"0\";\\n    string res;\\n    for (auto i = 0; i < t; i += cost[dp[i].first])\\n        res.push_back(dp[i].first + \\'1\\');\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 635189,
                "title": "c-dp-with-explanation",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n## Solution 1. DP\\n\\nThis is a typical knapsack problem.\\n\\nLet `dp[i + 1][c]` be the maximum string we can form using digits from `1` to `i + 1` and exactly `c` cost.\\n\\nFor `dp[i + 1][c]`, we have the following options:\\n* Don\\'t use digit `i + 1`. we get `dp[i][c]`.\\n* Use digit `i + 1` once, we get `string(1, \\'1\\' + i) + dp[i][c - A[i]]`\\n* Use digit `i + 1` twice, we get `string(2, \\'1\\' + i) + dp[i][c - 2 * A[i]]`.\\n* ...\\n* Use digit `i + 1` `k` times, we get `string(k, \\'1\\' + i) + dp[i][c - k * A[i]]`, where `k` is the maximum number satisfying `c - k * A[i] >= 0`.\\n\\nSo we have:\\n```\\ndp[i + 1][c] = max(\\n                    dp[i][c],\\n                    string(1, \\'1\\'+i) + dp[i][c - A[i]],\\n                    string(2, \\'1\\'+i) + dp[i][c - 2 * A[i]],\\n                    ...\\n                    string(k, \\'1\\'+i) + dp[i][c - k * A[i]]\\n)\\ndp[i][0] = \"\"\\n```\\n\\nTo get `dp[i + 1][c]`, the time complexity above is `O(k)`.\\n\\nWe can optimize it using `dp[i + 1][c - A[i]]` since:\\n\\n```\\ndp[i + 1][c - A[i]] = max(\\n                    dp[i][c - A[i]],\\n                    string(1, \\'1\\'+i) + dp[i][c - 2 * A[i]],\\n                    ...\\n                    string(k-1, \\'1\\'+i) + dp[i][c - k * A[i]]\\n)\\n```\\n\\nSo\\n```\\ndp[i + 1][c] = max(\\n                dp[i][c],\\n                string(1, \\'1\\'+i) + dp[i + 1][c - A[i]]\\n)\\n```\\n\\nNow we reduce the time complexity of getting `dp[i + 1][c]` to `O(1)`.\\n\\nSince `N` is just `9`, so both the time and space complexities are `O(T)`.\\n\\nNote that in implementation, we initialize `dp` in this way:\\n* `dp[i][0] = \"\"`. When `c` is `0`, `\"\"` is a valid string that we can get out of it.\\n* `dp[i][c] = \"0\"` where `c != 0`. We use `\"0\"` as a invalid string because we can\\'t use `\\'0\\'` in the integer.\\n\\nSo `dp[i + 1][c - A[i]] == \"0\"` means that we can\\'t form a valid string using digits from `1` to `i+1` with cost `c - A[i]`, and thus we can\\'t add digit `i+1` in front of `dp[i + 1][c - A[i]]`.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/form-largest-integer-with-digits-that-add-up-to-target/\\n// Author: github.com/lzl124631x\\n// Time: O(T)\\n// Space: O(T)\\nclass Solution {\\n    inline bool isGreaterThan(string &a, string &b) {\\n        return a.size() != b.size() ? a.size() > b.size() : a > b;\\n    }\\npublic:\\n    string largestNumber(vector<int>& A, int T) {\\n        int N = A.size();\\n        vector<vector<string>> dp(N + 1, vector<string>(T + 1, \"0\"));\\n        for (int i = 0; i <= N; ++i) dp[i][0] = \"\";\\n        for (int i = 0; i < N; ++i) {\\n            for (int c = 1; c <= T; ++c) {\\n                dp[i + 1][c] = dp[i][c];\\n                if (c < A[i] || dp[i + 1][c - A[i]] == \"0\") continue;\\n                auto s = string(1, \\'1\\' + i) + dp[i + 1][c - A[i]];\\n                if (isGreaterThan(s, dp[i + 1][c])) dp[i + 1][c] = s;\\n            }\\n        }\\n        return dp[N][T];\\n    }\\n};\\n```\\n\\n## Solution 2. DP\\n\\nSince `dp[i + 1][c]` is only dependent on `dp[i][c]` and `dp[i + 1][c - A[i]]`, we can further reduce the size of the `dp` array from `N * T` to `1 * T`.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/form-largest-integer-with-digits-that-add-up-to-target\\n// Author: github.com/lzl124631x\\n// Time: O(T)\\n// Space: O(T)\\nclass Solution {\\n    inline bool isGreaterThan(string &a, string &b) {\\n        return a.size() != b.size() ? a.size() > b.size() : a > b;\\n    }\\npublic:\\n    string largestNumber(vector<int>& A, int T) {\\n        int N = A.size();\\n        vector<string> dp(T + 1, \"0\");\\n        dp[0] = \"\";\\n        for (int i = 0; i < N; ++i) {\\n            for (int c = 1; c <= T; ++c) {\\n                if (c < A[i] || dp[c - A[i]] == \"0\") continue;\\n                auto s = string(1, \\'1\\' + i) + dp[c - A[i]];\\n                if (isGreaterThan(s, dp[c])) dp[c] = s;\\n            }\\n        }\\n        return dp[T];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ndp[i + 1][c] = max(\\n                    dp[i][c],\\n                    string(1, \\'1\\'+i) + dp[i][c - A[i]],\\n                    string(2, \\'1\\'+i) + dp[i][c - 2 * A[i]],\\n                    ...\\n                    string(k, \\'1\\'+i) + dp[i][c - k * A[i]]\\n)\\ndp[i][0] = \"\"\\n```\n```\\ndp[i + 1][c - A[i]] = max(\\n                    dp[i][c - A[i]],\\n                    string(1, \\'1\\'+i) + dp[i][c - 2 * A[i]],\\n                    ...\\n                    string(k-1, \\'1\\'+i) + dp[i][c - k * A[i]]\\n)\\n```\n```\\ndp[i + 1][c] = max(\\n                dp[i][c],\\n                string(1, \\'1\\'+i) + dp[i + 1][c - A[i]]\\n)\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/form-largest-integer-with-digits-that-add-up-to-target/\\n// Author: github.com/lzl124631x\\n// Time: O(T)\\n// Space: O(T)\\nclass Solution {\\n    inline bool isGreaterThan(string &a, string &b) {\\n        return a.size() != b.size() ? a.size() > b.size() : a > b;\\n    }\\npublic:\\n    string largestNumber(vector<int>& A, int T) {\\n        int N = A.size();\\n        vector<vector<string>> dp(N + 1, vector<string>(T + 1, \"0\"));\\n        for (int i = 0; i <= N; ++i) dp[i][0] = \"\";\\n        for (int i = 0; i < N; ++i) {\\n            for (int c = 1; c <= T; ++c) {\\n                dp[i + 1][c] = dp[i][c];\\n                if (c < A[i] || dp[i + 1][c - A[i]] == \"0\") continue;\\n                auto s = string(1, \\'1\\' + i) + dp[i + 1][c - A[i]];\\n                if (isGreaterThan(s, dp[i + 1][c])) dp[i + 1][c] = s;\\n            }\\n        }\\n        return dp[N][T];\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/form-largest-integer-with-digits-that-add-up-to-target\\n// Author: github.com/lzl124631x\\n// Time: O(T)\\n// Space: O(T)\\nclass Solution {\\n    inline bool isGreaterThan(string &a, string &b) {\\n        return a.size() != b.size() ? a.size() > b.size() : a > b;\\n    }\\npublic:\\n    string largestNumber(vector<int>& A, int T) {\\n        int N = A.size();\\n        vector<string> dp(T + 1, \"0\");\\n        dp[0] = \"\";\\n        for (int i = 0; i < N; ++i) {\\n            for (int c = 1; c <= T; ++c) {\\n                if (c < A[i] || dp[c - A[i]] == \"0\") continue;\\n                auto s = string(1, \\'1\\' + i) + dp[c - A[i]];\\n                if (isGreaterThan(s, dp[c])) dp[c] = s;\\n            }\\n        }\\n        return dp[T];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 635227,
                "title": "java-recursion-memoization-dp",
                "content": "```\\nclass Solution {\\n    public static String func(int[] cost, int target, String[] dp) {\\n        if(target == 0) return \"\";\\n        if(dp[target] != null) return dp[target];\\n        String max = \"0\";\\n        for(int i = 0; i < 9; i++) {\\n            if(target >= cost[i]) {\\n                String curr = func(cost, target - cost[i], dp);\\n                if(curr.equals(\"0\")) continue;\\n                curr = Integer.toString(i + 1) + curr;\\n                if(max.length() > curr.length()) continue;\\n                if(max.equals(\"0\") || curr.length() > max.length() || curr.length() == max.length() && max.compareTo(curr) < 0) max = curr;\\n            }\\n        }\\n        return dp[target] = max;\\n    }\\n    public String largestNumber(int[] cost, int target) {\\n        String[] dp = new String[target + 1];\\n        return func(cost, target, dp);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public static String func(int[] cost, int target, String[] dp) {\\n        if(target == 0) return \"\";\\n        if(dp[target] != null) return dp[target];\\n        String max = \"0\";\\n        for(int i = 0; i < 9; i++) {\\n            if(target >= cost[i]) {\\n                String curr = func(cost, target - cost[i], dp);\\n                if(curr.equals(\"0\")) continue;\\n                curr = Integer.toString(i + 1) + curr;\\n                if(max.length() > curr.length()) continue;\\n                if(max.equals(\"0\") || curr.length() > max.length() || curr.length() == max.length() && max.compareTo(curr) < 0) max = curr;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 635445,
                "title": "java-dynamic-programming-recursion-memoisation-easy-to-understand",
                "content": "\\nThe most simple way to go about doing this problem is to find all possible combinations that can be formed using a target number and a certain digit at hand. We should be asking the question thet if I use a digit D in the ans, then will the remaining target fetch me the largest possible number? \\n\\nSo, we now establish a base question - Given a number - target - what is the maximum number that we can derive out of it. So, we will consider all diigits from 1 to 9 and for each digit, we try to find if digit+find(target - cost[digit]) will be maximum or not!\\n\\nWe use a simple array to memoise. Thus dp[i] = maximum number that we can get from using i as the target.\\n\\n\\n\\n```\\n\\nclass Solution {\\n    \\n    String[] dp ;\\n    \\n    public String largestNumber(int[] cost, int target) {\\n        \\n\\t\\tdp = new String[target+1]; //string dp array to help us memoise\\n        \\n        find(cost, target);\\n\\n        return dp[target] == \"\"?\"0\":dp[target]; // we check if the answer is \"\" then no string could be found\\n    }\\n    \\n    public String find(int[] cost, int target){\\n\\n        if (target == 0) return \"\"; // base case. If target becomes 0, then it is possible to form a number\\n\\n        if (dp[target]!=null) return dp[target]; // memoisation to make the algorithm faster\\n        \\n        String curr = \"0\"; // base string\\n        for(int i = 8; i >= 0; i--){ // note that we loop backwards, thus any number formed is the maximum possible number of that length\\n            \\n            if (target - cost[i] >= 0){ // we only try to add the digit if its possible to choose from the cost array\\n                String x = find(cost, target - cost[i]); // this return the maximum number that can be formed using the remaing target once we have choosen digit d\\n                if (x.equals(\"0\")) continue; // if 0 is returned that means we couldnot form a number\\n                x = String.valueOf((i+1))+x;\\n                \\n                if(curr.equals(\"0\") || x.length() > curr.length()) curr = x; // we make sure we choose that digit which forms the largest number\\n                                \\n            }\\n        }\\n        \\n        dp[target] = curr; //store in dp array\\n        return dp[target];\\n    }\\n}\\n\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    \\n    String[] dp ;\\n    \\n    public String largestNumber(int[] cost, int target) {\\n        \\n\\t\\tdp = new String[target+1]; //string dp array to help us memoise\\n        \\n        find(cost, target);\\n\\n        return dp[target] == \"\"?\"0\":dp[target]; // we check if the answer is \"\" then no string could be found\\n    }\\n    \\n    public String find(int[] cost, int target){\\n\\n        if (target == 0) return \"\"; // base case. If target becomes 0, then it is possible to form a number\\n\\n        if (dp[target]!=null) return dp[target]; // memoisation to make the algorithm faster\\n        \\n        String curr = \"0\"; // base string\\n        for(int i = 8; i >= 0; i--){ // note that we loop backwards, thus any number formed is the maximum possible number of that length\\n            \\n            if (target - cost[i] >= 0){ // we only try to add the digit if its possible to choose from the cost array\\n                String x = find(cost, target - cost[i]); // this return the maximum number that can be formed using the remaing target once we have choosen digit d\\n                if (x.equals(\"0\")) continue; // if 0 is returned that means we couldnot form a number\\n                x = String.valueOf((i+1))+x;\\n                \\n                if(curr.equals(\"0\") || x.length() > curr.length()) curr = x; // we make sure we choose that digit which forms the largest number\\n                                \\n            }\\n        }\\n        \\n        dp[target] = curr; //store in dp array\\n        return dp[target];\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1265319,
                "title": "c-memoization-code-unbounded-knapsack-logic",
                "content": "C++ Memoization Code [Unbounded Knapsack Logic]\\nidea taken from - https://leetcode.com/problems/form-largest-integer-with-digits-that-add-up-to-target/discuss/654490/DP-is-Easy!-5-Step-DP-THINKING-process-EXPLAINED! \\n```\\nclass Solution {\\n    public:\\n    string largestNumber(vector<int>& cost, int target) {\\n        int n = cost.size();\\n        vector<vector<string>> dp(n + 1, vector<string>(target + 1, \"-1\"));\\n        return dfs(cost, 0, target, dp);\\n    }\\n    string dfs(vector<int>& cost, int idx, int target, vector<vector<string>>& dp) {\\n        if (target == 0) return \"\";                        // success\\n        if (target < 0 || idx == cost.size()) return \"0\";  // failure\\n\\n        if (dp[idx][target] != \"-1\") return dp[idx][target];\\n\\n        string includes = to_string(idx + 1) + dfs(cost, 0, target - cost[idx], dp);\\n        string excludes = dfs(cost, idx + 1, target, dp);\\n\\n        return dp[idx][target] = getBigger(includes, excludes);\\n    }\\n    string getBigger(string& s1, string& s2) {\\n        string t = \"0\";\\n        // https://stackoverflow.com/questions/2340281/check-if-a-string-contains-a-string-in-c\\n        if (s1.find(t) != std::string::npos) return s2;\\n        if (s2.find(t) != std::string::npos) return s1;\\n        if (s1.length() > s2.length())\\n            return s1;\\n        else\\n            return s2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public:\\n    string largestNumber(vector<int>& cost, int target) {\\n        int n = cost.size();\\n        vector<vector<string>> dp(n + 1, vector<string>(target + 1, \"-1\"));\\n        return dfs(cost, 0, target, dp);\\n    }\\n    string dfs(vector<int>& cost, int idx, int target, vector<vector<string>>& dp) {\\n        if (target == 0) return \"\";                        // success\\n        if (target < 0 || idx == cost.size()) return \"0\";  // failure\\n\\n        if (dp[idx][target] != \"-1\") return dp[idx][target];\\n\\n        string includes = to_string(idx + 1) + dfs(cost, 0, target - cost[idx], dp);\\n        string excludes = dfs(cost, idx + 1, target, dp);\\n\\n        return dp[idx][target] = getBigger(includes, excludes);\\n    }\\n    string getBigger(string& s1, string& s2) {\\n        string t = \"0\";\\n        // https://stackoverflow.com/questions/2340281/check-if-a-string-contains-a-string-in-c\\n        if (s1.find(t) != std::string::npos) return s2;\\n        if (s2.find(t) != std::string::npos) return s1;\\n        if (s1.length() > s2.length())\\n            return s1;\\n        else\\n            return s2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 635266,
                "title": "python-dp-topdown-with-memoization-solution-o-target-time-and-space",
                "content": "\\nPython DP topdown with memoization solution O(target) time and space\\n\\n\\nlet C[t] be the largest integer can be formed for target t.\\nC[0] = 0 (all costs are bigger than 0 so there is no way to form any digit with cost 0)\\nC[t] = max( {10*C[t-cost[d]] + d | d is a digit between 1 and 9, t-cost[d] >= 0 } )\\n\\nExplanation: if you want to calculate the largest number for target t, try using any of the digits.\\n    When you use the digit d you pay cost[d] (it\\'s actually cost[d-1] because it\\'s 0-index but for the explanation let\\'s say it\\'s cost[d]).\\n    So you check what\\'s the best digit to use, and choose it.\\n\\n\\n```\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        self.d = {}\\n        def top_down(t):\\n            if t == 0: return 0\\n            if t in self.d: return self.d[t]\\n            cur = float(\\'-inf\\')\\n            for digit in range(1,10):\\n                if (t-cost[digit-1]) >= 0:\\n                    cur = max(cur, top_down(t-cost[digit-1])*10+digit)\\n            self.d[t] = cur\\n            return cur\\n\\n        res = top_down(target)\\n        return str(res) if res != float(\\'-inf\\') else \"0\"\\n\\n```\\n\\nLast note about overflow:\\n\\nHere i\\'m using 10*<prev_biggest> + <current_digit>. The number can overflow.\\nNot in python though :) That\\'s an other reason to choose python.\\nBut if you choose an other language with overflow possible, can just use a different comparison method and store the biggest one in an array.\\nso the comperator function should just be one that knows how to compare two integers with array representation.\\n\\n\\nTo handle this, (the fact that the resulting number can be big) we can just remember at each C[t] the number of digits of the last integer possible with target=t. This information is actually enough to reconstruct the integer after computing the DP array. It requires a little more explaining, but the same principle with less explanations will be remember both the number of digits of the largest int, and also the last digit of this number.  this way the string of the largest int can be construced.\\n\\nI believe @votrubac did it very well in his last solution (\"O(n)\" solution):\\nhttps://leetcode.com/problems/form-largest-integer-with-digits-that-add-up-to-target/discuss/635190/C%2B%2B-Top-Down-greater-Bottom-Up-greater-O(n)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        self.d = {}\\n        def top_down(t):\\n            if t == 0: return 0\\n            if t in self.d: return self.d[t]\\n            cur = float(\\'-inf\\')\\n            for digit in range(1,10):\\n                if (t-cost[digit-1]) >= 0:\\n                    cur = max(cur, top_down(t-cost[digit-1])*10+digit)\\n            self.d[t] = cur\\n            return cur\\n\\n        res = top_down(target)\\n        return str(res) if res != float(\\'-inf\\') else \"0\"\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 811604,
                "title": "c-dp-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    int dp[9][5001];\\n    // shouldTake represents whether we should take current character in the answer\\n    bool shouldTake[9][5001];\\n\\n    // returns the maximum length of string which can be formed from current state\\n    int rec(int index, int target, vector<int>& cost) {\\n        // Base Conditions\\n        if (target == 0)\\n            return 0;\\n        if (index == -1)\\n            return -1e9;\\n        if (dp[index][target] != -1)\\n            return dp[index][target];\\n        // taken: Maximum length possible if I take current character\\n        // notTaken: Maximum length possible if I don\\'t take current character\\n        int taken = -1e9, notTaken = -1e9;\\n        // It\\'s possible to take current character\\n        if (cost[index] <= target) {\\n            int nextMove = rec(index, target - cost[index], cost);\\n            if (nextMove != -1e9)\\n                taken = nextMove + 1;\\n        }\\n        // Skip the current character\\n        notTaken = rec(index - 1, target, cost);\\n        if (taken == -1e9 && notTaken == -1e9) {    // No solution Possible from this state\\n            return dp[index][target] = -1e9;\\n        } else if (taken == -1e9) {     // We can\\'t take the current character\\n            shouldTake[index][target] = 0;\\n            return dp[index][target] = notTaken;\\n        } else if (notTaken == -1e9) {      // We must take the current character\\n            shouldTake[index][target] = 1;\\n            return dp[index][target] = taken;\\n        } else if (taken >= notTaken) {     // We should take the current character\\n            shouldTake[index][target] = 1;\\n            return dp[index][target] = taken;\\n        }\\n        // Else skip the current character\\n        shouldTake[index][target] = 0;\\n        return dp[index][target] = notTaken;\\n    }\\n\\n    // Function to recover the generated string\\n    string recover (int index, int target, vector<int>& cost) {\\n        if (target == 0 || index < 0)\\n            return \"\";\\n        if (shouldTake[index][target])  // Take the current character\\n            return to_string(index + 1) + recover(index, target - cost[index], cost);\\n        return recover(index - 1, target, cost);    // Don\\'t take the current character\\n    }\\n\\n    string largestNumber(vector<int>& cost, int target) {\\n        memset(dp, -1, sizeof(dp));\\n        int maxLength = rec(8, target, cost);\\n        if (maxLength == -1e9)\\n            return \"0\";\\n        return recover(8, target, cost);\\n    }\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dp[9][5001];\\n    // shouldTake represents whether we should take current character in the answer\\n    bool shouldTake[9][5001];\\n\\n    // returns the maximum length of string which can be formed from current state\\n    int rec(int index, int target, vector<int>& cost) {\\n        // Base Conditions\\n        if (target == 0)\\n            return 0;\\n        if (index == -1)\\n            return -1e9;\\n        if (dp[index][target] != -1)\\n            return dp[index][target];\\n        // taken: Maximum length possible if I take current character\\n        // notTaken: Maximum length possible if I don\\'t take current character\\n        int taken = -1e9, notTaken = -1e9;\\n        // It\\'s possible to take current character\\n        if (cost[index] <= target) {\\n            int nextMove = rec(index, target - cost[index], cost);\\n            if (nextMove != -1e9)\\n                taken = nextMove + 1;\\n        }\\n        // Skip the current character\\n        notTaken = rec(index - 1, target, cost);\\n        if (taken == -1e9 && notTaken == -1e9) {    // No solution Possible from this state\\n            return dp[index][target] = -1e9;\\n        } else if (taken == -1e9) {     // We can\\'t take the current character\\n            shouldTake[index][target] = 0;\\n            return dp[index][target] = notTaken;\\n        } else if (notTaken == -1e9) {      // We must take the current character\\n            shouldTake[index][target] = 1;\\n            return dp[index][target] = taken;\\n        } else if (taken >= notTaken) {     // We should take the current character\\n            shouldTake[index][target] = 1;\\n            return dp[index][target] = taken;\\n        }\\n        // Else skip the current character\\n        shouldTake[index][target] = 0;\\n        return dp[index][target] = notTaken;\\n    }\\n\\n    // Function to recover the generated string\\n    string recover (int index, int target, vector<int>& cost) {\\n        if (target == 0 || index < 0)\\n            return \"\";\\n        if (shouldTake[index][target])  // Take the current character\\n            return to_string(index + 1) + recover(index, target - cost[index], cost);\\n        return recover(index - 1, target, cost);    // Don\\'t take the current character\\n    }\\n\\n    string largestNumber(vector<int>& cost, int target) {\\n        memset(dp, -1, sizeof(dp));\\n        int maxLength = rec(8, target, cost);\\n        if (maxLength == -1e9)\\n            return \"0\";\\n        return recover(8, target, cost);\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 649471,
                "title": "easy-to-understand-c-solution-using-top-down-approach-with-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    string cal(vector<int>&v,int sum,unordered_map<int,string>&dp){\\n        if(sum<0)       \\n            return \"0\";\\n        \\n        if(sum==0)\\n            return \"\";\\n        \\n        if(dp.count(sum)>0)\\n            return dp[sum];\\n        \\n        string curr,res=\"0\";\\n        for(int d=1;d<=9;d++){\\n            curr=cal(v,sum-v[d-1],dp);\\n            if(curr==\"0\")       // skip if can\\'t solve sub-problem\\n                continue;\\n            curr=to_string(d)+curr;\\n            if(res.length()<=curr.length())\\n                res=curr;\\n        }\\n        dp[sum]=res;\\n        return res;\\n    }\\n    string largestNumber(vector<int>&v,int s){\\n        unordered_map<int,string>dp;\\n        return cal(v,s,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string cal(vector<int>&v,int sum,unordered_map<int,string>&dp){\\n        if(sum<0)       \\n            return \"0\";\\n        \\n        if(sum==0)\\n            return \"\";\\n        \\n        if(dp.count(sum)>0)\\n            return dp[sum];\\n        \\n        string curr,res=\"0\";\\n        for(int d=1;d<=9;d++){\\n            curr=cal(v,sum-v[d-1],dp);\\n            if(curr==\"0\")       // skip if can\\'t solve sub-problem\\n                continue;\\n            curr=to_string(d)+curr;\\n            if(res.length()<=curr.length())\\n                res=curr;\\n        }\\n        dp[sum]=res;\\n        return res;\\n    }\\n    string largestNumber(vector<int>&v,int s){\\n        unordered_map<int,string>dp;\\n        return cal(v,s,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1338757,
                "title": "easy-c-recursive-memoization-solution-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& cost, int target) {\\n        //dp[i] stores the largest digit that can be fromed with i as target\\n        vector<string> dp(target+1,\"#\");\\n        \\n        int len=cost.size();\\n        helper(cost,len,target,dp);\\n        return dp[target];\\n        \\n    }\\n    string helper(vector<int>& cost,int& len,int target,vector<string>& dp)\\n    {\\n        if(target==0)\\n            return \"\";\\n        //the current sub problem is already calculated\\n        if(dp[target]!=\"#\")\\n            return dp[target];\\n        \\n        //not yet calculated\\n        dp[target]=\"0\";\\n        string curr=\"\";\\n        for(int i=len-1;i>=0;i--)\\n        {\\n            //use i if the cost is less than or equal to the target\\n            if(cost[i]<=target){\\n                curr.push_back(i+1+\\'0\\');\\n                string x=helper(cost,len,target-cost[i],dp);\\n                //if the return string is not zero \\n                //it means we can build some largest number with the remaining target\\n                if(x!=\"0\")\\n                {\\n                    \\n                    //we can form some number with the remaining target\\n                    curr.append(x);\\n                    int currLen=curr.length();\\n                    int tLen=dp[target].length();\\n                    //update if we got the largest number than dp[target]\\n                    if(tLen < currLen)\\n                        dp[target]=curr;\\n                    else if(tLen == currLen)\\n                        dp[target]=max(dp[target],curr);\\n                }\\n                curr=\"\";\\n            }\\n                \\n        }\\n        //now dp[target] would be either 0 or some digit(if there is some answer) \\n        return dp[target];\\n        \\n    }\\n};\\n```\\n**Upvote if this helps you :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& cost, int target) {\\n        //dp[i] stores the largest digit that can be fromed with i as target\\n        vector<string> dp(target+1,\"#\");\\n        \\n        int len=cost.size();\\n        helper(cost,len,target,dp);\\n        return dp[target];\\n        \\n    }\\n    string helper(vector<int>& cost,int& len,int target,vector<string>& dp)\\n    {\\n        if(target==0)\\n            return \"\";\\n        //the current sub problem is already calculated\\n        if(dp[target]!=\"#\")\\n            return dp[target];\\n        \\n        //not yet calculated\\n        dp[target]=\"0\";\\n        string curr=\"\";\\n        for(int i=len-1;i>=0;i--)\\n        {\\n            //use i if the cost is less than or equal to the target\\n            if(cost[i]<=target){\\n                curr.push_back(i+1+\\'0\\');\\n                string x=helper(cost,len,target-cost[i],dp);\\n                //if the return string is not zero \\n                //it means we can build some largest number with the remaining target\\n                if(x!=\"0\")\\n                {\\n                    \\n                    //we can form some number with the remaining target\\n                    curr.append(x);\\n                    int currLen=curr.length();\\n                    int tLen=dp[target].length();\\n                    //update if we got the largest number than dp[target]\\n                    if(tLen < currLen)\\n                        dp[target]=curr;\\n                    else if(tLen == currLen)\\n                        dp[target]=max(dp[target],curr);\\n                }\\n                curr=\"\";\\n            }\\n                \\n        }\\n        //now dp[target] would be either 0 or some digit(if there is some answer) \\n        return dp[target];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 635527,
                "title": "o-target-solution-python",
                "content": "Based on @lee215 solution\\n\\nif multiple elements have same cost , consider only element with highest index\\n\\n```\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        \\n        dp = [0] + [-1] * (target + 5000)\\n        ct = {}\\n        \\n        for i,c in enumerate(cost):\\n            ct[c] = i       \\n        for t in range(1, target + 1):\\n            dp[t] = max(dp[t - c] * 10 + i + 1 for c,i in ct.items())\\n        \\n        if dp[target] <= 0:\\n            return \"0\"\\n        return str(dp[target])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        \\n        dp = [0] + [-1] * (target + 5000)\\n        ct = {}\\n        \\n        for i,c in enumerate(cost):\\n            ct[c] = i       \\n        for t in range(1, target + 1):\\n            dp[t] = max(dp[t - c] * 10 + i + 1 for c,i in ct.items())\\n        \\n        if dp[target] <= 0:\\n            return \"0\"\\n        return str(dp[target])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 635469,
                "title": "explain-my-thinking-bottom-up-dp-knapsack-problem-explaination-comments",
                "content": "```\\nI did this problem during context and failed multiple test case, so I want to explain my approach after submit successfully,\\nI hope you guys can understand my idea and have better idea. If you have any comments, welcome.\\n\\nTime complexity: O(9*target*target) = O(target*target)\\nSpace: O(9*target + target) = O(10*target)\\n\\n**Initial idea**: Knapsack problem. Why?\\n1. Target is like a maximum weight of a bag\\n2. Costs is like a weight of things\\n3. Digits is like values which we put in a bag\\n4. Our problem is find maximum value(digits) we could put into a bag(target) and make sure total weight(total cost) less than or equal weight of bag. \\nIn this situation we need to find total of weight equal weight of bag\\n\\nYou guys could explore more about knapsack problems:\\nhttps://www.youtube.com/watch?v=xCbYmUPvc2Q\\n\\n**with knapsack problem**: dp[][] with dp[i][j] is maximum painting value with cost from 1-> i and sum of cost == j, dp[i][j] is String type\\n\\n**Next idea**: I easily compare two integer, but with string(huge string) I should think about how effficiently compare them. \\n\\n**Solution**: I used helper method named \"compareToString\" with two parameters: \\nfirst String and second String and return which string greater than. \\nThis method used to compare value of two String after all of character of every string sorted in decreasing order, but I actually don\\'t sort them because it is expensive.\\nFor example: str1 = \"199\" str2 = \"256\", but this method will return \"199\" because actually \"199\" -> \"991\", \"256\" -> \"652\". \\n\\n**Note**: but before return the last result, we need to sort the string have greatest value in decreasing oder\\n\\nclass Solution {\\n    public String largestNumber(int[] cost, int target) {\\n        int[][] pairCostAndDigit = new int[cost.length][2];\\n        \\n        for(int i = 0; i < pairCostAndDigit.length; i++) {\\n            pairCostAndDigit[i][0] = cost[i];\\n            pairCostAndDigit[i][1] = i + 1;\\n        }\\n        \\n        String[][] dp = new String[pairCostAndDigit.length + 1][target + 1];\\n        \\n        for(int i = 1; i < dp.length; i++) {\\n            int curCost = pairCostAndDigit[i - 1][0];\\n            int digit = pairCostAndDigit[i - 1][1];\\n            \\n            for(int j = 1; j < dp[0].length; j++) {\\n                dp[i][j] = dp[i - 1][j];\\n                if (curCost == j) {\\n                    dp[i][j] = compareToString(String.valueOf(digit), dp[i][j]);\\n                } else if (curCost < j && dp[i][j - curCost] != null) {\\n                    dp[i][j] = compareToString(dp[i][j - curCost] + digit, dp[i][j]);\\n                }\\n            }\\n        }\\n        \\n        String re = dp[dp.length - 1][dp[0].length - 1];\\n        return re == null ? \"0\" : sort(re);\\n    }\\n    \\n    private String sort(String str) {\\n        int[] cArr = mapStrToIntArr(str);\\n        StringBuilder sb1 = new StringBuilder();\\n        for(int i = cArr.length - 1; i >= 0; i--) {\\n            while(cArr[i] > 0) {\\n                sb1.append(i);\\n                cArr[i]--;\\n            }\\n        }\\n        \\n        return sb1.toString();\\n    }\\n    \\n    \\n    private int[] mapStrToIntArr(String s) {\\n        int[] cArr = new int[10];\\n        for(char c : s.toCharArray()) {\\n            cArr[c - \\'0\\']++;\\n        }\\n        return cArr;\\n    }\\n    \\n    private String compareToString(String a, String b) {\\n        \\n        if (a == null) return b;\\n        else if (b == null) return a;\\n        else if (a.length() > b.length()) return a;\\n        else if (b.length() > a.length()) return b;\\n        \\n        int[] cArr = mapStrToIntArr(a);\\n        int[] bArr = mapStrToIntArr(b);\\n        \\n        int i = 9;\\n        while(i >= 1) {\\n            if (cArr[i] == bArr[i]) i--;\\n            else if (cArr[i] > bArr[i]) return a;\\n            else return b;\\n        }\\n        return null;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String largestNumber(int[] cost, int target) {\\n        int[][] pairCostAndDigit = new int[cost.length][2];\\n        \\n        for(int i = 0; i < pairCostAndDigit.length; i++) {\\n            pairCostAndDigit[i][0] = cost[i];\\n            pairCostAndDigit[i][1] = i + 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 635262,
                "title": "python-knapsack-greedy-o-target-clean-solution",
                "content": "```\\nclass Solution(object):\\n    def largestNumber(self, cost, target):\\n        cache = {}\\n        def max_num(i, target): # return the maximum number built with the given target\\n            if (i, target) in cache:\\n                return cache[(i, target)]\\n\\t\\t\\t\\t\\n            if i == len(cost) or target < 0: # we wont count overflow\\n                return float(\"-inf\")\\n\\t\\t\\t\\t\\n            if target == 0: # reaching the target sum of cost\\n                return 0\\n\\t\\t\\t\\n\\t\\t\\t# the two scenarios, 1 is take the current digit, the other one is not taking the current digit\\n\\t\\t\\t# as our i is moving from 0 to 8, the later coming digit should br greater than i, \\n\\t\\t\\t# so we are sure this can build the string optimally (in descending order)\\n            c1 = max_num(i, target - cost[i]) * 10 + i + 1\\n            c2 = max_num(i + 1, target)\\n            res = max(c1, c2)\\n            cache[(i, target)] = res\\n            return res\\n        \\n\\t\\t\\n\\t\\t\\n\\t\\t# retrieve the result by calling the function\\n        res = max_num(0, target)\\n        if res > 0:\\n            return str(max_num(0, target))\\n        else: # if the result is not valid, it will be negative infinity\\n            return \"0\"",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def largestNumber(self, cost, target):\\n        cache = {}",
                "codeTag": "Java"
            },
            {
                "id": 646959,
                "title": "dp-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string maxi(string a,string b){\\n        if(a.size()>b.size()){\\n            return a;\\n        }\\n        else if(a.size()<b.size()){\\n            return b;\\n        }\\n        else{\\n            if(a>b){\\n                return a;\\n            }\\n            return b;\\n        }\\n        return \"\";\\n    }\\n    string largestNumber(vector<int>& cost, int target) {\\n        unordered_map<int,map<int,string> > dp;\\n        for(int i=0;i<=target;i++){\\n            for(int j=0;j<=9;j++){\\n                if(i==0){\\n                    dp[i][j]=\"\";\\n                }\\n                else if(j==0){\\n                    dp[i][j]=\"0\";\\n                }\\n                else if(cost[j-1]<=i && dp[i-cost[j-1]][j]!=\"0\"){\\n                    dp[i][j]=maxi(to_string(j)+dp[i-cost[j-1]][j],dp[i][j-1]);\\n                }\\n                else{\\n                    dp[i][j]=dp[i][j-1];\\n                }\\n            }\\n        }\\n        return dp[target][9];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string maxi(string a,string b){\\n        if(a.size()>b.size()){\\n            return a;\\n        }\\n        else if(a.size()<b.size()){\\n            return b;\\n        }\\n        else{\\n            if(a>b){\\n                return a;\\n            }\\n            return b;\\n        }\\n        return \"\";\\n    }\\n    string largestNumber(vector<int>& cost, int target) {\\n        unordered_map<int,map<int,string> > dp;\\n        for(int i=0;i<=target;i++){\\n            for(int j=0;j<=9;j++){\\n                if(i==0){\\n                    dp[i][j]=\"\";\\n                }\\n                else if(j==0){\\n                    dp[i][j]=\"0\";\\n                }\\n                else if(cost[j-1]<=i && dp[i-cost[j-1]][j]!=\"0\"){\\n                    dp[i][j]=maxi(to_string(j)+dp[i-cost[j-1]][j],dp[i][j-1]);\\n                }\\n                else{\\n                    dp[i][j]=dp[i][j-1];\\n                }\\n            }\\n        }\\n        return dp[target][9];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 635702,
                "title": "python-dp-o-9-target-with-explanation",
                "content": "**COST:**\\nIf it costs the same to paint 2 digits, we always pick the larger digit\\nWe prepare a cost_map which has the cost as the key and the value is the digit for that cost\\nWe store the available costs in a costs array.\\n\\n**DP MATRIX:**\\nrows represent each of the possible costs available\\ncolumns represent the target values (0 to given target)\\ndp[i][j] represents the highest number formed if we only had costs 0 to cost[i] available and if the target was j.\\n\\n**DP EQUATION:**\\nThe dp equation boils down to: dp[i][j] = max(dp[i-1][j], *a*)\\ndp[i-1][j] represents the highest number formed using costs till i-1 and target j\\n*a* represents the number formed, if we pick cost[i] to form our number\\n\\nIf we pick cost[i] then we can form our number using the cost[i] digit and the best number formed till j-cost[i] (this is represented by dp[i][j-c] where c = cost[i]\\n\\n*a* = self.form_max_number(dp[i][j-c], cost_map[c])\\n\\n\\n**COMPLEXITY:**\\nTime Complexity = O(target * 9) => O(target)\\nSpace Complexity = O(target * 9) => O(target)\\n\\n\\n\\n```\\nclass Solution(object):\\n\\n    def form_max_number(self, v1, v2):\\n        if v1 == 0:\\n            return v2\\n        if v2 == 0:\\n            return v1\\n        str1 = str(v1) + str(v2)\\n        return int(\\'\\'.join(sorted(str1, reverse=True)))\\n\\n    def largestNumber(self, cost, target):\\n        \"\"\"\\n        :type cost: List[int]\\n        :type target: int\\n        :rtype: str\\n        \"\"\"\\n        cost_map = {} # best digit for each cost\\n        for i, c in enumerate(cost):\\n            cost_map[c] = i+1\\n\\n        #dp[i][j] represents the highest number formed if we only had costs 0 to cost[i] available and if the target was j.\\n        dp = [[-1 for _ in range(target+1)] for _ in range(len(cost_map)+1)]\\n\\n        # to handle the base case\\n        for i in range(len(dp)):\\n            dp[i][0] = 0\\n        costs = [0]+cost_map.keys()\\n\\n        for i in range(1, len(dp)):\\n            c = costs[i]\\n            for j in range(1, len(dp[0])):\\n                a = -1\\n                if j >= c and dp[i][j-c] != -1:\\n                    a = self.form_max_number(dp[i][j-c], cost_map[c])\\n                dp[i][j] = max(dp[i-1][j], a)\\n        if dp[-1][-1] == -1:\\n            return \\'0\\'\\n        return str(dp[-1][-1])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n\\n    def form_max_number(self, v1, v2):\\n        if v1 == 0:\\n            return v2\\n        if v2 == 0:\\n            return v1\\n        str1 = str(v1) + str(v2)\\n        return int(\\'\\'.join(sorted(str1, reverse=True)))\\n\\n    def largestNumber(self, cost, target):\\n        \"\"\"\\n        :type cost: List[int]\\n        :type target: int\\n        :rtype: str\\n        \"\"\"\\n        cost_map = {} # best digit for each cost\\n        for i, c in enumerate(cost):\\n            cost_map[c] = i+1\\n\\n        #dp[i][j] represents the highest number formed if we only had costs 0 to cost[i] available and if the target was j.\\n        dp = [[-1 for _ in range(target+1)] for _ in range(len(cost_map)+1)]\\n\\n        # to handle the base case\\n        for i in range(len(dp)):\\n            dp[i][0] = 0\\n        costs = [0]+cost_map.keys()\\n\\n        for i in range(1, len(dp)):\\n            c = costs[i]\\n            for j in range(1, len(dp[0])):\\n                a = -1\\n                if j >= c and dp[i][j-c] != -1:\\n                    a = self.form_max_number(dp[i][j-c], cost_map[c])\\n                dp[i][j] = max(dp[i-1][j], a)\\n        if dp[-1][-1] == -1:\\n            return \\'0\\'\\n        return str(dp[-1][-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 635564,
                "title": "javascript-simple-dp",
                "content": "Define the array with the length of total cost (target+1).\\nFor each index (total cost), it will save the string of max integer.\\n```\\nvar largestNumber = function(cost, target) {\\n    const arr = new Array(target+1).fill(\\'#\\');\\n    arr[0] = \\'\\';\\n    \\n    for (let i = 0; i < 9; i++) {\\n        for (let j = cost[i]; j <= target; j++) {\\n            if (arr[j-cost[i]] !== \\'#\\' && arr[j-cost[i]].length + 1 >= arr[j].length) {\\n                arr[j] = (i+1).toString().concat(arr[j-cost[i]]);\\n            }\\n        }\\n    }\\n    \\n    return arr[target] == \\'#\\' ? \\'0\\' : arr[target];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar largestNumber = function(cost, target) {\\n    const arr = new Array(target+1).fill(\\'#\\');\\n    arr[0] = \\'\\';\\n    \\n    for (let i = 0; i < 9; i++) {\\n        for (let j = cost[i]; j <= target; j++) {\\n            if (arr[j-cost[i]] !== \\'#\\' && arr[j-cost[i]].length + 1 >= arr[j].length) {\\n                arr[j] = (i+1).toString().concat(arr[j-cost[i]]);\\n            }\\n        }\\n    }\\n    \\n    return arr[target] == \\'#\\' ? \\'0\\' : arr[target];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2381024,
                "title": "c-two-states-dp",
                "content": "* For any path which we want to ignore in our calls, we append `0` to our string, since `0` is not allowed.\\n\\n\\n```\\n\\nclass Solution {\\npublic:\\n    vector<vector<string>> dp ;\\n    string largestNumber(vector<int>& cost, int target) {\\n        dp.resize(10,vector<string>(target+1,\"-1\"));\\n        return solve(cost,0,target) ;\\n    }\\n    \\n    string solve(vector<int>& cost,int idx,int target){\\n        if(!target) return \"\";\\n        if(target < 0 || idx >= size(cost)) return \"0\"; \\n        \\n        if(dp[idx][target]!=\"-1\") return dp[idx][target];\\n        \\n        string a = to_string(idx+1) + solve(cost,0,target-cost[idx]);\\n        string b = solve(cost,idx+1,target);\\n        \\n        return dp[idx][target] = a.back() == \\'0\\' ? b : b.back() == \\'0\\' ? a : size(a) == size(b) ? max(a,b) : size(a) > size(b) ? a : b ;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<vector<string>> dp ;\\n    string largestNumber(vector<int>& cost, int target) {\\n        dp.resize(10,vector<string>(target+1,\"-1\"));\\n        return solve(cost,0,target) ;\\n    }\\n    \\n    string solve(vector<int>& cost,int idx,int target){\\n        if(!target) return \"\";\\n        if(target < 0 || idx >= size(cost)) return \"0\"; \\n        \\n        if(dp[idx][target]!=\"-1\") return dp[idx][target];\\n        \\n        string a = to_string(idx+1) + solve(cost,0,target-cost[idx]);\\n        string b = solve(cost,idx+1,target);\\n        \\n        return dp[idx][target] = a.back() == \\'0\\' ? b : b.back() == \\'0\\' ? a : size(a) == size(b) ? max(a,b) : size(a) > size(b) ? a : b ;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 671570,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& cost, int target) {\\n        vector<int> dp(target + 1, -10000);\\n        dp[0] = 0;\\n        for (int t = 1; t <= target; ++t) {\\n            for (int i = 0; i < 9; ++i) {\\n                dp[t] = max(dp[t], t >= cost[i] ? 1 + dp[t - cost[i]] : -10000);\\n            }\\n        }\\n        if (dp[target] < 0) return \"0\";\\n        string res = \"\";\\n        for (int i = 8; i >= 0; --i) {\\n            while (target >= cost[i] && dp[target] == dp[target - cost[i]] + 1) {\\n                res.push_back(\\'1\\' + i);\\n                target -= cost[i];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& cost, int target) {\\n        vector<int> dp(target + 1, -10000);\\n        dp[0] = 0;\\n        for (int t = 1; t <= target; ++t) {\\n            for (int i = 0; i < 9; ++i) {\\n                dp[t] = max(dp[t], t >= cost[i] ? 1 + dp[t - cost[i]] : -10000);\\n            }\\n        }\\n        if (dp[target] < 0) return \"0\";\\n        string res = \"\";\\n        for (int i = 8; i >= 0; --i) {\\n            while (target >= cost[i] && dp[target] == dp[target - cost[i]] + 1) {\\n                res.push_back(\\'1\\' + i);\\n                target -= cost[i];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 635382,
                "title": "c-dfs-memo",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    unordered_map<int, string> memo;\\n    \\n    string build(const vector<int>& cost, const int& target) {\\n        if (memo.count(target)) return memo[target];\\n        string s, t;\\n        for (int i = 0; i < 9; ++i)\\n            if (cost[i] <= target) {\\n                t = build(cost, target - cost[i]);\\n                if (t != \"*\") {\\n                    t = char(\\'1\\' + i) + t;\\n                    s = s.length() < t.length() ? t : s.length() == t.length() && s < t ? t : s;\\n                }\\n            }\\n        return memo[target] = s.empty() ? \"*\" : s;\\n    }\\n    \\n    string largestNumber(vector<int>& cost, int target) {\\n        memo[0] = \"\";\\n        string ans = build(cost, target);\\n        return ans == \"*\" ? \"0\" : ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    unordered_map<int, string> memo;\\n    \\n    string build(const vector<int>& cost, const int& target) {\\n        if (memo.count(target)) return memo[target];\\n        string s, t;\\n        for (int i = 0; i < 9; ++i)\\n            if (cost[i] <= target) {\\n                t = build(cost, target - cost[i]);\\n                if (t != \"*\") {\\n                    t = char(\\'1\\' + i) + t;\\n                    s = s.length() < t.length() ? t : s.length() == t.length() && s < t ? t : s;\\n                }\\n            }\\n        return memo[target] = s.empty() ? \"*\" : s;\\n    }\\n    \\n    string largestNumber(vector<int>& cost, int target) {\\n        memo[0] = \"\";\\n        string ans = build(cost, target);\\n        return ans == \"*\" ? \"0\" : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3335444,
                "title": "short-sweet-memoized-code",
                "content": "````\\nclass Solution\\n{\\npublic:\\n    string solve(int tgt, vector<int> &c, vector<string> &dp)\\n    {\\n        if (tgt == 0)\\n        {\\n            return \"\";\\n        }\\n        if (dp[tgt] != \"#\")\\n        {\\n            return dp[tgt];\\n        }\\n        string ans = \"0\";\\n        for (int i = 1; i <= 9; i++)\\n        {\\n            if (tgt >= c[i-1])\\n            {\\n                string curr = solve(tgt - c[i - 1], c, dp);\\n                if(curr==\"0\")continue;\\n                curr = to_string(i)+curr;\\n                if(ans.length()>curr.length())continue;\\n                if((ans==\"0\")||(curr.length()>ans.length())||(curr.length()==ans.length()&&curr.compare(ans)>0)){\\n                    ans =curr;\\n                }\\n            }\\n        }\\n        return dp[tgt] = ans;\\n    }\\n    string largestNumber(vector<int> &cost, int target)\\n    {\\n        vector<string> dp(target + 1, \"#\");\\n        return solve(target, cost, dp);\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "````\\nclass Solution\\n{\\npublic:\\n    string solve(int tgt, vector<int> &c, vector<string> &dp)\\n    {\\n        if (tgt == 0)\\n        {\\n            return \"\";\\n        }\\n        if (dp[tgt] != \"#\")\\n        {\\n            return dp[tgt];\\n        }\\n        string ans = \"0\";\\n        for (int i = 1; i <= 9; i++)\\n        {\\n            if (tgt >= c[i-1])\\n            {\\n                string curr = solve(tgt - c[i - 1], c, dp);\\n                if(curr==\"0\")continue;\\n                curr = to_string(i)+curr;\\n                if(ans.length()>curr.length())continue;\\n                if((ans==\"0\")||(curr.length()>ans.length())||(curr.length()==ans.length()&&curr.compare(ans)>0)){\\n                    ans =curr;\\n                }\\n            }\\n        }\\n        return dp[tgt] = ans;\\n    }\\n    string largestNumber(vector<int> &cost, int target)\\n    {\\n        vector<string> dp(target + 1, \"#\");\\n        return solve(target, cost, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1019177,
                "title": "c-4ms-beat-100",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& cost, int target) {\\n        vector<State> dp(target+1);\\n        dp[0] = State{0,0};\\n        for(int i=1;i<=target;i++){\\n            auto& [len, pre] = dp[i];\\n            for(int j=8;j>=0;j--){\\n                int k = i-cost[j];\\n                if(k<0 || dp[k].len < 0) continue;\\n                if(dp[k].len+1 > len){\\n                    len = dp[k].len+1;\\n                    pre = j;\\n                }\\n            }\\n        }\\n        if(dp[target].len<0) return \"0\";\\n        \\n        string res;\\n        for(int i=target; i>0;){\\n            auto [len, pre] = dp[i];\\n            res += \\'1\\'+pre;\\n            i -= cost[pre];\\n        }\\n        return res;\\n    }\\n    \\n    struct State{\\n        int len=-1;\\n        int pre=0;\\n    };\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string largestNumber(vector<int>& cost, int target) {\\n        vector<State> dp(target+1);\\n        dp[0] = State{0,0}",
                "codeTag": "Java"
            },
            {
                "id": 720392,
                "title": "python-2-dp-solutions",
                "content": "Solution #1 (a more ordinary looking solution based on the magical one posted by lee215)\\n```\\nclass Solution(object):\\n    def largestNumber(self, cost, target):\\n        dp = [0]\\n        for i in range(1, target+1):\\n            result = 0\\n            for j, c in enumerate(cost):\\n                if c > i:\\n                    continue\\n                if dp[i-c] == 0 and i != c:\\n                    continue\\n                result = max(result, 10*dp[i-c] + j + 1)\\n            dp.append(result)\\n        return str(dp[target])\\n```\\n\\t\\nSolution #2 (top-down DP solution with memoization)\\n```\\nclass Solution(object):\\n    def largestNumber(self, cost, target):\\n        cache = {}\\n        def helper(remaining):\\n            if remaining == 0:\\n                return \\'\\'\\n            if remaining in cache:\\n                return cache[remaining]\\n            maximum = \\'0\\'\\n            for i in range(len(cost)):\\n                if cost[i] > remaining:\\n                    continue\\n                result = helper(remaining - cost[i])\\n                if result == \\'0\\':\\n                    continue\\n                maximum = larger(maximum, str(i+1) + result)\\n            cache[remaining] = maximum\\n            return maximum\\n\\n        def larger(a, b):\\n            if len(a) > len(b):\\n                return a\\n            if len(a) < len(b):\\n                return b\\n            return max(a, b)\\n\\n        return helper(target)\\n\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def largestNumber(self, cost, target):\\n        dp = [0]\\n        for i in range(1, target+1):\\n            result = 0\\n            for j, c in enumerate(cost):\\n                if c > i:\\n                    continue\\n                if dp[i-c] == 0 and i != c:\\n                    continue\\n                result = max(result, 10*dp[i-c] + j + 1)\\n            dp.append(result)\\n        return str(dp[target])\\n```\n```\\nclass Solution(object):\\n    def largestNumber(self, cost, target):\\n        cache = {}\\n        def helper(remaining):\\n            if remaining == 0:\\n                return \\'\\'\\n            if remaining in cache:\\n                return cache[remaining]\\n            maximum = \\'0\\'\\n            for i in range(len(cost)):\\n                if cost[i] > remaining:\\n                    continue\\n                result = helper(remaining - cost[i])\\n                if result == \\'0\\':\\n                    continue\\n                maximum = larger(maximum, str(i+1) + result)\\n            cache[remaining] = maximum\\n            return maximum\\n\\n        def larger(a, b):\\n            if len(a) > len(b):\\n                return a\\n            if len(a) < len(b):\\n                return b\\n            return max(a, b)\\n\\n        return helper(target)\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 636090,
                "title": "java-dp-knapsack",
                "content": "```\\nclass Solution {\\n    public String largestNumber(int[] cost, int target) {\\n        \\n\\t\\t/**\\n\\t\\tThis is the classic knapsack problem. You can also do with 1-D array.\\n\\t\\tTwo options either you include the current number \\'j\\' only if cost[j] > i, or you don\\'t include the current number. \\n\\t\\tWe are filling it with negative values, which will help while constructing the solution, for example when target = 3, \\n\\t\\twe can still use 7 and then our target will become \"1\" but there is a possibility we can\\'t make 1 (this is true for first example) \\n\\t\\tso using big negative values we can skip \"7\" as the number and look for different number (useful while reconstructing).\\n\\t\\t*/\\n        int[][] dp = new int[target+1][cost.length+1];        \\n        for(int i = 1; i <= target; i++){\\n            Arrays.fill(dp[i], -10000);\\n            for(int j = 1; j <= cost.length; j++){\\n                dp[i][j] = dp[i][j-1];\\n                if (i - cost[j-1] >= 0) dp[i][j] = Math.max(dp[i][j],1 + dp[i - cost[j-1]][j]);\\n            }\\n        }\\n\\n        StringBuilder builder = new StringBuilder();\\n        \\n\\t\\t/*\\n\\t\\tThis part is simple, we are just reconstructing the solution i.e. numbers used for  creating largest number.\\n\\t\\t*/\\n        int i = target;\\n        int j = cost.length;\\n        \\n        while(i > 0 && j > 0){\\n            if(i >= cost[j-1] && dp[i][j] == (1 + dp[i - cost[j-1]][j]) && dp[i][j] >= 0){\\n                builder.append(j);\\n                i -= cost[j-1];\\n            }else{\\n                j--;\\n            }\\n        }\\n        return (builder.length() == 0) ? \"0\" : builder.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String largestNumber(int[] cost, int target) {\\n        \\n\\t\\t/**\\n\\t\\tThis is the classic knapsack problem. You can also do with 1-D array.\\n\\t\\tTwo options either you include the current number \\'j\\' only if cost[j] > i, or you don\\'t include the current number. \\n\\t\\tWe are filling it with negative values, which will help while constructing the solution, for example when target = 3, \\n\\t\\twe can still use 7 and then our target will become \"1\" but there is a possibility we can\\'t make 1 (this is true for first example) \\n\\t\\tso using big negative values we can skip \"7\" as the number and look for different number (useful while reconstructing).\\n\\t\\t*/\\n        int[][] dp = new int[target+1][cost.length+1];        \\n        for(int i = 1; i <= target; i++){\\n            Arrays.fill(dp[i], -10000);\\n            for(int j = 1; j <= cost.length; j++){\\n                dp[i][j] = dp[i][j-1];\\n                if (i - cost[j-1] >= 0) dp[i][j] = Math.max(dp[i][j],1 + dp[i - cost[j-1]][j]);\\n            }\\n        }\\n\\n        StringBuilder builder = new StringBuilder();\\n        \\n\\t\\t/*\\n\\t\\tThis part is simple, we are just reconstructing the solution i.e. numbers used for  creating largest number.\\n\\t\\t*/\\n        int i = target;\\n        int j = cost.length;\\n        \\n        while(i > 0 && j > 0){\\n            if(i >= cost[j-1] && dp[i][j] == (1 + dp[i - cost[j-1]][j]) && dp[i][j] >= 0){\\n                builder.append(j);\\n                i -= cost[j-1];\\n            }else{\\n                j--;\\n            }\\n        }\\n        return (builder.length() == 0) ? \"0\" : builder.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 635442,
                "title": "simple-c-solution-top-down-approach",
                "content": "```\\nclass Solution {\\nprivate:\\n    vector<int>v;\\n    int t;\\n    vector<pair<string,bool>>mem;\\npublic:\\n    string maxx(string a,string b){\\n        if(a.size()>b.size())  return a;\\n        else if(a.size()<b.size())return b;\\n        else return max(a,b);\\n    }\\n    string largestNumber(vector<int>& cost, int target) {\\n        v=cost,t=target;\\n        mem=vector<pair<string,bool>>(target+5,make_pair(\"-1\",false));\\n        \\n        string ans=solve(t).first;;\\n        return (ans==\"\"?\"0\":ans);\\n    }\\n\\n    pair<string,bool> solve(int cur){\\n        if(cur==0)\\n            return {\"\",1};\\n\\n        pair<string,bool> &ret=mem[cur];\\n        if(ret.first!=\"-1\")return ret;\\n        ret.first=\"\";\\n        for(int i=0;i<9;i++){\\n            if(cur>=v[i]){\\n                pair<string ,bool>r=solve(cur-v[i]);\\n                if(r.second)\\n                    ret.first=maxx(ret.first,char(i+1+\\'0\\')+r.first),ret.second=1;\\n            }\\n        }\\n        return ret;\\n    }\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<int>v;\\n    int t;\\n    vector<pair<string,bool>>mem;\\npublic:\\n    string maxx(string a,string b){\\n        if(a.size()>b.size())  return a;\\n        else if(a.size()<b.size())return b;\\n        else return max(a,b);\\n    }\\n    string largestNumber(vector<int>& cost, int target) {\\n        v=cost,t=target;\\n        mem=vector<pair<string,bool>>(target+5,make_pair(\"-1\",false));\\n        \\n        string ans=solve(t).first;;\\n        return (ans==\"\"?\"0\":ans);\\n    }\\n\\n    pair<string,bool> solve(int cur){\\n        if(cur==0)\\n            return {\"\",1};\\n\\n        pair<string,bool> &ret=mem[cur];\\n        if(ret.first!=\"-1\")return ret;\\n        ret.first=\"\";\\n        for(int i=0;i<9;i++){\\n            if(cur>=v[i]){\\n                pair<string ,bool>r=solve(cur-v[i]);\\n                if(r.second)\\n                    ret.first=maxx(ret.first,char(i+1+\\'0\\')+r.first),ret.second=1;\\n            }\\n        }\\n        return ret;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 635441,
                "title": "pytohn-priority-queue",
                "content": "- push [cost, -val] into `priority queue`\\n- The first popped element with `cost=k` is the largest val of cost_k\\n\\nTime: `O(target*log(target)) `\\nSpace: `O(target*log(target)) `\\n\\n\\n```Python\\nfrom heapq import heappop, heappush\\n\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        \\n        queue = list()\\n        for num, c in enumerate(cost):\\n            heappush(queue, [c, -num-1])\\n\\n        checked = dict()\\n        while queue:\\n            \\n            c, num = heappop(queue)\\n            if c in checked:\\n                continue\\n            checked[c] = num\\n            \\n            for nxt_num, nxt_c in enumerate(cost):\\n                if c + nxt_c > target:\\n                    continue\\n                heappush(queue, [c + nxt_c, num*10-nxt_num - 1])\\n\\n        if target in checked:\\n            return str(-checked[target])\\n        return \\'0\\'\\n```\\n",
                "solutionTags": [],
                "code": "```Python\\nfrom heapq import heappop, heappush\\n\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        \\n        queue = list()\\n        for num, c in enumerate(cost):\\n            heappush(queue, [c, -num-1])\\n\\n        checked = dict()\\n        while queue:\\n            \\n            c, num = heappop(queue)\\n            if c in checked:\\n                continue\\n            checked[c] = num\\n            \\n            for nxt_num, nxt_c in enumerate(cost):\\n                if c + nxt_c > target:\\n                    continue\\n                heappush(queue, [c + nxt_c, num*10-nxt_num - 1])\\n\\n        if target in checked:\\n            return str(-checked[target])\\n        return \\'0\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 635265,
                "title": "bottom-up-dp-o-n-time-c",
                "content": "Bottom up dp, O(10n) space, O(10n) time\\nBasically radix sort the strings\\n```\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& cost, int target) {\\n        cost.insert(cost.begin(),0);\\n        vector<vector<int>> dp(target+1,vector<int>(10));\\n        vector<int> total(target+1);\\n        for(int i=1;i<=target;++i){ // current target\\n            vector<int> curr(10);\\n            int x=0;\\n            for(int d=1;d!=10;++d){\\n                if(i-cost[d]>=0){   // want to form exactly this target i\\n                    auto t=total[i-cost[d]];    // length of that string\\n                    if(t==0 &&i-cost[d]!=0)continue; // first one needs to be exact\\n                    if(t+1>x){\\n                        curr=dp[i-cost[d]];\\n                        curr[d]++;\\n                        x=t+1;\\n                    }\\n                    else if(t+1==x){\\n                        auto temp=dp[i-cost[d]];\\n                        temp[d]++;  // add d in\\n                        if(better(temp,curr)) curr=temp;\\n                        x=t+1;\\n                    }\\n                    // cout<<reconstruct(curr)<<\" \";\\n                }\\n            }\\n            dp[i]=curr;\\n            total[i]=x;\\n            // cout<<endl<<endl;\\n        }\\n        return total.back()==0?\"0\": reconstruct(dp.back());\\n    }\\n    string reconstruct(vector<int>& nums){    // turn a radix sort into a string again\\n        string res=\"\";\\n        for(int i=9;i!=0;--i){\\n            int x=nums[i];\\n            for(int j=0;j!=x;++j){\\n                res+=to_string(i);\\n            }\\n        }\\n        return res;\\n    }\\n    bool better(vector<int>& a,vector<int>& b){ // if a > b\\n        for(int i=9;i!=0;--i){\\n            if(a[i]>b[i])return true;\\n            if(a[i]<b[i])return false;\\n        }\\n        return false;\\n    }\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& cost, int target) {\\n        cost.insert(cost.begin(),0);\\n        vector<vector<int>> dp(target+1,vector<int>(10));\\n        vector<int> total(target+1);\\n        for(int i=1;i<=target;++i){ // current target\\n            vector<int> curr(10);\\n            int x=0;\\n            for(int d=1;d!=10;++d){\\n                if(i-cost[d]>=0){   // want to form exactly this target i\\n                    auto t=total[i-cost[d]];    // length of that string\\n                    if(t==0 &&i-cost[d]!=0)continue; // first one needs to be exact\\n                    if(t+1>x){\\n                        curr=dp[i-cost[d]];\\n                        curr[d]++;\\n                        x=t+1;\\n                    }\\n                    else if(t+1==x){\\n                        auto temp=dp[i-cost[d]];\\n                        temp[d]++;  // add d in\\n                        if(better(temp,curr)) curr=temp;\\n                        x=t+1;\\n                    }\\n                    // cout<<reconstruct(curr)<<\" \";\\n                }\\n            }\\n            dp[i]=curr;\\n            total[i]=x;\\n            // cout<<endl<<endl;\\n        }\\n        return total.back()==0?\"0\": reconstruct(dp.back());\\n    }\\n    string reconstruct(vector<int>& nums){    // turn a radix sort into a string again\\n        string res=\"\";\\n        for(int i=9;i!=0;--i){\\n            int x=nums[i];\\n            for(int j=0;j!=x;++j){\\n                res+=to_string(i);\\n            }\\n        }\\n        return res;\\n    }\\n    bool better(vector<int>& a,vector<int>& b){ // if a > b\\n        for(int i=9;i!=0;--i){\\n            if(a[i]>b[i])return true;\\n            if(a[i]<b[i])return false;\\n        }\\n        return false;\\n    }\\n\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 635197,
                "title": "simple-java-solution-using-dp",
                "content": "```\\nclass Solution {\\n    String res = \"0\";\\n    public String largestNumber(int[] cost, int target) {\\n        String[] dp = new String[target + 1];\\n        dp[0] = \"\";\\n        for(int i = 1; i <= target; i++){\\n            String str = \"\";\\n            for(int j = 0; j < cost.length; j++){\\n                String curr = \"\";\\n                if(i >= cost[j] && (i == cost[j] || dp[i - cost[j]].length() > 0)){// if i != cost[j] && dp[i - cost[j]] = \"\", means we cannot use dp[i - cost[j]] as we cannot get it using given costs\\n                    curr = (j + 1) + dp[i - cost[j]];\\n                }\\n                if(valid(curr, str)){\\n                    str = curr;\\n                }\\n            }\\n            dp[i] = str;\\n        }\\n        \\n        return dp[target].length() == 0 ? \"0\" : dp[target];\\n    }\\n    \\n    // check if s is greater than t\\n    public boolean valid(String s, String t){\\n        if(s.length() < t.length()){\\n            return false;\\n        }else if(s.length() > t.length()){\\n            return true;\\n        }\\n        int i = 0;\\n        while(i < s.length()){\\n            if(s.charAt(i) > t.charAt(i)){\\n                return true;\\n            }else if(s.charAt(i) < t.charAt(i)){\\n                return true;\\n            }\\n            i++;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    String res = \"0\";\\n    public String largestNumber(int[] cost, int target) {\\n        String[] dp = new String[target + 1];\\n        dp[0] = \"\";\\n        for(int i = 1; i <= target; i++){\\n            String str = \"\";\\n            for(int j = 0; j < cost.length; j++){\\n                String curr = \"\";\\n                if(i >= cost[j] && (i == cost[j] || dp[i - cost[j]].length() > 0)){// if i != cost[j] && dp[i - cost[j]] = \"\", means we cannot use dp[i - cost[j]] as we cannot get it using given costs\\n                    curr = (j + 1) + dp[i - cost[j]];\\n                }\\n                if(valid(curr, str)){\\n                    str = curr;\\n                }\\n            }\\n            dp[i] = str;\\n        }\\n        \\n        return dp[target].length() == 0 ? \"0\" : dp[target];\\n    }\\n    \\n    // check if s is greater than t\\n    public boolean valid(String s, String t){\\n        if(s.length() < t.length()){\\n            return false;\\n        }else if(s.length() > t.length()){\\n            return true;\\n        }\\n        int i = 0;\\n        while(i < s.length()){\\n            if(s.charAt(i) > t.charAt(i)){\\n                return true;\\n            }else if(s.charAt(i) < t.charAt(i)){\\n                return true;\\n            }\\n            i++;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3255906,
                "title": "beats-100-150ms-o-n-dp-python",
                "content": "![image.png](https://assets.leetcode.com/users/images/9a79bf2f-9f47-444e-8bc3-ca459c23632d_1677941827.2932508.png)\\n\\n\\n**Time: O(Target*9)\\nSpace: O(Target)**\\n```\\ndef largestNumber(self, cost: List[int], target: int) -> str:\\n    val_key = dict()\\n    for k,v in enumerate(cost):\\n        val_key[v] = k+1\\n    cost = sorted(set(cost), reverse=True)\\n\\n    @lru_cache(None)\\n    def f(target):\\n        if target == 0:\\n            return 0\\n        res = -inf\\n        for v in cost:\\n            if v <= target:\\n                num = f(target - v)\\n                res = max(res, num*10 + val_key[v])\\n        return res\\n    \\n    res = f(target)\\n    return \"0\" if res==-inf else str(res)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef largestNumber(self, cost: List[int], target: int) -> str:\\n    val_key = dict()\\n    for k,v in enumerate(cost):\\n        val_key[v] = k+1\\n    cost = sorted(set(cost), reverse=True)\\n\\n    @lru_cache(None)\\n    def f(target):\\n        if target == 0:\\n            return 0\\n        res = -inf\\n        for v in cost:\\n            if v <= target:\\n                num = f(target - v)\\n                res = max(res, num*10 + val_key[v])\\n        return res\\n    \\n    res = f(target)\\n    return \"0\" if res==-inf else str(res)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2947104,
                "title": "c-memoization-dp-95-96-tc-passing-don-t-know-why",
                "content": "![image](https://assets.leetcode.com/users/images/7fdfb366-8588-4fb9-ab0b-2c22fd836944_1671909255.9675682.png)\\nall test-case are passing except the last one.. i tried to optimize the code by memoization but no change :(\\nSuggestion are appreciated.\\n\\n```\\n#define vvs vector<vector<string>>\\nclass Solution {\\npublic:\\n    string solve(int idx,int target,vector<int>&cost,vvs &dp){\\n        //base case\\n        if(target==0)return \"\";\\n        if(idx<=0)return \"0\";\\n        \\n        //check the cache\\n        if(dp[idx][target]!= \"-1\")\\n            return dp[idx][target];\\n        \\n        string pick=\"#\"; //no value\\n        \\n        string notpick = solve(idx-1,target,cost,dp);\\n        \\n        if(cost[idx-1]<=target)\\n            pick = solve(idx,target-cost[idx-1],cost,dp);\\n        \\n//if pick has novalue/invalid value,then solely depend on notpick\\n        if(pick == \"#\" || pick==\"0\"){\\n            //notpick = \"0\"/\"\"/somestring\\n            sort(notpick.begin(), notpick.end(), greater<char>());\\n            return dp[idx][target] = notpick;\\n        }\\n        \\n        //now pick has some value other than # and \"0\"\\n        if(notpick!=\"0\" && notpick!=\"\")\\n            sort(notpick.begin(), notpick.end(), greater<char>());\\n        pick = pick + to_string(idx);\\n        sort(pick.begin(), pick.end(), greater<char>());\\n        \\n        if(pick.size()>notpick.size() || pick==notpick)\\n            return dp[idx][target] = pick;\\n        else if(pick.size()<notpick.size())\\n            return dp[idx][target] = notpick;\\n        if(pick<notpick)\\n            return dp[idx][target] = notpick;\\n        return dp[idx][target] = pick;\\n    }\\n    string largestNumber(vector<int>& cost, int target) {\\n        int n=9;\\n        vvs dp(10,vector<string>(target+1,\"-1\"));\\n        return solve(n,target,cost,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n#define vvs vector<vector<string>>\\nclass Solution {\\npublic:\\n    string solve(int idx,int target,vector<int>&cost,vvs &dp){\\n        //base case\\n        if(target==0)return \"\";\\n        if(idx<=0)return \"0\";\\n        \\n        //check the cache\\n        if(dp[idx][target]!= \"-1\")\\n            return dp[idx][target];\\n        \\n        string pick=\"#\"; //no value\\n        \\n        string notpick = solve(idx-1,target,cost,dp);\\n        \\n        if(cost[idx-1]<=target)\\n            pick = solve(idx,target-cost[idx-1],cost,dp);\\n        \\n//if pick has novalue/invalid value,then solely depend on notpick\\n        if(pick == \"#\" || pick==\"0\"){\\n            //notpick = \"0\"/\"\"/somestring\\n            sort(notpick.begin(), notpick.end(), greater<char>());\\n            return dp[idx][target] = notpick;\\n        }\\n        \\n        //now pick has some value other than # and \"0\"\\n        if(notpick!=\"0\" && notpick!=\"\")\\n            sort(notpick.begin(), notpick.end(), greater<char>());\\n        pick = pick + to_string(idx);\\n        sort(pick.begin(), pick.end(), greater<char>());\\n        \\n        if(pick.size()>notpick.size() || pick==notpick)\\n            return dp[idx][target] = pick;\\n        else if(pick.size()<notpick.size())\\n            return dp[idx][target] = notpick;\\n        if(pick<notpick)\\n            return dp[idx][target] = notpick;\\n        return dp[idx][target] = pick;\\n    }\\n    string largestNumber(vector<int>& cost, int target) {\\n        int n=9;\\n        vvs dp(10,vector<string>(target+1,\"-1\"));\\n        return solve(n,target,cost,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2512933,
                "title": "c-solution-time-o-n-memory-o-n-easy-to-understand-dynamic-programming",
                "content": "```C#\r\npublic class Solution {\r\n    public string LargestNumber(int[] cost, int target) {\r\n        Dictionary<int, string> memo = new ();\r\n        string ans = Solve(target);\r\n        if (ans.Length == 0) return \"0\";\r\n        return ans;\r\n        \r\n        string Solve(int t) {\r\n            if (t < 0) return string.Empty;\r\n            if (memo.TryGetValue(t, out var memoizedResult)) return memoizedResult;\r\n\r\n            string max = string.Empty;\r\n            for (int i = cost.Length - 1; i >= 0; i--) {\r\n                if (cost[i] == t && max.Length == 0) max = (i + 1).ToString();\r\n                else if (cost[i] < t) {\r\n                    string maxForRemainingCost = Solve(t - cost[i]);\r\n                    if (maxForRemainingCost.Length > 0 && maxForRemainingCost.Length >= max.Length) {\r\n                        max = $\"{(i + 1)}{maxForRemainingCost}\";\r\n                    }\r\n                }\r\n            }\r\n\r\n            memo[t] = max;\r\n            return max;\r\n        }\r\n    }\r\n}\r\n```",
                "solutionTags": [
                    "C#",
                    "Dynamic Programming"
                ],
                "code": "```C#\r\npublic class Solution {\r\n    public string LargestNumber(int[] cost, int target) {\r\n        Dictionary<int, string> memo = new ();\r\n        string ans = Solve(target);\r\n        if (ans.Length == 0) return \"0\";\r\n        return ans;\r\n        \r\n        string Solve(int t) {\r\n            if (t < 0) return string.Empty;\r\n            if (memo.TryGetValue(t, out var memoizedResult)) return memoizedResult;\r\n\r\n            string max = string.Empty;\r\n            for (int i = cost.Length - 1; i >= 0; i--) {\r\n                if (cost[i] == t && max.Length == 0) max = (i + 1).ToString();\r\n                else if (cost[i] < t) {\r\n                    string maxForRemainingCost = Solve(t - cost[i]);\r\n                    if (maxForRemainingCost.Length > 0 && maxForRemainingCost.Length >= max.Length) {\r\n                        max = $\"{(i + 1)}{maxForRemainingCost}\";\r\n                    }\r\n                }\r\n            }\r\n\r\n            memo[t] = max;\r\n            return max;\r\n        }\r\n    }\r\n}\r\n```",
                "codeTag": "Java"
            },
            {
                "id": 2225928,
                "title": "java-dp-is-easy-10-mins-read-easy-understand",
                "content": "```\\nString[] dp;\\n    \\n    public String func(int[]cost,int t){\\n        if(t==0){\\n            return \"\";\\n        }\\n        if(dp[t]!=null){\\n            return dp[t];\\n        }\\n        String max=\"0\";\\n        for(int i=0;i<9;i++){\\n            if(t>=cost[i]){\\n                String curr=func(cost,t-cost[i]);\\n                if(curr.equals(\"0\")){\\n                    continue;\\n                }\\n                curr=(i+1)+curr;\\n                if((curr.length()>=max.length()&&max.compareTo(curr)<0)){\\n                    max=curr;\\n                }\\n            }\\n        }\\n        return dp[t]=max;\\n    } \\n    \\n    public String largestNumber(int[] cost, int target) {\\n        dp=new String[target+1];\\n        return func(cost,target);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nString[] dp;\\n    \\n    public String func(int[]cost,int t){\\n        if(t==0){\\n            return \"\";\\n        }\\n        if(dp[t]!=null){\\n            return dp[t];\\n        }\\n        String max=\"0\";\\n        for(int i=0;i<9;i++){\\n            if(t>=cost[i]){\\n                String curr=func(cost,t-cost[i]);\\n                if(curr.equals(\"0\")){\\n                    continue;\\n                }\\n                curr=(i+1)+curr;\\n                if((curr.length()>=max.length()&&max.compareTo(curr)<0)){\\n                    max=curr;\\n                }\\n            }\\n        }\\n        return dp[t]=max;\\n    } \\n    \\n    public String largestNumber(int[] cost, int target) {\\n        dp=new String[target+1];\\n        return func(cost,target);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1735928,
                "title": "cpp-recursive-knapsack",
                "content": "Knapsack with capacity as target and objects profit as 1 to 9 with respective weights with infinite occurences with capacity constraint(given as target) => t\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    \\n    vector<vector<string>> dp;\\n    //2d dp with great knapsack infinite intuition \\n    \\n    string fun(int i,int tar,vector<int> &cost){\\n        \\n        if(tar == 0){\\n            return \"\";\\n        }\\n        if(i == n) return \"-1\";\\n        \\n        if(dp[i][tar] != \"-2\") return dp[i][tar];\\n        \\n        if(tar < cost[i]){\\n            return dp[i][tar] = fun(i+1,tar,cost);\\n        }\\n        \\n        string l = fun(i,tar-cost[i],cost);\\n       \\n        string r = fun(i+1,tar,cost);\\n   \\n        //this is only checking of \"null string if there is no answer return -1\"\\n        if(l == \"-1\" and r == \"-1\"){\\n            return dp[i][tar] = \"-1\";\\n        }else if(l == \"-1\"){\\n            return dp[i][tar] = r;\\n        }else if(r == \"-1\"){\\n            return dp[i][tar] = l + to_string(i+1);\\n        }\\n        l = l + to_string(i+1);\\n        if(l.size() > r.size()) return dp[i][tar] = l;\\n        else if(r.size() > l.size()) return dp[i][tar] = r;\\n        \\n        for(int I=0;I<l.size();I++){\\n            if(l[I] > r[I]){\\n                return dp[i][tar] = l;\\n            }else if(l[I] < r[I]){\\n                return dp[i][tar] = r;\\n            }\\n        }\\n        return dp[i][tar] = l;\\n    \\n    }\\n    \\n    string largestNumber(vector<int>& cost, int tar) {\\n        n = cost.size();\\n        dp = vector<vector<string>> (n,vector<string> (tar+1,\"-2\"));\\n        string ans = fun(0,tar,cost);\\n        if(ans == \"-1\") return \"0\";\\n        return ans;     \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    int n;\\n    \\n    vector<vector<string>> dp;\\n    //2d dp with great knapsack infinite intuition \\n    \\n    string fun(int i,int tar,vector<int> &cost){\\n        \\n        if(tar == 0){\\n            return \"\";\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1432719,
                "title": "c-tabulation-backtracking-unbounded-knapsack",
                "content": "\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    static bool compare(pair<int,char>&a, pair<int,char>&b){\\n        return a.second<b.second;\\n    }\\n\\t\\n\\tstring largestNumber(vector<int>& cost, int target) {\\n        int n=cost.size();\\n        vector<pair<int,char>>val(n);\\n        for(int i=0;i<n;i++){\\n            val[i].first=cost[i];\\n            val[i].second=\\'1\\'+i;\\n        }\\n        sort(val.begin(),val.end(),compare);\\n        int dp[10][target+1];\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<=9;i++)dp[i][0]=0;\\n        for(int i=1;i<=9;i++){\\n            for(int j=1;j<=target;j++){\\n                dp[i][j]=dp[i-1][j];\\n                if(j-val[i-1].first>=0 && dp[i][j-val[i-1].first]!=-1)dp[i][j]=max(dp[i][j],1+dp[i][j-val[i-1].first]);\\n            }\\n        }\\n        \\n        if(dp[9][target]==-1)return \"0\";\\n        string ans=\"\";\\n        int i=9,j=target;\\n\\t\\t//generating output string by backtracking\\n        while(i>0 && j>0){\\n            int f=-1;\\n            if(j-val[i-1].first>=0 && dp[i][j-val[i-1].first]!=-1)f=1+dp[i][j-val[i-1].first];\\n            int s=dp[i-1][j];\\n            if(f>=s){\\n                ans.push_back(val[i-1].second);\\n                j-=val[i-1].first;\\n            }\\n            else{\\n                i--;\\n            }\\n        }\\n        return ans;\\n       \\n    }\\n};\\n```\\n\\nIf you have any query/suggestion/feedback , pls comment!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool compare(pair<int,char>&a, pair<int,char>&b){\\n        return a.second<b.second;\\n    }\\n\\t\\n\\tstring largestNumber(vector<int>& cost, int target) {\\n        int n=cost.size();\\n        vector<pair<int,char>>val(n);\\n        for(int i=0;i<n;i++){\\n            val[i].first=cost[i];\\n            val[i].second=\\'1\\'+i;\\n        }\\n        sort(val.begin(),val.end(),compare);\\n        int dp[10][target+1];\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<=9;i++)dp[i][0]=0;\\n        for(int i=1;i<=9;i++){\\n            for(int j=1;j<=target;j++){\\n                dp[i][j]=dp[i-1][j];\\n                if(j-val[i-1].first>=0 && dp[i][j-val[i-1].first]!=-1)dp[i][j]=max(dp[i][j],1+dp[i][j-val[i-1].first]);\\n            }\\n        }\\n        \\n        if(dp[9][target]==-1)return \"0\";\\n        string ans=\"\";\\n        int i=9,j=target;\\n\\t\\t//generating output string by backtracking\\n        while(i>0 && j>0){\\n            int f=-1;\\n            if(j-val[i-1].first>=0 && dp[i][j-val[i-1].first]!=-1)f=1+dp[i][j-val[i-1].first];\\n            int s=dp[i-1][j];\\n            if(f>=s){\\n                ans.push_back(val[i-1].second);\\n                j-=val[i-1].first;\\n            }\\n            else{\\n                i--;\\n            }\\n        }\\n        return ans;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1412578,
                "title": "a-common-mistake-in-python-solutions",
                "content": "I found many Python solutions claimed `O(target)` time while writing statements like\\n```python\\n# i in [1, 2, ..., 9]\\nvar1 = var2 * 10 + i\\n```\\n\\nUnfortunately, it\\'s by no means a constant operation. Python allows built-in unbounded intergers, giving a illusion that Python, unlike many other languages, makes it possible to perform arbitrary integer arithmetics in *constant time*, which is a great **mistake** made by many novice Python-only programmers.\\n\\nPython actually stores numbers larger than `2^63 - 1` in a C array (from [PEP 237](https://www.python.org/dev/peps/pep-0237/)):\\n```c\\nunion {\\n    long i;\\n    struct {\\n        unsigned long length;\\n        digit digits[1];\\n    } bignum;\\n};\\n```\\nwhich means both representation and arithmetic of large integers take `O(b)` time, where `b` is the length of number. In this problem, the number can be at most 5000 digits long, which is definitely not negligible.\\n\\nIn the worst case, such Python programs incur `O(target ^ 2)` time complexity. But the efficient implementation of large integer arithmetics in CPython saves those careless Python programmers. Nonetheless, in a real interview, any experienced programmer will almost no doubt ask you write a genuine `O(target)` solution.\\n\\nMany new programmers lack the knowledge of internal bit-level representations of integers, and thus make mistakes in both interviews and production code. To avoid such bugs, I strongly recommend reading *Computer Systems: A Programmer\\'s Perspective*, giving a moderate overview of details of the execution of programs in a computer system.\\n\\nLastly, I\\'ll give a truly `O(target)` Python solution below.\\n```python\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        @cache\\n        def largest_num(target: int) -> Tuple[int, int]:\\n            \"\"\"Return (length of lartest number, next digit).\"\"\"\\n            if target == 0:\\n                return 0, 0\\n            maxlen, digit = -1, -1\\n            for i in range(1, 10):\\n                if target >= cost[i-1]:\\n                    length, _ = largest_num(target - cost[i-1])\\n                    if length >= 0 and length+1 >= maxlen:\\n                        maxlen = length+1\\n                        digit = i\\n            return maxlen, digit\\n        \\n        length, digit = largest_num(target)\\n        if length == -1:\\n            return \\'0\\'\\n        else:\\n            ans = []\\n            while digit:\\n                ans.append(digit)\\n                target -= cost[digit-1]\\n                _, digit = largest_num(target)\\n            return \\'\\'.join(str(d) for d in ans)\\n```",
                "solutionTags": [],
                "code": "```python\\n# i in [1, 2, ..., 9]\\nvar1 = var2 * 10 + i\\n```\n```c\\nunion {\\n    long i;\\n    struct {\\n        unsigned long length;\\n        digit digits[1];\\n    } bignum;\\n};\\n```\n```python\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        @cache\\n        def largest_num(target: int) -> Tuple[int, int]:\\n            \"\"\"Return (length of lartest number, next digit).\"\"\"\\n            if target == 0:\\n                return 0, 0\\n            maxlen, digit = -1, -1\\n            for i in range(1, 10):\\n                if target >= cost[i-1]:\\n                    length, _ = largest_num(target - cost[i-1])\\n                    if length >= 0 and length+1 >= maxlen:\\n                        maxlen = length+1\\n                        digit = i\\n            return maxlen, digit\\n        \\n        length, digit = largest_num(target)\\n        if length == -1:\\n            return \\'0\\'\\n        else:\\n            ans = []\\n            while digit:\\n                ans.append(digit)\\n                target -= cost[digit-1]\\n                _, digit = largest_num(target)\\n            return \\'\\'.join(str(d) for d in ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1260590,
                "title": "70-90-python-dp-solution",
                "content": "Quick explanation:\\nThe first two lines involving \\'prices\\' reduces the number of costs we have to iterate through in the case of duplicate costs, as only the one corresponding to the highest value is needed.\\n\\nThe dp then constructs the solution for each value, t, until the target is reached.\\n```\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        prices = dict(zip(cost,[1,2,3,4,5,6,7,8,9]))\\n        prices = sorted(prices.items())\\n        \\n        dp = [0] + [-1]*target\\n        \\n        for t in range(1,target+1):\\n            cur = -1\\n            for p, c in prices:\\n                if t >= p and dp[t-p] != -1:\\n                    cur = max(cur, dp[t-p]*10 + c)\\n            dp[t] = cur\\n                    \\n        if dp[-1] != -1:\\n            return str(dp[-1])\\n        return \"0\"\\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        prices = dict(zip(cost,[1,2,3,4,5,6,7,8,9]))\\n        prices = sorted(prices.items())\\n        \\n        dp = [0] + [-1]*target\\n        \\n        for t in range(1,target+1):\\n            cur = -1\\n            for p, c in prices:\\n                if t >= p and dp[t-p] != -1:\\n                    cur = max(cur, dp[t-p]*10 + c)\\n            dp[t] = cur\\n                    \\n        if dp[-1] != -1:\\n            return str(dp[-1])\\n        return \"0\"\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1113027,
                "title": "python3-top-down-dp",
                "content": "\\n```\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        \\n        @cache\\n        def fn(x): \\n            \"\"\"Return max integer given target x.\"\"\"\\n            if x == 0: return 0\\n            if x < 0: return -inf \\n            return max(fn(x - c) * 10 + i + 1 for i, c in enumerate(cost))\\n        \\n        return str(max(0, fn(target)))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        \\n        @cache\\n        def fn(x): \\n            \"\"\"Return max integer given target x.\"\"\"\\n            if x == 0: return 0\\n            if x < 0: return -inf \\n            return max(fn(x - c) * 10 + i + 1 for i, c in enumerate(cost))\\n        \\n        return str(max(0, fn(target)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 891520,
                "title": "c-very-short-and-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& cost, int tar) \\n    {\\n        vector<string>V(tar+1,\"-1\");    \\n        V[0]=\"\";\\n        for(int i=1;i<=tar;i++)\\n        {\\n            for(int j=0;j<cost.size();j++)\\n            {\\n                if(cost[j]<=i)\\n                {\\n                    if(V[i-cost[j]]!=\"-1\")\\n                    {\\n                        string h=to_string(j+1)+V[i-cost[j]];\\n                        if(h.size()>=V[i].size()||V[i]==\"-1\")\\n                            V[i]=h;                        \\n                    }\\n                }\\n            }\\n        }\\n        return V[tar]!=\"-1\"?V[tar]:\"0\";\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string largestNumber(vector<int>& cost, int tar) \\n    {\\n        vector<string>V(tar+1,\"-1\");    \\n        V[0]=\"\";\\n        for(int i=1;i<=tar;i++)\\n        {\\n            for(int j=0;j<cost.size();j++)\\n            {\\n                if(cost[j]<=i)\\n                {\\n                    if(V[i-cost[j]]!=\"-1\")\\n                    {\\n                        string h=to_string(j+1)+V[i-cost[j]];\\n                        if(h.size()>=V[i].size()||V[i]==\"-1\")\\n                            V[i]=h;                        \\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 824970,
                "title": "c-simple-knapsack-dp",
                "content": "If you\\'ve never been encountered with **knapsack dp** problem, please try to learn it first.\\nTime complexity : O(n).\\n\\n```\\nbool greater(string s1, string s2)\\n{\\n\\treturn s2.size() == s1.size() ? s2 > s1 : s2.size() > s1.size();\\n}\\n\\nstring largestNumber(vector<int>& cost, int target) \\n{\\n\\tunordered_map<int, char> digits;\\n\\n\\tfor (int i = 0; i < cost.size(); ++i) \\n\\t\\tdigits[cost[i]] = i + 1 + \\'0\\';\\n\\n\\tvector<string> dp(target + 1);\\n\\tdp[0] = \"0\";\\n\\n\\tfor (int i = 1; i <= target; ++i)\\n\\t\\tfor (auto [cost, ch] : digits)\\n\\t\\t  if (cost <= i && !dp[i - cost].empty() && greater(dp[i], dp[i - cost] + ch))\\n\\t\\t\\t\\tdp[i] = dp[i - cost] + ch;\\n\\n\\treturn dp.back().size() <= 1 ? \"0\" : dp.back().substr(1);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool greater(string s1, string s2)\\n{\\n\\treturn s2.size() == s1.size() ? s2 > s1 : s2.size() > s1.size();\\n}\\n\\nstring largestNumber(vector<int>& cost, int target) \\n{\\n\\tunordered_map<int, char> digits;\\n\\n\\tfor (int i = 0; i < cost.size(); ++i) \\n\\t\\tdigits[cost[i]] = i + 1 + \\'0\\';\\n\\n\\tvector<string> dp(target + 1);\\n\\tdp[0] = \"0\";\\n\\n\\tfor (int i = 1; i <= target; ++i)\\n\\t\\tfor (auto [cost, ch] : digits)\\n\\t\\t  if (cost <= i && !dp[i - cost].empty() && greater(dp[i], dp[i - cost] + ch))\\n\\t\\t\\t\\tdp[i] = dp[i - cost] + ch;\\n\\n\\treturn dp.back().size() <= 1 ? \"0\" : dp.back().substr(1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 756859,
                "title": "99-78-cpp-same-as-coin-change-with-given-target-can-take-as-many-as-coins-of-same-denom",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& cost, int target) {\\n        int n=cost.size();\\n        int dp[n+1][target+1];\\n        for(int i=1;i<=n;i++)\\n            dp[i][0]=0;\\n        for(int j=0;j<=target;j++)\\n            dp[0][j]=-1;\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=target;j++){\\n                if(j<cost[i-1]){\\n                    dp[i][j]=dp[i-1][j];\\n                }\\n                else{\\n                    dp[i][j]=dp[i-1][j];\\n                    if(dp[i][j-cost[i-1]]!=-1){\\n                        dp[i][j]=max(dp[i][j],1+dp[i][j-cost[i-1]]);\\n                    }\\n                }\\n            }\\n        }\\n        if(dp[n][target]==-1)\\n            return \"0\";\\n        int i=n,j=target;\\n        string ans=\"\";\\n        while(!(i==0||j==0)){\\n            if(cost[i-1]>j){\\n                i--;\\n            }\\n            else{\\n                if(dp[i][j]==dp[i][j-cost[i-1]]+1){\\n                    j=j-cost[i-1];\\n                    ans+=i+48;\\n                }\\n                else\\n                    i--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& cost, int target) {\\n        int n=cost.size();\\n        int dp[n+1][target+1];\\n        for(int i=1;i<=n;i++)\\n            dp[i][0]=0;\\n        for(int j=0;j<=target;j++)\\n            dp[0][j]=-1;\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=target;j++){\\n                if(j<cost[i-1]){\\n                    dp[i][j]=dp[i-1][j];\\n                }\\n                else{\\n                    dp[i][j]=dp[i-1][j];\\n                    if(dp[i][j-cost[i-1]]!=-1){\\n                        dp[i][j]=max(dp[i][j],1+dp[i][j-cost[i-1]]);\\n                    }\\n                }\\n            }\\n        }\\n        if(dp[n][target]==-1)\\n            return \"0\";\\n        int i=n,j=target;\\n        string ans=\"\";\\n        while(!(i==0||j==0)){\\n            if(cost[i-1]>j){\\n                i--;\\n            }\\n            else{\\n                if(dp[i][j]==dp[i][j-cost[i-1]]+1){\\n                    j=j-cost[i-1];\\n                    ans+=i+48;\\n                }\\n                else\\n                    i--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 640349,
                "title": "c-code-with-commented-line-o-9-2-target-top-down",
                "content": "```\\nclass Solution {\\npublic:\\n    int goal,A[5001];\\n    map<int,string>dp;   // for memorizing \\n    bool check(string a,string b)  // this function checks if b number is greater than a\\n    {\\n        if(a.size()!=b.size())  // if b\\'s size is bigger\\n        {\\n            if(a.size()<b.size())  \\n                return true;\\n            else\\n                return false;\\n        }\\n        if(a<b)  // if there of same size whichever one is bigger\\n         return true;\\n        else\\n         return false;\\n    }\\n    string make(int pos)\\n    {\\n        if(pos>goal)  // cant make it just return some garbage i returned \"0\"\\n            return \"0\";\\n        if(pos==goal) // we make it return empty string \\n            return \"\";\\n        if(dp[pos].size()>0)  // we have encounter this pos before so return from memory\\n            return dp[pos];\\n        dp[pos]=\"0\";  // if there is no way it should return \"0\"\\n        for(int i=1;i<=9;i++)\\n        {\\n            string a=make(pos+A[i-1]);\\n            if(a!=\"0\")  // if its valid (you can check your garbage )\\n            {\\n                  a=(char)(i+\\'0\\')+a;  // add that char \\n                  if(check(dp[pos],a)) // check if its bigger (optimal)\\n                      dp[pos]=a; // save the optimal one in the dp\\n            }\\n        }\\n        return dp[pos];\\n    }\\n    string largestNumber(vector<int>& cost, int target) {\\n        goal = target;  // for using it in make function \\n        for(int i=0;i<cost.size();i++)\\n        {\\n            A[i]=cost[i]; // for using it in make function \\n        }\\n        return make(0); // return the optimal answer when we used all target\\n    }\\n};\\n```\\n\\nIF you need more explanation see [Here](https://sohojeprogramming.blogspot.com/2020/05/1449-form-largest-integer-with-digits.html)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int goal,A[5001];\\n    map<int,string>dp;   // for memorizing \\n    bool check(string a,string b)  // this function checks if b number is greater than a\\n    {\\n        if(a.size()!=b.size())  // if b\\'s size is bigger\\n        {\\n            if(a.size()<b.size())  \\n                return true;\\n            else\\n                return false;\\n        }\\n        if(a<b)  // if there of same size whichever one is bigger\\n         return true;\\n        else\\n         return false;\\n    }\\n    string make(int pos)\\n    {\\n        if(pos>goal)  // cant make it just return some garbage i returned \"0\"\\n            return \"0\";\\n        if(pos==goal) // we make it return empty string \\n            return \"\";\\n        if(dp[pos].size()>0)  // we have encounter this pos before so return from memory\\n            return dp[pos];\\n        dp[pos]=\"0\";  // if there is no way it should return \"0\"\\n        for(int i=1;i<=9;i++)\\n        {\\n            string a=make(pos+A[i-1]);\\n            if(a!=\"0\")  // if its valid (you can check your garbage )\\n            {\\n                  a=(char)(i+\\'0\\')+a;  // add that char \\n                  if(check(dp[pos],a)) // check if its bigger (optimal)\\n                      dp[pos]=a; // save the optimal one in the dp\\n            }\\n        }\\n        return dp[pos];\\n    }\\n    string largestNumber(vector<int>& cost, int target) {\\n        goal = target;  // for using it in make function \\n        for(int i=0;i<cost.size();i++)\\n        {\\n            A[i]=cost[i]; // for using it in make function \\n        }\\n        return make(0); // return the optimal answer when we used all target\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 639504,
                "title": "python-o-n-to-o-n-in-stack-recursion-dp",
                "content": "**Solution 1:**  O(N\\xB2)\\n\\nwhile `st` is not empty, do\\n`acc, num = st.pop()`\\nif `acc < target`, then push `acc + price, num + digit` to `st`, where `price:digit \\u2208 costs`\\nelif `acc == target`, then compare `ans` to `num`, assign the larger **string** to `ans`  \\n\\nNote: both while loop and inner `num + digit` take O(N).\\n\\n```python\\ndef largestNumber(self, cost, target):\\n    ans, st = [0, \"0\"], [[0, \"\"]]\\n\\tcosts = {price: str(i + 1) for i, price in enumerate(cost)}\\n    while st:\\n        acc, num = st.pop()\\n        if acc < target:\\n            st += ([acc + price, num + digit] for price, digit in costs.items())\\n        elif acc == target:\\n            ans = max(ans, [len(num), num])\\n    return ans.pop()\\n```\\n\\n\\n**Solution 2:**  \\u2248 O(N)\\n\\nwhile `st` is not empty, do\\n`acc, num = st.pop()`\\nif `acc < target`, then push `acc + price, num * 10 + digit` to `st`, where `price:digit \\u2208 costs`\\nelif `acc == target`, then compare `ans` to `num`, assign the larger **integer** to `ans`  \\n\\nNote: Python supports bigint by default, but the performance is expected to decay if the number becomes too large. \\n\\n```python\\ndef largestNumber(self, cost, target):\\n    ans, st = 0, [[0, 0]]\\n\\tcosts = {price: i + 1 for i, price in enumerate(cost)}\\n    while st:\\n        acc, num = st.pop()\\n        if acc < target:\\n            st += ([acc + price, num * 10 + digit] for price, digit in costs.items())\\n        elif acc == target:\\n            ans = max(ans, num)\\n    return str(ans)\\n```\\n\\n\\n**Solution 3:** \\u2248 O(N)\\n\\nrecur(`acc`) = `-1`, if `acc > target`\\nrecur(`acc`) = `0`, if `acc == target`\\nrecur(`acc`) = max(`recur(acc + price) * 10 + digit`), where `price:digit \\u2208 costs`\\n\\nNote: same as above\\n\\n```python\\ndef largestNumber(self, cost, target):\\n    costs = {price: i + 1 for i, price in enumerate(cost)}\\n    def recur(acc):\\n        if acc > target:\\n            return -1\\n        if acc == target:\\n            return 0\\n        return max(recur(acc + price) * 10 + digit for price, digit in costs.items())  \\n    return str(max(0, recur(0)))\\n```\\n\\n\\n**Solution 4:** O(N) `@lee215`\\n\\n- Initialize 1D DP array;\\n- Establish the state transition for the max **number** of digits reachable;\\n- Backtrack the max number of digits reachable times the biggest digit possible to build the string.\\n\\n\\n```python\\ndef largestNumber(self, cost, target):\\n    dp = [0] + [-5001] * (target + 5000)\\n    costs = {price: str(i + 1) for i, price in enumerate(cost)}\\n    for i in range(1, target + 1):\\n        dp[i] = max(dp[i - price] for price in costs) + 1\\n\\t\\n\\tans = []\\n\\tif dp[target] < 0:\\n        return \"0\"\\t\\n    while target:\\n        _, digit, target = max(\\n            [dp[(i := target - price)], digit, i] for price, digit in costs.items()\\n        )\\n        ans.append(digit)\\n    return \"\".join(ans)\\n```\\n\\n**Solution 5:** O(N) `@votrubac`\\n\\n- Initialize 1D DP array;\\n- Establish the state transition for triplets of the max **number** of digits reachable, the max digit possible itself and the cost;\\n- Backtrack the digits reachable to build the string.\\n\\n```python\\ndef largestNumber(self, cost, target):\\n    dp = [[0, 0, 0]] + [[-5001, 0, 0] for _ in range(target + 5000)]\\n    costs = {price: str(i + 1) for i, price in enumerate(cost)}\\n    for i in range(1, target + 1):\\n        dp[i] = max(\\n            [num := dp[i - price][0] + 1, digit, price]\\n            for price, digit in costs.items()\\n        )\\n\\t\\n\\tans = []\\n    if (num := dp[target][0]) < 0:\\n        return \"0\"\\n    while target:\\n        ans.append(digit := dp[target][1])\\n        target -= (price := dp[target][2])\\n    return \"\".join(ans)\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```python\\ndef largestNumber(self, cost, target):\\n    ans, st = [0, \"0\"], [[0, \"\"]]\\n\\tcosts = {price: str(i + 1) for i, price in enumerate(cost)}\\n    while st:\\n        acc, num = st.pop()\\n        if acc < target:\\n            st += ([acc + price, num + digit] for price, digit in costs.items())\\n        elif acc == target:\\n            ans = max(ans, [len(num), num])\\n    return ans.pop()\\n```\n```python\\ndef largestNumber(self, cost, target):\\n    ans, st = 0, [[0, 0]]\\n\\tcosts = {price: i + 1 for i, price in enumerate(cost)}\\n    while st:\\n        acc, num = st.pop()\\n        if acc < target:\\n            st += ([acc + price, num * 10 + digit] for price, digit in costs.items())\\n        elif acc == target:\\n            ans = max(ans, num)\\n    return str(ans)\\n```\n```python\\ndef largestNumber(self, cost, target):\\n    costs = {price: i + 1 for i, price in enumerate(cost)}\\n    def recur(acc):\\n        if acc > target:\\n            return -1\\n        if acc == target:\\n            return 0\\n        return max(recur(acc + price) * 10 + digit for price, digit in costs.items())  \\n    return str(max(0, recur(0)))\\n```\n```python\\ndef largestNumber(self, cost, target):\\n    dp = [0] + [-5001] * (target + 5000)\\n    costs = {price: str(i + 1) for i, price in enumerate(cost)}\\n    for i in range(1, target + 1):\\n        dp[i] = max(dp[i - price] for price in costs) + 1\\n\\t\\n\\tans = []\\n\\tif dp[target] < 0:\\n        return \"0\"\\t\\n    while target:\\n        _, digit, target = max(\\n            [dp[(i := target - price)], digit, i] for price, digit in costs.items()\\n        )\\n        ans.append(digit)\\n    return \"\".join(ans)\\n```\n```python\\ndef largestNumber(self, cost, target):\\n    dp = [[0, 0, 0]] + [[-5001, 0, 0] for _ in range(target + 5000)]\\n    costs = {price: str(i + 1) for i, price in enumerate(cost)}\\n    for i in range(1, target + 1):\\n        dp[i] = max(\\n            [num := dp[i - price][0] + 1, digit, price]\\n            for price, digit in costs.items()\\n        )\\n\\t\\n\\tans = []\\n    if (num := dp[target][0]) < 0:\\n        return \"0\"\\n    while target:\\n        ans.append(digit := dp[target][1])\\n        target -= (price := dp[target][2])\\n    return \"\".join(ans)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 639140,
                "title": "easy-dynamic-programming-with-commented-code",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& cost, int target) {\\n\\t\\t//dp[i] stores the length of the largest number whose cost is i.\\n        vector<int> dp(target + 1, -1);\\n        \\n\\t\\t//dig[i] stores the first digit of the largest number whose cost is i and length is dp[i].\\n\\t\\tvector<int> dig(target + 1, 0);\\n        \\n\\t\\t//Base case - largest number that could be formed using 0 cost is 0 itself.\\n\\t\\tdp[0] = 0;\\n        \\n\\t\\t/*\\n\\t\\tFor each cost i, we are trying each digits from 1 to 9 as the first digit, and finding the maximum length.\\n\\t\\tAmong all first digit, which results with the maximum length, we chose the one with the maximum first digit, \\n\\t\\tso ran the inner loop in reverse order, and update only when the value exceeds the maximum value encountered so far. \\n\\t\\t*/\\n\\t\\t\\n\\t\\tfor(int i = 1; i <= target; ++i) {\\n            for(int d = 9; d >= 1; --d) {\\n                if(i >= cost[d - 1] && dp[i - cost[d - 1]] != -1) {\\n                    if(1 + dp[i - cost[d - 1]] > dp[i]) {\\n                        dp[i] = 1 + dp[i - cost[d - 1]];\\n                        dig[i] = d;\\n                    }\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\t// No number could be formed whose cost is equal to target.\\n        if(dp[target] == -1) \\n            return \"0\";\\n        \\n\\t\\t//Restore the largest number formed whose cost is equal to target, using the dig[] array we calculated above.\\n        string res = \"\";\\n        while(target > 0) {\\n            res += (char) (dig[target] + \\'0\\');\\n            target -= cost[dig[target] - 1];\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nI hope you understood the code. If you understood, feel free to give +1 :) If you didn\\'t, please let me know in the comments section below.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& cost, int target) {\\n\\t\\t//dp[i] stores the length of the largest number whose cost is i.\\n        vector<int> dp(target + 1, -1);\\n        \\n\\t\\t//dig[i] stores the first digit of the largest number whose cost is i and length is dp[i].\\n\\t\\tvector<int> dig(target + 1, 0);\\n        \\n\\t\\t//Base case - largest number that could be formed using 0 cost is 0 itself.\\n\\t\\tdp[0] = 0;\\n        \\n\\t\\t/*\\n\\t\\tFor each cost i, we are trying each digits from 1 to 9 as the first digit, and finding the maximum length.\\n\\t\\tAmong all first digit, which results with the maximum length, we chose the one with the maximum first digit, \\n\\t\\tso ran the inner loop in reverse order, and update only when the value exceeds the maximum value encountered so far. \\n\\t\\t*/\\n\\t\\t\\n\\t\\tfor(int i = 1; i <= target; ++i) {\\n            for(int d = 9; d >= 1; --d) {\\n                if(i >= cost[d - 1] && dp[i - cost[d - 1]] != -1) {\\n                    if(1 + dp[i - cost[d - 1]] > dp[i]) {\\n                        dp[i] = 1 + dp[i - cost[d - 1]];\\n                        dig[i] = d;\\n                    }\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\t// No number could be formed whose cost is equal to target.\\n        if(dp[target] == -1) \\n            return \"0\";\\n        \\n\\t\\t//Restore the largest number formed whose cost is equal to target, using the dig[] array we calculated above.\\n        string res = \"\";\\n        while(target > 0) {\\n            res += (char) (dig[target] + \\'0\\');\\n            target -= cost[dig[target] - 1];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 637288,
                "title": "easy-c-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    string maxString(string a, string b){\\n        if(a.size()>b.size())\\n            return a;\\n        else if(a.size()<b.size())\\n            return b;\\n        else{\\n            if(a>b)\\n                return a;\\n            else\\n                return b;\\n        }\\n        return \"\";\\n    }\\n    \\n    string largestNumber(vector<int>& cost, int target) {\\n        vector<vector<string>> dp(10, vector<string>(target+1, \"0\")); // 0 means no path possible\\n        \\n        for(int i=0; i<10; i++)\\n            dp[i][0]=\"\"; // means path possible when cost is 0.\\n            \\n        for(int i=1; i<10; i++){\\n            for(int j=1; j<=target; j++){\\n                dp[i][j]=dp[i-1][j];\\n                if(cost[i-1]<=j){\\n                    string partial;\\n                    if(dp[i][j-cost[i-1]]!=\"0\"){ // if not 0 i.e. path possible after choosing this element\\n                        partial=to_string(i)+dp[i][j-cost[i-1]];\\n                        dp[i][j]=maxString(dp[i][j], partial); // Custom max string as cannot compare string as it only compares first character.\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[9][target];\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    string maxString(string a, string b){\\n        if(a.size()>b.size())\\n            return a;\\n        else if(a.size()<b.size())\\n            return b;\\n        else{\\n            if(a>b)\\n                return a;\\n            else\\n                return b;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 636835,
                "title": "python-unbounded-knapsack-problem",
                "content": "It is an unbounded knapsack problem\\n```\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        \"\"\"unbounded knapsack\\n        dp[i][j] = the largest number while choosing i-th cost with target == j\\n        \"\"\"\\n        dp = [[0] * (target+1) for _ in range(10)]\\n        for i in range(10):\\n            dp[i][0] = 0\\n        for j in range(1, target+1):\\n            dp[0][j] = -sys.maxsize\\n        for i in range(1, 10):\\n            # i: 1 to 9\\n            # num: 9 to 1 i.e. 10-i\\n            # cost: cost[8 to 0] i.e. cost[9-i]\\n            for j in range(1, target+1):\\n                if j >= cost[9-i]:\\n                    dp[i][j] = max(dp[i-1][j], (dp[i][j-cost[9-i]] * 10) + 10-i)\\n                else:\\n                    dp[i][j] = dp[i-1][j]\\n        ans = dp[-1][target]\\n        return str(ans) if ans > 0 else \\'0\\'\\n```\\n\\nA more concise version:\\n```\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        dp = [0] + [-sys.maxsize] * target\\n        for i in range(1, 10):\\n            for j in range(1, target+1):\\n                if j >= cost[9-i]:\\n                    dp[j] = max(dp[j], (dp[j-cost[9-i]] * 10) + 10-i)\\n        return str(dp[target]) if dp[target] > 0 else \\'0\\'\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        \"\"\"unbounded knapsack\\n        dp[i][j] = the largest number while choosing i-th cost with target == j\\n        \"\"\"\\n        dp = [[0] * (target+1) for _ in range(10)]\\n        for i in range(10):\\n            dp[i][0] = 0\\n        for j in range(1, target+1):\\n            dp[0][j] = -sys.maxsize\\n        for i in range(1, 10):\\n            # i: 1 to 9\\n            # num: 9 to 1 i.e. 10-i\\n            # cost: cost[8 to 0] i.e. cost[9-i]\\n            for j in range(1, target+1):\\n                if j >= cost[9-i]:\\n                    dp[i][j] = max(dp[i-1][j], (dp[i][j-cost[9-i]] * 10) + 10-i)\\n                else:\\n                    dp[i][j] = dp[i-1][j]\\n        ans = dp[-1][target]\\n        return str(ans) if ans > 0 else \\'0\\'\\n```\n```\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        dp = [0] + [-sys.maxsize] * target\\n        for i in range(1, 10):\\n            for j in range(1, target+1):\\n                if j >= cost[9-i]:\\n                    dp[j] = max(dp[j], (dp[j-cost[9-i]] * 10) + 10-i)\\n        return str(dp[target]) if dp[target] > 0 else \\'0\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 636639,
                "title": "golang-simple-recursive-memo",
                "content": "```\\nfunc largestNumber(cost []int, target int) string {\\n\\tdata := map[int]string{}\\n\\tvar dfs func(t int) string\\n\\tdfs = func(t int) string {\\n\\t\\tif s, ok := data[t]; ok {\\n\\t\\t\\treturn s\\n\\t\\t} else {\\n\\t\\t\\tvar res string\\n\\t\\t\\tfor i := 0; i < len(cost); i++ {\\n\\t\\t\\t\\tif cost[i] < t {\\n\\t\\t\\t\\t\\tnext := dfs(t - cost[i])\\n\\t\\t\\t\\t\\tif len(next) > 0 {\\n\\t\\t\\t\\t\\t\\tres = max(res, string(\\'0\\'+i+1)+next)\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else if cost[i] == t {\\n\\t\\t\\t\\t\\tres = max(res, string(\\'0\\'+i+1))\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tdata[t] = res\\n\\t\\t\\treturn res\\n\\t\\t}\\n\\t}\\n\\tres := dfs(target)\\n\\tif res == \"\" {\\n\\t\\treturn \"0\"\\n\\t}\\n\\treturn res\\n}\\nfunc max(i, j string) string {\\n\\tif len(i) > len(j) {\\n\\t\\treturn i\\n\\t}\\n\\tif len(j) > len(i) {\\n\\t\\treturn j\\n\\t}\\n\\tif i > j {\\n\\t\\treturn i\\n\\t}\\n\\treturn j\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Recursion"
                ],
                "code": "```\\nfunc largestNumber(cost []int, target int) string {\\n\\tdata := map[int]string{}\\n\\tvar dfs func(t int) string\\n\\tdfs = func(t int) string {\\n\\t\\tif s, ok := data[t]; ok {\\n\\t\\t\\treturn s\\n\\t\\t} else {\\n\\t\\t\\tvar res string\\n\\t\\t\\tfor i := 0; i < len(cost); i++ {\\n\\t\\t\\t\\tif cost[i] < t {\\n\\t\\t\\t\\t\\tnext := dfs(t - cost[i])\\n\\t\\t\\t\\t\\tif len(next) > 0 {\\n\\t\\t\\t\\t\\t\\tres = max(res, string(\\'0\\'+i+1)+next)\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else if cost[i] == t {\\n\\t\\t\\t\\t\\tres = max(res, string(\\'0\\'+i+1))\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tdata[t] = res\\n\\t\\t\\treturn res\\n\\t\\t}\\n\\t}\\n\\tres := dfs(target)\\n\\tif res == \"\" {\\n\\t\\treturn \"0\"\\n\\t}\\n\\treturn res\\n}\\nfunc max(i, j string) string {\\n\\tif len(i) > len(j) {\\n\\t\\treturn i\\n\\t}\\n\\tif len(j) > len(i) {\\n\\t\\treturn j\\n\\t}\\n\\tif i > j {\\n\\t\\treturn i\\n\\t}\\n\\treturn j\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 635843,
                "title": "c-recursive-memoization",
                "content": "```\\nclass Solution {\\nprivate:\\n    vector<string> dp;\\n    \\n    bool bigger(string n, string p)\\n    {\\n        return n.length() > p.length() || (n.length() == p.length() && n > p);\\n    }\\n    \\n    string form(vector<int> &cost,int target)\\n    {\\n        if(target == 0)\\n            return \"\";\\n        else if(target < 0)\\n            return \"0\";\\n        \\n        if(dp[target] != \"-1\")\\n            return dp[target];\\n        \\n        string ans = \"0\";\\n        for(int i = 9; i>= 1;i--)\\n        {\\n            if(cost[i-1] <= target)\\n            {\\n                string res = form(cost, target - cost[i-1]);\\n                if(res == \"0\")\\n                    continue;\\n                res = to_string(i)+res;\\n                \\n                if(bigger(res, ans))\\n                    ans = res;\\n            }\\n        }\\n        \\n        dp[target] = ans;\\n        return ans;\\n    }\\npublic:\\n    string largestNumber(vector<int>& cost, int target) \\n    {\\n        dp.clear();\\n        dp.resize(target+1, \"-1\");\\n        \\n        \\n        return form(cost, target);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<string> dp;\\n    \\n    bool bigger(string n, string p)\\n    {\\n        return n.length() > p.length() || (n.length() == p.length() && n > p);\\n    }\\n    \\n    string form(vector<int> &cost,int target)\\n    {\\n        if(target == 0)\\n            return \"\";\\n        else if(target < 0)\\n            return \"0\";\\n        \\n        if(dp[target] != \"-1\")\\n            return dp[target];\\n        \\n        string ans = \"0\";\\n        for(int i = 9; i>= 1;i--)\\n        {\\n            if(cost[i-1] <= target)\\n            {\\n                string res = form(cost, target - cost[i-1]);\\n                if(res == \"0\")\\n                    continue;\\n                res = to_string(i)+res;\\n                \\n                if(bigger(res, ans))\\n                    ans = res;\\n            }\\n        }\\n        \\n        dp[target] = ans;\\n        return ans;\\n    }\\npublic:\\n    string largestNumber(vector<int>& cost, int target) \\n    {\\n        dp.clear();\\n        dp.resize(target+1, \"-1\");\\n        \\n        \\n        return form(cost, target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 635671,
                "title": "c-bottom-up-dp-o-n",
                "content": "\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& cost, int target) {\\n        vector<string>dp(target+1,\"-1\"),mask(10);\\n        for(int i=1;i<=target;i++)\\n        {\\n            for(int j=0;j<cost.size();j++)\\n            {\\n                if(i==cost[j])\\n                {\\n                       string s1=to_string(j+1);\\n                        if(dp[i]!=\"-1\")\\n                        {\\n                          if(dp[i].size()<=s1.size())\\n                              dp[i]=s1;\\n                        }\\n                        else\\n                        dp[i]=s1;\\n                }\\n                else if(i>cost[j])\\n                {\\n                    if(dp[i-cost[j]]!=\"-1\")\\n                    {\\n                        string s1=to_string(j+1)+dp[i-cost[j]];\\n                        if(dp[i]!=\"-1\")\\n                        {\\n                          if(dp[i].size()<=s1.size())\\n                              dp[i]=s1;\\n                        }\\n                        else\\n                        dp[i]=s1;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if(dp[target]==\"-1\")\\n            return \"0\";\\n        sort(dp[target].rbegin(),dp[target].rend());\\n        return dp[target];\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string largestNumber(vector<int>& cost, int target) {\\n        vector<string>dp(target+1,\"-1\"),mask(10);\\n        for(int i=1;i<=target;i++)\\n        {\\n            for(int j=0;j<cost.size();j++)\\n            {\\n                if(i==cost[j])\\n                {\\n                       string s1=to_string(j+1);\\n                        if(dp[i]!=\"-1\")\\n                        {\\n                          if(dp[i].size()<=s1.size())\\n                              dp[i]=s1;\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 635669,
                "title": "simple-recursive-dp",
                "content": "```\\nclass Solution {\\n    Map<Integer, Integer> map2 = new HashMap<>();\\n    Map<Integer, String> dp = new HashMap<>();\\n    \\n    public String largestNumber(int[] cost, int target) {\\n        for(int i = 0; i < cost.length; ++i) map2.put(cost[i], i + 1);\\n        \\n        String sol = helper(target);\\n        return (sol == null) ? \"0\" : sol;\\n    }\\n    \\n    public String helper(int remaining) {\\n        if(remaining < 0) return null;\\n        if(remaining == 0) return \"\";\\n        if(dp.containsKey(remaining)) return dp.get(remaining);\\n        \\n        String cur = null;\\n        for(int c : map2.keySet()){\\n            String next = helper(remaining - c);\\n            if(next != null){\\n                String totalString = String.valueOf(map2.get(c)) + next;\\n                if(cur == null || \\n                   totalString.length() > cur.length() ||\\n                   (totalString.length() == cur.length() && (totalString).compareTo(cur) > 0)) {\\n                    cur = totalString;\\n                }\\n            }\\n        }\\n        \\n        dp.put(remaining, cur);\\n        return cur;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Map<Integer, Integer> map2 = new HashMap<>();\\n    Map<Integer, String> dp = new HashMap<>();\\n    \\n    public String largestNumber(int[] cost, int target) {\\n        for(int i = 0; i < cost.length; ++i) map2.put(cost[i], i + 1);\\n        \\n        String sol = helper(target);\\n        return (sol == null) ? \"0\" : sol;\\n    }\\n    \\n    public String helper(int remaining) {\\n        if(remaining < 0) return null;\\n        if(remaining == 0) return \"\";\\n        if(dp.containsKey(remaining)) return dp.get(remaining);\\n        \\n        String cur = null;\\n        for(int c : map2.keySet()){\\n            String next = helper(remaining - c);\\n            if(next != null){\\n                String totalString = String.valueOf(map2.get(c)) + next;\\n                if(cur == null || \\n                   totalString.length() > cur.length() ||\\n                   (totalString.length() == cur.length() && (totalString).compareTo(cur) > 0)) {\\n                    cur = totalString;\\n                }\\n            }\\n        }\\n        \\n        dp.put(remaining, cur);\\n        return cur;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 635408,
                "title": "python-knapsack-dp",
                "content": "```\\nclass Solution(object):\\n    def largestNumber(self, cost, target):\\n        \"\"\"\\n        :type cost: List[int]\\n        :type target: int\\n        :rtype: str\\n        \"\"\"\\n        d = {}\\n        for i,c in enumerate(cost,1):\\n            d[c] = i\\n        \\n        n = len(d)\\n        \\n        dp = [\"\" for _ in range(target+1)]\\n        costs = sorted(d.items(),key = lambda x: x[1])\\n        \\n        for k,v in costs:\\n            for i in range(1,target+1):\\n                if i > k:\\n                    if dp[i-k]:\\n                        if int(dp[i-k][0]) > v:\\n                            temp = dp[i-k] + str(v)\\n                        else:\\n                            temp = str(v) + dp[i-k]\\n                    \\n                        if len(dp[i]) < len(temp):\\n                            dp[i] = temp\\n                        elif len(dp[i]) == len(temp):\\n                            flip = False\\n                            for a,b in zip(dp[i],temp):\\n                                if int(b) > int(a):\\n                                    flip = True\\n                                    break\\n                            if flip:\\n                                dp[i] = temp\\n                elif i == k:\\n                    temp = str(v)\\n                    if len(dp[i]) < len(temp):\\n                        dp[i] = temp\\n                    elif len(dp[i]) == len(temp):\\n                        flip = False\\n                        for a,b in zip(dp[i],temp):\\n                            if int(b) > int(a):\\n                                flip = True\\n                                break\\n                        if flip:\\n                            dp[i] = temp\\n        if dp[target]:\\n            return dp[target]\\n        \\n        return \"0\"\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def largestNumber(self, cost, target):\\n        \"\"\"\\n        :type cost: List[int]\\n        :type target: int\\n        :rtype: str\\n        \"\"\"\\n        d = {}\\n        for i,c in enumerate(cost,1):\\n            d[c] = i\\n        \\n        n = len(d)\\n        \\n        dp = [\"\" for _ in range(target+1)]\\n        costs = sorted(d.items(),key = lambda x: x[1])\\n        \\n        for k,v in costs:\\n            for i in range(1,target+1):\\n                if i > k:\\n                    if dp[i-k]:\\n                        if int(dp[i-k][0]) > v:\\n                            temp = dp[i-k] + str(v)\\n                        else:\\n                            temp = str(v) + dp[i-k]\\n                    \\n                        if len(dp[i]) < len(temp):\\n                            dp[i] = temp\\n                        elif len(dp[i]) == len(temp):\\n                            flip = False\\n                            for a,b in zip(dp[i],temp):\\n                                if int(b) > int(a):\\n                                    flip = True\\n                                    break\\n                            if flip:\\n                                dp[i] = temp\\n                elif i == k:\\n                    temp = str(v)\\n                    if len(dp[i]) < len(temp):\\n                        dp[i] = temp\\n                    elif len(dp[i]) == len(temp):\\n                        flip = False\\n                        for a,b in zip(dp[i],temp):\\n                            if int(b) > int(a):\\n                                flip = True\\n                                break\\n                        if flip:\\n                            dp[i] = temp\\n        if dp[target]:\\n            return dp[target]\\n        \\n        return \"0\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975257,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  string largestNumber(vector<int>& cost, int target) {\\n    // dp[i] := max length that cost i can achieve\\n    vector<int> dp(target + 1, INT_MIN);\\n    dp[0] = 0;  // When cost = 0, the best is empty string \"\"\\n\\n    for (int i = 1; i <= target; ++i)\\n      for (int d = 0; d < 9; ++d)\\n        if (i >= cost[d])\\n          dp[i] = max(dp[i], dp[i - cost[d]] + 1);\\n\\n    if (dp[target] < 0)\\n      return \"0\";\\n\\n    string ans;\\n\\n    // Greedily build the ans string\\n    for (int d = 8; d >= 0; --d)\\n      while (target >= cost[d] && dp[target] == dp[target - cost[d]] + 1) {\\n        target -= cost[d];\\n        ans += \\'1\\' + d;\\n      }\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  string largestNumber(vector<int>& cost, int target) {\\n    // dp[i] := max length that cost i can achieve\\n    vector<int> dp(target + 1, INT_MIN);\\n    dp[0] = 0;  // When cost = 0, the best is empty string \"\"\\n\\n    for (int i = 1; i <= target; ++i)\\n      for (int d = 0; d < 9; ++d)\\n        if (i >= cost[d])\\n          dp[i] = max(dp[i], dp[i - cost[d]] + 1);\\n\\n    if (dp[target] < 0)\\n      return \"0\";\\n\\n    string ans;\\n\\n    // Greedily build the ans string\\n    for (int d = 8; d >= 0; --d)\\n      while (target >= cost[d] && dp[target] == dp[target - cost[d]] + 1) {\\n        target -= cost[d];\\n        ans += \\'1\\' + d;\\n      }\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962595,
                "title": "c-python-knapsack-dp-solution-with-explanation",
                "content": "dp[i][j] is maximum string length when cost is j, and cost of maximum string must == j, and we only use first i digits.\\n\\ndp[.][0] is 0 because cost is 0 and bag also is empty, other values are -inf.\\n\\n\\nif j - c >= 0, dp[i][j] = max(dp[i][j-c] + 1, dp[i-1][j])\\nelse, dp[i][j] = dp[i-1][j].\\n\\n\\nAnd we can bulild answer greadily,\\nuse big number first, when dp[i][j-c] can be transfered to dp[i][j], add this number.\\n\\ntc is O(10 * target), sc is O(10 * target).\\n\\n### python\\n```python\\ninf = int(1e9)\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        \\n        dp = [[-inf] * (target + 1) for _ in range(10)]\\n        for i in range(1, 10):\\n            dp[i][0] = 0\\n            for size in range(1, target+1):\\n                if size - cost[i-1] >= 0:\\n                    dp[i][size] = max(dp[i][size-cost[i-1]] + 1, dp[i-1][size])\\n                else: dp[i][size] = dp[i-1][size]\\n        if dp[9][target] < 0: return \"0\"\\n        ans = []\\n        digit = 9\\n        while digit > 0:\\n            c = cost[digit-1]\\n            if target >= c and dp[digit][target] == dp[digit][target-c] + 1:\\n                ans.append(str(digit))\\n                target -= c\\n            else: digit -= 1\\n        return \\'\\'.join(ans)\\n```\\n### space optimization\\n### python\\n\\n```python\\ninf = int(1e9)\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        dp = [-inf] * (target + 1)\\n        dp[0] = 0\\n        for i in range(1, 10):\\n            c = cost[i-1]\\n            for j in range(c, target+1):\\n                dp[j] = max(dp[j-c] + 1, dp[j])\\n        \\n        if dp[-1] < 0: return \"0\"\\n        ans = []\\n        for d in range(9, 0, -1):\\n            c = cost[d-1]\\n            while target >= c and dp[target] == dp[target-c] + 1:\\n                target -= c\\n                ans.append(str(d))\\n        return \\'\\'.join(ans)\\n```\\n\\n\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& cost, int target) {\\n        vector<int> dp (target + 1, INT_MIN);\\n        dp[0] = 0;\\n        for (int i = 1; i <= 9; i+=1) {\\n            for (int j = cost[i-1], c = cost[i-1]; j <= target; j+=1) \\n                dp[j] = max(dp[j-c] + 1, dp[j]);\\n        }\\n        \\n        if (dp[target] < 0) return \"0\";\\n        string ans;\\n        for (int d = 9; d >= 1; d-=1) {\\n            int c = cost[d-1];\\n            while (target >= c && dp[target] == dp[target - c] + 1) {\\n                ans += \\'0\\' + d;\\n                target -= c;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```python\\ninf = int(1e9)\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        \\n        dp = [[-inf] * (target + 1) for _ in range(10)]\\n        for i in range(1, 10):\\n            dp[i][0] = 0\\n            for size in range(1, target+1):\\n                if size - cost[i-1] >= 0:\\n                    dp[i][size] = max(dp[i][size-cost[i-1]] + 1, dp[i-1][size])\\n                else: dp[i][size] = dp[i-1][size]\\n        if dp[9][target] < 0: return \"0\"\\n        ans = []\\n        digit = 9\\n        while digit > 0:\\n            c = cost[digit-1]\\n            if target >= c and dp[digit][target] == dp[digit][target-c] + 1:\\n                ans.append(str(digit))\\n                target -= c\\n            else: digit -= 1\\n        return \\'\\'.join(ans)\\n```\n```python\\ninf = int(1e9)\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        dp = [-inf] * (target + 1)\\n        dp[0] = 0\\n        for i in range(1, 10):\\n            c = cost[i-1]\\n            for j in range(c, target+1):\\n                dp[j] = max(dp[j-c] + 1, dp[j])\\n        \\n        if dp[-1] < 0: return \"0\"\\n        ans = []\\n        for d in range(9, 0, -1):\\n            c = cost[d-1]\\n            while target >= c and dp[target] == dp[target-c] + 1:\\n                target -= c\\n                ans.append(str(d))\\n        return \\'\\'.join(ans)\\n```\n```cpp\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& cost, int target) {\\n        vector<int> dp (target + 1, INT_MIN);\\n        dp[0] = 0;\\n        for (int i = 1; i <= 9; i+=1) {\\n            for (int j = cost[i-1], c = cost[i-1]; j <= target; j+=1) \\n                dp[j] = max(dp[j-c] + 1, dp[j]);\\n        }\\n        \\n        if (dp[target] < 0) return \"0\";\\n        string ans;\\n        for (int d = 9; d >= 1; d-=1) {\\n            int c = cost[d-1];\\n            while (target >= c && dp[target] == dp[target - c] + 1) {\\n                ans += \\'0\\' + d;\\n                target -= c;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951969,
                "title": "python-knapsack-with-repetitions-bottom-up-dp",
                "content": "# Intuition\\nWithin combinatorial optimization there are 3 school models of knapsack: fractional (greedy solution, easiest), integer with repetitions and integer without repetitions (hardest). This is integer with repetitions, weigth/capacity is target and cost, value is number constructed. Items to pick as much as you can are digits from 1-9 and their costs as weight reduction element.\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(TW)$$ - T is target, W is size of word in comparison char by char, loop that iterates are ignored as they are constant, 9. \\n\\n- Space complexity:\\n$$O(T)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def bigger(self, a, b):\\n        if len(a) != len(b): return len(a) > len(b)\\n        return a > b\\n    def largestNumber(self, cost, target):\\n        dp = [None] * (target + 1)\\n        dp[0] = \\'\\'\\n        for t in range(1, target + 1):\\n            for d in range(1, 10):\\n                c = cost[d-1]\\n                if t-c >= 0:\\n                    if dp[t-c] is not None:\\n                        candidate = dp[t-c] + str(d)\\n                        if dp[t] is None or self.bigger(candidate, dp[t]):\\n                            dp[t] = candidate\\n\\n        return dp[target] if dp[target] else \\'0\\'\\n\\n\\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def bigger(self, a, b):\\n        if len(a) != len(b): return len(a) > len(b)\\n        return a > b\\n    def largestNumber(self, cost, target):\\n        dp = [None] * (target + 1)\\n        dp[0] = \\'\\'\\n        for t in range(1, target + 1):\\n            for d in range(1, 10):\\n                c = cost[d-1]\\n                if t-c >= 0:\\n                    if dp[t-c] is not None:\\n                        candidate = dp[t-c] + str(d)\\n                        if dp[t] is None or self.bigger(candidate, dp[t]):\\n                            dp[t] = candidate\\n\\n        return dp[target] if dp[target] else \\'0\\'\\n\\n\\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874797,
                "title": "very-easy-memorization-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string max_str(string a, string b){\\n        return a.size()>b.size()?a:b;\\n        return a>b?a:b;\\n    }\\n    string rec(vector<int>&c, int t, vector<string>&d){\\n        if(t==0) return \"0\";\\n        if(d[t]!=\"-1\") return d[t];\\n        string s=\"\";\\n        for(int i=0;i<9;i++){\\n            if(c[i]<=t){\\n                string x=rec(c, t-c[i], d);\\n                if(x!=\"\") s=max_str(s,to_string(i+1)+x);\\n            }\\n        }\\n        return d[t]=s;\\n    }\\n    string largestNumber(vector<int>& c, int t) {\\n        vector<string>d(t+1,\"-1\");\\n        string ans=rec(c,t,d);\\n        if(ans==\"\") return \"0\";\\n        ans=ans.substr(0,ans.size()-1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string max_str(string a, string b){\\n        return a.size()>b.size()?a:b;\\n        return a>b?a:b;\\n    }\\n    string rec(vector<int>&c, int t, vector<string>&d){\\n        if(t==0) return \"0\";\\n        if(d[t]!=\"-1\") return d[t];\\n        string s=\"\";\\n        for(int i=0;i<9;i++){\\n            if(c[i]<=t){\\n                string x=rec(c, t-c[i], d);\\n                if(x!=\"\") s=max_str(s,to_string(i+1)+x);\\n            }\\n        }\\n        return d[t]=s;\\n    }\\n    string largestNumber(vector<int>& c, int t) {\\n        vector<string>d(t+1,\"-1\");\\n        string ans=rec(c,t,d);\\n        if(ans==\"\") return \"0\";\\n        ans=ans.substr(0,ans.size()-1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3866552,
                "title": "python-easiest-solution-faster-than-100-top-down-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        @lru_cache(None)\\n        def solve(target):\\n            if target < 0:\\n                return float(\\'-inf\\')\\n            if target == 0:\\n                return 0\\n            res = float(\\'-inf\\')\\n            for i in cost:\\n                res = max(res, 1+solve(target-i))\\n            return res\\n        temp = solve(target)\\n        if temp == float(\\'-inf\\'):return \"0\"\\n        ans = \"\"\\n        while target:\\n            mx, res = 0, 0\\n            for idx,i in enumerate(cost):\\n                temp = solve(target-i)\\n                if temp > mx:\\n                    mx = temp\\n                    res = idx+1\\n                elif temp == mx:\\n                    res = max(res, idx+1)\\n            ans += str(res)\\n            target -= cost[res-1]\\n        return ans\\n\\n            \\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        @lru_cache(None)\\n        def solve(target):\\n            if target < 0:\\n                return float(\\'-inf\\')\\n            if target == 0:\\n                return 0\\n            res = float(\\'-inf\\')\\n            for i in cost:\\n                res = max(res, 1+solve(target-i))\\n            return res\\n        temp = solve(target)\\n        if temp == float(\\'-inf\\'):return \"0\"\\n        ans = \"\"\\n        while target:\\n            mx, res = 0, 0\\n            for idx,i in enumerate(cost):\\n                temp = solve(target-i)\\n                if temp > mx:\\n                    mx = temp\\n                    res = idx+1\\n                elif temp == mx:\\n                    res = max(res, idx+1)\\n            ans += str(res)\\n            target -= cost[res-1]\\n        return ans\\n\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826766,
                "title": "simplified-knapsack-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string MAX(string &a,string &b){\\n        if(a.find(\"0\")!=string::npos) return b;\\n        if(b.find(\"0\")!=string::npos) return a;\\n        if(a.size()>b.size())return a;\\n        return b;\\n    }\\n    string f(vector<int>& cost, int target,int i,vector<vector<string>>&dp){\\n        if(target==0 && i==cost.size())return \"\";\\n        if(target<0 || i==cost.size()) return \"0\";\\n        if(dp[target][i]!=\"-1\")return dp[target][i];\\n        string op1=to_string(i+1)+f(cost,target-cost[i],0,dp);\\n        string op2=f(cost,target,i+1,dp);\\n        return dp[target][i]=MAX(op1,op2);\\n    }\\n    string largestNumber(vector<int>& cost, int target) {\\n        vector<vector<string>>dp(target+1,vector<string>(10,\"-1\"));\\n        return f(cost,target,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string MAX(string &a,string &b){\\n        if(a.find(\"0\")!=string::npos) return b;\\n        if(b.find(\"0\")!=string::npos) return a;\\n        if(a.size()>b.size())return a;\\n        return b;\\n    }\\n    string f(vector<int>& cost, int target,int i,vector<vector<string>>&dp){\\n        if(target==0 && i==cost.size())return \"\";\\n        if(target<0 || i==cost.size()) return \"0\";\\n        if(dp[target][i]!=\"-1\")return dp[target][i];\\n        string op1=to_string(i+1)+f(cost,target-cost[i],0,dp);\\n        string op2=f(cost,target,i+1,dp);\\n        return dp[target][i]=MAX(op1,op2);\\n    }\\n    string largestNumber(vector<int>& cost, int target) {\\n        vector<vector<string>>dp(target+1,vector<string>(10,\"-1\"));\\n        return f(cost,target,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3811669,
                "title": "very-very-easy-c-dp-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nstring find(string& s1, string& s2) {\\n        string t = \"0\";\\n        if (s1.find(t) != std::string::npos) return s2;\\n        if (s2.find(t) != std::string::npos) return s1;\\n        if (s1.length() > s2.length())\\n            return s1;\\n        else\\n            return s2;\\n    }\\nstring fun(vector<int>& cost, int i,int target,vector<vector<string>> &dp){\\n    if(target == 0) return \"\";\\n    if(target < 0 || i == cost.size()) return \"0\";\\n    if(dp[i][target]!=\"-1\") return dp[i][target];\\n    string pick = to_string(i+1)+ fun(cost,0,target-cost[i],dp);\\n    string not_pick = fun(cost,i+1,target,dp);\\n    \\n    return dp[i][target]= find(pick , not_pick);\\n\\n}\\n    string largestNumber(vector<int>& cost, int target) {\\n        int n = cost.size();\\n        vector<vector<string>> dp(n+1,vector<string>(target+1,\"-1\"));\\n        return fun(cost,0,target,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nstring find(string& s1, string& s2) {\\n        string t = \"0\";\\n        if (s1.find(t) != std::string::npos) return s2;\\n        if (s2.find(t) != std::string::npos) return s1;\\n        if (s1.length() > s2.length())\\n            return s1;\\n        else\\n            return s2;\\n    }\\nstring fun(vector<int>& cost, int i,int target,vector<vector<string>> &dp){\\n    if(target == 0) return \"\";\\n    if(target < 0 || i == cost.size()) return \"0\";\\n    if(dp[i][target]!=\"-1\") return dp[i][target];\\n    string pick = to_string(i+1)+ fun(cost,0,target-cost[i],dp);\\n    string not_pick = fun(cost,i+1,target,dp);\\n    \\n    return dp[i][target]= find(pick , not_pick);\\n\\n}\\n    string largestNumber(vector<int>& cost, int target) {\\n        int n = cost.size();\\n        vector<vector<string>> dp(n+1,vector<string>(target+1,\"-1\"));\\n        return fun(cost,0,target,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689074,
                "title": "simple-c-code-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nstring dp[5001]={};\\nstring sol(int t,vector<int> &cost)\\n{\\n    if(t==0)\\n    return \"\";\\n    if(!dp[t].empty())\\n    return dp[t];\\n    string res=\"0\";\\n    for(int i=0;i<9;i++)\\n    {\\n        if(t>=cost[i])\\n        {\\n       string cur=sol(t-cost[i],cost);\\n        if(cur==\"0\")\\n        continue;\\n        cur=to_string(i+1)+cur;\\n        if(res.length()>cur.length())\\n        continue;\\n        if(res==\"0\" || cur.length()>res.length() || cur.length()==res.length()&&res<cur)\\n        res=cur;\\n\\n    }\\n    }\\n    return dp[t]=res;\\n\\n}\\n    string largestNumber(vector<int>& cost, int target) {\\n        return sol(target,cost);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nstring dp[5001]={};\\nstring sol(int t,vector<int> &cost)\\n{\\n    if(t==0)\\n    return \"\";\\n    if(!dp[t].empty())\\n    return dp[t];\\n    string res=\"0\";\\n    for(int i=0;i<9;i++)\\n    {\\n        if(t>=cost[i])\\n        {\\n       string cur=sol(t-cost[i],cost);\\n        if(cur==\"0\")\\n        continue;\\n        cur=to_string(i+1)+cur;\\n        if(res.length()>cur.length())\\n        continue;\\n        if(res==\"0\" || cur.length()>res.length() || cur.length()==res.length()&&res<cur)\\n        res=cur;\\n\\n    }\\n    }\\n    return dp[t]=res;\\n\\n}\\n    string largestNumber(vector<int>& cost, int target) {\\n        return sol(target,cost);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3628318,
                "title": "such-a-joke-it-should-be-medium-dp-problem",
                "content": "I mean , come on , code is self explanatory.\\n\\n```\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        \\n        INF=10**18\\n        \\n        @lru_cache(None)\\n        def dfs(sum)->int:\\n            if(sum>target):\\n                return -INF\\n            if(sum==target):\\n                return 0\\n            \\n            ans=-INF\\n            for i in range(8,-1,-1):\\n                ans=max(ans,dfs(sum+cost[i])+1)\\n            return ans\\n            \\n        ok=dfs(0)\\n        if(ok<0):\\n            return \"0\"\\n        \\n        self.ans=\"\"\\n        \\n        def path(sum)->None:\\n            if(sum>=target):\\n                return \\n            \\n            to_add=[\"\",-INF]\\n            for i in range(8,-1,-1):\\n                if(to_add[1]<dfs(sum+cost[i])+1):\\n                    to_add=[i,dfs(sum+cost[i])+1]\\n            \\n            self.ans+=str(to_add[0]+1)\\n            path(sum+cost[to_add[0]])\\n                    \\n        \\n        path(0)\\n        \\n        return self.ans\\n        \\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        \\n        INF=10**18\\n        \\n        @lru_cache(None)\\n        def dfs(sum)->int:\\n            if(sum>target):\\n                return -INF\\n            if(sum==target):\\n                return 0\\n            \\n            ans=-INF\\n            for i in range(8,-1,-1):\\n                ans=max(ans,dfs(sum+cost[i])+1)\\n            return ans\\n            \\n        ok=dfs(0)\\n        if(ok<0):\\n            return \"0\"\\n        \\n        self.ans=\"\"\\n        \\n        def path(sum)->None:\\n            if(sum>=target):\\n                return \\n            \\n            to_add=[\"\",-INF]\\n            for i in range(8,-1,-1):\\n                if(to_add[1]<dfs(sum+cost[i])+1):\\n                    to_add=[i,dfs(sum+cost[i])+1]\\n            \\n            self.ans+=str(to_add[0]+1)\\n            path(sum+cost[to_add[0]])\\n                    \\n        \\n        path(0)\\n        \\n        return self.ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3407908,
                "title": "largest-integer-with-digits-adding-upto-target-c-explained-solution",
                "content": "***Do Upvote If Found Helpful !!!***\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe problem here is quite interesting and needs some good observations. Let\\'s first try to analyse the problem. Basically we have to form largest possible number such that cost of all digits used add upto target. Now if two numbers are of **same length(have same number of digits)**, then bigger one is decided by Most Significant Digit that is unequal in both numbers. If length of two numbers is not same, then the one with more number of digits is bigger. Following this observation, the above problem basically reduces down to the problem of finding **Largest Subset With Target Sum**. For this, you can simply use **Dynamic Programming** to find length of maximum subset with sum equal to target. Now after finding this, we need to find the maximum number that can be formed out of this. We start iterating from back with initial value as **target**. For **0-9**, we find the maximum index with max value of **LST(Largest Subset Target)**. Then we just add the digit corresponding to that index to our answer and update target by decreasing it by cost of current index. We repeat the algorithm of last 2 lines until target becomes 0. If there is no solution, just return 0. Rest implementation goes below :\\n\\n# Complexity\\n- Time complexity: **O(81T)** , where **T** is target sum\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(9T)** , where **T** is target sum\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& cost, int target) {\\n\\n        ios_base::sync_with_stdio(0);\\n\\n        vector<vector<int>>dp(target+1,vector<int>(9,-1));\\n        for(int i = 0; i < 9; i++){            // We dont need any digit for making sum 0\\n            dp[0][i] = 0;\\n        }\\n\\n        /* Top Down Approach - DP */\\n\\n        for(int i = 0; i <= target; i++){          // For each possible sum, find if it can be broken into possible subsets\\n            for(int j = 0; j < 9; j++){\\n                if(i - cost[j] >= 0){              // check if cost is less that or equal to current value of i\\n                    int mx = -1;\\n                    for(int k = 0; k < 9; k++){\\n                        mx = max(mx,dp[i-cost[j]][k]);\\n                    }\\n                    if(mx > -1){\\n                        dp[i][j] = max(dp[i][j],mx + 1);\\n                    }\\n                }\\n            }\\n        }\\n\\n        bool c = false;\\n        for(int i = 0; i < 9; i++){         // check if its possible to make any subset with sumcost equal to target\\n            if(dp[target][i] != -1){\\n                c = true;\\n                break;\\n            }\\n        }\\n\\n        if(!c){\\n            return \"0\";\\n        }\\n        else{\\n            string ans = \"\";\\n            while(target){\\n                int mx = -1,idx = 0;\\n                for(int k = 0; k < 9; k++){             // Find max index with max value of dp[target][k] (Largest Subset Size With Sum equal to current value of target)\\n                    if(dp[target][k] >= mx){\\n                        idx = k;\\n                        mx = dp[target][k];\\n                    }\\n                }\\n                ans = ans + char(idx + 1 + \\'0\\');          // Add the corresponding digit(convention used is 0-8 so add 1 for making it to 1-9) and update target\\n                target -= cost[idx];\\n            }\\n            return ans;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& cost, int target) {\\n\\n        ios_base::sync_with_stdio(0);\\n\\n        vector<vector<int>>dp(target+1,vector<int>(9,-1));\\n        for(int i = 0; i < 9; i++){            // We dont need any digit for making sum 0\\n            dp[0][i] = 0;\\n        }\\n\\n        /* Top Down Approach - DP */\\n\\n        for(int i = 0; i <= target; i++){          // For each possible sum, find if it can be broken into possible subsets\\n            for(int j = 0; j < 9; j++){\\n                if(i - cost[j] >= 0){              // check if cost is less that or equal to current value of i\\n                    int mx = -1;\\n                    for(int k = 0; k < 9; k++){\\n                        mx = max(mx,dp[i-cost[j]][k]);\\n                    }\\n                    if(mx > -1){\\n                        dp[i][j] = max(dp[i][j],mx + 1);\\n                    }\\n                }\\n            }\\n        }\\n\\n        bool c = false;\\n        for(int i = 0; i < 9; i++){         // check if its possible to make any subset with sumcost equal to target\\n            if(dp[target][i] != -1){\\n                c = true;\\n                break;\\n            }\\n        }\\n\\n        if(!c){\\n            return \"0\";\\n        }\\n        else{\\n            string ans = \"\";\\n            while(target){\\n                int mx = -1,idx = 0;\\n                for(int k = 0; k < 9; k++){             // Find max index with max value of dp[target][k] (Largest Subset Size With Sum equal to current value of target)\\n                    if(dp[target][k] >= mx){\\n                        idx = k;\\n                        mx = dp[target][k];\\n                    }\\n                }\\n                ans = ans + char(idx + 1 + \\'0\\');          // Add the corresponding digit(convention used is 0-8 so add 1 for making it to 1-9) and update target\\n                target -= cost[idx];\\n            }\\n            return ans;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3360516,
                "title": "dfs-memo-both-2d-1d-dp-unbounded-knapsack",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n\\n\\n        dp = [-1]*(target+1) \\n        def dfs(t):\\n\\n            if t==0: return 0 \\n            if t<0: return -inf  \\n\\n            if dp[t] != -1: return dp[t] \\n\\n            \\n            dp[t] = max(dfs(t - c) * 10 + i + 1 for i, c in enumerate(cost))\\n            return dp[t] \\n        \\n        return str(max(0,dfs(target)))\\n            \\n\\n        # 2D dP\\n        # dp = [[-1]*(target+1) for _ in range(len(cost)+1)]\\n        # def dfs(idx , t): \\n\\n           \\n        #     if t==0: return 0\\n        #     if t<0 or idx==len(cost): return -inf \\n\\n        #     if dp[idx][t]!=-1: return dp[idx][t]\\n            \\n            \\n        #     pick = (idx+1)+10*dfs(idx,t-cost[idx])  \\n        #     npick = dfs(idx+1,t)  \\n            \\n        #     dp[idx][t] = max(pick,npick)\\n        #     return dp[idx][t] \\n        \\n            \\n        # return str(max(0,dfs(0,target)))\\n        \\n\\n            \\n\\n\\n\\n        \\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n\\n\\n        dp = [-1]*(target+1) \\n        def dfs(t):\\n\\n            if t==0: return 0 \\n            if t<0: return -inf  \\n\\n            if dp[t] != -1: return dp[t] \\n\\n            \\n            dp[t] = max(dfs(t - c) * 10 + i + 1 for i, c in enumerate(cost))\\n            return dp[t] \\n        \\n        return str(max(0,dfs(target)))\\n            \\n\\n        # 2D dP\\n        # dp = [[-1]*(target+1) for _ in range(len(cost)+1)]\\n        # def dfs(idx , t): \\n\\n           \\n        #     if t==0: return 0\\n        #     if t<0 or idx==len(cost): return -inf \\n\\n        #     if dp[idx][t]!=-1: return dp[idx][t]\\n            \\n            \\n        #     pick = (idx+1)+10*dfs(idx,t-cost[idx])  \\n        #     npick = dfs(idx+1,t)  \\n            \\n        #     dp[idx][t] = max(pick,npick)\\n        #     return dp[idx][t] \\n        \\n            \\n        # return str(max(0,dfs(0,target)))\\n        \\n\\n            \\n\\n\\n\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3309915,
                "title": "recursive-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def largestNumber(self, cost, target):\\n        \"\"\"\\n        :type cost: List[int]\\n        :type target: int\\n        :rtype: str\\n        \"\"\"\\n        dp = {} \\n        def dfs(remain):\\n            if remain == 0:\\n                return \"\"\\n            \\n            if remain in dp:\\n                return dp[remain]\\n            maxPath = \"0\"\\n            \\n            for i in range(1, 10):\\n                if remain >= cost[i-1]:\\n                    curr = dfs(remain-cost[i-1])\\n                    if curr == \"0\":\\n                        continue \\n                    curr += str(i)\\n                    if len(maxPath) > len(curr):\\n                        continue\\n                    if maxPath == \"0\" or len(curr) > len(maxPath) or (len(curr) == len(maxPath) and int(curr) >= int(maxPath)):\\n                        maxPath = curr\\n            dp[remain] = maxPath\\n            return dp[remain]\\n        \\n\\n\\n        return dfs(target)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def largestNumber(self, cost, target):\\n        \"\"\"\\n        :type cost: List[int]\\n        :type target: int\\n        :rtype: str\\n        \"\"\"\\n        dp = {} \\n        def dfs(remain):\\n            if remain == 0:\\n                return \"\"\\n            \\n            if remain in dp:\\n                return dp[remain]\\n            maxPath = \"0\"\\n            \\n            for i in range(1, 10):\\n                if remain >= cost[i-1]:\\n                    curr = dfs(remain-cost[i-1])\\n                    if curr == \"0\":\\n                        continue \\n                    curr += str(i)\\n                    if len(maxPath) > len(curr):\\n                        continue\\n                    if maxPath == \"0\" or len(curr) > len(maxPath) or (len(curr) == len(maxPath) and int(curr) >= int(maxPath)):\\n                        maxPath = curr\\n            dp[remain] = maxPath\\n            return dp[remain]\\n        \\n\\n\\n        return dfs(target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3309850,
                "title": "c-recursion-can-you-spot-the-difference-both-are-same-but-one-gives-tle-and-another-ac",
                "content": "\\n\\n# Code #1\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> dp;\\n    string maxi(string &s1, string &s2)\\n    {\\n        string t=\"0\";\\n        if (s1.find(t) != std::string::npos) \\n            return s2;\\n        if (s2.find(t) != std::string::npos) \\n            return s1;\\n        if(s1.length()>s2.length()) \\n            return s1;\\n        return s2;\\n    }\\n    string dfs(vector<int> &ar, int t, int idx)\\n    {\\n        if(t < 0 || idx == ar.size())\\n            return \"0\";\\n        if(t == 0)\\n            return \"\";\\n        if(dp[idx][t] != \"-1\")\\n             return dp[idx][t];\\n\\n        string inc = to_string(idx+1) + dfs(ar, t-ar[idx], 0);\\n        string exc = dfs(ar, t, idx+1);\\n\\n        string ret= maxi(inc, exc);\\n        dp[idx][t] = ret;\\n        return ret;\\n    }\\n    string largestNumber(vector<int>& cost, int target) \\n    {\\n        dp.resize(cost.size()+1, vector<string> (target+1, \"-1\"));\\n        return dfs(cost, target, 0);    \\n    }\\n};\\n```\\n\\n# Code #2\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> dp;\\n    string maxi(string s1, string s2)\\n    {\\n        string t=\"0\";\\n        if (s1.find(t) != std::string::npos) \\n            return s2;\\n        if (s2.find(t) != std::string::npos) \\n            return s1;\\n        if(s1.length()>s2.length()) \\n            return s1;\\n        return s2;\\n    }\\n    string dfs(vector<int> &ar, int t, int idx)\\n    {\\n        if(t < 0 || idx == ar.size())\\n            return \"0\";\\n        if(t == 0)\\n            return \"\";\\n        if(dp[idx][t] != \"-1\")\\n             return dp[idx][t];\\n\\n        string inc = to_string(idx+1) + dfs(ar, t-ar[idx], 0);\\n        string exc = dfs(ar, t, idx+1);\\n\\n        string ret= maxi(inc, exc);\\n        dp[idx][t] = ret;\\n        return ret;\\n    }\\n    string largestNumber(vector<int>& cost, int target) \\n    {\\n        dp.resize(cost.size()+1, vector<string> (target+1, \"-1\"));\\n        return dfs(cost, target, 0);    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> dp;\\n    string maxi(string &s1, string &s2)\\n    {\\n        string t=\"0\";\\n        if (s1.find(t) != std::string::npos) \\n            return s2;\\n        if (s2.find(t) != std::string::npos) \\n            return s1;\\n        if(s1.length()>s2.length()) \\n            return s1;\\n        return s2;\\n    }\\n    string dfs(vector<int> &ar, int t, int idx)\\n    {\\n        if(t < 0 || idx == ar.size())\\n            return \"0\";\\n        if(t == 0)\\n            return \"\";\\n        if(dp[idx][t] != \"-1\")\\n             return dp[idx][t];\\n\\n        string inc = to_string(idx+1) + dfs(ar, t-ar[idx], 0);\\n        string exc = dfs(ar, t, idx+1);\\n\\n        string ret= maxi(inc, exc);\\n        dp[idx][t] = ret;\\n        return ret;\\n    }\\n    string largestNumber(vector<int>& cost, int target) \\n    {\\n        dp.resize(cost.size()+1, vector<string> (target+1, \"-1\"));\\n        return dfs(cost, target, 0);    \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> dp;\\n    string maxi(string s1, string s2)\\n    {\\n        string t=\"0\";\\n        if (s1.find(t) != std::string::npos) \\n            return s2;\\n        if (s2.find(t) != std::string::npos) \\n            return s1;\\n        if(s1.length()>s2.length()) \\n            return s1;\\n        return s2;\\n    }\\n    string dfs(vector<int> &ar, int t, int idx)\\n    {\\n        if(t < 0 || idx == ar.size())\\n            return \"0\";\\n        if(t == 0)\\n            return \"\";\\n        if(dp[idx][t] != \"-1\")\\n             return dp[idx][t];\\n\\n        string inc = to_string(idx+1) + dfs(ar, t-ar[idx], 0);\\n        string exc = dfs(ar, t, idx+1);\\n\\n        string ret= maxi(inc, exc);\\n        dp[idx][t] = ret;\\n        return ret;\\n    }\\n    string largestNumber(vector<int>& cost, int target) \\n    {\\n        dp.resize(cost.size()+1, vector<string> (target+1, \"-1\"));\\n        return dfs(cost, target, 0);    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3220689,
                "title": "easy-c-top-down-and-bottom-up-unbounded-knapsack",
                "content": "# Intuition\\n    Same as Unbounded Knapsack \\n\\n# Complexity\\n- Time complexity:\\n- O(9 * target)\\n- Space complexity:\\n- O(target)\\n\\n\\n# Top Down Approach\\n```\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& cost, int target) {\\n        vector<string> memo(target+1, \"-1\"); \\n        function<string(int)> dp;\\n        dp = [&](int cur) -> string {\\n            if(cur == 0) return \"\";\\n            if(cur<0) return \"0\";\\n            if(memo[cur] != \"-1\") return memo[cur];\\n            string ans = \"0\";\\n            for(int i=8; i>=0; --i) {\\n                string rem = dp(cur - cost[i]);\\n                if(rem == \"0\") continue;\\n                rem = to_string(i+1) + rem;\\n                if(ans == \"0\" || ans.size() < rem.size()) ans = rem;\\n            }\\n            return memo[cur] = ans;\\n        }; \\n        return dp(target);\\n    }\\n};\\n```\\n\\n# Bottom Up Approach\\n```\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& cost, int target) {\\n        vector<string> memo(target+1, \"0\"); \\n        memo[0] = \"\";\\n        for(int cur = 1; cur <= target; ++cur) {\\n            string ans = \"0\";\\n            for(int i=8; i>=0; --i) {\\n                if(cur < cost[i]) continue;\\n                string rem = memo[cur - cost[i]];\\n                if(rem == \"0\") continue;\\n                rem = to_string(i+1) + rem;\\n                if(ans == \"0\" || ans.size() < rem.size()) ans = rem;\\n            }\\n            memo[cur] = ans;\\n        }\\n        return memo[target];\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& cost, int target) {\\n        vector<string> memo(target+1, \"-1\"); \\n        function<string(int)> dp;\\n        dp = [&](int cur) -> string {\\n            if(cur == 0) return \"\";\\n            if(cur<0) return \"0\";\\n            if(memo[cur] != \"-1\") return memo[cur];\\n            string ans = \"0\";\\n            for(int i=8; i>=0; --i) {\\n                string rem = dp(cur - cost[i]);\\n                if(rem == \"0\") continue;\\n                rem = to_string(i+1) + rem;\\n                if(ans == \"0\" || ans.size() < rem.size()) ans = rem;\\n            }\\n            return memo[cur] = ans;\\n        }; \\n        return dp(target);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& cost, int target) {\\n        vector<string> memo(target+1, \"0\"); \\n        memo[0] = \"\";\\n        for(int cur = 1; cur <= target; ++cur) {\\n            string ans = \"0\";\\n            for(int i=8; i>=0; --i) {\\n                if(cur < cost[i]) continue;\\n                string rem = memo[cur - cost[i]];\\n                if(rem == \"0\") continue;\\n                rem = to_string(i+1) + rem;\\n                if(ans == \"0\" || ans.size() < rem.size()) ans = rem;\\n            }\\n            memo[cur] = ans;\\n        }\\n        return memo[target];\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202891,
                "title": "python-simple-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def largestNumber(self, cost, target):\\n        dict1 = collections.defaultdict(int)\\n\\n        for i,j in enumerate(cost):\\n            dict1[i+1] = j\\n\\n        @lru_cache(None)\\n        def dfs(total):\\n            if total == 0:\\n                return 0\\n\\n            str1 = float(\"-inf\")\\n\\n            for j in range(1,10):\\n                if total - dict1[j] >= 0:\\n                    str1 = max(str1,dfs(total-dict1[j])*10 + j)\\n\\n            return str1\\n\\n        res = dfs(target)\\n\\n        return str(res) if res != float(\"-inf\") else \"0\"\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestNumber(self, cost, target):\\n        dict1 = collections.defaultdict(int)\\n\\n        for i,j in enumerate(cost):\\n            dict1[i+1] = j\\n\\n        @lru_cache(None)\\n        def dfs(total):\\n            if total == 0:\\n                return 0\\n\\n            str1 = float(\"-inf\")\\n\\n            for j in range(1,10):\\n                if total - dict1[j] >= 0:\\n                    str1 = max(str1,dfs(total-dict1[j])*10 + j)\\n\\n            return str1\\n\\n        res = dfs(target)\\n\\n        return str(res) if res != float(\"-inf\") else \"0\"\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175295,
                "title": "python-simple-dp",
                "content": "# Approach\\ndp which is easy to see and read :) <3\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        dp=[\"\"]*(target+1)\\n        for i in range(0,target+1):\\n            for j in range(1,10):\\n                if i+cost[j-1]<=target :\\n                    if dp[i]==\"\" and i!=0:\\n                        continue\\n                    res=\"\".join(sorted(dp[i]+str(j),reverse=True))\\n                    if len(res)>len(dp[i+cost[j-1]]):\\n                        dp[i+cost[j-1]]=res\\n                    elif len(res)==len(dp[i+cost[j-1]]) and res>dp[i+cost[j-1]]:\\n                        dp[i+cost[j-1]]=res\\n        return [dp[target],\"0\"][dp[target]==\"\"]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        dp=[\"\"]*(target+1)\\n        for i in range(0,target+1):\\n            for j in range(1,10):\\n                if i+cost[j-1]<=target :\\n                    if dp[i]==\"\" and i!=0:\\n                        continue\\n                    res=\"\".join(sorted(dp[i]+str(j),reverse=True))\\n                    if len(res)>len(dp[i+cost[j-1]]):\\n                        dp[i+cost[j-1]]=res\\n                    elif len(res)==len(dp[i+cost[j-1]]) and res>dp[i+cost[j-1]]:\\n                        dp[i+cost[j-1]]=res\\n        return [dp[target],\"0\"][dp[target]==\"\"]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112303,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn largest_number(cost: Vec<i32>, target: i32) -> String {\\n        let mut dp = vec![0; target as usize + 1];\\n        for i in 1..=target {\\n            dp[i as usize] = -1;\\n            for j in 0..9 {\\n                if i >= cost[j] && dp[(i - cost[j]) as usize] >= 0 {\\n                    dp[i as usize] = std::cmp::max(dp[i as usize], dp[(i - cost[j]) as usize] + 1);\\n                }\\n            }\\n        }\\n        if dp[target as usize] < 0 {\\n            return \"0\".to_string();\\n        }\\n        let mut ans = String::new();\\n        let mut i = target;\\n        for j in (0..9).rev() {\\n            while i >= cost[j] && dp[(i - cost[j]) as usize] == dp[i as usize] - 1 {\\n                ans.push(((j + 1) as u8 + b\\'0\\') as char);\\n                i -= cost[j];\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn largest_number(cost: Vec<i32>, target: i32) -> String {\\n        let mut dp = vec![0; target as usize + 1];\\n        for i in 1..=target {\\n            dp[i as usize] = -1;\\n            for j in 0..9 {\\n                if i >= cost[j] && dp[(i - cost[j]) as usize] >= 0 {\\n                    dp[i as usize] = std::cmp::max(dp[i as usize], dp[(i - cost[j]) as usize] + 1);\\n                }\\n            }\\n        }\\n        if dp[target as usize] < 0 {\\n            return \"0\".to_string();\\n        }\\n        let mut ans = String::new();\\n        let mut i = target;\\n        for j in (0..9).rev() {\\n            while i >= cost[j] && dp[(i - cost[j]) as usize] == dp[i as usize] - 1 {\\n                ans.push(((j + 1) as u8 + b\\'0\\') as char);\\n                i -= cost[j];\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3090723,
                "title": "simple-dp-solution-recursion-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    string solve(vector<string> &dp, vector<int> &cost, int target)\\n    {\\n        if(dp[target]!=\"-1\")return dp[target];\\n        if(target == 0)return \"\";\\n        string ans = \"\";\\n        for(int i=0;i<9;i++)\\n        {\\n            if(target >= cost[i])\\n            {\\n                string s1 = \"\";\\n                s1 += to_string(i+1);\\n                string x = solve(dp, cost, target - cost[i]);\\n                if(x == \"0\")continue;\\n                s1 += x;\\n                if(ans.size() < s1.size())ans = s1;\\n                else if(ans.size() == s1.size())ans = max(ans , s1);\\n            }\\n        }\\n        if(ans == \"\")return dp[target] = \"0\";\\n        return dp[target] = ans;\\n    }\\n    string largestNumber(vector<int>& cost, int target) {\\n        vector<string> dp(target + 1, \"-1\");\\n        return solve(dp, cost, target);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string solve(vector<string> &dp, vector<int> &cost, int target)\\n    {\\n        if(dp[target]!=\"-1\")return dp[target];\\n        if(target == 0)return \"\";\\n        string ans = \"\";\\n        for(int i=0;i<9;i++)\\n        {\\n            if(target >= cost[i])\\n            {\\n                string s1 = \"\";\\n                s1 += to_string(i+1);\\n                string x = solve(dp, cost, target - cost[i]);\\n                if(x == \"0\")continue;\\n                s1 += x;\\n                if(ans.size() < s1.size())ans = s1;\\n                else if(ans.size() == s1.size())ans = max(ans , s1);\\n            }\\n        }\\n        if(ans == \"\")return dp[target] = \"0\";\\n        return dp[target] = ans;\\n    }\\n    string largestNumber(vector<int>& cost, int target) {\\n        vector<string> dp(target + 1, \"-1\");\\n        return solve(dp, cost, target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3034807,
                "title": "simple-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n   public String largestNumber(int[] cost, int target) {\\n          String[][] memo = new String[cost.length+1][target+1];\\n          String str = largestNum(cost, target, 1, memo);\\n          return !str.isEmpty() ? str : \"0\";\\n    }\\n\\n    public String largestNum(int[] cost, int target, int start, String[][] memo) {\\n           if(target <= -1) {\\n              return \"\";\\n           }\\n           if(start-1 >= 9) {\\n               return \"\";\\n           }\\n           if(target == 0) {\\n            return String.valueOf(start);\\n           }\\n           if(memo[start][target] != null) {\\n             return memo[start][target];\\n           }\\n           String str = largestNum(cost, target - cost[start - 1], start, memo);\\n           if (!str.isEmpty() && target-cost[start-1] > 0) {\\n                   str = str.concat(String.valueOf(start));\\n           }\\n           String str2 = largestNum(cost, target, start+1, memo);\\n           return memo[start][target] = str.length() < str2.length() ? str2 : str.length() > str2.length() ? str : str.compareTo(str2) >= 0 ? str : str2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public String largestNumber(int[] cost, int target) {\\n          String[][] memo = new String[cost.length+1][target+1];\\n          String str = largestNum(cost, target, 1, memo);\\n          return !str.isEmpty() ? str : \"0\";\\n    }\\n\\n    public String largestNum(int[] cost, int target, int start, String[][] memo) {\\n           if(target <= -1) {\\n              return \"\";\\n           }\\n           if(start-1 >= 9) {\\n               return \"\";\\n           }\\n           if(target == 0) {\\n            return String.valueOf(start);\\n           }\\n           if(memo[start][target] != null) {\\n             return memo[start][target];\\n           }\\n           String str = largestNum(cost, target - cost[start - 1], start, memo);\\n           if (!str.isEmpty() && target-cost[start-1] > 0) {\\n                   str = str.concat(String.valueOf(start));\\n           }\\n           String str2 = largestNum(cost, target, start+1, memo);\\n           return memo[start][target] = str.length() < str2.length() ? str2 : str.length() > str2.length() ? str : str.compareTo(str2) >= 0 ? str : str2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3007866,
                "title": "incorrect-greedy-solution",
                "content": "# Code\\n```\\nGreedy Solution wrong for (87/96) passed\\nInput : \\n[5,6,7,3,4,6,7,4,8]\\n29\\n\\nOutput : \"444444441\"\\nExpected : \"884444444\"\\n\\n---\\n\\n- As greedily choosing cost 3 will force us to choose a cost 5 (4, 1).\\n- Instead a choice of cost 4 and 4 was optimal (8, 4).\\n\\n---\\n\\n\\nclass Solution {\\npublic:\\n    #define cost first\\n    #define val second\\n    int dp[5001][10];\\n\\n    bool rec(int total, int i, vector<pair<int,int>> &v){\\n        if (total == 0) return true;\\n        else if (i == 9) return false;\\n        \\n        if (dp[total][i] == -1) {\\n            int mx_pos = -2;\\n            for (int j=total / v[i].cost; j>=0; j--){\\n                int rem = total - j * v[i].cost;\\n                bool pos = rec(rem, i+1, v);\\n                if (pos){\\n                    dp[total][i] = j;\\n                    return true;\\n                }\\n            }\\n            dp[total][i] = -2;\\n        }\\n        return false;\\n    }\\n\\n    string largestNumber(vector<int>& costs, int total) {\\n        vector<pair<int,int>> v(9);\\n        vector<int> cnt(10);\\n        for (int i=1; i<=total; i++){\\n            for (int j=0; j<9; j++){\\n                dp[i][j] = -1;\\n            }\\n        }\\n        for (int i=0; i<9; i++){\\n            v[i] = {costs[i], i+1};\\n        }\\n        sort(begin(v), end(v), [&](pair<int,int> &a, pair<int,int> &b){\\n            if (a.cost != b.cost) return a.cost < b.cost;\\n            return a.val > b.val;\\n        });\\n        \\n        rec(total, 0, v);\\n\\n        int i = 0;\\n        while (i < 9 && total > 0){\\n            cnt[v[i].val] = dp[total][i];\\n            total -= dp[total][i] * v[i].cost;\\n            i++;\\n        }\\n        \\n        string res = \"\";\\n        char c = \\'9\\';\\n        for (int i=9; i>0; i--, c--){\\n            while ((cnt[i]--) > 0){\\n                res.push_back(c);\\n            }\\n        }\\n\\n        if (res.empty()) return \"0\";\\n        else return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nGreedy Solution wrong for (87/96) passed\\nInput : \\n[5,6,7,3,4,6,7,4,8]\\n29\\n\\nOutput : \"444444441\"\\nExpected : \"884444444\"\\n\\n---\\n\\n- As greedily choosing cost 3 will force us to choose a cost 5 (4, 1).\\n- Instead a choice of cost 4 and 4 was optimal (8, 4).\\n\\n---\\n\\n\\nclass Solution {\\npublic:\\n    #define cost first\\n    #define val second\\n    int dp[5001][10];\\n\\n    bool rec(int total, int i, vector<pair<int,int>> &v){\\n        if (total == 0) return true;\\n        else if (i == 9) return false;\\n        \\n        if (dp[total][i] == -1) {\\n            int mx_pos = -2;\\n            for (int j=total / v[i].cost; j>=0; j--){\\n                int rem = total - j * v[i].cost;\\n                bool pos = rec(rem, i+1, v);\\n                if (pos){\\n                    dp[total][i] = j;\\n                    return true;\\n                }\\n            }\\n            dp[total][i] = -2;\\n        }\\n        return false;\\n    }\\n\\n    string largestNumber(vector<int>& costs, int total) {\\n        vector<pair<int,int>> v(9);\\n        vector<int> cnt(10);\\n        for (int i=1; i<=total; i++){\\n            for (int j=0; j<9; j++){\\n                dp[i][j] = -1;\\n            }\\n        }\\n        for (int i=0; i<9; i++){\\n            v[i] = {costs[i], i+1};\\n        }\\n        sort(begin(v), end(v), [&](pair<int,int> &a, pair<int,int> &b){\\n            if (a.cost != b.cost) return a.cost < b.cost;\\n            return a.val > b.val;\\n        });\\n        \\n        rec(total, 0, v);\\n\\n        int i = 0;\\n        while (i < 9 && total > 0){\\n            cnt[v[i].val] = dp[total][i];\\n            total -= dp[total][i] * v[i].cost;\\n            i++;\\n        }\\n        \\n        string res = \"\";\\n        char c = \\'9\\';\\n        for (int i=9; i>0; i--, c--){\\n            while ((cnt[i]--) > 0){\\n                res.push_back(c);\\n            }\\n        }\\n\\n        if (res.empty()) return \"0\";\\n        else return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2983612,
                "title": "java-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\n    public String largestNumber(int[] cost, int target) {\\n        String[] dp = new String[target + 1];\\n        Arrays.fill(dp, \"\");\\n\\n        for(int i = 1; i < dp.length; i++) {\\n            for(int j = 0; j < cost.length; j++) {\\n                if(i < cost[j]) continue;\\n                if((i - cost[j]) == 0 || ((i - cost[j]) > 0 \\n                && !dp[i - cost[j]].equals(\"\")))\\n                dp[i] = max(dp[i],(j+1) + dp[i - cost[j]]);\\n            }\\n        }\\n\\n        return (dp[target].equals(\"\") ? \"0\" : dp[target]);    \\n    }\\n\\n    private String max(String a, String b) {\\n        if(a.length() > b.length()) return a;\\n        else if(b.length() > a.length()) return b;\\n        return a.compareTo(b) < 0 ? b : a;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public String largestNumber(int[] cost, int target) {\\n        String[] dp = new String[target + 1];\\n        Arrays.fill(dp, \"\");\\n\\n        for(int i = 1; i < dp.length; i++) {\\n            for(int j = 0; j < cost.length; j++) {\\n                if(i < cost[j]) continue;\\n                if((i - cost[j]) == 0 || ((i - cost[j]) > 0 \\n                && !dp[i - cost[j]].equals(\"\")))\\n                dp[i] = max(dp[i],(j+1) + dp[i - cost[j]]);\\n            }\\n        }\\n\\n        return (dp[target].equals(\"\") ? \"0\" : dp[target]);    \\n    }\\n\\n    private String max(String a, String b) {\\n        if(a.length() > b.length()) return a;\\n        else if(b.length() > a.length()) return b;\\n        return a.compareTo(b) < 0 ? b : a;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2979414,
                "title": "python-dp-solution-easy-to-understand-faster-than-75",
                "content": "# Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe follow a simple take/leave type Memoization DFS where we choose either to take or leave a certain digit. If it\\'s not possibe, we return a generic string ```\"N\"```. Then we compare strings formed in both the cases and return the largest one\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        sz = len(cost)\\n        costToDigit = defaultdict(list)\\n        for digit in range(sz - 1, -1, -1):\\n            costToDigit[cost[digit]].append(digit)\\n        \\n        @cache\\n        def dp(digit: int, target: int) -> int:\\n            if target == 0: return \"\"\\n            if digit == sz or target < 0: return \"N\"\\n            leave = dp(digit + 1, target)\\n            take = dp(digit, target - cost[digit]) + str(costToDigit[cost[digit]][0] + 1)\\n            res = []\\n            if \"N\" not in leave: \\n                res.append(leave)\\n            if \"N\" not in take: \\n                res.append(take)\\n            if not res: return \"N\"\\n            if len(res) == 1: return res[0]\\n            if len(leave) > len(take):\\n                return leave\\n            elif len(take) > len(leave):\\n                return take\\n            else:\\n                return leave if leave > take else take\\n        \\n        ans = dp(0, target)\\n        return \"\".join(sorted(ans, reverse = True)) if ans != \"N\" else \"0\"\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\"N\"```\n```\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        sz = len(cost)\\n        costToDigit = defaultdict(list)\\n        for digit in range(sz - 1, -1, -1):\\n            costToDigit[cost[digit]].append(digit)\\n        \\n        @cache\\n        def dp(digit: int, target: int) -> int:\\n            if target == 0: return \"\"\\n            if digit == sz or target < 0: return \"N\"\\n            leave = dp(digit + 1, target)\\n            take = dp(digit, target - cost[digit]) + str(costToDigit[cost[digit]][0] + 1)\\n            res = []\\n            if \"N\" not in leave: \\n                res.append(leave)\\n            if \"N\" not in take: \\n                res.append(take)\\n            if not res: return \"N\"\\n            if len(res) == 1: return res[0]\\n            if len(leave) > len(take):\\n                return leave\\n            elif len(take) > len(leave):\\n                return take\\n            else:\\n                return leave if leave > take else take\\n        \\n        ans = dp(0, target)\\n        return \"\".join(sorted(ans, reverse = True)) if ans != \"N\" else \"0\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2969437,
                "title": "java-knapsack-no-string-comparison-dp-with-example-and-light-explanation",
                "content": "```\\nclass Solution {\\n    private static final boolean LEFT = true;\\n    private static final boolean UP = false;\\n    \\n    public String largestNumber(int[] cost, int target) {\\n        int[] dp = new int[target + 1];\\n        boolean[][] parent = new boolean[10][target + 1]; // parent matrix saves the \"parent pointer\" which records where the current result is coming from\\n        \\n        for (int i = 1; i < 10; i++) {\\n            int curCost = cost[i - 1];\\n            for (int cap = curCost; cap <= target; cap++) {\\n                int curLength = dp[cap - curCost] + 1;\\n                if (cap - curCost != 0 && dp[cap - curCost] == 0) {\\n                    curLength = 0;\\n                }\\n                \\n                if (curLength >= dp[cap]) {// we want to maximize the length of the digits we choose\\n\\t\\t\\t\\t// if there is a tie, we still need to update since the current digit has larger value than the digits we selected previously\\n                    dp[cap] = curLength;\\n                    parent[i][cap] = LEFT;\\n                }\\n            }\\n        }\\n        if (dp[target] == 0) return \"0\";\\n        return buildResult(parent, cost, target);\\n    }\\n    \\n    private String buildResult(boolean[][] parent, int[] cost, int target) {\\n        StringBuilder result = new StringBuilder();\\n        int row = 9;\\n        int col = target;\\n        while (target > 0) {\\n            if (parent[row][col] == UP) {\\n                row--;\\n            } else {\\n                target -= cost[row - 1];\\n                result.append(row);\\n                col -= cost[row - 1];\\n            }\\n        }\\n        return result.toString();\\n    }\\n}\\n\\n/*\\ndp[i][j]: saves the maximum length of the digits that we can get considering the first i digits using j cost\\n\\nExample:\\n 1 2 3 4 5 6 7 8 9 \\n[4,3,2,5,6,7,2,5,5] target = 9\\n\\n       0  1  2  3  4  5  6  7  8  9\\n0      0  0  0  0  0  0  0  0  0  0\\n1(4)   0  0  0  0  1  0  0  0  2  0\\n2(3)   0  0  0  1  1  0  2  2  2  3  \\n3(2)   0  0  1  1  2  2  3  3  4  4\\n4(5)   0  0  1  1  2  2  3  3  4  4\\n5(6)   0  0  1  1  2  2  3  3  4  4\\n6(7)   0  0  1  1  2  2  3  3  4  4\\n7(2)   0  0  1  1  2  2  3  3  4  4\\n8(5)   0  0  1  1  2  2  3  3  4  4\\n9(5)   0  0  1  1  2  2  3  3  4  4\\n\\n\\nparent matrix:\\n       0  1  2  3  4  5  6  7  8  9\\n0      u  u  u  u  u  u  u  u  u  u\\n1(4)   u  u  u  u  l  u  u  u  l  u\\n2(3)   u  u  u  l  u  u  l  l  u  l\\n3(2)   u  u  l  u  l  l  l  l  l  l\\n4(5)   u  u  u  u  u  u  u  u  u  u\\n5(6)   u  u  u  u  u  u  u  u  u  u\\n6(7)   u  u  u  u  u  u  u  u  u  u\\n7(2)   u  u  l  u  l  l  l  l  l  l\\n8(5)   u  u  u  u  u  u  u  u  u  u\\n9(5)   u  u  u  u  u  u  u  u  u  u\\n\\nu --> go up\\nl --> go left\\nmodel left and up with 0 and 1\\n0 ---> up\\n1 ---> left\\n\\n*/ \\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static final boolean LEFT = true;\\n    private static final boolean UP = false;\\n    \\n    public String largestNumber(int[] cost, int target) {\\n        int[] dp = new int[target + 1];\\n        boolean[][] parent = new boolean[10][target + 1]; // parent matrix saves the \"parent pointer\" which records where the current result is coming from\\n        \\n        for (int i = 1; i < 10; i++) {\\n            int curCost = cost[i - 1];\\n            for (int cap = curCost; cap <= target; cap++) {\\n                int curLength = dp[cap - curCost] + 1;\\n                if (cap - curCost != 0 && dp[cap - curCost] == 0) {\\n                    curLength = 0;\\n                }\\n                \\n                if (curLength >= dp[cap]) {// we want to maximize the length of the digits we choose\\n\\t\\t\\t\\t// if there is a tie, we still need to update since the current digit has larger value than the digits we selected previously\\n                    dp[cap] = curLength;\\n                    parent[i][cap] = LEFT;\\n                }\\n            }\\n        }\\n        if (dp[target] == 0) return \"0\";\\n        return buildResult(parent, cost, target);\\n    }\\n    \\n    private String buildResult(boolean[][] parent, int[] cost, int target) {\\n        StringBuilder result = new StringBuilder();\\n        int row = 9;\\n        int col = target;\\n        while (target > 0) {\\n            if (parent[row][col] == UP) {\\n                row--;\\n            } else {\\n                target -= cost[row - 1];\\n                result.append(row);\\n                col -= cost[row - 1];\\n            }\\n        }\\n        return result.toString();\\n    }\\n}\\n\\n/*\\ndp[i][j]: saves the maximum length of the digits that we can get considering the first i digits using j cost\\n\\nExample:\\n 1 2 3 4 5 6 7 8 9 \\n[4,3,2,5,6,7,2,5,5] target = 9\\n\\n       0  1  2  3  4  5  6  7  8  9\\n0      0  0  0  0  0  0  0  0  0  0\\n1(4)   0  0  0  0  1  0  0  0  2  0\\n2(3)   0  0  0  1  1  0  2  2  2  3  \\n3(2)   0  0  1  1  2  2  3  3  4  4\\n4(5)   0  0  1  1  2  2  3  3  4  4\\n5(6)   0  0  1  1  2  2  3  3  4  4\\n6(7)   0  0  1  1  2  2  3  3  4  4\\n7(2)   0  0  1  1  2  2  3  3  4  4\\n8(5)   0  0  1  1  2  2  3  3  4  4\\n9(5)   0  0  1  1  2  2  3  3  4  4\\n\\n\\nparent matrix:\\n       0  1  2  3  4  5  6  7  8  9\\n0      u  u  u  u  u  u  u  u  u  u\\n1(4)   u  u  u  u  l  u  u  u  l  u\\n2(3)   u  u  u  l  u  u  l  l  u  l\\n3(2)   u  u  l  u  l  l  l  l  l  l\\n4(5)   u  u  u  u  u  u  u  u  u  u\\n5(6)   u  u  u  u  u  u  u  u  u  u\\n6(7)   u  u  u  u  u  u  u  u  u  u\\n7(2)   u  u  l  u  l  l  l  l  l  l\\n8(5)   u  u  u  u  u  u  u  u  u  u\\n9(5)   u  u  u  u  u  u  u  u  u  u\\n\\nu --> go up\\nl --> go left\\nmodel left and up with 0 and 1\\n0 ---> up\\n1 ---> left\\n\\n*/ \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2966150,
                "title": "python-string-solution-knapsack-problem-bottom-up-dp",
                "content": "```\\ndef largestNumber(self, cost: List[int], t: int) -> str:\\n\\tdef str_comp(a, b):\\n\\t\\tif len(a)!=len(b):\\n\\t\\t\\treturn a if len(a)>len(b) else b\\n\\t\\treturn a if int(a)>int(b) else b\\n\\n\\tmp, dp = defaultdict(int), [\\'\\']*(t+1)\\n\\tfor i, c in enumerate(cost):\\n\\t\\tif c<=t:\\n\\t\\t\\tmp[c] = max(mp[c], i+1)  # Large digit will be used with the same cost\\n\\t\\t\\tdp[c] = str(i+1)\\n\\tfor i in range(t+1):\\n\\t\\tfor c in mp:\\n\\t\\t\\tif i+c<=t and dp[i]:\\n\\t\\t\\t\\tdp[i+c] = str_comp(dp[i+c], dp[i]+str(mp[c]))\\n\\treturn dp[-1] if dp[-1] else \\'0\\'\\n```",
                "solutionTags": [],
                "code": "```\\ndef largestNumber(self, cost: List[int], t: int) -> str:\\n\\tdef str_comp(a, b):\\n\\t\\tif len(a)!=len(b):\\n\\t\\t\\treturn a if len(a)>len(b) else b\\n\\t\\treturn a if int(a)>int(b) else b\\n\\n\\tmp, dp = defaultdict(int), [\\'\\']*(t+1)\\n\\tfor i, c in enumerate(cost):\\n\\t\\tif c<=t:\\n\\t\\t\\tmp[c] = max(mp[c], i+1)  # Large digit will be used with the same cost\\n\\t\\t\\tdp[c] = str(i+1)\\n\\tfor i in range(t+1):\\n\\t\\tfor c in mp:\\n\\t\\t\\tif i+c<=t and dp[i]:\\n\\t\\t\\t\\tdp[i+c] = str_comp(dp[i+c], dp[i]+str(mp[c]))\\n\\treturn dp[-1] if dp[-1] else \\'0\\'\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2934426,
                "title": "python-memo-dp",
                "content": "```\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        def mkx(n,s,st):return n*(10**st)+s,st+1\\n        mem=[-1 for x in range(target)]\\n        def dp(c):\\n            if c==target:return 0, 0, True\\n            if c>target:return 0, 0, False\\n            if mem[c]!=-1:return mem[c]\\n            m=-1\\n            mst=0\\n            xf=False\\n            for x in range(len(cost)):\\n                s,st,f=dp(cost[x]+c)\\n                if f:\\n                    s,st=mkx(x+1,s,st)\\n                    if s>m:m,mst=s,st\\n                    xf=True\\n            mem[c]=(m,mst,xf)\\n            return mem[c]\\n        x,st,f=dp(0)\\n        if f:return str(x)\\n        return \"0\"\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        def mkx(n,s,st):return n*(10**st)+s,st+1\\n        mem=[-1 for x in range(target)]\\n        def dp(c):\\n            if c==target:return 0, 0, True\\n            if c>target:return 0, 0, False\\n            if mem[c]!=-1:return mem[c]\\n            m=-1\\n            mst=0\\n            xf=False\\n            for x in range(len(cost)):\\n                s,st,f=dp(cost[x]+c)\\n                if f:\\n                    s,st=mkx(x+1,s,st)\\n                    if s>m:m,mst=s,st\\n                    xf=True\\n            mem[c]=(m,mst,xf)\\n            return mem[c]\\n        x,st,f=dp(0)\\n        if f:return str(x)\\n        return \"0\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830653,
                "title": "python-top-down-dp-with-intuition",
                "content": "### Intuition\\n\\n1. since we need to know mapping from cost to digit, we can use `hashmap` to help us\\n2. we can use take-or-skip DFS strategy to find valid candidate answer\\n\\t1. if we can\\'t find any valid candidate, we can use any placeholder to represent as invalid answer for us to memorization and prune branches. here I use `\"N\"`.\\n\\t2. if we find valid answer, return larger one. \\nwe can compare string\\'s length and use numeric string itself as tie-breaker\\nex. \"1111\" > \"11\" and \"4321\" > \"1234\"\\n\\nRuntime: 530 ms, faster than 70.59% of Python3 online submissions\\nMemory Usage: 181 MB, less than 5.88% of Python3 online submissions\\n\\ntime: `O(n * target)  = O(9 * target) = O(target)`\\n```python\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        n = len(cost)\\n        cost2Idx = defaultdict(list)\\n        for i in range(n-1, -1, -1):\\n            cost2Idx[cost[i]].append(i)\\n\\n        @functools.lru_cache(None)\\n        def dfs(i, target):\\n            if target == 0: return \"\"\\n            if i == n or target < 0: return \"N\"\\n            \\n            s1 = dfs(i+1, target)\\n            s2 = dfs(i, target-cost[i]) + str(cost2Idx[cost[i]][0]+1)\\n\\n            res = []\\n            if \"N\" not in s1: res.append(s1)\\n            if \"N\" not in s2: res.append(s2)\\n            \\n            if not res: return \"N\"\\n            if len(res) == 1: return res[0]\\n\\t\\t\\t\\n\\t\\t\\t# or simply just this one line\\n            # return sorted(res, key=lambda s: (len(s), s))[-1] if res else \"N\"\\n            if len(s1) > len(s2):\\n                return s1\\n            elif len(s2) > len(s1):\\n                return s2\\n            else:\\n                return s1 if s1 > s2 else s2\\n        \\n        ans = dfs(0, target)\\n        return \"\".join(sorted(ans, reverse=True)) if ans != \"N\" else \"0\"\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        n = len(cost)\\n        cost2Idx = defaultdict(list)\\n        for i in range(n-1, -1, -1):\\n            cost2Idx[cost[i]].append(i)\\n\\n        @functools.lru_cache(None)\\n        def dfs(i, target):\\n            if target == 0: return \"\"\\n            if i == n or target < 0: return \"N\"\\n            \\n            s1 = dfs(i+1, target)\\n            s2 = dfs(i, target-cost[i]) + str(cost2Idx[cost[i]][0]+1)\\n\\n            res = []\\n            if \"N\" not in s1: res.append(s1)\\n            if \"N\" not in s2: res.append(s2)\\n            \\n            if not res: return \"N\"\\n            if len(res) == 1: return res[0]\\n\\t\\t\\t\\n\\t\\t\\t# or simply just this one line\\n            # return sorted(res, key=lambda s: (len(s), s))[-1] if res else \"N\"\\n            if len(s1) > len(s2):\\n                return s1\\n            elif len(s2) > len(s1):\\n                return s2\\n            else:\\n                return s1 if s1 > s2 else s2\\n        \\n        ans = dfs(0, target)\\n        return \"\".join(sorted(ans, reverse=True)) if ans != \"N\" else \"0\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2676322,
                "title": "top-down",
                "content": "```\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        \\n        @lru_cache(None)\\n        def dfs(num,index):\\n            if num < 0:\\n                return \"0\"\\n            \\n            elif num == 0:\\n                return \"\"\\n            \\n            if index <= 0:\\n                return \"0\"\\n            \\n            res_1 = dfs(num - cost[index-1], index )\\n            res_2 = dfs(num , index - 1)\\n            \\n            if res_1 == \"0\" and res_2 == \"0\":\\n                return \"0\"\\n            elif res_1 == \"0\" and res_2 != \"0\":\\n                return res_2\\n            elif res_1 != \"0\" and res_2 == \"0\":\\n                return str(index) + res_1\\n            else:\\n                return max( str(index) + res_1, res_2, key = lambda x : int(x))\\n            \\n            \\n        return dfs(target,9)\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        \\n        @lru_cache(None)\\n        def dfs(num,index):\\n            if num < 0:\\n                return \"0\"\\n            \\n            elif num == 0:\\n                return \"\"\\n            \\n            if index <= 0:\\n                return \"0\"\\n            \\n            res_1 = dfs(num - cost[index-1], index )\\n            res_2 = dfs(num , index - 1)\\n            \\n            if res_1 == \"0\" and res_2 == \"0\":\\n                return \"0\"\\n            elif res_1 == \"0\" and res_2 != \"0\":\\n                return res_2\\n            elif res_1 != \"0\" and res_2 == \"0\":\\n                return str(index) + res_1\\n            else:\\n                return max( str(index) + res_1, res_2, key = lambda x : int(x))\\n            \\n            \\n        return dfs(target,9)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2657247,
                "title": "easy-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool maxx(string& s1,string& s2){\\n        if(s1.back()==\\'0\\') return false;\\n        else if(s2.back()==\\'0\\') return true;\\n        if(s1.length()==s2.length()){\\n            if(s1>=s2) return true;\\n            else return false;\\n        }\\n        else if(s1.length()>s2.length()) return true;\\n        else return false;\\n    }\\n    string rec(int idx,vector<int>& cost,int target,vector<vector<string>>& dp){\\n        if(idx==-1) {\\n            if(target==0) return \"\";\\n            else return \"0\";\\n        }\\n        if(dp[idx][target]!=\"#\") return dp[idx][target];\\n        string ans = rec(idx-1,cost,target,dp);\\n        if(target>=cost[idx]) {\\n            string op1;\\n            op1 += to_string(idx+1);\\n            op1 += rec(idx,cost,target-cost[idx],dp);\\n            if(maxx(op1,ans)) return dp[idx][target] = op1;\\n        }\\n        return dp[idx][target] = ans; \\n    }\\n    string largestNumber(vector<int>& cost, int target) {\\n        vector<vector<string>> dp(9,vector<string>(target+1,\"#\"));\\n        string ans = rec(8,cost,target,dp);\\n        if(ans.back()==\\'0\\') return \"0\";\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool maxx(string& s1,string& s2){\\n        if(s1.back()==\\'0\\') return false;\\n        else if(s2.back()==\\'0\\') return true;\\n        if(s1.length()==s2.length()){\\n            if(s1>=s2) return true;\\n            else return false;\\n        }\\n        else if(s1.length()>s2.length()) return true;\\n        else return false;\\n    }\\n    string rec(int idx,vector<int>& cost,int target,vector<vector<string>>& dp){\\n        if(idx==-1) {\\n            if(target==0) return \"\";\\n            else return \"0\";\\n        }\\n        if(dp[idx][target]!=\"#\") return dp[idx][target];\\n        string ans = rec(idx-1,cost,target,dp);\\n        if(target>=cost[idx]) {\\n            string op1;\\n            op1 += to_string(idx+1);\\n            op1 += rec(idx,cost,target-cost[idx],dp);\\n            if(maxx(op1,ans)) return dp[idx][target] = op1;\\n        }\\n        return dp[idx][target] = ans; \\n    }\\n    string largestNumber(vector<int>& cost, int target) {\\n        vector<vector<string>> dp(9,vector<string>(target+1,\"#\"));\\n        string ans = rec(8,cost,target,dp);\\n        if(ans.back()==\\'0\\') return \"0\";\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2606371,
                "title": "javascript-recursive-and-iterative-dp-solutions",
                "content": "##### Recursive [Accepted]\\n```\\nvar largestNumber = function(cost, target) {\\n    const INVALID_CASE = \\'0\\';\\n    const BASE_CASE = \\'\\';\\n\\n    const n = cost.length;\\n    const dp = new Array(n).fill().map(() => new Array(target + 1));\\n\\n    const dfs = (i = n - 1, remaining = target) => {\\n        if(i < 0 || remaining < 0) return INVALID_CASE;\\n        if(remaining === 0) return BASE_CASE;\\n\\n        if(dp[i][remaining]) return dp[i][remaining];\\n\\n        const includeDigit = dfs(i, remaining - cost[i]);\\n        const excludeDigit = dfs(i - 1, remaining);\\n\\n        let res = INVALID_CASE;\\n        if(includeDigit !== INVALID_CASE) {\\n            res = (i + 1) + includeDigit;\\n        }\\n        if(excludeDigit !== INVALID_CASE) {\\n            res = res === INVALID_CASE ? excludeDigit : (excludeDigit.length > res.length ? excludeDigit : res);\\n        }\\n\\n        dp[i][remaining] = res;\\n        return res;\\n    }\\n\\n    return dfs();\\n};\\n```\\nRuntime: O(target)\\nSpace: O(target) // length of cost is fixed\\n\\n&nbsp;\\n##### Iterative [Accepted]\\n```\\nvar largestNumber = function(cost, target) {\\n    const INVALID_CASE = \\'0\\';\\n    const BASE_CASE = \\'\\';\\n\\n    const n = cost.length;\\n\\n    const dp = new Array(target + 1);\\n    const getInt = (cost) => {\\n        if(cost < 0) return INVALID_CASE;\\n        if(cost === 0) return BASE_CASE;\\n\\n        return dp[cost] ?? INVALID_CASE;\\n    }\\n\\n    for(let j = 0; j <= target; j += 1) {\\n        for(let i = 0; i < n; i += 1) {\\n            const currentCost = cost[i];\\n            if(currentCost > target) continue;\\n\\n            const prevInt = getInt(j - currentCost);\\n            if(prevInt !== INVALID_CASE) {\\n                const includeDigit = (i + 1) + prevInt;\\n                dp[j] = dp[j] && dp[j].length > includeDigit.length && dp[j] !== INVALID_CASE ? dp[j] : includeDigit;\\n            }\\n        }\\n    }\\n\\n    return dp[target] ? dp[target] : INVALID_CASE;\\n};\\n```\\n\\nRuntime: O(target)\\nSpace: O(target)",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nvar largestNumber = function(cost, target) {\\n    const INVALID_CASE = \\'0\\';\\n    const BASE_CASE = \\'\\';\\n\\n    const n = cost.length;\\n    const dp = new Array(n).fill().map(() => new Array(target + 1));\\n\\n    const dfs = (i = n - 1, remaining = target) => {\\n        if(i < 0 || remaining < 0) return INVALID_CASE;\\n        if(remaining === 0) return BASE_CASE;\\n\\n        if(dp[i][remaining]) return dp[i][remaining];\\n\\n        const includeDigit = dfs(i, remaining - cost[i]);\\n        const excludeDigit = dfs(i - 1, remaining);\\n\\n        let res = INVALID_CASE;\\n        if(includeDigit !== INVALID_CASE) {\\n            res = (i + 1) + includeDigit;\\n        }\\n        if(excludeDigit !== INVALID_CASE) {\\n            res = res === INVALID_CASE ? excludeDigit : (excludeDigit.length > res.length ? excludeDigit : res);\\n        }\\n\\n        dp[i][remaining] = res;\\n        return res;\\n    }\\n\\n    return dfs();\\n};\\n```\n```\\nvar largestNumber = function(cost, target) {\\n    const INVALID_CASE = \\'0\\';\\n    const BASE_CASE = \\'\\';\\n\\n    const n = cost.length;\\n\\n    const dp = new Array(target + 1);\\n    const getInt = (cost) => {\\n        if(cost < 0) return INVALID_CASE;\\n        if(cost === 0) return BASE_CASE;\\n\\n        return dp[cost] ?? INVALID_CASE;\\n    }\\n\\n    for(let j = 0; j <= target; j += 1) {\\n        for(let i = 0; i < n; i += 1) {\\n            const currentCost = cost[i];\\n            if(currentCost > target) continue;\\n\\n            const prevInt = getInt(j - currentCost);\\n            if(prevInt !== INVALID_CASE) {\\n                const includeDigit = (i + 1) + prevInt;\\n                dp[j] = dp[j] && dp[j].length > includeDigit.length && dp[j] !== INVALID_CASE ? dp[j] : includeDigit;\\n            }\\n        }\\n    }\\n\\n    return dp[target] ? dp[target] : INVALID_CASE;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2552562,
                "title": "python-top-down-dp",
                "content": "**Solution**:\\n\\tUse dp to solve this problem. Let dp be the function that generate the largest number given a budget. For each dp call, check for all digits that we can use and if we were to use such digit, can the remaining budget be all used to form a number. If yes, append the digit to front of the returned number. Lastly, return the largest number.\\n\\n**Complexity**:\\nTime: O(n\\\\**2) where n == target // min(cost) and we will call dp n times and it costs O(n) to compare and concatenate n-length strings  \\nSpace: O(n)\\n\\t\\n```\\nfrom functools import lru_cache\\n\\n\\nclass Solution:\\n    def largestNumber(self, cost: list[int], target: int) -> str:\\n\\n        # Determine if string a is greater than string b\\n        def greater(a, b):\\n\\n            # If their lengths are different, use their length to determine if a is greater than b\\n            if len(a) != len(b):\\n                return len(a) > len(b)\\n\\n            # Else, check all digits one by one\\n            for c1, c2 in zip(a,b):\\n\\n                # If current digits of a and b are equal, continue to the next digits pair\\n                if c1 == c2:\\n                    continue\\n\\n                # Else, check if digit of a is greater than digit of b\\n                return c1>c2\\n\\n            # Return False if all digits are the same\\n            return False\\n\\n        # Save costs and their corresponding digits into a dict \\n        # Override the smaller digit with a larger one if their costs are the same\\n        costs = {c: str(i + 1) for i, c in enumerate(cost)}\\n\\n        # Top-down dp to find the largest number giving a budget\\n        @lru_cache(None)\\n        def dp(budget):\\n\\n            # If we have 0 budget left, we have reach the basecase, return (True, \"\")\\n            if budget == 0:\\n                return True, \"\"\\n\\n            # Initialize varaibles to store the largest number and the boolean to indicate that there is a digit where if we were to pick such digit, we can form a number using all of the remaining budget\\n            largestNum, ableToUseAll = \"\", False\\n\\n            # Iterate through all digits\\n            for cost, digit in costs.items():\\n\\n                # If the current digit has a higher cost than the budget, skip it\\n                if cost > budget:\\n                    continue\\n\\n                # Else, if we were to pick such digit, can all of the remaining budget be used to form a number?\\n                usedAll, nextNum = dp(budget - cost)\\n\\n                # If yes\\n                if usedAll:\\n\\n                    # Concatenate the picked digit with the next number to form the current number\\n                    num = digit + nextNum\\n\\n                    # If the current number is greater than previous number, save it\\n                    largestNum = num if greater(num, largestNum) else largestNum\\n\\n                    # Update the boolean  to indicate that we have found a number that formed using all of the budget\\n                    ableToUseAll = ableToUseAll or usedAll\\n\\n            # Return result if we were able to find a number formed using all of the budget\\n            # Else, return \"0\"\\n            return ableToUseAll, largestNum if ableToUseAll else \"0\"\\n\\n        return dp(target)[1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom functools import lru_cache\\n\\n\\nclass Solution:\\n    def largestNumber(self, cost: list[int], target: int) -> str:\\n\\n        # Determine if string a is greater than string b\\n        def greater(a, b):\\n\\n            # If their lengths are different, use their length to determine if a is greater than b\\n            if len(a) != len(b):\\n                return len(a) > len(b)\\n\\n            # Else, check all digits one by one\\n            for c1, c2 in zip(a,b):\\n\\n                # If current digits of a and b are equal, continue to the next digits pair\\n                if c1 == c2:\\n                    continue\\n\\n                # Else, check if digit of a is greater than digit of b\\n                return c1>c2\\n\\n            # Return False if all digits are the same\\n            return False\\n\\n        # Save costs and their corresponding digits into a dict \\n        # Override the smaller digit with a larger one if their costs are the same\\n        costs = {c: str(i + 1) for i, c in enumerate(cost)}\\n\\n        # Top-down dp to find the largest number giving a budget\\n        @lru_cache(None)\\n        def dp(budget):\\n\\n            # If we have 0 budget left, we have reach the basecase, return (True, \"\")\\n            if budget == 0:\\n                return True, \"\"\\n\\n            # Initialize varaibles to store the largest number and the boolean to indicate that there is a digit where if we were to pick such digit, we can form a number using all of the remaining budget\\n            largestNum, ableToUseAll = \"\", False\\n\\n            # Iterate through all digits\\n            for cost, digit in costs.items():\\n\\n                # If the current digit has a higher cost than the budget, skip it\\n                if cost > budget:\\n                    continue\\n\\n                # Else, if we were to pick such digit, can all of the remaining budget be used to form a number?\\n                usedAll, nextNum = dp(budget - cost)\\n\\n                # If yes\\n                if usedAll:\\n\\n                    # Concatenate the picked digit with the next number to form the current number\\n                    num = digit + nextNum\\n\\n                    # If the current number is greater than previous number, save it\\n                    largestNum = num if greater(num, largestNum) else largestNum\\n\\n                    # Update the boolean  to indicate that we have found a number that formed using all of the budget\\n                    ableToUseAll = ableToUseAll or usedAll\\n\\n            # Return result if we were able to find a number formed using all of the budget\\n            # Else, return \"0\"\\n            return ableToUseAll, largestNum if ableToUseAll else \"0\"\\n\\n        return dp(target)[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2448142,
                "title": "c-solution-dynamic-programming-by-storing-strings",
                "content": "```\\nclass Solution {\\nprivate:\\n    vector<string>mem;\\n    string solve(vector<int>&cost,int target){\\n        if(target==0){\\n            return \"\";\\n        } else if(mem[target]!=\"\\\\0\"){\\n            return mem[target];\\n        } else {\\n            string ans=\"0\";\\n            for(int i=0;i<cost.size();i++){\\n                if(target-cost[i]>=0){\\n                    string tmp=solve(cost,target-cost[i]);\\n                    if(tmp!=\"0\"){\\n                        tmp=to_string(i+1)+tmp;\\n                        if(tmp.size()>ans.size()){\\n                            ans=tmp;\\n                        } else if(tmp.size()==ans.size()){\\n                            ans=max(ans,tmp);\\n                        }\\n                    }\\n                }\\n            }\\n            return mem[target]=ans;\\n        }\\n    }\\npublic:\\n    string largestNumber(vector<int>& cost, int target) {\\n        mem=vector<string>(target+1,\"\\\\0\");\\n        return solve(cost,target);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\nprivate:\\n    vector<string>mem;\\n    string solve(vector<int>&cost,int target){\\n        if(target==0){\\n            return \"\";\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2423726,
                "title": "90ms-less-than-84mb-dp-with-a-little-compression-c",
                "content": "![image](https://assets.leetcode.com/users/images/e4f925aa-66ec-4a1e-943e-85bc8cf09272_1660467918.3795223.png)\\n```\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& cost, int target) {\\n        // compression here\\n        // eg: cost=[3, 3,3,3,5,5,5,5,5] will be (map[3] = 4, map[5] = 9)\\n        map<int, int> costInt;\\n        for(int i = 0; i < cost.size(); i++){\\n            costInt[cost[i]] = i + 1;\\n        }\\n        \\n        vector<int> singles; // eg: size == 2\\n        vector<string> dp(target + 1, \"\");\\n        // initialize\\n        for(auto& it: costInt){\\n            singles.push_back(it.first);\\n            dp[it.first] = (char)(\\'0\\' + it.second);\\n        }\\n        \\n        for(int i = 1; i <= target; i++){\\n            for(auto& sg: singles){ // singles = {3, 5}\\n                if(sg > i){\\n                    break;\\n                }\\n                int b = i - sg, newSize = 1 + dp[b].size(); \\n                // calculate new dp[i] after asure the newSize is longer !\\n                if(newSize > 1){\\n                    if(newSize > dp[i].size()){\\n                        dp[i] = dp[b] + dp[sg]; \\n                    }else if(newSize == dp[i].size()){\\n                        string tmp = dp[b] + dp[sg]; \\n                        dp[i] = dp[i] >= tmp ? dp[i] : tmp;\\n                    }\\n                }\\n            }\\n        }\\n        string ans = dp.back();\\n        return ans.empty() ? \"0\": ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& cost, int target) {\\n        // compression here\\n        // eg: cost=[3, 3,3,3,5,5,5,5,5] will be (map[3] = 4, map[5] = 9)\\n        map<int, int> costInt;\\n        for(int i = 0; i < cost.size(); i++){\\n            costInt[cost[i]] = i + 1;\\n        }\\n        \\n        vector<int> singles; // eg: size == 2\\n        vector<string> dp(target + 1, \"\");\\n        // initialize\\n        for(auto& it: costInt){\\n            singles.push_back(it.first);\\n            dp[it.first] = (char)(\\'0\\' + it.second);\\n        }\\n        \\n        for(int i = 1; i <= target; i++){\\n            for(auto& sg: singles){ // singles = {3, 5}\\n                if(sg > i){\\n                    break;\\n                }\\n                int b = i - sg, newSize = 1 + dp[b].size(); \\n                // calculate new dp[i] after asure the newSize is longer !\\n                if(newSize > 1){\\n                    if(newSize > dp[i].size()){\\n                        dp[i] = dp[b] + dp[sg]; \\n                    }else if(newSize == dp[i].size()){\\n                        string tmp = dp[b] + dp[sg]; \\n                        dp[i] = dp[i] >= tmp ? dp[i] : tmp;\\n                    }\\n                }\\n            }\\n        }\\n        string ans = dp.back();\\n        return ans.empty() ? \"0\": ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2419431,
                "title": "c-simple-c-code-dp-memoization",
                "content": "\\n# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\n    string dfs(int idx, vector<vector<string>> &dp, vector<int>& cost, int target)\\n    {\\n        if(target == 0)\\n            return \"\";\\n        if(idx >= cost.size() || target < 0)\\n            return \"0\";\\n        if(dp[idx][target] != \"-1\")\\n            return dp[idx][target];\\n        string val1, val2;\\n        val1 = dfs(0, dp, cost, target-cost[idx]);\\n        val2 = dfs(idx+1, dp, cost, target);\\n        if(val1 == \"0\")\\n        {\\n            return dp[idx][target] = val2;\\n        }\\n        else if(val2 == \"0\")\\n            return dp[idx][target] = to_string(idx+1) + val1;\\n        else\\n        {\\n            val1 = to_string(idx+1) + val1;\\n            if(val1.size() == val2.size())\\n            {\\n                return dp[idx][target] = max(val1,val2);\\n            }\\n            else if(val1.size() > val2.size())\\n                return dp[idx][target] = val1;\\n        }\\n        return dp[idx][target] = val2;\\n    }\\n        \\npublic:\\n    string largestNumber(vector<int>& cost, int target) {\\n        int n = cost.size();\\n        vector<vector<string>> dp(n, vector<string> (target+1, \"-1\"));\\n        return dfs(0, dp, cost, target);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    string dfs(int idx, vector<vector<string>> &dp, vector<int>& cost, int target)\\n    {\\n        if(target == 0)\\n            return \"\";\\n        if(idx >= cost.size() || target < 0)\\n            return \"0\";\\n        if(dp[idx][target] != \"-1\")\\n            return dp[idx][target];\\n        string val1, val2;\\n        val1 = dfs(0, dp, cost, target-cost[idx]);\\n        val2 = dfs(idx+1, dp, cost, target);\\n        if(val1 == \"0\")\\n        {\\n            return dp[idx][target] = val2;\\n        }\\n        else if(val2 == \"0\")\\n            return dp[idx][target] = to_string(idx+1) + val1;\\n        else\\n        {\\n            val1 = to_string(idx+1) + val1;\\n            if(val1.size() == val2.size())\\n            {\\n                return dp[idx][target] = max(val1,val2);\\n            }\\n            else if(val1.size() > val2.size())\\n                return dp[idx][target] = val1;\\n        }\\n        return dp[idx][target] = val2;\\n    }\\n        \\npublic:\\n    string largestNumber(vector<int>& cost, int target) {\\n        int n = cost.size();\\n        vector<vector<string>> dp(n, vector<string> (target+1, \"-1\"));\\n        return dfs(0, dp, cost, target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2410696,
                "title": "c-dp-memoization-good-question",
                "content": "```\\n string func(vector<int> &nums , int target , int i , vector<vector<string>> &dp )\\n    {\\n        if(i==nums.size() || target<0)\\n        {\\n            // false case return \\n            return \"0\";\\n        }\\n        \\n        if(target==0)\\n        {\\n            return \"\";\\n        }\\n        \\n        if(dp[i][target]!=\"-1\")\\n        {\\n            return dp[i][target];\\n        }\\n        \\n        string ans=\"0\";\\n        \\n        // Unbounded knapsack , take it or not take it \\n        \\n        string s1 =  func(nums , target-nums[i] , 0 , dp);\\n        string s2 = func(nums , target , i+1 , dp);\\n        \\n        // s1 , s2 must not contain any \"0\"\\n        \\n        // Now check which 2 of them is bigger \\n        \\n       \\n        \\n        if(s1==\"0\")\\n        {\\n            ans=s2;\\n        }\\n        else\\n        if(s2==\"0\")\\n        {\\n            ans= to_string(i+1) + s1;\\n        }\\n        else\\n        {\\n            if((int)s1.length()>=(int)s2.length())\\n            {\\n                ans= to_string(i+1) + s1;\\n            }\\n            else\\n            if((int)s1.length()<(int)s2.length())\\n            {\\n                ans=s2;\\n            }\\n            else\\n            {\\n                s1= to_string(i+1) + s1;\\n                if(s1 > s2)\\n                {\\n                    ans=s1;\\n                }\\n                else\\n                {\\n                    ans=s2;\\n                }\\n        }\\n        }\\n        \\n        return dp[i][target]=ans;\\n        \\n    }\\n    \\n    // Compare 2 strings using strcmp(s1 , s2) \\n    \\n    // if val > 0 -> s1>s2 , val<0 s2>s1 , val==0 s1=s2 .\\n    \\n    string largestNumber(vector<int>& nums, int target) {\\n        \\n        int n=nums.size();\\n        \\n        vector<vector<string>> dp(n+1 , vector<string>(target+2 , \"-1\"));\\n        \\n        string ans=func(nums , target , 0 , dp);\\n        \\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n string func(vector<int> &nums , int target , int i , vector<vector<string>> &dp )\\n    {\\n        if(i==nums.size() || target<0)\\n        {\\n            // false case return \\n            return \"0\";\\n        }\\n        \\n        if(target==0)\\n        {\\n            return \"\";\\n        }\\n        \\n        if(dp[i][target]!=\"-1\")\\n        {\\n            return dp[i][target];\\n        }\\n        \\n        string ans=\"0\";\\n        \\n        // Unbounded knapsack , take it or not take it \\n        \\n        string s1 =  func(nums , target-nums[i] , 0 , dp);\\n        string s2 = func(nums , target , i+1 , dp);\\n        \\n        // s1 , s2 must not contain any \"0\"\\n        \\n        // Now check which 2 of them is bigger \\n        \\n       \\n        \\n        if(s1==\"0\")\\n        {\\n            ans=s2;\\n        }\\n        else\\n        if(s2==\"0\")\\n        {\\n            ans= to_string(i+1) + s1;\\n        }\\n        else\\n        {\\n            if((int)s1.length()>=(int)s2.length())\\n            {\\n                ans= to_string(i+1) + s1;\\n            }\\n            else\\n            if((int)s1.length()<(int)s2.length())\\n            {\\n                ans=s2;\\n            }\\n            else\\n            {\\n                s1= to_string(i+1) + s1;\\n                if(s1 > s2)\\n                {\\n                    ans=s1;\\n                }\\n                else\\n                {\\n                    ans=s2;\\n                }\\n        }\\n        }\\n        \\n        return dp[i][target]=ans;\\n        \\n    }\\n    \\n    // Compare 2 strings using strcmp(s1 , s2) \\n    \\n    // if val > 0 -> s1>s2 , val<0 s2>s1 , val==0 s1=s2 .\\n    \\n    string largestNumber(vector<int>& nums, int target) {\\n        \\n        int n=nums.size();\\n        \\n        vector<vector<string>> dp(n+1 , vector<string>(target+2 , \"-1\"));\\n        \\n        string ans=func(nums , target , 0 , dp);\\n        \\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2348083,
                "title": "c-simplest-memoization-dynamic-programming",
                "content": "class Solution {\\npublic:\\n    \\n    unordered_map<int, string> dp;\\n    \\n    string fun(vector<int>& cost, int t){\\n        if(t == 0)\\n            return \"\";\\n        else if(t < 0)\\n            return \"0\";\\n        if(dp.count(t))\\n            return dp[t];\\n        \\n        string ans = \"\";\\n        for(int x = 8; x >= 0; x--){\\n            \\n            string rem = fun(cost, t - cost[x]);\\n            if(rem != \"0\" && ans.length() < 1+rem.length()){\\n                ans = to_string(x+1)+rem;\\n            }\\n        }\\n        \\n        return dp[t] = ans.length()?ans:\"0\";\\n        \\n    }\\n    \\n    string largestNumber(vector<int>& cost, int target) {\\n        return fun(cost,target);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    unordered_map<int, string> dp;\\n    \\n    string fun(vector<int>& cost, int t){\\n        if(t == 0)\\n            return \"\";\\n        else if(t < 0)\\n            return \"0\";\\n        if(dp.count(t))\\n            return dp[t];\\n        \\n        string ans = \"\";\\n        for(int x = 8; x >= 0; x--){\\n            \\n            string rem = fun(cost, t - cost[x]);\\n            if(rem != \"0\" && ans.length() < 1+rem.length()){\\n                ans = to_string(x+1)+rem;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2334509,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string minx(string s1,string s2){\\n        for(int i=0;i<s1.length();i++) {\\n            if(s1[i]==\\'0\\') {\\n                s1 = \"0\";\\n                break;\\n            }\\n        }\\n        for(int i=0;i<s2.length();i++) {\\n            if(s2[i]==\\'0\\') {\\n                s2 = \"0\";\\n                break;\\n            }\\n        }\\n        if(s1.length()>s2.length()) return s1;\\n        if(s2.length() > s1.length()) return s2;\\n        return max(s1,s2);\\n    }\\n    string rec(int target,map<int,char>& mp1,map<int,string>& mp2){\\n        if(target==0) return \"\";\\n        string str = \"0\";\\n        if(mp2.find(target)!=mp2.end()) return mp2[target];\\n        for(auto it:mp1){\\n            string str1 = \"\";\\n            str1 += it.second;\\n            if(target>=it.first) str = minx(str,str1 + rec(target-it.first,mp1,mp2) );\\n        }\\n        return mp2[target]=str;\\n    }\\n    string largestNumber(vector<int>& cost, int target) {\\n        map<int,char> mp1;\\n        map<int,string> mp2;\\n        for(int i=0;i<9;i++)mp1[cost[i]] = \\'1\\' + i;\\n        return rec(target,mp1,mp2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minx(string s1,string s2){\\n        for(int i=0;i<s1.length();i++) {\\n            if(s1[i]==\\'0\\') {\\n                s1 = \"0\";\\n                break;\\n            }\\n        }\\n        for(int i=0;i<s2.length();i++) {\\n            if(s2[i]==\\'0\\') {\\n                s2 = \"0\";\\n                break;\\n            }\\n        }\\n        if(s1.length()>s2.length()) return s1;\\n        if(s2.length() > s1.length()) return s2;\\n        return max(s1,s2);\\n    }\\n    string rec(int target,map<int,char>& mp1,map<int,string>& mp2){\\n        if(target==0) return \"\";\\n        string str = \"0\";\\n        if(mp2.find(target)!=mp2.end()) return mp2[target];\\n        for(auto it:mp1){\\n            string str1 = \"\";\\n            str1 += it.second;\\n            if(target>=it.first) str = minx(str,str1 + rec(target-it.first,mp1,mp2) );\\n        }\\n        return mp2[target]=str;\\n    }\\n    string largestNumber(vector<int>& cost, int target) {\\n        map<int,char> mp1;\\n        map<int,string> mp2;\\n        for(int i=0;i<9;i++)mp1[cost[i]] = \\'1\\' + i;\\n        return rec(target,mp1,mp2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2309046,
                "title": "dp-c-easy-understading-knapsack",
                "content": "```\\nclass Solution {\\npublic:\\n     vector<vector<string>>dp;\\n    string helper(vector<int>&cost,int data,int n)\\n    {\\n        if(data==0)\\n            return \"\";\\n        if(n==cost.size())\\n            return \"0\";\\n        if(dp[n][data]!=\"-1\")\\n            return dp[n][data];\\n       string yes=\"0\";\\n       string no=\"0\";\\n        if(cost[n]<=data)\\n            yes=helper(cost,data-cost[n],n);\\n            no=helper(cost,data,n+1);\\n        if(yes==\"0\"&&no==\"0\")\\n            return dp[n][data]= \"0\";\\n        else if(yes==\"0\")\\n            return dp[n][data]=no;\\n        else if(no==\"0\")\\n            return dp[n][data]=yes+to_string(n+1);\\n        else\\n        {\\n            yes=yes+to_string(n+1);\\n            if(yes.size()>no.size())\\n                return dp[n][data]=yes;\\n            if(no.size()>yes.size())\\n                return dp[n][data]=no;\\n            else\\n                for(int i=0;i<yes.size();i++)\\n                {\\n                    if(yes[i]>no[i])\\n                        return dp[n][data]=yes;\\n                   else if(no[i]>yes[i])\\n                        return dp[n][data]= no;\\n                }\\n            return dp[n][data]=yes;\\n        }\\n       \\n    }\\n    string largestNumber(vector<int>& cost, int target) {\\n       dp=vector<vector<string>>(cost.size(),vector<string>(target+1,\"-1\"));\\n       return helper(cost,target,0); \\n    }\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     vector<vector<string>>dp;\\n    string helper(vector<int>&cost,int data,int n)\\n    {\\n        if(data==0)\\n            return \"\";\\n        if(n==cost.size())\\n            return \"0\";\\n        if(dp[n][data]!=\"-1\")\\n            return dp[n][data];\\n       string yes=\"0\";\\n       string no=\"0\";\\n        if(cost[n]<=data)\\n            yes=helper(cost,data-cost[n],n);\\n            no=helper(cost,data,n+1);\\n        if(yes==\"0\"&&no==\"0\")\\n            return dp[n][data]= \"0\";\\n        else if(yes==\"0\")\\n            return dp[n][data]=no;\\n        else if(no==\"0\")\\n            return dp[n][data]=yes+to_string(n+1);\\n        else\\n        {\\n            yes=yes+to_string(n+1);\\n            if(yes.size()>no.size())\\n                return dp[n][data]=yes;\\n            if(no.size()>yes.size())\\n                return dp[n][data]=no;\\n            else\\n                for(int i=0;i<yes.size();i++)\\n                {\\n                    if(yes[i]>no[i])\\n                        return dp[n][data]=yes;\\n                   else if(no[i]>yes[i])\\n                        return dp[n][data]= no;\\n                }\\n            return dp[n][data]=yes;\\n        }\\n       \\n    }\\n    string largestNumber(vector<int>& cost, int target) {\\n       dp=vector<vector<string>>(cost.size(),vector<string>(target+1,\"-1\"));\\n       return helper(cost,target,0); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2308835,
                "title": "dp-easy-c-intersting",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[9][5001];\\n    int dps[9][5001];\\n    int helper(vector<int>&cost,int target,int i)\\n    {\\n        if(target==0)\\n            return 0;\\n        if(i<0)\\n            return INT_MIN;\\n        if(dps[i][target]!=-1)\\n            return dps[i][target];\\n        int yes=INT_MIN;\\n        int no=INT_MIN;\\n        if(target>=cost[i])\\n        {\\n            int next=helper(cost,target-cost[i],i);\\n            if(next!=INT_MIN)\\n                yes=next+1;\\n        }\\n        no=helper(cost,target,i-1);\\n        if(yes==INT_MIN&&no==INT_MIN)\\n        {   \\n            dp[i][target]=0;\\n            return dps[i][target]=yes;\\n        }\\n        else if(yes==INT_MIN)\\n        {   \\n            dp[i][target]=0;\\n            return dps[i][target]= no;\\n        }\\n        else if(no==INT_MIN)\\n        {     \\n            dp[i][target]=1;\\n             return dps[i][target]= yes;\\n        }\\n        else if(yes>=no)\\n        {\\n             dp[i][target]=1;\\n                return dps[i][target]= yes;\\n        }\\n        else\\n        {\\n             dp[i][target]=0;\\n                return dps[i][target]= no;\\n        }\\n    }\\n    string solve(vector<int>&cost,int target,int i)\\n    {\\n        if(target==0||i<0)\\n            return \"\";\\n        if(dp[i][target])\\n        {\\n            return to_string(i+1)+solve(cost,target-cost[i],i);\\n        }\\n        return solve(cost,target,i-1);\\n    }\\n    string largestNumber(vector<int>& cost, int target) {\\n        memset(dp,0,sizeof(dp));\\n        memset(dps,-1,sizeof(dps));\\n        int x= helper(cost,target,8);\\n        if(x==INT_MIN)\\n            return \"0\";\\n        \\n        return solve(cost,target,8);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[9][5001];\\n    int dps[9][5001];\\n    int helper(vector<int>&cost,int target,int i)\\n    {\\n        if(target==0)\\n            return 0;\\n        if(i<0)\\n            return INT_MIN;\\n        if(dps[i][target]!=-1)\\n            return dps[i][target];\\n        int yes=INT_MIN;\\n        int no=INT_MIN;\\n        if(target>=cost[i])\\n        {\\n            int next=helper(cost,target-cost[i],i);\\n            if(next!=INT_MIN)\\n                yes=next+1;\\n        }\\n        no=helper(cost,target,i-1);\\n        if(yes==INT_MIN&&no==INT_MIN)\\n        {   \\n            dp[i][target]=0;\\n            return dps[i][target]=yes;\\n        }\\n        else if(yes==INT_MIN)\\n        {   \\n            dp[i][target]=0;\\n            return dps[i][target]= no;\\n        }\\n        else if(no==INT_MIN)\\n        {     \\n            dp[i][target]=1;\\n             return dps[i][target]= yes;\\n        }\\n        else if(yes>=no)\\n        {\\n             dp[i][target]=1;\\n                return dps[i][target]= yes;\\n        }\\n        else\\n        {\\n             dp[i][target]=0;\\n                return dps[i][target]= no;\\n        }\\n    }\\n    string solve(vector<int>&cost,int target,int i)\\n    {\\n        if(target==0||i<0)\\n            return \"\";\\n        if(dp[i][target])\\n        {\\n            return to_string(i+1)+solve(cost,target-cost[i],i);\\n        }\\n        return solve(cost,target,i-1);\\n    }\\n    string largestNumber(vector<int>& cost, int target) {\\n        memset(dp,0,sizeof(dp));\\n        memset(dps,-1,sizeof(dps));\\n        int x= helper(cost,target,8);\\n        if(x==INT_MIN)\\n            return \"0\";\\n        \\n        return solve(cost,target,8);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2267757,
                "title": "javascript-solution-dp",
                "content": "```\\nfunction largestNumber(cost, target) {\\n    // set dp\\n    const dp = new Array(target + 1).fill(-Infinity), ans = []\\n    \\n    // for first\\n    dp[0] = 0\\n    \\n    // init cost\\n    for (const v of cost) {\\n        for (let i = v; i <= target; i++) {\\n            dp[i] = Math.max(dp[i], dp[i - v] + 1)\\n        }\\n    }\\n    \\n    // no enough\\n    if (dp[target] < 0) {\\n        return `0`\\n    }\\n    \\n    // continuously\\n    for (let i = 9, j = target; i > 0; i--) {\\n        for (let c = cost[i - 1]; j >= c && dp[j] === dp[j - c] + 1; j -= c) {\\n            ans.push(i)\\n        }\\n    }\\n    \\n    // end\\n    return ans.join(\\'\\')\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction largestNumber(cost, target) {\\n    // set dp\\n    const dp = new Array(target + 1).fill(-Infinity), ans = []\\n    \\n    // for first\\n    dp[0] = 0\\n    \\n    // init cost\\n    for (const v of cost) {\\n        for (let i = v; i <= target; i++) {\\n            dp[i] = Math.max(dp[i], dp[i - v] + 1)\\n        }\\n    }\\n    \\n    // no enough\\n    if (dp[target] < 0) {\\n        return `0`\\n    }\\n    \\n    // continuously\\n    for (let i = 9, j = target; i > 0; i--) {\\n        for (let c = cost[i - 1]; j >= c && dp[j] === dp[j - c] + 1; j -= c) {\\n            ans.push(i)\\n        }\\n    }\\n    \\n    // end\\n    return ans.join(\\'\\')\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2258242,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    string MAX(string a, string b) {\\n        if (a.length() != b.length()) {\\n            return a.length() > b.length() ? a : b;\\n        }\\n\\n        for (int i = 0; i < a.length(); i++) {\\n            if (a[i] != b[i]) {\\n                if (a[i] - \\'0\\' > b[i] - \\'0\\') return a;\\n                return b;\\n            }\\n        }\\n        return a;\\n    }\\n\\n    string largestNumber(vector<int>& cost, int target) {\\n\\n        vector<vector<string>> dp(10, vector<string> (target + 1, \"0\"));\\n        for (int i = 0; i <= 9; i++) dp[i][0] = \"\";\\n\\n\\n        /*\\n            this problem is unbounded knapsack exactly\\n            dp[i][j] : we have digits from 1 to i, and the given target is j, what is the maximum value we can make?\\n            one option is to take the digit i, other option is to not take the digit i\\n        */\\n        for (int i = 1; i <= 9; i++) {\\n            for (int j = 1; j <= target; j++) {\\n                dp[i][j] = dp[i - 1][j];\\n                if (j >= cost[i - 1]) {\\n                    if (dp[i][j - cost[i - 1]] != \"0\") dp[i][j] = MAX(dp[i][j], to_string(i) + dp[i][j - cost[i - 1]]);\\n                }\\n            }\\n        }\\n\\n        return dp[9][target];\\n\\n\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string MAX(string a, string b) {\\n        if (a.length() != b.length()) {\\n            return a.length() > b.length() ? a : b;\\n        }\\n\\n        for (int i = 0; i < a.length(); i++) {\\n            if (a[i] != b[i]) {\\n                if (a[i] - \\'0\\' > b[i] - \\'0\\') return a;\\n                return b;\\n            }\\n        }\\n        return a;\\n    }\\n\\n    string largestNumber(vector<int>& cost, int target) {\\n\\n        vector<vector<string>> dp(10, vector<string> (target + 1, \"0\"));\\n        for (int i = 0; i <= 9; i++) dp[i][0] = \"\";\\n\\n\\n        /*\\n            this problem is unbounded knapsack exactly\\n            dp[i][j] : we have digits from 1 to i, and the given target is j, what is the maximum value we can make?\\n            one option is to take the digit i, other option is to not take the digit i\\n        */\\n        for (int i = 1; i <= 9; i++) {\\n            for (int j = 1; j <= target; j++) {\\n                dp[i][j] = dp[i - 1][j];\\n                if (j >= cost[i - 1]) {\\n                    if (dp[i][j - cost[i - 1]] != \"0\") dp[i][j] = MAX(dp[i][j], to_string(i) + dp[i][j - cost[i - 1]]);\\n                }\\n            }\\n        }\\n\\n        return dp[9][target];\\n\\n\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2251008,
                "title": "use-of-unordered-map-memorizing-recursive-c-dp-sol",
                "content": "```\\nclass Solution {\\npublic:\\n    string sol(vector<int>& cost , int target , unordered_map<int , string> &dp){\\n      if(target<0){\\n          return \"0\";\\n      } \\n      if(target==0){\\n          return \"\";\\n      } \\n      if(dp.find(target)!=dp.end()){\\n          return dp[target];\\n      } \\n      string cur,res = \"0\";\\n      for(int i=0;i<9;i++){\\n          cur = sol(cost , target-cost[i] , dp);\\n          if(cur == \"0\"){\\n              continue;\\n          }\\n          cur = to_string(i+1)+cur;\\n          if(cur.size() >= res.size()){\\n              res=cur;\\n          }\\n      }\\n        dp[target] = res;\\n        return res;\\n    }\\n    string largestNumber(vector<int>&cost, int target) {\\n     unordered_map<int , string>dp;\\n       return sol(cost , target , dp);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    string sol(vector<int>& cost , int target , unordered_map<int , string> &dp){\\n      if(target<0){\\n          return \"0\";\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 2206114,
                "title": "bottom-up-apprach-dp-java-solution-detailed-explanation-solution",
                "content": "\\n```\\n// Space Complexity = O(N*M) (N == length of cost array and M == target )\\n// Time Complexity = O(N*M)\\n\\nclass Solution {\\n    Map<String,String> map =  new HashMap<>();\\n    String[][] memo;\\n    public String largestNumber(int[] cost, int target) {\\n        memo = new String[cost.length+1][target+1];\\n        \\n        for( int i = 0;i<=cost.length;i++ ){\\n            for(int j = 0;j<=target;j++) memo[i][j] = \"0\";\\n        }\\n        \\n        String res = helper(cost,cost.length-1,target);\\n        \\n        return res == \"-1\" ? \"0\" : res; \\n        \\n    }\\n    \\n    public String helper( int[] cost , int index , int target){\\n        if(target == 0) {\\n            return \"\";\\n        }\\n        \\n        if(target < 0) return \"-1\";\\n        \\n        if(index < 0) return \"-1\";\\n        \\n        if( memo[index][target] != \"0\") return memo[index][target];\\n        \\n        String str1 = (index+1) + helper(cost,cost.length-1,target-cost[index]) ;\\n        String str2 = helper(cost,index-1,target);\\n        \\n        String res = getBigger(str1,str2);\\n        \\n        memo[index][target] =  res;\\n        \\n        return res;\\n    }\\n    \\n    public String getBigger(String num1 , String num2){\\n        if( num1.contains(\"-1\") ) return num2;\\n        if( num2.contains(\"-1\") ) return num1;\\n        if( num1.length() > num2.length() ) return num1;\\n        if( num2.length() > num1.length() ) return num2;\\n        return Double.parseDouble( num1 ) < Double.parseDouble( num2 ) ? num2 : num1;\\n    }\\n}\\n```\\n\\n/*\\nAs we can see we are given a cost array and a target value and we are asked to return the largest string which we can form.\\n\\nTo create the largest string:\\nwe can take any cost value from index = (0,cost.length-1) + 1 ;(1-based indexing)\\n\\nIf we can not reach to our exact target value(target == 0) we return -1;\\n\\n\\nApproach:\\n\\n    As we can see this question is quite similar to unbounded knapsack(we can select one digit and again can select from the whole cost array)\\n    \\n    Two things can happen at each index we either pick the value or not\\n    1--> If we pick the cost value then we add that (index+1_) to our curr string and decrment cost[index] value from target and again call helper method fro the whole cost array.\\n    2 --> We don\\'t select current value and go index-1;target value remians the same as we have not selected the value.\\n    \\n    If target < 0(can not be form) return \"-1\" as there are no negative values.\\n    If target == 0 return \"\".\\n    \\n    Now At this point we have two string which are retuned.\\n    \\n    We compare them:\\n    if one of the string contains (-1) we return the other string.\\n    if one string has length greater than the other we return greater length string\\n    At last we compare both the string by  values and return string with greater value;\\n    \\n    This apprach can take a long amount of time and will give TLE if it is not memorize.\\n    So as index and target value are the one changing so we memorize respect to them.\\n    \\n    To fill the memorize array we use \"0\" as \"0\" is not present in the whole cost array.You can also choose \"0\" as the returned value if target goes less than 0 and \"-1\" to memorize array.I use it because i feel \"-1\" gives more meaning but its still the same thing.\\n    \\n*/",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n// Space Complexity = O(N*M) (N == length of cost array and M == target )\\n// Time Complexity = O(N*M)\\n\\nclass Solution {\\n    Map<String,String> map =  new HashMap<>();\\n    String[][] memo;\\n    public String largestNumber(int[] cost, int target) {\\n        memo = new String[cost.length+1][target+1];\\n        \\n        for( int i = 0;i<=cost.length;i++ ){\\n            for(int j = 0;j<=target;j++) memo[i][j] = \"0\";\\n        }\\n        \\n        String res = helper(cost,cost.length-1,target);\\n        \\n        return res == \"-1\" ? \"0\" : res; \\n        \\n    }\\n    \\n    public String helper( int[] cost , int index , int target){\\n        if(target == 0) {\\n            return \"\";\\n        }\\n        \\n        if(target < 0) return \"-1\";\\n        \\n        if(index < 0) return \"-1\";\\n        \\n        if( memo[index][target] != \"0\") return memo[index][target];\\n        \\n        String str1 = (index+1) + helper(cost,cost.length-1,target-cost[index]) ;\\n        String str2 = helper(cost,index-1,target);\\n        \\n        String res = getBigger(str1,str2);\\n        \\n        memo[index][target] =  res;\\n        \\n        return res;\\n    }\\n    \\n    public String getBigger(String num1 , String num2){\\n        if( num1.contains(\"-1\") ) return num2;\\n        if( num2.contains(\"-1\") ) return num1;\\n        if( num1.length() > num2.length() ) return num1;\\n        if( num2.length() > num1.length() ) return num2;\\n        return Double.parseDouble( num1 ) < Double.parseDouble( num2 ) ? num2 : num1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2155603,
                "title": "python-lru-cache",
                "content": "```\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        @lru_cache(None)\\n        def f(t):\\n            if t==0:\\n                return 0,\\'\\'\\n            ans=(-inf,\\'\\')\\n            for i in range(9):\\n                if t-cost[i]>=0:\\n                    a,b=f(t-cost[i])\\n                    if a==-inf:continue\\n                    ans=max(ans,(a+1,int(str(i+1)+str(b))))\\n            return ans\\n        return str(f(target)[1]) if str(f(target)[1])!=\\'\\' else \\'0\\'\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        @lru_cache(None)\\n        def f(t):\\n            if t==0:\\n                return 0,\\'\\'\\n            ans=(-inf,\\'\\')\\n            for i in range(9):\\n                if t-cost[i]>=0:\\n                    a,b=f(t-cost[i])\\n                    if a==-inf:continue\\n                    ans=max(ans,(a+1,int(str(i+1)+str(b))))\\n            return ans\\n        return str(f(target)[1]) if str(f(target)[1])!=\\'\\' else \\'0\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2150654,
                "title": "c-recursion-with-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[12][5005];\\n    int rec(int ind,int target,vector<int>&cost)\\n    {\\n        if(ind==0)\\n        {\\n            if(target)\\n                return dp[ind][target]=INT_MIN;\\n            return dp[ind][target]=0;\\n        }\\n        if(target==0)\\n            return dp[ind][target]=0;\\n        if(dp[ind][target]!=-1)\\n            return dp[ind][target];\\n        if(cost[ind-1]<=target)\\n            return dp[ind][target]=max(1+rec(ind,target-cost[ind-1],cost),rec(ind-1,target,cost));\\n        return dp[ind][target]=rec(ind-1,target,cost);\\n    }\\n    string largestNumber(vector<int>& cost, int target) {\\n        memset(dp,-1,sizeof(dp));\\n        int x=rec(9,target,cost);\\n        if(dp[9][target]<=0)\\n            return \"0\";\\n        string ans;\\n        int ind=9,target1=target;\\n        while(ind>0)\\n        {\\n            if(cost[ind-1]<=target1)\\n            {\\n                if(dp[ind][target1-cost[ind-1]]==dp[ind][target1]-1)\\n                    ans+=ind+\\'0\\',target1-=cost[ind-1];\\n                else\\n                    ind--;\\n            }\\n            else\\n                ind--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[12][5005];\\n    int rec(int ind,int target,vector<int>&cost)\\n    {\\n        if(ind==0)\\n        {\\n            if(target)\\n                return dp[ind][target]=INT_MIN;\\n            return dp[ind][target]=0;\\n        }\\n        if(target==0)\\n            return dp[ind][target]=0;\\n        if(dp[ind][target]!=-1)\\n            return dp[ind][target];\\n        if(cost[ind-1]<=target)\\n            return dp[ind][target]=max(1+rec(ind,target-cost[ind-1],cost),rec(ind-1,target,cost));\\n        return dp[ind][target]=rec(ind-1,target,cost);\\n    }\\n    string largestNumber(vector<int>& cost, int target) {\\n        memset(dp,-1,sizeof(dp));\\n        int x=rec(9,target,cost);\\n        if(dp[9][target]<=0)\\n            return \"0\";\\n        string ans;\\n        int ind=9,target1=target;\\n        while(ind>0)\\n        {\\n            if(cost[ind-1]<=target1)\\n            {\\n                if(dp[ind][target1-cost[ind-1]]==dp[ind][target1]-1)\\n                    ans+=ind+\\'0\\',target1-=cost[ind-1];\\n                else\\n                    ind--;\\n            }\\n            else\\n                ind--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2054957,
                "title": "python-dp-math-127ms-faster-than-100",
                "content": "https://leetcode.com/submissions/detail/702984069/\\n\\n1. Consider the easy case where the minimum cost is 1. We can construct the string from the largest digit with that cost and be done.\\n2. Find the GCD of the costs. If it doesn\\'t divide the `target`, we cannot satisfy the problem constraints and we can report the error early.\\n3. Find the LCM of the costs. We can substantially reduce the target if it is larger than the LCM: we know we\\'ll use the largest digit with the smallest cost to fill each LCM \"portion\" of the target, so we\\'ll only consider the remainder (`target %= c_lcm`) for DP.\\n4. Use DP: `dp[i]` will hold a tuple of `(number_of_digits, last_added_digit)`. `dp[0]` is the base case, requiring no digits. We can then iterate by increasing `i` until we fill the array up to the `dp[target]`. Complexity: `O(target%lcm(cost))` (sorry, there is no easier way to express it; we can even end up not doing any DP at all if the desired target was a multiple of the LCM(cost))\\n5. If it is impossible to represent the target, return \"0\".\\n6. Count the number of instances of each digit by (a) walking back the `dp` array and using the `last_added_digit` part of the tuple and (b) adjust by the number of LCM blocks calculated at step 3.\\n7. Construct the string from the counters of digits by putting the highest digits first.\\n\\n```\\nfrom math import gcd, lcm\\n\\n# Find largest digit with minimum cost\\ndef find_cheapest(cost):\\n    c = len(cost) - 1\\n    for d in range(len(cost) - 2, -1, -1):\\n        if cost[d] < cost[c]:\\n            c = d\\n    return c\\n\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        # Reduce the target: if it is more than LCM of costs, we can allocate\\n        # LCM*k blocks using the cheapest digit to make the longest number.\\n        # Also check GCD: if GCD(costs) does not divide the target, we cannot\\n        # represent it and can bail early. Also, if the minimum cost is 1,\\n        # we can just create an number from the largest digit with that cost.\\n        c_min = min(*cost)\\n        if c_min == 1:\\n            return chr(ord(\\'1\\') + find_cheapest(cost))*target\\n        c_lcm = lcm(*cost)\\n        c_gcd = gcd(*cost)\\n        if target % c_gcd != 0:\\n            return \"0\"\\n        n_lcm = target // c_lcm\\n        target %= c_lcm\\n        dp = [(-1, -1)] * (target + 1)\\n        dp[0] = 0, -1\\n        for v in range(1, target+1):\\n            bestlen = -1\\n            bestdig = -1\\n            for d in range(len(cost) - 1, -1, -1):\\n                c = cost[d]\\n                if c <= v:\\n                    prevlen = dp[v-c][0]\\n                    if prevlen != -1 and prevlen >= bestlen:\\n                        bestlen = prevlen + 1\\n                        bestdig = d\\n                        \\n            dp[v] = (bestlen, bestdig)\\n        if dp[target][0] == -1:\\n            return \"0\"\\n        # Count the accumulated digits\\n        digits = [0]*10\\n        v = target\\n        while v:\\n            digits[dp[v][1] + 1] += 1 # cost array has 1\\'s cost at [0]\\n            v -= cost[dp[v][1]]\\n        # If we skipped some multiple of LCM, find the cheapest digit and use it\\n        # as many times as possible.\\n        if n_lcm:\\n            cheapest = find_cheapest(cost)\\n            digits[cheapest + 1] += n_lcm * c_lcm // cost[cheapest]\\n        s = \"\"\\n        for d in range(9, 0, -1):\\n            s += chr(ord(\\'0\\') + d)*digits[d]\\n        return s\\n```",
                "solutionTags": [],
                "code": "```\\nfrom math import gcd, lcm\\n\\n# Find largest digit with minimum cost\\ndef find_cheapest(cost):\\n    c = len(cost) - 1\\n    for d in range(len(cost) - 2, -1, -1):\\n        if cost[d] < cost[c]:\\n            c = d\\n    return c\\n\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        # Reduce the target: if it is more than LCM of costs, we can allocate\\n        # LCM*k blocks using the cheapest digit to make the longest number.\\n        # Also check GCD: if GCD(costs) does not divide the target, we cannot\\n        # represent it and can bail early. Also, if the minimum cost is 1,\\n        # we can just create an number from the largest digit with that cost.\\n        c_min = min(*cost)\\n        if c_min == 1:\\n            return chr(ord(\\'1\\') + find_cheapest(cost))*target\\n        c_lcm = lcm(*cost)\\n        c_gcd = gcd(*cost)\\n        if target % c_gcd != 0:\\n            return \"0\"\\n        n_lcm = target // c_lcm\\n        target %= c_lcm\\n        dp = [(-1, -1)] * (target + 1)\\n        dp[0] = 0, -1\\n        for v in range(1, target+1):\\n            bestlen = -1\\n            bestdig = -1\\n            for d in range(len(cost) - 1, -1, -1):\\n                c = cost[d]\\n                if c <= v:\\n                    prevlen = dp[v-c][0]\\n                    if prevlen != -1 and prevlen >= bestlen:\\n                        bestlen = prevlen + 1\\n                        bestdig = d\\n                        \\n            dp[v] = (bestlen, bestdig)\\n        if dp[target][0] == -1:\\n            return \"0\"\\n        # Count the accumulated digits\\n        digits = [0]*10\\n        v = target\\n        while v:\\n            digits[dp[v][1] + 1] += 1 # cost array has 1\\'s cost at [0]\\n            v -= cost[dp[v][1]]\\n        # If we skipped some multiple of LCM, find the cheapest digit and use it\\n        # as many times as possible.\\n        if n_lcm:\\n            cheapest = find_cheapest(cost)\\n            digits[cheapest + 1] += n_lcm * c_lcm // cost[cheapest]\\n        s = \"\"\\n        for d in range(9, 0, -1):\\n            s += chr(ord(\\'0\\') + d)*digits[d]\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2009089,
                "title": "python-top-down",
                "content": "based on https://leetcode.com/problems/form-largest-integer-with-digits-that-add-up-to-target/discuss/635266/Python-DP-topdown-with-memoization-solution-O(target)-time-and-space\\n```\\nfrom functools import lru_cache\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        @lru_cache(None)\\n        def dfs(t):\\n            if t == 0: return 0\\n            res = float(\\'-inf\\')\\n            for digit in range(1,10):\\n                if t - cost[digit-1] >= 0:\\n                    res = max(res, dfs(t - cost[digit-1])*10+digit)\\n            return res\\n        res = dfs(target)\\n        return \"0\" if res == float(\\'-inf\\') else str(res)",
                "solutionTags": [
                    "Python"
                ],
                "code": "based on https://leetcode.com/problems/form-largest-integer-with-digits-that-add-up-to-target/discuss/635266/Python-DP-topdown-with-memoization-solution-O(target)-time-and-space\\n```\\nfrom functools import lru_cache\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        @lru_cache(None)\\n        def dfs(t):\\n            if t == 0: return 0\\n            res = float(\\'-inf\\')\\n            for digit in range(1,10):\\n                if t - cost[digit-1] >= 0:\\n                    res = max(res, dfs(t - cost[digit-1])*10+digit)\\n            return res\\n        res = dfs(target)\\n        return \"0\" if res == float(\\'-inf\\') else str(res)",
                "codeTag": "Java"
            },
            {
                "id": 1993036,
                "title": "js-dp",
                "content": "```\\nvar largestNumber = function (cost, target) {\\n\\tconst costs = {};\\n\\tfor (let d = 0; d < cost.length; d++) costs[cost[d]] = d + 1;\\n\\n\\tif (costs[1]) return (costs[1] + \"\").repeat(target);\\n\\n\\tconst dp = Array(target + 1)\\n\\t\\t\\t.fill()\\n\\t\\t\\t.map(() => Array(11).fill(0)),\\n\\t\\tcompare = (state1, state2) => {\\n\\t\\t\\tfor (let i = 9; i > 0; i--)\\n\\t\\t\\t\\tif (state1[i] !== state2[i])\\n\\t\\t\\t\\t\\treturn state1[i] > state2[i] ? state1 : state2;\\n\\t\\t\\treturn state1;\\n\\t\\t};\\n\\t//last item is digitCount, target 0 has 1 digit= 0\\n\\tdp[0][10] = 1;\\n\\n\\tfor (let a = 1; a < dp.length; a++)\\n\\t\\tfor (const c of Object.keys(costs))\\n\\t\\t\\tif (a >= c && dp[a - c][10]) {\\n\\t\\t\\t\\tconst newState = [...dp[a - c]];\\n\\t\\t\\t\\tnewState[10]++;\\n\\t\\t\\t\\tnewState[costs[c]]++;\\n\\t\\t\\t\\tif (newState[10] > dp[a][10]) dp[a] = newState;\\n\\t\\t\\t\\telse if (newState[10] === dp[a][10]) dp[a] = compare(newState, dp[a]);\\n\\t\\t\\t}\\n\\n\\tif (!dp[target][10]) return \"0\";\\n\\n\\tlet res = \"\";\\n\\tfor (let i = 9; i > 0; i--)\\n\\t\\tdp[target][i] && (res += (i + \"\").repeat(dp[target][i]));\\n\\treturn res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar largestNumber = function (cost, target) {\\n\\tconst costs = {};\\n\\tfor (let d = 0; d < cost.length; d++) costs[cost[d]] = d + 1;\\n\\n\\tif (costs[1]) return (costs[1] + \"\").repeat(target);\\n\\n\\tconst dp = Array(target + 1)\\n\\t\\t\\t.fill()\\n\\t\\t\\t.map(() => Array(11).fill(0)),\\n\\t\\tcompare = (state1, state2) => {\\n\\t\\t\\tfor (let i = 9; i > 0; i--)\\n\\t\\t\\t\\tif (state1[i] !== state2[i])\\n\\t\\t\\t\\t\\treturn state1[i] > state2[i] ? state1 : state2;\\n\\t\\t\\treturn state1;\\n\\t\\t};\\n\\t//last item is digitCount, target 0 has 1 digit= 0\\n\\tdp[0][10] = 1;\\n\\n\\tfor (let a = 1; a < dp.length; a++)\\n\\t\\tfor (const c of Object.keys(costs))\\n\\t\\t\\tif (a >= c && dp[a - c][10]) {\\n\\t\\t\\t\\tconst newState = [...dp[a - c]];\\n\\t\\t\\t\\tnewState[10]++;\\n\\t\\t\\t\\tnewState[costs[c]]++;\\n\\t\\t\\t\\tif (newState[10] > dp[a][10]) dp[a] = newState;\\n\\t\\t\\t\\telse if (newState[10] === dp[a][10]) dp[a] = compare(newState, dp[a]);\\n\\t\\t\\t}\\n\\n\\tif (!dp[target][10]) return \"0\";\\n\\n\\tlet res = \"\";\\n\\tfor (let i = 9; i > 0; i--)\\n\\t\\tdp[target][i] && (res += (i + \"\").repeat(dp[target][i]));\\n\\treturn res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1951812,
                "title": "dp-in-python-beat-100",
                "content": "# Explanation\\n\\n[Problem Description](https://leetcode.com/problems/form-largest-integer-with-digits-that-add-up-to-target/)\\n\\nThis problem could be solved by dynamic programing (DP). So, to the most important, let us define the state, and write the state transfer functions.\\n\\nFirstly, preprocess the cost array, so that we can easily compare the result of subproblems.\\n\\nSecondly, apply the dp algorithm. There are two implementations for it. The top-down (recursion) and bottom-up (iteration) ways. Actually most dp problems could be sovled in the two ways. Refer to [Solution 1](#solution-1) and [Solution 2](#solution-2) for details.\\n\\nBoth solutions can beat 100%.\\n\\n# Solution\\n\\n## Solution 1\\n```python\\nclass Solution:\\n    INFEASIBLE = \"-1\"\\n    \\n    def __init__(self):\\n        self.results = {}\\n        self.cost_sorted: List[Tuple[int, int]] = [(0,0)]\\n            \\n    def dp(self, target:int) -> str:\\n        if target in self.results: return self.results[target]\\n        result = \"\"\\n        for cost, order in self.cost_sorted:\\n            subtarget = target - cost\\n            if subtarget == 0: \\n                if result == \"\": result = str(order)\\n            elif subtarget < 0: continue\\n            else:\\n                subresult = self.dp(subtarget)\\n                if subresult != self.INFEASIBLE:\\n                    # Thanks to the preprocessing of the cost array, \\n                    # we could compare the results in this way\\n                    if len(subresult) > len(result) - 1:\\n                        result = str(order) + subresult\\n        if result != \"\":\\n            self.results[target] = result\\n            return result\\n        else:\\n            self.results[target] = self.INFEASIBLE\\n            return self.INFEASIBLE\\n            \\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        _cost: Dict = {}\\n        for i, c in enumerate(cost, 1):\\n            _cost[c] = i\\n        # here we sort it, for easier comparison between results\\n        self.cost_sorted = sorted(_cost.items(), key=lambda item:-item[1])\\n        # dp starts here\\n        self.dp(target)\\n        return  \"0\" if self.results[target] == self.INFEASIBLE else self.results[target]\\n```\\n\\n## complexity\\n\\n- time: $O(n*m)$\\n- space: $O(n)$\\n\\n\\n## Solution 2\\n\\n```python\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        _cost: Dict = {}\\n        for i, c in enumerate(cost, 1):\\n            _cost[c] = i\\n        # here we sort it, for easier comparison between results\\n        cost_sorted = sorted(_cost.items(), key=lambda item:-item[1])\\n        # dp starts here\\n        dp = [\"\"] + [\"-1\"] * target\\n        for t in range(1, target+1):\\n            for cost, order in cost_sorted:\\n                subtarget = t - cost\\n                if subtarget < 0: continue\\n                if subtarget == 0:\\n                    if dp[t] == \"-1\": dp[t] = str(order)\\n                else:\\n                    if dp[subtarget] == \"-1\": continue\\n                    r = str(order) + dp[subtarget]\\n                    if dp[t] == \"-1\": dp[t] = r\\n                    elif len(r) > len(dp[t]): dp[t] = r\\n        return  \"0\" if dp[target] == \"-1\" else dp[target]\\n```\\n\\n## complexity\\n\\n- time: $O(n*m)$\\n- space: $O(n)$\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    INFEASIBLE = \"-1\"\\n    \\n    def __init__(self):\\n        self.results = {}\\n        self.cost_sorted: List[Tuple[int, int]] = [(0,0)]\\n            \\n    def dp(self, target:int) -> str:\\n        if target in self.results: return self.results[target]\\n        result = \"\"\\n        for cost, order in self.cost_sorted:\\n            subtarget = target - cost\\n            if subtarget == 0: \\n                if result == \"\": result = str(order)\\n            elif subtarget < 0: continue\\n            else:\\n                subresult = self.dp(subtarget)\\n                if subresult != self.INFEASIBLE:\\n                    # Thanks to the preprocessing of the cost array, \\n                    # we could compare the results in this way\\n                    if len(subresult) > len(result) - 1:\\n                        result = str(order) + subresult\\n        if result != \"\":\\n            self.results[target] = result\\n            return result\\n        else:\\n            self.results[target] = self.INFEASIBLE\\n            return self.INFEASIBLE\\n            \\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        _cost: Dict = {}\\n        for i, c in enumerate(cost, 1):\\n            _cost[c] = i\\n        # here we sort it, for easier comparison between results\\n        self.cost_sorted = sorted(_cost.items(), key=lambda item:-item[1])\\n        # dp starts here\\n        self.dp(target)\\n        return  \"0\" if self.results[target] == self.INFEASIBLE else self.results[target]\\n```\n```python\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        _cost: Dict = {}\\n        for i, c in enumerate(cost, 1):\\n            _cost[c] = i\\n        # here we sort it, for easier comparison between results\\n        cost_sorted = sorted(_cost.items(), key=lambda item:-item[1])\\n        # dp starts here\\n        dp = [\"\"] + [\"-1\"] * target\\n        for t in range(1, target+1):\\n            for cost, order in cost_sorted:\\n                subtarget = t - cost\\n                if subtarget < 0: continue\\n                if subtarget == 0:\\n                    if dp[t] == \"-1\": dp[t] = str(order)\\n                else:\\n                    if dp[subtarget] == \"-1\": continue\\n                    r = str(order) + dp[subtarget]\\n                    if dp[t] == \"-1\": dp[t] = r\\n                    elif len(r) > len(dp[t]): dp[t] = r\\n        return  \"0\" if dp[target] == \"-1\" else dp[target]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1781771,
                "title": "javascript-solution",
                "content": "/**\\n * @param {number[]} cost\\n * @param {number} target\\n * @return {string}\\n */\\n\\nvar largestNumber = function (cost, target) {\\n  const m = target;\\n  // \\u4E3A\\u4E86\\u4ECE\\u5E95\\u5411\\u4E0A\\u8FDB\\u884C\\u63A8\\u7B97\\n  const n = cost.length + 2;\\n  // dp[i][j] \\u8868\\u793Atarget\\u4E3Ai\\u7684\\u65F6\\u5019\\uFF0C\\u4ECE9\\u5230j\\u7684\\u6700\\u5927\\u8868\\u793A\\uFF0C\\u56E0\\u4E3Acost\\u7684\\u957F\\u5EA6\\u6700\\u957F\\u4E3A9\\n  const dp = new Array(m + 1);\\n  for (let i = 0; i <= m; i++) {\\n    dp[i] = new Array(n).fill(\"0\");\\n  }\\n  for (let i = 1; i <= m; i++) {\\n    for (let j = cost.length; j > 0; j--) {\\n      // \\u5982\\u679C\\u5F53\\u524D\\u7684\\u6570\\u5B57\\u6BD4i\\u8FD8\\u5927\\uFF0C\\u90A3\\u4E48\\u53EA\\u80FD\\u4E0D\\u4F7F\\u7528\\u8BE5\\u6570\\u5B57\\uFF0C\\u770B\\u770B\\u524D\\u9762\\u7684\\u6709\\u6CA1\\u6709\\u66F4\\u5927\\u7684\\u503C\\n      if (cost[j - 1] > i) {\\n        dp[i][j] = dp[i][j + 1];\\n      } else if (cost[j - 1] === i) {\\n        // \\u6B64\\u65F6\\u6709\\u4E24\\u79CD\\u60C5\\u51B5\\uFF0C\\n        // \\u7B2C\\u4E00\\u79CD\\u60C5\\u51B5\\u662F\\u524D\\u9762\\u5DF2\\u7ECF\\u6709\\u66F4\\u5927\\u7684\\u503C\\u4E86\\uFF0C\\u6240\\u4EE5\\u6B64\\u65F6\\u4E5F\\u653E\\u5F03\\n        if (dp[i][j + 1].length > 1) {\\n          dp[i][j] = dp[i][j + 1];\\n        } else {\\n          // \\u5982\\u679C\\u524D\\u9762\\u6CA1\\u7528\\u7684\\u8BDD\\uFF0C\\u6B64\\u65F6\\u4F7F\\u7528\\u8BE5\\u7D22\\u5F15\\n          dp[i][j] = j + \"0\";\\n        }\\n        // \\u8FD8\\u6709\\u53E6\\u5916\\u4E00\\u79CD\\u60C5\\u51B5\\uFF0C\\u5982\\u679C\\u6B64\\u65F6\\u4F7F\\u7528\\u4E86\\u8BE5\\u7D22\\u5F15\\n        // \\u90A3\\u4E48dp[i-cost[j-1]][1] \\u5982\\u679C\\u6B64\\u65F6\\u8BE5\\u503C\\u6709\\u6700\\u5927\\u503C\\u4E86\\uFF0C\\u5E76\\u4E14\\n        // dp[i][j+1]\\u6B64\\u65F6\\u7684\\u957F\\u5EA6\\u5C0F\\u4E8Edp[i-cost[j-1]][1]+1,\\u90A3\\u4E48\\u5C31\\u4F7F\\u7528\\n      } else if (\\n        dp[i - cost[j - 1]][1].length > 1 &&\\n        dp[i - cost[j - 1]][1].length + 1 > dp[i][j + 1].length\\n      ) {\\n        dp[i][j] = j + dp[i - cost[j - 1]][1];\\n      } else {\\n        dp[i][j] = dp[i][j + 1];\\n      }\\n    }\\n  }\\n  if (dp[m][1].length > 1) {\\n    return dp[m][1].substring(0, dp[m][1].length - 1);\\n  }\\n  return dp[m][1];\\n};\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "/**\\n * @param {number[]} cost\\n * @param {number} target\\n * @return {string}\\n */\\n\\nvar largestNumber = function (cost, target) {\\n  const m = target;\\n  // \\u4E3A\\u4E86\\u4ECE\\u5E95\\u5411\\u4E0A\\u8FDB\\u884C\\u63A8\\u7B97\\n  const n = cost.length + 2;\\n  // dp[i][j] \\u8868\\u793Atarget\\u4E3Ai\\u7684\\u65F6\\u5019\\uFF0C\\u4ECE9\\u5230j\\u7684\\u6700\\u5927\\u8868\\u793A\\uFF0C\\u56E0\\u4E3Acost\\u7684\\u957F\\u5EA6\\u6700\\u957F\\u4E3A9\\n  const dp = new Array(m + 1);\\n  for (let i = 0; i <= m; i++) {\\n    dp[i] = new Array(n).fill(\"0\");\\n  }\\n  for (let i = 1; i <= m; i++) {\\n    for (let j = cost.length; j > 0; j--) {\\n      // \\u5982\\u679C\\u5F53\\u524D\\u7684\\u6570\\u5B57\\u6BD4i\\u8FD8\\u5927\\uFF0C\\u90A3\\u4E48\\u53EA\\u80FD\\u4E0D\\u4F7F\\u7528\\u8BE5\\u6570\\u5B57\\uFF0C\\u770B\\u770B\\u524D\\u9762\\u7684\\u6709\\u6CA1\\u6709\\u66F4\\u5927\\u7684\\u503C\\n      if (cost[j - 1] > i) {\\n        dp[i][j] = dp[i][j + 1];\\n      } else if (cost[j - 1] === i) {\\n        // \\u6B64\\u65F6\\u6709\\u4E24\\u79CD\\u60C5\\u51B5\\uFF0C\\n        // \\u7B2C\\u4E00\\u79CD\\u60C5\\u51B5\\u662F\\u524D\\u9762\\u5DF2\\u7ECF\\u6709\\u66F4\\u5927\\u7684\\u503C\\u4E86\\uFF0C\\u6240\\u4EE5\\u6B64\\u65F6\\u4E5F\\u653E\\u5F03\\n        if (dp[i][j + 1].length > 1) {\\n          dp[i][j] = dp[i][j + 1];\\n        } else {\\n          // \\u5982\\u679C\\u524D\\u9762\\u6CA1\\u7528\\u7684\\u8BDD\\uFF0C\\u6B64\\u65F6\\u4F7F\\u7528\\u8BE5\\u7D22\\u5F15\\n          dp[i][j] = j + \"0\";\\n        }\\n        // \\u8FD8\\u6709\\u53E6\\u5916\\u4E00\\u79CD\\u60C5\\u51B5\\uFF0C\\u5982\\u679C\\u6B64\\u65F6\\u4F7F\\u7528\\u4E86\\u8BE5\\u7D22\\u5F15\\n        // \\u90A3\\u4E48dp[i-cost[j-1]][1] \\u5982\\u679C\\u6B64\\u65F6\\u8BE5\\u503C\\u6709\\u6700\\u5927\\u503C\\u4E86\\uFF0C\\u5E76\\u4E14\\n        // dp[i][j+1]\\u6B64\\u65F6\\u7684\\u957F\\u5EA6\\u5C0F\\u4E8Edp[i-cost[j-1]][1]+1,\\u90A3\\u4E48\\u5C31\\u4F7F\\u7528\\n      } else if (\\n        dp[i - cost[j - 1]][1].length > 1 &&\\n        dp[i - cost[j - 1]][1].length + 1 > dp[i][j + 1].length\\n      ) {\\n        dp[i][j] = j + dp[i - cost[j - 1]][1];\\n      } else {\\n        dp[i][j] = dp[i][j + 1];\\n      }\\n    }\\n  }\\n  if (dp[m][1].length > 1) {\\n    return dp[m][1].substring(0, dp[m][1].length - 1);\\n  }\\n  return dp[m][1];\\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1755700,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string MAX(string &s1,string &s2)\\n    {\\n         if(s1.size()==s2.size())\\n            {\\n                return max(s1,s2);\\n            }\\n            if(s1.size()>s2.size())\\n            {\\n                return s1;\\n            }\\n            return s2;\\n    }\\n    string largestNumber(vector<int>& cost, int target) \\n    {\\n        int n=cost.size();\\n        string dp[target+1];\\n        for(int i=0;i<=target;i++)\\n        {\\n            dp[i]=\"0\";\\n        }\\n        dp[0]=\"\";\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int t=1;t<=target;t++)\\n            {\\n                if(t-cost[i]>=0&&dp[t-cost[i]]!=\"0\")\\n                {\\n                   string s=to_string(i+1)+dp[t-cost[i]];\\n                   dp[t]=MAX(s,dp[t]);\\n                }\\n            }\\n        }\\n        return dp[target];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string MAX(string &s1,string &s2)\\n    {\\n         if(s1.size()==s2.size())\\n            {\\n                return max(s1,s2);\\n            }\\n            if(s1.size()>s2.size())\\n            {\\n                return s1;\\n            }\\n            return s2;\\n    }\\n    string largestNumber(vector<int>& cost, int target) \\n    {\\n        int n=cost.size();\\n        string dp[target+1];\\n        for(int i=0;i<=target;i++)\\n        {\\n            dp[i]=\"0\";\\n        }\\n        dp[0]=\"\";\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int t=1;t<=target;t++)\\n            {\\n                if(t-cost[i]>=0&&dp[t-cost[i]]!=\"0\")\\n                {\\n                   string s=to_string(i+1)+dp[t-cost[i]];\\n                   dp[t]=MAX(s,dp[t]);\\n                }\\n            }\\n        }\\n        return dp[target];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1619971,
                "title": "golang-bottom-up",
                "content": "start from 0 to `target` points, build the result from bottom up, keeping track of the longest string possible using i points, where i is some number from 0 to `target`, to build a candidate string at a current level, just take the value of the index+1 and concat it with cache[curPoints-cost[index]].\\n\\n```\\nfunc largestNumber(cost []int, target int) string {\\n    cache := make([]*string, target+1)  // cache[i] means to largest string built with i points\\n    temp := \"\"\\n    cache[0] = &temp\\n    \\n    for i := range cache {\\n        for j, c := range cost {\\n            k := i - c  // points left\\n            if k > -1 && cache[k] != nil {  // points left is legal and has a valid max combination\\n                temp := string(j + \\'1\\') + *cache[k]\\n                cache[i] = max(cache[i], &temp)\\n            }\\n        }\\n    }\\n    \\n    if cache[target] == nil {\\n        return \"0\"\\n    }\\n    \\n    return *cache[target]\\n}\\n\\nfunc max(a, b *string) *string {\\n    if a == nil {\\n        return b\\n    }\\n    if b == nil {\\n        return a\\n    }\\n    if len(*a) < len(*b) {\\n        return b\\n    } else if len(*a) > len(*b) {\\n        return a\\n    }\\n    \\n    if *a > *b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc largestNumber(cost []int, target int) string {\\n    cache := make([]*string, target+1)  // cache[i] means to largest string built with i points\\n    temp := \"\"\\n    cache[0] = &temp\\n    \\n    for i := range cache {\\n        for j, c := range cost {\\n            k := i - c  // points left\\n            if k > -1 && cache[k] != nil {  // points left is legal and has a valid max combination\\n                temp := string(j + \\'1\\') + *cache[k]\\n                cache[i] = max(cache[i], &temp)\\n            }\\n        }\\n    }\\n    \\n    if cache[target] == nil {\\n        return \"0\"\\n    }\\n    \\n    return *cache[target]\\n}\\n\\nfunc max(a, b *string) *string {\\n    if a == nil {\\n        return b\\n    }\\n    if b == nil {\\n        return a\\n    }\\n    if len(*a) < len(*b) {\\n        return b\\n    } else if len(*a) > len(*b) {\\n        return a\\n    }\\n    \\n    if *a > *b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1439772,
                "title": "scala",
                "content": "```\\nimport scala.util.chaining._\\n\\nobject Solution {\\n  def largestNumber(cost: Array[Int], target: Int): String = {\\n    (1 to 8)\\n      .groupMapReduce(digit => cost(digit - 1))(identity)(math.max)\\n      .values\\n      .foldLeft(Map[Int, Number](0 -> Number())) { case (numbers, digit) =>\\n        (0 to target).flatMap(t => computeLargestNumber(numbers, digit, cost(digit - 1), t).map(t -> _)).toMap\\n      }\\n      .pipe(computeLargestNumber(_, 9, cost(8), target).map(_.toString).getOrElse(\"0\"))\\n  }\\n\\n  private def computeLargestNumber(numbers: Map[Int, Number], digit: Int, cost: Int, target: Int): Option[Number] = {\\n    (0 to target / cost)\\n      .flatMap { count => numbers.get(target - count * cost).map(_ + (digit -> count)) }\\n      .maxOption\\n  }\\n\\n  private final class Number private(counts: Map[Int, Int]) extends Ordered[Number] {\\n    lazy val size: Int = counts.values.sum\\n\\n    def +(count: (Int, Int)): Number = new Number(counts + count)\\n\\n    override def compare(that: Number): Int = Number.Ordering.compare(this, that)\\n\\n    def count(digit: Int): Int = counts.getOrElse(digit, 0)\\n\\n    override def toString: String = (9 to 1 by -1).map(digit => digit.toString * count(digit)).mkString\\n  }\\n\\n  private object Number {\\n    private val Ordering = (1 to 9).foldRight(scala.math.Ordering.by[Number, Int](_.size)) {\\n      (digit, ordering) => ordering.orElseBy(_.count(digit))\\n    }\\n\\n    def apply() = new Number(Map())\\n\\n    def apply(digit: Int, count: Int) = new Number(Map(digit -> count))\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport scala.util.chaining._\\n\\nobject Solution {\\n  def largestNumber(cost: Array[Int], target: Int): String = {\\n    (1 to 8)\\n      .groupMapReduce(digit => cost(digit - 1))(identity)(math.max)\\n      .values\\n      .foldLeft(Map[Int, Number](0 -> Number())) { case (numbers, digit) =>\\n        (0 to target).flatMap(t => computeLargestNumber(numbers, digit, cost(digit - 1), t).map(t -> _)).toMap\\n      }\\n      .pipe(computeLargestNumber(_, 9, cost(8), target).map(_.toString).getOrElse(\"0\"))\\n  }\\n\\n  private def computeLargestNumber(numbers: Map[Int, Number], digit: Int, cost: Int, target: Int): Option[Number] = {\\n    (0 to target / cost)\\n      .flatMap { count => numbers.get(target - count * cost).map(_ + (digit -> count)) }\\n      .maxOption\\n  }\\n\\n  private final class Number private(counts: Map[Int, Int]) extends Ordered[Number] {\\n    lazy val size: Int = counts.values.sum\\n\\n    def +(count: (Int, Int)): Number = new Number(counts + count)\\n\\n    override def compare(that: Number): Int = Number.Ordering.compare(this, that)\\n\\n    def count(digit: Int): Int = counts.getOrElse(digit, 0)\\n\\n    override def toString: String = (9 to 1 by -1).map(digit => digit.toString * count(digit)).mkString\\n  }\\n\\n  private object Number {\\n    private val Ordering = (1 to 9).foldRight(scala.math.Ordering.by[Number, Int](_.size)) {\\n      (digit, ordering) => ordering.orElseBy(_.count(digit))\\n    }\\n\\n    def apply() = new Number(Map())\\n\\n    def apply(digit: Int, count: Int) = new Number(Map(digit -> count))\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1438772,
                "title": "c-intuitive-memo",
                "content": "Try adding every number and substract its cost from target ( denoted by `k` ). For memoization, save the variable `k` in a map\\n```\\nunordered_map<int,string> mp;\\nclass Solution {\\n   public:\\n    string help(vector<int>& cost, int k) {\\n        if (k == 0) return \"\";\\n        if(mp.count(k)) return mp[k];\\n        string cur=\".\";\\n        for (int i = 0; i < 9; i++) {\\n            if (k - cost[i] >= 0) {\\n                string small = to_string(i + 1) + help(cost, k - cost[i]);\\n                if(small.back()==\\'.\\') continue;\\n                if (cur==\".\" || (cur.size()<small.size()) || (cur.size()==small.size() && cur<small)) cur = small;\\n            }\\n        }\\n        mp[k]=cur;\\n        return cur;\\n    }\\n\\n    string largestNumber(vector<int>& cost, int k) {\\n        mp.clear();\\n        string ans = help(cost, k);\\n        if(ans.back()==\\'.\\') return \"0\";\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nunordered_map<int,string> mp;\\nclass Solution {\\n   public:\\n    string help(vector<int>& cost, int k) {\\n        if (k == 0) return \"\";\\n        if(mp.count(k)) return mp[k];\\n        string cur=\".\";\\n        for (int i = 0; i < 9; i++) {\\n            if (k - cost[i] >= 0) {\\n                string small = to_string(i + 1) + help(cost, k - cost[i]);\\n                if(small.back()==\\'.\\') continue;\\n                if (cur==\".\" || (cur.size()<small.size()) || (cur.size()==small.size() && cur<small)) cur = small;\\n            }\\n        }\\n        mp[k]=cur;\\n        return cur;\\n    }\\n\\n    string largestNumber(vector<int>& cost, int k) {\\n        mp.clear();\\n        string ans = help(cost, k);\\n        if(ans.back()==\\'.\\') return \"0\";\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1435850,
                "title": "c-like-coin-change-counting-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& cost, int target) {\\n        vector<pair<int, array<int, 9>>> dp(target + 1);\\n        dp[0].first = 1;\\n        for (int i = 1; i <= target; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                if (i >= cost[j] && dp[i - cost[j]].first) {\\n                    auto p = dp[i - cost[j]];\\n                    p.second[8 - j]++;\\n                    dp[i] = max(dp[i], {p.first + 1, p.second});\\n                }\\n            }\\n        }\\n        string ans;\\n        for (int i = 0; i < 9; i++)\\n            ans += string(dp.back().second[i], \\'9\\' - i);\\n        return ans == \"\" ? \"0\" : ans;\\n    }\\n};\\n```\\n\\nfirst try fail\\n\\n```\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& cost, int target) {\\n        vector<pair<int, string>> dp(target + 1);\\n        dp[0].first = 1;\\n        for (int i = 1; i <= target; i++) {\\n            for (int j = 0; j < cost.size(); j++) {\\n                if (i >= cost[j] && dp[i - cost[j]].first) {\\n                    auto t = dp[i - cost[j]].second + to_string(j + 1);\\n                    sort(t.rbegin(), t.rend());\\n                    dp[i] = max(dp[i], {t.size(), t});\\n                }\\n            }\\n        }\\n        return dp.back().second == \"\" ? \"0\" : dp.back().second;\\n    }\\n};\\n``\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& cost, int target) {\\n        vector<pair<int, array<int, 9>>> dp(target + 1);\\n        dp[0].first = 1;\\n        for (int i = 1; i <= target; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                if (i >= cost[j] && dp[i - cost[j]].first) {\\n                    auto p = dp[i - cost[j]];\\n                    p.second[8 - j]++;\\n                    dp[i] = max(dp[i], {p.first + 1, p.second});\\n                }\\n            }\\n        }\\n        string ans;\\n        for (int i = 0; i < 9; i++)\\n            ans += string(dp.back().second[i], \\'9\\' - i);\\n        return ans == \"\" ? \"0\" : ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& cost, int target) {\\n        vector<pair<int, string>> dp(target + 1);\\n        dp[0].first = 1;\\n        for (int i = 1; i <= target; i++) {\\n            for (int j = 0; j < cost.size(); j++) {\\n                if (i >= cost[j] && dp[i - cost[j]].first) {\\n                    auto t = dp[i - cost[j]].second + to_string(j + 1);\\n                    sort(t.rbegin(), t.rend());\\n                    dp[i] = max(dp[i], {t.size(), t});\\n                }\\n            }\\n        }\\n        return dp.back().second == \"\" ? \"0\" : dp.back().second;\\n    }\\n};\\n``\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1432754,
                "title": "c-top-down-dp-easiest-thought-process-o-target-time",
                "content": "There is only one state for the DP. The rest is self explainatory.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<int> cost; \\n    vector<string> dp;\\n    \\n    string compare(string s1, string s2){\\n        if(s1.size() < s2.size()) return s2;\\n        if(s1.size() > s2.size()) return s1; \\n        \\n        for(int i=0 ; i<s1.size(); i++) {\\n            if(s1[i] < s2[i]) return s2;\\n        }\\n        return s1; \\n    }\\n    \\n    string memo(int target){\\n        if(target < 0) return \"NA\"; \\n        if(target == 0) return \"\";\\n        if(dp[target] != \"\") return dp[target]; \\n\\n        string curr = \"NA\"; \\n    \\n        for(int i=0; i<9; i++){\\n            char toAdd = \\'0\\' + i+1;\\n            string temp = memo(target-cost[i]); \\n            if (temp != \"NA\"){\\n                if(curr == \"NA\" ) curr = temp + toAdd; \\n                else  curr = compare(curr, toAdd+ temp );\\n            }\\n        }\\n        return dp[target] = curr; \\n    }\\n    \\n    string largestNumber(vector<int>& cost, int target) {\\n        this->cost = cost ;\\n        res = \"\"; \\n        dp.resize(target+1, \"\"); \\n        string res = memo(target); \\n        return res == \"NA\"? \"0\": res ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> cost; \\n    vector<string> dp;\\n    \\n    string compare(string s1, string s2){\\n        if(s1.size() < s2.size()) return s2;\\n        if(s1.size() > s2.size()) return s1; \\n        \\n        for(int i=0 ; i<s1.size(); i++) {\\n            if(s1[i] < s2[i]) return s2;\\n        }\\n        return s1; \\n    }\\n    \\n    string memo(int target){\\n        if(target < 0) return \"NA\"; \\n        if(target == 0) return \"\";\\n        if(dp[target] != \"\") return dp[target]; \\n\\n        string curr = \"NA\"; \\n    \\n        for(int i=0; i<9; i++){\\n            char toAdd = \\'0\\' + i+1;\\n            string temp = memo(target-cost[i]); \\n            if (temp != \"NA\"){\\n                if(curr == \"NA\" ) curr = temp + toAdd; \\n                else  curr = compare(curr, toAdd+ temp );\\n            }\\n        }\\n        return dp[target] = curr; \\n    }\\n    \\n    string largestNumber(vector<int>& cost, int target) {\\n        this->cost = cost ;\\n        res = \"\"; \\n        dp.resize(target+1, \"\"); \\n        string res = memo(target); \\n        return res == \"NA\"? \"0\": res ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1414777,
                "title": "c-unbounded-knapsack-concept-bottom-up-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    string maxString(string a, string b){\\n        int n = a.length();\\n        int m = b.length();\\n        if(n>m)\\n            return a;\\n        else if(m>n)\\n            return b;\\n        else{\\n            if(a>b)\\n                return a;\\n            else\\n                return b;\\n        }\\n        return \"\";\\n    }\\n    string largestNumber(vector<int>& cost, int target) {\\n        int n = 9;\\n        int m = target;\\n        vector<vector<string>>dp(n+1,vector<string>(m+1,\"0\"));\\n        \\n        for(int i=0; i<n+1; i++)\\n            dp[i][0] = \"\";\\n        \\n        for(int i=1; i<n+1; i++){\\n            for(int j=1; j<m+1; j++){\\n                if(cost[i-1] <= j){\\n                    string temp;\\n                    if(dp[i][j-cost[i-1]]!=\"0\"){\\n                        temp = to_string(i)+dp[i][j-cost[i-1]];\\n                        dp[i][j] = maxString(dp[i-1][j], temp);\\n                    }\\n                    else\\n                        dp[i][j] = dp[i-1][j];\\n                }\\n                else{\\n                    dp[i][j] = dp[i-1][j];\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n        \\n    }\\n};\\n```\\n**Do upvote if you find it helpful!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string maxString(string a, string b){\\n        int n = a.length();\\n        int m = b.length();\\n        if(n>m)\\n            return a;\\n        else if(m>n)\\n            return b;\\n        else{\\n            if(a>b)\\n                return a;\\n            else\\n                return b;\\n        }\\n        return \"\";\\n    }\\n    string largestNumber(vector<int>& cost, int target) {\\n        int n = 9;\\n        int m = target;\\n        vector<vector<string>>dp(n+1,vector<string>(m+1,\"0\"));\\n        \\n        for(int i=0; i<n+1; i++)\\n            dp[i][0] = \"\";\\n        \\n        for(int i=1; i<n+1; i++){\\n            for(int j=1; j<m+1; j++){\\n                if(cost[i-1] <= j){\\n                    string temp;\\n                    if(dp[i][j-cost[i-1]]!=\"0\"){\\n                        temp = to_string(i)+dp[i][j-cost[i-1]];\\n                        dp[i][j] = maxString(dp[i-1][j], temp);\\n                    }\\n                    else\\n                        dp[i][j] = dp[i-1][j];\\n                }\\n                else{\\n                    dp[i][j] = dp[i-1][j];\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1383454,
                "title": "java-help-how-to-memoize-my-solution",
                "content": "```\\nclass Solution {\\n    \\n    public String largestNumber(int[] cost, int target) {\\n        String res=helper(cost,target).toString();\\n        long ans=Long.parseLong(res);\\n        if(ans<0)return \"0\";\\n        return String.valueOf(ans);\\n    }\\n    private StringBuilder helper(int[]cost,int target){\\n        if(target==0)return new StringBuilder(\"0\");\\n        if(target<0)return new StringBuilder(\"-1\");\\n        StringBuilder str=new StringBuilder();\\n        str.append(\"-1\");\\n        for(int i=cost.length-1;i>=0;i--){\\n            StringBuilder num=helper(cost,target-cost[i]).append(String.valueOf(i+1));\\n            if(Long.parseLong(str.toString())<Long.parseLong(num.toString())){\\n                str=num;\\n            }\\n        }\\n        return str;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public String largestNumber(int[] cost, int target) {\\n        String res=helper(cost,target).toString();\\n        long ans=Long.parseLong(res);\\n        if(ans<0)return \"0\";\\n        return String.valueOf(ans);\\n    }\\n    private StringBuilder helper(int[]cost,int target){\\n        if(target==0)return new StringBuilder(\"0\");\\n        if(target<0)return new StringBuilder(\"-1\");\\n        StringBuilder str=new StringBuilder();\\n        str.append(\"-1\");\\n        for(int i=cost.length-1;i>=0;i--){\\n            StringBuilder num=helper(cost,target-cost[i]).append(String.valueOf(i+1));\\n            if(Long.parseLong(str.toString())<Long.parseLong(num.toString())){\\n                str=num;\\n            }\\n        }\\n        return str;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1373248,
                "title": "c-solution-o-target",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& cost, int target) {\\n        int dp[target+1];\\n        memset(dp,-1,sizeof(dp));\\n        dp[0] = 0;\\n        \\n        for(int i = 0; i < 9; i++){\\n            for(int j = cost[i]; j <= target; j++){\\n                    if(dp[j-cost[i]] != -1)\\n                    dp[j] = max(dp[j], dp[j-cost[i]]+1);\\n            }\\n        }\\n        if (dp[target] < 0) return \"0\";\\n        string res = \"\";\\n        for (int i = 8; i >= 0; --i) {\\n            while (target >= cost[i] && dp[target] == dp[target - cost[i]] + 1) {\\n                res.push_back(\\'1\\' + i);\\n                target -= cost[i];\\n            }\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string largestNumber(vector<int>& cost, int target) {\\n        int dp[target+1];\\n        memset(dp,-1,sizeof(dp));\\n        dp[0] = 0;\\n        \\n        for(int i = 0; i < 9; i++){\\n            for(int j = cost[i]; j <= target; j++){\\n                    if(dp[j-cost[i]] != -1)\\n                    dp[j] = max(dp[j], dp[j-cost[i]]+1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1240953,
                "title": "100-faster-dp-retrieve-type-solution",
                "content": "Thank @lee215 to this solution \\n**steps:**\\n1. first we will make dp\\n2. then retrieve complete string from this dp\\n3. personally for me this type of problems are considerd in dp-retrieve type problem \\n**java code is:**\\n# \\n```\\nclass Solution {\\n    public String largestNumber(int[] cost, int target) {\\n        int dp[]=new int[target+1];\\n        //make-dp\\n        for(int i=1;i<=target;i++){\\n          dp[i]=-1000_000;\\n            for(int j=0;j<9;j++)\\n                if(cost[j]<=i)\\n                    dp[i]=Math.max(dp[i],1+dp[i-cost[j]]);\\n        }\\n        if(dp[target]<0)return \"0\";\\n        StringBuilder res=new StringBuilder();\\n        //retrieve string from dp\\n        for(int i=8;i>=0;i--){\\n            while(target>=cost[i]&&dp[target]==dp[target-cost[i]]+1){\\n                res.append(i+1);\\n                target-=cost[i];\\n            }\\n        }\\n        return res.toString();\\n    }\\n}\\n```\\n**Please,Upvote if this is helpful**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public String largestNumber(int[] cost, int target) {\\n        int dp[]=new int[target+1];\\n        //make-dp\\n        for(int i=1;i<=target;i++){\\n          dp[i]=-1000_000;\\n            for(int j=0;j<9;j++)\\n                if(cost[j]<=i)\\n                    dp[i]=Math.max(dp[i],1+dp[i-cost[j]]);\\n        }\\n        if(dp[target]<0)return \"0\";\\n        StringBuilder res=new StringBuilder();\\n        //retrieve string from dp\\n        for(int i=8;i>=0;i--){\\n            while(target>=cost[i]&&dp[target]==dp[target-cost[i]]+1){\\n                res.append(i+1);\\n                target-=cost[i];\\n            }\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1145484,
                "title": "python-3-memoization",
                "content": "The variable `table` does an additional optimization, where if 2 digits have the same cost, always keep the latter one greedily. I tried the 2 dimensional DP first, i.e., `def dp(cur, target)` to keep track of current sum and the target, the algorithm is correct but it ends up TLE so I modified DP to keep only 1 dimensional index and now it works fine.\\n\\n```python\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        memo = defaultdict(lambda:float(\\'-inf\\'))\\n        table = {}\\n        for i, c in enumerate(cost):\\n            table[c] = i\\n\\n        def dp(target):\\n            if target < 0:\\n                return float(\\'-inf\\')\\n            if target == 0:\\n                return 0\\n            if target not in memo:\\n                for c in table:\\n                    d = table[c] + 1\\n                    memo[target] = max(memo[target],\\n                                    10*dp(target-c) + d)\\n            return memo[target]\\n        \\n        return str(max(0, dp(target)))\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        memo = defaultdict(lambda:float(\\'-inf\\'))\\n        table = {}\\n        for i, c in enumerate(cost):\\n            table[c] = i\\n\\n        def dp(target):\\n            if target < 0:\\n                return float(\\'-inf\\')\\n            if target == 0:\\n                return 0\\n            if target not in memo:\\n                for c in table:\\n                    d = table[c] + 1\\n                    memo[target] = max(memo[target],\\n                                    10*dp(target-c) + d)\\n            return memo[target]\\n        \\n        return str(max(0, dp(target)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1100520,
                "title": "python3-top-down-faster-than-96-15",
                "content": "```\\n\\tdef largestNumber(self, cost: List[int], target: int) -> str:\\n\\t\\td={}\\n        for i,c in enumerate(cost):\\n            d[c]=i+1\\n        @functools.lru_cache(None)\\n        def dfs(target):\\n            if target==0: return 0\\n            if target<min(cost):return -float(\\'inf\\')\\n            res=-float(\\'inf\\')\\n            for c in d:\\n                if target>=c:\\n                    res=max(res,d[c]+10*dfs(target-c))\\n            return res\\n        return str(max(dfs(target),0))",
                "solutionTags": [],
                "code": "```\\n\\tdef largestNumber(self, cost: List[int], target: int) -> str:\\n\\t\\td={}\\n        for i,c in enumerate(cost):\\n            d[c]=i+1\\n        @functools.lru_cache(None)\\n        def dfs(target):\\n            if target==0: return 0\\n            if target<min(cost):return -float(\\'inf\\')\\n            res=-float(\\'inf\\')\\n            for c in d:\\n                if target>=c:\\n                    res=max(res,d[c]+10*dfs(target-c))\\n            return res\\n        return str(max(dfs(target),0))",
                "codeTag": "Python3"
            },
            {
                "id": 1056023,
                "title": "bottom-up-dp",
                "content": "failed to solve by top -down but bottom up is pretty simple\\n```\\npublic String largestNumber(int[] cost, int target) {\\n        String[] dp = new String[target +1];\\n        Arrays.fill(dp,\"\");\\n        for (int i = 0; i< 9; i++){\\n            if (cost[i] <= target) dp[cost[i]] = larger(dp[cost[i]],String.valueOf(i+1));\\n        }\\n        for (int i = 1; i <= target; i++){\\n            for (int j = 0; j < 9; j++){\\n                if (i - cost[j] >= 0 && !dp[i-cost[j]].equals(\"\")){\\n                    dp[i] = larger(dp[i],String.valueOf(j+1)+dp[i-cost[j]]);\\n                }\\n            }\\n        }\\n        return dp[target].equals(\"\")?\"0\":dp[target];\\n    }\\n    String larger(String s1, String s2){\\n        int a = s1.length(), b = s2.length();\\n        if (a > b){\\n            return s1;\\n        }else if (a < b){\\n            return s2;\\n        }\\n        for (int i = 0; i < a; i++){\\n            if (s1.charAt(i) > s2.charAt(i)){\\n                return s1;\\n            }else if (s1.charAt(i) < s2.charAt(i)){\\n                return s2;\\n            }\\n        }\\n        return s1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic String largestNumber(int[] cost, int target) {\\n        String[] dp = new String[target +1];\\n        Arrays.fill(dp,\"\");\\n        for (int i = 0; i< 9; i++){\\n            if (cost[i] <= target) dp[cost[i]] = larger(dp[cost[i]],String.valueOf(i+1));\\n        }\\n        for (int i = 1; i <= target; i++){\\n            for (int j = 0; j < 9; j++){\\n                if (i - cost[j] >= 0 && !dp[i-cost[j]].equals(\"\")){\\n                    dp[i] = larger(dp[i],String.valueOf(j+1)+dp[i-cost[j]]);\\n                }\\n            }\\n        }\\n        return dp[target].equals(\"\")?\"0\":dp[target];\\n    }\\n    String larger(String s1, String s2){\\n        int a = s1.length(), b = s2.length();\\n        if (a > b){\\n            return s1;\\n        }else if (a < b){\\n            return s2;\\n        }\\n        for (int i = 0; i < a; i++){\\n            if (s1.charAt(i) > s2.charAt(i)){\\n                return s1;\\n            }else if (s1.charAt(i) < s2.charAt(i)){\\n                return s2;\\n            }\\n        }\\n        return s1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1054570,
                "title": "dynamic-programming",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[(int)10][(int)5005] ;\\n    string ans = \"\" ;\\n    string largestNumber(vector<int>& cost, int target) {\\n        memset(dp , -1 , sizeof(dp)) ;\\n        reverse(cost.begin() , cost.end());\\n        int longest = solve( 0 , target , cost  ) ;\\n        if(longest < 0  ) return \"0\" ;\\n        print( 0 , target , longest , cost )   ;\\n        return ans  ;\\n    }\\n    void print(int index , int target , int longest  , vector<int>& cost ){\\n        if(index == cost.size()) return ;\\n        int till_now = target ;\\n        int u = 0  ;\\n        string sv = \"\" ;\\n        char T = 57 - index ; \\n        bool flag = 0 ;\\n        int temp_til = 0 ;\\n        int temp_u = 0   ;\\n        string t_sv = \"\" ;\\n        while( till_now - cost[index] >= 0 && u <= longest ){\\n            till_now -= cost[index] ;\\n            ++u ;\\n            int temp = u + solve( index  + 1 , till_now  , cost ) ;\\n            sv += T ;\\n            if( temp == longest ){\\n                flag = 1 ;\\n                temp_til = till_now ;\\n                temp_u = u ; \\n                t_sv =sv   ; \\n            }\\n        }\\n        if(flag){\\n            ans += t_sv ;\\n            print(index + 1 , temp_til , longest - temp_u , cost ) ;\\n        }\\n        else\\n        { \\n            print(index + 1 , target , longest , cost ) ;   \\n        }\\n    }\\n    int solve(int index , int target , vector<int>& cost ){\\n       if( target == 0 ){\\n           return 0     ;\\n       }\\n        if( index == cost.size() ) return -INT_MAX ;\\n        int &ans = dp[index][target] ;\\n        if(~ans) return ans ;\\n        ans = 0 ;\\n        ans = solve( index + 1 , target , cost ) ;\\n       int till_now = target ;\\n        int U = 1 ; \\n        while( till_now - cost[index] >= 0 ){\\n            till_now -= cost[index] ;\\n            int temp =  U + solve( index + 1 , till_now , cost ) ;\\n            ++U ;\\n            ans = max(ans , temp ) ;\\n        }\\n        return ans ;\\n    }\\n};\\n```\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[(int)10][(int)5005] ;\\n    string ans = \"\" ;\\n    string largestNumber(vector<int>& cost, int target) {\\n        memset(dp , -1 , sizeof(dp)) ;\\n        reverse(cost.begin() , cost.end());\\n        int longest = solve( 0 , target , cost  ) ;\\n        if(longest < 0  ) return \"0\" ;\\n        print( 0 , target , longest , cost )   ;\\n        return ans  ;\\n    }\\n    void print(int index , int target , int longest  , vector<int>& cost ){\\n        if(index == cost.size()) return ;\\n        int till_now = target ;\\n        int u = 0  ;\\n        string sv = \"\" ;\\n        char T = 57 - index ; \\n        bool flag = 0 ;\\n        int temp_til = 0 ;\\n        int temp_u = 0   ;\\n        string t_sv = \"\" ;\\n        while( till_now - cost[index] >= 0 && u <= longest ){\\n            till_now -= cost[index] ;\\n            ++u ;\\n            int temp = u + solve( index  + 1 , till_now  , cost ) ;\\n            sv += T ;\\n            if( temp == longest ){\\n                flag = 1 ;\\n                temp_til = till_now ;\\n                temp_u = u ; \\n                t_sv =sv   ; \\n            }\\n        }\\n        if(flag){\\n            ans += t_sv ;\\n            print(index + 1 , temp_til , longest - temp_u , cost ) ;\\n        }\\n        else\\n        { \\n            print(index + 1 , target , longest , cost ) ;   \\n        }\\n    }\\n    int solve(int index , int target , vector<int>& cost ){\\n       if( target == 0 ){\\n           return 0     ;\\n       }\\n        if( index == cost.size() ) return -INT_MAX ;\\n        int &ans = dp[index][target] ;\\n        if(~ans) return ans ;\\n        ans = 0 ;\\n        ans = solve( index + 1 , target , cost ) ;\\n       int till_now = target ;\\n        int U = 1 ; \\n        while( till_now - cost[index] >= 0 ){\\n            till_now -= cost[index] ;\\n            int temp =  U + solve( index + 1 , till_now , cost ) ;\\n            ++U ;\\n            ans = max(ans , temp ) ;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1047096,
                "title": "python-top-down-dp",
                "content": "**Approach:**\\nUse top down dynamic programming with pointer **i** denoting the current\\nindex in nums and **target** denoting the remaining money we have to spend.\\n\\nThe exit conditions are:\\n1. If **i == len(nums)** or **target < 0** we have run out of numbers or spent too much money\\n2. **target == 0** we spent exactly the right amount of money\\n\\nIf neither exit condition is met, consider 2 options:\\n1. Do not paint the current number, move on to the next number\\n2. Paint the current number for a cost of cost[nums[i]], and consider painting the same number again.\\n\\nReturn the maximum of these two options.\\n\\n<details>\\n\\n<summary>Side note about <b>\"*-inf\"</b>: (click to show)</summary>\\n\\nWhen we find a state that **cannot** result in a solution, our return statement needs to \\nreturn something that **will not** be selected by the max function.\\n\\nHere the max function acts accordingly: for each option, split the string on \\'\\\\*\\' and then compare the last substring in the list.\\nFor instance: ```max(\"43\", \"444*-inf\", key = lambda s: float(s.split(\\'*\\')[-1]))``` will compare 43.0 to -inf and choose\\nthe first option because it is larger.\\n\\n</details>\\n\\n**Optimization:**\\nIf two numbers have the same cost, never use the smaller number.\\nThe first line of code automatically writes over smaller numbers that have the same cost as larger numbers.\\n\\n<br>\\n\\n```python\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        \\n        cost = {c: str(num) for num, c in enumerate(cost, 1)}\\n        cost = {cost[key]: key for key in cost}\\n        nums = sorted(cost, key = lambda n: -int(n))\\n        \\n        @functools.lru_cache(None)\\n        def helper(i, target):\\n            if i == len(nums) or target < 0:\\n                return \"*-inf\"\\n            if target == 0:\\n                return \\'\\'\\n            return max(helper(i+1, target), nums[i] + helper(i, target - cost[nums[i]]), key = lambda s: float(s.split(\\'*\\')[-1]))\\n        \\n        return max(\"0\", helper(0, target))\\n```",
                "solutionTags": [],
                "code": "```max(\"43\", \"444*-inf\", key = lambda s: float(s.split(\\'*\\')[-1]))```\n```python\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        \\n        cost = {c: str(num) for num, c in enumerate(cost, 1)}\\n        cost = {cost[key]: key for key in cost}\\n        nums = sorted(cost, key = lambda n: -int(n))\\n        \\n        @functools.lru_cache(None)\\n        def helper(i, target):\\n            if i == len(nums) or target < 0:\\n                return \"*-inf\"\\n            if target == 0:\\n                return \\'\\'\\n            return max(helper(i+1, target), nums[i] + helper(i, target - cost[nums[i]]), key = lambda s: float(s.split(\\'*\\')[-1]))\\n        \\n        return max(\"0\", helper(0, target))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1030893,
                "title": "similar-to-coin-change-solution-top-down-with-top-down-tracking",
                "content": "class Solution {\\n    public static int flg;\\n    public static int[] fin;\\n    public String largestNumber(int[] cost, int target) {\\n        int[] ans=new int[9];\\n        Arrays.fill(ans,0);\\n        fin=new int[9];\\n        Arrays.fill(fin,0);\\n        flg=0;\\n        int[][] dp=new int[cost.length+1][target+1];\\n        for(int[] arr:dp)Arrays.fill(arr,-1);\\n        //System.out.print(DFS(cost,8,target,dp));\\n        DFS1(cost,8,target,dp,ans);\\n        \\n        String str=\"\";\\n        for(int i=fin.length-1;i>=0;i--){\\n            for(int j=0;j<fin[i];j++)str+=(char)(49+i);\\n        }\\n        return (str.length()==0)?\"0\":str;\\n    }\\n    public static int DFS(int[] arr,int end,int target,int[][] dp){\\n        if(target==0)return 0;\\n        if(target<0)return -1000000;\\n        if(dp[end][target]!=-1)return dp[end][target];\\n        int max=Integer.MIN_VALUE;\\n        for(int i=end;i>=0;i--){\\n            if(target<arr[i])continue;\\n            max=Math.max(max,DFS(arr,i,target-arr[i],dp)+1);\\n        }\\n        dp[end][target]=max;\\n        return max;\\n    }\\n    public static void DFS1(int[] arr,int end,int target,int[][] dp,int[] ans){\\n        if(flg==1)return;\\n        if(target==0){\\n            if(flg==0){\\n                flg=1;\\n                for(int i=0;i<ans.length;i++){\\n                    fin[i]=ans[i];\\n                }\\n            }\\n            return;\\n        }\\n        int max=Integer.MIN_VALUE;\\n        for(int i=end;i>=0;i--){\\n            if(target<arr[i])continue;\\n            max=Math.max(max,DFS(arr,i,target-arr[i],dp)+1);\\n        }\\n        for(int i=end;i>=0;i--){\\n            if(max==DFS(arr,i,target-arr[i],dp)+1){\\n                ans[i]++;\\n                DFS1(arr,i,target-arr[i],dp,ans);\\n                ans[i]--;\\n            }\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public static int flg;\\n    public static int[] fin;\\n    public String largestNumber(int[] cost, int target) {\\n        int[] ans=new int[9];\\n        Arrays.fill(ans,0);\\n        fin=new int[9];\\n        Arrays.fill(fin,0);\\n        flg=0;\\n        int[][] dp=new int[cost.length+1][target+1];\\n        for(int[] arr:dp)Arrays.fill(arr,-1);\\n        //System.out.print(DFS(cost,8,target,dp));\\n        DFS1(cost,8,target,dp,ans);\\n        \\n        String str=\"\";\\n        for(int i=fin.length-1;i>=0;i--){\\n            for(int j=0;j<fin[i];j++)str+=(char)(49+i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1008404,
                "title": "c-complete-knapsack",
                "content": "```\\n//TC: O(9 * target)\\n//SC: O(target)\\n\\nclass Solution {\\npublic:\\n    \\n    string largestNumber(vector<int>& cost, int target) {\\n        \\n        vector<string> dp(target+1, \"0\");  //initialize with 0 for exactly match the target\\n        dp[0] = \"\";\\n        \\n        for(int i = 0; i < 9; i++)\\n            for(int t = 1; t <= target; t++)\\n                if(t >= cost[i] && dp[t - cost[i]] != \"0\"){\\n                    string tmp = to_string(i + 1) + dp[t - cost[i]];\\n                    if(tmp.size() > dp[t].size()) dp[t] = tmp;\\n                    else if(tmp.size() == dp[t].size()) dp[t] = max(dp[t], tmp);\\n                }\\n        \\n        return dp[target];\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//TC: O(9 * target)\\n//SC: O(target)\\n\\nclass Solution {\\npublic:\\n    \\n    string largestNumber(vector<int>& cost, int target) {\\n        \\n        vector<string> dp(target+1, \"0\");  //initialize with 0 for exactly match the target\\n        dp[0] = \"\";\\n        \\n        for(int i = 0; i < 9; i++)\\n            for(int t = 1; t <= target; t++)\\n                if(t >= cost[i] && dp[t - cost[i]] != \"0\"){\\n                    string tmp = to_string(i + 1) + dp[t - cost[i]];\\n                    if(tmp.size() > dp[t].size()) dp[t] = tmp;\\n                    else if(tmp.size() == dp[t].size()) dp[t] = max(dp[t], tmp);\\n                }\\n        \\n        return dp[target];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1001207,
                "title": "java-solution-dp",
                "content": "Time complexity is O(cost.length(fixed) * n * k)\\nn is the target, k is the length of longest string in DP, the length of the cost is fixed which is equals to 9.\\nI am not sure the findMax is the best solution.\\n```java\\n public String largestNumber(int[] cost, int target) {\\n        String[] dp = new String[target + 1];\\n        dp[0] = \"\";\\n        Map<Integer, Integer> costMap = new HashMap<>(); // store <value, maxIndex>\\n        for (int i = 0; i < cost.length; i++) {\\n            costMap.put(cost[i], Math.max(costMap.getOrDefault(cost[i], i + 1), i + 1));\\n        }\\n        for (int i = 1; i <= target; i++) {\\n            for (int j = 0; j < cost.length; j++) {\\n                if (i >= cost[j] && dp[i - cost[j]] != null) {\\n                    String v = i == cost[j] ? Integer.toString(costMap.get(i)) : Integer.toString(costMap.get(cost[j]));\\n                    String v1 = v + dp[i - cost[j]];\\n                    String v2 = dp[i - cost[j]] + v;\\n                    if (dp[i] == null || dp[i].equals(\"\")) {\\n                        dp[i] = findMax(v1, v2);\\n                    } else {\\n                        dp[i] = findMax(findMax(v1, v2), dp[i]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[target] == null || dp[target].equals(\"\") ? \"0\" : dp[target];\\n    }\\n    \\n    String findMax(String a, String b) {\\n        if (a.length() == b.length()) {\\n            for (int i = 0; i < a.length(); i++) {\\n                if (a.charAt(i) > b.charAt(i)) {\\n                    return a;\\n                } else if (a.charAt(i) < b.charAt(i)) {\\n                    return b;\\n                }\\n            }\\n        }\\n        return a.length() > b.length() ? a : b;\\n    }\\n```",
                "solutionTags": [],
                "code": "```java\\n public String largestNumber(int[] cost, int target) {\\n        String[] dp = new String[target + 1];\\n        dp[0] = \"\";\\n        Map<Integer, Integer> costMap = new HashMap<>(); // store <value, maxIndex>\\n        for (int i = 0; i < cost.length; i++) {\\n            costMap.put(cost[i], Math.max(costMap.getOrDefault(cost[i], i + 1), i + 1));\\n        }\\n        for (int i = 1; i <= target; i++) {\\n            for (int j = 0; j < cost.length; j++) {\\n                if (i >= cost[j] && dp[i - cost[j]] != null) {\\n                    String v = i == cost[j] ? Integer.toString(costMap.get(i)) : Integer.toString(costMap.get(cost[j]));\\n                    String v1 = v + dp[i - cost[j]];\\n                    String v2 = dp[i - cost[j]] + v;\\n                    if (dp[i] == null || dp[i].equals(\"\")) {\\n                        dp[i] = findMax(v1, v2);\\n                    } else {\\n                        dp[i] = findMax(findMax(v1, v2), dp[i]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[target] == null || dp[target].equals(\"\") ? \"0\" : dp[target];\\n    }\\n    \\n    String findMax(String a, String b) {\\n        if (a.length() == b.length()) {\\n            for (int i = 0; i < a.length(); i++) {\\n                if (a.charAt(i) > b.charAt(i)) {\\n                    return a;\\n                } else if (a.charAt(i) < b.charAt(i)) {\\n                    return b;\\n                }\\n            }\\n        }\\n        return a.length() > b.length() ? a : b;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 995727,
                "title": "python-dp-solution-o-10-target",
                "content": "```\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        def compareList(A, B):\\n            if len(A) > len(B):\\n                return True\\n            elif len(B) > len(A):\\n                return False\\n            else:\\n                if \"\".join(A) > \"\".join(B):\\n                    return True\\n                else:\\n                    return False\\n        maxInt = 0\\n        \\n        dp = [[[] for _ in range(target + 1)] for _ in range(10)]\\n        \\n        for j in range(8,0,-1):\\n            for k in range(0, j):\\n                if cost[k] == cost[j]:\\n                    cost[k] = 10000\\n                    \\n        print(\"True cost:\", cost)\\n        \\n        for i in range(1,10):\\n            for w in range(1,target+1):\\n                if w - cost[i-1]<0:\\n                    dp[i][w] = dp[i-1][w][:]\\n                else:\\n                    A = dp[i-1][w][:]\\n                    B = dp[i][w-cost[i-1]][:]\\n                    if not B and w - cost[i-1] != 0:\\n                        dp[i][w] = dp[i-1][w][:]\\n                        continue\\n                    B.append(str(i))\\n                    B.sort()\\n                    B.reverse()\\n                    # print(i,w)\\n                    # print(\"B:\", B)\\n                    if compareList(A, B):\\n                        dp[i][w] = A[:]\\n                    else:\\n                        dp[i][w] = B[:]\\n                     \\n                    if w == target:\\n                        maxInt = max(int(maxInt),int(\"\".join(dp[i][w])))\\n                    \\n        return str(maxInt)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        def compareList(A, B):\\n            if len(A) > len(B):\\n                return True\\n            elif len(B) > len(A):\\n                return False\\n            else:\\n                if \"\".join(A) > \"\".join(B):\\n                    return True\\n                else:\\n                    return False\\n        maxInt = 0\\n        \\n        dp = [[[] for _ in range(target + 1)] for _ in range(10)]\\n        \\n        for j in range(8,0,-1):\\n            for k in range(0, j):\\n                if cost[k] == cost[j]:\\n                    cost[k] = 10000\\n                    \\n        print(\"True cost:\", cost)\\n        \\n        for i in range(1,10):\\n            for w in range(1,target+1):\\n                if w - cost[i-1]<0:\\n                    dp[i][w] = dp[i-1][w][:]\\n                else:\\n                    A = dp[i-1][w][:]\\n                    B = dp[i][w-cost[i-1]][:]\\n                    if not B and w - cost[i-1] != 0:\\n                        dp[i][w] = dp[i-1][w][:]\\n                        continue\\n                    B.append(str(i))\\n                    B.sort()\\n                    B.reverse()\\n                    # print(i,w)\\n                    # print(\"B:\", B)\\n                    if compareList(A, B):\\n                        dp[i][w] = A[:]\\n                    else:\\n                        dp[i][w] = B[:]\\n                     \\n                    if w == target:\\n                        maxInt = max(int(maxInt),int(\"\".join(dp[i][w])))\\n                    \\n        return str(maxInt)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 956164,
                "title": "simple-knapsack-backtracking-to-get-the-string",
                "content": "```\\nclass Solution {\\npublic:\\n    const int sz = 10;\\n    string largestNumber(vector<int>& cost, int target) {\\n        vector<vector<pair<int, int>>> dp(sz, vector<pair<int, int>>(target + 1, {0, 0}));\\n        for(int i = 1; i < sz; ++i){\\n            for(int j = 1; j <= target; ++j){\\n                dp[i][j] = dp[i - 1][j];\\n                if(j - cost[i - 1] >= 0 && (j - cost[i - 1] == 0 || dp[i][j - cost[i - 1]].first) && dp[i][j - cost[i - 1]].first + 1 >= dp[i][j].first){\\n                       dp[i][j] = {dp[i][j - cost[i - 1]].first + 1, i};\\n                }\\n            }\\n        }\\n        string ans(\"\\\\0\");\\n        int i = 9, j = target;\\n        while(i > 0 && j > 0 ){\\n            if(dp[i][j].second == i)ans += (i + \\'0\\'), j -= cost[i - 1];\\n            else --i;\\n        }\\n        sort(ans.rbegin(), ans.rend());\\n        return ans == \"\\\\0\" ? \"0\" : ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    const int sz = 10;\\n    string largestNumber(vector<int>& cost, int target) {\\n        vector<vector<pair<int, int>>> dp(sz, vector<pair<int, int>>(target + 1, {0, 0}));\\n        for(int i = 1; i < sz; ++i){\\n            for(int j = 1; j <= target; ++j){\\n                dp[i][j] = dp[i - 1][j];\\n                if(j - cost[i - 1] >= 0 && (j - cost[i - 1] == 0 || dp[i][j - cost[i - 1]].first) && dp[i][j - cost[i - 1]].first + 1 >= dp[i][j].first){\\n                       dp[i][j] = {dp[i][j - cost[i - 1]].first + 1, i};\\n                }\\n            }\\n        }\\n        string ans(\"\\\\0\");\\n        int i = 9, j = target;\\n        while(i > 0 && j > 0 ){\\n            if(dp[i][j].second == i)ans += (i + \\'0\\'), j -= cost[i - 1];\\n            else --i;\\n        }\\n        sort(ans.rbegin(), ans.rend());\\n        return ans == \"\\\\0\" ? \"0\" : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 927865,
                "title": "c-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    array<int,9> f(array<int,9>&a, array<int,9>&b) {\\n        int x = (accumulate(a.begin(),a.end(),0));\\n        int y = (accumulate(b.begin(),b.end(),0));\\n        if(x < y) {\\n            return b;\\n        } else if(x > y) {\\n            return a; \\n        }\\n        for(int i = 8;i>=0;i--) {\\n            if(a[i] > b[i]) {\\n                return a;\\n            } else if(b[i] > a[i]) {\\n                return b;\\n            }\\n        }\\n        return a; \\n    }\\n    string g(array<int,9>& a) {\\n        string ret; \\n        for(int i = 8;i>=0;i--) {\\n            ret += string(a[i],\\'1\\'+i);\\n        }\\n        if(ret.empty()) {\\n            return \"0\";\\n        }\\n        return ret;\\n    }\\n    string largestNumber(vector<int>& cost, int target) {\\n        vector<vector<array<int,9>>> dp(cost.size(),vector<array<int,9>>(target+1));\\n        for(int i = 1;i*cost[0]<=target;i++) {\\n            dp[0][i*cost[0]][0] = i; \\n        }\\n        for(int i = 1;i<dp.size();i++) {\\n            for(int j=0;j<dp[i].size();j++) {\\n                if(j>=cost[i]) {\\n                    auto& x = dp[i][j-cost[i]];\\n                    int a = accumulate(x.begin(),x.end(),0);\\n                    if(j==cost[i] || a != 0) {\\n                        dp[i][j] = x; \\n                        dp[i][j][i]++;\\n                    }\\n                }\\n                dp[i][j] = f(dp[i][j],dp[i-1][j]);\\n            }\\n        }\\n        string ret = g(dp.back().back());\\n        return ret; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    array<int,9> f(array<int,9>&a, array<int,9>&b) {\\n        int x = (accumulate(a.begin(),a.end(),0));\\n        int y = (accumulate(b.begin(),b.end(),0));\\n        if(x < y) {\\n            return b;\\n        } else if(x > y) {\\n            return a; \\n        }\\n        for(int i = 8;i>=0;i--) {\\n            if(a[i] > b[i]) {\\n                return a;\\n            } else if(b[i] > a[i]) {\\n                return b;\\n            }\\n        }\\n        return a; \\n    }\\n    string g(array<int,9>& a) {\\n        string ret; \\n        for(int i = 8;i>=0;i--) {\\n            ret += string(a[i],\\'1\\'+i);\\n        }\\n        if(ret.empty()) {\\n            return \"0\";\\n        }\\n        return ret;\\n    }\\n    string largestNumber(vector<int>& cost, int target) {\\n        vector<vector<array<int,9>>> dp(cost.size(),vector<array<int,9>>(target+1));\\n        for(int i = 1;i*cost[0]<=target;i++) {\\n            dp[0][i*cost[0]][0] = i; \\n        }\\n        for(int i = 1;i<dp.size();i++) {\\n            for(int j=0;j<dp[i].size();j++) {\\n                if(j>=cost[i]) {\\n                    auto& x = dp[i][j-cost[i]];\\n                    int a = accumulate(x.begin(),x.end(),0);\\n                    if(j==cost[i] || a != 0) {\\n                        dp[i][j] = x; \\n                        dp[i][j][i]++;\\n                    }\\n                }\\n                dp[i][j] = f(dp[i][j],dp[i-1][j]);\\n            }\\n        }\\n        string ret = g(dp.back().back());\\n        return ret; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 899900,
                "title": "javascript-dp-tabulation-o-n-never-uses-numbers-directly-with-comments",
                "content": "```\\n/**\\n * @param {number[]} cost\\n * @param {number} target\\n * @return {string}\\n */\\nvar largestNumber = function(cost, target) {\\n    // DP[i][j] biggest number achievable, considering from digit \"9\" to digit j in i target\\n    // DP[i][1] max number formed with exactly i target\\n    var dp = new Array(target + 1).fill(0).map(el => new Array(cost.length + 2).fill(\"0\"));\\n    \\n    //increasing cost to build maximum number from bottom up\\n    for (var i = 1; i <= target; i++) {\\n        //highest digit to lowest digit so greater numbers with same size are found first\\n        for (var j = cost.length; j > 0; j--) {\\n            //if current digit is more expensive than what we can spend\\n            if(cost[j - 1] > i) {\\n                //inherit maximum value from previous digit with the same total cost\\n                dp[i][j] = dp[i][j + 1];\\n            }\\n            //if current digit costs exactly what we can spend\\n            else if(cost[j - 1] == i) {\\n                //if previous (greater) digits could already be used, use them instead\\n                if (dp[i][j + 1].length >= 2) {\\n                    dp[i][j] = dp[i][j + 1];\\n                }\\n                else {\\n                    //otherwise use this digit as the first used one (as it fully costs our current target)\\n                    dp[i][j] = j + \"0\";\\n                }\\n            }\\n            //if previous (greater) digits could be used to fully cost our current target, compare number sizes (between picking this one vs the biggest one already found) and pick the max\\n            else if (dp[i - cost[j - 1]][1].length != 1 && dp[i][j+1].length < dp[i - cost[j - 1]][1].length + 1){\\n                dp[i][j] = j + dp[i - cost[j - 1]][1];\\n            }\\n            else {\\n                dp[i][j] = dp[i][j + 1];\\n            }\\n        }\\n    }\\n    \\n    //since the problem stated the number could be too large, we never worked with the actual numbers so here we remove the starting value (represented by string \"0\") if a valid response was found\\n    if (dp[target][1].length > 1) {\\n        return dp[target][1].substring(0, dp[target][1].length - 1);\\n    }\\n    \\n    return dp[target][1];\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} cost\\n * @param {number} target\\n * @return {string}\\n */\\nvar largestNumber = function(cost, target) {\\n    // DP[i][j] biggest number achievable, considering from digit \"9\" to digit j in i target\\n    // DP[i][1] max number formed with exactly i target\\n    var dp = new Array(target + 1).fill(0).map(el => new Array(cost.length + 2).fill(\"0\"));\\n    \\n    //increasing cost to build maximum number from bottom up\\n    for (var i = 1; i <= target; i++) {\\n        //highest digit to lowest digit so greater numbers with same size are found first\\n        for (var j = cost.length; j > 0; j--) {\\n            //if current digit is more expensive than what we can spend\\n            if(cost[j - 1] > i) {\\n                //inherit maximum value from previous digit with the same total cost\\n                dp[i][j] = dp[i][j + 1];\\n            }\\n            //if current digit costs exactly what we can spend\\n            else if(cost[j - 1] == i) {\\n                //if previous (greater) digits could already be used, use them instead\\n                if (dp[i][j + 1].length >= 2) {\\n                    dp[i][j] = dp[i][j + 1];\\n                }\\n                else {\\n                    //otherwise use this digit as the first used one (as it fully costs our current target)\\n                    dp[i][j] = j + \"0\";\\n                }\\n            }\\n            //if previous (greater) digits could be used to fully cost our current target, compare number sizes (between picking this one vs the biggest one already found) and pick the max\\n            else if (dp[i - cost[j - 1]][1].length != 1 && dp[i][j+1].length < dp[i - cost[j - 1]][1].length + 1){\\n                dp[i][j] = j + dp[i - cost[j - 1]][1];\\n            }\\n            else {\\n                dp[i][j] = dp[i][j + 1];\\n            }\\n        }\\n    }\\n    \\n    //since the problem stated the number could be too large, we never worked with the actual numbers so here we remove the starting value (represented by string \"0\") if a valid response was found\\n    if (dp[target][1].length > 1) {\\n        return dp[target][1].substring(0, dp[target][1].length - 1);\\n    }\\n    \\n    return dp[target][1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 879281,
                "title": "python-memoization-o-n",
                "content": "```\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        mini = min(cost)\\n        @functools.lru_cache(None)\\n        def dp(n):\\n            if target == n: return 0\\n            if target<n or target-n<mini: return float(\"-inf\")\\n            return max([dp(n+cost[i])*10 + i+1 for i in range(len(cost))])\\n        return str(max(dp(0),0))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        mini = min(cost)\\n        @functools.lru_cache(None)\\n        def dp(n):\\n            if target == n: return 0\\n            if target<n or target-n<mini: return float(\"-inf\")\\n            return max([dp(n+cost[i])*10 + i+1 for i in range(len(cost))])\\n        return str(max(dp(0),0))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 875720,
                "title": "easy-c-dp-knapsack-style-o-target",
                "content": "```\\n// Return a string maximum of two strings representing integer\\nstring maxl(string a, string b)\\n{\\n    if(a.length()>b.length())\\n        return a;\\n    else if(a.length()<b.length())\\n        return b;\\n    else\\n    {\\n        int i=0;\\n        while(i<a.length() && a[i]==b[i])\\n            i++;\\n        if(i==a.length())\\n            return a;\\n        if(a[i]>b[i])\\n            return a;\\n        return b;\\n    }\\n}  \\nclass Solution {\\npublic:\\n    \\n    string largestNumber(vector<int>& a, int t) {\\n        vector<vector<string>> dp(t+1,vector<string>(9,\"0\"));\\n        // dp[i][j] stores a string represeting largest integer with digits [1,2,..,j+1] that add up to \"i\"\\n        for(int i=1;i<=t;i++)\\n        {\\n            for(int j=0;j<9;j++)\\n            {\\n                if(i-a[j]==0)  // if i==a[j], we can form an integer= j+1\\n                    dp[i][j]=to_string(j+1);\\n                // keep max of either by not using the digit (j+1) or by using it\\n                if(j>0) \\n                    dp[i][j]=maxl(dp[i][j-1], dp[i][j]); // case: not using (j+1) digit\\n                \\n                if(i-a[j]>=0 && dp[i-a[j]][8]!=\"0\") //case: by using it after checking if it is possible to make an integer by i-a[j] as target\\n                    dp[i][j]=maxl(dp[i][j], dp[i-a[j]][8]+to_string(j+1)); // dp[i-a[j]][8] stores max integer represented by string that add up to i-a[j] as target \\n            }\\n        }\\n        return dp[t][8];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// Return a string maximum of two strings representing integer\\nstring maxl(string a, string b)\\n{\\n    if(a.length()>b.length())\\n        return a;\\n    else if(a.length()<b.length())\\n        return b;\\n    else\\n    {\\n        int i=0;\\n        while(i<a.length() && a[i]==b[i])\\n            i++;\\n        if(i==a.length())\\n            return a;\\n        if(a[i]>b[i])\\n            return a;\\n        return b;\\n    }\\n}  \\nclass Solution {\\npublic:\\n    \\n    string largestNumber(vector<int>& a, int t) {\\n        vector<vector<string>> dp(t+1,vector<string>(9,\"0\"));\\n        // dp[i][j] stores a string represeting largest integer with digits [1,2,..,j+1] that add up to \"i\"\\n        for(int i=1;i<=t;i++)\\n        {\\n            for(int j=0;j<9;j++)\\n            {\\n                if(i-a[j]==0)  // if i==a[j], we can form an integer= j+1\\n                    dp[i][j]=to_string(j+1);\\n                // keep max of either by not using the digit (j+1) or by using it\\n                if(j>0) \\n                    dp[i][j]=maxl(dp[i][j-1], dp[i][j]); // case: not using (j+1) digit\\n                \\n                if(i-a[j]>=0 && dp[i-a[j]][8]!=\"0\") //case: by using it after checking if it is possible to make an integer by i-a[j] as target\\n                    dp[i][j]=maxl(dp[i][j], dp[i-a[j]][8]+to_string(j+1)); // dp[i-a[j]][8] stores max integer represented by string that add up to i-a[j] as target \\n            }\\n        }\\n        return dp[t][8];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 868392,
                "title": "1d-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& cost, int target) {\\n        // \"?\" : not decided\\n        // \"\" : decided, it is empty\\n        // \"0\" : decided, it does not exist\\n        vector<string> dp(target + 1, \"?\");\\n        return getdp(cost, target, dp);\\n    }\\n\\nprivate:\\n    string getdp(vector<int>& cost, int target, vector<string>& dp) {\\n        if (dp[target] != \"?\") {\\n            return dp[target];\\n        }\\n        if (target == 0) {\\n            return dp[target] = \"\";\\n        }\\n        string ans = \"0\";\\n        for (int i = 9; i >= 1; --i) {\\n            if (cost[i - 1] <= target) {\\n                if (string sub = getdp(cost, target - cost[i - 1], dp); sub != \"0\") {\\n                    if (string candidate = string(1, char(i + \\'0\\')) + sub; bigger(candidate, ans)) {\\n                        ans = move(candidate);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[target] = ans;\\n    }\\n\\n    bool bigger(string& lhs, string& rhs) {\\n        if (lhs.size() == rhs.size()) {\\n            return lhs > rhs;\\n        } else {\\n            return lhs.size() > rhs.size();\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& cost, int target) {\\n        // \"?\" : not decided\\n        // \"\" : decided, it is empty\\n        // \"0\" : decided, it does not exist\\n        vector<string> dp(target + 1, \"?\");\\n        return getdp(cost, target, dp);\\n    }\\n\\nprivate:\\n    string getdp(vector<int>& cost, int target, vector<string>& dp) {\\n        if (dp[target] != \"?\") {\\n            return dp[target];\\n        }\\n        if (target == 0) {\\n            return dp[target] = \"\";\\n        }\\n        string ans = \"0\";\\n        for (int i = 9; i >= 1; --i) {\\n            if (cost[i - 1] <= target) {\\n                if (string sub = getdp(cost, target - cost[i - 1], dp); sub != \"0\") {\\n                    if (string candidate = string(1, char(i + \\'0\\')) + sub; bigger(candidate, ans)) {\\n                        ans = move(candidate);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[target] = ans;\\n    }\\n\\n    bool bigger(string& lhs, string& rhs) {\\n        if (lhs.size() == rhs.size()) {\\n            return lhs > rhs;\\n        } else {\\n            return lhs.size() > rhs.size();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 800986,
                "title": "java-solution-easy-to-understand-with-complexity-of-o-target",
                "content": "```\\nclass Solution {\\n    static String[] aa;\\n    static String maxx(int target,int[] cost){\\n        if(target<0){\\n            return \"0\";\\n        }\\n        if(target==0){\\n           return \"\";\\n        }\\n        if(!aa[target].equals(\"#\")){\\n            return aa[target];\\n        }\\n        long maxs=0;\\n        String str=\"0\";\\n        for(int i=0;i<9;i++){\\n            String st=String.valueOf(i+1)+maxx(target-cost[i],cost);\\n            if(st.charAt(st.length()-1)==\\'0\\'){continue;}\\n            if(st.length()>str.length()){\\n                // maxs=Long.parseLong(st);\\n                str=st;\\n            }else if(st.length()==str.length()){\\n                if(!st.equals(str)){\\n                    for(int j=0;j<st.length();j++){\\n                        int ii=Integer.parseInt(String.valueOf(st.charAt(j)));\\n                        int jj=Integer.parseInt(String.valueOf(str.charAt(j)));\\n                            if(ii>jj){\\n                                str=st;\\n                                break;\\n                            }\\n                            else if(ii<jj){break;}\\n                        }\\n                    }\\n                \\n            }\\n        }\\n        return aa[target]=str;\\n    }\\n    \\n    public String largestNumber(int[] cost, int target) {\\n        aa=new String[target+1];\\n        Arrays.fill(aa,\"#\");\\n        \\n        return maxx(target,cost);\\n    }\\n}```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    static String[] aa;\\n    static String maxx(int target,int[] cost){\\n        if(target<0){\\n            return \"0\";\\n        }\\n        if(target==0){\\n           return \"\";\\n        }\\n        if(!aa[target].equals(\"#\")){\\n            return aa[target];\\n        }\\n        long maxs=0;\\n        String str=\"0\";\\n        for(int i=0;i<9;i++){\\n            String st=String.valueOf(i+1)+maxx(target-cost[i],cost);\\n            if(st.charAt(st.length()-1)==\\'0\\'){continue;}\\n            if(st.length()>str.length()){\\n                // maxs=Long.parseLong(st);\\n                str=st;\\n            }else if(st.length()==str.length()){\\n                if(!st.equals(str)){\\n                    for(int j=0;j<st.length();j++){\\n                        int ii=Integer.parseInt(String.valueOf(st.charAt(j)));\\n                        int jj=Integer.parseInt(String.valueOf(str.charAt(j)));\\n                            if(ii>jj){\\n                                str=st;\\n                                break;\\n                            }\\n                            else if(ii<jj){break;}\\n                        }\\n                    }\\n                \\n            }\\n        }\\n        return aa[target]=str;\\n    }\\n    \\n    public String largestNumber(int[] cost, int target) {\\n        aa=new String[target+1];\\n        Arrays.fill(aa,\"#\");\\n        \\n        return maxx(target,cost);\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 722726,
                "title": "dp-c-simple-solution-similiar-to-knapsack",
                "content": "```\\nclass Solution {\\npublic:\\n    string findmaximum(string a,string b){\\n        if (a.size()==b.size()){\\n            return a>=b?a:b ;\\n        }\\n        return a.size()>b.size()?a:b ;\\n    }\\n    \\n    string largestNumber(vector<int>& cost, int target) {\\n\\n        vector<vector<string>> dp(11,vector<string>(5001,\"0\")) ;\\n     \\n        int n = cost.size() ;\\n        for (int i=1;i<=n;i++){\\n            for (int j=1;j<=target;j++){\\n                dp[i][j] = dp[i-1][j] ;\\n                if (cost[i-1]>j) continue ;\\n                if (cost[i-1]==j) dp[i][j] = findmaximum(dp[i][j],to_string(i)) ;\\n                else if (cost[i-1]<j) {\\n                    if (dp[i][j-cost[i-1]]==\"0\")continue ; \\n                    dp[i][j] = findmaximum(dp[i][j],to_string(i)+dp[i][j-cost[i-1]]) ;\\n                }\\n            }\\n        }\\n        return dp[n][target] ;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string findmaximum(string a,string b){\\n        if (a.size()==b.size()){\\n            return a>=b?a:b ;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 705720,
                "title": "simple-python-bottom-up-dp",
                "content": "```\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        d = [0] + [-1] * (target)\\n        for j in reversed(range(1, 10)):   # reverse this for convenience, so that we can simply add the number to the tail\\n            c = cost[j-1]\\n            for t in range(c, target+1):   # this order should be from left to right, so that we handle all possible cost for this digit j\\n                if d[t-c] >= 0:\\n                    d[t] = max(d[t], d[t-c]*10 + j)\\n        return str(d[target]) if d[target] > 0 else \"0\"\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        d = [0] + [-1] * (target)\\n        for j in reversed(range(1, 10)):   # reverse this for convenience, so that we can simply add the number to the tail\\n            c = cost[j-1]\\n            for t in range(c, target+1):   # this order should be from left to right, so that we handle all possible cost for this digit j\\n                if d[t-c] >= 0:\\n                    d[t] = max(d[t], d[t-c]*10 + j)\\n        return str(d[target]) if d[target] > 0 else \"0\"\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 702540,
                "title": "classical-dp-solution-in-java",
                "content": "```\\nclass Solution {\\n    public String largestNumber(int[] cost, int target) {\\n        int[][] dp = new int[10][5001];\\n        Arrays.fill(dp[0],-1);\\n        \\n        for(int i=1;i<=cost.length; i++){\\n            for(int j=1;j<=target;j++){\\n                if(cost[i-1] > j) dp[i][j] = dp[i-1][j];\\n\\n                else {\\n                    int temp = (dp[i-1][j-cost[i-1]] == -1) ? -1 : 1+dp[i-1][j-cost[i-1]];\\n                    int t = (dp[i][j-cost[i-1]] == -1) ? -1 : 1+dp[i][j-cost[i-1]];\\n                    temp = (t == -1) ? temp : (temp == -1) ? t : (t >= temp)? t:temp; \\n                    dp[i][j] = (dp[i-1][j] == -1) ? temp : (temp == -1) ? dp[i-1][j] \\n                                 :(temp >= dp[i-1][j])?temp : dp[i-1][j];\\n                }\\n            }\\n        }\\n        if (dp[9][target] == -1) return \"0\";\\n            int i = 9, j = target;\\n         StringBuilder result = new StringBuilder();\\n           while(target > 0){\\n               \\n               if(target-cost[i-1] >= 0 &&  dp[i][target-cost[i-1]]+1 == dp[i][target]){\\n                   result.append(i);\\n                   target-= cost[i-1];\\n               }\\n               else if(target-cost[i-1] >= 0 && dp[i-1][target-cost[i-1]]+1 == dp[i][target]){\\n                   result.append(i);\\n                   target-=cost[i-1];\\n               }\\n               else i--;\\n           }\\n        \\n        return result.toString();\\n           \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String largestNumber(int[] cost, int target) {\\n        int[][] dp = new int[10][5001];\\n        Arrays.fill(dp[0],-1);\\n        \\n        for(int i=1;i<=cost.length; i++){\\n            for(int j=1;j<=target;j++){\\n                if(cost[i-1] > j) dp[i][j] = dp[i-1][j];\\n\\n                else {\\n                    int temp = (dp[i-1][j-cost[i-1]] == -1) ? -1 : 1+dp[i-1][j-cost[i-1]];\\n                    int t = (dp[i][j-cost[i-1]] == -1) ? -1 : 1+dp[i][j-cost[i-1]];\\n                    temp = (t == -1) ? temp : (temp == -1) ? t : (t >= temp)? t:temp; \\n                    dp[i][j] = (dp[i-1][j] == -1) ? temp : (temp == -1) ? dp[i-1][j] \\n                                 :(temp >= dp[i-1][j])?temp : dp[i-1][j];\\n                }\\n            }\\n        }\\n        if (dp[9][target] == -1) return \"0\";\\n            int i = 9, j = target;\\n         StringBuilder result = new StringBuilder();\\n           while(target > 0){\\n               \\n               if(target-cost[i-1] >= 0 &&  dp[i][target-cost[i-1]]+1 == dp[i][target]){\\n                   result.append(i);\\n                   target-= cost[i-1];\\n               }\\n               else if(target-cost[i-1] >= 0 && dp[i-1][target-cost[i-1]]+1 == dp[i][target]){\\n                   result.append(i);\\n                   target-=cost[i-1];\\n               }\\n               else i--;\\n           }\\n        \\n        return result.toString();\\n           \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 692289,
                "title": "o-n-time-and-space-c",
                "content": "in dp we keep the maximum digits we need to make the sum target;\\n\\n```\\nclass Solution\\n{\\npublic:\\n\\n\\tstring largestNumber(vector<int> &cost, int target)\\n\\t{\\n       map<int,int> mp;\\n        for(int i =0;i<size(cost);i++){\\n            mp[cost[i]]=i+1;\\n        }\\n        vector<int> costs;\\n        for(auto x : mp){\\n            costs.push_back(x.first);\\n        }\\n        \\n        vector<int> dp(target+1,0);\\n        vector<int> sv(target+1,0);\\n        dp[0]=1;\\n        for(int i = 0;i<target+1;i++){\\n            if(dp[i]>=1){\\n                for(auto j :costs){\\n                    if(i+j<=target)\\n                    if(dp[i]+1 > dp[i+j]){\\n                        dp[i+j] = dp[i]+1;\\n                        sv[i+j]=j;\\n                    }\\n                    else if(dp[i]+1 == dp[i+j]){\\n                        int jmp = sv[i+j];\\n                        if(mp[j]>mp[jmp])\\n                        sv[i+j]=j;\\n                    }\\n                }\\n            }\\n        }\\n        vector<int> ans;\\n        int temp = target;\\n        if(sv[target]==0)return \"0\";\\n        while(temp!=0){\\n            ans.push_back(sv[temp]);\\n            temp = temp - sv[temp];\\n        }\\n        vector<int> lol;\\n        for(auto x: ans){\\n            lol.push_back(mp[x]);\\n        }\\n        sort(lol.begin(),lol.end());\\n        reverse(lol.begin(),lol.end());\\n        string s ;\\n        for(auto x : lol)s+=to_string(x);\\n        return s;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n\\n\\tstring largestNumber(vector<int> &cost, int target)\\n\\t{\\n       map<int,int> mp;\\n        for(int i =0;i<size(cost);i++){\\n            mp[cost[i]]=i+1;\\n        }\\n        vector<int> costs;\\n        for(auto x : mp){\\n            costs.push_back(x.first);\\n        }\\n        \\n        vector<int> dp(target+1,0);\\n        vector<int> sv(target+1,0);\\n        dp[0]=1;\\n        for(int i = 0;i<target+1;i++){\\n            if(dp[i]>=1){\\n                for(auto j :costs){\\n                    if(i+j<=target)\\n                    if(dp[i]+1 > dp[i+j]){\\n                        dp[i+j] = dp[i]+1;\\n                        sv[i+j]=j;\\n                    }\\n                    else if(dp[i]+1 == dp[i+j]){\\n                        int jmp = sv[i+j];\\n                        if(mp[j]>mp[jmp])\\n                        sv[i+j]=j;\\n                    }\\n                }\\n            }\\n        }\\n        vector<int> ans;\\n        int temp = target;\\n        if(sv[target]==0)return \"0\";\\n        while(temp!=0){\\n            ans.push_back(sv[temp]);\\n            temp = temp - sv[temp];\\n        }\\n        vector<int> lol;\\n        for(auto x: ans){\\n            lol.push_back(mp[x]);\\n        }\\n        sort(lol.begin(),lol.end());\\n        reverse(lol.begin(),lol.end());\\n        string s ;\\n        for(auto x : lol)s+=to_string(x);\\n        return s;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 681246,
                "title": "c-d-p-solution",
                "content": "Coin change + maintaining max of each state.\\n```\\nstruct number\\n{\\n    int vec[10];\\n    int n;\\n    bool val;\\n    number()\\n    {\\n        for(int i=0;i<10;i++)\\n            vec[i]=0;\\n        n=0;\\n        val=false;\\n    }\\n    \\n};\\nclass Solution {\\npublic:\\n    bool compare(number num1,number num2)\\n    {\\n        if(num1.n>num2.n)\\n            return false;\\n        if(num1.n<num2.n)\\n            return true;\\n        for(int i=9;i>=1;i--)\\n        {\\n            if(num2.vec[i]>num1.vec[i])\\n                return true;\\n        }\\n        return false;\\n    }\\n    string largestNumber(vector<int>& cost, int target) {\\n        int i,j;\\n        number dp[10][target+1];\\n        for(i=1;i<10;i++)\\n            dp[i][0].val=true;\\n        for(i=1;i<10;i++)\\n        {\\n            for(j=1;j<=target;j++)\\n            {\\n                if(j>=cost[i-1])\\n                {\\n                    number temp=dp[i][j-cost[i-1]];\\n                    bool val1=dp[i-1][j].val;\\n                    bool val2=dp[i][j-cost[i-1]].val;\\n                    temp.vec[i]++;\\n                    temp.n++;\\n                    if(val1==true&&val2==true)\\n                    {\\n                        if(compare(dp[i-1][j],temp))\\n                            dp[i][j]=temp;\\n                        else\\n                            dp[i][j]=dp[i-1][j];\\n                    }\\n                    else if(val2==true)\\n                    {\\n                        dp[i][j]=temp;\\n                    }\\n                    else\\n                        dp[i][j]=dp[i-1][j];\\n                }\\n                else\\n                {\\n                    dp[i][j]=dp[i-1][j];\\n                }\\n            }\\n        }\\n        string s;\\n        for(i=9;i>=1;i--)\\n        {\\n            while(dp[9][target].vec[i])\\n            {\\n                s.push_back(\\'0\\'+i);\\n                dp[9][target].vec[i]--;\\n            }\\n        }\\n        if(s==\"\")\\n            return \"0\";\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct number\\n{\\n    int vec[10];\\n    int n;\\n    bool val;\\n    number()\\n    {\\n        for(int i=0;i<10;i++)\\n            vec[i]=0;\\n        n=0;\\n        val=false;\\n    }\\n    \\n};\\nclass Solution {\\npublic:\\n    bool compare(number num1,number num2)\\n    {\\n        if(num1.n>num2.n)\\n            return false;\\n        if(num1.n<num2.n)\\n            return true;\\n        for(int i=9;i>=1;i--)\\n        {\\n            if(num2.vec[i]>num1.vec[i])\\n                return true;\\n        }\\n        return false;\\n    }\\n    string largestNumber(vector<int>& cost, int target) {\\n        int i,j;\\n        number dp[10][target+1];\\n        for(i=1;i<10;i++)\\n            dp[i][0].val=true;\\n        for(i=1;i<10;i++)\\n        {\\n            for(j=1;j<=target;j++)\\n            {\\n                if(j>=cost[i-1])\\n                {\\n                    number temp=dp[i][j-cost[i-1]];\\n                    bool val1=dp[i-1][j].val;\\n                    bool val2=dp[i][j-cost[i-1]].val;\\n                    temp.vec[i]++;\\n                    temp.n++;\\n                    if(val1==true&&val2==true)\\n                    {\\n                        if(compare(dp[i-1][j],temp))\\n                            dp[i][j]=temp;\\n                        else\\n                            dp[i][j]=dp[i-1][j];\\n                    }\\n                    else if(val2==true)\\n                    {\\n                        dp[i][j]=temp;\\n                    }\\n                    else\\n                        dp[i][j]=dp[i-1][j];\\n                }\\n                else\\n                {\\n                    dp[i][j]=dp[i-1][j];\\n                }\\n            }\\n        }\\n        string s;\\n        for(i=9;i>=1;i--)\\n        {\\n            while(dp[9][target].vec[i])\\n            {\\n                s.push_back(\\'0\\'+i);\\n                dp[9][target].vec[i]--;\\n            }\\n        }\\n        if(s==\"\")\\n            return \"0\";\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 680385,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& A, int T) {\\n        string res=\"\";\\n        vector<vector<int>>dp(A.size()+1,vector(T+1,-2));\\n        int r=A.size();\\n        int c=T;\\n        for(int i=0;i<dp.size();i++)dp[i][0]=0;\\n        \\n        for(int i=1;i<dp.size();i++){\\n            int val=A[i-1];\\n            for(int j=1;j<dp[0].size();j++){\\n                if(val>j){\\n                    dp[i][j]=dp[i-1][j];\\n                }\\n                else{\\n                    int x=dp[i-1][j];\\n                    if(dp[i][j-val]!=-2)x=max(x,1+dp[i][j-val]);\\n                    dp[i][j]=x;\\n                }\\n            }\\n        }\\n        if(dp[r][c]==-2)return \"0\";\\n        while(r>0&&c>0){\\n            int val=A[r-1];\\n            if(val>c){\\n                r--;\\n            }else{\\n                if(dp[r][c-val]==dp[r][c]-1){\\n                    res+=to_string(r);\\n                    c-=val;\\n                }else{\\n                    r--;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& A, int T) {\\n        string res=\"\";\\n        vector<vector<int>>dp(A.size()+1,vector(T+1,-2));\\n        int r=A.size();\\n        int c=T;\\n        for(int i=0;i<dp.size();i++)dp[i][0]=0;\\n        \\n        for(int i=1;i<dp.size();i++){\\n            int val=A[i-1];\\n            for(int j=1;j<dp[0].size();j++){\\n                if(val>j){\\n                    dp[i][j]=dp[i-1][j];\\n                }\\n                else{\\n                    int x=dp[i-1][j];\\n                    if(dp[i][j-val]!=-2)x=max(x,1+dp[i][j-val]);\\n                    dp[i][j]=x;\\n                }\\n            }\\n        }\\n        if(dp[r][c]==-2)return \"0\";\\n        while(r>0&&c>0){\\n            int val=A[r-1];\\n            if(val>c){\\n                r--;\\n            }else{\\n                if(dp[r][c-val]==dp[r][c]-1){\\n                    res+=to_string(r);\\n                    c-=val;\\n                }else{\\n                    r--;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 669359,
                "title": "c-bottom-up-o-target-solution",
                "content": "The idea is to get the maximum number of digits using exactly some cost and the retracing the solution. \\nThe dp is calculated such that if we get the same answer using a larger digit then we use that digit instead of the previous smaller digit.\\nTime complexity = O(9*target) = O(target)\\nSpace complexity = O(target)\\n```\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& a, int target) {\\n        int n = 9;\\n        // dp[c] = Max number of digits obtained by exactly c cost.\\n        vector<int>dp(target+6,INT_MIN);\\n        vector<int>path(target+6,-1);\\n        dp[0] = 0;\\n        string ans;\\n        int i,c;\\n        for(i=0;i<n;i++){\\n            for(c=0;c+a[i]<=target;c++){\\n                if(dp[c] != INT_MIN && dp[c+a[i]] <= dp[c] + 1){\\n                    dp[c+a[i]] = dp[c] + 1;\\n                    path[c+a[i]] = i;\\n                }\\n            }\\n        }\\n        if(dp[target] == INT_MIN) return \"0\";\\n        int id = target;\\n        while(id > 0){\\n            assert(path[id] != -1);\\n            ans.push_back(path[id]+1+\\'0\\');\\n            id = id - a[path[id]];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& a, int target) {\\n        int n = 9;\\n        // dp[c] = Max number of digits obtained by exactly c cost.\\n        vector<int>dp(target+6,INT_MIN);\\n        vector<int>path(target+6,-1);\\n        dp[0] = 0;\\n        string ans;\\n        int i,c;\\n        for(i=0;i<n;i++){\\n            for(c=0;c+a[i]<=target;c++){\\n                if(dp[c] != INT_MIN && dp[c+a[i]] <= dp[c] + 1){\\n                    dp[c+a[i]] = dp[c] + 1;\\n                    path[c+a[i]] = i;\\n                }\\n            }\\n        }\\n        if(dp[target] == INT_MIN) return \"0\";\\n        int id = target;\\n        while(id > 0){\\n            assert(path[id] != -1);\\n            ans.push_back(path[id]+1+\\'0\\');\\n            id = id - a[path[id]];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 668711,
                "title": "python-strict-o-target-with-explanation",
                "content": "```\\nimport functools\\n\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        # Only use the best choice.\\n        # E.x: both digit \\'1\\' and \\'3\\' cost 2, only use \\'3\\'\\n        best = {}\\n        for digit, c in enumerate(cost, 1):\\n            best[c] = digit\\n        \\n        # Sort the costs on digits descendingly\\n        choices = sorted(best.keys(), key=lambda x:(-best[x], x))\\n        \\n        # use to retrive the result back, instead of generating all strings during the DP process.\\n        pre = {}\\n        \\n        # DP[amount]: describes the maximum number of digits we can use for the amount.\\n        @functools.lru_cache(None)\\n        def DP(amount):\\n            nonlocal choices, best, pre\\n            \\n            if amount < 0:\\n                return float(\\'-inf\\')\\n            elif amount == 0:\\n                return 0\\n            \\n            maxi = -1\\n            for choice in choices:\\n                c = DP(amount - choice)\\n                # since we sorted the choices before, we only update the pointer if there is a longer result\\n                if c > maxi:\\n                    maxi = c\\n                    pre[amount] = choice\\n            \\n            return float(\\'-inf\\') if maxi == -1 else maxi + 1\\n        \\n        count = DP(target)\\n        if count == float(\\'-inf\\'):\\n            return \\'0\\'\\n        \\n        # retrive the result\\n        answer = []\\n        while target > 0:\\n            answer.append(str(best[pre[target]]))\\n            target -= pre[target]\\n        \\n        return \\'\\'.join(answer)\\n```",
                "solutionTags": [],
                "code": "```\\nimport functools\\n\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        # Only use the best choice.\\n        # E.x: both digit \\'1\\' and \\'3\\' cost 2, only use \\'3\\'\\n        best = {}\\n        for digit, c in enumerate(cost, 1):\\n            best[c] = digit\\n        \\n        # Sort the costs on digits descendingly\\n        choices = sorted(best.keys(), key=lambda x:(-best[x], x))\\n        \\n        # use to retrive the result back, instead of generating all strings during the DP process.\\n        pre = {}\\n        \\n        # DP[amount]: describes the maximum number of digits we can use for the amount.\\n        @functools.lru_cache(None)\\n        def DP(amount):\\n            nonlocal choices, best, pre\\n            \\n            if amount < 0:\\n                return float(\\'-inf\\')\\n            elif amount == 0:\\n                return 0\\n            \\n            maxi = -1\\n            for choice in choices:\\n                c = DP(amount - choice)\\n                # since we sorted the choices before, we only update the pointer if there is a longer result\\n                if c > maxi:\\n                    maxi = c\\n                    pre[amount] = choice\\n            \\n            return float(\\'-inf\\') if maxi == -1 else maxi + 1\\n        \\n        count = DP(target)\\n        if count == float(\\'-inf\\'):\\n            return \\'0\\'\\n        \\n        # retrive the result\\n        answer = []\\n        while target > 0:\\n            answer.append(str(best[pre[target]]))\\n            target -= pre[target]\\n        \\n        return \\'\\'.join(answer)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 663560,
                "title": "java-dp",
                "content": "Orig from @lee215: \\nhttps://leetcode.com/problems/form-largest-integer-with-digits-that-add-up-to-target/discuss/635267/C%2B%2BJavaPython-Strict-O(Target)\\n\\n```\\npublic String largestNumber(int[] cs, int t) {\\n        int[] dp = new int[t + 1];\\n        for (int i = 1; i <= t; i++) {\\n            dp[i] = Integer.MIN_VALUE;\\n            for (int j = 0; j < cs.length; j++) {\\n                if (i >=cs[j] && dp[i - cs[j]] >= 0) dp[i] = Math.max(dp[i], dp[i - cs[j]] + 1);\\n            }\\n        }\\n        if (dp[t] < 0) return \"0\";\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 8; i >= 0; i--) {\\n            while (t >= cs[i] && dp[t] == dp[t - cs[i]] + 1) {\\n                sb.append(i + 1);\\n                t -= cs[i];\\n            }\\n        }\\n        return sb.toString();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic String largestNumber(int[] cs, int t) {\\n        int[] dp = new int[t + 1];\\n        for (int i = 1; i <= t; i++) {\\n            dp[i] = Integer.MIN_VALUE;\\n            for (int j = 0; j < cs.length; j++) {\\n                if (i >=cs[j] && dp[i - cs[j]] >= 0) dp[i] = Math.max(dp[i], dp[i - cs[j]] + 1);\\n            }\\n        }\\n        if (dp[t] < 0) return \"0\";\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 8; i >= 0; i--) {\\n            while (t >= cs[i] && dp[t] == dp[t - cs[i]] + 1) {\\n                sb.append(i + 1);\\n                t -= cs[i];\\n            }\\n        }\\n        return sb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 662130,
                "title": "dynamic-programming-solution-on-the-lines-of-unbounded-knapsack-problem",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    static bool string_comp(string &a,string&b)\\n{\\n    if(a.size()!=b.size())\\n    {\\n        if(a.size()>b.size())\\n            return false;\\n        else\\n            return true;\\n    }\\n    \\n    else\\n        return a<b;\\n    \\n    \\n}\\n    string largestNumber(vector<int>& cost, int target) {\\n        \\n        \\n        unordered_map<int,int>vals;\\n        \\n        for(int i=0;i<cost.size();++i)\\n        {\\n            if(vals[cost[i]]<(i+1))\\n            {\\n                vals[cost[i]]=i+1;\\n            }\\n        }\\n        \\n        vector<string> DP(target+1,\"0\");\\n        \\n        DP[0]=\"0\";\\n        \\n        vector<string> maxi;\\n        \\n        for(int i=1;i<=target;i++)\\n        {\\n            maxi.clear();\\n            for(auto j:vals)\\n            {\\n                if((i-j.first)<0)\\n                {   maxi.push_back(\"0\");\\n                    continue;\\n                }\\n                \\n                else if((i-j.first)==0)\\n                {\\n                    maxi.push_back(to_string(j.second));\\n                }\\n                \\n                else\\n                {\\n                    if(DP[(i-j.first)]==\"0\")\\n                        maxi.push_back(\"0\");\\n                    else\\n                        maxi.push_back(DP[(i-j.first)]+to_string(j.second));\\n                }\\n            }\\n            \\n            DP[i]=*max_element(maxi.begin(),maxi.end(),string_comp);\\n            \\n            \\n        }\\n        \\n        return DP[target];\\n        \\n        \\n        \\n        \\n        \\n    }\\n};\\n\\n```\\n\\nExplanation:\\nUnordered map is used to store the maximum number for a particular cost.\\nDP part of solution is exactly the same as knapsack problem with repetitions.\\n\\nSpace: Faster than 100% C++ solutions",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    static bool string_comp(string &a,string&b)\\n{\\n    if(a.size()!=b.size())\\n    {\\n        if(a.size()>b.size())\\n            return false;\\n        else\\n            return true;\\n    }\\n    \\n    else\\n        return a<b;\\n    \\n    \\n}\\n    string largestNumber(vector<int>& cost, int target) {\\n        \\n        \\n        unordered_map<int,int>vals;\\n        \\n        for(int i=0;i<cost.size();++i)\\n        {\\n            if(vals[cost[i]]<(i+1))\\n            {\\n                vals[cost[i]]=i+1;\\n            }\\n        }\\n        \\n        vector<string> DP(target+1,\"0\");\\n        \\n        DP[0]=\"0\";\\n        \\n        vector<string> maxi;\\n        \\n        for(int i=1;i<=target;i++)\\n        {\\n            maxi.clear();\\n            for(auto j:vals)\\n            {\\n                if((i-j.first)<0)\\n                {   maxi.push_back(\"0\");\\n                    continue;\\n                }\\n                \\n                else if((i-j.first)==0)\\n                {\\n                    maxi.push_back(to_string(j.second));\\n                }\\n                \\n                else\\n                {\\n                    if(DP[(i-j.first)]==\"0\")\\n                        maxi.push_back(\"0\");\\n                    else\\n                        maxi.push_back(DP[(i-j.first)]+to_string(j.second));\\n                }\\n            }\\n            \\n            DP[i]=*max_element(maxi.begin(),maxi.end(),string_comp);\\n            \\n            \\n        }\\n        \\n        return DP[target];\\n        \\n        \\n        \\n        \\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 654963,
                "title": "need-help-to-find-the-error-in-java-code",
                "content": "class Solution {\\n    long ans=0;\\n    public String largestNumber(int[] cost, int target) {\\n        //sol(0,cost,target,cost.length,0);\\n        //return Integer.toString((int)ans);\\n        \\n        int n=cost.length;\\n        String sol[][]=new String[n+1][target+1];\\n        for(int i=0;i<n+1;i++)\\n        {\\n            for(int j=0;j<target+1;j++)\\n            {  \\n                if(j==0)\\n                  sol[i][j]=\"0\";\\n                if(i==0)\\n                  sol[i][j]=\"\";\\n                \\n            }\\n        }\\n        for(int i=1;i<n+1;i++)\\n        {\\n            for(int j=1;j<target+1;j++)\\n            {\\n                if(j-cost[i-1]>0)\\n                    sol[i][j]=mx(Character.forDigit(i, 10)+sol[i][j-cost[i-1]],Character.forDigit(i, 10)+sol[i-1][j-cost[i-1]]);\\n                sol[i][j]=mx(sol[i][j],sol[i-1][j]);\\n            }\\n        }\\n        for(int i=0;i<n+1;i++)\\n        {\\n            for(int j=0;j<target+1;j++)\\n            {\\n                System.out.print(sol[i][j]+\" \");\\n            }\\n            System.out.println();\\n        }\\n        return sol[n][target];\\n    }\\n    public String mx(String s1,String s2)\\n    {\\n        if(s1==null)\\n            return s2;\\n        if(s2==null)\\n            return s1;\\n        if(s1.contains(\"0\"))\\n            return s2;\\n        if(s2.contains(\"0\"))\\n            return s1;\\n        if(s1.length()>s2.length())\\n            return s1;\\n        if(s2.length()>s1.length())\\n            return s2;\\n        \\n        for(int i=0;i<s1.length();i++)\\n        {\\n            if(s1.charAt(i)>s2.charAt(i))\\n            {\\n                return s1;\\n            }\\n            if(s2.charAt(i)>s1.charAt(i))\\n            {\\n                return s2;\\n            }\\n        }\\n        return s1;\\n    }\\n    \\n   \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    long ans=0;\\n    public String largestNumber(int[] cost, int target) {\\n        //sol(0,cost,target,cost.length,0);\\n        //return Integer.toString((int)ans);\\n        \\n        int n=cost.length;\\n        String sol[][]=new String[n+1][target+1];\\n        for(int i=0;i<n+1;i++)\\n        {\\n            for(int j=0;j<target+1;j++)\\n            {  \\n                if(j==0)\\n                  sol[i][j]=\"0\";\\n                if(i==0)\\n                  sol[i][j]=\"\";\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 652377,
                "title": "c-dynamic-programming-o-10-target-time-space",
                "content": "This is similar to the Knapsack problem. \\n```\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& cost, int target) {\\n        string num;\\n        vector<char> ch={\\'1\\',\\'2\\',\\'3\\',\\'4\\',\\'5\\',\\'6\\',\\'7\\',\\'8\\',\\'9\\'};\\n        vector<vector<int>> digits(target+1, vector<int> (10,0));\\n        for( int i=0; i<target; i++){\\n            if(i==0||0<digits[i].back()){// some targets\\'re unachieveable\\n                for( int j=0; j<cost.size(); j++){\\n                vector<int> vc=digits[i];\\n                vc[j]+=1;\\n                vc.back()+=1;\\n                int this_cost=i+cost[j];\\n                if(this_cost<=target&&lessThan(digits[this_cost],vc))// digits.size()==target+1\\n                    digits[this_cost]=vc;\\n                }\\n            }\\n        }\\n        \\n        for( int i=digits.back().size()-2; -1<i; i--){// digits.back().back() is sum of digits.back()\\n            for( int j=0; j<digits.back()[i]; j++){\\n                num.push_back(ch[i]);\\n            }\\n        }\\n        return num!=\"\"?num:\"0\";\\n    }\\n    \\nprotected:\\n    bool lessThan(vector<int> & vc1, vector<int> & vc2){//vc1.size()==vc2.size()==10; # of 1-9 and total counts\\n        for( int i=vc1.size()-1; -1<i; i--)\\n            if(vc1[i]<vc2[i])   return true;\\n            else if(vc2[i]<vc1[i])  return false;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestNumber(vector<int>& cost, int target) {\\n        string num;\\n        vector<char> ch={\\'1\\',\\'2\\',\\'3\\',\\'4\\',\\'5\\',\\'6\\',\\'7\\',\\'8\\',\\'9\\'};\\n        vector<vector<int>> digits(target+1, vector<int> (10,0));\\n        for( int i=0; i<target; i++){\\n            if(i==0||0<digits[i].back()){// some targets\\'re unachieveable\\n                for( int j=0; j<cost.size(); j++){\\n                vector<int> vc=digits[i];\\n                vc[j]+=1;\\n                vc.back()+=1;\\n                int this_cost=i+cost[j];\\n                if(this_cost<=target&&lessThan(digits[this_cost],vc))// digits.size()==target+1\\n                    digits[this_cost]=vc;\\n                }\\n            }\\n        }\\n        \\n        for( int i=digits.back().size()-2; -1<i; i--){// digits.back().back() is sum of digits.back()\\n            for( int j=0; j<digits.back()[i]; j++){\\n                num.push_back(ch[i]);\\n            }\\n        }\\n        return num!=\"\"?num:\"0\";\\n    }\\n    \\nprotected:\\n    bool lessThan(vector<int> & vc1, vector<int> & vc2){//vc1.size()==vc2.size()==10; # of 1-9 and total counts\\n        for( int i=vc1.size()-1; -1<i; i--)\\n            if(vc1[i]<vc2[i])   return true;\\n            else if(vc2[i]<vc1[i])  return false;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 650738,
                "title": "java-solution-with-explanation",
                "content": "https://medium.com/@poitevinpm/leetcode-1449-form-largest-integer-with-digits-that-add-up-to-target-dd26895594cf",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 646998,
                "title": "difference-in-two-solution",
                "content": "Hello, I am not able to figure out why first soultion give me wrong answer and second is accepted. \\n```\\n// Wrong answer \\n// key for memo is start_target\\nclass Solution {\\n  String largerString(String first, String second){\\n        if(second.length() > first.length()) return second;\\n        if(first.length()> second.length()) return first;\\n        return first.compareTo(second)<0?second:first;\\n    }\\n\\n    Map<String,String> done = new HashMap<>();\\n    String helper(int[] cost, int start, int target, StringBuilder sb){\\n        String key = start+\"_\"+target;\\n        if(target==0){ \\n            return sb.toString();\\n        }\\n        if(target<0) return \"\";\\n        if(done.containsKey(key)) return done.get(key);\\n        String tmp=\"\";\\n        for(int i=start;i>=0;i--){\\n            int len = sb.length();\\n            sb.append((i+1));\\n            tmp= largerString(helper(cost,i,target-cost[i],sb),tmp);\\n            sb.setLength(len);\\n        }\\n        done.put(key,tmp);\\n        return tmp;\\n    }\\n\\n    public String largestNumber(int[] cost, int target) {\\n        String ans = helper(cost,cost.length-1,target,new StringBuilder());\\n        if(ans.length()==0) return \"0\";\\n        return ans;\\n    }\\n}\\n```\\n\\n```\\n// AC\\n// key for memo is length_target\\n String largerString(String first, String second){\\n        if(second.length() > first.length()) return second;\\n        if(first.length()> second.length()) return first;\\n        return first.compareTo(second)<0?second:first;\\n    }\\n\\n    Map<String,String> done = new HashMap<>();\\n    String helper(int[] cost, int start, int target, StringBuilder sb){\\n        String key = sb.length()+\"_\"+target;\\n        if(target==0){ \\n            return sb.toString();\\n        }\\n        if(target<0) return \"\";\\n        if(done.containsKey(key)) return done.get(key);\\n        String tmp=\"\";\\n        for(int i=start;i>=0;i--){\\n            int len = sb.length();\\n            sb.append((i+1));\\n            tmp= largerString(helper(cost,i,target-cost[i],sb),tmp);\\n            sb.setLength(len);\\n        }\\n        done.put(key,tmp);\\n        return tmp;\\n    }\\n\\n    public String largestNumber(int[] cost, int target) {\\n        String ans = helper(cost,cost.length-1,target,new StringBuilder());\\n        if(ans.length()==0) return \"0\";\\n        return ans;\\n    }\\n```\\nThere is difference in key for memo. But why this is affecting solution.?\\n\\nThanks in advance",
                "solutionTags": [],
                "code": "```\\n// Wrong answer \\n// key for memo is start_target\\nclass Solution {\\n  String largerString(String first, String second){\\n        if(second.length() > first.length()) return second;\\n        if(first.length()> second.length()) return first;\\n        return first.compareTo(second)<0?second:first;\\n    }\\n\\n    Map<String,String> done = new HashMap<>();\\n    String helper(int[] cost, int start, int target, StringBuilder sb){\\n        String key = start+\"_\"+target;\\n        if(target==0){ \\n            return sb.toString();\\n        }\\n        if(target<0) return \"\";\\n        if(done.containsKey(key)) return done.get(key);\\n        String tmp=\"\";\\n        for(int i=start;i>=0;i--){\\n            int len = sb.length();\\n            sb.append((i+1));\\n            tmp= largerString(helper(cost,i,target-cost[i],sb),tmp);\\n            sb.setLength(len);\\n        }\\n        done.put(key,tmp);\\n        return tmp;\\n    }\\n\\n    public String largestNumber(int[] cost, int target) {\\n        String ans = helper(cost,cost.length-1,target,new StringBuilder());\\n        if(ans.length()==0) return \"0\";\\n        return ans;\\n    }\\n}\\n```\n```\\n// AC\\n// key for memo is length_target\\n String largerString(String first, String second){\\n        if(second.length() > first.length()) return second;\\n        if(first.length()> second.length()) return first;\\n        return first.compareTo(second)<0?second:first;\\n    }\\n\\n    Map<String,String> done = new HashMap<>();\\n    String helper(int[] cost, int start, int target, StringBuilder sb){\\n        String key = sb.length()+\"_\"+target;\\n        if(target==0){ \\n            return sb.toString();\\n        }\\n        if(target<0) return \"\";\\n        if(done.containsKey(key)) return done.get(key);\\n        String tmp=\"\";\\n        for(int i=start;i>=0;i--){\\n            int len = sb.length();\\n            sb.append((i+1));\\n            tmp= largerString(helper(cost,i,target-cost[i],sb),tmp);\\n            sb.setLength(len);\\n        }\\n        done.put(key,tmp);\\n        return tmp;\\n    }\\n\\n    public String largestNumber(int[] cost, int target) {\\n        String ans = helper(cost,cost.length-1,target,new StringBuilder());\\n        if(ans.length()==0) return \"0\";\\n        return ans;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 646278,
                "title": "simple-java-bottom-up-solution-based-on-unbounded-knapsack-approach",
                "content": "class Solution {\\n    public String largestNumber(int[] cost, int target) {\\n        \\n        String[][] num = new String[cost.length + 1][target + 1]; \\n        \\n        for(int i = 1; i <= cost.length; i++){\\n            int curCost = cost[i - 1];\\n            for(int j = 1; j <= target; j++){\\n                String num1, num2 = \"\";\\n                if(curCost <= j){\\n                   if(num[i][j - curCost] == null && j - curCost != 0){\\n                       num[i][j] = num[i - 1][j];\\n                   }else{\\n                     String prev = num[i][j - curCost] == null ? \"\" : num[i][j - curCost];  \\n                     num1 =  i + prev;\\n                     num2 = num[i - 1][j];\\n                     if(num2 == null) num2 = \"\";\\n                     num[i][j] = compareAndAssign(num1, num2);         \\n                   }\\n\\n                }else{\\n                   num[i][j] = num[i - 1][j]; \\n                }                \\n            }\\n                     \\n        }\\n       return num[cost.length][target] == null ? \"0\" : num[cost.length][target];\\n        \\n    }\\n    \\n    public String compareAndAssign(String num1, String num2){\\n        \\n        if(num1.length() == num2.length()){\\n            if(num1.compareTo(num2) > 0){\\n                return num1;\\n            }else{\\n                return num2;\\n            }\\n            \\n        }else if(num1.length() > num2.length()){\\n            return num1;\\n        }\\n        \\n        return num2;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String largestNumber(int[] cost, int target) {\\n        \\n        String[][] num = new String[cost.length + 1][target + 1]; \\n        \\n        for(int i = 1; i <= cost.length; i++){\\n            int curCost = cost[i - 1];\\n            for(int j = 1; j <= target; j++){\\n                String num1, num2 = \"\";\\n                if(curCost <= j){\\n                   if(num[i][j - curCost] == null && j - curCost != 0){\\n                       num[i][j] = num[i - 1][j];\\n                   }",
                "codeTag": "Java"
            },
            {
                "id": 644535,
                "title": "javascript-and-c-solutions",
                "content": "**Top-Down w/ Memo (TLE):**\\n\\nReduce target sum `T` to 0.  Keep track of sub-problem solutions with a memo.  Let `memo[t]` denote the max amount of digits used to formulate the answer for target `t`.  If `memo[T]` is reachable, then we can reconstruct the path from `T` to 0 since each predecessor is 1 digit away.\\n\\n*Javascript*\\n```\\nlet largestNumber = (A, T, N = 9, path = []) => {\\n    let m = Array(T + 1).fill(-1);\\n    let go = (t = T) => {\\n        if (m[t] > -1)\\n            return m[t];\\n        if (!t)\\n            return m[t] = 0; // target sum reached \\u2705\\n        for (let i = 0; i < N; ++i) {\\n            if (t - A[i] < 0)\\n                continue; // A[i] exceeds target sum \\u274C\\n            let cand = go(t - A[i]);\\n            if (cand > -1)\\n                m[t] = Math.max(m[t], 1 + cand);\\n        }\\n        return m[t];\\n    };\\n    go();\\n    if (m[T] == -1) // target sum not reached \\u274C\\n        return \\'0\\';\\n    for (let i = N - 1, t = T; 0 <= i; --i)\\n        while (0 <= t - A[i] && m[t] == 1 + m[t - A[i]])\\n            path.push(i + 1), // +1 for 1-based indexing\\n            t -= A[i];\\n    return path.join(\\'\\'); // reconstructed path \\uD83C\\uDFAF\\n};\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n\\tstatic constexpr auto N{ 9 };\\n\\tusing VI = vector<int>;\\n\\tstring largestNumber(VI& A, int T, string path = {}) {\\n\\t\\tVI m(T + 1, -1);\\n\\t\\tm[0] = 0;\\n\\t\\tgo(A, T, m);\\n\\t\\tif (m[T] == -1) // target sum not reached \\u274C\\n\\t\\t\\treturn \"0\";\\n\\t\\tfor (auto i{ N - 1 }, t{ T }; 0 <= i; --i)\\n\\t\\t\\twhile (0 <= t - A[i] && m[t] == 1 + m[t - A[i]])\\n\\t\\t\\t\\tpath.push_back(\\'0\\' + i + 1), // +1 for 1-based indexing\\n\\t\\t\\t\\tt -= A[i];\\n\\t\\treturn path; // reconstructed path \\uD83C\\uDFAF\\n\\t}\\nprivate:\\n\\tint go(VI& A, int t, VI& m) {\\n\\t\\tif (m[t] > -1)\\n\\t\\t\\treturn m[t];\\n\\t\\tif (!t)\\n\\t\\t\\treturn m[t] = 0; // target sum reached \\u2705\\n\\t\\tfor (auto i{ 0 }; i < N; ++i) {\\n\\t\\t\\tif (t - A[i] < 0)\\n\\t\\t\\t\\tcontinue; // A[i] exceeds target sum \\u274C\\n\\t\\t\\tauto cand = go(A, t - A[i], m);\\n\\t\\t\\tif (cand > -1)\\n\\t\\t\\t\\tm[t] = max(m[t], 1 + cand);\\n\\t\\t}\\n\\t\\treturn m[t];\\n\\t}\\n};\\n```\\n\\n---\\n\\n**Bottom-Up (AC):** same idea as above, but flipped upside-down.\\n\\n*Javascript*\\n```\\nlet largestNumber = (A, T, N = 9, path = []) => {\\n    let dp = Array(T + 1).fill(-1);\\n    dp[0] = 0; // target sum 0 is reached with 0 digits \\u2705\\n    for (let t = 1; t <= T; ++t)\\n        for (let i = 0; i < N; ++i)\\n            if (0 <= t - A[i] && dp[t - A[i]] > -1)\\n                dp[t] = Math.max(dp[t], 1 + dp[t - A[i]]);\\n    if (dp[T] == -1) // target sum not reached \\u274C\\n        return \\'0\\';\\n    for (let i = N - 1, t = T; 0 <= i; --i)\\n        while (0 <= t - A[i] && dp[t] == 1 + dp[t - A[i]])\\n            path.push(i + 1), // +1 for 1-based indexing\\n            t -= A[i];\\n    return path.join(\\'\\'); // reconstructed path \\uD83C\\uDFAF\\n};\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    static constexpr auto N{ 9 };\\n    using VI = vector<int>;\\n    string largestNumber(VI& A, int T, string path = {}) {\\n        VI dp(T + 1, -1);\\n        dp[0] = 0; // target sum 0 is reached with 0 digits \\u2705\\n        for (auto t{ 1 }; t <= T; ++t)\\n            for (auto i{ 0 }; i < N; ++i)\\n                if (0 <= t - A[i] && dp[t - A[i]] > -1)\\n                    dp[t] = max(dp[t], 1 + dp[t - A[i]]);\\n        if (dp[T] == -1) // target sum not reached \\u274C\\n            return \"0\";\\n        for (auto i{ N - 1 }, t{ T }; 0 <= i; --i)\\n            while (0 <= t - A[i] && dp[t] == 1 + dp[t - A[i]])\\n                path.push_back(\\'0\\' + i + 1), // +1 for 1-based indexing\\n                t -= A[i];\\n        return path; // reconstructed path \\uD83C\\uDFAF\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nlet largestNumber = (A, T, N = 9, path = []) => {\\n    let m = Array(T + 1).fill(-1);\\n    let go = (t = T) => {\\n        if (m[t] > -1)\\n            return m[t];\\n        if (!t)\\n            return m[t] = 0; // target sum reached \\u2705\\n        for (let i = 0; i < N; ++i) {\\n            if (t - A[i] < 0)\\n                continue; // A[i] exceeds target sum \\u274C\\n            let cand = go(t - A[i]);\\n            if (cand > -1)\\n                m[t] = Math.max(m[t], 1 + cand);\\n        }\\n        return m[t];\\n    };\\n    go();\\n    if (m[T] == -1) // target sum not reached \\u274C\\n        return \\'0\\';\\n    for (let i = N - 1, t = T; 0 <= i; --i)\\n        while (0 <= t - A[i] && m[t] == 1 + m[t - A[i]])\\n            path.push(i + 1), // +1 for 1-based indexing\\n            t -= A[i];\\n    return path.join(\\'\\'); // reconstructed path \\uD83C\\uDFAF\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\tstatic constexpr auto N{ 9 };\\n\\tusing VI = vector<int>;\\n\\tstring largestNumber(VI& A, int T, string path = {}) {\\n\\t\\tVI m(T + 1, -1);\\n\\t\\tm[0] = 0;\\n\\t\\tgo(A, T, m);\\n\\t\\tif (m[T] == -1) // target sum not reached \\u274C\\n\\t\\t\\treturn \"0\";\\n\\t\\tfor (auto i{ N - 1 }, t{ T }; 0 <= i; --i)\\n\\t\\t\\twhile (0 <= t - A[i] && m[t] == 1 + m[t - A[i]])\\n\\t\\t\\t\\tpath.push_back(\\'0\\' + i + 1), // +1 for 1-based indexing\\n\\t\\t\\t\\tt -= A[i];\\n\\t\\treturn path; // reconstructed path \\uD83C\\uDFAF\\n\\t}\\nprivate:\\n\\tint go(VI& A, int t, VI& m) {\\n\\t\\tif (m[t] > -1)\\n\\t\\t\\treturn m[t];\\n\\t\\tif (!t)\\n\\t\\t\\treturn m[t] = 0; // target sum reached \\u2705\\n\\t\\tfor (auto i{ 0 }; i < N; ++i) {\\n\\t\\t\\tif (t - A[i] < 0)\\n\\t\\t\\t\\tcontinue; // A[i] exceeds target sum \\u274C\\n\\t\\t\\tauto cand = go(A, t - A[i], m);\\n\\t\\t\\tif (cand > -1)\\n\\t\\t\\t\\tm[t] = max(m[t], 1 + cand);\\n\\t\\t}\\n\\t\\treturn m[t];\\n\\t}\\n};\\n```\n```\\nlet largestNumber = (A, T, N = 9, path = []) => {\\n    let dp = Array(T + 1).fill(-1);\\n    dp[0] = 0; // target sum 0 is reached with 0 digits \\u2705\\n    for (let t = 1; t <= T; ++t)\\n        for (let i = 0; i < N; ++i)\\n            if (0 <= t - A[i] && dp[t - A[i]] > -1)\\n                dp[t] = Math.max(dp[t], 1 + dp[t - A[i]]);\\n    if (dp[T] == -1) // target sum not reached \\u274C\\n        return \\'0\\';\\n    for (let i = N - 1, t = T; 0 <= i; --i)\\n        while (0 <= t - A[i] && dp[t] == 1 + dp[t - A[i]])\\n            path.push(i + 1), // +1 for 1-based indexing\\n            t -= A[i];\\n    return path.join(\\'\\'); // reconstructed path \\uD83C\\uDFAF\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    static constexpr auto N{ 9 };\\n    using VI = vector<int>;\\n    string largestNumber(VI& A, int T, string path = {}) {\\n        VI dp(T + 1, -1);\\n        dp[0] = 0; // target sum 0 is reached with 0 digits \\u2705\\n        for (auto t{ 1 }; t <= T; ++t)\\n            for (auto i{ 0 }; i < N; ++i)\\n                if (0 <= t - A[i] && dp[t - A[i]] > -1)\\n                    dp[t] = max(dp[t], 1 + dp[t - A[i]]);\\n        if (dp[T] == -1) // target sum not reached \\u274C\\n            return \"0\";\\n        for (auto i{ N - 1 }, t{ T }; 0 <= i; --i)\\n            while (0 <= t - A[i] && dp[t] == 1 + dp[t - A[i]])\\n                path.push_back(\\'0\\' + i + 1), // +1 for 1-based indexing\\n                t -= A[i];\\n        return path; // reconstructed path \\uD83C\\uDFAF\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 643643,
                "title": "python3-easy-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        \\n        # wille the cost is same, we always keep the larger digit\\n        # so we have the dict of cost and digit where cost is less or equal to target\\n        c = {}\\n        for i,n in enumerate(cost):\\n            if n <= target:\\n                c[n] = str(i + 1)\\n        \\n        dp = [None] * (target+1)\\n\\n        for k,v in c.items():\\n            dp[k] = [v]\\n        \\n        # for every cost\\n        for i in range(target):\\n            # if not number is that cost continue\\n            if not dp[i]:\\n                continue\\n            # choose the largest num in the cost, and append every possible number added a new digit\\n            max_num = str(max([int(a) for a in dp[i]]))\\n            for k,v in c.items():\\n                if k + i <= target:\\n                    if dp[k+i]:\\n                        dp[k+i].append(max_num + v)\\n                    else:\\n                        dp[k+i] = [max_num + v]\\n                        \\n        # check if any number have the cost equal to target \\n        # and choose the largest one\\n        if not dp[target]:\\n            return \"0\"\\n        return str(max([int(i) for i in dp[target]]))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        \\n        # wille the cost is same, we always keep the larger digit\\n        # so we have the dict of cost and digit where cost is less or equal to target\\n        c = {}\\n        for i,n in enumerate(cost):\\n            if n <= target:\\n                c[n] = str(i + 1)\\n        \\n        dp = [None] * (target+1)\\n\\n        for k,v in c.items():\\n            dp[k] = [v]\\n        \\n        # for every cost\\n        for i in range(target):\\n            # if not number is that cost continue\\n            if not dp[i]:\\n                continue\\n            # choose the largest num in the cost, and append every possible number added a new digit\\n            max_num = str(max([int(a) for a in dp[i]]))\\n            for k,v in c.items():\\n                if k + i <= target:\\n                    if dp[k+i]:\\n                        dp[k+i].append(max_num + v)\\n                    else:\\n                        dp[k+i] = [max_num + v]\\n                        \\n        # check if any number have the cost equal to target \\n        # and choose the largest one\\n        if not dp[target]:\\n            return \"0\"\\n        return str(max([int(i) for i in dp[target]]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 639533,
                "title": "easy-to-understand-knapsack-solution-c",
                "content": "This is a very standard knapsack problem.\\n\\t\\n```\\n/* vector<int> represents the number to be painted, digits in descend order\\n * the bigger number has either more digits, or bigger MSB\\n * /\\nbool compare(const vector<int>& l, const vector<int>& r) {\\n    if (l.size() != r.size()) return l.size() < r.size();\\n    else return l < r;\\n}\\nclass Solution {\\nprivate:\\n\\t/* put a number into vector<int> to keep the descend order */\\n    void put(vector<int>& v, int i) {\\n        auto it = v.begin();\\n        while (it != v.end() && *it > i) it ++;\\n        v.insert(it, i);\\n    }\\npublic:\\n    string largestNumber(vector<int>& cost, int target) {\\n        unordered_map<int,int> m;\\n\\t\\t/* with same cost, always try to paint the largest digit */\\n        for (int i = 0; i < cost.size(); i ++) {\\n            m[cost.at(i)] = i + 1;\\n        }\\n\\t\\t// knapsack\\n        vector<vector<vector<int>>> dp(target + 1, vector<vector<int>>(m.size() + 1, vector<int>()));\\n        for (int i = 1; i <= target; i ++) {\\n            auto it = m.begin();\\n            for (int j = 1; it != m.end(); j ++, it ++) {\\n\\t\\t\\t\\t/* with or without using the current cost to paint the digit, choose the one creating larger number */\\n                dp.at(i).at(j) = dp.at(i).at(j - 1);\\n                if (i >= it->first && (dp.at(i - it->first).at(j).size() > 0 || i == it->first)) {\\n                    vector<int> s = dp.at(i - it->first).at(j);\\n                    put(s, it->second);\\n                    dp.at(i).at(j) = max(s, dp.at(i).at(j),compare);\\n                }\\n            }\\n        }\\n        stringstream ss;\\n        for (auto n : dp[target][m.size()]) {\\n            ss << n;\\n        }\\n        return dp[target][m.size()].empty() ? \"0\" : ss.str();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/* vector<int> represents the number to be painted, digits in descend order\\n * the bigger number has either more digits, or bigger MSB\\n * /\\nbool compare(const vector<int>& l, const vector<int>& r) {\\n    if (l.size() != r.size()) return l.size() < r.size();\\n    else return l < r;\\n}\\nclass Solution {\\nprivate:\\n\\t/* put a number into vector<int> to keep the descend order */\\n    void put(vector<int>& v, int i) {\\n        auto it = v.begin();\\n        while (it != v.end() && *it > i) it ++;\\n        v.insert(it, i);\\n    }\\npublic:\\n    string largestNumber(vector<int>& cost, int target) {\\n        unordered_map<int,int> m;\\n\\t\\t/* with same cost, always try to paint the largest digit */\\n        for (int i = 0; i < cost.size(); i ++) {\\n            m[cost.at(i)] = i + 1;\\n        }\\n\\t\\t// knapsack\\n        vector<vector<vector<int>>> dp(target + 1, vector<vector<int>>(m.size() + 1, vector<int>()));\\n        for (int i = 1; i <= target; i ++) {\\n            auto it = m.begin();\\n            for (int j = 1; it != m.end(); j ++, it ++) {\\n\\t\\t\\t\\t/* with or without using the current cost to paint the digit, choose the one creating larger number */\\n                dp.at(i).at(j) = dp.at(i).at(j - 1);\\n                if (i >= it->first && (dp.at(i - it->first).at(j).size() > 0 || i == it->first)) {\\n                    vector<int> s = dp.at(i - it->first).at(j);\\n                    put(s, it->second);\\n                    dp.at(i).at(j) = max(s, dp.at(i).at(j),compare);\\n                }\\n            }\\n        }\\n        stringstream ss;\\n        for (auto n : dp[target][m.size()]) {\\n            ss << n;\\n        }\\n        return dp[target][m.size()].empty() ? \"0\" : ss.str();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 638828,
                "title": "c-dp-solution-using-current-cost-and-digit-counts-as-states",
                "content": "```\\nclass Solution \\n{\\n    public:\\n    bool a_larger(int a[10],int b[10])\\n    {\\n        for(int i=8;i>-1;i--)\\n        {\\n            if(a[i]>b[i])\\n            {\\n                return true;\\n            }\\n            else if(a[i]<b[i])\\n            {\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n    string largestNumber(vector<int>& cost, int target) \\n    {\\n        string result=\"\";\\n        int dp[target+1][10];\\n        memset(dp,0,sizeof(dp));\\n        map<int,int> total;\\n        for(int i=0;i<cost.size();i++)\\n        {\\n            total[cost[i]]=i;\\n        }\\n        for(int i=1;i<=target;i++)\\n        {\\n            for(map<int,int>::iterator it=total.begin();it!=total.end();it++)\\n            {\\n                if(i-it->first<0)\\n                {\\n                    break;\\n                }\\n                else\\n                {\\n                    int new_digits=dp[i-it->first][9]+1;\\n                    if(new_digits<dp[i][9]||(i-it->first!=0&&dp[i-it->first][9]==0))\\n                    {\\n                        continue;\\n                    }\\n                    if(new_digits>dp[i][9])\\n                    {\\n                        for(int j=0;j<9;j++)\\n                        {\\n                            dp[i][j]=dp[i-it->first][j];\\n                        }\\n                        dp[i][it->second]++;\\n                        dp[i][9]=new_digits;\\n                    }\\n                    else\\n                    {\\n                        int temp[10];\\n                        for(int j=0;j<9;j++)\\n                        {\\n                            temp[j]=dp[i-it->first][j];\\n                        }\\n                        temp[it->second]++;\\n                        if(a_larger(temp,dp[i]))\\n                        {\\n                            for(int j=0;j<9;j++)\\n                            {\\n                                dp[i][j]=temp[j];\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=8;i>-1;i--)\\n        {\\n            for(int j=0;j<dp[target][i];j++)\\n            {\\n                result+=to_string(i+1);\\n            }\\n        }\\n        if(result==\"\")\\n        {\\n            return \"0\";\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    bool a_larger(int a[10],int b[10])\\n    {\\n        for(int i=8;i>-1;i--)\\n        {\\n            if(a[i]>b[i])\\n            {\\n                return true;\\n            }\\n            else if(a[i]<b[i])\\n            {\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n    string largestNumber(vector<int>& cost, int target) \\n    {\\n        string result=\"\";\\n        int dp[target+1][10];\\n        memset(dp,0,sizeof(dp));\\n        map<int,int> total;\\n        for(int i=0;i<cost.size();i++)\\n        {\\n            total[cost[i]]=i;\\n        }\\n        for(int i=1;i<=target;i++)\\n        {\\n            for(map<int,int>::iterator it=total.begin();it!=total.end();it++)\\n            {\\n                if(i-it->first<0)\\n                {\\n                    break;\\n                }\\n                else\\n                {\\n                    int new_digits=dp[i-it->first][9]+1;\\n                    if(new_digits<dp[i][9]||(i-it->first!=0&&dp[i-it->first][9]==0))\\n                    {\\n                        continue;\\n                    }\\n                    if(new_digits>dp[i][9])\\n                    {\\n                        for(int j=0;j<9;j++)\\n                        {\\n                            dp[i][j]=dp[i-it->first][j];\\n                        }\\n                        dp[i][it->second]++;\\n                        dp[i][9]=new_digits;\\n                    }\\n                    else\\n                    {\\n                        int temp[10];\\n                        for(int j=0;j<9;j++)\\n                        {\\n                            temp[j]=dp[i-it->first][j];\\n                        }\\n                        temp[it->second]++;\\n                        if(a_larger(temp,dp[i]))\\n                        {\\n                            for(int j=0;j<9;j++)\\n                            {\\n                                dp[i][j]=temp[j];\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=8;i>-1;i--)\\n        {\\n            for(int j=0;j<dp[target][i];j++)\\n            {\\n                result+=to_string(i+1);\\n            }\\n        }\\n        if(result==\"\")\\n        {\\n            return \"0\";\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 638734,
                "title": "python-dfs-cache-greedy-o-target",
                "content": "```\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        \\'\\'\\'\\n        Greedy:\\n            1. paint the number with least cost first\\n            2. paint the largest number among those that have the same cost\\n        \\'\\'\\'\\n        cache, cost2digit = {}, {}\\n        for i, v in enumerate(cost):\\n            cost2digit[v] = str(i + 1) # keep the largest dight among those are of the same cost\\n        \\n        # (nlgn) for sorted, but n is up to 9 so this can be treated as constant time\\n        cost_keys = sorted(set(cost))\\n        \\n        # return flag and maximum integer you can paint using cost of t\\n        # flag == True -> can paint integer using cost of t\\n        def dfs(t):\\n            if 0 == t:\\n                return True, \"\"\\n            if t not in cache:\\n                res, flag = \"\", False\\n                for c in cost_keys:\\n                    if t < c:\\n                        break\\n                    tmp_flag, tmp_res = dfs(t - c)\\n                    if tmp_flag:\\n                        flag = True\\n                        # can paint integer using (t - c) cost\\n                        tmp = cost2digit[c] + tmp_res\\n                        \\n                        # string comparison\\n                        if len(tmp) > len(res):\\n                            res = tmp\\n                        elif len(tmp) == len(res):\\n                            res = max(res, tmp)\\n                        # res remain unchanged if len(tmp) < len(res)\\n                cache[t] = [flag, res]\\n            return cache[t]\\n        flag, res = dfs(target)\\n        return res if flag else \"0\"\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        \\'\\'\\'\\n        Greedy:\\n            1. paint the number with least cost first\\n            2. paint the largest number among those that have the same cost\\n        \\'\\'\\'\\n        cache, cost2digit = {}, {}\\n        for i, v in enumerate(cost):\\n            cost2digit[v] = str(i + 1) # keep the largest dight among those are of the same cost\\n        \\n        # (nlgn) for sorted, but n is up to 9 so this can be treated as constant time\\n        cost_keys = sorted(set(cost))\\n        \\n        # return flag and maximum integer you can paint using cost of t\\n        # flag == True -> can paint integer using cost of t\\n        def dfs(t):\\n            if 0 == t:\\n                return True, \"\"\\n            if t not in cache:\\n                res, flag = \"\", False\\n                for c in cost_keys:\\n                    if t < c:\\n                        break\\n                    tmp_flag, tmp_res = dfs(t - c)\\n                    if tmp_flag:\\n                        flag = True\\n                        # can paint integer using (t - c) cost\\n                        tmp = cost2digit[c] + tmp_res\\n                        \\n                        # string comparison\\n                        if len(tmp) > len(res):\\n                            res = tmp\\n                        elif len(tmp) == len(res):\\n                            res = max(res, tmp)\\n                        # res remain unchanged if len(tmp) < len(res)\\n                cache[t] = [flag, res]\\n            return cache[t]\\n        flag, res = dfs(target)\\n        return res if flag else \"0\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 638539,
                "title": "java-average-case-o-target-dp-solution-detailed-explanation",
                "content": "```\\nclass Solution {\\n    public String largestNumber(int[] cost, int target) {\\n        String[][] dp = new String[cost.length][target + 1];\\n        // construct dp by transition function\\n        for (int i = 0; i < dp.length; i++) {\\n            dp[i][0] = \"0\";\\n            for (int t = 1; t < dp[i].length; t++) {\\n                if (t < cost[i]) {\\n                    // cannot take the cost[i], so same as excluding this element\\n                    dp[i][t] = i == 0 ? \"-1\" : dp[i - 1][t];\\n                } else {\\n                    // can take the cost[i], and need further evaluation\\n                    String prev = dp[i][t - cost[i]];\\n                    if (!prev.equals(\"-1\")) {\\n                        // if take the cost[i], the new target is still reachable\\n                        int v = i + 1;\\n                        String include = prev.equals(\"0\") ? Integer.toString(v) : v + prev;\\n                        // compare to see if including or excluding the cost[i] is more profitable\\n                        dp[i][t] = i == 0 ? include : max(include, dp[i - 1][t]);\\n                    } else {\\n                        // if take the cost[i], the new target is not reachable, so cannot take\\n                        dp[i][t] = i == 0 ? \"-1\" : dp[i - 1][t];\\n                    }\\n                }\\n            }\\n        }\\n        String result = dp[cost.length - 1][target];\\n        return result.equals(\"-1\") ? \"0\" : dp[cost.length - 1][target];\\n    }\\n\\n    private String max(String a, String b) {\\n        if (b.equals(\"-1\")) return a;\\n        if (a.length() > b.length()) return a;\\n        if (a.length() < b.length()) return b;\\n        for (int i = 0; i < a.length(); i++) {\\n            if (a.charAt(i) > b.charAt(i)) return a;\\n            if (a.charAt(i) < b.charAt(i)) return b;\\n        }\\n        return a;\\n    }\\n}\\n\\n/**\\n * Time: O(9 * target^2), dp array of size 9 * target, and max function can be worst case O(target)\\n * Space: O(9 * target), dp array of size 9 * target\\n *\\n * intuition:\\n * This is a unbounded knapsack problem with exact weights. Comparing to classic unbounded knapsack problem, this also\\n * needs a reachability check component. \"-1\" here is to represent unreachable node. The dp stores String and the custom\\n * max function for String form integers are only here because of possible overflows, which causes this to be bounded by\\n * worst case of O(target^2), but on average, this is O(target).\\n *\\n * define: dp[i][t] maximum string form integer to satisfy target t with only the first i elements in the cost array\\n * base case: dp[i][0] = \"0\", if target is 0, nothing needed\\n * transition:\\n *      if (t < cost[i]): <cannot take the cost[i], so same as excluding this element>\\n *          dp[i][t] = dp[i-1][t] OR -1 if dp[i-1][t] is out of bound\\n *      else: <can take the cost[i], and need further evaluation>\\n *          if (dp[i][t - cost[i]] != \"-1\"): <if take the cost[i], the new target is still reachable>\\n *              <compare to see if including or excluding the cost[i] is more profitable>\\n *              dp[i][t] = max(dp[i-1][t], \"i + 1\" + dp[i][t - cost[i]]) OR \"i + 1\" + dp[i][t - cost[i]] if dp[i-1][t]\\n *              is out of bound. NOTE:  \"i + 1\" + dp[i][t - cost[i]] = \"i + 1\" if dp[i][t - cost[i]] == \"0\"\\n *          else: <if take the cost[i], the new target is not reachable, so cannot take>\\n *              dp[i][t] = dp[i-1][t] OR -1 if dp[i-1][t] is out of bound\\n * result: dp[cost.length - 1][target]\\n *\\n * example:\\n * input =\\n * [4,3,2,5,6,7,2,5,5]\\n * 9\\n * dp =          t\\n * i value cost  0   1   2   3   4   5    6    7     8     9\\n * 0     1    4 [0, -1, -1, -1,  1, -1,  -1,  -1,   11,   -1]\\n * 1     2    3 [0, -1, -1,  2,  1, -1,  22,  21,   11,  222]\\n * 2     3    2 [0, -1,  3,  2, 33, 32, 333, 332, 3333, 3332]\\n * 3     4    5 [0, -1,  3,  2, 33, 32, 333, 332, 3333, 3332]\\n * 4     5    6 [0, -1,  3,  2, 33, 32, 333, 332, 3333, 3332]\\n * 5     6    7 [0, -1,  3,  2, 33, 32, 333, 332, 3333, 3332]\\n * 6     7    2 [0, -1,  7,  2, 77, 72, 777, 772, 7777, 7772]\\n * 7     8    5 [0, -1,  7,  2, 77, 72, 777, 772, 7777, 7772]\\n * 8     9    5 [0, -1,  7,  2, 77, 72, 777, 772, 7777, 7772]\\n *\\n * */\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public String largestNumber(int[] cost, int target) {\\n        String[][] dp = new String[cost.length][target + 1];\\n        // construct dp by transition function\\n        for (int i = 0; i < dp.length; i++) {\\n            dp[i][0] = \"0\";\\n            for (int t = 1; t < dp[i].length; t++) {\\n                if (t < cost[i]) {\\n                    // cannot take the cost[i], so same as excluding this element\\n                    dp[i][t] = i == 0 ? \"-1\" : dp[i - 1][t];\\n                } else {\\n                    // can take the cost[i], and need further evaluation\\n                    String prev = dp[i][t - cost[i]];\\n                    if (!prev.equals(\"-1\")) {\\n                        // if take the cost[i], the new target is still reachable\\n                        int v = i + 1;\\n                        String include = prev.equals(\"0\") ? Integer.toString(v) : v + prev;\\n                        // compare to see if including or excluding the cost[i] is more profitable\\n                        dp[i][t] = i == 0 ? include : max(include, dp[i - 1][t]);\\n                    } else {\\n                        // if take the cost[i], the new target is not reachable, so cannot take\\n                        dp[i][t] = i == 0 ? \"-1\" : dp[i - 1][t];\\n                    }\\n                }\\n            }\\n        }\\n        String result = dp[cost.length - 1][target];\\n        return result.equals(\"-1\") ? \"0\" : dp[cost.length - 1][target];\\n    }\\n\\n    private String max(String a, String b) {\\n        if (b.equals(\"-1\")) return a;\\n        if (a.length() > b.length()) return a;\\n        if (a.length() < b.length()) return b;\\n        for (int i = 0; i < a.length(); i++) {\\n            if (a.charAt(i) > b.charAt(i)) return a;\\n            if (a.charAt(i) < b.charAt(i)) return b;\\n        }\\n        return a;\\n    }\\n}\\n\\n/**\\n * Time: O(9 * target^2), dp array of size 9 * target, and max function can be worst case O(target)\\n * Space: O(9 * target), dp array of size 9 * target\\n *\\n * intuition:\\n * This is a unbounded knapsack problem with exact weights. Comparing to classic unbounded knapsack problem, this also\\n * needs a reachability check component. \"-1\" here is to represent unreachable node. The dp stores String and the custom\\n * max function for String form integers are only here because of possible overflows, which causes this to be bounded by\\n * worst case of O(target^2), but on average, this is O(target).\\n *\\n * define: dp[i][t] maximum string form integer to satisfy target t with only the first i elements in the cost array\\n * base case: dp[i][0] = \"0\", if target is 0, nothing needed\\n * transition:\\n *      if (t < cost[i]): <cannot take the cost[i], so same as excluding this element>\\n *          dp[i][t] = dp[i-1][t] OR -1 if dp[i-1][t] is out of bound\\n *      else: <can take the cost[i], and need further evaluation>\\n *          if (dp[i][t - cost[i]] != \"-1\"): <if take the cost[i], the new target is still reachable>\\n *              <compare to see if including or excluding the cost[i] is more profitable>\\n *              dp[i][t] = max(dp[i-1][t], \"i + 1\" + dp[i][t - cost[i]]) OR \"i + 1\" + dp[i][t - cost[i]] if dp[i-1][t]\\n *              is out of bound. NOTE:  \"i + 1\" + dp[i][t - cost[i]] = \"i + 1\" if dp[i][t - cost[i]] == \"0\"\\n *          else: <if take the cost[i], the new target is not reachable, so cannot take>\\n *              dp[i][t] = dp[i-1][t] OR -1 if dp[i-1][t] is out of bound\\n * result: dp[cost.length - 1][target]\\n *\\n * example:\\n * input =\\n * [4,3,2,5,6,7,2,5,5]\\n * 9\\n * dp =          t\\n * i value cost  0   1   2   3   4   5    6    7     8     9\\n * 0     1    4 [0, -1, -1, -1,  1, -1,  -1,  -1,   11,   -1]\\n * 1     2    3 [0, -1, -1,  2,  1, -1,  22,  21,   11,  222]\\n * 2     3    2 [0, -1,  3,  2, 33, 32, 333, 332, 3333, 3332]\\n * 3     4    5 [0, -1,  3,  2, 33, 32, 333, 332, 3333, 3332]\\n * 4     5    6 [0, -1,  3,  2, 33, 32, 333, 332, 3333, 3332]\\n * 5     6    7 [0, -1,  3,  2, 33, 32, 333, 332, 3333, 3332]\\n * 6     7    2 [0, -1,  7,  2, 77, 72, 777, 772, 7777, 7772]\\n * 7     8    5 [0, -1,  7,  2, 77, 72, 777, 772, 7777, 7772]\\n * 8     9    5 [0, -1,  7,  2, 77, 72, 777, 772, 7777, 7772]\\n *\\n * */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 638405,
                "title": "java-solution-dp-with-data-structure",
                "content": "```\\nclass Solution {\\n    \\n    class Node{\\n        int[] data=new int[10];\\n        int cnt = 0;\\n        void add(int n){\\n            data[n]++;\\n            cnt++;\\n        }\\n        Node copy(){\\n            Node copy = new Node();\\n            copy.data = Arrays.copyOf(data, 10);\\n            copy.cnt = cnt;\\n            return copy;\\n        }\\n        String string(){\\n            StringBuilder sb = new StringBuilder();\\n            for(int i=9; i>=1; i--)\\n                for(int j=0; j<data[i]; j++)\\n                    sb.append(i);\\n            return sb.toString();\\n        }\\n    }\\n    \\n    Node max(Node a, Node b){\\n        if(b==null) return a;\\n        if(a.cnt>b.cnt) return a;\\n        if(b.cnt>a.cnt) return b;\\n        for(int i=9; i>=1; i--)\\n            if(a.data[i]>b.data[i]) return a;\\n            else if(a.data[i]<b.data[i]) return b;\\n        return a;\\n    }\\n    \\n    \\n    public String largestNumber(int[] cost, int target) {\\n        \\n        Node[] dp = new Node[target+1];\\n        dp[0] = new Node();\\n        \\n        for(int i=1; i<=target; i++){\\n            for(int j=0; j<9; j++){\\n                if(i-cost[j]<0 || dp[i-cost[j]] == null) continue;\\n                Node copy = dp[i-cost[j]].copy();\\n                copy.add(j+1);\\n                dp[i] = max(copy, dp[i]);\\n            }\\n        }\\n            \\n        return dp[target]==null?\"0\":dp[target].string();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    class Node{\\n        int[] data=new int[10];\\n        int cnt = 0;\\n        void add(int n){\\n            data[n]++;\\n            cnt++;\\n        }\\n        Node copy(){\\n            Node copy = new Node();\\n            copy.data = Arrays.copyOf(data, 10);\\n            copy.cnt = cnt;\\n            return copy;\\n        }\\n        String string(){\\n            StringBuilder sb = new StringBuilder();\\n            for(int i=9; i>=1; i--)\\n                for(int j=0; j<data[i]; j++)\\n                    sb.append(i);\\n            return sb.toString();\\n        }\\n    }\\n    \\n    Node max(Node a, Node b){\\n        if(b==null) return a;\\n        if(a.cnt>b.cnt) return a;\\n        if(b.cnt>a.cnt) return b;\\n        for(int i=9; i>=1; i--)\\n            if(a.data[i]>b.data[i]) return a;\\n            else if(a.data[i]<b.data[i]) return b;\\n        return a;\\n    }\\n    \\n    \\n    public String largestNumber(int[] cost, int target) {\\n        \\n        Node[] dp = new Node[target+1];\\n        dp[0] = new Node();\\n        \\n        for(int i=1; i<=target; i++){\\n            for(int j=0; j<9; j++){\\n                if(i-cost[j]<0 || dp[i-cost[j]] == null) continue;\\n                Node copy = dp[i-cost[j]].copy();\\n                copy.add(j+1);\\n                dp[i] = max(copy, dp[i]);\\n            }\\n        }\\n            \\n        return dp[target]==null?\"0\":dp[target].string();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 638161,
                "title": "java-dp-knapsack-similar-to-coin-change-explain-lee215-s-idea",
                "content": "This time my method is same as lee\\'s.\\nIt is similar as \\n\\n322. Coin Change\\n322. https://leetcode.com/problems/coin-change/\\n\\nJust like the coin change problem, the cost[] is \"coins\" that we have, cost[i] = value of the coin. \\nNow we have a target amount. We need to use any unlimited number of the coins to make the target amount. \\nThe difference is we need to maxmium the number of \"coins\" we need to use. As the more we use, the longer length(larger) the integer we could build.\\n\\nSo, we need to try amount from 1 to target. Find the largest amount of \"coins\" we could make the amount.\\n```\\nint[] dp = new int[target + 1];\\nfor (int t = 1; t <= target; ++t) {\\n\\tdp[t] = Integer.MIN_VALUE;\\n\\tfor (int i = 0; i < cost.length; i++) {\\n\\t\\tif (t >= cost[i])\\n\\t\\t\\tdp[t] = Math.max(dp[t], 1 + dp[t - cost[i]]);\\n\\t}\\n}\\n```\\nThen we just need to go back from dp[target] to build the integer.\\n\\nThe whole code is\\n```\\npublic String largestNumber(int[] cost, int target) {\\n\\tint[] dp = new int[target + 1];\\n\\tfor (int t = 1; t <= target; ++t) {\\n\\t\\tdp[t] = Integer.MIN_VALUE;\\n\\t\\tfor (int i = 0; i < cost.length; i++) {\\n\\t\\t\\tif (t >= cost[i])\\n\\t\\t\\t\\tdp[t] = Math.max(dp[t], 1 + dp[t - cost[i]]);\\n\\t\\t}\\n\\t}\\n\\tif (dp[target] < 0) \\n\\t\\treturn \"0\";\\n\\tStringBuilder res = new StringBuilder();\\n\\tfor (int i = cost.length - 1; i >= 0; i--) {\\n\\t\\twhile (target >= cost[i] && dp[target] == dp[target - cost[i]] + 1) {\\n\\t\\t\\tres.append(1 + i);\\n\\t\\t\\ttarget -= cost[i];\\n\\t\\t}\\n\\t}\\n\\treturn res.toString();\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nint[] dp = new int[target + 1];\\nfor (int t = 1; t <= target; ++t) {\\n\\tdp[t] = Integer.MIN_VALUE;\\n\\tfor (int i = 0; i < cost.length; i++) {\\n\\t\\tif (t >= cost[i])\\n\\t\\t\\tdp[t] = Math.max(dp[t], 1 + dp[t - cost[i]]);\\n\\t}\\n}\\n```\n```\\npublic String largestNumber(int[] cost, int target) {\\n\\tint[] dp = new int[target + 1];\\n\\tfor (int t = 1; t <= target; ++t) {\\n\\t\\tdp[t] = Integer.MIN_VALUE;\\n\\t\\tfor (int i = 0; i < cost.length; i++) {\\n\\t\\t\\tif (t >= cost[i])\\n\\t\\t\\t\\tdp[t] = Math.max(dp[t], 1 + dp[t - cost[i]]);\\n\\t\\t}\\n\\t}\\n\\tif (dp[target] < 0) \\n\\t\\treturn \"0\";\\n\\tStringBuilder res = new StringBuilder();\\n\\tfor (int i = cost.length - 1; i >= 0; i--) {\\n\\t\\twhile (target >= cost[i] && dp[target] == dp[target - cost[i]] + 1) {\\n\\t\\t\\tres.append(1 + i);\\n\\t\\t\\ttarget -= cost[i];\\n\\t\\t}\\n\\t}\\n\\treturn res.toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 637575,
                "title": "python-0-1-knapsack-with-parent-pointers",
                "content": "Whether a dynamic programming problems ask for max / min length, matches, number, or for the path that lead to the min or max, the problem is essentialy the same. To get the path that lead to the result we create a parent dict which gives us information about the path taken to reach the answer. At the end we can traverse backwards to reconstruct our path. \\n\\n\\n```python\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n            N = target + 1\\n            \\n            CostNode = namedtuple(\\'CostNode\\', [\\'cost\\', \\'num\\'])\\n            parent = {}\\n            \\n            dp = [-float(\\'inf\\')] * N\\n            dp[0] = 0\\n            \\n            for t in range(N):\\n                for i, c in enumerate(cost):\\n                    if t >= c and dp[t - c] + 1 >= dp[t]:\\n                        dp[t] = dp[t - c] + 1\\n                        parent[t] = CostNode(c, i + 1)\\n                            \\n            \\n            if dp[target] == -float(\\'inf\\'):\\n                return \\'0\\'\\n            \\n            maxint = []\\n           \\n            while t > 0:\\n                maxint.append(parent[t].num)\\n                t = t - parent[t].cost\\n            \\n            return  \\'\\'.join([str(num) for num in maxint])\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n            N = target + 1\\n            \\n            CostNode = namedtuple(\\'CostNode\\', [\\'cost\\', \\'num\\'])\\n            parent = {}\\n            \\n            dp = [-float(\\'inf\\')] * N\\n            dp[0] = 0\\n            \\n            for t in range(N):\\n                for i, c in enumerate(cost):\\n                    if t >= c and dp[t - c] + 1 >= dp[t]:\\n                        dp[t] = dp[t - c] + 1\\n                        parent[t] = CostNode(c, i + 1)\\n                            \\n            \\n            if dp[target] == -float(\\'inf\\'):\\n                return \\'0\\'\\n            \\n            maxint = []\\n           \\n            while t > 0:\\n                maxint.append(parent[t].num)\\n                t = t - parent[t].cost\\n            \\n            return  \\'\\'.join([str(num) for num in maxint])\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1809492,
                "content": [
                    {
                        "username": "Finesse",
                        "content": "This is a 0- knapsack problem with a slightly convoluted rule for deciding which collection is better"
                    },
                    {
                        "username": "ritikabansal1131",
                        "content": "Is it unbounded knapsack?? Choosing the right weight to target?"
                    }
                ]
            },
            {
                "id": 2020649,
                "content": [
                    {
                        "username": "Finesse",
                        "content": "This is a 0- knapsack problem with a slightly convoluted rule for deciding which collection is better"
                    },
                    {
                        "username": "ritikabansal1131",
                        "content": "Is it unbounded knapsack?? Choosing the right weight to target?"
                    }
                ]
            }
        ]
    }
]