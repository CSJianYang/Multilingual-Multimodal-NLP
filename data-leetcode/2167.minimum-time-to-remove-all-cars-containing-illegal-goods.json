[
    {
        "title": "Minimum Time to Remove All Cars Containing Illegal Goods",
        "question_content": "You are given a 0-indexed binary string s which represents a sequence of train cars. s[i] = '0' denotes that the ith car does not contain illegal goods and s[i] = '1' denotes that the ith car does contain illegal goods.\nAs the train conductor, you would like to get rid of all the cars containing illegal goods. You can do any of the following three operations any number of times:\n\n\tRemove a train car from the left end (i.e., remove s[0]) which takes 1 unit of time.\n\tRemove a train car from the right end (i.e., remove s[s.length - 1]) which takes 1 unit of time.\n\tRemove a train car from anywhere in the sequence which takes 2 units of time.\n\nReturn the minimum time to remove all the cars containing illegal goods.\nNote that an empty sequence of cars is considered to have no cars containing illegal goods.\n&nbsp;\nExample 1:\n\nInput: s = \"1100101\"\nOutput: 5\nExplanation: \nOne way to remove all the cars containing illegal goods from the sequence is to\n- remove a car from the left end 2 times. Time taken is 2 * 1 = 2.\n- remove a car from the right end. Time taken is 1.\n- remove the car containing illegal goods found in the middle. Time taken is 2.\nThis obtains a total time of 2 + 1 + 2 = 5. \nAn alternative way is to\n- remove a car from the left end 2 times. Time taken is 2 * 1 = 2.\n- remove a car from the right end 3 times. Time taken is 3 * 1 = 3.\nThis also obtains a total time of 2 + 3 = 5.\n5 is the minimum time taken to remove all the cars containing illegal goods. \nThere are no other ways to remove them with less time.\n\nExample 2:\n\nInput: s = \"0010\"\nOutput: 2\nExplanation:\nOne way to remove all the cars containing illegal goods from the sequence is to\n- remove a car from the left end 3 times. Time taken is 3 * 1 = 3.\nThis obtains a total time of 3.\nAnother way to remove all the cars containing illegal goods from the sequence is to\n- remove the car containing illegal goods found in the middle. Time taken is 2.\nThis obtains a total time of 2.\nAnother way to remove all the cars containing illegal goods from the sequence is to \n- remove a car from the right end 2 times. Time taken is 2 * 1 = 2. \nThis obtains a total time of 2.\n2 is the minimum time taken to remove all the cars containing illegal goods. \nThere are no other ways to remove them with less time.\n&nbsp;\nConstraints:\n\n\t1 <= s.length <= 2 * 105\n\ts[i] is either '0' or '1'.",
        "solutions": [
            {
                "id": 1748424,
                "title": "python-maximum-sum-on-subarray-explained",
                "content": "Actually this problem is about maximum sum on subarray (or minimum, which is equivalent), let us show this. The optimal strategy will be:\\n1. Take some elements from the left\\n2. Take some elements from the right\\n3. Take the rest elements from the middle.\\n\\nNow, the question is how to choose left and right parts, we can have potentially `O(n^2)` options and we can not check them all. Let us calculate how much we paid:\\n\\n`|..left..|..middle..|..right..|`\\n\\nFor left and right we paid just their lengths. For middle we pay twice number of ones se have inside, so we have: `len(left) + 2* count(middle, 1) + len(right) = len(left) + len(middle) + len(right) + 2*count(middle, 1) - len(middle) = n + count(middle, 1) - count(middle, 0)`.\\n\\nSo, in fact what we need to found is the subarray with the smallest `count(middle, 1) - count(middle, 0)` value. If we now replace all `0` with `-1`, it is the same as found the subarray with the smallest sum! And we can use classical dp solution for problem 53. Maximum Subarray. Do not forgot about empty array case, it costs me 5min penalty on the contest. \\n\\n#### Complexity\\nIt is `O(n)` for time and space.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def minimumTime(self, s):\\n        def minSum(nums):\\n            dp = [0]*len(nums)\\n            dp[0] = nums[0]\\n            for i in range(1, len(nums)):\\n                dp[i] = min(nums[i], nums[i] + dp[i-1])\\n            return min(0, min(dp))\\n\\n        n = len(s)\\n        s1 = [1 if i == \"1\" else -1 for i in s]\\n        score = minSum(s1)\\n       \\n        return n + score\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def minimumTime(self, s):\\n        def minSum(nums):\\n            dp = [0]*len(nums)\\n            dp[0] = nums[0]\\n            for i in range(1, len(nums)):\\n                dp[i] = min(nums[i], nums[i] + dp[i-1])\\n            return min(0, min(dp))\\n\\n        n = len(s)\\n        s1 = [1 if i == \"1\" else -1 for i in s]\\n        score = minSum(s1)\\n       \\n        return n + score\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748704,
                "title": "java-c-python-short-one-pass-o-1-space",
                "content": "# **Explanation**\\nOne pass from left to right.\\n`left` counts the cost to clear all illegal goods from `s[0]` to `s[i]`\\n`right` counts the cost to clear all illegal goods from `s[i+1]` to `s[n-1]`\\n\\nIf `s[i] == 1`, then update `left` value,\\nwe take the minimum of these 2 options:\\n1) `i + 1`, by removing all left cars, `i + 1`\\n2) `left + 2`, previously remove cose + removing the current `s[i]`\\n\\n`right = n - 1 - i`, be removing all right cars.\\n<br>\\n\\n# **Q&A**\\nQuestion:\\n- Right is not the minimum, it can be less than that `n - 1 - i`\\nAnswer:\\n- Yes, that\\'s true.\\nImagine in best case, `s[i+1]` to `s[n-1]` is removed as the right part.\\nThe cost for this case can be calculated when we iterate `s[i]`.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public int minimumTime(String s) {\\n        int n = s.length(), left = 0, res = n;\\n        for (int i = 0; i < n; ++i) {   \\n            left = Math.min(left + (s.charAt(i) - \\'0\\') * 2, i + 1);\\n            res = Math.min(res, left + n - 1 - i);\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int minimumTime(string s) {\\n        int n = s.size(), left = 0, res = n;\\n        for (int i = 0; i < n; ++i) {   \\n            left = min(left + (s[i] - \\'0\\') * 2, i + 1);\\n            res = min(res, left + n - 1 - i);\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def minimumTime(self, s):\\n        left, res, n = 0, len(s), len(s)\\n        for i,c in enumerate(s):\\n            left = min(left + (c == \\'1\\') * 2, i + 1)\\n            res = min(res, left + n - 1 - i)\\n        return res\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int minimumTime(String s) {\\n        int n = s.length(), left = 0, res = n;\\n        for (int i = 0; i < n; ++i) {   \\n            left = Math.min(left + (s.charAt(i) - \\'0\\') * 2, i + 1);\\n            res = Math.min(res, left + n - 1 - i);\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int minimumTime(string s) {\\n        int n = s.size(), left = 0, res = n;\\n        for (int i = 0; i < n; ++i) {   \\n            left = min(left + (s[i] - \\'0\\') * 2, i + 1);\\n            res = min(res, left + n - 1 - i);\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def minimumTime(self, s):\\n        left, res, n = 0, len(s), len(s)\\n        for i,c in enumerate(s):\\n            left = min(left + (c == \\'1\\') * 2, i + 1)\\n            res = min(res, left + n - 1 - i)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1748436,
                "title": "c-prefix-suffix-easy-and-concise",
                "content": "Intution-\\nFor each \\'i\\' (if the s[i] == \\'1\\') from the left side we have to options -\\n>Remove all the digits till index \"i\" with total cost = i+1\\n>Remove that index with 2 cost and add the previously calculated cost.\\n\\nSimilarly for right side .\\n\\nNow after making left and right we have to find minimum for each \"i\" two possibility remove some from left (which is already stored in left array) , and remove from right to \"i+1\" (which is already calculated in right array).\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int n = s.size();\\n        vector<int>left(n,0) , right(n,0);\\n        if(s[0]==\\'1\\')\\n            left[0] = 1;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(s[i]==\\'1\\')\\n\\t\\t\\t               //remove from middile with cost 2 OR remove till \"i\"\\n                left[i] = min(left[i-1]+2 , i+1);\\n            else\\n                left[i] = left[i-1];\\n        }\\n        \\n        if(s[n-1]==\\'1\\')\\n            right[n-1]=1;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(s[i]==\\'1\\')\\n                right[i] = min(right[i+1]+2,n-i);\\n            else\\n                right[i] = right[i+1];\\n        }\\n        int ansMIN = INT_MAX;\\n        ansMIN = min(left[n-1],right[0]);\\n        for(int i=0;i<=n-2;i++)\\n        {\\n            ansMIN = min(ansMIN , left[i] + right[i+1]);\\n        }\\n        return ansMIN;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int n = s.size();\\n        vector<int>left(n,0) , right(n,0);\\n        if(s[0]==\\'1\\')\\n            left[0] = 1;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(s[i]==\\'1\\')\\n\\t\\t\\t               //remove from middile with cost 2 OR remove till \"i\"\\n                left[i] = min(left[i-1]+2 , i+1);\\n            else\\n                left[i] = left[i-1];\\n        }\\n        \\n        if(s[n-1]==\\'1\\')\\n            right[n-1]=1;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(s[i]==\\'1\\')\\n                right[i] = min(right[i+1]+2,n-i);\\n            else\\n                right[i] = right[i+1];\\n        }\\n        int ansMIN = INT_MAX;\\n        ansMIN = min(left[n-1],right[0]);\\n        for(int i=0;i<=n-2;i++)\\n        {\\n            ansMIN = min(ansMIN , left[i] + right[i+1]);\\n        }\\n        return ansMIN;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748452,
                "title": "python-explanation-with-pictures-prefix-and-suffix",
                "content": "We assume that the *maxCost* is the cost that removing all illegal cars with a cost of 2, no matter where they are.\\nGiven the input car streams like below. The *maxCost* = 10\\n![image](https://assets.leetcode.com/users/images/829bdfe1-dc83-4620-9929-b0b8210457cb_1644120076.281245.png)\\n\\nThen, we would like to **save** some costs, by removing cars from one side, with a cost of 1.\\nFor example, in the first plan, the cost we **save** is 2, the overall cost is **10-2=8**.\\nHowever in the second plan, the cost we **save** is -2, meaning we actually make things worse, the overall cost is **10+2=12**.\\n\\n![image](https://assets.leetcode.com/users/images/a68825d7-c56a-44d7-9d0a-8a8f1a8f0c2e_1644120081.9612591.png)\\n\\nTherefore, we can build a prefix array, to record the cost we can save by removing all the cars on left side.\\n> Apparently, \\n> - One removed illegal car means we **saved** 1 cost. \\n> - One removed legal car means we **wasted** 1 cost.\\n\\n![image](https://assets.leetcode.com/users/images/3e89603e-f1af-4ac7-ab33-e153131ce807_1644120364.035242.png)\\n\\nSimilarly, suffix to record the cost we can save by removing all the cars on the right side.\\n![image](https://assets.leetcode.com/users/images/ad974281-d6bb-4662-affd-92540da339d7_1644120106.6847565.png)\\n\\nThen we use **pre_max** to record the maximum cost we can save up to i-th idx from the left side.\\nSimilary, use **suf_max** to record the maximum cost we can save up to i-th idx from the right side.\\n\\n![image](https://assets.leetcode.com/users/images/7ffaac2b-2ae2-4667-90fe-6ac9a0f66057_1644120113.3117552.png)\\n\\nThen we just need to iterate over pre_max and suf_max to find the maximum cost we can save, based on the *maxCost*.\\n> Notice that:\\n> - We have to add **pre_max[i]** and **suf_max[i + 1]**, rather than **suf_max[i]**, since we dont need to remove car[i] from both sides.\\n> - If pre_max[i] or suf_max[i + 1] is smaller than 0, we don\\'t need to add it (or add 0 instead), meaning we don\\'t bother moving any car from this side.\\n\\n![image](https://assets.leetcode.com/users/images/5f12de7a-7712-40ff-9b46-1bc362739967_1644120117.7919283.png)\\n\\n\\nMy code is ugly and redundant, like the *lft_saveCost* in the pictures is not needed at all since we can build pre_max in the first iteration.\\nPlease refer to others\\' like [DBabichev\\'s](https://leetcode.com/problems/minimum-time-to-remove-all-cars-containing-illegal-goods/discuss/1748424/Python-maximum-sum-on-subarray-explained).\\n\\n\\n\\n**Python**\\n```\\ndef minimumTime(self, A: str) -> int:\\n        n = len(A)\\n        if n == 1: return 1 if A == \\'1\\' else 0\\n        lft, rgt = [] * n, [] * n\\n        \\n        curr = 0\\n        for a in A:\\n            if a == \\'1\\':\\n                curr += 1\\n            else:\\n                curr -= 1\\n            lft.append(curr)\\n            \\n        curr = 0\\n        for a in A[::-1]:\\n            if a == \\'1\\':\\n                curr += 1\\n            else:\\n                curr -= 1\\n            rgt.append(curr)\\n        rgt.reverse()\\n\\n        exp = 2 * A.count(\\'1\\')   # MaximumCost, that is the cost of removing all cars with a cost of 2.\\n            \\n        lmax, curr = [lft[0]], lft[0]\\n        for i in range(1, n):\\n            curr = max(curr, lft[i])\\n            lmax.append(curr)\\n            \\n        rmax, curr = [rgt[-1]], rgt[-1]\\n        for i in range(n - 2, -1, -1):\\n            curr = max(curr, rgt[i])\\n            rmax.append(curr)            \\n        rmax.reverse()\\n        \\n        maxp = 0  # The maximum cost we can SAVE.\\n        for i in range(n - 1):\\n            maxp = max(maxp, max(0, lmax[i]) + max(0, rmax[i + 1]))\\n\\n        return exp - maxp  # The overall cost is the MaximumCost - \"the maximum cost we can save\".\\n```\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\ndef minimumTime(self, A: str) -> int:\\n        n = len(A)\\n        if n == 1: return 1 if A == \\'1\\' else 0\\n        lft, rgt = [] * n, [] * n\\n        \\n        curr = 0\\n        for a in A:\\n            if a == \\'1\\':\\n                curr += 1\\n            else:\\n                curr -= 1\\n            lft.append(curr)\\n            \\n        curr = 0\\n        for a in A[::-1]:\\n            if a == \\'1\\':\\n                curr += 1\\n            else:\\n                curr -= 1\\n            rgt.append(curr)\\n        rgt.reverse()\\n\\n        exp = 2 * A.count(\\'1\\')   # MaximumCost, that is the cost of removing all cars with a cost of 2.\\n            \\n        lmax, curr = [lft[0]], lft[0]\\n        for i in range(1, n):\\n            curr = max(curr, lft[i])\\n            lmax.append(curr)\\n            \\n        rmax, curr = [rgt[-1]], rgt[-1]\\n        for i in range(n - 2, -1, -1):\\n            curr = max(curr, rgt[i])\\n            rmax.append(curr)            \\n        rmax.reverse()\\n        \\n        maxp = 0  # The maximum cost we can SAVE.\\n        for i in range(n - 1):\\n            maxp = max(maxp, max(0, lmax[i]) + max(0, rmax[i + 1]))\\n\\n        return exp - maxp  # The overall cost is the MaximumCost - \"the maximum cost we can save\".\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1748440,
                "title": "sliding-window",
                "content": "#### Solution 1: Sliding Window\\n**Intuition:** after removing \"dirty\" cars, we will have one or more consecutive \"clean\" cars.\\n \\nFirst, we calculate and store the minimum cost to remove `i` cars from the right (`vr`). \\n \\nThen, we run the sliding window algorithm, tracking cost to remove `i` cars from left (`cost_left`). For each window of \"clean\" cars, we can figure out the minimum cost to remove cars from left and right.\\n\\nHere is the example for `[01001010]`:\\n\\n![image](https://assets.leetcode.com/users/images/6b0134ce-2367-4776-97f8-5d9a1e9c3a6f_1644121903.5348299.png)\\n \\nWe track and return the minimum cost among all windows.\\n\\n**C++**\\n```cpp\\nint minimumTime(string s) {\\n    int sz = s.size(), res = sz, cost_left = 0;\\n    vector<int> vr(sz + 1);\\n    for (int i = sz - 1; i >= 0; --i)\\n        vr[i] = min(vr[i + 1] + 2 * (s[i] == \\'1\\'), sz - i);\\n    for (int i = 0, j = 0; i < sz; ++i) {\\n        if (s[i] == \\'1\\')\\n            cost_left = min(cost_left + 2, i + 1);\\n        res = min(res, cost_left + vr[i]);\\n    }\\n    return res;\\n}\\n```\\n\\nIf we look closer, we do not even need to compute the cost to remove cars from the right. We can just assume that we remove all cars starting from `i`.\\n\\nThis is because if it\\'s better to remove a car from the middle, the `cost_left` would already reflect that.\\n\\n**C++**\\n```cpp\\nint minimumTime(string s) {\\n    int sz = s.size(), res = sz, cost_left = 0;\\n    for (int i = 0, j = 0; i < sz; ++i) {\\n        if (s[i] == \\'1\\')\\n            cost_left = min(cost_left + 2, i + 1);\\n        res = min(res, cost_left + sz - i - 1);\\n    }\\n    return res;\\n}\\n```\\n\\n#### Solution 2: Kadane\\'s\\nWe can re-formulate this as the maximum subaray problem. See [DBabichev\\'s](https://leetcode.com/problems/minimum-time-to-remove-all-cars-containing-illegal-goods/discuss/1748424/Python-maximum-sum-on-subarray-explained) post for more details.\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def minimumTime(self, s):\\n        def minSum(nums):\\n            dp, dp_min = nums[0], nums[0]\\n            for i in range(1, len(nums)):\\n                dp = min(nums[i], nums[i] + dp)\\n                dp_min = min(dp, dp_min)\\n            return min(0, dp_min)\\n        return len(s) + minSum([1 if i == \"1\" else -1 for i in s])\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint minimumTime(string s) {\\n    int sz = s.size(), res = sz, cost_left = 0;\\n    vector<int> vr(sz + 1);\\n    for (int i = sz - 1; i >= 0; --i)\\n        vr[i] = min(vr[i + 1] + 2 * (s[i] == \\'1\\'), sz - i);\\n    for (int i = 0, j = 0; i < sz; ++i) {\\n        if (s[i] == \\'1\\')\\n            cost_left = min(cost_left + 2, i + 1);\\n        res = min(res, cost_left + vr[i]);\\n    }\\n    return res;\\n}\\n```\n```cpp\\nint minimumTime(string s) {\\n    int sz = s.size(), res = sz, cost_left = 0;\\n    for (int i = 0, j = 0; i < sz; ++i) {\\n        if (s[i] == \\'1\\')\\n            cost_left = min(cost_left + 2, i + 1);\\n        res = min(res, cost_left + sz - i - 1);\\n    }\\n    return res;\\n}\\n```\n```python\\nclass Solution:\\n    def minimumTime(self, s):\\n        def minSum(nums):\\n            dp, dp_min = nums[0], nums[0]\\n            for i in range(1, len(nums)):\\n                dp = min(nums[i], nums[i] + dp)\\n                dp_min = min(dp, dp_min)\\n            return min(0, dp_min)\\n        return len(s) + minSum([1 if i == \"1\" else -1 for i in s])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748434,
                "title": "java-simple-o-n-explained",
                "content": "```\\nclass Solution {\\n    public int minimumTime(String s) {\\n        int size = s.length();\\n        int [] cost = new int[size+1];\\n        \\n        // calculate the cost from left to right;\\n        for(int i=0;i<size;i++){ \\n            if(s.charAt(i) == \\'1\\'){\\n                cost[i+1] = Math.min(i+1, cost[i] + 2); //cost is min of length and spot removal cost\\n            }else{\\n                cost[i+1] = cost[i];\\n            }\\n        }\\n        \\n        int out = cost[size];\\n        // calculate the cost from right to left;\\n        int [] cost2 = new int[size+1];\\n        for(int i=size-1;i>=0;i--){\\n            if(s.charAt(i) == \\'1\\'){\\n                cost2[i] = Math.min(size-i , cost2[i+1] + 2 ); //cost is min of length and spot removal cost\\n            }else{\\n                cost2[i] = cost2[i+1];\\n            }\\n            // find the sum which is min so that it will be the optimal cost from both edges.\\n            out = Math.min(out, cost[i] + cost2[i]);\\n        }\\n\\n       \\n        return out;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minimumTime(String s) {\\n        int size = s.length();\\n        int [] cost = new int[size+1];\\n        \\n        // calculate the cost from left to right;\\n        for(int i=0;i<size;i++){ \\n            if(s.charAt(i) == \\'1\\'){\\n                cost[i+1] = Math.min(i+1, cost[i] + 2); //cost is min of length and spot removal cost\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1748444,
                "title": "python-c-o-n-dp-with-clear-explanation-and-intuition",
                "content": "Intuitively, we could find two points `left_bar` and `right_bar`, and then we should remove everything on the left of `left_bar` sequentially one-by-one (takes 1 unit of time each), so do the `right_bar`. And remove every `1` between these two bars point by point (takes 2 units of time each).\\n\\n![image](https://assets.leetcode.com/users/images/ef52326b-ef07-427c-a46b-20a2ef80c208_1644121810.9673846.png)\\n\\nHowever, if we try out every possible `left_bar` and `right_bar`, it will take O(N^2) and get TLE. So how can we improve our solution from here? Usually it needs **Greedy**, **Two Pointer** or **DP**, this time I choose **DP**.\\n\\nHow to do it?\\n\\nWe can construct a DP solution in which DP[i] records the best solution on the left of index `i` (may be combined with 1 unit steps and 2 units steps). And the total cost at this point will be `DP[i]` + `\\n cost to remove every 1 on the right of index i sequentially`.\\n\\n![image](https://assets.leetcode.com/users/images/12dd1e57-8a3b-4c4b-a8f7-71f4b4e15e17_1644121827.2402318.png)\\n\\nLet\\'s start solving the DP part!\\n\\n**State Definition:**\\nActually, we need another dimension for recording `sequentially` or `non-sequentially`\\n\\n`DP[0][i]`: The best we can get until index `i` by only sequentially removing\\n`DP[1][i]`: The best we can get until index `i` and it\\'s already removing some `1` non-sequentially  at some point before (includes this point)\\n\\n**Transition of States:**\\n`DP[0][i] = DP[0][i-1] + 1`: Since we need to keep removing sequentially, we need to take 1 more unit of time to remove it no matter `0` or `1`.\\n`DP[1][i] = min(DP[1][i-1], DP[0][i-1]) + (2 if only s[i] == \\'1\\')`: Since we allow non-sequential removing, which means, we can choose the best we can get at last step, and we can ignore `0` at current step, however, we need to cost **2** more units of time for removing `1` at current step.\\n\\nIn the end, we need another array which I called `suffix_cost` to record how much time we need to remove all the `1` on the right of index `i` sequentially. I think the code explained it well already. Below is my `python` and `c++` version of code.\\n\\n<iframe src=\"https://leetcode.com/playground/NQKwfpfE/shared\" frameBorder=\"0\" width=\"800\" height=\"400\"></iframe>\\n\\nNotes: I let DP[0] as the initial value, so I iterated DP from `1 to N` instead of `0 to N-1`. It\\'s a little useful trick for simplifying the DP code.\\n\\nHope it helps :)\\n\\nActually, I just find out The Great @lee215 give us the [greedy](https://leetcode.com/problems/minimum-time-to-remove-all-cars-containing-illegal-goods/discuss/1748704/JavaC%2B%2BPython-One-Pass-O(1)-Space) version and it will be much simpler! But wish you can still learn something from my post.\\n\\nThe initution of Greedy approach is almost the same, since the best we can do for each `1` is still the following two:\\n1. remove it sequentially: i + 1\\n2. remove this point non-sequentially: `last best cost` + 2",
                "solutionTags": [],
                "code": "Intuitively, we could find two points `left_bar` and `right_bar`, and then we should remove everything on the left of `left_bar` sequentially one-by-one (takes 1 unit of time each), so do the `right_bar`. And remove every `1` between these two bars point by point (takes 2 units of time each).\\n\\n![image](https://assets.leetcode.com/users/images/ef52326b-ef07-427c-a46b-20a2ef80c208_1644121810.9673846.png)\\n\\nHowever, if we try out every possible `left_bar` and `right_bar`, it will take O(N^2) and get TLE. So how can we improve our solution from here? Usually it needs **Greedy**, **Two Pointer** or **DP**, this time I choose **DP**.\\n\\nHow to do it?\\n\\nWe can construct a DP solution in which DP[i] records the best solution on the left of index `i` (may be combined with 1 unit steps and 2 units steps). And the total cost at this point will be `DP[i]` + `\\n cost to remove every 1 on the right of index i sequentially`.\\n\\n![image](https://assets.leetcode.com/users/images/12dd1e57-8a3b-4c4b-a8f7-71f4b4e15e17_1644121827.2402318.png)\\n\\nLet\\'s start solving the DP part!\\n\\n**State Definition:**\\nActually, we need another dimension for recording `sequentially` or `non-sequentially`\\n\\n`DP[0][i]`: The best we can get until index `i` by only sequentially removing\\n`DP[1][i]`: The best we can get until index `i` and it\\'s already removing some `1` non-sequentially  at some point before (includes this point)\\n\\n**Transition of States:**\\n`DP[0][i] = DP[0][i-1] + 1`: Since we need to keep removing sequentially, we need to take 1 more unit of time to remove it no matter `0` or `1`.\\n`DP[1][i] = min(DP[1][i-1], DP[0][i-1]) + (2 if only s[i] == \\'1\\')`: Since we allow non-sequential removing, which means, we can choose the best we can get at last step, and we can ignore `0` at current step, however, we need to cost **2** more units of time for removing `1` at current step.\\n\\nIn the end, we need another array which I called `suffix_cost` to record how much time we need to remove all the `1` on the right of index `i` sequentially. I think the code explained it well already. Below is my `python` and `c++` version of code.\\n\\n<iframe src=\"https://leetcode.com/playground/NQKwfpfE/shared\" frameBorder=\"0\" width=\"800\" height=\"400\"></iframe>\\n\\nNotes: I let DP[0] as the initial value, so I iterated DP from `1 to N` instead of `0 to N-1`. It\\'s a little useful trick for simplifying the DP code.\\n\\nHope it helps :)\\n\\nActually, I just find out The Great @lee215 give us the [greedy](https://leetcode.com/problems/minimum-time-to-remove-all-cars-containing-illegal-goods/discuss/1748704/JavaC%2B%2BPython-One-Pass-O(1)-Space) version and it will be much simpler! But wish you can still learn something from my post.\\n\\nThe initution of Greedy approach is almost the same, since the best we can do for each `1` is still the following two:\\n1. remove it sequentially: i + 1\\n2. remove this point non-sequentially: `last best cost` + 2",
                "codeTag": "Unknown"
            },
            {
                "id": 1748475,
                "title": "c-o-n-short-and-sweet-dp-with-sliding-window",
                "content": "**Explanation** - \\n**My dp[i] stores the minimum time to remove all illegal goods from index i to n-1, where I can only remove from right.** I loop from the rightmost index. So, for any index i the transition is as follows - \\n1. If it\\'s a **\\'0\\'** then **dp[i]=dp[i+1]**\\n2. If it\\'s a **\\'1\\'** then you have two options - **either you consider this element as a middle one and add 2 to dp[i+1]** or **you remove all elements**. Hence, **dp[i]=min(dp[i+1]+2, n-i)**\\nNow, we can also remove elements from left. So, we can loop over the vector. **When we reach any index i, we will consider that we have removed all elements from 0 to i from the leftside.** So, our time for that index will be **i+1+dp[i+1]**. Since, we have removed all elements until i, we need to just consider elements from i+1 and hence we are adding the dp[i+1] to our i+1. \\nWe can loop for all i and minimize the final answer.\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int n=s.length();\\n        vector<int>dp(n,0);\\n        if(s[n-1]==\\'0\\'){\\n            dp[n-1]=0;\\n        } else {\\n            dp[n-1]=1;\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            if(s[i]==\\'0\\')dp[i]=dp[i+1];\\n            if(s[i]==\\'1\\'){\\n                dp[i]=2+dp[i+1]; // consider current index to be a middle one and remove\\n                dp[i]=min(dp[i],n-i); // or remove all to the right\\n            }\\n        }\\n\\t\\t// now go from left to right\\n        int ans=dp[0];\\n        for(int i=0;i<n-1;i++){\\n            ans=min(ans,i+1+dp[i+1]); // cost of removing all from left and dp[i+1]\\n        }\\n        ans=min(ans,n); // taking overall minimum\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int n=s.length();\\n        vector<int>dp(n,0);\\n        if(s[n-1]==\\'0\\'){\\n            dp[n-1]=0;\\n        } else {\\n            dp[n-1]=1;\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            if(s[i]==\\'0\\')dp[i]=dp[i+1];\\n            if(s[i]==\\'1\\'){\\n                dp[i]=2+dp[i+1]; // consider current index to be a middle one and remove\\n                dp[i]=min(dp[i],n-i); // or remove all to the right\\n            }\\n        }\\n\\t\\t// now go from left to right\\n        int ans=dp[0];\\n        for(int i=0;i<n-1;i++){\\n            ans=min(ans,i+1+dp[i+1]); // cost of removing all from left and dp[i+1]\\n        }\\n        ans=min(ans,n); // taking overall minimum\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748623,
                "title": "java-o-n-compute-left-compute-right-aggregate",
                "content": "The problem looks difficult because we have two ends to consider.\\n\\nThe way I thought about this problem is as follows: The minimum cost is found at point `p`, if we optimally remove 1\\'s from 0..p and p+1..n\\nIt is done in three steps:\\n\\n1. We optimally remove from the left side, assuming the right trimming isn\\'t available.\\n2. Then, we repeat: we remove from the right side, assuming the left trimming isn\\'t available.\\n3. Then, we find the minimum. We don\\'t know what the optimal `p` index is. So, we loop through all potential `p`, namely 0 to n and then find the minimum.\\n\\n\\n```\\nclass Solution {\\n    public int minimumTime(String s) {\\n        int n = s.length();\\n        int min = s.length();\\n        int[] nums = new int[n];\\n        for (int i = 0; i < n; i++)\\n            nums[i] = s.charAt(i) - \\'0\\';\\n\\n\\t\\t// step1\\n        int[] leftOptimized = new int[n + 2];\\n        for (int i = 1; i <= n; i++) {\\n            leftOptimized[i] = Math.min(i, leftOptimized[i - 1] + (nums[i - 1] == 1? 2: 0));\\n        }\\n\\n\\t\\t// step2\\n        int[] rightOptimized = new int[n + 2];\\n        for (int i = n; i > 0; i--) {\\n            rightOptimized[i] = Math.min(n - i + 1, rightOptimized[i + 1] + (nums[i - 1] == 1? 2: 0));\\n        }\\n\\n\\t\\t// step3\\n        for (int p = 0; p <= n; p++) {\\n            min = Math.min(min, leftOptimized[p] + rightOptimized[p + 1]);\\n        }\\n\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumTime(String s) {\\n        int n = s.length();\\n        int min = s.length();\\n        int[] nums = new int[n];\\n        for (int i = 0; i < n; i++)\\n            nums[i] = s.charAt(i) - \\'0\\';\\n\\n\\t\\t// step1\\n        int[] leftOptimized = new int[n + 2];\\n        for (int i = 1; i <= n; i++) {\\n            leftOptimized[i] = Math.min(i, leftOptimized[i - 1] + (nums[i - 1] == 1? 2: 0));\\n        }\\n\\n\\t\\t// step2\\n        int[] rightOptimized = new int[n + 2];\\n        for (int i = n; i > 0; i--) {\\n            rightOptimized[i] = Math.min(n - i + 1, rightOptimized[i + 1] + (nums[i - 1] == 1? 2: 0));\\n        }\\n\\n\\t\\t// step3\\n        for (int p = 0; p <= n; p++) {\\n            min = Math.min(min, leftOptimized[p] + rightOptimized[p + 1]);\\n        }\\n\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748445,
                "title": "easy-dp-in-c",
                "content": "For each position i, we have three opertions: 1. delete from left(time: i), 2. delete from right(time: size - i), 3. Remove(dp[i - 1] + 2 || dp[i + 1] + 2, if exist). So maintain two dp array,\\none in sequence and the other reversed. And the ans is the minimum sum of corespoding index of these two dp array.\\n\\n```\\ntypedef long long ll;\\nconst int mod=1000000007;\\n\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int size = s.length();\\n        \\n        vector<int> dp1(size + 1), dp2(size + 1);\\n        for(int i = 1; i <= size; i++){\\n            if(s[i - 1] == \\'0\\')\\n                dp1[i] = dp1[i - 1];\\n            else\\n                dp1[i] = min(i, dp1[i - 1] + 2);\\n        }\\n        \\n        reverse(s.begin(), s.end());\\n        for(int i = 1; i <= size; i++){\\n            if(s[i - 1] == \\'0\\')\\n                dp2[i] = dp2[i - 1];\\n            else\\n                dp2[i] = min(i, dp2[i - 1] + 2);\\n        }\\n        reverse(dp2.begin(), dp2.end());\\n\\n        int ans = INT_MAX;\\n        for(int i = 0; i <= size; i++){\\n            ans = min(ans, dp1[i] + dp2[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ntypedef long long ll;\\nconst int mod=1000000007;\\n\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int size = s.length();\\n        \\n        vector<int> dp1(size + 1), dp2(size + 1);\\n        for(int i = 1; i <= size; i++){\\n            if(s[i - 1] == \\'0\\')\\n                dp1[i] = dp1[i - 1];\\n            else\\n                dp1[i] = min(i, dp1[i - 1] + 2);\\n        }\\n        \\n        reverse(s.begin(), s.end());\\n        for(int i = 1; i <= size; i++){\\n            if(s[i - 1] == \\'0\\')\\n                dp2[i] = dp2[i - 1];\\n            else\\n                dp2[i] = min(i, dp2[i - 1] + 2);\\n        }\\n        reverse(dp2.begin(), dp2.end());\\n\\n        int ans = INT_MAX;\\n        for(int i = 0; i <= size; i++){\\n            ans = min(ans, dp1[i] + dp2[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749752,
                "title": "c-o-n-easy-dp-solution-with-explanation",
                "content": "As the problem states we need to remove illegal car from either: \\n\\t1. left [cost = 1]\\n\\t2. right [cost = 1]\\n\\t3. anywhere in between [cost = 2]\\n\\nSo, we will create two arrays which will store the cost from left-to-right[0...i] and right-to-left[i+1....n-1] traversal in two different pass.\\n\\nFor left-to-right array:\\n\\t1. Initialise the cost of array to 0.\\n\\t2. If `s[0] == \\'1\\' `means we can directly remove it from the left end which would be minimum cost = 1.\\n\\t3.` for (i = 1 to n - 1) `// we have 2 choices\\n\\t\\ta. `Either remove all the elements from left upto i which would cost = i + 1`\\n\\t\\tb. `Consider the previous cost + remove current element by cost = 2`\\n\\n\\t\\ti.e left_to_right[i] = min(left_to_right[i - 1] + 2, i + 1)\\n\\t\\t\\nDo similar thing for right-to-left array in reverse way\\n\\nAt the end, take the \\n\\n1. `min of(left_to_right[n - 1], right_to_left[0])`\\n2. `for (i = 0 to n - 2) `\\n\\t\\t`min of (left_to_right[i] + right_to_left[i+1])` \\n\\nExample:\\n```\\nindex          0  1  2  3  4  5  6\\nstring         1  1  0  0  1  0  1\\nleft_to_right  1  2  2  2  4  4  6\\n\\t\\t\\t    \\\\  \\\\  \\\\  \\\\  \\\\  \\\\\\nright_to_left  7  5  3  3  3  1  1\\n```\\n\\nCode:\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int n = s.size();\\n        vector<int> left_to_right(n, 0);\\n        vector<int> right_to_left(n, 0);\\n        \\n        if(s[0] == \\'1\\')\\n            left_to_right[0] = 1;\\n        \\n        for(int i = 1; i < n; i++)\\n            if(s[i] == \\'1\\')\\n                left_to_right[i] = min(left_to_right[i - 1] + 2, i + 1);\\n            else\\n                left_to_right[i] = left_to_right[i - 1];\\n        \\n        if(s[n - 1] == \\'1\\')\\n            right_to_left[n - 1] = 1;\\n        \\n        for(int i = n - 2; i >= 0; i--)\\n            if(s[i] == \\'1\\')\\n                right_to_left[i] = min(right_to_left[i + 1] + 2, n - i);\\n            else\\n                right_to_left[i] = right_to_left[i + 1];\\n        \\n        int ans = INT_MIN;\\n        ans = min(right_to_left[0], left_to_right[n - 1]);\\n        \\n        for(int i = 0; i < n - 1; i++)\\n        {\\n            ans = min(ans, left_to_right[i] + right_to_left[i + 1]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nPlease give suggestions, if any! I hope this helps! :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nindex          0  1  2  3  4  5  6\\nstring         1  1  0  0  1  0  1\\nleft_to_right  1  2  2  2  4  4  6\\n\\t\\t\\t    \\\\  \\\\  \\\\  \\\\  \\\\  \\\\\\nright_to_left  7  5  3  3  3  1  1\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int n = s.size();\\n        vector<int> left_to_right(n, 0);\\n        vector<int> right_to_left(n, 0);\\n        \\n        if(s[0] == \\'1\\')\\n            left_to_right[0] = 1;\\n        \\n        for(int i = 1; i < n; i++)\\n            if(s[i] == \\'1\\')\\n                left_to_right[i] = min(left_to_right[i - 1] + 2, i + 1);\\n            else\\n                left_to_right[i] = left_to_right[i - 1];\\n        \\n        if(s[n - 1] == \\'1\\')\\n            right_to_left[n - 1] = 1;\\n        \\n        for(int i = n - 2; i >= 0; i--)\\n            if(s[i] == \\'1\\')\\n                right_to_left[i] = min(right_to_left[i + 1] + 2, n - i);\\n            else\\n                right_to_left[i] = right_to_left[i + 1];\\n        \\n        int ans = INT_MIN;\\n        ans = min(right_to_left[0], left_to_right[n - 1]);\\n        \\n        for(int i = 0; i < n - 1; i++)\\n        {\\n            ans = min(ans, left_to_right[i] + right_to_left[i + 1]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600598,
                "title": "dp-prefix-suffix-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int n = s.length();\\n        vector<int> l(n+1,0),r(n+1,0);\\n        int i,x=0;\\n        for(i = 0; i < n; i++){//calculate for prefix\\n            if(s[i]==\\'1\\'){\\n                x++;\\n                l[i+1] = min(l[i]+2,i+1);\\n            }else{\\n                l[i+1] = l[i];\\n                x = 0;\\n            }\\n        }for(i = n-1; i >= 0; i--){//calculate for suffix\\n            if(s[i]==\\'1\\'){\\n                x++;\\n                r[i] = min(r[i+1]+2,n-i);\\n            }else{\\n                r[i] = r[i+1];\\n                x = 0;\\n            }\\n        }\\n        int ans = INT_MAX;\\n        for(i = 0; i <= n; i++){\\n            // cout<<l[i]<<\" \"<<r[i]<<\" # \";\\n            ans = min(ans,l[i]+r[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int n = s.length();\\n        vector<int> l(n+1,0),r(n+1,0);\\n        int i,x=0;\\n        for(i = 0; i < n; i++){//calculate for prefix\\n            if(s[i]==\\'1\\'){\\n                x++;\\n                l[i+1] = min(l[i]+2,i+1);\\n            }else{\\n                l[i+1] = l[i];\\n                x = 0;\\n            }\\n        }for(i = n-1; i >= 0; i--){//calculate for suffix\\n            if(s[i]==\\'1\\'){\\n                x++;\\n                r[i] = min(r[i+1]+2,n-i);\\n            }else{\\n                r[i] = r[i+1];\\n                x = 0;\\n            }\\n        }\\n        int ans = INT_MAX;\\n        for(i = 0; i <= n; i++){\\n            // cout<<l[i]<<\" \"<<r[i]<<\" # \";\\n            ans = min(ans,l[i]+r[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1764603,
                "title": "c-prefix-and-suffix-dp-solution",
                "content": "The problem can be solved by dissecting left part and right part, and storing into 2 DP state array. \\n\\nFor the left part (prefix): the transition state function is \\n* `if s[i]=0, pre[i+1] = pre[i]`\\n* `if s[i]=1, pre[i+1] = min(pre[i]+2, i+1)`\\n\\n`pre[i]+2` means we use 2 units to remove, `i+1` means we remove cars from index 0 to index i. \\nThe reason we put `i+1`, is because index starts from 0. \\n\\nFor the right part, the transition function is \\n* `if s[i]=0, suf[i] = suf[i+1]`\\n* `if s[i]=1, suf[i] = min(suf[i+1]+2, size-i)`\\n\\nThe res would be `pre[i]+suf[i+1]` , and we iterate the entire DP array \\n\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        \\n        const int size = s.size();\\n        \\n        if (size == 1)\\n        {\\n            return (s[0] == \\'0\\') ? 0 : 1;\\n        }\\n        \\n        vector<int> pre(size, 0);\\n        vector<int> suf(size, 0);\\n        \\n        pre[0] = (s[0] == \\'0\\') ? 0 : 1;\\n        \\n        for (int i = 1; i < size; ++i)\\n        {\\n            if (s[i] == \\'0\\')\\n            {\\n                pre[i] = pre[i-1];\\n            }\\n            else\\n            {\\n                pre[i] = std::min(pre[i-1]+2, i+1);\\n            }\\n        }\\n        \\n        suf[size-1] = (s[size-1] == \\'0\\') ? 0 : 1;\\n        \\n        for (int i = size-2; i >= 0; --i)\\n        {\\n            if (s[i] == \\'0\\')\\n            {\\n                suf[i] = suf[i+1];\\n            }\\n            else\\n            {\\n                suf[i] = std::min(suf[i+1]+2, size-i);\\n            }\\n        }\\n        \\n        int res = INT_MAX;\\n        for (int i = 0; i < size-1; ++i)\\n        {\\n            res = std::min(res, pre[i]+suf[i+1]);\\n        }\\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        \\n        const int size = s.size();\\n        \\n        if (size == 1)\\n        {\\n            return (s[0] == \\'0\\') ? 0 : 1;\\n        }\\n        \\n        vector<int> pre(size, 0);\\n        vector<int> suf(size, 0);\\n        \\n        pre[0] = (s[0] == \\'0\\') ? 0 : 1;\\n        \\n        for (int i = 1; i < size; ++i)\\n        {\\n            if (s[i] == \\'0\\')\\n            {\\n                pre[i] = pre[i-1];\\n            }\\n            else\\n            {\\n                pre[i] = std::min(pre[i-1]+2, i+1);\\n            }\\n        }\\n        \\n        suf[size-1] = (s[size-1] == \\'0\\') ? 0 : 1;\\n        \\n        for (int i = size-2; i >= 0; --i)\\n        {\\n            if (s[i] == \\'0\\')\\n            {\\n                suf[i] = suf[i+1];\\n            }\\n            else\\n            {\\n                suf[i] = std::min(suf[i+1]+2, size-i);\\n            }\\n        }\\n        \\n        int res = INT_MAX;\\n        for (int i = 0; i < size-1; ++i)\\n        {\\n            res = std::min(res, pre[i]+suf[i+1]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1760945,
                "title": "intuitive-and-detailed-explanation-c-8-lines-time-o-n-space-o-1",
                "content": "**Note**:\\n1. Current `index = i` and `s[i] is \\'1\\'`\\n2. `n = s.length()`\\n\\n**Some clues that can help construct the solution**\\n\\n1. If current element  is removed from the `left` then for all elements with index  `j < i` the *cost will be 0*\\n2. If current  is removed from the `right`  then for all elements with index  `j > i` the *cost will be 0*\\n\\n**Solution**\\nLet `cost = cost incurred till now`  and `total_cost = cost for the whole string`\\n\\nWhat can we do at current index?\\n\\n1. **Remove from the left**\\n\\t=> `cost = i + 1` (read the clues above)\\n\\t=> cannot say about total_cost yet as further string is not traversed\\n\\t\\n2. **Remove from the middle**\\n\\t=> `cost = 2 + cost`\\n\\t=> cannot say about total_cost yet as further string is not traversed\\n\\t\\n3. **Remove from the right**\\n\\t=> we do not need to traverse further if we removed from right (read clues)\\n\\t=> `total_cost = min(total_cost, cost + (n-i))`\\n\\t\\nNow, lets construct the code\\n\\n**Code**\\n```\\nint minimumTime(string &s) {\\n        int cost = 0, total_cost = INT_MAX, n = s.length();\\n        for(int i = 0; i < n; i += 1){\\n            if(s[i] == \\'1\\'){\\n                total_cost = min(total_cost, cost + (n-i)); // if removed from right\\n                cost = min(i+1, 2+cost); // left cost = i + 1 and mid cost = 2 + cost\\n            }\\n        }\\n        return min(total_cost, cost); // now we have completely traversed string\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nint minimumTime(string &s) {\\n        int cost = 0, total_cost = INT_MAX, n = s.length();\\n        for(int i = 0; i < n; i += 1){\\n            if(s[i] == \\'1\\'){\\n                total_cost = min(total_cost, cost + (n-i)); // if removed from right\\n                cost = min(i+1, 2+cost); // left cost = i + 1 and mid cost = 2 + cost\\n            }\\n        }\\n        return min(total_cost, cost); // now we have completely traversed string\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1760832,
                "title": "java-recursive-and-memoization-implementation",
                "content": "```\\n    private static int minTime(String s, int idx, int stage) {\\n        if (idx == s.length()) return 0;\\n\\n        int requiredTime = Integer.MAX_VALUE;\\n        char curr = s.charAt(idx);\\n        for (int i = stage; i < 3; i++) {\\n            int temp = Integer.MAX_VALUE;\\n            if (i == 0 || i == 2) {\\n                temp = 1 + minTime(s, idx + 1, i);\\n            } else if (i == 1) {\\n                if (curr == \\'1\\') {\\n                    temp = 2 + minTime(s, idx + 1, i);\\n                } else {\\n                    temp = minTime(s, idx + 1, i);\\n                }\\n            }\\n            requiredTime = Math.min(requiredTime, temp);\\n        }\\n        return requiredTime;\\n    }\\n```\\n\\nmemoization :\\n\\n```\\nclass Solution {\\n    private int[][] dp;\\n    private int minTime(String s, int idx, int stage) {\\n        if (idx == s.length()) return 0;\\n        else if(dp[idx][stage] != -1)   return dp[idx][stage];\\n\\n        int requiredTime = Integer.MAX_VALUE;\\n        char curr = s.charAt(idx);\\n        for (int i = stage; i < 3; i++) {\\n            int temp = Integer.MAX_VALUE;\\n            if (i == 0 ||  i == 2) {\\n                temp = 1 + minTime(s, idx + 1, i);\\n            } else if (i == 1) {\\n                if (curr == \\'1\\') {\\n                    temp = 2 + minTime(s, idx + 1, i);\\n                } else {\\n                    temp = minTime(s, idx + 1, i);\\n                }\\n            } \\n            requiredTime = Math.min(requiredTime, temp);\\n        }\\n        return dp[idx][stage] = requiredTime;\\n    }\\n    public int minimumTime(String s) {\\n        int n = s.length()+1;\\n        dp = new int[n][3];\\n        for(int[] dpArr : dp)   Arrays.fill(dpArr,-1);\\n        return minTime(s,0,0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n    private static int minTime(String s, int idx, int stage) {\\n        if (idx == s.length()) return 0;\\n\\n        int requiredTime = Integer.MAX_VALUE;\\n        char curr = s.charAt(idx);\\n        for (int i = stage; i < 3; i++) {\\n            int temp = Integer.MAX_VALUE;\\n            if (i == 0 || i == 2) {\\n                temp = 1 + minTime(s, idx + 1, i);\\n            } else if (i == 1) {\\n                if (curr == \\'1\\') {\\n                    temp = 2 + minTime(s, idx + 1, i);\\n                } else {\\n                    temp = minTime(s, idx + 1, i);\\n                }\\n            }\\n            requiredTime = Math.min(requiredTime, temp);\\n        }\\n        return requiredTime;\\n    }\\n```\n```\\nclass Solution {\\n    private int[][] dp;\\n    private int minTime(String s, int idx, int stage) {\\n        if (idx == s.length()) return 0;\\n        else if(dp[idx][stage] != -1)   return dp[idx][stage];\\n\\n        int requiredTime = Integer.MAX_VALUE;\\n        char curr = s.charAt(idx);\\n        for (int i = stage; i < 3; i++) {\\n            int temp = Integer.MAX_VALUE;\\n            if (i == 0 ||  i == 2) {\\n                temp = 1 + minTime(s, idx + 1, i);\\n            } else if (i == 1) {\\n                if (curr == \\'1\\') {\\n                    temp = 2 + minTime(s, idx + 1, i);\\n                } else {\\n                    temp = minTime(s, idx + 1, i);\\n                }\\n            } \\n            requiredTime = Math.min(requiredTime, temp);\\n        }\\n        return dp[idx][stage] = requiredTime;\\n    }\\n    public int minimumTime(String s) {\\n        int n = s.length()+1;\\n        dp = new int[n][3];\\n        for(int[] dpArr : dp)   Arrays.fill(dpArr,-1);\\n        return minTime(s,0,0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327881,
                "title": "time-o-n-space-o-n-suffix-prefix-c-dp-easy-to-understand",
                "content": "````\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int n = s.size();\\n        vector<int>left(n,0) , right(n,0);\\n        if(s[0]==\\'1\\')\\n            left[0] = 1;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(s[i]==\\'1\\')\\n                left[i] = min(left[i-1]+2 , i+1);\\n            else\\n                left[i] = left[i-1];\\n        }\\n        \\n        if(s[n-1]==\\'1\\')\\n            right[n-1]=1;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(s[i]==\\'1\\')\\n                right[i] = min(right[i+1]+2,n-i);\\n            else\\n                right[i] = right[i+1];\\n        }\\n        int ansMIN = INT_MAX;\\n        ansMIN = min(left[n-1],right[0]);\\n        for(int i=0;i<=n-2;i++)\\n        {\\n            ansMIN = min(ansMIN , left[i] + right[i+1]);\\n        }\\n        return ansMIN;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Suffix Array"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int n = s.size();\\n        vector<int>left(n,0) , right(n,0);\\n        if(s[0]==\\'1\\')\\n            left[0] = 1;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(s[i]==\\'1\\')\\n                left[i] = min(left[i-1]+2 , i+1);\\n            else\\n                left[i] = left[i-1];\\n        }\\n        \\n        if(s[n-1]==\\'1\\')\\n            right[n-1]=1;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(s[i]==\\'1\\')\\n                right[i] = min(right[i+1]+2,n-i);\\n            else\\n                right[i] = right[i+1];\\n        }\\n        int ansMIN = INT_MAX;\\n        ansMIN = min(left[n-1],right[0]);\\n        for(int i=0;i<=n-2;i++)\\n        {\\n            ansMIN = min(ansMIN , left[i] + right[i+1]);\\n        }\\n        return ansMIN;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2307629,
                "title": "beats-100-other-solutions",
                "content": "```\\nclass Solution:\\n    def minimumTime(self, s: str) -> int:\\n        c = 0\\n        m = 0\\n        for i in s:\\n            c += 1 if i==\\'1\\' else -1\\n            if(c<m):\\n                m = c\\n            if(c>0):\\n                c = 0\\n        return len(s)+m\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, s: str) -> int:\\n        c = 0\\n        m = 0\\n        for i in s:\\n            c += 1 if i==\\'1\\' else -1\\n            if(c<m):\\n                m = c\\n            if(c>0):\\n                c = 0\\n        return len(s)+m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1758032,
                "title": "c-easy-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int n=s.size();\\n        vector<int>left(n,0), right(n,0);//create prefix and suffix vector\\n        //if first index is 1 then initialize prefix first with 1\\n        if(s[0]==\\'1\\')\\n        {\\n            left[0]=1;\\n        }\\n        //traverse for all other elements\\n        for(int i=1;i<n;i++)\\n        {\\n            if(s[i]==\\'1\\')\\n            {//take mimi\\n                left[i]=min(left[i-1]+2,i+1);//take min of two choices i.e choose from middle or delete all \\n            }\\n            else\\n            {\\n                left[i]=left[i-1];//if its zero we dont add anything \\n            }\\n        }\\n        //if last index is 1 then initialize suffix last with 1\\n        if(s[n-1]==\\'1\\')\\n        {\\n            right[n-1]=1;\\n        }\\n        //traverse for all other elements\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(s[i]==\\'1\\')\\n            {\\n                right[i]=min(right[i+1]+2,n-i);//take min of two choices i.e choose from middle or delete all \\n            }\\n            else\\n            {\\n                right[i]=right[i+1];//if its zero we dont add anything \\n            }\\n        }\\n        int ans=INT_MAX;\\n        ans=min(left[n-1],right[0]);\\n        for(int i=0;i<=n-2;i++)\\n        {\\n            //ans will be left upto middle + middle to right\\n            ans=min(ans,left[i]+right[i+1]);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int n=s.size();\\n        vector<int>left(n,0), right(n,0);//create prefix and suffix vector\\n        //if first index is 1 then initialize prefix first with 1\\n        if(s[0]==\\'1\\')\\n        {\\n            left[0]=1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1748892,
                "title": "go-find-the-subarray-with-minimum-cost",
                "content": "The goal is to find a subarray that has fewer \\'1\\'s but more \\'0\\'s.\\nWe want to find a subarray [i, j) such that when we removed every \\'1\\'s in [i, j), and every \\'1\\'s and \\'0\\'s in [0, i) and [j, n), it will cost us the least. Say there are `x` \\'1\\'s and `y` \\'0\\'s in [i, j), the total cost is\\n`i + (n - j) + 2 *  x`\\nwhich is\\n`n - (j - i) + 2 * x = n - (x + y) + 2 * x = n + x - y`\\nNow it\\'s clear that we want to find a subarray with mininum `n + x - y`.\\n```\\nfunc minimumTime(s string) int {\\n    cost := 0\\n    min_cost := 0\\n    for _, ch := range s {\\n        if ch == \\'1\\' {\\n            cost = min(1, cost + 1)\\n        } else {\\n            cost = min(-1, cost - 1)\\n        }\\n        min_cost = min(min_cost, cost)\\n    }\\n    return len(s) + min_cost\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    } else {\\n        return b\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc minimumTime(s string) int {\\n    cost := 0\\n    min_cost := 0\\n    for _, ch := range s {\\n        if ch == \\'1\\' {\\n            cost = min(1, cost + 1)\\n        } else {\\n            cost = min(-1, cost - 1)\\n        }\\n        min_cost = min(min_cost, cost)\\n    }\\n    return len(s) + min_cost\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    } else {\\n        return b\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1748727,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int n=s.size();\\n        int cnt=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(s[i]==\\'1\\')\\n                cnt++;\\n        }\\n        int ans1=n;\\n        vector<int>dp(n,0);\\n        if(s[0]==\\'1\\')\\n            dp[0]=1;\\n        for(int i=1; i<n; i++)\\n        {\\n            if(s[i]==\\'1\\')\\n                dp[i]=min(i+1,dp[i-1]+2);\\n            else\\n                dp[i]=dp[i-1];\\n        }\\n        \\n        vector<int>rdp(n,0);\\n        if(s[n-1]==\\'1\\')\\n            rdp[n-1]=1;\\n        for(int i=n-2; i>=0; i--)\\n        {\\n            if(s[i]==\\'1\\')\\n                rdp[i]=min(n-i,rdp[i+1]+2);\\n            else\\n                rdp[i]=rdp[i+1];\\n        }\\n        \\n        vector<pair<int,int>>ans;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(s[i]==\\'1\\')\\n            {\\n                ans.push_back({dp[i],rdp[i]});\\n            }\\n        }\\n        ans1=min(rdp[0],dp[n-1]);\\n        \\n        for(int i=0; i<cnt-1; i++)\\n        {\\n            ans1=min(ans1,ans[i].first+ans[i+1].second);\\n        }\\n        return ans1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int n=s.size();\\n        int cnt=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(s[i]==\\'1\\')\\n                cnt++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2483486,
                "title": "c-easy-to-understand-comments-added-kadanes-algo",
                "content": "// time =  1*left + 2*middle(cntains 1s) + 1*right\\n// time = left + middle + right + 2*middle(contains 1s) - middle;\\n// time = n + 2*middle(contains 1s) - middle;\\n// time = n + 2*middle(contains 1s) - (middle(contains 1s) + middle(contains 0s));\\n// time = n +  middle(contains 1s) - middle(contains 0s);\\n\\n// to minimize time  we need to minimize  (middle(contains 1s) - middle(contains 0s));\\n\\n// ques. reduce to smallest subarray sum; subarr with minimum sum \\n// for this we use kadanes algorithm but in opposite fasion\\n\\n\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int n = s.size();\\n        \\n        vector<int> temp(n,1);\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'0\\'){\\n                temp[i] = -1;\\n            }\\n        }\\n        \\n        int res = n;\\n        int sum = 0 , mini = 0;   // mini stores subarray with minimum sum possible\\n        \\n        // kadanes algorithm but in opposite fasion\\n        for(auto ele : temp){\\n            sum += ele;\\n            mini = min(mini , sum);\\n            if(sum > 0)sum = 0;\\n        }\\n        \\n        return res + mini;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int n = s.size();\\n        \\n        vector<int> temp(n,1);\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'0\\'){\\n                temp[i] = -1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2102404,
                "title": "fully-explained-dp-simple-logic-cpp",
                "content": "Intuition here is in optimal case we will be removing some cars from starting some from end and some from in between with cost=2.\\nWe can simply calculte it with creating two vector, front(n) for calculating the min cost while removing from starting or random position till ith car and back(n) for calculating the min cost while removing from end or random position till ith car.\\nAfter doing the both calculation the optimal case will be min of front[i]+back[i] where i=0 to n\\n\\nPFB my code for your refernce:\\n\\n```\\nclass Solution {\\npublic:\\n\\n    int minimumTime(string s) {\\n        int n=s.size();\\n        vector<int> front(n,0),back(n,0);\\n        if(s[0]==\\'1\\') front[0]=1;\\n        for(int i=1;i<n;i++)\\n            if(s[i]==\\'1\\')\\n                front[i]=min(i+1,front[i-1]+2);\\n            else front[i]=front[i-1];\\n        if(s[n-1]==\\'1\\') back[n-1]=1;\\n        for(int i=n-2;i>=0;i--)\\n            if(s[i]==\\'1\\')\\n                back[i]=min(n-i,back[i+1]+2);\\n            else back[i]=back[i+1];\\n        int ans=min(front[n-1],back[0]);\\n        // for(auto x:front ) cout<<x<<\" \";cout<<\"\\\\n\";\\n        // for(auto x:back ) cout<<x<<\" \";cout<<\"\\\\n\";\\n        for(int i=0;i<n-1;i++)\\n            ans=min(ans,front[i]+back[i+1]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int minimumTime(string s) {\\n        int n=s.size();\\n        vector<int> front(n,0),back(n,0);\\n        if(s[0]==\\'1\\') front[0]=1;\\n        for(int i=1;i<n;i++)\\n            if(s[i]==\\'1\\')\\n                front[i]=min(i+1,front[i-1]+2);\\n            else front[i]=front[i-1];\\n        if(s[n-1]==\\'1\\') back[n-1]=1;\\n        for(int i=n-2;i>=0;i--)\\n            if(s[i]==\\'1\\')\\n                back[i]=min(n-i,back[i+1]+2);\\n            else back[i]=back[i+1];\\n        int ans=min(front[n-1],back[0]);\\n        // for(auto x:front ) cout<<x<<\" \";cout<<\"\\\\n\";\\n        // for(auto x:back ) cout<<x<<\" \";cout<<\"\\\\n\";\\n        for(int i=0;i<n-1;i++)\\n            ans=min(ans,front[i]+back[i+1]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2021193,
                "title": "python3-dp-with-explanation",
                "content": "dp[i] means the minimum cost removing all \\'1\\' to the left of i. \\nIf s[i]==1, we can\\n1. either remove everything to its left, total cost = i+1\\n2. or remove i in the middle, total cost = dp[i-1]+2\\nWhichever smaller.\\n\\nFor those on the right side of i, we simply remove everthing without considering the \"remove-middle\" case. We can do this because after go through all \"i\", all possible ways of \"complete-removing\" on right side will be covered.\\nThe \"remove-middle\" case will be specific to the left side only.\\n\\n```\\n    def minimumTime(self, s: str) -> int:\\n        left,res = 0,math.inf\\n        for i,c in enumerate(s):\\n            left = min(i+1, left+(c==\\'1\\')*2)\\n            res = min(res, left+len(s)-1-i)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def minimumTime(self, s: str) -> int:\\n        left,res = 0,math.inf\\n        for i,c in enumerate(s):\\n            left = min(i+1, left+(c==\\'1\\')*2)\\n            res = min(res, left+len(s)-1-i)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1801609,
                "title": "cpp-kadane-s-algo-o-n-easy-code",
                "content": "class Solution {\\npublic:\\n    int minimumTime(string s) {\\n        // this is typical question but we are applying kadanes algorithm here\\n        \\n        if ( s.size() == 1 and s.at(0) == \\'1\\') return 1;\\n        if ( s.size() == 1 and s.at(0) == \\'0\\') return 0;\\n        \\n        // we have to create an array to store the integer values for string\\n        // whereever we see 0 we will add -1 , and 1 will reamain unchanged\\n        \\n        vector<int> a( s.size() , 0);\\n        \\n        for ( auto i : s){\\n            if ( i == \\'0\\') a.push_back(-1);\\n            else a.push_back(1);\\n        }\\n        \\n        // now applying kadanes algo\\n        \\n        int mn = INT_MAX;\\n        int sum = 0;\\n        \\n        for( auto i : a){\\n            sum += i;\\n            \\n            mn = min ( mn , sum);\\n            // since we want min value we will change the condition of ( sum < 0) to sum > 0 \\n            if ( sum > 0) sum = 0;\\n        }\\n        \\n        return s.size() + mn;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minimumTime(string s) {\\n        // this is typical question but we are applying kadanes algorithm here\\n        \\n        if ( s.size() == 1 and s.at(0) == \\'1\\') return 1;\\n        if ( s.size() == 1 and s.at(0) == \\'0\\') return 0;\\n        \\n        // we have to create an array to store the integer values for string\\n        // whereever we see 0 we will add -1 , and 1 will reamain unchanged\\n        \\n        vector<int> a( s.size() , 0);\\n        \\n        for ( auto i : s){\\n            if ( i == \\'0\\') a.push_back(-1);\\n            else a.push_back(1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1801261,
                "title": "c-suffix-prifix-array",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n           int n = s.size();\\n           vector<int> pre(n, 0), suff(n, 0);\\n           if(s[0] == \\'1\\') pre[0] = 1;\\n        \\n           for(int i=1; i<n; i++){\\n               if(s[i] == \\'1\\'){\\n                   pre[i] = min(pre[i-1] + 2, i + 1);\\n               }\\n               else{\\n                   pre[i] = pre[i-1];\\n               }\\n           }\\n           \\n           if(s[n-1] == \\'1\\') suff[n-1] = 1;\\n            for(int i=n-2; i>=0; i--){\\n               if(s[i] == \\'1\\'){\\n                   suff[i] = min(suff[i+1] + 2, n - i);\\n               }\\n               else{\\n                   suff[i] = suff[i+1];\\n               }\\n           }\\n           int ans = min(pre[n-1], suff[0]);\\n           for(int i=0; i<n-1; i++){\\n               ans = min(ans, pre[i] + suff[i+1]);\\n           }\\n         return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumTime(string s) {\\n           int n = s.size();\\n           vector<int> pre(n, 0), suff(n, 0);\\n           if(s[0] == \\'1\\') pre[0] = 1;\\n        \\n           for(int i=1; i<n; i++){\\n               if(s[i] == \\'1\\'){\\n                   pre[i] = min(pre[i-1] + 2, i + 1);\\n               }",
                "codeTag": "Java"
            },
            {
                "id": 1770154,
                "title": "java-prefix-sum-dp",
                "content": "Approach - \\n1. Removed all left ones and right ones\\n2. Prefix arr(L) is to maintain cost for removing 1s from left i.e s[0..i] . If the prev char is \\'1\\' and cost[i-1] == (i-1) + 1 [1 based indexing]  then cost[i] = 1 + cost[i-1], else cost[i] = 2 + cost[i-1].\\n3. Similarly we calculate for cost array for removing 1s from right side\\n4. Min cost is min( l[i] + r[i] ) at every index\\n\\n```\\nclass Solution {\\n    public int minimumTime(String s) {\\n        int cost = 0;\\n        int n = s.length();\\n        int i = 0;\\n        for(; i<n; i++){\\n            int val = s.charAt(i) - \\'0\\';\\n            if(val==1){\\n                cost += 1;\\n            }else{\\n                break;\\n            }\\n        }\\n        if(i==n) return cost;\\n        int j = n - 1;\\n        for(; j > i; j--){\\n            int val = s.charAt(j) - \\'0\\';\\n            if(val==1){\\n                cost +=1;\\n            }else{\\n                break;\\n            }\\n        }\\n        \\n        return cost + cal(s.substring(i, j+1));\\n        \\n    }\\n    \\n    public int cal(String s){\\n        int n = s.length(), cost = Integer.MAX_VALUE;\\n        int[] l = new int[n];\\n\\t\\t//starting from 1 because out string s always starts with 0\\n        for(int i = 1; i < n; i++){\\n            int curr = s.charAt(i) - \\'0\\';\\n            int prev = s.charAt(i-1) - \\'0\\';\\n            if(curr == 1){\\n                if(prev == 1 && l[i-1] == (i-1) + 1){\\n                    l[i] = 1 + l[i-1];\\n                }else{\\n                    l[i] = 2 + l[i-1];\\n                }\\n            }else{\\n                l[i] = l[i-1];\\n            }\\n        }\\n        \\n\\t\\t//starting from n-2 because out string s always starts and end with 0\\n        int[] r = new int[n];\\n        for(int i = n-2; i >= 0; i--){\\n            int curr = s.charAt(i) - \\'0\\';\\n            int prev = s.charAt(i+1) - \\'0\\';\\n            if(curr == 1){\\n                if(prev == 1 && r[i+1] == n-1 - (i+1) + 1){\\n                    r[i] = 1 + r[i+1];\\n                }else{\\n                    r[i] = 2 + r[i+1];\\n                }\\n            }else{\\n                r[i] = r[i+1];\\n            }\\n        }\\n        \\n        for(int i = 0; i < n; i++){\\n            cost = Math.min(cost, l[i] + r[i]);\\n        }\\n\\n        return cost;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumTime(String s) {\\n        int cost = 0;\\n        int n = s.length();\\n        int i = 0;\\n        for(; i<n; i++){\\n            int val = s.charAt(i) - \\'0\\';\\n            if(val==1){\\n                cost += 1;\\n            }else{\\n                break;\\n            }\\n        }\\n        if(i==n) return cost;\\n        int j = n - 1;\\n        for(; j > i; j--){\\n            int val = s.charAt(j) - \\'0\\';\\n            if(val==1){\\n                cost +=1;\\n            }else{\\n                break;\\n            }\\n        }\\n        \\n        return cost + cal(s.substring(i, j+1));\\n        \\n    }\\n    \\n    public int cal(String s){\\n        int n = s.length(), cost = Integer.MAX_VALUE;\\n        int[] l = new int[n];\\n\\t\\t//starting from 1 because out string s always starts with 0\\n        for(int i = 1; i < n; i++){\\n            int curr = s.charAt(i) - \\'0\\';\\n            int prev = s.charAt(i-1) - \\'0\\';\\n            if(curr == 1){\\n                if(prev == 1 && l[i-1] == (i-1) + 1){\\n                    l[i] = 1 + l[i-1];\\n                }else{\\n                    l[i] = 2 + l[i-1];\\n                }\\n            }else{\\n                l[i] = l[i-1];\\n            }\\n        }\\n        \\n\\t\\t//starting from n-2 because out string s always starts and end with 0\\n        int[] r = new int[n];\\n        for(int i = n-2; i >= 0; i--){\\n            int curr = s.charAt(i) - \\'0\\';\\n            int prev = s.charAt(i+1) - \\'0\\';\\n            if(curr == 1){\\n                if(prev == 1 && r[i+1] == n-1 - (i+1) + 1){\\n                    r[i] = 1 + r[i+1];\\n                }else{\\n                    r[i] = 2 + r[i+1];\\n                }\\n            }else{\\n                r[i] = r[i+1];\\n            }\\n        }\\n        \\n        for(int i = 0; i < n; i++){\\n            cost = Math.min(cost, l[i] + r[i]);\\n        }\\n\\n        return cost;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748890,
                "title": "c-code-easy-to-understand-prefix-suffix-approach",
                "content": "class Solution {\\n\\npublic:\\n  \\n  int minimumTime(string s)\\n  {\\n        \\n\\t\\tint n=s.size();\\n\\t\\t\\n        vector <int> left(n,0);\\n        vector<int>right(n,0);\\n        \\n        if(s[0]==\\'1\\'){\\n            left[0]=1;\\n        }\\n        \\n        for(int i=1;i<n;i++){\\n            if(s[i]==\\'1\\')\\n                left[i]=min(left[i-1]+2,i+1);\\n            else \\n                left[i]=left[i-1];\\n        }\\n        \\n        if(s[n-1]==\\'1\\'){\\n            right[n-1]=1;\\n        }\\n        \\n        for(int i=n-2;i>=0;i--){\\n            if(s[i]==\\'1\\')\\n                right[i]=min(right[i+1]+2,n-i);\\n            else \\n                right[i]=right[i+1];\\n        }\\n        \\n        int ans=INT_MAX;\\n        \\n        ans=min(left[n-1],right[0]);\\n        \\n        for(int i=0;i<n-1;i++){\\n            ans=min(ans,left[i]+right[i+1]);\\n        }\\n        \\n        return ans;\\n        \\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n\\npublic:\\n  \\n  int minimumTime(string s)\\n  {\\n        \\n\\t\\tint n=s.size();\\n\\t\\t\\n        vector <int> left(n,0);\\n        vector<int>right(n,0);\\n        \\n        if(s[0]==\\'1\\'){\\n            left[0]=1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1748770,
                "title": "c-solution-using-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int n = s.size();\\n        int dp[n];\\n        \\n        if(s[0]==\\'1\\')\\n            dp[0]=1;\\n        else dp[0]=0;\\n        \\n        for(int i=1;i<n;i++){\\n            if(s[i]==\\'1\\'){\\n                dp[i]=dp[i-1]+2;\\n                dp[i]= min(dp[i], i+1);\\n            }else{\\n                dp[i] = dp[i-1];\\n            }\\n        }\\n        \\n        int ans = dp[n-1];\\n        for(int i=n-1;i>0;i--)\\n            ans = min(ans, n-i + dp[i-1]);\\n        \\n        ans = min(ans, n);\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\nDo **upVote** if it helps!",
                "solutionTags": [
                    "Array",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int n = s.size();\\n        int dp[n];\\n        \\n        if(s[0]==\\'1\\')\\n            dp[0]=1;\\n        else dp[0]=0;\\n        \\n        for(int i=1;i<n;i++){\\n            if(s[i]==\\'1\\'){\\n                dp[i]=dp[i-1]+2;\\n                dp[i]= min(dp[i], i+1);\\n            }else{\\n                dp[i] = dp[i-1];\\n            }\\n        }\\n        \\n        int ans = dp[n-1];\\n        for(int i=n-1;i>0;i--)\\n            ans = min(ans, n-i + dp[i-1]);\\n        \\n        ans = min(ans, n);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748477,
                "title": "python-easy-to-understand-solution-with-comments",
                "content": "```python\\nINF = 1 << 60\\n\\nclass Solution:\\n    def minimumTime(self, s):\\n        midone = 0  # 1\\'s inside mid region\\n        \\n        ans = INF\\n        \\n        # boundary of mid region\\n        left, right = -1, 0\\n        while right < len(s):\\n            if s[right] == \"1\":  # move 1 from right to mid\\n                midone += 1\\n            if right - left < midone * 2:  # if merge mid into left is more efficient, then merge\\n                left = right\\n                midone = 0\\n            ans = min(ans, midone * 2 + (left + 1) + (len(s) - right - 1))  # update answer\\n            right += 1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```python\\nINF = 1 << 60\\n\\nclass Solution:\\n    def minimumTime(self, s):\\n        midone = 0  # 1\\'s inside mid region\\n        \\n        ans = INF\\n        \\n        # boundary of mid region\\n        left, right = -1, 0\\n        while right < len(s):\\n            if s[right] == \"1\":  # move 1 from right to mid\\n                midone += 1\\n            if right - left < midone * 2:  # if merge mid into left is more efficient, then merge\\n                left = right\\n                midone = 0\\n            ans = min(ans, midone * 2 + (left + 1) + (len(s) - right - 1))  # update answer\\n            right += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2578807,
                "title": "dynamic-programming-a-magical-way-to-solve-problems",
                "content": "```\\n int minimumTime(string s) {\\n        \\n        int n=s.size();\\n        vector<int> left(n,0),right(n,0);\\n        \\n        if(s[0]==\\'1\\')     left[0]=1;\\n        if(s[n-1]==\\'1\\')   right[n-1]=1;\\n        \\n        //step 1 sirf left dp banao \\n        for(int i=1;i<n;i++)\\n        {\\n            if(s[i]==\\'0\\')\\n                left[i]=left[i-1];\\n            \\n          //ya to ith place tak sbko htadunga ya fr left[i-1]+2 jo b minimum hoga dono me se \\n            else\\n                left[i]=min(i+1,left[i-1]+2);  \\n        }\\n        \\n         //step2 sirf right dp banao \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(s[i]==\\'0\\')\\n                right[i]=right[i+1];\\n            \\n        //ya to ith place tak sbko htadunga ya fr right[i+1]+2 jo b minimum hoga dono me se \\n            else\\n                right[i]=min(n-i,right[i+1]+2);\\n        }\\n        \\n//step 3 ith tak mai left bnake launga aur (n to i+1) mai right se bnata hua aunga --> left[i]+right[i+1]  ans update krte rho sath sath\\n        \\n        int ans=min(left[n-1],right[0]);  //kya pta sirf left ya sirf right se min ans aa rha \\n        for(int i=0;i<=n-2;i++)\\n            ans=min(ans,left[i]+right[i+1]);\\n        \\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "```\\n int minimumTime(string s) {\\n        \\n        int n=s.size();\\n        vector<int> left(n,0),right(n,0);\\n        \\n        if(s[0]==\\'1\\')     left[0]=1;\\n        if(s[n-1]==\\'1\\')   right[n-1]=1;\\n        \\n        //step 1 sirf left dp banao \\n        for(int i=1;i<n;i++)\\n        {\\n            if(s[i]==\\'0\\')\\n                left[i]=left[i-1];\\n            \\n          //ya to ith place tak sbko htadunga ya fr left[i-1]+2 jo b minimum hoga dono me se \\n            else\\n                left[i]=min(i+1,left[i-1]+2);  \\n        }\\n        \\n         //step2 sirf right dp banao \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(s[i]==\\'0\\')\\n                right[i]=right[i+1];\\n            \\n        //ya to ith place tak sbko htadunga ya fr right[i+1]+2 jo b minimum hoga dono me se \\n            else\\n                right[i]=min(n-i,right[i+1]+2);\\n        }\\n        \\n//step 3 ith tak mai left bnake launga aur (n to i+1) mai right se bnata hua aunga --> left[i]+right[i+1]  ans update krte rho sath sath\\n        \\n        int ans=min(left[n-1],right[0]);  //kya pta sirf left ya sirf right se min ans aa rha \\n        for(int i=0;i<=n-2;i++)\\n            ans=min(ans,left[i]+right[i+1]);\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2362797,
                "title": "greedy-thinking-process-c-o-n",
                "content": "You must be confused thinking various things. Greedy comes first to mind. But the correct greedy algo is difficult to think.\\n**What is the picture when we will be removing the last illegal car?**\\nAns: All illegal cars from left and right must have been removed. Also it wont be that we would randomly remove cars from the middle. We will be removing leftmost illegal cars or the right most illegal car first.\\n\\nSo lets say there are total Z illegal cars.\\n1 2 3 4 5 .... Z\\n\\nLast illegal car removed, can be any of these. let it be X. \\nAlso lets say we have two arrays A and B. \\nA[i] stores cost to remove all illegal cars left of i.(including i)\\nB[i] stores cost to remove all illegal cars right of i.(including i)\\nMin cost to remove X illegal car at the last = min(left[X]+right[X+1],left[X-1+right[X]]);\\nThis was a greedy approach.\\nCalculation of left and right array can be done easily in O(n) time.\\nTotal complexity is O(n).\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        \\n        vector<int> left;\\n        int n = s.length();\\n        \\n        for(int i=0;i<n;i=i+1)    \\n        {if(s[i]==\\'1\\')\\n            {int a = 2;\\n             if(left.size()>0){a=left[left.size()-1]+2;}\\n             left.push_back(min(a,(int)i+1));\\n            }\\n        }\\n        \\n        if(left.size()==0){return 0;}\\n        \\n        vector<int> right(left.size());\\n        int ptr=left.size()-1;\\n        for(int i=n-1;i>=0;i=i-1)\\n            \\n        {if(s[i]==\\'1\\')\\n            {int a = 2;\\n             if(ptr<left.size()-1){a=right[ptr+1]+2;}\\n             right[ptr]=min(a,(int)n-(int)i);ptr--;\\n            }\\n        }\\n        \\n        int ans=min(left[left.size()-1],right[0]);\\n        for(int i=1;i<left.size();i=i+1)\\n        { ans= min(left[i-1]+right[i],ans); }\\n\\t\\t\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        \\n        vector<int> left;\\n        int n = s.length();\\n        \\n        for(int i=0;i<n;i=i+1)    \\n        {if(s[i]==\\'1\\')\\n            {int a = 2;\\n             if(left.size()>0){a=left[left.size()-1]+2;}\\n             left.push_back(min(a,(int)i+1));\\n            }\\n        }\\n        \\n        if(left.size()==0){return 0;}\\n        \\n        vector<int> right(left.size());\\n        int ptr=left.size()-1;\\n        for(int i=n-1;i>=0;i=i-1)\\n            \\n        {if(s[i]==\\'1\\')\\n            {int a = 2;\\n             if(ptr<left.size()-1){a=right[ptr+1]+2;}\\n             right[ptr]=min(a,(int)n-(int)i);ptr--;\\n            }\\n        }\\n        \\n        int ans=min(left[left.size()-1],right[0]);\\n        for(int i=1;i<left.size();i=i+1)\\n        { ans= min(left[i-1]+right[i],ans); }\\n\\t\\t\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2354419,
                "title": "c-kinda-kadane-s-very-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) \\n    {\\n        int n = s.size();\\n        vector<vector<int>> v(n,vector<int>(2,0));\\n        \\n        int prefix=0,prefixr=0;\\n        int maxx=0,maxxr=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'1\\') prefix+=2;\\n            maxx=max(maxx,((prefix-i-1)>0 ? (prefix-i-1) : 0));\\n            v[i][0] = maxx;\\n            \\n            if(s[n-1-i]==\\'1\\') prefixr+=2;\\n            v[n-1-i][1] = maxxr;\\n            maxxr=max(maxxr,((prefixr-i-1)>0 ? (prefixr-i-1) : 0));\\n        }\\n        \\n        maxx=0;\\n        for(int i=0;i<n;i++)\\n            maxx=max(maxx,v[i][0]+v[i][1]);\\n        \\n        // cout<<prefix<<endl;\\n        // for(int i=0;i<n;i++)\\n        //     cout<<v[i][0]<<\" \";\\n        // cout<<endl;\\n        // for(int i=0;i<n;i++)\\n        //     cout<<v[i][1]<<\" \";\\n        return prefix - maxx;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minimumTime(string s) \\n    {\\n        int n = s.size();\\n        vector<vector<int>> v(n,vector<int>(2,0));\\n        \\n        int prefix=0,prefixr=0;\\n        int maxx=0,maxxr=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'1\\') prefix+=2;\\n            maxx=max(maxx,((prefix-i-1)>0 ? (prefix-i-1) : 0));\\n            v[i][0] = maxx;\\n            \\n            if(s[n-1-i]==\\'1\\') prefixr+=2;\\n            v[n-1-i][1] = maxxr;\\n            maxxr=max(maxxr,((prefixr-i-1)>0 ? (prefixr-i-1) : 0));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2267794,
                "title": "c-dp-weird-easy",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n\\t\\tint n = s.length();\\n        vector<int> left(n), right(n);\\n\\t\\tleft[0] = s[0] == \\'1\\';\\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\tif (s[i] == \\'0\\') left[i] = left[i - 1];\\n\\t\\t\\telse left[i] = min(i + 1, 2 + left[i -1]);\\n\\t\\t}\\n\\t\\tright[n - 1] = s[n - 1] == \\'1\\';\\n\\t\\tfor (int i = n - 2; i >= 0; i--) {\\n\\t\\t\\tif (s[i] == \\'0\\') right[i] = right[i + 1];\\n\\t\\t\\telse right[i] = min(n - i, 2 + right[i + 1]);\\n\\t\\t}\\n\\t\\tint ans = min(left[n - 1], right[0]);\\n\\t\\tfor (int i = 0; i < n - 1; i++) {\\n\\t\\t\\tint cur = left[i] + right[i + 1];\\n\\t\\t\\tans = min(ans, cur);\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n\\t\\tint n = s.length();\\n        vector<int> left(n), right(n);\\n\\t\\tleft[0] = s[0] == \\'1\\';\\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\tif (s[i] == \\'0\\') left[i] = left[i - 1];\\n\\t\\t\\telse left[i] = min(i + 1, 2 + left[i -1]);\\n\\t\\t}\\n\\t\\tright[n - 1] = s[n - 1] == \\'1\\';\\n\\t\\tfor (int i = n - 2; i >= 0; i--) {\\n\\t\\t\\tif (s[i] == \\'0\\') right[i] = right[i + 1];\\n\\t\\t\\telse right[i] = min(n - i, 2 + right[i + 1]);\\n\\t\\t}\\n\\t\\tint ans = min(left[n - 1], right[0]);\\n\\t\\tfor (int i = 0; i < n - 1; i++) {\\n\\t\\t\\tint cur = left[i] + right[i + 1];\\n\\t\\t\\tans = min(ans, cur);\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2253305,
                "title": "c-recursive-dp-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    string s;\\n    int n;\\n    \\n    // Time complexity - O(n*stage) , here stage is only 3 so its O(n)\\n    \\n    // state - index, previous stage\\n    // stage = 0 -> remove current character from left move, so if char is 0/1 we will delete with cost 1\\n    // stage = 1 -> remove current character using anywhere move, so only if char is 1 we will delete with cost 2\\n    // stage = 2 -> remove current character using right move, so if char is 0/1 we will delete with cost 1\\n    \\n    // transition -> if previous character was in stage 0, current can be in stage 0,1,2\\n    //               if previous character was in stage 1, current can be in stage 1,2\\n    //               if previous character was in stage 2, current also in stage 2\\n    int dp[200005][3];\\n    const int inf = 1e9;\\n    int rec(int level,int stage){\\n        if(level == n){\\n            return 0;\\n        }\\n        if(dp[level][stage] != -1) return dp[level][stage];\\n        \\n        int ans = inf;\\n        if(stage == 0){\\n            // stay in stage 0\\n            ans = 1+rec(level+1,0);\\n            \\n            // choose stage 1 \\n            if(s[level] == \\'0\\'){\\n                ans = min(ans,rec(level+1,1));\\n            }\\n            else{\\n                ans = min(ans,2+rec(level+1,1));\\n            }\\n            \\n            // choose stage 2\\n            ans = min(ans,1+rec(level+1,2));\\n        }\\n        if(stage == 1){\\n            // stay in stage 1\\n            if(s[level] == \\'0\\'){\\n                ans = min(ans,rec(level+1,1));\\n            }\\n            else{\\n                ans = min(ans,2+rec(level+1,1));\\n            }\\n            // choose stage 2\\n            ans = min(ans,1+rec(level+1,2));\\n        }\\n        if(stage == 2){\\n            // should stay in stage 2\\n            ans = min(ans,1+rec(level+1,2));\\n        }\\n        return dp[level][stage] = ans;\\n    }\\n    \\n    int minimumTime(string _s) {\\n        s = _s;\\n        n = s.size();\\n        memset(dp,-1,sizeof(dp));\\n        return rec(0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string s;\\n    int n;\\n    \\n    // Time complexity - O(n*stage) , here stage is only 3 so its O(n)\\n    \\n    // state - index, previous stage\\n    // stage = 0 -> remove current character from left move, so if char is 0/1 we will delete with cost 1\\n    // stage = 1 -> remove current character using anywhere move, so only if char is 1 we will delete with cost 2\\n    // stage = 2 -> remove current character using right move, so if char is 0/1 we will delete with cost 1\\n    \\n    // transition -> if previous character was in stage 0, current can be in stage 0,1,2\\n    //               if previous character was in stage 1, current can be in stage 1,2\\n    //               if previous character was in stage 2, current also in stage 2\\n    int dp[200005][3];\\n    const int inf = 1e9;\\n    int rec(int level,int stage){\\n        if(level == n){\\n            return 0;\\n        }\\n        if(dp[level][stage] != -1) return dp[level][stage];\\n        \\n        int ans = inf;\\n        if(stage == 0){\\n            // stay in stage 0\\n            ans = 1+rec(level+1,0);\\n            \\n            // choose stage 1 \\n            if(s[level] == \\'0\\'){\\n                ans = min(ans,rec(level+1,1));\\n            }\\n            else{\\n                ans = min(ans,2+rec(level+1,1));\\n            }\\n            \\n            // choose stage 2\\n            ans = min(ans,1+rec(level+1,2));\\n        }\\n        if(stage == 1){\\n            // stay in stage 1\\n            if(s[level] == \\'0\\'){\\n                ans = min(ans,rec(level+1,1));\\n            }\\n            else{\\n                ans = min(ans,2+rec(level+1,1));\\n            }\\n            // choose stage 2\\n            ans = min(ans,1+rec(level+1,2));\\n        }\\n        if(stage == 2){\\n            // should stay in stage 2\\n            ans = min(ans,1+rec(level+1,2));\\n        }\\n        return dp[level][stage] = ans;\\n    }\\n    \\n    int minimumTime(string _s) {\\n        s = _s;\\n        n = s.size();\\n        memset(dp,-1,sizeof(dp));\\n        return rec(0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1933390,
                "title": "rust-o-n",
                "content": "```rust\\nuse std::cmp;\\n\\nimpl Solution {\\n    pub fn minimum_time(s: String) -> i32 {\\n        let mut cur_sum: i32 = 0;\\n        let mut min_sum: i32 = 0;\\n        for c in s.chars() {\\n            let n: i32 = if c == \\'1\\' { 1 } else { -1 };\\n            cur_sum = cmp::min(cur_sum+n, n);\\n            min_sum = cmp::min(min_sum, cur_sum);\\n        }\\n        (s.len() as i32) + min_sum\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::cmp;\\n\\nimpl Solution {\\n    pub fn minimum_time(s: String) -> i32 {\\n        let mut cur_sum: i32 = 0;\\n        let mut min_sum: i32 = 0;\\n        for c in s.chars() {\\n            let n: i32 = if c == \\'1\\' { 1 } else { -1 };\\n            cur_sum = cmp::min(cur_sum+n, n);\\n            min_sum = cmp::min(min_sum, cur_sum);\\n        }\\n        (s.len() as i32) + min_sum\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1854655,
                "title": "python-sliding-window-o-n-time-o-1-space",
                "content": "The first thing to realize here is that the order of operations doesn\\'t matter. If you were given a list of operations to apply, you could reorder it however you\\'d like and end still up with the same end result. \\nThis means the problem can be redefined as finding the optimal config for the following triplet: (number of left_pops, number of right_pops, number of other deletions).\\n\\nThis can be done with a brute force O(n^2) approach. You can try every possible combination of number of left pops and right pops, and for each combination find the final score by adding the numbers of pops to (`2 * the number of 1\\'s that still need to be removed in the middle)`.\\n\\nHowever, there is a more efficient way of building that middle interval. This interval can only be cheap enough to be viable if it contains more 0\\'s than 1\\'s. Furthermore, the optimal interval is the one for which the delta of (`number of 0\\'s in the interval - number of 1\\'s in the interval`) is the largest. \\n\\nYou can find a subset of intervals that is guaranteed to contain the optimal interval by using a sliding window. For every possible `right` pointer, you can find the longest interval ending at `right` such that, for every index `i` between `left` and `right`, the number of 0\\'s between `left` and `i` is greater than the number of 1\\'s between `left` and `i`. In other words, for every possible `right` pointer, you are finding the interval ending at `right` that has the largest possible delta.\\nOut of all these possible intervals, you need to pick the one with the largest delta. To get the final score, add the cost associated with the optimal interval with the number of left and right pops needed to reach the bounds of the interval.\\n\\n\\n```\\nclass Interval:\\n    def __init__(self, left: int, right: int, count_0: int, count_1: int):\\n        self.left = left\\n        self.right = right\\n        self.count_0 = count_0\\n        self.count_1 = count_1\\n\\nclass Solution:    \\n    def minimumTime(self, s: str) -> int:\\n        left = 0\\n        count_0 = 0\\n        count_1 = 0\\n        best_interval = None\\n        \\n        for right in range(len(s)):\\n            if s[right] == \\'0\\':\\n                count_0 += 1\\n            else:\\n                count_1 += 1\\n                \\n            while count_1 > count_0:\\n                if s[left] == \\'0\\':\\n                    count_0 -= 1\\n                else:\\n                    count_1 -= 1\\n                left += 1\\n\\n            curr_interval = Interval(left, right, count_0, count_1)\\n            if best_interval is None or \\\\\\n                curr_interval.count_0 - curr_interval.count_1 > best_interval.count_0 - best_interval.count_1:\\n                best_interval = curr_interval\\n\\n        \\n        return best_interval.count_1 * 2 + best_interval.left + len(s) - 1 - best_interval.right\\n",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "The first thing to realize here is that the order of operations doesn\\'t matter. If you were given a list of operations to apply, you could reorder it however you\\'d like and end still up with the same end result. \\nThis means the problem can be redefined as finding the optimal config for the following triplet: (number of left_pops, number of right_pops, number of other deletions).\\n\\nThis can be done with a brute force O(n^2) approach. You can try every possible combination of number of left pops and right pops, and for each combination find the final score by adding the numbers of pops to (`2 * the number of 1\\'s that still need to be removed in the middle)`.\\n\\nHowever, there is a more efficient way of building that middle interval. This interval can only be cheap enough to be viable if it contains more 0\\'s than 1\\'s. Furthermore, the optimal interval is the one for which the delta of (`number of 0\\'s in the interval - number of 1\\'s in the interval`) is the largest. \\n\\nYou can find a subset of intervals that is guaranteed to contain the optimal interval by using a sliding window. For every possible `right` pointer, you can find the longest interval ending at `right` such that, for every index `i` between `left` and `right`, the number of 0\\'s between `left` and `i` is greater than the number of 1\\'s between `left` and `i`. In other words, for every possible `right` pointer, you are finding the interval ending at `right` that has the largest possible delta.\\nOut of all these possible intervals, you need to pick the one with the largest delta. To get the final score, add the cost associated with the optimal interval with the number of left and right pops needed to reach the bounds of the interval.\\n\\n\\n```\\nclass Interval:\\n    def __init__(self, left: int, right: int, count_0: int, count_1: int):\\n        self.left = left\\n        self.right = right\\n        self.count_0 = count_0\\n        self.count_1 = count_1\\n\\nclass Solution:    \\n    def minimumTime(self, s: str) -> int:\\n        left = 0\\n        count_0 = 0\\n        count_1 = 0\\n        best_interval = None\\n        \\n        for right in range(len(s)):\\n            if s[right] == \\'0\\':\\n                count_0 += 1\\n            else:\\n                count_1 += 1\\n                \\n            while count_1 > count_0:\\n                if s[left] == \\'0\\':\\n                    count_0 -= 1\\n                else:\\n                    count_1 -= 1\\n                left += 1\\n\\n            curr_interval = Interval(left, right, count_0, count_1)\\n            if best_interval is None or \\\\\\n                curr_interval.count_0 - curr_interval.count_1 > best_interval.count_0 - best_interval.count_1:\\n                best_interval = curr_interval\\n\\n        \\n        return best_interval.count_1 * 2 + best_interval.left + len(s) - 1 - best_interval.right\\n",
                "codeTag": "Java"
            },
            {
                "id": 1836045,
                "title": "python-o-n-9-lines-explained",
                "content": "Consider we remove the left and right elements of s and get s[i~j], and then we just need to romove all the \\'1\\' in s[i~j].\\nTotal time is **len(s)- len(s[i~j])+ 2 sum(s[i~j])**\\n* (sum(s[i~j]) equals to the number of \\'1\\' in s[i~j])\\n\\nWith basic tranforms\\n* len(s[i~j]) = j - i - 1\\n* sum(s[i~j]) = sum(s[0~j])  - sum(s[0~i-1])\\n\\nLet  **A[i] = 2sum(s[0~i]) - i**\\nWe can find that **len(s) - len(s[i~j]) + 2 sum(s[i~j]) = len(s) + A[j] - A[i-1]**\\n\\n**Now, the question is:\\nfind i,j  , that minimize len(s) + A[j] - A[i-1]**\\n\\nAs len(s) is a constant. Now the problem looks pretty simple and familiar.\\n\\n* Note that s[i~j] could be empty.\\n\\n```\\nclass Solution:\\n    def minimumTime(self, s: str) -> int:\\n        s = [int(c) for c in s]\\n        for i in range(1, len(s)):\\n            s[i] += s[i-1]\\n        s = [2*x - i - 1 for i, x in enumerate(s)]\\n        \\n        curMax = ret = 0\\n        for i, x in enumerate(s):\\n            ret = min(ret, x - curMax)\\n            curMax = max(x, curMax)\\n        \\n        return ret + len(s)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, s: str) -> int:\\n        s = [int(c) for c in s]\\n        for i in range(1, len(s)):\\n            s[i] += s[i-1]\\n        s = [2*x - i - 1 for i, x in enumerate(s)]\\n        \\n        curMax = ret = 0\\n        for i, x in enumerate(s):\\n            ret = min(ret, x - curMax)\\n            curMax = max(x, curMax)\\n        \\n        return ret + len(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1778329,
                "title": "cpp-solution",
                "content": "the steps in the whole string are :-\\nstep=length(left)+(count of 1 in middle)*2+length(right)\\nnow adding and subtracting length(middle) in the above formula\\nstep=***len(left)+len(middle)+len(right)***+(count of 1 in middle)*2-length(middle)\\nthe highlighted portion is nothing but the whole string\\nstep=n+(count of 1in middle)*2 -((count of 1)+(count of 0))\\nstep=n+count of 1 in middle -count of 0 in middle\\nsince n is constant so we are required to decrease the second portion \\nnow if we observe it carefully count of 1 in middle is positive so if we decrease the count of 0 in iddle to as low as possible we will reach to the required ans.\\nso we will make all the 0 as -1 and will count the least subarray sum\\nso the final ans will be\\nn+least subarray sum\\n\\n**eg-10001\\nreplace 0 with -1\\n1 -1 -1 -1 1\\nthe least subarray sum will be -3\\nso the ans will be 5(size of string)-3=2**\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int n=s.size();\\n        int ans=n;\\n        vector<int>vec;\\n        for(auto it:s)\\n        {\\n            if(it==\\'0\\')vec.push_back(-1);\\n            else vec.push_back(1);\\n        }\\n        int sum=0;\\n        int mini=0;\\n        for(auto it:vec)\\n        {\\n            sum+=it;\\n            mini=min(sum,mini);\\n            if(sum>0)sum=0;\\n        }\\n        return ans+mini;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int n=s.size();\\n        int ans=n;\\n        vector<int>vec;\\n        for(auto it:s)\\n        {\\n            if(it==\\'0\\')vec.push_back(-1);\\n            else vec.push_back(1);\\n        }\\n        int sum=0;\\n        int mini=0;\\n        for(auto it:vec)\\n        {\\n            sum+=it;\\n            mini=min(sum,mini);\\n            if(sum>0)sum=0;\\n        }\\n        return ans+mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1757794,
                "title": "c-different-approach-than-dp-easy-to-understand",
                "content": "**Intuition :** https://leetcode.com/problems/minimum-time-to-remove-all-cars-containing-illegal-goods/discuss/1748424/Python-maximum-sum-on-subarray-explained\\n\\n**Explaination:**\\n![image](https://assets.leetcode.com/users/images/c96ec455-3f0e-4312-84c5-bba4a93b321c_1644398053.1649652.jpeg)\\n\\nFor this array : \\n1100101\\nwould become 1 1 -1 -1 1 -1 1\\nand kadane\\'s dp would give us a array like this\\n**1 1 -1 -2 -1 -2 -1**\\nThe least subarray is from index 2 to 3 ( and 2 to 5)\\nso if we consider index 2 to 3 as middle \\nthan left = 2 \\nthan right = 3\\nand cnt of 1 in middle = 0 (as no 1\\'s)\\nans = 2 + 3 + 0 = 5 \\n\\nconsider index 2 to 5 as middle \\nleft = 2\\nright = 1\\nmiddle = 2 (as only one 1)\\nans = 2 + 1 + 2 = 5;\\n\\nfor cases 00 ans would be 2 - 2\\nand for 11 take the case like **min(n,n + ans)**\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) \\n    {\\n        \\n        int n = s.length();\\n        if(n == 1)\\n        {\\n            if(s[0] == \\'1\\') return 1;\\n            else return 0;\\n        }\\n        vector<int> a(n,0);\\n        for(int i =0;i<n;i++)\\n        {\\n            if(s[i] == \\'0\\') a[i] = -1;\\n            else a[i] = 1;\\n        }\\n        \\n        vector<int> dp(n,0);\\n        \\n        dp[0] = a[0];\\n\\n        int ans = a[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            dp[i] = min(dp[i-1] + a[i] , a[i]);\\n            ans = min(ans,dp[i]);\\n        }\\n\\n        return min(n,n+ans); // for all ones case\\n    }\\n    \\n};\\n```\\n\\n\\nPlease upvote",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) \\n    {\\n        \\n        int n = s.length();\\n        if(n == 1)\\n        {\\n            if(s[0] == \\'1\\') return 1;\\n            else return 0;\\n        }\\n        vector<int> a(n,0);\\n        for(int i =0;i<n;i++)\\n        {\\n            if(s[i] == \\'0\\') a[i] = -1;\\n            else a[i] = 1;\\n        }\\n        \\n        vector<int> dp(n,0);\\n        \\n        dp[0] = a[0];\\n\\n        int ans = a[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            dp[i] = min(dp[i-1] + a[i] , a[i]);\\n            ans = min(ans,dp[i]);\\n        }\\n\\n        return min(n,n+ans); // for all ones case\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1756445,
                "title": "c-with-thought-process-explanation-and-diagram",
                "content": "**Explanation**  \\n\\n*Go below to see the code*\\n\\n![image](https://assets.leetcode.com/users/images/0e4a016f-2f96-485d-bbc4-dbac581a5390_1644348700.1834185.png)\\n\\n![image](https://assets.leetcode.com/users/images/77372f1d-3084-493a-84d8-ffbd9d7d9952_1644348729.854877.png)\\n\\n![image](https://assets.leetcode.com/users/images/8564979a-3d1c-4999-8dac-a07643a35063_1644348744.6305661.png)\\n\\n![image](https://assets.leetcode.com/users/images/cc8c4d74-fffe-425c-beda-89ec62e674d8_1644348759.1771886.png)\\n\\n![image](https://assets.leetcode.com/users/images/f8d8095c-84bd-408b-a088-6f8e1349ce0c_1644348787.7415931.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/ae567b64-833a-4b4a-9f60-2357ad118af7_1644348811.2816133.png)\\n\\n![image](https://assets.leetcode.com/users/images/f94f87a2-65b8-461d-a783-a5410fe08831_1644348828.6919262.png)\\n\\n\\n**Code**\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int n = s.size();\\n        vector<int> count (n+1, 0);\\n        \\n        for (int i = 1; i <= n; i++) {\\n            count[i] = count[i-1];\\n            if (s[i-1] == \\'1\\') count[i]++;\\n        }\\n        \\n        vector<int> costJ (n+1, INT_MAX);\\n        costJ[n] = 2*count[n];\\n        \\n        for (int j = n-1; j >= 0; j--) {\\n            costJ[j] = min (costJ[j+1], (2*count[j])+(n-j));\\n        }\\n        \\n        int minTime = costJ[0];\\n        for (int i = 0; i < n; i++) {\\n            minTime = min (minTime, costJ[i+1]-(2*count[i+1])+i+1);\\n        }\\n        \\n        return minTime;\\n    }\\n};\\n```\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int n = s.size();\\n        vector<int> count (n+1, 0);\\n        \\n        for (int i = 1; i <= n; i++) {\\n            count[i] = count[i-1];\\n            if (s[i-1] == \\'1\\') count[i]++;\\n        }\\n        \\n        vector<int> costJ (n+1, INT_MAX);\\n        costJ[n] = 2*count[n];\\n        \\n        for (int j = n-1; j >= 0; j--) {\\n            costJ[j] = min (costJ[j+1], (2*count[j])+(n-j));\\n        }\\n        \\n        int minTime = costJ[0];\\n        for (int i = 0; i < n; i++) {\\n            minTime = min (minTime, costJ[i+1]-(2*count[i+1])+i+1);\\n        }\\n        \\n        return minTime;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1752156,
                "title": "java-100-faster",
                "content": "```\\nclass Solution {\\n    public int minimumTime(String s) {\\n        int len = s.length(), ans = len + 1;\\n        int start = 0;\\n        for (int i = 0; i < len; i++) {\\n            if (s.charAt(i) ==\\'1\\') {\\n                start = Math.min(i + 1, start + 2);\\n            }\\n            int temp = len - i - 1;\\n            ans= Math.min(ans, (start + temp ));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumTime(String s) {\\n        int len = s.length(), ans = len + 1;\\n        int start = 0;\\n        for (int i = 0; i < len; i++) {\\n            if (s.charAt(i) ==\\'1\\') {\\n                start = Math.min(i + 1, start + 2);\\n            }\\n            int temp = len - i - 1;\\n            ans= Math.min(ans, (start + temp ));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1752102,
                "title": "c-easy-and-best-detailed-explanation",
                "content": "**Note:** Read until the end to understand completely and trace the examples.\\n\\nThis problem looks difficult as we can remove the goods from both left and right ends. \\nInorder to make it look simple, let\\'s break the problem into two cases and using this two cases let\\'s solve the original problem.\\n\\n**Case-1:**\\nFind the minimum cost to remove the illegal goods considering we have only two options:\\n1. We can remove from **left end** with cost of 1\\n2. We can remove from anywhere in the **middle** with cost of 2\\n\\nTo solve this, let\\'s store the minimum cost to remove the illegal goods (1\\'s) in the **leftCost** array, where leftCost[i] = min cost to remove all 1\\'s from index 0 to i\\n\\n**Removing the goods:**\\n1. If it is a legal good(0), no need to remove it. Hence, cost doesnot change.\\n**leftCost[i] = leftCost[i-1]**\\n\\n2. If it is an illegal good(1), there are two possiblities: \\n\\t1. Remove **directly from the middle** with cost 2 and add it to the previous cost. \\n\\t2. We need to **make it as the left end and then remove** with cost 1. Inorder to make it as left end, we need to remove all the goods upto index i and then remove at ith index. Hence the cost is i+1.\\n(No need to add it to the previous cost because anyhow we remove all the goods from left. So the cost will be covered in it)\\n\\n\\t\\tWe need to take minimum of these two possibilties:\\n**leftCost[i] = min(leftCost[i-1]+2, i+1)**\\n\\n![image](https://assets.leetcode.com/users/images/4cc04eb6-0fbc-4955-80f9-527d19c6b1c7_1644216490.8349097.png)\\n\\n\\nFinally, the cost at the last index leftCost[n-1] = min cost to remove all illegal goods from [0,n-1] considering we can only remove from left and middle.\\n\\n**Case-2:**\\nFind the minimum cost to remove the illegal goods considering we have only two options:\\n1. This time, we can remove from the **right end** with cost of 1\\n2. We can remove from anywhere in the **middle** with cost of 2\\n\\nLet\\'s store the minimum cost to remove the illegal goods (1\\'s) in the **rightCost** array, where rightCost[i] = min cost to remove all 1\\'s from index i to n-1.\\nHere, we start from the end to calculate this rightCost\\n\\nRemove the goods using the same approach as above:\\n1. For legal goods, **rightCost[i] = rightCost[i+1]**\\n2. For illegal goods, **rightCost[i] = min(rightCost[i+1]+2, n-i)**\\n\\n![image](https://assets.leetcode.com/users/images/33e22230-43da-4239-8321-060f76905eed_1644217203.7045038.png)\\n\\nFinally, the cost at the first index rightCost[0] = min cost to remove all illegal goods from [0,n-1] considering we can only remove from left and middle.\\n\\n**It\\'s time to solve the given problem :)**\\n\\nNow, for removing goods we have three options:\\n1. Remove from left; cost = 1\\n2. Remove from right; cost = 1\\n3. Remove from middle; cost = 2\\n\\nInorder to get the min cost to remove all the illegal goods, we need to find an index at which some goods are removed from the left and other goods are removed from right. \\n\\nHence, find the min cost to remove all illegal goods at each index i such that all goods from [0, i] are removed using case-1 and all goods from [i+1, n-1] are removed using case-2:\\n\\n**minCost[i] = leftCost[i] + rightCost[i+1]** where,\\nleftCost[i] = min cost to remove illegal goods from 0 to i \\nrightCost[i+1] = min cost to remove illegal goods from i+1 to n-1\\n\\n```\\nint minimumTime(string s) {\\n\\tint n = s.size();\\n\\n\\t// Find the cost for removing the illegal goods considering we have only two options:\\n\\t// 1. We can remove from the left end with cost 1\\n\\t// 2. We can remove from anywhere in the middle with cost 2\\n\\n\\tvector<int> leftCost(n,0);\\n\\tif(s[0] == \\'1\\'){\\n\\t\\tleftCost[0] = 1;\\n\\t}\\n\\tfor(int i=1; i<n; i++){\\n\\t\\tif(s[i] == \\'0\\'){\\n\\t\\t\\t// Legal good .i.e no need to remove it\\n\\t\\t\\t// Hence the removal cost will not increase\\n\\t\\t\\tleftCost[i] = leftCost[i-1];\\n\\t\\t}\\n\\t\\telse{\\n\\t\\t\\t// Illegal good, two ways to remove it:\\n\\t\\t\\t// Remove it from middle with cost 2 and add it to previous cost\\n\\t\\t\\t// Remove all the elements from the left with cost 1\\n\\t\\t\\t// We\\'ll not add leftCost[i-1] here because  all the elements are removed from left end, so its cost is covered\\n\\t\\t\\tleftCost[i] = min(leftCost[i-1]+2, i+1);\\n\\t\\t}\\n\\t}\\n\\n\\t// Similarly find cost for removing the illegal goods considering we have only two options:\\n\\t// 1. We can remove from the right end with cost 1\\n\\t// 2. We can remove from anywhere in the middle with cost 2\\n\\n\\tvector<int> rightCost(n, 0);\\n\\n\\tif(s[n-1] == \\'1\\')\\n\\t\\trightCost[n-1] = 1;\\n\\n\\tfor(int i=n-2; i>=0; i--){\\n\\t\\tif(s[i] == \\'0\\')\\n\\t\\t\\trightCost[i] = rightCost[i+1];\\n\\t\\telse\\n\\t\\t\\trightCost[i] = min(rightCost[i+1]+2, n-i);\\n\\t}\\n\\n\\t// Now, find cost for removing the illegal goods considering we have all three options:\\n\\t// 1. We can remove from the right end with cost 1\\n\\t// 2. We can remove from the right end with cost 1\\n\\t// 3. We can remove from anywhere in the middle with cost 2\\n\\n\\t// leftCost[n-1] will store the min cost to remove all 1\\'s (only left and middle removal)\\n\\t// rightCost[0] will store the min cost to remove all 1\\'s (only right and middle removal)\\n\\n\\tint minCost = min(leftCost[n-1], rightCost[0]);\\n\\n\\tfor(int i=0; i<n-1; i++){\\n\\t\\t// Min cost to remove illegal goods (1\\'s) = \\n\\t\\t// Min cost to remove 1\\'s from [0,i] + min cost to remove 1\\'s from [i+1,n]\\n\\t\\tminCost = min(minCost, leftCost[i]+rightCost[i+1]);\\n\\t}\\n\\treturn minCost;\\n}\\n```\\n\\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint minimumTime(string s) {\\n\\tint n = s.size();\\n\\n\\t// Find the cost for removing the illegal goods considering we have only two options:\\n\\t// 1. We can remove from the left end with cost 1\\n\\t// 2. We can remove from anywhere in the middle with cost 2\\n\\n\\tvector<int> leftCost(n,0);\\n\\tif(s[0] == \\'1\\'){\\n\\t\\tleftCost[0] = 1;\\n\\t}\\n\\tfor(int i=1; i<n; i++){\\n\\t\\tif(s[i] == \\'0\\'){\\n\\t\\t\\t// Legal good .i.e no need to remove it\\n\\t\\t\\t// Hence the removal cost will not increase\\n\\t\\t\\tleftCost[i] = leftCost[i-1];\\n\\t\\t}\\n\\t\\telse{\\n\\t\\t\\t// Illegal good, two ways to remove it:\\n\\t\\t\\t// Remove it from middle with cost 2 and add it to previous cost\\n\\t\\t\\t// Remove all the elements from the left with cost 1\\n\\t\\t\\t// We\\'ll not add leftCost[i-1] here because  all the elements are removed from left end, so its cost is covered\\n\\t\\t\\tleftCost[i] = min(leftCost[i-1]+2, i+1);\\n\\t\\t}\\n\\t}\\n\\n\\t// Similarly find cost for removing the illegal goods considering we have only two options:\\n\\t// 1. We can remove from the right end with cost 1\\n\\t// 2. We can remove from anywhere in the middle with cost 2\\n\\n\\tvector<int> rightCost(n, 0);\\n\\n\\tif(s[n-1] == \\'1\\')\\n\\t\\trightCost[n-1] = 1;\\n\\n\\tfor(int i=n-2; i>=0; i--){\\n\\t\\tif(s[i] == \\'0\\')\\n\\t\\t\\trightCost[i] = rightCost[i+1];\\n\\t\\telse\\n\\t\\t\\trightCost[i] = min(rightCost[i+1]+2, n-i);\\n\\t}\\n\\n\\t// Now, find cost for removing the illegal goods considering we have all three options:\\n\\t// 1. We can remove from the right end with cost 1\\n\\t// 2. We can remove from the right end with cost 1\\n\\t// 3. We can remove from anywhere in the middle with cost 2\\n\\n\\t// leftCost[n-1] will store the min cost to remove all 1\\'s (only left and middle removal)\\n\\t// rightCost[0] will store the min cost to remove all 1\\'s (only right and middle removal)\\n\\n\\tint minCost = min(leftCost[n-1], rightCost[0]);\\n\\n\\tfor(int i=0; i<n-1; i++){\\n\\t\\t// Min cost to remove illegal goods (1\\'s) = \\n\\t\\t// Min cost to remove 1\\'s from [0,i] + min cost to remove 1\\'s from [i+1,n]\\n\\t\\tminCost = min(minCost, leftCost[i]+rightCost[i+1]);\\n\\t}\\n\\treturn minCost;\\n}\\n```\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1751616,
                "title": "c-prefix-suffix-easily-understandable-soln-intuitions-explained-clearly-beginner-friendly-code",
                "content": "### Intuition : - We will find the min time from left to right & right to left for each positions . \\n### \\n### In left to right , We will consider  REMOVAL TIME as ( abs(i+1)  (removing each one by one fro leftmost starting point) , left[i-1[ + 2 (for random removal ) .\\n### \\n### In right  to left , We will consider REMOVAL TIMEas ( abs(n-i)  (removing each one by one fro rightmost starting point) , right[i+1[ + 2 (for random removal ) .\\n### \\n### After that Take the min value from( left[i]  (Min value of index i =0 to lets say k ) + right[i+1]  (Min value of index i=n-1 to k+1 )) . & Togetherly sum will give min time for whole array .**\\n\\n\\n\\n\\n\\n\\n\\nint minimumTime(string s) {\\n        \\n           int n=s.size();\\n            \\n            vector<int> left(n,0 ) , right(n,0);\\n            \\n            int ind=0;\\n            if(s[0]==\\'1\\')\\n            {\\n                    left[0]=1;\\n            }\\n            for(int i=1;i<n;i++)\\n            {\\n                    if(s[i]==\\'1\\' )\\n                    {\\n                            int val = min(i+1,left[i-1] + 2);\\n                            left[i]=val;\\n                    }\\n                    else\\n                    {\\n                            left[i]=left[i-1];\\n                    }\\n            }\\n            if(s[n-1]==\\'1\\')\\n            {\\n                    right[n-1]=1;\\n            }\\n            for(int i=n-2;i>=0;i--)\\n            {\\n                    if(s[i]==\\'1\\')\\n                    {\\n                            int val=min(n-i , right[i+1]+2);\\n                            right[i]=val;\\n                    }\\n                    else\\n                    {\\n                            right[i]=right[i+1];\\n                    }\\n            }\\n            \\n            int ans=min(right[0],left[n-1]);\\n            \\n            for(int i=1;i<n-1;i++)\\n            {\\n                    ans=min(ans , left[i] + right[i+1] );\\n            }\\n            return ans;\\n            \\n    }\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "### Intuition : - We will find the min time from left to right & right to left for each positions . \\n### \\n### In left to right , We will consider  REMOVAL TIME as ( abs(i+1)  (removing each one by one fro leftmost starting point) , left[i-1[ + 2 (for random removal ) .\\n### \\n### In right  to left , We will consider REMOVAL TIMEas ( abs(n-i)  (removing each one by one fro rightmost starting point) , right[i+1[ + 2 (for random removal ) .\\n### \\n### After that Take the min value from( left[i]  (Min value of index i =0 to lets say k ) + right[i+1]  (Min value of index i=n-1 to k+1 )) . & Togetherly sum will give min time for whole array .**\\n\\n\\n\\n\\n\\n\\n\\nint minimumTime(string s) {\\n        \\n           int n=s.size();\\n            \\n            vector<int> left(n,0 ) , right(n,0);\\n            \\n            int ind=0;\\n            if(s[0]==\\'1\\')\\n            {\\n                    left[0]=1;\\n            }\\n            for(int i=1;i<n;i++)\\n            {\\n                    if(s[i]==\\'1\\' )\\n                    {\\n                            int val = min(i+1,left[i-1] + 2);\\n                            left[i]=val;\\n                    }\\n                    else\\n                    {\\n                            left[i]=left[i-1];\\n                    }\\n            }\\n            if(s[n-1]==\\'1\\')\\n            {\\n                    right[n-1]=1;\\n            }\\n            for(int i=n-2;i>=0;i--)\\n            {\\n                    if(s[i]==\\'1\\')\\n                    {\\n                            int val=min(n-i , right[i+1]+2);\\n                            right[i]=val;\\n                    }\\n                    else\\n                    {\\n                            right[i]=right[i+1];\\n                    }\\n            }\\n            \\n            int ans=min(right[0],left[n-1]);\\n            \\n            for(int i=1;i<n-1;i++)\\n            {\\n                    ans=min(ans , left[i] + right[i+1] );\\n            }\\n            return ans;\\n            \\n    }\\n\\n\\n\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1751008,
                "title": "java-prefix-suffix-after-watching-3-videos-and-6-wa",
                "content": "# Success you know struggle you don\\'t\\n![image](https://assets.leetcode.com/users/images/3a805a94-9e44-4ee9-941b-ecc546c540eb_1644182446.9697533.png)\\n\\n**Now coming to code and explaination**\\n\\nBasic and straight forward idea is that if you are at a particular car and you wanted to know how much minimum money you can spend to be at that car => you can easily calculate by adding that how much you have paid from left side and right side.\\n\\n\\n```\\nclass Solution {\\n    public int minimumTime(String s) {\\n        int n = s.length();\\n        int[] arr1 = new int[n]; // right to left\\n        int[] arr2 = new int[n]; // left to right\\n        if(s.charAt(n-1)-\\'0\\'==1) arr1[n-1] = 1;\\n        for(int i=n-2;i>=0;i--){\\n            if(s.charAt(i)-\\'0\\'==1) arr1[i] = Math.min(arr1[i+1]+2,n-i); // arr[i+1] will keep sum till previous more like sum_from_right_so_far\\n            else arr1[i] = arr1[i+1];\\n        }\\n        if(s.charAt(0)-\\'0\\'==1) arr2[0] = 1;\\n        for(int i=1;i<n;i++){\\n            if(s.charAt(i)-\\'0\\'==1) arr2[i] = Math.min(arr2[i-1]+2,i+1);// arr[i+1] will keep sum till previous more like sum_from_left_so_far\\n            else arr2[i] = arr2[i-1];\\n        }\\n        int minOfAllZero = Integer.MAX_VALUE;\\n        minOfAllZero = Math.min(arr1[0],arr2[n-1]);\\n        for(int i=0;i<n-2;i++){\\n                minOfAllZero = Math.min(minOfAllZero,arr2[i]+arr1[i+1]);\\n        }\\n        return minOfAllZero;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumTime(String s) {\\n        int n = s.length();\\n        int[] arr1 = new int[n]; // right to left\\n        int[] arr2 = new int[n]; // left to right\\n        if(s.charAt(n-1)-\\'0\\'==1) arr1[n-1] = 1;\\n        for(int i=n-2;i>=0;i--){\\n            if(s.charAt(i)-\\'0\\'==1) arr1[i] = Math.min(arr1[i+1]+2,n-i); // arr[i+1] will keep sum till previous more like sum_from_right_so_far\\n            else arr1[i] = arr1[i+1];\\n        }\\n        if(s.charAt(0)-\\'0\\'==1) arr2[0] = 1;\\n        for(int i=1;i<n;i++){\\n            if(s.charAt(i)-\\'0\\'==1) arr2[i] = Math.min(arr2[i-1]+2,i+1);// arr[i+1] will keep sum till previous more like sum_from_left_so_far\\n            else arr2[i] = arr2[i-1];\\n        }\\n        int minOfAllZero = Integer.MAX_VALUE;\\n        minOfAllZero = Math.min(arr1[0],arr2[n-1]);\\n        for(int i=0;i<n-2;i++){\\n                minOfAllZero = Math.min(minOfAllZero,arr2[i]+arr1[i+1]);\\n        }\\n        return minOfAllZero;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749444,
                "title": "easy-c-solution-prefix-and-suffix",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int n = s.size();\\n        int cost = 0;\\n        vector<int> left(n, 0), right(n, 0);\\n            \\n        if(s[0] == \\'1\\')\\n        left[0] = 1;\\n        for(int i=1; i<n; i++)\\n        {\\n           if(s[i] == \\'1\\')\\n           left[i] = min(left[i-1]+2, i+1);    \\n           else\\n           left[i] = left[i-1];\\n        }\\n            \\n        if(s[n-1] == \\'1\\')\\n        right[n-1] = 1;\\n        for(int i = n-2; i>=0; i--)\\n        {\\n           if(s[i] == \\'1\\')\\n           right[i] = min(n-i, right[i+1]+2);\\n           else\\n           right[i] = right[i+1];\\n        }\\n       cost = min(left[n-1], right[0]);\\n       for(int i=0; i<n-2; i++)\\n       {\\n               cost = min(cost, (left[i]+right[i+1]));\\n       }\\n       return cost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int n = s.size();\\n        int cost = 0;\\n        vector<int> left(n, 0), right(n, 0);\\n            \\n        if(s[0] == \\'1\\')\\n        left[0] = 1;\\n        for(int i=1; i<n; i++)\\n        {\\n           if(s[i] == \\'1\\')\\n           left[i] = min(left[i-1]+2, i+1);    \\n           else\\n           left[i] = left[i-1];\\n        }\\n            \\n        if(s[n-1] == \\'1\\')\\n        right[n-1] = 1;\\n        for(int i = n-2; i>=0; i--)\\n        {\\n           if(s[i] == \\'1\\')\\n           right[i] = min(n-i, right[i+1]+2);\\n           else\\n           right[i] = right[i+1];\\n        }\\n       cost = min(left[n-1], right[0]);\\n       for(int i=0; i<n-2; i++)\\n       {\\n               cost = min(cost, (left[i]+right[i+1]));\\n       }\\n       return cost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749304,
                "title": "python-plain-solution",
                "content": "```\\nclass Solution(object):\\n    def minimumTime(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        right = [0]*(len(s)+1)\\n        \\n        for i in range(len(s)-1, -1, -1):\\n            if s[i] == \\'1\\':\\n                right[i] = min(right[i+1] + 2, len(s)-i)\\n            else:\\n                right[i] = right[i+1]\\n                \\n        left = 0\\n        res = len(s)\\n        for j in range(len(s)):\\n            if s[j] == \\'1\\':\\n                left = min(left + 2, j+1)\\n            res = min(res, left + right[j+1])\\n            \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minimumTime(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        right = [0]*(len(s)+1)\\n        \\n        for i in range(len(s)-1, -1, -1):\\n            if s[i] == \\'1\\':\\n                right[i] = min(right[i+1] + 2, len(s)-i)\\n            else:\\n                right[i] = right[i+1]\\n                \\n        left = 0\\n        res = len(s)\\n        for j in range(len(s)):\\n            if s[j] == \\'1\\':\\n                left = min(left + 2, j+1)\\n            res = min(res, left + right[j+1])\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749124,
                "title": "javascript-dp-179ms",
                "content": "```\\nconst minimumTime = (s) => {\\n    let n = s.length, minCostLM = 0, res = Number.MAX_SAFE_INTEGER;\\n    for (let i = 0; i < n; i++) {\\n\\t   // update min cost from left compared with just middle, i + 1: all use left cost, minCostLM + 2: prev left cost + current middle cost\\n        if (s[i] == \\'1\\') minCostLM = Math.min(i + 1, minCostLM + 2); \\n        let rightCost = n - i - 1;\\n        res = Math.min(res, minCostLM + rightCost);\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nconst minimumTime = (s) => {\\n    let n = s.length, minCostLM = 0, res = Number.MAX_SAFE_INTEGER;\\n    for (let i = 0; i < n; i++) {\\n\\t   // update min cost from left compared with just middle, i + 1: all use left cost, minCostLM + 2: prev left cost + current middle cost\\n        if (s[i] == \\'1\\') minCostLM = Math.min(i + 1, minCostLM + 2); \\n        let rightCost = n - i - 1;\\n        res = Math.min(res, minCostLM + rightCost);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1749077,
                "title": "left-and-right",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumTime(string s)\\n    {\\n       int n = s.length(),dp_right[200000],dp_left[200000];\\n        \\n       for(int i = 0;i < n;i++)\\n       {\\n           if(i == 0)\\n           dp_left[i] = s[i]-\\'0\\';\\n           else\\n           {\\n               if(s[i] == \\'1\\')\\n               dp_left[i] = min(i+1,dp_left[i-1]+2);\\n               else\\n               dp_left[i] = dp_left[i-1];\\n           }\\n       }\\n\\n       for(int i = n-1;i >= 0;i--)\\n       {\\n           if(i == n-1)\\n           dp_right[i] = s[i]-\\'0\\';\\n           else\\n           {\\n               if(s[i] == \\'1\\')\\n               dp_right[i] = min(n-i,dp_right[i+1]+2);\\n               else\\n               dp_right[i] = dp_right[i+1];\\n           }\\n       }\\n        \\n       int ans  = min(dp_right[0],dp_left[n-1]);\\n       for(int i = 0;i < n-1;i++)\\n       ans = min(ans,dp_left[i]+dp_right[i+1]);\\n       return ans; \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(string s)\\n    {\\n       int n = s.length(),dp_right[200000],dp_left[200000];\\n        \\n       for(int i = 0;i < n;i++)\\n       {\\n           if(i == 0)\\n           dp_left[i] = s[i]-\\'0\\';\\n           else\\n           {\\n               if(s[i] == \\'1\\')\\n               dp_left[i] = min(i+1,dp_left[i-1]+2);\\n               else\\n               dp_left[i] = dp_left[i-1];\\n           }\\n       }\\n\\n       for(int i = n-1;i >= 0;i--)\\n       {\\n           if(i == n-1)\\n           dp_right[i] = s[i]-\\'0\\';\\n           else\\n           {\\n               if(s[i] == \\'1\\')\\n               dp_right[i] = min(n-i,dp_right[i+1]+2);\\n               else\\n               dp_right[i] = dp_right[i+1];\\n           }\\n       }\\n        \\n       int ans  = min(dp_right[0],dp_left[n-1]);\\n       for(int i = 0;i < n-1;i++)\\n       ans = min(ans,dp_left[i]+dp_right[i+1]);\\n       return ans; \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748912,
                "title": "java-three-two-one-loop",
                "content": "**One loop**\\nCompare this deceptively short solution to Three loop and Two loop solutions below for improved intuition.\\nCompared to Two loops, it turns out there\\'s no need to precalculate the optimal suffix time - we can just use the remaining suffix length (removal from right), as the optimal prefix already includes the other two types of removals (from left and middle).\\n```\\npublic int minimumTime(String s) {\\n\\tchar[] ca= s.toCharArray();\\n\\tint n= ca.length, ans= n, time= 0;\\n\\tfor(int i=0; i<n; i++){\\n\\t\\ttime= ca[i]==\\'0\\' ? time : Math.min(time+2, i+1);\\n\\t\\tans= Math.min(ans, time + n-1-i);\\n\\t}\\n\\treturn ans;\\n}\\n\\n```\\n**Two loops**\\nsame idea as with three loops - just combine loops 1 and 3 (i.e. calculate suffix first) to make it a little more optimal, saving time and space\\n```\\n    public int minimumTime(String s) {\\n        char[] ca= s.toCharArray();\\n        int n= ca.length, rTime[]= new int[n+1];\\n        for(int i=n-1; i>-1; i--){\\n            rTime[i]= ca[i]==\\'0\\' ? rTime[i+1] : Math.min(rTime[i+1]+2, n-i);\\n        }\\n        int ans= rTime[0], lTime= 0;\\n        for(int i=0; i<n; i++){\\n            lTime= ca[i]==\\'0\\' ? lTime : Math.min(lTime+2, i+1);\\n            ans= Math.min(ans, lTime + rTime[i+1]);\\n        }\\n        return ans;\\n    }\\n```\\n\\n**Three loops**\\nCalculate optimal prefix (using removals from left and middle) and suffix (using removals from right and middle) at each step - then combine them\\n```\\npublic int minimumTime(String s) {\\n\\tchar[] ca= s.toCharArray();\\n\\tint n= ca.length;\\n\\n\\tint[] lTime= new int[n];\\n\\tlTime[0]= ca[0]==\\'0\\' ? 0 : 1;\\n\\tfor(int i=1; i<n; i++){\\n\\t\\tlTime[i]= ca[i]==\\'0\\' ? lTime[i-1] : Math.min(lTime[i-1]+2, i+1);\\n\\t}\\n\\n\\tint[] rTime= new int[n+1];\\n\\tfor(int i=n-1; i>-1; i--){\\n\\t\\trTime[i]= ca[i]==\\'0\\' ? rTime[i+1] : Math.min(rTime[i+1]+2, n-i);\\n\\t}\\n\\n\\tint ans= rTime[0];\\n\\tfor(int i=0; i<n; i++){\\n\\t\\tans= Math.min(ans, lTime[i]+rTime[i+1]);\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minimumTime(String s) {\\n\\tchar[] ca= s.toCharArray();\\n\\tint n= ca.length, ans= n, time= 0;\\n\\tfor(int i=0; i<n; i++){\\n\\t\\ttime= ca[i]==\\'0\\' ? time : Math.min(time+2, i+1);\\n\\t\\tans= Math.min(ans, time + n-1-i);\\n\\t}\\n\\treturn ans;\\n}\\n\\n```\n```\\n    public int minimumTime(String s) {\\n        char[] ca= s.toCharArray();\\n        int n= ca.length, rTime[]= new int[n+1];\\n        for(int i=n-1; i>-1; i--){\\n            rTime[i]= ca[i]==\\'0\\' ? rTime[i+1] : Math.min(rTime[i+1]+2, n-i);\\n        }\\n        int ans= rTime[0], lTime= 0;\\n        for(int i=0; i<n; i++){\\n            lTime= ca[i]==\\'0\\' ? lTime : Math.min(lTime+2, i+1);\\n            ans= Math.min(ans, lTime + rTime[i+1]);\\n        }\\n        return ans;\\n    }\\n```\n```\\npublic int minimumTime(String s) {\\n\\tchar[] ca= s.toCharArray();\\n\\tint n= ca.length;\\n\\n\\tint[] lTime= new int[n];\\n\\tlTime[0]= ca[0]==\\'0\\' ? 0 : 1;\\n\\tfor(int i=1; i<n; i++){\\n\\t\\tlTime[i]= ca[i]==\\'0\\' ? lTime[i-1] : Math.min(lTime[i-1]+2, i+1);\\n\\t}\\n\\n\\tint[] rTime= new int[n+1];\\n\\tfor(int i=n-1; i>-1; i--){\\n\\t\\trTime[i]= ca[i]==\\'0\\' ? rTime[i+1] : Math.min(rTime[i+1]+2, n-i);\\n\\t}\\n\\n\\tint ans= rTime[0];\\n\\tfor(int i=0; i<n; i++){\\n\\t\\tans= Math.min(ans, lTime[i]+rTime[i+1]);\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1748873,
                "title": "java-2-side-dp",
                "content": "```\\nclass Solution {\\n    public int minimumTime(String s) {\\n        int len = s.length();\\n        \\n        if (s.length() == 1) {\\n            return s.charAt(0) == \\'1\\' ? 1 : 0;\\n        }\\n\\n        int[] dp1 = new int[len];\\n        int[] dp2 = new int[len];\\n        \\n        for (int i = 0; i < len; i ++) {\\n            if (s.charAt(i) == \\'0\\') {\\n                dp1[i] = (i > 0 ? dp1[i-1] : 0);\\n            } else {\\n                if (i > 0) {\\n                    dp1[i] = Math.min(i + 1, dp1[i - 1] + 2);\\n                } else {\\n                    dp1[i] = i + 1;\\n                }\\n            }\\n        }\\n\\n        for (int i = len - 1; i >= 0; i --) {\\n            if (s.charAt(i) == \\'0\\') {\\n                dp2[i] = (i < len - 1 ? dp2[i+1] : 0);\\n            } else {\\n                \\n                if (i < len - 1) {\\n                    dp2[i] = Math.min(len - i, dp2[i + 1] + 2);\\n                } else {\\n                    dp2[i] = len - i;\\n                }\\n            }\\n        }\\n        \\n        int res = Integer.MAX_VALUE;\\n        for (int i = 0; i < len - 1; i ++) {\\n            res = Math.min(res, dp1[i] + dp2[i + 1]);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumTime(String s) {\\n        int len = s.length();\\n        \\n        if (s.length() == 1) {\\n            return s.charAt(0) == \\'1\\' ? 1 : 0;\\n        }\\n\\n        int[] dp1 = new int[len];\\n        int[] dp2 = new int[len];\\n        \\n        for (int i = 0; i < len; i ++) {\\n            if (s.charAt(i) == \\'0\\') {\\n                dp1[i] = (i > 0 ? dp1[i-1] : 0);\\n            } else {\\n                if (i > 0) {\\n                    dp1[i] = Math.min(i + 1, dp1[i - 1] + 2);\\n                } else {\\n                    dp1[i] = i + 1;\\n                }\\n            }\\n        }\\n\\n        for (int i = len - 1; i >= 0; i --) {\\n            if (s.charAt(i) == \\'0\\') {\\n                dp2[i] = (i < len - 1 ? dp2[i+1] : 0);\\n            } else {\\n                \\n                if (i < len - 1) {\\n                    dp2[i] = Math.min(len - i, dp2[i + 1] + 2);\\n                } else {\\n                    dp2[i] = len - i;\\n                }\\n            }\\n        }\\n        \\n        int res = Integer.MAX_VALUE;\\n        for (int i = 0; i < len - 1; i ++) {\\n            res = Math.min(res, dp1[i] + dp2[i + 1]);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748806,
                "title": "python-easy-to-understand-dp-o-n-time-o-1-space",
                "content": "O(n) time O(1) space solution\\n```\\nclass Solution:\\n    def minimumTime(self, s: str) -> int:\\n        n = len(s)\\n        REMOVE_FROM_LEFT, REMOVE_FROM_RIGHT, LEAVE = 0, 1, 2\\n        dp = [[0, 0, 0] for _ in range(2)]\\n        # dp[index][action]\\n        curr = dp[0]\\n        if s[0] == \\'0\\':\\n            curr[REMOVE_FROM_LEFT] = 1\\n            curr[REMOVE_FROM_RIGHT] = 1\\n            curr[LEAVE] = 0\\n        else:\\n            curr[REMOVE_FROM_LEFT] = 1\\n            curr[REMOVE_FROM_RIGHT] = 1\\n            curr[LEAVE] = 2\\n        prev = curr\\n        for i in range(1, n):\\n            i2 = i % 2\\n            curr = dp[i2]\\n            if s[i] == \\'0\\':\\n                curr[LEAVE] = min(prev[LEAVE], prev[REMOVE_FROM_LEFT])\\n                curr[REMOVE_FROM_LEFT] = 1 + prev[REMOVE_FROM_LEFT]\\n                curr[REMOVE_FROM_RIGHT] = 1 + min(prev)\\n            else:\\n                curr[LEAVE] = 2 + min(prev[LEAVE], prev[REMOVE_FROM_LEFT])\\n                curr[REMOVE_FROM_LEFT] = 1 + prev[REMOVE_FROM_LEFT]\\n                curr[REMOVE_FROM_RIGHT] = 1 + min(prev)\\n            prev = curr\\n        return min(curr)\\n```\\nThis is a formulaic modification of the straightforward O(n) space version (which FWIW is the version I submitted in the contest), namely\\n```\\nclass Solution:\\n    def minimumTime(self, s: str) -> int:\\n        n = len(s)\\n        REMOVE_FROM_LEFT, REMOVE_FROM_RIGHT, LEAVE = 0, 1, 2\\n        dp = [[0, 0, 0] for _ in range(n)]\\n        # dp[index][action]\\n        curr = dp[0]\\n        if s[0] == \\'0\\':\\n            curr[REMOVE_FROM_LEFT] = 1\\n            curr[REMOVE_FROM_RIGHT] = 1\\n            curr[LEAVE] = 0\\n        else:\\n            curr[REMOVE_FROM_LEFT] = 1\\n            curr[REMOVE_FROM_RIGHT] = 1\\n            curr[LEAVE] = 2\\n        prev = curr\\n        for i in range(1, n):\\n            curr = dp[i]\\n            if s[i] == \\'0\\':\\n                curr[LEAVE] = min(prev[LEAVE], prev[REMOVE_FROM_LEFT])\\n                curr[REMOVE_FROM_LEFT] = 1 + prev[REMOVE_FROM_LEFT]\\n                curr[REMOVE_FROM_RIGHT] = 1 + min(prev)\\n            else:\\n                curr[LEAVE] = 2 + min(prev[LEAVE], prev[REMOVE_FROM_LEFT])\\n                curr[REMOVE_FROM_LEFT] = 1 + prev[REMOVE_FROM_LEFT]\\n                curr[REMOVE_FROM_RIGHT] = 1 + min(prev)\\n            prev = curr\\n        return min(curr)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, s: str) -> int:\\n        n = len(s)\\n        REMOVE_FROM_LEFT, REMOVE_FROM_RIGHT, LEAVE = 0, 1, 2\\n        dp = [[0, 0, 0] for _ in range(2)]\\n        # dp[index][action]\\n        curr = dp[0]\\n        if s[0] == \\'0\\':\\n            curr[REMOVE_FROM_LEFT] = 1\\n            curr[REMOVE_FROM_RIGHT] = 1\\n            curr[LEAVE] = 0\\n        else:\\n            curr[REMOVE_FROM_LEFT] = 1\\n            curr[REMOVE_FROM_RIGHT] = 1\\n            curr[LEAVE] = 2\\n        prev = curr\\n        for i in range(1, n):\\n            i2 = i % 2\\n            curr = dp[i2]\\n            if s[i] == \\'0\\':\\n                curr[LEAVE] = min(prev[LEAVE], prev[REMOVE_FROM_LEFT])\\n                curr[REMOVE_FROM_LEFT] = 1 + prev[REMOVE_FROM_LEFT]\\n                curr[REMOVE_FROM_RIGHT] = 1 + min(prev)\\n            else:\\n                curr[LEAVE] = 2 + min(prev[LEAVE], prev[REMOVE_FROM_LEFT])\\n                curr[REMOVE_FROM_LEFT] = 1 + prev[REMOVE_FROM_LEFT]\\n                curr[REMOVE_FROM_RIGHT] = 1 + min(prev)\\n            prev = curr\\n        return min(curr)\\n```\n```\\nclass Solution:\\n    def minimumTime(self, s: str) -> int:\\n        n = len(s)\\n        REMOVE_FROM_LEFT, REMOVE_FROM_RIGHT, LEAVE = 0, 1, 2\\n        dp = [[0, 0, 0] for _ in range(n)]\\n        # dp[index][action]\\n        curr = dp[0]\\n        if s[0] == \\'0\\':\\n            curr[REMOVE_FROM_LEFT] = 1\\n            curr[REMOVE_FROM_RIGHT] = 1\\n            curr[LEAVE] = 0\\n        else:\\n            curr[REMOVE_FROM_LEFT] = 1\\n            curr[REMOVE_FROM_RIGHT] = 1\\n            curr[LEAVE] = 2\\n        prev = curr\\n        for i in range(1, n):\\n            curr = dp[i]\\n            if s[i] == \\'0\\':\\n                curr[LEAVE] = min(prev[LEAVE], prev[REMOVE_FROM_LEFT])\\n                curr[REMOVE_FROM_LEFT] = 1 + prev[REMOVE_FROM_LEFT]\\n                curr[REMOVE_FROM_RIGHT] = 1 + min(prev)\\n            else:\\n                curr[LEAVE] = 2 + min(prev[LEAVE], prev[REMOVE_FROM_LEFT])\\n                curr[REMOVE_FROM_LEFT] = 1 + prev[REMOVE_FROM_LEFT]\\n                curr[REMOVE_FROM_RIGHT] = 1 + min(prev)\\n            prev = curr\\n        return min(curr)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748708,
                "title": "c-prefix-suffix-in-linear-time-space-complexity",
                "content": "topics : prefix-suffix\\ntime complexitiy: O(N)\\nspace complexity: O(N)\\n\\t\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        vector<int> pre(s.size(), 0), suf(s.size(), 0);\\n        // prefix\\n        for(int i=0; i<s.size(); i++) {\\n            if(i == 0) {\\n                pre[i] = s[i] - \\'0\\';\\n            }\\n            else {\\n                if(s[i] == \\'1\\')\\n                    pre[i] = min(pre[i-1] + 2, i + 1);\\n                else\\n                    pre[i] = pre[i-1];\\n            }\\n        }\\n        // suffix\\n        for(int i=s.size()-1; i>=0; i--) {\\n            if(i == s.size()-1) {\\n                suf[i] = s[i] - \\'0\\';\\n            }\\n            else {\\n                if(s[i] == \\'1\\')\\n                    suf[i] = min(suf[i+1] + 2, int(s.size() - i));\\n                else\\n                    suf[i] = suf[i+1];\\n            }\\n        }\\n        \\n        int ans = INT_MAX;\\n        // find the minimum answer\\n        for(int i=0; i<s.size()-1; i++) {\\n            ans = min(ans, pre[i] + suf[i+1]);  \\n        }\\n        \\n        // this corner case required as above for loop runs only is size fo str > 1\\n        if(s.size() == 1) {\\n            return pre[0];\\n        }\\n        \\n        //if string not contains any 1\\'s\\n        if(ans == INT_MAX)\\n            ans = 0;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        vector<int> pre(s.size(), 0), suf(s.size(), 0);\\n        // prefix\\n        for(int i=0; i<s.size(); i++) {\\n            if(i == 0) {\\n                pre[i] = s[i] - \\'0\\';\\n            }\\n            else {\\n                if(s[i] == \\'1\\')\\n                    pre[i] = min(pre[i-1] + 2, i + 1);\\n                else\\n                    pre[i] = pre[i-1];\\n            }\\n        }\\n        // suffix\\n        for(int i=s.size()-1; i>=0; i--) {\\n            if(i == s.size()-1) {\\n                suf[i] = s[i] - \\'0\\';\\n            }\\n            else {\\n                if(s[i] == \\'1\\')\\n                    suf[i] = min(suf[i+1] + 2, int(s.size() - i));\\n                else\\n                    suf[i] = suf[i+1];\\n            }\\n        }\\n        \\n        int ans = INT_MAX;\\n        // find the minimum answer\\n        for(int i=0; i<s.size()-1; i++) {\\n            ans = min(ans, pre[i] + suf[i+1]);  \\n        }\\n        \\n        // this corner case required as above for loop runs only is size fo str > 1\\n        if(s.size() == 1) {\\n            return pre[0];\\n        }\\n        \\n        //if string not contains any 1\\'s\\n        if(ans == INT_MAX)\\n            ans = 0;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748604,
                "title": "c-shortest-clear-understanding-code-o-n-dp-space-can-be-reduced-to-o-1",
                "content": "In the end, operations can be done in the format like `(op1)(op1)(op1)....(op3)....(op3)....(op2)(op2)(op2)`. We use `f[i]` to represent the prefix cost when the last `op3` or `op1` or `no op` is at `i`. \\n\\nObviously, space can be reduced to O(1), since we only need `f[i-1]` and the enumrate process can be done at the same time of dp.\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int n = s.size();\\n        vector<int>f(n, n);\\n        f[0] = min((s[0]==\\'1\\')*2, 1);\\n        for(int i=1;i<n;i++) {\\n            f[i] = min(f[i-1] + (s[i]==\\'1\\')*2, i+1);\\n        }\\n        int ret =f[n-1];\\n\\t\\t// enumerate the position of op2.\\n        for(int i= n-1;i>=1;i--){\\n            ret = min(ret, n-i+f[i-1]);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int n = s.size();\\n        vector<int>f(n, n);\\n        f[0] = min((s[0]==\\'1\\')*2, 1);\\n        for(int i=1;i<n;i++) {\\n            f[i] = min(f[i-1] + (s[i]==\\'1\\')*2, i+1);\\n        }\\n        int ret =f[n-1];\\n\\t\\t// enumerate the position of op2.\\n        for(int i= n-1;i>=1;i--){\\n            ret = min(ret, n-i+f[i-1]);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748591,
                "title": "java-prefix-sum-easy-solution-o-n-solution",
                "content": "```\\nclass Solution {\\n    public int minimumTime(String s) {\\n        int cost = 0;\\n        int n = s.length();\\n\\t\\t// removing all left 1\\'s\\n        int i = 0;\\n        for(; i<n; i++){\\n            int val = s.charAt(i) - \\'0\\';\\n            if(val==1){\\n                cost += 1;\\n            }else{\\n                break;\\n            }\\n        }\\n        if(i==n) return cost;\\n\\t\\t// removing all right 1\\'s\\n        int j = n - 1;\\n        for(; j > i; j--){\\n            int val = s.charAt(j) - \\'0\\';\\n            if(val==1){\\n                cost +=1;\\n            }else{\\n                break;\\n            }\\n        }\\n        \\n        return cost + cal(s.substring(i, j+1));\\n        \\n    }\\n    \\n    public int cal(String s){\\n        int n = s.length(), cost = Integer.MAX_VALUE;\\n        int[] l = new int[n], r = new int[n];\\n\\t\\t// cost for removing left elements\\n        for(int i=1; i<n; i++){\\n            int val = s.charAt(i) - \\'0\\';\\n            int prev = s.charAt(i-1) - \\'0\\';\\n            if(val == 1){\\n\\t\\t\\t\\t// prev num is 1 and cost for removing prev 1 is equal to index\\n\\t\\t\\t\\t// next element removal cost becomes 1\\n                if(prev==1 && l[i-1] == i){\\n                    l[i] = 1 + l[i-1];\\n                }else{\\n                    l[i] = 2 + l[i-1];\\n                }\\n            }else{\\n                l[i] = l[i-1];\\n            }\\n        }\\n        \\n        // cost for removing left elements\\n        for(int i=n-2; i>=0; i--){\\n            int val = s.charAt(i) - \\'0\\';\\n            int prev = s.charAt(i+1) - \\'0\\';\\n            if(val == 1){\\n                if(prev==1 && r[i+1] == n-i-1){\\n                    r[i] = 1 + r[i+1];\\n                }else{\\n                    r[i] = 2 + r[i+1];\\n                }\\n            }else{\\n                r[i] = r[i+1];\\n            }\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            cost = Math.min(cost, l[i]+r[i]);\\n        }\\n\\n        return cost;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumTime(String s) {\\n        int cost = 0;\\n        int n = s.length();\\n\\t\\t// removing all left 1\\'s\\n        int i = 0;\\n        for(; i<n; i++){\\n            int val = s.charAt(i) - \\'0\\';\\n            if(val==1){\\n                cost += 1;\\n            }else{\\n                break;\\n            }\\n        }\\n        if(i==n) return cost;\\n\\t\\t// removing all right 1\\'s\\n        int j = n - 1;\\n        for(; j > i; j--){\\n            int val = s.charAt(j) - \\'0\\';\\n            if(val==1){\\n                cost +=1;\\n            }else{\\n                break;\\n            }\\n        }\\n        \\n        return cost + cal(s.substring(i, j+1));\\n        \\n    }\\n    \\n    public int cal(String s){\\n        int n = s.length(), cost = Integer.MAX_VALUE;\\n        int[] l = new int[n], r = new int[n];\\n\\t\\t// cost for removing left elements\\n        for(int i=1; i<n; i++){\\n            int val = s.charAt(i) - \\'0\\';\\n            int prev = s.charAt(i-1) - \\'0\\';\\n            if(val == 1){\\n\\t\\t\\t\\t// prev num is 1 and cost for removing prev 1 is equal to index\\n\\t\\t\\t\\t// next element removal cost becomes 1\\n                if(prev==1 && l[i-1] == i){\\n                    l[i] = 1 + l[i-1];\\n                }else{\\n                    l[i] = 2 + l[i-1];\\n                }\\n            }else{\\n                l[i] = l[i-1];\\n            }\\n        }\\n        \\n        // cost for removing left elements\\n        for(int i=n-2; i>=0; i--){\\n            int val = s.charAt(i) - \\'0\\';\\n            int prev = s.charAt(i+1) - \\'0\\';\\n            if(val == 1){\\n                if(prev==1 && r[i+1] == n-i-1){\\n                    r[i] = 1 + r[i+1];\\n                }else{\\n                    r[i] = 2 + r[i+1];\\n                }\\n            }else{\\n                r[i] = r[i+1];\\n            }\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            cost = Math.min(cost, l[i]+r[i]);\\n        }\\n\\n        return cost;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748515,
                "title": "python-dp-two-pass-easy-to-understand",
                "content": "Use dynamic programming where \\n* opt[i] represents the min cost to remove all 1 in s[:i]\\n* opt[i] = opt[i-1] if s[i] == 0 else min(opt[-1] + 2, i + 1)\\n\\nThe idea is, to remove a 1 at idx i from the left, \\nwe either remove all i elements before it,\\nor remove it from the middle\\n\\nDoing two pass, one from left to right\\ncalculate the min cost to remove all 1 in s[:i]\\n\\nanother pass from right to left\\ncalculate the min cost to remove all 1 in s[i:]\\n\\nThen, we only need to find out index j, where \\nopt_left[j] + opt_right[j] is minimum\\n\\n\\n```\\nclass Solution:\\n    def minimumTime(self, s: str) -> int:\\n        \"\"\"\\n        opt[i] min cost to remove s[:i]\\n        opt[i] = opt[i-1] if s[i] == 0\\n                 min(opt[-1] + 2, i + 1) if s[i] == 1\\n        \"\"\"\\n        \\n        def helper(s):\\n            opt = [0]\\n            for i in range(len(s)):\\n                if s[i] == \\'0\\':\\n                    opt.append(opt[-1])\\n                else:\\n                    opt.append(min(i + 1, opt[-1] + 2))\\n            return opt[1:]\\n    \\n        opt1 = helper(s)\\n        opt2 = helper(s[::-1])[::-1]\\n        res = max(opt1 + opt2)\\n        for i in range(len(s) - 1):\\n            res = min(res, opt1[i] + opt2[i+1])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, s: str) -> int:\\n        \"\"\"\\n        opt[i] min cost to remove s[:i]\\n        opt[i] = opt[i-1] if s[i] == 0\\n                 min(opt[-1] + 2, i + 1) if s[i] == 1\\n        \"\"\"\\n        \\n        def helper(s):\\n            opt = [0]\\n            for i in range(len(s)):\\n                if s[i] == \\'0\\':\\n                    opt.append(opt[-1])\\n                else:\\n                    opt.append(min(i + 1, opt[-1] + 2))\\n            return opt[1:]\\n    \\n        opt1 = helper(s)\\n        opt2 = helper(s[::-1])[::-1]\\n        res = max(opt1 + opt2)\\n        for i in range(len(s) - 1):\\n            res = min(res, opt1[i] + opt2[i+1])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4019739,
                "title": "efficient-and-short-js-solution-time-o-n-memory-o-1",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```js\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minimumTime = function (s) {\\n  let n = s.length;\\n  let dp = 0\\n  let res = n;\\n\\n  for (let i = 0; i < n; i++) {\\n    if (s[i] == \"1\") dp = Math.min(i + 1, dp + 2);\\n    res = Math.min(res, dp + n - i - 1);\\n  }\\n  \\n  return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minimumTime = function (s) {\\n  let n = s.length;\\n  let dp = 0\\n  let res = n;\\n\\n  for (let i = 0; i < n; i++) {\\n    if (s[i] == \"1\") dp = Math.min(i + 1, dp + 2);\\n    res = Math.min(res, dp + n - i - 1);\\n  }\\n  \\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3991824,
                "title": "beginner-friendly-time-o-n-space-o-1-one-loop-detail-explaination",
                "content": "# Intuition\\nRemove some cars from left at cost 1\\nRemove some cars  fron right at cost 1\\nRemove rest from middle at cost 2\\n\\nSo, take the minimum cost to remove illegal cars left to ith index + cost to remove all cars from ith index to the end\\n\\nOverall minimum from all index is final ans.\\n\\n# Approach\\nIn the code, back_clear is actually the minimum cost required to remove all illegal cars to the left of ith index.\\n\\nmn is the possible answer at the ith index.\\n\\n\\n```\\n// It is possible ans at ith index\\nback_clear + (n - i)\\n```\\n\\nIf you get \\'1\\' at ith index you have two choices\\n   either add 2 in previous for removing single car. (back_clear += 2)\\n   or remove all cars left to it. (back_clear = i+1)\\n\\ntake min of both choices \\n```\\nif (i < n && s[i] == \\'1\\') {\\n        back_clear = min(back_clear + 2, i - 0 + 1);\\n}\\n```\\n\\n# Code\\n```\\nclass Solution {\\n   public:\\n    int solve(string s) {\\n        int n = s.size(), back_clear = 0, mn = INT_MAX;\\n        \\n        for (int i = 0; i <= n; i++) {\\n            mn = min(mn, back_clear + (n - i));\\n            if (i < n && s[i] == \\'1\\') {\\n                back_clear = min(back_clear + 2, i - 0 + 1);\\n            }\\n        }\\n        return mn == INT_MAX ? 0 : mn;\\n    }\\n\\n    int minimumTime(string s) { return solve(s); }\\n};\\n\\n```\\n\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(1)\\n\\n```\\nIF HELPFUL \\n   PLEASE UPVOTE \\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// It is possible ans at ith index\\nback_clear + (n - i)\\n```\n```\\nif (i < n && s[i] == \\'1\\') {\\n        back_clear = min(back_clear + 2, i - 0 + 1);\\n}\\n```\n```\\nclass Solution {\\n   public:\\n    int solve(string s) {\\n        int n = s.size(), back_clear = 0, mn = INT_MAX;\\n        \\n        for (int i = 0; i <= n; i++) {\\n            mn = min(mn, back_clear + (n - i));\\n            if (i < n && s[i] == \\'1\\') {\\n                back_clear = min(back_clear + 2, i - 0 + 1);\\n            }\\n        }\\n        return mn == INT_MAX ? 0 : mn;\\n    }\\n\\n    int minimumTime(string s) { return solve(s); }\\n};\\n\\n```\n```\\nIF HELPFUL \\n   PLEASE UPVOTE \\uD83D\\uDC4D\\uD83D\\uDC4D\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3852807,
                "title": "3-lines-cpp-solution-no-use-of-dynamic-programming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) \\n    {\\n        int n = s.length();\\n        int start = 0;//start indicates ith index of 1 at every stage\\n        //I prefer to dry run my code for any one test case , u will feel the actual concept behind it\\n        int ans = n;\\n        for(int i=0; i<n; i++)\\n        {\\n            start = min(start + (s[i]-\\'0\\')*2 , i+1);\\n            ans = min(ans , start + n - 1 - i);\\n        }\\n        return ans;\\n    }\\n};\\n```//Please upvote if it helps uh",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) \\n    {\\n        int n = s.length();\\n        int start = 0;//start indicates ith index of 1 at every stage\\n        //I prefer to dry run my code for any one test case , u will feel the actual concept behind it\\n        int ans = n;\\n        for(int i=0; i<n; i++)\\n        {\\n            start = min(start + (s[i]-\\'0\\')*2 , i+1);\\n            ans = min(ans , start + n - 1 - i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3762976,
                "title": "my-solutions",
                "content": "**1. Use the DP `I`**\\n```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the string `s`\\n */\\nclass Solution {\\n public:\\n  int minimumTime(const string &s) {\\n    constexpr char legal = \\'0\\';\\n    const int n = static_cast<int>(s.size());\\n    int left[n + 1];\\n    memset(left, 0, sizeof(left));\\n    for (int i = 0; i < n; ++i) {\\n      if (s[i] == legal) {\\n        left[i + 1] = left[i];\\n      } else {\\n        left[i + 1] = min(left[i] + 2, i + 1);\\n      }\\n    }\\n    \\n    int right = 0;\\n    int ret = left[n];\\n    for (int i = n - 1; i > -1; --i) {\\n      if (s[i] != legal) {\\n        right = min(right + 2, n - i);\\n      }\\n      ret = min(ret, left[i] + right);\\n    }\\n    return ret;\\n  }\\n};\\n```\\n**2. Use the DP `II`**\\n```\\n/**\\n * 1. let number(a, 1) stand for the number of \\'1\\'s in the string `a`.\\n * 2. let number(a, 0) stand for the number of \\'0\\'s in the string `a`.\\n * 3. let length(a) stands for the length of the string `a`.\\n * 4. let left + middle + right = s\\n *\\n * solution = length(left) + 2 * number(middle, 1) + length(right)\\n *          = length(left) + length(middle) + length(right) + 2 * number(middle, 1) - length(middle)\\n *          = length(s) + number(middle, 1) - number(middle, 0)\\n *\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the string `s`\\n */\\nclass Solution {\\n public:\\n  int minimumTime(const string &s) {\\n    constexpr char legal = \\'0\\';\\n    const int n = static_cast<int>(s.size());\\n    int dp[n + 1];\\n    memset(dp, 0, sizeof(dp));\\n    for (int i = 0; i < n; ++i) {\\n      const int value = s[i] == legal ? -1 : 1;\\n      dp[i + 1] = min(value, dp[i] + value);\\n    }\\n    return n + *min_element(dp, dp + n + 1);\\n  }\\n};\\n```\\n**3. Use the DP `III`**\\n```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(1)\\n * where `n` is the length of the string `s`\\n */\\nclass Solution {\\n public:\\n  int minimumTime(const string &s) {\\n    constexpr char legal = \\'0\\';\\n    const int n = static_cast<int>(s.size());\\n    int dp_right = 0;\\n    int dp_middle = 0;\\n    for (int i = 0; i < n; ++i) {\\n      const bool is_legal = s[i] == legal;\\n      dp_right = min(dp_middle, dp_right) + 1;\\n      dp_middle = min(i, dp_middle) + (is_legal ? 0 : 2);\\n    }\\n    return min({n, dp_middle, dp_right});\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the string `s`\\n */\\nclass Solution {\\n public:\\n  int minimumTime(const string &s) {\\n    constexpr char legal = \\'0\\';\\n    const int n = static_cast<int>(s.size());\\n    int left[n + 1];\\n    memset(left, 0, sizeof(left));\\n    for (int i = 0; i < n; ++i) {\\n      if (s[i] == legal) {\\n        left[i + 1] = left[i];\\n      } else {\\n        left[i + 1] = min(left[i] + 2, i + 1);\\n      }\\n    }\\n    \\n    int right = 0;\\n    int ret = left[n];\\n    for (int i = n - 1; i > -1; --i) {\\n      if (s[i] != legal) {\\n        right = min(right + 2, n - i);\\n      }\\n      ret = min(ret, left[i] + right);\\n    }\\n    return ret;\\n  }\\n};\\n```\n```\\n/**\\n * 1. let number(a, 1) stand for the number of \\'1\\'s in the string `a`.\\n * 2. let number(a, 0) stand for the number of \\'0\\'s in the string `a`.\\n * 3. let length(a) stands for the length of the string `a`.\\n * 4. let left + middle + right = s\\n *\\n * solution = length(left) + 2 * number(middle, 1) + length(right)\\n *          = length(left) + length(middle) + length(right) + 2 * number(middle, 1) - length(middle)\\n *          = length(s) + number(middle, 1) - number(middle, 0)\\n *\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the string `s`\\n */\\nclass Solution {\\n public:\\n  int minimumTime(const string &s) {\\n    constexpr char legal = \\'0\\';\\n    const int n = static_cast<int>(s.size());\\n    int dp[n + 1];\\n    memset(dp, 0, sizeof(dp));\\n    for (int i = 0; i < n; ++i) {\\n      const int value = s[i] == legal ? -1 : 1;\\n      dp[i + 1] = min(value, dp[i] + value);\\n    }\\n    return n + *min_element(dp, dp + n + 1);\\n  }\\n};\\n```\n```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(1)\\n * where `n` is the length of the string `s`\\n */\\nclass Solution {\\n public:\\n  int minimumTime(const string &s) {\\n    constexpr char legal = \\'0\\';\\n    const int n = static_cast<int>(s.size());\\n    int dp_right = 0;\\n    int dp_middle = 0;\\n    for (int i = 0; i < n; ++i) {\\n      const bool is_legal = s[i] == legal;\\n      dp_right = min(dp_middle, dp_right) + 1;\\n      dp_middle = min(i, dp_middle) + (is_legal ? 0 : 2);\\n    }\\n    return min({n, dp_middle, dp_right});\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3722381,
                "title": "c-python-dynamic-proramming-solution-with-explanation",
                "content": "Enumerating all cutting lines can divide ```s``` into two parts, namely ```prefix``` and ```suffix```, one of which can be empty.\\n```prefix[i]``` is min cost to make ```s[0...i]``` clean, we only can use first type operation.\\n```suffix[i]``` is min cost to make ```s[i...]``` clean, we can use last two type operations.\\n\\n```prefix[i] = prefix[i-1] if s[i] ==\\'0\\' else i+1``` \\n\\n```suffix[i] =  suffix[i+1] if s[i] ==\\'0\\' else min(suffix[i+1] + 2, len(s) - i)``` where ``` len(s) - i``` is using third operation, ```suffix[i+1] + 2``` is using second operation.\\ntc is O(n), sc is O(n).\\n### python\\n```python\\nclass Solution:\\n    def minimumTime(self, s: str) -> int:\\n\\t\\t\\n\\t\\t# cost for s[i...]\\n        suffix = [0] * (len(s) + 1)\\n\\t\\t\\n        for i in range(len(s) - 1, -1, -1):\\n            if s[i] == \\'1\\':\\n\\t\\t\\t\\n\\t\\t\\t\\t# min(using second operation to remove s[i] + cost of s[i+1...], using third operation to remove s[i])\\n                suffix[i] = min(suffix[i+1] + 2, len(s) - i)\\n\\t\\t\\t\\t\\n            else: suffix[i] = suffix[i+1]\\n\\t\\t\\n        ans = 2 * len(s)\\n        prefix = 0\\n        for i, v in enumerate(s):\\n\\t\\t\\t\\n\\t\\t\\t# prefix[i]: using first operation to remove s[i]\\n            if v == \\'1\\': prefix = i + 1 \\n\\t\\t\\t\\n            ans = min(ans, prefix + suffix[i+1]) # cost of prefix[i] + suffix[i+1]\\n        return ans\\n```\\n\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        vector<int> suffix (s.size() + 1);\\n        int len = s.size();\\n        for (int i = s.size() - 1; i >= 0; i-=1) {\\n            if (s[i] == \\'1\\') suffix[i] = min(suffix[i+1] + 2, len - i);\\n            else suffix[i] = suffix[i+1];\\n        }\\n        int ans = 2 * s.size();\\n        int prefix = 0;\\n        for (int i = 0; i < s.size(); i+=1) {\\n            if (s[i] == \\'1\\') prefix = i + 1;\\n            ans = min(ans, prefix + suffix[i+1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```s```\n```prefix```\n```suffix```\n```prefix[i]```\n```s[0...i]```\n```suffix[i]```\n```s[i...]```\n```prefix[i] = prefix[i-1] if s[i] ==\\'0\\' else i+1```\n```suffix[i] =  suffix[i+1] if s[i] ==\\'0\\' else min(suffix[i+1] + 2, len(s) - i)```\n``` len(s) - i```\n```suffix[i+1] + 2```\n```python\\nclass Solution:\\n    def minimumTime(self, s: str) -> int:\\n\\t\\t\\n\\t\\t# cost for s[i...]\\n        suffix = [0] * (len(s) + 1)\\n\\t\\t\\n        for i in range(len(s) - 1, -1, -1):\\n            if s[i] == \\'1\\':\\n\\t\\t\\t\\n\\t\\t\\t\\t# min(using second operation to remove s[i] + cost of s[i+1...], using third operation to remove s[i])\\n                suffix[i] = min(suffix[i+1] + 2, len(s) - i)\\n\\t\\t\\t\\t\\n            else: suffix[i] = suffix[i+1]\\n\\t\\t\\n        ans = 2 * len(s)\\n        prefix = 0\\n        for i, v in enumerate(s):\\n\\t\\t\\t\\n\\t\\t\\t# prefix[i]: using first operation to remove s[i]\\n            if v == \\'1\\': prefix = i + 1 \\n\\t\\t\\t\\n            ans = min(ans, prefix + suffix[i+1]) # cost of prefix[i] + suffix[i+1]\\n        return ans\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        vector<int> suffix (s.size() + 1);\\n        int len = s.size();\\n        for (int i = s.size() - 1; i >= 0; i-=1) {\\n            if (s[i] == \\'1\\') suffix[i] = min(suffix[i+1] + 2, len - i);\\n            else suffix[i] = suffix[i+1];\\n        }\\n        int ans = 2 * s.size();\\n        int prefix = 0;\\n        for (int i = 0; i < s.size(); i+=1) {\\n            if (s[i] == \\'1\\') prefix = i + 1;\\n            ans = min(ans, prefix + suffix[i+1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696593,
                "title": "python-solution-using-kadane-s-algorithm-o-n-and-o-1",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def minimumTime(self, s: str) -> int:\\n        \\'\\'\\'\\n        the technique that we use is find middle string which contain 0 and 1 which done by cost 2 so we have to minimize that so we find maximum sum so minimum number of ones that done by cost 2 and overall cost is minimized\\n        \\'\\'\\'\\n        currentSum=0\\n        ans=0\\n        for i in range(len(s)):\\n            if(s[i]==\\'1\\'):\\n                currentSum-=1\\n            else:\\n                currentSum+=1\\n            if(currentSum<0):\\n                currentSum=0\\n            ans=max(ans,currentSum)\\n        return len(s)-ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, s: str) -> int:\\n        \\'\\'\\'\\n        the technique that we use is find middle string which contain 0 and 1 which done by cost 2 so we have to minimize that so we find maximum sum so minimum number of ones that done by cost 2 and overall cost is minimized\\n        \\'\\'\\'\\n        currentSum=0\\n        ans=0\\n        for i in range(len(s)):\\n            if(s[i]==\\'1\\'):\\n                currentSum-=1\\n            else:\\n                currentSum+=1\\n            if(currentSum<0):\\n                currentSum=0\\n            ans=max(ans,currentSum)\\n        return len(s)-ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696221,
                "title": "easiest-solution-with-best-thinking-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n        <--- KADANES\\'s Algo but it is min subarray sum of array--->\\n        INTUITION:   (means number of  one\\'s of every subproblem)\\n            min_cost=len(left)+(middle * 2)+len(right)      -->divide into subproblems\\n            min_cost=len(left)+len(middle)+len(right)+(count of ones in mid *2)-len(middle)\\n            min_cost=n + count_of_1_mid*2 -len(mid);\\n            min_cost= n+ count_of_1_mid*2 -count_of_1\\'s-count_of_0\\'s;\\n            min_cost=n + count_of_1_mid - count_of_0_mid;\\n\\n            n is constant so reduce the remaining part as much as possible\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumTime(String s) {\\n        int n=s.length();\\n        int[] arr=new int[n];\\n        for(int i=0;i<n;i++){\\n            arr[i]=(s.charAt(i)==\\'0\\')?-1:1;\\n        }\\n        int ans=n;\\n        int min=0;\\n        int sum=0;\\n        for(int i:arr){\\n            sum+=i;\\n            min=Math.min(min,sum);\\n            sum=(sum>0)?0:sum;\\n        }\\n        return ans+min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumTime(String s) {\\n        int n=s.length();\\n        int[] arr=new int[n];\\n        for(int i=0;i<n;i++){\\n            arr[i]=(s.charAt(i)==\\'0\\')?-1:1;\\n        }\\n        int ans=n;\\n        int min=0;\\n        int sum=0;\\n        for(int i:arr){\\n            sum+=i;\\n            min=Math.min(min,sum);\\n            sum=(sum>0)?0:sum;\\n        }\\n        return ans+min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685744,
                "title": "100-memory-and-60-in-speed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTime(self, s):\\n        left, min_time, n = 0, len(s), len(s)\\n\\n        for i,c in enumerate(s):\\n            left = min(left + (c==\"1\")*2,i+1)\\n            min_time = min(min_time,left + n-1-i)\\n\\n        return min_time\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, s):\\n        left, min_time, n = 0, len(s), len(s)\\n\\n        for i,c in enumerate(s):\\n            left = min(left + (c==\"1\")*2,i+1)\\n            min_time = min(min_time,left + n-1-i)\\n\\n        return min_time\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3301200,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTime(self, s):\\n        left, min_time, n = 0, len(s), len(s)\\n\\n        for i,c in enumerate(s):\\n            left = min(left + (c==\"1\")*2,i+1)\\n            min_time = min(min_time,left + n-1-i)\\n\\n        return min_time\\n\\n\\n\\n\\n        \\n\\n            \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, s):\\n        left, min_time, n = 0, len(s), len(s)\\n\\n        for i,c in enumerate(s):\\n            left = min(left + (c==\"1\")*2,i+1)\\n            min_time = min(min_time,left + n-1-i)\\n\\n        return min_time\\n\\n\\n\\n\\n        \\n\\n            \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3238901,
                "title": "dp-ez",
                "content": "\\n# Approach\\nsimple dp states\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTime(self, s: str) -> int:\\n        n=len(s)\\n        ind=[i for i in range(len(s)) if s[i]==\"1\"]\\n        if len(ind)==0:\\n            return 0\\n        dp=[[0,0,0] for i in range(len(ind))] #left spot right\\n        ans=float(\"inf\")\\n        for i in range(len(ind)):\\n            res=[0,0,0]\\n            if i:\\n                res=dp[i-1]\\n            dp[i][0]=ind[i]+1\\n            dp[i][1]=min(res[0],res[1])+2\\n            dp[i][2]=min(res[0],res[1])+(n-ind[i])\\n            ans=min(ans,dp[i][2])\\n        return min(ans,min(dp[-1]))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, s: str) -> int:\\n        n=len(s)\\n        ind=[i for i in range(len(s)) if s[i]==\"1\"]\\n        if len(ind)==0:\\n            return 0\\n        dp=[[0,0,0] for i in range(len(ind))] #left spot right\\n        ans=float(\"inf\")\\n        for i in range(len(ind)):\\n            res=[0,0,0]\\n            if i:\\n                res=dp[i-1]\\n            dp[i][0]=ind[i]+1\\n            dp[i][1]=min(res[0],res[1])+2\\n            dp[i][2]=min(res[0],res[1])+(n-ind[i])\\n            ans=min(ans,dp[i][2])\\n        return min(ans,min(dp[-1]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3124865,
                "title": "python-min-sum-of-contiguous-subsequence",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe trick is to convert this problem to:\\n    Remove the minimum sum of contiguous subsequence.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(N)$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(N)$\\n# Code\\n```\\nclass Solution:\\n    def minimumTime(self, s: str) -> int:\\n        pre = minS = -1 if s[0] == \\'0\\' else 0\\n        for i in range(1, len(s)):\\n            pre = min(0, pre + (1 if s[i] == \\'1\\' else -1))   \\n            minS = min(minS, pre)\\n        return len(s) + minS\\n\\n   \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, s: str) -> int:\\n        pre = minS = -1 if s[0] == \\'0\\' else 0\\n        for i in range(1, len(s)):\\n            pre = min(0, pre + (1 if s[i] == \\'1\\' else -1))   \\n            minS = min(minS, pre)\\n        return len(s) + minS\\n\\n   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2954129,
                "title": "optimal-strategy-pick-from-left-right-and-remaining-from-middle",
                "content": "```\\nclass Solution:\\n    def minimumTime(self, s: str) -> int:\\n        n = len(s)\\n        res = float(\\'inf\\')\\n        maxval = float(\\'-inf\\')\\n        p = 0\\n        for i in range(n + 1):\\n            c = 2 * p - i\\n            maxval = max(maxval, c)\\n            res = min(res, n + c - maxval)\\n            p += int(s[min(i, n - 1)])\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, s: str) -> int:\\n        n = len(s)\\n        res = float(\\'inf\\')\\n        maxval = float(\\'-inf\\')\\n        p = 0\\n        for i in range(n + 1):\\n            c = 2 * p - i\\n            maxval = max(maxval, c)\\n            res = min(res, n + c - maxval)\\n            p += int(s[min(i, n - 1)])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758255,
                "title": "c",
                "content": "```\\n// min : i + 2*(prefix[j] - prefix[i-1]) + n-j-1\\n//  ==>  [2* prefix[j] - j ] - [2 * prefix[i-1] -(i-1)] + n\\n//  ==>  Fn(j) - Fn(i-1) + n\\n//  ==>  Fn(0) = 1;  since prefix[-1] = 0;\\nint minimumTime(char * s){\\n    int n = strlen(s);\\n    int ans = n;\\n    int* prefix = malloc(n * sizeof(int));\\n    prefix[0] = (s[0] == \\'1\\');\\n    for(int i = 1; i <n; i++){\\n        prefix[i] = prefix[i-1] + (s[i] == \\'1\\');\\n    }\\n    int MaxFn = 1;  //so far, max of Fn\\n    for(int j = 0; j < n ; j++){\\n        int new = 2*prefix[j] - j;\\n        ans = fmin(ans, new - MaxFn + n);\\n        MaxFn = fmax(MaxFn, new);\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n// min : i + 2*(prefix[j] - prefix[i-1]) + n-j-1\\n//  ==>  [2* prefix[j] - j ] - [2 * prefix[i-1] -(i-1)] + n\\n//  ==>  Fn(j) - Fn(i-1) + n\\n//  ==>  Fn(0) = 1;  since prefix[-1] = 0;\\nint minimumTime(char * s){\\n    int n = strlen(s);\\n    int ans = n;\\n    int* prefix = malloc(n * sizeof(int));\\n    prefix[0] = (s[0] == \\'1\\');\\n    for(int i = 1; i <n; i++){\\n        prefix[i] = prefix[i-1] + (s[i] == \\'1\\');\\n    }\\n    int MaxFn = 1;  //so far, max of Fn\\n    for(int j = 0; j < n ; j++){\\n        int new = 2*prefix[j] - j;\\n        ans = fmin(ans, new - MaxFn + n);\\n        MaxFn = fmax(MaxFn, new);\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2621984,
                "title": "python-dp-solution-1473ms-faster-than-100",
                "content": "```\\nclass Solution:\\n    def minimumTime(self, s: str) -> int:\\n        ans, numOnes, numZeros = len(s), 0, 0\\n        for i in range(len(s)):\\n            if s[i] == \\'0\\':\\n                if numOnes > numZeros:\\n                    numOnes, numZeros = 0, 0\\n                numZeros += 1\\n            else:\\n                numOnes += 1\\n            ans = min(ans, len(s) - numZeros + numOnes)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, s: str) -> int:\\n        ans, numOnes, numZeros = len(s), 0, 0\\n        for i in range(len(s)):\\n            if s[i] == \\'0\\':\\n                if numOnes > numZeros:\\n                    numOnes, numZeros = 0, 0\\n                numZeros += 1\\n            else:\\n                numOnes += 1\\n            ans = min(ans, len(s) - numZeros + numOnes)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2555032,
                "title": "java-o-1-space-o-n-time-complexity",
                "content": "```\\npublic int minimumTime(String s) {\\n        int zero = 0, one = 0;\\n        int ans = s.length();\\n        for( int i = 0; i<s.length(); i++ ){\\n            if( s.charAt(i) == \\'0\\' ){\\n                if( zero < one ){\\n                    one = 0;\\n                    zero = 0;\\n                }\\n                zero++;\\n            }\\n            else\\n                one++;\\n            ans = Math.min( ans,s.length() + one - zero );\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\npublic int minimumTime(String s) {\\n        int zero = 0, one = 0;\\n        int ans = s.length();\\n        for( int i = 0; i<s.length(); i++ ){\\n            if( s.charAt(i) == \\'0\\' ){\\n                if( zero < one ){\\n                    one = 0;\\n                    zero = 0;\\n                }\\n                zero++;\\n            }\\n            else\\n                one++;\\n            ans = Math.min( ans,s.length() + one - zero );\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2465604,
                "title": "python3-dp",
                "content": "\\n```\\nclass Solution:\\n    def minimumTime(self, s: str) -> int:\\n        ans = inf \\n        prefix = 0 \\n        for i, ch in enumerate(s): \\n            if ch == \\'1\\': prefix = min(2 + prefix, i+1)\\n            ans = min(ans, prefix + len(s)-1-i)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, s: str) -> int:\\n        ans = inf \\n        prefix = 0 \\n        for i, ch in enumerate(s): \\n            if ch == \\'1\\': prefix = min(2 + prefix, i+1)\\n            ans = min(ans, prefix + len(s)-1-i)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2410044,
                "title": "java-o-n-prefix-suffix-dp",
                "content": "```\\nclass Solution {\\n    public int minimumTime(String s) {\\n        int len = s.length();\\n        int[] left = new int[len];\\n        int[] right = new int[len];\\n        \\n        left[0] = s.charAt(0) == \\'1\\' ? 1 : 0;\\n        right[len-1] = s.charAt(len-1) == \\'1\\' ? 1 : 0;\\n        \\n        for(int i = 1; i < len; i++)\\n        {\\n            if(s.charAt(i) == \\'0\\')\\n                left[i] = left[i-1];\\n            else\\n                left[i] = Math.min(i + 1, left[i-1] + 2);\\n        }\\n        \\n        for(int i = len - 2; i > -1; i--)\\n        {\\n            if(s.charAt(i) == \\'0\\')\\n                right[i] = right[i+1];\\n            else\\n                right[i] = Math.min(len - i, right[i+1] + 2);\\n        }\\n        \\n        int minTime = Integer.MAX_VALUE;\\n        \\n        for(int i = 0; i < len; i++)\\n        {\\n            int x = (i == len - 1) ? 0 : right[i+1];\\n            int y = left[i];\\n            minTime = Math.min(minTime, x + y);\\n        }\\n        \\n        return minTime;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumTime(String s) {\\n        int len = s.length();\\n        int[] left = new int[len];\\n        int[] right = new int[len];\\n        \\n        left[0] = s.charAt(0) == \\'1\\' ? 1 : 0;\\n        right[len-1] = s.charAt(len-1) == \\'1\\' ? 1 : 0;\\n        \\n        for(int i = 1; i < len; i++)\\n        {\\n            if(s.charAt(i) == \\'0\\')\\n                left[i] = left[i-1];\\n            else\\n                left[i] = Math.min(i + 1, left[i-1] + 2);\\n        }\\n        \\n        for(int i = len - 2; i > -1; i--)\\n        {\\n            if(s.charAt(i) == \\'0\\')\\n                right[i] = right[i+1];\\n            else\\n                right[i] = Math.min(len - i, right[i+1] + 2);\\n        }\\n        \\n        int minTime = Integer.MAX_VALUE;\\n        \\n        for(int i = 0; i < len; i++)\\n        {\\n            int x = (i == len - 1) ? 0 : right[i+1];\\n            int y = left[i];\\n            minTime = Math.min(minTime, x + y);\\n        }\\n        \\n        return minTime;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2393422,
                "title": "c-multistage-dp",
                "content": "```\\nclass Solution {\\n    int dp[200001][2];\\n    string s;\\n    int len;\\n    int dfs(int idx, int state){\\n        if(idx==len)\\n            return 0;\\n        if(dp[idx][state]!=-1)\\n            return dp[idx][state];\\n        if(s[idx]==\\'0\\'){\\n            if(state==0){\\n                return dp[idx][state]=min(1+dfs(idx+1,state),dfs(idx+1,1));\\n            }else{\\n                return dp[idx][state]=min(dfs(idx+1,state),len-idx);\\n            }\\n        }\\n        if(state==0)\\n            return dp[idx][state]=min(1+dfs(idx+1,state),2+dfs(idx+1,1));\\n        return dp[idx][state]=min(2+dfs(idx+1,state),len-idx);\\n    }\\npublic:\\n    int minimumTime(string ss) {\\n        memset(dp,-1,sizeof(dp));\\n        s=ss;\\n        len=s.size();\\n        return dfs(0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int dp[200001][2];\\n    string s;\\n    int len;\\n    int dfs(int idx, int state){\\n        if(idx==len)\\n            return 0;\\n        if(dp[idx][state]!=-1)\\n            return dp[idx][state];\\n        if(s[idx]==\\'0\\'){\\n            if(state==0){\\n                return dp[idx][state]=min(1+dfs(idx+1,state),dfs(idx+1,1));\\n            }else{\\n                return dp[idx][state]=min(dfs(idx+1,state),len-idx);\\n            }\\n        }\\n        if(state==0)\\n            return dp[idx][state]=min(1+dfs(idx+1,state),2+dfs(idx+1,1));\\n        return dp[idx][state]=min(2+dfs(idx+1,state),len-idx);\\n    }\\npublic:\\n    int minimumTime(string ss) {\\n        memset(dp,-1,sizeof(dp));\\n        s=ss;\\n        len=s.size();\\n        return dfs(0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2340063,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n//         n-minsubarray sum\\n        int n=s.size();\\n        vector<int> res;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'1\\') res.push_back(1);\\n            else res.push_back(-1);\\n        }\\n        int mini=0;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=res[i];\\n            mini=min(mini,sum);\\n            if(sum>0) sum=0;\\n        }\\n        return n+mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n//         n-minsubarray sum\\n        int n=s.size();\\n        vector<int> res;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'1\\') res.push_back(1);\\n            else res.push_back(-1);\\n        }\\n        int mini=0;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=res[i];\\n            mini=min(mini,sum);\\n            if(sum>0) sum=0;\\n        }\\n        return n+mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2275282,
                "title": "c-kadane-algo-easy-approach",
                "content": "class Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int n=s.size();\\n        int ans=n;\\n        vector<int> vec;\\n        for(auto it: s){\\n            if(it==\\'0\\') vec.push_back(-1);\\n            else vec.push_back(1);\\n        }\\n        \\n        //kadane algo for least subarray sum\\n        int mini=0;\\n        int sum=0;\\n        for(auto it:vec){\\n            sum+=it;\\n            mini=min(mini,sum);\\n            // cout<<sum<<\" \";\\n            if(sum>0) sum=0;\\n            \\n        }\\n        \\n        return ans+mini;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int n=s.size();\\n        int ans=n;\\n        vector<int> vec;\\n        for(auto it: s){\\n            if(it==\\'0\\') vec.push_back(-1);\\n            else vec.push_back(1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2055219,
                "title": "c-o-n-time-and-space-dynamic-programming-prefix",
                "content": "O(n) time&space; Dynamic Programming, Prefix \\n```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int prev, time1, time2, min_time=s.size();\\n        vector<int> remove_left(s.size()+1, 0), remove_right(s.size()+1, 0);// min time to remove illegal cars in (,i) and [i,) \\n        \\n        for( int i=0; i<s.size(); i++){\\n            prev=remove_left[i];\\n            if(s[i]==\\'1\\'){\\n                time1=i+1;\\n                time2=prev+2;\\n                remove_left[i+1]=time1<time2?time1:time2;\\n            }else{\\n                remove_left[i+1]=prev;\\n            }\\n        }\\n        \\n        for( int i=s.size()-1; -1<i; i--){\\n            prev=remove_right[i+1];\\n            if(s[i]==\\'1\\'){\\n                time1=s.size()-i;\\n                time2=prev+2;\\n                remove_right[i]=time1<time2?time1:time2;\\n            }else{\\n                remove_right[i]=prev;\\n            }\\n        }\\n        \\n        for( int i=0; i<=s.size(); i++){// remove (,i) and [i,)\\n            time1=remove_left[i];\\n            time2=remove_right[i];\\n            if(time1+time2<min_time)\\n                min_time=time1+time2;\\n        }\\n        \\n        return min_time;\\n    }\\n};\\n```\\n\\nO(n*n) time, TLE \\n```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int min_time=s.size();\\n        vector<int> ones={0};// 1s in [0,i) \\n        \\n        for( int i=0, time=0; i<s.size(); i++)\\n            ones.push_back(ones.back()+(s[i]==\\'1\\'));\\n        \\n        for( int i=0; i<=s.size(); i++){// remove (,i)\\n            for( int j=i-1; j<(int)s.size(); j++){// remove (j,); -1<s.size() return false\\n                int time=i+(s.size()-1-j)+2*(ones[j+1]-ones[i]);\\n                if(time<min_time)\\n                    min_time=time;\\n            }\\n        }\\n        \\n        return min_time;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int prev, time1, time2, min_time=s.size();\\n        vector<int> remove_left(s.size()+1, 0), remove_right(s.size()+1, 0);// min time to remove illegal cars in (,i) and [i,) \\n        \\n        for( int i=0; i<s.size(); i++){\\n            prev=remove_left[i];\\n            if(s[i]==\\'1\\'){\\n                time1=i+1;\\n                time2=prev+2;\\n                remove_left[i+1]=time1<time2?time1:time2;\\n            }else{\\n                remove_left[i+1]=prev;\\n            }\\n        }\\n        \\n        for( int i=s.size()-1; -1<i; i--){\\n            prev=remove_right[i+1];\\n            if(s[i]==\\'1\\'){\\n                time1=s.size()-i;\\n                time2=prev+2;\\n                remove_right[i]=time1<time2?time1:time2;\\n            }else{\\n                remove_right[i]=prev;\\n            }\\n        }\\n        \\n        for( int i=0; i<=s.size(); i++){// remove (,i) and [i,)\\n            time1=remove_left[i];\\n            time2=remove_right[i];\\n            if(time1+time2<min_time)\\n                min_time=time1+time2;\\n        }\\n        \\n        return min_time;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int min_time=s.size();\\n        vector<int> ones={0};// 1s in [0,i) \\n        \\n        for( int i=0, time=0; i<s.size(); i++)\\n            ones.push_back(ones.back()+(s[i]==\\'1\\'));\\n        \\n        for( int i=0; i<=s.size(); i++){// remove (,i)\\n            for( int j=i-1; j<(int)s.size(); j++){// remove (j,); -1<s.size() return false\\n                int time=i+(s.size()-1-j)+2*(ones[j+1]-ones[i]);\\n                if(time<min_time)\\n                    min_time=time;\\n            }\\n        }\\n        \\n        return min_time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2004701,
                "title": "golang-solution-easy-to-understand",
                "content": "```\\nfunc minimumTime(s string) int {\\n    size := len(s)\\n    if size == 0 {\\n        return 0\\n    }\\n    pre := make([]int, size)\\n    suf := make([]int, size)\\n    if s[0] == \\'1\\' {\\n        pre[0] = 1\\n    }\\n    for i:=1;i<size;i++ {\\n        if s[i] == \\'1\\' {\\n            pre[i] = min(pre[i-1]+2, i+1)\\n        }else{\\n            pre[i] = pre[i-1]\\n        }\\n    }\\n    if s[size-1] == \\'1\\' {\\n        suf[size-1] = 1\\n    }\\n    for i:= size-2;i>=0;i--{\\n        if s[i] == \\'1\\' {\\n            suf[i] = min(suf[i+1]+2, size-i)\\n        }else{\\n            suf[i] = suf[i+1]\\n        }\\n    }\\n    result := min(pre[size-1], suf[0])\\n    for i:=0; i<size-1;i++{\\n        result = min(result, pre[i]+suf[i+1])\\n    }\\n    return result\\n}\\n\\nfunc min(a,b int) int {\\n    if a < b{\\n        return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc minimumTime(s string) int {\\n    size := len(s)\\n    if size == 0 {\\n        return 0\\n    }\\n    pre := make([]int, size)\\n    suf := make([]int, size)\\n    if s[0] == \\'1\\' {\\n        pre[0] = 1\\n    }\\n    for i:=1;i<size;i++ {\\n        if s[i] == \\'1\\' {\\n            pre[i] = min(pre[i-1]+2, i+1)\\n        }else{\\n            pre[i] = pre[i-1]\\n        }\\n    }\\n    if s[size-1] == \\'1\\' {\\n        suf[size-1] = 1\\n    }\\n    for i:= size-2;i>=0;i--{\\n        if s[i] == \\'1\\' {\\n            suf[i] = min(suf[i+1]+2, size-i)\\n        }else{\\n            suf[i] = suf[i+1]\\n        }\\n    }\\n    result := min(pre[size-1], suf[0])\\n    for i:=0; i<size-1;i++{\\n        result = min(result, pre[i]+suf[i+1])\\n    }\\n    return result\\n}\\n\\nfunc min(a,b int) int {\\n    if a < b{\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1832128,
                "title": "c-simple-dp-solution-o-n-time-and-o-1-space",
                "content": "```\\npublic class Solution\\n{\\n\\tpublic int MinimumTime(string s)\\n\\t{\\n\\t\\tint size = s.Length;\\n\\t\\tint min = int.MaxValue;\\n\\t\\tint leftMin = 0;\\n\\t\\tfor (int i = 0; i < size; i++)\\n\\t\\t{\\n\\t\\t\\tleftMin = Math.Min(leftMin + 2 * (s[i] == \\'1\\' ? 1 : 0), i + 1);\\n\\t\\t\\tmin = Math.Min(min, leftMin + size - i - 1);\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn min;\\n\\t}\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n\\tpublic int MinimumTime(string s)\\n\\t{\\n\\t\\tint size = s.Length;\\n\\t\\tint min = int.MaxValue;\\n\\t\\tint leftMin = 0;\\n\\t\\tfor (int i = 0; i < size; i++)\\n\\t\\t{\\n\\t\\t\\tleftMin = Math.Min(leftMin + 2 * (s[i] == \\'1\\' ? 1 : 0), i + 1);\\n\\t\\t\\tmin = Math.Min(min, leftMin + size - i - 1);\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn min;\\n\\t}\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1829248,
                "title": "java-prefix-and-pruning",
                "content": "From the description, we can split the array into three parts.\\n{applying rule 1} {applying rule 3} {applying rule 2}\\nFor the part of applying rule 1 and rule 2, all elements should be removed. Let\\'s say the middle part is from start to end. Then for the first part, it is cost of start and it costs the third part N - end - 1.\\nFor the rule 3 part, it requires number of ones in that rule and then multiplied by 2.\\n\\nBecause the range sum is required, it can be achieved by a prefix sum array instead of iterating all elements between start and end. It gives O(1) solution for a given start and end. \\n\\nGiven above we can have a O(N^2) solution to iterate over all possible start and end.\\n\\n```java\\n    public int minimumTime(String s) {\\n        final int N = s.length();\\n        int[] sum = new int[N + 1];\\n        for (int i = 0; i < N; ++i) {\\n            sum[i + 1] = sum[i] + (s.charAt(i) - \\'0\\');\\n        }\\n\\t\\t// if there no 1, nothing needs to be done.\\n        if (sum[N] == 0) {\\n            return 0;\\n        }\\n\\t\\t// if not applying rule 3, the worst case is to remove all elements\\n        int res = s.length();\\n        for (int start = 0; start < N - 1; ++start) {\\n            for (int end = start; end < N ; ++end) {\\n                //rule 1:{start} rule 3 : {2 * (sum[end + 1] - sum[start])} rule 2 : {N - end - 1}\\n                res = Math.min(res, start + N - end - 1 + 2 * (sum[end + 1] - sum[start]));\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\nAppearantly, this solution is not for 10^5. It would be time out.\\nLet\\'s rewrite \\n```\\nstart + N - end - 1 + 2 * (sum[end + 1] - sum[start])\\n```\\nby grouping start and end seperately\\n```\\n{start - 2 * sum[start]} + N - 1 + {2 * sum[end + 1] - end}\\n```\\n\\nIt reminds me [1499](https://leetcode.com/problems/max-value-of-equation/)\\n\\nFor a given start, `start - 2 * sum[start] + N - 1` is a constant. The question become minimize `2 * sum[end + 1] - end` for all `end >= start`.\\nThen we can preprocess `2 * sum[end + 1] - end` to get a O(N) solution by iterating `end` backward and keep the minimun value\\n\\n```java\\n    public int minimumTime(String s) {\\n        final int N = s.length();\\n        int[] sum = new int[N + 1];\\n        for (int i = 0; i < N; ++i) {\\n            sum[i + 1] = sum[i] + (s.charAt(i) - \\'0\\');\\n        }\\n\\t\\t// if there no 1, nothing needs to be done.\\n        if (sum[N] == 0) {\\n            return 0;\\n        }\\n\\t\\t// if not applying rule 3, the worst case is to remove all elements\\n        int res = s.length();\\n        // preprocess 2 * sum[end + 1] - end reord the min value by iterating backward\\n        int[] right = new int[N];\\n        right[N - 1] = 2 * sum[N] - N + 1;\\n        for (int i = N - 2; i >= 0; --i) {\\n             right[i] = Math.min(2 * sum[i + 1] - i, right[i+1]);\\n        }\\n        for (int start = 0; start < N; ++start) {\\n            res = Math.min(res, start - 2 * sum[start] + N - 1 + right[start]);\\n        }\\n        return res;\\n    }\\n```\\n\\nOf course, the same logic applys to a given `end`.\\nFor a given `end`,  `2 * sum[end + 1] - end`  is a constant. It requires to minimize  `start - 2 * sum[start] + N - 1`  for all  `start <= end`. It is then can be implemented as the previous method with an extra array. However, we can save one loop and an array because  `start - 2 * sum[start] + N - 1` is in the left part, we can iterate it alone with end and only a variable to record the minimum is required.\\n\\n```java\\n    public int minimumTime(String s) {\\n        final int N = s.length();\\n        int[] sum = new int[N + 1];\\n        for (int i = 0; i < N; ++i) {\\n            sum[i + 1] = sum[i] + (s.charAt(i) - \\'0\\');\\n        }\\n        if (sum[N] == 0) {\\n            return 0;\\n        }\\n        int res = s.length();\\n        int min = Integer.MAX_VALUE;\\n        for (int end = 0; end < N; ++end) {\\n            min = Math.min(min, end - 2 * sum[end] + N - 1);\\n            res = Math.min(res, min + 2 * sum[end + 1] - end);\\n        }\\n        return res;\\n    }\\n```\\n\\n\\t",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```java\\n    public int minimumTime(String s) {\\n        final int N = s.length();\\n        int[] sum = new int[N + 1];\\n        for (int i = 0; i < N; ++i) {\\n            sum[i + 1] = sum[i] + (s.charAt(i) - \\'0\\');\\n        }\\n\\t\\t// if there no 1, nothing needs to be done.\\n        if (sum[N] == 0) {\\n            return 0;\\n        }\\n\\t\\t// if not applying rule 3, the worst case is to remove all elements\\n        int res = s.length();\\n        for (int start = 0; start < N - 1; ++start) {\\n            for (int end = start; end < N ; ++end) {\\n                //rule 1:{start} rule 3 : {2 * (sum[end + 1] - sum[start])} rule 2 : {N - end - 1}\\n                res = Math.min(res, start + N - end - 1 + 2 * (sum[end + 1] - sum[start]));\\n            }\\n        }\\n        return res;\\n    }\\n```\n```\\nstart + N - end - 1 + 2 * (sum[end + 1] - sum[start])\\n```\n```\\n{start - 2 * sum[start]} + N - 1 + {2 * sum[end + 1] - end}\\n```\n```java\\n    public int minimumTime(String s) {\\n        final int N = s.length();\\n        int[] sum = new int[N + 1];\\n        for (int i = 0; i < N; ++i) {\\n            sum[i + 1] = sum[i] + (s.charAt(i) - \\'0\\');\\n        }\\n\\t\\t// if there no 1, nothing needs to be done.\\n        if (sum[N] == 0) {\\n            return 0;\\n        }\\n\\t\\t// if not applying rule 3, the worst case is to remove all elements\\n        int res = s.length();\\n        // preprocess 2 * sum[end + 1] - end reord the min value by iterating backward\\n        int[] right = new int[N];\\n        right[N - 1] = 2 * sum[N] - N + 1;\\n        for (int i = N - 2; i >= 0; --i) {\\n             right[i] = Math.min(2 * sum[i + 1] - i, right[i+1]);\\n        }\\n        for (int start = 0; start < N; ++start) {\\n            res = Math.min(res, start - 2 * sum[start] + N - 1 + right[start]);\\n        }\\n        return res;\\n    }\\n```\n```java\\n    public int minimumTime(String s) {\\n        final int N = s.length();\\n        int[] sum = new int[N + 1];\\n        for (int i = 0; i < N; ++i) {\\n            sum[i + 1] = sum[i] + (s.charAt(i) - \\'0\\');\\n        }\\n        if (sum[N] == 0) {\\n            return 0;\\n        }\\n        int res = s.length();\\n        int min = Integer.MAX_VALUE;\\n        for (int end = 0; end < N; ++end) {\\n            min = Math.min(min, end - 2 * sum[end] + N - 1);\\n            res = Math.min(res, min + 2 * sum[end + 1] - end);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1806305,
                "title": "cpp-memoised",
                "content": "Why this dp solution does\\'t work\\n\\n```\\nint dp[5000][5000][2];\\nint vis[5000][5000][2];\\nint cost(string s,int i,int j,int f){\\n    if(i>=s.size()||j<0||i>j){\\n        return 0;\\n    }\\n    if(i==j){\\n        return s[i]==\\'1\\';\\n    }\\n    if(vis[i][j][f]){\\n        return dp[i][j][f];\\n    }\\n    int c = 0;\\n    int l,r;\\n    while((i<j)&&((s[i]==\\'1\\')||(s[j]==\\'1\\'))){\\n        if(s[i]==\\'1\\'){\\n            c+=1;\\n            i+=1;\\n        }\\n        if(s[j]==\\'1\\'){\\n            c+=1;\\n            j-=1;\\n        }\\n    }\\n    l = i;\\n    r = j;\\n    while((l<r)&&((s[l]==\\'0\\')||(s[r]==\\'0\\'))){\\n        if(s[l]==\\'0\\'){\\n            l+=1;\\n        }\\n        if(s[r]==\\'0\\'){\\n            r-=1;\\n        }\\n    }\\n    int ans;\\n    if(f){\\n        ans= dp[i][j][f] = (c+min({1+cost(s,i+1,j,1),1+cost(s,i,j-1,1),cost(s,l,r,1)}));\\n    }\\n    else{\\n        ans= dp[i][j][f] = (c+min({1+cost(s,i+1,j,0),1+cost(s,i,j-1,0),2*cost(s,l,r,1)}));\\n    }\\n    vis[i][j][f]=1;\\n    return ans;\\n}\\nclass Solution {\\npublic:\\n    int minimumTime(string A) {\\n        memset(dp,0,sizeof(dp));\\n        memset(vis,0,sizeof(vis));\\n        return cost(A,0,A.size()-1,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nint dp[5000][5000][2];\\nint vis[5000][5000][2];\\nint cost(string s,int i,int j,int f){\\n    if(i>=s.size()||j<0||i>j){\\n        return 0;\\n    }\\n    if(i==j){\\n        return s[i]==\\'1\\';\\n    }\\n    if(vis[i][j][f]){\\n        return dp[i][j][f];\\n    }\\n    int c = 0;\\n    int l,r;\\n    while((i<j)&&((s[i]==\\'1\\')||(s[j]==\\'1\\'))){\\n        if(s[i]==\\'1\\'){\\n            c+=1;\\n            i+=1;\\n        }\\n        if(s[j]==\\'1\\'){\\n            c+=1;\\n            j-=1;\\n        }\\n    }\\n    l = i;\\n    r = j;\\n    while((l<r)&&((s[l]==\\'0\\')||(s[r]==\\'0\\'))){\\n        if(s[l]==\\'0\\'){\\n            l+=1;\\n        }\\n        if(s[r]==\\'0\\'){\\n            r-=1;\\n        }\\n    }\\n    int ans;\\n    if(f){\\n        ans= dp[i][j][f] = (c+min({1+cost(s,i+1,j,1),1+cost(s,i,j-1,1),cost(s,l,r,1)}));\\n    }\\n    else{\\n        ans= dp[i][j][f] = (c+min({1+cost(s,i+1,j,0),1+cost(s,i,j-1,0),2*cost(s,l,r,1)}));\\n    }\\n    vis[i][j][f]=1;\\n    return ans;\\n}\\nclass Solution {\\npublic:\\n    int minimumTime(string A) {\\n        memset(dp,0,sizeof(dp));\\n        memset(vis,0,sizeof(vis));\\n        return cost(A,0,A.size()-1,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1794317,
                "title": "java-dp-solution",
                "content": "Lets break this problem into 2 sub-problems:\\n1.  2 operations are allowed : remove from current position or remove from left.\\n2.  2 operations are allowed : remove from current position or remove from right.\\n\\nLets calculate the answer for these 2 problems and store it in a array (left[], right[] respectively).\\nleft[i] denotes the answer for 1st subproblem if s[0:i+1] is considered. For left[i],\\ncase 1 : s[i] == \\'0\\' -> the answer is the same as for i-1.\\ncase 2 : s[i] == \\'1\\' -> now we have two choices, either remove all cars till i so the cost is i+1 or remove the ith car with cost 2 so the total cost becomes left[i-1] + 2. we take whichever is minimum.\\n\\nsimilarly for array right[] (calculated here by reversing the string s).\\n\\nNow we have the answers to both our sub-problems so lets try to find the answer to the original problem using this information. \\nThere will always be an index i in the string such that all removals till ith index are left removals and all removals after ith index are right removals. We just need to find the minimum cost using the information we have computed before. See the formula in the code below.\\n[Note : The case where left removals till i-1th index , right removals from i+1th index onwards and removing ith index with 2 unit cost is automatically taken care of.]\\n\\n```\\nclass Solution {\\n    public int minimumTime(String s) {\\n        int n = s.length();\\n        int left[] = new int[n];\\n        util(s, left);\\n        int right[] = new int[n];\\n        StringBuilder sb=new StringBuilder(s);\\n        sb.reverse();\\n        String rev = sb.toString();\\n        \\n        util(rev, right);\\n        int ans = Math.min(left[n-1], right[n-1]);\\n        for(int i=1;i<n-1;i++) {\\n            int cur = 2000000;\\n            if(s.charAt(i)==\\'0\\') {\\n                cur = left[i-1] + right[n-2-i];\\n            }\\n            else {\\n                cur = Math.min(left[i]+right[n-2-i], left[i-1]+right[n-1-i]);\\n            }\\n            ans = Math.min(cur,ans);\\n        }\\n        return ans;\\n    }\\n    \\n    private void util(String s, int dp[]) {\\n        int n = s.length();\\n       \\n        dp[0] = s.charAt(0)==\\'1\\' ? 1 : 0;\\n        for (int i=1;i<n ;i++ ) {\\n        \\tif (s.charAt(i)==\\'0\\') {\\n        \\t\\tdp[i] = dp[i-1];\\n        \\t}\\n        \\telse {\\n        \\t\\tdp[i] = Math.min(i+1, dp[i-1]+2);\\n        \\t}\\n        }\\n    }\\n}\\n```\\n\\nThis code can be optimized further but I have kept it simple for better understanding. We can compute the left[], right[] arrays in a single call to util() and also avoid reverse operation on the string.",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumTime(String s) {\\n        int n = s.length();\\n        int left[] = new int[n];\\n        util(s, left);\\n        int right[] = new int[n];\\n        StringBuilder sb=new StringBuilder(s);\\n        sb.reverse();\\n        String rev = sb.toString();\\n        \\n        util(rev, right);\\n        int ans = Math.min(left[n-1], right[n-1]);\\n        for(int i=1;i<n-1;i++) {\\n            int cur = 2000000;\\n            if(s.charAt(i)==\\'0\\') {\\n                cur = left[i-1] + right[n-2-i];\\n            }\\n            else {\\n                cur = Math.min(left[i]+right[n-2-i], left[i-1]+right[n-1-i]);\\n            }\\n            ans = Math.min(cur,ans);\\n        }\\n        return ans;\\n    }\\n    \\n    private void util(String s, int dp[]) {\\n        int n = s.length();\\n       \\n        dp[0] = s.charAt(0)==\\'1\\' ? 1 : 0;\\n        for (int i=1;i<n ;i++ ) {\\n        \\tif (s.charAt(i)==\\'0\\') {\\n        \\t\\tdp[i] = dp[i-1];\\n        \\t}\\n        \\telse {\\n        \\t\\tdp[i] = Math.min(i+1, dp[i-1]+2);\\n        \\t}\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786442,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    int find(string &s, int i, vector<int> &dp) {\\n        if (i==s.length()) {\\n            return 0;\\n        }\\n        if (dp[i] != -1 ){\\n            return dp[i];\\n        }\\n        int x = s.length();\\n        if (s[i] == \\'0\\') {\\n            dp[i] = find(s, i+1, dp);\\n        } else {\\n            dp[i] = min(x-i, 2 + find(s, i+1, dp));\\n        }\\n        return dp[i];\\n    }\\n    \\n    int minimumTime(string s) {\\n        vector<int> dp(s.length(), -1);\\n        \\n        int ans = INT_MAX;\\n        int numOnes=0;\\n        for(int i=0; i<s.length(); i++ ){\\n            if (s[i] == \\'0\\') {\\n                if (numOnes == 0) {\\n                    ans = min(ans, find(s, i+1, dp));\\n                } else {\\n                    ans = min(ans, i+1 + find(s, i+1, dp));\\n                }\\n                continue;\\n            }\\n            numOnes++;\\n            ans = min(ans, i+1 + find(s, i+1, dp));\\n            //cout<<i<<\" \"<<i+1<<\" \"<<find(s, i+1, dp)<<endl;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int find(string &s, int i, vector<int> &dp) {\\n        if (i==s.length()) {\\n            return 0;\\n        }\\n        if (dp[i] != -1 ){\\n            return dp[i];\\n        }\\n        int x = s.length();\\n        if (s[i] == \\'0\\') {\\n            dp[i] = find(s, i+1, dp);\\n        } else {\\n            dp[i] = min(x-i, 2 + find(s, i+1, dp));\\n        }\\n        return dp[i];\\n    }\\n    \\n    int minimumTime(string s) {\\n        vector<int> dp(s.length(), -1);\\n        \\n        int ans = INT_MAX;\\n        int numOnes=0;\\n        for(int i=0; i<s.length(); i++ ){\\n            if (s[i] == \\'0\\') {\\n                if (numOnes == 0) {\\n                    ans = min(ans, find(s, i+1, dp));\\n                } else {\\n                    ans = min(ans, i+1 + find(s, i+1, dp));\\n                }\\n                continue;\\n            }\\n            numOnes++;\\n            ans = min(ans, i+1 + find(s, i+1, dp));\\n            //cout<<i<<\" \"<<i+1<<\" \"<<find(s, i+1, dp)<<endl;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1776554,
                "title": "dp-from-left-and-right",
                "content": "```\\n\\n    def minimumTime(self, s):\\n        n = len(s)\\n        l, r, res = [0] * n, [0] * n, n\\n        left = right = 0\\n        for i, c in enumerate(s):\\n            left = min(left + (c == \\'1\\') * 2, i + 1)\\n            l[i] = left\\n        for i in range(n - 1, -1 , -1):\\n            c = s[i]\\n            right = min(right + (c == \\'1\\') * 2, n - 1 - i + 1)\\n            r[i] = right\\n        for i in range(n):\\n            res = min(res, l[i] + (r[i + 1] if i < n - 1 else 0))\\n        return res        \\n\\n\\n//optimized: \\n\\n    def minimumTime(self, s):\\n        n = len(s)\\n        dp = [0] * n\\n        left = right = 0\\n        for i, c in enumerate(s):\\n            left = min(left + (c == \\'1\\') * 2, i + 1)\\n            dp[i] = left\\n        for i in range(n - 1, -1 , -1):\\n            c = s[i]\\n            right = min(right + (c == \\'1\\') * 2, n - 1 - i + 1)\\n            if i:\\n                dp[i - 1] += right\\n        return min([n] + dp)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\n    def minimumTime(self, s):\\n        n = len(s)\\n        l, r, res = [0] * n, [0] * n, n\\n        left = right = 0\\n        for i, c in enumerate(s):\\n            left = min(left + (c == \\'1\\') * 2, i + 1)\\n            l[i] = left\\n        for i in range(n - 1, -1 , -1):\\n            c = s[i]\\n            right = min(right + (c == \\'1\\') * 2, n - 1 - i + 1)\\n            r[i] = right\\n        for i in range(n):\\n            res = min(res, l[i] + (r[i + 1] if i < n - 1 else 0))\\n        return res        \\n\\n\\n//optimized: \\n\\n    def minimumTime(self, s):\\n        n = len(s)\\n        dp = [0] * n\\n        left = right = 0\\n        for i, c in enumerate(s):\\n            left = min(left + (c == \\'1\\') * 2, i + 1)\\n            dp[i] = left\\n        for i in range(n - 1, -1 , -1):\\n            c = s[i]\\n            right = min(right + (c == \\'1\\') * 2, n - 1 - i + 1)\\n            if i:\\n                dp[i - 1] += right\\n        return min([n] + dp)",
                "codeTag": "Python3"
            },
            {
                "id": 1773469,
                "title": "c-linq-one-liner-o-n-time-space",
                "content": "```\\npublic class Solution \\n{\\n    public int MinimumTime(string s) => s\\n        .Select(c => c == \\'0\\' ? -1 : 1)\\n        .Aggregate(Enumerable.Empty<int>().Prepend(0),\\n                   (dp, num) => dp.Prepend(Math.Min(0, dp.First() + num)),\\n                   dp => s.Length + dp.Min());\\n}\\n```\\n\\nIdea of this solution beautifully explained here: [[Python] maximum sum on subarray, explained](https://leetcode.com/problems/minimum-time-to-remove-all-cars-containing-illegal-goods/discuss/1748424/Python-maximum-sum-on-subarray-explained)",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int MinimumTime(string s) => s\\n        .Select(c => c == \\'0\\' ? -1 : 1)\\n        .Aggregate(Enumerable.Empty<int>().Prepend(0),\\n                   (dp, num) => dp.Prepend(Math.Min(0, dp.First() + num)),\\n                   dp => s.Length + dp.Min());\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1772975,
                "title": "some-obscured-and-short-python-6-lines-no-explanations",
                "content": "```\\nclass Solution:\\n    def minimumTime(self, s: str) -> int:\\n        ed, rem, ans, n = 0, 0, len(s), len(s)\\n\\n        for j in range(n):\\n            rem = min(rem, j - 2 * ed)\\n            ed += int(s[j])\\n            ans = min(ans, 2 * ed + rem + n - j - 1)\\n\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, s: str) -> int:\\n        ed, rem, ans, n = 0, 0, len(s), len(s)\\n\\n        for j in range(n):\\n            rem = min(rem, j - 2 * ed)\\n            ed += int(s[j])\\n            ans = min(ans, 2 * ed + rem + n - j - 1)\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1771633,
                "title": "python-dp-solution",
                "content": "Delete purely from left and delete purely from right\\nkeep track of the min cost of 1) if there are leading 0s or 2) if there is nothing (this case simply deletes everything it met)\\n\\n```\\nclass Solution:\\n    def minimumTime(self, s: str) -> int:\\n        n = len(s)\\n        # Check from left\\n        noContainer = [1]\\n        \\n        if s[0] == \\'1\\':\\n            withContainer = [None]\\n        else:\\n            withContainer = [0]\\n            \\n        for i in range(1, n):\\n            if s[i] == \\'1\\':\\n                noContainer.append(noContainer[-1] + 1)\\n                if withContainer[-1] != None:\\n                    withContainer.append(withContainer[-1] + 2)\\n                else:\\n                    withContainer.append(None)\\n            else:\\n                noContainer.append(noContainer[-1] + 1)\\n                if withContainer[-1] != None:\\n                    withContainer.append(min(noContainer[-2], withContainer[-1]))\\n                else:\\n                    withContainer.append(noContainer[-2])\\n        \\n        fromLeft = [min(noContainer[i], withContainer[i]) if withContainer[i] != None else noContainer[i] for i in range(n)]\\n        noContainer = [1]\\n        if s[n-1] == \\'1\\':\\n            withContainer = [None]\\n        else:\\n            withContainer = [0]\\n            \\n        for i in range(n-2, -1, -1):\\n            if s[i] == \\'1\\':\\n                noContainer.append(noContainer[-1] + 1)\\n                if withContainer[-1] != None:\\n                    withContainer.append(withContainer[-1] + 2)\\n                else:\\n                    withContainer.append(None)\\n            else:\\n                noContainer.append(noContainer[-1] + 1)\\n                if withContainer[-1] != None:\\n                    withContainer.append(min(noContainer[-2], withContainer[-1]))\\n                else:\\n                    withContainer.append(noContainer[-2])\\n        \\n        withContainer= withContainer[::-1]\\n        noContainer = noContainer[::-1]\\n        fromRight = [min(noContainer[i], withContainer[i]) if withContainer[i] != None else noContainer[i] for i in range(n)]\\n        return min([fromLeft[i] + fromRight[i+1] for i in range(n-1)] + [fromLeft[n-1]] + [fromRight[0]])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, s: str) -> int:\\n        n = len(s)\\n        # Check from left\\n        noContainer = [1]\\n        \\n        if s[0] == \\'1\\':\\n            withContainer = [None]\\n        else:\\n            withContainer = [0]\\n            \\n        for i in range(1, n):\\n            if s[i] == \\'1\\':\\n                noContainer.append(noContainer[-1] + 1)\\n                if withContainer[-1] != None:\\n                    withContainer.append(withContainer[-1] + 2)\\n                else:\\n                    withContainer.append(None)\\n            else:\\n                noContainer.append(noContainer[-1] + 1)\\n                if withContainer[-1] != None:\\n                    withContainer.append(min(noContainer[-2], withContainer[-1]))\\n                else:\\n                    withContainer.append(noContainer[-2])\\n        \\n        fromLeft = [min(noContainer[i], withContainer[i]) if withContainer[i] != None else noContainer[i] for i in range(n)]\\n        noContainer = [1]\\n        if s[n-1] == \\'1\\':\\n            withContainer = [None]\\n        else:\\n            withContainer = [0]\\n            \\n        for i in range(n-2, -1, -1):\\n            if s[i] == \\'1\\':\\n                noContainer.append(noContainer[-1] + 1)\\n                if withContainer[-1] != None:\\n                    withContainer.append(withContainer[-1] + 2)\\n                else:\\n                    withContainer.append(None)\\n            else:\\n                noContainer.append(noContainer[-1] + 1)\\n                if withContainer[-1] != None:\\n                    withContainer.append(min(noContainer[-2], withContainer[-1]))\\n                else:\\n                    withContainer.append(noContainer[-2])\\n        \\n        withContainer= withContainer[::-1]\\n        noContainer = noContainer[::-1]\\n        fromRight = [min(noContainer[i], withContainer[i]) if withContainer[i] != None else noContainer[i] for i in range(n)]\\n        return min([fromLeft[i] + fromRight[i+1] for i in range(n-1)] + [fromLeft[n-1]] + [fromRight[0]])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1769831,
                "title": "javascript-dp-o-n-solution",
                "content": "Intuition:\\n  For each train car with value \"1\", you have 2 choices, you can erase all the train cars from the left to current index or simply remove the current index train car with 2 operations.\\n\\n```\\nvar minimumTime = function(s) {\\n  // Edge Case\\n  if (s.length === 1) return s[0];\\n  \\n  // General Case\\n  const left = new Array(s.length).fill(0);\\n  const right = new Array(s.length).fill(0);\\n  for (let i = 0; i < s.length - 1; ++i) {\\n    const pre = i - 1 >= 0 ? left[i - 1] : 0; \\n    if (s[i] === \"0\") left[i] = pre;\\n    if (s[i] === \"1\") left[i] = Math.min(pre + 2, i + 1)\\n  }\\n  \\n  for (let i = s.length - 1; i >= 0; --i) {\\n    const pre = i + 1 < s.length ? right[i + 1] : 0;\\n    if (s[i] === \"0\") right[i] = pre;\\n    if (s[i] === \"1\") right[i] = Math.min(pre + 2, s.length - i);\\n  }\\n  \\n  let min = Infinity;\\n  for (let i = 0; i < s.length - 1; ++i) {\\n    min = Math.min(min, left[i] + right[i + 1]);\\n  }\\n  \\n  return min;\\n};\\n\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nvar minimumTime = function(s) {\\n  // Edge Case\\n  if (s.length === 1) return s[0];\\n  \\n  // General Case\\n  const left = new Array(s.length).fill(0);\\n  const right = new Array(s.length).fill(0);\\n  for (let i = 0; i < s.length - 1; ++i) {\\n    const pre = i - 1 >= 0 ? left[i - 1] : 0; \\n    if (s[i] === \"0\") left[i] = pre;\\n    if (s[i] === \"1\") left[i] = Math.min(pre + 2, i + 1)\\n  }\\n  \\n  for (let i = s.length - 1; i >= 0; --i) {\\n    const pre = i + 1 < s.length ? right[i + 1] : 0;\\n    if (s[i] === \"0\") right[i] = pre;\\n    if (s[i] === \"1\") right[i] = Math.min(pre + 2, s.length - i);\\n  }\\n  \\n  let min = Infinity;\\n  for (let i = 0; i < s.length - 1; ++i) {\\n    min = Math.min(min, left[i] + right[i + 1]);\\n  }\\n  \\n  return min;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1768795,
                "title": "python-prefix-sum-easy-to-understand",
                "content": "This post basically is just a python version of C++ code by @chandanagrawal23, here is [original post ](https://leetcode.com/problems/minimum-time-to-remove-all-cars-containing-illegal-goods/discuss/1748436/C%2B%2B-or-Prefix-Suffix-or-Easy-and-concise)\\n\\nIn order to remove all \\'1\\'s in the string, it is easy to calculate the minimum cost from 0 to i by using a prefix_sum, it would also be easy to calcuate the minimum cost from the end to i+1 also by using suffix_sum , then we can find the a minimum cost to remove all \\'1\\'s  by removing \\'1\\' in the range(0, i+1) from left and removing \\'1\\' in the range( i+1, len(s)) from right. Overall, we can find the global minimum cost. \\n\\n```\\nclass Solution:\\n    def minimumTime(self, s: str) -> int:\\n        costL2R = [None]*len(s)\\n        cost = 0 if s[0]==\\'0\\' else 1\\n        costL2R[0]=cost\\n        for i in range(1,len(s)):\\n            if s[i]==\\'1\\':\\n                cost = min(cost+2,i+1)\\n            costL2R[i]=cost           \\n                \\n        costR2L = [None]*len(s)\\n        cost = 0 if s[-1]==\\'0\\' else 1\\n        costR2L[-1] = cost\\n        for i in range(len(s)-2,-1,-1):\\n            if s[i]==\\'1\\':\\n                cost = min(cost+2,len(s) - (i+1)+1)\\n            costR2L[i] = cost\\n        costR2L.append(0)\\n            \\n        minCost = len(s)\\n        for i in range(len(s)):\\n            minCost = min(minCost,costL2R[i]+costR2L[i+1])\\n        return minCost\\n```\\n\\n\\nI think this question is similar to **[1653. Minimum Deletions to Make String Balanced](https://leetcode.com/problems/minimum-deletions-to-make-string-balanced/)**, basically we just need to find a balanced point and cut the string into two parts.\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, s: str) -> int:\\n        costL2R = [None]*len(s)\\n        cost = 0 if s[0]==\\'0\\' else 1\\n        costL2R[0]=cost\\n        for i in range(1,len(s)):\\n            if s[i]==\\'1\\':\\n                cost = min(cost+2,i+1)\\n            costL2R[i]=cost           \\n                \\n        costR2L = [None]*len(s)\\n        cost = 0 if s[-1]==\\'0\\' else 1\\n        costR2L[-1] = cost\\n        for i in range(len(s)-2,-1,-1):\\n            if s[i]==\\'1\\':\\n                cost = min(cost+2,len(s) - (i+1)+1)\\n            costR2L[i] = cost\\n        costR2L.append(0)\\n            \\n        minCost = len(s)\\n        for i in range(len(s)):\\n            minCost = min(minCost,costL2R[i]+costR2L[i+1])\\n        return minCost\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1765516,
                "title": "python-o-1-space-o-n-time",
                "content": "```\\n\\nclass Solution:\\n    def minimumTime(self, s: str) -> int:\\n        #ans=n+count(middle,1)-count(middle,0)\\n        #finding largest sum subarray \\n        sum=0\\n        #print(dp)\\n        min_ans=0\\n        for e in s:\\n            i=1\\n            if e==\\'0\\':\\n                i=-1\\n            sum=sum+i\\n            min_ans=min(sum,min_ans)\\n            if sum>0:\\n                sum=0\\n        return len(s)+min_ans\\n        \\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution:\\n    def minimumTime(self, s: str) -> int:\\n        #ans=n+count(middle,1)-count(middle,0)\\n        #finding largest sum subarray \\n        sum=0\\n        #print(dp)\\n        min_ans=0\\n        for e in s:\\n            i=1\\n            if e==\\'0\\':\\n                i=-1\\n            sum=sum+i\\n            min_ans=min(sum,min_ans)\\n            if sum>0:\\n                sum=0\\n        return len(s)+min_ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1763255,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8  The ART of Dynamic Programming:](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master) preprocess the input string `s` via linear scans in both directions to find optimal prefix from left-to-right and suffix from right-to-left.  Then perform a linear scan of the preprocessed prefix/suffix to consider each `i`<sup>th</sup> candidate `cand` as a \"pivot\" index to find the `best` solution of all possible prefix/suffix.\\n\\n**Bottom-up recurrence relation:**\\n\\nEach current optimal `i`<sup>th</sup> prefix/suffix is built upon itself.  There are 2 use cases to consider:\\n\\n1. if `s[i] == \\'0\\'`, then the current optimal cost is set to the previous optimal cost `pre`\\n2. if `s[i] == \\'1\\'`, then we have 2 choices:\\na. \"cherry pick\" from the middle for a **relative cost** of 2 + previous optimal cost `pre`\\nb. \"slide from end\" for an **absolute cost** which depends on the direction of the preprocessing traversal (see note below)\\n\\nNote: when we consider \"slide from end\", the **absolute cost** is:\\n1. \\uD83D\\uDC49 `i + 1` when preprocessing from left-to-right\\n2. \\uD83D\\uDC48 `N - i` when preprocessing from right-to-left\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun minimumTime(s: String, INF: Int = (1e9 + 7).toInt()): Int {\\n        var best = INF\\n        var N = s.length\\n        fun f(beg: Int, end: Int): IntArray {\\n            var A = IntArray(N) { 0 }\\n            var i = beg\\n            A[i] = if (s[i] == \\'1\\') 1 else 0\\n            while (i != end) {\\n                var pre = A[i]\\n                i = if (beg < end) i + 1 else i - 1\\n                if (s[i] == \\'0\\') A[i] = pre\\n                if (s[i] == \\'1\\') A[i] = Math.min(2 + pre, if (beg < end) i + 1 else N - i)\\n            }\\n            return A\\n        }\\n        var L = f(0, N - 1)\\n        var R = f(N - 1, 0)\\n        for (i in 1 until N) {\\n            var cand = L[i - 1] + R[i]\\n            best = Math.min(best, cand)\\n        }\\n        return if (best < INF) best else if (s[0] == \\'0\\') 0 else 1\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet minimumTime = (s, best = Infinity) => {\\n    let N = s.length;\\n    let f = (beg, end) => {\\n        let A = Array(N).fill(0);\\n        A[beg] = Number(s[beg] == \\'1\\');\\n        for (let i = beg < end ? beg + 1 : beg - 1; beg < end ? i <= end : end <= i; beg < end ? ++i : --i) {\\n            let pre = beg < end ? A[i - 1] : A[i + 1];\\n            if (s[i] == \\'0\\') A[i] = pre;\\n            if (s[i] == \\'1\\') A[i] = Math.min(2 + pre, beg < end ? i + 1 : N - i);\\n        }\\n        return A;\\n    };\\n    let L = f(0, N - 1),\\n        R = f(N - 1, 0);\\n    for (let i = 1; i < N; ++i) {\\n        let cand = L[i - 1] + R[i];\\n        best = Math.min(best, cand);\\n    }\\n    return best < Infinity ? best : Number(s[0] == \\'1\\');\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def minimumTime(self, s: str, best = float(\\'inf\\')) -> int:\\n        N = len(s)\\n        def f(beg, end):\\n            A = [0] * N\\n            A[beg] = int(s[beg])\\n            for i in range(beg + 1 if beg < end else beg - 1, end + 1 if beg < end else -1, 1 if beg < end else -1):\\n                pre = A[i - 1] if beg < end else A[i + 1]\\n                if s[i] == \\'0\\': A[i] = pre\\n                if s[i] == \\'1\\': A[i] = min(2 + pre, i + 1 if beg < end else N - i)\\n            return A\\n        L = f(0, N - 1)\\n        R = f(N - 1, 0)\\n        for i in range(1, N):\\n            cand = L[i - 1] + R[i]\\n            best = min(best, cand)\\n        return best if best < float(\\'inf\\') else int(s[0])\\n```\\n\\n*Rust*\\n```\\ntype VL = Vec<usize>;\\nuse std::cmp::min;\\nimpl Solution {\\n    pub fn minimum_time(s: String) -> i32 {\\n        fn f(s: &String, beg: i32, end: i32) -> VL {\\n            let N = s.len();\\n            let mut A = vec![0; N];\\n            let mut i = beg as usize;\\n            A[i] = if s.chars().nth(i).unwrap() == \\'1\\' { 1 } else { 0 };\\n            while (i != end as usize) {\\n                let pre = A[i];\\n                i = if beg < end { i + 1 } else { i - 1 };\\n                if s.chars().nth(i).unwrap() == \\'0\\' { A[i] = pre; }\\n                else { A[i] = min(2 + pre, if beg < end { i + 1 } else { N - i }) }\\n            }\\n            return A;\\n        }\\n        let N = s.len() as i32;\\n        let L = f(&s, 0, N - 1);\\n        let R = f(&s, N - 1, 0);\\n        let mut best = 100000007;\\n        for i in 1..N as usize {\\n            let cand = L[i - 1] + R[i];\\n            best = min(best, cand);\\n        }\\n        return if best < 100000007 { best as i32 } else if s.chars().nth(0).unwrap() == \\'1\\' { 1 } else { 0 }\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int minimumTime(string s, int best = 1e9 + 7) {\\n        int N = s.size();\\n        auto f = [&](auto beg, auto end) {\\n            VI A(N);\\n            A[beg] = s[beg] == \\'1\\';\\n            for (auto i{ beg < end ? beg + 1 : beg - 1 }; beg < end ? i <= end : end <= i; beg < end ? ++i : --i) {\\n                auto pre = beg < end ? A[i - 1] : A[i + 1];\\n                if (s[i] == \\'0\\') A[i] = pre;\\n                if (s[i] == \\'1\\') A[i] = min(2 + pre, beg < end ? i + 1 : N - i);\\n            }\\n            return A;\\n        };\\n        auto L = f(0, N - 1),\\n             R = f(N - 1, 0);\\n        for (auto i{ 1 }; i < N; ++i) {\\n            auto cand = L[i - 1] + R[i];\\n            best = min(best, cand);\\n        }\\n        return best < 1e9 + 7 ? best : s[0] == \\'1\\';\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun minimumTime(s: String, INF: Int = (1e9 + 7).toInt()): Int {\\n        var best = INF\\n        var N = s.length\\n        fun f(beg: Int, end: Int): IntArray {\\n            var A = IntArray(N) { 0 }\\n            var i = beg\\n            A[i] = if (s[i] == \\'1\\') 1 else 0\\n            while (i != end) {\\n                var pre = A[i]\\n                i = if (beg < end) i + 1 else i - 1\\n                if (s[i] == \\'0\\') A[i] = pre\\n                if (s[i] == \\'1\\') A[i] = Math.min(2 + pre, if (beg < end) i + 1 else N - i)\\n            }\\n            return A\\n        }\\n        var L = f(0, N - 1)\\n        var R = f(N - 1, 0)\\n        for (i in 1 until N) {\\n            var cand = L[i - 1] + R[i]\\n            best = Math.min(best, cand)\\n        }\\n        return if (best < INF) best else if (s[0] == \\'0\\') 0 else 1\\n    }\\n}\\n```\n```\\nlet minimumTime = (s, best = Infinity) => {\\n    let N = s.length;\\n    let f = (beg, end) => {\\n        let A = Array(N).fill(0);\\n        A[beg] = Number(s[beg] == \\'1\\');\\n        for (let i = beg < end ? beg + 1 : beg - 1; beg < end ? i <= end : end <= i; beg < end ? ++i : --i) {\\n            let pre = beg < end ? A[i - 1] : A[i + 1];\\n            if (s[i] == \\'0\\') A[i] = pre;\\n            if (s[i] == \\'1\\') A[i] = Math.min(2 + pre, beg < end ? i + 1 : N - i);\\n        }\\n        return A;\\n    };\\n    let L = f(0, N - 1),\\n        R = f(N - 1, 0);\\n    for (let i = 1; i < N; ++i) {\\n        let cand = L[i - 1] + R[i];\\n        best = Math.min(best, cand);\\n    }\\n    return best < Infinity ? best : Number(s[0] == \\'1\\');\\n};\\n```\n```\\nclass Solution:\\n    def minimumTime(self, s: str, best = float(\\'inf\\')) -> int:\\n        N = len(s)\\n        def f(beg, end):\\n            A = [0] * N\\n            A[beg] = int(s[beg])\\n            for i in range(beg + 1 if beg < end else beg - 1, end + 1 if beg < end else -1, 1 if beg < end else -1):\\n                pre = A[i - 1] if beg < end else A[i + 1]\\n                if s[i] == \\'0\\': A[i] = pre\\n                if s[i] == \\'1\\': A[i] = min(2 + pre, i + 1 if beg < end else N - i)\\n            return A\\n        L = f(0, N - 1)\\n        R = f(N - 1, 0)\\n        for i in range(1, N):\\n            cand = L[i - 1] + R[i]\\n            best = min(best, cand)\\n        return best if best < float(\\'inf\\') else int(s[0])\\n```\n```\\ntype VL = Vec<usize>;\\nuse std::cmp::min;\\nimpl Solution {\\n    pub fn minimum_time(s: String) -> i32 {\\n        fn f(s: &String, beg: i32, end: i32) -> VL {\\n            let N = s.len();\\n            let mut A = vec![0; N];\\n            let mut i = beg as usize;\\n            A[i] = if s.chars().nth(i).unwrap() == \\'1\\' { 1 } else { 0 };\\n            while (i != end as usize) {\\n                let pre = A[i];\\n                i = if beg < end { i + 1 } else { i - 1 };\\n                if s.chars().nth(i).unwrap() == \\'0\\' { A[i] = pre; }\\n                else { A[i] = min(2 + pre, if beg < end { i + 1 } else { N - i }) }\\n            }\\n            return A;\\n        }\\n        let N = s.len() as i32;\\n        let L = f(&s, 0, N - 1);\\n        let R = f(&s, N - 1, 0);\\n        let mut best = 100000007;\\n        for i in 1..N as usize {\\n            let cand = L[i - 1] + R[i];\\n            best = min(best, cand);\\n        }\\n        return if best < 100000007 { best as i32 } else if s.chars().nth(0).unwrap() == \\'1\\' { 1 } else { 0 }\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int minimumTime(string s, int best = 1e9 + 7) {\\n        int N = s.size();\\n        auto f = [&](auto beg, auto end) {\\n            VI A(N);\\n            A[beg] = s[beg] == \\'1\\';\\n            for (auto i{ beg < end ? beg + 1 : beg - 1 }; beg < end ? i <= end : end <= i; beg < end ? ++i : --i) {\\n                auto pre = beg < end ? A[i - 1] : A[i + 1];\\n                if (s[i] == \\'0\\') A[i] = pre;\\n                if (s[i] == \\'1\\') A[i] = min(2 + pre, beg < end ? i + 1 : N - i);\\n            }\\n            return A;\\n        };\\n        auto L = f(0, N - 1),\\n             R = f(N - 1, 0);\\n        for (auto i{ 1 }; i < N; ++i) {\\n            auto cand = L[i - 1] + R[i];\\n            best = min(best, cand);\\n        }\\n        return best < 1e9 + 7 ? best : s[0] == \\'1\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1760918,
                "title": "c-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int n = s.size();\\n        vector<int> dp1(n);\\n        vector<int> dp2(n);\\n        for(int i = 0; i < n; i++) {\\n            if(s[i] == \\'1\\') {\\n                dp1[i] = min((i == 0 ? 0 : dp1[i - 1]) + 2, i + 1);\\n            }\\n            else {\\n                dp1[i] = (i == 0 ? 0 : dp1[i - 1]);\\n            }\\n        }\\n        for(int i = n - 1; i >= 0; i--) {\\n            if(s[i] == \\'1\\') {\\n                dp2[i] = min((i == n - 1 ? 0 : dp2[i + 1]) + 2, n - i);\\n            }\\n            else {\\n                dp2[i] = (i == n - 1 ? 0 : dp2[i + 1]);\\n            }\\n        }\\n        int sol = min(dp1[n - 1], dp2[0]);\\n        for(int i = 0; i < n - 1; i++) {\\n            sol = min(sol, dp1[i] + dp2[i + 1]);\\n        }\\n        return sol;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int n = s.size();\\n        vector<int> dp1(n);\\n        vector<int> dp2(n);\\n        for(int i = 0; i < n; i++) {\\n            if(s[i] == \\'1\\') {\\n                dp1[i] = min((i == 0 ? 0 : dp1[i - 1]) + 2, i + 1);\\n            }\\n            else {\\n                dp1[i] = (i == 0 ? 0 : dp1[i - 1]);\\n            }\\n        }\\n        for(int i = n - 1; i >= 0; i--) {\\n            if(s[i] == \\'1\\') {\\n                dp2[i] = min((i == n - 1 ? 0 : dp2[i + 1]) + 2, n - i);\\n            }\\n            else {\\n                dp2[i] = (i == n - 1 ? 0 : dp2[i + 1]);\\n            }\\n        }\\n        int sol = min(dp1[n - 1], dp2[0]);\\n        for(int i = 0; i < n - 1; i++) {\\n            sol = min(sol, dp1[i] + dp2[i + 1]);\\n        }\\n        return sol;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1760180,
                "title": "detailed-explaination-simple-dp-c-solution",
                "content": "# TIME & SPACE - O(n) O(n)******\\n// you can also start from the right side it will still work\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n\\t\\n        int n= s.size();\\n        vector<int> dp(n+1, 0);\\n        \\n        int ans =n; // if we remove all cars from 1 side consecutively\\n        \\n        // dp[1] means left will involve in 1 car removal(i.e., s[0]) in min time, and the rest of teh removal happens from  right\\n        // dp[3] means left will involve in 3 cars removal(i.e., s[0]. s[1] , s[2]) in min. time ,  and the rest of teh removal happens from  right\\n        for( int left=1; left<=n; left++){\\n            \\n             // we have 2 options for dp[left]: if s[left-1]=\\'1\\'  :\\n             // 1. asssume this 1 to be a middle car , for that we need 2 units of time\\n            // 2. or remove everything from left side one by 1 (ofc it will take \\'left\\' units of time )\\n            // take the minimum of the 2 options\\n            dp[left] = min( dp[left-1] + 2* (s[left-1]-\\'0\\') , left);  \\n            \\n            // from right side we will do  consecutive removals....so it will take (n-left) units of time\\n            // it will work because from the right side only consecutive illegal cars(s[i]==\\'1\\') will be removed, and the middle cars\\n            // closer to right side can still be picked up from the left side( becoz it will take constant 2 units from both sides)\\n            ans = min(ans, dp[left] + (n-left));\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumTime(string s) {\\n\\t\\n        int n= s.size();\\n        vector<int> dp(n+1, 0);\\n        \\n        int ans =n; // if we remove all cars from 1 side consecutively\\n        \\n        // dp[1] means left will involve in 1 car removal(i.e., s[0]) in min time, and the rest of teh removal happens from  right\\n        // dp[3] means left will involve in 3 cars removal(i.e., s[0]. s[1] , s[2]) in min. time ,  and the rest of teh removal happens from  right\\n        for( int left=1; left<=n; left++){\\n            \\n             // we have 2 options for dp[left]: if s[left-1]=\\'1\\'  :\\n             // 1. asssume this 1 to be a middle car , for that we need 2 units of time\\n            // 2. or remove everything from left side one by 1 (ofc it will take \\'left\\' units of time )\\n            // take the minimum of the 2 options\\n            dp[left] = min( dp[left-1] + 2* (s[left-1]-\\'0\\') , left);  \\n            \\n            // from right side we will do  consecutive removals....so it will take (n-left) units of time\\n            // it will work because from the right side only consecutive illegal cars(s[i]==\\'1\\') will be removed, and the middle cars\\n            // closer to right side can still be picked up from the left side( becoz it will take constant 2 units from both sides)\\n            ans = min(ans, dp[left] + (n-left));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1759775,
                "title": "java-wth-space-o-1",
                "content": "at ith index think about available options \\neither remove all  cars from the left or remove it from the middle and move ahead\\n\\nat ith index, we have an answer up to i-1 index in left \\nso at ith index if it is \"1\" then  left=Min(left+2,i+1);\\n  left+2 means removing it from middle \\ni+1// means removing all cars from left;\\nnow res storing the answer \\nat ith index answer up to 0 to i we have it in left \\nremaining (i+1)to(n-1) we remove all cars that cost (n-i-1);\\nres=min(res,left+n-1-i);\\nas we are considering all the cases from 0 to n-1 \\nfor each index, we are taking all cases either removing all cars from left or right and if we remove it from the middle then no matters(left or right ) cost will be two only ;\\nfor each index(removing from the middle or removing all cars (left, right))\\n// Code \\n\\n\\t           \\'\\'\\'if(s.length()==0){\\n                    return 0;\\n            }\\n           int res=s.length();\\n            int left=0;\\n            for(int i=0;i<s.length();i++){\\n                    left=Math.min(left+2*(s.charAt(i)-\\'0\\'),i+1);\\n                    res=Math.min(left+s.length()-1-i,res);\\n            }\\n            return res;\\'\\'\\'\\n\\t\\t\\t",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "at ith index think about available options \\neither remove all  cars from the left or remove it from the middle and move ahead\\n\\nat ith index, we have an answer up to i-1 index in left \\nso at ith index if it is \"1\" then  left=Min(left+2,i+1);\\n  left+2 means removing it from middle \\ni+1// means removing all cars from left;\\nnow res storing the answer \\nat ith index answer up to 0 to i we have it in left \\nremaining (i+1)to(n-1) we remove all cars that cost (n-i-1);\\nres=min(res,left+n-1-i);\\nas we are considering all the cases from 0 to n-1 \\nfor each index, we are taking all cases either removing all cars from left or right and if we remove it from the middle then no matters(left or right ) cost will be two only ;\\nfor each index(removing from the middle or removing all cars (left, right))\\n// Code \\n\\n\\t           \\'\\'\\'if(s.length()==0){\\n                    return 0;\\n            }\\n           int res=s.length();\\n            int left=0;\\n            for(int i=0;i<s.length();i++){\\n                    left=Math.min(left+2*(s.charAt(i)-\\'0\\'),i+1);\\n                    res=Math.min(left+s.length()-1-i,res);\\n            }\\n            return res;\\'\\'\\'\\n\\t\\t\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1758530,
                "title": "java-o-n-solution",
                "content": "class Solution {\\n    public int minimumTime(String s) {\\n        \\n        int l[]=new int[s.length()];\\n        if(s.charAt(0)==\\'1\\')\\n            l[0]=1;\\n        for(int i=1;i<s.length();i++)\\n        {\\n            char ch=s.charAt(i);\\n            if(ch==\\'0\\')\\n                l[i]=l[i-1];\\n            else\\n                l[i]=Math.min(i+1,l[i-1]+2);\\n        }\\n        int r[]=new int[s.length()];\\n        if(s.charAt(s.length()-1)==\\'1\\')\\n            r[r.length-1]=1;\\n        for(int i=s.length()-2;i>=0;i--)\\n        {\\n            char ch=s.charAt(i);\\n            if(ch==\\'0\\')\\n                r[i]=r[i+1];\\n            else\\n            {\\n                r[i]=Math.min(s.length()-i,r[i+1]+2);\\n            }\\n            \\n        }\\n        \\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<l.length-1;i++)\\n            min=Math.min(min,l[i]+r[i+1]);\\n        min=Math.min(l[l.length-1],min);\\n        min=Math.min(r[0],min);\\n        return min;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minimumTime(String s) {\\n        \\n        int l[]=new int[s.length()];\\n        if(s.charAt(0)==\\'1\\')\\n            l[0]=1;\\n        for(int i=1;i<s.length();i++)\\n        {\\n            char ch=s.charAt(i);\\n            if(ch==\\'0\\')\\n                l[i]=l[i-1];\\n            else\\n                l[i]=Math.min(i+1,l[i-1]+2);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1758528,
                "title": "java-solution-kadane-s-algo",
                "content": "```\\nclass Solution {\\n    public int minimumTime(String s) {\\n        int arr[]=new int [s.length()];\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(s.charAt(i)==\\'0\\')arr[i]=-1;\\n            else arr[i]=1;\\n        }\\n        int min=0;\\n        int sum=0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            sum+=arr[i];\\n            min=Math.min(min,sum);\\n            if(sum>0)\\n                sum=0;\\n        }\\n       return arr.length+min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumTime(String s) {\\n        int arr[]=new int [s.length()];\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(s.charAt(i)==\\'0\\')arr[i]=-1;\\n            else arr[i]=1;\\n        }\\n        int min=0;\\n        int sum=0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            sum+=arr[i];\\n            min=Math.min(min,sum);\\n            if(sum>0)\\n                sum=0;\\n        }\\n       return arr.length+min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1758223,
                "title": "kadane-s-algorithm-beats-97",
                "content": "```\\nclass Solution:\\n    def minimumTime(self, s: str) -> int:\\n        n = len(s)\\n        arr = [1 if s[i]==\"1\" else -1 for i in range(n)]\\n        sum=mini=0\\n        for num in arr:\\n            sum += num\\n            mini = min(mini,sum)\\n            if sum>0:\\n                sum = 0\\n        return n+mini\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, s: str) -> int:\\n        n = len(s)\\n        arr = [1 if s[i]==\"1\" else -1 for i in range(n)]\\n        sum=mini=0\\n        for num in arr:\\n            sum += num\\n            mini = min(mini,sum)\\n            if sum>0:\\n                sum = 0\\n        return n+mini\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1756780,
                "title": "go-easy-solution",
                "content": "```\\nfunc minimumTime(s string) int {\\n    nums:=make([]int,len(s))\\n    for i,v:=range s{\\n        nums[i]=1\\n        if string(v)==\"0\"{\\n            nums[i]=-1\\n        }\\n    }\\n    min:=0\\n    sum:=0\\n    for _,v:=range nums{\\n        sum+=v\\n        if sum>0{\\n            sum=0\\n        }\\n        if sum<min{\\n            min=sum\\n        }\\n    }\\n    return len(s)+min\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minimumTime(s string) int {\\n    nums:=make([]int,len(s))\\n    for i,v:=range s{\\n        nums[i]=1\\n        if string(v)==\"0\"{\\n            nums[i]=-1\\n        }\\n    }\\n    min:=0\\n    sum:=0\\n    for _,v:=range nums{\\n        sum+=v\\n        if sum>0{\\n            sum=0\\n        }\\n        if sum<min{\\n            min=sum\\n        }\\n    }\\n    return len(s)+min\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1755611,
                "title": "using-kadane-s-algorithm-easy-to-understand-in-cpp-c",
                "content": "class Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int n=s.size();\\n        int ans=n;\\n        vector<int>v;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'0\\')v.push_back(-1);\\n            else\\n                v.push_back(1);\\n        }\\n        int sum=0;\\n        int m=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=v[i];\\n            m=min(sum,m);\\n            if(sum>0)sum=0;\\n        }\\n        return m+ans;\\n    }\\n};\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int n=s.size();\\n        int ans=n;\\n        vector<int>v;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'0\\')v.push_back(-1);\\n            else\\n                v.push_back(1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1754320,
                "title": "c-easy-to-understand-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int n = s.size();\\n        // For each i, we have 3 options: 1. remove all chars from left\\n        // 2. remove all chars from right and 3. remove this char and the rest \\n        // of i-1 or i+1. \\n        // So lets do 2 loops, one for L2R pass and one for R2L pass\\n        // for case 3. L2R pass dp1[i] indicates min operations needed if we only remove\\n        // cars from the left, and R2L pass dp2[i] indicates min operations needed if we \\n        // only remove cars from the right uptil and including i. Then adding dp1[i] + dp2[i+1]\\n        // should give us the answer:\\n        vector<int> dp1(n, 0);\\n        vector<int> dp2(n, 0);\\n        \\n        // L2R pass for dp1[i]\\n        for (int i = 0; i < n; i++) {\\n            if (s[i] == \\'1\\') {\\n                dp1[i] = min(i+1, 2+(i > 0 ? dp1[i-1]: 0));\\n            } else {\\n                dp1[i] = (i > 0 ? dp1[i-1]: 0);\\n            }\\n        }\\n        \\n        // R2L pass for dp2[i]\\n        for (int i = n-1; i >= 0; i--) {\\n            if (s[i] == \\'1\\') {\\n                dp2[i] = min(n-i, 2+((i > n-2) ? 0 : dp2[i+1]));\\n            } else {\\n                dp2[i] = (i > n-2) ? 0 : dp2[i+1];\\n            }\\n        }\\n        \\n        int res = INT_MAX;\\n        for (int i = 0; i < n; i++) {\\n            // we use i+1 here since we don\\'t want to double count:\\n            res = min(res, dp1[i] + (i == n - 1 ? 0 : dp2[i+1]));\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int n = s.size();\\n        // For each i, we have 3 options: 1. remove all chars from left\\n        // 2. remove all chars from right and 3. remove this char and the rest \\n        // of i-1 or i+1. \\n        // So lets do 2 loops, one for L2R pass and one for R2L pass\\n        // for case 3. L2R pass dp1[i] indicates min operations needed if we only remove\\n        // cars from the left, and R2L pass dp2[i] indicates min operations needed if we \\n        // only remove cars from the right uptil and including i. Then adding dp1[i] + dp2[i+1]\\n        // should give us the answer:\\n        vector<int> dp1(n, 0);\\n        vector<int> dp2(n, 0);\\n        \\n        // L2R pass for dp1[i]\\n        for (int i = 0; i < n; i++) {\\n            if (s[i] == \\'1\\') {\\n                dp1[i] = min(i+1, 2+(i > 0 ? dp1[i-1]: 0));\\n            } else {\\n                dp1[i] = (i > 0 ? dp1[i-1]: 0);\\n            }\\n        }\\n        \\n        // R2L pass for dp2[i]\\n        for (int i = n-1; i >= 0; i--) {\\n            if (s[i] == \\'1\\') {\\n                dp2[i] = min(n-i, 2+((i > n-2) ? 0 : dp2[i+1]));\\n            } else {\\n                dp2[i] = (i > n-2) ? 0 : dp2[i+1];\\n            }\\n        }\\n        \\n        int res = INT_MAX;\\n        for (int i = 0; i < n; i++) {\\n            // we use i+1 here since we don\\'t want to double count:\\n            res = min(res, dp1[i] + (i == n - 1 ? 0 : dp2[i+1]));\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1753558,
                "title": "c-prefix-suffix-easy-solution-with-explanations",
                "content": "One pass from left to right.\\nleft counts the cost to clear all illegal goods from s[0] to s[i]\\nright counts the cost to clear all illegal goods from s[i+1] to s[n-1]\\n\\nIf s[i] == 1, then update left value,\\nwe take the minimum of these 2 options:\\n\\ni + 1, by removing all left cars, i + 1\\nleft + 2, previously remove cose + removing the current s[i]\\nright = n - 1 - i, be removing all right cars.\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int n = s.size();\\n        vector<int>prf(n+2 , 0) , suf(n+2 , 0);\\n        for(int i=0;i<n;i++){\\n            if(s[i] == \\'1\\') prf[i+1] = min(prf[i]+2,(i+1));\\n            else prf[i+1] = prf[i];\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            if(s[i] == \\'1\\') suf[i] = min(suf[i+1]+2 , (n-i));\\n            else suf[i] = suf[i+1];\\n        }\\n        int ans = 1000000000;\\n        for(int i=1;i<=n;i++) ans = min(ans , prf[i]+suf[i]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int n = s.size();\\n        vector<int>prf(n+2 , 0) , suf(n+2 , 0);\\n        for(int i=0;i<n;i++){\\n            if(s[i] == \\'1\\') prf[i+1] = min(prf[i]+2,(i+1));\\n            else prf[i+1] = prf[i];\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            if(s[i] == \\'1\\') suf[i] = min(suf[i+1]+2 , (n-i));\\n            else suf[i] = suf[i+1];\\n        }\\n        int ans = 1000000000;\\n        for(int i=1;i<=n;i++) ans = min(ans , prf[i]+suf[i]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1753452,
                "title": "javascript-solution-tc-o-n-sc-o-1-kadane-s-algorithm-consider-0-as-1-and-1-as-1-1",
                "content": "```\\nvar minimumTime = function(s) {\\n    const len = s.length;\\n    let totalMinEffort = 0;\\n    let currentMinEffort = 0;\\n    for(let i = 0; i < len; i++){\\n        if(s[i] === \\'0\\'){\\n            currentMinEffort = Math.min(currentMinEffort - 1, -1);\\n        } else {\\n            currentMinEffort = Math.min(currentMinEffort + 1, 1);\\n        }\\n        if(currentMinEffort < totalMinEffort){\\n            totalMinEffort = currentMinEffort;\\n        }\\n    }\\n    return len + totalMinEffort;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar minimumTime = function(s) {\\n    const len = s.length;\\n    let totalMinEffort = 0;\\n    let currentMinEffort = 0;\\n    for(let i = 0; i < len; i++){\\n        if(s[i] === \\'0\\'){\\n            currentMinEffort = Math.min(currentMinEffort - 1, -1);\\n        } else {\\n            currentMinEffort = Math.min(currentMinEffort + 1, 1);\\n        }\\n        if(currentMinEffort < totalMinEffort){\\n            totalMinEffort = currentMinEffort;\\n        }\\n    }\\n    return len + totalMinEffort;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1753222,
                "title": "minimum-subarray-sum",
                "content": "Adapted from https://leetcode.com/problems/minimum-time-to-remove-all-cars-containing-illegal-goods/discuss/1748424/Python-maximum-sum-on-subarray-explained.\\n\\nIt\\'s hard to decide that the final form must be \\'type-1 type-2 type-1\\'. There cannot be type-1 operation in between two type-2 operation segment because we can always find a cheaper solution. It\\'s easy to prove this lemma but it\\'s hard to raise the lemma up as the first step to prove.\\n\\nNote that if the minimal subarray sum is positive or 0, that means there is no zero in the string. We can just do type-1 operation and the answer is \\'n\\', any type-2 operation will increase the cost. If the minimal subarray sum is negative, then we do not care about whether the Left and Right parts are empty or not.\\n\\nThis is a good problem since it requires a lemma and a reduction to a known problem.\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int n = s.size(), dp = INT_MAX, minSub = INT_MAX;\\n        for (int i = 0; i < n; ++i) {\\n            dp = i ? (dp + (s[i] == \\'1\\' ? 1 : -1)) : INT_MAX;\\n            dp = min(dp, (s[i] == \\'1\\' ? 1 : -1));\\n            minSub = min(minSub, dp);\\n        }\\n        return n + min(0, minSub);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int n = s.size(), dp = INT_MAX, minSub = INT_MAX;\\n        for (int i = 0; i < n; ++i) {\\n            dp = i ? (dp + (s[i] == \\'1\\' ? 1 : -1)) : INT_MAX;\\n            dp = min(dp, (s[i] == \\'1\\' ? 1 : -1));\\n            minSub = min(minSub, dp);\\n        }\\n        return n + min(0, minSub);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1753193,
                "title": "100-faster-and-100-space-cost-efficiency-c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n       int i,n=s.size();\\n        int prefix_cost[n],sufix_cost[n];\\n        prefix_cost[0]=s[0]==\\'0\\'?0:1;\\n        for(i=1;i<n;i++)\\n        {\\n           if(s[i]==\\'1\\')\\n           {\\n               prefix_cost[i]=min(i+1,prefix_cost[i-1]+2);\\n           }\\n            else prefix_cost[i]=prefix_cost[i-1];\\n        }\\n        sufix_cost[n-1]=s[n-1]==\\'0\\'?0:1;\\n        for(i=n-2;i>=0;i--)\\n        {\\n           if(s[i]==\\'1\\')\\n           {\\n               sufix_cost[i]=min(n-i,sufix_cost[i+1]+2);\\n           }\\n            else sufix_cost[i]=sufix_cost[i+1];\\n        }\\n        int mc=min(sufix_cost[0],prefix_cost[n-1]);\\n        for(i=0;i<n-1;i++)\\n        {\\n            mc=min(mc,prefix_cost[i]+sufix_cost[i+1]);\\n        }\\n        return mc;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n       int i,n=s.size();\\n        int prefix_cost[n],sufix_cost[n];\\n        prefix_cost[0]=s[0]==\\'0\\'?0:1;\\n        for(i=1;i<n;i++)\\n        {\\n           if(s[i]==\\'1\\')\\n           {\\n               prefix_cost[i]=min(i+1,prefix_cost[i-1]+2);\\n           }\\n            else prefix_cost[i]=prefix_cost[i-1];\\n        }\\n        sufix_cost[n-1]=s[n-1]==\\'0\\'?0:1;\\n        for(i=n-2;i>=0;i--)\\n        {\\n           if(s[i]==\\'1\\')\\n           {\\n               sufix_cost[i]=min(n-i,sufix_cost[i+1]+2);\\n           }\\n            else sufix_cost[i]=sufix_cost[i+1];\\n        }\\n        int mc=min(sufix_cost[0],prefix_cost[n-1]);\\n        for(i=0;i<n-1;i++)\\n        {\\n            mc=min(mc,prefix_cost[i]+sufix_cost[i+1]);\\n        }\\n        return mc;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1752659,
                "title": "runtime-228-ms-faster-than-100-00-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int n=s.length();\\n        vector<int> prefix(n,0);\\n        if(s[0]==\\'1\\')\\n        {\\n            prefix[0]=1;\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            if(s[i]==\\'1\\')\\n            prefix[i] = min(prefix[i-1]+2,i+1);\\n            else\\n                prefix[i]=prefix[i-1];\\n        }\\n        vector<int> suffix(n,0);\\n        if(s[n-1]==\\'1\\')\\n        {\\n            suffix[n-1]=1;\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(s[i]==\\'1\\')\\n            suffix[i]=min(suffix[i+1]+2,n-i);\\n            else\\n                suffix[i]=suffix[i+1];\\n        }\\n        int mn=INT_MAX;\\n        mn = min(prefix[n-1],suffix[0]);\\n        for(int i=0;i<n-2;i++)\\n        {\\n            mn = min(mn,prefix[i]+suffix[i+1]);\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int n=s.length();\\n        vector<int> prefix(n,0);\\n        if(s[0]==\\'1\\')\\n        {\\n            prefix[0]=1;\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            if(s[i]==\\'1\\')\\n            prefix[i] = min(prefix[i-1]+2,i+1);\\n            else\\n                prefix[i]=prefix[i-1];\\n        }\\n        vector<int> suffix(n,0);\\n        if(s[n-1]==\\'1\\')\\n        {\\n            suffix[n-1]=1;\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(s[i]==\\'1\\')\\n            suffix[i]=min(suffix[i+1]+2,n-i);\\n            else\\n                suffix[i]=suffix[i+1];\\n        }\\n        int mn=INT_MAX;\\n        mn = min(prefix[n-1],suffix[0]);\\n        for(int i=0;i<n-2;i++)\\n        {\\n            mn = min(mn,prefix[i]+suffix[i+1]);\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1752500,
                "title": "c-150-ms-100-averse-reverse-traversal",
                "content": "Runtime: 150 ms, faster than 100.00% of C++ online submissions for Minimum Time to Remove All Cars Containing Illegal Goods.\\nMemory Usage: 36.5 MB, less than 100.00% of C++ online submissions for Minimum Time to Remove All Cars Containing Illegal Goods.\\n```\\nclass Solution {\\npublic:\\n  int minimumTime(string s) {\\n    int x = 0, t = 0;\\n    vector<int>l = {0};\\n    \\n    while(x != s.size()){                                          //averse traversal\\n      while(x != s.size() && s[x] == \\'0\\') x++;\\n      if(x == s.size()) break;\\n      \\n      int old_x = x;\\n      while(x != s.size() && s[x] == \\'1\\') x++;\\n       \\n      l.push_back(t = min<int>(t + ((x - old_x)<<1), x));\\n    }\\n    \\n    if(l.empty()) return 0;\\n    \\n    int ans = t, id = l.size() - 2;\\n    x = s.size()-1, t = 0;\\n    \\n    while(x != -1){                                                    //reverse traversal\\n      while(x != -1 && s[x] == \\'0\\') x--;\\n      if(x == -1) break;\\n      \\n      int old_x = x;\\n      while(x != -1 && s[x] == \\'1\\') x--;\\n       \\n      t = min<int>(t + ((old_x - x)<<1), s.size() - x - 1);\\n      ans = min<int>(ans, l[id--] + t );\\n    }\\n  \\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int minimumTime(string s) {\\n    int x = 0, t = 0;\\n    vector<int>l = {0};\\n    \\n    while(x != s.size()){                                          //averse traversal\\n      while(x != s.size() && s[x] == \\'0\\') x++;\\n      if(x == s.size()) break;\\n      \\n      int old_x = x;\\n      while(x != s.size() && s[x] == \\'1\\') x++;\\n       \\n      l.push_back(t = min<int>(t + ((x - old_x)<<1), x));\\n    }\\n    \\n    if(l.empty()) return 0;\\n    \\n    int ans = t, id = l.size() - 2;\\n    x = s.size()-1, t = 0;\\n    \\n    while(x != -1){                                                    //reverse traversal\\n      while(x != -1 && s[x] == \\'0\\') x--;\\n      if(x == -1) break;\\n      \\n      int old_x = x;\\n      while(x != -1 && s[x] == \\'1\\') x--;\\n       \\n      t = min<int>(t + ((old_x - x)<<1), s.size() - x - 1);\\n      ans = min<int>(ans, l[id--] + t );\\n    }\\n  \\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1752219,
                "title": "c-squeezing-everything-into-a-single-call-to-std-accumulate",
                "content": "No originality in the algorithm. It is just [DBabichev\\'s](https://leetcode.com/problems/minimum-time-to-remove-all-cars-containing-illegal-goods/discuss/1748424/Python-maximum-sum-on-subarray-explained) solution repackaged using the C++ Standard Library.\\n\\n```\\nclass Solution {\\npublic:\\n\\tint minimumTime(string s) {\\n\\t\\t return size(s) + accumulate(cbegin(s), cend(s), 0,\\n\\t\\t\\t[sum = 0](int minimum, char c) mutable {\\n\\t\\t\\t\\t(sum += 2 * (c - \\'0\\') - 1) > 0 ? sum = 0 : minimum = min(minimum, sum);\\n\\t\\t\\t\\treturn minimum;\\n\\t\\t    });\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint minimumTime(string s) {\\n\\t\\t return size(s) + accumulate(cbegin(s), cend(s), 0,\\n\\t\\t\\t[sum = 0](int minimum, char c) mutable {\\n\\t\\t\\t\\t(sum += 2 * (c - \\'0\\') - 1) > 0 ? sum = 0 : minimum = min(minimum, sum);\\n\\t\\t\\t\\treturn minimum;\\n\\t\\t    });\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1751985,
                "title": "c-o-n-dp",
                "content": "class Solution {\\npublic:\\n    int minimumTime(string s) {\\n        \\n        int n = s.size();\\n        vector<int> left(n, 0);\\n        vector<int> right(n, 0);\\n        int sum = 0;\\n        left[0] = s[0] - \\'0\\';\\n        for(int i = 1; i < n; i++)\\n            left[i] = min(left[i - 1] + (s[i] - \\'0\\') * 2, i + 1);\\n        \\n        sum = 0, right[n - 1] = s[n - 1] - \\'0\\';\\n        for(int i = n - 2; i >= 0; i--)\\n            right[i] = min(right[i + 1] + (s[i] - \\'0\\') * 2, n - i);\\n\\n        int ans = min(right[0], left[n - 1]);\\n        for(int i = 1; i < n - 1; i++)\\n            ans = min(ans, min(left[i] + right[i + 1], left[i - 1] + right[i]));\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumTime(string s) {\\n        \\n        int n = s.size();\\n        vector<int> left(n, 0);\\n        vector<int> right(n, 0);\\n        int sum = 0;\\n        left[0] = s[0] - \\'0\\';\\n        for(int i = 1; i < n; i++)\\n            left[i] = min(left[i - 1] + (s[i] - \\'0\\') * 2, i + 1);\\n        \\n        sum = 0, right[n - 1] = s[n - 1] - \\'0\\';\\n        for(int i = n - 2; i >= 0; i--)\\n            right[i] = min(right[i + 1] + (s[i] - \\'0\\') * 2, n - i);\\n\\n        int ans = min(right[0], left[n - 1]);\\n        for(int i = 1; i < n - 1; i++)\\n            ans = min(ans, min(left[i] + right[i + 1], left[i - 1] + right[i]));\\n        \\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1751826,
                "title": "c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) \\n    {\\n        int n=s.size(),res=n;\\n        if(n==1)\\n            return (s[0]-\\'0\\');\\n        vector<int>right(n,0);\\n        right[n-1]=s[n-1]==\\'1\\'?1:0;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(s[i]==\\'0\\')\\n                right[i]=right[i+1];\\n            else\\n                right[i]=min(n-i,right[i+1]+2);\\n        }\\n        int left=0;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(s[i]==\\'1\\')\\n                left=min(i+1,left+2);\\n            res=min(res,left+right[i+1]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) \\n    {\\n        int n=s.size(),res=n;\\n        if(n==1)\\n            return (s[0]-\\'0\\');\\n        vector<int>right(n,0);\\n        right[n-1]=s[n-1]==\\'1\\'?1:0;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(s[i]==\\'0\\')\\n                right[i]=right[i+1];\\n            else\\n                right[i]=min(n-i,right[i+1]+2);\\n        }\\n        int left=0;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(s[i]==\\'1\\')\\n                left=min(i+1,left+2);\\n            res=min(res,left+right[i+1]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1750127,
                "title": "prefix-suffix-approach-c-easy-to-understand",
                "content": "**Title** : Prefix Suffix\\n**Approach** : \\nThere are two ways either we remove single element or all elements before or after that element. So for each element we will calculate total cost removing all elements up-to that element from both side ( using prefix and suffix array).\\n\\nThen simply find minimum cost using these two arrays.\\n\\n**Code** : \\n```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        \\n        int n = s.size();\\n        vector<int>suffix(n, 0);\\n        vector<int>prefix(n, 0);\\n\\n        int ans=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'1\\'){\\n            ans += 2;\\n            ans = min(ans, i+1);\\n            }\\n            prefix[i] = ans;\\n        }\\n\\n        ans=0;\\n        for(int i=s.size()-1;i>=0;i--)\\n        {\\n            if(s[i]==\\'1\\'){\\n            ans += 2;\\n            ans = min(ans, n-i);\\n            }\\n            suffix[i] = ans;\\n        }\\n\\n        int res=min(suffix[0], prefix[n-1]);\\n        for(int i=0;i<s.size()-1;i++)\\n        {\\n            res = min(res, prefix[i]+suffix[i+1]);\\n        }\\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        \\n        int n = s.size();\\n        vector<int>suffix(n, 0);\\n        vector<int>prefix(n, 0);\\n\\n        int ans=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'1\\'){\\n            ans += 2;\\n            ans = min(ans, i+1);\\n            }\\n            prefix[i] = ans;\\n        }\\n\\n        ans=0;\\n        for(int i=s.size()-1;i>=0;i--)\\n        {\\n            if(s[i]==\\'1\\'){\\n            ans += 2;\\n            ans = min(ans, n-i);\\n            }\\n            suffix[i] = ans;\\n        }\\n\\n        int res=min(suffix[0], prefix[n-1]);\\n        for(int i=0;i<s.size()-1;i++)\\n        {\\n            res = min(res, prefix[i]+suffix[i+1]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1750118,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void find(string s,vector<int>&nums)\\n    {\\n        if(s[0]==\\'1\\')\\n        {\\n            nums[0]=1;\\n        }\\n        int n=nums.size();\\n        for(int i=1;i<n;i++)\\n        {\\n            nums[i]=(s[i]==\\'1\\')?min(nums[i-1]+2,i+1):nums[i-1];\\n        }\\n    }\\n    int minimumTime(string s) \\n    {\\n        int n=s.size();\\n        if(n==1&&s[0]==\\'1\\')\\n        {\\n            return 1;\\n        }\\n        vector<int>left(n,0),right(n,0);\\n        find(s,left);\\n        reverse(s.begin(),s.end());\\n        find(s,right);\\n        reverse(right.begin(),right.end());\\n        int ans=INT_MAX;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            ans=min(ans,left[i]+right[i+1]);\\n        }\\n        return ans==INT_MAX?0:ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void find(string s,vector<int>&nums)\\n    {\\n        if(s[0]==\\'1\\')\\n        {\\n            nums[0]=1;\\n        }\\n        int n=nums.size();\\n        for(int i=1;i<n;i++)\\n        {\\n            nums[i]=(s[i]==\\'1\\')?min(nums[i-1]+2,i+1):nums[i-1];\\n        }\\n    }\\n    int minimumTime(string s) \\n    {\\n        int n=s.size();\\n        if(n==1&&s[0]==\\'1\\')\\n        {\\n            return 1;\\n        }\\n        vector<int>left(n,0),right(n,0);\\n        find(s,left);\\n        reverse(s.begin(),s.end());\\n        find(s,right);\\n        reverse(right.begin(),right.end());\\n        int ans=INT_MAX;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            ans=min(ans,left[i]+right[i+1]);\\n        }\\n        return ans==INT_MAX?0:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1750110,
                "title": "faster-than-100-c-o-n",
                "content": "https://github.com/kumarmanish03/DSA-Solved-Questions/blob/main/String/Minimum%20Time%20to%20Remove%20All%20Cars%20Containing%20Illegal%20Goods.cpp\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int n = s.size();\\n        vector<int> left(n, 0), right(n, 0);\\n        int one = 0;\\n        \\n        if(s[0] == \\'0\\') right[0] = 0;\\n        else right[0] = 1, one++;\\n        for(int i = 1; i < n; i++){\\n            if(s[i] == \\'1\\'){\\n                one++;\\n                right[i] = min(one*2, min(i+1, right[i-1]+2));\\n            }\\n            else{\\n                right[i] = right[i-1];\\n            }\\n        }\\n        one = 0;\\n        if(s[n-1] == \\'0\\') left[n-1] = 0;\\n        else left[n-1] = 1, one++;\\n        for(int i = n-2; i >= 0; i--){\\n            if(s[i] == \\'1\\'){\\n                one++;\\n                left[i] = min(one*2, min(n-i, left[i+1]+2));\\n            }\\n            else{\\n                left[i] = left[i+1];\\n            }\\n        }\\n        \\n        int mn = n;\\n        for(int i = 0; i < n-1; i++){\\n            mn = min(mn, right[i] + left[i+1]);\\n        }\\n        mn = min(mn, right[n-1]);\\n        mn = min(mn, left[0]);\\n        // cout << ans << mn;\\n        return mn;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int n = s.size();\\n        vector<int> left(n, 0), right(n, 0);\\n        int one = 0;\\n        \\n        if(s[0] == \\'0\\') right[0] = 0;\\n        else right[0] = 1, one++;\\n        for(int i = 1; i < n; i++){\\n            if(s[i] == \\'1\\'){\\n                one++;\\n                right[i] = min(one*2, min(i+1, right[i-1]+2));\\n            }\\n            else{\\n                right[i] = right[i-1];\\n            }\\n        }\\n        one = 0;\\n        if(s[n-1] == \\'0\\') left[n-1] = 0;\\n        else left[n-1] = 1, one++;\\n        for(int i = n-2; i >= 0; i--){\\n            if(s[i] == \\'1\\'){\\n                one++;\\n                left[i] = min(one*2, min(n-i, left[i+1]+2));\\n            }\\n            else{\\n                left[i] = left[i+1];\\n            }\\n        }\\n        \\n        int mn = n;\\n        for(int i = 0; i < n-1; i++){\\n            mn = min(mn, right[i] + left[i+1]);\\n        }\\n        mn = min(mn, right[n-1]);\\n        mn = min(mn, left[0]);\\n        // cout << ans << mn;\\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1749789,
                "title": "c-prefix-and-suffix",
                "content": "```\\n int minimumTime(string s) {\\n        \\n        \\n        int n=s.size();\\n        vector<int> left(n,0),right(n,0);\\n        \\n       \\n        for(int i=0;i<n;i++){\\n            \\n            if(i==0){\\n                if(s[i]==\\'1\\') left[i] = 1;\\n            }\\n            else{\\n                \\n                if(s[i]==\\'1\\'){\\n                    left[i]=min(left[i-1] + 2, i + 1);\\n                }\\n                else{\\n                    left[i]=left[i-1];\\n                }\\n            }\\n        }\\n        \\n        \\n        for(int i=n-1;i>=0;i--){\\n            \\n            if(i==n-1){\\n                if(s[n-1]==\\'1\\'){\\n                    right[n-1] = 1;\\n                }\\n               \\n            }\\n             else{  \\n                    if(s[i]==\\'1\\'){\\n                         right[i] = min(right[i+1] + 2,(n-i));\\n                    }\\n                    else{\\n                        right[i]= right[i+1];\\n                    }\\n                   \\n                }\\n        }\\n        \\n        \\n        int ans=min(left[n-1],right[0]);\\n        \\n        \\n        for(int i=0;i<n-1;i++){\\n            ans=min(ans,left[i] + right[i+1]);\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n int minimumTime(string s) {\\n        \\n        \\n        int n=s.size();\\n        vector<int> left(n,0),right(n,0);\\n        \\n       \\n        for(int i=0;i<n;i++){\\n            \\n            if(i==0){\\n                if(s[i]==\\'1\\') left[i] = 1;\\n            }\\n            else{\\n                \\n                if(s[i]==\\'1\\'){\\n                    left[i]=min(left[i-1] + 2, i + 1);\\n                }\\n                else{\\n                    left[i]=left[i-1];\\n                }\\n            }\\n        }\\n        \\n        \\n        for(int i=n-1;i>=0;i--){\\n            \\n            if(i==n-1){\\n                if(s[n-1]==\\'1\\'){\\n                    right[n-1] = 1;\\n                }\\n               \\n            }\\n             else{  \\n                    if(s[i]==\\'1\\'){\\n                         right[i] = min(right[i+1] + 2,(n-i));\\n                    }\\n                    else{\\n                        right[i]= right[i+1];\\n                    }\\n                   \\n                }\\n        }\\n        \\n        \\n        int ans=min(left[n-1],right[0]);\\n        \\n        \\n        for(int i=0;i<n-1;i++){\\n            ans=min(ans,left[i] + right[i+1]);\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1749501,
                "title": "python-faster-than-100-no-dp-comments-for-explanation",
                "content": "```\\nclass Solution:\\n  \\'\\'\\'\\n  n: size of the string\\n  one_idcs: an array of all the 1-indices\\n  front: starting index in the one_idcs array\\n  back: last index in the one_idcs array\\n  cost_left: the cost so far for traversing forward from the left side\\n  cost_right: the cost so far for traversing backward from the right side\\n  \\'\\'\\'\\n  def cost(self, n, one_idcs, front, back, cost_left, cost_right):\\n    if back < front:\\n      return cost_left + cost_right\\n    \\n    # Only one 1. Either trim all the way to this point from either side or just remove it with cost 2\\n    if front == back:\\n      return min([one_idcs[front] + 1 + cost_right, # Trim forward all the way\\n                  cost_left + n - one_idcs[front], # Trim backwards all the way\\n                  cost_left + cost_right + 2]) # Just remove this one\\n    \\n    # The cost to trim all the way to the front index from the left\\n    trim_left_front = one_idcs[front] + 1\\n    # The cost to trim all the way to the front index from the right\\n    trim_right_front = n - one_idcs[front]\\n    \\n    # The cost to trim all the way to the back index from the left\\n    trim_left_back = one_idcs[back] + 1\\n    # The cost to trim all the way to the back index from the right\\n    trim_right_back = n - one_idcs[back]\\n    \\n    return min([cost_left + trim_right_front, # Trim backwards all the way to front index\\n                cost_right + trim_left_back, # Trim forward all the the way to the last index\\n                self.cost(n, one_idcs, front + 1, back - 1,\\n                          min(trim_left_front, cost_left + 2), # Trim forward to the front or just remove\\n                          min(trim_right_back, cost_right + 2))]) # Trim backward to the back or just remove\\n    \\n  def minimumTime(self, s: str) -> int:\\n    # Collect the index of all 1s\\n    one_idcs = [i for i in range(len(s)) if s[i] == \\'1\\']\\n    return self.cost(len(s), one_idcs, 0, len(one_idcs) - 1, 0, 0)\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n  \\'\\'\\'\\n  n: size of the string\\n  one_idcs: an array of all the 1-indices\\n  front: starting index in the one_idcs array\\n  back: last index in the one_idcs array\\n  cost_left: the cost so far for traversing forward from the left side\\n  cost_right: the cost so far for traversing backward from the right side\\n  \\'\\'\\'\\n  def cost(self, n, one_idcs, front, back, cost_left, cost_right):\\n    if back < front:\\n      return cost_left + cost_right\\n    \\n    # Only one 1. Either trim all the way to this point from either side or just remove it with cost 2\\n    if front == back:\\n      return min([one_idcs[front] + 1 + cost_right, # Trim forward all the way\\n                  cost_left + n - one_idcs[front], # Trim backwards all the way\\n                  cost_left + cost_right + 2]) # Just remove this one\\n    \\n    # The cost to trim all the way to the front index from the left\\n    trim_left_front = one_idcs[front] + 1\\n    # The cost to trim all the way to the front index from the right\\n    trim_right_front = n - one_idcs[front]\\n    \\n    # The cost to trim all the way to the back index from the left\\n    trim_left_back = one_idcs[back] + 1\\n    # The cost to trim all the way to the back index from the right\\n    trim_right_back = n - one_idcs[back]\\n    \\n    return min([cost_left + trim_right_front, # Trim backwards all the way to front index\\n                cost_right + trim_left_back, # Trim forward all the the way to the last index\\n                self.cost(n, one_idcs, front + 1, back - 1,\\n                          min(trim_left_front, cost_left + 2), # Trim forward to the front or just remove\\n                          min(trim_right_back, cost_right + 2))]) # Trim backward to the back or just remove\\n    \\n  def minimumTime(self, s: str) -> int:\\n    # Collect the index of all 1s\\n    one_idcs = [i for i in range(len(s)) if s[i] == \\'1\\']\\n    return self.cost(len(s), one_idcs, 0, len(one_idcs) - 1, 0, 0)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749412,
                "title": "c-sliding-window-solution-with-detailed-comments",
                "content": "**Idea :**\\n Find the minum cost to remove all illegal goods from 0 to i for all 0<=i<=n-1 from **left to right**. Then find the minimum cost to remove all illegal goods from n-1 to i from **right to left**. Then with the help of above calculated values, find a point in the middle for which the left cost + right cost is minimum.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        // so you either start cutting every stuff from left or cut only ones. In this manner we find dp[i] for all i from 0 to n such that dp[i] indicates min cost cut all trees from 0 to i. Lets go.\\n        int n = s.size();\\n        vector<int>dp1(n);        \\n        int last = 0;\\n        for(int i=0;i<n;i++) {\\n            if(s[i] == \\'1\\') {\\n                // here is a 1. So we must cut. How do we cut ? We cut all from left (taking i+1) or cut only 1s so far (adding 2 to the last value)     \\n                dp1[i] = min(last+2,i+1);\\n                last = dp1[i];\\n            } else {\\n                // here is a 0. What do we do ? We pick the last cost\\n                dp1[i] = last;\\n            }\\n            \\n            \\n        }\\n        // now lets do the same thing in reverse\\n        vector<int> dp2(n);        \\n        last = 0;\\n        for(int i=n-1;i>=0;i--) {\\n            if(s[i] == \\'1\\') {                \\n                dp2[i] = min(last+2, n-i);\\n                last = dp2[i];\\n            } else {\\n                dp2[i] = last;\\n            }\\n            \\n        }\\n        // now we got left and right points. now all we need to find is an optimal point, where cost to cut from left to that point + cost to cut from that point to end is minimum. Let\\'s try to do that\\n        // we start making that cut from left of 0 to right of n-1. left of zero means taking all from right(dp2). right of n-1 means taking all from left (dp1)\\n        int ret = 1e9;\\n        for(int i=0;i<=n;i++) {\\n            if(i==0) {\\n                ret = min(ret, dp2[0]);\\n            } else if(i==n) {\\n                ret = min(ret, dp1[n-1]);\\n            } else {\\n                // now we are going to cut to the left of i so we pick till i-1 from dp1 and till i from dp2\\n                ret = min(ret, dp1[i-1] + dp2[i]);\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        // so you either start cutting every stuff from left or cut only ones. In this manner we find dp[i] for all i from 0 to n such that dp[i] indicates min cost cut all trees from 0 to i. Lets go.\\n        int n = s.size();\\n        vector<int>dp1(n);        \\n        int last = 0;\\n        for(int i=0;i<n;i++) {\\n            if(s[i] == \\'1\\') {\\n                // here is a 1. So we must cut. How do we cut ? We cut all from left (taking i+1) or cut only 1s so far (adding 2 to the last value)     \\n                dp1[i] = min(last+2,i+1);\\n                last = dp1[i];\\n            } else {\\n                // here is a 0. What do we do ? We pick the last cost\\n                dp1[i] = last;\\n            }\\n            \\n            \\n        }\\n        // now lets do the same thing in reverse\\n        vector<int> dp2(n);        \\n        last = 0;\\n        for(int i=n-1;i>=0;i--) {\\n            if(s[i] == \\'1\\') {                \\n                dp2[i] = min(last+2, n-i);\\n                last = dp2[i];\\n            } else {\\n                dp2[i] = last;\\n            }\\n            \\n        }\\n        // now we got left and right points. now all we need to find is an optimal point, where cost to cut from left to that point + cost to cut from that point to end is minimum. Let\\'s try to do that\\n        // we start making that cut from left of 0 to right of n-1. left of zero means taking all from right(dp2). right of n-1 means taking all from left (dp1)\\n        int ret = 1e9;\\n        for(int i=0;i<=n;i++) {\\n            if(i==0) {\\n                ret = min(ret, dp2[0]);\\n            } else if(i==n) {\\n                ret = min(ret, dp1[n-1]);\\n            } else {\\n                // now we are going to cut to the left of i so we pick till i-1 from dp1 and till i from dp2\\n                ret = min(ret, dp1[i-1] + dp2[i]);\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749347,
                "title": "easy-to-understand-prefix-and-suffix-o-n-c",
                "content": "Lets consider removing elements from just one direction + removing specific elements. The problem is simple, if at any point removing the element with cost 2 is greater than removing all the previous elements, we remove all the previous elements.\\n\\nThis should be done in both left and right directions and we take the smallest cost of removing all `1`s by combining left and right cost\\n\\n```c++\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int n = s.size();\\n        int left_count = 0,to_left = 1, left_cost = 0,\\n            right_count = 0, to_right = 1, right_cost = 0;\\n        \\n        vector<int> right(n,0), left(n,0);\\n        for(int i = 0;i < n;++i){\\n            if(s[i] == \\'1\\'){\\n                ++left_count;\\n                //if cost of removing specific element is greater than removing all elements to the left\\n                //remove all the elements to the left\\n                if(left_count*2 >= to_left){ \\n                    left_cost += to_left;\\n                    to_left = 0;\\n                    left_count = 0;\\n                }\\n            }\\n            if(s[n-i-1] == \\'1\\'){\\n                ++right_count;\\n\\t\\t\\t\\t// same idea as left\\n                if(right_count*2 >= to_right){\\n                    right_cost += to_right;\\n                    to_right = 0;\\n                    right_count = 0;\\n                }\\n            }\\n            //keep track of cost at each index\\n            //at current index cost is min cost so far + (cost of removing elements to left/right)\\n            left[i] = left_cost+min(left_count*2,to_left);\\n            right[n-i-1] = right_cost+min(right_count*2,to_right);\\n            to_left++;\\n            to_right++;\\n        }\\n        int f = right[0];\\n        for(int i = 0;i < n-1;++i){\\n            f = min(f,left[i]+right[i+1]);\\n        }\\n        f = min(f, left[n-1]);\\n        return f;\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Suffix Array"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int n = s.size();\\n        int left_count = 0,to_left = 1, left_cost = 0,\\n            right_count = 0, to_right = 1, right_cost = 0;\\n        \\n        vector<int> right(n,0), left(n,0);\\n        for(int i = 0;i < n;++i){\\n            if(s[i] == \\'1\\'){\\n                ++left_count;\\n                //if cost of removing specific element is greater than removing all elements to the left\\n                //remove all the elements to the left\\n                if(left_count*2 >= to_left){ \\n                    left_cost += to_left;\\n                    to_left = 0;\\n                    left_count = 0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1749334,
                "title": "c-dynamic-programming",
                "content": "Remove all elements (good and bad), and chill! Cost in this case is n.\\n\\nOf course we need to optimise.\\n\\nSome elements will be removed from left (cost=1, operationType=1), some will be removed from right (cost=1, operationType=2), and some have to be removed from middle (cost=2, operationType=3).\\n\\n111...1  |  0...1...1...0 | 1....1\\n\\nOnes from ends will be removed with cost 1, how to deal with this remaining middle meddlesome portion.\\n\\nWe have two choices for this middle zone -\\n1. Continue removing from either end(left/right) even when it is 0 and increase cost by 1\\n2. Remove only \\'1\\' and use cost=2\\n\\nWe\\'ll split input string into two halves - left and right. Both halves can use operationType=3. But left half can remove elements only from left end, and right half can remove elements only from right end.\\n\\nThere will exist some splitting which will give us min cost.\\n\\nExample input: \"1100101\"\\ndp_left = 1,2,2,2,4,4,6\\ndp_right = 7,5,3,3,3,1,1\\n\\nOne possible solution is to split input as 11 | 00101\\nleft_cost = 2 (remove both entries)\\nright_cost = 3 (remove last three entries)\\ntotal_cost=5\\n\\n```\\nint minimumTime(string s) {\\n        // Split input into two parts - left and right\\n        // 110010111001011100101 -> 110010111 | 001011100101\\n        // dp_left[i] stores min cost if left and middle operations are allowed for arr[0...i]\\n        // dp_right[i] stores min cost if right and middle operations are allowed for arr[i...n]\\n        // cost if we split at index i is dp_left[i] + dp_right[i+1]\\n        // We should split such that it gives us min cost\\n        int n = s.size();\\n        vector<int> dp_left(n,0), dp_right(n,0);\\n        \\n        // Compute dp_left (prefix)\\n        for( int i=0; i<n; i++ )\\n        {\\n            if( i==0 ) dp_left[i] = ( s[i] == \\'0\\' ) ? 0 : 1;\\n            else if( s[i] == \\'1\\' )\\n                dp_left[i] = min( dp_left[i-1]+2, i+1 );\\n            else dp_left[i] = dp_left[i-1];\\n        }\\n        \\n        // Compute dp_right (suffix)\\n        for( int i=n-1; i>=0; i-- )\\n        {\\n            if( i==n-1 ) dp_right[i] = ( s[i] == \\'0\\' ) ? 0 : 1;\\n            else if( s[i] == \\'1\\' )\\n                dp_right[i] = min( dp_right[i+1]+2, n-i );\\n            else dp_right[i] = dp_right[i+1];\\n        }\\n        \\n        // compute overall min cost\\n        int minCost = min( dp_left[n-1], dp_right[0] ); // all left vs all right\\n        for( int i=0; i<n-1; i++ )\\n        {\\n           minCost = min( minCost, dp_left[i]+dp_right[i+1] );\\n        }\\n        return minCost;\\n    }\\n\\t",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "Remove all elements (good and bad), and chill! Cost in this case is n.\\n\\nOf course we need to optimise.\\n\\nSome elements will be removed from left (cost=1, operationType=1), some will be removed from right (cost=1, operationType=2), and some have to be removed from middle (cost=2, operationType=3).\\n\\n111...1  |  0...1...1...0 | 1....1\\n\\nOnes from ends will be removed with cost 1, how to deal with this remaining middle meddlesome portion.\\n\\nWe have two choices for this middle zone -\\n1. Continue removing from either end(left/right) even when it is 0 and increase cost by 1\\n2. Remove only \\'1\\' and use cost=2\\n\\nWe\\'ll split input string into two halves - left and right. Both halves can use operationType=3. But left half can remove elements only from left end, and right half can remove elements only from right end.\\n\\nThere will exist some splitting which will give us min cost.\\n\\nExample input: \"1100101\"\\ndp_left = 1,2,2,2,4,4,6\\ndp_right = 7,5,3,3,3,1,1\\n\\nOne possible solution is to split input as 11 | 00101\\nleft_cost = 2 (remove both entries)\\nright_cost = 3 (remove last three entries)\\ntotal_cost=5\\n\\n```\\nint minimumTime(string s) {\\n        // Split input into two parts - left and right\\n        // 110010111001011100101 -> 110010111 | 001011100101\\n        // dp_left[i] stores min cost if left and middle operations are allowed for arr[0...i]\\n        // dp_right[i] stores min cost if right and middle operations are allowed for arr[i...n]\\n        // cost if we split at index i is dp_left[i] + dp_right[i+1]\\n        // We should split such that it gives us min cost\\n        int n = s.size();\\n        vector<int> dp_left(n,0), dp_right(n,0);\\n        \\n        // Compute dp_left (prefix)\\n        for( int i=0; i<n; i++ )\\n        {\\n            if( i==0 ) dp_left[i] = ( s[i] == \\'0\\' ) ? 0 : 1;\\n            else if( s[i] == \\'1\\' )\\n                dp_left[i] = min( dp_left[i-1]+2, i+1 );\\n            else dp_left[i] = dp_left[i-1];\\n        }\\n        \\n        // Compute dp_right (suffix)\\n        for( int i=n-1; i>=0; i-- )\\n        {\\n            if( i==n-1 ) dp_right[i] = ( s[i] == \\'0\\' ) ? 0 : 1;\\n            else if( s[i] == \\'1\\' )\\n                dp_right[i] = min( dp_right[i+1]+2, n-i );\\n            else dp_right[i] = dp_right[i+1];\\n        }\\n        \\n        // compute overall min cost\\n        int minCost = min( dp_left[n-1], dp_right[0] ); // all left vs all right\\n        for( int i=0; i<n-1; i++ )\\n        {\\n           minCost = min( minCost, dp_left[i]+dp_right[i+1] );\\n        }\\n        return minCost;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1749319,
                "title": "c-code",
                "content": "```\\ndp[0][i] =it is the cost of sequential deletion , \\ndp[1][i] = it is the minmum cost till i ,by continuous or non  continuous deletion \\n```\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int n=s.length();\\n        //dp solution \\n        vector<int>suff(n+1,0);\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            suff[i]=suff[i+1];\\n            if(s[i]==\\'1\\')suff[i]=n-i;\\n        }\\n        vector<vector<int>>dp(2,vector<int>(n+1,0));\\n        int res=INT32_MAX;\\n        for(int i=1;i<=n;i++)\\n        {\\n            dp[0][i]=dp[0][i-1]+1;\\n            dp[1][i]=min(dp[0][i-1],dp[1][i-1])+((s[i-1]-\\'0\\')*2);\\n            res=min(res,min(dp[1][i],dp[0][i])+suff[i]);\\n        }\\n        return res;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\ndp[0][i] =it is the cost of sequential deletion , \\ndp[1][i] = it is the minmum cost till i ,by continuous or non  continuous deletion \\n```\n```\\n\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int n=s.length();\\n        //dp solution \\n        vector<int>suff(n+1,0);\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            suff[i]=suff[i+1];\\n            if(s[i]==\\'1\\')suff[i]=n-i;\\n        }\\n        vector<vector<int>>dp(2,vector<int>(n+1,0));\\n        int res=INT32_MAX;\\n        for(int i=1;i<=n;i++)\\n        {\\n            dp[0][i]=dp[0][i-1]+1;\\n            dp[1][i]=min(dp[0][i-1],dp[1][i-1])+((s[i-1]-\\'0\\')*2);\\n            res=min(res,min(dp[1][i],dp[0][i])+suff[i]);\\n        }\\n        return res;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749190,
                "title": "o-n-python-greedy-dp",
                "content": "We dp the problem then found there are three situations:\\n#dp[i] is the lowest cost of handling s[0:i+1]\\n1. when s[i] = \\'1\\', dp[i] = dp[i-1] +1\\n2. when s[i] = \\'0\\', if we decide to remove it, dp[i] = dp[i-1] +1\\n3. when s[i] = \\'0\\', if we decide not to remove it, then we only remove from the left. Under this constrain, we could treat this as a greedy.\\n\\n\\n```\\nclass Solution:\\n    def minimumTime(self, s: str) -> int:\\n        n = len(s)\\n        res = [0] * n\\n        if s[0] == \\'1\\': res[0] = 1\\n        \\n        #greedy: \\n        #cost[i] = the lowest cost of s[0:i+2] when s[i+1] is a 0 that we keep\\n        cost, cnt, cur = [0] * (n - 1), [0, 0], 0\\n        for i in range(len(cost)):\\n            value = int(s[i])\\n            if value == 0:\\n                cnt[value] += 1\\n            elif cnt[0] == 0:\\n                cur += 1\\n            else:\\n                cnt[value] += 1\\n                cur += 2\\n                if cnt[0] == cnt[1]: cnt = [0, 0]\\n            cost[i] = cur\\n        #dp:\\n        #res[i] = the lowest cost of s[0:i+1]\\n        for i in range(1, n):\\n            if s[i] == \\'1\\':\\n                res[i] = 1 + res[i - 1]\\n            else:\\n                res[i] = min(1 + res[i - 1], cost[i - 1]) #min(remove this 0, keep this 0)\\n            \\n        return res[n - 1]\\n        \\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, s: str) -> int:\\n        n = len(s)\\n        res = [0] * n\\n        if s[0] == \\'1\\': res[0] = 1\\n        \\n        #greedy: \\n        #cost[i] = the lowest cost of s[0:i+2] when s[i+1] is a 0 that we keep\\n        cost, cnt, cur = [0] * (n - 1), [0, 0], 0\\n        for i in range(len(cost)):\\n            value = int(s[i])\\n            if value == 0:\\n                cnt[value] += 1\\n            elif cnt[0] == 0:\\n                cur += 1\\n            else:\\n                cnt[value] += 1\\n                cur += 2\\n                if cnt[0] == cnt[1]: cnt = [0, 0]\\n            cost[i] = cur\\n        #dp:\\n        #res[i] = the lowest cost of s[0:i+1]\\n        for i in range(1, n):\\n            if s[i] == \\'1\\':\\n                res[i] = 1 + res[i - 1]\\n            else:\\n                res[i] = min(1 + res[i - 1], cost[i - 1]) #min(remove this 0, keep this 0)\\n            \\n        return res[n - 1]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749160,
                "title": "c-prefix-suffix",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumTime(string str) {\\n        \\n        #define ll long long\\n        \\n        int n = str.length();\\n        \\n        if(n == 1){\\n            return (int)(str[0] == \\'1\\');\\n        }\\n        \\n        ll prefix[3*100000]{0}, suffix[3*100000]{0};\\n        \\n        for(int i=0;i<n;++i){\\n            if(!i){\\n                prefix[i] = (str[i] == \\'1\\');\\n                continue;\\n            }\\n            prefix[i] = ((str[i] == \\'1\\') ? min((ll)i+1,prefix[i-1]+2) : prefix[i-1]);\\n        }\\n        \\n        for(int i=n-1;i>=0;--i){\\n            if(i==n-1){\\n                suffix[i] = (str[i] == \\'1\\');\\n                continue;\\n            }\\n            suffix[i] = (str[i] == \\'1\\' ? min((ll)n-i,suffix[i+1]+2) : suffix[i+1]);\\n        }\\n        \\n        int ans = INT_MAX;\\n        \\n        for(int i=0;i+1<n;++i){\\n            ans = min((ll)ans,prefix[i]+suffix[i+1]);\\n        }\\n        \\n        return min(ans,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(string str) {\\n        \\n        #define ll long long\\n        \\n        int n = str.length();\\n        \\n        if(n == 1){\\n            return (int)(str[0] == \\'1\\');\\n        }\\n        \\n        ll prefix[3*100000]{0}, suffix[3*100000]{0};\\n        \\n        for(int i=0;i<n;++i){\\n            if(!i){\\n                prefix[i] = (str[i] == \\'1\\');\\n                continue;\\n            }\\n            prefix[i] = ((str[i] == \\'1\\') ? min((ll)i+1,prefix[i-1]+2) : prefix[i-1]);\\n        }\\n        \\n        for(int i=n-1;i>=0;--i){\\n            if(i==n-1){\\n                suffix[i] = (str[i] == \\'1\\');\\n                continue;\\n            }\\n            suffix[i] = (str[i] == \\'1\\' ? min((ll)n-i,suffix[i+1]+2) : suffix[i+1]);\\n        }\\n        \\n        int ans = INT_MAX;\\n        \\n        for(int i=0;i+1<n;++i){\\n            ans = min((ll)ans,prefix[i]+suffix[i+1]);\\n        }\\n        \\n        return min(ans,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749036,
                "title": "c-9-liners-o-n-solution-with-explanation",
                "content": "Idea:\\n1. starts from left and right respectively, and record the minimum number of moves possible (eg.d1 and d2)\\n2. get the minimum d1[i]+d2[i+1] for all possible i\\n3. dp[i]=min(dp[i-1]+2,i+1)\\n->dp[i-1]+2 for removing illegal good from middle (cost=2)\\n->i+1 for removing all the left illegal goods\\n```\\nint minimumTime(string s) \\n{\\n\\tint result=INT_MAX,n=s.length(),d1[n],d2[n];\\n\\tfor(int i=0;i<n;i++) d1[i]=INT_MAX,d2[i]=INT_MAX; // d1 for 0 to n-1, d2 for n-1 to 0\\n\\n\\tfor(int i=0;i<n;i++)\\n\\t{\\n\\t\\tif(s[i]==\\'0\\') d1[i]=i==0?0:d1[i-1]; // cost doesn\\'t change\\n\\t\\telse d1[i]=i==0?1:min(d1[i-1]+2,i+1); // the smaller cost for 2 types of moves\\n\\n\\t\\tif(s[n-i-1]==\\'0\\') d2[n-i-1]=i==0?0:d2[n-i]; // cost doesn\\'t change\\n\\t\\telse d2[n-i-1]=i==0?1:min(d2[n-i]+2,i+1); // the smaller cost for 2 types of moves\\n\\t}\\n\\n\\tfor(int i=0;i<n-1;i++) result=min(result,d1[i]+d2[i+1]); // minimum costs if we start from both ends\\n\\n\\treturn result==INT_MAX?s[0]-\\'0\\':result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint minimumTime(string s) \\n{\\n\\tint result=INT_MAX,n=s.length(),d1[n],d2[n];\\n\\tfor(int i=0;i<n;i++) d1[i]=INT_MAX,d2[i]=INT_MAX; // d1 for 0 to n-1, d2 for n-1 to 0\\n\\n\\tfor(int i=0;i<n;i++)\\n\\t{\\n\\t\\tif(s[i]==\\'0\\') d1[i]=i==0?0:d1[i-1]; // cost doesn\\'t change\\n\\t\\telse d1[i]=i==0?1:min(d1[i-1]+2,i+1); // the smaller cost for 2 types of moves\\n\\n\\t\\tif(s[n-i-1]==\\'0\\') d2[n-i-1]=i==0?0:d2[n-i]; // cost doesn\\'t change\\n\\t\\telse d2[n-i-1]=i==0?1:min(d2[n-i]+2,i+1); // the smaller cost for 2 types of moves\\n\\t}\\n\\n\\tfor(int i=0;i<n-1;i++) result=min(result,d1[i]+d2[i+1]); // minimum costs if we start from both ends\\n\\n\\treturn result==INT_MAX?s[0]-\\'0\\':result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1748942,
                "title": "kotlin-one-line-o-n-dp-please-don-t-write-code-like-that",
                "content": "Same idea as [here](https://leetcode.com/problems/minimum-time-to-remove-all-cars-containing-illegal-goods/discuss/1748704/JavaC%2B%2BPython-Short-One-Pass-O(1)-Space), but in functional style in Kotlin and in one line. On each iteration we calculate the next state, which is minimum cost of everything left of `i`, cost of sequentially removing everything right of `i` and current minimum cost, which in worst case is `s.length` since we can just sequentially pull all the cars:\\n\\n```\\nclass Solution {\\n    fun minimumTime(s: String): Int = s.foldIndexed(Triple(0, s.length, s.length)) { i, (left, rightSeq, max), car -> ((left + (car - \\'0\\') * 2) to (rightSeq - 1)).let { (l, r) -> Triple(Math.min(i + 1, l), r, Math.min(max, l + r)) } }.third\\n}\\n```\\n\\nNow that the flexing is done, here\\'s a more readable version that won\\'t encourage your colleagues to downvote your pull request:\\n\\n```\\nclass Solution {\\n    fun minimumTime(s: String): Int {\\n        val initialState = Triple(0, s.length, s.length)\\n        val (_, _, result) = s.foldIndexed(initialState) { i, (prevLeft, prevRightSeq, max), car ->\\n            val left = prevLeft + (car - \\'0\\') * 2\\n            val rightSeq = prevRightSeq - 1\\n            Triple(Math.min(i + 1, left), rightSeq, Math.min(max, left + rightSeq))\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    fun minimumTime(s: String): Int = s.foldIndexed(Triple(0, s.length, s.length)) { i, (left, rightSeq, max), car -> ((left + (car - \\'0\\') * 2) to (rightSeq - 1)).let { (l, r) -> Triple(Math.min(i + 1, l), r, Math.min(max, l + r)) } }.third\\n}\\n```\n```\\nclass Solution {\\n    fun minimumTime(s: String): Int {\\n        val initialState = Triple(0, s.length, s.length)\\n        val (_, _, result) = s.foldIndexed(initialState) { i, (prevLeft, prevRightSeq, max), car ->\\n            val left = prevLeft + (car - \\'0\\') * 2\\n            val rightSeq = prevRightSeq - 1\\n            Triple(Math.min(i + 1, left), rightSeq, Math.min(max, left + rightSeq))\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748859,
                "title": "python-3-use-accumulate-with-sum-and-min",
                "content": "\\n```\\n    def minimumTime(self, s: str) -> int:\\n        lS = len(s)\\n        n1 = s.count(\\'1\\')\\n        listC = [ int(c) for c in list(s) ]\\n        listL = list(accumulate([0] + listC))\\n        listR = list(accumulate([0] + listC[::-1]))        \\n        \\n        listLL = [ (-listL[i])*2 + i for i in range(len(listL)) ]   # change in total time if moving i times from the left end\\n        listRR = [ (-listR[i])*2 + i for i in range(len(listL)) ]   # change in total time if moving i times from the right end\\n        listLLL = list(accumulate(listLL, min))\\n        listRRR = list(accumulate(listRR, min))\\n        return 2*n1 + min( listLLL[i] + listRRR[lS-i] for i in range(lS+1) )\\n```",
                "solutionTags": [],
                "code": "```\\n    def minimumTime(self, s: str) -> int:\\n        lS = len(s)\\n        n1 = s.count(\\'1\\')\\n        listC = [ int(c) for c in list(s) ]\\n        listL = list(accumulate([0] + listC))\\n        listR = list(accumulate([0] + listC[::-1]))        \\n        \\n        listLL = [ (-listL[i])*2 + i for i in range(len(listL)) ]   # change in total time if moving i times from the left end\\n        listRR = [ (-listR[i])*2 + i for i in range(len(listL)) ]   # change in total time if moving i times from the right end\\n        listLLL = list(accumulate(listLL, min))\\n        listRRR = list(accumulate(listRR, min))\\n        return 2*n1 + min( listLLL[i] + listRRR[lS-i] for i in range(lS+1) )\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1748853,
                "title": "c-dynamic-programming-o-n-easy-to-understand",
                "content": "**Explaination**\\nfor every index we have two possiblities, remove it with operation [1 - 2] or operation 3.\\nhere, we will build ```left``` and ```right``` array, where\\n* left[i] contains min time to remove indx ```i``` from 0 to i using left removal or anywhere \\n* right[i] contains min time to remove ```i``` from n-1 to i using right removal or anywhere \\n\\nfirstly, build an array ```nums``` which contains all index where s[i]==1\\nFor `left`( left.size() == nums.size() ), there are 2 possibilities\\n1. remove the index ```nums[i]``` from 0 to i using left operation, total time will ```nums[i]+1```\\n1. remove the index ```i``` from 0 to i using  removal from anywhere  , total time will``` 2 + left[i-1]```, that is min time to remove last index + 2\\n`left[i]` will be minimum of above two .\\n\\n For `right`( right.size() == nums.size()) traversing from last, there are 2 possibilitis\\n1. remove the index ```nums[i]``` from n to i using right operation, total time will ```n-nums[i]``` where n = s.size().\\n1. remove the index ```i``` from n to i using  removal from anywhere  , total time will``` 2 + right[i+1]```, that is min time to remove last index + 2\\n`right[i]` will be minimum of above two .\\n\\nAt last, find the min of `left[i-1] + right[i] ` for  0<=i<=n (take care of boundary cases)\\n\\n**Complexity**\\nTime O(n),  Space O(n)\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        if(s.size()==1){\\n            if(s[0]==\\'1\\') return 1;\\n            else return 0;\\n        }\\n        int re = INT_MAX,n=s.size();\\n        \\n        vector<int> nums; \\n        for(int i = 0; i<s.size();++i) if(s[i]==\\'1\\') nums.push_back(i);\\n        if(nums.size()==0) return 0;\\n        \\n        vector<int> left(nums.size(),INT_MAX),right(nums.size(),INT_MAX);\\n        left[0] = min(2,nums[0]+1);\\n        for(int i = 1; i<nums.size();++i) \\n            left[i] = min(left[i-1]+2,nums[i]+1);\\n        \\n        right[nums.size()-1] = min(n-nums[nums.size()-1],2);\\n        for(int i = nums.size()-2; i>=0;--i)\\n            right[i] = min(right[i+1]+2,n-nums[i]);\\n        \\n        re = min(right[0],left[left.size()-1]);\\n        for(int i = 1; i<nums.size();++i) re = min(left[i-1]+right[i],re);\\n        \\n        return re;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```left```\n```right```\n```i```\n```i```\n```nums```\n```nums[i]```\n```nums[i]+1```\n```i```\n``` 2 + left[i-1]```\n```nums[i]```\n```n-nums[i]```\n```i```\n``` 2 + right[i+1]```\n```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        if(s.size()==1){\\n            if(s[0]==\\'1\\') return 1;\\n            else return 0;\\n        }\\n        int re = INT_MAX,n=s.size();\\n        \\n        vector<int> nums; \\n        for(int i = 0; i<s.size();++i) if(s[i]==\\'1\\') nums.push_back(i);\\n        if(nums.size()==0) return 0;\\n        \\n        vector<int> left(nums.size(),INT_MAX),right(nums.size(),INT_MAX);\\n        left[0] = min(2,nums[0]+1);\\n        for(int i = 1; i<nums.size();++i) \\n            left[i] = min(left[i-1]+2,nums[i]+1);\\n        \\n        right[nums.size()-1] = min(n-nums[nums.size()-1],2);\\n        for(int i = nums.size()-2; i>=0;--i)\\n            right[i] = min(right[i+1]+2,n-nums[i]);\\n        \\n        re = min(right[0],left[left.size()-1]);\\n        for(int i = 1; i<nums.size();++i) re = min(left[i-1]+right[i],re);\\n        \\n        return re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748836,
                "title": "left-and-right-arrays-somewhat-simular-to-leetcode-problem-238-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int n = s.size();\\n        if(n == 1)  return s[0]==\\'1\\'?1:0;\\n        vector<int> left(n, 0);\\n        vector<int> right(n, 0);\\n        \\n        left[0] = s[0] == \\'1\\' ? 1 : 0;\\n        for(int i=1; i<n; ++i){\\n            left[i] = s[i] == \\'1\\' ? min(left[i-1]+2, i+1) : left[i-1];\\n        }\\n        right[n-1] = s[n-1] == \\'1\\' ? 1 : 0;\\n        for(int i=n-2; i>=0; --i){\\n            right[i] = s[i] == \\'1\\' ? min(right[i+1]+2, n-i) : right[i+1];\\n        }\\n        int ret = INT_MAX;\\n        for(int i=0; i<n-1; ++i){\\n            ret = min(ret, left[i] + right[i+1]);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int n = s.size();\\n        if(n == 1)  return s[0]==\\'1\\'?1:0;\\n        vector<int> left(n, 0);\\n        vector<int> right(n, 0);\\n        \\n        left[0] = s[0] == \\'1\\' ? 1 : 0;\\n        for(int i=1; i<n; ++i){\\n            left[i] = s[i] == \\'1\\' ? min(left[i-1]+2, i+1) : left[i-1];\\n        }\\n        right[n-1] = s[n-1] == \\'1\\' ? 1 : 0;\\n        for(int i=n-2; i>=0; --i){\\n            right[i] = s[i] == \\'1\\' ? min(right[i+1]+2, n-i) : right[i+1];\\n        }\\n        int ret = INT_MAX;\\n        for(int i=0; i<n-1; ++i){\\n            ret = min(ret, left[i] + right[i+1]);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748818,
                "title": "c-from-o-n-2-to-o-n",
                "content": "A brute-force-ish O(n^2) solution would be to find for every segment, how much it costs to remove every \"illegal\" item with a cost of 2, and remove the items outsidde the window from either sides. The optimal configuration is guaranteed to exist in this form. \\n\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        std::vector<int> prefix_sum(s.size() + 1, 0);\\n        int min_cost = s.size();\\n        const int len = s.size();\\n        for (int i = 0; i < s.size(); ++i) {\\n            prefix_sum[i + 1] = (s[i] == \\'1\\') + prefix_sum[i];\\n            const int suffix_len = len - i - 1;\\n            for (int j = 0; j <= i; ++j) {\\n                const int cost = j + suffix_len + (prefix_sum[i + 1] - prefix_sum[j]) * 2;\\n                min_cost = std::min(cost, min_cost);\\n            }\\n        }\\n        return min_cost;\\n    }\\n};\\n```\\n\\nWe may further observe that the inner loop can be optimized by only retaining the maximum of a slightly changed value that involes the length of a prefix and the associated prefix sum.  \\n\\n```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        const int len = s.size();        \\n        int min_cost = len;        \\n        std::optional<int> max_excess;\\n        std::vector<int> prefix_sum(s.size() + 1, 0);        \\n        for (int i = 0; i < s.size(); ++i) {\\n            prefix_sum[i + 1] = (s[i] == \\'1\\') + prefix_sum[i];\\n            const int suffix_len = len - i - 1;\\n            const int base_cost = suffix_len + 2 * prefix_sum[i + 1];\\n            \\n            const int cost = base_cost - max_excess.value_or(0);\\n            const int excess = 2 * prefix_sum[i + 1] - (i + 1);\\n            max_excess = std::max(excess, max_excess.value_or(0));\\n            \\n            min_cost = std::min(cost, min_cost);\\n        }\\n        return min_cost;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        std::vector<int> prefix_sum(s.size() + 1, 0);\\n        int min_cost = s.size();\\n        const int len = s.size();\\n        for (int i = 0; i < s.size(); ++i) {\\n            prefix_sum[i + 1] = (s[i] == \\'1\\') + prefix_sum[i];\\n            const int suffix_len = len - i - 1;\\n            for (int j = 0; j <= i; ++j) {\\n                const int cost = j + suffix_len + (prefix_sum[i + 1] - prefix_sum[j]) * 2;\\n                min_cost = std::min(cost, min_cost);\\n            }\\n        }\\n        return min_cost;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        const int len = s.size();        \\n        int min_cost = len;        \\n        std::optional<int> max_excess;\\n        std::vector<int> prefix_sum(s.size() + 1, 0);        \\n        for (int i = 0; i < s.size(); ++i) {\\n            prefix_sum[i + 1] = (s[i] == \\'1\\') + prefix_sum[i];\\n            const int suffix_len = len - i - 1;\\n            const int base_cost = suffix_len + 2 * prefix_sum[i + 1];\\n            \\n            const int cost = base_cost - max_excess.value_or(0);\\n            const int excess = 2 * prefix_sum[i + 1] - (i + 1);\\n            max_excess = std::max(excess, max_excess.value_or(0));\\n            \\n            min_cost = std::min(cost, min_cost);\\n        }\\n        return min_cost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748795,
                "title": "python-dp",
                "content": "```\\ndef solution:\\n\\tdef minimalTime(self, s: str) -> int:\\n\\t\\tn = len(s)\\n\\t\\trtol = [0] * (n + 1)\\n\\t\\tfor i in range(n - 1, -1, -1):\\n\\t\\t\\trtol[i] = rtol[i + 1] if s[i] == \\'0\\' else min(rtol[i + 1] + 2, n - i)\\n\\t\\tans = rtol[0]\\n\\t\\tltor = 0\\n\\t\\tfor i, c in enumerate(s):\\n\\t\\t\\tif c == \\'1\\':\\n\\t\\t\\t\\tltor = min(ltor + 2, i + 1)\\n\\t\\t\\t\\tans = min(ans, ltor + rtol[i + 1])\\n\\t\\treturn ans\\n```\\no(n) time\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\ndef solution:\\n\\tdef minimalTime(self, s: str) -> int:\\n\\t\\tn = len(s)\\n\\t\\trtol = [0] * (n + 1)\\n\\t\\tfor i in range(n - 1, -1, -1):\\n\\t\\t\\trtol[i] = rtol[i + 1] if s[i] == \\'0\\' else min(rtol[i + 1] + 2, n - i)\\n\\t\\tans = rtol[0]\\n\\t\\tltor = 0\\n\\t\\tfor i, c in enumerate(s):\\n\\t\\t\\tif c == \\'1\\':\\n\\t\\t\\t\\tltor = min(ltor + 2, i + 1)\\n\\t\\t\\t\\tans = min(ans, ltor + rtol[i + 1])\\n\\t\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1748690,
                "title": "java-prefix-sum-explanation-o-n-simple-to-understand-in-depth-explanation",
                "content": "Intuition: string can be split into three parts, \\n\\t- illegal goods collected from left end\\n\\t- illegal goods collected from right end\\n\\t- illegal goods collected from anywhere\\n\\nUse prefix sum to get sum of values through a range.\\nFor example, to get sum of \"1\" from i to j.\\nNumber of \"1\" from i to j \\n= Prefix[from i to j] \\n= Prefix[j] - Prefix[i - 1]\\n\\n```\\nclass Solution {\\n    public int minimumTime(String s) {\\n        int n = s.length();\\n\\n        // dp[i] stores number of \"1\"(illegal goods) up to i\\n        int[] dp = new int[n];\\n        dp[0] = s.charAt(0) == \\'1\\' ? 1 : 0;\\n        for (int i = 1; i < n; i++) {\\n            dp[i] = dp[i-1];\\n            if (s.charAt(i) == \\'1\\') {\\n                dp[i]++;\\n            }\\n        }\\n        /*\\n            Split array into three parts : [left / mid / right]\\n            left represent illgal goods collected from left end\\n            right represents illegal goods collected from right end\\n            \\n            time taken = left + right + mid * 2\\n            i represents the border between mid and right\\n            prev represents the border between mid and left    \\n            \\n            loop invariant: prev represents optimal point to stop collecting from left end(inclusive).\\n        */\\n        int min = Integer.MAX_VALUE;\\n        int prev = -1;\\n        for (int i = 0; i < n; i++) {\\n            /*\\n                Check if collecting from left end up to i \\n                takes less time than collecting from \\n                left end up to prev and collecting from middle.\\n                \\n                If so, update prev to i.\\n            */\\n            int midOnes = prev == -1 ? dp[i] : dp[i] - dp[prev];\\n            if (prev + 1 + midOnes * 2 > i + 1) {\\n                prev = i;\\n            }\\n            \\n            // Calculate time taken according to equation above\\n            int timeTaken = prev + 1; // left\\n            int val = prev == -1 ? 0 : dp[prev];\\n            timeTaken += (dp[i] - val) * 2; // mid\\n            timeTaken += (n - i - 1); // right\\n            min = Math.min(min, timeTaken);\\n        }\\n\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumTime(String s) {\\n        int n = s.length();\\n\\n        // dp[i] stores number of \"1\"(illegal goods) up to i\\n        int[] dp = new int[n];\\n        dp[0] = s.charAt(0) == \\'1\\' ? 1 : 0;\\n        for (int i = 1; i < n; i++) {\\n            dp[i] = dp[i-1];\\n            if (s.charAt(i) == \\'1\\') {\\n                dp[i]++;\\n            }\\n        }\\n        /*\\n            Split array into three parts : [left / mid / right]\\n            left represent illgal goods collected from left end\\n            right represents illegal goods collected from right end\\n            \\n            time taken = left + right + mid * 2\\n            i represents the border between mid and right\\n            prev represents the border between mid and left    \\n            \\n            loop invariant: prev represents optimal point to stop collecting from left end(inclusive).\\n        */\\n        int min = Integer.MAX_VALUE;\\n        int prev = -1;\\n        for (int i = 0; i < n; i++) {\\n            /*\\n                Check if collecting from left end up to i \\n                takes less time than collecting from \\n                left end up to prev and collecting from middle.\\n                \\n                If so, update prev to i.\\n            */\\n            int midOnes = prev == -1 ? dp[i] : dp[i] - dp[prev];\\n            if (prev + 1 + midOnes * 2 > i + 1) {\\n                prev = i;\\n            }\\n            \\n            // Calculate time taken according to equation above\\n            int timeTaken = prev + 1; // left\\n            int val = prev == -1 ? 0 : dp[prev];\\n            timeTaken += (dp[i] - val) * 2; // mid\\n            timeTaken += (n - i - 1); // right\\n            min = Math.min(min, timeTaken);\\n        }\\n\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748686,
                "title": "c-o-1-space-one-pass",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int N = s.length();\\n        int leftbest = 0;\\n        int best = N;\\n        for (int i = 0; i<=N;i++){\\n            best = min(best, leftbest + N-i);\\n            if (i<N && s[i] == \\'1\\') leftbest = min(leftbest+2, i+1);\\n        }\\n        return best;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int N = s.length();\\n        int leftbest = 0;\\n        int best = N;\\n        for (int i = 0; i<=N;i++){\\n            best = min(best, leftbest + N-i);\\n            if (i<N && s[i] == \\'1\\') leftbest = min(leftbest+2, i+1);\\n        }\\n        return best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748681,
                "title": "no-dp-tc-o-n-sc-o-1-faster-than-100",
                "content": "First, finding minimum among removing from left end and mid,\\nThen finding minimum among the  first min and removing from end.\\n\\n```\\nint ans = s.size(); // default case if all 1\\'s\\n\\nint first_min = 0;\\n\\nfor(int i = 0; i < s.size(); i++)\\n{\\n\\tif (s[i] == \\'1\\')\\n\\t\\tfirst_min = min(i+1, first_min+2);\\n\\n\\tans = min(ans, (int)(first_min + s.size() - (i+1)));\\n}\\n\\nreturn ans;\\n```\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint ans = s.size(); // default case if all 1\\'s\\n\\nint first_min = 0;\\n\\nfor(int i = 0; i < s.size(); i++)\\n{\\n\\tif (s[i] == \\'1\\')\\n\\t\\tfirst_min = min(i+1, first_min+2);\\n\\n\\tans = min(ans, (int)(first_min + s.size() - (i+1)));\\n}\\n\\nreturn ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1748668,
                "title": "c",
                "content": "if we fix both the left and right end, ans = len(left) + number of 1 between(left and right) + len(right)\\nIf we fix left size, ans = len(left) + min( number of 1 between(left and right) + len(right))\\nc total number of 1s, \\na, number of 1s in left\\nc -a, number of 1s to exclude the left\\nans = len(left) + min( 2*((c - a ) - s[r]) + len(r) )\\nans = len(left) +2*((c - a ) +  min(  len(r) - s[r]);\\n\\nthen all we need to store is min(  len(r) - s[r]).\\n\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int minimumTime(string s) {\\n        n = s.size();\\n        // vector<int> r(n, 0);\\n        vector<int> b(n, 0);\\n        int c = 0;\\n        int curmin = INT_MAX;\\n        for (int i = n - 1; i >= 0; i--)\\n        {\\n            c += s[i] == \\'1\\' ? 1 : 0;\\n            curmin = min(curmin, n - i - 2 * c);\\n            b[i] = curmin;\\n        }\\n        int ans = c * 2;\\n        int a = 0;\\n        ans = min(ans, c*2 + b[0]);\\n        for (int i = 0; i < n; i++)\\n        {\\n            a += s[i] == \\'1\\' ? 1 : 0;\\n            int a1 = i + 1 + (c - a) * 2;\\n            int a2 = (i + 1 < n) ? b[i + 1] + (c -a) * 2 + i + 1 : INT_MAX;\\n            ans = min(ans, a1);\\n            ans = min(ans, a2);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int minimumTime(string s) {\\n        n = s.size();\\n        // vector<int> r(n, 0);\\n        vector<int> b(n, 0);\\n        int c = 0;\\n        int curmin = INT_MAX;\\n        for (int i = n - 1; i >= 0; i--)\\n        {\\n            c += s[i] == \\'1\\' ? 1 : 0;\\n            curmin = min(curmin, n - i - 2 * c);\\n            b[i] = curmin;\\n        }\\n        int ans = c * 2;\\n        int a = 0;\\n        ans = min(ans, c*2 + b[0]);\\n        for (int i = 0; i < n; i++)\\n        {\\n            a += s[i] == \\'1\\' ? 1 : 0;\\n            int a1 = i + 1 + (c - a) * 2;\\n            int a2 = (i + 1 < n) ? b[i + 1] + (c -a) * 2 + i + 1 : INT_MAX;\\n            ans = min(ans, a1);\\n            ans = min(ans, a2);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748641,
                "title": "java-dp-o-n",
                "content": "```\\nclass Solution {\\n    public int minimumTime(String s) {\\n        List<List<Integer>> list = compressInput(s);\\n        //System.out.println(list);\\n        \\n        int len = list.size();\\n        \\n        int[] leTr = new int[len+1];\\n        int[] leNo = new int[len+1];        \\n        int zCnt = 0;\\n        for(int i=0;i<len;i++){\\n            List<Integer> cur = list.get(i);\\n            if(cur.get(0)==1){\\n                leTr[i+1] = leTr[i]+zCnt+cur.get(1);\\n                leNo[i+1] = leNo[i]+cur.get(1)*2;\\n                zCnt = 0;\\n            }else{\\n                leTr[i+1] = leTr[i];\\n                zCnt += cur.get(1);\\n                leNo[i+1] = Math.min(leTr[i],leNo[i]);\\n            }\\n        }\\n       // System.out.println(Arrays.toString(leTr));\\n       // System.out.println(Arrays.toString(leNo));\\n\\n        int[] riTr = new int[len+1];\\n        int[] riNo = new int[len+1];        \\n        zCnt = 0;\\n        for(int i=len-1;i>=0;i--){\\n            List<Integer> cur = list.get(i);\\n            if(cur.get(0)==1){\\n                riTr[i] = riTr[i+1]+zCnt+cur.get(1);\\n                riNo[i] = riNo[i+1]+cur.get(1)*2;\\n                zCnt = 0;\\n            }else{\\n                riTr[i] = riTr[i+1];\\n                zCnt+=cur.get(1);\\n                riNo[i] = Math.min(riTr[i+1],riNo[i+1]);\\n            }\\n        }\\n       // System.out.println(Arrays.toString(riTr));\\n      // System.out.println(Arrays.toString(riNo));\\n\\n        int minTime = Integer.MAX_VALUE;\\n        for(int i=0;i<=len;i++){\\n            minTime = Math.min(minTime,Math.min(leTr[i],leNo[i])+Math.min(riTr[i],riNo[i]));\\n        }\\n        \\n        return minTime;\\n    }\\n    private List<List<Integer>> compressInput(String s){\\n        List<List<Integer>> list = new ArrayList<>();\\n        char prev = \\'.\\';\\n        int cnt=0;\\n        for(char ch:s.toCharArray()){\\n            if(\\'.\\'==prev){\\n                prev = ch;\\n                cnt = 1;\\n            }else{\\n                if(prev == ch){\\n                    cnt++;\\n                }else{\\n                    list.add(Arrays.asList(prev-\\'0\\',cnt));\\n                    cnt = 1;\\n                    prev = ch;\\n                }\\n                \\n            }\\n        }\\n        list.add(Arrays.asList(prev-\\'0\\',cnt));\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumTime(String s) {\\n        List<List<Integer>> list = compressInput(s);\\n        //System.out.println(list);\\n        \\n        int len = list.size();\\n        \\n        int[] leTr = new int[len+1];\\n        int[] leNo = new int[len+1];        \\n        int zCnt = 0;\\n        for(int i=0;i<len;i++){\\n            List<Integer> cur = list.get(i);\\n            if(cur.get(0)==1){\\n                leTr[i+1] = leTr[i]+zCnt+cur.get(1);\\n                leNo[i+1] = leNo[i]+cur.get(1)*2;\\n                zCnt = 0;\\n            }else{\\n                leTr[i+1] = leTr[i];\\n                zCnt += cur.get(1);\\n                leNo[i+1] = Math.min(leTr[i],leNo[i]);\\n            }\\n        }\\n       // System.out.println(Arrays.toString(leTr));\\n       // System.out.println(Arrays.toString(leNo));\\n\\n        int[] riTr = new int[len+1];\\n        int[] riNo = new int[len+1];        \\n        zCnt = 0;\\n        for(int i=len-1;i>=0;i--){\\n            List<Integer> cur = list.get(i);\\n            if(cur.get(0)==1){\\n                riTr[i] = riTr[i+1]+zCnt+cur.get(1);\\n                riNo[i] = riNo[i+1]+cur.get(1)*2;\\n                zCnt = 0;\\n            }else{\\n                riTr[i] = riTr[i+1];\\n                zCnt+=cur.get(1);\\n                riNo[i] = Math.min(riTr[i+1],riNo[i+1]);\\n            }\\n        }\\n       // System.out.println(Arrays.toString(riTr));\\n      // System.out.println(Arrays.toString(riNo));\\n\\n        int minTime = Integer.MAX_VALUE;\\n        for(int i=0;i<=len;i++){\\n            minTime = Math.min(minTime,Math.min(leTr[i],leNo[i])+Math.min(riTr[i],riNo[i]));\\n        }\\n        \\n        return minTime;\\n    }\\n    private List<List<Integer>> compressInput(String s){\\n        List<List<Integer>> list = new ArrayList<>();\\n        char prev = \\'.\\';\\n        int cnt=0;\\n        for(char ch:s.toCharArray()){\\n            if(\\'.\\'==prev){\\n                prev = ch;\\n                cnt = 1;\\n            }else{\\n                if(prev == ch){\\n                    cnt++;\\n                }else{\\n                    list.add(Arrays.asList(prev-\\'0\\',cnt));\\n                    cnt = 1;\\n                    prev = ch;\\n                }\\n                \\n            }\\n        }\\n        list.add(Arrays.asList(prev-\\'0\\',cnt));\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748632,
                "title": "calculate-optimal-work-from-left-and-right-detailed-explanation",
                "content": "Let\\'s imagine a left inspector which walks toward the right and a right inspector that walks towards the left. Consider how much work it takes each inspector to inspect every car for each index.\\n\\nFor example for `s = \"1100101\"`\\n\\n`leftInspector = [1,2,2,2,4,4,6]`\\n`rightInspector = [7,5,3,3,3,1,1]`\\n\\nOnce we have those arrays built, the problem is simple! Just find the `min(leftInspector[i] + rightInspector[i + 1])`. In this case the best indices are 1 and 2 yielding the correct answer of 5.\\n\\nNow for the tricky part - The actual implementation. We will just consider the `leftInspector` because we can just reverse the input to get the `rightInspector` result.\\n\\nLet\\'s consider `s = \\'111110010011111001000\\'`.\\n\\nIntuitively we know that when there\\'s a lot of ones in a row, we should walk and if there\\'s a random one floating in space, we should teleport. For every index we should walk some distance and then grab the rest of the ones via teleportation. Let\\'s consider a cumulative sum where ones increment and zeros decrement\\n\\n` \\'111110010011111001000\\'`\\n`\\'123454343234567656543\\'`\\n\\n**This is key:** you should walk wherever the counter last reached an all time high. And you should teleport to grab the rest. For example to get index 10, you should walk to index 4 and teleport to indices 7 and 10.\\n\\n```js\\nvar minimumTime = function(s) {\\n    \\n    // Calculates the minimal work for an inspector walking to the right.\\n    function solve(ar) {\\n        \\n        // calculates the number of ones to the left of each index\\n        let countLeft = Array(ar.length).fill(0);\\n        let val = 0;\\n        for (let i = 0; i < ar.length; i++) {\\n            if (ar[i] === \\'1\\') {\\n                val++;\\n            }\\n            countLeft[i] = val;\\n        }\\n        \\n        \\n        let high = 0;\\n        let walk = -1;\\n        let cumulative = 0;\\n        const result = Array(ar.length).fill(0);\\n        for (let i = 0; i < ar.length; i++) {\\n            if (ar[i] === \\'1\\') {\\n                cumulative++;\\n                if (cumulative > 0 && cumulative > high) {\\n                    walk = i;\\n                    high = cumulative\\n                }\\n            } else {\\n                cumulative--;\\n            }\\n            // the amount to walk plus the amount to teleport\\n            result[i] = (walk + 1) + (countLeft[i] - (countLeft[walk] || 0)) * 2;\\n        }\\n        return result;\\n    }\\n    \\n    const ar = s.split(\\'\\');\\n    const leftInspector = solve(ar);\\n    const rightInspector = solve(ar.reverse()).reverse();\\n    \\n    let best = Math.min(leftInspector[leftInspector.length - 1], rightInspector[0]);\\n    for (let i = 0; i < rightInspector.length - 1; i++) {\\n        best = Math.min(best, leftInspector[i] + rightInspector[i + 1]);\\n    }\\n    return best;\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\nvar minimumTime = function(s) {\\n    \\n    // Calculates the minimal work for an inspector walking to the right.\\n    function solve(ar) {\\n        \\n        // calculates the number of ones to the left of each index\\n        let countLeft = Array(ar.length).fill(0);\\n        let val = 0;\\n        for (let i = 0; i < ar.length; i++) {\\n            if (ar[i] === \\'1\\') {\\n                val++;\\n            }\\n            countLeft[i] = val;\\n        }\\n        \\n        \\n        let high = 0;\\n        let walk = -1;\\n        let cumulative = 0;\\n        const result = Array(ar.length).fill(0);\\n        for (let i = 0; i < ar.length; i++) {\\n            if (ar[i] === \\'1\\') {\\n                cumulative++;\\n                if (cumulative > 0 && cumulative > high) {\\n                    walk = i;\\n                    high = cumulative\\n                }\\n            } else {\\n                cumulative--;\\n            }\\n            // the amount to walk plus the amount to teleport\\n            result[i] = (walk + 1) + (countLeft[i] - (countLeft[walk] || 0)) * 2;\\n        }\\n        return result;\\n    }\\n    \\n    const ar = s.split(\\'\\');\\n    const leftInspector = solve(ar);\\n    const rightInspector = solve(ar.reverse()).reverse();\\n    \\n    let best = Math.min(leftInspector[leftInspector.length - 1], rightInspector[0]);\\n    for (let i = 0; i < rightInspector.length - 1; i++) {\\n        best = Math.min(best, leftInspector[i] + rightInspector[i + 1]);\\n    }\\n    return best;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1748613,
                "title": "c-dp-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int size = s.size();\\n        vector<int> dp1(size, 0);\\n        vector<int> dp2(size, 0);\\n        int accu = 0;\\n        for(int i=0;i<dp1.size();i++){\\n            if(s[i]==\\'0\\'){\\n                dp1[i] = i==0 ? 0 : dp1[i-1];\\n                continue;\\n            }\\n            dp1[i] = min(i+1, accu+2);\\n            accu = dp1[i];\\n        }\\n        accu = 0;\\n        for(int i=dp2.size()-1;i>=0;i--){\\n            if(s[i]==\\'0\\'){\\n                dp2[i] = i==size-1 ? 0: dp2[i+1];\\n                continue;\\n            }\\n            dp2[i] = min(size - i, accu+2);\\n            accu = dp2[i];\\n        }\\n        int minval = INT_MAX;\\n        for(int i=0;i<size;i++){\\n            minval = min(minval, dp1[i]+dp2[i]-(s[i]==\\'1\\'));\\n        }\\n        return minval;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        int size = s.size();\\n        vector<int> dp1(size, 0);\\n        vector<int> dp2(size, 0);\\n        int accu = 0;\\n        for(int i=0;i<dp1.size();i++){\\n            if(s[i]==\\'0\\'){\\n                dp1[i] = i==0 ? 0 : dp1[i-1];\\n                continue;\\n            }\\n            dp1[i] = min(i+1, accu+2);\\n            accu = dp1[i];\\n        }\\n        accu = 0;\\n        for(int i=dp2.size()-1;i>=0;i--){\\n            if(s[i]==\\'0\\'){\\n                dp2[i] = i==size-1 ? 0: dp2[i+1];\\n                continue;\\n            }\\n            dp2[i] = min(size - i, accu+2);\\n            accu = dp2[i];\\n        }\\n        int minval = INT_MAX;\\n        for(int i=0;i<size;i++){\\n            minval = min(minval, dp1[i]+dp2[i]-(s[i]==\\'1\\'));\\n        }\\n        return minval;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748589,
                "title": "simple-and-concise-3-lines-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        const int n = s.length();\\n        int r = 0, ans = n;\\n        for (int i = n - 1; i >= 0; --i) {\\n          r = min(n - i, r + (s[i] == \\'1\\' ? 2 : 0));\\n\\t\\t  ans = min(ans, i + r);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTime(string s) {\\n        const int n = s.length();\\n        int r = 0, ans = n;\\n        for (int i = n - 1; i >= 0; --i) {\\n          r = min(n - i, r + (s[i] == \\'1\\' ? 2 : 0));\\n\\t\\t  ans = min(ans, i + r);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748554,
                "title": "c-solution-using-prefix-suffix-explanation",
                "content": "**here we have to minimize the cost of removal of train containing illegal goods\\nTo do so we gonna use prefix suffix approach\\nprefix array will store the optimal cost require to remove all 1s from left\\nwhile suffix array will store the optimal cost to remove all 1s from right\\nlast we need a traversal to check the minimum cost to remove all 1s  i.e (left + right) **\\n**TC = ~ O(N)**\\n**SC = ~ O(N)**\\n```\\nclass Solution {\\npublic:\\n    #define ll int\\n    int minimumTime(string s) {\\n        int n = s.size();\\n        vector<ll > pref( n , 0);\\n        vector<ll > suff( n , 0);\\n        \\n        pref[0] = s[0]== \\'1\\'? 1 : 0;\\n        \\n        for(int i=1 ; i < n; i++){\\n            pref[i] = pref[i-1];\\n            \\n            if(s[i] == \\'1\\'){\\n                pref[i] = min( i+1 , pref[i-1] + 2 );\\n            }\\n        }\\n        \\n        suff[n-1] = s[n-1] == \\'1\\' ?1 : 0;\\n        \\n        for(int i=n-2 ; i>= 0; i-- ){\\n            suff[i] = suff[i+1];\\n            \\n            if( s[i] == \\'1\\'){\\n                suff[i] = min( n - i , suff[i+1] + 2 );\\n            }\\n        }\\n        \\n        ll ans = INT_MAX;\\n        \\n        for(int i = 0 ; i< n; i++){\\n            \\n            ll temp = i + 1 >= n ? 0 : suff[i+1];\\n            \\n            ans = min ( ans , temp + pref[i] );\\n        }\\n        \\n        return (int)(ans);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll int\\n    int minimumTime(string s) {\\n        int n = s.size();\\n        vector<ll > pref( n , 0);\\n        vector<ll > suff( n , 0);\\n        \\n        pref[0] = s[0]== \\'1\\'? 1 : 0;\\n        \\n        for(int i=1 ; i < n; i++){\\n            pref[i] = pref[i-1];\\n            \\n            if(s[i] == \\'1\\'){\\n                pref[i] = min( i+1 , pref[i-1] + 2 );\\n            }\\n        }\\n        \\n        suff[n-1] = s[n-1] == \\'1\\' ?1 : 0;\\n        \\n        for(int i=n-2 ; i>= 0; i-- ){\\n            suff[i] = suff[i+1];\\n            \\n            if( s[i] == \\'1\\'){\\n                suff[i] = min( n - i , suff[i+1] + 2 );\\n            }\\n        }\\n        \\n        ll ans = INT_MAX;\\n        \\n        for(int i = 0 ; i< n; i++){\\n            \\n            ll temp = i + 1 >= n ? 0 : suff[i+1];\\n            \\n            ans = min ( ans , temp + pref[i] );\\n        }\\n        \\n        return (int)(ans);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566419,
                "content": [
                    {
                        "username": "leetcodergood",
                        "content": "please help....\\n\\nstart from left: 2+1+2+1111111 + 2+2+2+2+2+2"
                    },
                    {
                        "username": "rip",
                        "content": "which operations?"
                    },
                    {
                        "username": "vrushali_1",
                        "content": "[leetcode](https://leetcode.com) `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "darkain",
                        "content": "extracting zero wagons is also allowed in tests!\\n010110 = 5"
                    },
                    {
                        "username": "norushing",
                        "content": "Shouldn\\'t this test case return 24? (it\\'s returning 25)\\n\"011001111111101001010000001010011\""
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "[@norushing](/norushing) I\\'m also getting the same thing for this one. Did you end up finding what the issue is?"
                    },
                    {
                        "username": "norushing",
                        "content": "You's start from the right, removing 2, which would cost 2, and then you'd keep removing from the left, and this would cost 22.."
                    }
                ]
            },
            {
                "id": 1576347,
                "content": [
                    {
                        "username": "leetcodergood",
                        "content": "please help....\\n\\nstart from left: 2+1+2+1111111 + 2+2+2+2+2+2"
                    },
                    {
                        "username": "rip",
                        "content": "which operations?"
                    },
                    {
                        "username": "vrushali_1",
                        "content": "[leetcode](https://leetcode.com) `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "darkain",
                        "content": "extracting zero wagons is also allowed in tests!\\n010110 = 5"
                    },
                    {
                        "username": "norushing",
                        "content": "Shouldn\\'t this test case return 24? (it\\'s returning 25)\\n\"011001111111101001010000001010011\""
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "[@norushing](/norushing) I\\'m also getting the same thing for this one. Did you end up finding what the issue is?"
                    },
                    {
                        "username": "norushing",
                        "content": "You's start from the right, removing 2, which would cost 2, and then you'd keep removing from the left, and this would cost 22.."
                    }
                ]
            },
            {
                "id": 1724179,
                "content": [
                    {
                        "username": "leetcodergood",
                        "content": "please help....\\n\\nstart from left: 2+1+2+1111111 + 2+2+2+2+2+2"
                    },
                    {
                        "username": "rip",
                        "content": "which operations?"
                    },
                    {
                        "username": "vrushali_1",
                        "content": "[leetcode](https://leetcode.com) `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "darkain",
                        "content": "extracting zero wagons is also allowed in tests!\\n010110 = 5"
                    },
                    {
                        "username": "norushing",
                        "content": "Shouldn\\'t this test case return 24? (it\\'s returning 25)\\n\"011001111111101001010000001010011\""
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "[@norushing](/norushing) I\\'m also getting the same thing for this one. Did you end up finding what the issue is?"
                    },
                    {
                        "username": "norushing",
                        "content": "You's start from the right, removing 2, which would cost 2, and then you'd keep removing from the left, and this would cost 22.."
                    }
                ]
            },
            {
                "id": 1702066,
                "content": [
                    {
                        "username": "leetcodergood",
                        "content": "please help....\\n\\nstart from left: 2+1+2+1111111 + 2+2+2+2+2+2"
                    },
                    {
                        "username": "rip",
                        "content": "which operations?"
                    },
                    {
                        "username": "vrushali_1",
                        "content": "[leetcode](https://leetcode.com) `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "darkain",
                        "content": "extracting zero wagons is also allowed in tests!\\n010110 = 5"
                    },
                    {
                        "username": "norushing",
                        "content": "Shouldn\\'t this test case return 24? (it\\'s returning 25)\\n\"011001111111101001010000001010011\""
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "[@norushing](/norushing) I\\'m also getting the same thing for this one. Did you end up finding what the issue is?"
                    },
                    {
                        "username": "norushing",
                        "content": "You's start from the right, removing 2, which would cost 2, and then you'd keep removing from the left, and this would cost 22.."
                    }
                ]
            },
            {
                "id": 1683920,
                "content": [
                    {
                        "username": "leetcodergood",
                        "content": "please help....\\n\\nstart from left: 2+1+2+1111111 + 2+2+2+2+2+2"
                    },
                    {
                        "username": "rip",
                        "content": "which operations?"
                    },
                    {
                        "username": "vrushali_1",
                        "content": "[leetcode](https://leetcode.com) `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "darkain",
                        "content": "extracting zero wagons is also allowed in tests!\\n010110 = 5"
                    },
                    {
                        "username": "norushing",
                        "content": "Shouldn\\'t this test case return 24? (it\\'s returning 25)\\n\"011001111111101001010000001010011\""
                    },
                    {
                        "username": "ladiaz4e98",
                        "content": "[@norushing](/norushing) I\\'m also getting the same thing for this one. Did you end up finding what the issue is?"
                    },
                    {
                        "username": "norushing",
                        "content": "You's start from the right, removing 2, which would cost 2, and then you'd keep removing from the left, and this would cost 22.."
                    }
                ]
            }
        ]
    }
]