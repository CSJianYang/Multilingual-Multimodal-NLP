[
    {
        "title": "Parsing A Boolean Expression",
        "question_content": "A boolean expression is an expression that evaluates to either true or false. It can be in one of the following shapes:\n\n\t't' that evaluates to true.\n\t'f' that evaluates to false.\n\t'!(subExpr)' that evaluates to the logical NOT of the inner expression subExpr.\n\t'&(subExpr1, subExpr2, ..., subExprn)' that evaluates to the logical AND of the inner expressions subExpr1, subExpr2, ..., subExprn where n >= 1.\n\t'|(subExpr1, subExpr2, ..., subExprn)' that evaluates to the logical OR of the inner expressions subExpr1, subExpr2, ..., subExprn where n >= 1.\n\nGiven a string expression that represents a boolean expression, return the evaluation of that expression.\nIt is guaranteed that the given expression is valid and follows the given rules.\n&nbsp;\nExample 1:\n\nInput: expression = \"&(|(f))\"\nOutput: false\nExplanation: \nFirst, evaluate |(f) --> f. The expression is now \"&(f)\".\nThen, evaluate &(f) --> f. The expression is now \"f\".\nFinally, return false.\n\nExample 2:\n\nInput: expression = \"|(f,f,f,t)\"\nOutput: true\nExplanation: The evaluation of (false OR false OR false OR true) is true.\n\nExample 3:\n\nInput: expression = \"!(&(f,t))\"\nOutput: true\nExplanation: \nFirst, evaluate &(f,t) --> (false AND true) --> false --> f. The expression is now \"!(f)\".\nThen, evaluate !(f) --> NOT false --> true. We return true.\n\n&nbsp;\nConstraints:\n\n\t1 <= expression.length <= 2 * 104\n\texpression[i] is one following characters: '(', ')', '&', '|', '!', 't', 'f', and ','.",
        "solutions": [
            {
                "id": 323307,
                "title": "python-easy-1-line-cheat",
                "content": "## **Intuition**\\nWell, we can see that `&`, `|` and `!` are just three functions.\\nAnd in python, they are function `all`, `any` and keyword `not`.\\n\\n## **Explanation**\\nFollowing the description,\\nit demands us to evaluate the expression.\\nSo no recursion and no stack, I just `eval` the expression.\\n<br>\\n\\n## **Complexity**\\nTime `O(N)`\\nSapce `O(N)`\\nI guess it\\'s not fast compared with string parse, but wow it\\'s `O(N)`.\\n<br>\\n\\n**Python:**\\n```\\n    def parseBoolExpr(self, S, t=True, f=False):\\n        return eval(S.replace(\\'!\\', \\'not |\\').replace(\\'&(\\', \\'all([\\').replace(\\'|(\\', \\'any([\\').replace(\\')\\', \\'])\\'))\\n```",
                "solutionTags": [],
                "code": "```\\n    def parseBoolExpr(self, S, t=True, f=False):\\n        return eval(S.replace(\\'!\\', \\'not |\\').replace(\\'&(\\', \\'all([\\').replace(\\'|(\\', \\'any([\\').replace(\\')\\', \\'])\\'))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 323532,
                "title": "java-python-3-iterative-and-recursive-solutions-w-explanation-and-analysis",
                "content": "**Method 1:** Iterative version - Use Stack and Set.\\n\\nLoop through the input String:\\n1. Use a stack to store chars except `\\',\\'` and `\\')\\'`;\\n2. If we find a `\\')\\'`, keep popping out the chars from the stack till find a `\\'(\\'`; add the popped-out into a Set.\\n3. Pop out the `operator` after popping `\\')\\'`  out, push into stack the corresponding result according to the `operator`.\\n4. repeat the above till the end, and the remaining is the result.\\n\\n**[Java]**\\n\\n```java\\n    public boolean parseBoolExpr(String expression) {\\n        Deque<Character> stk = new ArrayDeque<>();\\n        for (int i = 0; i < expression.length(); ++i) {\\n            char c = expression.charAt(i);\\n            if (c == \\')\\') {\\n                Set<Character> seen = new HashSet<>();\\n                while (stk.peek() != \\'(\\')\\n                    seen.add(stk.pop());\\n                stk.pop();// pop out \\'(\\'.\\n                char operator = stk.pop(); // get operator for current expression.\\n                if (operator == \\'&\\') {\\n                    stk.push(seen.contains(\\'f\\') ? \\'f\\' : \\'t\\'); // if there is any \\'f\\', & expression results to \\'f\\'\\n                }else if (operator == \\'|\\') {\\n                    stk.push(seen.contains(\\'t\\') ? \\'t\\' : \\'f\\'); // if there is any \\'t\\', | expression results to \\'t\\'\\n                }else { // ! expression.\\n                    stk.push(seen.contains(\\'t\\') ? \\'f\\' : \\'t\\'); // Logical NOT flips the expression.\\n                }\\n            }else if (c != \\',\\') {\\n                stk.push(c);\\n            }\\n        }\\n        return stk.pop() == \\'t\\';\\n    }\\n```\\n**[Python 3]** credit to: **@zengfei216 and @cenkay**\\n\\n```python\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        stack = []\\n        for c in expression:\\n            if c == \\')\\':\\n                seen = set()\\n                while stack[-1] != \\'(\\':\\n                    seen.add(stack.pop())\\n                stack.pop()\\n                operator = stack.pop()\\n                stack.append(all(seen) if operator == \\'&\\' else any(seen) if operator == \\'|\\' else not seen.pop())\\n            elif c != \\',\\':\\n                stack.append(True if c == \\'t\\' else False if c == \\'f\\' else c)\\n        return stack.pop()\\n```\\n----\\n**Method 2:** Recursive version.\\n\\nUse `level` to count the non-matched `(` and `)`, together with `,`, we can delimit valid sub-expression and hence recurse to sub-problem.\\n\\n\\n**[Java]**\\n\\n\\n```java\\n    public boolean parseBoolExpr(String expression) {\\n        return parse(expression, 0, expression.length());\\n    }\\n    private boolean parse(String s, int lo, int hi) {\\n        char c = s.charAt(lo);\\n        if (hi - lo == 1) return c == \\'t\\'; // base case.\\n        boolean ans = c == \\'&\\'; // only when c is &, set ans to true; otherwise false.\\n        for (int i = lo + 2, start = i, level = 0; i < hi; ++i) {\\n            char d = s.charAt(i);\\n            if (level == 0 && (d == \\',\\' || d == \\')\\')) { // locate a valid sub-expression. \\n                boolean cur = parse(s, start, i); // recurse to sub-problem.\\n                start = i + 1; // next sub-expression start index.\\n                if (c == \\'&\\') ans &= cur;\\n                else if (c == \\'|\\') ans |= cur;\\n                else ans = !cur; // c == \\'!\\'.\\n            }\\n            if (d == \\'(\\') ++level;\\n            if (d == \\')\\') --level;\\n        }\\n        return ans;\\n    }\\n```\\n**[Python 3]**\\n\\n```python\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        \\n        def parse(e: str, lo: int, hi: int) -> bool:\\n            if hi - lo == 1: # base case\\n                return e[lo] == \\'t\\'               \\n            ans = e[lo] == \\'&\\' # only when the first char is \\'&\\', ans assigned True.\\n            level, start = 0, lo + 2 # e[lo + 1] must be \\'(\\', so start from lo + 2 to delimit sub-expression.\\n            for i in range(lo + 2, hi):\\n                if level == 0  and e[i] in [\\',\\', \\')\\']: # found a sub-expression.\\n                    cur = parse(e, start, i) # recurse to sub-problem.\\n                    start = i + 1 # start point of next sub-expression.\\n                    if e[lo] == \\'&\\':\\n                        ans &= cur\\n                    elif e[lo] == \\'|\\':\\n                        ans |= cur\\n                    else: # e[lo] is \\'!\\'.\\n                        ans = not cur\\n                if e[i] == \\'(\\':\\n                    level = level + 1\\n                elif e[i] == \\')\\':\\n                    level = level - 1\\n            return ans;        \\n        \\n        return parse(expression, 0, len(expression))\\n```\\n**Analysis:**\\nTime & space: O(n), n = expression.length().\\n\\n",
                "solutionTags": [],
                "code": "```java\\n    public boolean parseBoolExpr(String expression) {\\n        Deque<Character> stk = new ArrayDeque<>();\\n        for (int i = 0; i < expression.length(); ++i) {\\n            char c = expression.charAt(i);\\n            if (c == \\')\\') {\\n                Set<Character> seen = new HashSet<>();\\n                while (stk.peek() != \\'(\\')\\n                    seen.add(stk.pop());\\n                stk.pop();// pop out \\'(\\'.\\n                char operator = stk.pop(); // get operator for current expression.\\n                if (operator == \\'&\\') {\\n                    stk.push(seen.contains(\\'f\\') ? \\'f\\' : \\'t\\'); // if there is any \\'f\\', & expression results to \\'f\\'\\n                }else if (operator == \\'|\\') {\\n                    stk.push(seen.contains(\\'t\\') ? \\'t\\' : \\'f\\'); // if there is any \\'t\\', | expression results to \\'t\\'\\n                }else { // ! expression.\\n                    stk.push(seen.contains(\\'t\\') ? \\'f\\' : \\'t\\'); // Logical NOT flips the expression.\\n                }\\n            }else if (c != \\',\\') {\\n                stk.push(c);\\n            }\\n        }\\n        return stk.pop() == \\'t\\';\\n    }\\n```\n```python\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        stack = []\\n        for c in expression:\\n            if c == \\')\\':\\n                seen = set()\\n                while stack[-1] != \\'(\\':\\n                    seen.add(stack.pop())\\n                stack.pop()\\n                operator = stack.pop()\\n                stack.append(all(seen) if operator == \\'&\\' else any(seen) if operator == \\'|\\' else not seen.pop())\\n            elif c != \\',\\':\\n                stack.append(True if c == \\'t\\' else False if c == \\'f\\' else c)\\n        return stack.pop()\\n```\n```java\\n    public boolean parseBoolExpr(String expression) {\\n        return parse(expression, 0, expression.length());\\n    }\\n    private boolean parse(String s, int lo, int hi) {\\n        char c = s.charAt(lo);\\n        if (hi - lo == 1) return c == \\'t\\'; // base case.\\n        boolean ans = c == \\'&\\'; // only when c is &, set ans to true; otherwise false.\\n        for (int i = lo + 2, start = i, level = 0; i < hi; ++i) {\\n            char d = s.charAt(i);\\n            if (level == 0 && (d == \\',\\' || d == \\')\\')) { // locate a valid sub-expression. \\n                boolean cur = parse(s, start, i); // recurse to sub-problem.\\n                start = i + 1; // next sub-expression start index.\\n                if (c == \\'&\\') ans &= cur;\\n                else if (c == \\'|\\') ans |= cur;\\n                else ans = !cur; // c == \\'!\\'.\\n            }\\n            if (d == \\'(\\') ++level;\\n            if (d == \\')\\') --level;\\n        }\\n        return ans;\\n    }\\n```\n```python\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        \\n        def parse(e: str, lo: int, hi: int) -> bool:\\n            if hi - lo == 1: # base case\\n                return e[lo] == \\'t\\'               \\n            ans = e[lo] == \\'&\\' # only when the first char is \\'&\\', ans assigned True.\\n            level, start = 0, lo + 2 # e[lo + 1] must be \\'(\\', so start from lo + 2 to delimit sub-expression.\\n            for i in range(lo + 2, hi):\\n                if level == 0  and e[i] in [\\',\\', \\')\\']: # found a sub-expression.\\n                    cur = parse(e, start, i) # recurse to sub-problem.\\n                    start = i + 1 # start point of next sub-expression.\\n                    if e[lo] == \\'&\\':\\n                        ans &= cur\\n                    elif e[lo] == \\'|\\':\\n                        ans |= cur\\n                    else: # e[lo] is \\'!\\'.\\n                        ans = not cur\\n                if e[i] == \\'(\\':\\n                    level = level + 1\\n                elif e[i] == \\')\\':\\n                    level = level - 1\\n            return ans;        \\n        \\n        return parse(expression, 0, len(expression))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 325228,
                "title": "c-polish-notation",
                "content": "# Intuition\\nWe can parse parentheses and recursivelly evaluate the expression. Or, since the expression is in Poslih notation, we can use a simple stack approach.\\n# Recursive Solution\\nLogical AND and OR expressions are a bit tricky as they have multiple parameters, and a parameter can be an inner expression.\\n\\nSo, to extract parameters, we need to track the number of non-closed parentheses; when we see a comma (\",\") and the number of parentheses is zero, we found an entire parameter.\\n```\\nbool parseBoolExpr(string e) {\\n  if (e.size() == 1) return e == \"t\" ? true : false;\\n  if (e[0] == \\'!\\') return !parseBoolExpr(e.substr(2, e.size() - 3));\\n  bool isAnd = e[0] == \\'&\\' ? true : false, res = isAnd;\\n  for (auto i = 2, j = 2, cnt = 0; res == isAnd && i < e.size(); ++i) {\\n    if (e[i] == \\'(\\') ++cnt;\\n    if (e[i] == \\')\\') --cnt;      \\n    if (i == e.size() - 1 || (e[i] == \\',\\' && cnt == 0)) {\\n      if (isAnd) res &= parseBoolExpr(e.substr(j, i - j));\\n      else res |= parseBoolExpr(e.substr(j, i - j));\\n      j = i + 1;\\n    }\\n  }\\n  return res;\\n}\\n```\\n# Polish Notation\\nPolish notation is very easy to evaluate: push everything to the stack until you get the closing group marker (\\')\\'). Then, pop values from the stack (should be just \\'t\\' and \\'f\\' at this point) until you reach an operator (\\'!\\', \\'|\\' or \\'&\\'). Apply the operator to the values and push the result back to the stack.\\n\\nAdditional observations:\\n\\u2022\\tWe can ignore commas and open parentheses.\\n\\u2022\\tWe do not need to apply the operator to all parameters; we just need to know whether we have one or more \\'t\\', or one or more \\'f\\'.\\n```\\nbool parseBoolExpr(string e) {\\n  stack<char> s;\\n  for (auto ch : e) {\\n    if (ch == \\')\\') {\\n      auto hasT = false, hasF = false;\\n      while (s.top() == \\'t\\' || s.top() == \\'f\\') {\\n        hasT |= s.top() == \\'t\\';\\n        hasF |= s.top() == \\'f\\';\\n        s.pop();\\n      }\\n      auto op = s.top();\\n      s.pop();\\n      s.push(op == \\'!\\' ? hasF ? \\'t\\' : \\'f\\' : op == \\'&\\' ? !hasF ? \\'t\\' : \\'f\\' : hasT ? \\'t\\' : \\'f\\');\\n    }\\n    else if (ch != \\',\\' && ch != \\'(\\') s.push(ch);\\n  }\\n  return s.top() == \\'t\\' ? true : false;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool parseBoolExpr(string e) {\\n  if (e.size() == 1) return e == \"t\" ? true : false;\\n  if (e[0] == \\'!\\') return !parseBoolExpr(e.substr(2, e.size() - 3));\\n  bool isAnd = e[0] == \\'&\\' ? true : false, res = isAnd;\\n  for (auto i = 2, j = 2, cnt = 0; res == isAnd && i < e.size(); ++i) {\\n    if (e[i] == \\'(\\') ++cnt;\\n    if (e[i] == \\')\\') --cnt;      \\n    if (i == e.size() - 1 || (e[i] == \\',\\' && cnt == 0)) {\\n      if (isAnd) res &= parseBoolExpr(e.substr(j, i - j));\\n      else res |= parseBoolExpr(e.substr(j, i - j));\\n      j = i + 1;\\n    }\\n  }\\n  return res;\\n}\\n```\n```\\nbool parseBoolExpr(string e) {\\n  stack<char> s;\\n  for (auto ch : e) {\\n    if (ch == \\')\\') {\\n      auto hasT = false, hasF = false;\\n      while (s.top() == \\'t\\' || s.top() == \\'f\\') {\\n        hasT |= s.top() == \\'t\\';\\n        hasF |= s.top() == \\'f\\';\\n        s.pop();\\n      }\\n      auto op = s.top();\\n      s.pop();\\n      s.push(op == \\'!\\' ? hasF ? \\'t\\' : \\'f\\' : op == \\'&\\' ? !hasF ? \\'t\\' : \\'f\\' : hasT ? \\'t\\' : \\'f\\');\\n    }\\n    else if (ch != \\',\\' && ch != \\'(\\') s.push(ch);\\n  }\\n  return s.top() == \\'t\\' ? true : false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 323370,
                "title": "c-recursive-descent-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool f_not(const string& s,int& i){\\n        i+=2;\\n        auto ret = f(s,i);\\n        i++;\\n        return !ret;\\n    }\\n    \\n    bool f_and(const string& s,int& i){\\n        i+=2;\\n        bool ret = true;\\n        ret &= f(s,i);\\n        while(s[i]!=\\')\\'){\\n            i++;\\n            ret &= f(s,i);\\n        }\\n        i++;\\n        return ret;\\n    }\\n    \\n    bool f_or(const string& s,int& i){\\n        i+=2;\\n        bool ret = false;\\n        ret |= f(s,i);\\n        while(s[i]!=\\')\\'){\\n            i++;\\n            ret |= f(s,i);\\n        }\\n        i++;\\n        return ret;\\n    }\\n    \\n    bool f(const string& s, int& i){\\n        if(s[i] == \\'t\\'){\\n            i++;\\n            return true;\\n        } else if(s[i] == \\'f\\'){\\n            i++;\\n            return false;\\n        } else if(s[i] == \\'!\\'){\\n            return f_not(s,i);\\n        } else if(s[i] == \\'&\\'){\\n            return f_and(s,i);\\n        } return f_or(s,i);\\n    }\\n    bool parseBoolExpr(string expression) {\\n        int i = 0;\\n        return f(expression,i);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool f_not(const string& s,int& i){\\n        i+=2;\\n        auto ret = f(s,i);\\n        i++;\\n        return !ret;\\n    }\\n    \\n    bool f_and(const string& s,int& i){\\n        i+=2;\\n        bool ret = true;\\n        ret &= f(s,i);\\n        while(s[i]!=\\')\\'){\\n            i++;\\n            ret &= f(s,i);\\n        }\\n        i++;\\n        return ret;\\n    }\\n    \\n    bool f_or(const string& s,int& i){\\n        i+=2;\\n        bool ret = false;\\n        ret |= f(s,i);\\n        while(s[i]!=\\')\\'){\\n            i++;\\n            ret |= f(s,i);\\n        }\\n        i++;\\n        return ret;\\n    }\\n    \\n    bool f(const string& s, int& i){\\n        if(s[i] == \\'t\\'){\\n            i++;\\n            return true;\\n        } else if(s[i] == \\'f\\'){\\n            i++;\\n            return false;\\n        } else if(s[i] == \\'!\\'){\\n            return f_not(s,i);\\n        } else if(s[i] == \\'&\\'){\\n            return f_and(s,i);\\n        } return f_or(s,i);\\n    }\\n    bool parseBoolExpr(string expression) {\\n        int i = 0;\\n        return f(expression,i);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2356645,
                "title": "c-clean-code-smooth-as-f-k-stack",
                "content": "***Almost Spent 2 hrs to solve this one!! So please upvote if you find this solution intuative!!***\\n\\n```\\nclass Solution {\\nprivate:\\n    bool parse_or (vector<int> &res)\\n    {\\n        int mask = res[0];\\n        for(int i=1; i<res.size(); i++)\\n        {\\n            mask |= res[i];\\n        }\\n        return mask;\\n    }\\n    \\n    bool parse_and (vector<int> &res)\\n    {\\n        int mask = res[0];\\n        for(int i=1; i<res.size(); i++)\\n        {\\n            mask &= res[i];\\n        }\\n        return mask;\\n    }\\n    \\npublic:\\n    bool parseBoolExpr(string s) {\\n        int n = s.size();\\n        stack<int> st;\\n        for(int i =0; i<n; i++)\\n        {\\n            if(s[i] == \\',\\') continue;\\n            if(s[i]==\\')\\')\\n            {\\n                vector<int> res;\\n                while(st.top()!=\\'&\\' && st.top()!=\\'|\\' && st.top()!=\\'!\\')\\n                {\\n                    char c = st.top();\\n                    st.pop();\\n                    if(c==\\'t\\') res.push_back(1);\\n                    if(c==\\'f\\') res.push_back(0);\\n                }\\n                char c = st.top();\\n                st.pop();\\n                if(c==\\'&\\')\\n                {\\n                    if(parse_and(res)) st.push(\\'t\\');\\n                    else st.push(\\'f\\');\\n                }\\n                else if(c==\\'|\\') \\n                {\\n                    if(parse_or(res)) st.push(\\'t\\');\\n                    else st.push(\\'f\\');\\n                }\\n                else if(c==\\'!\\')\\n                {\\n                    if(res[0] == 0) st.push(\\'t\\'); \\n                    else st.push(\\'f\\');\\n                }\\n            }\\n            else st.push(s[i]);\\n        }\\n        return (st.top()==\\'t\\');\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool parse_or (vector<int> &res)\\n    {\\n        int mask = res[0];\\n        for(int i=1; i<res.size(); i++)\\n        {\\n            mask |= res[i];\\n        }\\n        return mask;\\n    }\\n    \\n    bool parse_and (vector<int> &res)\\n    {\\n        int mask = res[0];\\n        for(int i=1; i<res.size(); i++)\\n        {\\n            mask &= res[i];\\n        }\\n        return mask;\\n    }\\n    \\npublic:\\n    bool parseBoolExpr(string s) {\\n        int n = s.size();\\n        stack<int> st;\\n        for(int i =0; i<n; i++)\\n        {\\n            if(s[i] == \\',\\') continue;\\n            if(s[i]==\\')\\')\\n            {\\n                vector<int> res;\\n                while(st.top()!=\\'&\\' && st.top()!=\\'|\\' && st.top()!=\\'!\\')\\n                {\\n                    char c = st.top();\\n                    st.pop();\\n                    if(c==\\'t\\') res.push_back(1);\\n                    if(c==\\'f\\') res.push_back(0);\\n                }\\n                char c = st.top();\\n                st.pop();\\n                if(c==\\'&\\')\\n                {\\n                    if(parse_and(res)) st.push(\\'t\\');\\n                    else st.push(\\'f\\');\\n                }\\n                else if(c==\\'|\\') \\n                {\\n                    if(parse_or(res)) st.push(\\'t\\');\\n                    else st.push(\\'f\\');\\n                }\\n                else if(c==\\'!\\')\\n                {\\n                    if(res[0] == 0) st.push(\\'t\\'); \\n                    else st.push(\\'f\\');\\n                }\\n            }\\n            else st.push(s[i]);\\n        }\\n        return (st.top()==\\'t\\');\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 325120,
                "title": "a-compiler-front-end-writer-s-solution-recursive-descent-parsing",
                "content": "Compiler front-ends (lexer, parser, AST generators) routinely use recursive descent parsing to parse source code written in language which is defined by a set of (E)BNF grammars. Here\\'s my solution:\\n\\nLet\\'s define a BNF grammar for this language of booleans and we will implement a recursive descent parser for it.\\n\\n```\\n<comma> ::= \",\"\\n<bool> ::= \"t\" | \"f\"\\n<lparen> ::= \"(\"\\n<rparen> ::= \")\"\\n<not_expr> ::= \"!\" <lparen> <expr> <rparen>\\n<and_expr> ::= \"&\" <lparen> <expr> (<comma> <expr>)+ <rparen>\\n<or_expr> ::= \"|\" <lparen> <expr> (<comma> <expr>)+ <rparen>\\n<expr> ::= <bool> | <not_expr> | <and_expr> | <or_expr>\\n```\\n\\nThis grammar can parse any statement written in this language of booleans. The elegance of this is that once you have defined the grammar the parser code is pretty much described by the grammar rules where each non-terminal rule is turned into a method.\\n\\n```\\nclass Solution {\\n    int pos = 0; // a global source code position marker\\n    String src = \"\";\\n    public boolean parseBoolExpr(String expression) {\\n        pos = 0;\\n        src = expression;\\n        return parseExpr(); // call the entry rule\\n    }\\n    private boolean parseExpr() {\\n        if(src.charAt(pos) == \\'t\\') { //<expr> ::= \"t\"\\n            ++pos;\\n            return true;\\n        }\\n        if(src.charAt(pos) == \\'f\\') { //<expr> ::= \"f\"\\n            ++pos;\\n            return false;\\n        }\\n        boolean result = false;\\n        switch(src.charAt(pos)) {\\n\\t\\t//<not_expr> ::= \"!\" <lparen> <expr> <rparen>\\n            case \\'!\\': \\n                pos ++; //eat operator\\n                result = parseNotExpr();\\n                break;\\n\\t\\t//<or_expr> ::= \"|\" <lparen> <expr> (<comma> <expr>)+ <rparen>\\n            case \\'|\\':\\n                pos ++; //eat operator\\n                result = parseOrExpr();\\n                break;\\n\\t\\t//<and_expr> ::= \"&\" <lparen> <expr> (<comma> <expr>)+ <rparen>\\n            case \\'&\\':\\n                pos ++; //eat operator\\n                result = parseAndExpr();\\n                break;\\n        }\\n        return result;\\n    }\\n    private boolean parseNotExpr() {\\n        ++pos; //eat lparen\\n        boolean result = parseExpr();\\n        ++pos; //eat rparen\\n        return !result;\\n    }\\n    private boolean parseOrExpr() {\\n        ++pos; //eat lparen\\n        boolean result = parseExpr();\\n        while(pos < src.length() && src.charAt(pos) != \\')\\') {\\n            if(src.charAt(pos) == \\',\\') ++pos;\\n            else {\\n                result |= parseExpr();\\n            }\\n        }\\n        ++pos; //eat rparen\\n        return result;\\n    }\\n    private boolean parseAndExpr() {\\n        ++pos; //eat lparen\\n        boolean result = parseExpr();\\n        while(pos < src.length() && src.charAt(pos) != \\')\\') {\\n            if(src.charAt(pos) == \\',\\') ++pos;\\n            else {\\n                result &= parseExpr();\\n            }\\n        }\\n        ++pos; //eat rparen\\n        return result;\\n    }\\n}\\n```\\n\\nAs you can see each specific expression (!, & |) is responsible for advancing the position marker and what they do is pretty much exactly as the grammar rule defines.",
                "solutionTags": [],
                "code": "```\\n<comma> ::= \",\"\\n<bool> ::= \"t\" | \"f\"\\n<lparen> ::= \"(\"\\n<rparen> ::= \")\"\\n<not_expr> ::= \"!\" <lparen> <expr> <rparen>\\n<and_expr> ::= \"&\" <lparen> <expr> (<comma> <expr>)+ <rparen>\\n<or_expr> ::= \"|\" <lparen> <expr> (<comma> <expr>)+ <rparen>\\n<expr> ::= <bool> | <not_expr> | <and_expr> | <or_expr>\\n```\n```\\nclass Solution {\\n    int pos = 0; // a global source code position marker\\n    String src = \"\";\\n    public boolean parseBoolExpr(String expression) {\\n        pos = 0;\\n        src = expression;\\n        return parseExpr(); // call the entry rule\\n    }\\n    private boolean parseExpr() {\\n        if(src.charAt(pos) == \\'t\\') { //<expr> ::= \"t\"\\n            ++pos;\\n            return true;\\n        }\\n        if(src.charAt(pos) == \\'f\\') { //<expr> ::= \"f\"\\n            ++pos;\\n            return false;\\n        }\\n        boolean result = false;\\n        switch(src.charAt(pos)) {\\n\\t\\t//<not_expr> ::= \"!\" <lparen> <expr> <rparen>\\n            case \\'!\\': \\n                pos ++; //eat operator\\n                result = parseNotExpr();\\n                break;\\n\\t\\t//<or_expr> ::= \"|\" <lparen> <expr> (<comma> <expr>)+ <rparen>\\n            case \\'|\\':\\n                pos ++; //eat operator\\n                result = parseOrExpr();\\n                break;\\n\\t\\t//<and_expr> ::= \"&\" <lparen> <expr> (<comma> <expr>)+ <rparen>\\n            case \\'&\\':\\n                pos ++; //eat operator\\n                result = parseAndExpr();\\n                break;\\n        }\\n        return result;\\n    }\\n    private boolean parseNotExpr() {\\n        ++pos; //eat lparen\\n        boolean result = parseExpr();\\n        ++pos; //eat rparen\\n        return !result;\\n    }\\n    private boolean parseOrExpr() {\\n        ++pos; //eat lparen\\n        boolean result = parseExpr();\\n        while(pos < src.length() && src.charAt(pos) != \\')\\') {\\n            if(src.charAt(pos) == \\',\\') ++pos;\\n            else {\\n                result |= parseExpr();\\n            }\\n        }\\n        ++pos; //eat rparen\\n        return result;\\n    }\\n    private boolean parseAndExpr() {\\n        ++pos; //eat lparen\\n        boolean result = parseExpr();\\n        while(pos < src.length() && src.charAt(pos) != \\')\\') {\\n            if(src.charAt(pos) == \\',\\') ++pos;\\n            else {\\n                result &= parseExpr();\\n            }\\n        }\\n        ++pos; //eat rparen\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094182,
                "title": "c-easy-to-understand-20-lines",
                "content": "# Approach\\nUse recursive algorithm:\\n\\n* Parse operation\\n    * If it is simple expression (operation is \\'t\\' or \\'f\\') then return value.\\n    * Otherwise, recursively parse all subexpressions and calculate expression.\\n* Return resulting value\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: worse $$O(n)$$, average $$O(1)$$ amortized\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string e) {\\n        auto it = e.begin();\\n        return parse(it);\\n    }\\n\\n    bool parse(string::iterator& it) {\\n        switch (*(it++)) {\\n            case \\'t\\': return true;\\n            case \\'f\\': return false;\\n            case \\'|\\': return parse(it, false, [](bool init, bool val){ return init || val; });\\n            case \\'&\\': return parse(it, true,  [](bool init, bool val){ return init && val; });\\n            case \\'!\\': return parse(it, false, [](bool init, bool val){ return !val; });\\n        }\\n        return false;\\n    }\\n\\n    bool parse(string::iterator& it, bool init, function<bool(bool, bool)> op) {\\n        it++; // skip \\'(\\'\\n        while (true) {\\n            auto b = parse(it);\\n            init = op(init, b);\\n            if (*it == \\')\\') break;\\n            it++; // skip \\',\\'\\n        }\\n        it++; // skip \\')\\'\\n        return init;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string e) {\\n        auto it = e.begin();\\n        return parse(it);\\n    }\\n\\n    bool parse(string::iterator& it) {\\n        switch (*(it++)) {\\n            case \\'t\\': return true;\\n            case \\'f\\': return false;\\n            case \\'|\\': return parse(it, false, [](bool init, bool val){ return init || val; });\\n            case \\'&\\': return parse(it, true,  [](bool init, bool val){ return init && val; });\\n            case \\'!\\': return parse(it, false, [](bool init, bool val){ return !val; });\\n        }\\n        return false;\\n    }\\n\\n    bool parse(string::iterator& it, bool init, function<bool(bool, bool)> op) {\\n        it++; // skip \\'(\\'\\n        while (true) {\\n            auto b = parse(it);\\n            init = op(init, b);\\n            if (*it == \\')\\') break;\\n            it++; // skip \\',\\'\\n        }\\n        it++; // skip \\')\\'\\n        return init;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 323367,
                "title": "python-short-solution-using-stack",
                "content": "The idea is as follows:\\n\\n1. When encountering a \"t\" or \"f\", we evaluate it right away\\n2. If its not t or f, then it has to be an operator. In which case, we evaluate everything between \\'(\\' and \\')\\' using recursion and by storing them in a stack.\\n3. once we encounter \\')\\', we simply evaluate &, | and ! by evaluating the operands stored in the stack.\\n4. The one good pattern to follow is, once we finish evaluating a particular expression, we also return the index i+1, to the caller, so that the high level caller can continue evaluating other expressions from this returned index.\\n```\\ndef parseBoolExpr(self, e: str) -> bool:\\n        def ev(i):\\n            if e[i] in [\"t\", \"f\"]:\\n                return True if e[i] == \"t\" else False, i+1\\n            op = e[i]\\n            i, st = i+2, []\\n            while e[i] != \\')\\':\\n                if e[i] == \\',\\': \\n                    i += 1\\n                    continue\\n                res, i = ev(i)\\n                st.append(res)\\n            if op == \\'&\\':\\n                return all(st), i+1\\n            elif op == \\'|\\':\\n                return any(st), i+1\\n            elif op == \\'!\\':\\n                return not st[0], i+1\\n        res, i = ev(0)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\ndef parseBoolExpr(self, e: str) -> bool:\\n        def ev(i):\\n            if e[i] in [\"t\", \"f\"]:\\n                return True if e[i] == \"t\" else False, i+1\\n            op = e[i]\\n            i, st = i+2, []\\n            while e[i] != \\')\\':\\n                if e[i] == \\',\\': \\n                    i += 1\\n                    continue\\n                res, i = ev(i)\\n                st.append(res)\\n            if op == \\'&\\':\\n                return all(st), i+1\\n            elif op == \\'|\\':\\n                return any(st), i+1\\n            elif op == \\'!\\':\\n                return not st[0], i+1\\n        res, i = ev(0)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 685663,
                "title": "python-easy-stack-solution",
                "content": "```\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        func = {\\'&\\' : all, \\'|\\' : any, \\'!\\' : lambda x : not x[0]}\\n        \\n        stack = []\\n        for c in expression:\\n            if c in func:\\n                stack.append(func[c])\\n            elif c == \\'(\\':\\n                stack.append(\\'(\\')\\n            elif c == \\'f\\':\\n                stack.append(False)\\n            elif c == \\'t\\':\\n                stack.append(True)\\n                \\n            elif c == \\')\\':\\n                ss = []\\n                while stack[-1] != \\'(\\':\\n                    ss.append(stack.pop())\\n                stack.pop()\\n                stack.append(stack.pop()(ss))\\n\\n        return stack.pop()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        func = {\\'&\\' : all, \\'|\\' : any, \\'!\\' : lambda x : not x[0]}\\n        \\n        stack = []\\n        for c in expression:\\n            if c in func:\\n                stack.append(func[c])\\n            elif c == \\'(\\':\\n                stack.append(\\'(\\')\\n            elif c == \\'f\\':\\n                stack.append(False)\\n            elif c == \\'t\\':\\n                stack.append(True)\\n                \\n            elif c == \\')\\':\\n                ss = []\\n                while stack[-1] != \\'(\\':\\n                    ss.append(stack.pop())\\n                stack.pop()\\n                stack.append(stack.pop()(ss))\\n\\n        return stack.pop()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 548688,
                "title": "java-clean-code-with-iterative-approach-using-stack",
                "content": "```java\\npublic boolean parseBoolExpr(String expression) {\\n\\tif (expression == null || expression.length() == 0) return false;\\n\\n\\tStack<Character> ops = new Stack<>();\\n\\tStack<Boolean> operands = new Stack<>();\\n\\n\\tfor (int i = 0; i < expression.length(); i++) {\\n\\t\\tchar ch = expression.charAt(i);\\n\\n\\t\\tif (ch == \\'f\\')\\n\\t\\t\\toperands.push(false);\\n\\t\\telse if (ch == \\'t\\')\\n\\t\\t\\toperands.push(true);\\n\\t\\telse if (ch == \\'(\\')\\n\\t\\t\\toperands.push(null);\\n\\t\\telse if (ch == \\')\\') {\\n\\t\\t\\tchar operator = ops.pop();\\n\\n\\t\\t\\tboolean res = true;\\n\\t\\t\\tif (operator == \\'|\\')\\n\\t\\t\\t\\tres = false;\\n\\n\\t\\t\\twhile (!operands.isEmpty() && operands.peek() != null) {\\n\\t\\t\\t\\tif (operator == \\'|\\') \\n\\t\\t\\t\\t\\tres |= operands.pop();\\n\\t\\t\\t\\telse if (operator == \\'&\\')\\n\\t\\t\\t\\t\\tres &= operands.pop();\\n\\t\\t\\t\\telse if (operator == \\'!\\')\\n\\t\\t\\t\\t\\tres = !operands.pop(); \\n\\t\\t\\t}\\n\\t\\t\\toperands.pop();\\n\\t\\t\\toperands.push(res);\\n\\n\\t\\t} else if (ch == \\',\\') \\n\\t\\t\\tcontinue;\\n\\t\\telse {\\n\\t\\t\\tops.push(ch);\\n\\t\\t}\\n\\t}\\n\\treturn operands.peek();\\n}",
                "solutionTags": [],
                "code": "```java\\npublic boolean parseBoolExpr(String expression) {\\n\\tif (expression == null || expression.length() == 0) return false;\\n\\n\\tStack<Character> ops = new Stack<>();\\n\\tStack<Boolean> operands = new Stack<>();\\n\\n\\tfor (int i = 0; i < expression.length(); i++) {\\n\\t\\tchar ch = expression.charAt(i);\\n\\n\\t\\tif (ch == \\'f\\')\\n\\t\\t\\toperands.push(false);\\n\\t\\telse if (ch == \\'t\\')\\n\\t\\t\\toperands.push(true);\\n\\t\\telse if (ch == \\'(\\')\\n\\t\\t\\toperands.push(null);\\n\\t\\telse if (ch == \\')\\') {\\n\\t\\t\\tchar operator = ops.pop();\\n\\n\\t\\t\\tboolean res = true;\\n\\t\\t\\tif (operator == \\'|\\')\\n\\t\\t\\t\\tres = false;\\n\\n\\t\\t\\twhile (!operands.isEmpty() && operands.peek() != null) {\\n\\t\\t\\t\\tif (operator == \\'|\\') \\n\\t\\t\\t\\t\\tres |= operands.pop();\\n\\t\\t\\t\\telse if (operator == \\'&\\')\\n\\t\\t\\t\\t\\tres &= operands.pop();\\n\\t\\t\\t\\telse if (operator == \\'!\\')\\n\\t\\t\\t\\t\\tres = !operands.pop(); \\n\\t\\t\\t}\\n\\t\\t\\toperands.pop();\\n\\t\\t\\toperands.push(res);\\n\\n\\t\\t} else if (ch == \\',\\') \\n\\t\\t\\tcontinue;\\n\\t\\telse {\\n\\t\\t\\tops.push(ch);\\n\\t\\t}\\n\\t}\\n\\treturn operands.peek();\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 323341,
                "title": "clean-java-solution",
                "content": "```\\n  public boolean parseBoolExpr(String s) {\\n    if (s.equals(\"t\")) return true;\\n    if (s.equals(\"f\")) return false;\\n    char[] arr = s.toCharArray();\\n    char op = arr[0];\\n    boolean result = op != \\'|\\';\\n    int count = 0;\\n    for (int i = 1, pre = 2; i < arr.length; i++) {\\n      char c = arr[i];\\n      if (c == \\'(\\') count++;\\n      if (c == \\')\\') count--;\\n      if (c == \\',\\' && count == 1 || c == \\')\\' && count == 0) {\\n        boolean next = parseBoolExpr(s.substring(pre, i));\\n        pre = i + 1;\\n        if (op == \\'|\\') result |= next;\\n        else if (op == \\'&\\') result &= next;\\n        else result = !next;\\n      }\\n    }\\n    return result;\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\n  public boolean parseBoolExpr(String s) {\\n    if (s.equals(\"t\")) return true;\\n    if (s.equals(\"f\")) return false;\\n    char[] arr = s.toCharArray();\\n    char op = arr[0];\\n    boolean result = op != \\'|\\';\\n    int count = 0;\\n    for (int i = 1, pre = 2; i < arr.length; i++) {\\n      char c = arr[i];\\n      if (c == \\'(\\') count++;\\n      if (c == \\')\\') count--;\\n      if (c == \\',\\' && count == 1 || c == \\')\\' && count == 0) {\\n        boolean next = parseBoolExpr(s.substring(pre, i));\\n        pre = i + 1;\\n        if (op == \\'|\\') result |= next;\\n        else if (op == \\'&\\') result &= next;\\n        else result = !next;\\n      }\\n    }\\n    return result;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1366561,
                "title": "c-two-stacks-with-intuition",
                "content": "## Basic Idea of Question\\nThis question is basically a prefix expression evaluation question, with a small modification to include more than two arguments to operands.\\nSo now each operand is followed by a pair of parenthesis, which contain the arguments to the operand separated by commas (,).\\nWe are guaranteed to get a valid expression, so we can avoid doing many preliminary checks like parenthesis matching and number of arguments for each operand, and instead focus on implementing this multi argument system.\\n<br/>\\n## Approach\\nWe start off with the basic solution, with two stacks, one for the operands, and one for the operators and other symbols. For each operand, we have a pair of parenthesis after it, which contains its arguments. So when we encounter any operator (&, ! or |) we just push it to the operators stack. For \\'t\\' or \\'f\\' we push the corresponding boolean value on the operands stack. When we encounter an open bracket we again push it to the operators stack. The same with commas (,). The interesting and most important case is that of the closing bracket ( **\\')\\'** ).\\nHere we need to evaluate the expression uptil the nearest open bracket and push the result onto the operands stack.\\n\\nWe keep pushing the operators stack until we reach an open bracket, counting the number of commas in between. The operator just after it on the stack will be the operator which has all the current arguments. The number of arguments of the operator is given by ```commas + 1```, and we pop that many operands from the stack, performing the required operation on them.\\n\\nFor the & operation, we start from a result of ```true```, since **```true & a = a.```**. Similarly for | operation, we start with a result of ```false``` since **```false | a = a```**. For the ! operation, we don\\'t need to go into the loop, since we know it only has one operand, and hence we handle it separately and then continue to the next iteration.\\n\\nThis method of evaluating closed brackets first guarantees that whenever we iterate backwards to evaluate the expression, the expression only contains simple operands (true or false) separated by commas, since any other expression would have been evaluated to one of these values by then.\\n\\nAt the end of the iteration, we are left with only one operand on the operands stack and that is the result of the entire expression. We return it.\\n<br/>\\n## Code\\n```\\nbool parseBoolExpr(string expression) {\\n\\tint n = expression.size();\\n\\tstack<bool> operands;\\n\\tstack<char> operators;\\n\\tfor(int i = 0; i<n; i++) {\\n\\t\\tif(expression[i] == \\'!\\' || expression[i] == \\'&\\' || expression[i] == \\'|\\' || expression[i] == \\'(\\' || expression[i] == \\',\\') {\\n\\t\\t\\toperators.push(expression[i]);\\n\\t\\t}\\n\\t\\telse if(expression[i] == \\'t\\' || expression[i] == \\'f\\') {\\n\\t\\t\\tif(expression[i] == \\'t\\') operands.push(true);\\n\\t\\t\\telse operands.push(false);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t// \\')\\'\\n\\t\\t\\tint commas = 0;\\n\\t\\t\\twhile(operators.top() != \\'(\\') {\\n\\t\\t\\t\\tchar curr_op =  operators.top();\\n\\t\\t\\t\\toperators.pop();\\n\\t\\t\\t\\tif(curr_op == \\',\\') commas++;\\n\\t\\t\\t}\\n\\t\\t\\toperators.pop();\\n\\t\\t\\tchar curr_op = operators.top();\\n\\t\\t\\toperators.pop();\\n\\t\\t\\tbool result;\\n\\t\\t\\tif(curr_op == \\'!\\') {\\n\\t\\t\\t\\tresult = !operands.top();\\n\\t\\t\\t\\toperands.pop();\\n\\t\\t\\t\\toperands.push(result);\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\telse if(curr_op == \\'&\\') {\\n\\t\\t\\t\\tresult = true;\\n\\t\\t\\t}\\n\\t\\t\\telse if(curr_op == \\'|\\') {\\n\\t\\t\\t\\tresult = false;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i = 0; i<=commas; i++) {\\n\\t\\t\\t\\t//number of commas + 1\\n\\t\\t\\t\\tif(curr_op == \\'&\\') {\\n\\t\\t\\t\\t\\tresult &= operands.top();\\n\\t\\t\\t\\t\\toperands.pop();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(curr_op == \\'|\\') {\\n\\t\\t\\t\\t\\tresult |= operands.top();\\n\\t\\t\\t\\t\\toperands.pop();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\toperands.push(result);\\n\\t\\t}\\n\\t}\\n\\treturn operands.top();\\n}\\n```\\n<br/>\\n\\n## Complexity\\n**Time: O(n)** as every element is iterated over twice, first during the storage phase, and another time while evaluating the expression.\\n**Space: O(n)** which is the stack space required for two stacks.\\n\\nActually the time complexity is proportional to the number of sub expressions to evaluate, which is almost equal to n.\\n<br/>\\nPlease upvote the post if you liked it, and feel free to ask any doubts or suggest any corrections/improvements in the comments.",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```commas + 1```\n```true```\n```true & a = a.```\n```false```\n```false | a = a```\n```\\nbool parseBoolExpr(string expression) {\\n\\tint n = expression.size();\\n\\tstack<bool> operands;\\n\\tstack<char> operators;\\n\\tfor(int i = 0; i<n; i++) {\\n\\t\\tif(expression[i] == \\'!\\' || expression[i] == \\'&\\' || expression[i] == \\'|\\' || expression[i] == \\'(\\' || expression[i] == \\',\\') {\\n\\t\\t\\toperators.push(expression[i]);\\n\\t\\t}\\n\\t\\telse if(expression[i] == \\'t\\' || expression[i] == \\'f\\') {\\n\\t\\t\\tif(expression[i] == \\'t\\') operands.push(true);\\n\\t\\t\\telse operands.push(false);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t// \\')\\'\\n\\t\\t\\tint commas = 0;\\n\\t\\t\\twhile(operators.top() != \\'(\\') {\\n\\t\\t\\t\\tchar curr_op =  operators.top();\\n\\t\\t\\t\\toperators.pop();\\n\\t\\t\\t\\tif(curr_op == \\',\\') commas++;\\n\\t\\t\\t}\\n\\t\\t\\toperators.pop();\\n\\t\\t\\tchar curr_op = operators.top();\\n\\t\\t\\toperators.pop();\\n\\t\\t\\tbool result;\\n\\t\\t\\tif(curr_op == \\'!\\') {\\n\\t\\t\\t\\tresult = !operands.top();\\n\\t\\t\\t\\toperands.pop();\\n\\t\\t\\t\\toperands.push(result);\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\telse if(curr_op == \\'&\\') {\\n\\t\\t\\t\\tresult = true;\\n\\t\\t\\t}\\n\\t\\t\\telse if(curr_op == \\'|\\') {\\n\\t\\t\\t\\tresult = false;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i = 0; i<=commas; i++) {\\n\\t\\t\\t\\t//number of commas + 1\\n\\t\\t\\t\\tif(curr_op == \\'&\\') {\\n\\t\\t\\t\\t\\tresult &= operands.top();\\n\\t\\t\\t\\t\\toperands.pop();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(curr_op == \\'|\\') {\\n\\t\\t\\t\\t\\tresult |= operands.top();\\n\\t\\t\\t\\t\\toperands.pop();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\toperands.push(result);\\n\\t\\t}\\n\\t}\\n\\treturn operands.top();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 323709,
                "title": "java-c-python-concise-straightforward-stack-no-recursion",
                "content": "**Java**\\n```\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        Stack<Character> stack = new Stack<Character>(), cache = new Stack<Character>();\\n        for (char c: expression.toCharArray()) {\\n            if (c == \\')\\') {\\n                cache.clear();\\n                while (stack.peek() != \\'(\\')\\n                    cache.push(stack.pop());\\n                stack.pop();\\n                char cur = stack.pop();\\n                if (cur == \\'&\\')\\n                    stack.push(cache.contains(\\'f\\') ? \\'f\\':\\'t\\');\\n                else if (cur == \\'|\\')\\n                    stack.push(cache.contains(\\'t\\') ? \\'t\\':\\'f\\');\\n                else\\n                    stack.push(cache.pop() == \\'t\\' ? \\'f\\': \\'t\\');\\n            }\\n            else if (c != \\',\\')\\n                stack.push(c);\\n        }\\n        return stack.pop() == \\'t\\' ? true: false;\\n    }\\n}\\n```\\n**C#**\\n```\\npublic class Solution {\\n    public bool ParseBoolExpr(string expression) {\\n        Stack<char> stack = new Stack<char>(), cache = new Stack<char>();\\n        foreach(char c in expression) {\\n            if (c == \\')\\') {\\n                cache.Clear();\\n                while (stack.Peek() != \\'(\\')\\n                    cache.Push(stack.Pop());\\n                stack.Pop();\\n                char cur = stack.Pop();\\n                if (cur == \\'&\\')\\n                    stack.Push(cache.Contains(\\'f\\') ? \\'f\\':\\'t\\');\\n                else if (cur == \\'|\\')\\n                    stack.Push(cache.Contains(\\'t\\') ? \\'t\\':\\'f\\');\\n                else\\n                    stack.Push(cache.Pop() == \\'t\\' ? \\'f\\': \\'t\\');\\n            }\\n            else if (c != \\',\\')\\n                stack.Push(c);\\n        }\\n        return stack.Pop() == \\'t\\' ? true: false;\\n    }\\n}\\n\\n```\\n**Python**\\n```\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        stack = []\\n        for c in expression:\\n            if c == \\')\\':\\n                cache = []\\n                while stack[-1] != \\'(\\':\\n                    cache.append(stack.pop())\\n                stack.pop()\\n                cur = stack.pop()\\n                stack.append(all(cache) if cur == \\'&\\' else any(cache) if cur == \\'|\\' else not cache.pop())\\n            elif c != \\',\\':\\n                stack.append(True if c == \\'t\\' else False if c == \\'f\\' else c)\\n        return stack.pop()        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        Stack<Character> stack = new Stack<Character>(), cache = new Stack<Character>();\\n        for (char c: expression.toCharArray()) {\\n            if (c == \\')\\') {\\n                cache.clear();\\n                while (stack.peek() != \\'(\\')\\n                    cache.push(stack.pop());\\n                stack.pop();\\n                char cur = stack.pop();\\n                if (cur == \\'&\\')\\n                    stack.push(cache.contains(\\'f\\') ? \\'f\\':\\'t\\');\\n                else if (cur == \\'|\\')\\n                    stack.push(cache.contains(\\'t\\') ? \\'t\\':\\'f\\');\\n                else\\n                    stack.push(cache.pop() == \\'t\\' ? \\'f\\': \\'t\\');\\n            }\\n            else if (c != \\',\\')\\n                stack.push(c);\\n        }\\n        return stack.pop() == \\'t\\' ? true: false;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public bool ParseBoolExpr(string expression) {\\n        Stack<char> stack = new Stack<char>(), cache = new Stack<char>();\\n        foreach(char c in expression) {\\n            if (c == \\')\\') {\\n                cache.Clear();\\n                while (stack.Peek() != \\'(\\')\\n                    cache.Push(stack.Pop());\\n                stack.Pop();\\n                char cur = stack.Pop();\\n                if (cur == \\'&\\')\\n                    stack.Push(cache.Contains(\\'f\\') ? \\'f\\':\\'t\\');\\n                else if (cur == \\'|\\')\\n                    stack.Push(cache.Contains(\\'t\\') ? \\'t\\':\\'f\\');\\n                else\\n                    stack.Push(cache.Pop() == \\'t\\' ? \\'f\\': \\'t\\');\\n            }\\n            else if (c != \\',\\')\\n                stack.Push(c);\\n        }\\n        return stack.Pop() == \\'t\\' ? true: false;\\n    }\\n}\\n\\n```\n```\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        stack = []\\n        for c in expression:\\n            if c == \\')\\':\\n                cache = []\\n                while stack[-1] != \\'(\\':\\n                    cache.append(stack.pop())\\n                stack.pop()\\n                cur = stack.pop()\\n                stack.append(all(cache) if cur == \\'&\\' else any(cache) if cur == \\'|\\' else not cache.pop())\\n            elif c != \\',\\':\\n                stack.append(True if c == \\'t\\' else False if c == \\'f\\' else c)\\n        return stack.pop()        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 356016,
                "title": "c-easy-understanding-stack-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n        stack<char> pac;\\n        for(char ch :expression) {\\n            if(ch == \\',\\') continue;\\n            else if(ch == \\')\\') helper(pac);\\n            else pac.push(ch);\\n        }\\n        return pac.top() == \\'t\\'? true :false ;\\n    }\\n    void helper(stack<char> & pac) {\\n        bool hasf = false;\\n        bool hast = false;\\n        while(pac.top()!=\\'(\\') {\\n            char e = pac.top();\\n            pac.pop();  \\n            if(e == \\'t\\') hast= true;\\n            if(e == \\'f\\') hasf= true;\\n        }\\n        pac.pop();\\n        char exp = pac.top();\\n        pac.pop();\\n        if(exp == \\'!\\') pac.push (hasf? \\'t\\' : \\'f\\');\\n        if(exp == \\'&\\') pac.push (!hasf? \\'t\\' : \\'f\\');\\n        if(exp == \\'|\\') pac.push (hast? \\'t\\' : \\'f\\');\\n    }\\n};\\n````\\ntime O(N)  - one iteration through string  (n) , meanwhile deal with the stack still O(n)\\nspace O(N)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n        stack<char> pac;\\n        for(char ch :expression) {\\n            if(ch == \\',\\') continue;\\n            else if(ch == \\')\\') helper(pac);\\n            else pac.push(ch);\\n        }\\n        return pac.top() == \\'t\\'? true :false ;\\n    }\\n    void helper(stack<char> & pac) {\\n        bool hasf = false;\\n        bool hast = false;\\n        while(pac.top()!=\\'(\\') {\\n            char e = pac.top();\\n            pac.pop();  \\n            if(e == \\'t\\') hast= true;\\n            if(e == \\'f\\') hasf= true;\\n        }\\n        pac.pop();\\n        char exp = pac.top();\\n        pac.pop();\\n        if(exp == \\'!\\') pac.push (hasf? \\'t\\' : \\'f\\');\\n        if(exp == \\'&\\') pac.push (!hasf? \\'t\\' : \\'f\\');\\n        if(exp == \\'|\\') pac.push (hast? \\'t\\' : \\'f\\');\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2451429,
                "title": "c-stack",
                "content": "* `find` evaluate the net result of expression.\\n* For  `&` , one false is enough to determine the result (False).\\n* For  `|` , one true is enough to determine the result (True).\\n* For `\\'!\\'`, invert true or false.  \\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool OPERATOR(char ch){\\n        return (ch == \\'&\\' || ch == \\'|\\' || ch == \\'&\\' || ch == \\'!\\') ;\\n    }\\n    \\n    char find(int T , int F , char op){\\n        if(op == \\'!\\') return T ? \\'f\\' : \\'t\\' ;\\n        else if(op == \\'|\\') return T ? \\'t\\' : \\'f\\' ;\\n        else if(op == \\'&\\') return F ? \\'f\\' : \\'t\\' ;\\n        return \\'a\\' ;\\n    }\\n    bool parseBoolExpr(string exp) {\\n        stack<char> st ;\\n        for(int i = 0 ; i < exp.size() ; ++i ){\\n            if(exp[i] == \\',\\') continue ;\\n            \\n            if(OPERATOR(exp[i]) || exp[i] == \\'t\\' || exp[i] == \\'f\\' || exp[i] == \\'(\\') st.push(exp[i]) ;\\n            else if(exp[i] == \\')\\'){\\n                //evaluate and push to top\\n                int T = 0 , F = 0 ;\\n                char op ;\\n                while(st.size() and st.top() != \\'(\\'){\\n                    if(st.top() == \\'t\\') ++T ;\\n                    else if(st.top() == \\'f\\') ++F ;\\n                    st.pop() ;\\n                }\\n                st.pop() ; //remove the opening bracket \\n                op = st.top() ; st.pop() ; //just begin the bracket the operator will be there\\n                st.push(find(T,F,op)) ;\\n            }\\n        }   \\n        return st.top() == \\'t\\' ? ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool OPERATOR(char ch){\\n        return (ch == \\'&\\' || ch == \\'|\\' || ch == \\'&\\' || ch == \\'!\\') ;\\n    }\\n    \\n    char find(int T , int F , char op){\\n        if(op == \\'!\\') return T ? \\'f\\' : \\'t\\' ;\\n        else if(op == \\'|\\') return T ? \\'t\\' : \\'f\\' ;\\n        else if(op == \\'&\\') return F ? \\'f\\' : \\'t\\' ;\\n        return \\'a\\' ;\\n    }\\n    bool parseBoolExpr(string exp) {\\n        stack<char> st ;\\n        for(int i = 0 ; i < exp.size() ; ++i ){\\n            if(exp[i] == \\',\\') continue ;\\n            \\n            if(OPERATOR(exp[i]) || exp[i] == \\'t\\' || exp[i] == \\'f\\' || exp[i] == \\'(\\') st.push(exp[i]) ;\\n            else if(exp[i] == \\')\\'){\\n                //evaluate and push to top\\n                int T = 0 , F = 0 ;\\n                char op ;\\n                while(st.size() and st.top() != \\'(\\'){\\n                    if(st.top() == \\'t\\') ++T ;\\n                    else if(st.top() == \\'f\\') ++F ;\\n                    st.pop() ;\\n                }\\n                st.pop() ; //remove the opening bracket \\n                op = st.top() ; st.pop() ; //just begin the bracket the operator will be there\\n                st.push(find(T,F,op)) ;\\n            }\\n        }   \\n        return st.top() == \\'t\\' ? ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2353598,
                "title": "java-simulation-with-stacks-clean-code",
                "content": "Convert it to infix notation and simulate it. All the `,` becomes the operator that came before it.\\nFor example\\n```\\n\"|(t,f,f)\" -> (true | false | false)\\n\"!(t)\" -> (!true)\\n```\\n\\n#### Java\\n```Java\\n// Time O(n)\\n// Space O(n)\\n// https://en.wikipedia.org/wiki/Shunting_yard_algorithm\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        Deque<Boolean> stack = new ArrayDeque<>(); // store the computational result\\n        Deque<Character> op = new ArrayDeque<>();  // store the pending operators\\n        Deque<Character> p  = new ArrayDeque<>();  // store the operator for the current level.\\n        for (char ch : expression.toCharArray()){\\n            switch(ch){\\n                case \\'!\\', \\'&\\', \\'|\\' -> p.push(ch); // enter a new level, update the current operator.\\n                case \\'f\\', \\'t\\' -> stack.push(ch == \\'t\\'); // leaf node, push true or false directly into the stack\\n                case \\'(\\' -> {op.push(ch); if (p.peek() == \\'!\\') op.push(\\'!\\');} // Add ! if the current lvl operator is !\\n                case \\')\\' -> {go(op, stack); op.pop(); p.pop();} // process pending operators and pop off top items from op [\\'(\\'] and p (lvl ended).\\n                default  -> {go(op, stack); op.push(p.peek());} // process pending operators and push current operator onto op.\\n            };\\n        }\\n        go(op, stack); // process remaining operators.\\n        return stack.pop(); // It is guaranteed that there will only be 1 element left on the stack - that\\'s the answer.\\n    }\\n\\n    private void go(Deque<Character> op, Deque<Boolean> stack){\\n        while(!op.isEmpty() && op.peek() != \\'(\\'){\\n            switch(op.pop()){\\n                case \\'|\\' -> stack.push(stack.pop() | stack.pop());\\n                case \\'&\\' -> stack.push(stack.pop() & stack.pop());\\n                default  -> stack.push(!stack.pop());\\n            };\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\"|(t,f,f)\" -> (true | false | false)\\n\"!(t)\" -> (!true)\\n```\n```Java\\n// Time O(n)\\n// Space O(n)\\n// https://en.wikipedia.org/wiki/Shunting_yard_algorithm\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        Deque<Boolean> stack = new ArrayDeque<>(); // store the computational result\\n        Deque<Character> op = new ArrayDeque<>();  // store the pending operators\\n        Deque<Character> p  = new ArrayDeque<>();  // store the operator for the current level.\\n        for (char ch : expression.toCharArray()){\\n            switch(ch){\\n                case \\'!\\', \\'&\\', \\'|\\' -> p.push(ch); // enter a new level, update the current operator.\\n                case \\'f\\', \\'t\\' -> stack.push(ch == \\'t\\'); // leaf node, push true or false directly into the stack\\n                case \\'(\\' -> {op.push(ch); if (p.peek() == \\'!\\') op.push(\\'!\\');} // Add ! if the current lvl operator is !\\n                case \\')\\' -> {go(op, stack); op.pop(); p.pop();} // process pending operators and pop off top items from op [\\'(\\'] and p (lvl ended).\\n                default  -> {go(op, stack); op.push(p.peek());} // process pending operators and push current operator onto op.\\n            };\\n        }\\n        go(op, stack); // process remaining operators.\\n        return stack.pop(); // It is guaranteed that there will only be 1 element left on the stack - that\\'s the answer.\\n    }\\n\\n    private void go(Deque<Character> op, Deque<Boolean> stack){\\n        while(!op.isEmpty() && op.peek() != \\'(\\'){\\n            switch(op.pop()){\\n                case \\'|\\' -> stack.push(stack.pop() | stack.pop());\\n                case \\'&\\' -> stack.push(stack.pop() & stack.pop());\\n                default  -> stack.push(!stack.pop());\\n            };\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1916944,
                "title": "c-easy-understanding-stack",
                "content": "1> make a stack;\\n2> We don\\'t need \\'(\\' and \\',\\' for calculation;\\n3> rest push everything in stack;\\n4> we will start evaluating the expression when we encounter \\')\\' and push the result back in stack;\\n  a> while evaluating the expression we just need to check if we encoundered one true and one false;\\n  \\n\\n```\\nbool parseBoolExpr(string e) {\\n        stack<char> s;\\n        for(auto x:e){\\n            if(x==\\'(\\' || x==\\',\\') continue;\\n            if(x==\\')\\'){\\n                bool t = false;\\n                bool f = false;\\n                while(s.top() == \\'t\\' || s.top() == \\'f\\'){\\n                    if(s.top() == \\'t\\') t = true;\\n                    if(s.top() == \\'f\\') f = true;\\n                    s.pop();\\n                }\\n                \\n                char ex = s.top();\\n                s.pop();\\n                char p;\\n                if(ex==\\'&\\'){\\n                    p=f?\\'f\\':\\'t\\';\\n                }\\n                else if(ex==\\'|\\'){\\n                    p=t?\\'t\\':\\'f\\';\\n                }\\n                else{\\n                    p=t?\\'f\\':\\'t\\';\\n                }\\n                s.push(p);\\n                continue;\\n            }\\n            s.push(x);\\n        }\\n        return s.top()==\\'t\\'? true:false;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nbool parseBoolExpr(string e) {\\n        stack<char> s;\\n        for(auto x:e){\\n            if(x==\\'(\\' || x==\\',\\') continue;\\n            if(x==\\')\\'){\\n                bool t = false;\\n                bool f = false;\\n                while(s.top() == \\'t\\' || s.top() == \\'f\\'){\\n                    if(s.top() == \\'t\\') t = true;\\n                    if(s.top() == \\'f\\') f = true;\\n                    s.pop();\\n                }\\n                \\n                char ex = s.top();\\n                s.pop();\\n                char p;\\n                if(ex==\\'&\\'){\\n                    p=f?\\'f\\':\\'t\\';\\n                }\\n                else if(ex==\\'|\\'){\\n                    p=t?\\'t\\':\\'f\\';\\n                }\\n                else{\\n                    p=t?\\'f\\':\\'t\\';\\n                }\\n                s.push(p);\\n                continue;\\n            }\\n            s.push(x);\\n        }\\n        return s.top()==\\'t\\'? true:false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1582694,
                "title": "one-pass-with-stack-97-speed",
                "content": "![image](https://assets.leetcode.com/users/images/d5ac6556-04fd-440f-9d02-5cc63bc7e299_1637142671.9336207.png)\\n```\\nclass Solution:\\n    operands = {\"!\", \"&\", \"|\", \"t\", \"f\"}\\n    values = {\"t\", \"f\"}\\n\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        stack = []\\n        for c in expression:\\n            if c == \")\":\\n                val = stack.pop()\\n                args = set()\\n                while val in Solution.values:\\n                    args.add(val)\\n                    val = stack.pop()\\n                if val == \"!\":\\n                    stack.append(\"f\" if \"t\" in args else \"t\")\\n                elif val == \"&\":\\n                    stack.append(\"f\" if \"f\" in args else \"t\")\\n                elif val == \"|\":\\n                    stack.append(\"t\" if \"t\" in args else \"f\")\\n            elif c in Solution.operands:\\n                stack.append(c)\\n        return stack[0] == \"t\"\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    operands = {\"!\", \"&\", \"|\", \"t\", \"f\"}\\n    values = {\"t\", \"f\"}\\n\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        stack = []\\n        for c in expression:\\n            if c == \")\":\\n                val = stack.pop()\\n                args = set()\\n                while val in Solution.values:\\n                    args.add(val)\\n                    val = stack.pop()\\n                if val == \"!\":\\n                    stack.append(\"f\" if \"t\" in args else \"t\")\\n                elif val == \"&\":\\n                    stack.append(\"f\" if \"f\" in args else \"t\")\\n                elif val == \"|\":\\n                    stack.append(\"t\" if \"t\" in args else \"f\")\\n            elif c in Solution.operands:\\n                stack.append(c)\\n        return stack[0] == \"t\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1573286,
                "title": "java-simple-and-short-solution-using-stack",
                "content": "```\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        Stack<Character> stack = new Stack<Character>();\\n        for (char c : expression.toCharArray()) {\\n            if (c != \\')\\')\\n                stack.push(c);\\n            else {\\n                boolean hasTrue = false, hasFalse = false;\\n                while (stack.peek() != \\'(\\') {\\n                    char ch = stack.pop();\\n                    if (ch == \\'f\\')\\n                        hasFalse = true;\\n                    else if (ch == \\'t\\')\\n                        hasTrue = true;\\n                }\\n                stack.pop();\\n                char symbol = stack.pop();\\n                if (symbol == \\'&\\') {\\n                    if (hasFalse)\\n                        stack.push(\\'f\\');\\n                    else\\n                        stack.push(\\'t\\');\\n                }\\n                else if (symbol == \\'|\\') {\\n                    if (hasTrue)\\n                        stack.push(\\'t\\');\\n                    else\\n                        stack.push(\\'f\\');\\n                }\\n                else {\\n                    if (hasTrue)\\n                        stack.push(\\'f\\');\\n                    else\\n                        stack.push(\\'t\\');\\n                }\\n            }\\n        }\\n        return (stack.pop() == \\'t\\') ? true : false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        Stack<Character> stack = new Stack<Character>();\\n        for (char c : expression.toCharArray()) {\\n            if (c != \\')\\')\\n                stack.push(c);\\n            else {\\n                boolean hasTrue = false, hasFalse = false;\\n                while (stack.peek() != \\'(\\') {\\n                    char ch = stack.pop();\\n                    if (ch == \\'f\\')\\n                        hasFalse = true;\\n                    else if (ch == \\'t\\')\\n                        hasTrue = true;\\n                }\\n                stack.pop();\\n                char symbol = stack.pop();\\n                if (symbol == \\'&\\') {\\n                    if (hasFalse)\\n                        stack.push(\\'f\\');\\n                    else\\n                        stack.push(\\'t\\');\\n                }\\n                else if (symbol == \\'|\\') {\\n                    if (hasTrue)\\n                        stack.push(\\'t\\');\\n                    else\\n                        stack.push(\\'f\\');\\n                }\\n                else {\\n                    if (hasTrue)\\n                        stack.push(\\'f\\');\\n                    else\\n                        stack.push(\\'t\\');\\n                }\\n            }\\n        }\\n        return (stack.pop() == \\'t\\') ? true : false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1522838,
                "title": "c-o-n-time-stack-iterative",
                "content": "```\\nclass Solution {\\npublic:\\n    char evaluate(stack<char>&s){\\n        bool has_true=false;\\n        bool has_false=false;\\n        while(s.top()!=\\'&\\' && s.top()!=\\'!\\' && s.top()!=\\'|\\'){\\n            if(s.top()==\\'t\\')\\n                has_true=true;\\n            else\\n                has_false=true;\\n            s.pop();\\n        }\\n        if(s.top()==\\'&\\'){\\n            if(has_false==false)\\n                return \\'t\\';\\n        }\\n        else if(s.top()==\\'!\\'){\\n            if(has_false==true)\\n                return \\'t\\';\\n        }\\n        else{\\n            if(has_true==true)\\n                return \\'t\\';\\n        }\\n        return \\'f\\';\\n    }\\n    bool parseBoolExpr(string expression) {\\n        stack<char>s;\\n        for(auto ch:expression){\\n            if(ch!=\\')\\' && ch!=\\'(\\' && ch!=\\',\\')\\n                s.push(ch);\\n            if(ch==\\')\\'){\\n                char temp=evaluate(s);\\n                s.pop();\\n                s.push(temp);\\n            }\\n        }\\n        return s.top()==\\'t\\'?true:false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char evaluate(stack<char>&s){\\n        bool has_true=false;\\n        bool has_false=false;\\n        while(s.top()!=\\'&\\' && s.top()!=\\'!\\' && s.top()!=\\'|\\'){\\n            if(s.top()==\\'t\\')\\n                has_true=true;\\n            else\\n                has_false=true;\\n            s.pop();\\n        }\\n        if(s.top()==\\'&\\'){\\n            if(has_false==false)\\n                return \\'t\\';\\n        }\\n        else if(s.top()==\\'!\\'){\\n            if(has_false==true)\\n                return \\'t\\';\\n        }\\n        else{\\n            if(has_true==true)\\n                return \\'t\\';\\n        }\\n        return \\'f\\';\\n    }\\n    bool parseBoolExpr(string expression) {\\n        stack<char>s;\\n        for(auto ch:expression){\\n            if(ch!=\\')\\' && ch!=\\'(\\' && ch!=\\',\\')\\n                s.push(ch);\\n            if(ch==\\')\\'){\\n                char temp=evaluate(s);\\n                s.pop();\\n                s.push(temp);\\n            }\\n        }\\n        return s.top()==\\'t\\'?true:false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 354946,
                "title": "java-oop-solution-inspired-by-aahmedov",
                "content": "Concept Idea Post: https://leetcode.com/problems/parsing-a-boolean-expression/discuss/343700/Java-OOP-Solution\\n\\n```\\nclass Solution{\\n    public boolean parseBoolExpr(String expression) {\\n        Stack<Expr> stack = new Stack<>();\\n        char[] chars = expression.toCharArray();\\n\\n        for(int i = 0; i < chars.length; i ++) {\\n            if(chars[i] == \\'!\\')\\n                stack.push(new Not());\\n            else if(chars[i] == \\'&\\')\\n                stack.push(new And());\\n            else if(chars[i] == \\'|\\')\\n                stack.push(new Or());\\n            else if(chars[i] == \\'t\\')\\n                stack.peek().add(true);\\n            else if(chars[i] == \\'f\\')\\n                stack.peek().add(false);\\n            else if(chars[i] == \\')\\'){\\n                boolean curr = stack.pop().eval();\\n\\n                if(stack.isEmpty())\\n                    return curr;\\n\\n                stack.peek().add(curr);\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    private abstract class Expr {\\n        List<Boolean> list;\\n\\n        public Expr(){\\n            list = new ArrayList<>();\\n        }\\n\\n        public void add(boolean b) {\\n            list.add(b);\\n        }\\n\\n        public abstract boolean eval();\\n    }\\n\\n    private class And extends Expr {\\n        public boolean eval(){\\n            for(int i = 0; i < list.size(); i ++) {\\n                if(!list.get(i))\\n                    return false;\\n            }\\n\\n            return true;\\n        }\\n    }\\n\\n    private class Or extends Expr {\\n        public boolean eval(){\\n            for(int i = 0; i < list.size(); i ++) {\\n                if(list.get(i))\\n                    return true;\\n            }\\n\\n            return false;\\n        }\\n    }\\n\\n    private class Not extends Expr {\\n        public boolean eval(){\\n            return !list.get(0);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution{\\n    public boolean parseBoolExpr(String expression) {\\n        Stack<Expr> stack = new Stack<>();\\n        char[] chars = expression.toCharArray();\\n\\n        for(int i = 0; i < chars.length; i ++) {\\n            if(chars[i] == \\'!\\')\\n                stack.push(new Not());\\n            else if(chars[i] == \\'&\\')\\n                stack.push(new And());\\n            else if(chars[i] == \\'|\\')\\n                stack.push(new Or());\\n            else if(chars[i] == \\'t\\')\\n                stack.peek().add(true);\\n            else if(chars[i] == \\'f\\')\\n                stack.peek().add(false);\\n            else if(chars[i] == \\')\\'){\\n                boolean curr = stack.pop().eval();\\n\\n                if(stack.isEmpty())\\n                    return curr;\\n\\n                stack.peek().add(curr);\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    private abstract class Expr {\\n        List<Boolean> list;\\n\\n        public Expr(){\\n            list = new ArrayList<>();\\n        }\\n\\n        public void add(boolean b) {\\n            list.add(b);\\n        }\\n\\n        public abstract boolean eval();\\n    }\\n\\n    private class And extends Expr {\\n        public boolean eval(){\\n            for(int i = 0; i < list.size(); i ++) {\\n                if(!list.get(i))\\n                    return false;\\n            }\\n\\n            return true;\\n        }\\n    }\\n\\n    private class Or extends Expr {\\n        public boolean eval(){\\n            for(int i = 0; i < list.size(); i ++) {\\n                if(list.get(i))\\n                    return true;\\n            }\\n\\n            return false;\\n        }\\n    }\\n\\n    private class Not extends Expr {\\n        public boolean eval(){\\n            return !list.get(0);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 329879,
                "title": "python3-easy-to-understand-2-stack-solution",
                "content": "Basically, the idea is to maintain two stacks: \\n1. function stack, storing \"|\", \"&\" or \"!\" function objects\\n2. expression stack, storing cooresponding pools (each pool map to one function in the above func list): True of False\\n\\nThen we loop thru the expression:\\n* when encounter function symbol, we push to the func stack\\n* when encounter boolean symbol (i.e. \"t\" or \"f\"), we push to the corresponding pool of expressions\\n* when encounter \")\", it means we need to evaluate our last pool using our last function, then push back to the pool\\n\\nTime: O(n), where n means the length of the expression\\nSpace: O(2n) -> O(n), where we\\'re using two stacks to store the function objects and boolean values\\n\\n```\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        if not expression:\\n            return True\\n        \\n        funcs = [] # stack to store evaluating functions\\n        exprs = [] # stack to store pool(s) of expressions for each eval func in above list\\n        \\n        functions = {\"|\": any, \"!\": lambda x: x[0]^True, \"&\": all}\\n        bools = {\"t\": True, \"f\": False}\\n        \\n        for c in expression:\\n            if c in functions:\\n                exprs.append(list())\\n                funcs.append(functions.get(c)) # append a func obj\\n            elif c in bools:\\n\\t\\t\\t\\tif not len(exprs):\\n\\t\\t\\t\\t\\texprs.append([])\\n                exprs[-1].append(bools.get(c)) # append a bool val\\n            elif c == \")\":\\n                cur = funcs.pop()(exprs.pop())\\n                if len(exprs):\\n                    exprs[-1].append(cur)\\n                else:\\n                    exprs.append([cur])\\n        \\n        return exprs[-1][0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        if not expression:\\n            return True\\n        \\n        funcs = [] # stack to store evaluating functions\\n        exprs = [] # stack to store pool(s) of expressions for each eval func in above list\\n        \\n        functions = {\"|\": any, \"!\": lambda x: x[0]^True, \"&\": all}\\n        bools = {\"t\": True, \"f\": False}\\n        \\n        for c in expression:\\n            if c in functions:\\n                exprs.append(list())\\n                funcs.append(functions.get(c)) # append a func obj\\n            elif c in bools:\\n\\t\\t\\t\\tif not len(exprs):\\n\\t\\t\\t\\t\\texprs.append([])\\n                exprs[-1].append(bools.get(c)) # append a bool val\\n            elif c == \")\":\\n                cur = funcs.pop()(exprs.pop())\\n                if len(exprs):\\n                    exprs[-1].append(cur)\\n                else:\\n                    exprs.append([cur])\\n        \\n        return exprs[-1][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 329224,
                "title": "easy-readable-solution-java-similar-to-polish-notation",
                "content": "```\\npublic boolean parseBoolExpr(String expression) {\\n\\n        Stack<Character> operator = new Stack<>();\\n\\n        for (int i=expression.length()-1;i>=0;i--) {\\n            char c = expression.charAt(i);\\n            if(c==\\')\\' || c==\\'f\\' || c==\\'t\\') {\\n                operator.push(c);\\n            }else if(c==\\'(\\') {\\n                StringBuilder sb = new StringBuilder();\\n                if(i!=0) {\\n                    char op = expression.charAt(i-1);\\n                    while (!operator.empty() && operator.peek()!=\\')\\') {\\n                        char a = operator.pop();\\n                        if(Character.isAlphabetic(a)) {\\n                            sb.append(a);\\n                        }\\n                    }\\n                    operator.pop();\\n                    operator.push(performOperation(sb.toString(), op));\\n                }\\n            }\\n        }\\n\\n        return operator.pop() == \\'t\\';\\n    }\\n\\n    private char performOperation(String s,char op) {\\n        if(op==\\'!\\') {\\n            return s.equals(\"t\")?\\'f\\':\\'t\\';\\n        } else if(op==\\'|\\') {\\n            boolean flag = s.charAt(0) != \\'f\\';\\n            for (int i=1;i<s.length();i++) {\\n                flag = flag | (s.charAt(i) != \\'f\\');\\n            }\\n            return !flag ?\\'f\\':\\'t\\';\\n        } else {\\n            boolean flag = s.charAt(0) != \\'f\\';\\n            for (int i=1;i<s.length();i++) {\\n                flag = flag & (s.charAt(i) != \\'f\\');\\n            }\\n            return !flag ?\\'f\\':\\'t\\';\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean parseBoolExpr(String expression) {\\n\\n        Stack<Character> operator = new Stack<>();\\n\\n        for (int i=expression.length()-1;i>=0;i--) {\\n            char c = expression.charAt(i);\\n            if(c==\\')\\' || c==\\'f\\' || c==\\'t\\') {\\n                operator.push(c);\\n            }else if(c==\\'(\\') {\\n                StringBuilder sb = new StringBuilder();\\n                if(i!=0) {\\n                    char op = expression.charAt(i-1);\\n                    while (!operator.empty() && operator.peek()!=\\')\\') {\\n                        char a = operator.pop();\\n                        if(Character.isAlphabetic(a)) {\\n                            sb.append(a);\\n                        }\\n                    }\\n                    operator.pop();\\n                    operator.push(performOperation(sb.toString(), op));\\n                }\\n            }\\n        }\\n\\n        return operator.pop() == \\'t\\';\\n    }\\n\\n    private char performOperation(String s,char op) {\\n        if(op==\\'!\\') {\\n            return s.equals(\"t\")?\\'f\\':\\'t\\';\\n        } else if(op==\\'|\\') {\\n            boolean flag = s.charAt(0) != \\'f\\';\\n            for (int i=1;i<s.length();i++) {\\n                flag = flag | (s.charAt(i) != \\'f\\');\\n            }\\n            return !flag ?\\'f\\':\\'t\\';\\n        } else {\\n            boolean flag = s.charAt(0) != \\'f\\';\\n            for (int i=1;i<s.length();i++) {\\n                flag = flag & (s.charAt(i) != \\'f\\');\\n            }\\n            return !flag ?\\'f\\':\\'t\\';\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 323689,
                "title": "inconsistency-in-test-case-and-description",
                "content": "The problem statement says\\n```\\n\"&(expr1,expr2,...)\", evaluating to the logical AND of 2 or more inner expressions expr1, expr2, ...;\\n\"|(expr1,expr2,...)\", evaluating to the logical OR of 2 or more inner expressions expr1, expr2, ...\\n```\\n\\nBut in the test case `\"!(&(!(t),&(f),|(f)))\"` the last `&` and `|` evaluate a single inner expression.",
                "solutionTags": [],
                "code": "```\\n\"&(expr1,expr2,...)\", evaluating to the logical AND of 2 or more inner expressions expr1, expr2, ...;\\n\"|(expr1,expr2,...)\", evaluating to the logical OR of 2 or more inner expressions expr1, expr2, ...\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 323303,
                "title": "java-solution-using-stack",
                "content": "* Declare 2 stacks, one for operands and another for operators. Push all operands including \\'(\\', \\'t\\', \\'f\\' onto operands stack and push all operators including \\'|\\', \\'&\\', \\'!\\' onto operator stack.\\n* Whenever a close bracket is encountered, pop all the elements from operand stack until matching open bracket \\'(\\' is found. Also pop one operator from operator stack.\\n* Append all operands in a string and process with operator. If operator is \\'&\\' and there is a single \\'f\\' found, return false immediately. If operator is \\'!\\', invert operand.\\n* Have a count if there exists atleast 1 \\'t\\', and return true if found so.\\n* Pop the open bracket \\'(\\' from operand stack and add result back into stack.\\n* Finally, pop the last value from stack and return true or false.\\n```\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        Stack<Character> operands = new Stack<Character>();\\n        Stack<Character> operators = new Stack<Character>();\\n        for(char ch: expression.toCharArray()) {\\n            if(ch == \\',\\') {\\n                continue;\\n            } else if(ch == \\'(\\' || ch == \\'t\\' || ch == \\'f\\') {\\n                operands.push(ch);            \\n            } else if(ch == \\')\\') {\\n                //pop until open bracket\\n                boolean val = false;\\n                char opr = operators.pop();\\n                String popped = \"\";\\n                while(!operands.isEmpty() && operands.peek() != \\'(\\') {\\n                    popped += operands.pop();\\n                }\\n                val = eval(opr, popped);\\n                if(!operands.isEmpty())\\n                    operands.pop();\\n                if(val == true)\\n                    operands.push(\\'t\\');\\n                else \\n                    operands.push(\\'f\\');\\n            } else if(ch == \\'&\\' || ch == \\'|\\' || ch == \\'!\\') {\\n                operators.push(ch);\\n            }\\n        }\\n        char res = operands.pop();\\n        if(res == \\'t\\')\\n            return true;\\n        else\\n            return false;\\n    }\\n    public boolean eval(char opr, String popped) {\\n        int tcount = 0;\\n        for(char ch:popped.toCharArray()) {\\n            if(ch == \\'t\\')\\n                tcount++;\\n            if(opr == \\'&\\' && ch == \\'f\\')\\n                return false;\\n            else if(opr == \\'!\\' && ch == \\'t\\')\\n                return false;\\n            else if(opr == \\'!\\' && ch == \\'f\\')\\n                return true;\\n        } \\n        return tcount > 0? true: false;\\n    }\\n}\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        Stack<Character> operands = new Stack<Character>();\\n        Stack<Character> operators = new Stack<Character>();\\n        for(char ch: expression.toCharArray()) {\\n            if(ch == \\',\\') {\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3335785,
                "title": "stack-time-space-90-beats-short-sweet-c",
                "content": "````\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string str) {\\n        vector<char> s;\\n        int f = 0, t = 0,c;\\n        for(auto &i: str){\\n            if(i==\\',\\')continue;\\n            if(i==\\')\\'){\\n                f = 0, t = 0;\\n                c = \\'#\\';\\n                while(s.back() != \\'(\\'){\\n                    if(s.back()==\\'f\\')f++;\\n                    else if(s.back()==\\'t\\')t++;\\n                    s.pop_back();\\n                }\\n                s.pop_back();\\n                c = s.back();\\n                s.pop_back();\\n                if(c==\\'#\\')continue;\\n                if(c==\\'|\\'){\\n                    // cout<<\\'|\\';\\n                    if(t){\\n                       s.push_back(\\'t\\'); \\n                    }else{\\n                        s.push_back(\\'f\\');\\n                    }\\n                }else if(c==\\'!\\'){\\n                    cout<<\\'!\\';\\n                    if(f){\\n                        s.push_back(\\'t\\');\\n                    }else{\\n                        s.push_back(\\'f\\');\\n                    }\\n                }else{\\n                    cout<<\\'&\\';\\n                    if(f){\\n                       s.push_back(\\'f\\'); \\n                    }else{\\n                        s.push_back(\\'t\\');\\n                    }\\n                }\\n                // cout<<\" \"<<s.back()<<\" \"<<s.size()<<endl;\\n            }else{\\n                s.push_back(i);\\n            }\\n        }\\n        return s.back()==\\'f\\'?false:true;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Iterator"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string str) {\\n        vector<char> s;\\n        int f = 0, t = 0,c;\\n        for(auto &i: str){\\n            if(i==\\',\\')continue;\\n            if(i==\\')\\'){\\n                f = 0, t = 0;\\n                c = \\'#\\';\\n                while(s.back() != \\'(\\'){\\n                    if(s.back()==\\'f\\')f++;\\n                    else if(s.back()==\\'t\\')t++;\\n                    s.pop_back();\\n                }\\n                s.pop_back();\\n                c = s.back();\\n                s.pop_back();\\n                if(c==\\'#\\')continue;\\n                if(c==\\'|\\'){\\n                    // cout<<\\'|\\';\\n                    if(t){\\n                       s.push_back(\\'t\\'); \\n                    }else{\\n                        s.push_back(\\'f\\');\\n                    }\\n                }else if(c==\\'!\\'){\\n                    cout<<\\'!\\';\\n                    if(f){\\n                        s.push_back(\\'t\\');\\n                    }else{\\n                        s.push_back(\\'f\\');\\n                    }\\n                }else{\\n                    cout<<\\'&\\';\\n                    if(f){\\n                       s.push_back(\\'f\\'); \\n                    }else{\\n                        s.push_back(\\'t\\');\\n                    }\\n                }\\n                // cout<<\" \"<<s.back()<<\" \"<<s.size()<<endl;\\n            }else{\\n                s.push_back(i);\\n            }\\n        }\\n        return s.back()==\\'f\\'?false:true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2913876,
                "title": "solved-using-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nint closeString(string s, int i){\\n    stack<char> st;\\n    for(i; i<s.length(); i++){\\n        if(s[i]==\\'(\\'){\\n            st.push(\\'(\\');\\n        }\\n        else if(s[i]==\\')\\'){\\n            st.pop();\\n        }\\n        if(st.empty()){\\n            break;\\n        }\\n    }\\n        return i;\\n}\\n\\nbool isRight(string s){\\n    stack<char> st;\\n    for(int i=1; i<s.length(); i++){\\n        if(s[i]==\\'(\\'){\\n            st.push(\\'(\\');\\n        }\\n        else if(s[i]==\\')\\'){\\n            st.pop();\\n        }\\n        if(st.empty() && i!=s.length()-1){\\n            return false;\\n        }\\n    }\\n        return true;\\n}\\n\\n\\nstring check(string s, char a){\\n    if(a==\\'&\\'){\\n        for(int i=0; i<s.length(); i++){\\n            if(s[i]==\\'f\\'){\\n                return \"f\";\\n            }\\n        }\\n        return \"t\";\\n    } if(a==\\'|\\'){\\n        for(int i=0; i<s.length(); i++){\\n            if(s[i]==\\'t\\'){\\n                return \"t\";\\n            }\\n        }\\n        return \"f\";\\n    }\\n    if(a==\\'!\\'){\\n      if(s[0]==\\'t\\'){\\n        return \"f\";\\n      }\\n    }\\n    return \"t\";\\n}\\nbool isBracket(string s){\\n    for(int j=0; j<s.length(); j++){\\n        if(s[j]==\\'(\\' || s[j]==\\')\\'){\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\n\\nstring to_oper(char x){\\n    string op=\"\";\\n    if(x==\\'&\\'){\\n        op=\"&\";\\n    }\\n    else if(x==\\'!\\'){\\n        op=\"!\";\\n    }\\n    else{\\n        op=\"|\";\\n    }\\n    return op;\\n}\\nstring solve(string s){\\n     if(!isBracket(s) || s.length()==0){\\n          return s; \\n      }\\n    char a=s[0];  string c=\"\";\\n    string b=s.substr(2, s.length()-3);\\n\\n    if(isBracket(b)){\\n    int k=closeString(b,1);\\n    string x=\"\"; string y=\"\";\\n    x=b.substr(0,k+1);\\n    string h=\"\";\\n    if(b.length()>k+1){\\n    y=b.substr(k+2, s.length()-k-3);\\n    bool r=isRight(y);\\n    cout<<r<<endl;\\n    if(!r){\\n     y=to_oper(a)+\"(\"+y+\")\";\\n     cout<<y<<endl;\\n    }  \\n   h=\",\"+solve(y);\\n    }\\n    c=solve(x)+h;\\n    c= check(c, a);\\n    }\\n    else{\\n      c=solve(b);\\n       c= check(c, a);\\n    }\\n   // cout<<c<<endl;\\n    return c;\\n}\\n    bool parseBoolExpr(string expression) {\\n        string s;\\n        s=solve(expression);\\n        if(s==\"t\"){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nint closeString(string s, int i){\\n    stack<char> st;\\n    for(i; i<s.length(); i++){\\n        if(s[i]==\\'(\\'){\\n            st.push(\\'(\\');\\n        }\\n        else if(s[i]==\\')\\'){\\n            st.pop();\\n        }\\n        if(st.empty()){\\n            break;\\n        }\\n    }\\n        return i;\\n}\\n\\nbool isRight(string s){\\n    stack<char> st;\\n    for(int i=1; i<s.length(); i++){\\n        if(s[i]==\\'(\\'){\\n            st.push(\\'(\\');\\n        }\\n        else if(s[i]==\\')\\'){\\n            st.pop();\\n        }\\n        if(st.empty() && i!=s.length()-1){\\n            return false;\\n        }\\n    }\\n        return true;\\n}\\n\\n\\nstring check(string s, char a){\\n    if(a==\\'&\\'){\\n        for(int i=0; i<s.length(); i++){\\n            if(s[i]==\\'f\\'){\\n                return \"f\";\\n            }\\n        }\\n        return \"t\";\\n    } if(a==\\'|\\'){\\n        for(int i=0; i<s.length(); i++){\\n            if(s[i]==\\'t\\'){\\n                return \"t\";\\n            }\\n        }\\n        return \"f\";\\n    }\\n    if(a==\\'!\\'){\\n      if(s[0]==\\'t\\'){\\n        return \"f\";\\n      }\\n    }\\n    return \"t\";\\n}\\nbool isBracket(string s){\\n    for(int j=0; j<s.length(); j++){\\n        if(s[j]==\\'(\\' || s[j]==\\')\\'){\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\n\\nstring to_oper(char x){\\n    string op=\"\";\\n    if(x==\\'&\\'){\\n        op=\"&\";\\n    }\\n    else if(x==\\'!\\'){\\n        op=\"!\";\\n    }\\n    else{\\n        op=\"|\";\\n    }\\n    return op;\\n}\\nstring solve(string s){\\n     if(!isBracket(s) || s.length()==0){\\n          return s; \\n      }\\n    char a=s[0];  string c=\"\";\\n    string b=s.substr(2, s.length()-3);\\n\\n    if(isBracket(b)){\\n    int k=closeString(b,1);\\n    string x=\"\"; string y=\"\";\\n    x=b.substr(0,k+1);\\n    string h=\"\";\\n    if(b.length()>k+1){\\n    y=b.substr(k+2, s.length()-k-3);\\n    bool r=isRight(y);\\n    cout<<r<<endl;\\n    if(!r){\\n     y=to_oper(a)+\"(\"+y+\")\";\\n     cout<<y<<endl;\\n    }  \\n   h=\",\"+solve(y);\\n    }\\n    c=solve(x)+h;\\n    c= check(c, a);\\n    }\\n    else{\\n      c=solve(b);\\n       c= check(c, a);\\n    }\\n   // cout<<c<<endl;\\n    return c;\\n}\\n    bool parseBoolExpr(string expression) {\\n        string s;\\n        s=solve(expression);\\n        if(s==\"t\"){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2094373,
                "title": "efficient-approach-stack-iterative-or-using-iterator",
                "content": "***Using Stack :*** \\n```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n        stack<char>s;\\n        for(auto i: expression){\\n            if(i==\\')\\'){\\n                bool hast{false}, hasf{false};\\n                while(s.top()==\\'t\\' or s.top()==\\'f\\' or s.top()==\\',\\'){\\n                    if(s.top()==\\'t\\') hast=true;\\n                    if(s.top()==\\'f\\') hasf=true;\\n                    s.pop();\\n                }\\n                s.pop();\\n                char op=s.top();\\n                s.pop();\\n                if(op==\\'|\\')\\n                {\\n                    s.push(hast==true?\\'t\\':\\'f\\');\\n                }\\n                else if(op==\\'&\\')\\n                {\\n                    s.push(hasf==false?\\'t\\':\\'f\\');\\n                }\\n                else if(op==\\'!\\')\\n                {\\n                    s.push(hast==true?\\'f\\':\\'t\\');\\n                }\\n            }\\n            else {\\n                s.push(i);\\n            }\\n        }\\n        return s.top()==\\'t\\'?true:false;\\n    }\\n};\\n```\\n\\n***Using Iterator (Most Efficient) :***\\n```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n        auto it=expression.begin();\\n        return parse(it);\\n    }\\n    \\n    template <class Iterator>\\n    bool parse(Iterator &it){\\n        char ch=*it++;\\n        \\n        switch(ch){\\n            case \\'t\\':\\n                return true;\\n            case \\'f\\':\\n                return false;\\n            case \\'!\\':{\\n                ++it;\\n                bool arg=parse(it);\\n                ++it;\\n                return !arg;\\n            }\\n            case \\'&\\':{\\n                ++it;\\n                bool result=parse(it);\\n                while(*it==\\',\\'){\\n                    ++it;\\n                    bool rhs=parse(it);\\n                    result = result&&rhs;\\n                }\\n                ++it;\\n                return result;\\n            }\\n            case \\'|\\':{\\n                ++it;\\n                bool result = parse(it);\\n                while(*it==\\',\\'){\\n                    ++it;\\n                    bool rhs=parse(it);\\n                    result = result || rhs;\\n                }\\n                ++it;\\n                return result;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n        stack<char>s;\\n        for(auto i: expression){\\n            if(i==\\')\\'){\\n                bool hast{false}, hasf{false};\\n                while(s.top()==\\'t\\' or s.top()==\\'f\\' or s.top()==\\',\\'){\\n                    if(s.top()==\\'t\\') hast=true;\\n                    if(s.top()==\\'f\\') hasf=true;\\n                    s.pop();\\n                }\\n                s.pop();\\n                char op=s.top();\\n                s.pop();\\n                if(op==\\'|\\')\\n                {\\n                    s.push(hast==true?\\'t\\':\\'f\\');\\n                }\\n                else if(op==\\'&\\')\\n                {\\n                    s.push(hasf==false?\\'t\\':\\'f\\');\\n                }\\n                else if(op==\\'!\\')\\n                {\\n                    s.push(hast==true?\\'f\\':\\'t\\');\\n                }\\n            }\\n            else {\\n                s.push(i);\\n            }\\n        }\\n        return s.top()==\\'t\\'?true:false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n        auto it=expression.begin();\\n        return parse(it);\\n    }\\n    \\n    template <class Iterator>\\n    bool parse(Iterator &it){\\n        char ch=*it++;\\n        \\n        switch(ch){\\n            case \\'t\\':\\n                return true;\\n            case \\'f\\':\\n                return false;\\n            case \\'!\\':{\\n                ++it;\\n                bool arg=parse(it);\\n                ++it;\\n                return !arg;\\n            }\\n            case \\'&\\':{\\n                ++it;\\n                bool result=parse(it);\\n                while(*it==\\',\\'){\\n                    ++it;\\n                    bool rhs=parse(it);\\n                    result = result&&rhs;\\n                }\\n                ++it;\\n                return result;\\n            }\\n            case \\'|\\':{\\n                ++it;\\n                bool result = parse(it);\\n                while(*it==\\',\\'){\\n                    ++it;\\n                    bool rhs=parse(it);\\n                    result = result || rhs;\\n                }\\n                ++it;\\n                return result;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1945463,
                "title": "java-stack-solution-simple-with-comments",
                "content": "```\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        Stack<Character> stack = new Stack<>();\\n        for(char c: expression.toCharArray()) {\\n            // Dont pass Open Bracket and comma to stack. \\n            if(c == \\'(\\' || c == \\',\\') {\\n                continue;\\n            } \\n            // If Closing Bracket Evaluate Stack till latest operator\\n            if(c == \\')\\') {\\n                // True and False variables to Know truth Value\\n                boolean True = false, False = false;\\n                // Get Truth Values till latest operator\\n                while(stack.peek() == \\'t\\' || stack.peek() == \\'f\\') {\\n                    if(stack.pop() == \\'t\\') {\\n                        True = true;\\n                    } else {\\n                        False = true;\\n                    }\\n                }\\n                char operator = stack.pop(), result;\\n                if(operator == \\'&\\') {\\n                    // One false in AND operation is always false\\n                    result = False ? \\'f\\' : \\'t\\';\\n                } else if(operator == \\'|\\') {\\n                    // One true in OR operation is always true\\n                    result = True ? \\'t\\' : \\'f\\';\\n                } else {\\n                    // Simple Negation\\n                    result = True ? \\'f\\' : \\'t\\';\\n                }\\n                // Push Back the result of evaluation\\n                stack.push(result);\\n                continue;\\n            }\\n            stack.push(c);\\n        }\\n        return stack.pop() == \\'t\\' ? true : false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        Stack<Character> stack = new Stack<>();\\n        for(char c: expression.toCharArray()) {\\n            // Dont pass Open Bracket and comma to stack. \\n            if(c == \\'(\\' || c == \\',\\') {\\n                continue;\\n            } \\n            // If Closing Bracket Evaluate Stack till latest operator\\n            if(c == \\')\\') {\\n                // True and False variables to Know truth Value\\n                boolean True = false, False = false;\\n                // Get Truth Values till latest operator\\n                while(stack.peek() == \\'t\\' || stack.peek() == \\'f\\') {\\n                    if(stack.pop() == \\'t\\') {\\n                        True = true;\\n                    } else {\\n                        False = true;\\n                    }\\n                }\\n                char operator = stack.pop(), result;\\n                if(operator == \\'&\\') {\\n                    // One false in AND operation is always false\\n                    result = False ? \\'f\\' : \\'t\\';\\n                } else if(operator == \\'|\\') {\\n                    // One true in OR operation is always true\\n                    result = True ? \\'t\\' : \\'f\\';\\n                } else {\\n                    // Simple Negation\\n                    result = True ? \\'f\\' : \\'t\\';\\n                }\\n                // Push Back the result of evaluation\\n                stack.push(result);\\n                continue;\\n            }\\n            stack.push(c);\\n        }\\n        return stack.pop() == \\'t\\' ? true : false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1225977,
                "title": "c-0ms-100-faster-sol-commented-fully",
                "content": "**Please upvote if this helps :)**\\n```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n        stack<pair<int,int>> s_v;\\n        //s_v pair first denotes the number of \\'t\\' and second denotes the \\n        //number of \\'f\\' values\\n        stack<char> s_o;\\n        //s_o used to store the operators\\n        for(auto c:expression)\\n        {\\n            if(c==\\'(\\')\\n            {\\n                s_v.push({-1,-1}); //indicating a open bracket\\n                s_v.push({0,0}); \\n            }\\n            else if(c==\\'.\\')\\n            {\\n                //do nothing\\n            }\\n            else if(c==\\'!\\' || c==\\'|\\' || c==\\'&\\')\\n            {\\n                //push to operator stack\\n                s_o.push(c);\\n            }\\n            else if(c==\\'t\\' || c==\\'f\\')\\n            {\\n                if(c==\\'t\\')\\n                {\\n                    s_v.top().first++;\\n                }\\n                else{\\n                    s_v.top().second++;\\n                }\\n            }\\n            else if(c==\\')\\')\\n            {\\n                //evaluate the expression\\n                int numTrue=0,numFalse=0;\\n                while(s_v.top().first!=-1)\\n                {\\n                    //until a open bracket is found\\n                    numTrue+=s_v.top().first;\\n                    numFalse+=s_v.top().second;\\n                    s_v.pop();\\n                }\\n                //remove the opening bracket\\n                s_v.pop();\\n                pair<int,int> temp({0,0});\\n                if(s_o.top()==\\'&\\')\\n                {\\n                    //one false leads to false \\n                    (numFalse>=1) ? temp.second=1 : temp.first=1;\\n                }\\n                else if(s_o.top()==\\'|\\')\\n                {\\n                    //one true leads to true\\n                    (numTrue>=1) ?  temp.first=1 : temp.second=1;\\n                }\\n                else{\\n                    //if it is not operator\\n                        (numTrue==1) ? temp.second=1 : temp.first=1;\\n                }\\n                s_v.push(temp);\\n                s_o.pop(); //remove the last operator\\n            }\\n        }\\n        if(s_v.top().first)\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n        stack<pair<int,int>> s_v;\\n        //s_v pair first denotes the number of \\'t\\' and second denotes the \\n        //number of \\'f\\' values\\n        stack<char> s_o;\\n        //s_o used to store the operators\\n        for(auto c:expression)\\n        {\\n            if(c==\\'(\\')\\n            {\\n                s_v.push({-1,-1}); //indicating a open bracket\\n                s_v.push({0,0}); \\n            }\\n            else if(c==\\'.\\')\\n            {\\n                //do nothing\\n            }\\n            else if(c==\\'!\\' || c==\\'|\\' || c==\\'&\\')\\n            {\\n                //push to operator stack\\n                s_o.push(c);\\n            }\\n            else if(c==\\'t\\' || c==\\'f\\')\\n            {\\n                if(c==\\'t\\')\\n                {\\n                    s_v.top().first++;\\n                }\\n                else{\\n                    s_v.top().second++;\\n                }\\n            }\\n            else if(c==\\')\\')\\n            {\\n                //evaluate the expression\\n                int numTrue=0,numFalse=0;\\n                while(s_v.top().first!=-1)\\n                {\\n                    //until a open bracket is found\\n                    numTrue+=s_v.top().first;\\n                    numFalse+=s_v.top().second;\\n                    s_v.pop();\\n                }\\n                //remove the opening bracket\\n                s_v.pop();\\n                pair<int,int> temp({0,0});\\n                if(s_o.top()==\\'&\\')\\n                {\\n                    //one false leads to false \\n                    (numFalse>=1) ? temp.second=1 : temp.first=1;\\n                }\\n                else if(s_o.top()==\\'|\\')\\n                {\\n                    //one true leads to true\\n                    (numTrue>=1) ?  temp.first=1 : temp.second=1;\\n                }\\n                else{\\n                    //if it is not operator\\n                        (numTrue==1) ? temp.second=1 : temp.first=1;\\n                }\\n                s_v.push(temp);\\n                s_o.pop(); //remove the last operator\\n            }\\n        }\\n        if(s_v.top().first)\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 913012,
                "title": "java-recursive-solution-with-explanations-and-comments",
                "content": "Hi! This is my recursive solution to this problem. I commented almost everything. Give a thumbs up if I helped you!\\n;)\\n\\n```\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n\\t\\t//Basic cases\\n        if(expression.equals(\"t\"))return true;\\n        else if(expression.length() == 0||expression.equals(\"f\"))return false;\\n\\t\\t\\n        \\n        char first = expression.charAt(0);//represents the first char of \"expression\". Which\\n\\t\\t//has to be either \\'|\\', \\'&\\', or \\'!\\'. (since the algorithm checked if it is \\'t\\' or \\'f\\' at the start)\\n\\t\\t\\n        String body = expression.substring(2, expression.length() - 1);//discard brackets and\\n        //operators\\n\\t\\t\\n        if(first == \\'!\\')return !parseBoolExpr(body);//Logical NOT case: there is only 1\\n\\t\\t//inner expression. So just recurse with the inner expression, and reverse its evaluated value.\\n\\t\\t\\n        else if(first == \\'&\\'){\\n\\t\\t\\t//Logical AND case. Use recursion to figure out the \"inner\" expression!\\n            List<String> splits = splitProper(body);\\n            for(String part : splits){\\n                if(!parseBoolExpr(part))return false;//In an logical AND expression,\\n\\t\\t\\t\\t//when one of the expressions is false, you return false.\\n            }\\n            return true;//If all expressions evaluates to true, return true.\\n        }\\n        else if(first == \\'|\\'){\\n\\t\\t\\t//Logical OR case. Use recursion to figure out the \"inner\" expression!\\n            List<String> splits = splitProper(body);\\n            for(String part : splits){\\n                if(parseBoolExpr(part))return true;//In an logical OR expression,\\n\\t\\t\\t\\t//when one of the expressions is true, you return true.\\n            }\\n            return false;//When all of the expressions evaluates to false, return false.\\n        }\\n        System.out.println(\"ERROR!\");\\n        return false;\\n    }\\n    \\n    //Split into small expressions. Input str should be like this: \"expr1,expr2,...,exprN\"\\n\\t//and each expr is one of { \"t\", \"f\", \"!(another_expr)\", \"|(another_expr)\", \"&(another_expr)\"}\\n\\t//No recursions in this method. All it does is just splitting into multiple\\n\\t//small expressions :)\\n    public List<String> splitProper(String str){\\n        int bracketsMet = 0;//A very simple \"fake\" stack. bracketsMet = N means\\n\\t\\t//when looping str to index i, you came by N left-brackets or \"(\".\\n\\t\\t//Each time you come by a \"(\", add 1 to it. And similarly each time you\\n\\t\\t//come by a \")\", subtract it by 1. A proper split of str should not have\\n\\t\\t//different numbers of left-brackets and right-brackets. Therefore you can\\n\\t\\t//only split when bracketsMet is 0.\\n\\t\\t\\n        int left = 0;\\n        List<String> split = new ArrayList<>();\\n        for(int i = 0;i < str.length();i++){\\n            char c = str.charAt(i);\\n            if(c == \\'(\\')bracketsMet++;//Met a bracket. Uh oh... You can only split if bracketsMet is 0.\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t //Think about it!\\n            else if(c == \\',\\' && bracketsMet == 0){\\n                split.add(str.substring(left, i));\\n                left = i + 1;\\n            }\\n            else if(c == \\')\\')bracketsMet--;\\n        }\\n        \\n        split.add(str.substring(left, str.length()));\\n        return split;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n\\t\\t//Basic cases\\n        if(expression.equals(\"t\"))return true;\\n        else if(expression.length() == 0||expression.equals(\"f\"))return false;\\n\\t\\t\\n        \\n        char first = expression.charAt(0);//represents the first char of \"expression\". Which\\n\\t\\t//has to be either \\'|\\', \\'&\\', or \\'!\\'. (since the algorithm checked if it is \\'t\\' or \\'f\\' at the start)\\n\\t\\t\\n        String body = expression.substring(2, expression.length() - 1);//discard brackets and\\n        //operators\\n\\t\\t\\n        if(first == \\'!\\')return !parseBoolExpr(body);//Logical NOT case: there is only 1\\n\\t\\t//inner expression. So just recurse with the inner expression, and reverse its evaluated value.\\n\\t\\t\\n        else if(first == \\'&\\'){\\n\\t\\t\\t//Logical AND case. Use recursion to figure out the \"inner\" expression!\\n            List<String> splits = splitProper(body);\\n            for(String part : splits){\\n                if(!parseBoolExpr(part))return false;//In an logical AND expression,\\n\\t\\t\\t\\t//when one of the expressions is false, you return false.\\n            }\\n            return true;//If all expressions evaluates to true, return true.\\n        }\\n        else if(first == \\'|\\'){\\n\\t\\t\\t//Logical OR case. Use recursion to figure out the \"inner\" expression!\\n            List<String> splits = splitProper(body);\\n            for(String part : splits){\\n                if(parseBoolExpr(part))return true;//In an logical OR expression,\\n\\t\\t\\t\\t//when one of the expressions is true, you return true.\\n            }\\n            return false;//When all of the expressions evaluates to false, return false.\\n        }\\n        System.out.println(\"ERROR!\");\\n        return false;\\n    }\\n    \\n    //Split into small expressions. Input str should be like this: \"expr1,expr2,...,exprN\"\\n\\t//and each expr is one of { \"t\", \"f\", \"!(another_expr)\", \"|(another_expr)\", \"&(another_expr)\"}\\n\\t//No recursions in this method. All it does is just splitting into multiple\\n\\t//small expressions :)\\n    public List<String> splitProper(String str){\\n        int bracketsMet = 0;//A very simple \"fake\" stack. bracketsMet = N means\\n\\t\\t//when looping str to index i, you came by N left-brackets or \"(\".\\n\\t\\t//Each time you come by a \"(\", add 1 to it. And similarly each time you\\n\\t\\t//come by a \")\", subtract it by 1. A proper split of str should not have\\n\\t\\t//different numbers of left-brackets and right-brackets. Therefore you can\\n\\t\\t//only split when bracketsMet is 0.\\n\\t\\t\\n        int left = 0;\\n        List<String> split = new ArrayList<>();\\n        for(int i = 0;i < str.length();i++){\\n            char c = str.charAt(i);\\n            if(c == \\'(\\')bracketsMet++;//Met a bracket. Uh oh... You can only split if bracketsMet is 0.\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t //Think about it!\\n            else if(c == \\',\\' && bracketsMet == 0){\\n                split.add(str.substring(left, i));\\n                left = i + 1;\\n            }\\n            else if(c == \\')\\')bracketsMet--;\\n        }\\n        \\n        split.add(str.substring(left, str.length()));\\n        return split;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 627614,
                "title": "explain-me-this-testcase",
                "content": "```\\n\"!(&(!(&(f)),&(t),|(f,f,t)))\"\\n```\\n& AND | should have 2 or more than 2 parameters a/c to the question.....how is this test case correct \\n",
                "solutionTags": [],
                "code": "```\\n\"!(&(!(&(f)),&(t),|(f,f,t)))\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 351852,
                "title": "python3-solution-without-stack-or-recursion-beats-100-on-memory",
                "content": "```class Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        mapping = {\\n            \\'&\\': \\'all\\',\\n            \\'|\\': \\'any\\',\\n            \\'t\\': \\'True\\',\\n            \\'f\\': \\'False\\',\\n            \\'(\\': \\'([\\',\\n            \\')\\': \\'])\\',\\n            \\'!\\': \\'not any\\',\\n        }\\n        for m, v in mapping. items():\\n            expression = expression.replace(m, v)\\n        return(eval(expression))\\n\\t\\t```",
                "solutionTags": [],
                "code": "```class Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        mapping = {\\n            \\'&\\': \\'all\\',\\n            \\'|\\': \\'any\\',\\n            \\'t\\': \\'True\\',\\n            \\'f\\': \\'False\\',\\n            \\'(\\': \\'([\\',\\n            \\')\\': \\'])\\',\\n            \\'!\\': \\'not any\\',\\n        }\\n        for m, v in mapping. items():\\n            expression = expression.replace(m, v)\\n        return(eval(expression))\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 327764,
                "title": "java-one-pass-one-stack-clean",
                "content": "Solution is based on a direct iteration of parsing the expression string. We use stack to keep parts of expression that we parsed. We add to the stack untill we met \\')\\'. At this point we pop out of stack everything down to the recent \\'(\\' - this way we get all elements of one expression. During poping elements we registering trues and falses in a flag variables. Then depends on the operation - \\'!\\', \\'&\\' or \\'|\\' we analyse those flags and set the signle summary of a single expression back to the stack. \\nComplexities - time is O(length_of_string) - because we do the check every char in the expression string, plus max of same n when poping from the stack.\\nspace - O(length_of_string) for the stack.\\n```\\nStack<Character> state = new Stack();\\n    int N = expression.length();\\n    for (int i = 0; i < N; i++) {\\n      char ch = expression.charAt(i);\\n      if (ch == \\')\\') {\\n        //handle end of expression\\n        boolean hasTrue = false;\\n        boolean hasFalse = false;\\n        while(state.peek() != \\'(\\') {\\n          char next = state.pop();\\n          if (next == \\'t\\')\\n            hasTrue = true;\\n          else\\n            hasFalse = true;\\n        }\\n        //\\'(\\'\\n        state.pop();\\n        //action\\n        char oper = state.pop();\\n        if (oper == \\'&\\') {\\n          state.push(hasFalse ? \\'f\\' : \\'t\\');\\n        } else if (oper == \\'|\\') {\\n          state.push(hasTrue ? \\'t\\' : \\'f\\');\\n        } else {\\n          state.push(hasTrue ? \\'f\\' : \\'t\\');\\n        }\\n\\n      } else if (ch != \\',\\') {\\n        state.push(ch);\\n      }\\n    }\\n\\n    return state.pop() == \\'t\\';\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nStack<Character> state = new Stack();\\n    int N = expression.length();\\n    for (int i = 0; i < N; i++) {\\n      char ch = expression.charAt(i);\\n      if (ch == \\')\\') {\\n        //handle end of expression\\n        boolean hasTrue = false;\\n        boolean hasFalse = false;\\n        while(state.peek() != \\'(\\') {\\n          char next = state.pop();\\n          if (next == \\'t\\')\\n            hasTrue = true;\\n          else\\n            hasFalse = true;\\n        }\\n        //\\'(\\'\\n        state.pop();\\n        //action\\n        char oper = state.pop();\\n        if (oper == \\'&\\') {\\n          state.push(hasFalse ? \\'f\\' : \\'t\\');\\n        } else if (oper == \\'|\\') {\\n          state.push(hasTrue ? \\'t\\' : \\'f\\');\\n        } else {\\n          state.push(hasTrue ? \\'f\\' : \\'t\\');\\n        }\\n\\n      } else if (ch != \\',\\') {\\n        state.push(ch);\\n      }\\n    }\\n\\n    return state.pop() == \\'t\\';\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 323288,
                "title": "java-solution",
                "content": "\\n    \\n    public boolean parseBoolExpr(String expression) {\\n        char firstChar = expression.charAt(0);\\n        if (expression.length() == 1) {\\n            return  firstChar == \\'t\\';\\n        }\\n\\n        boolean booleanResult;\\n        List<String> partitions;\\n        switch (firstChar) {\\n            case \\'!\\':\\n                return !parseBoolExpr(expression.substring(1));\\n\\n            case \\'|\\':\\n                partitions = parse(expression.substring(1));\\n                booleanResult = parseBoolExpr(partitions.get(0));\\n                for (int i = 1; i < partitions.size(); i++) {\\n                    booleanResult = booleanResult || parseBoolExpr(partitions.get(i));\\n                }\\n                return booleanResult;\\n\\n            case \\'&\\':\\n                partitions = parse(expression.substring(1));\\n                booleanResult = parseBoolExpr(partitions.get(0));\\n                for (int i = 1; i < partitions.size(); i++) {\\n                    booleanResult = booleanResult && parseBoolExpr(partitions.get(i));\\n                }\\n                return booleanResult;\\n        }\\n\\n        return parseBoolExpr(expression.substring(1, expression.length() - 1));\\n    }\\n\\n    private List<String> parse(String expression) {\\n        List<String> partitions = new ArrayList<>();\\n        int openParenthesisCounter = 0;\\n        int closeParenthesisCounter = 0;\\n        int firstCharOfPartition = 1;\\n        for (int i = 1; i < expression.length() - 1; i++) {\\n            char c = expression.charAt(i);\\n            switch (c) {\\n                case \\'(\\':\\n                    ++openParenthesisCounter;\\n                    break;\\n                case \\')\\':\\n                    ++closeParenthesisCounter;\\n                    break;\\n                case \\',\\':\\n                    if (openParenthesisCounter == closeParenthesisCounter) {\\n                        partitions.add(expression.substring(firstCharOfPartition, i));\\n                        firstCharOfPartition = i + 1;\\n                    }\\n            }\\n        }\\n        partitions.add(expression.substring(firstCharOfPartition, expression.length() - 1));\\n\\n        return partitions;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "\\n    \\n    public boolean parseBoolExpr(String expression) {\\n        char firstChar = expression.charAt(0);\\n        if (expression.length() == 1) {\\n            return  firstChar == \\'t\\';\\n        }\\n\\n        boolean booleanResult;\\n        List<String> partitions;\\n        switch (firstChar) {\\n            case \\'!\\':\\n                return !parseBoolExpr(expression.substring(1));\\n\\n            case \\'|\\':\\n                partitions = parse(expression.substring(1));\\n                booleanResult = parseBoolExpr(partitions.get(0));\\n                for (int i = 1; i < partitions.size(); i++) {\\n                    booleanResult = booleanResult || parseBoolExpr(partitions.get(i));\\n                }\\n                return booleanResult;\\n\\n            case \\'&\\':\\n                partitions = parse(expression.substring(1));\\n                booleanResult = parseBoolExpr(partitions.get(0));\\n                for (int i = 1; i < partitions.size(); i++) {\\n                    booleanResult = booleanResult && parseBoolExpr(partitions.get(i));\\n                }\\n                return booleanResult;\\n        }\\n\\n        return parseBoolExpr(expression.substring(1, expression.length() - 1));\\n    }\\n\\n    private List<String> parse(String expression) {\\n        List<String> partitions = new ArrayList<>();\\n        int openParenthesisCounter = 0;\\n        int closeParenthesisCounter = 0;\\n        int firstCharOfPartition = 1;\\n        for (int i = 1; i < expression.length() - 1; i++) {\\n            char c = expression.charAt(i);\\n            switch (c) {\\n                case \\'(\\':\\n                    ++openParenthesisCounter;\\n                    break;\\n                case \\')\\':\\n                    ++closeParenthesisCounter;\\n                    break;\\n                case \\',\\':\\n                    if (openParenthesisCounter == closeParenthesisCounter) {\\n                        partitions.add(expression.substring(firstCharOfPartition, i));\\n                        firstCharOfPartition = i + 1;\\n                    }\\n            }\\n        }\\n        partitions.add(expression.substring(firstCharOfPartition, expression.length() - 1));\\n\\n        return partitions;\\n    }\\n}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3703033,
                "title": "c-easy-to-understand-using-stack",
                "content": "# Intuition\\n- As insertion and deletion operations are supposed to be executed on our string based on LILO, so stack may be the best possible approach.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- We need to calculate the boolean expression soon after the closing parenthesis. For the rest we can keep pushing them in stack.\\n- We can have various conditions based on our understanding in boolean expressions.\\n- we can ignore \\'(\\' and \\',\\' as they will affect our continuity and understanding to calculate the expression. \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N*log(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string exp) {\\n        stack<char> s;\\n        for(int i=0;i<exp.size();i++)\\n        {\\n            if(exp[i]==\\')\\')\\n            {\\n                int t=0,f=0;\\n                while(s.top()==\\'t\\'||s.top()==\\'f\\')\\n                {\\n                    if(s.top()==\\'t\\')\\n                    t=1;\\n                    else\\n                    f=1;\\n                    s.pop();\\n                }\\n                char op=s.top();\\n                s.pop();\\n                if(op==\\'|\\')\\n                {\\n                    if(t)\\n                    s.push(\\'t\\');\\n                    else\\n                    s.push(\\'f\\');\\n                }\\n                if(op==\\'!\\')\\n                {\\n                    if(t)\\n                    s.push(\\'f\\');\\n                    else\\n                    s.push(\\'t\\');\\n                }\\n                if(op==\\'&\\')\\n                {\\n                    if(f)\\n                    s.push(\\'f\\');\\n                    else\\n                    s.push(\\'t\\');\\n                }\\n            }\\n            else if(exp[i]!=\\',\\'&&exp[i]!=\\'(\\')\\n            s.push(exp[i]);\\n        } \\n        if(s.top()==\\'t\\')\\n        return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string exp) {\\n        stack<char> s;\\n        for(int i=0;i<exp.size();i++)\\n        {\\n            if(exp[i]==\\')\\')\\n            {\\n                int t=0,f=0;\\n                while(s.top()==\\'t\\'||s.top()==\\'f\\')\\n                {\\n                    if(s.top()==\\'t\\')\\n                    t=1;\\n                    else\\n                    f=1;\\n                    s.pop();\\n                }\\n                char op=s.top();\\n                s.pop();\\n                if(op==\\'|\\')\\n                {\\n                    if(t)\\n                    s.push(\\'t\\');\\n                    else\\n                    s.push(\\'f\\');\\n                }\\n                if(op==\\'!\\')\\n                {\\n                    if(t)\\n                    s.push(\\'f\\');\\n                    else\\n                    s.push(\\'t\\');\\n                }\\n                if(op==\\'&\\')\\n                {\\n                    if(f)\\n                    s.push(\\'f\\');\\n                    else\\n                    s.push(\\'t\\');\\n                }\\n            }\\n            else if(exp[i]!=\\',\\'&&exp[i]!=\\'(\\')\\n            s.push(exp[i]);\\n        } \\n        if(s.top()==\\'t\\')\\n        return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3198553,
                "title": "python-super-easy-solution-easy-to-understand-override-the-property-very-easy",
                "content": "```\\nclass Solution:\\n    \\n    def oro(self,*args):\\n        ans = False\\n        for elm in args:\\n            ans|=elm\\n        return ans\\n    \\n    def ando(self,*args):\\n        ans = True\\n        for elm in args:\\n            ans&=elm\\n        return ans\\n    \\n    def noto(self,args):\\n        return not args\\n    \\n    def parseBoolExpr(self, e: str) -> bool:\\n        e=e.replace(\\'f\\',\\'False\\').replace(\\'t\\',\\'True\\')\\n        e=e.replace(\\'!\\',\\'self.noto\\').replace(\\'|\\',\\'self.oro\\').replace(\\'&\\',\\'self.ando\\')\\n        return eval(e)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def oro(self,*args):\\n        ans = False\\n        for elm in args:\\n            ans|=elm\\n        return ans\\n    \\n    def ando(self,*args):\\n        ans = True\\n        for elm in args:\\n            ans&=elm\\n        return ans\\n    \\n    def noto(self,args):\\n        return not args\\n    \\n    def parseBoolExpr(self, e: str) -> bool:\\n        e=e.replace(\\'f\\',\\'False\\').replace(\\'t\\',\\'True\\')\\n        e=e.replace(\\'!\\',\\'self.noto\\').replace(\\'|\\',\\'self.oro\\').replace(\\'&\\',\\'self.ando\\')\\n        return eval(e)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2969279,
                "title": "simple-soln-with-o-n-time-complexity-using-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    pair<int, bool> exp(string s,int i,int n)\\n    {\\n        if(s[i]==\\'f\\') return {i,false};\\n        else if(s[i]==\\'t\\') return {i,true};\\n        char x=s[i]; bool y;int k=0;i=i+2;\\n        while(i<n && s[i]!=\\')\\')\\n        {\\n           bool z;\\n           if(s[i]==\\'f\\' || s[i]==\\'t\\')\\n           {\\n               if(s[i]==\\'f\\') z=false;\\n                  else z=true;\\n           }\\n           else if(s[i]==\\'|\\' ||s[i]==\\'&\\' || s[i]==\\'!\\') \\n           {\\n             pair<int, bool>p=exp(s,i,n);\\n             i=p.first;\\n             z=p.second;\\n           }\\n           if(k==0)\\n           {\\n               if(x==\\'!\\') y=!z;\\n               else y=z;\\n               k++;\\n           }\\n           else \\n           {\\n                if(x==\\'!\\') y=!z;\\n                else if(x==\\'&\\') y=y&z;\\n                else y=y|z;\\n           }\\n           i++;\\n        }\\n        return {i,y};\\n    }\\n    bool parseBoolExpr(string s) \\n    {\\n       int n=s.size();\\n      pair<int, bool>p= exp(s,0,n);\\n      return p.second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    pair<int, bool> exp(string s,int i,int n)\\n    {\\n        if(s[i]==\\'f\\') return {i,false};\\n        else if(s[i]==\\'t\\') return {i,true};\\n        char x=s[i]; bool y;int k=0;i=i+2;\\n        while(i<n && s[i]!=\\')\\')\\n        {\\n           bool z;\\n           if(s[i]==\\'f\\' || s[i]==\\'t\\')\\n           {\\n               if(s[i]==\\'f\\') z=false;\\n                  else z=true;\\n           }\\n           else if(s[i]==\\'|\\' ||s[i]==\\'&\\' || s[i]==\\'!\\') \\n           {\\n             pair<int, bool>p=exp(s,i,n);\\n             i=p.first;\\n             z=p.second;\\n           }\\n           if(k==0)\\n           {\\n               if(x==\\'!\\') y=!z;\\n               else y=z;\\n               k++;\\n           }\\n           else \\n           {\\n                if(x==\\'!\\') y=!z;\\n                else if(x==\\'&\\') y=y&z;\\n                else y=y|z;\\n           }\\n           i++;\\n        }\\n        return {i,y};\\n    }\\n    bool parseBoolExpr(string s) \\n    {\\n       int n=s.size();\\n      pair<int, bool>p= exp(s,0,n);\\n      return p.second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527812,
                "title": "c-simple-c-code",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\n    stack<char> st, ex;\\n    void evaluate(string &expr)\\n    {\\n        if(ex.top() == \\'!\\')\\n        {\\n            ex.pop();\\n            if(st.top() == \\'t\\')\\n            {\\n                st.pop();\\n                st.pop();\\n                st.push(\\'f\\');\\n            }\\n            else\\n            {\\n                st.pop();\\n                st.pop();\\n                st.push(\\'t\\');\\n            }\\n        }\\n        else if(ex.top() == \\'|\\')\\n        {\\n            ex.pop();\\n            bool tr = false;\\n            while(st.top() != \\'(\\')\\n            {\\n                if(st.top() == \\'t\\')\\n                    tr = true;\\n                st.pop();\\n            }\\n            st.pop();\\n            if(tr)\\n                st.push(\\'t\\');\\n            else\\n                st.push(\\'f\\');\\n        }\\n        else\\n        {\\n            ex.pop();\\n            bool tr = true;\\n            while(st.top() != \\'(\\')\\n            {\\n                if(st.top() == \\'f\\')\\n                    tr = false;\\n                st.pop();\\n            }\\n            st.pop();\\n            if(tr)\\n                st.push(\\'t\\');\\n            else\\n                st.push(\\'f\\');\\n        }\\n    }\\npublic:\\n    bool parseBoolExpr(string expr) {\\n        int i = 0, n = expr.size();\\n        while(i < n)\\n        {\\n            if(expr[i] == \\'(\\' || expr[i] == \\'t\\' || expr[i] == \\'f\\')\\n                st.push(expr[i]);               \\n            if(expr[i] == \\'|\\' || expr[i] == \\'&\\' || expr[i] == \\'!\\')\\n                ex.push(expr[i]);\\n            else if(expr[i] == \\')\\')\\n                evaluate(expr);\\n            i++;\\n        }\\n        if(st.top() == \\'t\\')\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    stack<char> st, ex;\\n    void evaluate(string &expr)\\n    {\\n        if(ex.top() == \\'!\\')\\n        {\\n            ex.pop();\\n            if(st.top() == \\'t\\')\\n            {\\n                st.pop();\\n                st.pop();\\n                st.push(\\'f\\');\\n            }\\n            else\\n            {\\n                st.pop();\\n                st.pop();\\n                st.push(\\'t\\');\\n            }\\n        }\\n        else if(ex.top() == \\'|\\')\\n        {\\n            ex.pop();\\n            bool tr = false;\\n            while(st.top() != \\'(\\')\\n            {\\n                if(st.top() == \\'t\\')\\n                    tr = true;\\n                st.pop();\\n            }\\n            st.pop();\\n            if(tr)\\n                st.push(\\'t\\');\\n            else\\n                st.push(\\'f\\');\\n        }\\n        else\\n        {\\n            ex.pop();\\n            bool tr = true;\\n            while(st.top() != \\'(\\')\\n            {\\n                if(st.top() == \\'f\\')\\n                    tr = false;\\n                st.pop();\\n            }\\n            st.pop();\\n            if(tr)\\n                st.push(\\'t\\');\\n            else\\n                st.push(\\'f\\');\\n        }\\n    }\\npublic:\\n    bool parseBoolExpr(string expr) {\\n        int i = 0, n = expr.size();\\n        while(i < n)\\n        {\\n            if(expr[i] == \\'(\\' || expr[i] == \\'t\\' || expr[i] == \\'f\\')\\n                st.push(expr[i]);               \\n            if(expr[i] == \\'|\\' || expr[i] == \\'&\\' || expr[i] == \\'!\\')\\n                ex.push(expr[i]);\\n            else if(expr[i] == \\')\\')\\n                evaluate(expr);\\n            i++;\\n        }\\n        if(st.top() == \\'t\\')\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1437107,
                "title": "c-clean-concise-solution-with-stack",
                "content": "```\\nclass Solution {\\n    void evaluate(pair<bool, char>& top, const bool& value) {\\n        switch (top.second) {\\n            case \\'!\\': top.first = !value; break;\\n            case \\'&\\': top.first &= value; break;\\n            case \\'|\\': top.first |= value;\\n        }\\n    }\\n    \\npublic:\\n    bool parseBoolExpr(const string& expression) {\\n        stack<pair<bool, char>> st;\\n        st.push({true, \\'&\\'});\\n        \\n        for(const char& c: expression)\\n            switch (c) {\\n                case \\'t\\': evaluate(st.top(), true); break;\\n                case \\'f\\': evaluate(st.top(), false); break;\\n                case \\'!\\': st.push({true, \\'!\\'}); break;\\n                case \\'&\\': st.push({true, \\'&\\'}); break;\\n                case \\'|\\': st.push({false, \\'|\\'}); break;\\n                case \\')\\':\\n                    const bool value = st.top().first;\\n                    st.pop();\\n                    evaluate(st.top(), value);\\n            }\\n        \\n        return st.top().first;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    void evaluate(pair<bool, char>& top, const bool& value) {\\n        switch (top.second) {\\n            case \\'!\\': top.first = !value; break;\\n            case \\'&\\': top.first &= value; break;\\n            case \\'|\\': top.first |= value;\\n        }\\n    }\\n    \\npublic:\\n    bool parseBoolExpr(const string& expression) {\\n        stack<pair<bool, char>> st;\\n        st.push({true, \\'&\\'});\\n        \\n        for(const char& c: expression)\\n            switch (c) {\\n                case \\'t\\': evaluate(st.top(), true); break;\\n                case \\'f\\': evaluate(st.top(), false); break;\\n                case \\'!\\': st.push({true, \\'!\\'}); break;\\n                case \\'&\\': st.push({true, \\'&\\'}); break;\\n                case \\'|\\': st.push({false, \\'|\\'}); break;\\n                case \\')\\':\\n                    const bool value = st.top().first;\\n                    st.pop();\\n                    evaluate(st.top(), value);\\n            }\\n        \\n        return st.top().first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 788995,
                "title": "python-sol-using-stack",
                "content": "class Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        stack = []\\n        \\n        for i in expression:\\n            if i != \\',\\':\\n                if i == \\')\\':\\n                    temp = set()\\n                    while stack and stack[-1] != \\'(\\':\\n                        temp.add(stack.pop())\\n                    stack.pop()\\n                    op = stack.pop()\\n\\n                    if op == \\'|\\':\\n                        if \\'t\\' in temp:\\n                            stack.append(\\'t\\')\\n                        else:\\n                            stack.append(\\'f\\')\\n\\n                    elif op == \\'&\\':\\n                        if \\'f\\' in temp:\\n                            stack.append(\\'f\\')\\n                        else:\\n                            stack.append(\\'t\\')\\n\\n                    elif op == \\'!\\':\\n                        if \\'t\\' in temp:\\n                            stack.append(\\'f\\')\\n                        else:\\n                            stack.append(\\'t\\')\\n                else:\\n                    stack.append(i)\\n                \\n        return True if stack.pop() == \\'t\\' else False",
                "solutionTags": [],
                "code": "class Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        stack = []\\n        \\n        for i in expression:\\n            if i != \\',\\':\\n                if i == \\')\\':\\n                    temp = set()\\n                    while stack and stack[-1] != \\'(\\':\\n                        temp.add(stack.pop())\\n                    stack.pop()\\n                    op = stack.pop()\\n\\n                    if op == \\'|\\':\\n                        if \\'t\\' in temp:\\n                            stack.append(\\'t\\')\\n                        else:\\n                            stack.append(\\'f\\')\\n\\n                    elif op == \\'&\\':\\n                        if \\'f\\' in temp:\\n                            stack.append(\\'f\\')\\n                        else:\\n                            stack.append(\\'t\\')\\n\\n                    elif op == \\'!\\':\\n                        if \\'t\\' in temp:\\n                            stack.append(\\'f\\')\\n                        else:\\n                            stack.append(\\'t\\')\\n                else:\\n                    stack.append(i)\\n                \\n        return True if stack.pop() == \\'t\\' else False",
                "codeTag": "Java"
            },
            {
                "id": 343700,
                "title": "java-oop-solution",
                "content": "```\\n    public boolean parseBoolExpr(String expression) {\\n        String exp = expression.trim();\\n        if(exp.isBlank())\\n            throw new IllegalArgumentException(\"Expression can\\'t be empty\");\\n        if(exp.length() == 1)\\n            return exp.equals(\"t\");\\n\\n        Stack<Expr> stack = new Stack<>();\\n        TrueExpr trueExpr = new TrueExpr();\\n        FalseExpr falseExpr = new FalseExpr();\\n        int idx = 0;\\n        while(idx < exp.length()) {\\n            char c = exp.charAt(idx++);\\n            if(c == \\'|\\') stack.push(new OrExpr());\\n            else if(c == \\'&\\') stack.push(new AndExpr());\\n            else if(c == \\'!\\') stack.push(new NegateExpr());\\n            else if(c == \\'f\\') stack.peek().add(falseExpr);\\n            else if(c == \\'t\\') stack.peek().add(trueExpr);\\n            else if(c == \\')\\') {\\n                boolean res = stack.pop().eval();\\n                if(stack.isEmpty())\\n                    return res;\\n                stack.peek().add(res ? trueExpr : falseExpr);\\n            }\\n        }\\n\\n        throw new IllegalStateException();\\n    }\\n\\n    private static abstract class Expr {\\n        List<Expr> list;\\n\\n        private Expr() {\\n            list = new LinkedList<>();\\n        }\\n\\n        abstract boolean eval();\\n\\n        void add(Expr e) {\\n            list.add(e);\\n        }\\n    }\\n\\n    private static class TrueExpr extends Expr {\\n\\n        @Override\\n        boolean eval() {\\n            return true;\\n        }\\n\\n        @Override\\n        void add(Expr e) {\\n            throw new UnsupportedOperationException();\\n        }\\n    }\\n\\n    private static class FalseExpr extends Expr {\\n\\n        @Override\\n        boolean eval() {\\n            return false;\\n        }\\n\\n        @Override\\n        void add(Expr e) {\\n            throw new UnsupportedOperationException();\\n        }\\n    }\\n\\n    private static class NegateExpr extends Expr {\\n\\n        @Override\\n        boolean eval() {\\n            if(list.size() != 1)\\n                throw new IllegalArgumentException(\"Expected one item, got \" + list.size());\\n\\n            return !list.get(0).eval();\\n        }\\n    }\\n\\n    private static class AndExpr extends Expr {\\n\\n        @Override\\n        boolean eval() {\\n            if(list.isEmpty())\\n                throw new IllegalArgumentException(\"Expected at least one item\");\\n\\n            boolean res = list.get(0).eval();\\n            for(int i = 1; i < list.size(); i++)\\n                res &= list.get(i).eval();\\n\\n            return res;\\n        }\\n    }\\n\\n    private static class OrExpr extends Expr {\\n\\n        @Override\\n        boolean eval() {\\n            if(list.isEmpty())\\n                throw new IllegalArgumentException(\"Expected at least one item\");\\n\\n            boolean res = list.get(0).eval();\\n            for(int i = 1; i < list.size(); i++)\\n                res |= list.get(i).eval();\\n\\n            return res;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean parseBoolExpr(String expression) {\\n        String exp = expression.trim();\\n        if(exp.isBlank())\\n            throw new IllegalArgumentException(\"Expression can\\'t be empty\");\\n        if(exp.length() == 1)\\n            return exp.equals(\"t\");\\n\\n        Stack<Expr> stack = new Stack<>();\\n        TrueExpr trueExpr = new TrueExpr();\\n        FalseExpr falseExpr = new FalseExpr();\\n        int idx = 0;\\n        while(idx < exp.length()) {\\n            char c = exp.charAt(idx++);\\n            if(c == \\'|\\') stack.push(new OrExpr());\\n            else if(c == \\'&\\') stack.push(new AndExpr());\\n            else if(c == \\'!\\') stack.push(new NegateExpr());\\n            else if(c == \\'f\\') stack.peek().add(falseExpr);\\n            else if(c == \\'t\\') stack.peek().add(trueExpr);\\n            else if(c == \\')\\') {\\n                boolean res = stack.pop().eval();\\n                if(stack.isEmpty())\\n                    return res;\\n                stack.peek().add(res ? trueExpr : falseExpr);\\n            }\\n        }\\n\\n        throw new IllegalStateException();\\n    }\\n\\n    private static abstract class Expr {\\n        List<Expr> list;\\n\\n        private Expr() {\\n            list = new LinkedList<>();\\n        }\\n\\n        abstract boolean eval();\\n\\n        void add(Expr e) {\\n            list.add(e);\\n        }\\n    }\\n\\n    private static class TrueExpr extends Expr {\\n\\n        @Override\\n        boolean eval() {\\n            return true;\\n        }\\n\\n        @Override\\n        void add(Expr e) {\\n            throw new UnsupportedOperationException();\\n        }\\n    }\\n\\n    private static class FalseExpr extends Expr {\\n\\n        @Override\\n        boolean eval() {\\n            return false;\\n        }\\n\\n        @Override\\n        void add(Expr e) {\\n            throw new UnsupportedOperationException();\\n        }\\n    }\\n\\n    private static class NegateExpr extends Expr {\\n\\n        @Override\\n        boolean eval() {\\n            if(list.size() != 1)\\n                throw new IllegalArgumentException(\"Expected one item, got \" + list.size());\\n\\n            return !list.get(0).eval();\\n        }\\n    }\\n\\n    private static class AndExpr extends Expr {\\n\\n        @Override\\n        boolean eval() {\\n            if(list.isEmpty())\\n                throw new IllegalArgumentException(\"Expected at least one item\");\\n\\n            boolean res = list.get(0).eval();\\n            for(int i = 1; i < list.size(); i++)\\n                res &= list.get(i).eval();\\n\\n            return res;\\n        }\\n    }\\n\\n    private static class OrExpr extends Expr {\\n\\n        @Override\\n        boolean eval() {\\n            if(list.isEmpty())\\n                throw new IllegalArgumentException(\"Expected at least one item\");\\n\\n            boolean res = list.get(0).eval();\\n            for(int i = 1; i < list.size(); i++)\\n                res |= list.get(i).eval();\\n\\n            return res;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 339266,
                "title": "java-short-solution",
                "content": "```\\n    public boolean parseBoolExpr(String e) {\\n        Deque<Character> s = new LinkedList<>();\\n        for(char c : e.toCharArray()) {\\n            if(c == \\')\\') {\\n                Set<Character> seen = new HashSet<>();\\n                while(s.peek() != \\'(\\') seen.add(s.pop());\\n                s.pop();\\n                char op = s.pop();\\n                if(op == \\'&\\') {\\n                    s.push(seen.contains(\\'f\\') ? \\'f\\' : \\'t\\');\\n                } else if(op == \\'|\\') {\\n                    s.push(seen.contains(\\'t\\') ? \\'t\\' : \\'f\\');\\n                } else if(op == \\'!\\') {\\n                    s.push(seen.contains(\\'f\\') ? \\'t\\' : \\'f\\');\\n                }\\n            } else if(c != \\',\\') {\\n                s.push(c);\\n            }\\n        }\\n        return s.peek() == \\'t\\' ? true : false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean parseBoolExpr(String e) {\\n        Deque<Character> s = new LinkedList<>();\\n        for(char c : e.toCharArray()) {\\n            if(c == \\')\\') {\\n                Set<Character> seen = new HashSet<>();\\n                while(s.peek() != \\'(\\') seen.add(s.pop());\\n                s.pop();\\n                char op = s.pop();\\n                if(op == \\'&\\') {\\n                    s.push(seen.contains(\\'f\\') ? \\'f\\' : \\'t\\');\\n                } else if(op == \\'|\\') {\\n                    s.push(seen.contains(\\'t\\') ? \\'t\\' : \\'f\\');\\n                } else if(op == \\'!\\') {\\n                    s.push(seen.contains(\\'f\\') ? \\'t\\' : \\'f\\');\\n                }\\n            } else if(c != \\',\\') {\\n                s.push(c);\\n            }\\n        }\\n        return s.peek() == \\'t\\' ? true : false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4010562,
                "title": "c-easy-to-follow-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Recursion is evident from the fact that there are sub problems (**sub-expressions in each operation**) that are required to be evaluated. \\n2. Each of the **subproblem could be solved with the same structure as the main problem** -> reuse the same functions\\n3. The next part of the problem is how to **parse each sub-problem**, i.e. parse the list of sub expresssions in each operation\\n\\n---\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n- To parse the expressions with parentheses, have a counter for the number of current left parentheses\\n\\n[Similar approach to this problem](https://leetcode.com/problems/valid-parentheses/)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> parse(string exp){\\n        // parse the string list of expression into sub expressions\\n        vector<string> exps;\\n        int n = exp.size();\\n        int  cur =0;\\n\\n        // number of current left brackets\\n        int left = 0;\\n\\n        while(cur<n){\\n            if(exp[cur] ==\\'t\\'){\\n                exps.push_back(\"t\");\\n                cur+=2;\\n            }\\n            else if(exp[cur]==\\'f\\'){\\n                exps.push_back(\"f\");\\n                cur+=2;\\n            }\\n            else if(exp[cur]==\\'!\\'){\\n                // find the next )\\n\\n                left = 0;\\n                for(int i=cur+1;i<n;++i){\\n                    if(exp[i]==\\'(\\')++left;\\n                    if(exp[i]==\\')\\'){\\n                        --left;\\n                        if(left ==0 ){\\n                            exps.push_back(exp.substr(cur, (i-cur+1)) );\\n                            cur = i+2;\\n                            break;\\n                        }\\n                    }\\n                }\\n\\n            }\\n            else if( exp[cur]==\\'&\\'){\\n                // find the next )\\n\\n                left = 0;\\n                for(int i=cur+1;i<n;++i){\\n                    if(exp[i]==\\'(\\')++left;\\n                    if(exp[i]==\\')\\'){\\n                        --left;\\n                        if(left ==0 ){\\n                            exps.push_back(exp.substr(cur, (i-cur+1)) );\\n                            cur = i+2;\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n            else{\\n                // find the next )\\n\\n                left = 0;\\n                for(int i=cur+1;i<n;++i){\\n                    if(exp[i]==\\'(\\')++left;\\n                    if(exp[i]==\\')\\'){\\n                        --left;\\n                        if(left ==0 ){\\n                            exps.push_back(exp.substr(cur, (i-cur+1)) );\\n                            cur = i+2;\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return exps;\\n    }\\n    bool valAnd(string exp){\\n        // seperate into list of expressions \\n        // return false from the first false\\n        vector<string> exps = parse(exp);\\n\\n        for(int i=0;i<exps.size();++i){\\n            if(!parseBoolExpr(exps[i]))return false;\\n        }\\n        \\n        return true;\\n    }\\n    bool valOr(string exp){\\n        // seperate into list of expressions\\n        // return true from the first true\\n        vector<string> exps = parse(exp);\\n\\n        for(int i=0;i<exps.size();++i){\\n            if(parseBoolExpr(exps[i]))return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    bool valNot(string exp){\\n        // return the NOT of the expression inside\\n        return !parseBoolExpr(exp);\\n    }\\n\\n    bool parseBoolExpr(string exp) {\\n        // recurstion\\n        // split into sub problems\\n\\n        int n = exp.size();\\n        bool eval =false;\\n\\n        if(n==1)return exp[0]==\\'t\\';\\n\\n        if(exp[0]==\\'&\\'){\\n            // if the operation is AND\\n            eval = valAnd(exp.substr(2,n-3));\\n        }\\n        else if(exp[0]==\\'|\\'){\\n            // if the operation is OR\\n            eval = valOr(exp.substr(2,n-3));\\n        }\\n        else{\\n            // if the operation is NOT\\n            eval = valNot(exp.substr(2, n-3));\\n        }\\n\\n        return eval;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> parse(string exp){\\n        // parse the string list of expression into sub expressions\\n        vector<string> exps;\\n        int n = exp.size();\\n        int  cur =0;\\n\\n        // number of current left brackets\\n        int left = 0;\\n\\n        while(cur<n){\\n            if(exp[cur] ==\\'t\\'){\\n                exps.push_back(\"t\");\\n                cur+=2;\\n            }\\n            else if(exp[cur]==\\'f\\'){\\n                exps.push_back(\"f\");\\n                cur+=2;\\n            }\\n            else if(exp[cur]==\\'!\\'){\\n                // find the next )\\n\\n                left = 0;\\n                for(int i=cur+1;i<n;++i){\\n                    if(exp[i]==\\'(\\')++left;\\n                    if(exp[i]==\\')\\'){\\n                        --left;\\n                        if(left ==0 ){\\n                            exps.push_back(exp.substr(cur, (i-cur+1)) );\\n                            cur = i+2;\\n                            break;\\n                        }\\n                    }\\n                }\\n\\n            }\\n            else if( exp[cur]==\\'&\\'){\\n                // find the next )\\n\\n                left = 0;\\n                for(int i=cur+1;i<n;++i){\\n                    if(exp[i]==\\'(\\')++left;\\n                    if(exp[i]==\\')\\'){\\n                        --left;\\n                        if(left ==0 ){\\n                            exps.push_back(exp.substr(cur, (i-cur+1)) );\\n                            cur = i+2;\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n            else{\\n                // find the next )\\n\\n                left = 0;\\n                for(int i=cur+1;i<n;++i){\\n                    if(exp[i]==\\'(\\')++left;\\n                    if(exp[i]==\\')\\'){\\n                        --left;\\n                        if(left ==0 ){\\n                            exps.push_back(exp.substr(cur, (i-cur+1)) );\\n                            cur = i+2;\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return exps;\\n    }\\n    bool valAnd(string exp){\\n        // seperate into list of expressions \\n        // return false from the first false\\n        vector<string> exps = parse(exp);\\n\\n        for(int i=0;i<exps.size();++i){\\n            if(!parseBoolExpr(exps[i]))return false;\\n        }\\n        \\n        return true;\\n    }\\n    bool valOr(string exp){\\n        // seperate into list of expressions\\n        // return true from the first true\\n        vector<string> exps = parse(exp);\\n\\n        for(int i=0;i<exps.size();++i){\\n            if(parseBoolExpr(exps[i]))return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    bool valNot(string exp){\\n        // return the NOT of the expression inside\\n        return !parseBoolExpr(exp);\\n    }\\n\\n    bool parseBoolExpr(string exp) {\\n        // recurstion\\n        // split into sub problems\\n\\n        int n = exp.size();\\n        bool eval =false;\\n\\n        if(n==1)return exp[0]==\\'t\\';\\n\\n        if(exp[0]==\\'&\\'){\\n            // if the operation is AND\\n            eval = valAnd(exp.substr(2,n-3));\\n        }\\n        else if(exp[0]==\\'|\\'){\\n            // if the operation is OR\\n            eval = valOr(exp.substr(2,n-3));\\n        }\\n        else{\\n            // if the operation is NOT\\n            eval = valNot(exp.substr(2, n-3));\\n        }\\n\\n        return eval;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3123797,
                "title": "python-stack-easy-to-understand-using-stack-python-beats-88-89-runtime-in-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n* After operator is always (expr1, expr2, ...).\\n* You can solve every operator(\\'f\\', \\'t\\', ....).\\n* Therefore you must solve expr => \\'t\\' or \\'f\\'.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* Using stack:\\n    - for each character in str:\\n        - if it is not \\'(\\' push it in stack\\n        - else if it is \\')\\':  => you have subExpr = operator(\\'f\\', \\'t\\', .....)   and you can solve it. Remove subExpr out stack and push result in stack.\\n        - else if it not \\',\\' push it in stack\\n        - Continue do the loop\\n    The answer is the last element in stack\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        stack1 = []\\n        stack2 = []\\n        top = \\'\\'\\n        for i in expression:\\n            if i == \\',\\':\\n                continue\\n            \\n            elif i == \\')\\':\\n                top = stack1.pop()\\n\\n                while top != \\'(\\':\\n                    stack2.append(top)\\n                    top = stack1.pop()\\n\\n                top = stack1.pop()\\n\\n                if top == \\'|\\':\\n                    stack1.append(\\'t\\' if \\'t\\' in stack2 else \\'f\\')\\n                \\n                elif top == \\'&\\':\\n                    stack1.append(\\'f\\' if \\'f\\' in stack2 else \\'t\\')\\n                \\n                elif top == \\'!\\':\\n                    stack1.append(\\'f\\' if \\'t\\' in stack2 else \\'t\\')\\n                stack2.clear()\\n            else:\\n                stack1.append(i)\\n\\n        return \\'t\\' in stack1\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Recursion",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        stack1 = []\\n        stack2 = []\\n        top = \\'\\'\\n        for i in expression:\\n            if i == \\',\\':\\n                continue\\n            \\n            elif i == \\')\\':\\n                top = stack1.pop()\\n\\n                while top != \\'(\\':\\n                    stack2.append(top)\\n                    top = stack1.pop()\\n\\n                top = stack1.pop()\\n\\n                if top == \\'|\\':\\n                    stack1.append(\\'t\\' if \\'t\\' in stack2 else \\'f\\')\\n                \\n                elif top == \\'&\\':\\n                    stack1.append(\\'f\\' if \\'f\\' in stack2 else \\'t\\')\\n                \\n                elif top == \\'!\\':\\n                    stack1.append(\\'f\\' if \\'t\\' in stack2 else \\'t\\')\\n                stack2.clear()\\n            else:\\n                stack1.append(i)\\n\\n        return \\'t\\' in stack1\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100813,
                "title": "two-stack-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string s) {\\n        \\n            stack<char> st; // STORE THE CHARACTER\\n            stack<char> op; // STORE LAST OPERATOR\\n            char last;\\n            for(char a : s){\\n                    \\n                    if(a == \\',\\') continue;\\n                    \\n                    if(a == \\'|\\' || a == \\'&\\' || a == \\'!\\') op.push(a); ;\\n                    \\n                    if(a != \\')\\')\\n                            st.push(a);\\n                    else{\\n                            int ans = st.top() == \\'f\\' ? 0 : 1;  st.pop();\\n                            last = op.top(); op.pop();        \\n                            while(!st.empty() && st.top() != \\'(\\'){\\n                                    \\n                                    int x = st.top() == \\'f\\' ? 0 : 1; st.pop();\\n                                    if(last == \\'|\\')\\n                                            ans = ans | x;\\n                                    else if(last == \\'&\\')\\n                                            ans = ans & x;\\n                            }\\n                            \\n                            if(last == \\'!\\')\\n                                    ans = !ans;\\n                            st.pop();\\n                            st.pop();\\n                            if(ans == 0) st.push(\\'f\\');\\n                            else st.push(\\'t\\');\\n                    }\\n            }\\n            \\n             return st.top() == \\'f\\'?false:true;\\n            \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string s) {\\n        \\n            stack<char> st; // STORE THE CHARACTER\\n            stack<char> op; // STORE LAST OPERATOR\\n            char last;\\n            for(char a : s){\\n                    \\n                    if(a == \\',\\') continue;\\n                    \\n                    if(a == \\'|\\' || a == \\'&\\' || a == \\'!\\') op.push(a); ;\\n                    \\n                    if(a != \\')\\')\\n                            st.push(a);\\n                    else{\\n                            int ans = st.top() == \\'f\\' ? 0 : 1;  st.pop();\\n                            last = op.top(); op.pop();        \\n                            while(!st.empty() && st.top() != \\'(\\'){\\n                                    \\n                                    int x = st.top() == \\'f\\' ? 0 : 1; st.pop();\\n                                    if(last == \\'|\\')\\n                                            ans = ans | x;\\n                                    else if(last == \\'&\\')\\n                                            ans = ans & x;\\n                            }\\n                            \\n                            if(last == \\'!\\')\\n                                    ans = !ans;\\n                            st.pop();\\n                            st.pop();\\n                            if(ans == 0) st.push(\\'f\\');\\n                            else st.push(\\'t\\');\\n                    }\\n            }\\n            \\n             return st.top() == \\'f\\'?false:true;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2964217,
                "title": "c-easy-to-understand-easy-to-code-stack-recursion",
                "content": "# It take lots of time to write this solution, so please upvote if you like this solution.\\n# Intuition\\nUsing stack we can easily solve this problem.\\n\\n# Complexity\\n- Time complexity:\\n- O(N^2) in --> worst case.\\n\\n- Space complexity:\\nO(N)+O(N) which is equivalent to O(N).\\n\\n# Code\\n```\\nbool parseBoolExpr(string expression)\\n{\\n    vector<bool> res;\\n    stack<char> st;\\n    int n = expression.length();\\n\\n    for (int i = n - 1; i > 0; i--)\\n    {\\n        char chara = expression[i];\\n        if (chara == \\',\\')\\n        {\\n            continue;\\n        }\\n        else if (chara == \\')\\')\\n        {\\n            st.push(chara);\\n        }\\n        else if (chara == \\'t\\' || chara == \\'f\\')\\n        {\\n            st.push(chara);\\n        }\\n        else if (chara == \\'(\\')\\n        {\\n            char symbol = expression[i - 1];\\n            while (st.top() != \\')\\')\\n            {\\n                if (st.top() == \\'t\\')\\n                {\\n                    res.push_back(1);\\n                }\\n                else if (st.top() == \\'f\\')\\n                {\\n                    res.push_back(0);\\n                }\\n                st.pop();\\n            }\\n            st.pop();\\n            if (symbol == \\'&\\')\\n            {\\n                bool mutex = true;\\n                for (auto element : res)\\n                {\\n                    mutex &= element;\\n                }\\n                mutex ? st.push(\\'t\\') : st.push(\\'f\\');\\n            }\\n            else if (symbol == \\'|\\')\\n            {\\n                bool mutex = false;\\n                for (auto element : res)\\n                {\\n                    mutex |= element;\\n                }\\n                mutex ? st.push(\\'t\\') : st.push(\\'f\\');\\n            }\\n            else if (symbol == \\'!\\')\\n            {\\n                bool element = res[0];\\n                element ? st.push(\\'f\\') : st.push(\\'t\\');\\n            }\\n            res.erase(res.begin(), res.end());\\n        }\\n    }\\n    \\n    return st.top() == \\'t\\';\\n}\\n# Please upvote if you like this solution.\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Stack",
                    "Recursion",
                    "Monotonic Stack"
                ],
                "code": "```\\nbool parseBoolExpr(string expression)\\n{\\n    vector<bool> res;\\n    stack<char> st;\\n    int n = expression.length();\\n\\n    for (int i = n - 1; i > 0; i--)\\n    {\\n        char chara = expression[i];\\n        if (chara == \\',\\')\\n        {\\n            continue;\\n        }\\n        else if (chara == \\')\\')\\n        {\\n            st.push(chara);\\n        }\\n        else if (chara == \\'t\\' || chara == \\'f\\')\\n        {\\n            st.push(chara);\\n        }\\n        else if (chara == \\'(\\')\\n        {\\n            char symbol = expression[i - 1];\\n            while (st.top() != \\')\\')\\n            {\\n                if (st.top() == \\'t\\')\\n                {\\n                    res.push_back(1);\\n                }\\n                else if (st.top() == \\'f\\')\\n                {\\n                    res.push_back(0);\\n                }\\n                st.pop();\\n            }\\n            st.pop();\\n            if (symbol == \\'&\\')\\n            {\\n                bool mutex = true;\\n                for (auto element : res)\\n                {\\n                    mutex &= element;\\n                }\\n                mutex ? st.push(\\'t\\') : st.push(\\'f\\');\\n            }\\n            else if (symbol == \\'|\\')\\n            {\\n                bool mutex = false;\\n                for (auto element : res)\\n                {\\n                    mutex |= element;\\n                }\\n                mutex ? st.push(\\'t\\') : st.push(\\'f\\');\\n            }\\n            else if (symbol == \\'!\\')\\n            {\\n                bool element = res[0];\\n                element ? st.push(\\'f\\') : st.push(\\'t\\');\\n            }\\n            res.erase(res.begin(), res.end());\\n        }\\n    }\\n    \\n    return st.top() == \\'t\\';\\n}\\n# Please upvote if you like this solution.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2591216,
                "title": "java-recursive-solution",
                "content": "```\\nclass Solution {\\n    public boolean f(char[] a, char l, int[] ind){\\n        boolean hasTrue = false;\\n        boolean hasFalse = false;\\n        \\n        while(a[ind[0]]!=\\')\\'){\\n            if(a[ind[0]]==\\'t\\'){\\n                hasTrue = true;\\n            }else if(a[ind[0]]==\\'f\\'){\\n                hasFalse = true;\\n            }else if(a[ind[0]]==\\'|\\' || a[ind[0]]==\\'&\\' || a[ind[0]]==\\'!\\'){\\n                char ch = a[ind[0]];\\n                ind[0]+=2;\\n                if(f(a,ch,ind)) hasTrue = true;\\n                else hasFalse = true;\\n            }\\n            ind[0]++;\\n        }\\n        // System.out.println(l + \" \"+ hasTrue +\" \"+ hasFalse);\\n        if(l == \\'|\\'){\\n            if(hasTrue) return true;\\n            else return false;\\n        }else if(l == \\'&\\'){\\n            if(hasFalse) return false;\\n            else return true;\\n        }else {\\n            if(hasTrue) return false;\\n            else return true;\\n        }\\n    }\\n    \\n    public boolean parseBoolExpr(String exp) {\\n        int[] ind = new int[1];\\n        ind[0]=2;\\n        return f(exp.toCharArray(), exp.charAt(0), ind);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean f(char[] a, char l, int[] ind){\\n        boolean hasTrue = false;\\n        boolean hasFalse = false;\\n        \\n        while(a[ind[0]]!=\\')\\'){\\n            if(a[ind[0]]==\\'t\\'){\\n                hasTrue = true;\\n            }else if(a[ind[0]]==\\'f\\'){\\n                hasFalse = true;\\n            }else if(a[ind[0]]==\\'|\\' || a[ind[0]]==\\'&\\' || a[ind[0]]==\\'!\\'){\\n                char ch = a[ind[0]];\\n                ind[0]+=2;\\n                if(f(a,ch,ind)) hasTrue = true;\\n                else hasFalse = true;\\n            }\\n            ind[0]++;\\n        }\\n        // System.out.println(l + \" \"+ hasTrue +\" \"+ hasFalse);\\n        if(l == \\'|\\'){\\n            if(hasTrue) return true;\\n            else return false;\\n        }else if(l == \\'&\\'){\\n            if(hasFalse) return false;\\n            else return true;\\n        }else {\\n            if(hasTrue) return false;\\n            else return true;\\n        }\\n    }\\n    \\n    public boolean parseBoolExpr(String exp) {\\n        int[] ind = new int[1];\\n        ind[0]=2;\\n        return f(exp.toCharArray(), exp.charAt(0), ind);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2583900,
                "title": "python-iterative-o-n-solution",
                "content": "```\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        logics = []\\n        stack = []\\n        \\n        def cal(tmp, top, op):\\n            if op == \\'!\\':\\n                tmp = \\'t\\' if tmp == \\'f\\' else \\'f\\'\\n            elif op == \\'&\\':\\n                tmp = \\'t\\' if (tmp == \\'t\\' and top == \\'t\\') else \\'f\\'\\n            elif op == \\'|\\':\\n                tmp = \\'t\\' if (tmp == \\'t\\' or top == \\'t\\') else \\'f\\'\\n            return tmp\\n\\n        for i in expression:\\n            if i in (\\'!\\', \\'&\\', \\'|\\'):\\n                logics.append(i)\\n            elif i == \\')\\':\\n                op = logics.pop()\\n                tmp = stack.pop()\\n                while stack:\\n                    top = stack.pop()\\n                    # print(tmp, top, op)\\n                    if op == \\'!\\' and top == \\'(\\': tmp = cal(tmp, tmp, op)\\n                    if top == \\'(\\': break\\n                    tmp = cal(tmp, top, op)\\n                stack.append(tmp)\\n            elif i == \\',\\': continue\\n            else:\\n                stack.append(i)\\n            # print(stack, logics, i)\\n        \\n        if logics:\\n            op = logics.pop()\\n            tmp = stack.pop()\\n            while stack:\\n                top = stack.pop()\\n                tmp = cal(tmp, top, op)\\n            stack.append(tmp)\\n        \\n        return True if stack[0] == \\'t\\' else False\\n        \\n                    \\n# Time: O(N)\\n# Space: O(N)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        logics = []\\n        stack = []\\n        \\n        def cal(tmp, top, op):\\n            if op == \\'!\\':\\n                tmp = \\'t\\' if tmp == \\'f\\' else \\'f\\'\\n            elif op == \\'&\\':\\n                tmp = \\'t\\' if (tmp == \\'t\\' and top == \\'t\\') else \\'f\\'\\n            elif op == \\'|\\':\\n                tmp = \\'t\\' if (tmp == \\'t\\' or top == \\'t\\') else \\'f\\'\\n            return tmp\\n\\n        for i in expression:\\n            if i in (\\'!\\', \\'&\\', \\'|\\'):\\n                logics.append(i)\\n            elif i == \\')\\':\\n                op = logics.pop()\\n                tmp = stack.pop()\\n                while stack:\\n                    top = stack.pop()\\n                    # print(tmp, top, op)\\n                    if op == \\'!\\' and top == \\'(\\': tmp = cal(tmp, tmp, op)\\n                    if top == \\'(\\': break\\n                    tmp = cal(tmp, top, op)\\n                stack.append(tmp)\\n            elif i == \\',\\': continue\\n            else:\\n                stack.append(i)\\n            # print(stack, logics, i)\\n        \\n        if logics:\\n            op = logics.pop()\\n            tmp = stack.pop()\\n            while stack:\\n                top = stack.pop()\\n                tmp = cal(tmp, top, op)\\n            stack.append(tmp)\\n        \\n        return True if stack[0] == \\'t\\' else False\\n        \\n                    \\n# Time: O(N)\\n# Space: O(N)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2528309,
                "title": "java-1-ms-faster-than-100-00-of-java-recursion",
                "content": "**<------------//VoteUp if you like the solution**\\n![image](https://assets.leetcode.com/users/images/68d9f323-15c8-49bd-842c-db99253c5eaa_1662274342.8303623.png)\\n\\n\\n```\\nclass Solution {\\n    \\n    int pos = 0;\\n    \\n    public boolean parseBoolExpr(String s) {\\n        pos = 0;\\n        return solve(s, \\'-\\');\\n    }\\n    \\n    public boolean solve(String s, char prev_sign) {\\n       \\n        boolean res = s.charAt(pos) == \\'f\\' ? false : true;\\n        char cur_sign = \\' \\';\\n        int flag_res_init = 0;\\n        while(pos < s.length()) {\\n            \\n            char cur_char = s.charAt(pos++);\\n            \\n            if(isExpr(cur_char)){\\n                res = eval(cur_char == \\'t\\'?true:false, res , prev_sign);\\n            }\\n            else if(isSign(cur_char)){\\n                cur_sign = cur_char;\\n            }\\n            else if(cur_char == \\'(\\'){\\n                if(flag_res_init == 1 || prev_sign == \\'!\\')\\n                    res = eval(solve(s, cur_sign), res, prev_sign);\\n                else {\\n                    res = solve(s, cur_sign);\\n                    flag_res_init = 1;\\n                }\\n            }\\n            else if(cur_char == \\')\\'){\\n                 return res;\\n            }\\n            \\n        }\\n       return res;\\n    }\\n    \\n    public boolean isExpr(char c){\\n        return (c == \\'f\\' || c == \\'t\\');\\n    }\\n    \\n    public boolean isSign(char c){\\n        return (c == \\'!\\' || c == \\'&\\' || c == \\'|\\');\\n    }\\n    \\n    public boolean eval(boolean e1, boolean e2, char sign) {\\n     \\n        boolean res = false;\\n        if(sign == \\'!\\')\\n            res = !e1;\\n        \\n        else if(sign == \\'|\\')\\n            res = e1 | e2;\\n        \\n        else if(sign == \\'&\\')\\n            res = e1&e2;\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int pos = 0;\\n    \\n    public boolean parseBoolExpr(String s) {\\n        pos = 0;\\n        return solve(s, \\'-\\');\\n    }\\n    \\n    public boolean solve(String s, char prev_sign) {\\n       \\n        boolean res = s.charAt(pos) == \\'f\\' ? false : true;\\n        char cur_sign = \\' \\';\\n        int flag_res_init = 0;\\n        while(pos < s.length()) {\\n            \\n            char cur_char = s.charAt(pos++);\\n            \\n            if(isExpr(cur_char)){\\n                res = eval(cur_char == \\'t\\'?true:false, res , prev_sign);\\n            }\\n            else if(isSign(cur_char)){\\n                cur_sign = cur_char;\\n            }\\n            else if(cur_char == \\'(\\'){\\n                if(flag_res_init == 1 || prev_sign == \\'!\\')\\n                    res = eval(solve(s, cur_sign), res, prev_sign);\\n                else {\\n                    res = solve(s, cur_sign);\\n                    flag_res_init = 1;\\n                }\\n            }\\n            else if(cur_char == \\')\\'){\\n                 return res;\\n            }\\n            \\n        }\\n       return res;\\n    }\\n    \\n    public boolean isExpr(char c){\\n        return (c == \\'f\\' || c == \\'t\\');\\n    }\\n    \\n    public boolean isSign(char c){\\n        return (c == \\'!\\' || c == \\'&\\' || c == \\'|\\');\\n    }\\n    \\n    public boolean eval(boolean e1, boolean e2, char sign) {\\n     \\n        boolean res = false;\\n        if(sign == \\'!\\')\\n            res = !e1;\\n        \\n        else if(sign == \\'|\\')\\n            res = e1 | e2;\\n        \\n        else if(sign == \\'&\\')\\n            res = e1&e2;\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2311895,
                "title": "c-easy-to-understand-simple-stack-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string e) {\\n        int n=e.size();\\n        stack<char> s,sign;\\n        for(int i=0;i<n;i++)\\n        {\\n            char ch=e[i];\\n            if(ch==\\',\\')\\n            continue;\\n            \\n            if(ch!=\\')\\')\\n            {\\n                if(ch==\\'!\\'||ch==\\'&\\'||ch==\\'|\\')\\n                {\\n                    sign.push(ch);\\n                }\\n                else\\n                    s.push(ch);\\n            }\\n            else\\n            {\\n                char op=sign.top();\\n                sign.pop();\\n                int hasT=-1,hasF=-1;\\n                while(s.top()!=\\'(\\')\\n                {\\n                    if(s.top()==\\'t\\')\\n                    {\\n                        hasT=true;\\n                    }\\n                    else\\n                    {\\n                        hasF=true;\\n                    }\\n                    s.pop();\\n                }\\n                s.pop();\\n                if(op==\\'!\\')\\n                {\\n                    if(hasT==1)\\n                    {\\n                        s.push(\\'f\\');\\n                    }\\n                    else if(hasF==1)\\n                    {\\n                        s.push(\\'t\\');\\n                    }\\n                }\\n                else if(op==\\'&\\')\\n                {\\n                    if(hasF==1)\\n                    {\\n                        s.push(\\'f\\');\\n                    }\\n                    else\\n                    {\\n                        s.push(\\'t\\');\\n                    }\\n                }\\n                else\\n                {\\n                    if(hasT==1)\\n                    {\\n                        s.push(\\'t\\');\\n                    }\\n                    else\\n                    {\\n                        s.push(\\'f\\');\\n                    }\\n                }\\n            }\\n        }\\n        return s.top()==\\'t\\';\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string e) {\\n        int n=e.size();\\n        stack<char> s,sign;\\n        for(int i=0;i<n;i++)\\n        {\\n            char ch=e[i];\\n            if(ch==\\',\\')\\n            continue;\\n            \\n            if(ch!=\\')\\')\\n            {\\n                if(ch==\\'!\\'||ch==\\'&\\'||ch==\\'|\\')\\n                {\\n                    sign.push(ch);\\n                }\\n                else\\n                    s.push(ch);\\n            }\\n            else\\n            {\\n                char op=sign.top();\\n                sign.pop();\\n                int hasT=-1,hasF=-1;\\n                while(s.top()!=\\'(\\')\\n                {\\n                    if(s.top()==\\'t\\')\\n                    {\\n                        hasT=true;\\n                    }\\n                    else\\n                    {\\n                        hasF=true;\\n                    }\\n                    s.pop();\\n                }\\n                s.pop();\\n                if(op==\\'!\\')\\n                {\\n                    if(hasT==1)\\n                    {\\n                        s.push(\\'f\\');\\n                    }\\n                    else if(hasF==1)\\n                    {\\n                        s.push(\\'t\\');\\n                    }\\n                }\\n                else if(op==\\'&\\')\\n                {\\n                    if(hasF==1)\\n                    {\\n                        s.push(\\'f\\');\\n                    }\\n                    else\\n                    {\\n                        s.push(\\'t\\');\\n                    }\\n                }\\n                else\\n                {\\n                    if(hasT==1)\\n                    {\\n                        s.push(\\'t\\');\\n                    }\\n                    else\\n                    {\\n                        s.push(\\'f\\');\\n                    }\\n                }\\n            }\\n        }\\n        return s.top()==\\'t\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2164769,
                "title": "c-stack-beats-95-simplest-best",
                "content": "**1. Implement a stack of char.\\n2. We store only, {\\'t\\',\\'f\\',\\'&\\',\\'|\\',\\'!\\'} in our stack.\\n3. Now, everytime we get \\')\\', we calculate our expression till that \\')\\'\\n4. Insert this temp_ans in stack and keep iterating\\n5. After all the iterations are complete, we are left with only one char at s.top()\\n6. If s.top()==\\'t\\', return true; else return false\\n7. I have also commented the code for any doubt !!!!\\n8. Hope you like the solution :-)**\\n\\n```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n        stack<char> s;\\n        for(auto x:expression)\\n        {\\n            if(x==\\'(\\' || x==\\',\\') continue;  // we \\'continue\\' our program because we do not want \\'(\\'  && \\',\\' in our stack;\\n            if(x==\\')\\')\\n            {\\n                bool a=false; // a --> checks if we get \\'t\\' or not, if yes \\'a\\' --> true \\n                bool b=false; // b --> checks if we get \\'f\\' or not, if yes \\'b\\' --> true \\n                while(s.top()==\\'t\\' || s.top()==\\'f\\')\\n                {\\n                    if(s.top()==\\'t\\') a=true;  // a --> true ,if, we get \\'t\\' atleast once\\n                    if(s.top()==\\'f\\') b=true; // b --> true ,if, we get \\'f\\' atleast once\\n                    s.pop();\\n                }\\n                char op=s.top(); // op --> stores the operator \\n                s.pop();\\n                char temp_ans;\\n                if(op==\\'&\\')\\n                {\\n                    if(b==true) // for atleast one \\'f\\', the \\'&\\' makes the exp false \\n                    {\\n                        temp_ans=\\'f\\';\\n                    }\\n                    else\\n                    {\\n                        temp_ans=\\'t\\'; // only if \\'b\\' if false ,i.e., no \\'f\\' present\\n                    }\\n                }\\n                else if(op==\\'|\\')\\n                {\\n                    if(a==true) // for atleast one \\'t\\', the \\'|\\' makes the exp true \\n                    {\\n                        temp_ans=\\'t\\';\\n                    }\\n                    else\\n                    {\\n                        temp_ans=\\'f\\'; // only if \\'a\\' if false ,i.e., no \\'t\\' present\\n                    }\\n                }\\n                else\\n                {\\n                    if(a==true) // ! operator changes \\'t\\' --> \\'f\\'\\n                    {\\n                        temp_ans=\\'f\\';\\n                    }\\n                    else\\n                    {\\n                        temp_ans=\\'t\\'; // ! operator changes \\'f\\' --> \\'t\\'\\n                    }\\n                }\\n                s.push(temp_ans);\\n                continue; // we \\'continue\\' our program because we do not want \\')\\' in our stack;\\n            }\\n            s.push(x);\\n        }\\n        if(s.top()==\\'t\\') return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n        stack<char> s;\\n        for(auto x:expression)\\n        {\\n            if(x==\\'(\\' || x==\\',\\') continue;  // we \\'continue\\' our program because we do not want \\'(\\'  && \\',\\' in our stack;\\n            if(x==\\')\\')\\n            {\\n                bool a=false; // a --> checks if we get \\'t\\' or not, if yes \\'a\\' --> true \\n                bool b=false; // b --> checks if we get \\'f\\' or not, if yes \\'b\\' --> true \\n                while(s.top()==\\'t\\' || s.top()==\\'f\\')\\n                {\\n                    if(s.top()==\\'t\\') a=true;  // a --> true ,if, we get \\'t\\' atleast once\\n                    if(s.top()==\\'f\\') b=true; // b --> true ,if, we get \\'f\\' atleast once\\n                    s.pop();\\n                }\\n                char op=s.top(); // op --> stores the operator \\n                s.pop();\\n                char temp_ans;\\n                if(op==\\'&\\')\\n                {\\n                    if(b==true) // for atleast one \\'f\\', the \\'&\\' makes the exp false \\n                    {\\n                        temp_ans=\\'f\\';\\n                    }\\n                    else\\n                    {\\n                        temp_ans=\\'t\\'; // only if \\'b\\' if false ,i.e., no \\'f\\' present\\n                    }\\n                }\\n                else if(op==\\'|\\')\\n                {\\n                    if(a==true) // for atleast one \\'t\\', the \\'|\\' makes the exp true \\n                    {\\n                        temp_ans=\\'t\\';\\n                    }\\n                    else\\n                    {\\n                        temp_ans=\\'f\\'; // only if \\'a\\' if false ,i.e., no \\'t\\' present\\n                    }\\n                }\\n                else\\n                {\\n                    if(a==true) // ! operator changes \\'t\\' --> \\'f\\'\\n                    {\\n                        temp_ans=\\'f\\';\\n                    }\\n                    else\\n                    {\\n                        temp_ans=\\'t\\'; // ! operator changes \\'f\\' --> \\'t\\'\\n                    }\\n                }\\n                s.push(temp_ans);\\n                continue; // we \\'continue\\' our program because we do not want \\')\\' in our stack;\\n            }\\n            s.push(x);\\n        }\\n        if(s.top()==\\'t\\') return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2122137,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        Stack<Character> stck=new Stack<Character>();\\n        for(int i=expression.length()-1;i>=0;i--)\\n        {\\n            if(expression.charAt(i)==\\')\\')\\n            {\\n                stck.push(\\')\\');\\n            }\\n            else if(expression.charAt(i)==\\',\\')\\n            {\\n                continue;\\n            }\\n            else if(expression.charAt(i)==\\'t\\' || expression.charAt(i)==\\'f\\')\\n            {\\n                stck.push(expression.charAt(i));\\n            }\\n            else if(expression.charAt(i)==\\'(\\')\\n            {\\n                char a=expression.charAt(i-1);\\n                if(a==\\'|\\')\\n                {\\n                    char result=\\'f\\';\\n                    while(stck.peek()!=\\')\\')\\n                    {\\n                        if(stck.pop()==\\'t\\')\\n                        {\\n                            result=\\'t\\';\\n                        }\\n                    }\\n                    stck.pop();\\n                    stck.push(result);\\n                    i=i-1;\\n                }\\n                else if(a==\\'!\\')\\n                {\\n                    if(stck.pop()==\\'t\\')\\n                    {\\n                        stck.pop();\\n                        stck.push(\\'f\\');\\n                    }\\n                    else\\n                    {\\n                        stck.pop();\\n                        stck.push(\\'t\\');\\n                    }\\n                    i=i-1;\\n                }\\n                else\\n                {\\n                    char result=\\'t\\';\\n                    while(stck.peek()!=\\')\\')\\n                    {\\n                        if(stck.pop()==\\'f\\')\\n                        {\\n                            result=\\'f\\';\\n                        }\\n                    }\\n                    stck.pop();\\n                    stck.push(result);\\n                    i=i-1;\\n                }\\n                \\n            }\\n        }\\n        \\n        if(stck.pop()==\\'t\\')\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        Stack<Character> stck=new Stack<Character>();\\n        for(int i=expression.length()-1;i>=0;i--)\\n        {\\n            if(expression.charAt(i)==\\')\\')\\n            {\\n                stck.push(\\')\\');\\n            }\\n            else if(expression.charAt(i)==\\',\\')\\n            {\\n                continue;\\n            }\\n            else if(expression.charAt(i)==\\'t\\' || expression.charAt(i)==\\'f\\')\\n            {\\n                stck.push(expression.charAt(i));\\n            }\\n            else if(expression.charAt(i)==\\'(\\')\\n            {\\n                char a=expression.charAt(i-1);\\n                if(a==\\'|\\')\\n                {\\n                    char result=\\'f\\';\\n                    while(stck.peek()!=\\')\\')\\n                    {\\n                        if(stck.pop()==\\'t\\')\\n                        {\\n                            result=\\'t\\';\\n                        }\\n                    }\\n                    stck.pop();\\n                    stck.push(result);\\n                    i=i-1;\\n                }\\n                else if(a==\\'!\\')\\n                {\\n                    if(stck.pop()==\\'t\\')\\n                    {\\n                        stck.pop();\\n                        stck.push(\\'f\\');\\n                    }\\n                    else\\n                    {\\n                        stck.pop();\\n                        stck.push(\\'t\\');\\n                    }\\n                    i=i-1;\\n                }\\n                else\\n                {\\n                    char result=\\'t\\';\\n                    while(stck.peek()!=\\')\\')\\n                    {\\n                        if(stck.pop()==\\'f\\')\\n                        {\\n                            result=\\'f\\';\\n                        }\\n                    }\\n                    stck.pop();\\n                    stck.push(result);\\n                    i=i-1;\\n                }\\n                \\n            }\\n        }\\n        \\n        if(stck.pop()==\\'t\\')\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1992936,
                "title": "c-o-n-time-stack-iterative-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string e) {\\n        stack<char> s;\\n        for(auto i:e)\\n        {\\n            if(i==\\')\\')\\n            {\\n                bool hast=false,hasf=false;\\n                while(s.top()==\\'t\\' || s.top()==\\'f\\' || s.top()==\\',\\')\\n                {\\n                    if(s.top()==\\'t\\')\\n                        hast=true;\\n                    if(s.top()==\\'f\\')\\n                        hasf=true;\\n                    s.pop();\\n                }\\n                s.pop();\\n                \\n                char op=s.top();\\n                s.pop();\\n                if(op==\\'|\\')\\n                {\\n                    s.push(hast==true?\\'t\\':\\'f\\');\\n                }\\n                else if(op==\\'&\\')\\n                {\\n                    s.push(hasf==false?\\'t\\':\\'f\\');\\n                }\\n                else if(op==\\'!\\')\\n                {\\n                    s.push(hast==true?\\'f\\':\\'t\\');\\n                }\\n            }\\n            else\\n                s.push(i);\\n        }\\n        return s.top()==\\'t\\'?true:false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string e) {\\n        stack<char> s;\\n        for(auto i:e)\\n        {\\n            if(i==\\')\\')\\n            {\\n                bool hast=false,hasf=false;\\n                while(s.top()==\\'t\\' || s.top()==\\'f\\' || s.top()==\\',\\')\\n                {\\n                    if(s.top()==\\'t\\')\\n                        hast=true;\\n                    if(s.top()==\\'f\\')\\n                        hasf=true;\\n                    s.pop();\\n                }\\n                s.pop();\\n                \\n                char op=s.top();\\n                s.pop();\\n                if(op==\\'|\\')\\n                {\\n                    s.push(hast==true?\\'t\\':\\'f\\');\\n                }\\n                else if(op==\\'&\\')\\n                {\\n                    s.push(hasf==false?\\'t\\':\\'f\\');\\n                }\\n                else if(op==\\'!\\')\\n                {\\n                    s.push(hast==true?\\'f\\':\\'t\\');\\n                }\\n            }\\n            else\\n                s.push(i);\\n        }\\n        return s.top()==\\'t\\'?true:false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1977669,
                "title": "straightforward-java-implementation",
                "content": "We can let recursion handle all the work.  The only tricky part is handling the manual parsing of the results for AND and OR.  Need to use a StringBuilder and make sure that the parentheses are matched and that we don\\'t call parseBoolExpr with an inavlid string.\\n\\n```\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n                \\n        char c = expression.charAt(0);\\n        \\n        if(c == \\'t\\'){\\n            return true;\\n        } else if(c == \\'f\\') {\\n            return false;\\n        } else if(c == \\'!\\'){\\n            return !parseBoolExpr(expression.substring(2, expression.length()-1));\\n        } else {\\n            List<Boolean> results = new ArrayList<>();\\n            StringBuilder sb = new StringBuilder();\\n            int numParens = 0;\\n            \\n            for(int i = 2; i < expression.length()-1; i++){\\n                char innerChar = expression.charAt(i);\\n                \\n                if(innerChar == \\'(\\'){\\n                    numParens++;\\n                } else if(innerChar == \\')\\'){\\n                    numParens--;\\n                } else if(innerChar == \\',\\' && sb.length() == 0){\\n                    continue;\\n                }\\n                sb.append(innerChar);\\n                \\n                if(numParens == 0){    \\n                    if(sb.length() == 1){\\n                        if(sb.toString().equals(\"t\") || sb.toString().equals(\"f\")){\\n                            results.add(parseBoolExpr(sb.toString()));\\n                            sb = new StringBuilder();\\n                        }\\n                    } else {\\n                        results.add(parseBoolExpr(sb.toString()));\\n                        sb = new StringBuilder();  \\n                    }\\n                }\\n            }\\n            \\n            if(c == \\'|\\'){\\n                for(boolean result : results){\\n                    if(result){\\n                        return true;\\n                    }\\n                }\\n                return false;\\n            } else {\\n                //c == &\\n                for(boolean result : results){\\n                    if(!result){\\n                        return false;\\n                    }\\n                }\\n                return true; \\n            }   \\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n                \\n        char c = expression.charAt(0);\\n        \\n        if(c == \\'t\\'){\\n            return true;\\n        } else if(c == \\'f\\') {\\n            return false;\\n        } else if(c == \\'!\\'){\\n            return !parseBoolExpr(expression.substring(2, expression.length()-1));\\n        } else {\\n            List<Boolean> results = new ArrayList<>();\\n            StringBuilder sb = new StringBuilder();\\n            int numParens = 0;\\n            \\n            for(int i = 2; i < expression.length()-1; i++){\\n                char innerChar = expression.charAt(i);\\n                \\n                if(innerChar == \\'(\\'){\\n                    numParens++;\\n                } else if(innerChar == \\')\\'){\\n                    numParens--;\\n                } else if(innerChar == \\',\\' && sb.length() == 0){\\n                    continue;\\n                }\\n                sb.append(innerChar);\\n                \\n                if(numParens == 0){    \\n                    if(sb.length() == 1){\\n                        if(sb.toString().equals(\"t\") || sb.toString().equals(\"f\")){\\n                            results.add(parseBoolExpr(sb.toString()));\\n                            sb = new StringBuilder();\\n                        }\\n                    } else {\\n                        results.add(parseBoolExpr(sb.toString()));\\n                        sb = new StringBuilder();  \\n                    }\\n                }\\n            }\\n            \\n            if(c == \\'|\\'){\\n                for(boolean result : results){\\n                    if(result){\\n                        return true;\\n                    }\\n                }\\n                return false;\\n            } else {\\n                //c == &\\n                for(boolean result : results){\\n                    if(!result){\\n                        return false;\\n                    }\\n                }\\n                return true; \\n            }   \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1873672,
                "title": "javascript-solution",
                "content": "Here\\'s my answer to this problem:\\n\\n```javascript\\nconst splitExpression = (expression) => {\\n  const exprs = [];\\n  let lastBreakPoint = -1;\\n  let openedPara = 0;\\n  for (let i = 0; i < expression.length; i++) {\\n    const char = expression[i];\\n    if (char === \\'(\\') openedPara++;\\n    if (char === \\')\\') openedPara--;\\n    if (openedPara === 0 && char === \\',\\') {\\n      exprs.push(expression.slice(lastBreakPoint + 1, i));\\n      lastBreakPoint = i;\\n    }\\n  }\\n  // Add remaining text as last exp\\n  exprs.push(expression.slice(lastBreakPoint + 1));\\n  return exprs;\\n};\\n\\n/**\\n * @param {string} expression\\n * @return {boolean}\\n */\\nvar parseBoolExpr = function (expression) {\\n  if (expression === \\'t\\') return true;\\n  if (expression === \\'f\\') return false;\\n  // remove first char and surrounding parentheses\\n  const innerExpression = expression.slice(2, -1);\\n\\n  if (expression[0] === \\'!\\') return !parseBoolExpr(innerExpression);\\n  const splitExpr = splitExpression(innerExpression);\\n  if (expression[0] === \\'&\\') return splitExpr.every(parseBoolExpr);\\n  if (expression[0] === \\'|\\') return splitExpr.some(parseBoolExpr);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```javascript\\nconst splitExpression = (expression) => {\\n  const exprs = [];\\n  let lastBreakPoint = -1;\\n  let openedPara = 0;\\n  for (let i = 0; i < expression.length; i++) {\\n    const char = expression[i];\\n    if (char === \\'(\\') openedPara++;\\n    if (char === \\')\\') openedPara--;\\n    if (openedPara === 0 && char === \\',\\') {\\n      exprs.push(expression.slice(lastBreakPoint + 1, i));\\n      lastBreakPoint = i;\\n    }\\n  }\\n  // Add remaining text as last exp\\n  exprs.push(expression.slice(lastBreakPoint + 1));\\n  return exprs;\\n};\\n\\n/**\\n * @param {string} expression\\n * @return {boolean}\\n */\\nvar parseBoolExpr = function (expression) {\\n  if (expression === \\'t\\') return true;\\n  if (expression === \\'f\\') return false;\\n  // remove first char and surrounding parentheses\\n  const innerExpression = expression.slice(2, -1);\\n\\n  if (expression[0] === \\'!\\') return !parseBoolExpr(innerExpression);\\n  const splitExpr = splitExpression(innerExpression);\\n  if (expression[0] === \\'&\\') return splitExpr.every(parseBoolExpr);\\n  if (expression[0] === \\'|\\') return splitExpr.some(parseBoolExpr);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1762748,
                "title": "simple-c-solution-this-is-not-hard-problem-medium-level-runtime-19ms",
                "content": "```\\nclass Solution {\\npublic:\\n   \\n    // Hint : Write a function \"parse\" which calls helper functions \"parse_or\", \"parse_and\", \"parse_not\".\\n    \\n    char parse_or(vector<char>&operands){\\n        for(auto ch : operands){\\n            if(ch == \\'t\\')\\n                return \\'t\\';\\n        }\\n        return \\'f\\';\\n    }\\n    \\n    char parse_not(vector<char>&operands){\\n        if (operands[0] == \\'t\\') {\\n            return \\'f\\';\\n        }\\n        return \\'t\\';\\n    }\\n    \\n    char parse_and(vector<char>&operands){\\n        for(auto ch : operands){\\n            if(ch == \\'f\\')\\n                return \\'f\\';\\n        }\\n        return \\'t\\';\\n    }\\n    \\n    bool isOperator(char ch){\\n        return ch == \\'!\\' or ch == \\'&\\' or ch == \\'|\\';\\n    }\\n    \\n    bool parseBoolExpr(string exp) \\n    {    \\n        int n=exp.size();\\n        stack<char>st;\\n        for(int i=n-1;i>=0;i--) // push string in reverse order due to prefix notation\\n        {\\n            char ch = exp[i];\\n            if(ch == \\',\\')\\n                continue;\\n            else if(!isOperator(ch)) // t, f, (, )\\n            {  \\n                st.push(ch);\\n            }\\n            else\\n            {\\n                char operation = ch;\\n                st.pop(); // for (\\n                vector<char>operands;\\n                while(st.top() != \\')\\')\\n                {\\n                    operands.push_back(st.top());\\n                    st.pop();\\n                }\\n                st.pop(); // for )\\n                char result;\\n                if(operation == \\'|\\'){\\n                    result = parse_or(operands);         \\n                }\\n                else if(operation == \\'&\\'){\\n                    result = parse_and(operands);\\n                }\\n                else{\\n                    result = parse_not(operands);\\n                }\\n                st.push(result);\\n            }\\n        }\\n        return st.top() == \\'t\\' ? true : false;\\n    }\\n};\\n```\\n**if you like my approach please don\\'t forget to hit upvote button ! : )**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    // Hint : Write a function \"parse\" which calls helper functions \"parse_or\", \"parse_and\", \"parse_not\".\\n    \\n    char parse_or(vector<char>&operands){\\n        for(auto ch : operands){\\n            if(ch == \\'t\\')\\n                return \\'t\\';\\n        }\\n        return \\'f\\';\\n    }\\n    \\n    char parse_not(vector<char>&operands){\\n        if (operands[0] == \\'t\\') {\\n            return \\'f\\';\\n        }\\n        return \\'t\\';\\n    }\\n    \\n    char parse_and(vector<char>&operands){\\n        for(auto ch : operands){\\n            if(ch == \\'f\\')\\n                return \\'f\\';\\n        }\\n        return \\'t\\';\\n    }\\n    \\n    bool isOperator(char ch){\\n        return ch == \\'!\\' or ch == \\'&\\' or ch == \\'|\\';\\n    }\\n    \\n    bool parseBoolExpr(string exp) \\n    {    \\n        int n=exp.size();\\n        stack<char>st;\\n        for(int i=n-1;i>=0;i--) // push string in reverse order due to prefix notation\\n        {\\n            char ch = exp[i];\\n            if(ch == \\',\\')\\n                continue;\\n            else if(!isOperator(ch)) // t, f, (, )\\n            {  \\n                st.push(ch);\\n            }\\n            else\\n            {\\n                char operation = ch;\\n                st.pop(); // for (\\n                vector<char>operands;\\n                while(st.top() != \\')\\')\\n                {\\n                    operands.push_back(st.top());\\n                    st.pop();\\n                }\\n                st.pop(); // for )\\n                char result;\\n                if(operation == \\'|\\'){\\n                    result = parse_or(operands);         \\n                }\\n                else if(operation == \\'&\\'){\\n                    result = parse_and(operands);\\n                }\\n                else{\\n                    result = parse_not(operands);\\n                }\\n                st.push(result);\\n            }\\n        }\\n        return st.top() == \\'t\\' ? true : false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1718499,
                "title": "c-stack-simple-clean-explained",
                "content": "## Approach\\nIt is really simple to solve the problem once you figure out how to handle the string. We can always use multiple pointers like other posts, but I\\'d argue that it makes the code unclean and painful to read. So we\\'ll use stacks.\\n\\nOn first glance, we might assume that we can push the characters of the input expression as it is into the stack. But this doesn\\'t work when are faced with expressions nested inside each other. To handle that, we can push the characters in the string in reverse order. Then we will deal with each nested expression from starting from the innermost ones. For example, if we consider the expression `&(t,|(t,f,t))`.\\n\\n<img src=\"https://assets.leetcode.com/users/images/e4009d5b-35a2-4ff8-b28f-3a8a8df9c963_1643110039.4563963.png\" width=\"700\"/>\\n\\n### Steps:\\n- Push the characters in the string in reverse order onto the stack (starting from the last character). Avoid pushing commas.\\n- If you encounter an operator,\\n\\t- Store the operator in some variable, I\\'ve called it ```operation```\\n\\t- Pop the operator (if you\\'d pushed it)\\n\\t- Pop the opening round bracket ```(```\\n\\t- Until you encounter the closing bracket ```)```,\\n\\t\\t- Pop the operands (```t``` or ```f```)\\n\\t\\t- Save it in a vector, let\\'s call it ```operands```\\n\\t- Pop the closing round bracket ```)```\\n\\t- Pass the vector ```operands``` to a compute the result based on the operation to be performed\\n\\t\\t- In my implementation, I have passed the operator and operands to a function named ```parser()```  which is calls the required operation accordingly.\\n\\t\\t- The ```parse_not()```, ```parse_and()``` and ```parse_or()``` functions handle the operations NOT, AND and OR (`!`, `&` and `|`) respectively.\\n\\t- Push the returned result from the operation onto the stack again.\\n\\t- Continue until all characters in the string have been pushed\\n\\t- The topmost element, will then provide the result of the entire boolean expression. \\n\\t\\t- Hence return `true` if calling top() on the stack returns `t` or else return `f`.\\n\\nLogic of boolean operations themselves:\\n- AND -> Result is `false`  even if one of the operands are false, regardless of the number of operands\\n- OR -> Result is `true` even if one of the operands are true, regardless of the number of operands\\n- NOT -> Result is the complement of the boolean value (`!(true) = false`, `!(false) = true`)\\n\\n### C++ Solution\\n```\\nclass Solution {\\npublic:\\n    bool isOperator(char c) {\\n        return c == \\'|\\' || c == \\'&\\' || c == \\'!\\';\\n    }\\n    \\n    char parse_not(vector<char> operands) {\\n        if (operands[0] == \\'t\\') {\\n            return \\'f\\';\\n        }\\n        return \\'t\\';\\n    }\\n    \\n    char parse_or(vector<char> operands) {\\n        for (char o : operands) {\\n            if (o == \\'t\\') {\\n                return \\'t\\';\\n            }\\n        }\\n        return \\'f\\';\\n    }\\n    \\n    char parse_and(vector<char> operands) {\\n        for (char o : operands) {\\n            if (o == \\'f\\') {\\n                return \\'f\\';\\n            }\\n        }\\n        return \\'t\\';\\n    }\\n    \\n    char parser(char op, vector<char> operands) {\\n        if (op == \\'!\\') {\\n            return parse_not(operands);\\n        } else if (op == \\'|\\') {\\n            return parse_or(operands);\\n        } else if (op == \\'&\\') {\\n            return parse_and(operands);\\n        }\\n        return op;\\n    }\\n    \\n    bool parseBoolExpr(string expression) {\\n        stack<char> s;\\n        char operation;\\n        for (int i = expression.size() - 1; i >= 0; i--) {\\n            if (expression[i] != \\',\\') {\\n                s.push(expression[i]); // push character onto stack\\n    \\n                if (isOperator(s.top())) {\\n                    operation = s.top();\\n                    s.pop(); // pop the operator\\n                    s.pop(); // pop the (\\n                    \\n                    vector<char> operands;\\n                    while (s.top() != \\')\\') {\\n                        operands.push_back(s.top()); // push an operand\\n                        s.pop(); // remove the operand\\n                    }\\n                    s.pop(); // pop the )\\n                    s.push(parser(operation, operands));\\n                }\\n            }\\n        }\\n        \\n        if (s.top() == \\'t\\') {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```operation```\n```(```\n```)```\n```t```\n```f```\n```operands```\n```)```\n```operands```\n```parser()```\n```parse_not()```\n```parse_and()```\n```parse_or()```\n```\\nclass Solution {\\npublic:\\n    bool isOperator(char c) {\\n        return c == \\'|\\' || c == \\'&\\' || c == \\'!\\';\\n    }\\n    \\n    char parse_not(vector<char> operands) {\\n        if (operands[0] == \\'t\\') {\\n            return \\'f\\';\\n        }\\n        return \\'t\\';\\n    }\\n    \\n    char parse_or(vector<char> operands) {\\n        for (char o : operands) {\\n            if (o == \\'t\\') {\\n                return \\'t\\';\\n            }\\n        }\\n        return \\'f\\';\\n    }\\n    \\n    char parse_and(vector<char> operands) {\\n        for (char o : operands) {\\n            if (o == \\'f\\') {\\n                return \\'f\\';\\n            }\\n        }\\n        return \\'t\\';\\n    }\\n    \\n    char parser(char op, vector<char> operands) {\\n        if (op == \\'!\\') {\\n            return parse_not(operands);\\n        } else if (op == \\'|\\') {\\n            return parse_or(operands);\\n        } else if (op == \\'&\\') {\\n            return parse_and(operands);\\n        }\\n        return op;\\n    }\\n    \\n    bool parseBoolExpr(string expression) {\\n        stack<char> s;\\n        char operation;\\n        for (int i = expression.size() - 1; i >= 0; i--) {\\n            if (expression[i] != \\',\\') {\\n                s.push(expression[i]); // push character onto stack\\n    \\n                if (isOperator(s.top())) {\\n                    operation = s.top();\\n                    s.pop(); // pop the operator\\n                    s.pop(); // pop the (\\n                    \\n                    vector<char> operands;\\n                    while (s.top() != \\')\\') {\\n                        operands.push_back(s.top()); // push an operand\\n                        s.pop(); // remove the operand\\n                    }\\n                    s.pop(); // pop the )\\n                    s.push(parser(operation, operands));\\n                }\\n            }\\n        }\\n        \\n        if (s.top() == \\'t\\') {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1636355,
                "title": "python-sol-stack",
                "content": "```python\\nclass Solution:\\n    def parseBoolExpr(self, e: str) -> bool:\\n        stack = []\\n        op = []\\n        for i in range(len(e)):\\n            if e[i] == \\')\\':\\n                sube = []\\n                while stack[-1] != \\'(\\':\\n                    last = stack.pop()\\n                    if last != \\',\\':\\n                        sube.append(last)\\n                stack.pop()\\n                add = []\\n                assert len(sube) > 0\\n                if stack[-1] == \\'!\\':\\n                    assert len(sube) == 1\\n                    if sube[0] == \\'f\\':\\n                        add.append(\\'t\\')\\n                    else:\\n                        add.append(\\'f\\')\\n                elif stack[-1] == \\'|\\':\\n                    if \\'t\\' in sube:\\n                        add.append(\\'t\\')\\n                    else:\\n                        add.append(\\'f\\')\\n                elif stack[-1] == \\'&\\':\\n                    if \\'f\\' in sube:\\n                        add.append(\\'f\\')\\n                    else:\\n                        add.append(\\'t\\')\\n                stack.pop()\\n                stack.append(add[0])\\n            else:\\n                if e[i] in (\\'!\\', \\'&\\', \\'|\\'):\\n                    op.append(e[i])\\n                stack.append(e[i])\\n        assert len(stack) == 1\\n        if stack[0] == \\'t\\':\\n            return 1\\n        else:\\n            return 0\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def parseBoolExpr(self, e: str) -> bool:\\n        stack = []\\n        op = []\\n        for i in range(len(e)):\\n            if e[i] == \\')\\':\\n                sube = []\\n                while stack[-1] != \\'(\\':\\n                    last = stack.pop()\\n                    if last != \\',\\':\\n                        sube.append(last)\\n                stack.pop()\\n                add = []\\n                assert len(sube) > 0\\n                if stack[-1] == \\'!\\':\\n                    assert len(sube) == 1\\n                    if sube[0] == \\'f\\':\\n                        add.append(\\'t\\')\\n                    else:\\n                        add.append(\\'f\\')\\n                elif stack[-1] == \\'|\\':\\n                    if \\'t\\' in sube:\\n                        add.append(\\'t\\')\\n                    else:\\n                        add.append(\\'f\\')\\n                elif stack[-1] == \\'&\\':\\n                    if \\'f\\' in sube:\\n                        add.append(\\'f\\')\\n                    else:\\n                        add.append(\\'t\\')\\n                stack.pop()\\n                stack.append(add[0])\\n            else:\\n                if e[i] in (\\'!\\', \\'&\\', \\'|\\'):\\n                    op.append(e[i])\\n                stack.append(e[i])\\n        assert len(stack) == 1\\n        if stack[0] == \\'t\\':\\n            return 1\\n        else:\\n            return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1480431,
                "title": "o-n-stack-solution-java",
                "content": "```\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        int n = expression.length();\\n        Stack<Character> stack = new Stack<>();\\n        for (int i = 0; i < n; i++) {\\n            char c = expression.charAt(i);\\n            if (c == \\')\\') {\\n                StringBuilder sb = new StringBuilder();\\n                while(stack.peek() != \\'(\\') {\\n                    char cc = stack.pop();\\n                    if (cc == \\',\\')\\n                        continue;\\n                    sb.append(cc);\\n                }\\n                stack.pop(); // pop opening parenthesis\\n                char operator = stack.pop();\\n                char result = evaluate(operator, sb.toString());\\n                stack.push(result);\\n            } else {\\n                stack.push(c);\\n            }\\n        }\\n        char result = stack.pop();\\n        return result == \\'t\\';\\n    }\\n    \\n    private char evaluate(char operator, String seq) {\\n        char result = \\'f\\';\\n        switch(operator) {\\n            case \\'&\\': {\\n                result = performAnd(seq);\\n                break;\\n            }\\n            case \\'|\\': {\\n                result = performOr(seq);\\n                break;\\n            }\\n            case \\'!\\': {\\n                result = performNot(seq);\\n                break;\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private char performAnd(String seq) {\\n        for (char c : seq.toCharArray()) {\\n            if (c == \\'f\\')\\n                return \\'f\\';\\n        }\\n        return \\'t\\';\\n    }\\n    \\n    private char performOr(String seq) {\\n        for (char c : seq.toCharArray()) {\\n            if (c == \\'t\\')\\n                return \\'t\\';\\n        }\\n        return \\'f\\';\\n    }\\n    \\n    private char performNot(String seq) {\\n        return seq.charAt(0) == \\'f\\' ? \\'t\\' : \\'f\\';\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        int n = expression.length();\\n        Stack<Character> stack = new Stack<>();\\n        for (int i = 0; i < n; i++) {\\n            char c = expression.charAt(i);\\n            if (c == \\')\\') {\\n                StringBuilder sb = new StringBuilder();\\n                while(stack.peek() != \\'(\\') {\\n                    char cc = stack.pop();\\n                    if (cc == \\',\\')\\n                        continue;\\n                    sb.append(cc);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1473527,
                "title": "python-stack-easy-to-understand-solution",
                "content": "```\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        stack = [] # stack[-1] stores the expression evaluation, stack[-2] stores the operator\\n        \\n        def compute(op, ex1, ex2):\\n            if op == \\'!\\':\\n                return not ex1\\n            elif op == \\'&\\':\\n                return ex1 and ex2\\n            elif op == \\'|\\':\\n                return ex1 or ex2\\n        \\n        for c in expression:\\n            if c in \"!|&\":\\n                stack.append(c)\\n                stack.append(False if c == \\'|\\' else True) # caveat: | needs to start with \"False\" as expression evaluation or else it will always evaluate to True\\n            elif c in \\'(,\\':\\n                continue\\n            elif c in \"tf\":\\n                stack[-1] = compute(stack[-2], True if c == \\'t\\' else False, stack[-1])\\n            elif c == \\')\\':\\n                cur_ex = stack[-1]\\n                stack.pop()\\n                stack.pop()\\n                if not stack: return cur_ex\\n                stack[-1] = compute(stack[-2], cur_ex, stack[-1])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        stack = [] # stack[-1] stores the expression evaluation, stack[-2] stores the operator\\n        \\n        def compute(op, ex1, ex2):\\n            if op == \\'!\\':\\n                return not ex1\\n            elif op == \\'&\\':\\n                return ex1 and ex2\\n            elif op == \\'|\\':\\n                return ex1 or ex2\\n        \\n        for c in expression:\\n            if c in \"!|&\":\\n                stack.append(c)\\n                stack.append(False if c == \\'|\\' else True) # caveat: | needs to start with \"False\" as expression evaluation or else it will always evaluate to True\\n            elif c in \\'(,\\':\\n                continue\\n            elif c in \"tf\":\\n                stack[-1] = compute(stack[-2], True if c == \\'t\\' else False, stack[-1])\\n            elif c == \\')\\':\\n                cur_ex = stack[-1]\\n                stack.pop()\\n                stack.pop()\\n                if not stack: return cur_ex\\n                stack[-1] = compute(stack[-2], cur_ex, stack[-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1456238,
                "title": "c-4ms-94-faster-sol-recursive-easy-to-understand-but-a-little-lengthy",
                "content": "basic logic behind the code is if while iterating through the code if s[i] becomes equal to !,|,& we create a static stack to avoid re declaration in case recursive call is not made or loop does not end then we push the element at i+1 index into the stack as i is one of the boolean operator the next element is bound to be\\'(\\' then we simply run a while loop till the stack is empty this will make us reach the pos\\'n after the closing bracket(\\')\\')in the string the we create a substring from pos\\'n j+2 j being the initial value of i i.e (operator pos\\'n) for the length i-j-3 and pass the string by reference to appropriate function and do this recursively until whole string is evaluated.\\n```\\nstring And(string &s);\\nstring OR(string &s);\\nstring Not(string &s);\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string s) {\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'!\\'||s[i]==\\'&\\'||s[i]==\\'|\\'){\\n                int j=i;\\n                static stack<char>stk;\\n                stk.push(s[j+1]);\\n                i=j+2;\\n                while(!stk.empty()){\\n                    if(s[i]==\\'(\\'){\\n                        stk.push(s[i]);\\n                        i++;\\n                        continue;\\n                    }\\n                    if(s[i]==\\')\\') {\\n                        stk.pop();\\n                        i++;\\n                        continue;\\n                    }\\n                    i++;\\n                }\\n                if(s[j]==\\'&\\') {\\n                    string str = (s.substr(j + 2, i - j - 3));\\n                    str= And(str);\\n                    if(j!=0){\\n                        s.replace(j,i-j,str);\\n                    }else {\\n                        s.replace(j, i, str);\\n                    }\\n                }\\n                if(s[j]==\\'!\\') {\\n                    string str = (s.substr(j + 2, i - j - 3));\\n                    str=Not(str);\\n                    if(j!=0){\\n                        s.replace(j,i-j,str);\\n                    }else {\\n                        s.replace(j, i, str);\\n                    }\\n                }\\n                if(s[j]==\\'|\\') {\\n                    string str = (s.substr(j + 2, i - j - 3));\\n                    str=OR(str);\\n                    if(j!=0){\\n                        s.replace(j,i-j,str);\\n                    }else {\\n                        s.replace(j, i, str);\\n                    }\\n                }i=-1;continue;//to make the loop again run from start \\n            }\\n        }\\n\\n            if(s[0]==\\'t\\')\\n                return true;\\n            if(s[0]==\\'f\\')\\n                return false;\\n\\n        return \"\";\\n    }\\n};\\n\\nstring OR(string &s) {\\n    for(int i=0;i<s.size();i++){\\n        if(s[i]==\\'!\\'||s[i]==\\'&\\'||s[i]==\\'|\\'){\\n            int j=i;\\n            static stack<char>stk;\\n            stk.push(s[j+1]);\\n            i=j+2;\\n            while(!stk.empty()){\\n                if(s[i]==\\'(\\'){\\n                    stk.push(s[i]);\\n                    i++;\\n                    continue;\\n                }\\n                if(s[i]==\\')\\') {\\n                    stk.pop();\\n                    i++;\\n                    continue;\\n                }\\n                i++;\\n            }\\n            if(s[j]==\\'&\\') {\\n                string str = (s.substr(j + 2, i - j - 3));\\n                str= And(str);\\n                if(j!=0){\\n                    s.replace(j,i-j,str);\\n                }else {\\n                    s.replace(j, i, str);\\n                }\\n            }\\n            if(s[j]==\\'!\\') {\\n                string str = (s.substr(j + 2, i - j - 3));\\n                str=Not(str);\\n                if(j!=0){\\n                    s.replace(j,i-j,str);\\n                }else {\\n                    s.replace(j, i, str);\\n                }\\n            }\\n            if(s[j]==\\'|\\') {\\n                string str = (s.substr(j + 2, i - j - 3));\\n                str=OR(str);\\n                if(j!=0){\\n                    s.replace(j,i-j,str);\\n                }else {\\n                    s.replace(j, i, str);\\n                }\\n            }i=-1;continue;//to make the loop again run from start \\n        }\\n        if(s[i]==\\'t\\')\\n            return \"t\";\\n    }\\n    return \"f\";\\n}\\nstring Not(string &s) {\\n    for(int i=0;i<s.size();i++){\\n        if(s[i]==\\'!\\'||s[i]==\\'&\\'||s[i]==\\'|\\'){\\n            int j=i;\\n            static stack<char>stk;\\n            stk.push(s[j+1]);\\n            i=j+2;\\n            while(!stk.empty()){\\n                if(s[i]==\\'(\\'){\\n                    stk.push(s[i]);\\n                    i++;\\n                    continue;\\n                }\\n                if(s[i]==\\')\\') {\\n                    stk.pop();\\n                    i++;\\n                    continue;\\n                }\\n                i++;\\n            }\\n            if(s[j]==\\'&\\') {\\n                string str = (s.substr(j + 2, i - j - 3));\\n                str= And(str);\\n                if(j!=0){\\n                    s.replace(j,i-j,str);\\n                }else {\\n                    s.replace(j, i, str);\\n                }\\n            }\\n            if(s[j]==\\'!\\') {\\n                string str = (s.substr(j + 2, i - j - 3));\\n                str=Not(str);\\n                if(j!=0){\\n                    s.replace(j,i-j,str);\\n                }else {\\n                    s.replace(j, i, str);\\n                }\\n            }\\n            if(s[j]==\\'|\\') {\\n                string str = (s.substr(j + 2, i - j - 3));\\n                str=OR(str);\\n                if(j!=0){\\n                    s.replace(j,i-j,str);\\n                }else {\\n                    s.replace(j, i, str);\\n                }\\n            }i=-1;continue;//to make the loop again run from start \\n        }\\n        if(s[i]==\\'t\\')\\n            return \"f\";\\n        if(s[i]==\\'f\\')\\n            return \"t\";\\n    }\\n    return \"\";\\n}\\nstring And(string &s) {\\n    for(int i=0;i<s.size();i++){\\n        if(s[i]==\\'!\\'||s[i]==\\'&\\'||s[i]==\\'|\\'){\\n            int j=i;\\n            static stack<char>stk;\\n            stk.push(s[j+1]);\\n            i=j+2;\\n            while(!stk.empty()){\\n                if(s[i]==\\'(\\'){\\n                    stk.push(s[i]);\\n                    i++;\\n                    continue;\\n                }\\n                if(s[i]==\\')\\') {\\n                    stk.pop();\\n                    i++;\\n                    continue;\\n                }\\n                i++;\\n            }\\n            if(s[j]==\\'&\\') {\\n                string str = (s.substr(j + 2, i - j - 3));\\n                str= And(str);\\n                if(j!=0){\\n                 s.replace(j,i-j,str);\\n                }else {\\n                    s.replace(j, i, str);\\n                }\\n            }\\n            if(s[j]==\\'!\\') {\\n                string str = (s.substr(j + 2, i - j - 3));\\n                str=Not(str);\\n                if(j!=0){\\n                    s.replace(j,i-j,str);\\n                }else {\\n                    s.replace(j, i, str);\\n                }\\n            }\\n            if(s[j]==\\'|\\') {\\n                string str = (s.substr(j + 2, i - j - 3));\\n                str=OR(str);\\n                if(j!=0){\\n                    s.replace(j,i-j,str);\\n                }else {\\n                    s.replace(j, i, str);\\n                }\\n            }i=-1;continue;//to make the loop again run from start \\n        }\\n        if(s[i]==\\'f\\')\\n            return \"f\";\\n    }\\n    return \"t\";\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstring And(string &s);\\nstring OR(string &s);\\nstring Not(string &s);\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string s) {\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'!\\'||s[i]==\\'&\\'||s[i]==\\'|\\'){\\n                int j=i;\\n                static stack<char>stk;\\n                stk.push(s[j+1]);\\n                i=j+2;\\n                while(!stk.empty()){\\n                    if(s[i]==\\'(\\'){\\n                        stk.push(s[i]);\\n                        i++;\\n                        continue;\\n                    }\\n                    if(s[i]==\\')\\') {\\n                        stk.pop();\\n                        i++;\\n                        continue;\\n                    }\\n                    i++;\\n                }\\n                if(s[j]==\\'&\\') {\\n                    string str = (s.substr(j + 2, i - j - 3));\\n                    str= And(str);\\n                    if(j!=0){\\n                        s.replace(j,i-j,str);\\n                    }else {\\n                        s.replace(j, i, str);\\n                    }\\n                }\\n                if(s[j]==\\'!\\') {\\n                    string str = (s.substr(j + 2, i - j - 3));\\n                    str=Not(str);\\n                    if(j!=0){\\n                        s.replace(j,i-j,str);\\n                    }else {\\n                        s.replace(j, i, str);\\n                    }\\n                }\\n                if(s[j]==\\'|\\') {\\n                    string str = (s.substr(j + 2, i - j - 3));\\n                    str=OR(str);\\n                    if(j!=0){\\n                        s.replace(j,i-j,str);\\n                    }else {\\n                        s.replace(j, i, str);\\n                    }\\n                }i=-1;continue;//to make the loop again run from start \\n            }\\n        }\\n\\n            if(s[0]==\\'t\\')\\n                return true;\\n            if(s[0]==\\'f\\')\\n                return false;\\n\\n        return \"\";\\n    }\\n};\\n\\nstring OR(string &s) {\\n    for(int i=0;i<s.size();i++){\\n        if(s[i]==\\'!\\'||s[i]==\\'&\\'||s[i]==\\'|\\'){\\n            int j=i;\\n            static stack<char>stk;\\n            stk.push(s[j+1]);\\n            i=j+2;\\n            while(!stk.empty()){\\n                if(s[i]==\\'(\\'){\\n                    stk.push(s[i]);\\n                    i++;\\n                    continue;\\n                }\\n                if(s[i]==\\')\\') {\\n                    stk.pop();\\n                    i++;\\n                    continue;\\n                }\\n                i++;\\n            }\\n            if(s[j]==\\'&\\') {\\n                string str = (s.substr(j + 2, i - j - 3));\\n                str= And(str);\\n                if(j!=0){\\n                    s.replace(j,i-j,str);\\n                }else {\\n                    s.replace(j, i, str);\\n                }\\n            }\\n            if(s[j]==\\'!\\') {\\n                string str = (s.substr(j + 2, i - j - 3));\\n                str=Not(str);\\n                if(j!=0){\\n                    s.replace(j,i-j,str);\\n                }else {\\n                    s.replace(j, i, str);\\n                }\\n            }\\n            if(s[j]==\\'|\\') {\\n                string str = (s.substr(j + 2, i - j - 3));\\n                str=OR(str);\\n                if(j!=0){\\n                    s.replace(j,i-j,str);\\n                }else {\\n                    s.replace(j, i, str);\\n                }\\n            }i=-1;continue;//to make the loop again run from start \\n        }\\n        if(s[i]==\\'t\\')\\n            return \"t\";\\n    }\\n    return \"f\";\\n}\\nstring Not(string &s) {\\n    for(int i=0;i<s.size();i++){\\n        if(s[i]==\\'!\\'||s[i]==\\'&\\'||s[i]==\\'|\\'){\\n            int j=i;\\n            static stack<char>stk;\\n            stk.push(s[j+1]);\\n            i=j+2;\\n            while(!stk.empty()){\\n                if(s[i]==\\'(\\'){\\n                    stk.push(s[i]);\\n                    i++;\\n                    continue;\\n                }\\n                if(s[i]==\\')\\') {\\n                    stk.pop();\\n                    i++;\\n                    continue;\\n                }\\n                i++;\\n            }\\n            if(s[j]==\\'&\\') {\\n                string str = (s.substr(j + 2, i - j - 3));\\n                str= And(str);\\n                if(j!=0){\\n                    s.replace(j,i-j,str);\\n                }else {\\n                    s.replace(j, i, str);\\n                }\\n            }\\n            if(s[j]==\\'!\\') {\\n                string str = (s.substr(j + 2, i - j - 3));\\n                str=Not(str);\\n                if(j!=0){\\n                    s.replace(j,i-j,str);\\n                }else {\\n                    s.replace(j, i, str);\\n                }\\n            }\\n            if(s[j]==\\'|\\') {\\n                string str = (s.substr(j + 2, i - j - 3));\\n                str=OR(str);\\n                if(j!=0){\\n                    s.replace(j,i-j,str);\\n                }else {\\n                    s.replace(j, i, str);\\n                }\\n            }i=-1;continue;//to make the loop again run from start \\n        }\\n        if(s[i]==\\'t\\')\\n            return \"f\";\\n        if(s[i]==\\'f\\')\\n            return \"t\";\\n    }\\n    return \"\";\\n}\\nstring And(string &s) {\\n    for(int i=0;i<s.size();i++){\\n        if(s[i]==\\'!\\'||s[i]==\\'&\\'||s[i]==\\'|\\'){\\n            int j=i;\\n            static stack<char>stk;\\n            stk.push(s[j+1]);\\n            i=j+2;\\n            while(!stk.empty()){\\n                if(s[i]==\\'(\\'){\\n                    stk.push(s[i]);\\n                    i++;\\n                    continue;\\n                }\\n                if(s[i]==\\')\\') {\\n                    stk.pop();\\n                    i++;\\n                    continue;\\n                }\\n                i++;\\n            }\\n            if(s[j]==\\'&\\') {\\n                string str = (s.substr(j + 2, i - j - 3));\\n                str= And(str);\\n                if(j!=0){\\n                 s.replace(j,i-j,str);\\n                }else {\\n                    s.replace(j, i, str);\\n                }\\n            }\\n            if(s[j]==\\'!\\') {\\n                string str = (s.substr(j + 2, i - j - 3));\\n                str=Not(str);\\n                if(j!=0){\\n                    s.replace(j,i-j,str);\\n                }else {\\n                    s.replace(j, i, str);\\n                }\\n            }\\n            if(s[j]==\\'|\\') {\\n                string str = (s.substr(j + 2, i - j - 3));\\n                str=OR(str);\\n                if(j!=0){\\n                    s.replace(j,i-j,str);\\n                }else {\\n                    s.replace(j, i, str);\\n                }\\n            }i=-1;continue;//to make the loop again run from start \\n        }\\n        if(s[i]==\\'f\\')\\n            return \"f\";\\n    }\\n    return \"t\";\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1433025,
                "title": "c-96-recursion-not-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n        if (expression == \"t\") return true;\\n        if (expression == \"f\") return false;\\n        \\n        auto oprt = expression[0];\\n        \\n        if (oprt == \\'!\\') {\\n            expression.pop_back();\\n            auto expr = expression.substr(2);\\n            return !parseBoolExpr(expr);\\n        }\\n        \\n        expression.pop_back();\\n        auto subexpr = expression.substr(2);\\n        int stk = 0;\\n        string expr;\\n        vector<string> exprs;\\n        for (auto cr : subexpr) {\\n            if (cr == \\'(\\') stk++;\\n            if (cr == \\')\\') stk--;\\n            if (cr == \\',\\') {\\n                if (stk == 0) {\\n                    exprs.push_back(expr);\\n                    expr = \"\";\\n                    continue;\\n                }\\n            }\\n            expr.push_back(cr);\\n        }\\n        \\n        exprs.push_back(expr);\\n        \\n        bool flag;\\n        if (oprt == \\'&\\') {\\n            flag = true;\\n            for (auto e : exprs) {\\n                flag = flag && parseBoolExpr(e);\\n            }\\n\\n        }\\n        \\n        if (oprt == \\'|\\') {\\n            flag = false;\\n            for (auto e : exprs) {\\n                flag = flag || parseBoolExpr(e);\\n            }\\n        }\\n        \\n        return flag;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n        if (expression == \"t\") return true;\\n        if (expression == \"f\") return false;\\n        \\n        auto oprt = expression[0];\\n        \\n        if (oprt == \\'!\\') {\\n            expression.pop_back();\\n            auto expr = expression.substr(2);\\n            return !parseBoolExpr(expr);\\n        }\\n        \\n        expression.pop_back();\\n        auto subexpr = expression.substr(2);\\n        int stk = 0;\\n        string expr;\\n        vector<string> exprs;\\n        for (auto cr : subexpr) {\\n            if (cr == \\'(\\') stk++;\\n            if (cr == \\')\\') stk--;\\n            if (cr == \\',\\') {\\n                if (stk == 0) {\\n                    exprs.push_back(expr);\\n                    expr = \"\";\\n                    continue;\\n                }\\n            }\\n            expr.push_back(cr);\\n        }\\n        \\n        exprs.push_back(expr);\\n        \\n        bool flag;\\n        if (oprt == \\'&\\') {\\n            flag = true;\\n            for (auto e : exprs) {\\n                flag = flag && parseBoolExpr(e);\\n            }\\n\\n        }\\n        \\n        if (oprt == \\'|\\') {\\n            flag = false;\\n            for (auto e : exprs) {\\n                flag = flag || parseBoolExpr(e);\\n            }\\n        }\\n        \\n        return flag;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1407632,
                "title": "cpp-solution-using-two-stacks",
                "content": "The first step is to reverse the string, so that whenever we encounter an operator, its operands are already in the stack, if we go from left to right in string.\\n\\nWhile iterating over the string, the following cases may arise:\\n1.  We encounter \\'t\\', \\'f\\', or \\')\\'. In this case, simply push to stack and continue.\\n2.  We encounter \\'(\\'. In this case, remove characters from stack until we have \\')\\' at the top of stack. This signifies that we have popped exactly one set of operands from stack.\\n3.  We encounter an operator. In this case, apply the operation on all the operands popped from stack in step 2, and store the answer back on stack.\\n\\nTo keep track of the operands we removed from our stack, we will use another temporary stack. This temporary stack would store only one set of operands at a time.\\n\\n**CODE:**\\n```\\nbool parseBoolExpr(string expression) {\\n        reverse(expression.begin(),expression.end());\\n        \\n        stack<char> s, t;\\n        for(auto c : expression) {\\n            if(c == \\')\\' || c == \\'t\\' || c == \\'f\\')\\n                s.push(c);\\n            else if(c == \\'(\\') {\\n                while(s.top() != \\')\\') {\\n                    t.push(s.top());\\n                    s.pop();\\n                }\\n                s.pop();\\n            }\\n            else if(c == \\'!\\') {\\n                char ans;\\n                while(!t.empty()) {\\n                    if(t.top() == \\'t\\')\\n                        ans = \\'f\\';\\n                    else ans = \\'t\\';\\n                    t.pop();\\n                }\\n                s.push(ans);\\n            }\\n            else if(c == \\'&\\') {\\n                char ans = \\'t\\';\\n                while(!t.empty()) {\\n                    if(t.top() == \\'f\\')\\n                        ans = \\'f\\';\\n                    t.pop();\\n                }\\n                s.push(ans);\\n            }\\n            else if(c == \\'|\\') {\\n                char ans = \\'f\\';\\n                while(!t.empty()) {\\n                    if(t.top() == \\'t\\')\\n                        ans = \\'t\\';\\n                    t.pop();\\n                }\\n                s.push(ans);\\n            }\\n        }\\n        \\n        return s.top() == \\'t\\' ? true : false;\\n    }\\n```",
                "solutionTags": [
                    "String",
                    "Stack"
                ],
                "code": "```\\nbool parseBoolExpr(string expression) {\\n        reverse(expression.begin(),expression.end());\\n        \\n        stack<char> s, t;\\n        for(auto c : expression) {\\n            if(c == \\')\\' || c == \\'t\\' || c == \\'f\\')\\n                s.push(c);\\n            else if(c == \\'(\\') {\\n                while(s.top() != \\')\\') {\\n                    t.push(s.top());\\n                    s.pop();\\n                }\\n                s.pop();\\n            }\\n            else if(c == \\'!\\') {\\n                char ans;\\n                while(!t.empty()) {\\n                    if(t.top() == \\'t\\')\\n                        ans = \\'f\\';\\n                    else ans = \\'t\\';\\n                    t.pop();\\n                }\\n                s.push(ans);\\n            }\\n            else if(c == \\'&\\') {\\n                char ans = \\'t\\';\\n                while(!t.empty()) {\\n                    if(t.top() == \\'f\\')\\n                        ans = \\'f\\';\\n                    t.pop();\\n                }\\n                s.push(ans);\\n            }\\n            else if(c == \\'|\\') {\\n                char ans = \\'f\\';\\n                while(!t.empty()) {\\n                    if(t.top() == \\'t\\')\\n                        ans = \\'t\\';\\n                    t.pop();\\n                }\\n                s.push(ans);\\n            }\\n        }\\n        \\n        return s.top() == \\'t\\' ? true : false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1388766,
                "title": "java-single-stack-easy-to-understand",
                "content": "```\\n\\nclass Solution {\\n\\tpublic boolean parseBoolExpr(String expression) {\\n        Stack<Character> stack = new Stack<>();\\n        for(int i=0;i<expression.length();i++){\\n            char ch = expression.charAt(i);\\n            if(ch == \\')\\' || ch == \\'}\\'){\\n                boolean orAns = false;\\n                boolean andAns = true;\\n                boolean NotAns = false;\\n                while(stack.peek() != \\'(\\'){\\n                    char rm = stack.pop();\\n                    if(rm == \\'f\\'){\\n                        andAns = false;\\n                    }\\n                    if(rm == \\'t\\'){\\n                        orAns = true;\\n                    }\\n                    NotAns = rm == \\'t\\' ? false:true;\\n                }\\n                stack.pop();\\n                char rm = stack.pop();\\n                if( rm == \\'&\\'){\\n                    stack.push(andAns ? \\'t\\':\\'f\\');\\n                }\\n                else if( rm == \\'|\\'){\\n                    stack.push(orAns ? \\'t\\':\\'f\\');\\n                }\\n                else if(rm == \\'!\\'){\\n                    stack.push(NotAns ? \\'t\\':\\'f\\');\\n                }\\n            }else{\\n                if(ch == \\'{\\'){\\n                    stack.push(\\'(\\');\\n                }\\n                else{\\n                     stack.push(ch);\\n                }\\n            }\\n            \\n        }\\n        \\n        return stack.pop() == \\'t\\'? true: false;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "class Solution {\\n\\tpublic boolean parseBoolExpr(String expression) {\\n        Stack<Character> stack = new Stack<>();\\n        for(int i=0;i<expression.length();i++){\\n            char ch = expression.charAt(i);\\n            if(ch == \\')\\' || ch == \\'}",
                "codeTag": "Java"
            },
            {
                "id": 1358099,
                "title": "c-clean-modularized-code",
                "content": "Process string right to left using **stack**.\\n\\n```\\nbool parseBoolExpr(string s) {\\n\\tint N=s.size();\\n\\tstack<char> stk;\\n\\tfor(int j=N-1; j>=0; j--) {\\n\\t\\tif (s[j] == \\',\\') continue;\\n\\t\\telse if (s[j] == \\')\\') stk.push(s[j]);\\n\\t\\telse if (s[j] == \\'(\\') {\\n\\t\\t\\tchar op = s[j-1];\\n\\t\\t\\tvector<bool> v;\\n\\t\\t\\twhile(stk.top() != \\')\\') {\\n\\t\\t\\t\\tv.push_back(toBool(stk.top()));  stk.pop();\\n\\t\\t\\t}\\n\\t\\t\\tstk.pop();\\n\\t\\t\\tstk.push(evaluate(op, v));\\n\\t\\t\\tj--;\\n\\t\\t} else stk.push(s[j]);\\n\\t}\\n\\treturn toBool(stk.top());\\n} \\n```\\n\\nHelpers: \\n```\\nchar evaluate(char op, vector<bool> &operands) {\\n\\tint result = op == \\'&\\' ? true : false;\\n\\tfor(bool v: operands) {\\n\\t\\tif (op == \\'!\\') return !v ? \\'t\\' : \\'f\\';\\n\\t\\telse if (op == \\'|\\') result |= v;\\n\\t\\telse result &= v;\\n\\t}\\n\\treturn result ? \\'t\\' : \\'f\\';\\n}\\n```\\n```\\nbool toBool(char c) {\\n\\treturn c == \\'t\\';\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool parseBoolExpr(string s) {\\n\\tint N=s.size();\\n\\tstack<char> stk;\\n\\tfor(int j=N-1; j>=0; j--) {\\n\\t\\tif (s[j] == \\',\\') continue;\\n\\t\\telse if (s[j] == \\')\\') stk.push(s[j]);\\n\\t\\telse if (s[j] == \\'(\\') {\\n\\t\\t\\tchar op = s[j-1];\\n\\t\\t\\tvector<bool> v;\\n\\t\\t\\twhile(stk.top() != \\')\\') {\\n\\t\\t\\t\\tv.push_back(toBool(stk.top()));  stk.pop();\\n\\t\\t\\t}\\n\\t\\t\\tstk.pop();\\n\\t\\t\\tstk.push(evaluate(op, v));\\n\\t\\t\\tj--;\\n\\t\\t} else stk.push(s[j]);\\n\\t}\\n\\treturn toBool(stk.top());\\n} \\n```\n```\\nchar evaluate(char op, vector<bool> &operands) {\\n\\tint result = op == \\'&\\' ? true : false;\\n\\tfor(bool v: operands) {\\n\\t\\tif (op == \\'!\\') return !v ? \\'t\\' : \\'f\\';\\n\\t\\telse if (op == \\'|\\') result |= v;\\n\\t\\telse result &= v;\\n\\t}\\n\\treturn result ? \\'t\\' : \\'f\\';\\n}\\n```\n```\\nbool toBool(char c) {\\n\\treturn c == \\'t\\';\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1351672,
                "title": "simple-and-clean-solution-using-recursion-pyhton",
                "content": "```\\nclass Solution:\\n    def parseBoolExpr(self, expression):\\n        l=len(expression)\\n        for i in range(l):\\n            if expression[i]==\"(\": st=i\\n            if expression[i]==\")\":\\n                en=i\\n                break\\n        op=expression[st-1]\\n        #print(op)\\n        #print(expression[st:en+1])\\n        if op==\"&\": v=self.And(expression[st:en+1])\\n        if op==\"|\": v=self.Nor(expression[st:en+1])\\n        if op==\"!\": v=self.Not(expression[st:en+1])\\n        expression=expression[:st-1]+v+expression[en+1:]\\n        if expression==\"f\": return False\\n        if expression==\"t\": return True\\n        else: return self.parseBoolExpr(expression)\\n    \\n    def Not(self,exp):\\n        if \"t\" in exp: return \"f\"\\n        return \"t\"\\n    def Nor(self,exp):\\n        if \"t\" in exp: return \"t\"\\n        return \"f\"\\n    def And(self,exp):\\n        if \"f\" in exp: return \"f\"\\n        return \"t\"\\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def parseBoolExpr(self, expression):\\n        l=len(expression)\\n        for i in range(l):\\n            if expression[i]==\"(\": st=i\\n            if expression[i]==\")\":\\n                en=i\\n                break\\n        op=expression[st-1]\\n        #print(op)\\n        #print(expression[st:en+1])\\n        if op==\"&\": v=self.And(expression[st:en+1])\\n        if op==\"|\": v=self.Nor(expression[st:en+1])\\n        if op==\"!\": v=self.Not(expression[st:en+1])\\n        expression=expression[:st-1]+v+expression[en+1:]\\n        if expression==\"f\": return False\\n        if expression==\"t\": return True\\n        else: return self.parseBoolExpr(expression)\\n    \\n    def Not(self,exp):\\n        if \"t\" in exp: return \"f\"\\n        return \"t\"\\n    def Nor(self,exp):\\n        if \"t\" in exp: return \"t\"\\n        return \"f\"\\n    def And(self,exp):\\n        if \"f\" in exp: return \"f\"\\n        return \"t\"\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1135308,
                "title": "c-solution-only-one-stack-solution-4ms-runtime",
                "content": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string s) {\\n       stack<char> stk;\\n        \\n        for(int i=s.size()-1;i>=0;i--)\\n        {\\n            if(s[i]==\\',\\') continue;\\n            \\n            else if(s[i]==\\'f\\' || s[i]==\\'t\\' || s[i]==\\')\\' || s[i]==\\'(\\') stk.push(s[i]);\\n            \\n            else if(s[i]==\\'!\\')\\n            {\\n                bool exp=true;\\n                while(1)\\n                {\\n                   char x = stk.top(); stk.pop();\\n                    if(x==\\'(\\') continue;\\n                    else if(x==\\'f\\') exp=true;\\n                    else if(x==\\'t\\') exp=false;\\n                    else if(x==\\')\\')\\n                    {\\n                       if(exp) stk.push(\\'t\\');\\n                        else stk.push(\\'f\\');\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            else if(s[i]==\\'|\\')\\n            {\\n                bool exp=false;\\n                while(1)\\n                {\\n                    char x = stk.top(); stk.pop();\\n                    if(x==\\'(\\') continue;\\n                    else if(x==\\'f\\') exp=exp|false;\\n                    else if(x==\\'t\\') exp=exp|true;\\n                    else if(x==\\')\\')\\n                    {\\n                       if(exp) stk.push(\\'t\\');\\n                        else stk.push(\\'f\\');\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            else if(s[i]==\\'&\\')\\n            {\\n                bool exp=true;\\n                while(1)\\n                {\\n                    char x = stk.top(); stk.pop();\\n                    if(x==\\'(\\') continue;\\n                    else if(x==\\'f\\') exp=exp & false;\\n                    else if(x==\\'t\\') exp=exp & true;\\n                    else if(x==\\')\\')\\n                    {\\n                       if(exp) stk.push(\\'t\\');\\n                        else stk.push(\\'f\\');\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if(stk.top()==\\'t\\') return true;\\n        else return false;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string s) {\\n       stack<char> stk;\\n        \\n        for(int i=s.size()-1;i>=0;i--)\\n        {\\n            if(s[i]==\\',\\') continue;\\n            \\n            else if(s[i]==\\'f\\' || s[i]==\\'t\\' || s[i]==\\')\\' || s[i]==\\'(\\') stk.push(s[i]);\\n            \\n            else if(s[i]==\\'!\\')\\n            {\\n                bool exp=true;\\n                while(1)\\n                {\\n                   char x = stk.top(); stk.pop();\\n                    if(x==\\'(\\') continue;\\n                    else if(x==\\'f\\') exp=true;\\n                    else if(x==\\'t\\') exp=false;\\n                    else if(x==\\')\\')\\n                    {\\n                       if(exp) stk.push(\\'t\\');\\n                        else stk.push(\\'f\\');\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            else if(s[i]==\\'|\\')\\n            {\\n                bool exp=false;\\n                while(1)\\n                {\\n                    char x = stk.top(); stk.pop();\\n                    if(x==\\'(\\') continue;\\n                    else if(x==\\'f\\') exp=exp|false;\\n                    else if(x==\\'t\\') exp=exp|true;\\n                    else if(x==\\')\\')\\n                    {\\n                       if(exp) stk.push(\\'t\\');\\n                        else stk.push(\\'f\\');\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            else if(s[i]==\\'&\\')\\n            {\\n                bool exp=true;\\n                while(1)\\n                {\\n                    char x = stk.top(); stk.pop();\\n                    if(x==\\'(\\') continue;\\n                    else if(x==\\'f\\') exp=exp & false;\\n                    else if(x==\\'t\\') exp=exp & true;\\n                    else if(x==\\')\\')\\n                    {\\n                       if(exp) stk.push(\\'t\\');\\n                        else stk.push(\\'f\\');\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if(stk.top()==\\'t\\') return true;\\n        else return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1128897,
                "title": "python-easy-and-straightforward-solution-using-stack",
                "content": "**Intuition - Parsing problems**\\n\\nThis is one of the typical parsing questions in Leetcode. \\n- Parsing is quite challenging if you are not familiar with it; but once you know, it\\'s very fun to solve.\\n- Approaches: This type of problem could be solved using recursive descent or stack. I prefer stack since it is pretty straightforward and easy for detailed runtime and space complexity analysis.\\n- ***Note***: It\\'s very useful to check beforehand whether iterating the list backward is the good option. For example, in the problem [Parsing atoms from a chemical formula](https://leetcode.com/problems/number-of-atoms/), going backward is the best way to start.  \\n\\n**Algorithm**\\n\\n- Example 1:  Input: \"!(f)\"=> ***NOT false*** => Output: ***True***\\n- Example 2: Input: \"|(f,t)\" => ***OR*** of (***false, true***) => Output: ***True***\\n- Approach: Iterate through the expression and put all the characters into a stack , when encounter \")\", pop each element in the previous inner expression out of the stack for parsing, and then put the result back in stack. If the expression is valid (as confirmed in the **Constraints** session), then at the end of the loop, the stack remains only 1 value, which is \"t\" or \"f\". \\n+ Note that there are only 3 logical characters NOT, OR and AND => For clean code, as suggested in the problem hints: \"Write a function \"parse\" which calls helper functions \"parse_or\", \"parse_and\", \"parse_not\"\".\\n\\n**Example:**\\n\\nInput: **expression = \"|(&(t,f,t),!(t))\"**\\nIterate from 0 to len(expression)-1\\n1. When encounter the first \")\" :\\n`stack = [\"|\", \"(\", \"&\", \"(\", \"t\", \"f\", \"t\"]`\\n2. Go through parse function, pop out `\"&\", \"(\", \"t\", \"f\", \"t\" `=> result is \"f\", put back \"f\" in stack\\n`stack = [\"|\", \"(\", \"f\"]`\\n3. Continue on the expression, encounter the second \")\":\\n`stack = [\"|\", \"(\", \"f\", \"!\", \"(\", \"t\"] `\\n4. Go through parse function, pop out `\"!\", \"(\", \"t\" `=> result is \"f\", put back \"f\" in stack\\n`stack = [\"|\", \"(\", \"f\", \"f\"]`\\n5. Continue on the expression, encounter the third \")\":\\n`stack = [\"|\", \"(\", \"f\", \"f\"]`\\n6. Go through parse function, pop out` \"|\", \"(\", \"f\", \"f\"` => result is \"f\", put back \"f\" in stack\\n`stack = [\"f\"]`\\n7. Return False since stack[0] = \"f\"\\n\\n**Python:**\\n\\n```\\ndef parseBoolExpr(self, expression: str) -> bool: \\n        ###helper functions \"parse_or\", \"parse_and\", \"parse_not\"\".\\n        def parse_not(vals):\\n            if len(vals) == 1:\\n                return \"f\" if vals[0] == \"t\" else \"t\"\\n            else:\\n                print(\"More than 1 in !\", vals)\\n                \\n        def parse_and(vals):\\n            boolval = True if vals[0] == \"t\" else False\\n            for x in vals[1:]:\\n                boolval = boolval and (True if x == \"t\" else False)\\n            return \"f\" if boolval == False else \"t\"\\n        \\n        def parse_or(vals):\\n            boolval = True if vals[0] == \"t\" else False\\n            for x in vals[1:]:\\n                boolval = boolval or (True if x == \"t\" else False)\\n            return \"f\" if boolval == False else \"t\"\\n        \\n        ### parse function\\n        def parsing(stack):\\n            vals = [] # to store inner expression elements\\n            expr = \"\" # to store the logical expression\\n            result = \"\" # final result\\n            while stack:\\n                #pop out the elements and store in the list \"vals\" in the current inner expression until reach \"(\"\\n                curr = stack.pop()\\n                if curr == \"(\":\\n                    #get the logical expression \\n                    if stack: \\n                        expr = stack.pop()\\n                        break\\n                else:\\n                    vals.append(curr)\\n            # parsing using the helper functions\\n            if expr == \"\":\\n                print(\"Something\\'s wrong\", vals)\\n            else:\\n                if expr == \"!\":\\n                    result = parse_not(vals)       \\n                elif expr == \"&\":\\n                    result = parse_and(vals)   \\n                elif expr == \"|\":\\n                    result = parse_or(vals) \\n            # put the result back into stack\\n            stack.append(result)\\n                    \\n        stack = []    \\n        for i, x in enumerate(expression):\\n            # if encounter \")\", do parsing\\n            if x == \")\":\\n                parsing(stack)\\n            elif x == \",\":\\n                pass\\n            else:\\n                stack.append(x)\\n                \\n        #  If the expression is valid then at the end of the loop,  the stack remains only 1 value, which is \"t\" or \"f\"         \\n        return True if stack[0] == \"t\" else False\\n```\\n\\n**Complexity Analysis**\\n\\n- Time Complexity: O(N^2), where N is the length of the expression\\nO(n) to iterate through the expression\\nThe parsing of the ***k*** inner expression may cost O(k). But ***k*** doesn\\'t have any limitation, it could take a value up to **k < N/2**, therefore the complexity boils down to O(N^2)\\n- Space Complexity: O(N). There is no more intermediate information than what is in the expression.\\n\\n**More On Parsing Problems**\\n\\nMedium Problems:\\n- [227. Basic Calculator II](https://leetcode.com/problems/basic-calculator-ii/) (Similar to parsing problem, but at lower level, usually grouped in the **stack problem group**.)\\n- [150. Evaluate Reverse Polish Notation](https://leetcode.com/problems/evaluate-reverse-polish-notation/)\\n\\nHard Problems:\\n- [726. Number of Atoms](https://leetcode.com/problems/number-of-atoms/)\\n- [736. Parse Lisp Expression](https://leetcode.com/problems/parse-lisp-expression/)\\n",
                "solutionTags": [],
                "code": "```\\ndef parseBoolExpr(self, expression: str) -> bool: \\n        ###helper functions \"parse_or\", \"parse_and\", \"parse_not\"\".\\n        def parse_not(vals):\\n            if len(vals) == 1:\\n                return \"f\" if vals[0] == \"t\" else \"t\"\\n            else:\\n                print(\"More than 1 in !\", vals)\\n                \\n        def parse_and(vals):\\n            boolval = True if vals[0] == \"t\" else False\\n            for x in vals[1:]:\\n                boolval = boolval and (True if x == \"t\" else False)\\n            return \"f\" if boolval == False else \"t\"\\n        \\n        def parse_or(vals):\\n            boolval = True if vals[0] == \"t\" else False\\n            for x in vals[1:]:\\n                boolval = boolval or (True if x == \"t\" else False)\\n            return \"f\" if boolval == False else \"t\"\\n        \\n        ### parse function\\n        def parsing(stack):\\n            vals = [] # to store inner expression elements\\n            expr = \"\" # to store the logical expression\\n            result = \"\" # final result\\n            while stack:\\n                #pop out the elements and store in the list \"vals\" in the current inner expression until reach \"(\"\\n                curr = stack.pop()\\n                if curr == \"(\":\\n                    #get the logical expression \\n                    if stack: \\n                        expr = stack.pop()\\n                        break\\n                else:\\n                    vals.append(curr)\\n            # parsing using the helper functions\\n            if expr == \"\":\\n                print(\"Something\\'s wrong\", vals)\\n            else:\\n                if expr == \"!\":\\n                    result = parse_not(vals)       \\n                elif expr == \"&\":\\n                    result = parse_and(vals)   \\n                elif expr == \"|\":\\n                    result = parse_or(vals) \\n            # put the result back into stack\\n            stack.append(result)\\n                    \\n        stack = []    \\n        for i, x in enumerate(expression):\\n            # if encounter \")\", do parsing\\n            if x == \")\":\\n                parsing(stack)\\n            elif x == \",\":\\n                pass\\n            else:\\n                stack.append(x)\\n                \\n        #  If the expression is valid then at the end of the loop,  the stack remains only 1 value, which is \"t\" or \"f\"         \\n        return True if stack[0] == \"t\" else False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1107628,
                "title": "c-simple-two-stack-solution",
                "content": "class Solution {\\npublic:\\n    bool parseBoolExpr(string exp) {\\n        stack<char> op;\\n        stack<char> st;\\n        \\n        for(int i=0;i<exp.length();i++)\\n        {\\n            if(exp[i]==\\'(\\' || exp[i]==\\'f\\' || exp[i]==\\'t\\')\\n                st.push(exp[i]);\\n            else if(exp[i]==\\'&\\' || exp[i]==\\'|\\' || exp[i]==\\'!\\')\\n                op.push(exp[i]);\\n            else if(exp[i]==\\')\\')\\n            {\\n                char oper;\\n                bool result;\\n                if(!op.empty())\\n                {\\n                    oper=op.top();\\n                    op.pop();\\n                }\\n                if(oper==\\'&\\')\\n                    result=true;\\n                else if(oper==\\'|\\')\\n                    result=false;\\n                while(!st.empty() && st.top()!=\\'(\\')\\n                {\\n                    char top=st.top();\\n                    st.pop();\\n\\t\\t\\t\\t\\tif(oper==\\'&\\')\\n\\t\\t\\t\\t\\t\\tresult&=(top==\\'t\\');\\n\\t\\t\\t\\t\\telse if(oper==\\'|\\')\\n\\t\\t\\t\\t\\t\\tresult|=(top==\\'t\\');\\n\\t\\t\\t\\t\\telse if(oper==\\'!\\')\\n\\t\\t\\t\\t\\t\\tresult=!(top==\\'t\\');\\n                }\\n                if(!st.empty() && st.top()==\\'(\\')\\n                    st.pop();\\n                st.push(result?\\'t\\':\\'f\\');\\n            }\\n        }\\n        \\n        if(!st.empty())\\n            return st.top()==\\'t\\'?true:false;\\n        return false;\\n    }\\n};\\n\\nThis solution is a simple solution with two stacks.\\nhowever, not sure why this solution shows runtime as 8ms which is 64% faster?\\nCan anyone explain me why this solution has higher runtime and how to improve it?",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool parseBoolExpr(string exp) {\\n        stack<char> op;\\n        stack<char> st;\\n        \\n        for(int i=0;i<exp.length();i++)\\n        {\\n            if(exp[i]==\\'(\\' || exp[i]==\\'f\\' || exp[i]==\\'t\\')\\n                st.push(exp[i]);\\n            else if(exp[i]==\\'&\\' || exp[i]==\\'|\\' || exp[i]==\\'!\\')\\n                op.push(exp[i]);\\n            else if(exp[i]==\\')\\')\\n            {\\n                char oper;\\n                bool result;\\n                if(!op.empty())\\n                {\\n                    oper=op.top();\\n                    op.pop();\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1002861,
                "title": "easy-to-understand-and-visualize-2-stack-approach",
                "content": "This is my first attempt at posting a discussion thread. I found it easy to work with 2 stacks one for the operators and another one for the expressions. I used a helper function called eval which works with a operator and a list of expression values.\\nThe approach is pretty simple I parse the string from left to right and i I find a operator I add it to the operator stack and for \\'(\\', \\' t\\' and \\'f\\' I add them to the exprs stack. Once I arrive at a \\')\\' Iknow that the previous operator has to be applied to the list of expressions till the previous \\'(\\'. so the eval function comes in handy. Then I push this result back to the expression stack and continue to the end. Finally the result will be at the top of the expression stack.\\n```\\npublic boolean parseBoolExpr(String s) {\\n        Stack<Character> ops = new Stack<>();\\n        Stack<Character> expr = new Stack<>();\\n        \\n        for(int i=0; i<s.length(); ++i) {\\n            if(s.charAt(i)==\\'!\\' || s.charAt(i)==\\'&\\' || s.charAt(i)==\\'|\\' ) {\\n                ops.push(s.charAt(i));\\n            } else {\\n                if(s.charAt(i)==\\',\\') {\\n                    continue;\\n                } else if(s.charAt(i) == \\')\\') {\\n                    List<Character> exprs = new ArrayList<>();\\n                    while(!expr.isEmpty() && expr.peek()!=\\'(\\') {\\n                        exprs.add(expr.pop());\\n                    }\\n                    expr.pop();\\n                    boolean res = eval(ops.pop(), exprs);\\n                    expr.push(res?\\'t\\':\\'f\\');\\n                } else {\\n                    expr.push(s.charAt(i));\\n                }\\n            }\\n        }\\n        return expr.peek()==\\'t\\';\\n    }\\n    public boolean eval(Character op, List<Character> expr) {\\n        if(op == \\'!\\') {\\n            return expr.get(0) == \\'t\\'? false:true;\\n        } else if(op == \\'|\\') {\\n            for(char c :expr) {\\n                if(c == \\'t\\') {\\n                    return true;\\n                } \\n            }\\n            return false;\\n        } else  {\\n            for(char c :expr) {\\n                if(c == \\'f\\') {\\n                    return false;\\n                } \\n            }\\n            return true;\\n        }\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\npublic boolean parseBoolExpr(String s) {\\n        Stack<Character> ops = new Stack<>();\\n        Stack<Character> expr = new Stack<>();\\n        \\n        for(int i=0; i<s.length(); ++i) {\\n            if(s.charAt(i)==\\'!\\' || s.charAt(i)==\\'&\\' || s.charAt(i)==\\'|\\' ) {\\n                ops.push(s.charAt(i));\\n            } else {\\n                if(s.charAt(i)==\\',\\') {\\n                    continue;\\n                } else if(s.charAt(i) == \\')\\') {\\n                    List<Character> exprs = new ArrayList<>();\\n                    while(!expr.isEmpty() && expr.peek()!=\\'(\\') {\\n                        exprs.add(expr.pop());\\n                    }\\n                    expr.pop();\\n                    boolean res = eval(ops.pop(), exprs);\\n                    expr.push(res?\\'t\\':\\'f\\');\\n                } else {\\n                    expr.push(s.charAt(i));\\n                }\\n            }\\n        }\\n        return expr.peek()==\\'t\\';\\n    }\\n    public boolean eval(Character op, List<Character> expr) {\\n        if(op == \\'!\\') {\\n            return expr.get(0) == \\'t\\'? false:true;\\n        } else if(op == \\'|\\') {\\n            for(char c :expr) {\\n                if(c == \\'t\\') {\\n                    return true;\\n                } \\n            }\\n            return false;\\n        } else  {\\n            for(char c :expr) {\\n                if(c == \\'f\\') {\\n                    return false;\\n                } \\n            }\\n            return true;\\n        }\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 930038,
                "title": "python-simple-intuitive-stack-o-n-time-o-n-space",
                "content": "```\\nclass Solution(object):\\n    def andFunction(self, array):\\n        return all(array)\\n\\n    def orFunction(self, array):\\n        return any(array)\\n\\n    def notFunction(self, array):\\n        return not(array[0])\\n\\n    def parseBoolExpr(self, expression):\\n        \"\"\"\\n        :type expression: str\\n        :rtype: bool\\n        \"\"\"\\n        stack = []\\n        functionMapper = {\\n            \\'&\\': self.andFunction,\\n            \\'|\\': self.orFunction,\\n            \\'!\\': self.notFunction\\n        }\\n\\n        for token in expression:\\n            if token == \\')\\':\\n                temp = []\\n                while stack[len(stack)-1] != \\'(\\':\\n                    temp.append(stack.pop())\\n                stack.pop()\\n                op = stack.pop()\\n\\n                func = functionMapper[op]\\n                stack.append(func(temp))\\n\\n            else:\\n                if token == \\'t\\':\\n                    stack.append(True)\\n                elif token == \\'f\\':\\n                    stack.append(False)\\n\\n                elif token == \\',\\':\\n                    continue\\n                else:\\n                    stack.append(token)\\n        return stack[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution(object):\\n    def andFunction(self, array):\\n        return all(array)\\n\\n    def orFunction(self, array):\\n        return any(array)\\n\\n    def notFunction(self, array):\\n        return not(array[0])\\n\\n    def parseBoolExpr(self, expression):\\n        \"\"\"\\n        :type expression: str\\n        :rtype: bool\\n        \"\"\"\\n        stack = []\\n        functionMapper = {\\n            \\'&\\': self.andFunction,\\n            \\'|\\': self.orFunction,\\n            \\'!\\': self.notFunction\\n        }\\n\\n        for token in expression:\\n            if token == \\')\\':\\n                temp = []\\n                while stack[len(stack)-1] != \\'(\\':\\n                    temp.append(stack.pop())\\n                stack.pop()\\n                op = stack.pop()\\n\\n                func = functionMapper[op]\\n                stack.append(func(temp))\\n\\n            else:\\n                if token == \\'t\\':\\n                    stack.append(True)\\n                elif token == \\'f\\':\\n                    stack.append(False)\\n\\n                elif token == \\',\\':\\n                    continue\\n                else:\\n                    stack.append(token)\\n        return stack[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 882898,
                "title": "javascript-recursion",
                "content": "Not too proud of this one.\\n```js\\nvar parseBoolExpr = function(x) {\\n    if (x === \\'t\\') return true;\\n    if (x === \\'f\\') return false;\\n    \\n    const op = x.charAt(0), content = x.substring(2, x.length - 1);\\n    if (op === \\'!\\') return !parseBoolExpr(content);\\n    \\n    const A = [];\\n    let level = 0, si = 0;\\n    for (let i = 0; i < content.length; ++i) {\\n        if (content[i] === \\'(\\') ++level;\\n        else if (content[i] === \\')\\') --level;\\n        if (level === 0 && (content[i] === \\'t\\' || content[i] === \\'f\\' || content[i] === \\')\\')) {\\n            A.push(content.substring(si, i + 1));\\n            si = i + 2;\\n        }\\n    }\\n    \\n    let b;\\n    if (op === \\'&\\')\\n        for (let a of A)\\n            b = b !== undefined ? b && parseBoolExpr(a) : parseBoolExpr(a);\\n    else if (op === \\'|\\')\\n        for (let a of A)\\n            b = b || parseBoolExpr(a);\\n    return b;\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\nvar parseBoolExpr = function(x) {\\n    if (x === \\'t\\') return true;\\n    if (x === \\'f\\') return false;\\n    \\n    const op = x.charAt(0), content = x.substring(2, x.length - 1);\\n    if (op === \\'!\\') return !parseBoolExpr(content);\\n    \\n    const A = [];\\n    let level = 0, si = 0;\\n    for (let i = 0; i < content.length; ++i) {\\n        if (content[i] === \\'(\\') ++level;\\n        else if (content[i] === \\')\\') --level;\\n        if (level === 0 && (content[i] === \\'t\\' || content[i] === \\'f\\' || content[i] === \\')\\')) {\\n            A.push(content.substring(si, i + 1));\\n            si = i + 2;\\n        }\\n    }\\n    \\n    let b;\\n    if (op === \\'&\\')\\n        for (let a of A)\\n            b = b !== undefined ? b && parseBoolExpr(a) : parseBoolExpr(a);\\n    else if (op === \\'|\\')\\n        for (let a of A)\\n            b = b || parseBoolExpr(a);\\n    return b;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 875448,
                "title": "recursive-stack",
                "content": "```\\nclass Solution:\\n    def parseBoolExpr(self, E: str) -> bool:\\n        if E==\"f\": return False\\n        if E==\"t\": return True\\n        if E[0]==\"!\": return not self.parseBoolExpr(E[2:-1])\\n        \\n        X = []\\n        sub = \"\"\\n        openb = 0\\n        for c in E[2:-1]:\\n            if c == \"(\": openb += 1\\n            if c == \")\": openb -= 1\\n            if c == \",\" and openb == 0: \\n                X.append(sub)\\n                sub=\"\"\\n            else: sub += c\\n        X.append(sub)\\n    \\n        X=[self.parseBoolExpr(x) for x in X]\\n        \\n        if E[0]==\\'&\\': return all(X)\\n        if E[0]==\"|\": return any(X)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def parseBoolExpr(self, E: str) -> bool:\\n        if E==\"f\": return False\\n        if E==\"t\": return True\\n        if E[0]==\"!\": return not self.parseBoolExpr(E[2:-1])\\n        \\n        X = []\\n        sub = \"\"\\n        openb = 0\\n        for c in E[2:-1]:\\n            if c == \"(\": openb += 1\\n            if c == \")\": openb -= 1\\n            if c == \",\" and openb == 0: \\n                X.append(sub)\\n                sub=\"\"\\n            else: sub += c\\n        X.append(sub)\\n    \\n        X=[self.parseBoolExpr(x) for x in X]\\n        \\n        if E[0]==\\'&\\': return all(X)\\n        if E[0]==\"|\": return any(X)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 812371,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string s) {\\n        stack<char> st;\\n        int operation=1;\\n       for(int i=s.length()-1;i>=0;i--){\\n           if(s[i]==\\'|\\'){\\n               bool result=false;\\n               while(st.size()){\\n                   if(st.top()==\\'(\\'){\\n                       st.pop();\\n                   }else if(st.top()==\\'t\\'){\\n                       result|=1;\\n                       st.pop();\\n                   }else if(st.top()==\\'f\\'){\\n                       result|=0;\\n                       st.pop();\\n                   }else if(st.top()==\\')\\'){\\n                       st.pop();\\n                       st.push(result==true?\\'t\\':\\'f\\');\\n                       break;\\n                   }\\n               }\\n           }else if(s[i]==\\'!\\'){\\n               bool result=false;\\n               while(st.size()){\\n                   if(st.top()==\\'(\\'){\\n                       st.pop();\\n                   }else if(st.top()==\\'t\\'){\\n                       result|=1;\\n                       st.pop();\\n                   }else if(st.top()==\\'f\\'){\\n                       result|=0;\\n                       st.pop();\\n                   }else if(st.top()==\\')\\'){\\n                       st.pop();\\n                       st.push(!result==true?\\'t\\':\\'f\\');\\n                       break;\\n                   }\\n               }\\n               \\n           }else if(s[i]==\\'&\\'){\\n               bool result=true;\\n               while(st.size()){\\n                   if(st.top()==\\'(\\'){\\n                       st.pop();\\n                   }else if(st.top()==\\'t\\'){\\n                       result&=1;\\n                       st.pop();\\n                   }else if(st.top()==\\'f\\'){\\n                       result&=0;\\n                       st.pop();\\n                   }else if(st.top()==\\')\\'){\\n                       st.pop();\\n                       st.push(result==true?\\'t\\':\\'f\\');\\n                       break;\\n                   }\\n               }\\n               \\n           }else if(s[i]==\\',\\'){\\n               continue;\\n           }else{\\n               st.push(s[i]);\\n           }\\n       }\\n        \\n        if(st.size()){\\n            if(st.top()==\\'t\\'){\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string s) {\\n        stack<char> st;\\n        int operation=1;\\n       for(int i=s.length()-1;i>=0;i--){\\n           if(s[i]==\\'|\\'){\\n               bool result=false;\\n               while(st.size()){\\n                   if(st.top()==\\'(\\'){\\n                       st.pop();\\n                   }else if(st.top()==\\'t\\'){\\n                       result|=1;\\n                       st.pop();\\n                   }else if(st.top()==\\'f\\'){\\n                       result|=0;\\n                       st.pop();\\n                   }else if(st.top()==\\')\\'){\\n                       st.pop();\\n                       st.push(result==true?\\'t\\':\\'f\\');\\n                       break;\\n                   }\\n               }\\n           }else if(s[i]==\\'!\\'){\\n               bool result=false;\\n               while(st.size()){\\n                   if(st.top()==\\'(\\'){\\n                       st.pop();\\n                   }else if(st.top()==\\'t\\'){\\n                       result|=1;\\n                       st.pop();\\n                   }else if(st.top()==\\'f\\'){\\n                       result|=0;\\n                       st.pop();\\n                   }else if(st.top()==\\')\\'){\\n                       st.pop();\\n                       st.push(!result==true?\\'t\\':\\'f\\');\\n                       break;\\n                   }\\n               }\\n               \\n           }else if(s[i]==\\'&\\'){\\n               bool result=true;\\n               while(st.size()){\\n                   if(st.top()==\\'(\\'){\\n                       st.pop();\\n                   }else if(st.top()==\\'t\\'){\\n                       result&=1;\\n                       st.pop();\\n                   }else if(st.top()==\\'f\\'){\\n                       result&=0;\\n                       st.pop();\\n                   }else if(st.top()==\\')\\'){\\n                       st.pop();\\n                       st.push(result==true?\\'t\\':\\'f\\');\\n                       break;\\n                   }\\n               }\\n               \\n           }else if(s[i]==\\',\\'){\\n               continue;\\n           }else{\\n               st.push(s[i]);\\n           }\\n       }\\n        \\n        if(st.size()){\\n            if(st.top()==\\'t\\'){\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 798124,
                "title": "beginner-friendly-not-really-hard-beats-95",
                "content": "```\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        stack=[]\\n        \\n        for sym in expression:\\n            if sym==\\',\\':\\n                continue\\n            elif sym==\\')\\':\\n                temp=set()\\n                while stack[-1]!= \\'(\\':\\n                    temp.add(stack.pop())\\n                stack.pop()\\n                oper=stack.pop()\\n                if oper==\\'!\\':\\n                    if \\'t\\' in temp:\\n                        stack.append(\\'f\\')\\n                    else:\\n                        stack.append(\\'t\\')\\n                elif oper==\"|\":\\n                    if \\'t\\' in temp:\\n                        stack.append(\\'t\\')\\n                    else:\\n                        stack.append(\\'f\\')\\n                else:\\n                    if \\'f\\' in temp:\\n                        stack.append(\\'f\\')\\n                    else:\\n                        stack.append(\\'t\\')\\n            else:\\n                stack.append(sym)\\n        \\n            \\n        return True if stack[-1]==\\'t\\' else False              \\n                \\n                        \\n                    \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        stack=[]\\n        \\n        for sym in expression:\\n            if sym==\\',\\':\\n                continue\\n            elif sym==\\')\\':\\n                temp=set()\\n                while stack[-1]!= \\'(\\':\\n                    temp.add(stack.pop())\\n                stack.pop()\\n                oper=stack.pop()\\n                if oper==\\'!\\':\\n                    if \\'t\\' in temp:\\n                        stack.append(\\'f\\')\\n                    else:\\n                        stack.append(\\'t\\')\\n                elif oper==\"|\":\\n                    if \\'t\\' in temp:\\n                        stack.append(\\'t\\')\\n                    else:\\n                        stack.append(\\'f\\')\\n                else:\\n                    if \\'f\\' in temp:\\n                        stack.append(\\'f\\')\\n                    else:\\n                        stack.append(\\'t\\')\\n            else:\\n                stack.append(sym)\\n        \\n            \\n        return True if stack[-1]==\\'t\\' else False              \\n                \\n                        \\n                    \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 767212,
                "title": "c-solution-beats-87",
                "content": "Maintaining two stacks, one for the `operators(&, |, !)` and the other for values\\nLogic:\\n1. When you find the operator, push it into the stack `operation`\\n2. When you find `,` continue;\\n3. When you find `)` that is the closing parenthisis of operation, perform the operation AND after performing the operation, if the operation stack is empty( meaning all operations are done) return the value, else push the value in the `val` stack for further use.\\n4. When you find anything else, push it into the stack `val`; \\n```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n        stack<char> operation;\\n        stack<char> val;\\n        char e;\\n        bool v;\\n        for(char c: expression) {\\n            if(c == \\'|\\' || c ==\\'&\\' || c == \\'!\\') {\\n                operation.push(c);\\n            } else if(c == \\',\\') {\\n\\t\\t\\t\\tcontinue; \\n\\t\\t\\t} else if(c == \\')\\') {\\n                // pop from the stack\\n                char op = operation.top(); operation.pop();\\n                if(op == \\'&\\') {\\n                    v = true;\\n                    e = val.top(); val.pop();\\n                    while(e != \\'(\\') {\\n                        bool a = e==\\'t\\'?true:false;\\n                        v = v&a;\\n                        e = val.top(); val.pop();\\n                    }\\n                }\\n                if(op == \\'|\\') {\\n                    v = false;\\n                    e = val.top(); val.pop();\\n                    while(e != \\'(\\') {\\n                        bool a = e==\\'t\\'?true:false;\\n                        v = v|a;\\n                        e = val.top(); val.pop();\\n                    }\\n                } \\n                if(op == \\'!\\') {\\n                    e = val.top(); val.pop();\\n                    while(e != \\'(\\') {\\n                        bool a = e==\\'t\\'?true:false;\\n                        v = !a;\\n                        e = val.top(); val.pop();\\n                    }\\n                }\\n                if(operation.empty()) {\\n                    return v;\\n                } else {\\n                    e = (v==true?\\'t\\':\\'f\\');\\n                    val.push(e);\\n                }\\n            } else {\\n                val.push(c);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n        stack<char> operation;\\n        stack<char> val;\\n        char e;\\n        bool v;\\n        for(char c: expression) {\\n            if(c == \\'|\\' || c ==\\'&\\' || c == \\'!\\') {\\n                operation.push(c);\\n            } else if(c == \\',\\') {\\n\\t\\t\\t\\tcontinue; \\n\\t\\t\\t} else if(c == \\')\\') {\\n                // pop from the stack\\n                char op = operation.top(); operation.pop();\\n                if(op == \\'&\\') {\\n                    v = true;\\n                    e = val.top(); val.pop();\\n                    while(e != \\'(\\') {\\n                        bool a = e==\\'t\\'?true:false;\\n                        v = v&a;\\n                        e = val.top(); val.pop();\\n                    }\\n                }\\n                if(op == \\'|\\') {\\n                    v = false;\\n                    e = val.top(); val.pop();\\n                    while(e != \\'(\\') {\\n                        bool a = e==\\'t\\'?true:false;\\n                        v = v|a;\\n                        e = val.top(); val.pop();\\n                    }\\n                } \\n                if(op == \\'!\\') {\\n                    e = val.top(); val.pop();\\n                    while(e != \\'(\\') {\\n                        bool a = e==\\'t\\'?true:false;\\n                        v = !a;\\n                        e = val.top(); val.pop();\\n                    }\\n                }\\n                if(operation.empty()) {\\n                    return v;\\n                } else {\\n                    e = (v==true?\\'t\\':\\'f\\');\\n                    val.push(e);\\n                }\\n            } else {\\n                val.push(c);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 647468,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n        stack<char> logic, var;\\n        for(auto& ch : expression){\\n            if(ch == \\'!\\' || ch == \\'|\\' || ch == \\'&\\'){\\n                logic.push(ch);\\n            }else if(ch == \\'(\\' || ch == \\'f\\' || ch == \\'t\\'){\\n                var.push(ch);\\n            }else if(ch == \\')\\'){\\n                char operation = logic.top(); logic.pop();\\n                char res = \\'t\\';\\n                if(operation == \\'!\\'){\\n                    if(!var.empty() && var.top() != \\'(\\'){\\n                        char top = var.top(); var.pop();\\n                        if(top == \\'t\\') res = \\'f\\';\\n                        else           res = \\'t\\';\\n                    }\\n                }else if(operation == \\'&\\'){\\n                    while(!var.empty() && var.top() != \\'(\\'){\\n                        char top = var.top(); var.pop();\\n                        if(top == \\'f\\') res = \\'f\\'; \\n                    }                    \\n                }else if(operation == \\'|\\'){\\n                    res = \\'f\\';\\n                    while(!var.empty() && var.top() != \\'(\\'){\\n                        char top = var.top(); var.pop();\\n                        if(top == \\'t\\') res = \\'t\\'; \\n                    }                        \\n                }\\n                var.pop(); var.push(res);\\n            }\\n        }\\n        return var.top() == \\'t\\' ? true : false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n        stack<char> logic, var;\\n        for(auto& ch : expression){\\n            if(ch == \\'!\\' || ch == \\'|\\' || ch == \\'&\\'){\\n                logic.push(ch);\\n            }else if(ch == \\'(\\' || ch == \\'f\\' || ch == \\'t\\'){\\n                var.push(ch);\\n            }else if(ch == \\')\\'){\\n                char operation = logic.top(); logic.pop();\\n                char res = \\'t\\';\\n                if(operation == \\'!\\'){\\n                    if(!var.empty() && var.top() != \\'(\\'){\\n                        char top = var.top(); var.pop();\\n                        if(top == \\'t\\') res = \\'f\\';\\n                        else           res = \\'t\\';\\n                    }\\n                }else if(operation == \\'&\\'){\\n                    while(!var.empty() && var.top() != \\'(\\'){\\n                        char top = var.top(); var.pop();\\n                        if(top == \\'f\\') res = \\'f\\'; \\n                    }                    \\n                }else if(operation == \\'|\\'){\\n                    res = \\'f\\';\\n                    while(!var.empty() && var.top() != \\'(\\'){\\n                        char top = var.top(); var.pop();\\n                        if(top == \\'t\\') res = \\'t\\'; \\n                    }                        \\n                }\\n                var.pop(); var.push(res);\\n            }\\n        }\\n        return var.top() == \\'t\\' ? true : false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 581908,
                "title": "go-beats-100-0ms-ll-1-parser",
                "content": "```go\\n/*\\ngrammar definition:\\n\\nS-> !(S) | |(L) | &(L) | E\\nL-> S | S,L\\nE-> t | f\\n*/\\nfunc parseBoolExpr(expression string) bool {\\n\\treader := strings.NewReader(expression)\\n\\treturn parseExpr(reader)\\n}\\n\\nfunc parseExpr(reader *strings.Reader) bool {\\n\\tlookahead, _ := reader.ReadByte()\\n\\n\\tvar result bool\\n\\tif lookahead == \\'!\\' {\\n\\t\\treader.ReadByte()\\n\\t\\tresult = !parseExpr(reader)\\n\\t\\treader.ReadByte() // eliminate trailing \\')\\'\\n\\t} else if lookahead == \\'|\\' {\\n\\t\\treader.ReadByte()\\n\\t\\tresult = parseOrExpList(reader)\\n\\t} else if lookahead == \\'&\\' {\\n\\t\\treader.ReadByte()\\n\\t\\tresult = parseAndExpList(reader)\\n\\t} else if lookahead == \\'t\\' {\\n\\t\\treturn true\\n\\t} else {\\n\\t\\treturn false\\n\\t}\\n\\treturn result\\n}\\n\\nfunc parseAndExpList(reader *strings.Reader) bool {\\n\\tresult := parseExpr(reader)\\n\\tif reader.Len() > 0 {\\n\\t\\tlookahead, _ := reader.ReadByte()\\n\\t\\tif lookahead == \\',\\' {\\n\\t\\t\\tif !parseAndExpList(reader) {\\n\\t\\t\\t\\treturn false\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// or otherwise, lookahead is \\')\\' and it was just consumed\\n\\t}\\n\\treturn result\\n}\\n\\nfunc parseOrExpList(reader *strings.Reader) bool {\\n\\tresult := parseExpr(reader)\\n\\tif reader.Len() > 0 {\\n\\t\\tlookahead, _ := reader.ReadByte()\\n\\t\\tif lookahead == \\',\\' {\\n\\t\\t\\tif parseOrExpList(reader) {\\n\\t\\t\\t\\tresult = true\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```\\n\\nbonus(script to generate random expression for testing purpose):\\n\\n```python\\nimport random\\n\\nfrom typing import Tuple\\n\\ndef generateRandomExpr(depth) -> str:\\n    sub, closed = generateRandomExprHelper(depth - 1)\\n    if not closed:\\n        choice = random.randint(1, 2)\\n        if choice == 1:\\n            return f\\'|({sub})\\'\\n        elif choice == 2:\\n            return f\\'&({sub})\\'\\n    return sub\\n\\ndef generateRandomExprHelper(depth) -> Tuple[str, bool]:\\n    result = \\'\\'\\n    if depth == 0:\\n        return (random.choice([\\'t\\', \\'f\\']), True)\\n\\n    size = random.randint(1, 6)\\n    while size > 0:\\n        randDepth = random.randint(0, depth - 1)\\n        sub, closed = generateRandomExprHelper(randDepth)\\n        if closed and random.randint(0, 1) == 1:\\n            sub = f\\'!({sub})\\'\\n\\n        result += sub\\n        result += \\',\\'\\n        size -= 1\\n\\n    result = result[:-1]\\n    choice = random.randint(1, 3)\\n    if choice == 1:\\n        return (f\\'|({result})\\', True)\\n    elif choice == 2:\\n        return (f\\'&({result})\\', True)\\n    return (result, False)\\n\\nif __name__ == \"__main__\":\\n    print(generateRandomExpr(1))\\n```",
                "solutionTags": [],
                "code": "```go\\n/*\\ngrammar definition:\\n\\nS-> !(S) | |(L) | &(L) | E\\nL-> S | S,L\\nE-> t | f\\n*/\\nfunc parseBoolExpr(expression string) bool {\\n\\treader := strings.NewReader(expression)\\n\\treturn parseExpr(reader)\\n}\\n\\nfunc parseExpr(reader *strings.Reader) bool {\\n\\tlookahead, _ := reader.ReadByte()\\n\\n\\tvar result bool\\n\\tif lookahead == \\'!\\' {\\n\\t\\treader.ReadByte()\\n\\t\\tresult = !parseExpr(reader)\\n\\t\\treader.ReadByte() // eliminate trailing \\')\\'\\n\\t} else if lookahead == \\'|\\' {\\n\\t\\treader.ReadByte()\\n\\t\\tresult = parseOrExpList(reader)\\n\\t} else if lookahead == \\'&\\' {\\n\\t\\treader.ReadByte()\\n\\t\\tresult = parseAndExpList(reader)\\n\\t} else if lookahead == \\'t\\' {\\n\\t\\treturn true\\n\\t} else {\\n\\t\\treturn false\\n\\t}\\n\\treturn result\\n}\\n\\nfunc parseAndExpList(reader *strings.Reader) bool {\\n\\tresult := parseExpr(reader)\\n\\tif reader.Len() > 0 {\\n\\t\\tlookahead, _ := reader.ReadByte()\\n\\t\\tif lookahead == \\',\\' {\\n\\t\\t\\tif !parseAndExpList(reader) {\\n\\t\\t\\t\\treturn false\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// or otherwise, lookahead is \\')\\' and it was just consumed\\n\\t}\\n\\treturn result\\n}\\n\\nfunc parseOrExpList(reader *strings.Reader) bool {\\n\\tresult := parseExpr(reader)\\n\\tif reader.Len() > 0 {\\n\\t\\tlookahead, _ := reader.ReadByte()\\n\\t\\tif lookahead == \\',\\' {\\n\\t\\t\\tif parseOrExpList(reader) {\\n\\t\\t\\t\\tresult = true\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```\n```python\\nimport random\\n\\nfrom typing import Tuple\\n\\ndef generateRandomExpr(depth) -> str:\\n    sub, closed = generateRandomExprHelper(depth - 1)\\n    if not closed:\\n        choice = random.randint(1, 2)\\n        if choice == 1:\\n            return f\\'|({sub})\\'\\n        elif choice == 2:\\n            return f\\'&({sub})\\'\\n    return sub\\n\\ndef generateRandomExprHelper(depth) -> Tuple[str, bool]:\\n    result = \\'\\'\\n    if depth == 0:\\n        return (random.choice([\\'t\\', \\'f\\']), True)\\n\\n    size = random.randint(1, 6)\\n    while size > 0:\\n        randDepth = random.randint(0, depth - 1)\\n        sub, closed = generateRandomExprHelper(randDepth)\\n        if closed and random.randint(0, 1) == 1:\\n            sub = f\\'!({sub})\\'\\n\\n        result += sub\\n        result += \\',\\'\\n        size -= 1\\n\\n    result = result[:-1]\\n    choice = random.randint(1, 3)\\n    if choice == 1:\\n        return (f\\'|({result})\\', True)\\n    elif choice == 2:\\n        return (f\\'&({result})\\', True)\\n    return (result, False)\\n\\nif __name__ == \"__main__\":\\n    print(generateRandomExpr(1))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 560631,
                "title": "c-o-n-using-stacks",
                "content": "Approach:\\n**result is a boolean variable\\n1. form a **newexp** by removing those \\'*annoying*\\' commas form **exp**\\n2. create two stacks : One for operands {\\'**(**\\',\\'**t**\\',\\'**f**\\'}\\n                                  Second one for operators {\\'**!**\\',\\'**&**\\',\\'**|**\\'}\\n3. Now start traversing the newexp( : c):\\n* if( c == \\'(\\' OR \\'t\\' OR \\'f\\'), then push c -> operands\\n* if(c == \\'!\\' OR \\'&\\' OR \\'|\\'), then push c -> operators\\n* if(c == \\')\\'), then action begins :\\n* result =  operands.top\\n* while ( operands.top != \\'(\\')\\n     keep evaluating, result = result OPR operands.top\\n\\t and keep popping the operands\\n* finally when operands.top == \\'(\\', pop it out and push back the result\\n* continue this until you have evaluated newexp completely\\n* finally operands will be left with only one element, and that is our final result\\uD83D\\uDE09\\n\\n**TALK IS CHEAP, SHOW ME THE CODE**\\n\\n```\\nbool operate(bool f,bool s,char optr){\\n        return (optr==\\'&\\')?f&&s:f||s;}\\n    \\n    bool parseBoolExpr(string exp) {\\n      string newexp = \"\";  \\n       \\n        for(char c : exp){\\n           if(c != \\',\\')   newexp += c;}\\n        \\n     bool result = true;\\n     \\n     stack<char> operands,operators;\\n        \\n     char optr;\\n     \\n    int i=0; \\n    while(i < newexp.length()){\\n        \\n        if(newexp[i]==\\'!\\' || newexp[i]==\\'|\\' || newexp[i]==\\'&\\'){\\n           \\n            operators.push(newexp[i]);\\n            i++;\\n            \\n        }\\n        else if(newexp[i] == \\')\\'){\\n            \\n         optr = operators.top();operators.pop();\\n         result = operands.top()==\\'t\\'?true:false;\\n         operands.pop();\\n         \\n        if(optr != \\'!\\'){\\n             \\n           while(operands.top() != \\'(\\'){\\n             \\n             bool temp = operands.top()==\\'t\\'?true:false;\\n             operands.pop();\\n             result = operate(result,temp,optr);\\n           \\n           }\\n            \\n         }\\n         else\\n             result = !result;\\n\\n         operands.pop();\\n         operands.push(result?\\'t\\':\\'f\\');   \\n        i++;\\n        }\\n        else{    \\n            \\n            operands.push(newexp[i]);\\n            i++;\\n\\n        }\\n    }\\n        result = operands.top()==\\'t\\'?true:false;\\n        operands.pop();\\n        return result;\\n }\\n ```",
                "solutionTags": [],
                "code": "```\\nbool operate(bool f,bool s,char optr){\\n        return (optr==\\'&\\')?f&&s:f||s;}\\n    \\n    bool parseBoolExpr(string exp) {\\n      string newexp = \"\";  \\n       \\n        for(char c : exp){\\n           if(c != \\',\\')   newexp += c;}\\n        \\n     bool result = true;\\n     \\n     stack<char> operands,operators;\\n        \\n     char optr;\\n     \\n    int i=0; \\n    while(i < newexp.length()){\\n        \\n        if(newexp[i]==\\'!\\' || newexp[i]==\\'|\\' || newexp[i]==\\'&\\'){\\n           \\n            operators.push(newexp[i]);\\n            i++;\\n            \\n        }\\n        else if(newexp[i] == \\')\\'){\\n            \\n         optr = operators.top();operators.pop();\\n         result = operands.top()==\\'t\\'?true:false;\\n         operands.pop();\\n         \\n        if(optr != \\'!\\'){\\n             \\n           while(operands.top() != \\'(\\'){\\n             \\n             bool temp = operands.top()==\\'t\\'?true:false;\\n             operands.pop();\\n             result = operate(result,temp,optr);\\n           \\n           }\\n            \\n         }\\n         else\\n             result = !result;\\n\\n         operands.pop();\\n         operands.push(result?\\'t\\':\\'f\\');   \\n        i++;\\n        }\\n        else{    \\n            \\n            operands.push(newexp[i]);\\n            i++;\\n\\n        }\\n    }\\n        result = operands.top()==\\'t\\'?true:false;\\n        operands.pop();\\n        return result;\\n }\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 539849,
                "title": "python-stack-solution-one-template-to-solve-1106-1096-224",
                "content": "This problem is similar as 224 and 1096. The three solutions in fact are very similar.\\n\\nmy 1106 solution.\\n```\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        def helper(pre, cur):\\n            if pre == None:\\n                pre = True if stk[-1] == \\'&\\' else False\\n            if stk[-1] == \\'&\\':\\n                pre &= cur\\n            elif stk[-1] == \\'!\\':\\n                pre = not cur\\n            else:\\n                pre |= cur\\n            return pre \\n            \\n        stk, op, pre = [], \\'\\', None\\n        for c in expression:\\n            if c in \\'&|!\\':\\n                op = c\\n            elif c == \\'(\\':\\n                stk.append(pre)\\n                stk.append(op)\\n                pre = None\\n            elif c in \\'tf\\':\\n                cur = True if c == \\'t\\' else False\\n                pre = helper(pre, cur)\\n            elif c == \\')\\':\\n                stk.pop()\\n                ppre = stk.pop()\\n                if stk:\\n                    pre = helper(ppre, pre)\\n        return pre\\n```\\n\\n224 solution\\nreference: https://leetcode.com/problems/basic-calculator/discuss/62362/JAVA-Easy-Version-To-Understand!!!!!\\n\\n```\\n\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        res = 0\\n        sign = 1\\n        stk = []\\n        i, n = 0, len(s)\\n        while i < n:\\n            if s[i].isdigit():\\n                cur = int(s[i])\\n                while i+1 < n and s[i+1].isdigit():\\n                    cur = cur*10 + int(s[i+1])\\n                    i += 1\\n                res += cur*sign\\n            elif s[i] == \\'+\\':\\n                sign = 1\\n            elif s[i] == \\'-\\':\\n                sign = -1\\n            elif s[i] == \\'(\\':\\n                stk.append(res)\\n                stk.append(sign)\\n                sign = 1\\n                res = 0\\n            elif s[i] == \\')\\':\\n                res = res*stk.pop() + stk.pop()\\n            i += 1\\n        return res\\n```\\n\\n1096 solution. \\nreference: https://leetcode.com/problems/brace-expansion-ii/discuss/322002/Python-concise-stack-solution\\n```\\nclass Solution:\\n    def braceExpansionII(self, expression: str) -> List[str]:\\n        stk, pre, cur = [], [], [\\'\\']\\n        for v in expression:\\n            if v == \\'{\\':\\n                stk.append(pre)\\n                stk.append(cur)\\n                pre, cur = [], [\\'\\']\\n            elif v.isalpha():\\n                cur = [c+v for c in cur]\\n            elif v == \\'}\\':\\n                p_cur= stk.pop()\\n                p_pre = stk.pop()\\n                cur = [p+c for c in pre+cur for p in p_cur]\\n                pre = p_pre\\n            else:\\n                pre += cur\\n                cur = [\\'\\']\\n        return sorted(set(pre+cur))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        def helper(pre, cur):\\n            if pre == None:\\n                pre = True if stk[-1] == \\'&\\' else False\\n            if stk[-1] == \\'&\\':\\n                pre &= cur\\n            elif stk[-1] == \\'!\\':\\n                pre = not cur\\n            else:\\n                pre |= cur\\n            return pre \\n            \\n        stk, op, pre = [], \\'\\', None\\n        for c in expression:\\n            if c in \\'&|!\\':\\n                op = c\\n            elif c == \\'(\\':\\n                stk.append(pre)\\n                stk.append(op)\\n                pre = None\\n            elif c in \\'tf\\':\\n                cur = True if c == \\'t\\' else False\\n                pre = helper(pre, cur)\\n            elif c == \\')\\':\\n                stk.pop()\\n                ppre = stk.pop()\\n                if stk:\\n                    pre = helper(ppre, pre)\\n        return pre\\n```\n```\\n\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        res = 0\\n        sign = 1\\n        stk = []\\n        i, n = 0, len(s)\\n        while i < n:\\n            if s[i].isdigit():\\n                cur = int(s[i])\\n                while i+1 < n and s[i+1].isdigit():\\n                    cur = cur*10 + int(s[i+1])\\n                    i += 1\\n                res += cur*sign\\n            elif s[i] == \\'+\\':\\n                sign = 1\\n            elif s[i] == \\'-\\':\\n                sign = -1\\n            elif s[i] == \\'(\\':\\n                stk.append(res)\\n                stk.append(sign)\\n                sign = 1\\n                res = 0\\n            elif s[i] == \\')\\':\\n                res = res*stk.pop() + stk.pop()\\n            i += 1\\n        return res\\n```\n```\\nclass Solution:\\n    def braceExpansionII(self, expression: str) -> List[str]:\\n        stk, pre, cur = [], [], [\\'\\']\\n        for v in expression:\\n            if v == \\'{\\':\\n                stk.append(pre)\\n                stk.append(cur)\\n                pre, cur = [], [\\'\\']\\n            elif v.isalpha():\\n                cur = [c+v for c in cur]\\n            elif v == \\'}\\':\\n                p_cur= stk.pop()\\n                p_pre = stk.pop()\\n                cur = [p+c for c in pre+cur for p in p_cur]\\n                pre = p_pre\\n            else:\\n                pre += cur\\n                cur = [\\'\\']\\n        return sorted(set(pre+cur))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 513761,
                "title": "scala-10-lines-pattern-based-solution-beats-100",
                "content": "```\\n  def parseBoolExpr(expression: String): Boolean = ((true, Seq.empty[Char], -1) /: expression){\\n    case ((_, st, -1), op@(\\'!\\' | \\'&\\' | \\'|\\')) => (true, op +: st, -1) // add a new operator to the stack\\n    case ((_, st, -1), c@(\\'t\\' | \\'f\\')) => (c == \\'t\\', st, -1) // true of false\\n    case ((false, st@(\\'&\\' +: _), -1), \\',\\') => (false, st, 0) // we are inside of & and we got false for the previous argument, so we just going to skip the rest, so set the nest level to 0\\n    case ((true, st@(\\'|\\' +: _), -1), \\',\\') => (true, st, 0) // we are inside of | and we got true for the previous argument\\n    case (s@(_, _, -1), \\'(\\') => s // we can ignore (, when we are not in the skipping mode (the nest level is -1)\\n    case ((cv, \\'!\\' +: st, -1), \\')\\') => (!cv, st, -1)  // we accomplished !, so we are going to return reversed result\\n    case ((cv, _ +: st, 0 | -1), \\')\\') => (cv, st, -1) // pop the stack, when we encounter )\\n    case ((cv, st, cn), \\'(\\') => (cv, st, cn + 1) // we are skipping the rest of arguments inside & or |, so just increase the nest level\\n    case ((cv, st, cn), \\')\\') => (cv, st, cn - 1) // we are skipping the rest of arguments inside & or |, so just decrease the nest level\\n    case (s, _) => s // ignore all other cases\\n  }._1\\n```",
                "solutionTags": [],
                "code": "```\\n  def parseBoolExpr(expression: String): Boolean = ((true, Seq.empty[Char], -1) /: expression){\\n    case ((_, st, -1), op@(\\'!\\' | \\'&\\' | \\'|\\')) => (true, op +: st, -1) // add a new operator to the stack\\n    case ((_, st, -1), c@(\\'t\\' | \\'f\\')) => (c == \\'t\\', st, -1) // true of false\\n    case ((false, st@(\\'&\\' +: _), -1), \\',\\') => (false, st, 0) // we are inside of & and we got false for the previous argument, so we just going to skip the rest, so set the nest level to 0\\n    case ((true, st@(\\'|\\' +: _), -1), \\',\\') => (true, st, 0) // we are inside of | and we got true for the previous argument\\n    case (s@(_, _, -1), \\'(\\') => s // we can ignore (, when we are not in the skipping mode (the nest level is -1)\\n    case ((cv, \\'!\\' +: st, -1), \\')\\') => (!cv, st, -1)  // we accomplished !, so we are going to return reversed result\\n    case ((cv, _ +: st, 0 | -1), \\')\\') => (cv, st, -1) // pop the stack, when we encounter )\\n    case ((cv, st, cn), \\'(\\') => (cv, st, cn + 1) // we are skipping the rest of arguments inside & or |, so just increase the nest level\\n    case ((cv, st, cn), \\')\\') => (cv, st, cn - 1) // we are skipping the rest of arguments inside & or |, so just decrease the nest level\\n    case (s, _) => s // ignore all other cases\\n  }._1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 496457,
                "title": "python-3-solution-using-classes-and-2-stacks-beats-100-memory-o-n",
                "content": "The basic idea is to add an expression to a stack and when a `)` is found pop the expression, evaluate it and append it again. Whatever is remaining in the stack is the final solution.\\n\\n```python\\nclass Expr:\\n\\n\\tdef __init__(self, val):\\n\\t\\tself.val = val\\n\\nclass AndExpr(Expr):\\n\\n\\tdef eval(self):\\n\\t\\treturn all(self.val)\\n\\nclass OrExpr(Expr):\\n\\t\\n\\tdef eval(self):\\n\\t\\treturn any(self.val)\\n\\nclass NotExpr(Expr):\\n\\n\\tdef eval(self):\\n\\t\\treturn not self.val[0]\\n\\nmapper = {\\n    \\'!\\': NotExpr,\\n    \\'&\\': AndExpr,\\n    \\'|\\': OrExpr,\\n}\\n\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        if len(expression) == 1:\\n            return expression == \\'t\\'\\n\\n        parsed = [[]]\\n        stack = []\\n        \\n        for i, letter in enumerate(expression):\\n\\n            if letter in mapper:\\n                stack.append(mapper[letter])\\n                parsed.append([])\\n            elif letter in (\\'t\\', \\'f\\'):\\n                parsed[-1].append(letter == \\'t\\')\\n            elif letter == \\')\\':\\n                expr = stack.pop()\\n                values = parsed.pop()\\n                instance = expr(values)\\n                parsed[-1].append(instance.eval())\\n\\n        return parsed[-1][-1]\\n````",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Expr:\\n\\n\\tdef __init__(self, val):\\n\\t\\tself.val = val\\n\\nclass AndExpr(Expr):\\n\\n\\tdef eval(self):\\n\\t\\treturn all(self.val)\\n\\nclass OrExpr(Expr):\\n\\t\\n\\tdef eval(self):\\n\\t\\treturn any(self.val)\\n\\nclass NotExpr(Expr):\\n\\n\\tdef eval(self):\\n\\t\\treturn not self.val[0]\\n\\nmapper = {\\n    \\'!\\': NotExpr,\\n    \\'&\\': AndExpr,\\n    \\'|\\': OrExpr,\\n}\\n\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        if len(expression) == 1:\\n            return expression == \\'t\\'\\n\\n        parsed = [[]]\\n        stack = []\\n        \\n        for i, letter in enumerate(expression):\\n\\n            if letter in mapper:\\n                stack.append(mapper[letter])\\n                parsed.append([])\\n            elif letter in (\\'t\\', \\'f\\'):\\n                parsed[-1].append(letter == \\'t\\')\\n            elif letter == \\')\\':\\n                expr = stack.pop()\\n                values = parsed.pop()\\n                instance = expr(values)\\n                parsed[-1].append(instance.eval())\\n\\n        return parsed[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 466489,
                "title": "dijkstra-s-two-stack-algorithm",
                "content": "I have no idea why[ **Dijkstra\\'s Two-Stack Algorithm**](http://www.wisenheimerbrainstorm.com/archive/algorithms/dijkstra-s-two-stack-algorithm) doesn\\'t appear more often on this forum.\\n\\nWe split the tokens into 2 categories: we treat `t`, `f`, `(` and `)` as **operands** and `!`, `&` and `|` as **operators**. We use a stack for each category, so that when we see an operator we push it onto the operators stack and when we see an operand we push it onto the operators stack, **EXCEPT** when we see a closing paranthesys. A `)` means **take all the operators untill you find it\\'s matching `(`**, **apply the top operand to them** and **put the resulting value back onto the operands stack**. The code features the details I left out.\\n\\nAssuming a correct expression is passed, we will always end up with 2 stacks consisting of **no operators** and **a single operand**, the final result.\\n\\n```\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        Stack<Character> operators = new Stack<>();\\n        Stack<Character> operands = new Stack<>();\\n        \\n        for (char c: expression.toCharArray()) {\\n            if (c == \\'t\\' || c == \\'f\\' || c == \\'(\\') {\\n                operands.push(c);\\n            } else if (c == \\'!\\' || c == \\'&\\' || c == \\'|\\') {\\n                operators.push(c);\\n            } else if (c == \\')\\') {\\n                char operator = operators.pop();\\n                boolean result = operands.pop() == \\'t\\' ? true : false;\\n                if (operator == \\'!\\') {\\n                    result = !result;\\n                }\\n                \\n                while (operands.peek() != \\'(\\') {\\n                    boolean operand = operands.pop() == \\'t\\' ? true : false;\\n                    if (operator == \\'&\\') {\\n                        result = result && operand;\\n                    } else {\\n                        result = result || operand;\\n                    }\\n                }\\n                operands.pop();\\n                \\n                operands.push(result == true ? \\'t\\' : \\'f\\');\\n            }\\n        }\\n        \\n        return operands.peek() == \\'t\\' ? true : false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        Stack<Character> operators = new Stack<>();\\n        Stack<Character> operands = new Stack<>();\\n        \\n        for (char c: expression.toCharArray()) {\\n            if (c == \\'t\\' || c == \\'f\\' || c == \\'(\\') {\\n                operands.push(c);\\n            } else if (c == \\'!\\' || c == \\'&\\' || c == \\'|\\') {\\n                operators.push(c);\\n            } else if (c == \\')\\') {\\n                char operator = operators.pop();\\n                boolean result = operands.pop() == \\'t\\' ? true : false;\\n                if (operator == \\'!\\') {\\n                    result = !result;\\n                }\\n                \\n                while (operands.peek() != \\'(\\') {\\n                    boolean operand = operands.pop() == \\'t\\' ? true : false;\\n                    if (operator == \\'&\\') {\\n                        result = result && operand;\\n                    } else {\\n                        result = result || operand;\\n                    }\\n                }\\n                operands.pop();\\n                \\n                operands.push(result == true ? \\'t\\' : \\'f\\');\\n            }\\n        }\\n        \\n        return operands.peek() == \\'t\\' ? true : false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 461236,
                "title": "c-solution",
                "content": "```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\n\\npublic class Node {\\n    public Node Parent { get; set; }\\n    public List<Node> Nodes { get; } = new List<Node>();\\n    public char Val { get; set; }\\n\\n    public bool GetResult() {\\n        if (Val == \\'|\\') return Or(Nodes.Select(x => x.GetResult()));\\n        if (Val == \\'&\\') return And(Nodes.Select(x => x.GetResult()));\\n        if (Val == \\'!\\') return Not(Nodes.First().GetResult());\\n        return Val == \\'t\\';\\n    }\\n\\n    private static bool Not(bool x) => !x;\\n\\n    private static bool Or(IEnumerable<bool> xs)\\n        => xs.Aggregate(false, (x, y) => x || y);\\n\\n    private static bool And(IEnumerable<bool> xs)\\n        => xs.Aggregate(true, (x, y) => x && y);\\n}\\n\\npublic class Solution {\\n    public bool ParseBoolExpr(string expression) {\\n        Node curr = null;\\n\\n        foreach (var c in expression.ToCharArray()) {\\n            if (\"|&!tf\".Contains(c)) {\\n                var node = new Node { Val = c, Parent = curr };\\n                curr?.Nodes.Add(node);\\n                curr = node;\\n            }\\n            else if (\",)\".Contains(c)) {\\n                curr = curr?.Parent;\\n            }\\n        }\\n\\n        return curr?.GetResult() ?? throw new Exception();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\n\\npublic class Node {\\n    public Node Parent { get; set; }\\n    public List<Node> Nodes { get; } = new List<Node>();\\n    public char Val { get; set; }\\n\\n    public bool GetResult() {\\n        if (Val == \\'|\\') return Or(Nodes.Select(x => x.GetResult()));\\n        if (Val == \\'&\\') return And(Nodes.Select(x => x.GetResult()));\\n        if (Val == \\'!\\') return Not(Nodes.First().GetResult());\\n        return Val == \\'t\\';\\n    }\\n\\n    private static bool Not(bool x) => !x;\\n\\n    private static bool Or(IEnumerable<bool> xs)\\n        => xs.Aggregate(false, (x, y) => x || y);\\n\\n    private static bool And(IEnumerable<bool> xs)\\n        => xs.Aggregate(true, (x, y) => x && y);\\n}\\n\\npublic class Solution {\\n    public bool ParseBoolExpr(string expression) {\\n        Node curr = null;\\n\\n        foreach (var c in expression.ToCharArray()) {\\n            if (\"|&!tf\".Contains(c)) {\\n                var node = new Node { Val = c, Parent = curr };\\n                curr?.Nodes.Add(node);\\n                curr = node;\\n            }\\n            else if (\",)\".Contains(c)) {\\n                curr = curr?.Parent;\\n            }\\n        }\\n\\n        return curr?.GetResult() ?? throw new Exception();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 428163,
                "title": "short-python-solution-with-commentary-for-every-line",
                "content": "\\n```\\nclass Solution(object):\\n```\\nFrom the starting code provided by leetcode.\\n```\\n    def parseBoolExpr(self, expr):\\n```\\nI shortened the argument \"expression\" to just \"expr\".  I originally used it more often.\\n```\\n        func,ops,args = {\"&\": all, \"|\":any, \"!\":lambda x:not x[0]},[all],[[]]\\n```\\nI\\'m using aggregate assignment for 3 varaibles.\\n```ops``` holds a stack of operators waiting to evaluate their arguments.  Note that \"&( x )\" gives you back x.  Having a default here let\\'s me handle expressions with no operators.  In theory those are legal (```\"t\", evaluating to True;```), but I was surprised to learn they didn\\'t test for it. My code handles that case.\\n```args``` holds True and False values which are either directly specified, or the result of an operator.\\n```func``` is a list of allowed functions.  Python\\'s any() returns True if any of it\\'s arguments are True, which matches the behavior of the \"|\" operator in this problem.  The same for all() and \"&\".  I implemented \"!\" with a lambda that assumes there\\'s just one argument.\\n```\\n        for ch in expr:\\n```\\nMy first attempt was too complicated, with skipping around and short-circuit evaluation.  I need to avoid \"pre-mature optimizartion\" and start simple.  So here I will evaluate one character at a time.\\n```\\n            if ch in func:\\n```\\nWhen used on a dictionary, Python\\'s ```in``` operator acts on the dictionary keys.  If the current letter is any of the functions (\"!&}\"), then this ```if``` statetment will evaluate to True.\\n```\\n                ops.append(func[ch])\\n```\\nI append the function, not the character.  Functions and built-ins are objects that can be stored in a list.  Later, I\\'m going to call this function directly, which make look a little weird.\\n```\\n                args.append([])\\n```\\nI picked operators that work on a list of arguments.  The list gets fed to the current operator, so a new operator needs a new list to hold it\\'s arguments.\\n```\\n            elif ch in \"tf\":\\n```\\nI suspect this is faster than two separate ```if``` statements.  I catch \"t\" or \"f\" with one line.\\n```\\n                args[-1].append( ch == \"t\" )\\n```\\nI\\'m translating ch into True/False.  \"t\"==\"t\" gives me True, and \"f\"==\"t\" gives me False.  Every argument gets appended to the list.\\n```\\n            elif ch == \")\":\\n```\\nI actually ignore ( and , since they don\\'t change anything.  But \")\" is very important.\\n```\\n                args[-2].append(ops.pop()(args.pop()))\\n```\\nTo quote the matrix, this may feel a little weird.  I should explain each part in turn:\\n```args.pop()``` takes the current list of arguments, which I\\'ve been appending to using ```args[1].append()```.  I need to turn the entire list into one True or False value, so I pop() the list since it\\'s not needed anymore.\\n```ops.pop()``` takes the current operator off the stack - but it also calls the operator.\\n\\nIf you pretend ```ops.pop()``` is op, and allow ```args.pop()``` is arg, you will see this expression:\\n``` op ( arg ) ```\\nI\\'m actually calling the operator (any, all, or lambda) on the list of arguments.  That will result in a True False value... bu where do I put that value?\\n```args[-2].append(...)``` is where I place the result of the nested operator.  Once it returns True or False, that\\'s just another True/False value for the outer operator to process.  Note that ```args[-2]``` gets evaluated first, refering to the prior operator.  And then ```args.pop()``` removes args[-1] from the stack of arguments.\\n```\\n        return args[0][0]\\n```\\nI have a top-level dummy operator of \"all\", which should have just one boolean to evaluate.  The first operator in the list, in effect, is called by this dummy top-level operator.  Since ```all( x )``` is the same as x, I shouldn\\'t change the result of the boolean calclation.\\n\\nThe first argument is args[0], and there should be just one thing in the list, so args[0][0].\\n\\nIf explaining it line-by-line still left you confused, please quote the line and ask me questions about it.",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n```\n```\\n    def parseBoolExpr(self, expr):\\n```\n```\\n        func,ops,args = {\"&\": all, \"|\":any, \"!\":lambda x:not x[0]},[all],[[]]\\n```\n```ops```\n```\"t\", evaluating to True;```\n```args```\n```func```\n```\\n        for ch in expr:\\n```\n```\\n            if ch in func:\\n```\n```in```\n```if```\n```\\n                ops.append(func[ch])\\n```\n```\\n                args.append([])\\n```\n```\\n            elif ch in \"tf\":\\n```\n```if```\n```\\n                args[-1].append( ch == \"t\" )\\n```\n```\\n            elif ch == \")\":\\n```\n```\\n                args[-2].append(ops.pop()(args.pop()))\\n```\n```args.pop()```\n```args[1].append()```\n```ops.pop()```\n```ops.pop()```\n```args.pop()```\n``` op ( arg ) ```\n```args[-2].append(...)```\n```args[-2]```\n```args.pop()```\n```\\n        return args[0][0]\\n```\n```all( x )```",
                "codeTag": "Java"
            },
            {
                "id": 420775,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public boolean parseBoolExpr(String str) {\\n     \\n        Stack<Character> s = new Stack<>();   \\n        HashSet<Character> hash = new HashSet<>();\\n        \\n        int i=0;\\n        \\n        while(i<str.length()){\\n            if(str.charAt(i)==\\')\\'){\\n                hash = new HashSet<>(); \\n                while(s.peek()!=\\'(\\'){\\n                    hash.add(s.pop());\\n                }\\n                s.pop();\\n                char op = s.pop();\\n                if(op == \\'&\\')\\n                    s.push( hash.contains(\\'f\\') ? \\'f\\' : \\'t\\' );\\n                else if(op == \\'|\\')\\n                    s.push( hash.contains(\\'t\\') ? \\'t\\' : \\'f\\' );\\n                else if(op == \\'!\\')\\n                    s.push( hash.contains(\\'f\\') ? \\'t\\' : \\'f\\');       \\n            }\\n            else if(str.charAt(i) != \\',\\'){\\n                s.push(str.charAt(i));\\n            }\\n            i++;\\n        }\\n        return s.pop() == \\'t\\' ? true : false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean parseBoolExpr(String str) {\\n     \\n        Stack<Character> s = new Stack<>();   \\n        HashSet<Character> hash = new HashSet<>();\\n        \\n        int i=0;\\n        \\n        while(i<str.length()){\\n            if(str.charAt(i)==\\')\\'){\\n                hash = new HashSet<>(); \\n                while(s.peek()!=\\'(\\'){\\n                    hash.add(s.pop());\\n                }\\n                s.pop();\\n                char op = s.pop();\\n                if(op == \\'&\\')\\n                    s.push( hash.contains(\\'f\\') ? \\'f\\' : \\'t\\' );\\n                else if(op == \\'|\\')\\n                    s.push( hash.contains(\\'t\\') ? \\'t\\' : \\'f\\' );\\n                else if(op == \\'!\\')\\n                    s.push( hash.contains(\\'f\\') ? \\'t\\' : \\'f\\');       \\n            }\\n            else if(str.charAt(i) != \\',\\'){\\n                s.push(str.charAt(i));\\n            }\\n            i++;\\n        }\\n        return s.pop() == \\'t\\' ? true : false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 391064,
                "title": "c-elegant-recursive-solution",
                "content": "\\n    string endChars = \")}\";\\n    string ops = \"|!&\";\\n    \\n    \\n    bool solve(string&s, int &idx){\\n        char op = s[idx];\\n        bool res = op == \\'|\\' ? false : true;\\n        idx++;\\n        \\n        while(endChars.find(s[idx]) == -1){\\n            if(ops.find(s[idx]) != -1){\\n                bool c = solve(s, idx);\\n                \\n                if (op == \\'&\\') res &= c;\\n\\t\\t\\t\\tif (op == \\'|\\') res |= c;\\n\\t\\t\\t\\tif (op == \\'!\\') res = !c;\\n                \\n            }else if(s[idx] == \\'(\\' || s[idx] == \\'{\\' || s[idx] == \\',\\'){\\n                idx++;\\n                continue;\\n            }else{\\n                bool c = s[idx] == \\'t\\' ? true : false;\\n                if (op == \\'&\\') res &= c;\\n\\t\\t\\t\\tif (op == \\'|\\') res |= c;\\n\\t\\t\\t\\tif (op == \\'!\\') res = !c;\\n            }    \\n            idx++;\\n        }\\n        return res;\\n    }\\n    \\n    \\n    bool parseBoolExpr(string expression) {\\n        int i =0;\\n        expression = \"!(\" + expression + \")\";\\n        return !solve(expression, i);\\n       \\n    }\\n\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "\\n    string endChars = \")}\";\\n    string ops = \"|!&\";\\n    \\n    \\n    bool solve(string&s, int &idx){\\n        char op = s[idx];\\n        bool res = op == \\'|\\' ? false : true;\\n        idx++;\\n        \\n        while(endChars.find(s[idx]) == -1){\\n            if(ops.find(s[idx]) != -1){\\n                bool c = solve(s, idx);\\n                \\n                if (op == \\'&\\') res &= c;\\n\\t\\t\\t\\tif (op == \\'|\\') res |= c;\\n\\t\\t\\t\\tif (op == \\'!\\') res = !c;\\n                \\n            }else if(s[idx] == \\'(\\' || s[idx] == \\'{\\' || s[idx] == \\',\\'){\\n                idx++;\\n                continue;\\n            }else{\\n                bool c = s[idx] == \\'t\\' ? true : false;\\n                if (op == \\'&\\') res &= c;\\n\\t\\t\\t\\tif (op == \\'|\\') res |= c;\\n\\t\\t\\t\\tif (op == \\'!\\') res = !c;\\n            }    \\n            idx++;\\n        }\\n        return res;\\n    }\\n    \\n    \\n    bool parseBoolExpr(string expression) {\\n        int i =0;\\n        expression = \"!(\" + expression + \")\";\\n        return !solve(expression, i);\\n       \\n    }\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 378304,
                "title": "python-clear-solution-with-regex-99-65-100",
                "content": "```\\nimport re\\n\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        pattern = \\'(\\\\&|\\\\||\\\\!)\\\\(((t|f)(,(t|f))*)\\\\)\\'\\n        while True:\\n            m = re.search(pattern, expression)\\n            if m is None:\\n                break\\n            if m.group(1) == \\'&\\':\\n                rep = \\'f\\' if \\'f\\' in m.group(2) else \\'t\\'\\n            elif m.group(1) == \\'|\\':\\n                rep = \\'t\\' if \\'t\\' in m.group(2) else \\'f\\'\\n            else:\\n                rep = \\'t\\' if m.group(2) == \\'f\\' else \\'f\\'\\n            expression = expression.replace(m.group(0), rep)\\n        return True if expression == \\'t\\' else False\\n```",
                "solutionTags": [],
                "code": "```\\nimport re\\n\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        pattern = \\'(\\\\&|\\\\||\\\\!)\\\\(((t|f)(,(t|f))*)\\\\)\\'\\n        while True:\\n            m = re.search(pattern, expression)\\n            if m is None:\\n                break\\n            if m.group(1) == \\'&\\':\\n                rep = \\'f\\' if \\'f\\' in m.group(2) else \\'t\\'\\n            elif m.group(1) == \\'|\\':\\n                rep = \\'t\\' if \\'t\\' in m.group(2) else \\'f\\'\\n            else:\\n                rep = \\'t\\' if m.group(2) == \\'f\\' else \\'f\\'\\n            expression = expression.replace(m.group(0), rep)\\n        return True if expression == \\'t\\' else False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 367580,
                "title": "ll-1-recursive-parser-in-python",
                "content": "The parser decides what to do by looking at the next character. The current index gets passed into and out of the functions to avoid string slicing. The value of `i` after parsing indicates how much of the string has been consumed so far. I\\'ve tried to provide helpful error messages in the event that an invalid expression is entered.\\n\\n```python\\nclass Solution:\\n\\n    def parseBoolExpr(self, expression):\\n        result, i = self.parse_expression(expression)\\n        if i == len(expression):\\n            return result\\n        else:\\n            raise ValueError(\\'not all of the expression was parsed\\')\\n\\n    def parse_expression(self, expr, i=0):\\n        if expr[i] == \\'t\\':\\n            return (True, i+1)\\n        elif expr[i] == \\'f\\':\\n            return (False, i+1)\\n        elif expr[i] == \\'!\\':\\n            subexprs, i = self.parse_sequence(expr, i+1)\\n            if len(subexprs) != 1:\\n                raise ValueError(f\"expected exactly one sub-expression in negation but got {len(subexprs)}\")\\n            return (not subexprs[0], i)\\n        elif expr[i] == \\'&\\':\\n            conjuncts, i = self.parse_sequence(expr, i+1)\\n            return all(conjuncts), i\\n        elif expr[i] == \\'|\\':\\n            disjuncts, i = self.parse_sequence(expr, i+1)\\n            return any(disjuncts), i\\n        else:\\n            raise ValueError(\\'invalid expression\\')\\n    \\n    def parse_sequence(self, expr, i=0):\\n        if expr[i] != \\'(\\':\\n            raise ValueError(f\"expected \\'(\\' at index {i} but got {expr[i]!r}\")\\n\\n        first, i = self.parse_expression(expr, i+1)\\n        results = [first]\\n\\n        while expr[i] == \\',\\':\\n            result, i = self.parse_expression(expr, i+1)\\n            results.append(result)\\n        \\n        if expr[i] != \\')\\':\\n            raise ValueError(f\"expected \\')\\' at index {i} but got {expr[i]!r}\")\\n\\n        return results, i+1\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n\\n    def parseBoolExpr(self, expression):\\n        result, i = self.parse_expression(expression)\\n        if i == len(expression):\\n            return result\\n        else:\\n            raise ValueError(\\'not all of the expression was parsed\\')\\n\\n    def parse_expression(self, expr, i=0):\\n        if expr[i] == \\'t\\':\\n            return (True, i+1)\\n        elif expr[i] == \\'f\\':\\n            return (False, i+1)\\n        elif expr[i] == \\'!\\':\\n            subexprs, i = self.parse_sequence(expr, i+1)\\n            if len(subexprs) != 1:\\n                raise ValueError(f\"expected exactly one sub-expression in negation but got {len(subexprs)}\")\\n            return (not subexprs[0], i)\\n        elif expr[i] == \\'&\\':\\n            conjuncts, i = self.parse_sequence(expr, i+1)\\n            return all(conjuncts), i\\n        elif expr[i] == \\'|\\':\\n            disjuncts, i = self.parse_sequence(expr, i+1)\\n            return any(disjuncts), i\\n        else:\\n            raise ValueError(\\'invalid expression\\')\\n    \\n    def parse_sequence(self, expr, i=0):\\n        if expr[i] != \\'(\\':\\n            raise ValueError(f\"expected \\'(\\' at index {i} but got {expr[i]!r}\")\\n\\n        first, i = self.parse_expression(expr, i+1)\\n        results = [first]\\n\\n        while expr[i] == \\',\\':\\n            result, i = self.parse_expression(expr, i+1)\\n            results.append(result)\\n        \\n        if expr[i] != \\')\\':\\n            raise ValueError(f\"expected \\')\\' at index {i} but got {expr[i]!r}\")\\n\\n        return results, i+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 342757,
                "title": "short-parsing-on-stack-c",
                "content": "```C++\\nclass Solution {\\npublic:\\n    char compute(char op, vector<bool> const& v) {\\n        //assert(v.size() != 0);\\n        if (op == \\'!\\') return !v.front() ? \\'t\\' : \\'f\\';\\n        bool res = op == \\'&\\';\\n        for (bool o : v) {\\n            if (op == \\'&\\' && o == false) {\\n                res = false;\\n                break;\\n            } else if (op == \\'|\\' && o == true) {\\n                res = true;\\n                break;\\n            }\\n        }\\n        return res ? \\'t\\' : \\'f\\';\\n    }\\n    \\n    bool isop(char c) {\\n        return c == \\'&\\' || c == \\'|\\' || c == \\'!\\';\\n    }\\n    \\n    bool parseBoolExpr(string expression) {\\n        stack<char> st; // can have t,f,operation\\n        for (char c : expression) {\\n            if (isop(c) || c == \\'t\\' || c == \\'f\\')\\n                st.push(c);\\n            if (c == \\')\\') {\\n                vector<bool> operands;\\n                while (!isop(st.top())) {\\n                    operands.push_back(st.top() == \\'f\\' ? false : true);\\n                    st.pop();\\n                }\\n                char op = st.top();\\n                st.pop();\\n                st.push(compute(op, operands));\\n                \\n            }\\n            // ( and , are skipped\\n        }\\n        return st.top() == \\'t\\';\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    char compute(char op, vector<bool> const& v) {\\n        //assert(v.size() != 0);\\n        if (op == \\'!\\') return !v.front() ? \\'t\\' : \\'f\\';\\n        bool res = op == \\'&\\';\\n        for (bool o : v) {\\n            if (op == \\'&\\' && o == false) {\\n                res = false;\\n                break;\\n            } else if (op == \\'|\\' && o == true) {\\n                res = true;\\n                break;\\n            }\\n        }\\n        return res ? \\'t\\' : \\'f\\';\\n    }\\n    \\n    bool isop(char c) {\\n        return c == \\'&\\' || c == \\'|\\' || c == \\'!\\';\\n    }\\n    \\n    bool parseBoolExpr(string expression) {\\n        stack<char> st; // can have t,f,operation\\n        for (char c : expression) {\\n            if (isop(c) || c == \\'t\\' || c == \\'f\\')\\n                st.push(c);\\n            if (c == \\')\\') {\\n                vector<bool> operands;\\n                while (!isop(st.top())) {\\n                    operands.push_back(st.top() == \\'f\\' ? false : true);\\n                    st.pop();\\n                }\\n                char op = st.top();\\n                st.pop();\\n                st.push(compute(op, operands));\\n                \\n            }\\n            // ( and , are skipped\\n        }\\n        return st.top() == \\'t\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 328397,
                "title": "java-o-n-recursive-way-without-substring-15-line",
                "content": "the thought behind it is same as the discuss i write here https://leetcode.com/discuss/topic/328064\\n```\\nint i = 0;\\npublic boolean parseBoolExpr(String expression) {\\n\\treturn help(expression.toCharArray());\\n}\\nboolean help(char[] cs) {\\n\\tif (cs[i] == \\'t\\' || cs[i] == \\'f\\') {\\n\\t\\treturn cs[i++] == \\'t\\';\\n\\t}\\n\\tchar tag = cs[i++];\\n\\tSet<Boolean> bs = new HashSet<>();\\n\\tassert(cs[i++] == \\'(\\');\\n\\twhile (cs[i] != \\')\\') {\\n\\t\\tbs.add(help(cs));\\n\\t\\tif (cs[i] == \\',\\') i++;\\n\\t}\\n\\tassert(cs[i++] == \\')\\');\\n\\tif (tag == \\'!\\') return bs.contains(false);\\n\\treturn tag == \\'|\\' ? bs.contains(true) : !bs.contains(false);\\n}\\n```\\n\\niterative way\\n```\\npublic boolean parseBoolExpr(String exp) {\\n        Deque<Character> st = new ArrayDeque<>(exp.length());\\n        char[] cs = exp.toCharArray();\\n        for (int i = 0; i < cs.length; i++) {\\n            if (cs[i] == \\')\\') {\\n                Set<Character> bs = new HashSet<>();\\n                while (st.peek() != \\'(\\') {\\n                    bs.add(st.pop());\\n                }\\n                st.pop();\\n                char tag = st.pop();\\n                if (tag == \\'!\\') st.push(bs.contains(\\'f\\') ? \\'t\\' : \\'f\\');\\n                else {\\n                    boolean res = tag == \\'|\\' ? bs.contains(\\'t\\') : !bs.contains(\\'f\\');\\n                    st.push(res ? \\'t\\' : \\'f\\');\\n                }\\n            } else if (cs[i] != \\',\\') {\\n                st.push(cs[i]);\\n            }\\n        }\\n        return st.peek() == \\'t\\';\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint i = 0;\\npublic boolean parseBoolExpr(String expression) {\\n\\treturn help(expression.toCharArray());\\n}\\nboolean help(char[] cs) {\\n\\tif (cs[i] == \\'t\\' || cs[i] == \\'f\\') {\\n\\t\\treturn cs[i++] == \\'t\\';\\n\\t}\\n\\tchar tag = cs[i++];\\n\\tSet<Boolean> bs = new HashSet<>();\\n\\tassert(cs[i++] == \\'(\\');\\n\\twhile (cs[i] != \\')\\') {\\n\\t\\tbs.add(help(cs));\\n\\t\\tif (cs[i] == \\',\\') i++;\\n\\t}\\n\\tassert(cs[i++] == \\')\\');\\n\\tif (tag == \\'!\\') return bs.contains(false);\\n\\treturn tag == \\'|\\' ? bs.contains(true) : !bs.contains(false);\\n}\\n```\n```\\npublic boolean parseBoolExpr(String exp) {\\n        Deque<Character> st = new ArrayDeque<>(exp.length());\\n        char[] cs = exp.toCharArray();\\n        for (int i = 0; i < cs.length; i++) {\\n            if (cs[i] == \\')\\') {\\n                Set<Character> bs = new HashSet<>();\\n                while (st.peek() != \\'(\\') {\\n                    bs.add(st.pop());\\n                }\\n                st.pop();\\n                char tag = st.pop();\\n                if (tag == \\'!\\') st.push(bs.contains(\\'f\\') ? \\'t\\' : \\'f\\');\\n                else {\\n                    boolean res = tag == \\'|\\' ? bs.contains(\\'t\\') : !bs.contains(\\'f\\');\\n                    st.push(res ? \\'t\\' : \\'f\\');\\n                }\\n            } else if (cs[i] != \\',\\') {\\n                st.push(cs[i]);\\n            }\\n        }\\n        return st.peek() == \\'t\\';\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 328392,
                "title": "rust-0ms-faster-than-100",
                "content": "```rust\\n/// We can solve this problem by implementing our own stack and treat (&, |, !) as a function calls\\n/// and (t, f) as params to these functions.\\n///\\n/// For example here is a simple Expression representing `not` function\\n/// input: \"!(f)\"\\n/// the parser will create an empty stack at first for this function\\n/// ```t\\n/// +---------+\\n/// |         |\\n/// +---------+\\n/// ```\\n/// after that the parser will match every `char` in the expression and try to push that `Expr`\\n/// in the stack\\n///\\n/// We have two type of `Expr` represented by the `Expr` enum.\\n/// so the parser will at first hit the `!` char, it will push `Expr::Func(not)` to the stack\\n///\\n/// ```t\\n/// +-----------------+\\n/// | Expr::Func(not) |\\n/// +-----------------+\\n/// ```\\n/// next it would match the `(` char, we ignore that, then matching the `f` char, it will map\\n/// that to `Expr::Const(false)` and push it to the stack\\n/// ```t\\n/// +--------------------+\\n/// |   Expr::Func(not)  |\\n/// +--------------------+\\n/// | Expr::Const(false) |\\n/// +--------------------+\\n/// ```\\n/// > Note that since our stack is implemented using `Vec` it pushes in the reverse order, but\\n/// the stack is pushes into the top.\\n///\\n/// next we he hit the `)` char, that\\'s where we execute the expr.\\n///\\n/// we will start from the back (last element) in our `Vec` to act as a `Stack`, we start to\\n/// collect a new `Vec` of `bool`s called `params` from the stack and pop that value too from the\\n/// stack and once we hit a `Expr::Func` we stop.\\n/// `params = [false]`\\n/// ```t\\n/// +-----------------+\\n/// | Expr::Func(not) |\\n/// +-----------------+\\n/// ```\\n/// next we get that function from the stack, and call it with the collected `params`\\n/// ```t\\n/// +---------+\\n/// |         |\\n/// +---------+\\n/// ```\\n/// `result = Expr::Const(func(params))`\\n///\\n/// and we push the result pack in the stack\\n/// ```t\\n/// +-------------------+\\n/// | Expr::Const(true) |\\n/// +-------------------+\\n/// ```\\n/// and we go to next `char` and so on..\\n///\\n/// at the end of the loop we know that we will be left with one `Expr::Const` on the top of our\\n/// stack so we fetch it and return the result :)\\n///\\npub fn parse_bool_expr(expression: String) -> bool {\\n    let mut stack: Vec<Expr> = Vec::new();\\n    for c in expression.chars() {\\n        match c {\\n            \\'!\\' => stack.push(Expr::Func(not)),\\n            \\'|\\' => stack.push(Expr::Func(or)),\\n            \\'&\\' => stack.push(Expr::Func(and)),\\n            \\'t\\' => stack.push(Expr::Const(true)),\\n            \\'f\\' => stack.push(Expr::Const(false)),\\n            \\')\\' => {\\n                let mut params: Vec<bool> = vec![];\\n                while let Some(Expr::Const(v)) = stack.last() {\\n                    params.push(*v);\\n                    stack.pop(); // then remove it\\n                }\\n                // get the last func for these params\\n                if let Expr::Func(func) = stack.pop().unwrap() {\\n                    let result = func(params);\\n                    // store the value back to the stack.\\n                    stack.push(Expr::Const(result));\\n                }\\n            }\\n            _ => {\\n                // I would ignore that\\n            }\\n        }\\n    }\\n    if let Expr::Const(v) = *stack.last().unwrap() {\\n        v\\n    } else {\\n        unreachable!(\"Oh Bad\")\\n    }\\n}\\n\\nfn not(tf: Vec<bool>) -> bool {\\n    !tf[0]\\n}\\n\\nfn or(tf: Vec<bool>) -> bool {\\n    tf.iter().any(|v| *v)\\n}\\n\\nfn and(tf: Vec<bool>) -> bool {\\n    tf.iter().all(|v| *v)\\n}\\n\\nenum Expr {\\n    Const(bool),\\n    Func(fn(tf: Vec<bool>) -> bool),\\n}\\n```\\n\\nif you have any improvements, i would be more than happy to mention it here \\uD83E\\uDD70\\n",
                "solutionTags": [],
                "code": "```rust\\n/// We can solve this problem by implementing our own stack and treat (&, |, !) as a function calls\\n/// and (t, f) as params to these functions.\\n///\\n/// For example here is a simple Expression representing `not` function\\n/// input: \"!(f)\"\\n/// the parser will create an empty stack at first for this function\\n/// ```\n```\\n/// after that the parser will match every `char` in the expression and try to push that `Expr`\\n/// in the stack\\n///\\n/// We have two type of `Expr` represented by the `Expr` enum.\\n/// so the parser will at first hit the `!` char, it will push `Expr::Func(not)` to the stack\\n///\\n/// ```\n```\\n/// next it would match the `(` char, we ignore that, then matching the `f` char, it will map\\n/// that to `Expr::Const(false)` and push it to the stack\\n/// ```\n```\\n/// > Note that since our stack is implemented using `Vec` it pushes in the reverse order, but\\n/// the stack is pushes into the top.\\n///\\n/// next we he hit the `)` char, that\\'s where we execute the expr.\\n///\\n/// we will start from the back (last element) in our `Vec` to act as a `Stack`, we start to\\n/// collect a new `Vec` of `bool`s called `params` from the stack and pop that value too from the\\n/// stack and once we hit a `Expr::Func` we stop.\\n/// `params = [false]`\\n/// ```\n```\\n/// next we get that function from the stack, and call it with the collected `params`\\n/// ```\n```\\n/// `result = Expr::Const(func(params))`\\n///\\n/// and we push the result pack in the stack\\n/// ```\n```\\n/// and we go to next `char` and so on..\\n///\\n/// at the end of the loop we know that we will be left with one `Expr::Const` on the top of our\\n/// stack so we fetch it and return the result :)\\n///\\npub fn parse_bool_expr(expression: String) -> bool {\\n    let mut stack: Vec<Expr> = Vec::new();\\n    for c in expression.chars() {\\n        match c {\\n            \\'!\\' => stack.push(Expr::Func(not)),\\n            \\'|\\' => stack.push(Expr::Func(or)),\\n            \\'&\\' => stack.push(Expr::Func(and)),\\n            \\'t\\' => stack.push(Expr::Const(true)),\\n            \\'f\\' => stack.push(Expr::Const(false)),\\n            \\')\\' => {\\n                let mut params: Vec<bool> = vec![];\\n                while let Some(Expr::Const(v)) = stack.last() {\\n                    params.push(*v);\\n                    stack.pop(); // then remove it\\n                }\\n                // get the last func for these params\\n                if let Expr::Func(func) = stack.pop().unwrap() {\\n                    let result = func(params);\\n                    // store the value back to the stack.\\n                    stack.push(Expr::Const(result));\\n                }\\n            }\\n            _ => {\\n                // I would ignore that\\n            }\\n        }\\n    }\\n    if let Expr::Const(v) = *stack.last().unwrap() {\\n        v\\n    } else {\\n        unreachable!(\"Oh Bad\")\\n    }\\n}\\n\\nfn not(tf: Vec<bool>) -> bool {\\n    !tf[0]\\n}\\n\\nfn or(tf: Vec<bool>) -> bool {\\n    tf.iter().any(|v| *v)\\n}\\n\\nfn and(tf: Vec<bool>) -> bool {\\n    tf.iter().all(|v| *v)\\n}\\n\\nenum Expr {\\n    Const(bool),\\n    Func(fn(tf: Vec<bool>) -> bool),\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 327752,
                "title": "simple-python-solution-using-stack",
                "content": "```\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        \"\"\"\\n        :type expression: str\\n        :rtype: bool\\n        \"\"\"\\n        stack, i = [], 0\\n        \\n        while i < len(expression):\\n            c = expression[i]\\n            if c == \\')\\':\\n                operands = []\\n                while stack[-1] in (True, False):\\n                    operands.append(stack.pop())\\n                operator = stack.pop()    \\n                stack.append(operator(operands))\\n            elif c == \\'!\\':\\n                stack.append(lambda x: not x[0])\\n            elif c == \\'&\\':\\n                stack.append(all)\\n            elif c == \\'|\\':\\n                stack.append(any)\\n            elif c == \\'t\\':   \\n                stack.append(True)\\n            elif c == \\'f\\':   \\n                stack.append(False)\\n            \\n            i += 1\\n        \\n        return stack[-1]\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        \"\"\"\\n        :type expression: str\\n        :rtype: bool\\n        \"\"\"\\n        stack, i = [], 0\\n        \\n        while i < len(expression):\\n            c = expression[i]\\n            if c == \\')\\':\\n                operands = []\\n                while stack[-1] in (True, False):\\n                    operands.append(stack.pop())\\n                operator = stack.pop()    \\n                stack.append(operator(operands))\\n            elif c == \\'!\\':\\n                stack.append(lambda x: not x[0])\\n            elif c == \\'&\\':\\n                stack.append(all)\\n            elif c == \\'|\\':\\n                stack.append(any)\\n            elif c == \\'t\\':   \\n                stack.append(True)\\n            elif c == \\'f\\':   \\n                stack.append(False)\\n            \\n            i += 1\\n        \\n        return stack[-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 323843,
                "title": "simple-100-java-recursive-parser-with-explanation",
                "content": "This is a problem of type \"Recursive Parser\", just like other problems are of, say, type \"Sliding Window\" or type \"DFS\". The Recursive Parser pattern is a useful pattern to have in your mental toolbox.\\n\\nThe general structure to solving these problems is:\\n\\n* `parse()`: This function will handle \"blocks\", or logical groups of computation. In this problem, our \"blocks\" will look like `operator(boolean, boolean, ...)`. For example, a block would be `&(t, t, f)`. Another block is `!(t)`. Blocks may contain blocks, such as `|(f, &(t, t))`. Our `parse()` function will recursively call itself to transform that inner block into a single boolean value and then perform the `|`. `Parse()` will parse an expression by keeping a running list of its constituents (in this case, booleans). Once it encounters `)` it will call `eval()` with its operator and constituents. \\n* `eval()`: This function takes an operator and a list of elements, and performs the operation on those elements. Returns a single value.\\n* `i`: This global variable is current index in the string the parser is at. This will monotonically increase, making our time O(n). It must be a global because, when `parse()` calls itself, after that child call is done, the original `parse()` call needs to know where to pick up parsing, so it may continue parsing its own expression. We can\\'t have `parse()` return the amount `i` was incremented by, because we instead need `parse()` return the result of a computation (which, in this case, is a boolean). \\n* `s`: It\\'s the string we\\'re parsing. Doesn\\'t have to be a global. I like it because it\\'s one less argument to pass around.\\n\\nOther Recursive Parser pattern problems to try:\\n* https://leetcode.com/problems/brace-expansion-ii/\\n* https://leetcode.com/problems/basic-calculator-iii/\\n\\n```\\nclass Solution {\\n    int i;\\n    String s;\\n    \\n    public boolean parseBoolExpr(String expression) {\\n        i = 0;\\n        s = expression;\\n        \\n        return parse();\\n    }\\n    \\n    private boolean parse() {\\n        char op = s.charAt(i++);\\n        List<Boolean> bools = new ArrayList();\\n        \\n        while (i < s.length()) {\\n            char c = s.charAt(i++);\\n            \\n            if (c == \\'t\\' || c == \\'f\\')\\n                bools.add(c == \\'t\\');\\n            else if (c == \\'|\\' || c == \\'&\\' || c == \\'!\\') {\\n                i--;\\n                bools.add(parse());\\n            }\\n            else if (c == \\')\\')\\n                break;\\n        }\\n        return eval(bools, op);\\n    }\\n    \\n    private boolean eval(List<Boolean> bools, char op) {\\n        if (op == \\'!\\')\\n            return !bools.get(0);\\n        \\n        boolean result = (op == \\'|\\') ? false : true;\\n        for (boolean bool : bools)\\n            result = (op == \\'|\\') ? (result || bool) : (result && bool);\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int i;\\n    String s;\\n    \\n    public boolean parseBoolExpr(String expression) {\\n        i = 0;\\n        s = expression;\\n        \\n        return parse();\\n    }\\n    \\n    private boolean parse() {\\n        char op = s.charAt(i++);\\n        List<Boolean> bools = new ArrayList();\\n        \\n        while (i < s.length()) {\\n            char c = s.charAt(i++);\\n            \\n            if (c == \\'t\\' || c == \\'f\\')\\n                bools.add(c == \\'t\\');\\n            else if (c == \\'|\\' || c == \\'&\\' || c == \\'!\\') {\\n                i--;\\n                bools.add(parse());\\n            }\\n            else if (c == \\')\\')\\n                break;\\n        }\\n        return eval(bools, op);\\n    }\\n    \\n    private boolean eval(List<Boolean> bools, char op) {\\n        if (op == \\'!\\')\\n            return !bools.get(0);\\n        \\n        boolean result = (op == \\'|\\') ? false : true;\\n        for (boolean bool : bools)\\n            result = (op == \\'|\\') ? (result || bool) : (result && bool);\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 323742,
                "title": "c-recursion-solution-4ms-beats-100-memory",
                "content": "Run this code.\\nWatch the Stdout\\nto know how recursion works in this solution.\\n```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n        vector<string> tmp;\\n        if(expression[0]==\\'|\\'){\\n            tmp=partition(expression);\\n            return orJudge(tmp);\\n        }else if(expression[0]==\\'&\\'){\\n            tmp=partition(expression);\\n            return andJudge(tmp);\\n        }else{\\n            tmp=partition(expression);\\n            return !notJudge(tmp);\\n        }\\n    }\\n    vector<string> partition(string expression){\\n        int size=expression.size();\\n        int mark=0,pos=2;\\n        int i,j;\\n        vector<string> ret;\\n        cout << \"Expression: \" << expression << endl;\\n        for(i=2;i<size;++i){\\n            if(expression[i]==\\',\\' && mark==0){\\n                string tmp=expression.substr(pos,i-pos);\\n                ret.push_back(tmp);\\n                cout << tmp << endl;\\n                pos=i+1;\\n            }else if(expression[i]==\\')\\' && mark==0){\\n                string tmp=expression.substr(pos,i-pos);\\n                ret.push_back(tmp);\\n                cout << tmp << endl;\\n                pos=i+1;\\n            }\\n            if(expression[i]==\\'(\\'){\\n                ++mark;\\n            }else if(expression[i]==\\')\\'){\\n                --mark;\\n            }\\n        }\\n        cout << \"Expression partition Finished.\" << endl;\\n        return ret;\\n    }\\n    bool andJudge(vector<string> A){\\n        int i;\\n        int size=A.size();\\n        vector<string> recursion;\\n        for(i=0;i<size;++i){\\n            if(A[i].size()==1){\\n                if(A[i][0]==\\'f\\')\\n                    return false;\\n            }else{\\n                if(A[i][0]==\\'|\\'){\\n                    recursion=partition(A[i]);\\n                    if(!orJudge(recursion)){\\n                        return false;\\n                    }\\n                }else if(A[i][0]==\\'&\\'){\\n                    recursion=partition(A[i]);\\n                    if(!andJudge(recursion)){\\n                        return false;\\n                    }\\n                }else{\\n                    recursion=partition(A[i]);\\n                    if(notJudge(recursion)){\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    bool orJudge(vector<string> A){\\n        int i;\\n        int size=A.size();\\n        vector<string> recursion;\\n        for(i=0;i<size;++i){\\n            if(A[i].size()==1){\\n                if(A[i][0]==\\'t\\')\\n                    return true;\\n            }else{\\n                if(A[i][0]==\\'|\\'){\\n                    recursion=partition(A[i]);\\n                    if(orJudge(recursion)){\\n                        return true;\\n                    }\\n                }else if(A[i][0]==\\'&\\'){\\n                    recursion=partition(A[i]);\\n                    if(andJudge(recursion)){\\n                        return true;\\n                    }\\n                }else{\\n                    recursion=partition(A[i]);\\n                    if(!notJudge(recursion)){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool notJudge(vector<string> A){\\n        int i;\\n        int size=A.size();\\n        vector<string> recursion;\\n        for(i=0;i<size;++i){\\n            if(A[i].size()==1){\\n                if(A[i][0]==\\'t\\')\\n                    return true;\\n                else\\n                    return false;\\n            }else{\\n                if(A[i][0]==\\'|\\'){\\n                    recursion=partition(A[i]);\\n                    return orJudge(recursion);\\n                }else if(A[i][0]==\\'&\\'){\\n                    recursion=partition(A[i]);\\n                    return andJudge(recursion);\\n                }else{\\n                    recursion=partition(A[i]);\\n                    return !notJudge(recursion);\\n                }\\n            }\\n        }\\n        return false; //return guard\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n        vector<string> tmp;\\n        if(expression[0]==\\'|\\'){\\n            tmp=partition(expression);\\n            return orJudge(tmp);\\n        }else if(expression[0]==\\'&\\'){\\n            tmp=partition(expression);\\n            return andJudge(tmp);\\n        }else{\\n            tmp=partition(expression);\\n            return !notJudge(tmp);\\n        }\\n    }\\n    vector<string> partition(string expression){\\n        int size=expression.size();\\n        int mark=0,pos=2;\\n        int i,j;\\n        vector<string> ret;\\n        cout << \"Expression: \" << expression << endl;\\n        for(i=2;i<size;++i){\\n            if(expression[i]==\\',\\' && mark==0){\\n                string tmp=expression.substr(pos,i-pos);\\n                ret.push_back(tmp);\\n                cout << tmp << endl;\\n                pos=i+1;\\n            }else if(expression[i]==\\')\\' && mark==0){\\n                string tmp=expression.substr(pos,i-pos);\\n                ret.push_back(tmp);\\n                cout << tmp << endl;\\n                pos=i+1;\\n            }\\n            if(expression[i]==\\'(\\'){\\n                ++mark;\\n            }else if(expression[i]==\\')\\'){\\n                --mark;\\n            }\\n        }\\n        cout << \"Expression partition Finished.\" << endl;\\n        return ret;\\n    }\\n    bool andJudge(vector<string> A){\\n        int i;\\n        int size=A.size();\\n        vector<string> recursion;\\n        for(i=0;i<size;++i){\\n            if(A[i].size()==1){\\n                if(A[i][0]==\\'f\\')\\n                    return false;\\n            }else{\\n                if(A[i][0]==\\'|\\'){\\n                    recursion=partition(A[i]);\\n                    if(!orJudge(recursion)){\\n                        return false;\\n                    }\\n                }else if(A[i][0]==\\'&\\'){\\n                    recursion=partition(A[i]);\\n                    if(!andJudge(recursion)){\\n                        return false;\\n                    }\\n                }else{\\n                    recursion=partition(A[i]);\\n                    if(notJudge(recursion)){\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    bool orJudge(vector<string> A){\\n        int i;\\n        int size=A.size();\\n        vector<string> recursion;\\n        for(i=0;i<size;++i){\\n            if(A[i].size()==1){\\n                if(A[i][0]==\\'t\\')\\n                    return true;\\n            }else{\\n                if(A[i][0]==\\'|\\'){\\n                    recursion=partition(A[i]);\\n                    if(orJudge(recursion)){\\n                        return true;\\n                    }\\n                }else if(A[i][0]==\\'&\\'){\\n                    recursion=partition(A[i]);\\n                    if(andJudge(recursion)){\\n                        return true;\\n                    }\\n                }else{\\n                    recursion=partition(A[i]);\\n                    if(!notJudge(recursion)){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool notJudge(vector<string> A){\\n        int i;\\n        int size=A.size();\\n        vector<string> recursion;\\n        for(i=0;i<size;++i){\\n            if(A[i].size()==1){\\n                if(A[i][0]==\\'t\\')\\n                    return true;\\n                else\\n                    return false;\\n            }else{\\n                if(A[i][0]==\\'|\\'){\\n                    recursion=partition(A[i]);\\n                    return orJudge(recursion);\\n                }else if(A[i][0]==\\'&\\'){\\n                    recursion=partition(A[i]);\\n                    return andJudge(recursion);\\n                }else{\\n                    recursion=partition(A[i]);\\n                    return !notJudge(recursion);\\n                }\\n            }\\n        }\\n        return false; //return guard\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 323710,
                "title": "python-stack-solution",
                "content": "```\\nclass Solution(object):\\n    def parseBoolExpr(self, expression):\\n        \"\"\"\\n        :type expression: str\\n        :rtype: bool\\n        \"\"\"\\n        \\n        def getAns(stack, operation):\\n            res = stack.pop()\\n            if operation == \\'!\\':\\n                return not res\\n            \\n            while len(stack)>0 and stack[len(stack)-1]!=\\'(\\':\\n                temp = stack.pop()\\n                if operation == \\'|\\':\\n                    res = (res or temp)\\n                else:\\n                    res = (res and temp)\\n            return res\\n                    \\n        \\n        stack = []\\n        operations = []\\n        for i in range(len(expression)):\\n            c = expression[i]\\n            if c==\\'(\\':\\n                stack.append(c)\\n            elif c==\\'!\\' or c==\\'&\\' or c==\\'|\\':\\n                operations.append(c)\\n            elif c==\\'t\\':\\n                stack.append(True)\\n            elif c==\\'f\\':\\n                stack.append(False)\\n            elif c==\\')\\':\\n                temp = getAns(stack, operations[len(operations)-1])\\n                stack.pop()\\n                stack.append(temp)\\n                operations.pop()\\n        \\n        \\n        return stack[0]\\n                \\n                \\n            \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def parseBoolExpr(self, expression):\\n        \"\"\"\\n        :type expression: str\\n        :rtype: bool\\n        \"\"\"\\n        \\n        def getAns(stack, operation):\\n            res = stack.pop()\\n            if operation == \\'!\\':\\n                return not res\\n            \\n            while len(stack)>0 and stack[len(stack)-1]!=\\'(\\':\\n                temp = stack.pop()\\n                if operation == \\'|\\':\\n                    res = (res or temp)\\n                else:\\n                    res = (res and temp)\\n            return res\\n                    \\n        \\n        stack = []\\n        operations = []\\n        for i in range(len(expression)):\\n            c = expression[i]\\n            if c==\\'(\\':\\n                stack.append(c)\\n            elif c==\\'!\\' or c==\\'&\\' or c==\\'|\\':\\n                operations.append(c)\\n            elif c==\\'t\\':\\n                stack.append(True)\\n            elif c==\\'f\\':\\n                stack.append(False)\\n            elif c==\\')\\':\\n                temp = getAns(stack, operations[len(operations)-1])\\n                stack.pop()\\n                stack.append(temp)\\n                operations.pop()\\n        \\n        \\n        return stack[0]\\n                \\n                \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 323562,
                "title": "rust-clean-solution-using-recursion",
                "content": "```rust\\nuse std::str::Chars;\\n\\nimpl Solution {\\n    pub fn parse_next(iter: &mut Chars) -> bool {\\n        match iter.next() {\\n            Some(\\'t\\') => true,\\n            Some(\\'f\\') => false,\\n            Some(\\'&\\') => Solution::parse_and(iter),\\n            Some(\\'|\\') => Solution::parse_or(iter),\\n            Some(\\'!\\') => Solution::parse_not(iter),\\n            _ => unreachable!()\\n        }\\n    }\\n\\n    pub fn parse_not(iter: &mut Chars) -> bool {\\n        let mut result = true;\\n        loop {\\n            match iter.next() {\\n                Some(\\')\\') => return !result,\\n                Some(\\'(\\') => result = Solution::parse_next(iter),\\n                _ => unreachable!()\\n            }\\n        }\\n    }\\n\\n    pub fn parse_and(iter: &mut Chars) -> bool {\\n        let mut result = true;\\n        loop {\\n            match iter.next() {\\n                Some(\\')\\') => return result,\\n                Some(\\'(\\') => result = Solution::parse_next(iter),\\n                Some(\\',\\') => result = Solution::parse_next(iter) && result,\\n                _ => unreachable!()\\n            }\\n        }\\n    }\\n    \\n    pub fn parse_or(iter: &mut Chars) -> bool {\\n        let mut result = false;\\n        loop {\\n            match iter.next() {\\n                Some(\\')\\') => return result,\\n                Some(\\'(\\') => result = Solution::parse_next(iter),\\n                Some(\\',\\') => result = Solution::parse_next(iter) || result,\\n                _ => unreachable!()\\n            }\\n        }\\n    }\\n\\n    pub fn parse_bool_expr(expression: String) -> bool {\\n        let mut iter = expression.chars();\\n        Solution::parse_next(&mut iter)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nuse std::str::Chars;\\n\\nimpl Solution {\\n    pub fn parse_next(iter: &mut Chars) -> bool {\\n        match iter.next() {\\n            Some(\\'t\\') => true,\\n            Some(\\'f\\') => false,\\n            Some(\\'&\\') => Solution::parse_and(iter),\\n            Some(\\'|\\') => Solution::parse_or(iter),\\n            Some(\\'!\\') => Solution::parse_not(iter),\\n            _ => unreachable!()\\n        }\\n    }\\n\\n    pub fn parse_not(iter: &mut Chars) -> bool {\\n        let mut result = true;\\n        loop {\\n            match iter.next() {\\n                Some(\\')\\') => return !result,\\n                Some(\\'(\\') => result = Solution::parse_next(iter),\\n                _ => unreachable!()\\n            }\\n        }\\n    }\\n\\n    pub fn parse_and(iter: &mut Chars) -> bool {\\n        let mut result = true;\\n        loop {\\n            match iter.next() {\\n                Some(\\')\\') => return result,\\n                Some(\\'(\\') => result = Solution::parse_next(iter),\\n                Some(\\',\\') => result = Solution::parse_next(iter) && result,\\n                _ => unreachable!()\\n            }\\n        }\\n    }\\n    \\n    pub fn parse_or(iter: &mut Chars) -> bool {\\n        let mut result = false;\\n        loop {\\n            match iter.next() {\\n                Some(\\')\\') => return result,\\n                Some(\\'(\\') => result = Solution::parse_next(iter),\\n                Some(\\',\\') => result = Solution::parse_next(iter) || result,\\n                _ => unreachable!()\\n            }\\n        }\\n    }\\n\\n    pub fn parse_bool_expr(expression: String) -> bool {\\n        let mut iter = expression.chars();\\n        Solution::parse_next(&mut iter)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 323465,
                "title": "c-easy-to-understand-solution-using-stack-with-explanation",
                "content": "You my use the cout to help understanding how it works.\\nGiven the 4th exemple: \\n|(&(t,f,t),!(t))\\nThe result stack: |(&tft\\nEvaluation stack: &tft\\n\\nAfter the first evaluation\\nThe result stack: |(f\\n\\nAnd then\\nThe result stack: |(f!(t\\nEvaluation stack: !t\\n\\nAfter the second evaluation\\nThe result stack: |(ff\\n\\nAne then\\nThe result stack: |(ff\\nEvaluation stack: |ff\\n\\nAfter the third evaluation\\nThe result stack: f --> final answer\\n\\n* Analysis: (Feel free to correct me if I am wrong, not quite sure about the analysis of this problem)\\n    * Time complexity: O(N) since each element will be push into the stack and pop once.\\n    * Space complexity: O(N) \\n```\\n#include <bits/stdc++.h>\\nclass Solution \\n{\\npublic:\\n    bool parseBoolExpr(string exp) \\n    {\\n        int n = exp.size();\\n        vector<char> ev;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(exp[i] != \\',\\')\\n            {\\n                ev.push_back(exp[i]);\\n            }\\n        }\\n        \\n        n = ev.size();\\n        deque<char> res;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(ev[i] != \\')\\')\\n            {\\n                res.push_back(ev[i]);\\n            }\\n            else\\n            {\\n                deque<char> eval_stk; // stack stored for evaluation   \\n                while(res.size() && res.back() != \\'&\\' && res.back() != \\'|\\' && res.back() != \\'!\\') // push back the operands\\n                {\\n                    cout << \"res_back \" << res.back() << \\'\\\\n\\';\\n                    if(res.back() == \\'t\\' || res.back() == \\'f\\')\\n                    {\\n                        eval_stk.push_back(res.back());\\n                    }\\n                    res.pop_back();\\n                }\\n                \\n                char op = res.back(); // get operator\\n                res.pop_back(); // pop that operator out\\n                bool on = (eval_stk.back() == \\'t\\') ? 1 : 0; // first answer\\n                cout <<\"on \" << on << \" op \" << op << \"res.size() \" << res.size() << \\'\\\\n\\';\\n                \\n                if(op == \\'|\\') // or operator\\n                {\\n                    while(eval_stk.size())\\n                    {\\n                        if((eval_stk.back() == \\'t\\'))\\n                        {\\n                            on |= 1; // early stopping if encounter OR 1\\n                            break;\\n                        }\\n                        else\\n                        {\\n                            on |= 0;\\n                        }\\n                        eval_stk.pop_back();\\n                    }\\n                }\\n                else if(op == \\'&\\') // and operator\\n                {\\n                    while(eval_stk.size())\\n                    {\\n                        if((eval_stk.back() == \\'t\\'))\\n                        {\\n                            on &= 1;\\n                        }\\n                        else\\n                        {\\n                            on &= 0; // early stopping if encounter AND 0\\n                            break;\\n                        }\\n                        eval_stk.pop_back();\\n                    }\\n                }\\n                else if(op == \\'!\\')\\n                {\\n                    on ^= 1; // toggle the boolean result\\n                }\\n                res.push_back((on == 1) ? \\'t\\' : \\'f\\');\\n            }\\n        }\\n        \\n        return (res.back() == \\'t\\') ? 1 : 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#include <bits/stdc++.h>\\nclass Solution \\n{\\npublic:\\n    bool parseBoolExpr(string exp) \\n    {\\n        int n = exp.size();\\n        vector<char> ev;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(exp[i] != \\',\\')\\n            {\\n                ev.push_back(exp[i]);\\n            }\\n        }\\n        \\n        n = ev.size();\\n        deque<char> res;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(ev[i] != \\')\\')\\n            {\\n                res.push_back(ev[i]);\\n            }\\n            else\\n            {\\n                deque<char> eval_stk; // stack stored for evaluation   \\n                while(res.size() && res.back() != \\'&\\' && res.back() != \\'|\\' && res.back() != \\'!\\') // push back the operands\\n                {\\n                    cout << \"res_back \" << res.back() << \\'\\\\n\\';\\n                    if(res.back() == \\'t\\' || res.back() == \\'f\\')\\n                    {\\n                        eval_stk.push_back(res.back());\\n                    }\\n                    res.pop_back();\\n                }\\n                \\n                char op = res.back(); // get operator\\n                res.pop_back(); // pop that operator out\\n                bool on = (eval_stk.back() == \\'t\\') ? 1 : 0; // first answer\\n                cout <<\"on \" << on << \" op \" << op << \"res.size() \" << res.size() << \\'\\\\n\\';\\n                \\n                if(op == \\'|\\') // or operator\\n                {\\n                    while(eval_stk.size())\\n                    {\\n                        if((eval_stk.back() == \\'t\\'))\\n                        {\\n                            on |= 1; // early stopping if encounter OR 1\\n                            break;\\n                        }\\n                        else\\n                        {\\n                            on |= 0;\\n                        }\\n                        eval_stk.pop_back();\\n                    }\\n                }\\n                else if(op == \\'&\\') // and operator\\n                {\\n                    while(eval_stk.size())\\n                    {\\n                        if((eval_stk.back() == \\'t\\'))\\n                        {\\n                            on &= 1;\\n                        }\\n                        else\\n                        {\\n                            on &= 0; // early stopping if encounter AND 0\\n                            break;\\n                        }\\n                        eval_stk.pop_back();\\n                    }\\n                }\\n                else if(op == \\'!\\')\\n                {\\n                    on ^= 1; // toggle the boolean result\\n                }\\n                res.push_back((on == 1) ? \\'t\\' : \\'f\\');\\n            }\\n        }\\n        \\n        return (res.back() == \\'t\\') ? 1 : 0;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 323417,
                "title": "easily-implemented-python-solution",
                "content": "```\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        def split_expression(exp):\\n            level, sub_exp, sub_exps = 0, \\'\\', []\\n            for char in exp:\\n                if char == \\',\\' and level == 0:\\n                    sub_exps.append(sub_exp)\\n                    sub_exp = \\'\\'\\n                else:\\n                    sub_exp += char\\n                    if char == \\'(\\':\\n                        level += 1\\n                    if char == \\')\\':\\n                        level -= 1\\n            sub_exps.append(sub_exp)\\n            return sub_exps\\n                \\n        \\n        if expression == \\'t\\':\\n            return True\\n        elif expression == \\'f\\':\\n            return False\\n        elif expression[0] == \\'!\\':\\n            return not self.parseBoolExpr(expression[2:-1])\\n        elif expression[0] == \\'&\\':\\n            sub_exps = split_expression(expression[2:-1])\\n            for sub_exp in sub_exps:\\n                if not self.parseBoolExpr(sub_exp):\\n                    return False\\n            return True\\n        elif expression[0] == \\'|\\':\\n            sub_exps = split_expression(expression[2:-1])\\n            for sub_exp in sub_exps:\\n                if self.parseBoolExpr(sub_exp):\\n                    return True\\n            return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        def split_expression(exp):\\n            level, sub_exp, sub_exps = 0, \\'\\', []\\n            for char in exp:\\n                if char == \\',\\' and level == 0:\\n                    sub_exps.append(sub_exp)\\n                    sub_exp = \\'\\'\\n                else:\\n                    sub_exp += char\\n                    if char == \\'(\\':\\n                        level += 1\\n                    if char == \\')\\':\\n                        level -= 1\\n            sub_exps.append(sub_exp)\\n            return sub_exps\\n                \\n        \\n        if expression == \\'t\\':\\n            return True\\n        elif expression == \\'f\\':\\n            return False\\n        elif expression[0] == \\'!\\':\\n            return not self.parseBoolExpr(expression[2:-1])\\n        elif expression[0] == \\'&\\':\\n            sub_exps = split_expression(expression[2:-1])\\n            for sub_exp in sub_exps:\\n                if not self.parseBoolExpr(sub_exp):\\n                    return False\\n            return True\\n        elif expression[0] == \\'|\\':\\n            sub_exps = split_expression(expression[2:-1])\\n            for sub_exp in sub_exps:\\n                if self.parseBoolExpr(sub_exp):\\n                    return True\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 323400,
                "title": "concise-and-clear-java-solution-using-recursion",
                "content": "```\\n    public boolean parseBoolExpr(String expression) {\\n        return eval(expression);\\n    }\\n    \\n    private boolean eval(String expression) {\\n        if (expression.length() == 1) {\\n            return expression.equals(\"t\") ? true : false;\\n        }\\n        \\n       \\n        char mark = expression.charAt(0);\\n        List<String> list = parse(expression);        \\n         boolean res = eval(list.get(0)); \\n        \\n        if (mark == \\'!\\') {\\n            return !res;\\n        }\\n        for (int i = 1; i < list.size(); i++) {\\n            String exp = list.get(i);\\n            if (mark == \\'&\\') {\\n                res &= eval(exp);\\n            } else if (mark == \\'|\\') {\\n                res |= eval(exp);\\n            } \\n        }\\n        return res;\\n    }\\n    \\n    private List<String> parse(String expression) {\\n        List<String> res = new ArrayList<>();\\n        int start = 2, end = 2;\\n        int open = 0, close = 0;\\n        while (end < expression.length() - 1) {\\n            char c = expression.charAt(end);\\n            switch(c) {\\n                case \\'(\\':\\n                    open++;\\n                    break;\\n                case \\')\\' :\\n                    close++;\\n                    break;\\n                case \\',\\' :\\n                    if (open == close) {\\n                        res.add(expression.substring(start, end));\\n                        start = end + 1;\\n                    }\\n                    break;\\n            }\\n            end++;\\n        }\\n        res.add(expression.substring(start, end));\\n        return res;\\n    }\\n\\t",
                "solutionTags": [],
                "code": "```\\n    public boolean parseBoolExpr(String expression) {\\n        return eval(expression);\\n    }\\n    \\n    private boolean eval(String expression) {\\n        if (expression.length() == 1) {\\n            return expression.equals(\"t\") ? true : false;\\n        }\\n        \\n       \\n        char mark = expression.charAt(0);\\n        List<String> list = parse(expression);        \\n         boolean res = eval(list.get(0)); \\n        \\n        if (mark == \\'!\\') {\\n            return !res;\\n        }\\n        for (int i = 1; i < list.size(); i++) {\\n            String exp = list.get(i);\\n            if (mark == \\'&\\') {\\n                res &= eval(exp);\\n            } else if (mark == \\'|\\') {\\n                res |= eval(exp);\\n            } \\n        }\\n        return res;\\n    }\\n    \\n    private List<String> parse(String expression) {\\n        List<String> res = new ArrayList<>();\\n        int start = 2, end = 2;\\n        int open = 0, close = 0;\\n        while (end < expression.length() - 1) {\\n            char c = expression.charAt(end);\\n            switch(c) {\\n                case \\'(\\':\\n                    open++;\\n                    break;\\n                case \\')\\' :\\n                    close++;\\n                    break;\\n                case \\',\\' :\\n                    if (open == close) {\\n                        res.add(expression.substring(start, end));\\n                        start = end + 1;\\n                    }\\n                    break;\\n            }\\n            end++;\\n        }\\n        res.add(expression.substring(start, end));\\n        return res;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 323346,
                "title": "python3-clear-recursive-solution",
                "content": "\\n- similar to brace expansion II (see my previous post for this problem: [Brace Expansion II - LeetCode](https://leetcode.com/problems/brace-expansion-ii/discuss/317623/Python3-Clear-and-Short-Recursive-Solution))\\n- the point is to try removing a level of parentheses (or the top level boolean operator) in each recursive call\\n- base case: when there is no parentheses (i.e., no boolean operator) in the expression\\n- use a boolean list to store all booleans in the same level\\n- note that the boolean operator must appear at `0` index of a valid expression (if there is a boolean operator)\\n\\n```py\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        if len(expression) == 1:\\n            return expression == \\'t\\'\\n        op = expression[0]\\n        boolean_list = []\\n        level = 0\\n        start = 2\\n        for i in range(2, len(expression) - 1):\\n            ch = expression[i]\\n            if ch == \\'(\\':\\n                level += 1\\n            elif ch == \\')\\':\\n                level -= 1\\n            elif ch == \\',\\' and level == 0:\\n                boolean_list.append(self.parseBoolExpr(expression[start:i]))\\n                start = i+1\\n            elif ch not in \\'&|!\\' and level == 0:\\n                boolean_list.append(True if ch == \\'t\\' else False)\\n        boolean_list.append(self.parseBoolExpr(expression[start:-1]))\\n        if op == \\'!\\':\\n            return not boolean_list[0]\\n        elif op == \\'&\\':\\n            return all(boolean_list)\\n        else:\\n            return any(boolean_list)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```py\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        if len(expression) == 1:\\n            return expression == \\'t\\'\\n        op = expression[0]\\n        boolean_list = []\\n        level = 0\\n        start = 2\\n        for i in range(2, len(expression) - 1):\\n            ch = expression[i]\\n            if ch == \\'(\\':\\n                level += 1\\n            elif ch == \\')\\':\\n                level -= 1\\n            elif ch == \\',\\' and level == 0:\\n                boolean_list.append(self.parseBoolExpr(expression[start:i]))\\n                start = i+1\\n            elif ch not in \\'&|!\\' and level == 0:\\n                boolean_list.append(True if ch == \\'t\\' else False)\\n        boolean_list.append(self.parseBoolExpr(expression[start:-1]))\\n        if op == \\'!\\':\\n            return not boolean_list[0]\\n        elif op == \\'&\\':\\n            return all(boolean_list)\\n        else:\\n            return any(boolean_list)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 323299,
                "title": "java-on-recursion-similar-to-basic-calculator-iii",
                "content": "```\\nclass Solution {\\n    public boolean parseBoolExpr(String s) {\\n        Queue<Character> q = new LinkedList<>();\\n        for (char c : s.toCharArray()) {\\n            q.offer(c);\\n        }\\n        return cal(q).get(0);\\n    }\\n    public List<Boolean> cal(Queue<Character> q) {\\n        List<Boolean> temp = new ArrayList<>();\\n        char operator = \\'&\\';\\n        while (!q.isEmpty()) {\\n            char c = q.poll();\\n            if (c == \\'|\\' || c == \\'&\\' || c == \\'!\\') operator = c;\\n            if (c == \\'t\\') temp.add(true);\\n            if (c == \\'f\\') temp.add(false);\\n            if (c == \\')\\') return temp;\\n            if (c == \\'(\\') temp.add(helper(cal(q), operator));\\n        }\\n        return temp;\\n    }\\n    public boolean helper(List<Boolean> res, char operator) {\\n        boolean cur = res.get(0);\\n        if (operator == \\'!\\') return !cur;\\n        for (int i = 1; i < res.size(); i++) {\\n            cur = operator == \\'&\\' ? cur && res.get(i) : cur || res.get(i);\\n        }\\n        return cur;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean parseBoolExpr(String s) {\\n        Queue<Character> q = new LinkedList<>();\\n        for (char c : s.toCharArray()) {\\n            q.offer(c);\\n        }\\n        return cal(q).get(0);\\n    }\\n    public List<Boolean> cal(Queue<Character> q) {\\n        List<Boolean> temp = new ArrayList<>();\\n        char operator = \\'&\\';\\n        while (!q.isEmpty()) {\\n            char c = q.poll();\\n            if (c == \\'|\\' || c == \\'&\\' || c == \\'!\\') operator = c;\\n            if (c == \\'t\\') temp.add(true);\\n            if (c == \\'f\\') temp.add(false);\\n            if (c == \\')\\') return temp;\\n            if (c == \\'(\\') temp.add(helper(cal(q), operator));\\n        }\\n        return temp;\\n    }\\n    public boolean helper(List<Boolean> res, char operator) {\\n        boolean cur = res.get(0);\\n        if (operator == \\'!\\') return !cur;\\n        for (int i = 1; i < res.size(); i++) {\\n            cur = operator == \\'&\\' ? cur && res.get(i) : cur || res.get(i);\\n        }\\n        return cur;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4099869,
                "title": "python",
                "content": "# Code\\n```\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        stack = []\\n        e = []\\n\\n        def apply(e, operator):\\n            if operator == \\'|\\':\\n                if len(e) == 1:\\n                    return e[-1]\\n                else:\\n                    res = e[0]|e[1]\\n                    for i in range(2, len(e)):\\n                        res |= e[i]\\n                return res\\n            elif operator == \\'&\\': \\n                if len(e) == 1:\\n                    return e[-1]\\n                else:\\n                    res = e[0]&e[1]\\n                    for i in range(2, len(e)):\\n                        res &= e[i]\\n                return res\\n            \\n            else:\\n                return False if e[-1] == True else True \\n\\n       \\n        for i in range(len(expression)):\\n            if expression[i] in (\\'!\\', \"|\", \"&\", \\'(\\'):\\n                stack.append(expression[i])\\n            \\n            else:\\n                if expression[i] == \\')\\':\\n                    while stack[-1] != \\'(\\':\\n                        e.append(stack.pop())\\n\\n                    stack.pop()\\n                    print(e, stack[-1])\\n                    stack.append(apply(e, stack.pop()))\\n                    e = []\\n\\n                if (expression[i] == \\'f\\' or expression[i] == \\'t\\'):\\n                    stack.append(False if expression[i] == \\'f\\' else True)\\n\\n        return stack[-1]\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        stack = []\\n        e = []\\n\\n        def apply(e, operator):\\n            if operator == \\'|\\':\\n                if len(e) == 1:\\n                    return e[-1]\\n                else:\\n                    res = e[0]|e[1]\\n                    for i in range(2, len(e)):\\n                        res |= e[i]\\n                return res\\n            elif operator == \\'&\\': \\n                if len(e) == 1:\\n                    return e[-1]\\n                else:\\n                    res = e[0]&e[1]\\n                    for i in range(2, len(e)):\\n                        res &= e[i]\\n                return res\\n            \\n            else:\\n                return False if e[-1] == True else True \\n\\n       \\n        for i in range(len(expression)):\\n            if expression[i] in (\\'!\\', \"|\", \"&\", \\'(\\'):\\n                stack.append(expression[i])\\n            \\n            else:\\n                if expression[i] == \\')\\':\\n                    while stack[-1] != \\'(\\':\\n                        e.append(stack.pop())\\n\\n                    stack.pop()\\n                    print(e, stack[-1])\\n                    stack.append(apply(e, stack.pop()))\\n                    e = []\\n\\n                if (expression[i] == \\'f\\' or expression[i] == \\'t\\'):\\n                    stack.append(False if expression[i] == \\'f\\' else True)\\n\\n        return stack[-1]\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4098971,
                "title": "c-easy-1-stack-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string s) {\\n        stack<char>st;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\')\\'){\\n                int x=0,y=0;\\n                while(st.top()!=\\'(\\'){\\n                    if(st.top()==\\'f\\')y++;\\n                    else if(st.top()==\\'t\\')x++;\\n                    st.pop();\\n                }\\n                st.pop();\\n                if(st.top()==\\'&\\'){\\n                    st.pop();\\n                    if(y>0)st.push(\\'f\\');\\n                    else st.push(\\'t\\');\\n                    \\n                }else if(st.top()==\\'|\\'){st.pop();\\n                    if(x>0)st.push(\\'t\\');\\n                    else st.push(\\'f\\');\\n                    \\n                }else{st.pop();\\n                    if(x>0)st.push(\\'f\\');\\n                    else st.push(\\'t\\');\\n                    \\n                }\\n                \\n            }else{\\n                if(s[i]!=\\',\\');\\n            st.push(s[i]);}\\n        }\\n        if(st.top()==\\'t\\')return 1;\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string s) {\\n        stack<char>st;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\')\\'){\\n                int x=0,y=0;\\n                while(st.top()!=\\'(\\'){\\n                    if(st.top()==\\'f\\')y++;\\n                    else if(st.top()==\\'t\\')x++;\\n                    st.pop();\\n                }\\n                st.pop();\\n                if(st.top()==\\'&\\'){\\n                    st.pop();\\n                    if(y>0)st.push(\\'f\\');\\n                    else st.push(\\'t\\');\\n                    \\n                }else if(st.top()==\\'|\\'){st.pop();\\n                    if(x>0)st.push(\\'t\\');\\n                    else st.push(\\'f\\');\\n                    \\n                }else{st.pop();\\n                    if(x>0)st.push(\\'f\\');\\n                    else st.push(\\'t\\');\\n                    \\n                }\\n                \\n            }else{\\n                if(s[i]!=\\',\\');\\n            st.push(s[i]);}\\n        }\\n        if(st.top()==\\'t\\')return 1;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4097175,
                "title": "easy-to-understand-stack-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool subExpr(char logical_op,int t,int f){\\n        if(logical_op == \\'&\\'){\\n            if(f) return false;\\n            else return true;\\n        }\\n        if(logical_op == \\'|\\'){\\n            if(t) return true;\\n            return false;\\n        }\\n        else{\\n            if(t) return false;\\n            return true;\\n        }\\n    }\\n\\n    bool parseBoolExpr(string expression) {\\n        stack<char>s;\\n\\n        int n = expression.length();\\n\\n        for(int i = 0;i<n;i++){\\n            if(expression[i] == \\',\\') continue;\\n\\n            if(expression[i] == \\')\\'){\\n                int f = 0;int t = 0;\\n                while(s.top() == \\'f\\' || s.top() == \\'t\\' || s.top() == \\'(\\'){\\n                    if(s.top() == \\'f\\') f++;\\n                    if(s.top() == \\'t\\') t++;\\n                    s.pop();\\n                }\\n                bool k = subExpr(s.top(),t,f);\\n                s.pop();\\n\\n                if(k) s.push(\\'t\\');\\n                else s.push(\\'f\\');\\n            }else{\\n                s.push(expression[i]);\\n            }\\n        }\\n\\n        if(s.top() == \\'f\\') return false;\\n        else return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool subExpr(char logical_op,int t,int f){\\n        if(logical_op == \\'&\\'){\\n            if(f) return false;\\n            else return true;\\n        }\\n        if(logical_op == \\'|\\'){\\n            if(t) return true;\\n            return false;\\n        }\\n        else{\\n            if(t) return false;\\n            return true;\\n        }\\n    }\\n\\n    bool parseBoolExpr(string expression) {\\n        stack<char>s;\\n\\n        int n = expression.length();\\n\\n        for(int i = 0;i<n;i++){\\n            if(expression[i] == \\',\\') continue;\\n\\n            if(expression[i] == \\')\\'){\\n                int f = 0;int t = 0;\\n                while(s.top() == \\'f\\' || s.top() == \\'t\\' || s.top() == \\'(\\'){\\n                    if(s.top() == \\'f\\') f++;\\n                    if(s.top() == \\'t\\') t++;\\n                    s.pop();\\n                }\\n                bool k = subExpr(s.top(),t,f);\\n                s.pop();\\n\\n                if(k) s.push(\\'t\\');\\n                else s.push(\\'f\\');\\n            }else{\\n                s.push(expression[i]);\\n            }\\n        }\\n\\n        if(s.top() == \\'f\\') return false;\\n        else return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4096853,
                "title": "c-readable-recursive-string-parsing-92-time-and-memory",
                "content": "# Intuition\\nAlthough this problem requires careful implementation and a thorough test case to start with, this problem can be broken down into 3 cases of AND, OR and NOT.\\n\\n# Approach\\nRecursively parse inner expressions and apply the parent operator to them.\\nStop parsing an inner expression as soon as the stopper bool value is found. E.g.: once we found false, it doesn\\'t make sense to eval \\'&\\' anymore, it\\'s always going to result in false.\\n\\n# Complexity\\n- Time complexity:\\nO(n) - one pass of the input string.\\n\\n- Space complexity:\\nO(n) for recursion callstack.\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool ParseBoolExpr(string expression) {\\n        if (expression.Length == 1)\\n            return expression == \"t\";\\n        \\n        char oper = expression[0];\\n        int end = 0;\\n        return Eval(expression, oper, 2, ref end);\\n    }\\n\\n    private bool Eval(string expr, char oper, int start, ref int end)\\n    {\\n        if (oper == \\'&\\')\\n        {\\n            return EvalAndOr(expr, start, isAnd: true, ref end);\\n        }\\n        else if (oper == \\'|\\')\\n        {\\n            return EvalAndOr(expr, start, isAnd: false, ref end);\\n        }\\n        else if (oper == \\'!\\')\\n        {\\n            char newOp = expr[start];\\n            if (IsOperator(newOp))\\n            {\\n                return !Eval(expr, newOp, start + 2, ref end);\\n            }\\n            \\n            end = start + 1;\\n            return newOp == \\'f\\';\\n        }\\n\\n        throw new Exception(\"Impossible\");\\n    }\\n\\n    // if isAnd == false, then this is for \\'|\\' operator.\\n    // for \\'&\\', any false operator will stop eval immediately, returning false.\\n    // for \\'|\\' it\\'s any true.\\n    private bool EvalAndOr(string expr, int start, bool isAnd, ref int end)\\n    {\\n        // for better readability.\\n        char stopper = isAnd ? \\'f\\' : \\'t\\';\\n        char insignificant = isAnd ? \\'t\\' : \\'f\\';\\n        bool stopperBool = isAnd ? false : true;\\n        for (var i = start; i < expr.Length; i++)\\n        {\\n            if (expr[i] == stopper)\\n            {\\n                end = LookAheadFor(expr, i + 1, \\')\\', \\'(\\') + 1;\\n                return stopperBool;\\n            }\\n            else if (expr[i] == insignificant || expr[i] == \\',\\')\\n                continue;\\n            \\n            char newOp = expr[i];\\n            if (IsOperator(newOp))\\n            {\\n                bool innerVal = Eval(expr, newOp, i + 2, ref end);\\n                if (innerVal == stopperBool)\\n                    return stopperBool;\\n                \\n                i = end;\\n            }\\n        }\\n\\n        return isAnd;\\n    }\\n\\n    private int LookAheadFor(string expr, int start, char target, char counterPart)\\n    {\\n        // opened already.\\n        int count = 1;\\n        for (int i = start; i < expr.Length; i++)\\n        {\\n            if (expr[i] == target)\\n            {\\n                if (--count == 0)\\n                    return i;\\n            } else if (expr[i] == counterPart)\\n                count++;\\n        }\\n\\n        return int.MinValue;\\n    }\\n\\n    private bool IsOperator(char c)\\n    {\\n        return c == \\'&\\' || c == \\'|\\' || c == \\'!\\';\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool ParseBoolExpr(string expression) {\\n        if (expression.Length == 1)\\n            return expression == \"t\";\\n        \\n        char oper = expression[0];\\n        int end = 0;\\n        return Eval(expression, oper, 2, ref end);\\n    }\\n\\n    private bool Eval(string expr, char oper, int start, ref int end)\\n    {\\n        if (oper == \\'&\\')\\n        {\\n            return EvalAndOr(expr, start, isAnd: true, ref end);\\n        }\\n        else if (oper == \\'|\\')\\n        {\\n            return EvalAndOr(expr, start, isAnd: false, ref end);\\n        }\\n        else if (oper == \\'!\\')\\n        {\\n            char newOp = expr[start];\\n            if (IsOperator(newOp))\\n            {\\n                return !Eval(expr, newOp, start + 2, ref end);\\n            }\\n            \\n            end = start + 1;\\n            return newOp == \\'f\\';\\n        }\\n\\n        throw new Exception(\"Impossible\");\\n    }\\n\\n    // if isAnd == false, then this is for \\'|\\' operator.\\n    // for \\'&\\', any false operator will stop eval immediately, returning false.\\n    // for \\'|\\' it\\'s any true.\\n    private bool EvalAndOr(string expr, int start, bool isAnd, ref int end)\\n    {\\n        // for better readability.\\n        char stopper = isAnd ? \\'f\\' : \\'t\\';\\n        char insignificant = isAnd ? \\'t\\' : \\'f\\';\\n        bool stopperBool = isAnd ? false : true;\\n        for (var i = start; i < expr.Length; i++)\\n        {\\n            if (expr[i] == stopper)\\n            {\\n                end = LookAheadFor(expr, i + 1, \\')\\', \\'(\\') + 1;\\n                return stopperBool;\\n            }\\n            else if (expr[i] == insignificant || expr[i] == \\',\\')\\n                continue;\\n            \\n            char newOp = expr[i];\\n            if (IsOperator(newOp))\\n            {\\n                bool innerVal = Eval(expr, newOp, i + 2, ref end);\\n                if (innerVal == stopperBool)\\n                    return stopperBool;\\n                \\n                i = end;\\n            }\\n        }\\n\\n        return isAnd;\\n    }\\n\\n    private int LookAheadFor(string expr, int start, char target, char counterPart)\\n    {\\n        // opened already.\\n        int count = 1;\\n        for (int i = start; i < expr.Length; i++)\\n        {\\n            if (expr[i] == target)\\n            {\\n                if (--count == 0)\\n                    return i;\\n            } else if (expr[i] == counterPart)\\n                count++;\\n        }\\n\\n        return int.MinValue;\\n    }\\n\\n    private bool IsOperator(char c)\\n    {\\n        return c == \\'&\\' || c == \\'|\\' || c == \\'!\\';\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086969,
                "title": "simple-stack-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        Stack<Character> stack =new Stack<>();\\n\\n        for(int i=0;i<expression.length();i++){\\n             char ch = expression.charAt(i);\\n             if(ch==\\',\\')continue;\\n\\n             if(ch!=\\')\\'){\\n                 stack.push(ch);\\n                 continue;\\n             }\\n             int t =0;\\n             int f=0;\\n             while(stack.peek()!=\\'(\\'){\\n                 char a = stack.pop();\\n                 if(a==\\'t\\')t++;\\n                 if(a==\\'f\\')f++;\\n             }\\n             stack.pop();\\n             if(stack.peek() ==\\'&\\'){\\n                 stack.pop();\\n                if(f>0){\\n                stack.push(\\'f\\');\\n                }               \\n                else{\\n                    stack.push(\\'t\\');\\n                } \\n             }\\n             else if(stack.peek()==\\'|\\'){\\n                 stack.pop();\\n                 if(t>0){\\n                   stack.push(\\'t\\');\\n                 }\\n                 else{\\n                     stack.push(\\'f\\');\\n                 }\\n                \\n             }\\n             else{\\n                stack.pop();\\n                if(t==1){\\n                    stack.push(\\'f\\');\\n                }\\n                else{\\n                    stack.push(\\'t\\');\\n                }\\n             }\\n        }  \\n         return stack.peek()==\\'t\\';  \\n    }\\n   \\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        Stack<Character> stack =new Stack<>();\\n\\n        for(int i=0;i<expression.length();i++){\\n             char ch = expression.charAt(i);\\n             if(ch==\\',\\')continue;\\n\\n             if(ch!=\\')\\'){\\n                 stack.push(ch);\\n                 continue;\\n             }\\n             int t =0;\\n             int f=0;\\n             while(stack.peek()!=\\'(\\'){\\n                 char a = stack.pop();\\n                 if(a==\\'t\\')t++;\\n                 if(a==\\'f\\')f++;\\n             }\\n             stack.pop();\\n             if(stack.peek() ==\\'&\\'){\\n                 stack.pop();\\n                if(f>0){\\n                stack.push(\\'f\\');\\n                }               \\n                else{\\n                    stack.push(\\'t\\');\\n                } \\n             }\\n             else if(stack.peek()==\\'|\\'){\\n                 stack.pop();\\n                 if(t>0){\\n                   stack.push(\\'t\\');\\n                 }\\n                 else{\\n                     stack.push(\\'f\\');\\n                 }\\n                \\n             }\\n             else{\\n                stack.pop();\\n                if(t==1){\\n                    stack.push(\\'f\\');\\n                }\\n                else{\\n                    stack.push(\\'t\\');\\n                }\\n             }\\n        }  \\n         return stack.peek()==\\'t\\';  \\n    }\\n   \\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4060602,
                "title": "c-o-n-clean-code-one-operator-one-function",
                "content": "# Intuition\\nOne operator, one function\\n\\n# Approach\\nRecursion\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)(without stack usage)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n        int i = 0;\\n        return solve(expression, i);\\n    }\\n\\n    bool solve(string& expression, int& index) {\\n        switch (expression[index]) {\\n        case \\'!\\':\\n            return solveNotExpr(expression, index);\\n        case \\'&\\':\\n            return solveAndExpr(expression, index);\\n        case \\'|\\':\\n            return solveOrExpr(expression, index);\\n        }\\n        return solveLetter(expression, index);\\n    }\\n\\n    bool solveAndExpr(string& expression, int& index) {\\n        index += 2;\\n        bool res = true;\\n        while (expression[index] != \\')\\') {\\n            if (expression[index] == \\',\\') {\\n                index++;\\n            } else {\\n                bool r = solve(expression, index);\\n                res &= r;\\n            }\\n        }\\n        index++;\\n        return res;\\n    }\\n\\n    bool solveOrExpr(string& expression, int& index) {\\n        index += 2;\\n        bool res = false;\\n        while (expression[index] != \\')\\') {\\n            if (expression[index] == \\',\\') {\\n                index++;\\n            } else {\\n                bool r = solve(expression, index);\\n                res |= r;\\n            }\\n        }\\n        index++;\\n        return res;\\n    }\\n\\n    bool solveNotExpr(string& expression, int& index) {\\n        index += 2;\\n        bool r = solve(expression, index);\\n        index++;\\n        return !r;\\n    }\\n\\n    bool solveLetter(string& expression, int& index) {\\n        char c = expression[index];\\n        index++;\\n        if (c == \\'t\\')\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n        int i = 0;\\n        return solve(expression, i);\\n    }\\n\\n    bool solve(string& expression, int& index) {\\n        switch (expression[index]) {\\n        case \\'!\\':\\n            return solveNotExpr(expression, index);\\n        case \\'&\\':\\n            return solveAndExpr(expression, index);\\n        case \\'|\\':\\n            return solveOrExpr(expression, index);\\n        }\\n        return solveLetter(expression, index);\\n    }\\n\\n    bool solveAndExpr(string& expression, int& index) {\\n        index += 2;\\n        bool res = true;\\n        while (expression[index] != \\')\\') {\\n            if (expression[index] == \\',\\') {\\n                index++;\\n            } else {\\n                bool r = solve(expression, index);\\n                res &= r;\\n            }\\n        }\\n        index++;\\n        return res;\\n    }\\n\\n    bool solveOrExpr(string& expression, int& index) {\\n        index += 2;\\n        bool res = false;\\n        while (expression[index] != \\')\\') {\\n            if (expression[index] == \\',\\') {\\n                index++;\\n            } else {\\n                bool r = solve(expression, index);\\n                res |= r;\\n            }\\n        }\\n        index++;\\n        return res;\\n    }\\n\\n    bool solveNotExpr(string& expression, int& index) {\\n        index += 2;\\n        bool r = solve(expression, index);\\n        index++;\\n        return !r;\\n    }\\n\\n    bool solveLetter(string& expression, int& index) {\\n        char c = expression[index];\\n        index++;\\n        if (c == \\'t\\')\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043509,
                "title": "typescript-best-solution-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction parseBoolExpr(expression: string): boolean {\\n\\nlet stack = [];\\n\\nfor(let i=0; i<expression.length;i++)\\n{\\n\\n   if(expression[i]!=\")\" && expression[i]!=\",\" )\\n   {\\n      stack.push(expression[i]);\\n   }\\n   else if(expression[i]==\")\")\\n   {\\n     evaluate(stack)\\n   }\\n\\n}\\n\\nif(stack[0] == \\'t\\')\\n{\\nreturn true;\\n}\\n\\nreturn false;\\n\\n};\\n\\nfunction evaluate(stack:string[])\\n{\\n\\n     let operands = [];\\n     let top = stack.pop()\\n     \\n     if(top == \\'t\\' || top == \"f\")\\n     {\\n         operands.push(top);\\n     }\\n\\n     while(top != \"(\")\\n     {\\n        top = stack.pop()\\n     \\n        if(top == \\'t\\' || top == \"f\")\\n        {\\n         operands.push(top);\\n        }\\n\\n     }\\n\\n     let operator = stack.pop();\\n         //Evaluate\\n\\n     let true_count = 0;\\n     let false_count=0;\\n\\n     for(let i=0; i < operands.length; i++)\\n     {\\n         if(operands[i]==\"t\")\\n         {\\n             true_count++;\\n         }\\n         else\\n         {\\n            false_count++;\\n         }\\n     }\\n\\n     if(operator== \"|\")\\n     {\\n         if(true_count > 0)\\n         {\\n             stack.push(\\'t\\');\\n         }\\n         else\\n         {\\n             stack.push(\\'f\\');\\n         }\\n     }\\n     else if(operator== \"&\")\\n     {\\n         if(false_count > 0)\\n         {\\n             stack.push(\\'f\\');\\n         }\\n         else\\n         {\\n             stack.push(\\'t\\');\\n         }\\n     }\\n     else if(operator== \"!\")\\n     {\\n         if(true_count == 0)\\n         {\\n             stack.push(\\'t\\');\\n         }\\n         else\\n         {\\n              stack.push(\\'f\\');\\n         }\\n     }\\n\\n}\\n\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction parseBoolExpr(expression: string): boolean {\\n\\nlet stack = [];\\n\\nfor(let i=0; i<expression.length;i++)\\n{\\n\\n   if(expression[i]!=\")\" && expression[i]!=\",\" )\\n   {\\n      stack.push(expression[i]);\\n   }\\n   else if(expression[i]==\")\")\\n   {\\n     evaluate(stack)\\n   }\\n\\n}\\n\\nif(stack[0] == \\'t\\')\\n{\\nreturn true;\\n}\\n\\nreturn false;\\n\\n};\\n\\nfunction evaluate(stack:string[])\\n{\\n\\n     let operands = [];\\n     let top = stack.pop()\\n     \\n     if(top == \\'t\\' || top == \"f\")\\n     {\\n         operands.push(top);\\n     }\\n\\n     while(top != \"(\")\\n     {\\n        top = stack.pop()\\n     \\n        if(top == \\'t\\' || top == \"f\")\\n        {\\n         operands.push(top);\\n        }\\n\\n     }\\n\\n     let operator = stack.pop();\\n         //Evaluate\\n\\n     let true_count = 0;\\n     let false_count=0;\\n\\n     for(let i=0; i < operands.length; i++)\\n     {\\n         if(operands[i]==\"t\")\\n         {\\n             true_count++;\\n         }\\n         else\\n         {\\n            false_count++;\\n         }\\n     }\\n\\n     if(operator== \"|\")\\n     {\\n         if(true_count > 0)\\n         {\\n             stack.push(\\'t\\');\\n         }\\n         else\\n         {\\n             stack.push(\\'f\\');\\n         }\\n     }\\n     else if(operator== \"&\")\\n     {\\n         if(false_count > 0)\\n         {\\n             stack.push(\\'f\\');\\n         }\\n         else\\n         {\\n             stack.push(\\'t\\');\\n         }\\n     }\\n     else if(operator== \"!\")\\n     {\\n         if(true_count == 0)\\n         {\\n             stack.push(\\'t\\');\\n         }\\n         else\\n         {\\n              stack.push(\\'f\\');\\n         }\\n     }\\n\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4039851,
                "title": "easy-to-understand-solution-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n        stack<char> st;\\n\\n        for (int i = 0; i < expression.size(); i++) {\\n            int countt = 0;\\n            int countf = 0;\\n            if (expression[i] == \\',\\') \\n                continue;\\n\\n            if (expression[i] == \\')\\') {\\n                while (st.top() == \\'t\\' || st.top() == \\'f\\') {\\n                    if (st.top() == \\'t\\') {\\n                        countt++;\\n                    }\\n                    else {\\n                        countf++;\\n                    }\\n                    st.pop();\\n                }\\n                st.pop();\\n                if (st.top() == \\'|\\') {\\n                    st.pop();\\n                    if (countt)\\n                        st.push(\\'t\\');\\n                    else\\n                        st.push(\\'f\\');\\n                }\\n                else if (st.top() == \\'!\\') {\\n                    st.pop();\\n                    if (countt)\\n                        st.push(\\'f\\');\\n                    else\\n                        st.push(\\'t\\');\\n                }\\n                else {\\n                    st.pop();\\n                    if (countf)\\n                        st.push(\\'f\\');\\n                    else\\n                        st.push(\\'t\\');\\n                }\\n            }\\n            else\\n                st.push(expression[i]);\\n        }\\n\\n        return st.top() == \\'t\\';\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n        stack<char> st;\\n\\n        for (int i = 0; i < expression.size(); i++) {\\n            int countt = 0;\\n            int countf = 0;\\n            if (expression[i] == \\',\\') \\n                continue;\\n\\n            if (expression[i] == \\')\\') {\\n                while (st.top() == \\'t\\' || st.top() == \\'f\\') {\\n                    if (st.top() == \\'t\\') {\\n                        countt++;\\n                    }\\n                    else {\\n                        countf++;\\n                    }\\n                    st.pop();\\n                }\\n                st.pop();\\n                if (st.top() == \\'|\\') {\\n                    st.pop();\\n                    if (countt)\\n                        st.push(\\'t\\');\\n                    else\\n                        st.push(\\'f\\');\\n                }\\n                else if (st.top() == \\'!\\') {\\n                    st.pop();\\n                    if (countt)\\n                        st.push(\\'f\\');\\n                    else\\n                        st.push(\\'t\\');\\n                }\\n                else {\\n                    st.pop();\\n                    if (countf)\\n                        st.push(\\'f\\');\\n                    else\\n                        st.push(\\'t\\');\\n                }\\n            }\\n            else\\n                st.push(expression[i]);\\n        }\\n\\n        return st.top() == \\'t\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4030978,
                "title": "c-solution-easy-to-understand-using-stack",
                "content": "# Intuition\\nit is just like the problem valid paranthesis which is easy version of this ques.\\nYou can just think about solving each () baracket than you wil be come to know that this can be done by using stack.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe have to solve each baracket and again push the result to the stack as it may also be part of another previous bracket.\\n\\nexample\\n&(!(f)|(ftf));\\ninitially i will push all the char to stack till i encounter \\')\\'.\\nwhen i get ) then i will pop all the char from stack till first open baracket( and count f and t, now i will check the sign\\n\\n                char sn=s.top(); // sign \\n                s.pop();  //poping the sign\\n                if(sn==\\'|\\'){\\n                    if(t)s.push(\\'t\\');  // if ther is any true then push true in stack similarly for all;\\n                    else s.push(\\'f\\');\\n                }\\n                else if(sn==\\'&\\'){\\n                    if(f==0)s.push(\\'t\\');\\n                    else s.push(\\'f\\');\\n                }\\n                else if(sn==\\'!\\'){\\n                    if(f)s.push(\\'t\\');\\n                    else s.push(\\'f\\');\\n                }\\n\\n# Complexity\\n- Time complexity:\\n- O(n);\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n) as one stack is required.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string a) {\\n        stack<char> s;\\n        int n=a.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(a[i]!=\\')\\')s.push(a[i]);\\n            else {\\n                int t=0,f=0;\\n                while(s.empty() || s.top()!=\\'(\\'){\\n                    char cur=s.top();s.pop();\\n                    if(cur==\\'t\\')t++;\\n                    else if(cur==\\'f\\') f++;\\n                }\\n                s.pop();\\n                char sn=s.top();\\n                s.pop();\\n                if(sn==\\'|\\'){\\n                    if(t)s.push(\\'t\\');\\n                    else s.push(\\'f\\');\\n                }\\n                else if(sn==\\'&\\'){\\n                    if(f==0)s.push(\\'t\\');\\n                    else s.push(\\'f\\');\\n                }\\n                else if(sn==\\'!\\'){\\n                    if(f)s.push(\\'t\\');\\n                    else s.push(\\'f\\');\\n                }\\n            }\\n        }\\n        return s.top()==\\'t\\';\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string a) {\\n        stack<char> s;\\n        int n=a.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(a[i]!=\\')\\')s.push(a[i]);\\n            else {\\n                int t=0,f=0;\\n                while(s.empty() || s.top()!=\\'(\\'){\\n                    char cur=s.top();s.pop();\\n                    if(cur==\\'t\\')t++;\\n                    else if(cur==\\'f\\') f++;\\n                }\\n                s.pop();\\n                char sn=s.top();\\n                s.pop();\\n                if(sn==\\'|\\'){\\n                    if(t)s.push(\\'t\\');\\n                    else s.push(\\'f\\');\\n                }\\n                else if(sn==\\'&\\'){\\n                    if(f==0)s.push(\\'t\\');\\n                    else s.push(\\'f\\');\\n                }\\n                else if(sn==\\'!\\'){\\n                    if(f)s.push(\\'t\\');\\n                    else s.push(\\'f\\');\\n                }\\n            }\\n        }\\n        return s.top()==\\'t\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023175,
                "title": "c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n        stack<char> st;\\n        int t,f;\\n        for(auto i:expression){\\n            if(i==\\')\\'){\\n                t=0;\\n                f=0;\\n                while(st.top()!=\\'(\\' ){ \\n                    if(st.top()==\\'t\\') t++;\\n                    if(st.top()==\\'f\\') f++;\\n                    st.pop();\\n                    }\\n                st.pop();\\n                if(st.top()==\\'&\\'){\\n                    st.pop();\\n                    if(f==0) st.push(\\'t\\');\\n                    else st.push(\\'f\\');\\n                }\\n                else if(st.top()==\\'|\\'){\\n                    st.pop();\\n                    if(t==0) st.push(\\'f\\');\\n                    else st.push(\\'t\\');\\n                }\\n                else if(st.top()==\\'!\\'){\\n                    st.pop();\\n                    if(f==1) st.push(\\'t\\');\\n                    else st.push(\\'f\\');\\n                }\\n\\n            }\\n            else{\\n                if(i!=\\',\\') st.push(i);\\n            }\\n        }\\n        return st.top() == \\'t\\';\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n        stack<char> st;\\n        int t,f;\\n        for(auto i:expression){\\n            if(i==\\')\\'){\\n                t=0;\\n                f=0;\\n                while(st.top()!=\\'(\\' ){ \\n                    if(st.top()==\\'t\\') t++;\\n                    if(st.top()==\\'f\\') f++;\\n                    st.pop();\\n                    }\\n                st.pop();\\n                if(st.top()==\\'&\\'){\\n                    st.pop();\\n                    if(f==0) st.push(\\'t\\');\\n                    else st.push(\\'f\\');\\n                }\\n                else if(st.top()==\\'|\\'){\\n                    st.pop();\\n                    if(t==0) st.push(\\'f\\');\\n                    else st.push(\\'t\\');\\n                }\\n                else if(st.top()==\\'!\\'){\\n                    st.pop();\\n                    if(f==1) st.push(\\'t\\');\\n                    else st.push(\\'f\\');\\n                }\\n\\n            }\\n            else{\\n                if(i!=\\',\\') st.push(i);\\n            }\\n        }\\n        return st.top() == \\'t\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4021600,
                "title": "c-solution-o-n-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$ O(n) $$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool ParseBoolExpr(string expression) {\\n        Stack<char> stack = new();\\n        int j=expression.Length-1;\\n\\n        while(j >= 0){\\n            while(j >= 0 && (expression[j] == \\')\\' || expression[j] == \\',\\')){\\n                if(expression[j] == \\')\\'){\\n                    stack.Push(expression[j]);\\n                }\\n\\n                j--;\\n            }\\n\\n            while(j >= 0 && expression[j] != \\'(\\'){\\n                if(expression[j] != \\',\\'){\\n                    stack.Push(expression[j]);\\n                }\\n\\n                j--;\\n            }\\n\\n            if(expression[j] == \\'(\\'){\\n                j--;\\n            }\\n\\n            var op = expression[j--];\\n\\n            // Console.WriteLine($\"Before: stack.Count={stack.Count}, op={op}\");\\n\\n            if(op == \\'|\\' || op == \\'&\\'){\\n                bool tFound = false, fFound=false;\\n\\n                while(stack.Peek() != \\')\\'){\\n                    // Console.WriteLine($\"stack.Peek() = {stack.Peek()}, stack.Count={stack.Count}\");\\n                    tFound = tFound || stack.Peek() == \\'t\\';\\n                    fFound = stack.Pop() == \\'f\\' || fFound;\\n                }\\n\\n                stack.Pop();\\n                if(op == \\'|\\'){\\n                    stack.Push(tFound ? \\'t\\' : \\'f\\');\\n                }\\n                else if(op == \\'&\\'){\\n                    stack.Push(fFound ? \\'f\\' : \\'t\\');\\n                }\\n            }\\n            else{\\n                var top = stack.Pop();\\n                stack.Pop();\\n                stack.Push(top == \\'t\\' ? \\'f\\' : \\'t\\');\\n            }\\n\\n            // Console.WriteLine($\"stack.Count = {stack.Count}\");\\n        }\\n        \\n        return stack.Pop() == \\'t\\' ? true : false;\\n    }\\n}\\n\\n/*\\n\\n\\n\"|(f,f,f,t)\"\\n\"!(&(f,t))\"\\n\"!(&(!(t),&(f),|(f)))\"\\n\\n*/\\n```",
                "solutionTags": [
                    "C#",
                    "String",
                    "Stack"
                ],
                "code": "```\\npublic class Solution {\\n    public bool ParseBoolExpr(string expression) {\\n        Stack<char> stack = new();\\n        int j=expression.Length-1;\\n\\n        while(j >= 0){\\n            while(j >= 0 && (expression[j] == \\')\\' || expression[j] == \\',\\')){\\n                if(expression[j] == \\')\\'){\\n                    stack.Push(expression[j]);\\n                }\\n\\n                j--;\\n            }\\n\\n            while(j >= 0 && expression[j] != \\'(\\'){\\n                if(expression[j] != \\',\\'){\\n                    stack.Push(expression[j]);\\n                }\\n\\n                j--;\\n            }\\n\\n            if(expression[j] == \\'(\\'){\\n                j--;\\n            }\\n\\n            var op = expression[j--];\\n\\n            // Console.WriteLine($\"Before: stack.Count={stack.Count}, op={op}\");\\n\\n            if(op == \\'|\\' || op == \\'&\\'){\\n                bool tFound = false, fFound=false;\\n\\n                while(stack.Peek() != \\')\\'){\\n                    // Console.WriteLine($\"stack.Peek() = {stack.Peek()}, stack.Count={stack.Count}\");\\n                    tFound = tFound || stack.Peek() == \\'t\\';\\n                    fFound = stack.Pop() == \\'f\\' || fFound;\\n                }\\n\\n                stack.Pop();\\n                if(op == \\'|\\'){\\n                    stack.Push(tFound ? \\'t\\' : \\'f\\');\\n                }\\n                else if(op == \\'&\\'){\\n                    stack.Push(fFound ? \\'f\\' : \\'t\\');\\n                }\\n            }\\n            else{\\n                var top = stack.Pop();\\n                stack.Pop();\\n                stack.Push(top == \\'t\\' ? \\'f\\' : \\'t\\');\\n            }\\n\\n            // Console.WriteLine($\"stack.Count = {stack.Count}\");\\n        }\\n        \\n        return stack.Pop() == \\'t\\' ? true : false;\\n    }\\n}\\n\\n/*\\n\\n\\n\"|(f,f,f,t)\"\\n\"!(&(f,t))\"\\n\"!(&(!(t),&(f),|(f)))\"\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016282,
                "title": "stack-implementation-easy-to-follow",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool ParseBoolExpr(string expression) { \\n        Stack<char> stkSymbol = new Stack<char>();\\n        Stack<char> stkChar = new Stack<char>();\\n        char AND = \\'&\\', OR = \\'|\\', NOT = \\'!\\', CLOSE = \\')\\', TRUE = \\'t\\', FALSE = \\'f\\', OPEN = \\'(\\';\\n\\n        HashSet<char> hsSymbol = new HashSet<char>(){\\'&\\', \\'|\\', \\'!\\'};\\n        HashSet<char> hsChar = new HashSet<char>(){\\'(\\', \\'t\\', \\'f\\'};\\n\\n        foreach(char c in expression){\\n            if(hsSymbol.Contains(c)){\\n                stkSymbol.Push(c);\\n                continue;\\n            }\\n\\n            if(hsChar.Contains(c)){\\n                stkChar.Push(c);\\n                continue;\\n            }\\n\\n            if(c == CLOSE){\\n                char symbolToBeApplied = stkSymbol.Pop();\\n                char fetchedElement = stkChar.Pop();\\n                bool computedResult = fetchedElement == TRUE? true : false;\\n\\n                if(symbolToBeApplied == NOT)\\n                    computedResult = !computedResult;\\n\\n                while(stkChar.Peek() != OPEN){\\n                    fetchedElement = stkChar.Pop();\\n                    bool tempComputedResult = fetchedElement == TRUE? true : false;\\n\\n                    if(symbolToBeApplied == AND)\\n                        computedResult &= tempComputedResult;\\n                    else if(symbolToBeApplied == OR)\\n                        computedResult |= tempComputedResult;\\n                }\\n\\n                stkChar.Pop();\\n                char charComputedResult = computedResult ? TRUE : FALSE;\\n                stkChar.Push(charComputedResult);\\n            }\\n        }\\n\\n        return stkChar.Peek() == TRUE? true : false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "String",
                    "Stack"
                ],
                "code": "```\\npublic class Solution {\\n    public bool ParseBoolExpr(string expression) { \\n        Stack<char> stkSymbol = new Stack<char>();\\n        Stack<char> stkChar = new Stack<char>();\\n        char AND = \\'&\\', OR = \\'|\\', NOT = \\'!\\', CLOSE = \\')\\', TRUE = \\'t\\', FALSE = \\'f\\', OPEN = \\'(\\';\\n\\n        HashSet<char> hsSymbol = new HashSet<char>(){\\'&\\', \\'|\\', \\'!\\'};\\n        HashSet<char> hsChar = new HashSet<char>(){\\'(\\', \\'t\\', \\'f\\'};\\n\\n        foreach(char c in expression){\\n            if(hsSymbol.Contains(c)){\\n                stkSymbol.Push(c);\\n                continue;\\n            }\\n\\n            if(hsChar.Contains(c)){\\n                stkChar.Push(c);\\n                continue;\\n            }\\n\\n            if(c == CLOSE){\\n                char symbolToBeApplied = stkSymbol.Pop();\\n                char fetchedElement = stkChar.Pop();\\n                bool computedResult = fetchedElement == TRUE? true : false;\\n\\n                if(symbolToBeApplied == NOT)\\n                    computedResult = !computedResult;\\n\\n                while(stkChar.Peek() != OPEN){\\n                    fetchedElement = stkChar.Pop();\\n                    bool tempComputedResult = fetchedElement == TRUE? true : false;\\n\\n                    if(symbolToBeApplied == AND)\\n                        computedResult &= tempComputedResult;\\n                    else if(symbolToBeApplied == OR)\\n                        computedResult |= tempComputedResult;\\n                }\\n\\n                stkChar.Pop();\\n                char charComputedResult = computedResult ? TRUE : FALSE;\\n                stkChar.Push(charComputedResult);\\n            }\\n        }\\n\\n        return stkChar.Peek() == TRUE? true : false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4007978,
                "title": "java-solution-with-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    Stack<Character> stk = new Stack();\\n    public boolean parseBoolExpr(String expression) {\\n        for (int i = 0; i < expression.length(); i++) {\\n            char c = expression.charAt(i);\\n            if (c == \\',\\') continue;\\n            if (c == \\')\\') {\\n                List<Boolean> operandList = new ArrayList();\\n                while (true) {\\n                    char popped = (char) stk.pop();\\n                    if (popped == \\'t\\') operandList.add(true);\\n                    else if (popped == \\'f\\') operandList.add(false);\\n                    else if (popped == \\'(\\') break;\\n                }\\n                char operator = stk.pop();\\n                stk.push(evaluate(operator, operandList));\\n            } else {\\n                stk.push(c);\\n            }\\n        }\\n        char remaining = stk.pop();\\n        if (remaining == \\'t\\') return true;\\n        return false;\\n    }\\n\\n    private char evaluate(char operator, List<Boolean> operandList) {\\n        if (operator == \\'!\\') {\\n            if (operandList.get(0)) return \\'f\\';\\n            return \\'t\\';\\n        }\\n\\n        boolean ret = false;\\n        if (operandList.get(0)) ret = true;\\n        for (int i = 1; i < operandList.size(); i++) {\\n            if (operator == \\'&\\') {\\n                ret = ret && operandList.get(i);\\n            } else if (operator == \\'|\\') {\\n                ret = ret || operandList.get(i);\\n            }\\n        } \\n        if (ret) return \\'t\\';\\n        return \\'f\\';\\n    }\\n}\\n\\n/*\\nuse a stack\\nwhenever you see a close bracket we will pop the stack up to the last open bracket\\n*/\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    Stack<Character> stk = new Stack();\\n    public boolean parseBoolExpr(String expression) {\\n        for (int i = 0; i < expression.length(); i++) {\\n            char c = expression.charAt(i);\\n            if (c == \\',\\') continue;\\n            if (c == \\')\\') {\\n                List<Boolean> operandList = new ArrayList();\\n                while (true) {\\n                    char popped = (char) stk.pop();\\n                    if (popped == \\'t\\') operandList.add(true);\\n                    else if (popped == \\'f\\') operandList.add(false);\\n                    else if (popped == \\'(\\') break;\\n                }\\n                char operator = stk.pop();\\n                stk.push(evaluate(operator, operandList));\\n            } else {\\n                stk.push(c);\\n            }\\n        }\\n        char remaining = stk.pop();\\n        if (remaining == \\'t\\') return true;\\n        return false;\\n    }\\n\\n    private char evaluate(char operator, List<Boolean> operandList) {\\n        if (operator == \\'!\\') {\\n            if (operandList.get(0)) return \\'f\\';\\n            return \\'t\\';\\n        }\\n\\n        boolean ret = false;\\n        if (operandList.get(0)) ret = true;\\n        for (int i = 1; i < operandList.size(); i++) {\\n            if (operator == \\'&\\') {\\n                ret = ret && operandList.get(i);\\n            } else if (operator == \\'|\\') {\\n                ret = ret || operandList.get(i);\\n            }\\n        } \\n        if (ret) return \\'t\\';\\n        return \\'f\\';\\n    }\\n}\\n\\n/*\\nuse a stack\\nwhenever you see a close bracket we will pop the stack up to the last open bracket\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966074,
                "title": "using-stack-easy-intuitive-approach",
                "content": "# Intuition\\nJust treat it like valid parenthesis question.\\n\\n# Approach\\nBy this I mean evaluate for each parenthesis as soon as it completes and then pop all those values from stack and insert your evaluated value in it. For eg: |(&(t,f,t),!(t)) -> Here we will keep on inserting values till we get a closed parentheis i.e. \\')\\' then we will evaluate value of function by popping elements from stack till st.top() != \\'(\\' finally get the operation on which we have to evaluate that is &,|,!. I creted seperate function for evaluation.\\n\\n# Complexity\\n- Time complexity: O(3*n)\\n\\n\\n- Space complexity: O(2*n), Stack space & temporary vector space.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool give(char ch){\\n        if(ch==\\'f\\') return false;\\n        return true;\\n    }\\n    //Evaluates value of expression.\\n    bool get(vector<char> v, char ch){\\n        if(ch==\\'&\\'){\\n            for(int i = 0;i<v.size();++i){\\n                if(!give(v[i])) return false;\\n            }\\n            return true;\\n        }\\n        else if(ch==\\'|\\'){\\n            for(int i = 0;i<v.size();++i){\\n                if(give(v[i])) return true;\\n            }\\n            return false;\\n        }\\n        return !give(v[0]);\\n    }\\n    \\n    bool remove(stack<char> &st){\\n        vector<char> v;\\n        while(st.top()!=\\'(\\'){\\n            v.push_back(st.top());\\n            st.pop();\\n        }\\n        st.pop();\\n        char ch = st.top();\\n        st.pop();\\n        return get(v,ch);\\n    }\\n\\n    bool check(string s, int n){\\n        stack<char> st;\\n        int i = 0;\\n        //char ch;\\n        while(i<n){\\n            // if(s[i]==\\'&\\' || s[i]==\\'|\\' || s[i]==\\'!\\') ch = s[i];\\n            if(s[i] == \\')\\'){\\n                if(remove(st)) st.push(\\'t\\');\\n                else st.push(\\'f\\');\\n            }\\n            else if(s[i]==\\',\\');\\n            else st.push(s[i]);\\n            i++;\\n        }\\n        return give(st.top());\\n    }\\n\\n    bool parseBoolExpr(string exp) {\\n        return check(exp,exp.size());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool give(char ch){\\n        if(ch==\\'f\\') return false;\\n        return true;\\n    }\\n    //Evaluates value of expression.\\n    bool get(vector<char> v, char ch){\\n        if(ch==\\'&\\'){\\n            for(int i = 0;i<v.size();++i){\\n                if(!give(v[i])) return false;\\n            }\\n            return true;\\n        }\\n        else if(ch==\\'|\\'){\\n            for(int i = 0;i<v.size();++i){\\n                if(give(v[i])) return true;\\n            }\\n            return false;\\n        }\\n        return !give(v[0]);\\n    }\\n    \\n    bool remove(stack<char> &st){\\n        vector<char> v;\\n        while(st.top()!=\\'(\\'){\\n            v.push_back(st.top());\\n            st.pop();\\n        }\\n        st.pop();\\n        char ch = st.top();\\n        st.pop();\\n        return get(v,ch);\\n    }\\n\\n    bool check(string s, int n){\\n        stack<char> st;\\n        int i = 0;\\n        //char ch;\\n        while(i<n){\\n            // if(s[i]==\\'&\\' || s[i]==\\'|\\' || s[i]==\\'!\\') ch = s[i];\\n            if(s[i] == \\')\\'){\\n                if(remove(st)) st.push(\\'t\\');\\n                else st.push(\\'f\\');\\n            }\\n            else if(s[i]==\\',\\');\\n            else st.push(s[i]);\\n            i++;\\n        }\\n        return give(st.top());\\n    }\\n\\n    bool parseBoolExpr(string exp) {\\n        return check(exp,exp.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958036,
                "title": "java-intuitive-easy-iterative-solution",
                "content": "# Intuition: Use Stack\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static boolean parseBoolExpr(String expression) {\\n        Stack<Character> others = new Stack<>();\\n        Stack<Character> operators = new Stack<>();\\n        char expressionArr[] = expression.toCharArray();\\n\\n        for(char character : expressionArr){\\n            if(character == \\',\\'){\\n                continue;\\n            } else if(character == \\'(\\' || character == \\'t\\' || character == \\'f\\'){\\n                others.push(character);\\n            } else if(character == \\'!\\' || character == \\'&\\' || character == \\'|\\'){\\n                operators.push(character);\\n            } else {\\n                if(operators.peek() == \\'!\\'){\\n                    operators.pop();\\n                    others.push(evaluateNegation(others));\\n                } else if(operators.peek() == \\'&\\'){\\n                    operators.pop();\\n                    others.push(evaluateAND(others));\\n                } else {\\n                    operators.pop();\\n                    others.push(evaluateOR(others));\\n                }\\n            }\\n        }\\n        \\n        return others.pop() == \\'t\\';\\n    }\\n\\n    private static char evaluateNegation(Stack<Character> stack){\\n        char finalAns = stack.pop() == \\'t\\' ? \\'f\\' : \\'t\\';\\n        stack.pop();\\n        return finalAns;\\n    }\\n\\n    private static char evaluateOR(Stack<Character> stack){\\n        char finalAns = \\'f\\';\\n        while(stack.peek() != \\'(\\'){\\n            char poppedChar = stack.pop();\\n            if(poppedChar == \\'t\\'){\\n                finalAns = \\'t\\';\\n            }\\n        }\\n        stack.pop();\\n        return finalAns;\\n    }\\n\\n    private static char evaluateAND(Stack<Character> stack){\\n        char finalAns = \\'t\\';\\n        while(stack.peek() != \\'(\\'){\\n            char poppedChar = stack.pop();\\n            if(poppedChar == \\'f\\'){\\n                finalAns = \\'f\\';\\n            }\\n        }\\n        stack.pop();\\n        return finalAns;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public static boolean parseBoolExpr(String expression) {\\n        Stack<Character> others = new Stack<>();\\n        Stack<Character> operators = new Stack<>();\\n        char expressionArr[] = expression.toCharArray();\\n\\n        for(char character : expressionArr){\\n            if(character == \\',\\'){\\n                continue;\\n            } else if(character == \\'(\\' || character == \\'t\\' || character == \\'f\\'){\\n                others.push(character);\\n            } else if(character == \\'!\\' || character == \\'&\\' || character == \\'|\\'){\\n                operators.push(character);\\n            } else {\\n                if(operators.peek() == \\'!\\'){\\n                    operators.pop();\\n                    others.push(evaluateNegation(others));\\n                } else if(operators.peek() == \\'&\\'){\\n                    operators.pop();\\n                    others.push(evaluateAND(others));\\n                } else {\\n                    operators.pop();\\n                    others.push(evaluateOR(others));\\n                }\\n            }\\n        }\\n        \\n        return others.pop() == \\'t\\';\\n    }\\n\\n    private static char evaluateNegation(Stack<Character> stack){\\n        char finalAns = stack.pop() == \\'t\\' ? \\'f\\' : \\'t\\';\\n        stack.pop();\\n        return finalAns;\\n    }\\n\\n    private static char evaluateOR(Stack<Character> stack){\\n        char finalAns = \\'f\\';\\n        while(stack.peek() != \\'(\\'){\\n            char poppedChar = stack.pop();\\n            if(poppedChar == \\'t\\'){\\n                finalAns = \\'t\\';\\n            }\\n        }\\n        stack.pop();\\n        return finalAns;\\n    }\\n\\n    private static char evaluateAND(Stack<Character> stack){\\n        char finalAns = \\'t\\';\\n        while(stack.peek() != \\'(\\'){\\n            char poppedChar = stack.pop();\\n            if(poppedChar == \\'f\\'){\\n                finalAns = \\'f\\';\\n            }\\n        }\\n        stack.pop();\\n        return finalAns;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3955710,
                "title": "stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe key of this problem is operators like `!,&,|` must on the left of `(`\\nHere\\'s a breakdown of the function\\'s logic:\\n\\nInitialize an empty stack.\\n\\nIterate over each character in the expression.\\n\\nIf the stack is empty or the current character is not a closing parenthesis ()), push the character onto the stack.\\n\\nIf the current character is a closing parenthesis:\\n    Initialize an empty temp list to hold the contents between the opening and closing parentheses.\\n    Pop characters off the stack until an opening parenthesis (() is encountered. Store these characters in the temp list and pop the opening parenthesis.\\n    Pop the next character off the stack. This will be the operator (!, &, or |).\\n    Depending on the operator, evaluate the contents of the temp list and push the result onto the stack:\\n\\n        If the operator is !, it\\'s a NOT operation, so if the first (and only) character in temp is f, push t onto the stack, otherwise push f.\\n\\n        If the operator is &, it\\'s an AND operation, so if f is not in temp, push t onto the stack, otherwise push f.\\n\\n        If the operator is |, it\\'s an OR operation, so if t is in temp, push t onto the stack, otherwise push f.\\n\\nAfter processing the entire expression, the stack should have one item which is the result of evaluating the Boolean expression.\\nReturn True if the result is t, otherwise return False.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        stack = []\\n        for i in expression:\\n            if not stack or i != \")\":\\n                stack.append(i)\\n            else:\\n                temp = []\\n                while stack[-1] != \"(\":\\n                    temp.append(stack.pop())\\n                stack.pop()\\n                op = stack.pop()\\n                if op == \"!\":\\n                    stack.append(\"t\" if temp[0] == \"f\" else \"f\")\\n                elif op == \"&\":\\n                    stack.append(\"t\" if \"f\" not in temp else \"f\")\\n                elif op == \"|\":\\n                    stack.append(\"t\" if \"t\" in temp else \"f\")\\n        return stack[0] == \"t\"\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        stack = []\\n        for i in expression:\\n            if not stack or i != \")\":\\n                stack.append(i)\\n            else:\\n                temp = []\\n                while stack[-1] != \"(\":\\n                    temp.append(stack.pop())\\n                stack.pop()\\n                op = stack.pop()\\n                if op == \"!\":\\n                    stack.append(\"t\" if temp[0] == \"f\" else \"f\")\\n                elif op == \"&\":\\n                    stack.append(\"t\" if \"f\" not in temp else \"f\")\\n                elif op == \"|\":\\n                    stack.append(\"t\" if \"t\" in temp else \"f\")\\n        return stack[0] == \"t\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954404,
                "title": "fast-easy-to-understand-recursive-solution-beats-100-speed",
                "content": "\\n# Code\\n```\\n/**\\n * @param {string} expression\\n * @return {boolean}\\n */\\nvar parseBoolExpr = function(expression) {\\n        const helper = function (index) {\\n            let sign = expression[index];\\n            if (sign === \\'t\\' || sign === \\'f\\') return [index, sign === \\'t\\']\\n            index += 2;\\n            let booleans = []\\n            while(true){\\n                let [processedIndex, bool] = helper(index);\\n                booleans.push(bool)\\n                index = processedIndex;\\n                if(expression[index+1] === \\')\\') break;\\n                index += 2;\\n            }\\n            index++;\\n            switch (sign) {\\n                case \\'!\\':\\n                    return [index, !booleans[0]]\\n                case \\'&\\':\\n                    return [index, booleans.every(e=> e)]\\n                case \\'|\\':\\n                    return [index, booleans.some(e=> e)]\\n            }\\n        }\\n        return helper(0)[1]\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} expression\\n * @return {boolean}\\n */\\nvar parseBoolExpr = function(expression) {\\n        const helper = function (index) {\\n            let sign = expression[index];\\n            if (sign === \\'t\\' || sign === \\'f\\') return [index, sign === \\'t\\']\\n            index += 2;\\n            let booleans = []\\n            while(true){\\n                let [processedIndex, bool] = helper(index);\\n                booleans.push(bool)\\n                index = processedIndex;\\n                if(expression[index+1] === \\')\\') break;\\n                index += 2;\\n            }\\n            index++;\\n            switch (sign) {\\n                case \\'!\\':\\n                    return [index, !booleans[0]]\\n                case \\'&\\':\\n                    return [index, booleans.every(e=> e)]\\n                case \\'|\\':\\n                    return [index, booleans.some(e=> e)]\\n            }\\n        }\\n        return helper(0)[1]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3895534,
                "title": "short-and-simple-using-stack",
                "content": "```\\nclass Solution {\\npublic: \\n    char expVal(int t, int f, char op){\\n        if(op==\\'&\\') return f?\\'f\\':\\'t\\';\\n        if(op==\\'|\\') return t?\\'t\\':\\'f\\';\\n        return t?\\'f\\':\\'t\\';\\n    }\\n    \\n    bool parseBoolExpr(string exp) {\\n        set<char> isOp={\\'&\\', \\'|\\', \\'!\\'};\\n        stack<char> op, e;\\n\\n        for(int i=0; i<exp.size(); i++){\\n            if(exp[i]==\\',\\') continue;\\n            \\n            if(exp[i]==\\')\\'){\\n                int ct=0, cf=0;\\n                while(e.top()!=\\'(\\'){\\n                    ct+=e.top()==\\'t\\';\\n                    cf+=e.top()==\\'f\\';\\n                    e.pop();\\n                }\\n                e.pop();\\n                e.push(expVal(ct, cf, op.top()));\\n                op.pop();\\n            }\\n            else if(isOp.count(exp[i])) op.push(exp[i]);\\n            else e.push(exp[i]);\\n        }\\n        return e.top()==\\'t\\';\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    char expVal(int t, int f, char op){\\n        if(op==\\'&\\') return f?\\'f\\':\\'t\\';\\n        if(op==\\'|\\') return t?\\'t\\':\\'f\\';\\n        return t?\\'f\\':\\'t\\';\\n    }\\n    \\n    bool parseBoolExpr(string exp) {\\n        set<char> isOp={\\'&\\', \\'|\\', \\'!\\'};\\n        stack<char> op, e;\\n\\n        for(int i=0; i<exp.size(); i++){\\n            if(exp[i]==\\',\\') continue;\\n            \\n            if(exp[i]==\\')\\'){\\n                int ct=0, cf=0;\\n                while(e.top()!=\\'(\\'){\\n                    ct+=e.top()==\\'t\\';\\n                    cf+=e.top()==\\'f\\';\\n                    e.pop();\\n                }\\n                e.pop();\\n                e.push(expVal(ct, cf, op.top()));\\n                op.pop();\\n            }\\n            else if(isOp.count(exp[i])) op.push(exp[i]);\\n            else e.push(exp[i]);\\n        }\\n        return e.top()==\\'t\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886472,
                "title": "best-and-easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string e) {\\n        auto it = e.begin();\\n        return parse(it);\\n    }\\n\\n    bool parse(string::iterator& it) {\\n        switch (*(it++)) {\\n            case \\'t\\': return true;\\n            case \\'f\\': return false;\\n            case \\'|\\': return parse(it, false, [](bool init, bool val){ return init || val; });\\n            case \\'&\\': return parse(it, true,  [](bool init, bool val){ return init && val; });\\n            case \\'!\\': return parse(it, false, [](bool init, bool val){ return !val; });\\n        }\\n        return false;\\n    }\\n\\n    bool parse(string::iterator& it, bool init, function<bool(bool, bool)> op) {\\n        it++; \\n        while (true) {\\n            auto b = parse(it);\\n            init = op(init, b);\\n            if (*it == \\')\\') break;\\n            it++; \\n        }\\n        it++; \\n        return init;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string e) {\\n        auto it = e.begin();\\n        return parse(it);\\n    }\\n\\n    bool parse(string::iterator& it) {\\n        switch (*(it++)) {\\n            case \\'t\\': return true;\\n            case \\'f\\': return false;\\n            case \\'|\\': return parse(it, false, [](bool init, bool val){ return init || val; });\\n            case \\'&\\': return parse(it, true,  [](bool init, bool val){ return init && val; });\\n            case \\'!\\': return parse(it, false, [](bool init, bool val){ return !val; });\\n        }\\n        return false;\\n    }\\n\\n    bool parse(string::iterator& it, bool init, function<bool(bool, bool)> op) {\\n        it++; \\n        while (true) {\\n            auto b = parse(it);\\n            init = op(init, b);\\n            if (*it == \\')\\') break;\\n            it++; \\n        }\\n        it++; \\n        return init;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873554,
                "title": "javascript-o-n",
                "content": "# Intuition\\nTo evaluates expression best thing to do is to thing about stack\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Push every character into stack expect `,`.\\n- If we encounter `)` pop it from the stack and store in set.\\n- Then one more char from stack so that it remove `(`\\n- Now pop one more character because it will operation which we have to perform\\n- Using this operation find `t` or `f` and store it in stack.\\n- When return from check stack last elemet whether it\\'s `t` or `f`\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} expression\\n * @return {boolean}\\n */\\nvar parseBoolExpr = function(expression) {\\n    let stack = []; \\n    for(let i = 0; i < expression.length; i++) {\\n        const char = expression[i];\\n        if (char === \\')\\') {\\n            let _seen = new Set();\\n            while(stack.at(-1) !== \\'(\\'){\\n                _seen.add(stack.pop());\\n            }\\n            stack.pop();\\n            const operator = stack.pop();\\n            if(operator === \\'&\\') {\\n                stack.push(_seen.has(\\'f\\') ? \\'f\\' : \\'t\\');\\n            } else if (operator === \\'|\\') {\\n                stack.push(_seen.has(\\'t\\') ? \\'t\\' : \\'f\\');\\n            } else {\\n                 stack.push(_seen.has(\\'t\\') ? \\'f\\' : \\'t\\');\\n            }\\n        } else if (char !== \\',\\') {\\n            stack.push(char)\\n        }\\n    }\\n    return stack.pop() == \\'t\\';\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} expression\\n * @return {boolean}\\n */\\nvar parseBoolExpr = function(expression) {\\n    let stack = []; \\n    for(let i = 0; i < expression.length; i++) {\\n        const char = expression[i];\\n        if (char === \\')\\') {\\n            let _seen = new Set();\\n            while(stack.at(-1) !== \\'(\\'){\\n                _seen.add(stack.pop());\\n            }\\n            stack.pop();\\n            const operator = stack.pop();\\n            if(operator === \\'&\\') {\\n                stack.push(_seen.has(\\'f\\') ? \\'f\\' : \\'t\\');\\n            } else if (operator === \\'|\\') {\\n                stack.push(_seen.has(\\'t\\') ? \\'t\\' : \\'f\\');\\n            } else {\\n                 stack.push(_seen.has(\\'t\\') ? \\'f\\' : \\'t\\');\\n            }\\n        } else if (char !== \\',\\') {\\n            stack.push(char)\\n        }\\n    }\\n    return stack.pop() == \\'t\\';\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3854174,
                "title": "java-just-normal-stack-operation",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        Stack<Character> st = new Stack<Character>();\\n\\n        for(int i = expression.length()-1;i>=0;i--){\\n            //only one element, just push the opposite into the stack\\n            if(expression.charAt(i)==\\'!\\'){\\n                st.pop();//(\\n                char temp = st.pop();\\n                st.pop();//)\\n                if(temp==\\'t\\') st.push(\\'f\\');\\n                else st.push(\\'t\\');\\n            }\\n\\n            //initialise a \"false\", if there is one \"true\", the result is true\\n            else if(expression.charAt(i)==\\'|\\'){\\n                st.pop();//(\\n                char temp = \\'f\\';\\n                while(st.peek()!=\\')\\'){\\n                    if(st.pop()==\\'t\\'){\\n                        temp = \\'t\\';\\n                        \\n                    }\\n\\n                }\\n                st.pop();//)\\n                st.push(temp);\\n\\n            }\\n\\n            //initialise a \"true\", if there is one \"false\", the result is false\\n            else if(expression.charAt(i)==\\'&\\'){\\n                st.pop();//(\\n                char temp = \\'t\\';\\n                while(st.peek()!=\\')\\'){\\n                    if(st.pop()==\\'f\\'){\\n                        temp = \\'f\\';\\n                        \\n                    }\\n\\n                }\\n                st.pop();//)\\n                st.push(temp);\\n            }\\n            else\\n                st.push(expression.charAt(i));\\n        }\\n\\n        return st.peek()==\\'t\\'; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        Stack<Character> st = new Stack<Character>();\\n\\n        for(int i = expression.length()-1;i>=0;i--){\\n            //only one element, just push the opposite into the stack\\n            if(expression.charAt(i)==\\'!\\'){\\n                st.pop();//(\\n                char temp = st.pop();\\n                st.pop();//)\\n                if(temp==\\'t\\') st.push(\\'f\\');\\n                else st.push(\\'t\\');\\n            }\\n\\n            //initialise a \"false\", if there is one \"true\", the result is true\\n            else if(expression.charAt(i)==\\'|\\'){\\n                st.pop();//(\\n                char temp = \\'f\\';\\n                while(st.peek()!=\\')\\'){\\n                    if(st.pop()==\\'t\\'){\\n                        temp = \\'t\\';\\n                        \\n                    }\\n\\n                }\\n                st.pop();//)\\n                st.push(temp);\\n\\n            }\\n\\n            //initialise a \"true\", if there is one \"false\", the result is false\\n            else if(expression.charAt(i)==\\'&\\'){\\n                st.pop();//(\\n                char temp = \\'t\\';\\n                while(st.peek()!=\\')\\'){\\n                    if(st.pop()==\\'f\\'){\\n                        temp = \\'f\\';\\n                        \\n                    }\\n\\n                }\\n                st.pop();//)\\n                st.push(temp);\\n            }\\n            else\\n                st.push(expression.charAt(i));\\n        }\\n\\n        return st.peek()==\\'t\\'; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3854019,
                "title": "python-easy-to-undestand-solution-using-two-stacks-prefix-expression",
                "content": "# Code\\n```\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        operands = []\\n        operators = []\\n        b = {\"f\": False, \"t\": True, \"(\": \"(\"}\\n        for i in range(len(expression)):\\n            if expression[i] in \"(ft\":\\n                operands.append(b[expression[i]])\\n            elif expression[i] in \"!&|\":\\n                operators.append(expression[i])\\n            elif expression[i] == \")\":\\n                c = []\\n                while operands and operands[-1] != \"(\":\\n                    c.append(operands.pop())\\n                operands.pop()\\n                val = None\\n                if operators[-1] == \"&\":\\n                    val = True\\n                    for x in c:\\n                        val = val and x\\n                elif operators[-1] == \"|\":\\n                    val = False\\n                    for x in c:\\n                        val = val or x\\n                else:\\n                    val = not c[0]\\n                operands.append(val)\\n                operators.pop()\\n        return operands[-1]\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        operands = []\\n        operators = []\\n        b = {\"f\": False, \"t\": True, \"(\": \"(\"}\\n        for i in range(len(expression)):\\n            if expression[i] in \"(ft\":\\n                operands.append(b[expression[i]])\\n            elif expression[i] in \"!&|\":\\n                operators.append(expression[i])\\n            elif expression[i] == \")\":\\n                c = []\\n                while operands and operands[-1] != \"(\":\\n                    c.append(operands.pop())\\n                operands.pop()\\n                val = None\\n                if operators[-1] == \"&\":\\n                    val = True\\n                    for x in c:\\n                        val = val and x\\n                elif operators[-1] == \"|\":\\n                    val = False\\n                    for x in c:\\n                        val = val or x\\n                else:\\n                    val = not c[0]\\n                operands.append(val)\\n                operators.pop()\\n        return operands[-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3844299,
                "title": "intuitive-recursion-approach-1ms",
                "content": "# Intuition\\nThere are 2 main options for the first character of the expression given or any subexpression:\\n\\n1. Either \\'t\\' or \\'f\\'.\\n2. An operator \\'!\\',\\'&\\' or \\'|\\' followed by \\'(\\' followed by an expression or list of expressions and closed with \\')\\'\\n\\nThis means that if we can break either of these options into a subexpression or a series of subexpressions, we can use `parseBoolExpr` on those subexpressions to find thier boolean values, and ultimately use boolean algebra to combine them.\\n\\nAdditionally, we note that for any series of expressions ANDed together, if any value is found to be false, the entire expression is false, and for any series of expressions ORed together if any value is found to be false, the entire expression is false. We shall call this boolean for the OR or the AND the overriding operator.\\n\\n# Approach\\n\\n1. So, in making `parseBoolExpr` a recursive method, we first check if the expression starts with \\'t\\' or \\'f\\', and if so, we return the corresponding value (any subexpression that starts with \\'t\\' or \\'f\\' only contains 1 character).\\n2. Then we check for \\'!\\'. If the expression starts with \\'!\\', we can strip the first and last parenthesis and return the opposite of `parseBoolExpr` on the resulting substring.\\n3. Lastly for `parseBoolExpr`, we know that the first character is either \\'&\\' or \\'|\\', and using the intuition that any false in \\'&\\' makes the whole statment false and any true in \\'|\\' makes the whole statement true, we save this corresponding boolean depending on if the character is an \\'&\\' or \\'|\\'. As previously discussed, we shall refer to this as the overriding operator. To handle the expressions inside the parenthesis that we strip, we call `parseList`.\\n4. In `parseList` we will iterate through each character in the expression looking for commas. We know we have gotten to the end index of a first statement once we see a comma and there are no open parenthesis (which we track with parenParity).\\n5. We check if the overriding operator is the outcome of that subexpression, and return that operator if true. Otherwise, we continue looping through and save our index+1 to strip away the comma when finding the next statement.\\n6. Once `idx`=`expression.length` we know that we have one sub-expression left to check as the last one ends without a comma. We check this accordingly, and if it does not equal to the overring operator then we know that all of the expressions were not the overriding operator, and therefore the whole statement evaulates to `!operator`.\\n\\nWe have now covered all cases, so in the end parseBoolExpr will successfully subdivide all expressions to evaulate them recursively.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        if(expression.charAt(0) == \\'t\\'){\\n            return true;\\n        }\\n        if(expression.charAt(0) == \\'f\\'){\\n            return false;\\n        }\\n        if(expression.charAt(0)==\\'!\\'){\\n            return !parseBoolExpr(expression.substring(2,expression.length()-1));\\n        }\\n        return parseList(expression.substring(2,expression.length()-1),expression.charAt(0)==\\'|\\');\\n        \\n    }\\n\\n    private boolean parseList(String expression, boolean operator){\\n        int parenParity = 0;\\n        int prevIdx = 0;\\n        int idx = 0;\\n        while(idx<expression.length()){\\n            if(expression.charAt(idx)==\\'(\\'){\\n                parenParity++;\\n            }\\n            else if(expression.charAt(idx)==\\')\\'){\\n                parenParity--;\\n            }\\n            else if(expression.charAt(idx)==\\',\\' && parenParity==0){\\n                if(parseBoolExpr(expression.substring(prevIdx,idx))==operator){\\n                    return operator;\\n                }\\n                prevIdx=idx+1;\\n            }\\n            idx++;\\n        }\\n        if(parseBoolExpr(expression.substring(prevIdx,idx))==operator){\\n            return operator;\\n        }\\n        return !operator;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        if(expression.charAt(0) == \\'t\\'){\\n            return true;\\n        }\\n        if(expression.charAt(0) == \\'f\\'){\\n            return false;\\n        }\\n        if(expression.charAt(0)==\\'!\\'){\\n            return !parseBoolExpr(expression.substring(2,expression.length()-1));\\n        }\\n        return parseList(expression.substring(2,expression.length()-1),expression.charAt(0)==\\'|\\');\\n        \\n    }\\n\\n    private boolean parseList(String expression, boolean operator){\\n        int parenParity = 0;\\n        int prevIdx = 0;\\n        int idx = 0;\\n        while(idx<expression.length()){\\n            if(expression.charAt(idx)==\\'(\\'){\\n                parenParity++;\\n            }\\n            else if(expression.charAt(idx)==\\')\\'){\\n                parenParity--;\\n            }\\n            else if(expression.charAt(idx)==\\',\\' && parenParity==0){\\n                if(parseBoolExpr(expression.substring(prevIdx,idx))==operator){\\n                    return operator;\\n                }\\n                prevIdx=idx+1;\\n            }\\n            idx++;\\n        }\\n        if(parseBoolExpr(expression.substring(prevIdx,idx))==operator){\\n            return operator;\\n        }\\n        return !operator;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841761,
                "title": "recusive-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} expression\\n * @return {boolean}\\n */\\nfunction parseBoolExpr(expr) {\\n    if (expr === \\'f\\') return false;\\n    if (expr === \\'t\\') return true;\\n\\n    expr = lexing(expr);\\n    if (expr[0] == \\'&\\') {\\n        for (let i = 1; i < expr.length; i++) {\\n            expr[i] = parseBoolExpr(expr[i]);\\n            if (!expr[i]) return false;\\n        }\\n        return true;\\n    } else if (expr[0] === \\'|\\') {\\n        for (let i = 1; i < expr.length; i++) {\\n            expr[i] = parseBoolExpr(expr[i]);\\n            if (expr[i]) return true;\\n        }\\n        return false;\\n    } else { // if (expr[0] === \\'!\\')\\n        return !(parseBoolExpr(expr[1]))\\n    }\\n}\\n\\nfunction lexing(expr) {\\n\\n    const res = [];\\n    if (expr[0] === \\'&\\' || expr[0] === \\'|\\' || expr[0] === \\'!\\') res.push(expr[0]);\\n\\n    let lastPos = 1;\\n    let leftBracket = -1;\\n    for (let i = 1; i < expr.length; i++) {\\n        if (expr[i] === \\'(\\') {\\n            leftBracket++;\\n            if (leftBracket > 0) {\\n                lastPos = i-1;\\n\\n                while(++i < expr.length && leftBracket > 0) {\\n                    if (expr[i] === \\'(\\') leftBracket++;\\n                    if (expr[i] === \\')\\') leftBracket--;\\n                }\\n                res.push(expr.slice(lastPos, i));\\n                lastPos = i;\\n            } \\n        } else if (expr[i] === \\',\\') {\\n            res.push(expr.slice(lastPos+1, i));\\n            lastPos = i;\\n        } else if (expr[i] === \\')\\') {\\n            res.push(expr.slice(lastPos+1, i));\\n            lastPos = i;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} expression\\n * @return {boolean}\\n */\\nfunction parseBoolExpr(expr) {\\n    if (expr === \\'f\\') return false;\\n    if (expr === \\'t\\') return true;\\n\\n    expr = lexing(expr);\\n    if (expr[0] == \\'&\\') {\\n        for (let i = 1; i < expr.length; i++) {\\n            expr[i] = parseBoolExpr(expr[i]);\\n            if (!expr[i]) return false;\\n        }\\n        return true;\\n    } else if (expr[0] === \\'|\\') {\\n        for (let i = 1; i < expr.length; i++) {\\n            expr[i] = parseBoolExpr(expr[i]);\\n            if (expr[i]) return true;\\n        }\\n        return false;\\n    } else { // if (expr[0] === \\'!\\')\\n        return !(parseBoolExpr(expr[1]))\\n    }\\n}\\n\\nfunction lexing(expr) {\\n\\n    const res = [];\\n    if (expr[0] === \\'&\\' || expr[0] === \\'|\\' || expr[0] === \\'!\\') res.push(expr[0]);\\n\\n    let lastPos = 1;\\n    let leftBracket = -1;\\n    for (let i = 1; i < expr.length; i++) {\\n        if (expr[i] === \\'(\\') {\\n            leftBracket++;\\n            if (leftBracket > 0) {\\n                lastPos = i-1;\\n\\n                while(++i < expr.length && leftBracket > 0) {\\n                    if (expr[i] === \\'(\\') leftBracket++;\\n                    if (expr[i] === \\')\\') leftBracket--;\\n                }\\n                res.push(expr.slice(lastPos, i));\\n                lastPos = i;\\n            } \\n        } else if (expr[i] === \\',\\') {\\n            res.push(expr.slice(lastPos+1, i));\\n            lastPos = i;\\n        } else if (expr[i] === \\')\\') {\\n            res.push(expr.slice(lastPos+1, i));\\n            lastPos = i;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3832197,
                "title": "parsing-a-boolean-expression",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nParenthesis problems come, think in terms of stack.\\nwe need to evaluate for an operator,before that we need to resolve the various subproblems that were there.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe most basic subproblem would be operator(t,f,t) etc.\\nhow can  I solve it.\\nRemember for an operator say op we need to have it\\'s values in a vector.\\nsay we start and then found an operator op, then what we do is that we keep on moving if found a closing bracket, can only found if all it\\'s subproblems inside have been evaluated.\\nwe want the answers for the subproblems ( )inside the parenthesis, so we take them out of the stack and then apply the appropriate operation on them.\\nfinally since again we solved a subproblem we then store it\\'s result in the stack only.\\nfinally the st top element would be having the result.\\nsince two variables T,F are there so instead of storing all their occurences we can store a frequency hash for them to further optimize our space.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// https://www.youtube.com/watch?v=lYw86z7Astg&ab_channel=leetuition\\n\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n        stack<char> st;\\n        // hash[0]=truecnt,hash[1]=falseccnt; , used instead of storing everything.\\n        for(auto ch:expression)\\n        {\\n            if(ch==\\',\\') continue;\\n            if(ch!=\\')\\') \\n            {\\n             st.push(ch);\\n             continue;\\n            }\\n            int hash[2]={0}; \\n            while(st.top()!=\\'(\\')\\n            {\\n                st.top()==\\'t\\'?hash[0]++:hash[1]++;\\n                st.pop();\\n            }\\n            st.pop();\\n            if(st.empty())continue;\\n            //evaluate for the operator.\\n            char op=st.top();st.pop();\\n            char topush;\\n            switch(op)\\n            {\\n                case \\'&\\':\\n                topush=hash[1]!=0?\\'f\\':\\'t\\';break;\\n                case \\'|\\':\\n                topush=hash[0]!=0?\\'t\\':\\'f\\';break;\\n                case \\'!\\':\\n                topush=hash[0]!=0?\\'f\\':\\'t\\';\\n                break;\\n            }\\n            st.push(topush);\\n        }\\n        \\n        return st.top()==\\'t\\';\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\n// https://www.youtube.com/watch?v=lYw86z7Astg&ab_channel=leetuition\\n\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n        stack<char> st;\\n        // hash[0]=truecnt,hash[1]=falseccnt; , used instead of storing everything.\\n        for(auto ch:expression)\\n        {\\n            if(ch==\\',\\') continue;\\n            if(ch!=\\')\\') \\n            {\\n             st.push(ch);\\n             continue;\\n            }\\n            int hash[2]={0}; \\n            while(st.top()!=\\'(\\')\\n            {\\n                st.top()==\\'t\\'?hash[0]++:hash[1]++;\\n                st.pop();\\n            }\\n            st.pop();\\n            if(st.empty())continue;\\n            //evaluate for the operator.\\n            char op=st.top();st.pop();\\n            char topush;\\n            switch(op)\\n            {\\n                case \\'&\\':\\n                topush=hash[1]!=0?\\'f\\':\\'t\\';break;\\n                case \\'|\\':\\n                topush=hash[0]!=0?\\'t\\':\\'f\\';break;\\n                case \\'!\\':\\n                topush=hash[0]!=0?\\'f\\':\\'t\\';\\n                break;\\n            }\\n            st.push(topush);\\n        }\\n        \\n        return st.top()==\\'t\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3812030,
                "title": "simple-python-o-n-stack-solution",
                "content": "`!, &, |` are functions, so every time we encounter them, we want to create a new \"function stack frame\". Once we see a `)`, we have all the parameters to the function, so we can evaluate it and pop the stack frame.\\n```\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        def eval_expr(expr):\\n            op = expr[0]\\n            if op == \\'!\\':\\n                return not expr[1]\\n            elif op == \\'&\\':\\n                return all(expr[1:])\\n            elif op == \\'|\\':\\n                return any(expr[1:])\\n\\n        stack = [[]]\\n        i = 0\\n        while i < len(expression):\\n            if expression[i] in \\'tf\\':\\n                stack[-1].append(True if expression[i] == \\'t\\' else False)\\n                i += 1\\n            elif expression[i] in \\'!&|\\':\\n                stack.append([expression[i]])\\n                i += 2\\n            elif expression[i] == \\')\\':\\n                t = stack.pop()\\n                stack[-1].append(eval_expr(t))\\n                i += 1\\n            else:\\n                i += 1\\n        return stack[-1][0]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        def eval_expr(expr):\\n            op = expr[0]\\n            if op == \\'!\\':\\n                return not expr[1]\\n            elif op == \\'&\\':\\n                return all(expr[1:])\\n            elif op == \\'|\\':\\n                return any(expr[1:])\\n\\n        stack = [[]]\\n        i = 0\\n        while i < len(expression):\\n            if expression[i] in \\'tf\\':\\n                stack[-1].append(True if expression[i] == \\'t\\' else False)\\n                i += 1\\n            elif expression[i] in \\'!&|\\':\\n                stack.append([expression[i]])\\n                i += 2\\n            elif expression[i] == \\')\\':\\n                t = stack.pop()\\n                stack[-1].append(eval_expr(t))\\n                i += 1\\n            else:\\n                i += 1\\n        return stack[-1][0]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797098,
                "title": "beats-100-of-the-c-solutions-simple-approach-using-stack",
                "content": "# Intuition\\nMost of the questions which includes a expression in it can be solved by stack.\\n\\n# Approach\\nwe maintain 2 stacks.one for storing operators and other for storing expressions.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)+O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string s) {\\n        stack<char>op,exp;\\n        int idx=0;\\n        int n=s.size();\\n        while(idx<n){\\n            if(s[idx]==\\',\\'){\\n                idx++;\\n                continue;\\n            }\\n            if(s[idx]==\\'&\\' || s[idx]==\\'|\\' || s[idx]==\\'!\\'){\\n                op.push(s[idx]);\\n            }\\n            else if(s[idx]==\\')\\'){\\n                int ctf=0,ctt=0;\\n                while(exp.top()!=\\'(\\'){\\n                    if(exp.top()==\\'f\\') ctf++;\\n                    else ctt++;\\n                    exp.pop();\\n                }\\n                exp.pop();\\n                char oper=op.top();\\n                op.pop();\\n                if(oper==\\'&\\'){\\n                    if(ctf==0) exp.push(\\'t\\');\\n                    else exp.push(\\'f\\');\\n                }\\n                else if(oper==\\'|\\'){\\n                    if(ctt==0) exp.push(\\'f\\');\\n                    else exp.push(\\'t\\');\\n                }\\n                else{\\n                    if(ctt==0) exp.push(\\'t\\');\\n                    else exp.push(\\'f\\');\\n                }\\n            }\\n            else{\\n                exp.push(s[idx]);\\n            }\\n            idx++;\\n        }\\n        \\n        if(exp.top()==\\'f\\') return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string s) {\\n        stack<char>op,exp;\\n        int idx=0;\\n        int n=s.size();\\n        while(idx<n){\\n            if(s[idx]==\\',\\'){\\n                idx++;\\n                continue;\\n            }\\n            if(s[idx]==\\'&\\' || s[idx]==\\'|\\' || s[idx]==\\'!\\'){\\n                op.push(s[idx]);\\n            }\\n            else if(s[idx]==\\')\\'){\\n                int ctf=0,ctt=0;\\n                while(exp.top()!=\\'(\\'){\\n                    if(exp.top()==\\'f\\') ctf++;\\n                    else ctt++;\\n                    exp.pop();\\n                }\\n                exp.pop();\\n                char oper=op.top();\\n                op.pop();\\n                if(oper==\\'&\\'){\\n                    if(ctf==0) exp.push(\\'t\\');\\n                    else exp.push(\\'f\\');\\n                }\\n                else if(oper==\\'|\\'){\\n                    if(ctt==0) exp.push(\\'f\\');\\n                    else exp.push(\\'t\\');\\n                }\\n                else{\\n                    if(ctt==0) exp.push(\\'t\\');\\n                    else exp.push(\\'f\\');\\n                }\\n            }\\n            else{\\n                exp.push(s[idx]);\\n            }\\n            idx++;\\n        }\\n        \\n        if(exp.top()==\\'f\\') return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3759517,
                "title": "parsing-boolean-expression-recursion-easy-to-understand",
                "content": "# Problem Statement:\\nYou are given a string representing a boolean expression, where \\'t\\' represents true, \\'f\\' represents false, \\'&\\' represents the logical AND operator, \\'|\\' represents the logical OR operator, and \\'!\\' represents the logical NOT operator. You need to parse and evaluate the given boolean expression.\\n\\n# Intuition:\\nTo solve this problem, we can use a recursive parsing approach. We define different parsing functions for each logical operator (\\'&\\', \\'|\\', \\'!\\') and recursively evaluate the subexpressions.\\n\\n# Approach:\\n1. Define a parsing function `parseOr` for the logical OR operator (\\'|\\'):\\n   - The function takes the following parameters:\\n     - `expression`: The boolean expression string.\\n     - `index`: The current index in the expression string.\\n   - Move past the opening \\'|(\\' in the expression.\\n   - Initialize a boolean variable `response` to store the result.\\n   - Parse the first expression by calling the `parse` function recursively.\\n   - While the current character is not \\')\\', move to the next character and parse the subsequent expressions. Perform the logical OR operation with the previous result.\\n   - Move past the closing \\')\\'.\\n   - Return the final response.\\n   \\n2. Define a parsing function `parseAnd` for the logical AND operator (\\'&\\'):\\n   - The function takes similar parameters as `parseOr`.\\n   - Move past the opening \\'&(\\' in the expression.\\n   - Initialize a boolean variable `response` to store the result.\\n   - Parse the first expression by calling the `parse` function recursively.\\n   - While the current character is not \\')\\', move to the next character and parse the subsequent expressions. Perform the logical AND operation with the previous result.\\n   - Move past the closing \\')\\'.\\n   - Return the final response.\\n   \\n3. Define a parsing function `parseNot` for the logical NOT operator (\\'!\\'):\\n   - The function takes similar parameters as `parseOr`.\\n   - Move past the opening \\'!(\\' in the expression.\\n   - Parse the expression after the \\'!\\' by calling the `parse` function recursively.\\n   - Move past the closing \\')\\'.\\n   - Perform logical negation on the parsed expression and return the result.\\n   \\n4. Define a general parsing function `parse` to handle the base cases and parse the main expression:\\n   - The function takes similar parameters as the other parsing functions.\\n   - Check the current character in the expression:\\n     - If it is \\'f\\', move to the next character and return false.\\n     - If it is \\'&\\', call `parseAnd` to parse the AND operation.\\n     - If it is \\'|\\', call `parseOr` to parse the OR operation.\\n     - If it is \\'!\\', call `parseNot` to parse the NOT operation.\\n     - Otherwise, move to the next character and return true.\\n     \\n5. In the `parseBoolExpr` function:\\n   - Initialize an index variable to 0 to track the current position in the expression.\\n   - Call the `parse` function to start parsing from index 0.\\n   - Return the final result.\\n\\n# Complexity Analysis:\\n- Let n be the length of the input expression.\\n- The time complexity of the solution is O(n) since we process each character once.\\n- The space complexity is O(1) since we don\\'t use any extra space that scales with the input size.\\n\\n# Code:\\n```cpp\\n\\nclass Solution {\\npublic:\\n    bool parseOr(string& expression, int& index) {\\n        index += 2; // Move past the opening \\'|(\\'\\n        bool response = false;\\n        response |= parse(expression, index); // Parse the first expression\\n        while (expression[index] != \\')\\') {\\n            index++;\\n            response |= parse(expression, index); // Parse the subsequent expressions and perform OR operation\\n        }\\n        index++; // Move past the closing \\')\\'\\n        return response;\\n    }\\n    \\n    bool parseAnd(string& expression, int& index) {\\n        index += 2; // Move past the opening \\'&(\\'\\n        bool response = true;\\n        response &= parse(expression, index); // Parse the first expression\\n        while (expression[index] != \\')\\') {\\n            index++;\\n            response &= parse(expression, index); // Parse the subsequent expressions and perform AND operation\\n        }\\n        index++; // Move past the closing \\')\\'\\n        return response;\\n    }\\n    \\n    bool parseNot(string& expression, int& index) {\\n        index += 2; // Move past the opening \\'!(\\'\\n        bool response = parse(expression, index); // Parse the expression after the \\'!\\'\\n        index++; // Move past the closing \\')\\'\\n        return !response; // Perform logical negation\\n    }\\n    \\n    bool parse(string& expression, int& index) {\\n        if (expression[index] == \\'f\\') {\\n            index++;\\n            return false; // Return false for \\'f\\'\\n        } else if (expression[index] == \\'&\\') {\\n            return parseAnd(expression, index); // Parse AND operation\\n        } else if (expression[index] == \\'|\\') {\\n            return parseOr(expression, index); // Parse OR operation\\n        } else if (expression[index] == \\'!\\') {\\n            return parseNot(expression, index); // Parse NOT operation\\n        }\\n        index++;\\n        return true; // Return true for \\'t\\'\\n    }\\n    \\n    bool parseBoolExpr(string expression) {\\n        int index = 0;\\n        bool ans = parse(expression, index); // Start parsing from index 0\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Recursion"
                ],
                "code": "```cpp\\n\\nclass Solution {\\npublic:\\n    bool parseOr(string& expression, int& index) {\\n        index += 2; // Move past the opening \\'|(\\'\\n        bool response = false;\\n        response |= parse(expression, index); // Parse the first expression\\n        while (expression[index] != \\')\\') {\\n            index++;\\n            response |= parse(expression, index); // Parse the subsequent expressions and perform OR operation\\n        }\\n        index++; // Move past the closing \\')\\'\\n        return response;\\n    }\\n    \\n    bool parseAnd(string& expression, int& index) {\\n        index += 2; // Move past the opening \\'&(\\'\\n        bool response = true;\\n        response &= parse(expression, index); // Parse the first expression\\n        while (expression[index] != \\')\\') {\\n            index++;\\n            response &= parse(expression, index); // Parse the subsequent expressions and perform AND operation\\n        }\\n        index++; // Move past the closing \\')\\'\\n        return response;\\n    }\\n    \\n    bool parseNot(string& expression, int& index) {\\n        index += 2; // Move past the opening \\'!(\\'\\n        bool response = parse(expression, index); // Parse the expression after the \\'!\\'\\n        index++; // Move past the closing \\')\\'\\n        return !response; // Perform logical negation\\n    }\\n    \\n    bool parse(string& expression, int& index) {\\n        if (expression[index] == \\'f\\') {\\n            index++;\\n            return false; // Return false for \\'f\\'\\n        } else if (expression[index] == \\'&\\') {\\n            return parseAnd(expression, index); // Parse AND operation\\n        } else if (expression[index] == \\'|\\') {\\n            return parseOr(expression, index); // Parse OR operation\\n        } else if (expression[index] == \\'!\\') {\\n            return parseNot(expression, index); // Parse NOT operation\\n        }\\n        index++;\\n        return true; // Return true for \\'t\\'\\n    }\\n    \\n    bool parseBoolExpr(string expression) {\\n        int index = 0;\\n        bool ans = parse(expression, index); // Start parsing from index 0\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3753841,
                "title": "stack-solution-easy-to-understand",
                "content": "# Complexity\\n- Time complexity:\\n- o(n)\\n\\n- Space complexity:\\n- o(n){both stack total = o(n)}\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool isValid(char curr){\\n        if(curr ==\\'t\\' || curr == \\'f\\' || curr == \\'(\\'){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    bool parseBoolExpr(string expression) {\\n        stack<char>st;  // stores ( \\'(\\',\\'t\\',\\'f\\' )\\n        stack<char>exp; // stores (\\'all operators\\')\\n        for(int i = 0;i<expression.size();i++){\\n            char current = expression[i];\\n            if(current == \\'&\\' || current == \\'|\\' || current == \\'!\\'){\\n                exp.push(current);\\n            }\\n            if(isValid(current)){\\n                st.push(current);\\n            }\\n            else{\\n                if(current == \\')\\'){\\n                    bool result = st.top() == \\'t\\'?true:false;\\n                    while(st.top()!= \\'(\\'){\\n                        // cout<<result<<endl;\\n                        st.pop();\\n                        if(exp.top() == \\'&\\'){\\n                            bool opr = st.top() == \\'t\\'?true:st.top() == \\'f\\'?false:result;\\n                            result = result&&opr;\\n                        }\\n                        else if(exp.top() == \\'|\\'){\\n                            bool opr = st.top() == \\'t\\'?true:st.top() == \\'f\\'?false:result;\\n                            // the above statement takes care of the case &(f) since it will evaluate to (f && f) or result&&result \\n                            result = result||opr;\\n                        }\\n                        else if(exp.top() == \\'!\\'){\\n                            result = !result;\\n                        }\\n                        cout<<result<<endl;\\n                    }\\n                    st.pop();\\n                    result == true?st.push(\\'t\\'):st.push(\\'f\\');\\n                    exp.pop();\\n                }\\n            }\\n        }\\n        return st.top() == \\'t\\'?true:false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool isValid(char curr){\\n        if(curr ==\\'t\\' || curr == \\'f\\' || curr == \\'(\\'){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    bool parseBoolExpr(string expression) {\\n        stack<char>st;  // stores ( \\'(\\',\\'t\\',\\'f\\' )\\n        stack<char>exp; // stores (\\'all operators\\')\\n        for(int i = 0;i<expression.size();i++){\\n            char current = expression[i];\\n            if(current == \\'&\\' || current == \\'|\\' || current == \\'!\\'){\\n                exp.push(current);\\n            }\\n            if(isValid(current)){\\n                st.push(current);\\n            }\\n            else{\\n                if(current == \\')\\'){\\n                    bool result = st.top() == \\'t\\'?true:false;\\n                    while(st.top()!= \\'(\\'){\\n                        // cout<<result<<endl;\\n                        st.pop();\\n                        if(exp.top() == \\'&\\'){\\n                            bool opr = st.top() == \\'t\\'?true:st.top() == \\'f\\'?false:result;\\n                            result = result&&opr;\\n                        }\\n                        else if(exp.top() == \\'|\\'){\\n                            bool opr = st.top() == \\'t\\'?true:st.top() == \\'f\\'?false:result;\\n                            // the above statement takes care of the case &(f) since it will evaluate to (f && f) or result&&result \\n                            result = result||opr;\\n                        }\\n                        else if(exp.top() == \\'!\\'){\\n                            result = !result;\\n                        }\\n                        cout<<result<<endl;\\n                    }\\n                    st.pop();\\n                    result == true?st.push(\\'t\\'):st.push(\\'f\\');\\n                    exp.pop();\\n                }\\n            }\\n        }\\n        return st.top() == \\'t\\'?true:false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3751841,
                "title": "unique-solution-stack-vector",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string exp) {\\n        if(exp.size() == 1) return exp[0] == \\'f\\' ? false : true;\\n        stack<char> s;\\n        vector<char> v;\\n        bool flag=false;\\n\\n        for(int i=0;i<exp.size();i++){\\n            if(exp[i] == \\')\\'){\\n                flag = false;\\n                while(!(s.top() == \\'(\\')){\\n                    v.push_back(s.top());\\n                    cout<<s.top()<<\" \";\\n                    s.pop();\\n                }\\n                s.pop();\\n                char ch = s.top(); s.pop();\\n\\n                if(v[0] == \\'t\\') flag = true;\\n                if(ch == \\'!\\'){\\n                    flag = !flag;\\n                    char fl = flag==false ? \\'f\\' : \\'t\\';\\n                    s.push(fl);\\n                    cout<<flag<<\" \";\\n                }else if(ch == \\'&\\'){\\n                    for(int i=1;i<v.size();i++){\\n                        bool f=false;\\n                        if(v[i] == \\'t\\') f = true;\\n                        flag &= f;\\n                    }\\n                    char fl = flag==false ? \\'f\\' : \\'t\\';\\n                    s.push(fl);\\n                    cout<<flag<<\" \";\\n                }else if(ch == \\'|\\'){\\n                    for(int i=1;i<v.size();i++){\\n                        bool f=false;\\n                        if(v[i] == \\'t\\') f = true;\\n                        flag |= f;\\n                    }\\n                    char fl = flag==false ? \\'f\\' : \\'t\\';\\n                    s.push(fl);\\n                    cout<<flag<<\" \";\\n                }\\n                v.clear();\\n            }\\n            else if(exp[i] != \\',\\'){\\n                s.push(exp[i]);\\n            }\\n        }\\n        return flag;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string exp) {\\n        if(exp.size() == 1) return exp[0] == \\'f\\' ? false : true;\\n        stack<char> s;\\n        vector<char> v;\\n        bool flag=false;\\n\\n        for(int i=0;i<exp.size();i++){\\n            if(exp[i] == \\')\\'){\\n                flag = false;\\n                while(!(s.top() == \\'(\\')){\\n                    v.push_back(s.top());\\n                    cout<<s.top()<<\" \";\\n                    s.pop();\\n                }\\n                s.pop();\\n                char ch = s.top(); s.pop();\\n\\n                if(v[0] == \\'t\\') flag = true;\\n                if(ch == \\'!\\'){\\n                    flag = !flag;\\n                    char fl = flag==false ? \\'f\\' : \\'t\\';\\n                    s.push(fl);\\n                    cout<<flag<<\" \";\\n                }else if(ch == \\'&\\'){\\n                    for(int i=1;i<v.size();i++){\\n                        bool f=false;\\n                        if(v[i] == \\'t\\') f = true;\\n                        flag &= f;\\n                    }\\n                    char fl = flag==false ? \\'f\\' : \\'t\\';\\n                    s.push(fl);\\n                    cout<<flag<<\" \";\\n                }else if(ch == \\'|\\'){\\n                    for(int i=1;i<v.size();i++){\\n                        bool f=false;\\n                        if(v[i] == \\'t\\') f = true;\\n                        flag |= f;\\n                    }\\n                    char fl = flag==false ? \\'f\\' : \\'t\\';\\n                    s.push(fl);\\n                    cout<<flag<<\" \";\\n                }\\n                v.clear();\\n            }\\n            else if(exp[i] != \\',\\'){\\n                s.push(exp[i]);\\n            }\\n        }\\n        return flag;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3747468,
                "title": "python-simple-solution-to-split-the-input-into-boolean-expressions-and-evaluate-them-recursively",
                "content": "# Approach\\nEvaluating boolean expressions is straight forward if we can split the string into boolean expressions.\\nString.split is not helpful and can result in bugs if we have nested expressions. We have to split the string at the point where open bracket count is 0. Keep a counter and increment it for every \"(\" and decrement it for every \")\" seen so far. If we see a \",\" and the bracket count is 0, split the string\\nUse the parent method to recursive evaluate the sub_expressions.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nfrom functools import reduce\\nimport operator as op\\n\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        \\n        def child_expressions(parent_expression):\\n            l = len(parent_expression)\\n            child_expression = parent_expression[2: l-1]\\n\\n            br_count = 0\\n            result = []\\n            cur_expression = \"\"\\n            for ch in child_expression:\\n                if ch == \\'(\\':\\n                    br_count += 1\\n                elif ch == \\')\\':\\n                    br_count -= 1\\n                elif ch == \\',\\':\\n                    if br_count == 0:\\n                        result.append(cur_expression)\\n                        cur_expression = \"\"\\n                        continue\\n                cur_expression += ch\\n            if cur_expression:\\n                result.append(cur_expression)\\n            return result\\n\\n\\n        if expression == \\'t\\':\\n            return True\\n        elif expression == \\'f\\':\\n            return False\\n        elif expression.startswith(\"!\"):\\n            l = len(expression)\\n            return not self.parseBoolExpr(expression[2:l-1])\\n        elif expression.startswith(\"&\"):\\n            return reduce(op.iand, map(self.parseBoolExpr, child_expressions(expression)))\\n        elif expression.startswith(\"|\"):\\n            return reduce(op.ior,  map(self.parseBoolExpr, child_expressions(expression)))\\n        else:\\n            return False\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom functools import reduce\\nimport operator as op\\n\\nclass Solution:\\n    def parseBoolExpr(self, expression: str) -> bool:\\n        \\n        def child_expressions(parent_expression):\\n            l = len(parent_expression)\\n            child_expression = parent_expression[2: l-1]\\n\\n            br_count = 0\\n            result = []\\n            cur_expression = \"\"\\n            for ch in child_expression:\\n                if ch == \\'(\\':\\n                    br_count += 1\\n                elif ch == \\')\\':\\n                    br_count -= 1\\n                elif ch == \\',\\':\\n                    if br_count == 0:\\n                        result.append(cur_expression)\\n                        cur_expression = \"\"\\n                        continue\\n                cur_expression += ch\\n            if cur_expression:\\n                result.append(cur_expression)\\n            return result\\n\\n\\n        if expression == \\'t\\':\\n            return True\\n        elif expression == \\'f\\':\\n            return False\\n        elif expression.startswith(\"!\"):\\n            l = len(expression)\\n            return not self.parseBoolExpr(expression[2:l-1])\\n        elif expression.startswith(\"&\"):\\n            return reduce(op.iand, map(self.parseBoolExpr, child_expressions(expression)))\\n        elif expression.startswith(\"|\"):\\n            return reduce(op.ior,  map(self.parseBoolExpr, child_expressions(expression)))\\n        else:\\n            return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744192,
                "title": "100-faster-stack-easy-to-understand-expression-evaluation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n        stack<char> s1;\\n        stack<char> s2;\\n        for(char c : expression){\\n            if(c == \\',\\') continue;\\n            if(c == \\'!\\' || c == \\'&\\' || c== \\'|\\'){\\n                s2.push(c);\\n            }\\n            else if(c != \\')\\'){\\n                s1.push(c);\\n            }\\n            else{\\n                while(s2.empty() == false){\\n                   char c1 = s1.top();\\n                   s1.pop();\\n                   char c2 = s1.top();\\n                   s1.pop();\\n                   if(c2 == \\'(\\'){\\n                       if(s2.top() == \\'!\\'){\\n                           s2.pop();\\n                           if(c1 == \\'f\\') s1.push(\\'t\\');\\n                           else s1.push(\\'f\\');\\n                       }\\n                       else{\\n                           s2.pop();\\n                           s1.push(c1);\\n                       } \\n                       break;\\n                   }\\n                   else{\\n                       if(s2.top() == \\'&\\'){\\n                           bool b1 = c1 == \\'t\\' ? true : false;\\n                           bool b2 = c2 == \\'t\\' ? true : false;\\n                           bool b3 = b1&b2;\\n                           if(b3 == false) s1.push(\\'f\\');\\n                           else s1.push(\\'t\\');\\n                       }\\n                       if(s2.top() == \\'|\\'){\\n                           bool b1 = c1 == \\'t\\' ? true : false;\\n                           bool b2 = c2 == \\'t\\' ? true : false;\\n                           bool b3 = b1|b2;\\n                           if(b3 == false) s1.push(\\'f\\');\\n                           else s1.push(\\'t\\');\\n                       }\\n                   }\\n                }\\n            }\\n        }\\n        if(s1.top() == \\'t\\') return true;\\n        else return false;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n        stack<char> s1;\\n        stack<char> s2;\\n        for(char c : expression){\\n            if(c == \\',\\') continue;\\n            if(c == \\'!\\' || c == \\'&\\' || c== \\'|\\'){\\n                s2.push(c);\\n            }\\n            else if(c != \\')\\'){\\n                s1.push(c);\\n            }\\n            else{\\n                while(s2.empty() == false){\\n                   char c1 = s1.top();\\n                   s1.pop();\\n                   char c2 = s1.top();\\n                   s1.pop();\\n                   if(c2 == \\'(\\'){\\n                       if(s2.top() == \\'!\\'){\\n                           s2.pop();\\n                           if(c1 == \\'f\\') s1.push(\\'t\\');\\n                           else s1.push(\\'f\\');\\n                       }\\n                       else{\\n                           s2.pop();\\n                           s1.push(c1);\\n                       } \\n                       break;\\n                   }\\n                   else{\\n                       if(s2.top() == \\'&\\'){\\n                           bool b1 = c1 == \\'t\\' ? true : false;\\n                           bool b2 = c2 == \\'t\\' ? true : false;\\n                           bool b3 = b1&b2;\\n                           if(b3 == false) s1.push(\\'f\\');\\n                           else s1.push(\\'t\\');\\n                       }\\n                       if(s2.top() == \\'|\\'){\\n                           bool b1 = c1 == \\'t\\' ? true : false;\\n                           bool b2 = c2 == \\'t\\' ? true : false;\\n                           bool b3 = b1|b2;\\n                           if(b3 == false) s1.push(\\'f\\');\\n                           else s1.push(\\'t\\');\\n                       }\\n                   }\\n                }\\n            }\\n        }\\n        if(s1.top() == \\'t\\') return true;\\n        else return false;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736770,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public void split(String x, ArrayList<String> arr){\\n        \\n        if(x.length() == 0){\\n            return;\\n        }\\n        if(x.startsWith(\"&\") || x.startsWith(\"|\") || x.startsWith(\"!\")){\\n            int open = 1;\\n            int charIndex = 2;\\n            while(open!=0){\\n                if(x.charAt(charIndex) == \\')\\'){\\n                    open--;\\n                }\\n                if(x.charAt(charIndex) == \\'(\\'){\\n                    open++;\\n                }   \\n\\n                charIndex++;\\n\\n            }\\n            arr.add(x.substring(0, charIndex));\\n            if(x.length() > charIndex + 1){\\n                split(x.substring(charIndex + 1), arr);\\n            }\\n        }\\n        else{\\n            arr.add(x.substring(0,1));\\n            if(x.length() > 2){\\n                split(x.substring(2), arr);\\n            }\\n            \\n        }\\n\\n    }\\n    public boolean parseBoolExpr(String expression) {\\n        \\n        if(expression.length() == 1){\\n            if(expression.charAt(0) == \\'f\\'){\\n                return false;\\n            }\\n            return true;\\n        }\\n\\n        if(expression.startsWith(\"&\")){\\n            expression = expression.substring(2,expression.length() - 1);\\n            ArrayList<String> arr = new ArrayList<>();\\n            split(expression, arr);\\n            for(String s : arr){\\n                boolean x = parseBoolExpr(s);\\n                if(!x){\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n        else if(expression.startsWith(\"|\")){\\n            expression = expression.substring(2,expression.length() - 1);\\n            ArrayList<String> arr = new ArrayList<>();\\n            split(expression, arr);\\n            // System.out.println(arr);\\n            for(String s : arr){\\n                boolean x = parseBoolExpr(s);\\n                if(x){\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        else{\\n            expression = expression.substring(2,expression.length() - 1);\\n            \\n            boolean x = parseBoolExpr(expression);\\n            return !x;\\n\\n        }\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public void split(String x, ArrayList<String> arr){\\n        \\n        if(x.length() == 0){\\n            return;\\n        }\\n        if(x.startsWith(\"&\") || x.startsWith(\"|\") || x.startsWith(\"!\")){\\n            int open = 1;\\n            int charIndex = 2;\\n            while(open!=0){\\n                if(x.charAt(charIndex) == \\')\\'){\\n                    open--;\\n                }\\n                if(x.charAt(charIndex) == \\'(\\'){\\n                    open++;\\n                }   \\n\\n                charIndex++;\\n\\n            }\\n            arr.add(x.substring(0, charIndex));\\n            if(x.length() > charIndex + 1){\\n                split(x.substring(charIndex + 1), arr);\\n            }\\n        }\\n        else{\\n            arr.add(x.substring(0,1));\\n            if(x.length() > 2){\\n                split(x.substring(2), arr);\\n            }\\n            \\n        }\\n\\n    }\\n    public boolean parseBoolExpr(String expression) {\\n        \\n        if(expression.length() == 1){\\n            if(expression.charAt(0) == \\'f\\'){\\n                return false;\\n            }\\n            return true;\\n        }\\n\\n        if(expression.startsWith(\"&\")){\\n            expression = expression.substring(2,expression.length() - 1);\\n            ArrayList<String> arr = new ArrayList<>();\\n            split(expression, arr);\\n            for(String s : arr){\\n                boolean x = parseBoolExpr(s);\\n                if(!x){\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n        else if(expression.startsWith(\"|\")){\\n            expression = expression.substring(2,expression.length() - 1);\\n            ArrayList<String> arr = new ArrayList<>();\\n            split(expression, arr);\\n            // System.out.println(arr);\\n            for(String s : arr){\\n                boolean x = parseBoolExpr(s);\\n                if(x){\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        else{\\n            expression = expression.substring(2,expression.length() - 1);\\n            \\n            boolean x = parseBoolExpr(expression);\\n            return !x;\\n\\n        }\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735399,
                "title": "easy-c-solution-using-stack-with-approach-explained",
                "content": "# Intuition\\nAs we need to evaluate each expressions inside the brackets and eventually come out. So we will use stack.\\n\\n# Approach\\nWe will take a stack and keep pushing the values inside it till we get an closing bracket i.e \\')\\'. The  moment we got this then we will pop out all of the characters and store it in a vector for evaluating. We will pop out till we encounter an opening bracket i.e \\'(\\'.\\n\\nNow that we have got our vector to work then we will check if st.top() is \\'&\\' or \\'|\\' or \\'!\\'. According to that we will do our operation.\\n\\nWhen it is \\'&\\' then we know if any of them is false then we return false else return true. Thats what we have done in evaland function.\\n\\nWhen it is \\'|\\' then we know if any of them is true then we return true else return false. Thats what we have done in evalor function.\\n\\nWhen it is \\'!\\' then we know if inside it is false we return true and vice versa. Thats what we have done in evalnot function.\\n\\nAfter evaluating everything we keep pushing the evaluated values inside stack to continue the operation.\\n\\nAt last when every operation is done then what remains in stack is the ans Hence returning the st.top().\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void evaland(stack<char> &st, vector<char> &f){\\n        int cnt=0;\\n        for(auto it: f){\\n            if(it==\\'f\\'){\\n                st.pop();\\n                st.push(\\'f\\');\\n                cnt=1;\\n                break;\\n            }\\n        }\\n        if(cnt==0){\\n            st.pop();\\n            st.push(\\'t\\');\\n        }\\n    }\\n\\n    void evalor(stack<char> &st, vector<char> &f){\\n        int cnt=0;\\n        for(auto it: f){\\n            if(it==\\'t\\'){\\n                st.pop();\\n                st.push(\\'t\\');\\n                cnt=1;\\n                break;\\n            }\\n        }\\n        if(cnt==0){\\n            st.pop();\\n            st.push(\\'f\\');\\n        }\\n    }\\n\\n    void evalnot(stack<char> &st, vector<char> &f){\\n        if(f[0]==\\'t\\') st.push(\\'f\\');\\n        if(f[0]==\\'f\\') st.push(\\'t\\');\\n    }\\n\\n    bool parseBoolExpr(string s) {\\n        int n=s.size();\\n        stack<char> st;\\n        for(int i=0; i<n; i++){\\n            st.push(s[i]);\\n            if(st.top()==\\')\\'){\\n                vector<char> f;\\n                st.pop();\\n                while(st.top()!=\\'(\\'){\\n                    if(st.top()==\\'t\\' || st.top()==\\'f\\'){\\n                        f.push_back(st.top());\\n                    }\\n                    st.pop();\\n                }\\n                st.pop();\\n                if(st.top()==\\'&\\'){\\n                    evaland(st, f);  \\n                }\\n\\n                if(st.top()==\\'|\\'){\\n                    evalor(st, f);\\n                }\\n\\n                if(st.top()==\\'!\\'){\\n                    evalnot(st, f);\\n                }\\n            }\\n        }\\n        if(st.top()==\\'t\\') return true;\\n        return false;\\n    }\\n};\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void evaland(stack<char> &st, vector<char> &f){\\n        int cnt=0;\\n        for(auto it: f){\\n            if(it==\\'f\\'){\\n                st.pop();\\n                st.push(\\'f\\');\\n                cnt=1;\\n                break;\\n            }\\n        }\\n        if(cnt==0){\\n            st.pop();\\n            st.push(\\'t\\');\\n        }\\n    }\\n\\n    void evalor(stack<char> &st, vector<char> &f){\\n        int cnt=0;\\n        for(auto it: f){\\n            if(it==\\'t\\'){\\n                st.pop();\\n                st.push(\\'t\\');\\n                cnt=1;\\n                break;\\n            }\\n        }\\n        if(cnt==0){\\n            st.pop();\\n            st.push(\\'f\\');\\n        }\\n    }\\n\\n    void evalnot(stack<char> &st, vector<char> &f){\\n        if(f[0]==\\'t\\') st.push(\\'f\\');\\n        if(f[0]==\\'f\\') st.push(\\'t\\');\\n    }\\n\\n    bool parseBoolExpr(string s) {\\n        int n=s.size();\\n        stack<char> st;\\n        for(int i=0; i<n; i++){\\n            st.push(s[i]);\\n            if(st.top()==\\')\\'){\\n                vector<char> f;\\n                st.pop();\\n                while(st.top()!=\\'(\\'){\\n                    if(st.top()==\\'t\\' || st.top()==\\'f\\'){\\n                        f.push_back(st.top());\\n                    }\\n                    st.pop();\\n                }\\n                st.pop();\\n                if(st.top()==\\'&\\'){\\n                    evaland(st, f);  \\n                }\\n\\n                if(st.top()==\\'|\\'){\\n                    evalor(st, f);\\n                }\\n\\n                if(st.top()==\\'!\\'){\\n                    evalnot(st, f);\\n                }\\n            }\\n        }\\n        if(st.top()==\\'t\\') return true;\\n        return false;\\n    }\\n};\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3727972,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n\\n       stack<char>st1;\\n       stack<char>st2;\\n       bool ans=true;\\n\\n       for(int i=0;i<expression.length();i++){\\n\\n         if(expression[i]!=\\')\\'){\\n             st1.push(expression[i]);\\n         }else{\\n\\n             while(st1.top()!=\\'(\\'){\\n                 char ch=st1.top();\\n                  st1.pop();\\n\\n                 if(ch==\\'t\\'){\\n                     st2.push(true);\\n                 }else if(ch==\\'f\\'){\\n                     st2.push(false);\\n                 }\\n                \\n             }\\n\\n             if(!st1.empty()){\\n                 st1.pop();\\n\\n                 if(!st1.empty()){\\n                    char op = st1.top();\\n                    st1.pop();\\n                    bool check=true;\\n                    if(!st2.empty()){\\n                     check=st2.top();\\n                    st2.pop();\\n                    }\\n\\n                    while(!st2.empty()){\\n                        bool val = st2.top();\\n                        st2.pop();\\n                       \\n                        if(op==\\'!\\'){\\n                            check = !val; \\n                        } \\n                        else if(op==\\'&\\'){\\n                           check =check & val;\\n                        }else{\\n                            check = check | val;\\n                        }\\n                         \\n                    }\\n                    if(op==\\'!\\'){\\n                        check =!check;\\n                    }\\n                    st1.push(check==true?\\'t\\':\\'f\\');\\n                 }\\n             }\\n\\n         }\\n\\n\\n       }\\n      \\n      if(!st1.empty()){\\n          ans =st1.top()==\\'t\\'?true:false;\\n      }\\n\\n      return ans;\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string expression) {\\n\\n       stack<char>st1;\\n       stack<char>st2;\\n       bool ans=true;\\n\\n       for(int i=0;i<expression.length();i++){\\n\\n         if(expression[i]!=\\')\\'){\\n             st1.push(expression[i]);\\n         }else{\\n\\n             while(st1.top()!=\\'(\\'){\\n                 char ch=st1.top();\\n                  st1.pop();\\n\\n                 if(ch==\\'t\\'){\\n                     st2.push(true);\\n                 }else if(ch==\\'f\\'){\\n                     st2.push(false);\\n                 }\\n                \\n             }\\n\\n             if(!st1.empty()){\\n                 st1.pop();\\n\\n                 if(!st1.empty()){\\n                    char op = st1.top();\\n                    st1.pop();\\n                    bool check=true;\\n                    if(!st2.empty()){\\n                     check=st2.top();\\n                    st2.pop();\\n                    }\\n\\n                    while(!st2.empty()){\\n                        bool val = st2.top();\\n                        st2.pop();\\n                       \\n                        if(op==\\'!\\'){\\n                            check = !val; \\n                        } \\n                        else if(op==\\'&\\'){\\n                           check =check & val;\\n                        }else{\\n                            check = check | val;\\n                        }\\n                         \\n                    }\\n                    if(op==\\'!\\'){\\n                        check =!check;\\n                    }\\n                    st1.push(check==true?\\'t\\':\\'f\\');\\n                 }\\n             }\\n\\n         }\\n\\n\\n       }\\n      \\n      if(!st1.empty()){\\n          ans =st1.top()==\\'t\\'?true:false;\\n      }\\n\\n      return ans;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690053,
                "title": "simple-cpp-solution-using-two-stacks",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    char calculate(char expr,char c1,char c2){\\n        int t1 = c1==\\'t\\' ? 1 : 0;\\n        int t2 = c2==\\'t\\' ? 1 : 0;\\n        int ans;\\n        if(expr==\\'|\\'){\\n            ans = (t1|t2);\\n        }\\n        else if(expr==\\'&\\'){\\n            ans = (t1&t2);\\n        }\\n        return ans==1 ? \\'t\\' : \\'f\\';\\n    }\\npublic:\\n    bool parseBoolExpr(string ex) {\\n        stack<char> st1,st2;\\n        for(int i=0; i<ex.length(); i++){\\n            if(ex[i]==\\'|\\' || ex[i]==\\'&\\' || ex[i]==\\'!\\'){\\n                st1.push(ex[i]);\\n            }\\n            else if(ex[i]!=\\')\\' && ex[i]!=\\',\\'){\\n                st2.push(ex[i]);\\n            }\\n            else if(ex[i]==\\')\\'){\\n                char ch = st1.top();\\n                st1.pop();\\n                char ch2 = st2.top();\\n                st2.pop();\\n                while(st2.size() && st2.top()!=\\'(\\'){\\n                    int ch3 = st2.top();\\n                    ch2 = calculate(ch,ch2,ch3);\\n                    st2.pop();\\n                }\\n                if(st2.size()){\\n                    st2.pop();\\n                }\\n                if(ch==\\'!\\'){\\n                    ch2 = ch2==\\'t\\' ? \\'f\\' : \\'t\\';\\n                }\\n                st2.push(ch2);\\n            }\\n        }\\n        if(st2.top()==\\'t\\'){\\n            return 1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    char calculate(char expr,char c1,char c2){\\n        int t1 = c1==\\'t\\' ? 1 : 0;\\n        int t2 = c2==\\'t\\' ? 1 : 0;\\n        int ans;\\n        if(expr==\\'|\\'){\\n            ans = (t1|t2);\\n        }\\n        else if(expr==\\'&\\'){\\n            ans = (t1&t2);\\n        }\\n        return ans==1 ? \\'t\\' : \\'f\\';\\n    }\\npublic:\\n    bool parseBoolExpr(string ex) {\\n        stack<char> st1,st2;\\n        for(int i=0; i<ex.length(); i++){\\n            if(ex[i]==\\'|\\' || ex[i]==\\'&\\' || ex[i]==\\'!\\'){\\n                st1.push(ex[i]);\\n            }\\n            else if(ex[i]!=\\')\\' && ex[i]!=\\',\\'){\\n                st2.push(ex[i]);\\n            }\\n            else if(ex[i]==\\')\\'){\\n                char ch = st1.top();\\n                st1.pop();\\n                char ch2 = st2.top();\\n                st2.pop();\\n                while(st2.size() && st2.top()!=\\'(\\'){\\n                    int ch3 = st2.top();\\n                    ch2 = calculate(ch,ch2,ch3);\\n                    st2.pop();\\n                }\\n                if(st2.size()){\\n                    st2.pop();\\n                }\\n                if(ch==\\'!\\'){\\n                    ch2 = ch2==\\'t\\' ? \\'f\\' : \\'t\\';\\n                }\\n                st2.push(ch2);\\n            }\\n        }\\n        if(st2.top()==\\'t\\'){\\n            return 1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683477,
                "title": "simple-straight-forward",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string exp) {\\n        stack<char> st , op;\\n\\n        for(int i=0;i<exp.length();i++) {\\n            if(exp[i] == \\',\\') continue;\\n            if(exp[i] == \\'&\\' || exp[i] == \\'|\\' || exp[i] == \\'!\\') {\\n                op.push(exp[i]);\\n            }\\n            else if(exp[i] == \\'(\\') {\\n                st.push(exp[i]);\\n            }\\n            else if(exp[i] == \\'t\\') {\\n                st.push(\\'1\\');\\n            }\\n            else if(exp[i] == \\'f\\') {\\n                st.push(\\'0\\');\\n            }\\n            else {    // closing bracket\\n                char curr_op = op.top();\\n                op.pop();\\n                int num = -1;\\n                while(!st.empty() && st.top() != \\'(\\') {\\n                    if(curr_op == \\'!\\') num = !(st.top()-\\'0\\');     // \\'!\\' is single input operator\\n                    else if(num == -1) num = st.top()-\\'0\\';\\n                    else {\\n                        if(curr_op == \\'&\\') num &= (st.top()-\\'0\\');\\n                        if(curr_op == \\'|\\') num |= (st.top()-\\'0\\');\\n                    }\\n                    st.pop();\\n                }\\n                st.pop();\\n                if(num != -1) st.push(num+\\'0\\');\\n            }\\n        }\\n        \\n        if(st.top()==\\'1\\') return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string exp) {\\n        stack<char> st , op;\\n\\n        for(int i=0;i<exp.length();i++) {\\n            if(exp[i] == \\',\\') continue;\\n            if(exp[i] == \\'&\\' || exp[i] == \\'|\\' || exp[i] == \\'!\\') {\\n                op.push(exp[i]);\\n            }\\n            else if(exp[i] == \\'(\\') {\\n                st.push(exp[i]);\\n            }\\n            else if(exp[i] == \\'t\\') {\\n                st.push(\\'1\\');\\n            }\\n            else if(exp[i] == \\'f\\') {\\n                st.push(\\'0\\');\\n            }\\n            else {    // closing bracket\\n                char curr_op = op.top();\\n                op.pop();\\n                int num = -1;\\n                while(!st.empty() && st.top() != \\'(\\') {\\n                    if(curr_op == \\'!\\') num = !(st.top()-\\'0\\');     // \\'!\\' is single input operator\\n                    else if(num == -1) num = st.top()-\\'0\\';\\n                    else {\\n                        if(curr_op == \\'&\\') num &= (st.top()-\\'0\\');\\n                        if(curr_op == \\'|\\') num |= (st.top()-\\'0\\');\\n                    }\\n                    st.pop();\\n                }\\n                st.pop();\\n                if(num != -1) st.push(num+\\'0\\');\\n            }\\n        }\\n        \\n        if(st.top()==\\'1\\') return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3680037,
                "title": "full-smooth-solution-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool f_not(const string& s,int& i){\\n        i+=2;\\n        auto ret = f(s,i);\\n        i++;\\n        return !ret;\\n    }\\n    \\n    bool f_and(const string& s,int& i){\\n        i+=2;\\n        bool ret = true;\\n        ret &= f(s,i);\\n        while(s[i]!=\\')\\'){\\n            i++;\\n            ret &= f(s,i);\\n        }\\n        i++;\\n        return ret;\\n    }\\n    \\n    bool f_or(const string& s,int& i){\\n        i+=2;\\n        bool ret = false;\\n        ret |= f(s,i);\\n        while(s[i]!=\\')\\'){\\n            i++;\\n            ret |= f(s,i);\\n        }\\n        i++;\\n        return ret;\\n    }\\n    \\n    bool f(const string& s, int& i){\\n        if(s[i] == \\'t\\'){\\n            i++;\\n            return true;\\n        } else if(s[i] == \\'f\\'){\\n            i++;\\n            return false;\\n        } else if(s[i] == \\'!\\'){\\n            return f_not(s,i);\\n        } else if(s[i] == \\'&\\'){\\n            return f_and(s,i);\\n        } return f_or(s,i);\\n    }\\n    bool parseBoolExpr(string expression) {\\n        int i = 0;\\n        return f(expression,i);\\n    }\\n};\\n```\\nUpvote if it helps\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool f_not(const string& s,int& i){\\n        i+=2;\\n        auto ret = f(s,i);\\n        i++;\\n        return !ret;\\n    }\\n    \\n    bool f_and(const string& s,int& i){\\n        i+=2;\\n        bool ret = true;\\n        ret &= f(s,i);\\n        while(s[i]!=\\')\\'){\\n            i++;\\n            ret &= f(s,i);\\n        }\\n        i++;\\n        return ret;\\n    }\\n    \\n    bool f_or(const string& s,int& i){\\n        i+=2;\\n        bool ret = false;\\n        ret |= f(s,i);\\n        while(s[i]!=\\')\\'){\\n            i++;\\n            ret |= f(s,i);\\n        }\\n        i++;\\n        return ret;\\n    }\\n    \\n    bool f(const string& s, int& i){\\n        if(s[i] == \\'t\\'){\\n            i++;\\n            return true;\\n        } else if(s[i] == \\'f\\'){\\n            i++;\\n            return false;\\n        } else if(s[i] == \\'!\\'){\\n            return f_not(s,i);\\n        } else if(s[i] == \\'&\\'){\\n            return f_and(s,i);\\n        } return f_or(s,i);\\n    }\\n    bool parseBoolExpr(string expression) {\\n        int i = 0;\\n        return f(expression,i);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3675851,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def parseBoolExpr(expression: String): Boolean = {\\n      val stack = scala.collection.mutable.Stack[Char]()\\n      for (c <- expression) \\n        if (c == \\')\\') {\\n          val seen = scala.collection.mutable.Set[Char]()\\n          while (stack.top != \\'(\\') seen += stack.pop()\\n          stack.pop()\\n          val operator = stack.pop()\\n          if (operator == \\'!\\') stack.push(if (seen.head == \\'t\\') \\'f\\' else \\'t\\')\\n          else if (operator == \\'&\\') stack.push(if (seen.contains(\\'f\\')) \\'f\\' else \\'t\\')\\n          else if (operator == \\'|\\') stack.push(if (seen.contains(\\'t\\')) \\'t\\' else \\'f\\')\\n        } else if (c != \\',\\') stack.push(c)\\n      stack.top == \\'t\\'\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def parseBoolExpr(expression: String): Boolean = {\\n      val stack = scala.collection.mutable.Stack[Char]()\\n      for (c <- expression) \\n        if (c == \\')\\') {\\n          val seen = scala.collection.mutable.Set[Char]()\\n          while (stack.top != \\'(\\') seen += stack.pop()\\n          stack.pop()\\n          val operator = stack.pop()\\n          if (operator == \\'!\\') stack.push(if (seen.head == \\'t\\') \\'f\\' else \\'t\\')\\n          else if (operator == \\'&\\') stack.push(if (seen.contains(\\'f\\')) \\'f\\' else \\'t\\')\\n          else if (operator == \\'|\\') stack.push(if (seen.contains(\\'t\\')) \\'t\\' else \\'f\\')\\n        } else if (c != \\',\\') stack.push(c)\\n      stack.top == \\'t\\'\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3672517,
                "title": "java-easy-to-understand-time-complexity-o-n-space-complexity-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimilar apporach to solve this problem is that using evalutate expression in stack.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimple follow logical gates property and count no. of true and false:\\n\\nLike in \\n1. Logical OR gate: if one true is present then resut is always true\\n2. Logical AND gate if one false is present then result is always false\\n1. Logical NOT gate: It is apply only one variable and the invented  value of input like input : true -> false / false -> true\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nDepends upon the size of stack --> O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nDepends upon the size of stack --> O(N)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        Stack<Character> st = new Stack<>();\\n        boolean ans = true;\\n        int count_True = 0 , count_False = 0;\\n        for(int i=0;i<expression.length();i++){\\n            if(expression.charAt(i)==\\')\\'){\\n                count_True = 0;\\n                count_False = 0;\\n                while(!st.empty()){\\n                    char ch = st.pop();\\n                    if(ch==\\'!\\'||ch==\\'|\\'||ch==\\'&\\'){\\n                        switch(ch){\\n                            case \\'&\\':\\n                                ans = count_False > 0 && count_True>=0 ? false : true;\\n                                break;\\n                            case \\'|\\':\\n                               ans = count_False >= 0 && count_True>0 ? true : false;\\n                               break;\\n                            default:\\n                               ans = count_False > 0 ? true : false;\\n                               break;\\n                        }\\n                        ch = ans ? \\'t\\' : \\'f\\';\\n                        st.push(ch);\\n                        break;\\n                    }\\n                    else{\\n                        if(ch==\\'t\\'){\\n                            ++count_True;\\n                        }\\n                        else{\\n                            if(ch==\\'f\\') ++count_False;\\n                        }\\n                    }\\n                }\\n            }\\n            else{\\n                st.push(expression.charAt(i));\\n            }\\n        }\\n        return st.peek()==\\'t\\' ? true:false;\\n    }\\n}\\n```\\n# **Please up vote for me!!!!**",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        Stack<Character> st = new Stack<>();\\n        boolean ans = true;\\n        int count_True = 0 , count_False = 0;\\n        for(int i=0;i<expression.length();i++){\\n            if(expression.charAt(i)==\\')\\'){\\n                count_True = 0;\\n                count_False = 0;\\n                while(!st.empty()){\\n                    char ch = st.pop();\\n                    if(ch==\\'!\\'||ch==\\'|\\'||ch==\\'&\\'){\\n                        switch(ch){\\n                            case \\'&\\':\\n                                ans = count_False > 0 && count_True>=0 ? false : true;\\n                                break;\\n                            case \\'|\\':\\n                               ans = count_False >= 0 && count_True>0 ? true : false;\\n                               break;\\n                            default:\\n                               ans = count_False > 0 ? true : false;\\n                               break;\\n                        }\\n                        ch = ans ? \\'t\\' : \\'f\\';\\n                        st.push(ch);\\n                        break;\\n                    }\\n                    else{\\n                        if(ch==\\'t\\'){\\n                            ++count_True;\\n                        }\\n                        else{\\n                            if(ch==\\'f\\') ++count_False;\\n                        }\\n                    }\\n                }\\n            }\\n            else{\\n                st.push(expression.charAt(i));\\n            }\\n        }\\n        return st.peek()==\\'t\\' ? true:false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3660685,
                "title": "easy-java-solution-using-stack",
                "content": "Refer this video for the explanation : \\n\\n\\nhttps://youtu.be/lYw86z7Astg\\n\\n\\nPS: This video is not created by me. I understood the concept of this problem from this video and wrote this code by myself. Maybe it could help you as well.\\n```\\nclass Solution {\\n\\n    public char find(boolean hasTrue, boolean hasFalse, char op){\\n        if(op == \\'!\\') return hasTrue? \\'f\\' : \\'t\\';\\n        else if(op == \\'|\\') return hasTrue? \\'t\\' : \\'f\\';\\n        else if(op == \\'&\\') return hasFalse? \\'f\\' : \\'t\\';\\n        return \\'a\\';\\n    }\\n\\n    public boolean parseBoolExpr(String expression) {\\n        Stack<Character> st = new Stack<>();\\n        char[] exp = expression.toCharArray();\\n        for(char ch : exp){\\n            if(ch == \\',\\') continue;\\n            if(ch != \\')\\') st.push(ch);\\n            else{\\n                boolean hasTrue = false;\\n                boolean hasFalse = false;\\n                while(!st.isEmpty() && st.peek() != \\'(\\'){\\n                    char top = st.pop();\\n                    if(top == \\'t\\') hasTrue = true;\\n                    else if(top == \\'f\\') hasFalse = true;\\n                }\\n                st.pop(); // Removing the opening bracket\\n                char op = st.pop(); // Operator\\n                st.push(find(hasTrue,hasFalse,op));\\n            }\\n        }\\n        return st.peek() == \\'t\\';\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n\\n    public char find(boolean hasTrue, boolean hasFalse, char op){\\n        if(op == \\'!\\') return hasTrue? \\'f\\' : \\'t\\';\\n        else if(op == \\'|\\') return hasTrue? \\'t\\' : \\'f\\';\\n        else if(op == \\'&\\') return hasFalse? \\'f\\' : \\'t\\';\\n        return \\'a\\';\\n    }\\n\\n    public boolean parseBoolExpr(String expression) {\\n        Stack<Character> st = new Stack<>();\\n        char[] exp = expression.toCharArray();\\n        for(char ch : exp){\\n            if(ch == \\',\\') continue;\\n            if(ch != \\')\\') st.push(ch);\\n            else{\\n                boolean hasTrue = false;\\n                boolean hasFalse = false;\\n                while(!st.isEmpty() && st.peek() != \\'(\\'){\\n                    char top = st.pop();\\n                    if(top == \\'t\\') hasTrue = true;\\n                    else if(top == \\'f\\') hasFalse = true;\\n                }\\n                st.pop(); // Removing the opening bracket\\n                char op = st.pop(); // Operator\\n                st.push(find(hasTrue,hasFalse,op));\\n            }\\n        }\\n        return st.peek() == \\'t\\';\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649608,
                "title": "c-shunting-yard-inspired-solution-beats-95-in-time",
                "content": "# Intuition\\nI inspired from the shunting yard algorithm, used to create an RPN from a correctly parsed expression\\n\\n# Approach\\nThis algorithm is inspired by the Shunting Yard Algorithm that is used to calculate the RPN of any right-parenthesized expression.  \\n\\nI use two stacks:  \\n- one that will store the operators *&*, *|*, *!*\\n- another one that will store the other tokens *f*, *t*, *(*\\nit will never contain *\\')\\'* though because of the algorithm\\'s logic (see further)\\n\\nI parse the expression character by character and fill the stacks based on the following logic:\\n- whenever i meet an operator, i push it on the operators stack\\n- whenever I meet any other token except from *\\')\\'*, I push it on the tokens stack\\n- when I meet a closing parenthesis \\')\\', it means that it is closing an operator expression that could have been &(...), |(...) or !(...). It is actually very easy to know, because based on how we pushed our operators on our op stack, it is just the last operator we pushed.\\nSo we just take the operator on top of our op stack, and we apply it to every element on top of our other stack, until we meet a left parenthesis \\'(\\'. It is the signal that we unwinded every elements that were inside our parenthesized expression. We then discard the left parenthesis and push the result of this on top of our expression stack. And we keep going\\n# Complexity\\n$$n$$ is the length of our expression\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(std::string s)\\n    {\\n        std::stack<char> ops, tokens;\\n\\n        for (int i = 0; s[i]; i++)\\n        {\\n            if (s[i] == \\'f\\' || s[i] == \\'t\\' || s[i] == \\'(\\')\\n                tokens.push(s[i]);\\n            else if (s[i] == \\'!\\' || s[i] == \\'&\\' || s[i] == \\'|\\')\\n                ops.push(s[i]);\\n            else if (s[i] == \\')\\')\\n            {\\n                bool res = (tokens.top() == \\'t\\');\\n                tokens.pop();\\n                char op = ops.top();\\n                ops.pop();\\n                if (op == \\'&\\')\\n                {\\n                    while (tokens.top() != \\'(\\')\\n                    {\\n                        res = res && (tokens.top() == \\'t\\');\\n                        tokens.pop();\\n                    }\\n                }\\n                else if (op == \\'|\\')\\n                {\\n                    while (tokens.top() != \\'(\\')\\n                    {\\n                        res = res || (tokens.top() == \\'t\\');\\n                        tokens.pop();\\n                    }\\n                }\\n                else if (op == \\'!\\')\\n                    res = !res;\\n                tokens.pop();\\n                tokens.push(res ? \\'t\\' : \\'f\\');\\n            }\\n        }\\n        return tokens.top() == \\'t\\';\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(std::string s)\\n    {\\n        std::stack<char> ops, tokens;\\n\\n        for (int i = 0; s[i]; i++)\\n        {\\n            if (s[i] == \\'f\\' || s[i] == \\'t\\' || s[i] == \\'(\\')\\n                tokens.push(s[i]);\\n            else if (s[i] == \\'!\\' || s[i] == \\'&\\' || s[i] == \\'|\\')\\n                ops.push(s[i]);\\n            else if (s[i] == \\')\\')\\n            {\\n                bool res = (tokens.top() == \\'t\\');\\n                tokens.pop();\\n                char op = ops.top();\\n                ops.pop();\\n                if (op == \\'&\\')\\n                {\\n                    while (tokens.top() != \\'(\\')\\n                    {\\n                        res = res && (tokens.top() == \\'t\\');\\n                        tokens.pop();\\n                    }\\n                }\\n                else if (op == \\'|\\')\\n                {\\n                    while (tokens.top() != \\'(\\')\\n                    {\\n                        res = res || (tokens.top() == \\'t\\');\\n                        tokens.pop();\\n                    }\\n                }\\n                else if (op == \\'!\\')\\n                    res = !res;\\n                tokens.pop();\\n                tokens.push(res ? \\'t\\' : \\'f\\');\\n            }\\n        }\\n        return tokens.top() == \\'t\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3638925,
                "title": "kotlin-using-stack-beats-100",
                "content": "# Intuition\\nSimple stack problem\\n# Approach\\nJust add all the \\'&\\' \\'|\\' \\'!\\' \\'t\\' \\'f\\' \\'(\\' to stack and perform operation when you encounter a \\')\\'. The operation you perform should replace the expression till last operation with the corresponding result. \\n# Complexity\\n- Time complexity:\\nO(N^2) - Think of a case like !(!(!(!(!(!(!(f)))))))\\n- Space complexity:\\nO(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    fun parseBoolExpr(expression: String): Boolean {\\n        val stack = mutableListOf<Char>()\\n        expression.forEachIndexed{ index, value ->\\n            if(value == \\'&\\' || value == \\'|\\' || value == \\'!\\' || value == \\'(\\' || value == \\'t\\' || value == \\'f\\'){\\n                stack.add(value)\\n            }\\n            if(value == \\')\\'){\\n                popStack(stack)\\n            }\\n        }\\n        return stack[0] == \\'t\\'\\n    }\\n\\n    fun popStack(stack: MutableList<Char>){\\n        var op = \\' \\'\\n        val expArray = mutableListOf<Char>()\\n        for (it in (stack.lastIndex downTo 0)){\\n            val e = stack.removeAt(it)\\n            if(e == \\'t\\' || e == \\'f\\') expArray.add(e)\\n            if(e == \\'&\\' || e == \\'|\\' || e == \\'!\\' ){\\n                op = e\\n                break\\n            }\\n        }\\n        stack.add(when(op){\\n            \\'&\\' -> andChars(expArray)\\n            \\'|\\' -> orChars(expArray)\\n            else -> negateChars(expArray)\\n        })\\n    }\\n\\n    fun andChars(exps: MutableList<Char>): Char {\\n        return if(exps.contains(\\'f\\'))  \\'f\\' else \\'t\\'\\n    }\\n    fun orChars(exps: MutableList<Char>): Char {\\n        return if(exps.contains(\\'t\\')) \\'t\\' else \\'f\\'\\n    }\\n    fun negateChars(exps: MutableList<Char>): Char {\\n        if(exps[0] == \\'t\\') return \\'f\\' else return \\'t\\'\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun parseBoolExpr(expression: String): Boolean {\\n        val stack = mutableListOf<Char>()\\n        expression.forEachIndexed{ index, value ->\\n            if(value == \\'&\\' || value == \\'|\\' || value == \\'!\\' || value == \\'(\\' || value == \\'t\\' || value == \\'f\\'){\\n                stack.add(value)\\n            }\\n            if(value == \\')\\'){\\n                popStack(stack)\\n            }\\n        }\\n        return stack[0] == \\'t\\'\\n    }\\n\\n    fun popStack(stack: MutableList<Char>){\\n        var op = \\' \\'\\n        val expArray = mutableListOf<Char>()\\n        for (it in (stack.lastIndex downTo 0)){\\n            val e = stack.removeAt(it)\\n            if(e == \\'t\\' || e == \\'f\\') expArray.add(e)\\n            if(e == \\'&\\' || e == \\'|\\' || e == \\'!\\' ){\\n                op = e\\n                break\\n            }\\n        }\\n        stack.add(when(op){\\n            \\'&\\' -> andChars(expArray)\\n            \\'|\\' -> orChars(expArray)\\n            else -> negateChars(expArray)\\n        })\\n    }\\n\\n    fun andChars(exps: MutableList<Char>): Char {\\n        return if(exps.contains(\\'f\\'))  \\'f\\' else \\'t\\'\\n    }\\n    fun orChars(exps: MutableList<Char>): Char {\\n        return if(exps.contains(\\'t\\')) \\'t\\' else \\'f\\'\\n    }\\n    fun negateChars(exps: MutableList<Char>): Char {\\n        if(exps[0] == \\'t\\') return \\'f\\' else return \\'t\\'\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633148,
                "title": "c-recursion-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsee the code and you can easily understand it...\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool parseor(string expression){\\n        vector<bool>v;\\n        \\n        int idx=0;\\n        while(idx<expression.length()){\\n            string temp=\"\";\\n            int cnt=0;\\n            while(idx<expression.length()){\\n                 if(  expression[idx]==\\',\\' && cnt==0)break;\\n                 if(expression[idx]==\\'(\\')cnt++;\\n                if(expression[idx]==\\')\\')cnt--;\\n                temp+=expression[idx];\\n                idx++;\\n            }\\n            cout<<temp<<endl;\\n            v.push_back(parseBoolExpr(temp));\\n            idx++;\\n        }\\n\\n        bool ans=false;\\n        for(auto x:v)ans=ans||x;\\n        return ans;\\n    }\\n    bool parseand(string expression){\\n        vector<bool>v;\\n        \\n        int idx=0;\\n        while(idx<expression.length()){\\n            string temp=\"\";\\n            int cnt=0;\\n            while(idx<expression.length()){\\n                if(  (expression[idx]==\\',\\' && cnt==0))break;\\n                if(expression[idx]==\\'(\\')cnt++;\\n                if(expression[idx]==\\')\\')cnt--;\\n                temp+=expression[idx];\\n                idx++;\\n            }\\n            cout<<temp<<endl;\\n            v.push_back(parseBoolExpr(temp));\\n            idx++;\\n        }\\n\\n        bool ans=true;\\n        for(auto x:v)ans=ans&&x;\\n        return ans;\\n    }\\n\\n    bool parseBoolExpr(string expression) {\\n        if(expression.length()==1){\\n            return expression[0]==\\'t\\'?true:false;\\n        }\\n        if(expression[0]==\\'|\\'){\\n           return parseor(expression.substr(2,expression.length()-3));\\n        }\\n        if(expression[0]==\\'&\\'){\\n           return parseand(expression.substr(2,expression.length()-3));\\n        }\\n        if(expression[0]==\\'!\\'){\\n           return !parseBoolExpr(expression.substr(2,expression.length()-3));\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseor(string expression){\\n        vector<bool>v;\\n        \\n        int idx=0;\\n        while(idx<expression.length()){\\n            string temp=\"\";\\n            int cnt=0;\\n            while(idx<expression.length()){\\n                 if(  expression[idx]==\\',\\' && cnt==0)break;\\n                 if(expression[idx]==\\'(\\')cnt++;\\n                if(expression[idx]==\\')\\')cnt--;\\n                temp+=expression[idx];\\n                idx++;\\n            }\\n            cout<<temp<<endl;\\n            v.push_back(parseBoolExpr(temp));\\n            idx++;\\n        }\\n\\n        bool ans=false;\\n        for(auto x:v)ans=ans||x;\\n        return ans;\\n    }\\n    bool parseand(string expression){\\n        vector<bool>v;\\n        \\n        int idx=0;\\n        while(idx<expression.length()){\\n            string temp=\"\";\\n            int cnt=0;\\n            while(idx<expression.length()){\\n                if(  (expression[idx]==\\',\\' && cnt==0))break;\\n                if(expression[idx]==\\'(\\')cnt++;\\n                if(expression[idx]==\\')\\')cnt--;\\n                temp+=expression[idx];\\n                idx++;\\n            }\\n            cout<<temp<<endl;\\n            v.push_back(parseBoolExpr(temp));\\n            idx++;\\n        }\\n\\n        bool ans=true;\\n        for(auto x:v)ans=ans&&x;\\n        return ans;\\n    }\\n\\n    bool parseBoolExpr(string expression) {\\n        if(expression.length()==1){\\n            return expression[0]==\\'t\\'?true:false;\\n        }\\n        if(expression[0]==\\'|\\'){\\n           return parseor(expression.substr(2,expression.length()-3));\\n        }\\n        if(expression[0]==\\'&\\'){\\n           return parseand(expression.substr(2,expression.length()-3));\\n        }\\n        if(expression[0]==\\'!\\'){\\n           return !parseBoolExpr(expression.substr(2,expression.length()-3));\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3614994,
                "title": "parsing-a-boolean-expression",
                "content": "\\n```\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        Stack<Character>st = new Stack<>();\\n        for(char ch :expression.toCharArray()){\\n            if(ch!=\\')\\')\\n            st.push(ch);\\n            else{\\n                boolean T =false ,F = false;\\n                while(st.peek()!=\\'(\\'){\\n                  char check = st.pop();\\n                  if(check==\\'f\\')\\n                    F = true;\\n                  else if(check==\\'t\\')\\n                  T = true;  \\n                }\\n                st.pop();\\n                char optr  = st.pop();\\n                if(optr==\\'&\\'){\\n                    if(F)\\n                    st.push(\\'f\\');\\n                    else\\n                    st.push(\\'t\\');\\n                }\\n                else if(optr ==\\'!\\'){\\n                   if(F)\\n                   st.push(\\'t\\');\\n                   else\\n                    st.push(\\'f\\');\\n                }\\n                else{\\n                    if(T)\\n                     st.push(\\'t\\');\\n                     else\\n                   st.push(\\'f\\');\\n                }\\n            }\\n        }\\n        return st.pop()==\\'t\\'?true:false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        Stack<Character>st = new Stack<>();\\n        for(char ch :expression.toCharArray()){\\n            if(ch!=\\')\\')\\n            st.push(ch);\\n            else{\\n                boolean T =false ,F = false;\\n                while(st.peek()!=\\'(\\'){\\n                  char check = st.pop();\\n                  if(check==\\'f\\')\\n                    F = true;\\n                  else if(check==\\'t\\')\\n                  T = true;  \\n                }\\n                st.pop();\\n                char optr  = st.pop();\\n                if(optr==\\'&\\'){\\n                    if(F)\\n                    st.push(\\'f\\');\\n                    else\\n                    st.push(\\'t\\');\\n                }\\n                else if(optr ==\\'!\\'){\\n                   if(F)\\n                   st.push(\\'t\\');\\n                   else\\n                    st.push(\\'f\\');\\n                }\\n                else{\\n                    if(T)\\n                     st.push(\\'t\\');\\n                     else\\n                   st.push(\\'f\\');\\n                }\\n            }\\n        }\\n        return st.pop()==\\'t\\'?true:false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588797,
                "title": "using-stack-only-no-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string e) {\\n        if(e.size()==1)return (e[0]==\\'t\\');\\n        stack<char>st;\\n        for(int i = 0;i<e.size();i++){\\n            if(e[i]==\\')\\'){\\n                string t;\\n                while(!st.empty() and st.top()!=\\'(\\'){\\n                    t.push_back(st.top());\\n                    st.pop();\\n                }\\n                if(!st.empty())st.pop();\\n                if(t.size()==0)continue;\\n                char op;\\n                if(!st.empty()){\\n                    op = st.top();\\n                    st.pop();\\n                }\\n                \\n                if(op==\\'!\\'){\\n                    if(t[0]==\\'0\\')st.push(\\'1\\');\\n                    else st.push(\\'0\\');\\n                }\\n                else{\\n                    while(t.size()>1){\\n                    if(op==\\'|\\'){\\n                        int x = (t[t.size()-1] - \\'0\\') | (t[t.size()-2] -\\'0\\');\\n                        t.pop_back();\\n                        t.pop_back();\\n                        t.push_back(x + \\'0\\');\\n                    }\\n                    else if(op==\\'&\\'){\\n                        int x = (int(t[t.size()-1]) - \\'0\\') & (int(t[t.size()-2]) -\\'0\\');\\n                        t.pop_back();\\n                        t.pop_back();\\n                        t.push_back(x+\\'0\\');\\n                    }\\n                  }\\n                  st.push(t[0]);\\n                }\\n                cout<<st.top();\\n            }\\n            else {\\n                if(e[i]==\\'t\\')st.push(\\'1\\');\\n                else if(e[i]==\\'f\\')st.push(\\'0\\');\\n                else if(e[i]==\\',\\')continue;\\n                else st.push(e[i]);\\n            }\\n            cout<<st.size()<<\" \";\\n        }\\n        if(st.top()==\\'0\\')return 0;\\n        else return 1;\\n        return st.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool parseBoolExpr(string e) {\\n        if(e.size()==1)return (e[0]==\\'t\\');\\n        stack<char>st;\\n        for(int i = 0;i<e.size();i++){\\n            if(e[i]==\\')\\'){\\n                string t;\\n                while(!st.empty() and st.top()!=\\'(\\'){\\n                    t.push_back(st.top());\\n                    st.pop();\\n                }\\n                if(!st.empty())st.pop();\\n                if(t.size()==0)continue;\\n                char op;\\n                if(!st.empty()){\\n                    op = st.top();\\n                    st.pop();\\n                }\\n                \\n                if(op==\\'!\\'){\\n                    if(t[0]==\\'0\\')st.push(\\'1\\');\\n                    else st.push(\\'0\\');\\n                }\\n                else{\\n                    while(t.size()>1){\\n                    if(op==\\'|\\'){\\n                        int x = (t[t.size()-1] - \\'0\\') | (t[t.size()-2] -\\'0\\');\\n                        t.pop_back();\\n                        t.pop_back();\\n                        t.push_back(x + \\'0\\');\\n                    }\\n                    else if(op==\\'&\\'){\\n                        int x = (int(t[t.size()-1]) - \\'0\\') & (int(t[t.size()-2]) -\\'0\\');\\n                        t.pop_back();\\n                        t.pop_back();\\n                        t.push_back(x+\\'0\\');\\n                    }\\n                  }\\n                  st.push(t[0]);\\n                }\\n                cout<<st.top();\\n            }\\n            else {\\n                if(e[i]==\\'t\\')st.push(\\'1\\');\\n                else if(e[i]==\\'f\\')st.push(\\'0\\');\\n                else if(e[i]==\\',\\')continue;\\n                else st.push(e[i]);\\n            }\\n            cout<<st.size()<<\" \";\\n        }\\n        if(st.top()==\\'0\\')return 0;\\n        else return 1;\\n        return st.top();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3583376,
                "title": "intuitive-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nThe typical pattern can be described as such:\\n\\none \"sign\" ```(|, &, !)```, followed by a \"```()```\", inside of which there may be \"```f```\", \"```t```\", or another ```expression```.\\n\\nWith this realization, we define a function ```boolean dp(s)``` which takes a string and generates the boolean value it represents. \\n\\n\\n\\n# Approach\\nThe first character of the string is guaranteed to be ```|``` ```&``` or ```!```. So we say char ```sign = s.charAt(0);```\\n\\nAfter the first character we traverse the string. If we see a \"```t```\" or an \"```f```\" we parse it and add to our list. Whenever we see another \"```sign```\", we know there is a nested string that needs to be decoded. \\nWe define an integer ```stack = 1 ```, which is used to indicate the layer of the parenthesis. We then move our pointer forward: any left parenthesis ```(``` will add 1 to the ```stack```; any right parenthesis ```)``` will reduce the stack by 1. When the stack is zero, it means we have reached the end of the nested string. We then subtract this string and do the recursion. \\n \\n# Note: \\n\\nThis recursion does not have an explicit \"base case\" as the actual base would the an expression that does not have any nested string. For example: ```|(t,f,t,f)```\\n\\nIf you find my solution useful, please upvote :)\\n\\n```\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        return dp(expression);\\n    }\\n\\n    boolean dp(String s){\\n\\n      char sign = s.charAt(0);\\n      List<Boolean> list = new ArrayList();\\n\\n      for(int i = 1; i<s.length(); i++){\\n          \\n          char c = s.charAt(i);\\n          if(c==\\'t\\' || c==\\'f\\') {\\n            if(c==\\'t\\') list.add(true);\\n            else if (c==\\'f\\') list.add(false);\\n          } else if(c==\\'&\\' || c==\\'|\\' ||c==\\'!\\' ){\\n            \\n            int j = i+2;\\n            int stack = 1;\\n            //!(&(f,t, !(f,t)))\\n\\n            while(stack!=0){\\n              if(s.charAt(j)==\\'(\\') stack++;\\n              else if(s.charAt(j)==\\')\\') stack--;\\n              j++;\\n            }\\n\\n            boolean sub = dp(s.substring(i, j));\\n            list.add(sub);\\n            i=j-1;\\n          }\\n          \\n      }\\n      \\n     return eval(sign, list);\\n\\n    }\\n\\n    boolean eval(char sign, List<Boolean> list){\\n\\n        boolean res = false;\\n\\n        if(sign == \\'|\\'){\\n          boolean first = false;\\n\\n          for(boolean flag: list){\\n            res|=flag;\\n          }\\n          \\n        }\\n\\n        if(sign == \\'&\\'){\\n          res = true;\\n          boolean first = true;\\n          for(boolean flag: list){\\n            res &=flag;\\n          }\\n        }\\n\\n        if(sign == \\'!\\'){\\n          return !list.get(0);\\n        }\\n\\n        return res;\\n\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```(|, &, !)```\n```()```\n```f```\n```t```\n```expression```\n```boolean dp(s)```\n```|```\n```&```\n```!```\n```sign = s.charAt(0);```\n```t```\n```f```\n```sign```\n```stack = 1 ```\n```(```\n```stack```\n```)```\n```|(t,f,t,f)```\n```\\nclass Solution {\\n    public boolean parseBoolExpr(String expression) {\\n        return dp(expression);\\n    }\\n\\n    boolean dp(String s){\\n\\n      char sign = s.charAt(0);\\n      List<Boolean> list = new ArrayList();\\n\\n      for(int i = 1; i<s.length(); i++){\\n          \\n          char c = s.charAt(i);\\n          if(c==\\'t\\' || c==\\'f\\') {\\n            if(c==\\'t\\') list.add(true);\\n            else if (c==\\'f\\') list.add(false);\\n          } else if(c==\\'&\\' || c==\\'|\\' ||c==\\'!\\' ){\\n            \\n            int j = i+2;\\n            int stack = 1;\\n            //!(&(f,t, !(f,t)))\\n\\n            while(stack!=0){\\n              if(s.charAt(j)==\\'(\\') stack++;\\n              else if(s.charAt(j)==\\')\\') stack--;\\n              j++;\\n            }\\n\\n            boolean sub = dp(s.substring(i, j));\\n            list.add(sub);\\n            i=j-1;\\n          }\\n          \\n      }\\n      \\n     return eval(sign, list);\\n\\n    }\\n\\n    boolean eval(char sign, List<Boolean> list){\\n\\n        boolean res = false;\\n\\n        if(sign == \\'|\\'){\\n          boolean first = false;\\n\\n          for(boolean flag: list){\\n            res|=flag;\\n          }\\n          \\n        }\\n\\n        if(sign == \\'&\\'){\\n          res = true;\\n          boolean first = true;\\n          for(boolean flag: list){\\n            res &=flag;\\n          }\\n        }\\n\\n        if(sign == \\'!\\'){\\n          return !list.get(0);\\n        }\\n\\n        return res;\\n\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1568231,
                "content": [
                    {
                        "username": "bluedreamer94",
                        "content": "In the problem description, it says: \\n\"&(expr1,expr2,...)\", evaluating to the logical AND of 2 or more inner expressions\"\\nand there is a corresponding statement for the OR operator.\\n\\nHowever, when I submitted my solution, I failed on this test case:\\n\"!(&(!(t),&(f),|(f)))\"\\n\\nAs you can see, there are ANDs and ORs with only 1 argument. I was able to complete my solution simply by having my code return the input value for the AND or OR of a single argument, ie AND(t) = t, OR(f) = f, etc\\n\\nIt would be good for LeetCoders if the problem statement could be corrected. Other than\\nthat I think this is a great problem btw."
                    },
                    {
                        "username": "AnujJadhav",
                        "content": "It says invalid expression for this testcase, I think they have updated the testcases."
                    },
                    {
                        "username": "ranjithreddy-31",
                        "content": "This should be labeled as Medium"
                    },
                    {
                        "username": "Msey",
                        "content": "Classic approach is to use a polish notation featuring stack"
                    }
                ]
            },
            {
                "id": 1983448,
                "content": [
                    {
                        "username": "bluedreamer94",
                        "content": "In the problem description, it says: \\n\"&(expr1,expr2,...)\", evaluating to the logical AND of 2 or more inner expressions\"\\nand there is a corresponding statement for the OR operator.\\n\\nHowever, when I submitted my solution, I failed on this test case:\\n\"!(&(!(t),&(f),|(f)))\"\\n\\nAs you can see, there are ANDs and ORs with only 1 argument. I was able to complete my solution simply by having my code return the input value for the AND or OR of a single argument, ie AND(t) = t, OR(f) = f, etc\\n\\nIt would be good for LeetCoders if the problem statement could be corrected. Other than\\nthat I think this is a great problem btw."
                    },
                    {
                        "username": "AnujJadhav",
                        "content": "It says invalid expression for this testcase, I think they have updated the testcases."
                    },
                    {
                        "username": "ranjithreddy-31",
                        "content": "This should be labeled as Medium"
                    },
                    {
                        "username": "Msey",
                        "content": "Classic approach is to use a polish notation featuring stack"
                    }
                ]
            },
            {
                "id": 1829521,
                "content": [
                    {
                        "username": "bluedreamer94",
                        "content": "In the problem description, it says: \\n\"&(expr1,expr2,...)\", evaluating to the logical AND of 2 or more inner expressions\"\\nand there is a corresponding statement for the OR operator.\\n\\nHowever, when I submitted my solution, I failed on this test case:\\n\"!(&(!(t),&(f),|(f)))\"\\n\\nAs you can see, there are ANDs and ORs with only 1 argument. I was able to complete my solution simply by having my code return the input value for the AND or OR of a single argument, ie AND(t) = t, OR(f) = f, etc\\n\\nIt would be good for LeetCoders if the problem statement could be corrected. Other than\\nthat I think this is a great problem btw."
                    },
                    {
                        "username": "AnujJadhav",
                        "content": "It says invalid expression for this testcase, I think they have updated the testcases."
                    },
                    {
                        "username": "ranjithreddy-31",
                        "content": "This should be labeled as Medium"
                    },
                    {
                        "username": "Msey",
                        "content": "Classic approach is to use a polish notation featuring stack"
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Sum Obtained of Any Permutation",
        "question_content": "<p>We have an array of integers, <code>nums</code>, and an array of <code>requests</code> where <code>requests[i] = [start<sub>i</sub>, end<sub>i</sub>]</code>. The <code>i<sup>th</sup></code> request asks for the sum of <code>nums[start<sub>i</sub>] + nums[start<sub>i</sub> + 1] + ... + nums[end<sub>i</sub> - 1] + nums[end<sub>i</sub>]</code>. Both <code>start<sub>i</sub></code> and <code>end<sub>i</sub></code> are <em>0-indexed</em>.</p>\n\n<p>Return <em>the maximum total sum of all requests <strong>among all permutations</strong> of</em> <code>nums</code>.</p>\n\n<p>Since the answer may be too large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,4,5], requests = [[1,3],[0,1]]\n<strong>Output:</strong> 19\n<strong>Explanation:</strong> One permutation of nums is [2,1,3,4,5] with the following result: \nrequests[0] -&gt; nums[1] + nums[2] + nums[3] = 1 + 3 + 4 = 8\nrequests[1] -&gt; nums[0] + nums[1] = 2 + 1 = 3\nTotal sum: 8 + 3 = 11.\nA permutation with a higher total sum is [3,5,4,2,1] with the following result:\nrequests[0] -&gt; nums[1] + nums[2] + nums[3] = 5 + 4 + 2 = 11\nrequests[1] -&gt; nums[0] + nums[1] = 3 + 5  = 8\nTotal sum: 11 + 8 = 19, which is the best that you can do.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,4,5,6], requests = [[0,1]]\n<strong>Output:</strong> 11\n<strong>Explanation:</strong> A permutation with the max total sum is [6,5,4,3,2,1] with request sums [11].</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,4,5,10], requests = [[0,2],[1,3],[1,1]]\n<strong>Output:</strong> 47\n<strong>Explanation:</strong> A permutation with the max total sum is [4,10,5,3,2,1] with request sums [19,18,10].</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i]&nbsp;&lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= requests.length &lt;=&nbsp;10<sup>5</sup></code></li>\n\t<li><code>requests[i].length == 2</code></li>\n\t<li><code>0 &lt;= start<sub>i</sub>&nbsp;&lt;= end<sub>i</sub>&nbsp;&lt;&nbsp;n</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 854206,
                "title": "java-c-python-sweep-line",
                "content": "# Intuition\\nWe want to calculate the frequency for `A[i]`.\\nAssign the big element `A[i]` to the position queried more frequently.\\n<br>\\n\\n# **Explanation**\\nFor each request `[i,j]`,\\nwe set `count[i]++` and `count[j + 1]--`,\\n\\nThen we sweep once the whole `count`,\\nwe can find the frequency for `count[i]`.\\n\\nNote that for all intervals inputs,\\nthis method should be the first intuition you come up with.\\n<br>\\n\\n# **Complexity**\\nTime `O(NlogN)` for sorting\\nSpace `O(N)`\\n<br>\\n\\n**Java:**\\n```java\\n    public int maxSumRangeQuery(int[] A, int[][] req) {\\n        long res = 0, mod = (long)1e9 + 7;\\n        int n = A.length, count[] = new int[n];\\n        for (int[] r: req) {\\n            count[r[0]] += 1;\\n            if (r[1] + 1 < n)\\n                count[r[1] + 1] -= 1;\\n        }\\n        for (int i = 1; i < n; ++i)\\n            count[i] += count[i - 1];\\n        Arrays.sort(A);\\n        Arrays.sort(count);\\n        for (int i = 0; i < n; ++i)\\n            res += (long)A[i] * count[i];\\n        return (int)(res % mod);\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    int maxSumRangeQuery(vector<int>& A, vector<vector<int>>& req) {\\n        long res = 0, mod = 1e9 + 7, n = A.size();\\n        vector<int> count(n);\\n        for (auto &r: req) {\\n            count[r[0]] += 1;\\n            if (r[1] + 1 < n)\\n                count[r[1] + 1] -= 1;\\n        }\\n        for (int i = 1; i < n; ++i)\\n            count[i] += count[i - 1];\\n        sort(begin(count), end(count));\\n        sort(begin(A), end(A));\\n        for (int i = 0; i < n; ++i)\\n            res += (long)A[i] * count[i];\\n        return res % mod;\\n    }\\n```\\n\\n**Python:**\\n```py\\n    def maxSumRangeQuery(self, A, req):\\n        n = len(A)\\n        count = [0] * (n + 1)\\n        for i, j in req:\\n            count[i] += 1\\n            count[j + 1] -= 1\\n        for i in xrange(1, n + 1):\\n            count[i] += count[i - 1]\\n        res = 0\\n        for v, c in zip(sorted(count[:-1]), sorted(A)):\\n            res += v * c\\n        return res % (10**9 + 7)\\n```\\n<br>\\n\\n# More Sweep Line Problems\\nHere are some sweep line problem that I solved.\\nI\\'ll make a summary for this method.\\nLet me know other related problems or my other related posts.\\nGood luck and have fun.\\n\\n- [253. Meeting Rooms II](https://leetcode.com/problems/meeting-rooms-ii/)\\n- [1094. Car Pooling](https://leetcode.com/problems/car-pooling/discuss/317610/JavaC++Python-Meeting-Rooms-III) \\n- [1109. Corporate Flight Bookings](https://leetcode.com/problems/corporate-flight-bookings/discuss/328856/JavaC%2B%2BPython-Straight-Forward-Solution)\\n<br>",
                "solutionTags": [],
                "code": "```java\\n    public int maxSumRangeQuery(int[] A, int[][] req) {\\n        long res = 0, mod = (long)1e9 + 7;\\n        int n = A.length, count[] = new int[n];\\n        for (int[] r: req) {\\n            count[r[0]] += 1;\\n            if (r[1] + 1 < n)\\n                count[r[1] + 1] -= 1;\\n        }\\n        for (int i = 1; i < n; ++i)\\n            count[i] += count[i - 1];\\n        Arrays.sort(A);\\n        Arrays.sort(count);\\n        for (int i = 0; i < n; ++i)\\n            res += (long)A[i] * count[i];\\n        return (int)(res % mod);\\n    }\\n```\n```cpp\\n    int maxSumRangeQuery(vector<int>& A, vector<vector<int>>& req) {\\n        long res = 0, mod = 1e9 + 7, n = A.size();\\n        vector<int> count(n);\\n        for (auto &r: req) {\\n            count[r[0]] += 1;\\n            if (r[1] + 1 < n)\\n                count[r[1] + 1] -= 1;\\n        }\\n        for (int i = 1; i < n; ++i)\\n            count[i] += count[i - 1];\\n        sort(begin(count), end(count));\\n        sort(begin(A), end(A));\\n        for (int i = 0; i < n; ++i)\\n            res += (long)A[i] * count[i];\\n        return res % mod;\\n    }\\n```\n```py\\n    def maxSumRangeQuery(self, A, req):\\n        n = len(A)\\n        count = [0] * (n + 1)\\n        for i, j in req:\\n            count[i] += 1\\n            count[j + 1] -= 1\\n        for i in xrange(1, n + 1):\\n            count[i] += count[i - 1]\\n        res = 0\\n        for v, c in zip(sorted(count[:-1]), sorted(A)):\\n            res += v * c\\n        return res % (10**9 + 7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 854149,
                "title": "c-java-o-n-log-n",
                "content": "#### Intuition\\nWe should put the largest number into the most queried position.\\n\\n#### Solution\\nWe can count how many times each position was queried using another array `cnt`. To do so in O(n), we mark the start and end of each query with `+ 1` and `- 1`, and then calculate counts for each position in one swipe.\\n\\n> You can see the picture that demonstrates this here: [1109. Corporate Flight Bookings](https://leetcode.com/problems/corporate-flight-bookings/discuss/328871/C%2B%2BJava-with-picture-O(n)).\\n\\nThen, we can sort the input array and the count array, so that larger numbers and higher count are in the matching positions. Finally, we compute the maximum sum in one last swipe.\\n\\n**C++**\\n```cpp\\nint maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n    vector<int> cnt(nums.size());\\n    for (auto &r : requests) {\\n        cnt[r[0]] += 1;\\n        if (r[1] + 1 < nums.size())\\n            cnt[r[1] + 1] -= 1;\\n    }\\n    partial_sum(begin(cnt), end(cnt), begin(cnt));\\n    sort(begin(nums), end(nums));\\n    sort(begin(cnt), end(cnt));\\n    return inner_product(begin(nums), end(nums), begin(cnt), 0, \\n        [](int res, long long m){ return (res + m) % 1000000007; }, multiplies<long long>());\\n}\\n```\\n**Java**\\n```java\\npublic int maxSumRangeQuery(int[] nums, int[][] requests) {\\n    int cnt[] = new int[nums.length];\\n    for (var r : requests) {\\n        cnt[r[0]] += 1;\\n        if (r[1] + 1 < nums.length)\\n            cnt[r[1] + 1] -= 1;\\n    }\\n    for (int i = 1; i < cnt.length; ++i)\\n        cnt[i] += cnt[i - 1];\\n    Arrays.sort(nums);\\n    Arrays.sort(cnt);\\n    long res = 0;\\n    for (int i = 0; i < nums.length; ++i)\\n        res = (res + (long)nums[i] * cnt[i]) % 1000000007;\\n    return (int)res;\\n}\\n```\\n**Complexity Analysis**\\n- Time: O(n log n)\\n- Memory: O(n) for storing counts.\\n",
                "solutionTags": [],
                "code": "```cpp\\nint maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n    vector<int> cnt(nums.size());\\n    for (auto &r : requests) {\\n        cnt[r[0]] += 1;\\n        if (r[1] + 1 < nums.size())\\n            cnt[r[1] + 1] -= 1;\\n    }\\n    partial_sum(begin(cnt), end(cnt), begin(cnt));\\n    sort(begin(nums), end(nums));\\n    sort(begin(cnt), end(cnt));\\n    return inner_product(begin(nums), end(nums), begin(cnt), 0, \\n        [](int res, long long m){ return (res + m) % 1000000007; }, multiplies<long long>());\\n}\\n```\n```java\\npublic int maxSumRangeQuery(int[] nums, int[][] requests) {\\n    int cnt[] = new int[nums.length];\\n    for (var r : requests) {\\n        cnt[r[0]] += 1;\\n        if (r[1] + 1 < nums.length)\\n            cnt[r[1] + 1] -= 1;\\n    }\\n    for (int i = 1; i < cnt.length; ++i)\\n        cnt[i] += cnt[i - 1];\\n    Arrays.sort(nums);\\n    Arrays.sort(cnt);\\n    long res = 0;\\n    for (int i = 0; i < nums.length; ++i)\\n        res = (res + (long)nums[i] * cnt[i]) % 1000000007;\\n    return (int)res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 854155,
                "title": "java-count-frequencies-of-indexes-and-then-sort-with-explanation",
                "content": "Iterate through the requests array. \\nTake an aux array of size equal to the size of the array arr.\\nFor each request {st, end}, mark aux[st] = aux[st] + 1 and aux[end + 1] = aux[end + 1] - 1.\\n\\nNow when you iterate over this array aux, keep a running sum. At curr index i, the running sum will tell you as to how many times that current index i would have been visited.\\n\\nNow you have frequencies for all the indexes. Sort them.\\n\\nNow apply greedy approach, it is pretty obvious that you would like to keep the maximum element in the array at the index where you had the maximum frequency. \\n\\nSort arr.\\nSort aux.\\nJust iterate over aux and array and sum the products of the frequencies in sorted aux and elements in sorted arr.\\n\\n\\nHapy Coding !!\\n\\n\\n```\\nclass Solution {\\n    public int maxSumRangeQuery(int[] nums, int[][] requests) {\\n        int n = nums.length;\\n        int[] aux = new int[n];\\n        for(int i = 0; i < requests.length; i++) {\\n            int[] curr = requests[i];\\n            int st = curr[0], end = curr[1];\\n            aux[st]++;\\n            if(end != n - 1) aux[end + 1]--;\\n        }\\n        int sum = 0;\\n        for(int i = 0; i < aux.length; i++) {\\n            sum += aux[i];\\n            aux[i] = sum;\\n        }\\n        Arrays.sort(nums);\\n        Arrays.sort(aux);\\n        long ans = 0;\\n        int mod = (int)Math.pow(10, 9) + 7;\\n        for(int i = 0; i < n; i++) {\\n            long temp = 1;\\n            ans  = (ans + (((temp * aux[i]) % mod) * nums[i]) % mod) % mod;\\n        }\\n        return (int)ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxSumRangeQuery(int[] nums, int[][] requests) {\\n        int n = nums.length;\\n        int[] aux = new int[n];\\n        for(int i = 0; i < requests.length; i++) {\\n            int[] curr = requests[i];\\n            int st = curr[0], end = curr[1];\\n            aux[st]++;\\n            if(end != n - 1) aux[end + 1]--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 854156,
                "title": "put-the-largest-number-at-index-with-the-most-requests",
                "content": "Let\\'s start with the obvious, if there is only one request = [start, end], which covers k = end - start + 1 elements, then the maximum sum would be the sum of the largest k numbers from nums. Because only elements in between start and end will count, we will greedily put the largest numbers to the index between start and end. Since we can choose any permutation, it means we have the freedom to assign numbers from nums to any index we want.\\n\\nIn general, the greedy strategy still works. We need to put the largest number to the index that has been requested the most. Because if an index has been requested m times, then it will contribute m * (value we assign to that index) to the final sum. The number of requests plays the role of weight or importance.\\n\\nNow it boils down to how to compute the number of requests for each index. Since each request is an interval, we can do this more efficiently than looping over each requested interval and count. A similar problem is[ Car Pool](https://leetcode.com/problems/car-pooling/). (BTW, I also encountered that problem during a contest, that time I struggled and used a heap).\\n\\nWe can solve this problem in linear time. Starting from an array t = [0] * (len(nums) + 1),  for each request = [start, end], we let t[start] += 1, indicate that every index after this point will be counted 1 more time because of this request, and t[end + 1] -= 1, indicate that every index after end will be counted 1 less time because of the end of this request. Now the prefix sum of this array t is corresponds to the number of requests for each index. We choose array t has length len(nums) + 1, only because we need to ensure end + 1 is within the range when we put t[end+1] -= 1. To compute the number of requests for indices, we will only count the first len(nums) prefix sums.\\n\\nWe record every prefix sum(i.e. the number of requests) in a new array (or we can do it inplace at t), then we just follow the greedy strategy, to sort both t and nums, and take the sum of t[i] * nums[i] for all i, i.e. dot product between t and nums.\\n\\nTime Complexity:\\nLet N1, N2 be the size of nums and requests. Since we loop through all requests, that is O(N2), computing prefix sum of t and looping through nums are O(N1). Finally sorting takes O(N1 * log(N1)), so it is O(N1 * log(N1) + N2).\\n\\nSpace Complexity:\\nOnly new array is t, it is O(N1).\\n\\n\\nPython:\\n```\\n    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\\n        mod = 10**9 + 7\\n        n = len(nums)\\n        t = [0]*(n + 1)\\n        for a, b in requests:\\n            t[a] += 1\\n            t[b + 1] -= 1\\n        for i in range(1, n):\\n            t[i] += t[i - 1]\\n        \\n        nums.sort()\\n        t.pop()\\n        t.sort()\\n\\n        return sum(a*b for a, b in zip(nums, t)) % mod\\n```\\n\\nC++:\\n```\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        int n = nums.size();\\n        vector<int> t(n + 1, 0);\\n        for (auto x: requests){\\n            t[x[0]]++;\\n            t[x[1] + 1]--;\\n        }\\n\\n        for (int i = 1; i < n; i++){\\n            t[i] += t[i - 1];\\n        }\\n        \\n\\n        \\n        sort(nums.begin(), nums.end());\\n        sort(t.begin(), t.end() - 1);\\n        int ans = 0, mod = 1e9 + 7;\\n        for (int i = 0; i < n; i++){\\n            ans = (ans + (nums[i]%mod)*(t[i]%mod)) % mod;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\\n        mod = 10**9 + 7\\n        n = len(nums)\\n        t = [0]*(n + 1)\\n        for a, b in requests:\\n            t[a] += 1\\n            t[b + 1] -= 1\\n        for i in range(1, n):\\n            t[i] += t[i - 1]\\n        \\n        nums.sort()\\n        t.pop()\\n        t.sort()\\n\\n        return sum(a*b for a, b in zip(nums, t)) % mod\\n```\n```\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        int n = nums.size();\\n        vector<int> t(n + 1, 0);\\n        for (auto x: requests){\\n            t[x[0]]++;\\n            t[x[1] + 1]--;\\n        }\\n\\n        for (int i = 1; i < n; i++){\\n            t[i] += t[i - 1];\\n        }\\n        \\n\\n        \\n        sort(nums.begin(), nums.end());\\n        sort(t.begin(), t.end() - 1);\\n        int ans = 0, mod = 1e9 + 7;\\n        for (int i = 0; i < n; i++){\\n            ans = (ans + (nums[i]%mod)*(t[i]%mod)) % mod;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 854196,
                "title": "c-greedy-solution-with-explanation",
                "content": "**Approach :**\\n1. Count how many times each index occure in all requests. Take an array (*count[ ]*) for this.\\n2. Increment count for beginning index of requests and decrement count for the next to end index of requests.\\n3. accumulate the values in the *count[ ]* to get number of occurrence of each index in all requests.  \\n4. Do sorting in both arrays.\\n5. To get maximum sum, take smallest number (*nums[i]*) corresponding to smallest count (*count[i]*) and so on till largest number corresponding to largest count and compute sum.\\n\\n**Complexity :**\\nTime - O(nlog(n))\\nSpace - O(n)\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& r) {\\n        //Step - 1\\n        vector<int>count(nums.size(), 0);\\n        //Step - 2\\n        for(int i = 0; i < r.size(); i++){\\n            count[r[i][0]]++;\\n            if(r[i][1] + 1 < nums.size()){\\n                count[r[i][1] + 1]--;\\n            }\\n        }\\n        //Step - 3\\n        for(int i = 1; i < nums.size(); i++){\\n            count[i] += count[i - 1];\\n        }\\n        //Step - 4\\n        sort(count.begin(), count.end());\\n        sort(nums.begin(), nums.end());\\n        //Step - 5\\n        long long int sum = 0;\\n\\t\\tint mod = (int)1e9 + 7;\\n        for(int i = 0; i < nums.size(); i++){\\n            sum += count[i] * nums[i];\\n            sum %= mod;\\n        }\\n        return int(sum);\\n    }\\n};\\n\\n```\\n\\nIf you find this helpful, please do upvote :)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& r) {\\n        //Step - 1\\n        vector<int>count(nums.size(), 0);\\n        //Step - 2\\n        for(int i = 0; i < r.size(); i++){\\n            count[r[i][0]]++;\\n            if(r[i][1] + 1 < nums.size()){\\n                count[r[i][1] + 1]--;\\n            }\\n        }\\n        //Step - 3\\n        for(int i = 1; i < nums.size(); i++){\\n            count[i] += count[i - 1];\\n        }\\n        //Step - 4\\n        sort(count.begin(), count.end());\\n        sort(nums.begin(), nums.end());\\n        //Step - 5\\n        long long int sum = 0;\\n\\t\\tint mod = (int)1e9 + 7;\\n        for(int i = 0; i < nums.size(); i++){\\n            sum += count[i] * nums[i];\\n            sum %= mod;\\n        }\\n        return int(sum);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 854207,
                "title": "python-find-ranks",
                "content": "```python\\nclass Solution:\\n    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\\n\\t    \"\"\"\\n\\t\\tnums = [1,2,3,4,5], requests = [[1,3],[0,1]]\\n\\t\\tranks = [1,2,1,1,0]\\n\\t\\t\\n\\t\\tSo, largest element at index 1, is requested twice...\\n\\t\\tSo, multiplying the sorted(requests) and sorted(ranks) should give us the answer\\n\\t    \"\"\"\\n        from operator import add\\n        lenn = len(nums)\\n        ranks = [0] * (lenn + 1)\\n        for i, j in requests:\\n            ranks[i]  += 1\\n            ranks[j+1] -= 1\\n        for i in range(1, lenn + 1):\\n            ranks[i] += ranks[i-1]\\n        ranks = ranks[:lenn]\\n        return sum(x*y for x, y in zip(sorted(ranks), sorted(nums))) % (10**9 + 7)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\\n\\t    \"\"\"\\n\\t\\tnums = [1,2,3,4,5], requests = [[1,3],[0,1]]\\n\\t\\tranks = [1,2,1,1,0]\\n\\t\\t\\n\\t\\tSo, largest element at index 1, is requested twice...\\n\\t\\tSo, multiplying the sorted(requests) and sorted(ranks) should give us the answer\\n\\t    \"\"\"\\n        from operator import add\\n        lenn = len(nums)\\n        ranks = [0] * (lenn + 1)\\n        for i, j in requests:\\n            ranks[i]  += 1\\n            ranks[j+1] -= 1\\n        for i in range(1, lenn + 1):\\n            ranks[i] += ranks[i-1]\\n        ranks = ranks[:lenn]\\n        return sum(x*y for x, y in zip(sorted(ranks), sorted(nums))) % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1258961,
                "title": "c-solution-intuition-greedy-solution",
                "content": "## Basic Idea of the Question\\nWe are given an array of numbers (nums) and a set of requests (requests), and our task is to maximise the total sum of outputs of the requests for any permutation of the numbers in the array. The output of a request is defined as :\\n\\n<code>Output for request [start, end] = \\nnums[start] + nums[start+1] + nums[start+2] + ..... + nums[end - 1] + nums[end]</code>\\n\\nWe have to return the answer mod 1e9 + 7.\\n\\nAt first, this task my seem daunting, seeing the constraints, you might be thinking, checking all permutations for all requests, would just be impractical, and you would be right in thinking so. So how can you maximise the answer for a request, without considering all possible permutations.\\n\\nFirst, let\\'s look at what the question expects from us:\\nLet\\'s say the first request was [0,1], thus its answer would be nums[0] + nums[1].\\nSimilarly let\\'s say the second request was [1,4], then its answer would be nums[1] + nums[2] + nums[3] + nums[4].\\n\\nThen the total sum (that we have to maximise) will be nums[0] + 2 * nums[1] + nums[2] + nums[3] + nums[4].\\nLook closely, the order of the requests, and their specific ranges don\\'t matter, it is only the frequency of each index in the requests, that actually matters. It my be pretty clear to you now that for maximizing this sum, we need the largest elements of the array at the most frequently requested elements. The relative order for indices with equal frequency doesn\\'t matter, since all of them are only being added to each other.\\n<br/>\\n## Approach\\nAs stated before, we don\\'t care about the relative order of the requests, instead we focus on the number of times a particular index has been requested. So first, we calculate this by iterating over the requests array.\\nHere if we would have gone the naive way, we would have iterated over the whole request range, and incremented each value. But that is not very efficient, and will lead to TLE. Instead, we use a well known algorithm called LineSweep, or ScanLine, in which instead of storing the actual values of the elements and updating them, we just store the changes, i.e at the start of a range, we increment the element by one, and at the element after the range, we decrement it. This way, we don\\'t have to iterate over multiple request ranges, and a simple cumulative sum of the array will give us the values desired.\\n\\nThen we sort both the nums array, and the indices array (in any order, it doesn\\'t matter as long as both of the arrays are sorted in the same order), and iterate over both the arrays simlutaneously. The sum is updated to sum + nums[i] * indices[i] using appropriate modulus operations.\\n<br/>\\n\\n## Code\\n```\\nint maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n\\tint n = nums.size();\\n\\tint r = requests.size();\\n\\tvector<int> indices(n, 0);\\n\\tfor(int i = 0; i<r; i++) {\\n\\t\\tindices[requests[i][0]]++;\\n\\t\\tif(requests[i][1] < n-1) indices[requests[i][1] + 1]--;\\n\\t}\\n\\tfor(int i = 1; i<n; i++) {\\n\\t\\tindices[i] += indices[i-1];\\n\\t}\\n\\tsort(nums.begin(), nums.end(), greater<int>());\\n\\tsort((indices.begin(), indices.end(), greater<int>());\\n\\tint sum = 0;\\n\\tfor(int i = 0; i<n; i++) {\\n\\t\\tsum = (sum + ((long long)(nums[i]%mod) * (long long)(indices[i]%mod))%mod)%mod;\\n\\t}\\n\\treturn sum;\\n}\\n```\\n\\n**Time : O(nlogn + r)** where n is the number of elements in nums array and r is the number of requests.\\n**Space: O(n)** for the extra indices array.\\n\\n<br/>\\n\\n**Upvote** if you liked this post and learned something from it, and feel free to ask any doubts, or suggest any corrections/improvements in the comments.\\n\\n",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nint maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n\\tint n = nums.size();\\n\\tint r = requests.size();\\n\\tvector<int> indices(n, 0);\\n\\tfor(int i = 0; i<r; i++) {\\n\\t\\tindices[requests[i][0]]++;\\n\\t\\tif(requests[i][1] < n-1) indices[requests[i][1] + 1]--;\\n\\t}\\n\\tfor(int i = 1; i<n; i++) {\\n\\t\\tindices[i] += indices[i-1];\\n\\t}\\n\\tsort(nums.begin(), nums.end(), greater<int>());\\n\\tsort((indices.begin(), indices.end(), greater<int>());\\n\\tint sum = 0;\\n\\tfor(int i = 0; i<n; i++) {\\n\\t\\tsum = (sum + ((long long)(nums[i]%mod) * (long long)(indices[i]%mod))%mod)%mod;\\n\\t}\\n\\treturn sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1137105,
                "title": "python-solution-beats-99-with-comments",
                "content": "class Solution:\\n\\n    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\\n        overlap = [0]*len(nums) + [0] # record the frequency for each index \\n        cum = 0\\n        for start, end in requests: # traverse the interval will be time-consuming\\n            overlap[start]+=1\\n            overlap[end+1]-=1\\n        for i in range(len(overlap)): # we do it only once \\n            cum += overlap[i]\\n            overlap[i] = cum\\n        nums.sort() # sort the index and nums \\n        overlap.sort()\\n        ans = sum([nums[i]*overlap[i+1] for i in range(len(nums))]) # multiply by index\\n        return ans%(10**9+7)",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n\\n    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\\n        overlap = [0]*len(nums) + [0] # record the frequency for each index \\n        cum = 0\\n        for start, end in requests: # traverse the interval will be time-consuming\\n            overlap[start]+=1\\n            overlap[end+1]-=1\\n        for i in range(len(overlap)): # we do it only once \\n            cum += overlap[i]\\n            overlap[i] = cum\\n        nums.sort() # sort the index and nums \\n        overlap.sort()\\n        ans = sum([nums[i]*overlap[i+1] for i in range(len(nums))]) # multiply by index\\n        return ans%(10**9+7)",
                "codeTag": "Java"
            },
            {
                "id": 888260,
                "title": "java-o-nlogn-m-with-code-and-video-explanation",
                "content": "# Solution\\nWe really want to know how many times each index appears in the requests. This can be calculated by keeping track of the first index a request starts at and the first index a request is no longer active. The prefix sum can be used to quickly compute the counts of the indexes. \\n\\nOnce we know how many times an index appears, we want to match it with the largest number (because we want the max sum possible). Sort the nums and counts arrays. After that keep track of the sum of the product of the values at each index.\\n# Video\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/sb2FNlfxQpg\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\\n\\n# Code\\n```java\\nclass Solution {\\n         \\n    static int MOD = (int)Math.pow(10, 9) + 7;\\n    \\n    public int maxSumRangeQuery(int[] nums, int[][] requests) {\\n        long sum = 0;\\n        int n = nums.length;\\n        int[] counts = new int[n];\\n        \\n        for (int[] request : requests) {\\n            int start = request[0];\\n\\t\\t\\t// First index not counted in the request\\n            int end = request[1] + 1; \\n            counts[start]++;\\n\\t\\t\\t// The first index not counted could be out of bounds. Ignore in that case\\n            if (end < n) {\\n                counts[end]--;\\n            }\\n        }\\n        \\n\\t\\t// Apply prefix sum\\n        for (int i = 1; i < n; i++) {\\n            counts[i] += counts[i-1];\\n        }\\n        \\n        Arrays.sort(nums);\\n        Arrays.sort(counts);\\n        \\n        for (int i = 0; i < n; i++) {\\n            long val = (long)nums[i] * (long)counts[i];\\n            sum += val;\\n        }\\n        \\n        return (int)(sum % MOD);\\n    }\\n}\\n```\\n# Complexity Analysis\\nTime: O(nlogn + m)\\nSpace: O(n)",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n         \\n    static int MOD = (int)Math.pow(10, 9) + 7;\\n    \\n    public int maxSumRangeQuery(int[] nums, int[][] requests) {\\n        long sum = 0;\\n        int n = nums.length;\\n        int[] counts = new int[n];\\n        \\n        for (int[] request : requests) {\\n            int start = request[0];\\n\\t\\t\\t// First index not counted in the request\\n            int end = request[1] + 1; \\n            counts[start]++;\\n\\t\\t\\t// The first index not counted could be out of bounds. Ignore in that case\\n            if (end < n) {\\n                counts[end]--;\\n            }\\n        }\\n        \\n\\t\\t// Apply prefix sum\\n        for (int i = 1; i < n; i++) {\\n            counts[i] += counts[i-1];\\n        }\\n        \\n        Arrays.sort(nums);\\n        Arrays.sort(counts);\\n        \\n        for (int i = 0; i < n; i++) {\\n            long val = (long)nums[i] * (long)counts[i];\\n            sum += val;\\n        }\\n        \\n        return (int)(sum % MOD);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 854182,
                "title": "python-5-lines-binary-search-o-nlogn",
                "content": "Find how many times each position is requested, then we could greedily assign the largest number to the most frequently requested position.\\n\\n\\nWe want the number of times position `i` is requested.\\nIn other words, we want the number of requests that start NO later than `i` and end NO earlier than `i`.\\n\\nFirst sort the start and end times.\\n`bisect_right(s, i)`: number of requests that start NO later than `i`.\\n`bisect_left(e, i)`: number of requests that end earlier than `i`.\\n\\nNumber of times position `i` is requested = `bisect_right(s, i)` - `bisect_left(e, i)`.\\n\\n```\\nfrom bisect import bisect_left, bisect_right\\n\\nclass Solution:\\n    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\\n        s = sorted([a for a, _ in requests])\\n        e = sorted([a for _, a in requests])\\n\\t\\t\\n        freq = [bisect_right(s, i) - bisect_left(e, i) for i in range(len(nums))]\\n\\t\\t\\t\\n        res = sum(f * n for f, n in zip(sorted(freq), sorted(nums)))\\n        return res % int(1e9 + 7)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom bisect import bisect_left, bisect_right\\n\\nclass Solution:\\n    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\\n        s = sorted([a for a, _ in requests])\\n        e = sorted([a for _, a in requests])\\n\\t\\t\\n        freq = [bisect_right(s, i) - bisect_left(e, i) for i in range(len(nums))]\\n\\t\\t\\t\\n        res = sum(f * n for f, n in zip(sorted(freq), sorted(nums)))\\n        return res % int(1e9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 884152,
                "title": "python3-zip-reversely-sorted-nums-and-counts-maximum-sum-obtained-of-any-permutation",
                "content": "```\\nclass Solution:\\n    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\\n        count = [0] * len(nums)\\n        for i, j in requests:\\n            count[i] += 1\\n            if j + 1 < len(count):\\n                count[j+1] -= 1\\n        cur = 0\\n        for i in range(len(count)):\\n            count[i] += cur\\n            cur = count[i]\\n        return sum(n * c for n, c in zip(sorted(nums, reverse=True), sorted(count, reverse=True))) % (10 ** 9 + 7)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\\n        count = [0] * len(nums)\\n        for i, j in requests:\\n            count[i] += 1\\n            if j + 1 < len(count):\\n                count[j+1] -= 1\\n        cur = 0\\n        for i in range(len(count)):\\n            count[i] += cur\\n            cur = count[i]\\n        return sum(n * c for n, c in zip(sorted(nums, reverse=True), sorted(count, reverse=True))) % (10 ** 9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855510,
                "title": "easy-to-understand-python-o-m-nlogn-time-o-n-space",
                "content": "Main idea: Count the frequency with which each index appears in `requests` array. Then sort frequency and `nums` arrays and pair them. Thus, the largest value in `nums` array have to be paired with the highest frequency value.\\n\\nMain difficulty is to count frquencies. The naive implementation may result in TLE. Thus, we have to come up with something smart.\\n\\nImproved algorithm:\\n1. Lets create array `freq` with size `n + 1` \\n2. Loop through `requests` array:\\n\\t* Let say there is some `a,b = requests[i]`.\\n\\t* Increment `freq[a]` and decrement `freq[b+1]`.\\n3. Loop over freq array and accumulate frequencies:\\n\\t* `freq[i] += freq[i-1]`  \\n\\nThe correctness of the algorithm is quite intuitive.\\nM is the size of `requests` array and N is size of `nums` array.\\n\\n**Time complexity**: O(M + NlogN)\\n**Space complexity**: O(N)\\n```\\nclass Solution:\\n    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\\n        MOD = 10**9 + 7\\n        n = len(nums)\\n        ans = 0\\n        freq = [0] * (n+1)\\n        for (a,b) in requests:\\n            freq[a] += 1\\n            freq[b + 1] -= 1\\n        for i in range(1,len(freq)):\\n            freq[i] += freq[i-1]\\n        freq.sort(reverse = True)\\n        nums.sort(reverse = True)\\n        return sum([freq[i]*nums[i] for i in range(n)])%MOD\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\\n        MOD = 10**9 + 7\\n        n = len(nums)\\n        ans = 0\\n        freq = [0] * (n+1)\\n        for (a,b) in requests:\\n            freq[a] += 1\\n            freq[b + 1] -= 1\\n        for i in range(1,len(freq)):\\n            freq[i] += freq[i-1]\\n        freq.sort(reverse = True)\\n        nums.sort(reverse = True)\\n        return sum([freq[i]*nums[i] for i in range(n)])%MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 858539,
                "title": "c-running-sum-to-calculate-frequencies-beats-99",
                "content": "\\n## Idea \\n1. Count the frequencies of each position, store results into `freq`\\n2. Reorder `num` such that the largest number in `nums` is assigned with the largest number in `freq`, the second largest in `nums`  is assigned with the second largest from `freq`, and so on.\\n\\nThe difficulty is: *how to efficiently calculate the frequencies of each position, i.e., the overlapping of lines*. Brute-force way takes time `O(n^2)` and causes TLE (go ahead and try it). \\n\\n### Efficiently calculate the frequencies\\nA better way is, for a given interval `[i, j]`, we \\n1. increase the frequency of positions `i` by 1; \\n2. decrease the frequency of positions `j+1` by 1, and delay the rest calculations to a later loop \\n3. in the (later) loop over interval `[1, n-1]`, we keep a running sum. At current position `i`, the running sum is exactly the frequency the position i would have been visited.\\n\\n\\n## Complexity \\nTime `O(n logn)`\\nSpace `O(n)`\\n\\n```cpp\\nclass Solution {\\npublic:\\n  int maxSumRangeQuery(vector<int> &nums, vector<vector<int>> &requests) {\\n    int n = nums.size();\\n    std::vector<int> freq(n, 0);\\n    for (auto &r : requests) {\\n      freq[r[0]]++;\\n      if (r[1] < n - 1) freq[r[1] + 1]--;\\n    }\\n    for (int i = 1; i < n; i++)\\n      freq[i] += freq[i - 1];\\n\\n    sort(nums.begin(), nums.end(), greater<int>());\\n    sort(freq.begin(), freq.end(), greater<int>());\\n\\n    uint64_t res = 0;\\n\\n    for (int i = 0; i < nums.size(); i++) {\\n      if (freq[i] == 0)\\n        break;\\n      res = (res + freq[i] * nums[i]) % (1e9+7);\\n    }\\n\\n    return res;\\n  }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n  int maxSumRangeQuery(vector<int> &nums, vector<vector<int>> &requests) {\\n    int n = nums.size();\\n    std::vector<int> freq(n, 0);\\n    for (auto &r : requests) {\\n      freq[r[0]]++;\\n      if (r[1] < n - 1) freq[r[1] + 1]--;\\n    }\\n    for (int i = 1; i < n; i++)\\n      freq[i] += freq[i - 1];\\n\\n    sort(nums.begin(), nums.end(), greater<int>());\\n    sort(freq.begin(), freq.end(), greater<int>());\\n\\n    uint64_t res = 0;\\n\\n    for (int i = 0; i < nums.size(); i++) {\\n      if (freq[i] == 0)\\n        break;\\n      res = (res + freq[i] * nums[i]) % (1e9+7);\\n    }\\n\\n    return res;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 854883,
                "title": "java-o-m-n-and-o-n",
                "content": "We just need to calculate the frequencies for each arr[i] based on requests;\\nEasy to come up with a brutal force solution:\\n\\nVersion 1: TLE\\n```\\n    public int maxSumRangeQuery(int[] nums, int[][] rs) {\\n        Arrays.sort(nums);\\n        int n = nums.length, cnt[] = new int[n], res = 0, mod = 1_000_000_007;\\n        for (int[] r : rs) \\n            for (int i = r[0]; i <= r[1]; i++) \\n                cnt[i]++;\\n        Arrays.sort(cnt);\\n        for (int i = n - 1; i >= 0; i--)\\n            res = (res + nums[i] * cnt[i]) % mod;\\n        return res;\\n    }\\n```\\n\\nThen we try to use some temp arrays to use accumlative sum to calculate freqs:\\n[Ref](https://leetcode.com/problems/maximum-sum-obtained-of-any-permutation/discuss/854206/JavaC%2B%2BPython-Sweep-Line): @lee215\\n```\\n    public int maxSumRangeQuery(int[] nums, int[][] rs) {\\n        Arrays.sort(nums);\\n        int n = nums.length, cnt[] = new int[n], acc[] = new int[n], res = 0, mod = 1_000_000_007;\\n        for (int[] r : rs) {\\n            cnt[r[0]]++;  // any i after r[0] will get one more freq;\\n            if (r[1] + 1 < n) cnt[r[1] + 1]--;  // make sure after r[1] to get +1 + -1 = 0 accumulative more freq;\\n        }\\n        acc[0] = cnt[0];  // prefix sum, or accumlative sum, which will be freqs for each i;\\n        for (int i = 1; i < n; i++)\\n            acc[i] = acc[i - 1] + cnt[i];\\n        Arrays.sort(acc);\\n        for (int i = n - 1; i >= 0; i--)\\n            res = (res + nums[i] * acc[i]) % mod;\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int maxSumRangeQuery(int[] nums, int[][] rs) {\\n        Arrays.sort(nums);\\n        int n = nums.length, cnt[] = new int[n], res = 0, mod = 1_000_000_007;\\n        for (int[] r : rs) \\n            for (int i = r[0]; i <= r[1]; i++) \\n                cnt[i]++;\\n        Arrays.sort(cnt);\\n        for (int i = n - 1; i >= 0; i--)\\n            res = (res + nums[i] * cnt[i]) % mod;\\n        return res;\\n    }\\n```\n```\\n    public int maxSumRangeQuery(int[] nums, int[][] rs) {\\n        Arrays.sort(nums);\\n        int n = nums.length, cnt[] = new int[n], acc[] = new int[n], res = 0, mod = 1_000_000_007;\\n        for (int[] r : rs) {\\n            cnt[r[0]]++;  // any i after r[0] will get one more freq;\\n            if (r[1] + 1 < n) cnt[r[1] + 1]--;  // make sure after r[1] to get +1 + -1 = 0 accumulative more freq;\\n        }\\n        acc[0] = cnt[0];  // prefix sum, or accumlative sum, which will be freqs for each i;\\n        for (int i = 1; i < n; i++)\\n            acc[i] = acc[i - 1] + cnt[i];\\n        Arrays.sort(acc);\\n        for (int i = n - 1; i >= 0; i--)\\n            res = (res + nums[i] * acc[i]) % mod;\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2496324,
                "title": "c-priority-queue-and-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        priority_queue<int> pq;\\n        int n=nums.size();\\n        long long ans=0;\\n        int mod = 1000*1000*1000+7;\\n        vector<int> cnt(n+1,0);\\n        for(auto &v : requests)\\n            cnt[v[0]]++, cnt[v[1]+1]--;\\n        for(int i=1; i<=n; i++) cnt[i]+=cnt[i-1];\\n        for(int i=0; i<n; i++) pq.push(cnt[i]);\\n        sort(nums.rbegin(),nums.rend());\\n        int j=0;\\n        while(!pq.empty()) {\\n            ans = (ans+1LL*pq.top()*nums[j++] % mod) % mod;\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        priority_queue<int> pq;\\n        int n=nums.size();\\n        long long ans=0;\\n        int mod = 1000*1000*1000+7;\\n        vector<int> cnt(n+1,0);\\n        for(auto &v : requests)\\n            cnt[v[0]]++, cnt[v[1]+1]--;\\n        for(int i=1; i<=n; i++) cnt[i]+=cnt[i-1];\\n        for(int i=0; i<n; i++) pq.push(cnt[i]);\\n        sort(nums.rbegin(),nums.rend());\\n        int j=0;\\n        while(!pq.empty()) {\\n            ans = (ans+1LL*pq.top()*nums[j++] % mod) % mod;\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1530114,
                "title": "python-o-n-log-n",
                "content": "```\\nclass Solution:\\n    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\\n        n = len(nums)\\n        MOD = 10**9 + 7\\n        freq_map = [0]*n\\n        for start, end in requests:\\n            freq_map[start] += 1\\n            if end+1<n:\\n                freq_map[end+1] -= 1\\n        \\n        for index, val in enumerate(freq_map):\\n            if index != 0:\\n                freq_map[index] += freq_map[index-1]\\n            \\n        freq_map.sort(reverse=True)\\n        nums.sort(reverse = True)\\n        ans = 0\\n        for i in range(n):\\n            ans += freq_map[i]*nums[i]\\n        return ans%MOD\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\\n        n = len(nums)\\n        MOD = 10**9 + 7\\n        freq_map = [0]*n\\n        for start, end in requests:\\n            freq_map[start] += 1\\n            if end+1<n:\\n                freq_map[end+1] -= 1\\n        \\n        for index, val in enumerate(freq_map):\\n            if index != 0:\\n                freq_map[index] += freq_map[index-1]\\n            \\n        freq_map.sort(reverse=True)\\n        nums.sort(reverse = True)\\n        ans = 0\\n        for i in range(n):\\n            ans += freq_map[i]*nums[i]\\n        return ans%MOD\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1251770,
                "title": "c-solution-using-linesweep-algo",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& request) {\\n        int n=nums.size();\\n        long long res=0,mod=1e9+7;\\n       vector<long> p(n+1,0);\\n        sort(request.begin(),request.end());\\n        for(auto j:request)\\n        {\\n            p[j[0]]++;\\n            p[j[1]+1]--;\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            p[i]=p[i]+p[i-1];\\n        }\\n        sort(p.begin(),p.end());\\n        sort(nums.begin(),nums.end());\\n        for(int i=n;i>=1;i--)\\n        {\\n            res=(res+((long)nums[i-1]*p[i])%mod)%mod;\\n        }\\n        return(res%mod);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& request) {\\n        int n=nums.size();\\n        long long res=0,mod=1e9+7;\\n       vector<long> p(n+1,0);\\n        sort(request.begin(),request.end());\\n        for(auto j:request)\\n        {\\n            p[j[0]]++;\\n            p[j[1]+1]--;\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            p[i]=p[i]+p[i-1];\\n        }\\n        sort(p.begin(),p.end());\\n        sort(nums.begin(),nums.end());\\n        for(int i=n;i>=1;i--)\\n        {\\n            res=(res+((long)nums[i-1]*p[i])%mod)%mod;\\n        }\\n        return(res%mod);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 854221,
                "title": "c-o-nlogn-intuitive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n\\t\\n        int MOD = 1000000007;\\n        sort (nums.rbegin() , nums.rend() );\\n        \\n        int n = nums.size();\\n        \\n        vector<int> v(n+1);\\n        \\n        for (vector<int> x: requests ){\\n            v[x[0]] += 1;\\n            if ((x[1]+1)<=n) v[x[1]+1] -= 1;\\n        }        \\n        \\n        for (int i = 1;i<n;i++){\\n            v[i] += v[i-1];\\n        }\\n        \\n        sort(v.rbegin() , v.rend() );\\n        \\n        long long ans = 0;\\n        int i = 0;\\n        while (v[i] != 0 && i < n ){\\n            ans += ( v[i] * nums[i] )%MOD  ; \\n            i++;\\n        }\\n        \\n        return ans%MOD;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n\\t\\n        int MOD = 1000000007;\\n        sort (nums.rbegin() , nums.rend() );\\n        \\n        int n = nums.size();\\n        \\n        vector<int> v(n+1);\\n        \\n        for (vector<int> x: requests ){\\n            v[x[0]] += 1;\\n            if ((x[1]+1)<=n) v[x[1]+1] -= 1;\\n        }        \\n        \\n        for (int i = 1;i<n;i++){\\n            v[i] += v[i-1];\\n        }\\n        \\n        sort(v.rbegin() , v.rend() );\\n        \\n        long long ans = 0;\\n        int i = 0;\\n        while (v[i] != 0 && i < n ){\\n            ans += ( v[i] * nums[i] )%MOD  ; \\n            i++;\\n        }\\n        \\n        return ans%MOD;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 854217,
                "title": "c-o-nlogn-with-explanation",
                "content": "The idea is to position the highest number of array nums to the position with highest frequency and so on for the following frequencies.\\nThe only catch here is not to add a frequency count in brute force manner, but instead add \"+1\" at \"interval beginning\" and subtract \"-1\" at \"interval end position +1\" and then presum to the final array of frequency distribution. The rest is intuitive.\\n```\\nint maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        int n = nums.size();\\n        nums.push_back(0);\\n        vector<int> mp(n+1,0);\\n        long long res = 0;\\n        for(auto &p:requests)\\n        {\\n            mp[p[0]] += 1;\\n            mp[p[1]+1] -= 1;\\n        }\\n        for(int i=1;i<=n;i++)\\n            mp[i] += mp[i-1];\\n        sort(nums.begin(),nums.end());\\n        sort(mp.begin(),mp.end());\\n        for(int i=n;i>=0;i--)\\n            res += nums[i]*mp[i];\\n        return res%1000000007;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        int n = nums.size();\\n        nums.push_back(0);\\n        vector<int> mp(n+1,0);\\n        long long res = 0;\\n        for(auto &p:requests)\\n        {\\n            mp[p[0]] += 1;\\n            mp[p[1]+1] -= 1;\\n        }\\n        for(int i=1;i<=n;i++)\\n            mp[i] += mp[i-1];\\n        sort(nums.begin(),nums.end());\\n        sort(mp.begin(),mp.end());\\n        for(int i=n;i>=0;i--)\\n            res += nums[i]*mp[i];\\n        return res%1000000007;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 854210,
                "title": "java-greedy-solution-time-o-nlogn",
                "content": "```\\nclass Solution {\\n    public int maxSumRangeQuery(int[] nums, int[][] requests) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int[] arr = new int[n + 1]; //max possible index of an array\\n        for (int[] req : requests) {\\n            arr[req[0]]++;  //increment left bound by 1\\n            arr[req[1]+1]--;  //decrease right bound by 1\\n        }\\n        \\n        //compute the prefix sum of arr\\n        \\n        for (int i = 1; i <= n; i++) \\n            arr[i] += arr[i - 1];\\n        \\n        //greedily pick maximum value for most frequently repeated index\\n        Arrays.sort(arr);\\n        int i = n;\\n        long sum = 0;\\n        long mod = 1000000007;\\n        \\n        while (i > 0) {\\n            if (arr[i] == 0)\\n                break;\\n            sum = (sum + (arr[i] * nums[i-1])%mod) % mod;\\n            i--;\\n        }\\n        \\n        return (int) (sum % mod);\\n    }\\n}```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumRangeQuery(int[] nums, int[][] requests) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int[] arr = new int[n + 1]; //max possible index of an array\\n        for (int[] req : requests) {\\n            arr[req[0]]++;  //increment left bound by 1\\n            arr[req[1]+1]--;  //decrease right bound by 1\\n        }\\n        \\n        //compute the prefix sum of arr\\n        \\n        for (int i = 1; i <= n; i++) \\n            arr[i] += arr[i - 1];\\n        \\n        //greedily pick maximum value for most frequently repeated index\\n        Arrays.sort(arr);\\n        int i = n;\\n        long sum = 0;\\n        long mod = 1000000007;\\n        \\n        while (i > 0) {\\n            if (arr[i] == 0)\\n                break;\\n            sum = (sum + (arr[i] * nums[i-1])%mod) % mod;\\n            i--;\\n        }\\n        \\n        return (int) (sum % mod);\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 854153,
                "title": "simple-solution-python",
                "content": "```\\n# Approach:  \\n# \\tFind most requested posion and calculate sum request_count * element(order of request_count) . \\n\\nmod = 10**9+7\\n\\nclass Solution:\\n    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\\n        n = len(nums)\\n        arr = [0]*(n+1) # add extra element for handel n+1 case\\n        for i, j in requests:\\n            arr[i]  += 1\\n            arr[j+1] -= 1\\n        for i in range(1, n+1):\\n            arr[i] += arr[i-1]\\n        arr = arr[:n] # remove extra element\\n        nums.sort()\\n        arr.sort()\\n        ans = 0\\n        for i in range(n):\\n            ans += nums[i] * arr[i]\\n        return ans%mod\\n        \\n```",
                "solutionTags": [],
                "code": "```\\n# Approach:  \\n# \\tFind most requested posion and calculate sum request_count * element(order of request_count) . \\n\\nmod = 10**9+7\\n\\nclass Solution:\\n    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\\n        n = len(nums)\\n        arr = [0]*(n+1) # add extra element for handel n+1 case\\n        for i, j in requests:\\n            arr[i]  += 1\\n            arr[j+1] -= 1\\n        for i in range(1, n+1):\\n            arr[i] += arr[i-1]\\n        arr = arr[:n] # remove extra element\\n        nums.sort()\\n        arr.sort()\\n        ans = 0\\n        for i in range(n):\\n            ans += nums[i] * arr[i]\\n        return ans%mod\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741559,
                "title": "python-3-sweep-line-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\\n        n = len(nums)\\n        cnt = [0 for _ in range(n + 1)]\\n        for i, j in requests:\\n            cnt[i] += 1\\n            cnt[j + 1] -= 1\\n        \\n        for i in range(1, n + 1):\\n            cnt[i] += cnt[i - 1]\\n        \\n        res = 0\\n        for v, c in zip(sorted(cnt[:-1]), sorted(nums)):\\n            res += v * c\\n        \\n        return res % (10 ** 9 + 7)\\n```",
                "solutionTags": [
                    "Python3",
                    "Line Sweep"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\\n        n = len(nums)\\n        cnt = [0 for _ in range(n + 1)]\\n        for i, j in requests:\\n            cnt[i] += 1\\n            cnt[j + 1] -= 1\\n        \\n        for i in range(1, n + 1):\\n            cnt[i] += cnt[i - 1]\\n        \\n        res = 0\\n        for v, c in zip(sorted(cnt[:-1]), sorted(nums)):\\n            res += v * c\\n        \\n        return res % (10 ** 9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3025880,
                "title": "simple-python-solution-greedy-prefix-sum-nlog-n",
                "content": "# Intuition and approach\\n**since we can use any permutation of list.so we will use greedy approach for purmutation selection of list. we will place the maximum element at the index which is included in most intervals.\\n\\n**now we have to find the index which occured in most interval. this can be done using \"PREFIX SUM\". we will initiate freq array of size same as list and all elements are zero.\\nthen we will travese the request list and update freq array as following:\\n        freq[re1[i][0]]+=1 and freq[req[i][1]+1]-=1(take care of n-1 index)\\n\\nnow we will simply travese freq and update it by freq[i]+=freq[i-1] this will give us frequncy of each element\\n\\n** now we will sort both nums and freq.\\n   initiate ans=0 and travese nums while updating ans as following:\\n    ans=(ans+(freq[i]*nums[i])%1e9+7)%1e9+7\\n\\n** at the end return your ans.\\n\\n\\n\\n# Complexity\\n- Time complexity:o(nlog(n))\\n\\n- Space complexity:o(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxSumRangeQuery(self, nums: List[int], req: List[List[int]]) -> int:\\n        n=len(nums)\\n        r=len(req)\\n        a=[0 for i in range(n)]    //freq list\\n        for i in range(r):\\n            a[req[i][0]]+=1\\n            if(req[i][1]<n-1):\\n                a[req[i][1]+1]-=1\\n        \\n        for i in range(n):\\n            if(i==0):\\n                continue\\n            a[i]+=a[i-1]\\n\\n        a.sort()\\n        nums.sort()\\n        ans=0\\n        N=1e9 + 7\\n        for i in range(n-1,-1,-1):\\n            ans+=(a[i]*nums[i])%N\\n            ans%=N\\n        return int(ans%N)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumRangeQuery(self, nums: List[int], req: List[List[int]]) -> int:\\n        n=len(nums)\\n        r=len(req)\\n        a=[0 for i in range(n)]    //freq list\\n        for i in range(r):\\n            a[req[i][0]]+=1\\n            if(req[i][1]<n-1):\\n                a[req[i][1]+1]-=1\\n        \\n        for i in range(n):\\n            if(i==0):\\n                continue\\n            a[i]+=a[i-1]\\n\\n        a.sort()\\n        nums.sort()\\n        ans=0\\n        N=1e9 + 7\\n        for i in range(n-1,-1,-1):\\n            ans+=(a[i]*nums[i])%N\\n            ans%=N\\n        return int(ans%N)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2460651,
                "title": "find-frequency-of-each-index-in-sum-and-assign-larger-value-to-most-frequent",
                "content": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\\n        n = len(nums)\\n        nums.sort()\\n        res = 0\\n        freq = defaultdict(int)\\n        for l, r in requests:\\n            freq[l] += 1\\n            freq[r + 1] -= 1\\n        for i in range(1, n + 1):\\n            freq[i] += freq[i - 1]\\n        weights = sorted([freq[i] for i in range(n)])\\n        for i in range(n):\\n            res += nums[i] * weights[i]\\n        return res % (10 ** 9 + 7)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\\n        n = len(nums)\\n        nums.sort()\\n        res = 0\\n        freq = defaultdict(int)\\n        for l, r in requests:\\n            freq[l] += 1\\n            freq[r + 1] -= 1\\n        for i in range(1, n + 1):\\n            freq[i] += freq[i - 1]\\n        weights = sorted([freq[i] for i in range(n)])\\n        for i in range(n):\\n            res += nums[i] * weights[i]\\n        return res % (10 ** 9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2403380,
                "title": "basic-and-intuitive-easy-greedy-solution",
                "content": "This is a basic way to solve a range update solution , if you dont wanna use segment tree or fenwick .... here first part of my solution just do range update in an array ... to find the positions which are coming frequently in all the ranges , so that we can put a large value at those spots .....\\n// code\\n\\nclass Solution {\\npublic:\\n    static bool compare(int a,int b){\\n        return a>b;\\n    }\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& req) {\\n        int n=nums.size();\\n        vector<int> range_sum(n,0);\\n        for(int i=0;i<req.size();i++){\\n            int a=req[i][0];\\n            int b=req[i][1];\\n            range_sum[a]+=1;\\n            if((b+1)<n){\\n                range_sum[b+1]-=1;\\n            }\\n        }\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            count+=range_sum[i];\\n            range_sum[i]=count;\\n        }\\n        sort(nums.begin(),nums.end(),compare);\\n        int ans=0;\\n        int mod=pow(10,9)+7;\\n        sort(range_sum.begin(),range_sum.end(),compare);\\n        for(int i=0;i<n;i++){\\n            long long temp=(long long)(nums[i])*range_sum[i];\\n            ans=(ans%mod+temp%mod)%mod;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    static bool compare(int a,int b){\\n        return a>b;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2299286,
                "title": "c-nlogn-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& req) {\\n        int n = nums.size();\\n        vector<int> ranges(n + 1);\\n        for(int i = 0; i < req.size(); i++) {\\n            ranges[req[i][0]]++;\\n            ranges[req[i][1] + 1]--;\\n        }\\n        for(int i = 1; i <= n; i++) {\\n            ranges[i] = ranges[i - 1] + ranges[i];\\n        }\\n        sort(ranges.begin(), ranges.end(), greater<int>());\\n        sort(nums.begin(), nums.end(), greater<int>());\\n        int mod = 1e9 + 7;\\n        int i = 0;\\n        long long sum = 0;\\n        while(ranges[i] != 0) {\\n            sum += (long long) ranges[i]*nums[i];\\n            i++;\\n        }\\n        return sum%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& req) {\\n        int n = nums.size();\\n        vector<int> ranges(n + 1);\\n        for(int i = 0; i < req.size(); i++) {\\n            ranges[req[i][0]]++;\\n            ranges[req[i][1] + 1]--;\\n        }\\n        for(int i = 1; i <= n; i++) {\\n            ranges[i] = ranges[i - 1] + ranges[i];\\n        }\\n        sort(ranges.begin(), ranges.end(), greater<int>());\\n        sort(nums.begin(), nums.end(), greater<int>());\\n        int mod = 1e9 + 7;\\n        int i = 0;\\n        long long sum = 0;\\n        while(ranges[i] != 0) {\\n            sum += (long long) ranges[i]*nums[i];\\n            i++;\\n        }\\n        return sum%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085431,
                "title": "java-o-n-log-n-frequency-array-and-sorting-explanation",
                "content": "There are in my opinion two key insights to this problem. I will go through each and then show my code.\\n\\nThe first key insight is that we don\\'t need to test every permutation. We only need to select a permutation which will give us the greatest sum for the requests. So how do we know which permutations will give us the greatest sum for the requests? We select a permutation where all the large numbers are in the most requests.\\nSo for example: `nums = { 10, 2, 4, 6, 9, 1, 1, 2 },  requests = { {2, 5} , {3, 6}, {0, 3} }`\\nIn this case we use the number in index 3 in all three requests. so it should be our biggest number because the number of requests to which it belongs is the greatest. Following this line of thought we can calculate the frequency for each index. Then we pair the largest numbers in our nums with the largest frequency. So in this case our index frequency array looks lile: `{ 1, 1, 2, 3, 2, 2, 1, 0  }`. So one of our ideal permutations is `{ 1, 2, 9, 10, 6, 4, 2, 1 }`. Any of the the 9, 6, or 4 can be interchanged with eachother. Similarly the 2s, and one of the 1s can safely be interchanged with each other, but the groupings of high numbers with high frequencies and low numbers with low frequencies must remain.\\n\\nThis leads us to an approach where.\\n1) Create a frequency array for the frequency each index appears in requests\\n2) Sort the array of numbers\\n3) Sort the frequency array\\n4) Our arrays are the same length so from highest to lowest multiply the number by the frequency to get the sum for that index and add it to the total sum (don\\'t forget to use the modulus to prevent overflow)\\n\\nThe second insight occurred to me after doing this and still receiving a Time Limit Exceeded for a test case with a particularly large set of requests. Sorting is N Log N. Going through the index of each array is just N... so the only spot left for a slowdown was in my creation of the frequency array. I was doing a naive approach of going through each request, and for each request going through each index in the range to increment the frequency. For requests with particularly large ranges this approaches N*M, where M is the number of requests. So how can this be improved? By realizing there might be a way to calculate frequency for multiple overlappying request at once, and indeed there is. By looping through the request once and just marking the start index with a positive frequency offset and the end index with a negative frequency offset, we can then just loop through the frequency array once and apply the offsets. This yields an N+M time complexity instead, which is far superior.\\n\\n```\\npublic class Solution {\\n    static int MODULUS = ((int)Math.pow(10, 9)) + 7;\\n    \\n    //O(NlogN + N + M + N) where N = size of nums, M = size of requests\\n    public int maxSumRangeQuery(int[] nums, int[][] requests) {\\n        int[] indexFrequencies = getIndexFrequencies(nums.length, requests);\\n        Arrays.sort(nums);\\n        Arrays.sort(indexFrequencies);\\n        int sum = 0;\\n\\t\\t// Loop in descending order until we are at the end or at 0 frequency numbers (they no longer affect the sum)\\n        for(int i = indexFrequencies.length-1; i >= 0 && indexFrequencies[i] > 0; i--) {\\n            int totalNumberSummation = (int)(((long)indexFrequencies[i] * (long)nums[i]) % MODULUS);\\n            sum = (sum + totalNumberSummation) % MODULUS;\\n        }\\n        return sum;\\n    }\\n    \\n    //O(N + M)\\n    public int[] getIndexFrequencies(int length, int[][] requests) {\\n        int[] indexFrequencies = new int[length];\\n        initializeArrayWithFrequencyOffsets(indexFrequencies, requests);\\n        countFrequenciesUsingOffsets(indexFrequencies);\\n        return indexFrequencies;\\n    }\\n    \\n    //O(M) where M is the size of the requests\\n    public void initializeArrayWithFrequencyOffsets(int[] frequencyOffsets, int[][] requests) {\\n        for(int i = 0; i < requests.length; i++) {\\n            int start = requests[i][0];\\n            int end = requests[i][1];\\n            frequencyOffsets[start]++;\\n            if(end+1 < frequencyOffsets.length) { // We only do a decrement offset if the range ends before the end of the array\\n                frequencyOffsets[end+1]--;\\n            }\\n        }\\n    }\\n    \\n    //O(N)\\n    public void countFrequenciesUsingOffsets(int[] frequencyOffsetsToFrequencies) {\\n        int currentFrequency = 0;\\n        for(int i = 0; i < frequencyOffsetsToFrequencies.length; i++) {\\n            currentFrequency += frequencyOffsetsToFrequencies[i];\\n            frequencyOffsetsToFrequencies[i] = currentFrequency;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    static int MODULUS = ((int)Math.pow(10, 9)) + 7;\\n    \\n    //O(NlogN + N + M + N) where N = size of nums, M = size of requests\\n    public int maxSumRangeQuery(int[] nums, int[][] requests) {\\n        int[] indexFrequencies = getIndexFrequencies(nums.length, requests);\\n        Arrays.sort(nums);\\n        Arrays.sort(indexFrequencies);\\n        int sum = 0;\\n\\t\\t// Loop in descending order until we are at the end or at 0 frequency numbers (they no longer affect the sum)\\n        for(int i = indexFrequencies.length-1; i >= 0 && indexFrequencies[i] > 0; i--) {\\n            int totalNumberSummation = (int)(((long)indexFrequencies[i] * (long)nums[i]) % MODULUS);\\n            sum = (sum + totalNumberSummation) % MODULUS;\\n        }\\n        return sum;\\n    }\\n    \\n    //O(N + M)\\n    public int[] getIndexFrequencies(int length, int[][] requests) {\\n        int[] indexFrequencies = new int[length];\\n        initializeArrayWithFrequencyOffsets(indexFrequencies, requests);\\n        countFrequenciesUsingOffsets(indexFrequencies);\\n        return indexFrequencies;\\n    }\\n    \\n    //O(M) where M is the size of the requests\\n    public void initializeArrayWithFrequencyOffsets(int[] frequencyOffsets, int[][] requests) {\\n        for(int i = 0; i < requests.length; i++) {\\n            int start = requests[i][0];\\n            int end = requests[i][1];\\n            frequencyOffsets[start]++;\\n            if(end+1 < frequencyOffsets.length) { // We only do a decrement offset if the range ends before the end of the array\\n                frequencyOffsets[end+1]--;\\n            }\\n        }\\n    }\\n    \\n    //O(N)\\n    public void countFrequenciesUsingOffsets(int[] frequencyOffsetsToFrequencies) {\\n        int currentFrequency = 0;\\n        for(int i = 0; i < frequencyOffsetsToFrequencies.length; i++) {\\n            currentFrequency += frequencyOffsetsToFrequencies[i];\\n            frequencyOffsetsToFrequencies[i] = currentFrequency;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2075797,
                "title": "two-approaches-st-pq-and-simple-presum-sorting",
                "content": "```\\n// Using Segment Tree + priority_queue \\n\\nclass Solution {\\npublic:\\n    int st[400001];\\n    int n;\\n    \\n    void update(int node,int & a,int & b,int x,int & y)\\n    {\\n        if(a>y || b<x)\\n            return;\\n        if(x==y)\\n            st[node]++;\\n        else if(x>=a && y<=b)\\n            st[node]++;\\n        else\\n        {\\n            int m = (x+y)/2;\\n            update(2*node+1,a,b,x,m);\\n            update(2*node+2,a,b,m+1,y);\\n        }\\n    }\\n    \\n    void prop(int i,int a,int & b)\\n    {\\n        if(a==b)\\n            return;\\n        st[2*i+1]+=st[i];\\n        st[2*i+2]+=st[i];\\n        st[i]=0;\\n    }\\n    \\n    int sum(int node,int & a,int & b,int x,int & y)\\n    {\\n        prop(node,x,y);\\n        if(a>y || b<x)\\n            return 0;\\n        if(x==y)\\n            return st[node];\\n        int m = (x+y)/2;\\n        return sum(2*node+1,a,b,x,m)+ sum(2*node+2,a,b,m+1,y);\\n    }\\n    \\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& r) {\\n        n=nums.size()-1;\\n        sort(nums.begin(),nums.end());\\n        priority_queue<int> m;\\n        for(auto i:r)\\n            update(0,i[0],i[1],0,n);\\n        for(int i=0;i<=n;i++)\\n        {\\n            int x = sum(0,i,i,0,n);\\n            m.push(x);\\n        }\\n        long long ans=0;\\n        for(int i=n;i>=0;i--)\\n            ans=  (ans+ (1LL*nums[i]*m.top())%1000000007)%1000000007,m.pop();\\n        return ans;\\n    }\\n};\\n```\\n\\n```\\n// Solution 2   Presum technique + sorting\\n\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& r) {\\n        int n=nums.size();\\n        int a[n+1];\\n        memset(a,0,sizeof(a));\\n        for(auto i:r)\\n            a[i[0]]+=1,a[i[1]+1]+=-1;\\n        partial_sum(a,a+n+1,a);\\n        sort(a,a+n+1);\\n        sort(nums.begin(),nums.end());\\n        long long ans=0;\\n        for(int i=n-1;i>=0;i--)\\n            ans=  (ans+ (1LL*nums[i]*a[i+1])%1000000007)%1000000007;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n// Using Segment Tree + priority_queue \\n\\nclass Solution {\\npublic:\\n    int st[400001];\\n    int n;\\n    \\n    void update(int node,int & a,int & b,int x,int & y)\\n    {\\n        if(a>y || b<x)\\n            return;\\n        if(x==y)\\n            st[node]++;\\n        else if(x>=a && y<=b)\\n            st[node]++;\\n        else\\n        {\\n            int m = (x+y)/2;\\n            update(2*node+1,a,b,x,m);\\n            update(2*node+2,a,b,m+1,y);\\n        }\\n    }\\n    \\n    void prop(int i,int a,int & b)\\n    {\\n        if(a==b)\\n            return;\\n        st[2*i+1]+=st[i];\\n        st[2*i+2]+=st[i];\\n        st[i]=0;\\n    }\\n    \\n    int sum(int node,int & a,int & b,int x,int & y)\\n    {\\n        prop(node,x,y);\\n        if(a>y || b<x)\\n            return 0;\\n        if(x==y)\\n            return st[node];\\n        int m = (x+y)/2;\\n        return sum(2*node+1,a,b,x,m)+ sum(2*node+2,a,b,m+1,y);\\n    }\\n    \\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& r) {\\n        n=nums.size()-1;\\n        sort(nums.begin(),nums.end());\\n        priority_queue<int> m;\\n        for(auto i:r)\\n            update(0,i[0],i[1],0,n);\\n        for(int i=0;i<=n;i++)\\n        {\\n            int x = sum(0,i,i,0,n);\\n            m.push(x);\\n        }\\n        long long ans=0;\\n        for(int i=n;i>=0;i--)\\n            ans=  (ans+ (1LL*nums[i]*m.top())%1000000007)%1000000007,m.pop();\\n        return ans;\\n    }\\n};\\n```\n```\\n// Solution 2   Presum technique + sorting\\n\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& r) {\\n        int n=nums.size();\\n        int a[n+1];\\n        memset(a,0,sizeof(a));\\n        for(auto i:r)\\n            a[i[0]]+=1,a[i[1]+1]+=-1;\\n        partial_sum(a,a+n+1,a);\\n        sort(a,a+n+1);\\n        sort(nums.begin(),nums.end());\\n        long long ans=0;\\n        for(int i=n-1;i>=0;i--)\\n            ans=  (ans+ (1LL*nums[i]*a[i+1])%1000000007)%1000000007;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1984118,
                "title": "python3-greedy-line-sweep-prefix-sum-o-nlogn",
                "content": "```\\nclass Solution:\\n    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\\n        arr=[0 for _ in range(len(nums))]\\n        for start,end in requests:                        #line sweep\\n            arr[start]+=1\\n            if end+1<len(nums): arr[end+1]-=1\\n        for i in range(1,len(arr)):                         #prefix sum\\n            arr[i]+=arr[i-1]\\n        res=0\\n        for num,freq in zip(sorted(nums,reverse=True),sorted(arr,reverse=True)):    #greedy\\n            res+=num*freq\\n        return res%(10**9+7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\\n        arr=[0 for _ in range(len(nums))]\\n        for start,end in requests:                        #line sweep\\n            arr[start]+=1\\n            if end+1<len(nums): arr[end+1]-=1\\n        for i in range(1,len(arr)):                         #prefix sum\\n            arr[i]+=arr[i-1]\\n        res=0\\n        for num,freq in zip(sorted(nums,reverse=True),sorted(arr,reverse=True)):    #greedy\\n            res+=num*freq\\n        return res%(10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1920174,
                "title": "c-prefix-sum-based-solution-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n        int mod = 1e9 + 7;\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests)     {\\n      int n = nums.size();\\n            vector<int> v(n+1,0);\\n            for(int i =0; i < requests.size(); i++){\\n                    v[requests[i][0]] += 1;\\n                    v[requests[i][1]+1] -= 1;\\n            }\\n            vector<int> pre(n,0);\\n            for(int i = 0; i < n ; i++){\\n                    if(i == 0)pre[0] = v[0];\\n                    else{\\n                            pre[i] = pre[i-1] + v[i];\\n                    }\\n            }\\n            priority_queue<int>pq1, pq2;\\n            for(auto it : pre)pq1.push(it);\\n            for(auto it : nums)pq2.push(it);\\n            long long int sum = 0;\\n            while(!pq1.empty()){\\n                    auto it = pq1.top(); pq1.pop();\\n                    auto i = pq2.top();pq2.pop();\\n                    sum += 1LL*it *i;\\n                    sum %= mod;\\n            }\\n            return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        int mod = 1e9 + 7;\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests)     {\\n      int n = nums.size();\\n            vector<int> v(n+1,0);\\n            for(int i =0; i < requests.size(); i++){\\n                    v[requests[i][0]] += 1;\\n                    v[requests[i][1]+1] -= 1;\\n            }\\n            vector<int> pre(n,0);\\n            for(int i = 0; i < n ; i++){\\n                    if(i == 0)pre[0] = v[0];\\n                    else{\\n                            pre[i] = pre[i-1] + v[i];\\n                    }\\n            }\\n            priority_queue<int>pq1, pq2;\\n            for(auto it : pre)pq1.push(it);\\n            for(auto it : nums)pq2.push(it);\\n            long long int sum = 0;\\n            while(!pq1.empty()){\\n                    auto it = pq1.top(); pq1.pop();\\n                    auto i = pq2.top();pq2.pop();\\n                    sum += 1LL*it *i;\\n                    sum %= mod;\\n            }\\n            return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1465749,
                "title": "simple-sorting-greedy-difference-array",
                "content": "This problem can be considered as greedy logic we need to put the largest element at such position such that it lies inside the largest no of query ranges so that it can be added largest no of time so we create an array which stores the number of query segment inside which any ith index lies. Sort the frequency counts and greedily put the largest remaining elements in positions such that that position has the largest frequency count amongst all the remaining possible indices\\n\\n\\n```\\n#define ll long long int\\nconst int mod=1e9+7;\\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\\n\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& a, vector<vector<int>>& b) {\\n        IOS;\\n        ll i,n=a.size();\\n        vector<ll> f(n+2,0);\\n        \\n        for(auto v:b){\\n            f[v[0]]++;\\n            f[v[1]+1]--;\\n        }\\n        \\n        for(i=1;i<n;i++)\\n            f[i]+=f[i-1];\\n            \\n        sort(f.begin(),f.end(),greater<ll>());\\n        sort(a.begin(),a.end(),greater<int>());\\n        \\n        ll k=0,s=0;\\n        \\n        for(i=0;i<n;i++,k++){\\n            if(f[i])\\n                s=(s+a[k]*f[i])%mod;    \\n            else\\n                break;\\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n#define ll long long int\\nconst int mod=1e9+7;\\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\\n\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& a, vector<vector<int>>& b) {\\n        IOS;\\n        ll i,n=a.size();\\n        vector<ll> f(n+2,0);\\n        \\n        for(auto v:b){\\n            f[v[0]]++;\\n            f[v[1]+1]--;\\n        }\\n        \\n        for(i=1;i<n;i++)\\n            f[i]+=f[i-1];\\n            \\n        sort(f.begin(),f.end(),greater<ll>());\\n        sort(a.begin(),a.end(),greater<int>());\\n        \\n        ll k=0,s=0;\\n        \\n        for(i=0;i<n;i++,k++){\\n            if(f[i])\\n                s=(s+a[k]*f[i])%mod;    \\n            else\\n                break;\\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1325501,
                "title": "java-o-nlogn-time-o-n-space-using-sorting-and-range-array",
                "content": "```class Solution {\\n    public int maxSumRangeQuery(int[] nums, int[][] requests) {\\n        int[] indexCounts = indexCounts(requests, nums.length);\\n        int modulo = (int) Math.pow(10, 9) + 7;\\n        Arrays.sort(nums);\\n        Arrays.sort(indexCounts);\\n        long sum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            sum += (long) nums[i] * indexCounts[i];\\n            sum %= modulo;\\n        }\\n        return (int) sum;\\n    }\\n    \\n    public int[] indexCounts(int[][] requests, int len) {\\n        int[] rangeCounts = new int[len + 1];\\n        int[] indexCounts = new int[len];\\n        int rangeCount = 0;\\n        for (int[] r : requests) {\\n            rangeCounts[r[0]] += 1;\\n            rangeCounts[r[1] + 1] -= 1;\\n        }\\n        for (int i = 0; i < len; i++) {\\n            rangeCount += rangeCounts[i];\\n            indexCounts[i] = rangeCount;\\n        }\\n        return indexCounts;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxSumRangeQuery(int[] nums, int[][] requests) {\\n        int[] indexCounts = indexCounts(requests, nums.length);\\n        int modulo = (int) Math.pow(10, 9) + 7;\\n        Arrays.sort(nums);\\n        Arrays.sort(indexCounts);\\n        long sum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            sum += (long) nums[i] * indexCounts[i];\\n            sum %= modulo;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1284947,
                "title": "easy-python3",
                "content": "# Intuition\\nFirstly we should find how much request we have for different elements then we should multiply biggest elements on highest frequencies\\n```\\n\\'\\'\\'\\nTime complexity: O(r+n)\\nr = len(requests)\\nn = len(nums)\\n\\'\\'\\'\\nclass Solution:\\n    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\\n        l = len(nums)\\n        sums = [0]*(l+1)\\n        answer = 0\\n        N = 10**9 + 7\\n        for r in requests:\\n            sums[r[0]] += 1\\n            sums[r[1]+1] -= 1\\n        for i in range(l):\\n            sums[i+1] += sums[i]\\n        sums.sort(key = lambda x: -x)\\n        nums.sort(key = lambda x: -x)\\n        for i in range(l):\\n            answer += (sums[i]*nums[i])%N\\n        return answer%N\\n```",
                "solutionTags": [],
                "code": "```\\n\\'\\'\\'\\nTime complexity: O(r+n)\\nr = len(requests)\\nn = len(nums)\\n\\'\\'\\'\\nclass Solution:\\n    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\\n        l = len(nums)\\n        sums = [0]*(l+1)\\n        answer = 0\\n        N = 10**9 + 7\\n        for r in requests:\\n            sums[r[0]] += 1\\n            sums[r[1]+1] -= 1\\n        for i in range(l):\\n            sums[i+1] += sums[i]\\n        sums.sort(key = lambda x: -x)\\n        nums.sort(key = lambda x: -x)\\n        for i in range(l):\\n            answer += (sums[i]*nums[i])%N\\n        return answer%N\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1281706,
                "title": "c-simple-solution-with-difference-array-with-explanation-100-run-time",
                "content": "**Analysis:**\\n\\nFirst note that although it seems that the question is asking us to first identify a permutation of `nums`, what it really entails that we are free to assign elements in `nums` to any index in a manner that can maximize the result.\\n\\nNote to achieve the most optimal result, we can go about greedily assign the largest value in the array to the index which is covered by the most number of intervals (i.e. requests), and second largest value in the array to the index which is covered by the second most number of intervals, and so on. It doesn\\'t matter which interval an element is covered by, as long as we know its ranking in the number of occurrences it\\'s being covered by, we can assign the corresponding value in the array.\\n\\nHow do we go about finding the number of occurrences of each element in the array? We can use **difference array** to track that. We can generate the difference array by traversing through the intervals.\\n\\nOnce we have have from the number of occurrences of each element from the difference array, we can greedily assign each to the corresponding value in the array in a greedy fashion. We just need to sort both the input array and the occurrences array, and keep adding the product of each pair of elements to the result from the beginning to the end.\\n\\n**Solution:**\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(std::vector<int>& nums, std::vector<std::vector<int>>& requests) {\\n        const auto n = nums.size();\\n\\n        std::vector<int> difference(n+1, 0);\\n\\n        for ( const auto& request : requests ) {\\n            const auto start = request.front();\\n            const auto end = request.back();\\n\\n            difference[start]++;\\n            difference[end+1]--;\\n        }\\n\\n        for ( size_t i = 1; i <= n; ++i )\\n            difference[i] += difference[i-1];\\n\\n        std::sort( nums.begin(), nums.end(), std::greater<int>() );\\n        std::sort( difference.begin(), difference.end(), std::greater<int>() );\\n\\n        int64_t res = 0;\\n\\n        #define MOD ( (int)1e9 + 7 )\\n\\n        for ( int i = 0; i < n; ++i )\\n            res = ( res + ( (int64_t)nums[i] * difference[i] ) % MOD ) % MOD;\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(std::vector<int>& nums, std::vector<std::vector<int>>& requests) {\\n        const auto n = nums.size();\\n\\n        std::vector<int> difference(n+1, 0);\\n\\n        for ( const auto& request : requests ) {\\n            const auto start = request.front();\\n            const auto end = request.back();\\n\\n            difference[start]++;\\n            difference[end+1]--;\\n        }\\n\\n        for ( size_t i = 1; i <= n; ++i )\\n            difference[i] += difference[i-1];\\n\\n        std::sort( nums.begin(), nums.end(), std::greater<int>() );\\n        std::sort( difference.begin(), difference.end(), std::greater<int>() );\\n\\n        int64_t res = 0;\\n\\n        #define MOD ( (int)1e9 + 7 )\\n\\n        for ( int i = 0; i < n; ++i )\\n            res = ( res + ( (int64_t)nums[i] * difference[i] ) % MOD ) % MOD;\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1033753,
                "title": "c-solution-100-some-explanation",
                "content": "I\\'d like to share my view on this question. \\n\\nFirstly, we can note that in order to get the maximum sum, we just need to place the largest number to the place which is added the most times. So if we can get a vector `v`, with `v[i]` representing the times that row `i` is counted. We can arrange `nums` so that the largest number lies in row `i`, where `v[i]` is largest among `v`. To achieve this, we just need to sort over `v` and `nums`. The final result is the sumproduct of `nums` and `v`.\\n\\nSo the question is reduced to, how can we get such a `v`? It is similar to calendar questions [Canlenar III](https://leetcode.com/problems/my-calendar-iii/). The basic idea is that we go throuthg `reqeusts` to keep track of locations where counting is increased and where it is decreased. We then get the cumulative sum of this location tracking vector.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        vector<int> tbl( nums.size()+1, 0 );    // tbl is the location tracking vector\\n        for( auto &p : requests ){\\n            ++tbl[p[0]]; --tbl[p[1]+1];               // Counting is increasing 1 at p[0], decreasing 1 at p[1]+1\\n        }\\n        \\n        int tmp = 0;\\n        vector<long> tbl2( nums.size(),0);    // tbl2 is `v` mentioned in explanation\\n        for( int i = 0; i != tbl2.size(); ++i ){\\n            tmp += tbl[i];                                // it is the cumulative sum of the location tracker\\n            tbl2[i] = tmp;\\n        }\\n        \\n\\t\\t// Sort tbl2 and nums to match largest number in nums to largest counted positions\\n        sort( tbl2.begin(), tbl2.end() );\\n        sort( nums.begin(), nums.end() );\\n        \\n        long long res(0);\\n        for( int i = 0; i != nums.size(); ++i ){\\n            res += nums[i] * tbl2[i];                           // Calculate the sum of the products\\n        }\\n        \\n        return res % 1000000007;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        vector<int> tbl( nums.size()+1, 0 );    // tbl is the location tracking vector\\n        for( auto &p : requests ){\\n            ++tbl[p[0]]; --tbl[p[1]+1];               // Counting is increasing 1 at p[0], decreasing 1 at p[1]+1\\n        }\\n        \\n        int tmp = 0;\\n        vector<long> tbl2( nums.size(),0);    // tbl2 is `v` mentioned in explanation\\n        for( int i = 0; i != tbl2.size(); ++i ){\\n            tmp += tbl[i];                                // it is the cumulative sum of the location tracker\\n            tbl2[i] = tmp;\\n        }\\n        \\n\\t\\t// Sort tbl2 and nums to match largest number in nums to largest counted positions\\n        sort( tbl2.begin(), tbl2.end() );\\n        sort( nums.begin(), nums.end() );\\n        \\n        long long res(0);\\n        for( int i = 0; i != nums.size(); ++i ){\\n            res += nums[i] * tbl2[i];                           // Calculate the sum of the products\\n        }\\n        \\n        return res % 1000000007;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1015747,
                "title": "python3-o-nlogn-sort-solution-6-lines",
                "content": "```\\nclass Solution:\\n    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\\n        s = [0] * (len(nums)+1)\\n        for i, j in requests:\\n            s[i] += 1\\n            s[j+1] -= 1\\n        c, n = sorted(accumulate(s), reverse=1), sorted(nums, reverse=1)\\n        return sum(a*b for a, b in zip(c, n)) % int(1e9 + 7)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\\n        s = [0] * (len(nums)+1)\\n        for i, j in requests:\\n            s[i] += 1\\n            s[j+1] -= 1\\n        c, n = sorted(accumulate(s), reverse=1), sorted(nums, reverse=1)\\n        return sum(a*b for a, b in zip(c, n)) % int(1e9 + 7)",
                "codeTag": "Java"
            },
            {
                "id": 859404,
                "title": "python-3-straight-forward-solution",
                "content": "```\\nclass Solution:\\n    def maxSumRangeQuery(self, nums, requests) -> int:\\n        \"\"\"\\n        Given an array of integers (nums) and an array of range\\n        requests (requests), each request containing the start\\n        and end indexes of a range within nums, this program\\n        determines the maximum sum over requests for all permutations\\n        of nums.\\n\\n        :param nums: array of integers\\n        :type nums: list[int]\\n        :param requests: array of range requests, each containing\\n                         the start and end indexes of a range of\\n                         indexes within nums\\n        :type requests: list[list[int]]\\n        :return: maximum sum over the range requests (requests)\\n        :rtype: int\\n        \"\"\"\\n\\n        \"\"\"\\n        Initialize length of nums array (len_nums)\\n        \"\"\"\\n        len_nums = len(nums)\\n\\n        \"\"\"\\n        Determine the frequency for each index within nums\\n        \"\"\"\\n        frequencies = [0] * (len_nums + 1)\\n        for start, end in requests:\\n            frequencies[start] += 1\\n            frequencies[end + 1] -= 1\\n        for k in range(1, len_nums):\\n            frequencies[k] += frequencies[k - 1]\\n\\n        \"\"\"\\n        Determine the maximum range sum (max_sum).\\n        \"\"\"\\n        frequencies.sort(reverse=True)\\n        nums.sort(reverse=True)\\n        max_sum = 0\\n        for num, frequency in zip(nums, frequencies):\\n            max_sum += num * frequency\\n        return max_sum % (10**9 + 7)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumRangeQuery(self, nums, requests) -> int:\\n        \"\"\"\\n        Given an array of integers (nums) and an array of range\\n        requests (requests), each request containing the start\\n        and end indexes of a range within nums, this program\\n        determines the maximum sum over requests for all permutations\\n        of nums.\\n\\n        :param nums: array of integers\\n        :type nums: list[int]\\n        :param requests: array of range requests, each containing\\n                         the start and end indexes of a range of\\n                         indexes within nums\\n        :type requests: list[list[int]]\\n        :return: maximum sum over the range requests (requests)\\n        :rtype: int\\n        \"\"\"\\n\\n        \"\"\"\\n        Initialize length of nums array (len_nums)\\n        \"\"\"\\n        len_nums = len(nums)\\n\\n        \"\"\"\\n        Determine the frequency for each index within nums\\n        \"\"\"\\n        frequencies = [0] * (len_nums + 1)\\n        for start, end in requests:\\n            frequencies[start] += 1\\n            frequencies[end + 1] -= 1\\n        for k in range(1, len_nums):\\n            frequencies[k] += frequencies[k - 1]\\n\\n        \"\"\"\\n        Determine the maximum range sum (max_sum).\\n        \"\"\"\\n        frequencies.sort(reverse=True)\\n        nums.sort(reverse=True)\\n        max_sum = 0\\n        for num, frequency in zip(nums, frequencies):\\n            max_sum += num * frequency\\n        return max_sum % (10**9 + 7)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 858624,
                "title": "easy-to-understand-python-solution",
                "content": "```\\nclass Solution:\\n    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\\n        n=len(nums)\\n        l=[0]*n\\n        for i in requests:\\n            l[i[0]]+=1\\n            if(i[1]+1<n):\\n                l[i[1]+1]-=1\\n        for i in range(1,n):\\n            l[i]+=l[i-1]\\n        l.sort(reverse=True)\\n        nums.sort(reverse=True)\\n        ans=0\\n        for i in range(len(nums)):\\n            ans+=nums[i]*l[i]\\n        return ans%(10**9+7)\\n\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\\n        n=len(nums)\\n        l=[0]*n\\n        for i in requests:\\n            l[i[0]]+=1\\n            if(i[1]+1<n):\\n                l[i[1]+1]-=1\\n        for i in range(1,n):\\n            l[i]+=l[i-1]\\n        l.sort(reverse=True)\\n        nums.sort(reverse=True)\\n        ans=0\\n        for i in range(len(nums)):\\n            ans+=nums[i]*l[i]\\n        return ans%(10**9+7)\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 855823,
                "title": "c-solution-via-sorting-and-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int count(vector<int>& begs, int k){\\n        auto search = upper_bound(begs.begin(), begs.end(), k);\\n        if(search == begs.end()) return begs.size();\\n        return search - begs.begin();        \\n    }\\n       \\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        int x = nums.size();\\n        vector<int> dist(x,0);\\n        \\n        int m = requests.size();\\n        \\n        vector<int> begs(m,-1);\\n        vector<int> ends(m,-1);\\n        \\n        int maxx = INT_MIN;\\n        int minn = INT_MAX;\\n        for(int i = 0; i<m; i++){                     \\n            int s = requests[i][0];\\n            int f = requests[i][1];\\n            begs[i]=s;\\n            ends[i]=f;\\n            \\n            minn = min(minn, s);\\n            maxx = max(maxx, f);\\n        }\\n        \\n        sort(begs.begin(), begs.end());\\n        sort(ends.begin(), ends.end());\\n        \\n        for(int k = minn; k<=maxx; k++){\\n            int bigger = count(begs, k);           \\n            int smaller = count(ends, k-1);\\n            dist[k]=max(bigger-smaller, 0);\\n        }\\n\\n        sort(begin(dist), end(dist));\\n        sort(begin(nums), end(nums));\\n\\n        int S = 0;\\n\\n        int n = dist.size();\\n        for(int i=0; i<n;i++)\\n        {\\n            if(dist[n-1-i]==0) break;\\n            long add =((long)nums[nums.size()-1-i]*(long)dist[n-1-i])%1000000007;\\n            S = (S+add)%1000000007;\\n        }\\n\\n        return S;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int count(vector<int>& begs, int k){\\n        auto search = upper_bound(begs.begin(), begs.end(), k);\\n        if(search == begs.end()) return begs.size();\\n        return search - begs.begin();        \\n    }\\n       \\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        int x = nums.size();\\n        vector<int> dist(x,0);\\n        \\n        int m = requests.size();\\n        \\n        vector<int> begs(m,-1);\\n        vector<int> ends(m,-1);\\n        \\n        int maxx = INT_MIN;\\n        int minn = INT_MAX;\\n        for(int i = 0; i<m; i++){                     \\n            int s = requests[i][0];\\n            int f = requests[i][1];\\n            begs[i]=s;\\n            ends[i]=f;\\n            \\n            minn = min(minn, s);\\n            maxx = max(maxx, f);\\n        }\\n        \\n        sort(begs.begin(), begs.end());\\n        sort(ends.begin(), ends.end());\\n        \\n        for(int k = minn; k<=maxx; k++){\\n            int bigger = count(begs, k);           \\n            int smaller = count(ends, k-1);\\n            dist[k]=max(bigger-smaller, 0);\\n        }\\n\\n        sort(begin(dist), end(dist));\\n        sort(begin(nums), end(nums));\\n\\n        int S = 0;\\n\\n        int n = dist.size();\\n        for(int i=0; i<n;i++)\\n        {\\n            if(dist[n-1-i]==0) break;\\n            long add =((long)nums[nums.size()-1-i]*(long)dist[n-1-i])%1000000007;\\n            S = (S+add)%1000000007;\\n        }\\n\\n        return S;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855588,
                "title": "difference-array-implementation-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        \\n        \\n        int n=nums.size();\\n        int mod=1e9+7;\\n        vector<int> diff(n,0);\\n        \\n        \\n        sort(nums.begin(),nums.end(),greater<int>());\\n        \\n        for(auto temp:requests)\\n        {\\n            int a = temp[0];\\n            int b = temp[1];\\n            \\n            diff[a]++;\\n            \\n            if(b!=n-1)\\n                diff[b+1]--;\\n        }\\n        \\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            diff[i]=diff[i-1]+diff[i];\\n        }\\n        \\n        sort(diff.begin(),diff.end(),greater<int>());\\n        \\n        \\n        long long res=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            res=(res+ (diff[i]*nums[i])%mod)%mod;\\n        }\\n        \\n        return res;\\n        \\n        \\n     \\n        \\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        \\n        \\n        int n=nums.size();\\n        int mod=1e9+7;\\n        vector<int> diff(n,0);\\n        \\n        \\n        sort(nums.begin(),nums.end(),greater<int>());\\n        \\n        for(auto temp:requests)\\n        {\\n            int a = temp[0];\\n            int b = temp[1];\\n            \\n            diff[a]++;\\n            \\n            if(b!=n-1)\\n                diff[b+1]--;\\n        }\\n        \\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            diff[i]=diff[i-1]+diff[i];\\n        }\\n        \\n        sort(diff.begin(),diff.end(),greater<int>());\\n        \\n        \\n        long long res=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            res=(res+ (diff[i]*nums[i])%mod)%mod;\\n        }\\n        \\n        return res;\\n        \\n        \\n     \\n        \\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 854322,
                "title": "c-find-frequency-o-n-log-n",
                "content": "Runtime: 840 ms\\nMemory Usage: 50.1 MB\\n```\\n    public int MaxSumRangeQuery(int[] nums, int[][] requests) {\\n\\n        int[] start = new int[nums.Length];\\n        int[] end = new int[nums.Length];\\n        \\n        foreach(int[] r in requests)\\n        {\\n            start[r[0]]++;\\n            end[r[1]]++;\\n        }\\n        \\n        int[] freq = new int[nums.Length];\\n        int crnt = 0;\\n        \\n        for(int i=0; i< nums.Length; i++)\\n        {\\n            freq[i] = start[i]+crnt;\\n            crnt = freq[i] - end[i];\\n        }\\n        \\n        Array.Sort(freq);\\n        Array.Sort(nums);\\n        \\n        int sum = 0;\\n        int mod = (int)Math.Pow(10,9)+7;\\n        \\n        for(int i=nums.Length-1; i>=0 && freq[i] > 0; i--)\\n        {\\n            sum += nums[i] * freq[i];\\n            if (sum > mod) { sum %= mod; }\\n        }\\n        \\n        return sum;\\n    }",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "Runtime: 840 ms\\nMemory Usage: 50.1 MB\\n```\\n    public int MaxSumRangeQuery(int[] nums, int[][] requests) {\\n\\n        int[] start = new int[nums.Length];\\n        int[] end = new int[nums.Length];\\n        \\n        foreach(int[] r in requests)\\n        {\\n            start[r[0]]++;\\n            end[r[1]]++;\\n        }\\n        \\n        int[] freq = new int[nums.Length];\\n        int crnt = 0;\\n        \\n        for(int i=0; i< nums.Length; i++)\\n        {\\n            freq[i] = start[i]+crnt;\\n            crnt = freq[i] - end[i];\\n        }\\n        \\n        Array.Sort(freq);\\n        Array.Sort(nums);\\n        \\n        int sum = 0;\\n        int mod = (int)Math.Pow(10,9)+7;\\n        \\n        for(int i=nums.Length-1; i>=0 && freq[i] > 0; i--)\\n        {\\n            sum += nums[i] * freq[i];\\n            if (sum > mod) { sum %= mod; }\\n        }\\n        \\n        return sum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 854310,
                "title": "python-segment-tree-version",
                "content": "Segment Tree is not the good solution, but I think this question is good to learn and implement tree because no pre-build and no request for range value return in this question. \\n\\n```\\nclass Seg:\\n    def __init__(self, nums):\\n        self.tree=[0 for i in range(4*len(nums))]\\n        self.n=len(nums)\\n        self.data=[]\\n\\n    def tree_update(self, index, l, r, i,j):\\n        if l>j or r<i:\\n            return 0\\n        if i<=l and j>=r:\\n            self.tree[index]+=1\\n            return \\n        mid=(l+r)//2\\n        if i>mid:\\n            self.tree_update(2*index+2,mid+1,r,i,j)\\n        elif j<=mid:\\n            self.tree_update(2*index+1,l,mid,i,j)\\n        else:\\n            self.tree_update(2*index+2,mid+1,r,mid+1,j)\\n            self.tree_update(2*index+1,l,mid,i,mid)\\n    \\n    def update(self, i, j):\\n        if self.n>0:\\n            self.tree_update(0,0,self.n-1,i,j)\\n\\n    def search(self,index,l,r,pre):\\n        if l==r:\\n            self.data.append(pre+self.tree[index])\\n        else:\\n            pre+=self.tree[index]\\n            mid=(l+r)//2\\n            self.search(2*index+1,l,mid,pre)\\n            self.search(2*index+2,mid+1,r,pre)\\n    def result(self):\\n        self.search(0,0,self.n-1,0)\\n        return self.data\\n    \\n    \\nclass Solution:\\n    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\\n        nums.sort()\\n        mod=10**9+7\\n        tree=Seg(nums)\\n        for i,j in requests:\\n            tree.update(i,j)\\n        ans=tree.result()\\n        ans.sort()\\n        out=0\\n        while ans:\\n            out+=ans.pop()*nums.pop()\\n            out%=mod\\n        return out\\n```",
                "solutionTags": [
                    "Python",
                    "Tree"
                ],
                "code": "```\\nclass Seg:\\n    def __init__(self, nums):\\n        self.tree=[0 for i in range(4*len(nums))]\\n        self.n=len(nums)\\n        self.data=[]\\n\\n    def tree_update(self, index, l, r, i,j):\\n        if l>j or r<i:\\n            return 0\\n        if i<=l and j>=r:\\n            self.tree[index]+=1\\n            return \\n        mid=(l+r)//2\\n        if i>mid:\\n            self.tree_update(2*index+2,mid+1,r,i,j)\\n        elif j<=mid:\\n            self.tree_update(2*index+1,l,mid,i,j)\\n        else:\\n            self.tree_update(2*index+2,mid+1,r,mid+1,j)\\n            self.tree_update(2*index+1,l,mid,i,mid)\\n    \\n    def update(self, i, j):\\n        if self.n>0:\\n            self.tree_update(0,0,self.n-1,i,j)\\n\\n    def search(self,index,l,r,pre):\\n        if l==r:\\n            self.data.append(pre+self.tree[index])\\n        else:\\n            pre+=self.tree[index]\\n            mid=(l+r)//2\\n            self.search(2*index+1,l,mid,pre)\\n            self.search(2*index+2,mid+1,r,pre)\\n    def result(self):\\n        self.search(0,0,self.n-1,0)\\n        return self.data\\n    \\n    \\nclass Solution:\\n    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\\n        nums.sort()\\n        mod=10**9+7\\n        tree=Seg(nums)\\n        for i,j in requests:\\n            tree.update(i,j)\\n        ans=tree.result()\\n        ans.sort()\\n        out=0\\n        while ans:\\n            out+=ans.pop()*nums.pop()\\n            out%=mod\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 854274,
                "title": "c-o-n-log-n-lazy-propagation",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    typedef long long lli;\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        vector<int>t(nums.size(), 0);\\n        for(auto r : requests){\\n            int s = r[0];\\n            int e = r[1];\\n            t[s]=t[s]+1;\\n            if(e+1<nums.size())t[e+1]=t[e+1]-1;\\n        }\\n        \\n        for(int i=1;i<nums.size();i++){\\n            t[i]=t[i]+t[i-1];\\n        }\\n        \\n        lli sum=0;\\n        sort(t.begin(), t.end());\\n        sort(nums.begin(), nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            sum=(sum+(t[i]*nums[i])%1000000007)%1000000007;\\n        }\\n        return sum%1000000007;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    typedef long long lli;\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        vector<int>t(nums.size(), 0);\\n        for(auto r : requests){\\n            int s = r[0];\\n            int e = r[1];\\n            t[s]=t[s]+1;\\n            if(e+1<nums.size())t[e+1]=t[e+1]-1;\\n        }\\n        \\n        for(int i=1;i<nums.size();i++){\\n            t[i]=t[i]+t[i-1];\\n        }\\n        \\n        lli sum=0;\\n        sort(t.begin(), t.end());\\n        sort(nums.begin(), nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            sum=(sum+(t[i]*nums[i])%1000000007)%1000000007;\\n        }\\n        return sum%1000000007;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 854269,
                "title": "java-easy-solution",
                "content": "Finding the frequency is key.\\n\\nAt first, we are finding a number of occurrences for each position. In order to get the maximum result, we have to consider the position at which we have maximum occurrences has the maximum element. So we are sorting order of occurrences and order of given numbers.\\n\\nAt the end, we are multiplying number of occurrences with the number we have.\\n\\nIf any one have questions please let me know we can discuss :).\\n\\n```\\nclass Solution {\\n    public int maxSumRangeQuery(int[] nums, int[][] requests) {\\n        \\n        int order[]=new int[nums.length];\\n        Arrays.sort(nums);\\n        \\n        for(int i=0;i<requests.length;i++)\\n        {\\n            int min=requests[i][0];\\n            int max=requests[i][1];\\n            \\n            order[min]=order[min]+1;\\n            if((max+1)<nums.length)\\n                order[max+1]=order[max+1]-1;\\n        }\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            order[i]+=order[i-1];\\n        }\\n        Arrays.sort(order);\\n        long result=0;\\n        for(int i=order.length-1;i>=0;i--)\\n        {\\n            if(order[i]==0)\\n                break;\\n            result+=nums[i]*order[i];\\n        }\\n        return (int)(result%(1000000007));\\n    }\\n    \\n\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxSumRangeQuery(int[] nums, int[][] requests) {\\n        \\n        int order[]=new int[nums.length];\\n        Arrays.sort(nums);\\n        \\n        for(int i=0;i<requests.length;i++)\\n        {\\n            int min=requests[i][0];\\n            int max=requests[i][1];\\n            \\n            order[min]=order[min]+1;\\n            if((max+1)<nums.length)\\n                order[max+1]=order[max+1]-1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 854162,
                "title": "c-o-n-log-n-time-limit-exceeded-solved",
                "content": "We need the permutation such that the given request order have the maximum sum.\\nSo if we sort \\n1. the array of numbers \\n2. request array.\\nThen take the maximum element requested maxium time followed by the next element requested maxium time so on, and the sum returned will be the answer.\\nStep 1: Sort the array\\nStep 2: Write the request in an arrray format.\\nStep 3: Sort the  request array.\\nStep 4: Take the maximum element available for each request.\\n.\\nNow let\\'s do a dry run on this example:\\nnums = [1,2,3,4,5], requests = [[1,3],[0,1]]\\nStep 1: Sort numbers:\\nnums = [5,4,3,2,1]\\nStep 2: Map the request to request array\\nrequest = [1,2,1,1,0,0]\\nStep 3: Sort Request Array:\\nrequest = [0,0,1,1,1,2]\\nStep 4:\\nsum = 5 * 2 + 4 * 1 +3 * 1 + 2 * 1= 19\\n.\\nIn case of step 2 we can do the following:\\n```\\nvector<int> request(nums.size());\\nfor(auto a:requests){\\n\\tfor(int i=a[0];i<=a[1];i++){\\n\\t\\trequest[i]++;\\n\\t}\\n}\\n```\\nBut this will give time limit exceeded as for each input request we are traversing the array multiple times.\\nHow to optimize ?\\nIf for each input we could store the start and end in a seperate array and compute the request array at the end just once:\\n```\\nvector<int> request(nums.size());\\nvector<int> start(nums.size()),end(nums.size());\\nfor(auto a:requests){\\n\\tstart[a[0]]++;\\n\\tend[a[1]]++;\\n}\\nint sum = 0;\\nfor(int i=0;i<request.size();i++){\\n\\tsum = sum + start[i];\\n\\trequest[i] = sum;\\n\\tsum = sum - end[i];\\n}\\n```\\nFull Code:\\n```\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        sort(nums.begin(),nums.end());\\n        vector<int> request(nums.size());\\n        vector<int> start(nums.size()),end(nums.size());\\n        int mod = 1e9 + 7;\\n        for(auto a:requests){\\n            start[a[0]]++;\\n            end[a[1]]++;\\n        }\\n        int sum = 0;\\n        for(int i=0;i<request.size();i++){\\n            sum = sum + start[i];\\n            request[i] = sum;\\n            sum = sum - end[i];\\n        }\\n        sort(request.begin(),request.end());\\n        long long ans = 0;\\n        int i=request.size()-1;\\n        while(i>=0 and request[i]!=0){\\n            ans += (request[i]*nums[i])%mod;\\n            ans = ans%mod;\\n            i--;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nTime Complexity:\\nSort: O(n*logn)\\nRequest Array construction: O(n)\\nMerge: O(n).\\nTime  Complexity : O(n*logn)\\nSpace Complexity: O(n)",
                "solutionTags": [],
                "code": "```\\nvector<int> request(nums.size());\\nfor(auto a:requests){\\n\\tfor(int i=a[0];i<=a[1];i++){\\n\\t\\trequest[i]++;\\n\\t}\\n}\\n```\n```\\nvector<int> request(nums.size());\\nvector<int> start(nums.size()),end(nums.size());\\nfor(auto a:requests){\\n\\tstart[a[0]]++;\\n\\tend[a[1]]++;\\n}\\nint sum = 0;\\nfor(int i=0;i<request.size();i++){\\n\\tsum = sum + start[i];\\n\\trequest[i] = sum;\\n\\tsum = sum - end[i];\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        sort(nums.begin(),nums.end());\\n        vector<int> request(nums.size());\\n        vector<int> start(nums.size()),end(nums.size());\\n        int mod = 1e9 + 7;\\n        for(auto a:requests){\\n            start[a[0]]++;\\n            end[a[1]]++;\\n        }\\n        int sum = 0;\\n        for(int i=0;i<request.size();i++){\\n            sum = sum + start[i];\\n            request[i] = sum;\\n            sum = sum - end[i];\\n        }\\n        sort(request.begin(),request.end());\\n        long long ans = 0;\\n        int i=request.size()-1;\\n        while(i>=0 and request[i]!=0){\\n            ans += (request[i]*nums[i])%mod;\\n            ans = ans%mod;\\n            i--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4093119,
                "title": "o-nlogn-sort-line-sweep",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Among the requests we need to find the highest frequency index and we can assign largest number in our array to it which will increase the sum.\\n2. We can use sorting. We basically need to map high freq indexes to larger numbers. \\n3. We need to have frequency of each index.\\n4. If we iterate from start to end for each request the complexity can be around (nlogn+(m*n)) where m is no. of requests and since in worst case each request can cover all indexes. But an (m*n) solution will give TLE.\\n5. So we will use line sweep algo for iterating on requests.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. sort the nums array.\\n2. create a frequency arr to store frequency of each index. \\n3. Use line sweep algo to iterate on requests. Then follow up with a loop to cumulate the frequency of indexes. Sort the arr array.\\n4. Now initialise sum variable and run a loop to increment it as per the intuition that for largest freq map the greatest number and so on.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxSumRangeQuery(int[] nums, int[][] requests) {\\n        int n=nums.length;\\n        Arrays.sort(nums);\\n        long[] arr=new long[n];\\n        //sweep line\\n        for(int[] req: requests){\\n            arr[req[0]]++;\\n            if(req[1]+1<n){\\n                arr[req[1]+1]--;\\n            }\\n        }\\n        long cumulation=0;\\n        for(int i=0;i<n;i++){\\n            cumulation+=arr[i];\\n            arr[i]=cumulation;\\n        }\\n        long mod=(long)(1e9+7);\\n        Arrays.sort(arr);\\n        long sum=(long)0;\\n        for(int i=n-1;i>=0;i--){\\n            if(arr[i]==0) break;\\n            sum=(sum+(arr[i]*nums[i])%mod)%mod;\\n        }\\n        return (int)(sum%mod);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumRangeQuery(int[] nums, int[][] requests) {\\n        int n=nums.length;\\n        Arrays.sort(nums);\\n        long[] arr=new long[n];\\n        //sweep line\\n        for(int[] req: requests){\\n            arr[req[0]]++;\\n            if(req[1]+1<n){\\n                arr[req[1]+1]--;\\n            }\\n        }\\n        long cumulation=0;\\n        for(int i=0;i<n;i++){\\n            cumulation+=arr[i];\\n            arr[i]=cumulation;\\n        }\\n        long mod=(long)(1e9+7);\\n        Arrays.sort(arr);\\n        long sum=(long)0;\\n        for(int i=n-1;i>=0;i--){\\n            if(arr[i]==0) break;\\n            sum=(sum+(arr[i]*nums[i])%mod)%mod;\\n        }\\n        return (int)(sum%mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042260,
                "title": "my-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaxSumRangeQuery(int[] nums, int[][] requests) \\n{\\n            var numsOrderByDescending = nums.OrderByDescending(i => i).ToList();\\n\\n            int[] indexWeightArray = new int[nums.Length];\\n\\n            for (int i = 0; i < requests.GetLength(0); i++)\\n            {\\n                for (int j = requests[i][0]; j <= requests[i][1]; j++)\\n                {\\n                    indexWeightArray[j]++;\\n                }\\n            }\\n\\n            ulong total = 0;\\n            int index = 0;\\n            indexWeightArray\\n                .OrderByDescending(i => i)\\n                .ToList()\\n                .ForEach(l => total += (ulong)l * (ulong)numsOrderByDescending[index++]);\\n            int sum = Convert.ToInt32(total % 1000000007);\\n            return sum;\\n        }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxSumRangeQuery(int[] nums, int[][] requests) \\n{\\n            var numsOrderByDescending = nums.OrderByDescending(i => i).ToList();\\n\\n            int[] indexWeightArray = new int[nums.Length];\\n\\n            for (int i = 0; i < requests.GetLength(0); i++)\\n            {\\n                for (int j = requests[i][0]; j <= requests[i][1]; j++)\\n                {\\n                    indexWeightArray[j]++;\\n                }\\n            }\\n\\n            ulong total = 0;\\n            int index = 0;\\n            indexWeightArray\\n                .OrderByDescending(i => i)\\n                .ToList()\\n                .ForEach(l => total += (ulong)l * (ulong)numsOrderByDescending[index++]);\\n            int sum = Convert.ToInt32(total % 1000000007);\\n            return sum;\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039830,
                "title": "easy-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const int mod=1e9+7;\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& r) {\\n        vector<int>v(nums.size()+1,0);\\n        for(int i=0;i<r.size();i++)\\n        {\\n            v[r[i][0]]++;\\n            v[r[i][1]+1]--;\\n        }\\n        for(int i=1;i<v.size();i++)\\n        {\\n            v[i]+=v[i-1];\\n        }\\n        vector<pair<int,int>>v1;\\n        for(int i=0;i<v.size()-1;i++)\\n        {\\n            v1.push_back({v[i],i});\\n        }\\n        sort(v1.begin(),v1.end());\\n        sort(nums.begin(),nums.end());\\n        vector<int>temp(nums.size());\\n        for(int i=v1.size()-1;i>=0;i--)\\n        {\\n            temp[v1[i].second]=nums[i];\\n        }\\n        for(int i=1;i<temp.size();i++)\\n        {\\n            temp[i]+=temp[i-1];\\n        }\\n        int ans=0;\\n        for(int i=0;i<r.size();i++)\\n        {\\n            int x=r[i][0];\\n            int y=r[i][1];\\n            if(x==0)\\n            {\\n                ans=((ans%mod)+(temp[y]%mod))%mod;\\n            }\\n            else\\n            {\\n                ans=((ans%mod)+((temp[y]-temp[x-1])%mod))%mod;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod=1e9+7;\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& r) {\\n        vector<int>v(nums.size()+1,0);\\n        for(int i=0;i<r.size();i++)\\n        {\\n            v[r[i][0]]++;\\n            v[r[i][1]+1]--;\\n        }\\n        for(int i=1;i<v.size();i++)\\n        {\\n            v[i]+=v[i-1];\\n        }\\n        vector<pair<int,int>>v1;\\n        for(int i=0;i<v.size()-1;i++)\\n        {\\n            v1.push_back({v[i],i});\\n        }\\n        sort(v1.begin(),v1.end());\\n        sort(nums.begin(),nums.end());\\n        vector<int>temp(nums.size());\\n        for(int i=v1.size()-1;i>=0;i--)\\n        {\\n            temp[v1[i].second]=nums[i];\\n        }\\n        for(int i=1;i<temp.size();i++)\\n        {\\n            temp[i]+=temp[i-1];\\n        }\\n        int ans=0;\\n        for(int i=0;i<r.size();i++)\\n        {\\n            int x=r[i][0];\\n            int y=r[i][1];\\n            if(x==0)\\n            {\\n                ans=((ans%mod)+(temp[y]%mod))%mod;\\n            }\\n            else\\n            {\\n                ans=((ans%mod)+((temp[y]-temp[x-1])%mod))%mod;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4029446,
                "title": "sweep-line-c",
                "content": "# Code\\n```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& a) {\\n        int n=100001;\\n        vector<int>v(n,0);\\n\\n        for(auto i:a){\\n            v[i[0]]++;\\n            v[i[1]+1]--;\\n        }\\n\\n        vector<ll>freq;\\n\\n        if(v[0]>0)freq.push_back(v[0]);\\n\\n        for(int i=1;i<n;i++){\\n            v[i]+=v[i-1];\\n            if(v[i]>0)freq.push_back(v[i]);\\n        }\\n\\n        sort(freq.begin(),freq.end());\\n        reverse(freq.begin(),freq.end());\\n\\n        sort(nums.begin(),nums.end());\\n        reverse(nums.begin(),nums.end());\\n\\n        ll mod=1e9+7,ans=0;\\n\\n        for(int i=0;i<freq.size();i++){\\n            ans = (ans %mod + (freq[i]%mod * long(nums[i])%mod)%mod)%mod;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& a) {\\n        int n=100001;\\n        vector<int>v(n,0);\\n\\n        for(auto i:a){\\n            v[i[0]]++;\\n            v[i[1]+1]--;\\n        }\\n\\n        vector<ll>freq;\\n\\n        if(v[0]>0)freq.push_back(v[0]);\\n\\n        for(int i=1;i<n;i++){\\n            v[i]+=v[i-1];\\n            if(v[i]>0)freq.push_back(v[i]);\\n        }\\n\\n        sort(freq.begin(),freq.end());\\n        reverse(freq.begin(),freq.end());\\n\\n        sort(nums.begin(),nums.end());\\n        reverse(nums.begin(),nums.end());\\n\\n        ll mod=1e9+7,ans=0;\\n\\n        for(int i=0;i<freq.size();i++){\\n            ans = (ans %mod + (freq[i]%mod * long(nums[i])%mod)%mod)%mod;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4026942,
                "title": "cpp-solution-using-prefix-sum",
                "content": "# Intuition\\nThe highest element of given array must be present at mostly queried position.\\n\\n# Approach\\n1.Calculate the frequencies of all the indices given in the requests array.\\n2.The time complexity for finding the frequency can be improved by the prefix sum approach rather than the general traversals.\\n3.Store the frequencies of the indices in a separate array or vector v.\\n4.Now sort both the numbers and the additional array that you have used.(The sorting can be done in any way).\\n5.Multiply the elements of same indices from both the arrays and find their sum.\\n6.Return the answer by calculating modulo of number with 10e9+7.   \\n\\n# Complexity\\n- Time complexity:\\nO(NlogN)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& n, vector<vector<int>>& r) {\\n        int p=n.size();\\n        int q=r.size();\\n        vector<int> v(p,0);\\n        // Calculate prefix sum for range queries\\n    for (int i = 0; i < q; i++) {\\n        int start = r[i][0];\\n        int end = r[i][1];\\n        v[start] += 1;\\n        if (end + 1 < p) {\\n            v[end + 1] -= 1;\\n        }\\n    }\\n\\n    // Calculate cumulative counts\\n    for (int i = 1; i < p; i++) {\\n        v[i] += v[i - 1];\\n    }\\n        sort(v.begin(),v.end(),greater<int>());\\n        sort(n.begin(),n.end(),greater<int>());\\n       long long maxSum = 0;  // Use long long to prevent overflow\\n    const int MOD = 1000000007;\\n    for (int i = 0; i < p; i++) {\\n        maxSum = (maxSum + static_cast<long long>(n[i]) * v[i]) % MOD;\\n    }\\n\\n    return static_cast<int>(maxSum);  // Cast to int after taking the modulo\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& n, vector<vector<int>>& r) {\\n        int p=n.size();\\n        int q=r.size();\\n        vector<int> v(p,0);\\n        // Calculate prefix sum for range queries\\n    for (int i = 0; i < q; i++) {\\n        int start = r[i][0];\\n        int end = r[i][1];\\n        v[start] += 1;\\n        if (end + 1 < p) {\\n            v[end + 1] -= 1;\\n        }\\n    }\\n\\n    // Calculate cumulative counts\\n    for (int i = 1; i < p; i++) {\\n        v[i] += v[i - 1];\\n    }\\n        sort(v.begin(),v.end(),greater<int>());\\n        sort(n.begin(),n.end(),greater<int>());\\n       long long maxSum = 0;  // Use long long to prevent overflow\\n    const int MOD = 1000000007;\\n    for (int i = 0; i < p; i++) {\\n        maxSum = (maxSum + static_cast<long long>(n[i]) * v[i]) % MOD;\\n    }\\n\\n    return static_cast<int>(maxSum);  // Cast to int after taking the modulo\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002223,
                "title": "python-3-simple-sweep-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\\n        \\n        # get the count for each coordiate\\n            # 0, 1, 2, 3, 4\\n            #    1  1  1\\n            #  1 1\\n            #  1 2  1  1\\n            # \\n\\n        mod = 10 ** 9 + 7\\n        N = len(nums)\\n        sweep_array = [0] * (N + 1)\\n\\n        for s, e in requests:\\n            sweep_array[s] += 1\\n            sweep_array[e + 1] -= 1\\n        \\n        # get prefix sum\\n        for i in range(1, N):\\n            sweep_array[i] += sweep_array[i - 1]\\n        \\n        # sort the sweep_array, nums in desc\\n        nums.sort(reverse=True)\\n        sweep_array.sort(reverse=True)\\n        res = 0\\n        for num, cnt in zip(nums, sweep_array):\\n            if not cnt:\\n                break\\n            res += num * cnt\\n        return res % mod\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\\n        \\n        # get the count for each coordiate\\n            # 0, 1, 2, 3, 4\\n            #    1  1  1\\n            #  1 1\\n            #  1 2  1  1\\n            # \\n\\n        mod = 10 ** 9 + 7\\n        N = len(nums)\\n        sweep_array = [0] * (N + 1)\\n\\n        for s, e in requests:\\n            sweep_array[s] += 1\\n            sweep_array[e + 1] -= 1\\n        \\n        # get prefix sum\\n        for i in range(1, N):\\n            sweep_array[i] += sweep_array[i - 1]\\n        \\n        # sort the sweep_array, nums in desc\\n        nums.sort(reverse=True)\\n        sweep_array.sort(reverse=True)\\n        res = 0\\n        for num, cnt in zip(nums, sweep_array):\\n            if not cnt:\\n                break\\n            res += num * cnt\\n        return res % mod\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3995748,
                "title": "easy-to-understand-javascript-solution-greedy",
                "content": "# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nvar maxSumRangeQuery = function(nums, requests) {\\n    const MODULO = 10 ** 9 + 7;\\n    const size = nums.length;\\n    const frequency = Array(size).fill(0);\\n\\n    for (const [start, end] of requests) {\\n        frequency[start] += 1;\\n        if (end + 1 === size) continue;\\n        frequency[end + 1] -= 1;\\n    }\\n    for (let index = 1; index < size; index++) {\\n        frequency[index] += frequency[index - 1];\\n    }\\n    frequency.sort((a, b) => a - b);\\n    nums.sort((a, b) => a - b);\\n\\n    return nums.reduce((result, num, index) => {\\n        return (result + num * frequency[index]) % MODULO;\\n    }, 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxSumRangeQuery = function(nums, requests) {\\n    const MODULO = 10 ** 9 + 7;\\n    const size = nums.length;\\n    const frequency = Array(size).fill(0);\\n\\n    for (const [start, end] of requests) {\\n        frequency[start] += 1;\\n        if (end + 1 === size) continue;\\n        frequency[end + 1] -= 1;\\n    }\\n    for (let index = 1; index < size; index++) {\\n        frequency[index] += frequency[index - 1];\\n    }\\n    frequency.sort((a, b) => a - b);\\n    nums.sort((a, b) => a - b);\\n\\n    return nums.reduce((result, num, index) => {\\n        return (result + num * frequency[index]) % MODULO;\\n    }, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3967640,
                "title": "java-clean-and-simple-prefix-sum-solution",
                "content": "```\\nimport java.util.stream.IntStream;\\n\\nimport static java.util.Arrays.parallelPrefix;\\nimport static java.util.Arrays.sort;\\n\\nclass Solution {\\n    private static final long MAX = (long) 1e9 + 7;\\n\\n    public int maxSumRangeQuery(int[] A, int[][] R) {\\n        int n = A.length;\\n        int[] U = new int[n]; // finding most used index in requests\\n\\n        for (var r : R) {\\n            U[r[0]]++;\\n\\n            if (r[1] + 1 < n)\\n                U[r[1] + 1]--;\\n        }\\n\\n        parallelPrefix(U, Integer::sum);\\n\\n        sort(U);\\n        sort(A);\\n\\n        long output = IntStream.range(0, n)\\n                .mapToLong(i -> (long) U[i] * A[i])\\n                .reduce(Long::sum)\\n                .orElseThrow();\\n\\n        return (int) (output % MAX);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nimport java.util.stream.IntStream;\\n\\nimport static java.util.Arrays.parallelPrefix;\\nimport static java.util.Arrays.sort;\\n\\nclass Solution {\\n    private static final long MAX = (long) 1e9 + 7;\\n\\n    public int maxSumRangeQuery(int[] A, int[][] R) {\\n        int n = A.length;\\n        int[] U = new int[n]; // finding most used index in requests\\n\\n        for (var r : R) {\\n            U[r[0]]++;\\n\\n            if (r[1] + 1 < n)\\n                U[r[1] + 1]--;\\n        }\\n\\n        parallelPrefix(U, Integer::sum);\\n\\n        sort(U);\\n        sort(A);\\n\\n        long output = IntStream.range(0, n)\\n                .mapToLong(i -> (long) U[i] * A[i])\\n                .reduce(Long::sum)\\n                .orElseThrow();\\n\\n        return (int) (output % MAX);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944863,
                "title": "c-sweep-line-on-requests",
                "content": "# Intuition\\nThe idea is simply a greedy algorithm: the maximum number should occur as often as possible. To achieve this we use the sweep line method on requests to identify points that covered by biggest number of intervals. Then we sort points by occuriences and also sort numbers ascending. The result is simpy the sum nums[i]*occurences[i] \\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaxSumRangeQuery(int[] nums, int[][] requests) \\n    {\\n        var modulo = (int) 1e9 + 7;\\n        var n = nums.Length;\\n        var counter = new long[n + 1];\\n\\n        var events = new List<(int, int)>();\\n\\n        foreach(var request in requests)\\n        {\\n            events.Add( (request[0], 1));\\n            events.Add( (request[1] + 1, -1));\\n        } \\n\\n        events.Sort((a, b) => a.Item1 - b.Item1);\\n        \\n        foreach(var myEvent in events)\\n        {\\n            counter[myEvent.Item1] += myEvent.Item2;\\n        }\\n\\n        for(int i = 1; i <= n; ++i)\\n        {\\n            counter[i] += counter[i-1];\\n        }\\n\\n        Array.Sort(counter);\\n        Array.Sort(nums);\\n\\n        var result = 0L;\\n        for(int i = n; i >= 0; --i)\\n        {\\n            if(counter[i] > 0)\\n            {\\n                result = (result + (nums[i-1]*counter[i]) % modulo + modulo) % modulo;\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n\\n        return (int) (result % modulo);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxSumRangeQuery(int[] nums, int[][] requests) \\n    {\\n        var modulo = (int) 1e9 + 7;\\n        var n = nums.Length;\\n        var counter = new long[n + 1];\\n\\n        var events = new List<(int, int)>();\\n\\n        foreach(var request in requests)\\n        {\\n            events.Add( (request[0], 1));\\n            events.Add( (request[1] + 1, -1));\\n        } \\n\\n        events.Sort((a, b) => a.Item1 - b.Item1);\\n        \\n        foreach(var myEvent in events)\\n        {\\n            counter[myEvent.Item1] += myEvent.Item2;\\n        }\\n\\n        for(int i = 1; i <= n; ++i)\\n        {\\n            counter[i] += counter[i-1];\\n        }\\n\\n        Array.Sort(counter);\\n        Array.Sort(nums);\\n\\n        var result = 0L;\\n        for(int i = n; i >= 0; --i)\\n        {\\n            if(counter[i] > 0)\\n            {\\n                result = (result + (nums[i-1]*counter[i]) % modulo + modulo) % modulo;\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n\\n        return (int) (result % modulo);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3926192,
                "title": "o-n-solution-c-prefix-sum-easy-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\\\\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests)  {\\n        int n = nums.size();\\n        vector<int> prefix(n+1,0);\\n        for(auto it:requests){\\n            prefix[it[0]]++;\\n            prefix[it[1]+1]--;\\n        }\\n        for(int i=1;i<=n;i++){\\n            prefix[i] = prefix[i-1]+prefix[i];\\n        }\\n        sort(nums.begin(),nums.end());\\n        sort(prefix.begin(),prefix.end()-1);\\n        int mod = 1e9+7;\\n        long long sum=0;\\n        for(int i=0;i<n;i++){\\n            sum =(sum +(long long) prefix[i]*nums[i])%mod;\\n         \\n        }\\n        return sum;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests)  {\\n        int n = nums.size();\\n        vector<int> prefix(n+1,0);\\n        for(auto it:requests){\\n            prefix[it[0]]++;\\n            prefix[it[1]+1]--;\\n        }\\n        for(int i=1;i<=n;i++){\\n            prefix[i] = prefix[i-1]+prefix[i];\\n        }\\n        sort(nums.begin(),nums.end());\\n        sort(prefix.begin(),prefix.end()-1);\\n        int mod = 1e9+7;\\n        long long sum=0;\\n        for(int i=0;i<n;i++){\\n            sum =(sum +(long long) prefix[i]*nums[i])%mod;\\n         \\n        }\\n        return sum;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3926054,
                "title": "rust-elixir-prefix-sum-sorting-greedy",
                "content": "# Approach\\n1. Use prefix sum approach to sum up the number of times each `nums[i]` will be added to the total sum. (Let `count` be the result)\\n2. Sort both `count` and `nums` because we want the larger integers to be added the more times.\\n3. Add up the total sum while doing modulo $$10^9 + 7$$.\\n\\n# Complexity\\n- Time complexity: $$O(n*log(n) + m)$$\\n\\n- Space complexity: $$O(n)$$\\n\\nWhere `n = nums.len()` and `m = requests.len()`.\\n\\n# Code\\n```Rust []\\nimpl Solution {\\n    pub fn max_sum_range_query(mut nums: Vec<i32>, requests: Vec<Vec<i32>>) -> i32 {\\n        let n = nums.len();\\n        let mut count = vec![0i32; n];\\n        for v in requests.iter() {\\n            count[v[0] as usize] += 1;\\n            if v[1] as usize + 1 < n {\\n                count[v[1] as usize + 1] -= 1;\\n            }\\n        }\\n        for i in 1..n {\\n            count[i] += count[i - 1];\\n        }\\n        count.sort_unstable();\\n        nums.sort_unstable();\\n        let mut ans = 0i64;\\n        for i in 0..nums.len() {\\n            ans += nums[i] as i64 * count[i] as i64;\\n            ans %= 1_000_000_007i64;\\n        }\\n        ans as i32\\n    }\\n}\\n```\\n```Elixir []\\ndefmodule Solution do\\n  @spec max_sum_range_query(nums :: [integer], requests :: [[integer]]) :: integer\\n  def max_sum_range_query(nums, requests) do\\n    Enum.reduce(requests, %{}, fn [s, e], map ->\\n      Map.update(map, s, 1, &(&1 + 1))\\n      |> Map.update(e + 1, -1, &(&1 - 1))\\n    end)\\n    |> then(fn map ->\\n      Enum.map(0..length(nums) - 1, &Map.get(map, &1, 0))\\n    end)\\n    |> Enum.scan(&+/2)\\n    |> Enum.sort()\\n    |> Enum.zip_reduce(Enum.sort(nums), 0, fn c, x, acc ->\\n      rem(acc + c * x, 1_000_000_007)\\n    end)\\n  end\\nend\\n```",
                "solutionTags": [
                    "Rust",
                    "Elixir",
                    "Greedy",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```Rust []\\nimpl Solution {\\n    pub fn max_sum_range_query(mut nums: Vec<i32>, requests: Vec<Vec<i32>>) -> i32 {\\n        let n = nums.len();\\n        let mut count = vec![0i32; n];\\n        for v in requests.iter() {\\n            count[v[0] as usize] += 1;\\n            if v[1] as usize + 1 < n {\\n                count[v[1] as usize + 1] -= 1;\\n            }\\n        }\\n        for i in 1..n {\\n            count[i] += count[i - 1];\\n        }\\n        count.sort_unstable();\\n        nums.sort_unstable();\\n        let mut ans = 0i64;\\n        for i in 0..nums.len() {\\n            ans += nums[i] as i64 * count[i] as i64;\\n            ans %= 1_000_000_007i64;\\n        }\\n        ans as i32\\n    }\\n}\\n```\n```Elixir []\\ndefmodule Solution do\\n  @spec max_sum_range_query(nums :: [integer], requests :: [[integer]]) :: integer\\n  def max_sum_range_query(nums, requests) do\\n    Enum.reduce(requests, %{}, fn [s, e], map ->\\n      Map.update(map, s, 1, &(&1 + 1))\\n      |> Map.update(e + 1, -1, &(&1 - 1))\\n    end)\\n    |> then(fn map ->\\n      Enum.map(0..length(nums) - 1, &Map.get(map, &1, 0))\\n    end)\\n    |> Enum.scan(&+/2)\\n    |> Enum.sort()\\n    |> Enum.zip_reduce(Enum.sort(nums), 0, fn c, x, acc ->\\n      rem(acc + c * x, 1_000_000_007)\\n    end)\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3778158,
                "title": "sweep-line-prefix-sums",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBY reading the Question only it is easy to deduce that we have to find such a permutation in which the given request sequence sum is maximized. So why not calculate which indexes are appearing most number of times and just put the highest values in that indexes. As simple as that\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe are using Line Sweep algorithm to find out which indexes are appearing the most number of times. and then for the highest number of appearance we are taking the highest number to put there. Basically instead of calculating from the requests we are directly calculating the corresponding contributions and summing them up.\\nBut we have to take care of the INTEGER OVERFLOW cause that can cause an issue. so it is better to start of with long long variables to avoid problems later.$$O(n)$$\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& req) {\\n        vector<int>v(nums.size(),0);\\n        //try calculating which indexes contribute the most to the ans\\n        for(int i=0;i<req.size();i++){\\n            v[req[i][0]]++;\\n           if(req[i][1]+1<nums.size()) v[req[i][1]+1]--;\\n        }\\n        for(int i=0;i<v.size()-1;i++){\\n            v[i+1]+=v[i];\\n        }\\n        //now we have got which index is appearing how many times\\n        vector<pair<long long int,int>>vp;\\n        int p=0;\\n        for(auto &it:v){\\n            vp.push_back({it,p});\\n            p++;\\n        }\\n        sort(vp.begin(),vp.end());\\n        sort(nums.begin(),nums.end());\\n        vector<int>newv(nums.size());\\n        long long int ans=0;\\n        long long int ans1=0;\\n        for(int i=vp.size()-1;i>=0;--i){\\n            newv[vp[i].second]=nums[i];\\n            long long int temp=vp[i].first*nums[i];\\n            ans1=(ans1+temp)%1000000007;\\n        }\\n    \\n        return ans1;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Line Sweep",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& req) {\\n        vector<int>v(nums.size(),0);\\n        //try calculating which indexes contribute the most to the ans\\n        for(int i=0;i<req.size();i++){\\n            v[req[i][0]]++;\\n           if(req[i][1]+1<nums.size()) v[req[i][1]+1]--;\\n        }\\n        for(int i=0;i<v.size()-1;i++){\\n            v[i+1]+=v[i];\\n        }\\n        //now we have got which index is appearing how many times\\n        vector<pair<long long int,int>>vp;\\n        int p=0;\\n        for(auto &it:v){\\n            vp.push_back({it,p});\\n            p++;\\n        }\\n        sort(vp.begin(),vp.end());\\n        sort(nums.begin(),nums.end());\\n        vector<int>newv(nums.size());\\n        long long int ans=0;\\n        long long int ans1=0;\\n        for(int i=vp.size()-1;i>=0;--i){\\n            newv[vp[i].second]=nums[i];\\n            long long int temp=vp[i].first*nums[i];\\n            ans1=(ans1+temp)%1000000007;\\n        }\\n    \\n        return ans1;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713233,
                "title": "easy-c-intuitive-solution",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& req) {\\n        int n = nums.size();\\n        vector<int> pre(n, 0);\\n        for(vector<int> v: req){\\n            pre[v[0]] += 1;\\n            if(v[1] + 1 < n) pre[v[1] + 1] -= 1;\\n        }\\n        for(int i = 1; i < n; i++) pre[i] += pre[i-1];\\n        sort(nums.begin(), nums.end());\\n        sort(pre.begin(), pre.end());\\n\\n        ll res = 0;\\n        for(int i = 0; i < n; i++){\\n            res = (res%mod + ((ll) pre[i] % mod) * nums[i] % mod) % mod;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Line Sweep",
                    "Prefix Sum"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& req) {\\n        int n = nums.size();\\n        vector<int> pre(n, 0);\\n        for(vector<int> v: req){\\n            pre[v[0]] += 1;\\n            if(v[1] + 1 < n) pre[v[1] + 1] -= 1;\\n        }\\n        for(int i = 1; i < n; i++) pre[i] += pre[i-1];\\n        sort(nums.begin(), nums.end());\\n        sort(pre.begin(), pre.end());\\n\\n        ll res = 0;\\n        for(int i = 0; i < n; i++){\\n            res = (res%mod + ((ll) pre[i] % mod) * nums[i] % mod) % mod;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702252,
                "title": "line-sweep-c-tc-o-n-logn-sc-o-n",
                "content": "# Code\\n```\\nint MOD = 1000000007;\\n\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        int n = nums.size(), m = requests.size();\\n\\n        vector<int> tracker(n + 1, 0);\\n        \\n        for (int idx = 0; idx < m; idx++) {\\n            tracker[requests[idx][0]]++;\\n            tracker[requests[idx][1] + 1]--;\\n        }\\n\\n        vector<int> maxOccurences;\\n        \\n        for (int idx = 0; idx < n; idx++) {\\n            if(idx > 0)\\n                tracker[idx] += tracker[idx - 1];\\n\\n            maxOccurences.push_back(tracker[idx]);\\n        }\\n\\n        sort(maxOccurences.begin(), maxOccurences.end());\\n        sort(nums.begin(), nums.end());\\n        \\n        int idx1 = maxOccurences.size() - 1, idx2 = n - 1;\\n        long long totalSum = 0;\\n\\n        while (idx1 >= 0) {\\n            int occurence = maxOccurences[idx1--];\\n            totalSum = (totalSum + ((long long) occurence  * nums[idx2--]) % MOD) % MOD ;\\n        }\\n\\n        return totalSum;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Line Sweep"
                ],
                "code": "```\\nint MOD = 1000000007;\\n\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        int n = nums.size(), m = requests.size();\\n\\n        vector<int> tracker(n + 1, 0);\\n        \\n        for (int idx = 0; idx < m; idx++) {\\n            tracker[requests[idx][0]]++;\\n            tracker[requests[idx][1] + 1]--;\\n        }\\n\\n        vector<int> maxOccurences;\\n        \\n        for (int idx = 0; idx < n; idx++) {\\n            if(idx > 0)\\n                tracker[idx] += tracker[idx - 1];\\n\\n            maxOccurences.push_back(tracker[idx]);\\n        }\\n\\n        sort(maxOccurences.begin(), maxOccurences.end());\\n        sort(nums.begin(), nums.end());\\n        \\n        int idx1 = maxOccurences.size() - 1, idx2 = n - 1;\\n        long long totalSum = 0;\\n\\n        while (idx1 >= 0) {\\n            int occurence = maxOccurences[idx1--];\\n            totalSum = (totalSum + ((long long) occurence  * nums[idx2--]) % MOD) % MOD ;\\n        }\\n\\n        return totalSum;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3678267,
                "title": "c-easy-solution-only-using-for-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        int M = 1e9 + 7;\\n        sort(nums.begin(),nums.end());\\n        int n = nums.size();\\n        vector<int> v(n+2 , 0);\\n        for(int i  = 0 ; i < requests.size() ; i++){\\n            v[requests[i][0]]++;\\n            v[requests[i][1]+1]--;\\n        }\\n        for(int i = 1; i< v.size() ; i++){\\n            v[i] = v[i]+v[i-1];\\n        }\\n        sort(v.begin() ,v.end());\\n        reverse(v.begin(),v.end());\\n        // for(auto x : v){\\n        //     cout<<x<<\" \";\\n        // }\\n        // cout<<endl;\\n        long long int ans  = 0;\\n        for(int i = n ; i > 0 ; i--){\\n            ans = ans + (v[n-i]*1LL*nums[i-1])%M;\\n            ans = ans%M;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        int M = 1e9 + 7;\\n        sort(nums.begin(),nums.end());\\n        int n = nums.size();\\n        vector<int> v(n+2 , 0);\\n        for(int i  = 0 ; i < requests.size() ; i++){\\n            v[requests[i][0]]++;\\n            v[requests[i][1]+1]--;\\n        }\\n        for(int i = 1; i< v.size() ; i++){\\n            v[i] = v[i]+v[i-1];\\n        }\\n        sort(v.begin() ,v.end());\\n        reverse(v.begin(),v.end());\\n        // for(auto x : v){\\n        //     cout<<x<<\" \";\\n        // }\\n        // cout<<endl;\\n        long long int ans  = 0;\\n        for(int i = n ; i > 0 ; i--){\\n            ans = ans + (v[n-i]*1LL*nums[i-1])%M;\\n            ans = ans%M;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3663486,
                "title": "swift-easy-solutions",
                "content": "\\n# Code\\n```\\nclass Solution {\\n   func maxSumRangeQuery(_ nums: [Int], _ requests: [[Int]]) -> Int {\\n    var count = Array(repeating: 0, count: nums.count)\\n    for i in 0..<requests.count{\\n        count[requests[i][0]] += 1\\n        if requests[i][1] + 1 < nums.count{\\n            count[requests[i][1] + 1] -= 1\\n        }\\n    }\\n    \\n    for i in 1..<nums.count{\\n        count[i] += count[i-1]\\n    }\\n    count = count.sorted()\\n    var nums = nums.sorted()\\n    var mod = 1e9+7\\n    var sum = 0\\n    \\n    for i in 0..<nums.count{\\n        sum += count[i] * nums[i]\\n        sum%=Int(mod)\\n    }\\n    return sum\\n}\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n   func maxSumRangeQuery(_ nums: [Int], _ requests: [[Int]]) -> Int {\\n    var count = Array(repeating: 0, count: nums.count)\\n    for i in 0..<requests.count{\\n        count[requests[i][0]] += 1\\n        if requests[i][1] + 1 < nums.count{\\n            count[requests[i][1] + 1] -= 1\\n        }\\n    }\\n    \\n    for i in 1..<nums.count{\\n        count[i] += count[i-1]\\n    }\\n    count = count.sorted()\\n    var nums = nums.sorted()\\n    var mod = 1e9+7\\n    var sum = 0\\n    \\n    for i in 0..<nums.count{\\n        sum += count[i] * nums[i]\\n        sum%=Int(mod)\\n    }\\n    return sum\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3641213,
                "title": "retrieves-one-of-the-possible-correct-orders",
                "content": "# Code\\n```\\n#define ll long long\\n#define mod (int)1e9+7\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& v, vector<vector<int>>& r) {\\n        int n = v.size(), q = r.size();\\n        vector<int>pre_v(n);\\n        for(int i=0; i<q; i++){\\n            int a = r[i][0], b = r[i][1]+1;\\n            pre_v[a] += 1;\\n            if(b<n) pre_v[b] -= 1;\\n        }\\n\\n        for(int i=1; i<n; i++){\\n            pre_v[i] += pre_v[i-1];\\n        }\\n        vector<pair<int, int>>vp(n);\\n        for(int i=0; i<n; i++){\\n            vp[i] = {pre_v[i], i};\\n        }\\n        sort(vp.rbegin(), vp.rend());\\n        vector<int>new_v(n);\\n        sort(v.rbegin(), v.rend());\\n        for(int i=0; i<n; i++){\\n            new_v[vp[i].second] = v[i]; \\n        }\\n\\n        for(auto x: new_v) cout<< x << \\' \\';  // prints one of the possible orders for the maximum sum\\n\\n        for(int i=1; i<n; i++){\\n            new_v[i] += new_v[i-1];\\n        }\\n\\n        ll ans = 0;\\n        for(int i=0; i<q; i++){\\n            int a = r[i][0] - 1, b = r[i][1];\\n            (ans += new_v[b] - (a>=0?new_v[a]:0)) %= mod;\\n        }     \\n        return ans;  \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\n#define mod (int)1e9+7\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& v, vector<vector<int>>& r) {\\n        int n = v.size(), q = r.size();\\n        vector<int>pre_v(n);\\n        for(int i=0; i<q; i++){\\n            int a = r[i][0], b = r[i][1]+1;\\n            pre_v[a] += 1;\\n            if(b<n) pre_v[b] -= 1;\\n        }\\n\\n        for(int i=1; i<n; i++){\\n            pre_v[i] += pre_v[i-1];\\n        }\\n        vector<pair<int, int>>vp(n);\\n        for(int i=0; i<n; i++){\\n            vp[i] = {pre_v[i], i};\\n        }\\n        sort(vp.rbegin(), vp.rend());\\n        vector<int>new_v(n);\\n        sort(v.rbegin(), v.rend());\\n        for(int i=0; i<n; i++){\\n            new_v[vp[i].second] = v[i]; \\n        }\\n\\n        for(auto x: new_v) cout<< x << \\' \\';  // prints one of the possible orders for the maximum sum\\n\\n        for(int i=1; i<n; i++){\\n            new_v[i] += new_v[i-1];\\n        }\\n\\n        ll ans = 0;\\n        for(int i=0; i<q; i++){\\n            int a = r[i][0] - 1, b = r[i][1];\\n            (ans += new_v[b] - (a>=0?new_v[a]:0)) %= mod;\\n        }     \\n        return ans;  \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3564544,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& rq) {\\n        long long ans=0;\\n        int N=1e9+7;\\n        sort(nums.begin() , nums.end() , greater<int>());\\n        int n=nums.size();\\n        int m=rq.size();\\n        vector<int>freq(n);\\n        for(int i=0;i<m;i++){\\n             freq[rq[i][0]]++;\\n             if(rq[i][1]!=n-1){\\n                 freq[rq[i][1]+1]--;\\n             }\\n        }\\n\\n        // find prefix array\\n        for(int i=1;i<n;i++){\\n            freq[i]+=freq[i-1];\\n        }\\n        sort(freq.begin() , freq.end() , greater<int>());\\n        for(auto i:freq) cout<<i<<\" \";\\n        for(int i=0;i<n;i++){\\n            ans=(ans+((long long)freq[i]*(long long)nums[i]))%N;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& rq) {\\n        long long ans=0;\\n        int N=1e9+7;\\n        sort(nums.begin() , nums.end() , greater<int>());\\n        int n=nums.size();\\n        int m=rq.size();\\n        vector<int>freq(n);\\n        for(int i=0;i<m;i++){\\n             freq[rq[i][0]]++;\\n             if(rq[i][1]!=n-1){\\n                 freq[rq[i][1]+1]--;\\n             }\\n        }\\n\\n        // find prefix array\\n        for(int i=1;i<n;i++){\\n            freq[i]+=freq[i-1];\\n        }\\n        sort(freq.begin() , freq.end() , greater<int>());\\n        for(auto i:freq) cout<<i<<\" \";\\n        for(int i=0;i<n;i++){\\n            ans=(ans+((long long)freq[i]*(long long)nums[i]))%N;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3561263,
                "title": "simple-easy-to-understand-solution-codechef-c",
                "content": "# Intuition\\n1st time i saw this problem in codechef(\"Maximum Sum Permutation\") and in search of some hint for that problem i come to this problem basically both the problems are same the only difference is that here we don\\'t have to print the result array and in codechef problem we have to print the array.\\nThe intution is simple we just have to count the occurances of the perticular element and then we will place the maximum number we have in array to the maximum frequent item.\\n\\n# Approach\\nWe have to find the frequency of the elements and then we will multiply the maxfrequency item to the maximum number we are having and in that way we will also find the sum.\\nHere I\\'m also involving code for finding the result array which we have to print in the codechef contest problem\\n\\n# Complexity\\n- Time complexity:\\nO(nlog(n))\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n#define M 1000000007\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        int n = nums.size();\\n        vector<int> power(n+2, 0);\\n        vector<vector<int> > vv;\\n        ll ans(0);\\n        for(auto i : requests){\\n            ++power[i[0]];\\n            --power[i[1]+1];\\n        }\\n        vv.push_back({power[0], 0});\\n        int p(0);\\n        for(int i = 1; i <= n; i++){\\n            power[i] += power[i-1];\\n            vv.push_back({power[i], i});\\n        }\\n        sort(vv.begin(), vv.end());\\n        reverse(vv.begin(), vv.end());\\n        //sort(power.begin(), power.end(), greater<int>());\\n        sort(nums.begin(), nums.end(), greater<int>());\\n        for(int i = 0; i < n; i++){\\n            ans += (ll)1*nums[i]*vv[i][0];\\n            power[vv[i][1]] = nums[i];\\n            ans%=M;\\n        }\\n        for(int i = 1; i <= n; i++){\\n            cout<<power[i]<<\" \";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sort",
                    "Sorting",
                    "Bucket Sort"
                ],
                "code": "```\\n#define M 1000000007\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        int n = nums.size();\\n        vector<int> power(n+2, 0);\\n        vector<vector<int> > vv;\\n        ll ans(0);\\n        for(auto i : requests){\\n            ++power[i[0]];\\n            --power[i[1]+1];\\n        }\\n        vv.push_back({power[0], 0});\\n        int p(0);\\n        for(int i = 1; i <= n; i++){\\n            power[i] += power[i-1];\\n            vv.push_back({power[i], i});\\n        }\\n        sort(vv.begin(), vv.end());\\n        reverse(vv.begin(), vv.end());\\n        //sort(power.begin(), power.end(), greater<int>());\\n        sort(nums.begin(), nums.end(), greater<int>());\\n        for(int i = 0; i < n; i++){\\n            ans += (ll)1*nums[i]*vv[i][0];\\n            power[vv[i][1]] = nums[i];\\n            ans%=M;\\n        }\\n        for(int i = 1; i <= n; i++){\\n            cout<<power[i]<<\" \";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3380927,
                "title": "java-prefix-and-line-sweep",
                "content": "# Approach\\n1. Looking at the intervals, we observe that some intervals/numbers are in higher demand, are more frequent that others. EG: [[1,3],[0,1]]. Index 1 is requested twice, 0 once, 2 & 3 once.\\n2. It makes sense to put the highest numbers at the most requested intervals/indices\\n3. On an int[] mark the presence of intervals with +1 (beginning) and -1 (ending index + 1)\\n    - eg: [1,3] and [0,1] will\\n   - [1,3] -> [0,+1,0,0,-1] (index 1 will be marked with +1 and index 4 with -1)\\n    - [0,1] -> [+1,+2,-1,0,-1]\\n4. Run a line sweep from 0 to n and determine the bonus/stat of each index\\n    => [+1,+2,+1,+1, -1]\\n    - We see that index 0 and 2 and 3 are requested 1 time and index 1 twice.\\n5. Sort the bonus array [-1,1,1,1,2]\\n6. Sort the given numbers (eg:) [1,2,3,4,5]\\n7. From i = n to 0 or while bonus > 0, multiply the bonus [-1,1,1,1,2] with the highest numbers [i].\\n    - eg: 5 * 2 + 1 * 1 + 1 * 3.. etc\\n8. Return the modulo.\\n\\n# Complexity\\n- Time complexity:$$O(n logn + nlogn + 2*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxSumRangeQuery(int[] nums, int[][] requests) {\\n        Arrays.sort(nums);\\n        int[] mostFrequentNumbers = getMostFrequentNumbers(requests, nums.length);\\n        return getTopNumbersByReference(nums, mostFrequentNumbers);\\n    }\\n\\n    private int getTopNumbersByReference(int[] nums, int[] intervalRelevance) {\\n        long sum = 0L;\\n        for (int j = intervalRelevance.length -1, i = nums.length -1; j >=0 && intervalRelevance[j] > 0; j--) {\\n            sum += (long) nums[i] * intervalRelevance[j];\\n            i--;\\n        }\\n        return (int) (sum % 1_000_000_007);\\n    }\\n\\n    private int[] getMostFrequentNumbers(int[][] requests, int n) {\\n        int[] mostFrequent =  new int[n+1];\\n        for (int[] request : requests) {\\n            mostFrequent[request[0]]++;\\n            mostFrequent[request[1]+1]--;\\n        }\\n\\n        int bonus = 0;\\n        for (int i = 0; i < mostFrequent.length; i++) {\\n            bonus += mostFrequent[i];\\n            mostFrequent[i] = bonus;\\n        }\\n\\n        Arrays.sort(mostFrequent);\\n        return mostFrequent;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumRangeQuery(int[] nums, int[][] requests) {\\n        Arrays.sort(nums);\\n        int[] mostFrequentNumbers = getMostFrequentNumbers(requests, nums.length);\\n        return getTopNumbersByReference(nums, mostFrequentNumbers);\\n    }\\n\\n    private int getTopNumbersByReference(int[] nums, int[] intervalRelevance) {\\n        long sum = 0L;\\n        for (int j = intervalRelevance.length -1, i = nums.length -1; j >=0 && intervalRelevance[j] > 0; j--) {\\n            sum += (long) nums[i] * intervalRelevance[j];\\n            i--;\\n        }\\n        return (int) (sum % 1_000_000_007);\\n    }\\n\\n    private int[] getMostFrequentNumbers(int[][] requests, int n) {\\n        int[] mostFrequent =  new int[n+1];\\n        for (int[] request : requests) {\\n            mostFrequent[request[0]]++;\\n            mostFrequent[request[1]+1]--;\\n        }\\n\\n        int bonus = 0;\\n        for (int i = 0; i < mostFrequent.length; i++) {\\n            bonus += mostFrequent[i];\\n            mostFrequent[i] = bonus;\\n        }\\n\\n        Arrays.sort(mostFrequent);\\n        return mostFrequent;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3358339,
                "title": "solution-using-prefix-sum-and-sorting",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        vector<int> ren( 100002 , 0);\\n        int mod = 1e9+7 ; \\n        for( auto x : requests){\\n            ren[x[0]]+=1;\\n            ren[x[1]+1]-=1;\\n        }\\n        // for( auto x : ren)cout<<x<<\" \";\\n        vector<int> ps(100002 , 0);\\n        ps[0]=ren[0];\\n        for( int i =1 ; i< 100002 ; i++){\\n            ps[i]= ps[i-1]+ren[i];\\n        }\\n        sort(ps.begin() ,ps.end(), greater<int>());\\n        \\n        sort(nums.begin(), nums.end(), greater<int>());\\n        long  long ans=0;\\n            for( int i =0; i<nums.size(); i++ ){\\n                ans = ( ans + ( (nums[i]*1ll)*(ps[i]*1ll) * 1ll))%mod;\\n            }\\n        return ans%mod;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        vector<int> ren( 100002 , 0);\\n        int mod = 1e9+7 ; \\n        for( auto x : requests){\\n            ren[x[0]]+=1;\\n            ren[x[1]+1]-=1;\\n        }\\n        // for( auto x : ren)cout<<x<<\" \";\\n        vector<int> ps(100002 , 0);\\n        ps[0]=ren[0];\\n        for( int i =1 ; i< 100002 ; i++){\\n            ps[i]= ps[i-1]+ren[i];\\n        }\\n        sort(ps.begin() ,ps.end(), greater<int>());\\n        \\n        sort(nums.begin(), nums.end(), greater<int>());\\n        long  long ans=0;\\n            for( int i =0; i<nums.size(); i++ ){\\n                ans = ( ans + ( (nums[i]*1ll)*(ps[i]*1ll) * 1ll))%mod;\\n            }\\n        return ans%mod;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3292938,
                "title": "c-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\nUsed amount of time for tests - 450ms\\n\\n- Space complexity:\\nO(N)\\nUsed amount of memory for tests - 62MB\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaxSumRangeQuery(int[] nums, int[][] requests) {\\n        int mod = (int) 1e9 + 7;\\n        int n = nums.Length;\\n        int[] freq = new int[n];\\n        for(int i=0; i < requests.Length; i++) {\\n            freq[requests[i][0]]++;\\n            if(requests[i][1] + 1 < n)\\n                freq[requests[i][1] + 1]--;\\n        }\\n        for (int i = 1; i < n; i ++) {\\n            freq[i] += freq[i - 1];\\n        }\\n        Array.Sort(nums);\\n        Array.Sort(freq);\\n        int max = 0;\\n        for (int i = 0; i < nums.Length; i++) {\\n            max = (int) (((long) nums[i] * freq[i] + max) % mod);\\n        }\\n        return max;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Greedy",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxSumRangeQuery(int[] nums, int[][] requests) {\\n        int mod = (int) 1e9 + 7;\\n        int n = nums.Length;\\n        int[] freq = new int[n];\\n        for(int i=0; i < requests.Length; i++) {\\n            freq[requests[i][0]]++;\\n            if(requests[i][1] + 1 < n)\\n                freq[requests[i][1] + 1]--;\\n        }\\n        for (int i = 1; i < n; i ++) {\\n            freq[i] += freq[i - 1];\\n        }\\n        Array.Sort(nums);\\n        Array.Sort(freq);\\n        int max = 0;\\n        for (int i = 0; i < nums.Length; i++) {\\n            max = (int) (((long) nums[i] * freq[i] + max) % mod);\\n        }\\n        return max;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3212969,
                "title": "prefix-sum-line-seeping-sorting-multimap-with-commented-code",
                "content": "# Intuition\\nprefix sum  and line sweeping technique\\ncrux--> we will try to know the number of request for each indexes with help of sweepin technique\\nNow to make the total sum maximum,we have to put the largest element at the index whose request is highest(so that highest number will contribute more to the total sum) and so on.\\n\\n# Complexity\\n- Time complexity:\\nO(NlogN)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint mod=1e9+7;\\n\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end(),greater<int>());\\n       long long ans=0;\\n        vector<int>ls(n+1,0);\\n        for(auto it:requests)\\n        {\\n            int st=it[0];\\n            int end=it[1];\\n            ls[st] +=1;\\n            ls[end+1] -=1;\\n        }\\n\\n        //count the number of request for each indexes in map [freq,index]\\n        //we could have also used multiset because we only need freq not index (as we dont need to return permutation)\\n        multimap<int,int>mp;\\n        int s=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            s +=ls[i];\\n           mp.insert({s,i});\\n        }\\n       \\n       int i=0;\\n        for(auto it=mp.rbegin();it!=mp.rend();it++)\\n        {\\n            long long freq=it->first;\\n            int index=it->second;\\n           ans=(ans+(freq*nums[i])%mod)%mod;\\n           i++;\\n        }\\n\\n\\n\\n  return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Line Sweep",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint mod=1e9+7;\\n\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end(),greater<int>());\\n       long long ans=0;\\n        vector<int>ls(n+1,0);\\n        for(auto it:requests)\\n        {\\n            int st=it[0];\\n            int end=it[1];\\n            ls[st] +=1;\\n            ls[end+1] -=1;\\n        }\\n\\n        //count the number of request for each indexes in map [freq,index]\\n        //we could have also used multiset because we only need freq not index (as we dont need to return permutation)\\n        multimap<int,int>mp;\\n        int s=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            s +=ls[i];\\n           mp.insert({s,i});\\n        }\\n       \\n       int i=0;\\n        for(auto it=mp.rbegin();it!=mp.rend();it++)\\n        {\\n            long long freq=it->first;\\n            int index=it->second;\\n           ans=(ans+(freq*nums[i])%mod)%mod;\\n           i++;\\n        }\\n\\n\\n\\n  return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3136811,
                "title": "get-count-for-every-index-coming-in-requests",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        long long n = nums.size(), i, ans = 0, mod = 1e9+7;\\n        vector <long> v(n+1, 0);\\n        for (auto x : requests) {\\n            v[x[0]]++;\\n            v[x[1]+1]--;\\n        }\\n        for (i=1;i<=n;i++)\\n        v[i] += v[i-1];\\n        sort(v.rbegin(), v.rend());\\n        sort(nums.rbegin(), nums.rend());\\n        for (i=0;i<n;i++)\\n        ans = (ans + (v[i]*nums[i])%mod)%mod;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        long long n = nums.size(), i, ans = 0, mod = 1e9+7;\\n        vector <long> v(n+1, 0);\\n        for (auto x : requests) {\\n            v[x[0]]++;\\n            v[x[1]+1]--;\\n        }\\n        for (i=1;i<=n;i++)\\n        v[i] += v[i-1];\\n        sort(v.rbegin(), v.rend());\\n        sort(nums.rbegin(), nums.rend());\\n        for (i=0;i<n;i++)\\n        ans = (ans + (v[i]*nums[i])%mod)%mod;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108514,
                "title": "sweepline-algorithm-python",
                "content": "```\\nclass Solution:\\n    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\\n        \\n        sweepline = [0] * len(nums)\\n        \\n        for u,v in requests:\\n            sweepline[u] += 1\\n            if v+1 < len(nums):\\n                sweepline[v+1] -= 1\\n            \\n        priority = list(accumulate(sweepline)) # get how many times does a particular index is used\\n        \\n        priority.sort(reverse=1)\\n        nums.sort(reverse=1)\\n        \\n        res = 0\\n        for i,j in zip(priority, nums):\\n            res += i*j\\n            \\n        return res%1000000007\\n            \\n        \\n````",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\\n        \\n        sweepline = [0] * len(nums)\\n        \\n        for u,v in requests:\\n            sweepline[u] += 1\\n            if v+1 < len(nums):\\n                sweepline[v+1] -= 1\\n            \\n        priority = list(accumulate(sweepline)) # get how many times does a particular index is used\\n        \\n        priority.sort(reverse=1)\\n        nums.sort(reverse=1)\\n        \\n        res = 0\\n        for i,j in zip(priority, nums):\\n            res += i*j\\n            \\n        return res%1000000007\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083095,
                "title": "c-create-hash-table-of-ranges-then-add-to-heap",
                "content": "Honestly could optimize this solution but it does not TLE and the big picture approach of it is correct I think.\\n```\\nclass Solution {\\npublic:\\n    \\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        vector<int> t(100001);\\n        unordered_map<int,int> freq;\\n        for (auto& v : requests){\\n            ++t[v[0]];\\n            --t[v[1] + 1];\\n        }\\n        int cur = 0;\\n        for (auto& n : t){\\n            cur += n;\\n            ++freq[cur];\\n        }\\n        sort(nums.begin(), nums.end());\\n        long long ans = 0;\\n        priority_queue<pair<int,int>> q;\\n        for (auto& [f,s] : freq)\\n            if (f != 0) q.push({f, s});\\n        int i = nums.size() - 1;\\n        while (!q.empty() && i > -1){\\n            auto [f,s] = q.top();\\n            q.pop();\\n            long next = nums[i--];\\n            ans += next * f;\\n            ans %= 1000000007;\\n            if (s > 1) q.push({f, s - 1});\\n        }\\n        return ans;   \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        vector<int> t(100001);\\n        unordered_map<int,int> freq;\\n        for (auto& v : requests){\\n            ++t[v[0]];\\n            --t[v[1] + 1];\\n        }\\n        int cur = 0;\\n        for (auto& n : t){\\n            cur += n;\\n            ++freq[cur];\\n        }\\n        sort(nums.begin(), nums.end());\\n        long long ans = 0;\\n        priority_queue<pair<int,int>> q;\\n        for (auto& [f,s] : freq)\\n            if (f != 0) q.push({f, s});\\n        int i = nums.size() - 1;\\n        while (!q.empty() && i > -1){\\n            auto [f,s] = q.top();\\n            q.pop();\\n            long next = nums[i--];\\n            ans += next * f;\\n            ans %= 1000000007;\\n            if (s > 1) q.push({f, s - 1});\\n        }\\n        return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3073678,
                "title": "explaining-the-frequency-array-an-integral",
                "content": "# Intuition\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCameras contains the number of cameras at each intersection where cameras[i] = the number of cameras at intersection $i$. Requests contains all the intesection ranges where you used a boost to speed up temporarily.\\n\\nYour sus score, measuring how likely you are to get pulled over, is given by the sum of, $speed[i] * cameras[i]$ for intersection $i$, across all intersections. Find the maximum sus score you can obtain for any permutation of the number of Cameras at each intersection.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe integral of acceleration is speed (velocity). Before acceleration is integrated, the 1 and -1 offsets represent changes in the rate of change. The rate of change increases by 1, decreases by 1, etc.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def maxSumRangeQuery(self, cameras: List[int], requests: List[List[int]]) -> int:\\n        position = [0] * len(nums)\\n        acceleration = [0] * len(nums)\\n        for l,r in requests:\\n            # speed up\\n            acceleration[l] += 1\\n            if r+1 < len(acceleration):\\n                # slow down\\n                acceleration[r+1] -= 1\\n\\n        # change acceleration to speed (integral)\\n        for i in range(1, len(acceleration)):\\n            acceleration[i] += acceleration[i-1]\\n\\n        # make the max speeds match with the max cameras\\n        cameras = sorted(cameras)\\n        speed = sorted(acceleration)\\n        return sum([n*c for n,c in zip(cameras, speed)]) % ((10**9)+7)\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumRangeQuery(self, cameras: List[int], requests: List[List[int]]) -> int:\\n        position = [0] * len(nums)\\n        acceleration = [0] * len(nums)\\n        for l,r in requests:\\n            # speed up\\n            acceleration[l] += 1\\n            if r+1 < len(acceleration):\\n                # slow down\\n                acceleration[r+1] -= 1\\n\\n        # change acceleration to speed (integral)\\n        for i in range(1, len(acceleration)):\\n            acceleration[i] += acceleration[i-1]\\n\\n        # make the max speeds match with the max cameras\\n        cameras = sorted(cameras)\\n        speed = sorted(acceleration)\\n        return sum([n*c for n,c in zip(cameras, speed)]) % ((10**9)+7)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039047,
                "title": "intuitive-soft-proof",
                "content": "hey?\\nlets talk about the proof,\\nwhy do we need to consider maximum element at the index with highest request frequency\\n\\nsuppose there are n index, with r1,r2.... rn requests\\nr1<=r2<=r3<=....<=rn\\n\\nat every index among r1..rn we have to fill element\\n\\nsuppose m is our maximum element in the array,\\n\\ncase 1: we dont use m\\n\\nso all the indexes are filled with elements less than m,\\nit can be intuitively observed that , if we replace any element with m,we will get greater answer.\\n\\ncase 2: we use m \\n\\nif we dont use m to fill the index with highest frequency,\\nthen m is used to fill other index, and some other element with less value is used to fill the index with highest freq\\n\\nlets say the two indexes be\\nia,ib\\nwhere ib has more frequency ( or greater occurences in request array)\\nia is filled with greatest element\\nand ib is filled with element (say e) which is smaller than the greatest element\\n\\nminfill=min(ia,ib)\\n\\nnow here\\'s the catch,\\nif you intuitively observe, you\\'d find that\\nwhen we fill both the indexes,\\nminfill requests when served , yiled the same answer,\\nbut for ib, remaining requests are ib-minfill\\n\\nthis is filled by element which is smaller than greatest element\\n\\nso we can clearly see, it is always optimal to use greatest element to fill the index with highest request freq\\n",
                "solutionTags": [],
                "code": "hey?\\nlets talk about the proof,\\nwhy do we need to consider maximum element at the index with highest request frequency\\n\\nsuppose there are n index, with r1,r2.... rn requests\\nr1<=r2<=r3<=....<=rn\\n\\nat every index among r1..rn we have to fill element\\n\\nsuppose m is our maximum element in the array,\\n\\ncase 1: we dont use m\\n\\nso all the indexes are filled with elements less than m,\\nit can be intuitively observed that , if we replace any element with m,we will get greater answer.\\n\\ncase 2: we use m \\n\\nif we dont use m to fill the index with highest frequency,\\nthen m is used to fill other index, and some other element with less value is used to fill the index with highest freq\\n\\nlets say the two indexes be\\nia,ib\\nwhere ib has more frequency ( or greater occurences in request array)\\nia is filled with greatest element\\nand ib is filled with element (say e) which is smaller than the greatest element\\n\\nminfill=min(ia,ib)\\n\\nnow here\\'s the catch,\\nif you intuitively observe, you\\'d find that\\nwhen we fill both the indexes,\\nminfill requests when served , yiled the same answer,\\nbut for ib, remaining requests are ib-minfill\\n\\nthis is filled by element which is smaller than greatest element\\n\\nso we can clearly see, it is always optimal to use greatest element to fill the index with highest request freq\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2993708,
                "title": "python3-greedy-calculate-freq-w-comments",
                "content": "# Intuition\\nIt is obvious that we should not go for generating all permutations and then run the requests i.e brute force way. \\nIf we see the requests then one thing is to note that these request can be overlapping and if we place maximmum values on these places , this will give us maximum total.\\nSo this suggests that , we should look for indices which occured max number of times in requests and place higher values there.\\n\\n# Approach\\nlook for indices which has mximum occurence in requests. With simple\\niteration we will ger TLE as it might run for o(n*n). We can use prefix sum to optimize it\\n\\n# Complexity\\n- Time complexity:\\nO(nlongn)\\n\\n- Space complexity:\\n $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\\n        n = len(nums)\\n        freq = [0]*(n+1)\\n        for i, j in requests:\\n            freq[i] += 1\\n            freq[j + 1] -= 1\\n        for i in range(1, n + 1):\\n            freq[i] += freq[i - 1]\\n        freq.sort(reverse=True)\\n        nums.sort(reverse=True)\\n        \\n        total = 0\\n        for i in range(n):\\n            if freq[i]:\\n                total +=  (nums[i] * freq[i]) % 1000000007\\n            else:\\n                break\\n        return total%1000000007\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\\n        n = len(nums)\\n        freq = [0]*(n+1)\\n        for i, j in requests:\\n            freq[i] += 1\\n            freq[j + 1] -= 1\\n        for i in range(1, n + 1):\\n            freq[i] += freq[i - 1]\\n        freq.sort(reverse=True)\\n        nums.sort(reverse=True)\\n        \\n        total = 0\\n        for i in range(n):\\n            if freq[i]:\\n                total +=  (nums[i] * freq[i]) % 1000000007\\n            else:\\n                break\\n        return total%1000000007\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947148,
                "title": "java-very-simple-count-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maxSumRangeQuery(int[] nums, int[][] requests) {\\n        int N = nums.length;\\n        int[] hm = new int[N+1];\\n        long mod = 1_000_000_007;\\n\\n        for(int[] req : requests) {\\n            int s = req[0];\\n            int e = req[1];\\n\\n            hm[s]++;\\n            hm[e+1]--;\\n        }\\n\\n        long[] arr = new long[N];\\n        long cur = 0;\\n        for(int i=0; i<N; i++) {\\n            cur += hm[i];\\n            arr[i] = cur;\\n        }\\n\\n        Arrays.sort(arr);\\n        Arrays.sort(nums);\\n\\n        long ans = 0;\\n        for(int i=N-1; i>=0; i--) {\\n            ans = (ans + arr[i]*(long)nums[i]) % mod;\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumRangeQuery(int[] nums, int[][] requests) {\\n        int N = nums.length;\\n        int[] hm = new int[N+1];\\n        long mod = 1_000_000_007;\\n\\n        for(int[] req : requests) {\\n            int s = req[0];\\n            int e = req[1];\\n\\n            hm[s]++;\\n            hm[e+1]--;\\n        }\\n\\n        long[] arr = new long[N];\\n        long cur = 0;\\n        for(int i=0; i<N; i++) {\\n            cur += hm[i];\\n            arr[i] = cur;\\n        }\\n\\n        Arrays.sort(arr);\\n        Arrays.sort(nums);\\n\\n        long ans = 0;\\n        for(int i=N-1; i>=0; i--) {\\n            ans = (ans + arr[i]*(long)nums[i]) % mod;\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2863083,
                "title": "python-prefix-sum-and-sorting-based-solution-faster-than-98-o-n-log-n",
                "content": "```\\nclass Solution:\\n    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\\n        count = [0] * len(nums)\\n        for start, end in requests:\\n            count[start] += 1\\n            if end + 1 < len(nums):\\n                count[end + 1] -= 1\\n        count, res = list(accumulate(count)), 0\\n        nums.sort(); count.sort()\\n        for num, cnt in zip(nums, count):\\n            res = (res + (num * cnt)) % 1000000007\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\\n        count = [0] * len(nums)\\n        for start, end in requests:\\n            count[start] += 1\\n            if end + 1 < len(nums):\\n                count[end + 1] -= 1\\n        count, res = list(accumulate(count)), 0\\n        nums.sort(); count.sort()\\n        for num, cnt in zip(nums, count):\\n            res = (res + (num * cnt)) % 1000000007\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2848532,
                "title": "c-sorting-prefix-sum-tc-o-nlog-n",
                "content": "```\\n/*\\n\\tApproach : Logic is simple the index which occur maximum times in range at that place we place maximum \\n\\telement from nums.\\n\\tSo first find occurence of each index then maximum element from nums are placed at max occurence index\\n*/\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& req) {\\n        int n = nums.size();\\n        vector<int> dp(n+1,0);\\n        for(auto &v:req){\\n            dp[v[0]]++;\\n            dp[v[1]+1]--;\\n        }\\n        int sum = 0;\\n        for(int i=0;i<=n;i++){\\n            sum+=dp[i];\\n            dp[i] = sum;\\n        }\\n        long long ans = 0;\\n        sort(dp.begin(),dp.end(),greater<int>());\\n        sort(nums.begin(),nums.end(),greater<int>());\\n        for(int i=0;i<n;i++){\\n            ans= (ans + ((long)nums[i]*dp[i]))%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nIf You Like Solution Please Upvote :)\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\n/*\\n\\tApproach : Logic is simple the index which occur maximum times in range at that place we place maximum \\n\\telement from nums.\\n\\tSo first find occurence of each index then maximum element from nums are placed at max occurence index\\n*/\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& req) {\\n        int n = nums.size();\\n        vector<int> dp(n+1,0);\\n        for(auto &v:req){\\n            dp[v[0]]++;\\n            dp[v[1]+1]--;\\n        }\\n        int sum = 0;\\n        for(int i=0;i<=n;i++){\\n            sum+=dp[i];\\n            dp[i] = sum;\\n        }\\n        long long ans = 0;\\n        sort(dp.begin(),dp.end(),greater<int>());\\n        sort(nums.begin(),nums.end(),greater<int>());\\n        for(int i=0;i<n;i++){\\n            ans= (ans + ((long)nums[i]*dp[i]))%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2835251,
                "title": "c-line-sweep-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe max element should be placed such that is is used max times in the requests.\\nThe second max to be used 2nd max times and so on.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStore the counts of a index used in the requests using line sweep method.\\nNow sort both the num array and count array.\\nThe max element to be used max times so we just need to multiply the counts with the array indices.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    ll M = 1e9+7;\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<int> cnt(n+1,0);\\n        for(auto i:requests){\\n            cnt[i[0]]++;\\n            cnt[i[1]+1]--;\\n        }\\n        for(int i=1; i<=n; i++){\\n            cnt[i] += cnt[i-1];\\n        }\\n        sort(cnt.begin(), cnt.end());\\n        int j = n-1; ll ans = 0;\\n        for(int i=n; cnt[i]>0; i--){\\n            ans += (ll)nums[j--]*(ll)cnt[i];\\n            ans %= M;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Line Sweep",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    ll M = 1e9+7;\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<int> cnt(n+1,0);\\n        for(auto i:requests){\\n            cnt[i[0]]++;\\n            cnt[i[1]+1]--;\\n        }\\n        for(int i=1; i<=n; i++){\\n            cnt[i] += cnt[i-1];\\n        }\\n        sort(cnt.begin(), cnt.end());\\n        int j = n-1; ll ans = 0;\\n        for(int i=n; cnt[i]>0; i--){\\n            ans += (ll)nums[j--]*(ll)cnt[i];\\n            ans %= M;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2816775,
                "title": "javascript-count-and-sort-solution",
                "content": "# Complexity\\n- Time complexity: O(n log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number[][]} requests\\n * @return {number}\\n */\\nvar maxSumRangeQuery = function(nums, requests) {\\n    const duplicated = new Array(nums.length).fill(0)\\n    for(let i = 0; i < requests.length ; i++){\\n        const [ start, end ] = requests[i]\\n        duplicated[start] += 1\\n        if(end !== nums.length -1){\\n            duplicated[end+1] -=1\\n        }\\n    }\\n    const values = []\\n    let sum = 0;\\n    for(let i = 0; i < duplicated.length; i++){\\n        sum += duplicated[i]\\n        values[i] = sum\\n    }\\n    let result = 0\\n    nums.sort((a,b)=> { return a < b ? 1 : -1 })\\n    values.sort((a,b)=> { return a < b ? 1 : -1 })\\n    console.log(values)\\n\\n    for(let i = 0; i < values.length; i++){\\n        result = result + (values[i] * nums[i])\\n    }\\n    return result % 1000000007\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number[][]} requests\\n * @return {number}\\n */\\nvar maxSumRangeQuery = function(nums, requests) {\\n    const duplicated = new Array(nums.length).fill(0)\\n    for(let i = 0; i < requests.length ; i++){\\n        const [ start, end ] = requests[i]\\n        duplicated[start] += 1\\n        if(end !== nums.length -1){\\n            duplicated[end+1] -=1\\n        }\\n    }\\n    const values = []\\n    let sum = 0;\\n    for(let i = 0; i < duplicated.length; i++){\\n        sum += duplicated[i]\\n        values[i] = sum\\n    }\\n    let result = 0\\n    nums.sort((a,b)=> { return a < b ? 1 : -1 })\\n    values.sort((a,b)=> { return a < b ? 1 : -1 })\\n    console.log(values)\\n\\n    for(let i = 0; i < values.length; i++){\\n        result = result + (values[i] * nums[i])\\n    }\\n    return result % 1000000007\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2799283,
                "title": "c",
                "content": "Runtime: 391 ms, faster than 100.00% of C online submissions for Maximum Sum Obtained of Any Permutation.\\nMemory Usage: 32.9 MB, less than 57.14% of C online submissions for Maximum Sum Obtained of Any Permutation.\\n```\\nint cmpfunc(const void* a, const void* b){\\n    return *(int*)b - *(int*)a;\\n}\\nint maxSumRangeQuery(int* nums, int numsSize, int** requests, int requestsSize, int* requestsColSize){\\n    int mod = 1e9 + 7;\\n    int n = numsSize;\\n    int* prefix = calloc((n+1) , sizeof(int));\\n    for(int i = 0; i < requestsSize; i++){\\n        prefix[requests[i][0]] += 1;\\n        prefix[requests[i][1] + 1] -= 1;\\n    }\\n    for(int i = 1; i < n; i++){\\n        prefix[i] += prefix[i-1];    \\n    }\\n    qsort(nums, n, sizeof(int), cmpfunc);\\n    qsort(prefix, n, sizeof(int), cmpfunc);\\n    int sum = 0;\\n    for(int i = 0; i < n; i++){\\n        if(prefix[i] == 0)\\n            break;\\n        sum = (sum + (long long)prefix[i]*nums[i] % mod) % mod;\\n    }\\n    return sum;\\n}\\n```",
                "solutionTags": [
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nint cmpfunc(const void* a, const void* b){\\n    return *(int*)b - *(int*)a;\\n}\\nint maxSumRangeQuery(int* nums, int numsSize, int** requests, int requestsSize, int* requestsColSize){\\n    int mod = 1e9 + 7;\\n    int n = numsSize;\\n    int* prefix = calloc((n+1) , sizeof(int));\\n    for(int i = 0; i < requestsSize; i++){\\n        prefix[requests[i][0]] += 1;\\n        prefix[requests[i][1] + 1] -= 1;\\n    }\\n    for(int i = 1; i < n; i++){\\n        prefix[i] += prefix[i-1];    \\n    }\\n    qsort(nums, n, sizeof(int), cmpfunc);\\n    qsort(prefix, n, sizeof(int), cmpfunc);\\n    int sum = 0;\\n    for(int i = 0; i < n; i++){\\n        if(prefix[i] == 0)\\n            break;\\n        sum = (sum + (long long)prefix[i]*nums[i] % mod) % mod;\\n    }\\n    return sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2795762,
                "title": "easy-c-prefix-sum-sort-solution-commented-fully",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    #define mod 1000000007\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& req) {\\n        //sort   nums in a ascending order \\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        vector<int>freq(n,0);\\n        \\n        //store the frequencies of indices from all the requests\\n        for(int i=0;i<req.size();i++)\\n        {\\n            int l=req[i][0],r=req[i][1];\\n            //freq increases from starting index\\n            freq[l]++;\\n            //as interval ends we need to decrease the frequency\\n            if(r+1<n)\\n                freq[r+1]--;\\n        }\\n        //now make the freq as prefix sum to get the actual freq of every index\\n        for(int i=1;i<n;i++)\\n            freq[i]+=freq[i-1];\\n        \\n        sort(freq.begin(),freq.end());\\n        \\n        long long res=0;\\n        for(int j=freq.size()-1,i=n-1;j>=0;j--,i--)\\n        {\\n            ll currFreq=freq[j];\\n            if(currFreq==0)\\n                break;\\n            res+=(currFreq)*(nums[i]);\\n            res%=mod;\\n        }\\n        return res;\\n        \\n       \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    #define mod 1000000007\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& req) {\\n        //sort   nums in a ascending order \\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        vector<int>freq(n,0);\\n        \\n        //store the frequencies of indices from all the requests\\n        for(int i=0;i<req.size();i++)\\n        {\\n            int l=req[i][0],r=req[i][1];\\n            //freq increases from starting index\\n            freq[l]++;\\n            //as interval ends we need to decrease the frequency\\n            if(r+1<n)\\n                freq[r+1]--;\\n        }\\n        //now make the freq as prefix sum to get the actual freq of every index\\n        for(int i=1;i<n;i++)\\n            freq[i]+=freq[i-1];\\n        \\n        sort(freq.begin(),freq.end());\\n        \\n        long long res=0;\\n        for(int j=freq.size()-1,i=n-1;j>=0;j--,i--)\\n        {\\n            ll currFreq=freq[j];\\n            if(currFreq==0)\\n                break;\\n            res+=(currFreq)*(nums[i]);\\n            res%=mod;\\n        }\\n        return res;\\n        \\n       \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2732031,
                "title": "c-max-heap-prefix-count",
                "content": "```class Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& r) {\\n        int n = nums.size();\\n        vector<int>freq(n+1);\\n        for(int i = 0 ; i < r.size() ; i++){\\n            freq[r[i][0]]++;\\n            freq[r[i][1]+1]--;\\n        }\\n        for(int i = 1 ; i < n ; i++)\\n            freq[i] += freq[i-1];\\n        priority_queue<int>pq;\\n        for(int i = 0 ; i < n ; i++)\\n            pq.push(freq[i]);\\n        int ans = 0;\\n        long long mod = 1e9 + 7;\\n        sort(nums.rbegin(),nums.rend());\\n        int i = 0;\\n        while(!pq.empty()){\\n            ans = (ans + ((pq.top()%mod)*(nums[i++]%mod))%mod)%mod;\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Greedy",
                    "Heap (Priority Queue)",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& r) {\\n        int n = nums.size();\\n        vector<int>freq(n+1);\\n        for(int i = 0 ; i < r.size() ; i++){\\n            freq[r[i][0]]++;\\n            freq[r[i][1]+1]--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2684709,
                "title": "c-sort-greedy-o-mlogm-nlogn-time-o-m-n-space",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n \\\\times \\\\log(n) + m \\\\times \\\\log(m))$$ ->\\n`n` is the length of array `nums`.\\n`m` is the length of array `requests`.\\n\\n- Space complexity:\\n$$O(n + m)$$ ->\\n`n` is the length of array `nums`.\\n`m` is the length of array `requests`.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static int maxSumRangeQuery(vector<int> nums, const vector<vector<int>>& requests) {\\n        const int n = size(nums);\\n        const int m = size(requests);\\n        vector<int> start(m), finish(m);\\n        vector<int> overlap(n);\\n        for (int i = 0; i < m; ++i) {\\n            start[i] = requests[i][0];\\n            finish[i] = requests[i][1] + 1;\\n        }\\n        sort(begin(start), end(start));\\n        sort(begin(finish), end(finish));\\n        for (int i = 0, j = 0, k = 0; i < n; ++i) {\\n            while (j < m && start[j] <= i)\\n                ++j;\\n            while (k < m && finish[k] <= i)\\n                ++k;\\n            overlap[i] = j - k;\\n        }\\n        sort(begin(overlap), end(overlap));\\n        sort(begin(nums), end(nums));\\n        int64_t ret = 0;\\n        for (int i = 0; i < n; ++i)\\n            ret += int64_t(nums[i]) * overlap[i];\\n        return int(ret % 1000000007);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static int maxSumRangeQuery(vector<int> nums, const vector<vector<int>>& requests) {\\n        const int n = size(nums);\\n        const int m = size(requests);\\n        vector<int> start(m), finish(m);\\n        vector<int> overlap(n);\\n        for (int i = 0; i < m; ++i) {\\n            start[i] = requests[i][0];\\n            finish[i] = requests[i][1] + 1;\\n        }\\n        sort(begin(start), end(start));\\n        sort(begin(finish), end(finish));\\n        for (int i = 0, j = 0, k = 0; i < n; ++i) {\\n            while (j < m && start[j] <= i)\\n                ++j;\\n            while (k < m && finish[k] <= i)\\n                ++k;\\n            overlap[i] = j - k;\\n        }\\n        sort(begin(overlap), end(overlap));\\n        sort(begin(nums), end(nums));\\n        int64_t ret = 0;\\n        for (int i = 0; i < n; ++i)\\n            ret += int64_t(nums[i]) * overlap[i];\\n        return int(ret % 1000000007);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2673762,
                "title": "python3",
                "content": "class Solution:\\n\\n    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\\n        length = len(nums)\\n        count = [0]*length\\n\\t\\t\\n        for start,end in requests:\\n            count[start]+=1\\n            if end+1<length:\\n                count[end+1]-=1\\n        \\n        for i in range(1,length):\\n            count[i]+=count[i-1]\\n        \\n        count.sort()\\n        nums.sort()\\n        \\n        sums = 0\\n        for c,n in zip(count,nums):\\n            sums+=c*n\\n        return sums%(10**9+7)",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\\n        length = len(nums)\\n        count = [0]*length\\n\\t\\t\\n        for start,end in requests:\\n            count[start]+=1\\n            if end+1<length:\\n                count[end+1]-=1\\n        \\n        for i in range(1,length):\\n            count[i]+=count[i-1]\\n        \\n        count.sort()\\n        nums.sort()\\n        \\n        sums = 0\\n        for c,n in zip(count,nums):\\n            sums+=c*n\\n        return sums%(10**9+7)",
                "codeTag": "Java"
            },
            {
                "id": 2668308,
                "title": "easy-python-greedy-solution-78-faster",
                "content": "![image](https://assets.leetcode.com/users/images/b1cb12f9-20f9-4caf-910b-730830b08f48_1665054996.3015187.png)\\n\\n```\\nclass Solution:\\n    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\\n        nums = sorted(nums,reverse = True)\\n        n = len(nums)\\n        occ = [0] * (n+1)\\n        memo =[0] * (n+1)\\n\\n        for i in range(len(requests)):\\n            occ[requests[i][0]] += 1\\n            occ[requests[i][1]+1] -= 1\\n\\n        cur = 0\\n        for i in range(n):\\n            cur += occ[i]\\n            memo[i] += cur\\n\\n        memo = sorted(memo,reverse = True)\\n\\n        res = 0\\n        for i in range(n):\\n            res += int(nums[i] * memo[i])\\n            \\n        return res % 1000000007\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\\n        nums = sorted(nums,reverse = True)\\n        n = len(nums)\\n        occ = [0] * (n+1)\\n        memo =[0] * (n+1)\\n\\n        for i in range(len(requests)):\\n            occ[requests[i][0]] += 1\\n            occ[requests[i][1]+1] -= 1\\n\\n        cur = 0\\n        for i in range(n):\\n            cur += occ[i]\\n            memo[i] += cur\\n\\n        memo = sorted(memo,reverse = True)\\n\\n        res = 0\\n        for i in range(n):\\n            res += int(nums[i] * memo[i])\\n            \\n        return res % 1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2589864,
                "title": "javascript-line-sweep-w-prefix-sum",
                "content": "**Solution: Line Sweep w/ Prefix Sum**\\n\\n1. Count the number of requests for each index in nums using line sweep and prefix sum.\\n2. Filter out the indexes with at least 1 request and sort them in desc order based on the number of requests.\\n3. Sort `nums` in desc order.\\n4. Assign each number (from largest to smallest) to the sorted indexes.\\n\\n`n = length of nums`, `m = number of requests`\\nTime Complexity: `O(n log(n) + m)` 609ms\\nSpace Complexity: `O(n)` 80.8MB\\n```\\nvar maxSumRangeQuery = function(nums, requests) {\\n  let n = nums.length, sum = Array(n).fill(0);\\n  for (let [start, end] of requests) {\\n    sum[start]++;\\n    sum[end + 1]--;\\n  }\\n  for (let i = 1; i < n; i++) {\\n    sum[i] += sum[i - 1];\\n  }\\n\\n  let indexes = sum.filter((num) => num > 0).sort((a, b) => b - a);\\n  nums.sort((a, b) => b - a);\\n  let ans = 0, MOD = 10 ** 9 + 7;\\n  for (let i = 0, j = 0; i < indexes.length; i++) {\\n    ans = (ans + indexes[i] * nums[j]) % MOD;\\n    j++;\\n  }\\n  return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxSumRangeQuery = function(nums, requests) {\\n  let n = nums.length, sum = Array(n).fill(0);\\n  for (let [start, end] of requests) {\\n    sum[start]++;\\n    sum[end + 1]--;\\n  }\\n  for (let i = 1; i < n; i++) {\\n    sum[i] += sum[i - 1];\\n  }\\n\\n  let indexes = sum.filter((num) => num > 0).sort((a, b) => b - a);\\n  nums.sort((a, b) => b - a);\\n  let ans = 0, MOD = 10 ** 9 + 7;\\n  for (let i = 0, j = 0; i < indexes.length; i++) {\\n    ans = (ans + indexes[i] * nums[j]) % MOD;\\n    j++;\\n  }\\n  return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2470539,
                "title": "python-sweep-line-max-heap-solution-o-k-log-n",
                "content": "```\\ndef maxSumRangeQuery(self, nums: List[int], rs: List[List[int]]) -> int:\\n\\tfreq = [0]*(len(nums)+1)\\n\\tfor s, e in rs:\\n\\t\\tfreq[s] -= 1\\n\\t\\tfreq[e+1] += 1\\n\\t\\t# Note we will use max heap so the result is opposite for the sweep-line\\n\\tfreq = list(accumulate(freq))\\n\\theapify(freq)\\n\\tnums = [-n for n in nums]\\n\\theapify(nums)\\n\\ts = 0\\n\\twhile(freq and nums):\\n\\t\\ts += (heappop(nums))*(heappop(freq))\\n\\t\\ts %= (10**9+7)\\n\\treturn s\\n```",
                "solutionTags": [],
                "code": "```\\ndef maxSumRangeQuery(self, nums: List[int], rs: List[List[int]]) -> int:\\n\\tfreq = [0]*(len(nums)+1)\\n\\tfor s, e in rs:\\n\\t\\tfreq[s] -= 1\\n\\t\\tfreq[e+1] += 1\\n\\t\\t# Note we will use max heap so the result is opposite for the sweep-line\\n\\tfreq = list(accumulate(freq))\\n\\theapify(freq)\\n\\tnums = [-n for n in nums]\\n\\theapify(nums)\\n\\ts = 0\\n\\twhile(freq and nums):\\n\\t\\ts += (heappop(nums))*(heappop(freq))\\n\\t\\ts %= (10**9+7)\\n\\treturn s\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2459763,
                "title": "logical",
                "content": "```\\nclass Solution {\\n    public int maxSumRangeQuery(int[] nums, int[][] requests) {\\n        int[] freqOfIndicesInRequests = new int[nums.length];\\n        \\n        for(int[] range : requests){\\n            int start = range[0];\\n            int end = range[1]+1; //we need to add 1 because till range[1] we are including the index. We start excluding index from rage[1]+1.\\n            freqOfIndicesInRequests[start]++;\\n            \\n            if(end<nums.length) //since 1 is added, it might go out of bound.\\n                freqOfIndicesInRequests[end]--;\\n        }\\n        \\n        //as of now freqOfIndicesInRequests array represents the number of new requests starting at any index.\\n        //if the value is negative, it means one of the request is ending at this index.\\n        //so to count the actual number of inclusions of an index, we need to add the existing number of times the index is included + new range starting from here.\\n        for(int i=1;i<nums.length;i++){\\n            freqOfIndicesInRequests[i]+=freqOfIndicesInRequests[i-1];\\n        }\\n        \\n        Arrays.sort(freqOfIndicesInRequests);\\n        Arrays.sort(nums);\\n        \\n        long result=0;\\n        int mod = (int)1e9+7;\\n        for(int i=0;i<nums.length;i++){\\n            long val = (long)nums[i]*(long)freqOfIndicesInRequests[i];\\n            result+=val;\\n        }\\n        \\n        return (int)(result%mod);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumRangeQuery(int[] nums, int[][] requests) {\\n        int[] freqOfIndicesInRequests = new int[nums.length];\\n        \\n        for(int[] range : requests){\\n            int start = range[0];\\n            int end = range[1]+1; //we need to add 1 because till range[1] we are including the index. We start excluding index from rage[1]+1.\\n            freqOfIndicesInRequests[start]++;\\n            \\n            if(end<nums.length) //since 1 is added, it might go out of bound.\\n                freqOfIndicesInRequests[end]--;\\n        }\\n        \\n        //as of now freqOfIndicesInRequests array represents the number of new requests starting at any index.\\n        //if the value is negative, it means one of the request is ending at this index.\\n        //so to count the actual number of inclusions of an index, we need to add the existing number of times the index is included + new range starting from here.\\n        for(int i=1;i<nums.length;i++){\\n            freqOfIndicesInRequests[i]+=freqOfIndicesInRequests[i-1];\\n        }\\n        \\n        Arrays.sort(freqOfIndicesInRequests);\\n        Arrays.sort(nums);\\n        \\n        long result=0;\\n        int mod = (int)1e9+7;\\n        for(int i=0;i<nums.length;i++){\\n            long val = (long)nums[i]*(long)freqOfIndicesInRequests[i];\\n            result+=val;\\n        }\\n        \\n        return (int)(result%mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2440370,
                "title": "c-solution",
                "content": "```\\nint maxSumRangeQuery(vector<int>& a, vector<vector<int>>& req) {\\n        int m=1000000007;\\n        sort(a.begin(),a.end());\\n        long long sum=0;\\n        int n = a.size();\\n        vector<int> b(n,0);\\n        for(int i=0;i<req.size();++i){\\n            b[req[i][1]]++;\\n            if(req[i][0]==0){\\n                continue;\\n            }\\n            b[req[i][0]-1]--;\\n        }\\n        \\n        for(int i=n-2;i>=0;--i){\\n            b[i]=b[i]+b[i+1];\\n        }\\n        \\n        sort(b.begin(),b.end());\\n        for(int i=0;i<n;++i){\\n            sum+=((long long)(b[i])*(a[i]))%m;\\n        }\\n        return sum%m;\\n       \\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint maxSumRangeQuery(vector<int>& a, vector<vector<int>>& req) {\\n        int m=1000000007;\\n        sort(a.begin(),a.end());\\n        long long sum=0;\\n        int n = a.size();\\n        vector<int> b(n,0);\\n        for(int i=0;i<req.size();++i){\\n            b[req[i][1]]++;\\n            if(req[i][0]==0){\\n                continue;\\n            }\\n            b[req[i][0]-1]--;\\n        }\\n        \\n        for(int i=n-2;i>=0;--i){\\n            b[i]=b[i]+b[i+1];\\n        }\\n        \\n        sort(b.begin(),b.end());\\n        for(int i=0;i<n;++i){\\n            sum+=((long long)(b[i])*(a[i]))%m;\\n        }\\n        return sum%m;\\n       \\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2406077,
                "title": "python-breef",
                "content": "Instead of sweeping the whole range, only indicate the begining and end of the range and later, with one sweep create the whole array.\\n\\n```\\n    def maxSumRangeQuery(self, nums, requests):\\n        nums.sort()\\n        c = [0] * (len(nums) + 1)\\n        for a, b in requests:\\n            c[a] += 1\\n            c[b+1] -= 1\\n            \\n        acc = sorted(accumulate(c))\\n        return sum(a * b for a, b in zip(acc[1:], nums)) % 1_000_000_007\\n```",
                "solutionTags": [],
                "code": "```\\n    def maxSumRangeQuery(self, nums, requests):\\n        nums.sort()\\n        c = [0] * (len(nums) + 1)\\n        for a, b in requests:\\n            c[a] += 1\\n            c[b+1] -= 1\\n            \\n        acc = sorted(accumulate(c))\\n        return sum(a * b for a, b in zip(acc[1:], nums)) % 1_000_000_007\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2331115,
                "title": "intuitive-copy-magic-from-others",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        int len = nums.size() + 1;\\n        vector<long long> index(len);\\n        \\n        // Strang Magic\\n        for (auto r : requests) {\\n            index[r[0]]++;\\n            index[r[1] + 1]--;\\n        }\\n        partial_sum(index.begin(), index.end(), index.begin());\\n        sort(index.begin(), index.end());\\n        sort(nums.begin(), nums.end());\\n        int n_idx = nums.size() - 1;\\n        int i_idx = index.size() - 1;\\n        long long res = 0;\\n        const int Magic = 1\\'000\\'000\\'007;\\n        while (index[i_idx] and n_idx >= 0) {\\n            res += index[i_idx] * nums[n_idx];\\n            res %= Magic;\\n            --i_idx;\\n            --n_idx;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        int len = nums.size() + 1;\\n        vector<long long> index(len);\\n        \\n        // Strang Magic\\n        for (auto r : requests) {\\n            index[r[0]]++;\\n            index[r[1] + 1]--;\\n        }\\n        partial_sum(index.begin(), index.end(), index.begin());\\n        sort(index.begin(), index.end());\\n        sort(nums.begin(), nums.end());\\n        int n_idx = nums.size() - 1;\\n        int i_idx = index.size() - 1;\\n        long long res = 0;\\n        const int Magic = 1\\'000\\'000\\'007;\\n        while (index[i_idx] and n_idx >= 0) {\\n            res += index[i_idx] * nums[n_idx];\\n            res %= Magic;\\n            --i_idx;\\n            --n_idx;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2273594,
                "title": "python-simple-sweep-line-algorithm",
                "content": "\\n    def maxSumRangeQuery(self, nums, requests):\\n        n, total = len(nums), 0\\n        \\n        count = [0]*(n+1)\\n        \\n        for left, right in requests:\\n            count[left] += 1\\n            count[right+1] -= 1\\n            \\n        for i in range(1,len(count)):\\n            count[i] += count[i-1]\\n            \\n        for i, j in zip(sorted(count[:-1]), sorted(nums)):\\n            total += i*j\\n            \\n        return total%(10**9+7)",
                "solutionTags": [],
                "code": "\\n    def maxSumRangeQuery(self, nums, requests):\\n        n, total = len(nums), 0\\n        \\n        count = [0]*(n+1)\\n        \\n        for left, right in requests:\\n            count[left] += 1\\n            count[right+1] -= 1\\n            \\n        for i in range(1,len(count)):\\n            count[i] += count[i-1]\\n            \\n        for i, j in zip(sorted(count[:-1]), sorted(nums)):\\n            total += i*j\\n            \\n        return total%(10**9+7)",
                "codeTag": "Python3"
            },
            {
                "id": 2269937,
                "title": "python3-prefix-sum-and-greedy",
                "content": "```\\nclass Solution:\\n    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\\n        freqs = [0 for _ in range(len(nums))]\\n        for request in requests:\\n            freqs[request[0]] += 1\\n            if request[1]+1 < len(nums):\\n                freqs[request[1]+1] -= 1\\n        for i in range(1, len(freqs)):\\n            freqs[i] += freqs[i-1]\\n        freqs.sort()\\n        nums.sort()\\n        res = 0\\n        for i in range(len(freqs)):\\n            res += freqs[i] * nums[i]\\n        return res % (1000000000 + 7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\\n        freqs = [0 for _ in range(len(nums))]\\n        for request in requests:\\n            freqs[request[0]] += 1\\n            if request[1]+1 < len(nums):\\n                freqs[request[1]+1] -= 1\\n        for i in range(1, len(freqs)):\\n            freqs[i] += freqs[i-1]\\n        freqs.sort()\\n        nums.sort()\\n        res = 0\\n        for i in range(len(freqs)):\\n            res += freqs[i] * nums[i]\\n        return res % (1000000000 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2253187,
                "title": "rust-solution-using-greeedy",
                "content": "```\\nconst MOD:usize = 1_000_000_007;\\n\\nimpl Solution {\\n  pub fn max_sum_range_query(mut nums: Vec<i32>, requests: Vec<Vec<i32>>) -> i32 {\\n    let n = nums.len();\\n    let mut memo = vec![(0,0);n];\\n    \\n    for arr in requests {\\n      memo[arr[0] as usize].0 += 1;\\n      memo[arr[1] as usize].1 += 1;\\n    }\\n\\n    let mut counts = vec![0;n];\\n    let mut temp = 0;\\n    for i in 0..n {\\n      temp += memo[i].0;\\n      counts[i] = temp;\\n      temp -= memo[i].1;\\n    }\\n\\n    counts.sort();\\n    nums.sort();\\n    let mut result = 0;\\n    for i in 0..n {\\n      result += counts[i] as usize * nums[i] as usize % MOD;\\n      result %= MOD;\\n    }\\n\\n    result as i32\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Greedy"
                ],
                "code": "```\\nconst MOD:usize = 1_000_000_007;\\n\\nimpl Solution {\\n  pub fn max_sum_range_query(mut nums: Vec<i32>, requests: Vec<Vec<i32>>) -> i32 {\\n    let n = nums.len();\\n    let mut memo = vec![(0,0);n];\\n    \\n    for arr in requests {\\n      memo[arr[0] as usize].0 += 1;\\n      memo[arr[1] as usize].1 += 1;\\n    }\\n\\n    let mut counts = vec![0;n];\\n    let mut temp = 0;\\n    for i in 0..n {\\n      temp += memo[i].0;\\n      counts[i] = temp;\\n      temp -= memo[i].1;\\n    }\\n\\n    counts.sort();\\n    nums.sort();\\n    let mut result = 0;\\n    for i in 0..n {\\n      result += counts[i] as usize * nums[i] as usize % MOD;\\n      result %= MOD;\\n    }\\n\\n    result as i32\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2249728,
                "title": "c-sweep-line-technique",
                "content": "* Suppose we already have the best permutation available which yields max sum for `requests` , then answer would be simple. Simply create prefix sum of array and add sum from each request.\\n\\n* How to find best permuation ??. We use Line Sweep.\\n\\n* In `createPermutation` function , for each requests we mark the end and beginning of request indices with **+1 and -1.** For example , say `request = [0,1]` , then our sweep array would be `[1,0,-1]`. `+1 at 0 and -1 at 2` , why ?? Because when we take prefix sum of this sweep array , it would look like this -> `[1,1,0]` , this signifies that for `req = [0,1]` each element at 0 and 1 was required 1 time only.\\n\\n* Hence , we keep creating out sweep line array and at the end , the index in sweep array which has the most occurence will be worthy of keeping largest element from nums and vice-versa.\\n```\\nclass Solution {\\npublic:\\n    int MOD = 1e9 + 7 ;\\n    vector<int> createPermutation(vector<int>&nums , vector<vector<int>> &requests){\\n        sort(begin(nums),end(nums)) ;\\n        \\n        vector<int>sweep(nums.size() + 1) ;\\n        for(auto &x : requests) ++sweep[x[0]] , --sweep[x[1] + 1] ;\\n        for(int i = 1 ; i < sweep.size() ; ++i ) sweep[i] += sweep[i-1] ;\\n        \\n        vector<int> aux(nums.size()) ;\\n        set<pair<int,int>> st ;\\n        for(int i = 0 ; i < nums.size() ; ++i ) st.insert({sweep[i],i}) ;\\n        \\n        int i = 0 ;\\n        while(st.size()){\\n            auto[freq,idx] = *begin(st) ;\\n            st.erase(begin(st)) ;\\n            aux[idx] = nums[i++] ;\\n        }\\n        return aux ;\\n    }\\n    \\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        vector<int> aux = createPermutation(nums,requests);\\n        vector<int>pref ;\\n        for(auto &x : aux) pref.push_back(pref.empty() ? x : x + pref.back()) ;\\n        int ans = 0 ;\\n        for(auto &x : requests) ans = (ans + (pref[x[1]] - (x[0]-1 >= 0 ? pref[x[0] - 1] : 0) + MOD) % MOD) % MOD;\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int MOD = 1e9 + 7 ;\\n    vector<int> createPermutation(vector<int>&nums , vector<vector<int>> &requests){\\n        sort(begin(nums),end(nums)) ;\\n        \\n        vector<int>sweep(nums.size() + 1) ;\\n        for(auto &x : requests) ++sweep[x[0]] , --sweep[x[1] + 1] ;\\n        for(int i = 1 ; i < sweep.size() ; ++i ) sweep[i] += sweep[i-1] ;\\n        \\n        vector<int> aux(nums.size()) ;\\n        set<pair<int,int>> st ;\\n        for(int i = 0 ; i < nums.size() ; ++i ) st.insert({sweep[i],i}) ;\\n        \\n        int i = 0 ;\\n        while(st.size()){\\n            auto[freq,idx] = *begin(st) ;\\n            st.erase(begin(st)) ;\\n            aux[idx] = nums[i++] ;\\n        }\\n        return aux ;\\n    }\\n    \\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        vector<int> aux = createPermutation(nums,requests);\\n        vector<int>pref ;\\n        for(auto &x : aux) pref.push_back(pref.empty() ? x : x + pref.back()) ;\\n        int ans = 0 ;\\n        for(auto &x : requests) ans = (ans + (pref[x[1]] - (x[0]-1 >= 0 ? pref[x[0] - 1] : 0) + MOD) % MOD) % MOD;\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2240671,
                "title": "c-easy-approach-with-explaination",
                "content": "idea here is to count the number of times an index appear requests\\nsince increasing index one by one gives TLE, we use Difference array method to count the index and store it in t\\nnow sort both t and a\\na = [1,2,3,4,5], requests = [[1,3],[0,1]]\\nfor this requests t will be = [ 1, 2, 1, 1, 0 ]\\nbecoze index 1 appear in two range of request\\nafter sorting \\na=[1,2,3,4,5], t=[ 0, 1, 1, 1, 2 ]\\nnow wun a loop fron n-1 and store sum of a[i]*t[i]\\n```\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& a, vector<vector<int>>& r) {\\n        sort(begin(a),end(a));\\n        long long c=0,m=pow(10,9)+7;\\n        int n=a.size();\\n        vector<int> t(n+1);\\n        for(auto i:r)\\n            t[i[0]]++,t[i[1]+1]--;\\n        for(int i=1;i<n;i++)\\n            t[i]+=t[i-1];\\n        t.pop_back();\\n        sort(begin(t),end(t));\\n        for(int i=n-1;i>=0;i--)\\n            c=(c+t[i]*1ll*a[i])%m;\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& a, vector<vector<int>>& r) {\\n        sort(begin(a),end(a));\\n        long long c=0,m=pow(10,9)+7;\\n        int n=a.size();\\n        vector<int> t(n+1);\\n        for(auto i:r)\\n            t[i[0]]++,t[i[1]+1]--;\\n        for(int i=1;i<n;i++)\\n            t[i]+=t[i-1];\\n        t.pop_back();\\n        sort(begin(t),end(t));\\n        for(int i=n-1;i>=0;i--)\\n            c=(c+t[i]*1ll*a[i])%m;\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2167059,
                "title": "c-easy-greedy-solution-fast",
                "content": "```\\nclass Solution {\\npublic:\\n    long long mod=(1e9+7);\\n    int maxSumRangeQuery(vector<int>& a, vector<vector<int>>& r) {\\n        vector<int> b(a.size()+1,0);\\n\\t\\t\\n\\t\\t//marking where maximum intervals overlap so that we can put maximum value there\\n\\t\\t\\n        for(int i=0;i<r.size();i++){\\n            b[r[i][0]]++;\\n            b[r[i][1]+1]--;\\n        }\\n        for(int i=1;i<b.size();i++){\\n            b[i]+=b[i-1];\\n        }\\n        sort(a.begin(),a.end());\\n        sort(b.begin(),b.end()-1);\\n        long long ans=0;\\n        for(int i=a.size()-1;i>=0;i--){\\n            ans+=((long long)a[i]*(long long)b[i])%mod;\\n            ans=ans%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long mod=(1e9+7);\\n    int maxSumRangeQuery(vector<int>& a, vector<vector<int>>& r) {\\n        vector<int> b(a.size()+1,0);\\n\\t\\t\\n\\t\\t//marking where maximum intervals overlap so that we can put maximum value there\\n\\t\\t\\n        for(int i=0;i<r.size();i++){\\n            b[r[i][0]]++;\\n            b[r[i][1]+1]--;\\n        }\\n        for(int i=1;i<b.size();i++){\\n            b[i]+=b[i-1];\\n        }\\n        sort(a.begin(),a.end());\\n        sort(b.begin(),b.end()-1);\\n        long long ans=0;\\n        for(int i=a.size()-1;i>=0;i--){\\n            ans+=((long long)a[i]*(long long)b[i])%mod;\\n            ans=ans%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138371,
                "title": "highly-randomized-solution-c",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& r) {\\n        //Step - 1\\n        vector<int>count(nums.size(), 0);\\n        //Step - 2\\n        for(int i = 0; i < r.size(); i++){\\n            count[r[i][0]]++;\\n            if(r[i][1] + 1 < nums.size()){\\n                count[r[i][1] + 1]--;\\n            }\\n        }\\n        //Step - 3\\n        for(int i = 1; i < nums.size(); i++){\\n            count[i] += count[i - 1];\\n        }\\n        //Step - 4\\n        sort(count.begin(), count.end());\\n        sort(nums.begin(), nums.end());\\n        //Step - 5\\n        long long  sum = 0;\\n\\t\\tlong long  mod = (int)1e9 + 7;\\n        for(int i = 0; i < nums.size(); i++){\\n            sum += (count[i]%mod) * (nums[i]%mod);\\n            sum %= mod;\\n        }\\n        return sum;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2132897,
                "title": "counting-intervals",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        \\n        auto comp = [](const vector<int> &v1, const vector<int> &v2)\\n             {\\n                return v1[0] < v2[0]; \\n             };\\n        \\n        sort(requests.begin(), requests.end(), comp);\\n        \\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        \\n        int last = 0;\\n        \\n        int val = 0;\\n        bool left_flag = false;\\n        int interval = 0;\\n        for(auto &r : requests)\\n        {\\n            \\n            while(!pq.empty() && pq.top() < r[0])\\n            {\\n                int top = pq.top();\\n                pq.pop();\\n                \\n                interval = top - last;\\n                if(left_flag)\\n                {\\n                    interval++;\\n                    left_flag = false;\\n                }\\n                addFreq(val, interval);\\n                val--;\\n                last = top;\\n            }\\n            \\n            interval = r[0] - last - 1;\\n            if(left_flag)\\n            {\\n                interval++;\\n            }\\n            addFreq(val, interval);\\n            val++;\\n            last = r[0];\\n            pq.push(r[1]);\\n            left_flag = true;\\n        }\\n        \\n        while(!pq.empty())\\n        {\\n            int top = pq.top();\\n            pq.pop();\\n\\n            interval = top - last;\\n            if(left_flag)\\n            {\\n                interval++;\\n                left_flag = false;\\n            }\\n            addFreq(val, interval);\\n            val--;\\n            last = top;\\n        }\\n        \\n        \\n        int index = 0;\\n        long long sum = 0; \\n        sort(nums.begin(), nums.end(), greater<int>());\\n        for(int i = freq.size()-1 ; i >= 0 ; i--)\\n        {\\n            for(int j = 0 ; j < freq[i] ; j++)\\n            {\\n                sum+= (long long)i * (long long)nums[index];\\n                sum %= 1000000007;\\n                index++;\\n            }\\n        }\\n        \\n        // for(auto i : freq)\\n        // {\\n        //     cout << i << \\' \\';\\n        // }\\n        \\n        return sum;\\n    }\\n   \\n    \\n    \\n    void addFreq(int f, int times)\\n    {\\n        // cout << f << \\' \\' << freq.size() << endl;\\n        if(f == freq.size())\\n        {\\n            freq.push_back(0);\\n        }\\n        \\n        freq[f] += times;\\n    }\\nprivate:\\n    vector<int> freq{0};\\n};\\n```\\n\\nTime complexity: O(NLogN + mLogm) = O(NlogN)\\nSpace: O(N)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        \\n        auto comp = [](const vector<int> &v1, const vector<int> &v2)\\n             {\\n                return v1[0] < v2[0]; \\n             };\\n        \\n        sort(requests.begin(), requests.end(), comp);\\n        \\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        \\n        int last = 0;\\n        \\n        int val = 0;\\n        bool left_flag = false;\\n        int interval = 0;\\n        for(auto &r : requests)\\n        {\\n            \\n            while(!pq.empty() && pq.top() < r[0])\\n            {\\n                int top = pq.top();\\n                pq.pop();\\n                \\n                interval = top - last;\\n                if(left_flag)\\n                {\\n                    interval++;\\n                    left_flag = false;\\n                }\\n                addFreq(val, interval);\\n                val--;\\n                last = top;\\n            }\\n            \\n            interval = r[0] - last - 1;\\n            if(left_flag)\\n            {\\n                interval++;\\n            }\\n            addFreq(val, interval);\\n            val++;\\n            last = r[0];\\n            pq.push(r[1]);\\n            left_flag = true;\\n        }\\n        \\n        while(!pq.empty())\\n        {\\n            int top = pq.top();\\n            pq.pop();\\n\\n            interval = top - last;\\n            if(left_flag)\\n            {\\n                interval++;\\n                left_flag = false;\\n            }\\n            addFreq(val, interval);\\n            val--;\\n            last = top;\\n        }\\n        \\n        \\n        int index = 0;\\n        long long sum = 0; \\n        sort(nums.begin(), nums.end(), greater<int>());\\n        for(int i = freq.size()-1 ; i >= 0 ; i--)\\n        {\\n            for(int j = 0 ; j < freq[i] ; j++)\\n            {\\n                sum+= (long long)i * (long long)nums[index];\\n                sum %= 1000000007;\\n                index++;\\n            }\\n        }\\n        \\n        // for(auto i : freq)\\n        // {\\n        //     cout << i << \\' \\';\\n        // }\\n        \\n        return sum;\\n    }\\n   \\n    \\n    \\n    void addFreq(int f, int times)\\n    {\\n        // cout << f << \\' \\' << freq.size() << endl;\\n        if(f == freq.size())\\n        {\\n            freq.push_back(0);\\n        }\\n        \\n        freq[f] += times;\\n    }\\nprivate:\\n    vector<int> freq{0};\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2127593,
                "title": "o-nlogn-easy",
                "content": "```\\nclass Solution {\\n    public int maxSumRangeQuery(int[] nums, int[][] requests) {\\n        \\n        // just count the freq. of each index, now since we need to assign maximum element with maximum frequency. then sort both the array and keep assigning the value and get the result\\n        \\n        int[] freq = new int[nums.length];\\n        \\n        for(int[] row : requests){\\n            freq[row[0]]++;\\n            if(row[1] + 1 < nums.length)\\n                freq[row[1] + 1]--;\\n        }\\n        \\n        for(int i = 1; i < freq.length; i++)\\n            freq[i] += freq[i-1];\\n        \\n        int MOD = (int)Math.pow(10, 9) + 7;\\n        long result = 0;\\n\\n        Arrays.sort(freq);\\n        Arrays.sort(nums);\\n        \\n        for(int i = freq.length - 1; i >= 0; i--){\\n            if(freq[i] == 0) break;\\n            result = (result + (long)freq[i] * nums[i]) % MOD;\\n        }\\n        \\n        return (int)result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumRangeQuery(int[] nums, int[][] requests) {\\n        \\n        // just count the freq. of each index, now since we need to assign maximum element with maximum frequency. then sort both the array and keep assigning the value and get the result\\n        \\n        int[] freq = new int[nums.length];\\n        \\n        for(int[] row : requests){\\n            freq[row[0]]++;\\n            if(row[1] + 1 < nums.length)\\n                freq[row[1] + 1]--;\\n        }\\n        \\n        for(int i = 1; i < freq.length; i++)\\n            freq[i] += freq[i-1];\\n        \\n        int MOD = (int)Math.pow(10, 9) + 7;\\n        long result = 0;\\n\\n        Arrays.sort(freq);\\n        Arrays.sort(nums);\\n        \\n        for(int i = freq.length - 1; i >= 0; i--){\\n            if(freq[i] == 0) break;\\n            result = (result + (long)freq[i] * nums[i]) % MOD;\\n        }\\n        \\n        return (int)result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2022967,
                "title": "c-greedy-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        int cnt[100002] = {0};\\n\\n        for (int i = 0; i < requests.size(); ++i) {\\n            ++cnt[requests[i][0]], --cnt[requests[i][1] + 1];\\n        }\\n        \\n        for (int i = 0, freq = 0; i < nums.size(); ++i) {\\n            freq += cnt[i];\\n            cnt[i] = freq;\\n        }\\n\\n        priority_queue<long long> fpq;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            fpq.push(cnt[i]);\\n        }\\n        \\n        sort(nums.begin(), nums.end(), greater<int>());\\n        int mod = 1e9 + 7, res = 0;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            res = (res + nums[i] * fpq.top() % mod) % mod;\\n            fpq.pop();\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        int cnt[100002] = {0};\\n\\n        for (int i = 0; i < requests.size(); ++i) {\\n            ++cnt[requests[i][0]], --cnt[requests[i][1] + 1];\\n        }\\n        \\n        for (int i = 0, freq = 0; i < nums.size(); ++i) {\\n            freq += cnt[i];\\n            cnt[i] = freq;\\n        }\\n\\n        priority_queue<long long> fpq;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            fpq.push(cnt[i]);\\n        }\\n        \\n        sort(nums.begin(), nums.end(), greater<int>());\\n        int mod = 1e9 + 7, res = 0;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            res = (res + nums[i] * fpq.top() % mod) % mod;\\n            fpq.pop();\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2005372,
                "title": "python-heap-difference-array-popularity-of-an-index",
                "content": "```\\nclass Solution:\\n    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\\n        m_heap = [] # max heap to store largest numbers in nums\\n        m_heap2 = [] # max heap to store (popularity, index)\\n        heapify(m_heap)\\n        heapify(m_heap2)\\n        for num in nums:\\n            heappush(m_heap, -num)\\n        \\n        n = len(nums)\\n        nums2 = [-1] * n\\n        popular = [0] * (n + 1) # difference array to store the popularity of each index\\n        \\n        for L, R in requests:\\n            popular[L] += 1\\n            popular[R + 1] -= 1\\n        \\n        ps = 0 # prefix sum to get the popularity of an index i\\n        for i in range(n):\\n            ps += popular[i]\\n            heappush(m_heap2, (-ps, i))\\n        \\n        # place the largest numbers into the most popular indices\\n        while m_heap2:\\n            nums2[heappop(m_heap2)[1]] = -heappop(m_heap)\\n        \\n        # if we still have left over numbers, place them in the open spots\\n        if m_heap:\\n            for i in range(n):\\n                if nums2[i] == -1:\\n                    nums2[i] = -heappop(m_heap)\\n                    \\n        pre_s = [0] * n # prefix sum\\n        last = 0\\n        MOD = int(1e9) + 7\\n        for i in range(n):\\n            pre_s[i] = ((last % MOD) + (nums2[i] % MOD)) % MOD\\n            last = pre_s[i]\\n            \\n        res = 0\\n        # prefix sum queries\\n        for L,R in requests:\\n            prev = pre_s[L - 1] if L - 1 >= 0 else 0\\n            res = ((res % MOD) + ((pre_s[R] - prev) % MOD)) % MOD\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Array",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\\n        m_heap = [] # max heap to store largest numbers in nums\\n        m_heap2 = [] # max heap to store (popularity, index)\\n        heapify(m_heap)\\n        heapify(m_heap2)\\n        for num in nums:\\n            heappush(m_heap, -num)\\n        \\n        n = len(nums)\\n        nums2 = [-1] * n\\n        popular = [0] * (n + 1) # difference array to store the popularity of each index\\n        \\n        for L, R in requests:\\n            popular[L] += 1\\n            popular[R + 1] -= 1\\n        \\n        ps = 0 # prefix sum to get the popularity of an index i\\n        for i in range(n):\\n            ps += popular[i]\\n            heappush(m_heap2, (-ps, i))\\n        \\n        # place the largest numbers into the most popular indices\\n        while m_heap2:\\n            nums2[heappop(m_heap2)[1]] = -heappop(m_heap)\\n        \\n        # if we still have left over numbers, place them in the open spots\\n        if m_heap:\\n            for i in range(n):\\n                if nums2[i] == -1:\\n                    nums2[i] = -heappop(m_heap)\\n                    \\n        pre_s = [0] * n # prefix sum\\n        last = 0\\n        MOD = int(1e9) + 7\\n        for i in range(n):\\n            pre_s[i] = ((last % MOD) + (nums2[i] % MOD)) % MOD\\n            last = pre_s[i]\\n            \\n        res = 0\\n        # prefix sum queries\\n        for L,R in requests:\\n            prev = pre_s[L - 1] if L - 1 >= 0 else 0\\n            res = ((res % MOD) + ((pre_s[R] - prev) % MOD)) % MOD\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1991838,
                "title": "c-o-n-log-n",
                "content": "#define ll long long\\n#define mod 1000000007\\nstatic int cmp(int a, int b)\\n{\\n    return a > b;\\n}\\nclass Solution\\n{\\npublic:\\n    int maxSumRangeQuery(vector<int> &v, vector<vector<int>> &requests)\\n    {\\n\\n        sort(requests.begin(), requests.end());\\n        //        we calculate at every index in how many group (i.e start and end of request array )that index is present\\n        int size = v.size();\\n        vector<int> v1(size, 0);\\n        priority_queue<int, vector<int>, greater<int>> q1;\\n\\n        int j = 0;\\n        ll sum = 0;\\n        for (int i = 0; i < size; i++)\\n        {\\n\\n            if (j < requests.size())\\n            {\\n                int a = requests[j][0];\\n                int b = requests[j][1];\\n\\n                while (j < requests.size() && a == i)\\n                {\\n                    sum += 1;\\n                    q1.push(b);\\n                    j++;\\n                    if (j < requests.size())\\n                    {\\n                        a = requests[j][0];\\n                        b = requests[j][1];\\n                    }\\n                }\\n            }\\n            v1[i] = sum;\\n            while (!q1.empty() && q1.top() == i)\\n            {\\n                q1.pop();\\n                sum -= 1;\\n            }\\n        }\\n\\n        // NOW WE PUSH ALL ELEMENT IN PRIORITY QUEUE TO KNOW MAXIMUM NUMBER OF TIME SAME ELEMENT PRESENT IN THE START AND END RANGE\\n        priority_queue<int, vector<int>> q;\\n        for (auto a : v1)\\n        {\\n            if (a > 0)\\n            {\\n                q.push(a);\\n            }\\n        }\\n        ll ans = 0;\\n        sort(v.begin(), v.end(), cmp);\\n        int i = 0;\\n        while (!q.empty())\\n        {\\n            ll temp = (ll)v[i] * (ll)q.top();\\n\\n            q.pop();\\n            ans = (ans % mod + temp % mod) % mod;\\n\\n            i++;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "class Solution\\n{\\npublic:\\n    int maxSumRangeQuery(vector<int> &v, vector<vector<int>> &requests)\\n    {\\n\\n        sort(requests.begin(), requests.end());\\n        //        we calculate at every index in how many group (i.e start and end of request array )that index is present\\n        int size = v.size();\\n        vector<int> v1(size, 0);\\n        priority_queue<int, vector<int>, greater<int>> q1;\\n\\n        int j = 0;\\n        ll sum = 0;\\n        for (int i = 0; i < size; i++)\\n        {\\n\\n            if (j < requests.size())\\n            {\\n                int a = requests[j][0];\\n                int b = requests[j][1];\\n\\n                while (j < requests.size() && a == i)\\n                {\\n                    sum += 1;\\n                    q1.push(b);\\n                    j++;\\n                    if (j < requests.size())\\n                    {\\n                        a = requests[j][0];\\n                        b = requests[j][1];\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1881409,
                "title": "c-cf-and-pf",
                "content": "```\\n int MOD =  1e9 + 7;\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        \\n        vector<int> v(1e5+1,0);\\n        \\n        \\n        for(int i=0;i<requests.size();i++){\\n            \\n             int s=requests[i][0];\\n             int l=requests[i][1];\\n            \\n             \\n                 v[s]++;\\n             \\n                 v[l+1]--;\\n        }\\n        \\n        \\n        for(int i=1;i<nums.size();i++){\\n            v[i]+=v[i-1];\\n        }\\n        \\n        \\n        \\n        vector<pair<int,int>> w;\\n        \\n        \\n        for(int i=0;i<nums.size();i++){\\n            w.push_back({v[i],i});\\n        }\\n        \\n        \\n        long long int ans=0;\\n        \\n        \\n        sort(w.begin(),w.end());\\n        sort(nums.begin(),nums.end());\\n        \\n        \\n        for(int i=0;i<nums.size();i++){\\n            ans= ans + ((long long int)w[i].first*(long long int)nums[i]);\\n            ans%=MOD;\\n        }\\n        \\n        \\n        return (int)ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\n int MOD =  1e9 + 7;\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        \\n        vector<int> v(1e5+1,0);\\n        \\n        \\n        for(int i=0;i<requests.size();i++){\\n            \\n             int s=requests[i][0];\\n             int l=requests[i][1];\\n            \\n             \\n                 v[s]++;\\n             \\n                 v[l+1]--;\\n        }\\n        \\n        \\n        for(int i=1;i<nums.size();i++){\\n            v[i]+=v[i-1];\\n        }\\n        \\n        \\n        \\n        vector<pair<int,int>> w;\\n        \\n        \\n        for(int i=0;i<nums.size();i++){\\n            w.push_back({v[i],i});\\n        }\\n        \\n        \\n        long long int ans=0;\\n        \\n        \\n        sort(w.begin(),w.end());\\n        sort(nums.begin(),nums.end());\\n        \\n        \\n        for(int i=0;i<nums.size();i++){\\n            ans= ans + ((long long int)w[i].first*(long long int)nums[i]);\\n            ans%=MOD;\\n        }\\n        \\n        \\n        return (int)ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1834428,
                "title": "python-sweep-line-ranks",
                "content": "The main insight is that you don\\'t actually need to materialize the permutation or any of the range sums. You can just add up the number of times each index is queried, and then sort those from highest to lowest. The largest number should go in the most frequently queried index, and so on. \\n\\nRuntime is O(n log n) because of the sorting of nums. All the other operations are linear time.\\n\\n```\\nclass Solution:\\n    def maxSumRangeQuery(self, nums, requests):\\n        rank = [0] * len(nums)\\n        for start, end in requests:\\n            rank[start] += 1\\n            if end + 1 < len(rank):\\n                rank[end+1] -= 1\\n        for i in range(1, len(rank)):\\n            rank[i] += rank[i-1]\\n        \\n        queue = []\\n        for r in rank:\\n            if r > 0:\\n                queue.append(-r)\\n                            \\n        heapq.heapify(queue)\\n\\t\\tnums.sort()\\n        sum_ = 0\\n        while queue:\\n            n = heapq.heappop(queue)\\n            sum_ += nums.pop() * -n\\n        return sum_ % (10**9 + 7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumRangeQuery(self, nums, requests):\\n        rank = [0] * len(nums)\\n        for start, end in requests:\\n            rank[start] += 1\\n            if end + 1 < len(rank):\\n                rank[end+1] -= 1\\n        for i in range(1, len(rank)):\\n            rank[i] += rank[i-1]\\n        \\n        queue = []\\n        for r in rank:\\n            if r > 0:\\n                queue.append(-r)\\n                            \\n        heapq.heapify(queue)\\n\\t\\tnums.sort()\\n        sum_ = 0\\n        while queue:\\n            n = heapq.heappop(queue)\\n            sum_ += nums.pop() * -n\\n        return sum_ % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1789064,
                "title": "java-frequency-array-sorting-0-nlogs",
                "content": "```\\nclass Solution {\\n    //0(nlogn) range query solved in this way\\n    public int maxSumRangeQuery(int[] nums, int[][] requests) {\\n        int[]exist=new int[nums.length];\\n        \\n        for(int[]req:requests){\\n            exist[req[0]]++;\\n            \\n            if(req[1] < nums.length-1)\\n                exist[req[1]+1]--;\\n        }\\n        for(int i=1;i<exist.length;i++)\\n            exist[i]+=exist[i-1];\\n        \\n        Arrays.sort(exist);\\n        Arrays.sort(nums);\\n        int mod=1000000007;\\n        long s=0;\\n        for(int i=0;i<nums.length;i++){\\n            long temp=(long) 1;\\n            s =(s + (((temp * exist[i]) % mod) * nums[i]) % mod) % mod;\\n        }\\n        return (int) s;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    //0(nlogn) range query solved in this way\\n    public int maxSumRangeQuery(int[] nums, int[][] requests) {\\n        int[]exist=new int[nums.length];\\n        \\n        for(int[]req:requests){\\n            exist[req[0]]++;\\n            \\n            if(req[1] < nums.length-1)\\n                exist[req[1]+1]--;\\n        }\\n        for(int i=1;i<exist.length;i++)\\n            exist[i]+=exist[i-1];\\n        \\n        Arrays.sort(exist);\\n        Arrays.sort(nums);\\n        int mod=1000000007;\\n        long s=0;\\n        for(int i=0;i<nums.length;i++){\\n            long temp=(long) 1;\\n            s =(s + (((temp * exist[i]) % mod) * nums[i]) % mod) % mod;\\n        }\\n        return (int) s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786376,
                "title": "rust-98ms",
                "content": "```\\nimpl Solution {\\n    pub fn max_sum_range_query(mut nums: Vec<i32>, requests: Vec<Vec<i32>>) -> i32 {\\n        const MOD: isize = 1_000_000_007;                                                                                                                     \\n        let n = nums.len();                                                                        \\n        let mut freq = vec![0; n];                                                                  \\n                                                                                                            \\n        for r in &requests {        \\n            freq[r[0] as usize] += 1;                                                      \\n            let end = (r[1] + 1) as usize;                                                                       \\n            if end < n {                                                                                         \\n               freq[end] -= 1;                                                                                  \\n             }                                                                                                  \\n        }\\n\\t\\t\\n        for i in 1..n {                                                                                       \\n            freq[i] += freq[i - 1];                                                                            \\n        }                                                                         \\n                                                                                                     \\n        freq.sort();\\n        nums.sort();\\n         \\n        let ans: isize = nums\\n\\t\\t\\t.iter()\\n\\t\\t\\t.zip(freq.iter())\\n\\t\\t\\t.map(|(a, b)| (*a as isize) * (*b as isize))\\n\\t\\t\\t.sum();\\n\\t\\t\\n        (ans % MOD) as i32  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn max_sum_range_query(mut nums: Vec<i32>, requests: Vec<Vec<i32>>) -> i32 {\\n        const MOD: isize = 1_000_000_007;                                                                                                                     \\n        let n = nums.len();                                                                        \\n        let mut freq = vec![0; n];                                                                  \\n                                                                                                            \\n        for r in &requests {        \\n            freq[r[0] as usize] += 1;                                                      \\n            let end = (r[1] + 1) as usize;                                                                       \\n            if end < n {                                                                                         \\n               freq[end] -= 1;                                                                                  \\n             }                                                                                                  \\n        }\\n\\t\\t\\n        for i in 1..n {                                                                                       \\n            freq[i] += freq[i - 1];                                                                            \\n        }                                                                         \\n                                                                                                     \\n        freq.sort();\\n        nums.sort();\\n         \\n        let ans: isize = nums\\n\\t\\t\\t.iter()\\n\\t\\t\\t.zip(freq.iter())\\n\\t\\t\\t.map(|(a, b)| (*a as isize) * (*b as isize))\\n\\t\\t\\t.sum();\\n\\t\\t\\n        (ans % MOD) as i32  \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1731424,
                "title": "java-30ms-scanline-algo-sorting",
                "content": "```\\nclass Solution {\\n    public int maxSumRangeQuery(int[] nums, int[][] requests) {\\n        int n = nums.length;\\n        int[] pref = new int[n];\\n        for(int i=0;i<requests.length;i++){\\n            pref[requests[i][0]]++;\\n            if(requests[i][1]+1<n)pref[requests[i][1]+1]--;\\n        }\\n        for(int i=1;i<n;i++){\\n            pref[i]+= pref[i-1];\\n        }\\n        Arrays.sort(nums);\\n        Arrays.sort(pref);\\n        long res = 0;\\n        for(int i=0;i<n;i++){\\n            res+=((long)pref[i]*nums[i]);\\n            res%=1000000007;\\n        }\\n        return (int)res%1000000007;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumRangeQuery(int[] nums, int[][] requests) {\\n        int n = nums.length;\\n        int[] pref = new int[n];\\n        for(int i=0;i<requests.length;i++){\\n            pref[requests[i][0]]++;\\n            if(requests[i][1]+1<n)pref[requests[i][1]+1]--;\\n        }\\n        for(int i=1;i<n;i++){\\n            pref[i]+= pref[i-1];\\n        }\\n        Arrays.sort(nums);\\n        Arrays.sort(pref);\\n        long res = 0;\\n        for(int i=0;i<n;i++){\\n            res+=((long)pref[i]*nums[i]);\\n            res%=1000000007;\\n        }\\n        return (int)res%1000000007;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1729972,
                "title": "java-greedy-with-difference-array-priority-queue",
                "content": "Runs a little bit slow but worked \\n\\n```\\nclass Solution {\\n    int mod = (int) 1e9+7;\\n    public int maxSumRangeQuery(int[] nums, int[][] requests) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int [] res = new int[n];\\n        int [] dif = new int[n+2];\\n        for (int [] nxt : requests) {\\n            dif[nxt[0]]++; dif[nxt[1]+1]--;\\n        }\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> {\\n            return b-a;\\n        });\\n        if (dif[0]!=0) {\\n            pq.add(dif[0]);\\n        }\\n        for (int i = 1; i<=n; i++) {\\n            dif[i]+=dif[i-1];\\n            if (dif[i]!=0) {\\n                pq.add(dif[i]);\\n            }\\n        }\\n        int ptr = n-1;\\n        long ans = 0;\\n        while (!pq.isEmpty()) {\\n            int v = pq.poll();\\n            ans = (ans % mod + ((long)v*nums[ptr]) % mod)%mod; \\n            ptr--;\\n        }\\n        return (int) ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int mod = (int) 1e9+7;\\n    public int maxSumRangeQuery(int[] nums, int[][] requests) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int [] res = new int[n];\\n        int [] dif = new int[n+2];\\n        for (int [] nxt : requests) {\\n            dif[nxt[0]]++; dif[nxt[1]+1]--;\\n        }\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> {\\n            return b-a;\\n        });\\n        if (dif[0]!=0) {\\n            pq.add(dif[0]);\\n        }\\n        for (int i = 1; i<=n; i++) {\\n            dif[i]+=dif[i-1];\\n            if (dif[i]!=0) {\\n                pq.add(dif[i]);\\n            }\\n        }\\n        int ptr = n-1;\\n        long ans = 0;\\n        while (!pq.isEmpty()) {\\n            int v = pq.poll();\\n            ans = (ans % mod + ((long)v*nums[ptr]) % mod)%mod; \\n            ptr--;\\n        }\\n        return (int) ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1704447,
                "title": "lala-s-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        const int mxn = 1e5+5;\\n        const long long int md = 1e9 + 7;\\n        vector<int> cnt(mxn,0);\\n        for(auto k:requests){\\n            cnt[k[0]]++;\\n            cnt[k[1]+1]--;\\n        }\\n        vector<int> vbn;\\n        int pfx = 0;\\n        for(int i=0;i<mxn;i++){\\n            pfx+=cnt[i];\\n            if(pfx>0)vbn.push_back(pfx);\\n        }\\n        int ptr = nums.size()-1;\\n        long long int ans = 0;\\n        sort(nums.begin(),nums.end());\\n        sort(vbn.begin(),vbn.end(),greater<int>());\\n        for(auto k : vbn){\\n            ans = (ans + ((k%md)*(nums[ptr]%md))%md)%md;\\n            ptr--;\\n        }\\n        return (ans%md);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        const int mxn = 1e5+5;\\n        const long long int md = 1e9 + 7;\\n        vector<int> cnt(mxn,0);\\n        for(auto k:requests){\\n            cnt[k[0]]++;\\n            cnt[k[1]+1]--;\\n        }\\n        vector<int> vbn;\\n        int pfx = 0;\\n        for(int i=0;i<mxn;i++){\\n            pfx+=cnt[i];\\n            if(pfx>0)vbn.push_back(pfx);\\n        }\\n        int ptr = nums.size()-1;\\n        long long int ans = 0;\\n        sort(nums.begin(),nums.end());\\n        sort(vbn.begin(),vbn.end(),greater<int>());\\n        for(auto k : vbn){\\n            ans = (ans + ((k%md)*(nums[ptr]%md))%md)%md;\\n            ptr--;\\n        }\\n        return (ans%md);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1700007,
                "title": "python3",
                "content": "class Solution:\\n\\n    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\\n        result,n = 0,len(nums)\\n        count=[0]*n\\n        \\n        for request in requests:\\n            start,end=request[0],request[1]+1\\n            count[start]+=1\\n            if end<n:\\n                count[end]-=1   \\n                \\n        for i in range(1,len(count)):\\n            count[i]+=count[i-1]\\n            \\n        count.sort()\\n        nums.sort()\\n        \\n        for x,y in zip(count,nums):\\n            result+=x*y\\n        return result%(10**9+7)",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\\n        result,n = 0,len(nums)\\n        count=[0]*n\\n        \\n        for request in requests:\\n            start,end=request[0],request[1]+1\\n            count[start]+=1\\n            if end<n:\\n                count[end]-=1   \\n                \\n        for i in range(1,len(count)):\\n            count[i]+=count[i-1]\\n            \\n        count.sort()\\n        nums.sort()\\n        \\n        for x,y in zip(count,nums):\\n            result+=x*y\\n        return result%(10**9+7)",
                "codeTag": "Java"
            },
            {
                "id": 1670446,
                "title": "line-sweep-sort-c",
                "content": "```\\n    int m = pow(10, 9) + 7;\\n    \\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        \\n        sort(nums.begin(), nums.end()); reverse(nums.begin(), nums.end());\\n        unordered_map<int, int> mp, gaps; \\n        \\n        for(auto r : requests) mp[r[0]]++, mp[r[1] + 1]--;\\n        \\n        int x = 0;\\n        \\n        for(int i = 0 ; i < nums.size() ; i++) {\\n            \\n            x += mp[i];\\n            if(x) gaps[x]++;\\n        }\\n        \\n        vector<pair<int, int>> v;\\n        for(auto e : gaps) v.push_back({e.first, e.second});\\n        sort(v.begin(), v.end()); reverse(v.begin(), v.end());\\n        \\n        int i = 0;  long long res = 0;\\n        \\n        for(auto n : v) \\n            for(int k = 0 ; k < n.second ; k++) \\n                res = (res + ((long long)nums[i++] * n.first) % m) % m;\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int m = pow(10, 9) + 7;\\n    \\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        \\n        sort(nums.begin(), nums.end()); reverse(nums.begin(), nums.end());\\n        unordered_map<int, int> mp, gaps; \\n        \\n        for(auto r : requests) mp[r[0]]++, mp[r[1] + 1]--;\\n        \\n        int x = 0;\\n        \\n        for(int i = 0 ; i < nums.size() ; i++) {\\n            \\n            x += mp[i];\\n            if(x) gaps[x]++;\\n        }\\n        \\n        vector<pair<int, int>> v;\\n        for(auto e : gaps) v.push_back({e.first, e.second});\\n        sort(v.begin(), v.end()); reverse(v.begin(), v.end());\\n        \\n        int i = 0;  long long res = 0;\\n        \\n        for(auto n : v) \\n            for(int k = 0 ; k < n.second ; k++) \\n                res = (res + ((long long)nums[i++] * n.first) % m) % m;\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1658417,
                "title": "assign-large-numbers-to-the-indexes-with-high-overlap-of-requests",
                "content": "Since we can make any permutation, we can achieve the highest sum by assigning large  numbers to the indexes with high overlap of requests. Therefore, we first count the number of request overlap for each index and calculate the sum.\\n\\ntime complexity: `O(r + n log n)`\\nspace complexity: `O(r + n)`\\nwhere `n` is the length of nums and `r` is the number of reqeusts\\n```typescript\\nconst MOD = Math.pow(10, 9) + 7\\n\\nfunction maxSumRangeQuery(nums: number[], requests: number[][]): number {\\n    // save all the start and end index of the requests in sorted order\\n\\tconst start = []\\n    const end = []\\n    for (let request of requests) {\\n        const [s, e] = request\\n        start.push(s)\\n        end.push(e)\\n    }\\n    start.sort((a, b) => a - b)\\n    end.sort((a, b) => a - b)\\n\\t\\n\\t// for each index, count the number of request overlap\\n    const overlap = Array(nums.length).fill(0)\\n    let cnt = 0\\n    for (let i=0; i<overlap.length; i+=1) {\\n        while (start[0] === i) {\\n            cnt += 1\\n            start.shift()\\n        }\\n        while (end[0] + 1 === i) {\\n            cnt -= 1\\n            end.shift()\\n        }\\n        overlap[i] = cnt\\n    }\\n\\t\\n\\t// calculate the sum\\n    let sum = 0\\n    nums.sort((a, b) => a - b)\\n    overlap.sort((a, b) => b - a)\\n    for (let overlapCnt of overlap) {\\n        if (overlapCnt === 0) {\\n            break\\n        }\\n        sum += overlapCnt * nums.pop() % MOD\\n    }\\n    return sum % MOD\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```typescript\\nconst MOD = Math.pow(10, 9) + 7\\n\\nfunction maxSumRangeQuery(nums: number[], requests: number[][]): number {\\n    // save all the start and end index of the requests in sorted order\\n\\tconst start = []\\n    const end = []\\n    for (let request of requests) {\\n        const [s, e] = request\\n        start.push(s)\\n        end.push(e)\\n    }\\n    start.sort((a, b) => a - b)\\n    end.sort((a, b) => a - b)\\n\\t\\n\\t// for each index, count the number of request overlap\\n    const overlap = Array(nums.length).fill(0)\\n    let cnt = 0\\n    for (let i=0; i<overlap.length; i+=1) {\\n        while (start[0] === i) {\\n            cnt += 1\\n            start.shift()\\n        }\\n        while (end[0] + 1 === i) {\\n            cnt -= 1\\n            end.shift()\\n        }\\n        overlap[i] = cnt\\n    }\\n\\t\\n\\t// calculate the sum\\n    let sum = 0\\n    nums.sort((a, b) => a - b)\\n    overlap.sort((a, b) => b - a)\\n    for (let overlapCnt of overlap) {\\n        if (overlapCnt === 0) {\\n            break\\n        }\\n        sum += overlapCnt * nums.pop() % MOD\\n    }\\n    return sum % MOD\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1577615,
                "title": "tle",
                "content": "My codes are TLE. Where is the problem? I think this should be faster than directly sort the input, as we only need the number range in the requests.\\nheapify is O(n), pulling k largest number is nlogn at most(klogn when k << n). \\n\\n```\\n        n = len(nums)\\n        freq = [0]*n\\n    \\n        for start, end in requests:\\n            for i in range(start,min(end+1,n)):\\n                freq[i] += 1\\n\\n        freq.sort(reverse = True)\\n        k = len(freq)\\n        heapq.heapify(nums)\\n        val = heapq.nlargest(k,nums)\\n        cnt = sum([x*y for (x,y) in zip(freq,val)])\\n        return(cnt%1000000007)\\n```",
                "solutionTags": [],
                "code": "```\\n        n = len(nums)\\n        freq = [0]*n\\n    \\n        for start, end in requests:\\n            for i in range(start,min(end+1,n)):\\n                freq[i] += 1\\n\\n        freq.sort(reverse = True)\\n        k = len(freq)\\n        heapq.heapify(nums)\\n        val = heapq.nlargest(k,nums)\\n        cnt = sum([x*y for (x,y) in zip(freq,val)])\\n        return(cnt%1000000007)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1575620,
                "title": "go-binary-indexed-tree",
                "content": "m * log(n) + n * log(n)\\n```\\nfunc maxSumRangeQuery(nums []int, requests [][]int) int {\\n    \\n    b := BITree{\\n        t: make([]int, len(nums) + 1),\\n        l: len(nums) + 1,\\n    }\\n    for _, v := range requests {\\n        b.add(v[0] + 1, 1) \\n        b.add(v[1] + 2, -1)\\n    }\\n    \\n    times := make([]int, len(nums))\\n    for i := 0; i < len(nums); i++ {\\n        times[i] = b.sum(i + 1)\\n    }\\n    \\n    sort.Ints(nums)\\n    sort.Ints(times)    \\n    \\n    res := 0\\n    for i := 0; i < len(times); i++ {\\n        res = (res + times[i] * nums[i]) % 1000000007\\n    }\\n    return res\\n}\\n\\ntype BITree struct {\\n    t []int\\n    l int\\n}\\n\\n\\nfunc (b BITree) sum(n int) int {\\n    res := 0\\n    for n > 0 {\\n        res += b.t[n]\\n        n = n & (n - 1)\\n    }\\n    return res\\n}\\n\\nfunc (b BITree) add(n int, a int) { \\n    for n < b.l {\\n        b.t[n] += a\\n        n = n + n - n & (n - 1)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc maxSumRangeQuery(nums []int, requests [][]int) int {\\n    \\n    b := BITree{\\n        t: make([]int, len(nums) + 1),\\n        l: len(nums) + 1,\\n    }\\n    for _, v := range requests {\\n        b.add(v[0] + 1, 1) \\n        b.add(v[1] + 2, -1)\\n    }\\n    \\n    times := make([]int, len(nums))\\n    for i := 0; i < len(nums); i++ {\\n        times[i] = b.sum(i + 1)\\n    }\\n    \\n    sort.Ints(nums)\\n    sort.Ints(times)    \\n    \\n    res := 0\\n    for i := 0; i < len(times); i++ {\\n        res = (res + times[i] * nums[i]) % 1000000007\\n    }\\n    return res\\n}\\n\\ntype BITree struct {\\n    t []int\\n    l int\\n}\\n\\n\\nfunc (b BITree) sum(n int) int {\\n    res := 0\\n    for n > 0 {\\n        res += b.t[n]\\n        n = n & (n - 1)\\n    }\\n    return res\\n}\\n\\nfunc (b BITree) add(n int, a int) { \\n    for n < b.l {\\n        b.t[n] += a\\n        n = n + n - n & (n - 1)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1423209,
                "title": "o-nlogn-prefix-sum-method-17ms-sol-in-java-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int maxSumRangeQuery(int[] nums, int[][] requests) {\\n        int req[] = new int[nums.length]; //create a new request array\\n        for(int i = 0; i < requests.length; i++)\\n        { \\n            int left = requests[i][0]; //get starting point of range\\n            int right = requests[i][1]; // get ending point of range\\n            req[left] += 1;              // increase the left index by 1\\n            if(right + 1 < nums.length){ // if right+1 is in range\\n                req[right+1] -= 1;       //decrease right index by 1\\n            }\\n        }\\n        for(int i = 1; i < nums.length; i++)\\n        {                                     //calculate prefix sum for req array\\n            req[i] += req[i - 1];   \\n        }\\n        Arrays.sort(req); //sort req array \\n        Arrays.sort(nums); //sort req array\\n        \\n        long sum = 0; //initialize sum \\n        int MOD = (int)Math.pow(10,9) + 7; //calculate mod\\n        for(int i = 0 ; i < nums.length; i++)  //run a loop to calculate final sum\\n        {\\n            sum += (long)nums[i] * (long)req[i];\\n        }\\n        return (int)(sum % MOD); //return \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumRangeQuery(int[] nums, int[][] requests) {\\n        int req[] = new int[nums.length]; //create a new request array\\n        for(int i = 0; i < requests.length; i++)\\n        { \\n            int left = requests[i][0]; //get starting point of range\\n            int right = requests[i][1]; // get ending point of range\\n            req[left] += 1;              // increase the left index by 1\\n            if(right + 1 < nums.length){ // if right+1 is in range\\n                req[right+1] -= 1;       //decrease right index by 1\\n            }\\n        }\\n        for(int i = 1; i < nums.length; i++)\\n        {                                     //calculate prefix sum for req array\\n            req[i] += req[i - 1];   \\n        }\\n        Arrays.sort(req); //sort req array \\n        Arrays.sort(nums); //sort req array\\n        \\n        long sum = 0; //initialize sum \\n        int MOD = (int)Math.pow(10,9) + 7; //calculate mod\\n        for(int i = 0 ; i < nums.length; i++)  //run a loop to calculate final sum\\n        {\\n            sum += (long)nums[i] * (long)req[i];\\n        }\\n        return (int)(sum % MOD); //return \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1385608,
                "title": "o-n-log-n-sorting-differencearray-c",
                "content": "```\\n\\t#define ll long long int\\n\\t#define MOD (ll) 1e9 + 7\\n\\n\\t#define ModAdd(a,b,N) \\t\\t((a)%(N) + (b)%(N))%(N)\\n\\t#define ModSub(a,b,N) \\t\\t((a)%(N) - (b)%(N))%(N)\\n\\t#define ModMultiply(a,b,N)\\t((a)%(N) * (b)%(N))%(N)\\n\\n\\tint maxSumRangeQuery(vector<int>& a, vector<vector<int>>& Q) \\n    {\\n        int n = a.size();\\n        int d[n + 1]; for(int i = 0; i <= n; i++) d[i] = 0;\\n        \\n        for(auto q : Q)\\n        {\\n            d[q[0]]++;\\n            d[q[1] + 1]--;\\n        }\\n        \\n        for(int i = 1; i <= n; i++) d[i] += d[i - 1];\\n        \\n        vector<int> need;\\n        for(int i = 0; i < n; i++) if(d[i]) need.push_back(d[i]);\\n        \\n        sort(need.begin(),need.end(),greater<int>());\\n        \\n        sort(a.begin(),a.end(),greater<int>());\\n        \\n        int ans = 0;\\n        for(int i = 0; i < need.size(); i++)\\n            ans = ModAdd(ans,ModMultiply(need[i] , a[i], MOD),MOD);\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\t#define ll long long int\\n\\t#define MOD (ll) 1e9 + 7\\n\\n\\t#define ModAdd(a,b,N) \\t\\t((a)%(N) + (b)%(N))%(N)\\n\\t#define ModSub(a,b,N) \\t\\t((a)%(N) - (b)%(N))%(N)\\n\\t#define ModMultiply(a,b,N)\\t((a)%(N) * (b)%(N))%(N)\\n\\n\\tint maxSumRangeQuery(vector<int>& a, vector<vector<int>>& Q) \\n    {\\n        int n = a.size();\\n        int d[n + 1]; for(int i = 0; i <= n; i++) d[i] = 0;\\n        \\n        for(auto q : Q)\\n        {\\n            d[q[0]]++;\\n            d[q[1] + 1]--;\\n        }\\n        \\n        for(int i = 1; i <= n; i++) d[i] += d[i - 1];\\n        \\n        vector<int> need;\\n        for(int i = 0; i < n; i++) if(d[i]) need.push_back(d[i]);\\n        \\n        sort(need.begin(),need.end(),greater<int>());\\n        \\n        sort(a.begin(),a.end(),greater<int>());\\n        \\n        int ans = 0;\\n        for(int i = 0; i < need.size(); i++)\\n            ans = ModAdd(ans,ModMultiply(need[i] , a[i], MOD),MOD);\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1345876,
                "title": "java-solution",
                "content": "My JAVA solution - \\n\\nclass Solution {\\n    public int maxSumRangeQuery(int[] nums, int[][] requests) {\\n        int n = nums.length;\\n        int rep[] = new int[n];\\n        Arrays.fill(rep,0);\\n        for(int i=0;i<requests.length;i++){\\n            int s = requests[i][0];\\n            int e = requests[i][1];\\n            rep[s]++;\\n            if(e+1<n)\\n            rep[e+1]--;\\n        }\\n        for(int i=1;i<n;i++){\\n            rep[i]=rep[i-1]+rep[i];\\n        }\\n        Arrays.sort(nums);\\n        long res = 0;\\n        Arrays.sort(rep);\\n        for(int i : rep)\\n        for(int i=n-1;i>=0;i--){\\n            res = (res +(long) rep[i]*nums[i])  ;\\n        }\\n        return (int)(res%1000000007);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxSumRangeQuery(int[] nums, int[][] requests) {\\n        int n = nums.length;\\n        int rep[] = new int[n];\\n        Arrays.fill(rep,0);\\n        for(int i=0;i<requests.length;i++){\\n            int s = requests[i][0];\\n            int e = requests[i][1];\\n            rep[s]++;\\n            if(e+1<n)\\n            rep[e+1]--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1335436,
                "title": "find-the-repeated-times-for-each-unique-range-in-the-array-then-greedily-to-assign-the-max",
                "content": "```scala\\n  def maxSumRangeQuery(nums: Array[Int], requests: Array[Array[Int]]): Int = {\\n    type int = Int\\n    case class D(id: int, start: int)\\n    case class T(wid: int, times: int)\\n   \\n    val arr = Array.ofDim[D](requests.length << 1)\\n    var i   = 0\\n    requests.foreach(r => {\\n      arr(i) = D(r(0), 1)\\n      arr(i + 1) = D(r(1), -1)\\n      i += 2\\n    })\\n    arr.sortInPlaceWith((a, b) => if (a.id != b.id) a.id < b.id else a.start > b.start)\\n    var count = 0\\n    import scala.collection.mutable.ArrayBuffer\\n    val ab   = new ArrayBuffer[T]\\n    var prev = -1\\n    arr.foreach(d => {\\n      if (prev != -1) ab append T(d.id - prev + (if (d.start == 1) 0 else 1), count)\\n      prev = if (d.start == 1) d.id else d.id + 1\\n      if (d.start == 1) count += 1 else count -= 1\\n    })\\n    ab.sortInPlaceWith((a, b) => a.times > b.times)\\n    nums.sortInPlaceWith(_ > _)\\n    i = 0\\n    var res = 0d\\n    ab.foreach(x => {\\n      var tmp = 0d\\n      (0 until x.wid).foreach(y => tmp += nums(i + y))\\n      i += x.wid\\n      res += tmp * x.times\\n    })\\n\\n    (res % (Math.pow(10, 9) + 7)).toInt\\n\\n  }\\n```",
                "solutionTags": [],
                "code": "```scala\\n  def maxSumRangeQuery(nums: Array[Int], requests: Array[Array[Int]]): Int = {\\n    type int = Int\\n    case class D(id: int, start: int)\\n    case class T(wid: int, times: int)\\n   \\n    val arr = Array.ofDim[D](requests.length << 1)\\n    var i   = 0\\n    requests.foreach(r => {\\n      arr(i) = D(r(0), 1)\\n      arr(i + 1) = D(r(1), -1)\\n      i += 2\\n    })\\n    arr.sortInPlaceWith((a, b) => if (a.id != b.id) a.id < b.id else a.start > b.start)\\n    var count = 0\\n    import scala.collection.mutable.ArrayBuffer\\n    val ab   = new ArrayBuffer[T]\\n    var prev = -1\\n    arr.foreach(d => {\\n      if (prev != -1) ab append T(d.id - prev + (if (d.start == 1) 0 else 1), count)\\n      prev = if (d.start == 1) d.id else d.id + 1\\n      if (d.start == 1) count += 1 else count -= 1\\n    })\\n    ab.sortInPlaceWith((a, b) => a.times > b.times)\\n    nums.sortInPlaceWith(_ > _)\\n    i = 0\\n    var res = 0d\\n    ab.foreach(x => {\\n      var tmp = 0d\\n      (0 until x.wid).foreach(y => tmp += nums(i + y))\\n      i += x.wid\\n      res += tmp * x.times\\n    })\\n\\n    (res % (Math.pow(10, 9) + 7)).toInt\\n\\n  }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1335342,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\n    static bool compare(const int&a , const int&b)\\n    {\\n        return a>b;\\n    }\\n    \\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        int n=nums.size();\\n        vector<int>v(n+1,0);\\n        for(int i=0;i<requests.size();i++)\\n        {\\n            v[requests[i][0]]++;\\n            v[requests[i][1]+1]--;\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            v[i]+=v[i-1];\\n        }\\n        long long ans=0;\\n        long long cv = 1e9+7;\\n        priority_queue<long long>pq;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(v[i]!=0)\\n            {\\n                pq.push(v[i]);\\n            }\\n        }\\n        sort(nums.begin(),nums.end(),compare);\\n        int j=0;\\n        while(!pq.empty() && j<nums.size())\\n        {\\n            ans+= (nums[j]*pq.top())%1000000007;\\n            pq.pop();\\n            j++;\\n        }\\n        return ans%cv;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    static bool compare(const int&a , const int&b)\\n    {\\n        return a>b;\\n    }\\n    \\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        int n=nums.size();\\n        vector<int>v(n+1,0);\\n        for(int i=0;i<requests.size();i++)\\n        {\\n            v[requests[i][0]]++;\\n            v[requests[i][1]+1]--;\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            v[i]+=v[i-1];\\n        }\\n        long long ans=0;\\n        long long cv = 1e9+7;\\n        priority_queue<long long>pq;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(v[i]!=0)\\n            {\\n                pq.push(v[i]);\\n            }\\n        }\\n        sort(nums.begin(),nums.end(),compare);\\n        int j=0;\\n        while(!pq.empty() && j<nums.size())\\n        {\\n            ans+= (nums[j]*pq.top())%1000000007;\\n            pq.pop();\\n            j++;\\n        }\\n        return ans%cv;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1307467,
                "title": "java-85-faster-sorting",
                "content": "```\\nclass Solution {\\n    public int maxSumRangeQuery(int[] nums, int[][] requests) {\\n        Arrays.sort(nums);\\n        int l=nums.length;\\n        int[] tempArr= new int[l];\\n\\t\\t// requests[i][0] incrementing index element by 1 and for requests[i][1]+1 decrementing by 1\\n\\t\\t// this will help me get the freq of occurance of each index of array \\'nums\\' in \\n\\t\\t// all \\'requests\\' intervals when I compute the sum array of tempArr.\\n        for(int i=0;i<requests.length;i++){\\n            int a=requests[i][0];\\n            int b=requests[i][1]+1;\\n            tempArr[a]++;\\n            if(b<l)\\n                tempArr[b]--;\\n        }\\n        \\n        int prev=0;\\n        for(int i=0;i<l;i++){\\n            tempArr[i]+=prev;\\n            prev=tempArr[i];\\n        }\\n        Arrays.sort(tempArr);\\n        int index = l-1;\\n        \\n        long ans = 0;\\n        while(index>=0){\\n            if(tempArr[index]==0)\\n                break;\\n            long x=tempArr[index]%1000000007;\\n            long y=nums[index]%1000000007;\\n            index--;\\n            ans+=x*y;\\n        }\\n        \\n        return (int)(ans%1000000007);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumRangeQuery(int[] nums, int[][] requests) {\\n        Arrays.sort(nums);\\n        int l=nums.length;\\n        int[] tempArr= new int[l];\\n\\t\\t// requests[i][0] incrementing index element by 1 and for requests[i][1]+1 decrementing by 1\\n\\t\\t// this will help me get the freq of occurance of each index of array \\'nums\\' in \\n\\t\\t// all \\'requests\\' intervals when I compute the sum array of tempArr.\\n        for(int i=0;i<requests.length;i++){\\n            int a=requests[i][0];\\n            int b=requests[i][1]+1;\\n            tempArr[a]++;\\n            if(b<l)\\n                tempArr[b]--;\\n        }\\n        \\n        int prev=0;\\n        for(int i=0;i<l;i++){\\n            tempArr[i]+=prev;\\n            prev=tempArr[i];\\n        }\\n        Arrays.sort(tempArr);\\n        int index = l-1;\\n        \\n        long ans = 0;\\n        while(index>=0){\\n            if(tempArr[index]==0)\\n                break;\\n            long x=tempArr[index]%1000000007;\\n            long y=nums[index]%1000000007;\\n            index--;\\n            ans+=x*y;\\n        }\\n        \\n        return (int)(ans%1000000007);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1302399,
                "title": "c-simple-greedy-solution-using-priority-queue",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    static bool comp(int a,int b)\\n    {\\n        return a>b;\\n    }\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        int n=nums.size();\\n        int ar[n+3];\\n        memset(ar,0,sizeof(ar));\\n        for(int i=0;i<requests.size();i++)\\n        {\\n            ar[requests[i][0]]++;\\n            ar[requests[i][1]+1]--;\\n        }\\n        priority_queue<int> pq;\\n        for(int i=1;i<n;i++)\\n        {\\n            ar[i]+=ar[i-1];\\n            if(ar[i]>0)\\n            {\\n                pq.push(ar[i]);\\n            }\\n        }\\n        if(ar[0]>0)\\n        {\\n            pq.push(ar[0]);\\n        }\\n        sort(nums.begin(),nums.end(),comp);\\n        int i=0;\\n        long ans=0;\\n        while(!pq.empty())\\n        {\\n            ans=(ans+((long)nums[i]*(long)pq.top())%1000000007)%1000000007;\\n            // cout<<pq.top()<<\" \";\\n            pq.pop();\\n            i++;\\n        }\\n        ans=ans%1000000007;\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    static bool comp(int a,int b)\\n    {\\n        return a>b;\\n    }\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        int n=nums.size();\\n        int ar[n+3];\\n        memset(ar,0,sizeof(ar));\\n        for(int i=0;i<requests.size();i++)\\n        {\\n            ar[requests[i][0]]++;\\n            ar[requests[i][1]+1]--;\\n        }\\n        priority_queue<int> pq;\\n        for(int i=1;i<n;i++)\\n        {\\n            ar[i]+=ar[i-1];\\n            if(ar[i]>0)\\n            {\\n                pq.push(ar[i]);\\n            }\\n        }\\n        if(ar[0]>0)\\n        {\\n            pq.push(ar[0]);\\n        }\\n        sort(nums.begin(),nums.end(),comp);\\n        int i=0;\\n        long ans=0;\\n        while(!pq.empty())\\n        {\\n            ans=(ans+((long)nums[i]*(long)pq.top())%1000000007)%1000000007;\\n            // cout<<pq.top()<<\" \";\\n            pq.pop();\\n            i++;\\n        }\\n        ans=ans%1000000007;\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1242810,
                "title": "c-counting-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long int\\n    int mod=1000000007;\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) \\n    {\\n        int n=nums.size();\\n        vector<int>freq(n+1,0);\\n        for(auto q:requests)\\n        {\\n            freq[q[0]]++;\\n            freq[q[1]+1]--;\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            freq[i]+=freq[i-1];\\n        }\\n        sort(freq.rbegin(),freq.rend());\\n        sort(nums.rbegin(),nums.rend());\\n        ll res=0;\\n        for(int i=0;i<n;i++)\\n            res=(res+(ll)freq[i]*nums[i])%mod;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long int\\n    int mod=1000000007;\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) \\n    {\\n        int n=nums.size();\\n        vector<int>freq(n+1,0);\\n        for(auto q:requests)\\n        {\\n            freq[q[0]]++;\\n            freq[q[1]+1]--;\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            freq[i]+=freq[i-1];\\n        }\\n        sort(freq.rbegin(),freq.rend());\\n        sort(nums.rbegin(),nums.rend());\\n        ll res=0;\\n        for(int i=0;i<n;i++)\\n            res=(res+(ll)freq[i]*nums[i])%mod;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1242192,
                "title": "is-this-called-scanline",
                "content": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9+7;\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n    int n = nums.size();\\n    vector<int> count(n,0);\\n    for(int i =0; i<requests.size(); i++){\\n        \\n        count[requests[i][0]]++;\\n        if(requests[i][1]+1<n) count[requests[i][1]+1]--;\\n        \\n        \\n    }\\n        \\n    for(int i =1; i<n; i++){\\n        count[i]+=count[i-1];\\n    }\\n    sort(count.begin(),count.end());\\n    sort(nums.begin(),nums.end());\\n    long long int res =0;\\n    for(int i =0; i<n; i++){\\n    res = (res + ((long)count[i]*nums[i])%mod)%mod;    \\n    }\\n    return res%(mod);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9+7;\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n    int n = nums.size();\\n    vector<int> count(n,0);\\n    for(int i =0; i<requests.size(); i++){\\n        \\n        count[requests[i][0]]++;\\n        if(requests[i][1]+1<n) count[requests[i][1]+1]--;\\n        \\n        \\n    }\\n        \\n    for(int i =1; i<n; i++){\\n        count[i]+=count[i-1];\\n    }\\n    sort(count.begin(),count.end());\\n    sort(nums.begin(),nums.end());\\n    long long int res =0;\\n    for(int i =0; i<n; i++){\\n    res = (res + ((long)count[i]*nums[i])%mod)%mod;    \\n    }\\n    return res%(mod);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1214671,
                "title": "c-solution-using-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxNumber = (int)1e9+7;\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        priority_queue<long long int> maxValue;\\n        for(int x : nums){\\n            maxValue.push(x);\\n        }\\n        \\n        int len =nums.size();\\n        vector<long long int> indexFreq(len+2,0);\\n        for(vector<int> pairs : requests){\\n            // for(int i = pairs[0];i<=pairs[1];i++){\\n            //     indexFreq[i]=indexFreq[i]+1;\\n            // }\\n            indexFreq[pairs[0]]++;\\n            indexFreq[pairs[1]+1]--;\\n        }\\n        \\n        for(int i=1;i<indexFreq.size();i++){\\n            indexFreq[i]=indexFreq[i]+indexFreq[i-1];\\n        }\\n        \\n        sort(indexFreq.begin(), indexFreq.end());\\n        \\n        long long int i=len+1,sum=0;\\n        while(indexFreq[i]!=0 && i>=0 && !maxValue.empty()){\\n            sum = (sum%maxNumber + (indexFreq[i]*maxValue.top())%maxNumber)%maxNumber;\\n            maxValue.pop();\\n            i--;\\n        }\\n        \\n        return sum;\\n        \\n    }\\n};\\n```\\n\\nThe Aim is to use prefix Sum technique to calculate indexFreq;",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxNumber = (int)1e9+7;\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        priority_queue<long long int> maxValue;\\n        for(int x : nums){\\n            maxValue.push(x);\\n        }\\n        \\n        int len =nums.size();\\n        vector<long long int> indexFreq(len+2,0);\\n        for(vector<int> pairs : requests){\\n            // for(int i = pairs[0];i<=pairs[1];i++){\\n            //     indexFreq[i]=indexFreq[i]+1;\\n            // }\\n            indexFreq[pairs[0]]++;\\n            indexFreq[pairs[1]+1]--;\\n        }\\n        \\n        for(int i=1;i<indexFreq.size();i++){\\n            indexFreq[i]=indexFreq[i]+indexFreq[i-1];\\n        }\\n        \\n        sort(indexFreq.begin(), indexFreq.end());\\n        \\n        long long int i=len+1,sum=0;\\n        while(indexFreq[i]!=0 && i>=0 && !maxValue.empty()){\\n            sum = (sum%maxNumber + (indexFreq[i]*maxValue.top())%maxNumber)%maxNumber;\\n            maxValue.pop();\\n            i--;\\n        }\\n        \\n        return sum;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1208670,
                "title": "c",
                "content": "/*Reverse order qsort*/\\nint cmp(const void* a,const void* b){\\n    return *(int*)b-*(int*)a;\\n}\\n\\n\\nint maxSumRangeQuery(int* nums, int numsSize, int** requests, int requestsSize, int* requestsColSize){\\n    int mod = 1000000007;\\n    int* count = (int*)calloc((numsSize+1),sizeof(int));\\n    for(int i=0;i<requestsSize;i++){\\n        count[requests[i][0]]++;\\n        count[requests[i][1]+1]--;\\n    }\\n    for(int i=1;i<=numsSize;i++){\\n        count[i] += count[i-1];\\n    }\\n    \\n    long long result = 0;\\n    qsort(count,numsSize+1,sizeof(int),cmp);\\n    qsort(nums,numsSize,sizeof(int),cmp);\\n    \\n    \\n    for(int i=0;i<numsSize;i++){\\n        int temp = count[i];\\n        result+=(((long long)count[i]%mod)*nums[i]);  //(long long) is necessary\\n    }\\n    return result%=mod;\\n}",
                "solutionTags": [],
                "code": "/*Reverse order qsort*/\\nint cmp(const void* a,const void* b){\\n    return *(int*)b-*(int*)a;\\n}\\n\\n\\nint maxSumRangeQuery(int* nums, int numsSize, int** requests, int requestsSize, int* requestsColSize){\\n    int mod = 1000000007;\\n    int* count = (int*)calloc((numsSize+1),sizeof(int));\\n    for(int i=0;i<requestsSize;i++){\\n        count[requests[i][0]]++;\\n        count[requests[i][1]+1]--;\\n    }\\n    for(int i=1;i<=numsSize;i++){\\n        count[i] += count[i-1];\\n    }\\n    \\n    long long result = 0;\\n    qsort(count,numsSize+1,sizeof(int),cmp);\\n    qsort(nums,numsSize,sizeof(int),cmp);\\n    \\n    \\n    for(int i=0;i<numsSize;i++){\\n        int temp = count[i];\\n        result+=(((long long)count[i]%mod)*nums[i]);  //(long long) is necessary\\n    }\\n    return result%=mod;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1202615,
                "title": "js",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number[][]} requests\\n * @return {number}\\n */\\nvar maxSumRangeQuery = function(nums, requests) {\\n    const len = nums.length\\n    nums.sort((a, b) => a - b)\\n    \\n    \\n    const patchesMap = new Map()\\n    for (const request of requests.values()) {\\n        const [fromIndex, toIndex] = request\\n        const startIndex = -1 + fromIndex\\n        const endIndex = toIndex\\n        patchesMap.set(startIndex, -1 + (patchesMap.get(startIndex) || 0))\\n        patchesMap.set(endIndex, 1 + (patchesMap.get(endIndex) || 0))\\n    }\\n    \\n    const plusPatches = [], minusPatches = []\\n    for (const [i, val] of patchesMap.entries()) {\\n        if (val === 0)  continue\\n        let pushTo\\n        if (val > 0) pushTo = plusPatches\\n        else pushTo = minusPatches\\n        \\n        for (let j = 0, absVal = Math.abs(val);\\n        j < absVal; j++) {\\n            pushTo.push(i)\\n        }\\n    }\\n\\n    \\n    function compare(a, b) {\\n        return a - b\\n    }\\n    \\n    plusPatches.sort(compare)\\n    minusPatches.sort(compare)\\n    \\n    const table = new Array(len)\\n    for (let i = 0, plusPatchIndex = 0, minusPatchIndex = 0; i < len; i++) {\\n        for (; plusPatchIndex < plusPatches.length; plusPatchIndex++) {\\n            const plusPatch = plusPatches[plusPatchIndex]\\n            if (plusPatch >= i) break\\n        }\\n        const plusCount = plusPatches.length - plusPatchIndex\\n        \\n        for (; minusPatchIndex < minusPatches.length; minusPatchIndex++) {\\n            const minusPatch = minusPatches[minusPatchIndex]\\n            if (minusPatch >= i)    break\\n        }\\n        const minusCount = minusPatches.length - minusPatchIndex\\n        \\n        const patchCount = plusCount - minusCount\\n        const record = { i, patchCount }\\n        table[i] = record\\n    }\\n    table.sort((A, B) => B.patchCount - A.patchCount)\\n\\n    \\n    let order = new Array(len)\\n    for (let i = 0; i < len; i++) {\\n        const index = table[i].i\\n        const value = nums.pop()\\n        order[index] = value\\n    }\\n\\n    \\n    const sumSF = new Array(len)\\n    sumSF[-1] = 0\\n    for (const [i, val] of order.entries())\\n        sumSF[i] = val + sumSF[-1 + i]\\n\\n\\n    let result = 0\\n    const modMe = 10 ** 9 + 7\\n    for (const request of requests.values()) {\\n        const [fromIndex, toIndex] = request\\n        let outcome = sumSF[toIndex] - sumSF[-1 + fromIndex]\\n        result += outcome\\n        result %= modMe\\n    }\\n    \\n    \\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number[][]} requests\\n * @return {number}\\n */\\nvar maxSumRangeQuery = function(nums, requests) {\\n    const len = nums.length\\n    nums.sort((a, b) => a - b)\\n    \\n    \\n    const patchesMap = new Map()\\n    for (const request of requests.values()) {\\n        const [fromIndex, toIndex] = request\\n        const startIndex = -1 + fromIndex\\n        const endIndex = toIndex\\n        patchesMap.set(startIndex, -1 + (patchesMap.get(startIndex) || 0))\\n        patchesMap.set(endIndex, 1 + (patchesMap.get(endIndex) || 0))\\n    }\\n    \\n    const plusPatches = [], minusPatches = []\\n    for (const [i, val] of patchesMap.entries()) {\\n        if (val === 0)  continue\\n        let pushTo\\n        if (val > 0) pushTo = plusPatches\\n        else pushTo = minusPatches\\n        \\n        for (let j = 0, absVal = Math.abs(val);\\n        j < absVal; j++) {\\n            pushTo.push(i)\\n        }\\n    }\\n\\n    \\n    function compare(a, b) {\\n        return a - b\\n    }\\n    \\n    plusPatches.sort(compare)\\n    minusPatches.sort(compare)\\n    \\n    const table = new Array(len)\\n    for (let i = 0, plusPatchIndex = 0, minusPatchIndex = 0; i < len; i++) {\\n        for (; plusPatchIndex < plusPatches.length; plusPatchIndex++) {\\n            const plusPatch = plusPatches[plusPatchIndex]\\n            if (plusPatch >= i) break\\n        }\\n        const plusCount = plusPatches.length - plusPatchIndex\\n        \\n        for (; minusPatchIndex < minusPatches.length; minusPatchIndex++) {\\n            const minusPatch = minusPatches[minusPatchIndex]\\n            if (minusPatch >= i)    break\\n        }\\n        const minusCount = minusPatches.length - minusPatchIndex\\n        \\n        const patchCount = plusCount - minusCount\\n        const record = { i, patchCount }\\n        table[i] = record\\n    }\\n    table.sort((A, B) => B.patchCount - A.patchCount)\\n\\n    \\n    let order = new Array(len)\\n    for (let i = 0; i < len; i++) {\\n        const index = table[i].i\\n        const value = nums.pop()\\n        order[index] = value\\n    }\\n\\n    \\n    const sumSF = new Array(len)\\n    sumSF[-1] = 0\\n    for (const [i, val] of order.entries())\\n        sumSF[i] = val + sumSF[-1 + i]\\n\\n\\n    let result = 0\\n    const modMe = 10 ** 9 + 7\\n    for (const request of requests.values()) {\\n        const [fromIndex, toIndex] = request\\n        let outcome = sumSF[toIndex] - sumSF[-1 + fromIndex]\\n        result += outcome\\n        result %= modMe\\n    }\\n    \\n    \\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1171184,
                "title": "detailed-o-nlogn-solution-using-prefix-sum-technique",
                "content": "\\t// time complexity : O(nlogn), space complexity : O(max(requests))\\n\\t/*\\n\\t  --> Since we need to maximize our sum, we try to put the max value in that index whose request is more, so that it will be added as many times as possbile.\\n\\t  --> Using prefix array technique, the the request for each index.\\n\\t  --> Then sort prefix[] and nums[] \\n\\t  --> And assign highest value in nums to highest value in prefix[] untill there are requests\\n\\t*/\\n\\tclass Solution {\\n\\t\\tpublic int maxSumRangeQuery(int[] nums, int[][] requests) {\\n\\t\\t\\tint maxIndex = 0;\\n\\t\\t\\tfor(int[] ele : requests)\\n\\t\\t\\t\\tmaxIndex = Math.max(maxIndex,Math.max(ele[0],ele[1]));\\n\\t\\t\\tlong[] prefix = new long[maxIndex+2];\\n\\t\\t\\tfor(int[] ele : requests){\\n\\t\\t\\t\\tprefix[ele[0]]++;\\n\\t\\t\\t\\tprefix[ele[1]+1]--;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=1;i<prefix.length;i++)\\n\\t\\t\\t\\t prefix[i] += prefix[i-1];\\n\\t\\t\\tArrays.sort(prefix);\\n\\t\\t\\tArrays.sort(nums);\\n\\t\\t\\tlong sum = 0;\\n\\t\\t\\tint mod = (int)1e9+7;\\n\\t\\t\\tint i = nums.length-1;\\n\\t\\t\\tint last = prefix.length-1;\\n\\t\\t\\twhile(last>=0 && prefix[last]>0){\\n\\t\\t\\t\\tsum += (prefix[last--] * nums[i--]);\\n\\t\\t\\t\\tsum %=mod;\\n\\t\\t\\t}\\n\\t\\t\\treturn (int)sum;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int maxSumRangeQuery(int[] nums, int[][] requests) {\\n\\t\\t\\tint maxIndex = 0;\\n\\t\\t\\tfor(int[] ele : requests)\\n\\t\\t\\t\\tmaxIndex = Math.max(maxIndex,Math.max(ele[0],ele[1]));\\n\\t\\t\\tlong[] prefix = new long[maxIndex+2];\\n\\t\\t\\tfor(int[] ele : requests){\\n\\t\\t\\t\\tprefix[ele[0]]++;\\n\\t\\t\\t\\tprefix[ele[1]+1]--;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1107329,
                "title": "c-fast-enough-and-short-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        vector<int> freq(nums.size()+1, 0);\\n        for (const auto& r : requests) {\\n            freq[r[0]]++;\\n            freq[r[1]+1]--;\\n        }\\n        freq.pop_back();\\n        partial_sum(freq.begin(), freq.end(), freq.begin());\\n        \\n        sort(nums.begin(), nums.end());\\n        sort(freq.begin(), freq.end());\\n        \\n        long long ans = 0;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            if (!freq[i]) continue;\\n            ans += (long long)nums[i] * freq[i];\\n            ans %= 1000000007;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        vector<int> freq(nums.size()+1, 0);\\n        for (const auto& r : requests) {\\n            freq[r[0]]++;\\n            freq[r[1]+1]--;\\n        }\\n        freq.pop_back();\\n        partial_sum(freq.begin(), freq.end(), freq.begin());\\n        \\n        sort(nums.begin(), nums.end());\\n        sort(freq.begin(), freq.end());\\n        \\n        long long ans = 0;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            if (!freq[i]) continue;\\n            ans += (long long)nums[i] * freq[i];\\n            ans %= 1000000007;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1089379,
                "title": "c-solution-sort-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& req) {\\n        int n = nums.size();\\n        vector<long long > order(n) , freq(n+1,0);\\n        for( int i = 0; i < req.size();i++){\\n            freq[ req[i][0] ] += 1;\\n            freq[ req[i][1] + 1 ] -= 1;\\n        }\\n        for( int i = 1 ; i <n ;i ++){\\n            freq[i] += freq[i-1];\\n        }\\n        for( int i =0 ;i<n;i++) order[i] = i ;\\n        sort( order.begin() , order.end() , [&](int x , int y){\\n            return freq[x]<freq[y];\\n        });\\n        \\n        sort( nums.begin() , nums.end());\\n        long long  ans = 0;\\n        for( int i = 0 ;i<n;i++){\\n            ans+= (freq[order[i]]*nums[i]);\\n            ans = ans%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& req) {\\n        int n = nums.size();\\n        vector<long long > order(n) , freq(n+1,0);\\n        for( int i = 0; i < req.size();i++){\\n            freq[ req[i][0] ] += 1;\\n            freq[ req[i][1] + 1 ] -= 1;\\n        }\\n        for( int i = 1 ; i <n ;i ++){\\n            freq[i] += freq[i-1];\\n        }\\n        for( int i =0 ;i<n;i++) order[i] = i ;\\n        sort( order.begin() , order.end() , [&](int x , int y){\\n            return freq[x]<freq[y];\\n        });\\n        \\n        sort( nums.begin() , nums.end());\\n        long long  ans = 0;\\n        for( int i = 0 ;i<n;i++){\\n            ans+= (freq[order[i]]*nums[i]);\\n            ans = ans%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1085563,
                "title": "go-golang-solution-using-sort-not-optimized",
                "content": "```\\ntype indexCount struct {\\n    idx int\\n    count int\\n}\\n\\nfunc maxSumRangeQuery(nums []int, requests [][]int) int {\\n    \\n    requestArray := make([]indexCount, len(nums))\\n    \\n    for i := 0; i < len(nums); i++ {\\n        requestArray[i].idx = i\\n    }\\n    \\n    for _, request := range requests {\\n        for i := request[0]; i <= request[1]; i++ {\\n            requestArray[i].count++\\n        }\\n    }\\n    \\n    sort.Slice(requestArray, func(i, j int) bool {\\n        return requestArray[i].count > requestArray[j].count\\n    })\\n    \\n    sort.Ints(nums)\\n    n := len(nums)-1\\n    output := make([]int, len(nums))\\n    for i := 0; i < len(requestArray); i++ {\\n        idx := requestArray[i].idx\\n        output[idx] = nums[n]\\n        n--\\n    }\\n    \\n    count := 0\\n        \\n    for i := 0; i < len(requestArray); i++ {\\n        if requestArray[i].count > 0 {\\n            idx := requestArray[i].idx\\n            count += (requestArray[i].count * output[idx])\\n            count = count % 1000000007\\n        }\\n    }\\n    \\n    return count \\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntype indexCount struct {\\n    idx int\\n    count int\\n}\\n\\nfunc maxSumRangeQuery(nums []int, requests [][]int) int {\\n    \\n    requestArray := make([]indexCount, len(nums))\\n    \\n    for i := 0; i < len(nums); i++ {\\n        requestArray[i].idx = i\\n    }\\n    \\n    for _, request := range requests {\\n        for i := request[0]; i <= request[1]; i++ {\\n            requestArray[i].count++\\n        }\\n    }\\n    \\n    sort.Slice(requestArray, func(i, j int) bool {\\n        return requestArray[i].count > requestArray[j].count\\n    })\\n    \\n    sort.Ints(nums)\\n    n := len(nums)-1\\n    output := make([]int, len(nums))\\n    for i := 0; i < len(requestArray); i++ {\\n        idx := requestArray[i].idx\\n        output[idx] = nums[n]\\n        n--\\n    }\\n    \\n    count := 0\\n        \\n    for i := 0; i < len(requestArray); i++ {\\n        if requestArray[i].count > 0 {\\n            idx := requestArray[i].idx\\n            count += (requestArray[i].count * output[idx])\\n            count = count % 1000000007\\n        }\\n    }\\n    \\n    return count \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1081528,
                "title": "c-very-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        const int n = nums.size();\\n        vector<int> weights(n, 0);\\n        \\n        for (const auto & request : requests) {\\n            ++weights[request[0]];\\n            if (request[1] < n - 1) {\\n                --weights[request[1] + 1];\\n            }\\n        }\\n        for (int i = 1; i < n; ++i) {\\n            weights[i] += weights[i - 1];\\n        }\\n        \\n        sort(begin(weights), end(weights));\\n        sort(begin(nums), end(nums));\\n        \\n        int res = 0;\\n        const int mod = 1e9 + 7;\\n        for (int i = 0; i < n; ++i) {\\n            long long sum = (weights[i] * (long long)nums[i]) % mod;\\n            res = (res + sum) % mod;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        const int n = nums.size();\\n        vector<int> weights(n, 0);\\n        \\n        for (const auto & request : requests) {\\n            ++weights[request[0]];\\n            if (request[1] < n - 1) {\\n                --weights[request[1] + 1];\\n            }\\n        }\\n        for (int i = 1; i < n; ++i) {\\n            weights[i] += weights[i - 1];\\n        }\\n        \\n        sort(begin(weights), end(weights));\\n        sort(begin(nums), end(nums));\\n        \\n        int res = 0;\\n        const int mod = 1e9 + 7;\\n        for (int i = 0; i < n; ++i) {\\n            long long sum = (weights[i] * (long long)nums[i]) % mod;\\n            res = (res + sum) % mod;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1078855,
                "title": "java-straight-forward",
                "content": "*  sort `nums`\\n*  group by used count\\n*  sort counts\\n*  make max product by taking greatest from both `nums` and sorted `counts`\\n```\\nclass Solution {\\n    static final int MOD=1000000007;\\n    public int maxSumRangeQuery(int[] nums, int[][] requests) {\\n        Arrays.sort(nums);\\n        // begin and end\\n        TreeMap<Integer,Integer> be=new TreeMap<>();\\n        for(var req:requests) {\\n            be.put(req[0],be.getOrDefault(req[0],0)+1);\\n            be.put(req[1]+1,be.getOrDefault(req[1]+1,0)-1);\\n        }\\n        // group by count of used, sort by DESC order\\n        TreeMap<Integer,Integer> cnts=new TreeMap<>(Collections.reverseOrder());\\n        int cnt=0,b=0;\\n        for(var entry:be.entrySet()) {\\n            // end\\n            var e=entry.getKey();\\n            // changes\\n            var c=entry.getValue();\\n            if(c!=0) {\\n                // from [b,e), number been used cnt times\\n                var len=e-b;\\n                cnts.put(cnt,cnts.getOrDefault(cnt,0)+len);\\n                // update begin and cnt\\n                b=e;\\n                cnt+=c;\\n            }\\n        }\\n        \\n        int idx=nums.length-1,sum=0;\\n        for(var entry:cnts.entrySet()) {\\n            var len=entry.getValue();\\n            var tmp=0l;\\n            // pick max number\\n            for(int i=0;i<len;i++) {\\n                tmp+=nums[idx--];\\n            }\\n            tmp*=entry.getKey();\\n            tmp%=MOD;\\n            sum+=(int)tmp;\\n            sum%=MOD;\\n        }\\n        return sum;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    static final int MOD=1000000007;\\n    public int maxSumRangeQuery(int[] nums, int[][] requests) {\\n        Arrays.sort(nums);\\n        // begin and end\\n        TreeMap<Integer,Integer> be=new TreeMap<>();\\n        for(var req:requests) {\\n            be.put(req[0],be.getOrDefault(req[0],0)+1);\\n            be.put(req[1]+1,be.getOrDefault(req[1]+1,0)-1);\\n        }\\n        // group by count of used, sort by DESC order\\n        TreeMap<Integer,Integer> cnts=new TreeMap<>(Collections.reverseOrder());\\n        int cnt=0,b=0;\\n        for(var entry:be.entrySet()) {\\n            // end\\n            var e=entry.getKey();\\n            // changes\\n            var c=entry.getValue();\\n            if(c!=0) {\\n                // from [b,e), number been used cnt times\\n                var len=e-b;\\n                cnts.put(cnt,cnts.getOrDefault(cnt,0)+len);\\n                // update begin and cnt\\n                b=e;\\n                cnt+=c;\\n            }\\n        }\\n        \\n        int idx=nums.length-1,sum=0;\\n        for(var entry:cnts.entrySet()) {\\n            var len=entry.getValue();\\n            var tmp=0l;\\n            // pick max number\\n            for(int i=0;i<len;i++) {\\n                tmp+=nums[idx--];\\n            }\\n            tmp*=entry.getKey();\\n            tmp%=MOD;\\n            sum+=(int)tmp;\\n            sum%=MOD;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1035883,
                "title": "java-line-sweep-prefix-sum",
                "content": "```\\npublic int maxSumRangeQuery(int[] nums, int[][] requests) {\\n        if(nums == null || nums.length == 0) return 0;\\n        int mod = 1_000_000_007;\\n        int[] prefixArr = new int[nums.length];\\n        for (int[] request : requests){\\n            int i = request[0];\\n            int j = request[1];\\n            prefixArr[i] += 1;\\n            if(j+1 < nums.length)\\n                prefixArr[j+1] += -1;\\n        }\\n        List<Integer> list = new ArrayList<>();\\n        list.add(prefixArr[0]);\\n        for (int i = 1; i < prefixArr.length; ++i){\\n            prefixArr[i] = prefixArr[i-1] + prefixArr[i];\\n            list.add(prefixArr[i]);\\n        }\\n\\n        list = list.stream().filter(i -> i != 0).collect(Collectors.toList());\\n        Collections.sort(list, Comparator.reverseOrder());\\n        long sum = 0;\\n        Arrays.sort(nums); int ind = nums.length-1;\\n        for (int i = 0; i < list.size(); i++){\\n            int product = (list.get(i) * nums[ind--]);\\n            product = product % mod;\\n            sum += product;\\n            sum = sum % mod;\\n        }\\n        return (int)sum;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maxSumRangeQuery(int[] nums, int[][] requests) {\\n        if(nums == null || nums.length == 0) return 0;\\n        int mod = 1_000_000_007;\\n        int[] prefixArr = new int[nums.length];\\n        for (int[] request : requests){\\n            int i = request[0];\\n            int j = request[1];\\n            prefixArr[i] += 1;\\n            if(j+1 < nums.length)\\n                prefixArr[j+1] += -1;\\n        }\\n        List<Integer> list = new ArrayList<>();\\n        list.add(prefixArr[0]);\\n        for (int i = 1; i < prefixArr.length; ++i){\\n            prefixArr[i] = prefixArr[i-1] + prefixArr[i];\\n            list.add(prefixArr[i]);\\n        }\\n\\n        list = list.stream().filter(i -> i != 0).collect(Collectors.toList());\\n        Collections.sort(list, Comparator.reverseOrder());\\n        long sum = 0;\\n        Arrays.sort(nums); int ind = nums.length-1;\\n        for (int i = 0; i < list.size(); i++){\\n            int product = (list.get(i) * nums[ind--]);\\n            product = product % mod;\\n            sum += product;\\n            sum = sum % mod;\\n        }\\n        return (int)sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1021891,
                "title": "java-o-n-k-space-and-time",
                "content": "``` O(n + k) ``` algorithm, where `n` is nums.length and `k` is requests.length.\\n\\nThe idea is that we sort all  requests and then perform a line sweep through the request line of size `n`. At each point of the line we keep track of the number of requests which are being served at that point and write them in an array `mult`. This count is the number of requests which were previously opened and not yet closed. Finally we sort both `nums` and `mult` and the answer is the dot product of the two vectors. \\n\\nAnalysis: sorting can be implemented in `O(n)` or `O(k)` with radix sort. The line sweep algorithm to determine `mult` takes `O(n + k)`as each point in the line and request endpoint is processed once. The dot product is a linear operator as well.    \\n\\n```\\nclass Solution {\\n    public int maxSumRangeQuery(int[] nums, int[][] requests) {\\n        int[] begins = new int[requests.length];\\n        int[] ends = new int[requests.length];\\n        for (int i = 0; i < requests.length; ++i) {\\n            begins[i] = requests[i][0];\\n            ends[i] = requests[i][1] + 1; // exclusive\\n        }\\n        radixsort(begins, begins.length);\\n        radixsort(ends, ends.length);\\n        radixsort(nums, nums.length);\\n        int[] mult = new int[nums.length];\\n        for (int i = 0, b = 0, e = 0, curr = 0; i < nums.length; ++i) {\\n            while (b < begins.length && begins[b] == i) {\\n                ++curr;\\n                ++b;\\n            }\\n            while (e < ends.length && ends[e] == i) {\\n                --curr;\\n                ++e;\\n            }\\n            mult[i] = curr;\\n        }\\n        radixsort(mult, mult.length);\\n        long ans = 0;\\n        for (int i = mult.length - 1; i >= 0; --i) {\\n            ans += (long) mult[i] * nums[i];\\n        }\\n        return (int) (ans % 1_000_000_007);\\n    }\\n    \\n    /* Geekforgeek radixsort */\\n    \\n    // A utility function to get maximum value in arr[] \\n    static int getMax(int arr[], int n) \\n    { \\n        int mx = arr[0]; \\n        for (int i = 1; i < n; i++) \\n            if (arr[i] > mx) \\n                mx = arr[i]; \\n        return mx; \\n    } \\n  \\n    // A function to do counting sort of arr[] according to \\n    // the digit represented by exp. \\n    static void countSort(int arr[], int n, int exp) \\n    { \\n        int output[] = new int[n]; // output array \\n        int i; \\n        int count[] = new int[10]; \\n        Arrays.fill(count, 0); \\n  \\n        // Store count of occurrences in count[] \\n        for (i = 0; i < n; i++) \\n            count[(arr[i] / exp) % 10]++; \\n  \\n        // Change count[i] so that count[i] now contains \\n        // actual position of this digit in output[] \\n        for (i = 1; i < 10; i++) \\n            count[i] += count[i - 1]; \\n  \\n        // Build the output array \\n        for (i = n - 1; i >= 0; i--) { \\n            output[count[(arr[i] / exp) % 10] - 1] = arr[i]; \\n            count[(arr[i] / exp) % 10]--; \\n        } \\n  \\n        // Copy the output array to arr[], so that arr[] now \\n        // contains sorted numbers according to curent digit \\n        for (i = 0; i < n; i++) \\n            arr[i] = output[i]; \\n    } \\n  \\n    // The main function to that sorts arr[] of size n using \\n    // Radix Sort \\n    static void radixsort(int arr[], int n) \\n    { \\n        // Find the maximum number to know number of digits \\n        int m = getMax(arr, n); \\n  \\n        // Do counting sort for every digit. Note that \\n        // instead of passing digit number, exp is passed. \\n        // exp is 10^i where i is current digit number \\n        for (int exp = 1; m / exp > 0; exp *= 10) \\n            countSort(arr, n, exp); \\n    } \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` O(n + k) ```\n```\\nclass Solution {\\n    public int maxSumRangeQuery(int[] nums, int[][] requests) {\\n        int[] begins = new int[requests.length];\\n        int[] ends = new int[requests.length];\\n        for (int i = 0; i < requests.length; ++i) {\\n            begins[i] = requests[i][0];\\n            ends[i] = requests[i][1] + 1; // exclusive\\n        }\\n        radixsort(begins, begins.length);\\n        radixsort(ends, ends.length);\\n        radixsort(nums, nums.length);\\n        int[] mult = new int[nums.length];\\n        for (int i = 0, b = 0, e = 0, curr = 0; i < nums.length; ++i) {\\n            while (b < begins.length && begins[b] == i) {\\n                ++curr;\\n                ++b;\\n            }\\n            while (e < ends.length && ends[e] == i) {\\n                --curr;\\n                ++e;\\n            }\\n            mult[i] = curr;\\n        }\\n        radixsort(mult, mult.length);\\n        long ans = 0;\\n        for (int i = mult.length - 1; i >= 0; --i) {\\n            ans += (long) mult[i] * nums[i];\\n        }\\n        return (int) (ans % 1_000_000_007);\\n    }\\n    \\n    /* Geekforgeek radixsort */\\n    \\n    // A utility function to get maximum value in arr[] \\n    static int getMax(int arr[], int n) \\n    { \\n        int mx = arr[0]; \\n        for (int i = 1; i < n; i++) \\n            if (arr[i] > mx) \\n                mx = arr[i]; \\n        return mx; \\n    } \\n  \\n    // A function to do counting sort of arr[] according to \\n    // the digit represented by exp. \\n    static void countSort(int arr[], int n, int exp) \\n    { \\n        int output[] = new int[n]; // output array \\n        int i; \\n        int count[] = new int[10]; \\n        Arrays.fill(count, 0); \\n  \\n        // Store count of occurrences in count[] \\n        for (i = 0; i < n; i++) \\n            count[(arr[i] / exp) % 10]++; \\n  \\n        // Change count[i] so that count[i] now contains \\n        // actual position of this digit in output[] \\n        for (i = 1; i < 10; i++) \\n            count[i] += count[i - 1]; \\n  \\n        // Build the output array \\n        for (i = n - 1; i >= 0; i--) { \\n            output[count[(arr[i] / exp) % 10] - 1] = arr[i]; \\n            count[(arr[i] / exp) % 10]--; \\n        } \\n  \\n        // Copy the output array to arr[], so that arr[] now \\n        // contains sorted numbers according to curent digit \\n        for (i = 0; i < n; i++) \\n            arr[i] = output[i]; \\n    } \\n  \\n    // The main function to that sorts arr[] of size n using \\n    // Radix Sort \\n    static void radixsort(int arr[], int n) \\n    { \\n        // Find the maximum number to know number of digits \\n        int m = getMax(arr, n); \\n  \\n        // Do counting sort for every digit. Note that \\n        // instead of passing digit number, exp is passed. \\n        // exp is 10^i where i is current digit number \\n        for (int exp = 1; m / exp > 0; exp *= 10) \\n            countSort(arr, n, exp); \\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1015924,
                "title": "simple-solution-using-prefix-sum-c",
                "content": "Time Complexity : O(NlogN)\\n\\n\\'\\'\\'\\n#define mod 1000000007\\n\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) \\n    {\\n        int n1=nums.size(),n2=requests.size(),i;\\n        long long a[100001]={0};\\n        \\n        for(i=0;i<n1;i++)\\n            a[i]=0;\\n        for(;i<100001;i++)\\n            a[i]=1000000;\\n        \\n        //Prefix Sum\\n        for(i=0;i<n2;i++)\\n        {\\n            a[requests[i][0]]++;\\n            a[requests[i][1]+1]--;\\n        }\\n        \\n        for(i=1;i<n1;i++)\\n            a[i]+=a[i-1];\\n\\t\\t\\t\\n        //Sorting And Multiplying\\n        sort(a,a+n1+1);\\n        sort(nums.begin(),nums.end());\\n        long long ans=0;\\n        \\n        for(i=n1-1;i>=0;i--)\\n            ans = ( ans + ((a[i]*nums[i])%mod) )%mod;\\n\\n        return ans%mod;\\n    }\\n};\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) \\n    {\\n        int n1=nums.size(),n2=requests.size(),i;\\n        long long a[100001]={0}",
                "codeTag": "Java"
            },
            {
                "id": 994932,
                "title": "c-short-solution",
                "content": "Run-time is `O(NlogN+M)`, where `N` is size of `nums` and `M` size of `requests`. Space is `O(N)`.\\n\\n```\\n#define MOD 1000000007\\n\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        int size{(int)nums.size()};\\n        std::vector<int> acc(size+1, 0);\\n        for(const auto &r: requests) ++acc[r[0]], --acc[r[1]+1];\\n        for(int i{1}; i < size; ++i) acc[i] += acc[i-1];\\n        std::sort(acc.begin(), --acc.end());\\n        std::sort(nums.begin(), nums.end());\\n        int64_t sum{0};\\n        for(int i{0}; i < size; ++i) sum = (sum + ((int64_t)nums[i]*acc[i])%MOD)%MOD;\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define MOD 1000000007\\n\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        int size{(int)nums.size()};\\n        std::vector<int> acc(size+1, 0);\\n        for(const auto &r: requests) ++acc[r[0]], --acc[r[1]+1];\\n        for(int i{1}; i < size; ++i) acc[i] += acc[i-1];\\n        std::sort(acc.begin(), --acc.end());\\n        std::sort(nums.begin(), nums.end());\\n        int64_t sum{0};\\n        for(int i{0}; i < size; ++i) sum = (sum + ((int64_t)nums[i]*acc[i])%MOD)%MOD;\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 993404,
                "title": "c-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) \\n    {\\n       int n=nums.size();\\n       vector<long long> temp(n+1),cumm(n);\\n        for(auto &x : requests){\\n            temp[x[0]] += 1;\\n            temp[x[1]+1] -= 1;\\n        }\\n        for(int i=0;i<n;i++)\\n            cumm[i] = i==0 ? temp[i] : cumm[i-1] + temp[i];\\n       vector<pair<long long,long long>>v;\\n       vector<long long>per(nums.size(),0);\\n       for(int i=0;i<cumm.size();i++)\\n          v.push_back({cumm[i],i});\\n       sort(v.begin(),v.end());\\n       sort(nums.begin(),nums.end());\\n       long long last=nums.size()-1;\\n       for(int i=v.size()-1;i>=0;i--)\\n       {\\n           per[v[i].second]=nums[last];\\n           last--;\\n       }\\n        const int mod = (int)1e9 + 7;\\n        long long sum=0;\\n       for(int i=0;i<cumm.size();i++)\\n       {\\n           long long z=((cumm[i]%mod)*(per[i]%mod))%mod;\\n           sum=(sum%mod+z%mod)%mod;\\n       }\\n       return sum%mod;\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) \\n    {\\n       int n=nums.size();\\n       vector<long long> temp(n+1),cumm(n);\\n        for(auto &x : requests){\\n            temp[x[0]] += 1;\\n            temp[x[1]+1] -= 1;\\n        }\\n        for(int i=0;i<n;i++)\\n            cumm[i] = i==0 ? temp[i] : cumm[i-1] + temp[i];\\n       vector<pair<long long,long long>>v;\\n       vector<long long>per(nums.size(),0);\\n       for(int i=0;i<cumm.size();i++)\\n          v.push_back({cumm[i],i});\\n       sort(v.begin(),v.end());\\n       sort(nums.begin(),nums.end());\\n       long long last=nums.size()-1;\\n       for(int i=v.size()-1;i>=0;i--)\\n       {\\n           per[v[i].second]=nums[last];\\n           last--;\\n       }\\n        const int mod = (int)1e9 + 7;\\n        long long sum=0;\\n       for(int i=0;i<cumm.size();i++)\\n       {\\n           long long z=((cumm[i]%mod)*(per[i]%mod))%mod;\\n           sum=(sum%mod+z%mod)%mod;\\n       }\\n       return sum%mod;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 981417,
                "title": "naive-frequency-count-causes-tle",
                "content": "For people who do not fully understand the solution behind the post: [Sweep Line solution by lee215](https://leetcode.com/problems/maximum-sum-obtained-of-any-permutation/discuss/854206/JavaC%2B%2BPython-Sweep-Line,) here is an explanation:\\n\\nWhat we do:\\nFirst we count the number of occurences of every element from `start[i]` to `end[i]` for every list in `requests`. For example given the input `nums = [1,2,3,4,5]`, we make a frequency list `freq = [0, 0, 0, 0, 0]`. We then use the first list in the `requests` list, which is `(1,3)`, and we increase the indices from `1` to `3` in the `freq` list, which will become `freq = [0, 1, 1, 1, 0]`.\\nUse the next list in the `requests` list, which is `[0, 1]`, we get `[1, 2, 1, 1, 0]`. We then sort this `freq` list in reverse order, and also sort the `nums` in reverse order, we have `sorted_freq = [2, 1, 1, 1, 0]` and `sorted_nums = [5, 4, 3, 2 ,1]`. We loop through `i`: `sum += sorted_freq[i] * sorted_nums[i]`, and we get our answer.\\n\\nHowever, we have one drawback that will cause TLE: it is inefficient to loop through every element in every list and increase its count in `freq`. Assume that `nums` has size `n` and `freq` has `k` elements, its complexity is `O(n*k)`.\\n\\nSo we need top find a better solution, which is Lee\\'s answer, and the explanation behind it is in: [here](https://leetcode.com/problems/maximum-sum-obtained-of-any-permutation/discuss/854206/JavaC++Python-Sweep-Line/702473).",
                "solutionTags": [],
                "code": "For people who do not fully understand the solution behind the post: [Sweep Line solution by lee215](https://leetcode.com/problems/maximum-sum-obtained-of-any-permutation/discuss/854206/JavaC%2B%2BPython-Sweep-Line,) here is an explanation:\\n\\nWhat we do:\\nFirst we count the number of occurences of every element from `start[i]` to `end[i]` for every list in `requests`. For example given the input `nums = [1,2,3,4,5]`, we make a frequency list `freq = [0, 0, 0, 0, 0]`. We then use the first list in the `requests` list, which is `(1,3)`, and we increase the indices from `1` to `3` in the `freq` list, which will become `freq = [0, 1, 1, 1, 0]`.\\nUse the next list in the `requests` list, which is `[0, 1]`, we get `[1, 2, 1, 1, 0]`. We then sort this `freq` list in reverse order, and also sort the `nums` in reverse order, we have `sorted_freq = [2, 1, 1, 1, 0]` and `sorted_nums = [5, 4, 3, 2 ,1]`. We loop through `i`: `sum += sorted_freq[i] * sorted_nums[i]`, and we get our answer.\\n\\nHowever, we have one drawback that will cause TLE: it is inefficient to loop through every element in every list and increase its count in `freq`. Assume that `nums` has size `n` and `freq` has `k` elements, its complexity is `O(n*k)`.\\n\\nSo we need top find a better solution, which is Lee\\'s answer, and the explanation behind it is in: [here](https://leetcode.com/problems/maximum-sum-obtained-of-any-permutation/discuss/854206/JavaC++Python-Sweep-Line/702473).",
                "codeTag": "Unknown"
            },
            {
                "id": 977689,
                "title": "javascript-beats-10-runtime",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number[][]} requests\\n * @return {number}\\n */\\nvar maxSumRangeQuery = function(nums, requests) {\\n    let frequency = new Array(nums.length).fill(0)\\n    for(let req of requests){\\n        for(let i=req[0];i<=req[1];i++){\\n            frequency[i]++\\n        }\\n    }\\n    nums = nums.sort((a,b)=>a-b)\\n    let freqArr = frequency.sort((a,b)=>b-a)\\n    let sum =0\\n    for(let freq of freqArr){\\n        sum += (freq * nums.pop())\\n    }\\n    const mod = (10 ** 9) + 7;\\n    return sum%mod\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number[][]} requests\\n * @return {number}\\n */\\nvar maxSumRangeQuery = function(nums, requests) {\\n    let frequency = new Array(nums.length).fill(0)\\n    for(let req of requests){\\n        for(let i=req[0];i<=req[1];i++){\\n            frequency[i]++\\n        }\\n    }\\n    nums = nums.sort((a,b)=>a-b)\\n    let freqArr = frequency.sort((a,b)=>b-a)\\n    let sum =0\\n    for(let freq of freqArr){\\n        sum += (freq * nums.pop())\\n    }\\n    const mod = (10 ** 9) + 7;\\n    return sum%mod\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 969035,
                "title": "share-my-java-solution",
                "content": "```\\nclass Solution {\\n    public int maxSumRangeQuery(int[] nums, int[][] requests) {\\n         int[] count = new int[nums.length];\\n         for(int[] ele: requests){\\n             count[ele[0]]++;\\n             if(ele[1]!=nums.length-1){\\n                 count[ele[1]+1]--;\\n             }\\n         }\\n        \\n         int cur = 0;\\n         for(int i=0;i<count.length;i++){\\n             cur += count[i];\\n             count[i] = cur;\\n         }\\n        \\n        List<Integer> list = new ArrayList<>();\\n        for(int i=0;i<count.length;i++){\\n            if(count[i]!=0){\\n                list.add(count[i]);\\n            }\\n        }\\n        \\n        int index = nums.length-1;\\n        Arrays.sort(nums);\\n        Collections.sort(list, (a, b)->(b-a));\\n        long res = 0;\\n        int mod = (int)(1e9+7);\\n        for(Integer ele: list){\\n            res += ele*(long)nums[index];\\n            res %= mod;\\n            index--;\\n        }\\n        \\n        return (int)res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumRangeQuery(int[] nums, int[][] requests) {\\n         int[] count = new int[nums.length];\\n         for(int[] ele: requests){\\n             count[ele[0]]++;\\n             if(ele[1]!=nums.length-1){\\n                 count[ele[1]+1]--;\\n             }\\n         }\\n        \\n         int cur = 0;\\n         for(int i=0;i<count.length;i++){\\n             cur += count[i];\\n             count[i] = cur;\\n         }\\n        \\n        List<Integer> list = new ArrayList<>();\\n        for(int i=0;i<count.length;i++){\\n            if(count[i]!=0){\\n                list.add(count[i]);\\n            }\\n        }\\n        \\n        int index = nums.length-1;\\n        Arrays.sort(nums);\\n        Collections.sort(list, (a, b)->(b-a));\\n        long res = 0;\\n        int mod = (int)(1e9+7);\\n        for(Integer ele: list){\\n            res += ele*(long)nums[index];\\n            res %= mod;\\n            index--;\\n        }\\n        \\n        return (int)res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 931197,
                "title": "c-sweep-line",
                "content": "```\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        const int n = nums.size();\\n        vector<int> cnt(n+1,0), accuCnt;\\n        for(auto& v:requests){\\n            cnt[v[0]]++;\\n            cnt[v[1]+1]--;\\n        }\\n        int acc = 0;\\n        for(int i=0;i<n;i++){\\n            acc += cnt[i];\\n            accuCnt.push_back(acc);\\n        }\\n        sort(accuCnt.begin(), accuCnt.end());\\n        sort(nums.begin(), nums.end());\\n        long long res = 0;\\n        for(int i=0;i<n;i++) res += long(accuCnt[i]) * nums[i];\\n        return res % long(1e9+7);\\n    }",
                "solutionTags": [],
                "code": "```\\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests) {\\n        const int n = nums.size();\\n        vector<int> cnt(n+1,0), accuCnt;\\n        for(auto& v:requests){\\n            cnt[v[0]]++;\\n            cnt[v[1]+1]--;\\n        }\\n        int acc = 0;\\n        for(int i=0;i<n;i++){\\n            acc += cnt[i];\\n            accuCnt.push_back(acc);\\n        }\\n        sort(accuCnt.begin(), accuCnt.end());\\n        sort(nums.begin(), nums.end());\\n        long long res = 0;\\n        for(int i=0;i<n;i++) res += long(accuCnt[i]) * nums[i];\\n        return res % long(1e9+7);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 917655,
                "title": "prefix-sum-approach-c",
                "content": "class Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& a, vector<vector<int>>& requests) {\\n        \\n        int answer =0;\\n        int n = a.size();\\n        vector<int> count(n);\\n        \\n        for( vector<int> req : requests){\\n            int l = req[0], r = req[1];\\n            count[l]++;\\n            if( r != n-1)\\n                count[r+1]--;\\n            // for(int i =l; i <=r; i++){\\n            //     count[i]++;\\n            // }\\n        }\\n        for( int i =1;i <n; i++){\\n            count[i] = count[i-1] + count[i];\\n        }\\n        const int mod = 1e9 +7;\\n        sort( count.begin(), count.end());\\n        sort(a.begin(), a.end());\\n        for( int i=0; i<n ; i++){\\n            // cout << count[i];\\n            answer = (answer + count[i]*1ll*a[i])%mod;\\n        }\\n        return answer;    \\n    }\\n    \\n    \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxSumRangeQuery(vector<int>& a, vector<vector<int>>& requests) {\\n        \\n        int answer =0;\\n        int n = a.size();\\n        vector<int> count(n);\\n        \\n        for( vector<int> req : requests){\\n            int l = req[0], r = req[1];\\n            count[l]++;\\n            if( r != n-1)\\n                count[r+1]--;\\n            // for(int i =l; i <=r; i++){\\n            //     count[i]++;\\n            // }",
                "codeTag": "Java"
            },
            {
                "id": 917059,
                "title": "python-sweep-line-o-n-log-n",
                "content": "Sweep line + hashmap list\\n\\nfreq_range[freq] = range list\\n\\n```\\nclass Solution:\\n    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\\n        A = []\\n        for s, e in requests:\\n            A.append((s, 0))\\n            A.append((e, 1))\\n        A.sort()\\n        fr = defaultdict(list) # freq range,\\n        cnt = 0\\n        # print(A)\\n        \\n        n = len(A)\\n        i = 0\\n        while i < n:\\n            r = 1\\n            while i < n - 1 and A[i+1] == A[i]:\\n                r += 1\\n                i += 1\\n            p, flag = A[i]\\n            if flag == 0:\\n                cnt += r\\n                if cnt - r > 0:\\n                    fr[cnt-r].append((pre, p-1))\\n                pre = p\\n            elif flag == 1:\\n                cnt -= r\\n                fr[cnt+r].append((pre, p))\\n                # print(\"-1, pre, p:\", pre, p)\\n                pre = p+1\\n            i += 1\\n        \\n        nums.sort(reverse=True)\\n        ks = list(fr.keys())\\n        ks.sort(reverse=True)\\n        ans = 0\\n        MOD = 10**9 + 7\\n        i = 0\\n        # print(fr)\\n        for k in ks:\\n            for s, e in fr[k]:\\n                d = e - s + 1\\n                ans += sum(nums[i:i+d]) * k\\n                ans %= MOD\\n                i += d\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\\n        A = []\\n        for s, e in requests:\\n            A.append((s, 0))\\n            A.append((e, 1))\\n        A.sort()\\n        fr = defaultdict(list) # freq range,\\n        cnt = 0\\n        # print(A)\\n        \\n        n = len(A)\\n        i = 0\\n        while i < n:\\n            r = 1\\n            while i < n - 1 and A[i+1] == A[i]:\\n                r += 1\\n                i += 1\\n            p, flag = A[i]\\n            if flag == 0:\\n                cnt += r\\n                if cnt - r > 0:\\n                    fr[cnt-r].append((pre, p-1))\\n                pre = p\\n            elif flag == 1:\\n                cnt -= r\\n                fr[cnt+r].append((pre, p))\\n                # print(\"-1, pre, p:\", pre, p)\\n                pre = p+1\\n            i += 1\\n        \\n        nums.sort(reverse=True)\\n        ks = list(fr.keys())\\n        ks.sort(reverse=True)\\n        ans = 0\\n        MOD = 10**9 + 7\\n        i = 0\\n        # print(fr)\\n        for k in ks:\\n            for s, e in fr[k]:\\n                d = e - s + 1\\n                ans += sum(nums[i:i+d]) * k\\n                ans %= MOD\\n                i += d\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 910705,
                "title": "java-17ms-o-nlogn-after-some-test-cases-added",
                "content": "So many wrong solutions ignoring integer value limit,\\neven when I copied the source with 15m, it couldn\\'t pass the problem.\\n\\nBelow is my source which can pass with 17ms\\n\\n```\\nclass Solution {\\n    public int maxSumRangeQuery(int[] nums, int[][] requests) {\\n        int len = nums.length;\\n        int cnt[] = new int[len];\\n        for(int[] r:requests){\\n            cnt[r[0]]++; \\n            if(r[1]+1<len)cnt[r[1]+1]--;\\n        }\\n        for(int i=1; i<len; i++)cnt[i]+=cnt[i-1];\\n        Arrays.sort(cnt);\\n        Arrays.sort(nums);\\n        long ans = 0;\\n        for(int i=len-1; i>=0 && cnt[i]>0; i--){\\n            ans += (long)cnt[i]*nums[i];\\n        }\\n        return (int)(ans%1000000007);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumRangeQuery(int[] nums, int[][] requests) {\\n        int len = nums.length;\\n        int cnt[] = new int[len];\\n        for(int[] r:requests){\\n            cnt[r[0]]++; \\n            if(r[1]+1<len)cnt[r[1]+1]--;\\n        }\\n        for(int i=1; i<len; i++)cnt[i]+=cnt[i-1];\\n        Arrays.sort(cnt);\\n        Arrays.sort(nums);\\n        long ans = 0;\\n        for(int i=len-1; i>=0 && cnt[i]>0; i--){\\n            ans += (long)cnt[i]*nums[i];\\n        }\\n        return (int)(ans%1000000007);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 885834,
                "title": "golang-sort-solution",
                "content": "```go\\nfunc maxSumRangeQuery(nums []int, requests [][]int) int {\\n\\tsort.Slice(requests, func(i, j int) bool {\\n\\t\\tif requests[i][0] == requests[j][0] {\\n\\t\\t\\treturn requests[i][1] < requests[j][1]\\n\\t\\t}\\n\\t\\treturn requests[i][0] < requests[j][0]\\n\\t})\\n\\trequests2 := make([][]int, len(requests))\\n\\tfor i := range requests {\\n\\t\\trequests2[i] = make([]int, 2)\\n\\t\\tcopy(requests2[i], requests[i])\\n\\t}\\n\\tsort.Slice(requests2, func(i, j int) bool {\\n\\t\\tif requests2[i][1] == requests2[j][1] {\\n\\t\\t\\treturn requests2[i][0] < requests2[j][0]\\n\\t\\t}\\n\\t\\treturn requests2[i][1] < requests2[j][1]\\n\\t})\\n\\tminValue, maxValue := requests[0][0], requests2[len(requests2)-1][1]\\n\\trequests = append(requests, []int{maxValue+1, maxValue+1})\\n\\trequests2 = append(requests2, []int{maxValue+1, maxValue+1})\\n\\tindex1, index2 := 0, 0\\n\\tcounter := []int{}\\n\\tfor i := minValue; i <= maxValue; i++ {\\n\\t\\t// index1, head > 1\\n\\t\\tfor requests[index1][0] <= i {\\n\\t\\t\\tindex1++\\n\\t\\t}\\n\\t\\t// index2, tail >= i\\n\\t\\tfor requests2[index2][1] < i {\\n\\t\\t\\tindex2++\\n\\t\\t}\\n\\t\\tcounter = append(counter, index1 - index2)\\n\\t}\\n\\tsort.Ints(counter)\\n\\tsort.Ints(nums)\\n\\treverse(counter)\\n\\treverse(nums)\\n\\tmaxSummaryMod := 0\\n\\tfor i := 0; i < len(counter) && i < len(nums); i++ {\\n\\t\\tmaxSummaryMod += counter[i] * nums[i]\\n\\t\\tmaxSummaryMod %= 1000000007\\n\\t}\\n\\treturn maxSummaryMod\\n}\\n\\nfunc reverse(A []int) {\\n\\tfor i := 0; i < len(A)/2; i++ {\\n\\t\\tA[i], A[len(A)-1-i] = A[len(A)-1-i], A[i]\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc maxSumRangeQuery(nums []int, requests [][]int) int {\\n\\tsort.Slice(requests, func(i, j int) bool {\\n\\t\\tif requests[i][0] == requests[j][0] {\\n\\t\\t\\treturn requests[i][1] < requests[j][1]\\n\\t\\t}\\n\\t\\treturn requests[i][0] < requests[j][0]\\n\\t})\\n\\trequests2 := make([][]int, len(requests))\\n\\tfor i := range requests {\\n\\t\\trequests2[i] = make([]int, 2)\\n\\t\\tcopy(requests2[i], requests[i])\\n\\t}\\n\\tsort.Slice(requests2, func(i, j int) bool {\\n\\t\\tif requests2[i][1] == requests2[j][1] {\\n\\t\\t\\treturn requests2[i][0] < requests2[j][0]\\n\\t\\t}\\n\\t\\treturn requests2[i][1] < requests2[j][1]\\n\\t})\\n\\tminValue, maxValue := requests[0][0], requests2[len(requests2)-1][1]\\n\\trequests = append(requests, []int{maxValue+1, maxValue+1})\\n\\trequests2 = append(requests2, []int{maxValue+1, maxValue+1})\\n\\tindex1, index2 := 0, 0\\n\\tcounter := []int{}\\n\\tfor i := minValue; i <= maxValue; i++ {\\n\\t\\t// index1, head > 1\\n\\t\\tfor requests[index1][0] <= i {\\n\\t\\t\\tindex1++\\n\\t\\t}\\n\\t\\t// index2, tail >= i\\n\\t\\tfor requests2[index2][1] < i {\\n\\t\\t\\tindex2++\\n\\t\\t}\\n\\t\\tcounter = append(counter, index1 - index2)\\n\\t}\\n\\tsort.Ints(counter)\\n\\tsort.Ints(nums)\\n\\treverse(counter)\\n\\treverse(nums)\\n\\tmaxSummaryMod := 0\\n\\tfor i := 0; i < len(counter) && i < len(nums); i++ {\\n\\t\\tmaxSummaryMod += counter[i] * nums[i]\\n\\t\\tmaxSummaryMod %= 1000000007\\n\\t}\\n\\treturn maxSummaryMod\\n}\\n\\nfunc reverse(A []int) {\\n\\tfor i := 0; i < len(A)/2; i++ {\\n\\t\\tA[i], A[len(A)-1-i] = A[len(A)-1-i], A[i]\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 882765,
                "title": "this-is-a-really-good-leetcode-question-w-python-solution",
                "content": "I think this is my new favorite question on Leetcode \\uD83D\\uDD25 \\uD83D\\uDD25\\uD83D\\uDC4C \\n\\n\\n\\n```python\\nclass Solution(object):\\n    def maxSumRangeQuery(self, nums, requests):\\n        largestNums = sorted(nums)\\n        db = {}\\n        how_frequent = [0 for i in range(len(nums))]\\n        \\n        for startPoint, endPoint in requests:\\n            how_frequent[startPoint] += 1\\n            if endPoint + 1 < len(how_frequent):\\n                how_frequent[endPoint + 1] -= 1\\n                \\n        db[0] = how_frequent[0]\\n        for i in range(1, len(how_frequent)):\\n            how_frequent[i] += how_frequent[i-1]\\n            db[i] = how_frequent[i]\\n        \\n        sumVal = 0\\n        for val in sorted(db.iteritems(), key=lambda x: x[1], reverse=True):\\n            sumVal += largestNums.pop(-1) * val[1]\\n            \\n        return sumVal % ((10 ** 9) + 7)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def maxSumRangeQuery(self, nums, requests):\\n        largestNums = sorted(nums)\\n        db = {}\\n        how_frequent = [0 for i in range(len(nums))]\\n        \\n        for startPoint, endPoint in requests:\\n            how_frequent[startPoint] += 1\\n            if endPoint + 1 < len(how_frequent):\\n                how_frequent[endPoint + 1] -= 1\\n                \\n        db[0] = how_frequent[0]\\n        for i in range(1, len(how_frequent)):\\n            how_frequent[i] += how_frequent[i-1]\\n            db[i] = how_frequent[i]\\n        \\n        sumVal = 0\\n        for val in sorted(db.iteritems(), key=lambda x: x[1], reverse=True):\\n            sumVal += largestNums.pop(-1) * val[1]\\n            \\n        return sumVal % ((10 ** 9) + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 880571,
                "title": "java-nlog-n",
                "content": "```\\n    public int maxSumRangeQuery(int[] nums, int[][] requests) {\\n        int mod = (int) 1e9 + 7;\\n        int n = nums.length,res = 0, times[][] = new int[n][2],ind = 0;\\n        int[] nArr = new int[n],sum = new int[n + 1];\\n        for(int[] r : requests){\\n            times[r[0]][0]++;\\n            if(r[1] + 1 < n) times[r[1] + 1][0]--;\\n        }\\n        for(int i = 1;i < n;i++){\\n            times[i][0] += times[i - 1][0];\\n            times[i][1] = i;\\n        }\\n        Arrays.sort(nums);\\n        Arrays.sort(times,(a,b) -> a[0] - b[0]);\\n        for(int i = n - 1;i >= 0;i--){\\n            nArr[times[i][1]] = nums[i];\\n        }\\n        for(int i = 0;i < n;i++) sum[i + 1] = (sum[i] + nArr[i])%mod;\\n        for(int[] r : requests){\\n            res = (res + sum[r[1] + 1] - sum[r[0]])%mod;\\n        }\\n        return res;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    public int maxSumRangeQuery(int[] nums, int[][] requests) {\\n        int mod = (int) 1e9 + 7;\\n        int n = nums.length,res = 0, times[][] = new int[n][2],ind = 0;\\n        int[] nArr = new int[n],sum = new int[n + 1];\\n        for(int[] r : requests){\\n            times[r[0]][0]++;\\n            if(r[1] + 1 < n) times[r[1] + 1][0]--;\\n        }\\n        for(int i = 1;i < n;i++){\\n            times[i][0] += times[i - 1][0];\\n            times[i][1] = i;\\n        }\\n        Arrays.sort(nums);\\n        Arrays.sort(times,(a,b) -> a[0] - b[0]);\\n        for(int i = n - 1;i >= 0;i--){\\n            nArr[times[i][1]] = nums[i];\\n        }\\n        for(int i = 0;i < n;i++) sum[i + 1] = (sum[i] + nArr[i])%mod;\\n        for(int[] r : requests){\\n            res = (res + sum[r[1] + 1] - sum[r[0]])%mod;\\n        }\\n        return res;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 877518,
                "title": "two-python-solution-count-repeat-o-n-and-heap-o-nlog-n",
                "content": "Solution 1:\\n    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\\n        repeated = [0]*(len(nums)+1)\\n        for req in requests:\\n            repeated[req[0]] += 1\\n            repeated[req[1]+1] -= 1\\n        for i in range(1, len(nums)+1):\\n            repeated[i] += repeated[i-1]\\n        return sum([x*y for x,y in zip(sorted(nums), sorted(repeated[:len(nums)]))])%(10**9+7)\\n\\t\\nSolution 2:\\ndef maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\\n        requests = sorted(requests)\\n        repeated, dp, idx = [],[],0\\n        for i in range(len(nums)):\\n            while dp and dp[0] < i:\\n                heapq.heappop(dp)\\n            while idx < len(requests) and requests[idx][0] <= i:\\n                heapq.heappush(dp, requests[idx][1])\\n                idx += 1\\n            repeated.append(len(dp))\\n        return sum([x*y for x,y in zip(sorted(nums), sorted(repeated))])%(10**9 + 7)\\n",
                "solutionTags": [],
                "code": "Solution 1:\\n    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\\n        repeated = [0]*(len(nums)+1)\\n        for req in requests:\\n            repeated[req[0]] += 1\\n            repeated[req[1]+1] -= 1\\n        for i in range(1, len(nums)+1):\\n            repeated[i] += repeated[i-1]\\n        return sum([x*y for x,y in zip(sorted(nums), sorted(repeated[:len(nums)]))])%(10**9+7)\\n\\t\\nSolution 2:\\ndef maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:\\n        requests = sorted(requests)\\n        repeated, dp, idx = [],[],0\\n        for i in range(len(nums)):\\n            while dp and dp[0] < i:\\n                heapq.heappop(dp)\\n            while idx < len(requests) and requests[idx][0] <= i:\\n                heapq.heappush(dp, requests[idx][1])\\n                idx += 1\\n            repeated.append(len(dp))\\n        return sum([x*y for x,y in zip(sorted(nums), sorted(repeated))])%(10**9 + 7)\\n",
                "codeTag": "Python3"
            },
            {
                "id": 871503,
                "title": "different-approach-o-nlogn-mlogm",
                "content": "I couldn\\'t think of the sweep solution, wahoo!\\n\\nIntuition:\\n1. The number of times index i gets queried is the same as the number of overlapping intervals occurring at index i. We can count the number of overlapping intervals occuring at each index.\\n\\nIdea:\\n1. Sort all the interval start/end points in ascending order. In case of a tie, place the start points before the endpoints\\n3. When we see a start point, the number of overlapping intervals increases by 1\\n4. *After* we move past an end point, the number of overlapping intervals decreases by 1\\n\\nAnalysis:\\n* The inefficiency comes from the fact that we do more work than we have to. Sorting the interval points takes a lot of time and does not directly help us compute the answer.\\n\\nO(nlogn +mlogm) time, O(n+m) space\\n\\n```\\nclass Solution {\\npublic:\\n    struct endpoint {\\n        int val;\\n        bool is_start;\\n    };\\n    \\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests)\\n    {\\n        int n = nums.size();\\n        vector<endpoint> points;\\n\\n        for (auto& p : requests)\\n        {\\n            points.push_back({p.front(), true});\\n            points.push_back({p.back(), false});\\n        }\\n        \\n        std::sort(points.begin(), points.end(), [](const endpoint& p1, const endpoint& p2){\\n            return p1.val == p2.val ? (p1.is_start && !p2.is_start) : p1.val < p2.val;\\n        });\\n\\n        size_t j = 0;\\n        int active_intervals = 0;\\n        vector<long> counts;\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (; j < points.size() && points[j].val == i && points[j].is_start; j++)\\n                active_intervals++;\\n            \\n            counts.push_back(active_intervals);\\n            \\n            for (; j < points.size() && points[j].val == i && !points[j].is_start; j++)\\n                active_intervals--; \\n        }\\n        \\n        std::sort(counts.begin(), counts.end(), greater<long>());\\n        std::sort(nums.begin(), nums.end(), greater<int>());\\n        \\n        long res = 0;\\n        for (int i = 0; i < n && counts[i] > 0; i++)\\n        {\\n            res = (res + nums[i] * counts[i]) % 1000000007;\\n        }\\n        \\n        return (int) res;  \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    struct endpoint {\\n        int val;\\n        bool is_start;\\n    };\\n    \\n    int maxSumRangeQuery(vector<int>& nums, vector<vector<int>>& requests)\\n    {\\n        int n = nums.size();\\n        vector<endpoint> points;\\n\\n        for (auto& p : requests)\\n        {\\n            points.push_back({p.front(), true});\\n            points.push_back({p.back(), false});\\n        }\\n        \\n        std::sort(points.begin(), points.end(), [](const endpoint& p1, const endpoint& p2){\\n            return p1.val == p2.val ? (p1.is_start && !p2.is_start) : p1.val < p2.val;\\n        });\\n\\n        size_t j = 0;\\n        int active_intervals = 0;\\n        vector<long> counts;\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (; j < points.size() && points[j].val == i && points[j].is_start; j++)\\n                active_intervals++;\\n            \\n            counts.push_back(active_intervals);\\n            \\n            for (; j < points.size() && points[j].val == i && !points[j].is_start; j++)\\n                active_intervals--; \\n        }\\n        \\n        std::sort(counts.begin(), counts.end(), greater<long>());\\n        std::sort(nums.begin(), nums.end(), greater<int>());\\n        \\n        long res = 0;\\n        for (int i = 0; i < n && counts[i] > 0; i++)\\n        {\\n            res = (res + nums[i] * counts[i]) % 1000000007;\\n        }\\n        \\n        return (int) res;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1568450,
                "content": [
                    {
                        "username": "the_algorithmic_eye",
                        "content": "Some important points:\\n1. In order to maximise the sum, the index which occurs in more number of requests (max overlap) must be assigned a higher value. \\n2. We need to do constant time range updates per query to increase elements in range [l, r]. To do this, we simply do the following:\\n\\t* \\tIncrement arr[l] by 1\\n\\t* \\tDecrement a[r+1] by 1 (if it exists)\\n\\nI have explained these things in detail using visualizations: https://youtu.be/slTcWHIUfUE\\n# Code\\n![image](https://assets.leetcode.com/users/images/ea6a572c-7e51-4dd5-bff4-525552d5cb76_1600689351.3661175.png)\\n\\n"
                    },
                    {
                        "username": "p23_5",
                        "content": "Dif array\\nGreedy approach -> put the maximum element on the index most under incremnet requests"
                    },
                    {
                        "username": "helowl",
                        "content": "[@aditya_42](/aditya_42) use difference array concept \\nyou can refer this link https://codeforces.com/blog/entry/78762"
                    },
                    {
                        "username": "aditya_42",
                        "content": "it is not different, I also thought about the same thing first but it\\'s just a longer way of doing the same thing"
                    }
                ]
            },
            {
                "id": 1574651,
                "content": [
                    {
                        "username": "the_algorithmic_eye",
                        "content": "Some important points:\\n1. In order to maximise the sum, the index which occurs in more number of requests (max overlap) must be assigned a higher value. \\n2. We need to do constant time range updates per query to increase elements in range [l, r]. To do this, we simply do the following:\\n\\t* \\tIncrement arr[l] by 1\\n\\t* \\tDecrement a[r+1] by 1 (if it exists)\\n\\nI have explained these things in detail using visualizations: https://youtu.be/slTcWHIUfUE\\n# Code\\n![image](https://assets.leetcode.com/users/images/ea6a572c-7e51-4dd5-bff4-525552d5cb76_1600689351.3661175.png)\\n\\n"
                    },
                    {
                        "username": "p23_5",
                        "content": "Dif array\\nGreedy approach -> put the maximum element on the index most under incremnet requests"
                    },
                    {
                        "username": "helowl",
                        "content": "[@aditya_42](/aditya_42) use difference array concept \\nyou can refer this link https://codeforces.com/blog/entry/78762"
                    },
                    {
                        "username": "aditya_42",
                        "content": "it is not different, I also thought about the same thing first but it\\'s just a longer way of doing the same thing"
                    }
                ]
            }
        ]
    },
    {
        "title": "Number of Wonderful Substrings",
        "question_content": "<p>A <strong>wonderful</strong> string is a string where <strong>at most one</strong> letter appears an <strong>odd</strong> number of times.</p>\r\n\r\n<ul>\r\n\t<li>For example, <code>&quot;ccjjc&quot;</code> and <code>&quot;abab&quot;</code> are wonderful, but <code>&quot;ab&quot;</code> is not.</li>\r\n</ul>\r\n\r\n<p>Given a string <code>word</code> that consists of the first ten lowercase English letters (<code>&#39;a&#39;</code> through <code>&#39;j&#39;</code>), return <em>the <strong>number of wonderful non-empty substrings</strong> in </em><code>word</code><em>. If the same substring appears multiple times in </em><code>word</code><em>, then count <strong>each occurrence</strong> separately.</em></p>\r\n\r\n<p>A <strong>substring</strong> is a contiguous sequence of characters in a string.</p>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong class=\"example\">Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> word = &quot;aba&quot;\r\n<strong>Output:</strong> 4\r\n<strong>Explanation:</strong> The four wonderful substrings are underlined below:\r\n- &quot;<u><strong>a</strong></u>ba&quot; -&gt; &quot;a&quot;\r\n- &quot;a<u><strong>b</strong></u>a&quot; -&gt; &quot;b&quot;\r\n- &quot;ab<u><strong>a</strong></u>&quot; -&gt; &quot;a&quot;\r\n- &quot;<u><strong>aba</strong></u>&quot; -&gt; &quot;aba&quot;\r\n</pre>\r\n\r\n<p><strong class=\"example\">Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> word = &quot;aabb&quot;\r\n<strong>Output:</strong> 9\r\n<strong>Explanation:</strong> The nine wonderful substrings are underlined below:\r\n- &quot;<strong><u>a</u></strong>abb&quot; -&gt; &quot;a&quot;\r\n- &quot;<u><strong>aa</strong></u>bb&quot; -&gt; &quot;aa&quot;\r\n- &quot;<u><strong>aab</strong></u>b&quot; -&gt; &quot;aab&quot;\r\n- &quot;<u><strong>aabb</strong></u>&quot; -&gt; &quot;aabb&quot;\r\n- &quot;a<u><strong>a</strong></u>bb&quot; -&gt; &quot;a&quot;\r\n- &quot;a<u><strong>abb</strong></u>&quot; -&gt; &quot;abb&quot;\r\n- &quot;aa<u><strong>b</strong></u>b&quot; -&gt; &quot;b&quot;\r\n- &quot;aa<u><strong>bb</strong></u>&quot; -&gt; &quot;bb&quot;\r\n- &quot;aab<u><strong>b</strong></u>&quot; -&gt; &quot;b&quot;\r\n</pre>\r\n\r\n<p><strong class=\"example\">Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> word = &quot;he&quot;\r\n<strong>Output:</strong> 2\r\n<strong>Explanation:</strong> The two wonderful substrings are underlined below:\r\n- &quot;<b><u>h</u></b>e&quot; -&gt; &quot;h&quot;\r\n- &quot;h<strong><u>e</u></strong>&quot; -&gt; &quot;e&quot;\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong>Constraints:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>1 &lt;= word.length &lt;= 10<sup>5</sup></code></li>\r\n\t<li><code>word</code> consists of lowercase English letters from <code>&#39;a&#39;</code>&nbsp;to <code>&#39;j&#39;</code>.</li>\r\n</ul>",
        "solutions": [
            {
                "id": 1299773,
                "title": "intuitive-explanation-easy-to-understand",
                "content": "First part: we only care about if a letter is odd or even count, so we can track the current state of the string from [0...i] using a bitmask. 1 will mean that character is odd and 0 will mean that character is even. For example, \"1001\" means d has odd count, c even, b even, a odd\\n\\nTo calculate the answer: We go through from index 0 to the length of the string, updating the state of the string from [0...current index]. If we have seen our current state before (say [0...j] has the same state as [0...i], that means the substring between j and i has an even count of all characters. Think about each new character as flicking it\\'s own light switch. Flicking a switch an even amount of times results in no change. So if we see that we have previously run into the current state, we know there is a substring with even count of all characters in between that state and the current state. We add however many times we have previously run into the current state. This is because if we\\'ve run into the state once before, say at j, we know [j...current index] has even count of all characters. So we add 1 to our answer. If we\\'ve run into the state twice before, say at j and i, we know that [j... current index] has even count of all characters and [i...current index] has even count of all characters, so we add 2. \\n\\nNext we tackle the part where one character can be odd. If there is one character which occurs an odd amount of times between [previous index... current index], and all other characters are even, that means we only need to flick one switch to turn our current state into the previous one. We try flicking each switch and see if we have run into that state before. If we have that means we have a wonderful substring because only 1 character appears an odd number of times between [previous index... current index]. Again we add the number of times we have previously run into the state, because of the same reason as above. If we\\'ve seen the state at j, then [j...current] has only 1 odd character, and if we\\'ve seen it at j and i, then [j...current] and [i...current] have only 1 odd character, etc. \\n\\nRuntime will be O(n)\\n\\nCode with comments\\n```\\npublic long wonderfulSubstrings(String word) {\\n        long[] cnt = new long[1024]; // cnt[state] stores how many times the state occurs\\n        cnt[0] = 1;  //empty string gives case where all characters occur even number of times\\n        int mask = 0; // current state\\n        long ans = 0;\\n        char[] chars = word.toCharArray();\\n        for (char c:chars) {\\n            int idx = c - \\'a\\';\\n            mask ^= 1 << idx; // update state\\n            ans += cnt[mask]; // add count of same previous states\\n            for (int i=0; i<10; i++) {\\n                int lookFor = mask ^ (1 << i); // try flick each switch\\n                ans += cnt[lookFor];\\n            }\\n            cnt[mask]++; // add 1 to count of times we\\'ve seen current state\\n        }\\n        return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic long wonderfulSubstrings(String word) {\\n        long[] cnt = new long[1024]; // cnt[state] stores how many times the state occurs\\n        cnt[0] = 1;  //empty string gives case where all characters occur even number of times\\n        int mask = 0; // current state\\n        long ans = 0;\\n        char[] chars = word.toCharArray();\\n        for (char c:chars) {\\n            int idx = c - \\'a\\';\\n            mask ^= 1 << idx; // update state\\n            ans += cnt[mask]; // add count of same previous states\\n            for (int i=0; i<10; i++) {\\n                int lookFor = mask ^ (1 << i); // try flick each switch\\n                ans += cnt[lookFor];\\n            }\\n            cnt[mask]++; // add 1 to count of times we\\'ve seen current state\\n        }\\n        return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1299525,
                "title": "count-bitmasks-with-picture",
                "content": "The idea is similar to:\\n- [1371. Find the Longest Substring Containing Vowels in Even Counts](https://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/discuss/534135/C%2B%2BJava-with-picture). \\n- [1542. Find Longest Awesome Substring](https://leetcode.com/problems/find-longest-awesome-substring/discuss/779893/C%2B%2BJavaPython3-with-picture-(similar-to-1371))\\n\\nWe can track whether we have an odd (1) or even (0) number of characters using a bit mask. Every time we see a character - we just flip the corresponding bit. Unlike related problems listed above, where we track the minimum position for each bitmask, here we count how many times we arrived at that bitmask (`cnt[mask]`).\\n\\n![image](https://assets.leetcode.com/users/images/636d7963-0c54-4824-a841-9bb8f10494e0_1624774942.5141225.png)\\n\\nIn the example above, we have four wonderful substrings: `abab`, `cc`, `ababcc` and `bccb`.\\n\\n>For simplicity, we only show substrings with all even characters. We will look into counting substrings with one odd character below.\\n\\nSay we arrive at bitmask `0000000001` at index `i`. That means that the count of all characters in `word[0..i]` is even except for `a`. What if we have seen this bitmask before at index `j`? Same, count for character `a` is odd in `word[0..j]`. Now, it tells us that the count for all characters in `word[j + 1, i]` is even... We have found a wonderful substring!\\n\\nFinal stretch - our substring can have up to one \"odd\" character. So we mutate our bitmask - one character at a time, and add the count for the mutated bitmask. The substring between the original and mutated mask will have a single \"odd\" character. In other words, XOR of these two masks will have one bit set.\\n\\n> This is the same technique as we used in [1542. Find Longest Awesome Substring](https://leetcode.com/problems/find-longest-awesome-substring/discuss/779893/C%2B%2BJavaPython3-with-picture-(similar-to-1371)).\\n\\nFor example, for bitmask `0000000100` (or 4, which correspond to the first `c` in the example above), we will try:\\n1. `0000000101`\\n2. `0000000110`\\n3. `0000000000` -> this matches `ababc` substring in the example above.\\n4. `0000001100` \\n\\t- and so on...\\n\\n**C++**\\nNote that we run the count one more time for the original mask - the shift `1 << 11` is offset by `1023 &` operation.\\n\\n```cpp\\nlong long wonderfulSubstrings(string word) {\\n    long cnt[1024] = { 1 }, mask = 0, res = 0;\\n    for (auto ch : word) {\\n        mask ^= 1 << (ch - \\'a\\');\\n        res += cnt[mask];\\n        for (auto n = 0; n < 10; ++n)\\n            res += cnt[mask ^ (1 << n)];\\n        ++cnt[mask];\\n    }\\n    return res;\\n}\\n```\\n**Java**\\n```java\\npublic long wonderfulSubstrings(String word) {\\n    long cnt[] = new long[1024], res = 0;\\n    int mask = 0;\\n    cnt[0] = 1;\\n    for (var ch : word.toCharArray()) {\\n        mask ^= 1 << (ch - \\'a\\');\\n        res += cnt[mask];\\n        for (var n = 0; n < 10; ++n)\\n            res += cnt[mask ^ (1 << n)];\\n        ++cnt[mask];\\n    }\\n    return res;\\n}\\n```\\n**Python 3**\\n```python\\nclass Solution:\\n    def wonderfulSubstrings(self, word: str) -> int:\\n        cnt, res, mask = [1] + [0] * 1023, 0, 0\\n        for ch in word:\\n            mask ^= 1 << (ord(ch) - ord(\\'a\\'))\\n            res += cnt[mask]\\n            for n in range(10):\\n                res += cnt[mask ^ 1 << n];\\n            cnt[mask] += 1\\n        return res\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```cpp\\nlong long wonderfulSubstrings(string word) {\\n    long cnt[1024] = { 1 }, mask = 0, res = 0;\\n    for (auto ch : word) {\\n        mask ^= 1 << (ch - \\'a\\');\\n        res += cnt[mask];\\n        for (auto n = 0; n < 10; ++n)\\n            res += cnt[mask ^ (1 << n)];\\n        ++cnt[mask];\\n    }\\n    return res;\\n}\\n```\n```java\\npublic long wonderfulSubstrings(String word) {\\n    long cnt[] = new long[1024], res = 0;\\n    int mask = 0;\\n    cnt[0] = 1;\\n    for (var ch : word.toCharArray()) {\\n        mask ^= 1 << (ch - \\'a\\');\\n        res += cnt[mask];\\n        for (var n = 0; n < 10; ++n)\\n            res += cnt[mask ^ (1 << n)];\\n        ++cnt[mask];\\n    }\\n    return res;\\n}\\n```\n```python\\nclass Solution:\\n    def wonderfulSubstrings(self, word: str) -> int:\\n        cnt, res, mask = [1] + [0] * 1023, 0, 0\\n        for ch in word:\\n            mask ^= 1 << (ord(ch) - ord(\\'a\\'))\\n            res += cnt[mask]\\n            for n in range(10):\\n                res += cnt[mask ^ 1 << n];\\n            cnt[mask] += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1299523,
                "title": "c-bit-vector-prefix-parities-similar-to-prefix-sums",
                "content": "**Observation**\\n\\nAt any point `i` if you want to find how many substrings with even count of a character has been encountered you would need to find the number of times from `0` to `i` the same parity (odd or even) of the character was encounterd.\\nFor eg: If current count of `a` is `7`, you would need to know the number of prefix counts where `a` was `1`, `3`, `5` ... until `7`. This is because `odd - odd` is even.\\nif current count of `a` was `6`, you would need to know the number of prefix count where `a` was `0`, `2`, `4` ... until 6. This is because `even - even` is even.\\n\\nWe can see that we only need to know if the character has been encountered odd or even number of times. \\nThus we can use a `set` bit to denote if the character has been encounterd odd number of times or `unset` bit to denote it has been encountered even number of times instead of prefix count we store prefix parities.\\n\\n* The logic can now be translated to: If current parity of `a` is `0b0001` (denoting count of `a` is odd) we simply sum up the previous prefixes where parity was `0b0001`.\\n* Similarly to find the odd count we would find opposite parity count, in this case `0b0000`.\\n* The same logic can now be applied to multiple characters by using different bit for each character. Eg: `\"abcda\" = 0b1110`\\n\\n![image](https://assets.leetcode.com/users/images/9a10dd8c-69a7-4f62-9a4e-504e1f2efbe3_1624778387.6477914.gif)\\n\\n*Animation showing working of the observation on sample input*\\n\\n\\n**Similar Questions:**\\n* [1371. Find the Longest Substring Containing Vowels in Even Counts](https://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/)\\n* [1542. Find Longest Awesome Substring](https://leetcode.com/problems/find-longest-awesome-substring/)\\n\\n**Solution**\\n\\nTo have at most 1 odd we sum the counts of all even characters encounterd + count of a single character that can be odd, we try each character from `a` to `j`. We use the similar prefix parity logic as explained above to get results for both operations 1) Count of substrings with all characters even in count. 2) Count of substrings with 1 character odd in count.\\n\\n`Running` stores the parities of all characters until index `i`  i.e `word[0...i]`. For finding count of even characters we sum counts of of all `j<i` where  `word[0...j]` had same parity as `running` since then `word[j+1...i]` would have characters with all even counts as seen in the observation section.\\n\\nTo find substrings with 1 character odd in count we flip one bit of `running` at a time and sum counts of all `j<i` where  `word[0...j]` had same parity as running except 1 bit (the one we flipped) as this would mean `word[j+1...i]` had all characters in even count except the one that represents the flipped bit which would be odd in count.\\n\\n```c++\\nclass Solution {\\npublic:\\n\\t// Returns the set bit for a character.\\n    int getHash(char &c) {\\n        return 1<<(c-\\'a\\');\\n    }\\n    long long wonderfulSubstrings(string word) {\\n\\t\\t// Stores prefix parities.\\n        unordered_map<int,int> count={{0,1}};\\n\\t\\tint running=0;\\n        long long result=0;\\n        for(char &w:word) {\\n\\t\\t\\t// Update the running parity\\n            running^=getHash(w);\\n\\t\\t\\t\\n\\t\\t\\t// Add counts of substrings with at most character `c` of odd counts.\\n\\t\\t\\t// As seen in observation we need count of prefix parities with opposite parity of character we are considering for odd count.\\n\\t\\t\\t// The rest remains same as we want even count for all other characters.\\n\\t\\t\\t// Here we are checking all possible characters, however it can be obtimized to check characters only present in the input word.\\n            for(char c=\\'a\\';c<=\\'j\\';c++)\\n                result+=count[running^getHash(c)];\\n\\t\\t\\t\\t\\n\\t\\t\\t// Add counts of substrings with all characters with even counts.\\n\\t\\t\\t// As seen in observation we need count of prefix parities with same parities as current running parity.\\n            result+=count[running];\\n\\t\\t\\t\\n\\t\\t\\t// Update the counts for next future iterations.\\n            count[running]++;\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n**Solution 2 [Minor Optimization]**\\n\\nAs mentioned in the comments section and comments in previous code, we don\\'t really need to go over all possible characters but only the ones encountered in the prefix till now, since only those can possibly be odd, all others will simply return `0` substrings as our answer. The following code implements this optimization. \\n\\nUnexpectedly I saw a decent difference in runtime between the two solutions, hence adding this.\\n\\n```c++\\nclass Solution {\\npublic:\\n    int getHash(char &c) {\\n        return 1<<(c-\\'a\\');\\n    }\\n    long long wonderfulSubstrings(string word) {\\n        unordered_map<int,int> count={{0,1}};\\n        unordered_set<char> usedChars;\\n\\t\\tint running=0;\\n        long long result=0;\\n        for(char &w:word) {\\n            running^=getHash(w);\\n            \\n            // Add used characters to check for odd count.\\n            usedChars.insert(w);\\n            \\n            // Only iterate over characters encountered till now atleast once.\\n            // Since only those can possibly be odd in any substring.\\n            for(char c:usedChars)\\n                result+=count[running^getHash(c)];\\n            result+=count[running]++;\\n        }\\n        return result;\\n    }\\n};\\n```\\n**Complexity**\\nTime: `O(10n) = O(n)`. We iterate over entire word at each iteration we add substring counts for the characters `a` to `j` to be odd in count.\\nSpace: `O(2^10) = O(1024) = O(1)`. We can store at most all combinations of parities of `a` to `j` which is `2^10`.",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n\\t// Returns the set bit for a character.\\n    int getHash(char &c) {\\n        return 1<<(c-\\'a\\');\\n    }\\n    long long wonderfulSubstrings(string word) {\\n\\t\\t// Stores prefix parities.\\n        unordered_map<int,int> count={{0,1}};\\n\\t\\tint running=0;\\n        long long result=0;\\n        for(char &w:word) {\\n\\t\\t\\t// Update the running parity\\n            running^=getHash(w);\\n\\t\\t\\t\\n\\t\\t\\t// Add counts of substrings with at most character `c` of odd counts.\\n\\t\\t\\t// As seen in observation we need count of prefix parities with opposite parity of character we are considering for odd count.\\n\\t\\t\\t// The rest remains same as we want even count for all other characters.\\n\\t\\t\\t// Here we are checking all possible characters, however it can be obtimized to check characters only present in the input word.\\n            for(char c=\\'a\\';c<=\\'j\\';c++)\\n                result+=count[running^getHash(c)];\\n\\t\\t\\t\\t\\n\\t\\t\\t// Add counts of substrings with all characters with even counts.\\n\\t\\t\\t// As seen in observation we need count of prefix parities with same parities as current running parity.\\n            result+=count[running];\\n\\t\\t\\t\\n\\t\\t\\t// Update the counts for next future iterations.\\n            count[running]++;\\n        }\\n        return result;\\n    }\\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    int getHash(char &c) {\\n        return 1<<(c-\\'a\\');\\n    }\\n    long long wonderfulSubstrings(string word) {\\n        unordered_map<int,int> count={{0,1}};\\n        unordered_set<char> usedChars;\\n\\t\\tint running=0;\\n        long long result=0;\\n        for(char &w:word) {\\n            running^=getHash(w);\\n            \\n            // Add used characters to check for odd count.\\n            usedChars.insert(w);\\n            \\n            // Only iterate over characters encountered till now atleast once.\\n            // Since only those can possibly be odd in any substring.\\n            for(char c:usedChars)\\n                result+=count[running^getHash(c)];\\n            result+=count[running]++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1299552,
                "title": "java-c-python-bit-mask-prefix",
                "content": "# **Explanation**\\nUse a mask to count the current prefix string.\\nmask & 1 means whether it has odd \\'a\\'\\nmask & 2 means whether it has odd \\'b\\'\\nmask & 4 means whether it has odd \\'c\\'\\n...\\n\\nWe find the number of wonderful string with all even number of characters.\\nThen we flip each of bits, 10 at most, and doing this again.\\nThis will help to find string with at most one odd number of characters.\\n\\n# **Complexity**\\nTime `O(10n)`, Space `O(1024)`\\n<br>\\n\\n**Java**\\n```java\\n    public long wonderfulSubstrings(String word) {\\n        long res = 0, count[]  = new long[1024];\\n        int cur = 0;\\n        count[0] = 1L;\\n        for (int i = 0; i < word.length(); ++i) {\\n            cur ^= 1 << (word.charAt(i) - \\'a\\');\\n            res += count[cur]++;\\n            for (int j = 0; j < 10; ++j)\\n                res += count[cur ^ (1 << j)];\\n        }\\n        return res;\\n    }\\n```\\n**C++**\\n```cpp\\n    long long wonderfulSubstrings(string word) {\\n        vector<int> count(1024);\\n        long long res = 0, cur = 0;\\n        count[0] = 1L;\\n        for (char& c: word) {\\n            cur ^= 1 << (c - \\'a\\');\\n            res += count[cur]++;\\n            for (int i = 0; i < 10; ++i)\\n                res += count[cur ^ (1 << i)];\\n        }\\n        return res;\\n    }\\n```\\n**Python**\\n```py\\n    def wonderfulSubstrings(self, word):\\n        count = [1] + [0] * 1024\\n        res = cur = 0\\n        for c in word:\\n            cur ^= 1 << (ord(c) - ord(\\'a\\'))\\n            res += count[cur]\\n            res += sum(count[cur ^ (1 << i)] for i in xrange(10))\\n            count[cur] += 1\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public long wonderfulSubstrings(String word) {\\n        long res = 0, count[]  = new long[1024];\\n        int cur = 0;\\n        count[0] = 1L;\\n        for (int i = 0; i < word.length(); ++i) {\\n            cur ^= 1 << (word.charAt(i) - \\'a\\');\\n            res += count[cur]++;\\n            for (int j = 0; j < 10; ++j)\\n                res += count[cur ^ (1 << j)];\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    long long wonderfulSubstrings(string word) {\\n        vector<int> count(1024);\\n        long long res = 0, cur = 0;\\n        count[0] = 1L;\\n        for (char& c: word) {\\n            cur ^= 1 << (c - \\'a\\');\\n            res += count[cur]++;\\n            for (int i = 0; i < 10; ++i)\\n                res += count[cur ^ (1 << i)];\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def wonderfulSubstrings(self, word):\\n        count = [1] + [0] * 1024\\n        res = cur = 0\\n        for c in word:\\n            cur ^= 1 << (ord(c) - ord(\\'a\\'))\\n            res += count[cur]\\n            res += sum(count[cur ^ (1 << i)] for i in xrange(10))\\n            count[cur] += 1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1301408,
                "title": "bitmask-with-pictures-python-o-n",
                "content": "So solve this problem, we need to know a few things\\n### 1 We can represent the odd/evenness of a string with a bitmask\\n\\nFirst we count the number of occurrences of each character in the string. Then we convert the count to binary 0 = even, 1 = odd since all we care about is even or odd not the actual count.\\n![image](https://assets.leetcode.com/users/images/e2b42950-4b62-486c-b961-22adaf02366d_1624824380.2197793.png)\\n\\n\\nIf you need a refresher for bitmask, check out this [tutorial](https://algo.monster/problems/bitmask_intro).\\n\\n### 2. In terms of bitmask calculations, appending a character to a string is equivalent to doing an XOR operation of the bitmask of the character and the bitmask of string. \\n\\n![image](https://assets.leetcode.com/users/images/6e524b71-1627-486b-951f-d76484775a2a_1624824396.403979.png)\\n\\n\\nQuick review of XOR: it returns 1 if the bits are different, 0 if they are the same. Adding a character to a string flips the even/odd bit for that character in the bitmask.\\n\\n### 3. If the prefix of a string has the same bitmask as the string, then the remaining substring\\u2019s bitmask has all its bits 0 and is a wonderful string.\\n\\n![image](https://assets.leetcode.com/users/images/faefa62f-42be-435a-9ab1-24d43b8a27a0_1624824402.1264205.png)\\n\\nWith the knowledge under our belt, we can now go through each character of the string compute the bitmask incrementally using 2) and test if a matching prefix exists using 3) and add to result. This handles all the cases where occurrence of all characters are even.\\nWe also want to add the case where one character appears odd number of times. We can do this by flipping the bit for each character in the current string and if the resulting bitmask exist as a prefix then add the count to the result.\\n\\n```\\nclass Solution:\\n    def wonderfulSubstrings(self, word: str) -> int:\\n        # count is a bitmask where each bit represent the count of a character from a-j % 2\\n        # bitmask is 10 bits, each bit 2 values, 2^10 = 1024\\n        count = [0] * 1024\\n        # 0 means empty string, which has all its bits 0\\n        count[0] = 1\\n        ans = 0\\n        cur = 0\\n        for char in word:\\n            # bitmask of the current string ending in char\\n            cur ^= 1 << (ord(char) - ord(\\'a\\'))\\n            # add the all even case to result\\n            ans += count[cur]\\n            # flip each bit and see if there\\'s matching prefix\\n            # this adds the \\'at most one\\' odd case.\\n            for i in range(10):\\n                new_bitmask = cur ^ (1 << i)\\n                if count[new_bitmask] > 0:\\n                    ans += count[new_bitmask]\\n            count[cur] += 1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def wonderfulSubstrings(self, word: str) -> int:\\n        # count is a bitmask where each bit represent the count of a character from a-j % 2\\n        # bitmask is 10 bits, each bit 2 values, 2^10 = 1024\\n        count = [0] * 1024\\n        # 0 means empty string, which has all its bits 0\\n        count[0] = 1\\n        ans = 0\\n        cur = 0\\n        for char in word:\\n            # bitmask of the current string ending in char\\n            cur ^= 1 << (ord(char) - ord(\\'a\\'))\\n            # add the all even case to result\\n            ans += count[cur]\\n            # flip each bit and see if there\\'s matching prefix\\n            # this adds the \\'at most one\\' odd case.\\n            for i in range(10):\\n                new_bitmask = cur ^ (1 << i)\\n                if count[new_bitmask] > 0:\\n                    ans += count[new_bitmask]\\n            count[cur] += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1299556,
                "title": "python3-one-pass-o-n-bit-masks",
                "content": "```\\nclass Solution:\\n    # idea: we don\\'t need to know exact substring to define if it\\'s \"wonderful\" or not\\n    #   but rather if number of occurrences of each letter is odd/even;\\n    #   so there are only two states for each letter, so we can use binary mask to represent any substring\\n    #\\n    #   for example \"0101\" represents: (\"d\" even number, \"c\" - odd, \"b\" - even, \"a\" - odd);\\n\\t#   \\n\\t#  a mask will represent a prefix of word [0..k] where `0 <= k < len(word)`\\n\\t#  if we have two masks that represent prefixes [0..k] and [0..p], where `p > k`,\\n\\t#  then substring [k+1..p] is \"wonderful\" if:\\n\\t#     1. two masks are equal (all letters in substring [k+1..p] have even frequency)\\n\\t#     2. or two masks are 1 bit different (only one letter in substring [k+1..p] has odd frequency)\\n\\t#\\n\\t#   we can test this with XOR operator:\\n\\t#       if (mask_0_k ^ mask_0_p) == mask_with_0_or_1_bit_set => we have a \"wonderful\" substring\\n    #\\n    #   we can iterate through word and:\\n\\t#       1. compute a mask based on previous mask (switch bit for corresponding letter)\\n\\t#       2. find all masks that would combine with current one a \"wonderful\" string (equal mask or one bit different mask)\\n\\t#       3. check how many of those masks we saw earlier and add the number to result\\n\\t#       4. memorize current mask (so it can be used on further iterations)\\n\\t#\\n    #   example: \"ccbbc\" (3 letter alphabet)\\n\\t#                     binary_index:        [111, 110, 101, 100, 011, 010, 001, 000]\\n    #       \"\" -      { mask: 000, mask_count: [  0,   0,   0,   0,   0,   0,   0, 0+1], res: 0 }\\n    #       \"c\" -     { mask: 100, mask_count: [  0,   0,   0, 0+1,   0,   0,   0,   1], res: 0 + 0 (equal masks) + 1 (1 bit different masks) = 1 }\\n    #       \"cc\" -    { mask: 000, mask_count: [  0,   0,   0,   1,   0,   0,   0, 1+1], res: 1 + 1 (equal masks) + 1 (1 bit different masks) = 3 }\\n    #       \"ccb\" -   { mask: 010, mask_count: [  0,   0,   0,   1,   0, 0+1,   0,   2], res: 3 + 0 (equal masks) + 2 (1 bit different masks) = 5 }\\n    #       \"ccbb\" -  { mask: 000, mask_count: [  0,   0,   0,   1,   0,   1,   0, 2+1], res: 5 + 2 (equal masks) + 2 (1 bit different masks) = 9 }\\n    #       \"ccbbc\" - { mask: 100, mask_count: [  0,   0,   0, 1+1,   0,   1,   0,   3], res: 9 + 1 (equal masks) + 3 (1 bit different masks) = 13 }\\n\\t#\\n    \\n    def wonderfulSubstrings(self, word: str) -> int:\\n        mask = 0\\n        mask_count = [0] * 1024\\n        mask_count[mask] += 1\\n        res = 0\\n\\n        for letter in word:\\n            mask ^= 1 << ord(letter) - ord(\"a\")\\n            res += mask_count[mask]\\n            for i in range(10):\\n                res += mask_count[mask ^ 1 << i]\\n            mask_count[mask] += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # idea: we don\\'t need to know exact substring to define if it\\'s \"wonderful\" or not\\n    #   but rather if number of occurrences of each letter is odd/even;\\n    #   so there are only two states for each letter, so we can use binary mask to represent any substring\\n    #\\n    #   for example \"0101\" represents: (\"d\" even number, \"c\" - odd, \"b\" - even, \"a\" - odd);\\n\\t#   \\n\\t#  a mask will represent a prefix of word [0..k] where `0 <= k < len(word)`\\n\\t#  if we have two masks that represent prefixes [0..k] and [0..p], where `p > k`,\\n\\t#  then substring [k+1..p] is \"wonderful\" if:\\n\\t#     1. two masks are equal (all letters in substring [k+1..p] have even frequency)\\n\\t#     2. or two masks are 1 bit different (only one letter in substring [k+1..p] has odd frequency)\\n\\t#\\n\\t#   we can test this with XOR operator:\\n\\t#       if (mask_0_k ^ mask_0_p) == mask_with_0_or_1_bit_set => we have a \"wonderful\" substring\\n    #\\n    #   we can iterate through word and:\\n\\t#       1. compute a mask based on previous mask (switch bit for corresponding letter)\\n\\t#       2. find all masks that would combine with current one a \"wonderful\" string (equal mask or one bit different mask)\\n\\t#       3. check how many of those masks we saw earlier and add the number to result\\n\\t#       4. memorize current mask (so it can be used on further iterations)\\n\\t#\\n    #   example: \"ccbbc\" (3 letter alphabet)\\n\\t#                     binary_index:        [111, 110, 101, 100, 011, 010, 001, 000]\\n    #       \"\" -      { mask: 000, mask_count: [  0,   0,   0,   0,   0,   0,   0, 0+1], res: 0 }\\n    #       \"c\" -     { mask: 100, mask_count: [  0,   0,   0, 0+1,   0,   0,   0,   1], res: 0 + 0 (equal masks) + 1 (1 bit different masks) = 1 }\\n    #       \"cc\" -    { mask: 000, mask_count: [  0,   0,   0,   1,   0,   0,   0, 1+1], res: 1 + 1 (equal masks) + 1 (1 bit different masks) = 3 }\\n    #       \"ccb\" -   { mask: 010, mask_count: [  0,   0,   0,   1,   0, 0+1,   0,   2], res: 3 + 0 (equal masks) + 2 (1 bit different masks) = 5 }\\n    #       \"ccbb\" -  { mask: 000, mask_count: [  0,   0,   0,   1,   0,   1,   0, 2+1], res: 5 + 2 (equal masks) + 2 (1 bit different masks) = 9 }\\n    #       \"ccbbc\" - { mask: 100, mask_count: [  0,   0,   0, 1+1,   0,   1,   0,   3], res: 9 + 1 (equal masks) + 3 (1 bit different masks) = 13 }\\n\\t#\\n    \\n    def wonderfulSubstrings(self, word: str) -> int:\\n        mask = 0\\n        mask_count = [0] * 1024\\n        mask_count[mask] += 1\\n        res = 0\\n\\n        for letter in word:\\n            mask ^= 1 << ord(letter) - ord(\"a\")\\n            res += mask_count[mask]\\n            for i in range(10):\\n                res += mask_count[mask ^ 1 << i]\\n            mask_count[mask] += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1301518,
                "title": "array-of-bitmasks-and-its-working-intuition-c-java",
                "content": "I read a lot of solutions for this problem in the discuss section but couldn\\'t gain the intuition towards the solution.\\n*Then I looked at the Hints provided and tried to brainstrom over as to why this approach works.\\n\\n* I then finally came up with a strong reasoning as provided below:\\n\\n* The first thing that we\\'ll do is to maintain a **BITMASK** for each index while travelling from left to right over the string just like we do for prefixSum.\\n* The **BITMASK** will store that which letters are even in frequency and which are odd. The **BITMASK** will be having 10 places for each of the first 10 letters like :\\n```\\n                            j i h g f e d c b a\\n                            9 8 7 6 5 4 3 2 1 0\\n```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  \\n* Now, the letters which have **ODD FREQUENCY** will have its bit =  **1** and letters with **EVEN FREQUENCY** will have its bit = **0**.\\n* The frequency of the current character can be updated by toggling its bit because **Odd + 1 = Even** and **Even + 1 = Odd**.\\n* Also, for each bitmask, we\\'ll store its frequency in a **HASHMAP**.\\n* Now, consider bitmask at index **i** as  :   \\n     1 0 1 0 0 0 1 0 1 0 1\\n\\t \\n\\t ***Now this bitmask can pair with*** :\\n\\t \\n1. \\t Its same mask at a previous index **j** beacuse then it will mean that the previous same bitmask will have the same elements which occurred as even and odd in this mask, and the substring between these indices, i.e. **i - j length substring**, will have :\\n\\n\\t    **ith : 10100010101 - jth : 10100010101** elements which evaulates to :\\n\\t\\t```\\n\\t\\t\\t   1  0  1  0  0  0  1  0  1  0  1\\n\\t\\t     - 1  0  1  0  0  0  1  0  1  0  1\\n\\t\\t\\t------------------------------------ \\n\\t\\t\\t   0  0  0  0  0  0  0  0  0  0  0 \\n\\t\\t\\t(Beacuse of Even - Even Frequency and Odd - Odd Frequency which both equals Even)\\n\\t\\t\\n\\t\\t```\\n\\t\\t\\n\\t\\tWhich means the substring from **i - j** has all characters\\' frequency **Even** numbers of time.\\n\\t\\t\\n        Therefore, first way is ```count += freq[currMask]```\\n\\n2. Now, a second way is to count frequency of all the bitmasks at **previous indices** which differ from the current bitmask at exactly one place. This works beacuse the bitmask which will have exactly one bit difference will evalute to :\\n\\t  \\n\\t  Example let the previous bitmask be 1 0 1 0 0 1  1 0 1 0 1\\n\\t  \\n\\t  **ith : 10100010101 - jth : 10100110101** elements which evaulates to :\\n\\t  \\n\\t  \\n\\n\\t\\t     1  0  1  0  0  0  1  0  1  0  1\\n\\t       - 1  0  1  0  0  1  1  0  1  0  1\\n\\t\\t  ------------------------------------ \\n\\t\\t     0  0  0  0  0  1  0  0  0  0  0 \\n\\t\\t\\t(One Bit is 1 because it is due to substraction of Odd - Even or Even - Odd and the rest are 0 beacuse of Even - Even Frequency and Odd - Odd Frequency which both equals Even)\\n\\n   Which means the substring from **i - j** has One characters\\' frequency **Odd** numbers of time and all others **Even**, which satisfies the given constraint.\\n\\t\\t\\n        Therefore, second way is count += freq[AllBitMasks with exactly 1 Bit Different]\\n\\t\\t\\n\\t\\n\\t**I hope that I was able to make you understand the approach. Below is the C++ and Java Code :**\\n\\n\\t\\n\\n**C++**\\n\\n```\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string &word) {\\n        int n = word.size();\\n        long long count = 0;\\n        \\n        vector<long long> freq((1 << 10) + 1, 0); // Since we have to take only 2^10 possibilies, we can avoid an unordered_map\\n        \\n        freq[0] = 1;  // initialize the frequency of 0000000000 as 1 because when no element is encountered, then th bitmask is 0\\n        int res = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            int mask = (1 << (word[i] - \\'a\\'));\\n            res ^= mask; // toggling bit of the current character to make it from odd to even OR even to odd\\n            count += freq[res]; // way 1\\n\\t\\t\\t\\n\\t\\t\\tint chkMask = 1;\\n            for (int j = 1; j <= 10; j++) {    // Loop for checking all possiblities of different places of the Different Bit\\n                count += freq[chkMask ^ res];\\n                chkMask <<= 1;\\n            }\\n            \\n            freq[res]++;  // increasing the frequency of the current bitmask\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\\n\\n\\n**JAVA**\\n```\\nclass Solution {\\n    public long wonderfulSubstrings(String word) {\\n        int n = word.length();\\n        long count = 0;\\n        \\n        long[] freq = new long[(1 << 10) + 1]; // Since we have to take only 2^10 possibilies, we can avoid an HashMap\\n        \\n        freq[0] = 1;\\n        int res = 0; // initialize the frequency of 0000000000 as 1 because when no element is encountered, then th bitmask is 0\\n        \\n        for (int i = 0; i < n; i++) {\\n            int mask = (1 << (word.charAt(i) - \\'a\\'));\\n            res ^= mask; // toggling bit of the current character to make it from odd to even OR even to odd\\n            int chkMask = 1;\\n            \\n            count += freq[res];\\n            for (int j = 1; j <= 10; j++) {  // Loop for checking all possiblities of different places of the Different Bit\\n                count += freq[chkMask ^ res];\\n                chkMask <<= 1;\\n            }\\n            \\n            freq[res]++; // increasing the frequency of the current bitmask\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\n                            j i h g f e d c b a\\n                            9 8 7 6 5 4 3 2 1 0\\n```\n```\\n\\t\\t\\t   1  0  1  0  0  0  1  0  1  0  1\\n\\t\\t     - 1  0  1  0  0  0  1  0  1  0  1\\n\\t\\t\\t------------------------------------ \\n\\t\\t\\t   0  0  0  0  0  0  0  0  0  0  0 \\n\\t\\t\\t(Beacuse of Even - Even Frequency and Odd - Odd Frequency which both equals Even)\\n\\t\\t\\n\\t\\t```\n```count += freq[currMask]```\n```\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string &word) {\\n        int n = word.size();\\n        long long count = 0;\\n        \\n        vector<long long> freq((1 << 10) + 1, 0); // Since we have to take only 2^10 possibilies, we can avoid an unordered_map\\n        \\n        freq[0] = 1;  // initialize the frequency of 0000000000 as 1 because when no element is encountered, then th bitmask is 0\\n        int res = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            int mask = (1 << (word[i] - \\'a\\'));\\n            res ^= mask; // toggling bit of the current character to make it from odd to even OR even to odd\\n            count += freq[res]; // way 1\\n\\t\\t\\t\\n\\t\\t\\tint chkMask = 1;\\n            for (int j = 1; j <= 10; j++) {    // Loop for checking all possiblities of different places of the Different Bit\\n                count += freq[chkMask ^ res];\\n                chkMask <<= 1;\\n            }\\n            \\n            freq[res]++;  // increasing the frequency of the current bitmask\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public long wonderfulSubstrings(String word) {\\n        int n = word.length();\\n        long count = 0;\\n        \\n        long[] freq = new long[(1 << 10) + 1]; // Since we have to take only 2^10 possibilies, we can avoid an HashMap\\n        \\n        freq[0] = 1;\\n        int res = 0; // initialize the frequency of 0000000000 as 1 because when no element is encountered, then th bitmask is 0\\n        \\n        for (int i = 0; i < n; i++) {\\n            int mask = (1 << (word.charAt(i) - \\'a\\'));\\n            res ^= mask; // toggling bit of the current character to make it from odd to even OR even to odd\\n            int chkMask = 1;\\n            \\n            count += freq[res];\\n            for (int j = 1; j <= 10; j++) {  // Loop for checking all possiblities of different places of the Different Bit\\n                count += freq[chkMask ^ res];\\n                chkMask <<= 1;\\n            }\\n            \\n            freq[res]++; // increasing the frequency of the current bitmask\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1299986,
                "title": "python3-bitwise-explanation-o-n",
                "content": "Sharing my Intution to solve problems like these. \\n\\n1. I always like to pay close attention to the constraints of the problem. characters in range \\'a\\' to \\'j\\' is a big hint towards possibility of exponential calculation. generally , its safe to run ~ (2^14) algorithm to get an acceptance. Here we have 10 characters so (2^10) should suffice if needed, the question remains if this constraint is going to be a bottleneck to memory or time\\n\\n2. Even / Odd applies a 0 | 1 condition. leading to a strongcase for using a bitmask \\n(pointing towards -> memory over time)\\n\\nLet\\'s create a bitmask = 0 to denote even/odd occurences of each character which holds their relative bit in the mask before we start traversal of the string\\n\\n**0: even or no occurence\\n1: odd occurence**\\n\\n```\\nj i h g f e d c b a\\n0 0 0 0 0 0 0 0 0 0\\n```\\n\\n```for s = \"fabaf\"```\\nThe bitmask evolves in following manner\\n\\n2.1 ```ch = f```\\n```\\nj i h g f e d c b a\\n0 0 0 0 1 0 0 0 0 0\\n```\\n2.2 ```ch = a```\\n```\\nj i h g f e d c b a\\n0 0 0 0 1 0 0 0 0 1\\n```\\n2.3 ```ch = b```\\n```\\nj i h g f e d c b a\\n0 0 0 0 1 0 0 0 1 1\\n```\\n2.4 ```ch = a```\\n```\\nj i h g f e d c b a\\n0 0 0 0 1 0 0 0 1 0\\n```\\n2.6 ```ch = f```\\n```\\nj i h g f e d c b a\\n0 0 0 0 0 0 0 0 1 0\\n```\\n\\nBasically at each step , we modify our mask to  prefix (0|1) occurences of characters seen at that point so far\\n\\n[**Optional** information on general bitwise math]\\n*To convert from (0 to 1) at bit \\'i\\' can be achieved as followed*\\n``` \\nmask =  101010\\n\\nwe want to modify bit at index(0 based , Right -> Left) 2 to \\'1\\' , use or\\n\\ni.e 101010 | 000100 = 101110\\n(mask | (1 << i))\\n```\\n\\n*To convert from (1 to 0) at bit \\'i\\' can be achieved as followed*\\n``` \\nmask =  101010\\n\\nwe want to modify bit at index(0 based , Right -> Left ) 3 to \\'0\\', use xor\\n\\ni.e 101010 ^ 001000 = 100010\\n(mask ^ (1 << i))\\n```\\n\\n\\n3. If you made to this point , Kudos! , With labour work all done , lets concentrate on logic to finish this problem off\\n\\nHint 1: As we can have atmost 1 odd occurences of a character in the substring. all the substrings that contribute to the final answer must have only 1 or 0 overall bits set to 1, \\n**i.e the the bit representation of that substring will be either 0 or a power of 2 (why?)**\\n\\nHint 2:\\nLets say at any point in our prefix mask evaluation, assume our mask has value\\n```\\nmask =  10010101\\n```\\n\\nwe are looking to find some prefix (t) in the history seen so far that could evaluate to\\n**mask ^ t = 0**      \\n=>    \\n```t = mask```\\n\\nor\\n\\n**mask ^t = (some power of 2)** (lets try all powers of two in range 10) \\n=>   \\n```t = mask ^ (1 << j) [j in range 10]```\\n\\nQuestion for the reader: Why did we use XOR here to evaulate history? \\n*(HINT 1: Draw truth table for odd - odd , odd - even , even - odd , even - even) \\n(HINT 2: The XOR between mask and t gives you bitwise representation of the substring from the point t to current point)*\\n\\nComment in the section below , if you need more assistance on this, will be happy to elaborate\\n\\n\\nFinally the code for your perusal\\n```\\nclass Solution:\\n    def wonderfulSubstrings(self, word: str) -> int:\\n        \\n        count = Counter()\\n        seen = Counter()\\n        seen[0] = 1\\n        \\n        mask = 0\\n        ans = 0\\n        for i , c in enumerate(word):\\n            count[c] += 1\\n            bit = ord(c) - ord(\\'a\\')\\n            \\n            if count[c]&1:\\n                mask =  mask | (1 << bit)\\n            else:\\n                mask =  mask ^ (1 << bit)\\n                \\n            ans += seen[mask]\\n\\t\\t\\t\\n            for j in range(11):\\n                if ((1 << j) ^ mask) in seen:\\n                    ans += seen[(1 << j) ^ mask]       \\n                    \\n            seen[mask] += 1\\n            \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nj i h g f e d c b a\\n0 0 0 0 0 0 0 0 0 0\\n```\n```for s = \"fabaf\"```\n```ch = f```\n```\\nj i h g f e d c b a\\n0 0 0 0 1 0 0 0 0 0\\n```\n```ch = a```\n```\\nj i h g f e d c b a\\n0 0 0 0 1 0 0 0 0 1\\n```\n```ch = b```\n```\\nj i h g f e d c b a\\n0 0 0 0 1 0 0 0 1 1\\n```\n```ch = a```\n```\\nj i h g f e d c b a\\n0 0 0 0 1 0 0 0 1 0\\n```\n```ch = f```\n```\\nj i h g f e d c b a\\n0 0 0 0 0 0 0 0 1 0\\n```\n``` \\nmask =  101010\\n\\nwe want to modify bit at index(0 based , Right -> Left) 2 to \\'1\\' , use or\\n\\ni.e 101010 | 000100 = 101110\\n(mask | (1 << i))\\n```\n``` \\nmask =  101010\\n\\nwe want to modify bit at index(0 based , Right -> Left ) 3 to \\'0\\', use xor\\n\\ni.e 101010 ^ 001000 = 100010\\n(mask ^ (1 << i))\\n```\n```\\nmask =  10010101\\n```\n```t = mask```\n```t = mask ^ (1 << j) [j in range 10]```\n```\\nclass Solution:\\n    def wonderfulSubstrings(self, word: str) -> int:\\n        \\n        count = Counter()\\n        seen = Counter()\\n        seen[0] = 1\\n        \\n        mask = 0\\n        ans = 0\\n        for i , c in enumerate(word):\\n            count[c] += 1\\n            bit = ord(c) - ord(\\'a\\')\\n            \\n            if count[c]&1:\\n                mask =  mask | (1 << bit)\\n            else:\\n                mask =  mask ^ (1 << bit)\\n                \\n            ans += seen[mask]\\n\\t\\t\\t\\n            for j in range(11):\\n                if ((1 << j) ^ mask) in seen:\\n                    ans += seen[(1 << j) ^ mask]       \\n                    \\n            seen[mask] += 1\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1299520,
                "title": "subarray-sum-equals-k-hashmap-bitmasks",
                "content": "This problem is very similar to subarray sum equals k. https://leetcode.com/problems/subarray-sum-equals-k/\\n\\nStore the current string in a frequency table of length ten and store the freq of each char. Since we only care about the parity of the substring we can use bitmasks to be efficient! We store the masks into a hashtable then the problem reduces to subarray sum equals k.\\n\\nJust make sure to count separately the ways to get the 0 mask (all evens) and exactly 1 odd count substring.\\n\\nOnly other trick is to use long long to avoid overflow!!\\n\\nO(10 * n)\\n\\n```\\nusing ll = long long;\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string s) {\\n\\t\\tint n = s.size();\\n\\t\\tunordered_map<int, ll> mp;\\n\\t\\tmp[0] = 1;\\n\\t\\tll res = 0, sum = 0;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\t// store the char as a bit in a mask\\n\\t\\t\\tint c = s[i] - \\'a\\';\\n\\t\\t\\t// use xor to flip parity\\n\\t\\t\\tsum ^= (1 << c);\\n\\n\\t\\t\\t// the ways to get 0 odds is the number of masks \\'sum\\' \\n\\t\\t\\t// since they cancel each other in a subtraction\\n\\t\\t\\tif (mp.count(sum)) {\\n\\t\\t\\t\\tres += mp[sum];\\n\\t\\t\\t}\\n\\n\\t\\t\\t// count ways to get exactly 1 bit separately O(10)\\n\\t\\t\\tfor (int b = 0; b < 10; b++) {\\n\\t\\t\\t\\tint nsum = sum;\\n\\t\\t\\t\\tif (mp.count(nsum ^ (1 << b))) {\\n\\t\\t\\t\\t\\tres += mp[nsum ^ (1 << b)];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tmp[sum]++;\\n\\t\\t}\\n\\t\\treturn res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\nusing ll = long long;\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string s) {\\n\\t\\tint n = s.size();\\n\\t\\tunordered_map<int, ll> mp;\\n\\t\\tmp[0] = 1;\\n\\t\\tll res = 0, sum = 0;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\t// store the char as a bit in a mask\\n\\t\\t\\tint c = s[i] - \\'a\\';\\n\\t\\t\\t// use xor to flip parity\\n\\t\\t\\tsum ^= (1 << c);\\n\\n\\t\\t\\t// the ways to get 0 odds is the number of masks \\'sum\\' \\n\\t\\t\\t// since they cancel each other in a subtraction\\n\\t\\t\\tif (mp.count(sum)) {\\n\\t\\t\\t\\tres += mp[sum];\\n\\t\\t\\t}\\n\\n\\t\\t\\t// count ways to get exactly 1 bit separately O(10)\\n\\t\\t\\tfor (int b = 0; b < 10; b++) {\\n\\t\\t\\t\\tint nsum = sum;\\n\\t\\t\\t\\tif (mp.count(nsum ^ (1 << b))) {\\n\\t\\t\\t\\t\\tres += mp[nsum ^ (1 << b)];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tmp[sum]++;\\n\\t\\t}\\n\\t\\treturn res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1299537,
                "title": "python3-freq-table-w-mask",
                "content": "\\n```\\nclass Solution:\\n    def wonderfulSubstrings(self, word: str) -> int:\\n        ans = mask = 0\\n        freq = defaultdict(int, {0: 1})\\n        for ch in word: \\n            mask ^= 1 << ord(ch)-97\\n            ans += freq[mask]\\n            for i in range(10): ans += freq[mask ^ 1 << i]\\n            freq[mask] += 1\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def wonderfulSubstrings(self, word: str) -> int:\\n        ans = mask = 0\\n        freq = defaultdict(int, {0: 1})\\n        for ch in word: \\n            mask ^= 1 << ord(ch)-97\\n            ans += freq[mask]\\n            for i in range(10): ans += freq[mask ^ 1 << i]\\n            freq[mask] += 1\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1312448,
                "title": "java-commented-single-pass-using-bitmasks-and-xor",
                "content": "I did not find lot of good explanation about this question. \\nAdded some comments in code to explain whats going on. \\n\\n```\\nclass Solution {\\n    public long wonderfulSubstrings(String word) {\\n        long result = 0l;\\n        int mask = 0;\\n        // the count array contains the number of times a particualr mask value is seen until now. \\n        // Why size of 1024? Because we have 10 char allowed - a to j, so maximum value of mask can be 2^10 =1024.\\n        // Eg: mask value 0, 1, 2, 3, 4, .. 1023.. each corresponding to a-j\\n              // 9 8 7 6 5 4 3 2 1 0\\n              // j i h g f e d c b a\\n   //max value = 1 1 1 1 1 1 1 1 1 1\\n        // = 2^10 = 1024\\n        int[] count = new int[1024];\\n        \\n        // also set count[0] = 1, to represent empty string, mask 0 happened once.\\n        count[0] = 1;\\n        \\n        // iterate over each char one pass, and \\n        // a) find mask value at current position\\n        // b) count substrings with all even occurences\\n        // c) count substrings with just 1 odd occurence\\n\\t\\t// d) update count array to increment the number of occurence we saw the mask by 1\\n        for(char c: word.toCharArray()) {\\n            // for even count substrings\\n            mask = mask ^ (1 << c - \\'a\\');\\n            result = result + count[mask];\\n            // for max 1 odd count substrings\\n            for(int i = 0; i < 10; i++) {\\n                // lets see if we have seen substrings with 1 odd char count (a-j)\\n                result = result + count[mask^ (1<<i)];\\n            }\\n            \\n            // update count array that we have seen mask=m now\\n            count[mask]++;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long wonderfulSubstrings(String word) {\\n        long result = 0l;\\n        int mask = 0;\\n        // the count array contains the number of times a particualr mask value is seen until now. \\n        // Why size of 1024? Because we have 10 char allowed - a to j, so maximum value of mask can be 2^10 =1024.\\n        // Eg: mask value 0, 1, 2, 3, 4, .. 1023.. each corresponding to a-j\\n              // 9 8 7 6 5 4 3 2 1 0\\n              // j i h g f e d c b a\\n   //max value = 1 1 1 1 1 1 1 1 1 1\\n        // = 2^10 = 1024\\n        int[] count = new int[1024];\\n        \\n        // also set count[0] = 1, to represent empty string, mask 0 happened once.\\n        count[0] = 1;\\n        \\n        // iterate over each char one pass, and \\n        // a) find mask value at current position\\n        // b) count substrings with all even occurences\\n        // c) count substrings with just 1 odd occurence\\n\\t\\t// d) update count array to increment the number of occurence we saw the mask by 1\\n        for(char c: word.toCharArray()) {\\n            // for even count substrings\\n            mask = mask ^ (1 << c - \\'a\\');\\n            result = result + count[mask];\\n            // for max 1 odd count substrings\\n            for(int i = 0; i < 10; i++) {\\n                // lets see if we have seen substrings with 1 odd char count (a-j)\\n                result = result + count[mask^ (1<<i)];\\n            }\\n            \\n            // update count array that we have seen mask=m now\\n            count[mask]++;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1306777,
                "title": "extremely-easy-solution-with-explanation-c-parity-hashmap",
                "content": "Intuition::  \\n\\n:) I have made a string temp of length 10 since given string contains char from \\'a\\'\\n to \\'j\\'. Initialised temp with \"0000000000\" since initially no character has been counted.\\n \\n :) If from 0 to i-th index the count of any character is even then it will be represent by \\'0\\' and if it is odd then \\'1\\'. So each time we just have to do one flip corresponding to the character. \\n \\n :) There are two cases which satisfies the problem\\n      (1) when substring contains all characters with even count( so no odd count e.g. \"aabb\" ).\\n\\t  (2) when substring contains (k-1) characters with even count and 1 character with odd count.\\n:)\\n     (1) This condition can be met if we find the string same as temp already in the map.\\n\\t      e.g. let temp at i-th index =\"0010100110\". If we find same string in map with frequency  f, then             this means we have f substrings ending at i-th index and having all characters even time. So do             ans=ans+f.\\n\\t(2) This can be by flipping one bit of temp ans looking for it in map. So this how we ensure that all                characters appeared even time except the one for which we flipped the bit. Let f be the             frequency. Hence ans=ans+f.\\n\\t\\n\\tRemeber even-even =even and odd-odd =even. \\n\\t        \\n\\t\\t\\n```\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string word) {\\n      int len=word.length();\\n        unordered_map<string, int>mp; // key -> count string and value is it\\'s frequency.\\n        string temp=\"0000000000\";\\n        long long ans=0;\\n        mp[temp]=1;\\n        for(int i=0;i<len;i++)\\n        {\\n           temp[word[i]-\\'a\\']= temp[word[i]-\\'a\\']==\\'0\\'?\\'1\\':\\'0\\';\\n            if(mp.find(temp)!=mp.end())\\n            {\\n                ans+=mp[temp];\\n            }\\n            mp[temp]++;\\n            for(int j=0;j<10;j++)\\n            {\\n                string t=temp;\\n                t[j]=t[j]==\\'0\\'?\\'1\\':\\'0\\';\\n                if(mp.find(t)!=mp.end())\\n                    ans+=mp[t];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string word) {\\n      int len=word.length();\\n        unordered_map<string, int>mp; // key -> count string and value is it\\'s frequency.\\n        string temp=\"0000000000\";\\n        long long ans=0;\\n        mp[temp]=1;\\n        for(int i=0;i<len;i++)\\n        {\\n           temp[word[i]-\\'a\\']= temp[word[i]-\\'a\\']==\\'0\\'?\\'1\\':\\'0\\';\\n            if(mp.find(temp)!=mp.end())\\n            {\\n                ans+=mp[temp];\\n            }\\n            mp[temp]++;\\n            for(int j=0;j<10;j++)\\n            {\\n                string t=temp;\\n                t[j]=t[j]==\\'0\\'?\\'1\\':\\'0\\';\\n                if(mp.find(t)!=mp.end())\\n                    ans+=mp[t];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1300877,
                "title": "python-o-n-solution-with-comments-prefix-sum-bit-mask",
                "content": "explaination for this   `res+=dp[curr ^(1<<i)]`.\\nIntuition :\\nThis was similar to solving the problem of finding the subarray of sum k. This can be solved using prefix sum concept . For example given an array a= [ 2, 3 ,4 ,5 ,10] and k=9, we can calculate running sum and store Its prefix sum array as dp=[2,5,9,14,24]. Here for a running sum \"rs =14 \" which occured at index j=3, we can check if \"rs - k=14-9=5\" is available in dp array. let\\'s say \"rs - k=5\" was available at index i=1 (i<j) then subarray a[i+1 : j ]=a[2:3] will sum upto k=9.\\n\\nNow coming to this problem, let\\'s say we want a subarray which gives 1000000000 and we have a \"curr\"  value( similar to running sum mentioned above ) so we should check if dp[ curr - 1000000000] . But since these are binary numbers dp[ curr - 1000000000] is equivalent to dp[ curr ^ 1000000000] --> dp[ curr^(1<<pos)] here pos=10. \\nThe reason for checking ``curr^1000000000`` was `curr ^ (curr^1000000000) = 1000000000 `.\\nSimilarily we want to check all other possibilities like 0100000000, 0010000000,... etc. All these cases corresponds to having one character with odd count and others with even count\\n\\n\\n```\\nclass Solution:\\n    def wonderfulSubstrings(self, word: str) -> int:\\n        \\n        # we are representing each char with a bit, 0 for count being even and 1 for odd\\n        # 10 char from a to j\\n        # array to store 2^10 numbers\\n        dp=[0]*1024\\n        \\n        # jihgfedcba -> 0000000000\\n        curr=0  # 000..(0-> 10 times) \\n        \\n        # since we are starting with curr as 0 make dp[0]=1\\n        dp[0]=1\\n        \\n        # result\\n        res=0\\n        \\n        for c in word:\\n            # 1<<i sets i th bit to 1 and else to 0\\n            # xor will toggle the bit\\n            curr^= (1<<(ord(c)-ord(\\'a\\')))\\n            \\n            # if curr occurred earlier at j and now at i then [j+1: i] has all zeroes\\n            # this was to count all zeroes case\\n            res+=dp[curr]\\n            \\n            # now to check if these 100000..,010000..,001.. cases  can be acheived using brute force\\n            # we want to see if curr ^ delta = 10000.. or 010000.. etc\\n            # curr^delta =1000... then\\n            # curr ^ 1000.. = delta\\n            \\n            for i in range(10):\\n                res+=dp[curr ^(1<<i)]      \\n               \\n            dp[curr]+=1       \\n            \\n        \\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def wonderfulSubstrings(self, word: str) -> int:\\n        \\n        # we are representing each char with a bit, 0 for count being even and 1 for odd\\n        # 10 char from a to j\\n        # array to store 2^10 numbers\\n        dp=[0]*1024\\n        \\n        # jihgfedcba -> 0000000000\\n        curr=0  # 000..(0-> 10 times) \\n        \\n        # since we are starting with curr as 0 make dp[0]=1\\n        dp[0]=1\\n        \\n        # result\\n        res=0\\n        \\n        for c in word:\\n            # 1<<i sets i th bit to 1 and else to 0\\n            # xor will toggle the bit\\n            curr^= (1<<(ord(c)-ord(\\'a\\')))\\n            \\n            # if curr occurred earlier at j and now at i then [j+1: i] has all zeroes\\n            # this was to count all zeroes case\\n            res+=dp[curr]\\n            \\n            # now to check if these 100000..,010000..,001.. cases  can be acheived using brute force\\n            # we want to see if curr ^ delta = 10000.. or 010000.. etc\\n            # curr^delta =1000... then\\n            # curr ^ 1000.. = delta\\n            \\n            for i in range(10):\\n                res+=dp[curr ^(1<<i)]      \\n               \\n            dp[curr]+=1       \\n            \\n        \\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1299533,
                "title": "simple-o-n-solution-using-bitmasks",
                "content": "```\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string s) {\\n        \\n        int mod = 1023;\\n        long long ans = 0;\\n        int n = s.length();\\n        unordered_map<int, long long> mp;\\n        mp[0] = 1;\\n        int x = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            x^= (1<<(s[i]-\\'a\\'));\\n            \\n            for(int j = 0; j < 10; j++)\\n            {\\n                int w = (1<< j);\\n                ans+= mp[x^w];\\n            }\\n            ans+= mp[x];\\n            \\n            mp[x]++;\\n                \\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string s) {\\n        \\n        int mod = 1023;\\n        long long ans = 0;\\n        int n = s.length();\\n        unordered_map<int, long long> mp;\\n        mp[0] = 1;\\n        int x = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            x^= (1<<(s[i]-\\'a\\'));\\n            \\n            for(int j = 0; j < 10; j++)\\n            {\\n                int w = (1<< j);\\n                ans+= mp[x^w];\\n            }\\n            ans+= mp[x];\\n            \\n            mp[x]++;\\n                \\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2340404,
                "title": "beats-100-other-s-solutions",
                "content": "```\\nclass Solution:\\n    def wonderfulSubstrings(self, word: str) -> int:\\n        c = Counter(accumulate((1 << (ord(ch) - 97) for ch in word), xor, initial = 0))\\n        out = 0\\n        for k in c:\\n            temp = c[k] - 1\\n            for mask in range(10):\\n                if (kk := k ^ (1 << mask)) in c:\\n                    temp += c[kk]\\n            out += temp * c[k]\\n        return out // 2\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def wonderfulSubstrings(self, word: str) -> int:\\n        c = Counter(accumulate((1 << (ord(ch) - 97) for ch in word), xor, initial = 0))\\n        out = 0\\n        for k in c:\\n            temp = c[k] - 1\\n            for mask in range(10):\\n                if (kk := k ^ (1 << mask)) in c:\\n                    temp += c[kk]\\n            out += temp * c[k]\\n        return out // 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1299610,
                "title": "java-prefix-bitmap-hashmap",
                "content": "```\\nclass Solution {\\n    public long wonderfulSubstrings(String word) {\\n        //hashmap, for each index i, we can have something about [0, i]\\n        //and we also know about [0, j] where j < i\\n        //can we get something out of this and calcualte how many ending at i\\n        //for each index, we record the odd and even for each letter\\n        //we can encode this information with binary number of length 10\\n        //key is binary number of length 10 and value is count\\n        Map<Integer, Long> map = new HashMap<>();\\n        map.put(0, 1L);\\n        long res = 0;\\n        int cur = 0;\\n        for (char c : word.toCharArray()) {\\n            cur = cur ^ (1 << (c-\\'a\\'));\\n            res += map.getOrDefault(cur, 0L);\\n            for (int i = 0; i < 10; i++) {\\n                cur = cur ^ (1 << i);\\n                res += map.getOrDefault(cur, 0L);\\n                cur = cur ^ (1 << i);\\n            }\\n            map.put(cur, map.getOrDefault(cur, 0L)+1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long wonderfulSubstrings(String word) {\\n        //hashmap, for each index i, we can have something about [0, i]\\n        //and we also know about [0, j] where j < i\\n        //can we get something out of this and calcualte how many ending at i\\n        //for each index, we record the odd and even for each letter\\n        //we can encode this information with binary number of length 10\\n        //key is binary number of length 10 and value is count\\n        Map<Integer, Long> map = new HashMap<>();\\n        map.put(0, 1L);\\n        long res = 0;\\n        int cur = 0;\\n        for (char c : word.toCharArray()) {\\n            cur = cur ^ (1 << (c-\\'a\\'));\\n            res += map.getOrDefault(cur, 0L);\\n            for (int i = 0; i < 10; i++) {\\n                cur = cur ^ (1 << i);\\n                res += map.getOrDefault(cur, 0L);\\n                cur = cur ^ (1 << i);\\n            }\\n            map.put(cur, map.getOrDefault(cur, 0L)+1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1311485,
                "title": "c-commented",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string word) {\\n        // used to store occurence of  mask of letter\\n        int count[1024]{};\\n        long long res = 0 , running = 0;  // res  will store total substring  , running will store current mask of substring\\n        count[0] = 1;\\n        \\n        for(auto &ch : word){\\n            \\n            // masking letter by shifting 1 to the left ith distance\\n            running = running^(1<<(ch-\\'a\\'));\\n            \\n            //calculating res if this mask appear before , also updating count of mask in count map\\n            res += count[running]++;\\n            \\n            //now need to see if there is some odd no of occurence of letter , in the current range\\'\\n            // that will give some more substrings\\n            // we will go for mask of each letter and xor with running mask to get the  \\n            // no of occurence of such mask .\\n            for(int i=0;i<10;i++){\\n\\t\\t\\n                res += count[running ^ (1<<i)];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string word) {\\n        // used to store occurence of  mask of letter\\n        int count[1024]{};\\n        long long res = 0 , running = 0;  // res  will store total substring  , running will store current mask of substring\\n        count[0] = 1;\\n        \\n        for(auto &ch : word){\\n            \\n            // masking letter by shifting 1 to the left ith distance\\n            running = running^(1<<(ch-\\'a\\'));\\n            \\n            //calculating res if this mask appear before , also updating count of mask in count map\\n            res += count[running]++;\\n            \\n            //now need to see if there is some odd no of occurence of letter , in the current range\\'\\n            // that will give some more substrings\\n            // we will go for mask of each letter and xor with running mask to get the  \\n            // no of occurence of such mask .\\n            for(int i=0;i<10;i++){\\n\\t\\t\\n                res += count[running ^ (1<<i)];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1300930,
                "title": "c-bitmask",
                "content": "```\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string word) {\\n        int n=word.length();\\n        int mask=0;\\n        unordered_map<int,int>m;\\n        m[0]++;\\n        long long int ans=0;\\n        for(int i=0;i<n;i++){\\n            mask = mask^(1<<(word[i]-\\'a\\'));\\n            int temp=mask;\\n            int j=0;\\n            while(j<=9){\\n               int x=temp^(1<<j);\\n                ans+=m[x];\\n                j++;\\n                \\n            }\\n            ans+=m[mask];\\n            m[mask]++;\\n        }\\n        \\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string word) {\\n        int n=word.length();\\n        int mask=0;\\n        unordered_map<int,int>m;\\n        m[0]++;\\n        long long int ans=0;\\n        for(int i=0;i<n;i++){\\n            mask = mask^(1<<(word[i]-\\'a\\'));\\n            int temp=mask;\\n            int j=0;\\n            while(j<=9){\\n               int x=temp^(1<<j);\\n                ans+=m[x];\\n                j++;\\n                \\n            }\\n            ans+=m[mask];\\n            m[mask]++;\\n        }\\n        \\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1945704,
                "title": "c-bitmask-time-complexity-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string word) {\\n        // unordered_map keeps the count of all the bitmask values seen so far\\n        unordered_map<int,int> m;\\n        int n = word.size();\\n        int mask = 0;\\n        long long cnt = 0;\\n        // when no character is taken (It is to be done for counting prefix string)\\n        m[0]++;\\n        for(int i = 0; i < n; i++){\\n            int cur = word[i]-\\'a\\';\\n            mask ^= (1<<cur);\\n            // Counting strings where all character appear even times\\n            if(m.count(mask)){\\n                cnt += m[mask];\\n            }\\n            // Counintg strings where exactly 1 character appear odd times\\n            for(int j = 0; j <= 9; j++){\\n                int temp = mask ^ (1<<j);\\n                if(m.count(temp)){\\n                    cnt  += m[temp];\\n                }\\n            }\\n            // Adding the current mask to the unordered_map\\n            m[mask]++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string word) {\\n        // unordered_map keeps the count of all the bitmask values seen so far\\n        unordered_map<int,int> m;\\n        int n = word.size();\\n        int mask = 0;\\n        long long cnt = 0;\\n        // when no character is taken (It is to be done for counting prefix string)\\n        m[0]++;\\n        for(int i = 0; i < n; i++){\\n            int cur = word[i]-\\'a\\';\\n            mask ^= (1<<cur);\\n            // Counting strings where all character appear even times\\n            if(m.count(mask)){\\n                cnt += m[mask];\\n            }\\n            // Counintg strings where exactly 1 character appear odd times\\n            for(int j = 0; j <= 9; j++){\\n                int temp = mask ^ (1<<j);\\n                if(m.count(temp)){\\n                    cnt  += m[temp];\\n                }\\n            }\\n            // Adding the current mask to the unordered_map\\n            m[mask]++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1301686,
                "title": "simplest-c-code",
                "content": "```\\nlong long wonderfulSubstrings(string word) {\\n\\n\\tint cnt[1 << 10] = {0};\\n\\tint idx = 0;\\n\\n\\tlong long res = 0;\\n\\n\\tfor (char& c : word) {\\n\\n\\t\\tcnt[idx]++;\\n\\n\\t\\tidx ^= (1 << (c - \\'a\\'));\\n\\n\\t\\tres += cnt[idx];\\n\\t\\tfor (int i = 0; i < 10; ++i) {\\n\\t\\t\\tres += cnt[idx ^ (1 << i)];\\n\\t\\t}\\n\\n\\t}\\n\\n\\treturn res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nlong long wonderfulSubstrings(string word) {\\n\\n\\tint cnt[1 << 10] = {0};\\n\\tint idx = 0;\\n\\n\\tlong long res = 0;\\n\\n\\tfor (char& c : word) {\\n\\n\\t\\tcnt[idx]++;\\n\\n\\t\\tidx ^= (1 << (c - \\'a\\'));\\n\\n\\t\\tres += cnt[idx];\\n\\t\\tfor (int i = 0; i < 10; ++i) {\\n\\t\\t\\tres += cnt[idx ^ (1 << i)];\\n\\t\\t}\\n\\n\\t}\\n\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1299801,
                "title": "step-by-step-detailed-table-explanation-of-bitmask-idea",
                "content": "I spent some time looking at the solutions posted and finally got the idea by drawing a table using `\\'aabb\\'` as an example:\\n\\n```\\n//          11 10 01 00  Even Odd  Total\\n// 1  init  0   0  0  1\\n// 2  a            X      0    1    1\\n// 3  MU    0   0  1  1\\n// 4  aa              X   1    1    2\\n// 5  MU    0   0  1  2\\n// 6  aab       X         0    2    2\\n// 7  MU    0   1  1  2\\n// 8  aabb            X   2    2    4\\n// 9  final 0   1  1  3   3    6    9\\n```\\n\\ncolumn names:\\n- `11`,`10`, etc represents the count of each bitmask we have seen (`maskCount` array)\\n- `Even`,`Odd`, `Total`  represents new even counts (no odd occurrences), odd counts (1 odd occurrence) and total counts added\\n\\nFor each letter, we break it up into two stages:\\n- first stage corresponds to rows `2,4,6,8` where we take the letter, calculate the new counts using the letter\\'s bitmask and `maskCount` from previous row. example:\\n\\t- in row 2, we have letter `a` corresponding to `01` bitmask, which can be a valid substring by mutating the existing `00` bitmask. This is considered **1 odd count**. The total count is 1.\\n\\t- in row 4, we have letter `a` again and the whole prefix `aa` correspond to `00` bitmask, which is **1 even count** since we have seen it before (empty state). It also differs from previous bitmask `01` by 1, meaning it can turn previous `01` bitmasks (odd strings) into valid substring.\\n\\t\\t- This is similar to prefix sum idea: we take the difference betwen current \\'aa\\' string and the previous \\'a\\' string, resulting in a new \\'a\\' string (\\'a**a**\\', we got the bold part). This second new \\'a\\' string is the valid substring that we are looking for.\\n\\t\\t- There is 1 previous `01` so we have **1 odd count**. In total there are two counts.\\n\\t\\t- let\\'s say we have \\'aaaa\\', then the two odd counts would be we have \\'a**aaa**\\' and \\'aaa**a**\\'.\\n- second stage corresponds to rows `3,5,7` where we do a mask update (`MU`) of previous `maskCount`. example:\\n  - in row 3, we mutate the `maskCount` from row 1 to add the letter `a`\\'s bitmask `01` from row 2.\\n\\nEventually when we reach the end, the answer is just the total number of counts added.\\n\\nCode for reference:\\n```js\\nvar wonderfulSubstrings = function (word) {\\n  let mask = 0;\\n  let maskCount = Array(1024).fill(0);\\n  maskCount[0] = 1;\\n  let total = 0;\\n  for (let i = 0; i < word.length; i++) {\\n    const c = word[i];\\n    mask ^= 1 << (c.charCodeAt(0) - 97);\\n    total += maskCount[mask];\\n    for (let j = 0; j < 10; j++) {\\n      total += maskCount[mask ^ (1 << j)];\\n    }\\n    maskCount[mask] += 1;\\n  }\\n  return total;\\n};\\n```",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "```\\n//          11 10 01 00  Even Odd  Total\\n// 1  init  0   0  0  1\\n// 2  a            X      0    1    1\\n// 3  MU    0   0  1  1\\n// 4  aa              X   1    1    2\\n// 5  MU    0   0  1  2\\n// 6  aab       X         0    2    2\\n// 7  MU    0   1  1  2\\n// 8  aabb            X   2    2    4\\n// 9  final 0   1  1  3   3    6    9\\n```\n```js\\nvar wonderfulSubstrings = function (word) {\\n  let mask = 0;\\n  let maskCount = Array(1024).fill(0);\\n  maskCount[0] = 1;\\n  let total = 0;\\n  for (let i = 0; i < word.length; i++) {\\n    const c = word[i];\\n    mask ^= 1 << (c.charCodeAt(0) - 97);\\n    total += maskCount[mask];\\n    for (let j = 0; j < 10; j++) {\\n      total += maskCount[mask ^ (1 << j)];\\n    }\\n    maskCount[mask] += 1;\\n  }\\n  return total;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1299620,
                "title": "1e8-tle",
                "content": "Leetcode can\\'t run 1e8 in one second?\\n``` c++\\nclass Solution {\\npublic:\\n    long long dp[2][1024];\\n    long long wonderfulSubstrings(string word) {\\n        int M=0;\\n        for(int i=0;i<word.size();i++){\\n            M=max(M,1<<(word[i]-\\'a\\'+1));\\n        }\\n        dp[0][1<<(word[0]-\\'a\\')]=1;\\n        long long ans=1;\\n        for(int i=1;i<word.size();i++){\\n            dp[(i-1)&1][0]+=1;\\n            for(int mask=0;mask<M;mask++){\\n                int newMask=(1<<(word[i]-\\'a\\'))^mask;\\n                dp[i&1][newMask]=dp[(i-1)&1][mask];           \\n            }\\n            ans+=dp[i&1][0];\\n            for(int m=0;(1<<m)<M;m++){\\n                 ans+=dp[i&1][1<<m];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "``` c++\\nclass Solution {\\npublic:\\n    long long dp[2][1024];\\n    long long wonderfulSubstrings(string word) {\\n        int M=0;\\n        for(int i=0;i<word.size();i++){\\n            M=max(M,1<<(word[i]-\\'a\\'+1));\\n        }\\n        dp[0][1<<(word[0]-\\'a\\')]=1;\\n        long long ans=1;\\n        for(int i=1;i<word.size();i++){\\n            dp[(i-1)&1][0]+=1;\\n            for(int mask=0;mask<M;mask++){\\n                int newMask=(1<<(word[i]-\\'a\\'))^mask;\\n                dp[i&1][newMask]=dp[(i-1)&1][mask];           \\n            }\\n            ans+=dp[i&1][0];\\n            for(int m=0;(1<<m)<M;m++){\\n                 ans+=dp[i&1][1<<m];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953977,
                "title": "python-3-bitmask-o-n-o-1",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def wonderfulSubstrings(self, word: str) -> int:\\n        seen = defaultdict(int)\\n        seen[0] += 1\\n        ans = 0\\n        mask = 0\\n        for c in word:\\n            mask ^= (1 << (ord(c) - ord(\\'a\\')))\\n            ans += seen[mask]\\n            for i in range(ord(\\'j\\') - ord(\\'a\\') + 1):\\n                ans += seen[mask ^ (1 << i)]\\n            seen[mask] += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def wonderfulSubstrings(self, word: str) -> int:\\n        seen = defaultdict(int)\\n        seen[0] += 1\\n        ans = 0\\n        mask = 0\\n        for c in word:\\n            mask ^= (1 << (ord(c) - ord(\\'a\\')))\\n            ans += seen[mask]\\n            for i in range(ord(\\'j\\') - ord(\\'a\\') + 1):\\n                ans += seen[mask ^ (1 << i)]\\n            seen[mask] += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3554223,
                "title": "rust-python-linear-with-masking-and-very-detailed-explanation",
                "content": "# Intuition\\nAs we are speaking about at most 1 character of of odd size, then all that we care is prefix sum modulo 2. Lets look at this string `aabacacabc`. If we are going to generate that prefix-sum-modulo-2, the genaration will look like this:\\n\\n```\\n    | 0 1 2 3 4 5 6 7 8 9\\n    | a a b a c a c a b c\\n----|--------------------\\na 0 | 1 0 0 1 1 0 0 1 1 1\\nb 0 | 0 0 1 1 1 1 1 1 0 0\\nc 0 | 0 0 0 0 1 1 0 0 0 1\\n```\\n\\nWe will not need all this table and we will maintain it in a streaming way. So at a step 7, our prefix sum will be `1 1 0`. Notice that because the numbers in this prefix sum are only 0/1, we can compactly represent it as a binary number (which can be at most 2^3 in our case and 2^10 in general). To compactly calcualte it we can use `prefix ^= 1 << (ord(c) - 97)` as we change the bit of a specific position.\\n\\nLets look at this 7-th step and the value becomes: `b110`. Now because of the requirement: **at most one letter appears an odd number of times**, this means that we can have:\\n - 0 letters of odd time. For this position to have zero odd letters, you need to see how many times this specific position was seen so far\\n - 1 letter which will appear odd time. To have only number we need to add 3 possible values (`010`, `100`, `111`)\\n\\nIn general case:\\n - `cnt[prefix]` for zero odd letter\\n - `cnt[prefix ^ (1 << i)]` where i is from 0 to 10, for 1 odd letter\\n\\nThis gives a full solution.\\n\\n# Complexity\\n\\nLet the size of alphabet is $A$ and the lenght of the string $n$. In our case $A = 10$.\\n\\n- Time complexity: $O(2^A)$. Which is $1024 = O(1)$\\n- Space complexity: $O(n \\\\cdot A)$. Which is $10 * O(n) = O(n)$\\n\\n# Code\\n```Rust []\\nimpl Solution {\\n  pub fn wonderful_substrings(word: String) -> i64 {\\n    let mut cnt: [i64; 1024] = [0; 1024];\\n    let (mut total, mut prefix) = (0, 0);\\n    cnt[0] = 1;\\n\\n    for c in word.bytes() {\\n      prefix ^= (1 << (c - 97)) as usize;\\n      total += cnt[prefix];\\n      for i in 0 .. 10 {\\n        total += cnt[prefix ^ (1 << i)];\\n      }\\n      cnt[prefix] += 1;\\n    }\\n    return total;\\n  }\\n}\\n```\\n```python []\\nclass Solution:\\n  def wonderfulSubstrings(self, word: str) -> int:\\n    cnt, total, prefix = [0] * 1024, 0, 0\\n    cnt[0] = 1\\n\\n    for c in word:\\n      prefix ^= 1 << (ord(c) - 97)\\n      total += cnt[prefix]\\n      for i in range(10):\\n        total += cnt[prefix ^ (1 << i)]\\n      cnt[prefix] += 1\\n    \\n    return total\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Rust"
                ],
                "code": "```\\n    | 0 1 2 3 4 5 6 7 8 9\\n    | a a b a c a c a b c\\n----|--------------------\\na 0 | 1 0 0 1 1 0 0 1 1 1\\nb 0 | 0 0 1 1 1 1 1 1 0 0\\nc 0 | 0 0 0 0 1 1 0 0 0 1\\n```\n```Rust []\\nimpl Solution {\\n  pub fn wonderful_substrings(word: String) -> i64 {\\n    let mut cnt: [i64; 1024] = [0; 1024];\\n    let (mut total, mut prefix) = (0, 0);\\n    cnt[0] = 1;\\n\\n    for c in word.bytes() {\\n      prefix ^= (1 << (c - 97)) as usize;\\n      total += cnt[prefix];\\n      for i in 0 .. 10 {\\n        total += cnt[prefix ^ (1 << i)];\\n      }\\n      cnt[prefix] += 1;\\n    }\\n    return total;\\n  }\\n}\\n```\n```python []\\nclass Solution:\\n  def wonderfulSubstrings(self, word: str) -> int:\\n    cnt, total, prefix = [0] * 1024, 0, 0\\n    cnt[0] = 1\\n\\n    for c in word:\\n      prefix ^= 1 << (ord(c) - 97)\\n      total += cnt[prefix]\\n      for i in range(10):\\n        total += cnt[prefix ^ (1 << i)]\\n      cnt[prefix] += 1\\n    \\n    return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2689831,
                "title": "python-solution-faster-90",
                "content": "\\tclass Solution:\\n\\t\\tdef wonderfulSubstrings(self, word: str) -> int:\\n\\t\\t\\tmask = 0\\n\\t\\t\\tmask_count = [0] * 1024\\n\\t\\t\\tmask_count[mask] += 1\\n\\t\\t\\tres = 0\\n\\n\\t\\t\\tfor letter in word:\\n\\t\\t\\t\\tmask ^= 1 << ord(letter) - ord(\"a\")\\n\\t\\t\\t\\tres += mask_count[mask]\\n\\t\\t\\t\\tfor i in range(10):\\n\\t\\t\\t\\t\\tres += mask_count[mask ^ 1 << i]\\n\\t\\t\\t\\tmask_count[mask] += 1\\n\\t\\t\\treturn res",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef wonderfulSubstrings(self, word: str) -> int:\\n\\t\\t\\tmask = 0\\n\\t\\t\\tmask_count = [0] * 1024\\n\\t\\t\\tmask_count[mask] += 1\\n\\t\\t\\tres = 0\\n\\n\\t\\t\\tfor letter in word:\\n\\t\\t\\t\\tmask ^= 1 << ord(letter) - ord(\"a\")\\n\\t\\t\\t\\tres += mask_count[mask]\\n\\t\\t\\t\\tfor i in range(10):\\n\\t\\t\\t\\t\\tres += mask_count[mask ^ 1 << i]\\n\\t\\t\\t\\tmask_count[mask] += 1\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 2542389,
                "title": "c-bitmask-prefix-sum-with-explanation-and-clean-code",
                "content": "**Time Complexity:** O(N)\\n**Space Complexity:** O(N)\\n\\n```\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string word) {\\n        const int N = word.size();\\n        unordered_map<int,int> maskCnt;\\n        \\n        \\n        long long ans = 0;\\n        // It is a 10 bit long integer. We are representing a ->0 , b ->1 ...\\n        // If the ith character is odd then the i th bit is 1 else it is 0\\n        // For example , 0000000010 means b occurs odd time, and rest occur even times\\n        int mask = 0;\\n        maskCnt[0] = 1;\\n \\n        for(int i = 0;i<N;i++){\\n            \\n            //We are counting frequency of the prefix\\n            // Suppose, If we already had even number of a, then adding it to current prefic \\n            // will make it odd.\\n            // xor operator flips the 0 -> 1 and 1 -> 0\\n            mask ^= (1<<(word[i]-\\'a\\'));\\n          \\n            // If two prefixes (lets say at l and r) have same mask then it means the substring s[l .. r] have even occurences of all characters. So it is a valid answer\\n            // l = 0000010010 and r = 0000010010 . If we subtract, we get 0. Which shows all numbers occur even times \\n            \\n            ans+=maskCnt[mask];\\n            \\n            // If we flip one bit then it means that there is odd occurence of a character\\n            // That is why we can flip at most one bit\\n            for(int i = 0;i<10;i++)\\n                ans += maskCnt[mask^(1<<i)];\\n            \\n              maskCnt[mask]++;\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string word) {\\n        const int N = word.size();\\n        unordered_map<int,int> maskCnt;\\n        \\n        \\n        long long ans = 0;\\n        // It is a 10 bit long integer. We are representing a ->0 , b ->1 ...\\n        // If the ith character is odd then the i th bit is 1 else it is 0\\n        // For example , 0000000010 means b occurs odd time, and rest occur even times\\n        int mask = 0;\\n        maskCnt[0] = 1;\\n \\n        for(int i = 0;i<N;i++){\\n            \\n            //We are counting frequency of the prefix\\n            // Suppose, If we already had even number of a, then adding it to current prefic \\n            // will make it odd.\\n            // xor operator flips the 0 -> 1 and 1 -> 0\\n            mask ^= (1<<(word[i]-\\'a\\'));\\n          \\n            // If two prefixes (lets say at l and r) have same mask then it means the substring s[l .. r] have even occurences of all characters. So it is a valid answer\\n            // l = 0000010010 and r = 0000010010 . If we subtract, we get 0. Which shows all numbers occur even times \\n            \\n            ans+=maskCnt[mask];\\n            \\n            // If we flip one bit then it means that there is odd occurence of a character\\n            // That is why we can flip at most one bit\\n            for(int i = 0;i<10;i++)\\n                ans += maskCnt[mask^(1<<i)];\\n            \\n              maskCnt[mask]++;\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1501383,
                "title": "dp-bitmask",
                "content": "If ith bit is set it means that the particular character has occured odd number of times and if the ith bit is 0 it means that particular bit has occured even no of times.\\n\\n```\\n#define ll long long int\\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\\nclass Solution {\\npublic:\\n    ll wonderfulSubstrings(string s) {\\n        IOS;\\n        int i,n=s.length(),state=0,dp[1030];\\n        memset(dp,0,sizeof(dp));\\n        int pw2[11];\\n        pw2[0]=1;\\n        for(i=1;i<11;i++)\\n            pw2[i]=pw2[i-1]<<1;\\n        \\n        dp[state]=1; // when no alphabet is taken i.e empty string\\n        ll ans=0;\\n\\t\\t\\n\\t\\t// for every ith index we are finding the number of left indices that satisfy the constraints\\n        for(int i=0;i<n;i++){\\n            state=state^pw2[s[i]-\\'a\\'];\\n            ans+=dp[state]; // if we want all characters to be even\\n            int temp=state;\\n            for(int j=0;j<10;j++){\\n                temp=temp^pw2[j];\\n                ans=ans+dp[temp]; // if we want jth character to be odd and rest to be even\\n                temp=temp^pw2[j];\\n            }\\n            dp[state]++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\n#define ll long long int\\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\\nclass Solution {\\npublic:\\n    ll wonderfulSubstrings(string s) {\\n        IOS;\\n        int i,n=s.length(),state=0,dp[1030];\\n        memset(dp,0,sizeof(dp));\\n        int pw2[11];\\n        pw2[0]=1;\\n        for(i=1;i<11;i++)\\n            pw2[i]=pw2[i-1]<<1;\\n        \\n        dp[state]=1; // when no alphabet is taken i.e empty string\\n        ll ans=0;\\n\\t\\t\\n\\t\\t// for every ith index we are finding the number of left indices that satisfy the constraints\\n        for(int i=0;i<n;i++){\\n            state=state^pw2[s[i]-\\'a\\'];\\n            ans+=dp[state]; // if we want all characters to be even\\n            int temp=state;\\n            for(int j=0;j<10;j++){\\n                temp=temp^pw2[j];\\n                ans=ans+dp[temp]; // if we want jth character to be odd and rest to be even\\n                temp=temp^pw2[j];\\n            }\\n            dp[state]++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1405968,
                "title": "java-bit-mask",
                "content": "```\\n\\tpublic long wonderfulSubstrings(String word) {     \\n        long res = 0;\\n        int mask = 0;\\n        long[] cnt = new long[1024];\\n        cnt[mask] = 1; // We have seen 0 state once to start with\\n        \\n        for(char ch: word.toCharArray()){\\n            mask = mask ^ (1 << (ch - \\'a\\')); // Flip the ith bit as per char\\n            res += cnt[mask];// Collect answer if we have seen similar mask before, which means there is a substring in between with only even occurence of characters\\n            \\n            for(int n= 0; n < 10;n++){//Try checking all cnt index with just 1 bit differ from current mask, to find any substring with just 1 bit flipped/one letter appearing odd number of times\\n                res += cnt[mask ^ (1 << n)];\\n                \\n            }\\n            \\n            cnt[mask] += 1;// Update current state count\\n        }\\n        return res;\\n    }\\n```\\nReferenced from other solutions\\nTime: O(10n) = O(n). We iterate over entire word at each iteration we add substring counts for the characters a to j to be odd in count.\\nSpace: O(2^10) = O(1024) = O(1). We can store at most all combinations of parities of a to j which is 2^10.",
                "solutionTags": [],
                "code": "```\\n\\tpublic long wonderfulSubstrings(String word) {     \\n        long res = 0;\\n        int mask = 0;\\n        long[] cnt = new long[1024];\\n        cnt[mask] = 1; // We have seen 0 state once to start with\\n        \\n        for(char ch: word.toCharArray()){\\n            mask = mask ^ (1 << (ch - \\'a\\')); // Flip the ith bit as per char\\n            res += cnt[mask];// Collect answer if we have seen similar mask before, which means there is a substring in between with only even occurence of characters\\n            \\n            for(int n= 0; n < 10;n++){//Try checking all cnt index with just 1 bit differ from current mask, to find any substring with just 1 bit flipped/one letter appearing odd number of times\\n                res += cnt[mask ^ (1 << n)];\\n                \\n            }\\n            \\n            cnt[mask] += 1;// Update current state count\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1389106,
                "title": "c-bitmasking",
                "content": "This is a typical use of bitmasks. The idea is like this: we use a bitmask to indicate what characters are used odd number of times, and we use a hashmap to keep track of previously seen bitmasks.\\n\\nFor example, let\\'s consider the example \"aba\".\\n\\n\"\" -> bitmask will be 0000000000 (\\'a\\' - \\'j\\' 10 characters as specified in the problem)\\n\"a\" -> bitmask will be 0000000001, meaning a is used odd number of times\\n\"ab\" -> bitmask will now be 0000000011, meaning both a and b are used odd number of times.\\n\"aba\" -> bitmask will be 0000000010. \\n\\nIn each iteration, we will increment the hashmap[bitmask] by one, meaning we have seen this bitmask before. \\n\\n```ans += seen[mask];``` will count the substrings that have all letters used even number of times.\\n```ans += seen[mask ^ (1<<j)]; ``` will count the substrings that have exactly 1 letter that is used odd number of times.\\n\\nTime complexity will be O(10N) = O(N).\\n\\n```cpp\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string word) {\\n        unordered_map<int, int> seen;\\n        seen[0] = 1;\\n        int mask = 0;\\n        long long ans = 0;\\n        for (int i = 0; i < word.length(); ++i){\\n            mask ^= (1 << (word[i] - \\'a\\'));\\n            ans += seen[mask];\\n            for (int j = 0; j < 10; ++j){\\n                ans += seen[mask ^ (1<<j)];\\n            }\\n            seen[mask]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```ans += seen[mask];```\n```ans += seen[mask ^ (1<<j)]; ```\n```cpp\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string word) {\\n        unordered_map<int, int> seen;\\n        seen[0] = 1;\\n        int mask = 0;\\n        long long ans = 0;\\n        for (int i = 0; i < word.length(); ++i){\\n            mask ^= (1 << (word[i] - \\'a\\'));\\n            ans += seen[mask];\\n            for (int j = 0; j < 10; ++j){\\n                ans += seen[mask ^ (1<<j)];\\n            }\\n            seen[mask]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1362200,
                "title": "simple-o-n-xor-solution",
                "content": "As the hint says - \\n* For each prefix of the string, check which characters are of even frequency and which are not and represent it by a bitmask.\\n* Find the other prefixes whose masks differs from the current prefix mask by at most one bit.\\n\\nTo find other prefixes whose masks differs from the current prefix mask by at most one bit, we loop through the string and at any index, xor each bit.\\n```\\nclass Solution {\\n    public long wonderfulSubstrings(String word) {\\n        long[] dp = new long[(int)Math.pow(2,10)];\\n        long sum = 0;\\n        int curr = 0;\\n        dp[0] = 1;\\n        for(int i=0;i<word.length();i++){\\n            curr = curr ^ (1<<(word.charAt(i)-\\'a\\'));\\n            sum += dp[curr];\\n            dp[curr]++;\\n            for(int j=0;j<10;j++)\\n                sum += dp[curr ^ (1<<j)];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long wonderfulSubstrings(String word) {\\n        long[] dp = new long[(int)Math.pow(2,10)];\\n        long sum = 0;\\n        int curr = 0;\\n        dp[0] = 1;\\n        for(int i=0;i<word.length();i++){\\n            curr = curr ^ (1<<(word.charAt(i)-\\'a\\'));\\n            sum += dp[curr];\\n            dp[curr]++;\\n            for(int j=0;j<10;j++)\\n                sum += dp[curr ^ (1<<j)];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1356429,
                "title": "java-prefix-bitmasks-with-many-comments",
                "content": "The first solution gave me TLE with  \"70 / 88 test cases passed. \"\\nComplexity O(N * N * A), where N - number of charactres, A- alphabet size\\nMemory O(N * A)\\nIt\\'s based on prefix sums computation and checkup at substrings positions  whether total number of odd diff-sums for each character is less than 2 \\n```\\n   public long wonderfulSubstrings(String word) {\\n        char[] ch = word.toCharArray();\\n        int len = ch.length;\\n        int[][] count = new int[len+1][\\'j\\'-\\'a\\'+1];\\n        int res=0;\\n\\n        for(int i=0;i<len;i++){\\n            for(char c=\\'a\\';c<=\\'j\\';c++)\\n                 count[i+1][c-\\'a\\']=count[i][c-\\'a\\'];    \\n\\n            count[i+1][ch[i]-\\'a\\']++;\\n        }\\n        \\n        for(int i=0;i<len;i++)\\n            for(int j=i;j<len;j++){\\n                int r=0;\\n                for(char c=\\'a\\';c<=\\'j\\' && r<=1;c++)\\n                    if((count[j+1][c-\\'a\\']-count[i][c-\\'a\\']&0x01)!=0)\\n                        r++;    \\n                \\n                if(r<=1)\\n                    res++;\\n            }\\n        return res;\\n```\\nAnother solution has complexity O(N * A), memory O(2^A)\\nOverall idea is similar to the first solution.\\nHowever instead of intermediate sum at any place,  let\\'s keep bitmask with info whether we faced each character odd or even times so far\\n```\\n    public long wonderfulSubstrings(String word) {\\n        long[] hashMap = new long[1<<\\'j\\'-\\'a\\'+1];  //store count of all faced bitmask combinations from 0b0000000000 to 0b1111111111\\n        long res=0;\\n        int bitMask=0;\\n        \\n        hashMap[0]=1;\\n        \\n        for(char ch : word.toCharArray()){\\n            bitMask ^= 1<<ch-\\'a\\'; //reverse corresponding bit with respect to the faced character\\n            //if we faced  the same bitmask once, that means substring between prev. bitmask and curr. bitmask contains only even number of changes for all characters \\'a\\' through \\'j\\'\\n            //if we faced the same bitmask two or more times, then let\\'s add all substrings started in prev. occurrences and finished at curr. occurrence\\n            //finally, increment bitmask we have just faced\\n            res += hashMap[bitMask]++;  \\n            \\n            //in the same manner, check all faced occurrences of bitmasks with just one odd bit difference\\n            //and count corresponding substrings started there and finished with current bitmask\\n            for(char c=\\'a\\';c<=\\'j\\';c++)\\n                res += hashMap[bitMask ^ 1<<c-\\'a\\'];\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n   public long wonderfulSubstrings(String word) {\\n        char[] ch = word.toCharArray();\\n        int len = ch.length;\\n        int[][] count = new int[len+1][\\'j\\'-\\'a\\'+1];\\n        int res=0;\\n\\n        for(int i=0;i<len;i++){\\n            for(char c=\\'a\\';c<=\\'j\\';c++)\\n                 count[i+1][c-\\'a\\']=count[i][c-\\'a\\'];    \\n\\n            count[i+1][ch[i]-\\'a\\']++;\\n        }\\n        \\n        for(int i=0;i<len;i++)\\n            for(int j=i;j<len;j++){\\n                int r=0;\\n                for(char c=\\'a\\';c<=\\'j\\' && r<=1;c++)\\n                    if((count[j+1][c-\\'a\\']-count[i][c-\\'a\\']&0x01)!=0)\\n                        r++;    \\n                \\n                if(r<=1)\\n                    res++;\\n            }\\n        return res;\\n```\n```\\n    public long wonderfulSubstrings(String word) {\\n        long[] hashMap = new long[1<<\\'j\\'-\\'a\\'+1];  //store count of all faced bitmask combinations from 0b0000000000 to 0b1111111111\\n        long res=0;\\n        int bitMask=0;\\n        \\n        hashMap[0]=1;\\n        \\n        for(char ch : word.toCharArray()){\\n            bitMask ^= 1<<ch-\\'a\\'; //reverse corresponding bit with respect to the faced character\\n            //if we faced  the same bitmask once, that means substring between prev. bitmask and curr. bitmask contains only even number of changes for all characters \\'a\\' through \\'j\\'\\n            //if we faced the same bitmask two or more times, then let\\'s add all substrings started in prev. occurrences and finished at curr. occurrence\\n            //finally, increment bitmask we have just faced\\n            res += hashMap[bitMask]++;  \\n            \\n            //in the same manner, check all faced occurrences of bitmasks with just one odd bit difference\\n            //and count corresponding substrings started there and finished with current bitmask\\n            for(char c=\\'a\\';c<=\\'j\\';c++)\\n                res += hashMap[bitMask ^ 1<<c-\\'a\\'];\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1338846,
                "title": "c-o-n-and-o-1-space-5-6-lines",
                "content": "```\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string s) {\\n        // O(N) Time complexity and O(1034)~O(1) space\\n        vector<int>count(1024,0);\\n        vector<int>keys={1,2,4,8,16,32,64,128,256,512};\\n        count[0]=1;\\n        long long ans=0;\\n        int stage=0,n=s.size();\\n        for(int i=0;i<n;i++){\\n            stage=stage^keys[s[i]-\\'a\\'];\\n            if(count[stage]!=0) ans+=count[stage];\\n            for(auto j: keys) if(count[stage^j]!=0) ans+=count[stage^j];\\n            count[stage]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string s) {\\n        // O(N) Time complexity and O(1034)~O(1) space\\n        vector<int>count(1024,0);\\n        vector<int>keys={1,2,4,8,16,32,64,128,256,512};\\n        count[0]=1;\\n        long long ans=0;\\n        int stage=0,n=s.size();\\n        for(int i=0;i<n;i++){\\n            stage=stage^keys[s[i]-\\'a\\'];\\n            if(count[stage]!=0) ans+=count[stage];\\n            for(auto j: keys) if(count[stage^j]!=0) ans+=count[stage^j];\\n            count[stage]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1302894,
                "title": "100-time-100-javascript-solution",
                "content": "Approach:\\n\\xA0 \\xA0 We know that there are only 10 different characters from a to j\\n\\xA0 \\xA0 We can represent frequency of characters in any such string with a 10 digit long binary number\\n\\xA0 \\xA0 Here ith digit will be 1 if number of occurrences of ith character is odd, it will be 0 otherwise. Example 0000000001 is binary representation for string which has odd number of \\'a\\'. \\n\\xA0 \\xA0 00000000011 is binary representation for string which has odd number of \\'b\\' and \\'a\\'. \\n\\xA0 \\xA0 \\n\\xA0 \\xA0 Now we will start traversal of string from left to right, in each step we will toggle ith digit in binaryRepresentation, as the frequency of the ith char will toggle in even and odd.\\n\\xA0 \\xA0 We will keep storing binaryRepresentation(bitmask) as key and frequency as value in a hashMap(map)\\n\\xA0 \\xA0 Each time will\\xA0check if the current binaryRepresentation or any other binaryRepresentation with a difference of 1 bit is there in the hashMap, if yes then we will add the frequency in the answer.\\n\\t\\n\\t\\n```\\n/**\\n * @param {string} word\\n * @return {number}\\n */\\nvar wonderfulSubstrings = function(word) {\\n    let hashMap={},ans=0,binaryRepresentation=0,t,pos,number,oneBitToggled;\\n    hashMap[0]=1;\\n    for(let i=0;i<word.length;i++){\\n        pos = word[i].charCodeAt(0)-\"a\".charCodeAt(0);//Let\\'s use position 0 for a, 1 for b .... 9 for j\\n        t = (1 << pos);\\n        binaryRepresentation = (binaryRepresentation^t);//Toggle the bit at pos in the current mask(pattern)\\n        //This loop will check same binaryRepresentation and all the other binaryRepresentation with difference of 1 bit\\n        for(let i=0;i<10;i++){//Check all the numbers by changing 1 position\\n            number = (1<<i);//Change 1 bit at a time \\n            oneBitToggled = (binaryRepresentation^number);\\n            if(hashMap[oneBitToggled]!==undefined){\\n                ans += hashMap[oneBitToggled];\\n            }\\n        }\\n        if(hashMap[binaryRepresentation]===undefined){\\n            hashMap[binaryRepresentation]=1;\\n        }else{\\n            ans += hashMap[binaryRepresentation];\\n            hashMap[binaryRepresentation]++;\\n        }\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bitmask"
                ],
                "code": "```\\n/**\\n * @param {string} word\\n * @return {number}\\n */\\nvar wonderfulSubstrings = function(word) {\\n    let hashMap={},ans=0,binaryRepresentation=0,t,pos,number,oneBitToggled;\\n    hashMap[0]=1;\\n    for(let i=0;i<word.length;i++){\\n        pos = word[i].charCodeAt(0)-\"a\".charCodeAt(0);//Let\\'s use position 0 for a, 1 for b .... 9 for j\\n        t = (1 << pos);\\n        binaryRepresentation = (binaryRepresentation^t);//Toggle the bit at pos in the current mask(pattern)\\n        //This loop will check same binaryRepresentation and all the other binaryRepresentation with difference of 1 bit\\n        for(let i=0;i<10;i++){//Check all the numbers by changing 1 position\\n            number = (1<<i);//Change 1 bit at a time \\n            oneBitToggled = (binaryRepresentation^number);\\n            if(hashMap[oneBitToggled]!==undefined){\\n                ans += hashMap[oneBitToggled];\\n            }\\n        }\\n        if(hashMap[binaryRepresentation]===undefined){\\n            hashMap[binaryRepresentation]=1;\\n        }else{\\n            ans += hashMap[binaryRepresentation];\\n            hashMap[binaryRepresentation]++;\\n        }\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1300572,
                "title": "go-bitmask-o-n",
                "content": "```\\nfunc wonderfulSubstrings(word string) int64 {\\n    dict := map[rune]int{}\\n    visited := map[int64]int64{}\\n    visited[0] = 1\\n    var mask, result int64 = 0, 0\\n    for _, ch := range word {\\n        dict[ch] += 1\\n        \\n        bit := rune(ch) - rune(\\'a\\')\\n        if dict[ch] % 2 != 0 {\\n            mask |= (1 << bit)\\n        } else {\\n            mask ^= (1 << bit)\\n        }\\n        \\n        result += visited[mask]\\n        for j:=0; j< 11; j++ {\\n            val := int64(1 << j) ^ mask\\n            if _, ok := visited[val]; ok {\\n                result += visited[val]\\n            }\\n        }\\n        visited[mask] += 1\\n    }\\n    return result\\n}\\n",
                "solutionTags": [
                    "Go",
                    "Bitmask"
                ],
                "code": "```\\nfunc wonderfulSubstrings(word string) int64 {\\n    dict := map[rune]int{}\\n    visited := map[int64]int64{}\\n    visited[0] = 1\\n    var mask, result int64 = 0, 0\\n    for _, ch := range word {\\n        dict[ch] += 1\\n        \\n        bit := rune(ch) - rune(\\'a\\')\\n        if dict[ch] % 2 != 0 {\\n            mask |= (1 << bit)\\n        } else {\\n            mask ^= (1 << bit)\\n        }\\n        \\n        result += visited[mask]\\n        for j:=0; j< 11; j++ {\\n            val := int64(1 << j) ^ mask\\n            if _, ok := visited[val]; ok {\\n                result += visited[val]\\n            }\\n        }\\n        visited[mask] += 1\\n    }\\n    return result\\n}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1300161,
                "title": "python3-o-n-beats-66-3396ms-count-bitmasks-this-problem-is-very-similar-to-1542",
                "content": "This problem is very similar in approach to \\nhttps://leetcode.com/problems/find-longest-awesome-substring/ \\n\\nSince we are given only letters \\'a\\' to \\'j\\', using bitmasks is possible.\\nFor a given mask - we have to find count of those previously seen masks - such that the XOR between the previous mask and current mask, yields a substring with \\'at most one odd element\\'.\\n\\n```\\nclass Solution:\\n    def wonderfulSubstrings(self, word: str) -> int:\\n        \\n        masks = [0]\\n        \\n        for i in range(10):\\n            masks.append(1<<i)\\n    \\n        cnts = collections.Counter()        \\n        cnts[0] = 1\\n                    \\n        cur_mask = 0\\n        ans = 0\\n        for i,c in enumerate(word):\\n            cur_mask = cur_mask ^ (1<<(ord(c)-ord(\\'a\\')))\\n            for m in masks:\\n                ans += cnts[(cur_mask ^ m)]\\n                \\n            cnts[cur_mask] += 1\\n                \\n        return ans\\n\\n```\\n\\nHope the explanation is clear, please let me know in the comments.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def wonderfulSubstrings(self, word: str) -> int:\\n        \\n        masks = [0]\\n        \\n        for i in range(10):\\n            masks.append(1<<i)\\n    \\n        cnts = collections.Counter()        \\n        cnts[0] = 1\\n                    \\n        cur_mask = 0\\n        ans = 0\\n        for i,c in enumerate(word):\\n            cur_mask = cur_mask ^ (1<<(ord(c)-ord(\\'a\\')))\\n            for m in masks:\\n                ans += cnts[(cur_mask ^ m)]\\n                \\n            cnts[cur_mask] += 1\\n                \\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1299755,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string s) {\\n        int n = s.size();\\n        long long res = 0;\\n        int i, j, f[1024], now;\\n        for (i = 0; i < 1024; ++i) f[i] = 0;\\n        f[0] = 1;\\n        now = 0;\\n        for (i = 0; i < n; ++i){\\n            j = (s[i] - \\'a\\');\\n            now ^= (1<<j);\\n            res += f[now];\\n            for (j = 0; j < 10; ++j)\\n                res += f[now ^ (1<<j)];                \\n            ++f[now];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string s) {\\n        int n = s.size();\\n        long long res = 0;\\n        int i, j, f[1024], now;\\n        for (i = 0; i < 1024; ++i) f[i] = 0;\\n        f[0] = 1;\\n        now = 0;\\n        for (i = 0; i < n; ++i){\\n            j = (s[i] - \\'a\\');\\n            now ^= (1<<j);\\n            res += f[now];\\n            for (j = 0; j < 10; ++j)\\n                res += f[now ^ (1<<j)];                \\n            ++f[now];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1299699,
                "title": "prefix-sum-bit-xor-o-n",
                "content": "map 10 letters to 10 bits.\\nif letter count is odd, set bit to 1,\\nif letter count is event, set bit to 0.\\n\\nthen use currt prefix sum minus existing prefix sum,  use hashmap to speed up.\\n\\nif bit_sum exists, or (bit_sum XOR the letter idx) exists, ans += existing bit_sum count.\\n\\nbit_sum exists: means all even, since delta is 0.\\n(bit_sum XOR one letter idx) exists : mean only one odd letters count.\\n\\n```\\nclass Solution:\\n    def wonderfulSubstrings(self, word: str) -> int:\\n        bit_sum = 0\\n        ans = 0\\n        sum_cnt = defaultdict(int)\\n        sum_cnt[0] = 1\\n        \\n        for c in word:\\n            c = ord(c) - ord(\\'a\\')\\n            bit_sum ^= (1 << c)\\n            key = bit_sum\\n            if key in sum_cnt:\\n                # print(\"key\", key)\\n                ans += sum_cnt[key]\\n            \\n            for i in range(10):\\n                bit_sum2 = bit_sum ^ (1 << i)\\n                key2 = bit_sum2\\n                if key2 in sum_cnt:\\n                    # print(\"key2\", key2)\\n                    ans += sum_cnt[key2]\\n            \\n            # print(\"key\", key, sum_cnt)\\n            key = bit_sum\\n            sum_cnt[key] += 1\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def wonderfulSubstrings(self, word: str) -> int:\\n        bit_sum = 0\\n        ans = 0\\n        sum_cnt = defaultdict(int)\\n        sum_cnt[0] = 1\\n        \\n        for c in word:\\n            c = ord(c) - ord(\\'a\\')\\n            bit_sum ^= (1 << c)\\n            key = bit_sum\\n            if key in sum_cnt:\\n                # print(\"key\", key)\\n                ans += sum_cnt[key]\\n            \\n            for i in range(10):\\n                bit_sum2 = bit_sum ^ (1 << i)\\n                key2 = bit_sum2\\n                if key2 in sum_cnt:\\n                    # print(\"key2\", key2)\\n                    ans += sum_cnt[key2]\\n            \\n            # print(\"key\", key, sum_cnt)\\n            key = bit_sum\\n            sum_cnt[key] += 1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1299659,
                "title": "please-help-me-identify-where-i-went-wrong",
                "content": "I am facing difficulty to correct it.\\n```\\nclass Solution {\\n    public long wonderfulSubstrings(String word) {\\n        int i=0, j=0;\\n        List<Character> lis = new ArrayList<Character>();\\n        StringBuilder str = new StringBuilder();\\n            while(i<word.length())\\n            {\\n                if(j<=word.length()-1)\\n                {\\n                char ch = word.charAt(i);\\n                str=str.append(ch);        \\n                if(str.length()==2 && str.charAt(0)!=str.charAt(1)) continue;\\n                lis.add(ch);\\n                }\\n                if(i==word.length()-1)\\n                {\\n                    j++;\\n                    i=j;\\n                   str.setLength(0);\\n                }\\n               else\\n                  i++;\\n            }\\n        return lis.size();\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long wonderfulSubstrings(String word) {\\n        int i=0, j=0;\\n        List<Character> lis = new ArrayList<Character>();\\n        StringBuilder str = new StringBuilder();\\n            while(i<word.length())\\n            {\\n                if(j<=word.length()-1)\\n                {\\n                char ch = word.charAt(i);\\n                str=str.append(ch);        \\n                if(str.length()==2 && str.charAt(0)!=str.charAt(1)) continue;\\n                lis.add(ch);\\n                }\\n                if(i==word.length()-1)\\n                {\\n                    j++;\\n                    i=j;\\n                   str.setLength(0);\\n                }\\n               else\\n                  i++;\\n            }\\n        return lis.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1299587,
                "title": "c-o-n-hashmap-bit-operation",
                "content": "For odd: iff odd - odd = even. For even: iff even - even = even. \\nOnly the odd-even of counts of each character matters, so we maintain a hashmap of bitmap to the number of occurances.\\n```\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string word) {\\n        long long result = 0;\\n        unordered_map<int, int> hmap;\\n        int bits = 0;\\n        hmap[0] = 1;\\n        for (char ch : word) {\\n            int idx = (ch - \\'a\\');\\n            bits = bits ^ (1 << idx);\\n\\t\\t\\t// all evens\\n            if (hmap.find(bits) != hmap.end()) {\\n                result += hmap[bits];\\n            }\\n\\t\\t\\t// iterate on the only one odd for each char\\n            for (int i = 0; i < 10; i++) {\\n                int bits2 = bits ^ (1 << i);\\n                if (hmap.find(bits2) != hmap.end()) {\\n                    result += hmap[bits2];\\n                }\\n            }\\n            hmap[bits]++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string word) {\\n        long long result = 0;\\n        unordered_map<int, int> hmap;\\n        int bits = 0;\\n        hmap[0] = 1;\\n        for (char ch : word) {\\n            int idx = (ch - \\'a\\');\\n            bits = bits ^ (1 << idx);\\n\\t\\t\\t// all evens\\n            if (hmap.find(bits) != hmap.end()) {\\n                result += hmap[bits];\\n            }\\n\\t\\t\\t// iterate on the only one odd for each char\\n            for (int i = 0; i < 10; i++) {\\n                int bits2 = bits ^ (1 << i);\\n                if (hmap.find(bits2) != hmap.end()) {\\n                    result += hmap[bits2];\\n                }\\n            }\\n            hmap[bits]++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069095,
                "title": "counting-wonderful-substrings-an-efficient-algorithm-using-bit-manipulation",
                "content": "# Intuition\\r\\nThe problem is about counting the number of \"wonderful\" substrings in a given word. A \"wonderful\" substring is one in which at most one character occurs an odd number of times. The first thought is to check every possible substring, but that would be inefficient. A better way might be to use bitwise manipulation to keep track of odd and even occurrences of characters in the substrings.\\r\\n\\r\\n## Approach\\r\\n1. **Initialize Variables**: Use a `mask` variable to keep track of the odd/even occurrence of each character in the substring. Use a `freq_counter` dictionary to keep track of the frequency of each mask value, which helps in counting the number of \"wonderful\" substrings efficiently.\\r\\n2. **Iterate Through the String**: Iterate through the string, updating the `mask` at each step.\\r\\n3. **Counting Substrings**: Utilize the updated `mask` and `freq_counter` to count the number of \"wonderful\" substrings that end at the current character.\\r\\n4. **Special Case**: Special consideration is given to substrings that have exactly one character with an odd frequency, by toggling each bit one at a time and checking if that \\'flipped\\' mask has appeared before.\\r\\n\\r\\n## Complexity\\r\\n\\r\\n- **Time Complexity**: The time complexity is $O(n)$ where $ n $ is the length of the word. We go through each character once, and for each character, we perform constant-time operations.\\r\\n  \\r\\n- **Space Complexity**: The space complexity is $O(1)$ as we only use a constant amount of extra space. The maximum number of unique masks is $2^{10} = 1024$, which is a constant number because the input word consists of the first ten lowercase English letters (\\'a\\' through \\'j\\').\\r\\n\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution:\\r\\n    def wonderfulSubstrings(self, word: str) -> int:\\r\\n        count = 0\\r\\n        mask = 0\\r\\n        freq_counter = {0: 1}  # To account for empty substring\\r\\n        \\r\\n        for char in word:\\r\\n            # Update the mask for the current character\\r\\n            mask ^= 1 << (ord(char) - ord(\\'a\\'))\\r\\n            \\r\\n            # Count \"wonderful\" substrings ending at this character\\r\\n            count += freq_counter.get(mask, 0)\\r\\n            \\r\\n            # Check for \"wonderful\" substrings that have exactly one character with odd frequency\\r\\n            for i in range(10):  # Since there are only 10 different letters (\\'a\\' to \\'j\\')\\r\\n                count += freq_counter.get(mask ^ (1 << i), 0)\\r\\n            \\r\\n            # Update frequency counter\\r\\n            freq_counter[mask] = freq_counter.get(mask, 0) + 1\\r\\n        \\r\\n        return count\\r\\n\\r\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\r\\nclass Solution:\\r\\n    def wonderfulSubstrings(self, word: str) -> int:\\r\\n        count = 0\\r\\n        mask = 0\\r\\n        freq_counter = {0: 1}  # To account for empty substring\\r\\n        \\r\\n        for char in word:\\r\\n            # Update the mask for the current character\\r\\n            mask ^= 1 << (ord(char) - ord(\\'a\\'))\\r\\n            \\r\\n            # Count \"wonderful\" substrings ending at this character\\r\\n            count += freq_counter.get(mask, 0)\\r\\n            \\r\\n            # Check for \"wonderful\" substrings that have exactly one character with odd frequency\\r\\n            for i in range(10):  # Since there are only 10 different letters (\\'a\\' to \\'j\\')\\r\\n                count += freq_counter.get(mask ^ (1 << i), 0)\\r\\n            \\r\\n            # Update frequency counter\\r\\n            freq_counter[mask] = freq_counter.get(mask, 0) + 1\\r\\n        \\r\\n        return count\\r\\n\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012399,
                "title": "python-solution-using-bit-masking-and-find-pair-which-have-xor-equal-to-target-in-o-n-10-and-o-1",
                "content": "# Code\\n```\\nclass Solution:\\n    def wonderfulSubstrings(self, word: str) -> int:\\n        s=ans=0\\n        d={0:1}\\n        for val in word:\\n            s^=(1<<(ord(val)-97))\\n            for item in [0,1,2,4,8,16,32,64,128,256,512]:\\n                if(item^s in d):\\n                    ans+=d[item^s]\\n            if(s in d):\\n                d[s]+=1\\n            else:\\n                d[s]=1\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def wonderfulSubstrings(self, word: str) -> int:\\n        s=ans=0\\n        d={0:1}\\n        for val in word:\\n            s^=(1<<(ord(val)-97))\\n            for item in [0,1,2,4,8,16,32,64,128,256,512]:\\n                if(item^s in d):\\n                    ans+=d[item^s]\\n            if(s in d):\\n                d[s]+=1\\n            else:\\n                d[s]=1\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981746,
                "title": "c-solution",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\n public:\\r\\n  long long wonderfulSubstrings(string word) {\\r\\n    long long ans = 0;\\r\\n    int prefix = 0;           // Binary prefix\\r\\n    vector<int> count(1024);  // Binary prefix count\\r\\n    count[0] = 1;             // Empty string \"\"\\r\\n\\r\\n    for (const char c : word) {\\r\\n      prefix ^= 1 << c - \\'a\\';\\r\\n      ans += count[prefix];         // All chars occur even times\\r\\n      for (int i = 0; i < 10; ++i)  // (\\'a\\' + i) occurs odd times\\r\\n        ans += count[prefix ^ 1 << i];\\r\\n      ++count[prefix];\\r\\n    }\\r\\n\\r\\n    return ans;\\r\\n  }\\r\\n};\\r\\n\\r\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\r\\nclass Solution {\\r\\n public:\\r\\n  long long wonderfulSubstrings(string word) {\\r\\n    long long ans = 0;\\r\\n    int prefix = 0;           // Binary prefix\\r\\n    vector<int> count(1024);  // Binary prefix count\\r\\n    count[0] = 1;             // Empty string \"\"\\r\\n\\r\\n    for (const char c : word) {\\r\\n      prefix ^= 1 << c - \\'a\\';\\r\\n      ans += count[prefix];         // All chars occur even times\\r\\n      for (int i = 0; i < 10; ++i)  // (\\'a\\' + i) occurs odd times\\r\\n        ans += count[prefix ^ 1 << i];\\r\\n      ++count[prefix];\\r\\n    }\\r\\n\\r\\n    return ans;\\r\\n  }\\r\\n};\\r\\n\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975567,
                "title": "bitwise-masking-for-efficiently-counting-wonderful-substring-91-beats",
                "content": "# Intuition\\r\\nGiven a word, our objective is to find out how many of its substrings are \"wonderful\". A substring is considered \"wonderful\" if at most one of its characters appears an odd number of times. The direct approach would be to generate all substrings and then check the frequency of each character in every substring, but this method is inefficient for longer words. Instead, using bitwise operations, we can track the odd and even occurrences of each character in an efficient manner. A binary mask works well for this, where each bit in the mask signifies the odd/even state for each character in the word.\\r\\n\\r\\n# Approach\\r\\n\\r\\n1. **Mask Representation**: Each of the 10 lowercase English letters can be represented using a single bit. If the bit is `1`, it indicates that the character has been seen an odd number of times so far; if `0`, it\\'s been seen an even number of times.\\r\\n2. **Iterate Over the Word**: As we iterate over each character in the word, we update our mask to reflect the new state (odd/even) of the characters seen so far.\\r\\n3. **Counting Wonderful Substrings**: We maintain a count of how often each possible mask has appeared. As we iterate over the word, for each mask, we look at the previous counts of the same mask and the counts of masks that differ from the current one by just one bit.\\r\\n4. **Return the Result**: Sum up all the counts to get the total number of \"wonderful\" substrings.\\r\\n\\r\\n# Complexity\\r\\n- Time complexity: `O(n)`, where `n` is the length of the word. We iterate over the word once, and for each character, we perform constant-time operations.\\r\\n\\r\\n- Space complexity: : `O(1)`, since the size of the count array is constant (1025 elements, regardless of the word\\'s length).\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution:\\r\\n    def wonderfulSubstrings(self, word: str) -> int:\\r\\n        mask, count = 0, [1] + [0] * 1024\\r\\n        res = 0\\r\\n        for ch in word:\\r\\n            mask ^= 1 << (ord(ch) - ord(\\'a\\'))\\r\\n            res += count[mask]\\r\\n            for i in range(10):\\r\\n                res += count[mask ^ (1 << i)]\\r\\n            count[mask] += 1\\r\\n        return res\\r\\n\\r\\n```",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\r\\nclass Solution:\\r\\n    def wonderfulSubstrings(self, word: str) -> int:\\r\\n        mask, count = 0, [1] + [0] * 1024\\r\\n        res = 0\\r\\n        for ch in word:\\r\\n            mask ^= 1 << (ord(ch) - ord(\\'a\\'))\\r\\n            res += count[mask]\\r\\n            for i in range(10):\\r\\n                res += count[mask ^ (1 << i)]\\r\\n            count[mask] += 1\\r\\n        return res\\r\\n\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3858984,
                "title": "java-solution-beats-96",
                "content": "```\\nclass Solution {\\n    public long wonderfulSubstrings(String s) {\\n        long[] maskF = new long[1 << 10];\\n        maskF[0] = 1;\\n        long ans = 0;\\n        int i = 0, n = s.length(), mask = 0;\\n        while (i < n) {\\n            mask ^= 1 << (9 - (s.charAt(i++) - \\'a\\'));\\n            ans += maskF[mask]++;\\n            for (int j = 0; j < 10; j++) {\\n                ans += maskF[mask ^ (1 << j)];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    public long wonderfulSubstrings(String s) {\\n        long[] maskF = new long[1 << 10];\\n        maskF[0] = 1;\\n        long ans = 0;\\n        int i = 0, n = s.length(), mask = 0;\\n        while (i < n) {\\n            mask ^= 1 << (9 - (s.charAt(i++) - \\'a\\'));\\n            ans += maskF[mask]++;\\n            for (int j = 0; j < 10; j++) {\\n                ans += maskF[mask ^ (1 << j)];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3805040,
                "title": "c-o-n-tc-o-n-sc",
                "content": "\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    long long wonderfulSubstrings(string s) {\\r\\n        //masking\\r\\n        //traverse the string and \\r\\n        //store the xor of all letters on the fly in mask\\r\\n        //       |A|B|B|A|C|C|B|\\r\\n        //xor  0,[1,3,1,0,4,0,2]\\r\\n\\r\\n        //if same mask found        ans++\\r\\n        //Or if after adding one more letter, same mask is found    ans++\\r\\n\\r\\n        //observe (A,1) and (B,1)   \\r\\n        //observe (B,2)^A = 3   \\'cause(2^1==3)      \\r\\n        long long ans=0;\\r\\n        int mask=0;\\r\\n        unordered_map<int,int> count;\\r\\n        count[0]=1;         \\r\\n        for(char c:s){\\r\\n            int ind=c-\\'a\\';\\r\\n            mask^=(1<<ind);\\r\\n            ans+=count[mask];\\r\\n            for(int i=0;i<10;i++){\\r\\n                int lookFor=mask^(1<<i);\\r\\n                ans+=count[lookFor];\\r\\n            }\\r\\n            count[mask]++;\\r\\n        }\\r\\n        return ans;\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    long long wonderfulSubstrings(string s) {\\r\\n        //masking\\r\\n        //traverse the string and \\r\\n        //store the xor of all letters on the fly in mask\\r\\n        //       |A|B|B|A|C|C|B|\\r\\n        //xor  0,[1,3,1,0,4,0,2]\\r\\n\\r\\n        //if same mask found        ans++\\r\\n        //Or if after adding one more letter, same mask is found    ans++\\r\\n\\r\\n        //observe (A,1) and (B,1)   \\r\\n        //observe (B,2)^A = 3   \\'cause(2^1==3)      \\r\\n        long long ans=0;\\r\\n        int mask=0;\\r\\n        unordered_map<int,int> count;\\r\\n        count[0]=1;         \\r\\n        for(char c:s){\\r\\n            int ind=c-\\'a\\';\\r\\n            mask^=(1<<ind);\\r\\n            ans+=count[mask];\\r\\n            for(int i=0;i<10;i++){\\r\\n                int lookFor=mask^(1<<i);\\r\\n                ans+=count[lookFor];\\r\\n            }\\r\\n            count[mask]++;\\r\\n        }\\r\\n        return ans;\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3804571,
                "title": "bitmask-prefix-xor",
                "content": "class Solution {\\npublic:\\n    long long wonderfulSubstrings(string word) {\\n\\t\\n        int n= word.size();\\n        \\n        int mask=0;\\n        long long ans=0;\\n        \\n        unordered_map<int,int> m; // mask and its frequency\\n        m[0]=1;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            mask^= (1<<(word[i]-\\'a\\'));\\n            \\n            if(m.count(0^mask))\\n                ans+= m[0^mask];\\n            \\n            for(int k=0;k<10;k++)\\n            {\\n                int copy= mask;\\n                copy^= (1<<k);\\n                \\n                if(m.count(copy))\\n                    ans+= m[copy];\\n            }\\n            m[mask]++;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    long long wonderfulSubstrings(string word) {\\n\\t\\n        int n= word.size();\\n        \\n        int mask=0;\\n        long long ans=0;\\n        \\n        unordered_map<int,int> m; // mask and its frequency\\n        m[0]=1;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            mask^= (1<<(word[i]-\\'a\\'));\\n            \\n            if(m.count(0^mask))\\n                ans+= m[0^mask];\\n            \\n            for(int k=0;k<10;k++)\\n            {\\n                int copy= mask;\\n                copy^= (1<<k);\\n                \\n                if(m.count(copy))\\n                    ans+= m[copy];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3759820,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(1)\\n * where `n` is the length of the string `word`\\n */\\nclass Solution {\\n public:\\n  long long wonderfulSubstrings(const string &word) {\\n    constexpr int letters = 10;\\n    constexpr char a = \\'a\\';\\n    constexpr int layouts = 1 << letters;\\n    int layout_to_count[layouts]{};\\n    layout_to_count[0] = 1;\\n    long long ret = 0;\\n    int layout = 0;\\n    for (const char c : word) {\\n      layout ^= 1 << (c - a);\\n      ret += layout_to_count[layout];\\n      for (int letter = 0; letter < letters; ++letter) {\\n        ret += layout_to_count[(1 << letter) ^ layout];\\n      }\\n      ++layout_to_count[layout];\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(1)\\n * where `n` is the length of the string `word`\\n */\\nclass Solution {\\n public:\\n  long long wonderfulSubstrings(const string &word) {\\n    constexpr int letters = 10;\\n    constexpr char a = \\'a\\';\\n    constexpr int layouts = 1 << letters;\\n    int layout_to_count[layouts]{};\\n    layout_to_count[0] = 1;\\n    long long ret = 0;\\n    int layout = 0;\\n    for (const char c : word) {\\n      layout ^= 1 << (c - a);\\n      ret += layout_to_count[layout];\\n      for (int letter = 0; letter < letters; ++letter) {\\n        ret += layout_to_count[(1 << letter) ^ layout];\\n      }\\n      ++layout_to_count[layout];\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571872,
                "title": "prefix-xor-dict-python",
                "content": "Steps \\n1. Traverse the string and keep a prefix_xor maintained\\n2. we will keep the count of each prefix_xor in a map \\n3. For each prefix_xor search if it exists in the map before and add the count to ans. This works because two times the same xor will xor up to 0 which means all the alphabet in this substr has even count \\n4. For each prefix_xor ,calculate temp_xor by flipping exactly a single bit and search this temp_xor in dict. This will ensure that exactly 1 odd count alphabet in present.\\n5. Finally update the map with prefix_sum \\n6. Return the ans  \\n\\n\\n\\n```\\nclass Solution:\\n    def wonderfulSubstrings(self, word: str) -> int:\\n        \\n        prefix_xor,ans=0,0\\n        m:map[int,int]={}\\n        m[prefix_xor]=1\\n        for i,ch in enumerate(word):\\n            prefix_xor=prefix_xor^(1<<(ord(ch)-ord(\\'a\\')))\\n            if prefix_xor in m:\\n                ans+=m[prefix_xor]\\n            for j in range(0,10):\\n                temp_xor=prefix_xor^(1<<j)\\n                if temp_xor in m:\\n                    ans+=m[temp_xor]\\n            if prefix_xor in m:\\n                m[prefix_xor]+=1\\n            else:\\n                m[prefix_xor]=1\\n        return ans \\n                \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def wonderfulSubstrings(self, word: str) -> int:\\n        \\n        prefix_xor,ans=0,0\\n        m:map[int,int]={}\\n        m[prefix_xor]=1\\n        for i,ch in enumerate(word):\\n            prefix_xor=prefix_xor^(1<<(ord(ch)-ord(\\'a\\')))\\n            if prefix_xor in m:\\n                ans+=m[prefix_xor]\\n            for j in range(0,10):\\n                temp_xor=prefix_xor^(1<<j)\\n                if temp_xor in m:\\n                    ans+=m[temp_xor]\\n            if prefix_xor in m:\\n                m[prefix_xor]+=1\\n            else:\\n                m[prefix_xor]=1\\n        return ans \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502017,
                "title": "c-and-java-solution-prefix-array-and-bitmasks",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# c++\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    long long wonderfulSubstrings(string word) {\\r\\n        long long ans=0;\\r\\n        int arr[(1<<11)]={};\\r\\n        int n=word.size();\\r\\n        int mask=0;\\r\\n        for(int i=0;i<n;i++){\\r\\n            mask=mask^(1<<(word[i]-\\'a\\'));\\r\\n            arr[mask]++;\\r\\n            if(mask==0) ans++;\\r\\n            else{\\r\\n                int cnt=0;\\r\\n                for(int i=0;i<=9 && (1<<i)<=mask;i++){\\r\\n                    if(mask & (1<<i)) cnt++;\\r\\n                }\\r\\n                if(cnt==1) ans++;\\r\\n            }\\r\\n        }\\r\\n        mask=0;\\r\\n        for(int i=0;i<n;i++){\\r\\n            mask=mask^(1<<(word[i]-\\'a\\'));\\r\\n            arr[mask]--;\\r\\n            ans+=arr[mask];\\r\\n            for(int i=0;i<=9;i++){\\r\\n                ans+=arr[mask^(1<<i)];\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return ans;\\r\\n    }\\r\\n};\\r\\n```\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\n    public long wonderfulSubstrings(String word) {\\r\\n        long ans=0;\\r\\n        long arr[]=new long[(1<<11)];\\r\\n        int n=word.length();\\r\\n        int mask=0;\\r\\n        for(int i=0;i<n;i++){\\r\\n            mask=mask^(1<<(word.charAt(i)-\\'a\\'));\\r\\n            arr[mask]++;\\r\\n            if(mask==0) ans++;\\r\\n            else{\\r\\n                int cnt=0;\\r\\n                for(int j=0;j<=9 && (1<<j)<=mask;j++){\\r\\n                    if((mask & (1<<j))!=0) cnt++;\\r\\n                }\\r\\n                if(cnt==1) ans++;\\r\\n            }\\r\\n        }\\r\\n        mask=0;\\r\\n        for(int i=0;i<n;i++){\\r\\n            mask=mask^(1<<(word.charAt(i)-\\'a\\'));\\r\\n            arr[mask]--;\\r\\n            ans+=arr[mask];\\r\\n            for(int j=0;j<=9;j++){\\r\\n                ans+=arr[mask^(1<<j)];\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return ans;\\r\\n    }\\r\\n}\\r\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    long long wonderfulSubstrings(string word) {\\r\\n        long long ans=0;\\r\\n        int arr[(1<<11)]={};\\r\\n        int n=word.size();\\r\\n        int mask=0;\\r\\n        for(int i=0;i<n;i++){\\r\\n            mask=mask^(1<<(word[i]-\\'a\\'));\\r\\n            arr[mask]++;\\r\\n            if(mask==0) ans++;\\r\\n            else{\\r\\n                int cnt=0;\\r\\n                for(int i=0;i<=9 && (1<<i)<=mask;i++){\\r\\n                    if(mask & (1<<i)) cnt++;\\r\\n                }\\r\\n                if(cnt==1) ans++;\\r\\n            }\\r\\n        }\\r\\n        mask=0;\\r\\n        for(int i=0;i<n;i++){\\r\\n            mask=mask^(1<<(word[i]-\\'a\\'));\\r\\n            arr[mask]--;\\r\\n            ans+=arr[mask];\\r\\n            for(int i=0;i<=9;i++){\\r\\n                ans+=arr[mask^(1<<i)];\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return ans;\\r\\n    }\\r\\n};\\r\\n```\n```\\r\\nclass Solution {\\r\\n    public long wonderfulSubstrings(String word) {\\r\\n        long ans=0;\\r\\n        long arr[]=new long[(1<<11)];\\r\\n        int n=word.length();\\r\\n        int mask=0;\\r\\n        for(int i=0;i<n;i++){\\r\\n            mask=mask^(1<<(word.charAt(i)-\\'a\\'));\\r\\n            arr[mask]++;\\r\\n            if(mask==0) ans++;\\r\\n            else{\\r\\n                int cnt=0;\\r\\n                for(int j=0;j<=9 && (1<<j)<=mask;j++){\\r\\n                    if((mask & (1<<j))!=0) cnt++;\\r\\n                }\\r\\n                if(cnt==1) ans++;\\r\\n            }\\r\\n        }\\r\\n        mask=0;\\r\\n        for(int i=0;i<n;i++){\\r\\n            mask=mask^(1<<(word.charAt(i)-\\'a\\'));\\r\\n            arr[mask]--;\\r\\n            ans+=arr[mask];\\r\\n            for(int j=0;j<=9;j++){\\r\\n                ans+=arr[mask^(1<<j)];\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return ans;\\r\\n    }\\r\\n}\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436355,
                "title": "c-hashmap-bit-manipulation-o-n-time-complexity",
                "content": "# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n$$O(n)$$\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n$$O(n)$$\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    long long wonderfulSubstrings(string word) {\\r\\n        long long res = 0, tmp = 0;\\r\\n        unordered_map<int,int> mp;\\r\\n        for (char c : word) {\\r\\n            tmp ^= (1 << (c - \\'a\\'));\\r\\n            res += mp[tmp];\\r\\n            int cnt = 0;\\r\\n            for (int i = 0; i < 10; ++ i) {\\r\\n                res += mp[tmp ^ (1 << i)];\\r\\n                cnt += ((tmp >> i) & 1);\\r\\n            }\\r\\n            res += (cnt <= 1);\\r\\n            ++ mp[tmp];\\r\\n        }\\r\\n        return res;\\r\\n    }\\r\\n};\\r\\n```\\r\\n**Please upvote if u like the solution :)**",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Bit Manipulation"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    long long wonderfulSubstrings(string word) {\\r\\n        long long res = 0, tmp = 0;\\r\\n        unordered_map<int,int> mp;\\r\\n        for (char c : word) {\\r\\n            tmp ^= (1 << (c - \\'a\\'));\\r\\n            res += mp[tmp];\\r\\n            int cnt = 0;\\r\\n            for (int i = 0; i < 10; ++ i) {\\r\\n                res += mp[tmp ^ (1 << i)];\\r\\n                cnt += ((tmp >> i) & 1);\\r\\n            }\\r\\n            res += (cnt <= 1);\\r\\n            ++ mp[tmp];\\r\\n        }\\r\\n        return res;\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3392541,
                "title": "c-count-subarrays-with-xor-equals-k-easy-to-understand-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    long long helper(string &word, char x){\\n        int desiredMask=(1 << (x-\\'a\\'));\\n        int mask=0;\\n        long long res=0;\\n        \\n        unordered_map<int,int> mpp;\\n        \\n        for(auto c: word){\\n            mask^=(1 << (c-\\'a\\'));\\n            if(mask==desiredMask){\\n                res++;\\n            }\\n            if(mpp.find(desiredMask ^ mask)!=mpp.end()){\\n                res+=mpp[desiredMask ^ mask];\\n            }\\n            mpp[mask]++;\\n        }\\n        return res;\\n    }\\n    \\n    long long zeroXOR(string &word){\\n        long long res=0;\\n        int mask=0;\\n\\n        unordered_map<int,int> mpp;\\n        \\n        for(auto x: word){\\n            mask^=(1 << (x-\\'a\\'));\\n            if(mask==0){\\n                res++;\\n            }\\n            if(mpp.find(mask)!=mpp.end()){\\n                res+=mpp[mask];\\n            }\\n            mpp[mask]++;\\n        }\\n        return res;\\n    }\\n    \\n    long long wonderfulSubstrings(string word) {\\n        long long res=0;\\n        for(int i=0;i<10;i++){\\n            res+=helper(word,i+\\'a\\');\\n        }\\n        res+=zeroXOR(word);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Counting",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long helper(string &word, char x){\\n        int desiredMask=(1 << (x-\\'a\\'));\\n        int mask=0;\\n        long long res=0;\\n        \\n        unordered_map<int,int> mpp;\\n        \\n        for(auto c: word){\\n            mask^=(1 << (c-\\'a\\'));\\n            if(mask==desiredMask){\\n                res++;\\n            }\\n            if(mpp.find(desiredMask ^ mask)!=mpp.end()){\\n                res+=mpp[desiredMask ^ mask];\\n            }\\n            mpp[mask]++;\\n        }\\n        return res;\\n    }\\n    \\n    long long zeroXOR(string &word){\\n        long long res=0;\\n        int mask=0;\\n\\n        unordered_map<int,int> mpp;\\n        \\n        for(auto x: word){\\n            mask^=(1 << (x-\\'a\\'));\\n            if(mask==0){\\n                res++;\\n            }\\n            if(mpp.find(mask)!=mpp.end()){\\n                res+=mpp[mask];\\n            }\\n            mpp[mask]++;\\n        }\\n        return res;\\n    }\\n    \\n    long long wonderfulSubstrings(string word) {\\n        long long res=0;\\n        for(int i=0;i<10;i++){\\n            res+=helper(word,i+\\'a\\');\\n        }\\n        res+=zeroXOR(word);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314575,
                "title": "c",
                "content": "```\\nlong long wonderfulSubstrings(char * word){\\n    int n = strlen(word) ;\\n    int* count = calloc(1 << 10, sizeof(int)) ;\\n    count[0] = 1 ;\\n    int state = 0 ;\\n    long long ret = 0 ;\\n    for(int i = 0; i < n; i++){\\n        int k = word[i] - \\'a\\' ;\\n        state ^= (1 << k) ;\\n        ret += count[state] ;\\n        for(int j = 0; j < 10; j++){\\n            int stateJ = state ^ (1 << j) ;\\n            ret += count[stateJ] ;\\n        }\\n        count[state]++ ;\\n    }\\n    free(count) ;\\n    return ret ;\\n}\\n```",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "```\\nlong long wonderfulSubstrings(char * word){\\n    int n = strlen(word) ;\\n    int* count = calloc(1 << 10, sizeof(int)) ;\\n    count[0] = 1 ;\\n    int state = 0 ;\\n    long long ret = 0 ;\\n    for(int i = 0; i < n; i++){\\n        int k = word[i] - \\'a\\' ;\\n        state ^= (1 << k) ;\\n        ret += count[state] ;\\n        for(int j = 0; j < 10; j++){\\n            int stateJ = state ^ (1 << j) ;\\n            ret += count[stateJ] ;\\n        }\\n        count[state]++ ;\\n    }\\n    free(count) ;\\n    return ret ;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3306010,
                "title": "python-bitmask-suffix-map",
                "content": "\\n\\n```\\nclass Solution:\\n    def wonderfulSubstrings(self, word: str) -> int:\\n\\n        #use bitmasks to keep track of odd sums and ^ suffix ranges to check if valid\\n        \\n        #go right to left and keep a count of times we see the bitmask\\n        #also we can go through a - j for each bitmask and count the times a 1 bit diff occurs after this point\\n        \\n        mp = defaultdict(int)\\n        #the start of our list will be 0 so we increase it by 1\\n        mp[0] +=1\\n        res = 0\\n        bit = 0\\n        for i in range(len(word) -1,-1,-1):    \\n            #extract and apply the bit value from character into our suffix\\n            ch = ord(word[i]) - ord(\\'a\\')\\n            bit ^= (1 << ch)\\n            #if we found an exact match add the number of times this occurance has shown up\\n            res += mp[bit]\\n            #A-J so we cycle 10 bits\\n            for j in range(10):\\n                #flip each bit in our current suffix and see how many matches we find\\n                flip = bit ^ (1 << j)\\n                #add the matches\\n                res += mp[flip]\\n            \\n            #increment this bitmask\\n            mp[bit] +=1\\n        \\n        \\n        return res\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation",
                    "Suffix Array",
                    "Bitmask"
                ],
                "code": "\\n\\n```\\nclass Solution:\\n    def wonderfulSubstrings(self, word: str) -> int:\\n\\n        #use bitmasks to keep track of odd sums and ^ suffix ranges to check if valid\\n        \\n        #go right to left and keep a count of times we see the bitmask\\n        #also we can go through a - j for each bitmask and count the times a 1 bit diff occurs after this point\\n        \\n        mp = defaultdict(int)\\n        #the start of our list will be 0 so we increase it by 1\\n        mp[0] +=1\\n        res = 0\\n        bit = 0\\n        for i in range(len(word) -1,-1,-1):    \\n            #extract and apply the bit value from character into our suffix\\n            ch = ord(word[i]) - ord(\\'a\\')\\n            bit ^= (1 << ch)\\n            #if we found an exact match add the number of times this occurance has shown up\\n            res += mp[bit]\\n            #A-J so we cycle 10 bits\\n            for j in range(10):\\n                #flip each bit in our current suffix and see how many matches we find\\n                flip = bit ^ (1 << j)\\n                #add the matches\\n                res += mp[flip]\\n            \\n            #increment this bitmask\\n            mp[bit] +=1\\n        \\n        \\n        return res\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 3293939,
                "title": "beats-100-python-bitmask-defaltdict",
                "content": "![image.png](https://assets.leetcode.com/users/images/7d85d9df-6c8d-41a4-bc32-affede306cc4_1678754346.732281.png)\\r\\n\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution(object):\\r\\n    def wonderfulSubstrings(self, word):\\r\\n        \"\"\"\\r\\n        :type word: str\\r\\n        :rtype: int\\r\\n        \"\"\"\\r\\n        counter = defaultdict(int)\\r\\n        counter[0] = 1\\r\\n        bitmask = 0\\r\\n        res=0\\r\\n        for i,c in enumerate(word):\\r\\n            ind = ord(c) - ord(\\'a\\')\\r\\n            bitmask = bitmask ^ (1 << ind)\\r\\n            res = res + counter[bitmask]\\r\\n            for i in range(10):\\r\\n                res = res + counter[bitmask ^ (1<<i)]\\r\\n            counter[bitmask] = counter[bitmask] + 1\\r\\n        return res\\r\\n\\r\\n\\r\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\r\\nclass Solution(object):\\r\\n    def wonderfulSubstrings(self, word):\\r\\n        \"\"\"\\r\\n        :type word: str\\r\\n        :rtype: int\\r\\n        \"\"\"\\r\\n        counter = defaultdict(int)\\r\\n        counter[0] = 1\\r\\n        bitmask = 0\\r\\n        res=0\\r\\n        for i,c in enumerate(word):\\r\\n            ind = ord(c) - ord(\\'a\\')\\r\\n            bitmask = bitmask ^ (1 << ind)\\r\\n            res = res + counter[bitmask]\\r\\n            for i in range(10):\\r\\n                res = res + counter[bitmask ^ (1<<i)]\\r\\n            counter[bitmask] = counter[bitmask] + 1\\r\\n        return res\\r\\n\\r\\n\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3238228,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn wonderful_substrings(word: String) -> i64 {\\n        let (mut cnt, mut mask, mut res) = (vec![0; 1024], 0, 0);\\n        cnt[0] = 1;\\n        for ch in word.chars() {\\n            mask ^= 1 << (ch as u8 - b\\'a\\');\\n            res += cnt[mask];\\n            for n in 0..10 {\\n                res += cnt[mask ^ (1 << n)];\\n            }\\n            cnt[mask] += 1;\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn wonderful_substrings(word: String) -> i64 {\\n        let (mut cnt, mut mask, mut res) = (vec![0; 1024], 0, 0);\\n        cnt[0] = 1;\\n        for ch in word.chars() {\\n            mask ^= 1 << (ch as u8 - b\\'a\\');\\n            res += cnt[mask];\\n            for n in 0..10 {\\n                res += cnt[mask ^ (1 << n)];\\n            }\\n            cnt[mask] += 1;\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3216218,
                "title": "c-o-n-short-bit-masking-solution",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\nFor each prefix, use a bitmask to represent the odd`(=1)`/even`(=0)` count of each alphabet. If two bitmasks `0..i`, `0..j` are identical or differs by 1 bit, then the substring between `i, j` are wonderful. In addition, we have to take care of the case where `i=j` and avoid double counting by `res/2`(`i>j` and `i<j` are counted twice but they represent identical substring).\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\nUse a integer table of size (1<<10+1) to memoize the number of prefix with a specific mask. Adding a character `c` is flippint the bit at `1<<(c-\\'a\\')`, equivalent to xor `1<<(c-\\'a\\')`. \\r\\n\\r\\nFor each none-zero entry `s` in the memoization table, find states with one bit difference with it by `s^(1<<i), i = 0..9` and\\r\\n1. add `dp[s]*dp[s] - dp[s]`, where `-dp[s]` is to avoid counting empty substring\\r\\n2. add `dp[t]*dp[s]`, where t has one bit difference from s\\r\\n3. divide the final answer by 2 to avoid double-counting substrings\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n$O(n + 10\\\\cdot 1024)$\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n$O(1024)$\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    long long wonderfulSubstrings(string word) {\\r\\n        int mask = 0;\\r\\n        int dp[1025] = {0};\\r\\n        dp[0]++;\\r\\n        for (char &c: word) {\\r\\n            mask ^= (1<<(c-\\'a\\'));\\r\\n            ++dp[mask];\\r\\n        }\\r\\n        long long res = 0;\\r\\n        for (int s = 0; s < (1<<10); ++s) {\\r\\n            if (dp[s] == 0) continue;\\r\\n            int sum = dp[s];\\r\\n            for (int i = 0; i < 10; ++i) {\\r\\n                sum += dp[s^(1<<i)];\\r\\n            }\\r\\n            res += (1LL*sum-1)*dp[s];\\r\\n        }\\r\\n        return res/2;\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++",
                    "Memoization",
                    "Bitmask"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    long long wonderfulSubstrings(string word) {\\r\\n        int mask = 0;\\r\\n        int dp[1025] = {0};\\r\\n        dp[0]++;\\r\\n        for (char &c: word) {\\r\\n            mask ^= (1<<(c-\\'a\\'));\\r\\n            ++dp[mask];\\r\\n        }\\r\\n        long long res = 0;\\r\\n        for (int s = 0; s < (1<<10); ++s) {\\r\\n            if (dp[s] == 0) continue;\\r\\n            int sum = dp[s];\\r\\n            for (int i = 0; i < 10; ++i) {\\r\\n                sum += dp[s^(1<<i)];\\r\\n            }\\r\\n            res += (1LL*sum-1)*dp[s];\\r\\n        }\\r\\n        return res/2;\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3048007,
                "title": "count-0-odd-and-1-odd-using-prefix-sum",
                "content": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def wonderfulSubstrings(self, word: str) -> int:\\n        ctr = Counter()\\n        charctr = [0] * 10\\n        ctr[tuple(charctr)] = 1\\n        for c in word:\\n            charctr[ord(c) - ord(\\'a\\')] += 1\\n            ctr[tuple([p % 2 for p in charctr])] += 1\\n        res = 0\\n        for p in ctr:\\n            res += ctr[p] * (ctr[p] - 1) // 2\\n            temp = list(p)\\n            for x in range(10):\\n                if p[x] == 0:\\n                    temp[x] = 1\\n                    res += ctr[p] * ctr[tuple(temp)]\\n                    temp[x] = 0\\n        return res\\n```\\n\\n![image](https://assets.leetcode.com/users/images/42de3648-ffa5-4cc5-8448-3296b40e1d59_1673671225.396781.png)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def wonderfulSubstrings(self, word: str) -> int:\\n        ctr = Counter()\\n        charctr = [0] * 10\\n        ctr[tuple(charctr)] = 1\\n        for c in word:\\n            charctr[ord(c) - ord(\\'a\\')] += 1\\n            ctr[tuple([p % 2 for p in charctr])] += 1\\n        res = 0\\n        for p in ctr:\\n            res += ctr[p] * (ctr[p] - 1) // 2\\n            temp = list(p)\\n            for x in range(10):\\n                if p[x] == 0:\\n                    temp[x] = 1\\n                    res += ctr[p] * ctr[tuple(temp)]\\n                    temp[x] = 0\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3040400,
                "title": "simple-c-code-using-bit-manipulation-and-hashing",
                "content": "\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    long long wonderfulSubstrings(string s){\\r\\n        long long n = s.size(), ans = 0;\\r\\n        vector<long long> pref(n+1, 0);\\r\\n        map<int,int> mp;\\r\\n        mp[0]++;\\r\\n        for(int i=1;i<=n;i++)\\r\\n        {\\r\\n            pref[i]=pref[i-1];\\r\\n            int x = s[i-1]-\\'a\\';\\r\\n            pref[i] = pref[i] xor (1 << x);\\r\\n            ans += mp[pref[i]];\\r\\n            for(int k=0;k<10;k++)ans += mp[pref[i] xor (1 << k)];\\r\\n            mp[pref[i]]++;\\r\\n        }\\r\\n        return ans;\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    long long wonderfulSubstrings(string s){\\r\\n        long long n = s.size(), ans = 0;\\r\\n        vector<long long> pref(n+1, 0);\\r\\n        map<int,int> mp;\\r\\n        mp[0]++;\\r\\n        for(int i=1;i<=n;i++)\\r\\n        {\\r\\n            pref[i]=pref[i-1];\\r\\n            int x = s[i-1]-\\'a\\';\\r\\n            pref[i] = pref[i] xor (1 << x);\\r\\n            ans += mp[pref[i]];\\r\\n            for(int k=0;k<10;k++)ans += mp[pref[i] xor (1 << k)];\\r\\n            mp[pref[i]]++;\\r\\n        }\\r\\n        return ans;\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3007654,
                "title": "python-bitmask-o-10n",
                "content": "# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def wonderfulSubstrings(self, word: str) -> int:\\n        d = defaultdict(int)\\n        mask = 0\\n        d[mask] = 1\\n        res = 0\\n        for c in word:\\n            mask ^= 1 << (ord(c)-ord(\\'a\\'))\\n            res += d[mask]\\n            for i in range(10):\\n                res += d[mask ^ (1 << i)]\\n            d[mask] += 1\\n        return res\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def wonderfulSubstrings(self, word: str) -> int:\\n        d = defaultdict(int)\\n        mask = 0\\n        d[mask] = 1\\n        res = 0\\n        for c in word:\\n            mask ^= 1 << (ord(c)-ord(\\'a\\'))\\n            res += d[mask]\\n            for i in range(10):\\n                res += d[mask ^ (1 << i)]\\n            d[mask] += 1\\n        return res\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2981589,
                "title": "bitmask-hash-map",
                "content": "# Intuition\\nWe need to care about count of 1 character is odd or even not its count, and also have limit type of character \\'a\\' to \\'j\\'. So bitmask with xor operator can keep track of odd/even status of each character.\\nCheck this example:\\n```\\nIndex:     0 1 2 3 4 5 6 7\\nstring: -  a b a b c c b a\\nmask:   0  1 3 2 0 4 0 2 3 (1st bit is a, 2nd is b, ...)\\n```\\nWe have 2 cases: odd or even number of characters.\\n\\n1 - For even number of characters:\\nObserve \\'c\\' with mask **0** at index 5, we can see 2 places with same 0 mask. We can list 2 substrings with even number of characters:\\n-  \"ababcc\" => starting position next to mask **0** at beggining\\n-  \"cc\" => starting position next to \\'b\\' index 3 with mask **0**\\n\\nDo same with \\'b\\' at index 6, mask **2**, we can list 1 substring ending with it, because we have 1 mask **2** at \\'a\\' index 2\\n\\nDo same with \\'a\\' at index 7, mask **3**, we can list 1 substring ending with it, because we have 1 mask **3** at \\'b\\' index 1\\n\\nIt shows that number of substrings with even characters ending with current index will be the count of its mask.\\n\\n2 - For odd number of characters:\\nAlso observe \\'c\\' at index 5, mask **0**, we can list 3 substrings ending with it having odd number of characters:\\n- babcc => starting position next to \\'a\\' index 0 with mask **1**\\n- bcc => starting position next to \\'a\\' index 2 with mask **2**\\n- c => starting position next to \\'c\\' index 4 with mask **4**\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis give us idea of flipping 1 bit of current mask, and sum their count.\\n\\nWe can check this observation with \\'b\\' at index 6, mask **2**\\n- Flip 1st bit of 2, it\\'s 3, as observation, we have 1 mask 3 in above example, so 1 substring starting next to it. \"abccb\"\\n- Flip 2nd bit of 2, it\\'s 0, as observation, we have 3 mask 0 in above example, so 3 substring starting next to it. \"ababccb\", \"ccb\", \"b\"\\n- Flip 3rd bit of 2, it\\'s 6, we don\\'t have mask 6, so no substring for it.\\n- so on ...\\n\\nBased on above ideas, we use hasmap or array to storing count for each mask, increase it by 1 for each iteration. Because 0 is the default value of mask, count of mask 0 is 1 at the begginning.\\n\\nThe problem asks for all possible substring, so we iterate the whole string. For each iteration we calculate new mask, calculate count of even/odd substrings based on new mask. Then increase count of new mask by 1.\\n\\n# Complexity\\n- Time complexity: O(n), iterate string 1 time, each iteration have constant loop from \\'a\\' to \\'j\\'\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1024), map need 2^(\\'j\\'-\\'a\\') = 2^10 to store count\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string word) {\\n        unordered_map<int,int> cnt = {{0,1}};\\n        int mask = 0;\\n        long long ret = 0;\\n        for(char c: word) {\\n            mask ^= 1 << (c-\\'a\\');\\n            ret += cnt[mask];\\n            for(char i = \\'a\\'; i <= \\'j\\'; i++)\\n                ret += cnt[mask ^ (1 << (i-\\'a\\'))];\\n            cnt[mask]++;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nIndex:     0 1 2 3 4 5 6 7\\nstring: -  a b a b c c b a\\nmask:   0  1 3 2 0 4 0 2 3 (1st bit is a, 2nd is b, ...)\\n```\n```\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string word) {\\n        unordered_map<int,int> cnt = {{0,1}};\\n        int mask = 0;\\n        long long ret = 0;\\n        for(char c: word) {\\n            mask ^= 1 << (c-\\'a\\');\\n            ret += cnt[mask];\\n            for(char i = \\'a\\'; i <= \\'j\\'; i++)\\n                ret += cnt[mask ^ (1 << (i-\\'a\\'))];\\n            cnt[mask]++;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2879272,
                "title": "easy-c-solution-with-explaination",
                "content": "```\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string word) {\\n        long long int ans=0;\\n        unordered_map<int,int>mp;\\n        mp[0]=1;\\n        int bit=0;\\n        for(int i=0;i<word.length();i++)\\n        {\\n            bit=bit^(1<<(word[i]-\\'a\\'));\\n            ans=ans+mp[bit];  // if bit pattern repeats itself this means all characters have \\n            // even occurence\\n            for(int j=0;j<10;j++)\\n            {\\n                ans=ans+mp[bit^(1<<j)]; // for odd occurence just flip one bit out of 10\\n            }\\n            mp[bit]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string word) {\\n        long long int ans=0;\\n        unordered_map<int,int>mp;\\n        mp[0]=1;\\n        int bit=0;\\n        for(int i=0;i<word.length();i++)\\n        {\\n            bit=bit^(1<<(word[i]-\\'a\\'));\\n            ans=ans+mp[bit];  // if bit pattern repeats itself this means all characters have \\n            // even occurence\\n            for(int j=0;j<10;j++)\\n            {\\n                ans=ans+mp[bit^(1<<j)]; // for odd occurence just flip one bit out of 10\\n            }\\n            mp[bit]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2862567,
                "title": "c-solution",
                "content": "even - even = even\\nodd - odd = even \\nodd - even = odd\\neven - odd = odd ...(1)\\n\\nFor characters with count equals to an odd number, label as 1, else 0. Create a mask. \\n\\nFor example, we have \"ababaccj\", then the mask to represent the substring that starts at index 0 and ends at index 7 is \"1000000001\"\\n\\nThen, consider:\\n1. If the number of characters such that the count equals to odd number is <= 1, then this substring (starting at index 0) is valid. Else, it is not valid.\\n\\n2. Notice any previously existing mask(s). If the difference in bits between 2 masks is 1, then by cancel them out using ...(1) (which is same as XOR operation), only one character\\'s count is an odd number. \\nIf the difference is 0, then all the counts will be even, which is perfect.\\n* Example : \"01000\" vs \"10000\", the difference is 2.\\n\\nApply basic combination rules **(-_-)...** to count the number of valid substrings.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    std::unordered_map<string, int> S;\\n    int mk[10];\\n    string init = \"0000000000\";\\n    string mk_to_str() {\\n        string res = init;\\n        for (int i = 0; i < 10; i++) {\\n            res[i] = (char)(mk[i] + \\'0\\');\\n        }\\n        return res;\\n    }\\n    bool valid(string& s) {\\n        int cnt = 0;\\n        for (int i = 0; i < 10; i++) {\\n            cnt += (int)(s[i] - \\'0\\');\\n        }\\n        return cnt <= 1 ? true : false;\\n    }\\n    long long wonderfulSubstrings(string word) {\\n        S = {};\\n        string tmp;\\n        long long res = 0;\\n        for (char c : word) {\\n            mk[(c - \\'a\\')] ^= 1;\\n            tmp = mk_to_str();\\n            S[tmp]++; \\n            if (valid(tmp)) {\\n                res += S[tmp];\\n            }\\n            else {\\n                res += S[tmp] - 1; \\n            }\\n            for (int i = 0; i < 10; i++) {\\n                tmp[i] = (tmp[i] == \\'0\\') ? \\'1\\' : \\'0\\';\\n                res += S[tmp];\\n                tmp[i] = (tmp[i] == \\'0\\') ? \\'1\\' : \\'0\\';\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    std::unordered_map<string, int> S;\\n    int mk[10];\\n    string init = \"0000000000\";\\n    string mk_to_str() {\\n        string res = init;\\n        for (int i = 0; i < 10; i++) {\\n            res[i] = (char)(mk[i] + \\'0\\');\\n        }\\n        return res;\\n    }\\n    bool valid(string& s) {\\n        int cnt = 0;\\n        for (int i = 0; i < 10; i++) {\\n            cnt += (int)(s[i] - \\'0\\');\\n        }\\n        return cnt <= 1 ? true : false;\\n    }\\n    long long wonderfulSubstrings(string word) {\\n        S = {};\\n        string tmp;\\n        long long res = 0;\\n        for (char c : word) {\\n            mk[(c - \\'a\\')] ^= 1;\\n            tmp = mk_to_str();\\n            S[tmp]++; \\n            if (valid(tmp)) {\\n                res += S[tmp];\\n            }\\n            else {\\n                res += S[tmp] - 1; \\n            }\\n            for (int i = 0; i < 10; i++) {\\n                tmp[i] = (tmp[i] == \\'0\\') ? \\'1\\' : \\'0\\';\\n                res += S[tmp];\\n                tmp[i] = (tmp[i] == \\'0\\') ? \\'1\\' : \\'0\\';\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2817795,
                "title": "c-o-n-100-solution",
                "content": "```\\npublic class Solution {\\n    public long WonderfulSubstrings(string word)\\n    {\\n        // create a tracker to see how many times you have seen a mask\\n        // in this case 2^10 because only 10 letters\\n        ushort[] tracker = new ushort[1024];\\n        // Mask of 0 has been seen 1 time now because thats how we start\\n        tracker[0] = 1;\\n        ushort mask = 0;\\n        long count = 0;\\n        ushort[] masks = new ushort[10];\\n        \\n        // save on bitshift operations by creating the masks for each letter only once at the start\\n        for (ushort i = 0; i < 10; i++)\\n            masks[i] = (ushort)(1 << i);\\n\\n\\n        // iterate through every letter in the word\\n        for (int i = 0; i < word.Length; i++)\\n        {\\n            // Add the newest letter to the mask\\n            // mask update just changed the respective bit based on the next letter seen\\n            mask ^= (ushort)(1 << word[i] - \\'a\\');\\n\\n            // add the number of times this mask has been seen to the count\\n            count += tracker[mask];\\n\\n            // iterate through each of the letters possible and flip that bit in the mask\\n            // add all instances that this mask + 1 bit flipped has been seen\\n            for (int j = 0; j < 10; j++)\\n            {\\n                count += tracker[mask ^ masks[j]];\\n            }\\n            // Add 1 to the tracker to say that we have seen this mask 1 more time\\n            tracker[mask]++;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "```\\npublic class Solution {\\n    public long WonderfulSubstrings(string word)\\n    {\\n        // create a tracker to see how many times you have seen a mask\\n        // in this case 2^10 because only 10 letters\\n        ushort[] tracker = new ushort[1024];\\n        // Mask of 0 has been seen 1 time now because thats how we start\\n        tracker[0] = 1;\\n        ushort mask = 0;\\n        long count = 0;\\n        ushort[] masks = new ushort[10];\\n        \\n        // save on bitshift operations by creating the masks for each letter only once at the start\\n        for (ushort i = 0; i < 10; i++)\\n            masks[i] = (ushort)(1 << i);\\n\\n\\n        // iterate through every letter in the word\\n        for (int i = 0; i < word.Length; i++)\\n        {\\n            // Add the newest letter to the mask\\n            // mask update just changed the respective bit based on the next letter seen\\n            mask ^= (ushort)(1 << word[i] - \\'a\\');\\n\\n            // add the number of times this mask has been seen to the count\\n            count += tracker[mask];\\n\\n            // iterate through each of the letters possible and flip that bit in the mask\\n            // add all instances that this mask + 1 bit flipped has been seen\\n            for (int j = 0; j < 10; j++)\\n            {\\n                count += tracker[mask ^ masks[j]];\\n            }\\n            // Add 1 to the tracker to say that we have seen this mask 1 more time\\n            tracker[mask]++;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2767462,
                "title": "prefix-sum-bitmask-implementation-python-explaination",
                "content": "Intuition: \\nEvens and Odd count for each letters gives the sense of bit mask usage and also the constraints\\n\\n#### Bitmask Working:\\nConsider the string made up of abcde letters:\\nSo we can use five letters to show the even odd letter count in the string\\u2028\\naabd-> 01010 > even odd combination\\n\\nAddition of Char:\\naabd+b->aabdb->01000\\u2028\\n01010^00010->01000\\u2028\\nSo, addition of string is equivalent to XOR of bit mask for both strings\\n\\n1.Finding even count of letters:\\u2028\\nInitialize count{0:1}-> empty string with bit mask value 0 with count 1\\n\\nConsider Eg: aabb\\nPrefix sum-\\n> a a b b\\n>  1 0 2 0  \\n\\nIterate over the string,when you find new a with prefix_sum =0(for all other prefix_sum values)\\nif prefix==0 is already present ,then that value will be its contributions in solution and increment {0,2}\\n\\nExplanation:\\n {} {aa}-> this is the contribution\\u2028if prefix==0 , contribution is 1\\n{} {aa}-> {aabb} {bb} contribution 2\\n\\nContribution(acutal substring) is from the index ahead of previous index with that current value till the current index. aa contribution is next index of aa till current index ->bb \\n\\n2.Finding one odd count\\n For any current prefix sum ,\\n\\t prefix_sum+ all indices  ,will lead to all even + one odd combo \\n\\t\\t\\nFor i in all letter:\\n>new_bitmask=old_bitmask+char\\n>Check if new_bitmask in count:\\n\\t\\t\\t>if yes ,add the value to res\\n\\nImplementation:\\n\\n```\\nclass Solution:\\n    def wonderfulSubstrings(self, word: str) -> int:\\n        \\n        count={}\\n        count[0]=1\\n        curr=0\\n        res=0\\n        for i in range(0,len(word)):\\n            curr^=1<<(ord(word[i])-ord(\"a\"))\\n            \\n            \\n            if(curr in count):\\n                res+=count[curr]\\n            \\n            for j in range(0,10):\\n                new_mask=curr^1<<j\\n                if(new_mask in count):\\n                    res+=count[new_mask]\\n            \\n            if(curr not in count):\\n                count[curr]=1\\n            else:\\n                count[curr]+=1\\n       \\n        return res\\n            \\n```\\n\\nTime Complexity- O(n)\\nSpace Complexity- O(1)",
                "solutionTags": [
                    "Python",
                    "Prefix Sum",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def wonderfulSubstrings(self, word: str) -> int:\\n        \\n        count={}\\n        count[0]=1\\n        curr=0\\n        res=0\\n        for i in range(0,len(word)):\\n            curr^=1<<(ord(word[i])-ord(\"a\"))\\n            \\n            \\n            if(curr in count):\\n                res+=count[curr]\\n            \\n            for j in range(0,10):\\n                new_mask=curr^1<<j\\n                if(new_mask in count):\\n                    res+=count[new_mask]\\n            \\n            if(curr not in count):\\n                count[curr]=1\\n            else:\\n                count[curr]+=1\\n       \\n        return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2700612,
                "title": "python-time-o-10-n-bit-mask-dictionary-count",
                "content": "class Solution(object):\\n    def wonderfulSubstrings(self, word):\\n        \\n        poolVal = set({0}) #The set include 0 and odd occurence case\\n        base = 1\\n        for i in range(10):\\n            poolVal.add(base)\\n            base = base << 1\\n        \\n        lenW = len(word)\\n        a = ord(\\'a\\')\\n        dictCnt = {}\\n        window = (1 << (ord(word[0]) - a)) \\n        dictCnt[window] = 1\\n        result = 1\\n        \\n        #window records the odd, even status of the 10 chars in word[0 : i + 1]\\n        #0: means even, 1: means odd\\n        \\n        for i in range(1, lenW): \\n            \\n            window = window ^ (1 << (ord(word[i]) - a)) #Current window bit-mask\\n            \\n            if(window in poolVal): #If current window satisify condition in problem\\n                result += 1\\n            \\n            for j in range(10): #check whether there are previous windows that only has one char\\'s status is different from current window\\n                tmp = window ^ (1 << j)\\n                \\n                if(tmp in dictCnt):\\n                    result += dictCnt[tmp]\\n                 \\n            if(window in dictCnt):\\n                result += dictCnt[window]\\n                dictCnt[window] += 1\\n            else:\\n                dictCnt[window] = 1\\n        \\n        return result",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def wonderfulSubstrings(self, word):\\n        \\n        poolVal = set({0}",
                "codeTag": "Java"
            },
            {
                "id": 2633751,
                "title": "c-bit-mask-with-dictionary",
                "content": "```\\n\\tpublic long WonderfulSubstrings(string word) {\\n        var dict = new Dictionary<int, long> { { 0, 1 } };\\n        var mask = 0;\\n        long res = 0;\\n        var valid = new HashSet<int> { 0 };\\n        for (int i = 0; i < 11; i++)\\n            valid.Add(1 << i);\\n        foreach (var l in word) {\\n            var temp = l - \\'a\\';\\n            if (((mask >> temp) & 1) == 1)\\n                mask -= 1 << temp;\\n            else\\n                mask |= 1 << temp;\\n            foreach (var num in valid) {\\n                if (!dict.ContainsKey(mask ^ num)) continue;\\n                res += dict[mask ^ num];\\n            }\\n            if (!dict.ContainsKey(mask))\\n                dict[mask] = 0;\\n            dict[mask]++;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic long WonderfulSubstrings(string word) {\\n        var dict = new Dictionary<int, long> { { 0, 1 } };\\n        var mask = 0;\\n        long res = 0;\\n        var valid = new HashSet<int> { 0 };\\n        for (int i = 0; i < 11; i++)\\n            valid.Add(1 << i);\\n        foreach (var l in word) {\\n            var temp = l - \\'a\\';\\n            if (((mask >> temp) & 1) == 1)\\n                mask -= 1 << temp;\\n            else\\n                mask |= 1 << temp;\\n            foreach (var num in valid) {\\n                if (!dict.ContainsKey(mask ^ num)) continue;\\n                res += dict[mask ^ num];\\n            }\\n            if (!dict.ContainsKey(mask))\\n                dict[mask] = 0;\\n            dict[mask]++;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2447835,
                "title": "easy-short-clean-efficient-code",
                "content": "```\\nclass Solution {\\n    typedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    long long wonderfulSubstrings(string& s) {\\n        vi(ll)ump(1024);\\n        ++ump[0];\\n        ll ans = 0, bm = 0;\\n        for (char ch : s) {\\n            bm ^= 1 << (ch - \\'a\\');\\n            ans += ump[bm];\\n            for (ll i = 0;i < 10;++i) {\\n                ans += ump[bm ^ (1 << i)];\\n            }\\n            ump[bm]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Iterator",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    typedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    long long wonderfulSubstrings(string& s) {\\n        vi(ll)ump(1024);\\n        ++ump[0];\\n        ll ans = 0, bm = 0;\\n        for (char ch : s) {\\n            bm ^= 1 << (ch - \\'a\\');\\n            ans += ump[bm];\\n            for (ll i = 0;i < 10;++i) {\\n                ans += ump[bm ^ (1 << i)];\\n            }\\n            ump[bm]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2396413,
                "title": "shouldn-t-it-be-a-hard-question",
                "content": "shouldn\\'t it be a hard question? Feel sorry I don\\'t understand even after checking other ppl\\'s solutions.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2342271,
                "title": "simple-c-bitmask-and-xor",
                "content": "```\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string s) {\\n        long long ans = 0;\\n        unordered_map<int,long long> mp;\\n        mp[0] = 1;\\n        int mask = 0;\\n        for(auto it:s)\\n        {\\n            int val = it - \\'a\\';\\n            mask ^= (1<<val);\\n            ans += mp[mask]; //even occurances\\n            for(int i = 0;i<10;i++)\\n            {\\n                int temp_mask = mask^(1<<i); //odd occurances\\n                ans += mp[temp_mask];\\n            }\\n            mp[mask]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string s) {\\n        long long ans = 0;\\n        unordered_map<int,long long> mp;\\n        mp[0] = 1;\\n        int mask = 0;\\n        for(auto it:s)\\n        {\\n            int val = it - \\'a\\';\\n            mask ^= (1<<val);\\n            ans += mp[mask]; //even occurances\\n            for(int i = 0;i<10;i++)\\n            {\\n                int temp_mask = mask^(1<<i); //odd occurances\\n                ans += mp[temp_mask];\\n            }\\n            mp[mask]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2295767,
                "title": "python-simple-bitmasking",
                "content": "\\n    def wonderfulSubstrings(self, word):\\n        n, mask, dict1, total = len(word), 0, defaultdict(int), 0\\n        \\n        dict1[0] = 1\\n        \\n        for w in word:\\n            mask ^= 1 << (ord(w) - ord(\"a\"))\\n            \\n            if mask in dict1:\\n                total += dict1[mask]\\n                \\n            for i in range(10):\\n                tmp = mask ^ (1 << i)\\n                total += dict1[tmp]\\n                \\n            dict1[mask] += 1\\n            \\n        return total",
                "solutionTags": [],
                "code": "\\n    def wonderfulSubstrings(self, word):\\n        n, mask, dict1, total = len(word), 0, defaultdict(int), 0\\n        \\n        dict1[0] = 1\\n        \\n        for w in word:\\n            mask ^= 1 << (ord(w) - ord(\"a\"))\\n            \\n            if mask in dict1:\\n                total += dict1[mask]\\n                \\n            for i in range(10):\\n                tmp = mask ^ (1 << i)\\n                total += dict1[tmp]\\n                \\n            dict1[mask] += 1\\n            \\n        return total",
                "codeTag": "Python3"
            },
            {
                "id": 2268983,
                "title": "2276ms-vs-705ms-vs-98ms",
                "content": "Using string as map key\\n2276ms\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    void flipBit(string &curr, int j) {\\n        if(curr[j]==\\'0\\') curr[j] = \\'1\\';\\n        else curr[j] = \\'0\\';\\n    }\\n    \\n    ll wonderfulSubstrings(string word) {\\n        int n = word.length();\\n        vector<ll> pre(n), suf(n);\\n        unordered_map<string, ll> m;\\n        ll res = 0;\\n        string curr = \"0000000000\";\\n        m[curr]++;\\n        for(int i=0; i<n; i++) {\\n            int c = (word[i]-\\'a\\');\\n            flipBit(curr, c);\\n            res += m[curr];\\n            for(int j=0; j<10; j++) {\\n                flipBit(curr, j);\\n                res += m[curr];\\n                flipBit(curr, j);\\n            }\\n            m[curr]++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nUsing number as key\\n705ms\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    void flipBit(ll &curr, int j) {\\n        curr = curr ^ (1ll<<j);\\n    }\\n    \\n    ll wonderfulSubstrings(string word) {\\n        int n = word.length();\\n        unordered_map<ll, ll> m;\\n        ll res = 0;\\n        ll curr = 0;\\n        m[curr]++;\\n        \\n        for(int i=0; i<n; i++) {\\n            int c = (word[i]-\\'a\\');\\n            flipBit(curr, c);\\n            res += m[curr];\\n            for(int j=0; j<10; j++) {\\n                flipBit(curr, j);\\n                res += m[curr];\\n                flipBit(curr, j);\\n            }\\n            m[curr]++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nRather than using map, used array to count prefixes\\n98ms\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    void flipBit(ll &curr, int j) {\\n        curr = curr ^ (1ll<<j);\\n    }\\n    \\n    ll wonderfulSubstrings(string word) {\\n        int n = word.length();\\n        vector<ll> m(1024);\\n        ll res = 0;\\n        ll curr = 0;\\n        m[curr]++;\\n        \\n        for(int i=0; i<n; i++) {\\n            int c = (word[i]-\\'a\\');\\n            flipBit(curr, c);\\n            res += m[curr];\\n            for(int j=0; j<10; j++) {\\n                flipBit(curr, j);\\n                res += m[curr];\\n                flipBit(curr, j);\\n            }\\n            m[curr]++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    void flipBit(string &curr, int j) {\\n        if(curr[j]==\\'0\\') curr[j] = \\'1\\';\\n        else curr[j] = \\'0\\';\\n    }\\n    \\n    ll wonderfulSubstrings(string word) {\\n        int n = word.length();\\n        vector<ll> pre(n), suf(n);\\n        unordered_map<string, ll> m;\\n        ll res = 0;\\n        string curr = \"0000000000\";\\n        m[curr]++;\\n        for(int i=0; i<n; i++) {\\n            int c = (word[i]-\\'a\\');\\n            flipBit(curr, c);\\n            res += m[curr];\\n            for(int j=0; j<10; j++) {\\n                flipBit(curr, j);\\n                res += m[curr];\\n                flipBit(curr, j);\\n            }\\n            m[curr]++;\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    void flipBit(ll &curr, int j) {\\n        curr = curr ^ (1ll<<j);\\n    }\\n    \\n    ll wonderfulSubstrings(string word) {\\n        int n = word.length();\\n        unordered_map<ll, ll> m;\\n        ll res = 0;\\n        ll curr = 0;\\n        m[curr]++;\\n        \\n        for(int i=0; i<n; i++) {\\n            int c = (word[i]-\\'a\\');\\n            flipBit(curr, c);\\n            res += m[curr];\\n            for(int j=0; j<10; j++) {\\n                flipBit(curr, j);\\n                res += m[curr];\\n                flipBit(curr, j);\\n            }\\n            m[curr]++;\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    void flipBit(ll &curr, int j) {\\n        curr = curr ^ (1ll<<j);\\n    }\\n    \\n    ll wonderfulSubstrings(string word) {\\n        int n = word.length();\\n        vector<ll> m(1024);\\n        ll res = 0;\\n        ll curr = 0;\\n        m[curr]++;\\n        \\n        for(int i=0; i<n; i++) {\\n            int c = (word[i]-\\'a\\');\\n            flipBit(curr, c);\\n            res += m[curr];\\n            for(int j=0; j<10; j++) {\\n                flipBit(curr, j);\\n                res += m[curr];\\n                flipBit(curr, j);\\n            }\\n            m[curr]++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2250132,
                "title": "c-beginner-friendly-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string word) {\\n        int n = word.length();\\n        long long int ans = 0;\\n        string x(10,\\'0\\');\\n        unordered_map<string,int> mp;\\n        mp[x]++;\\n        for(int i=0;i<n;i++){\\n            int idx = word[i]-\\'a\\';\\n            x[idx] = \\'1\\' - x[idx];\\n            ans += mp[x];\\n            for(int j=0;j<10;j++){\\n                string y = x;\\n                y[j] = \\'1\\' - y[j];\\n                ans += mp[y];\\n            }\\n            mp[x]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string word) {\\n        int n = word.length();\\n        long long int ans = 0;\\n        string x(10,\\'0\\');\\n        unordered_map<string,int> mp;\\n        mp[x]++;\\n        for(int i=0;i<n;i++){\\n            int idx = word[i]-\\'a\\';\\n            x[idx] = \\'1\\' - x[idx];\\n            ans += mp[x];\\n            for(int j=0;j<10;j++){\\n                string y = x;\\n                y[j] = \\'1\\' - y[j];\\n                ans += mp[y];\\n            }\\n            mp[x]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2238041,
                "title": "c-bitmask",
                "content": "```\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string word) {\\n        int bit = 0;\\n\\t\\t\\n\\t\\t// {bitmask, # of prefix with this bitmask}\\n        unordered_map<int, long long> mp;\\n        \\n        for(int i=0; i<word.size(); ++i) {\\n            int d = word[i] - \\'a\\';\\n            bit = bit ^ (int) pow(2, d);\\n            mp[bit]++;\\n        }\\n        \\n        long long ans = 0;\\n        for(auto& [k, v] : mp) {\\n            ans += v * (v-1) / 2;\\n            int odddigit = 0;\\n            for(int d=0; d<10; d++) {\\n                int p = pow(2, d);\\n                if(k & p) odddigit += 1;\\n                \\n\\t\\t\\t\\t// find other bitmasks that has one bit difference.\\n                int k2 = k ^ p;\\n                if(k < k2 && mp.count(k2)) {\\n                    ans += v * mp[k2];\\n                }\\n            }\\n\\t\\t\\t// The bitmask itself has less than 2 odd characters.\\n            if(odddigit < 2) ans += v;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string word) {\\n        int bit = 0;\\n\\t\\t\\n\\t\\t// {bitmask, # of prefix with this bitmask}\\n        unordered_map<int, long long> mp;\\n        \\n        for(int i=0; i<word.size(); ++i) {\\n            int d = word[i] - \\'a\\';\\n            bit = bit ^ (int) pow(2, d);\\n            mp[bit]++;\\n        }\\n        \\n        long long ans = 0;\\n        for(auto& [k, v] : mp) {\\n            ans += v * (v-1) / 2;\\n            int odddigit = 0;\\n            for(int d=0; d<10; d++) {\\n                int p = pow(2, d);\\n                if(k & p) odddigit += 1;\\n                \\n\\t\\t\\t\\t// find other bitmasks that has one bit difference.\\n                int k2 = k ^ p;\\n                if(k < k2 && mp.count(k2)) {\\n                    ans += v * mp[k2];\\n                }\\n            }\\n\\t\\t\\t// The bitmask itself has less than 2 odd characters.\\n            if(odddigit < 2) ans += v;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2219844,
                "title": "few-lines-python-passed-40-80",
                "content": "\\nclass Solution(object):        \\n    def wonderfulSubstrings(self, word): \\n        count,i,j,word = 0,0,0,list(str(word))\\n        for i in range(len(word)):\\n            j=i+1\\n            while j!=len(word)+1:        \\n                if sum([g%2 for g in [word[i:j].count(m) for m in set(word[i:j])]])<2:                                   \\n                           count = count +1  \\n                j=j+1\\n        return count",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\nclass Solution(object):        \\n    def wonderfulSubstrings(self, word): \\n        count,i,j,word = 0,0,0,list(str(word))\\n        for i in range(len(word)):\\n            j=i+1\\n            while j!=len(word)+1:        \\n                if sum([g%2 for g in [word[i:j].count(m) for m in set(word[i:j])]])<2:                                   \\n                           count = count +1  \\n                j=j+1\\n        return count",
                "codeTag": "Java"
            },
            {
                "id": 2011925,
                "title": "c-quick-learner-10-bits-to-represent-a-j-count-as-odd-or-even",
                "content": "May 5, 2022\\n**Introduction**\\nIt is hard to be a quick learner. What I did is to choose top-voted discuss post, and then learn to write C# code based on the discuss post. \\n\\n**Similar Questions**:\\n\\n1371. Find the Longest Substring Containing Vowels in Even Counts\\n1542. Find Longest Awesome Substring\\n\\n**Solution | PhoenixDD**\\nI just quickly copied the solution written by PhoenixDD:\\n\\nTo have at most 1 odd we sum the counts of all even characters encounterd + count of a single character that can be odd, we try each character from a to j. We use the similar prefix parity logic as explained above to get results for both operations 1) Count of substrings with all characters even in count. 2) Count of substrings with 1 character odd in count.\\n\\nRunning stores the parities of all characters until index i i.e word[0...i]. For finding count of even characters we sum counts of of all j<i where word[0...j] had same parity as running since then word[j+1...i] would have characters with all even counts as seen in the observation section.\\n\\nTo find substrings with 1 character odd in count we flip one bit of running at a time and sum counts of all j<i where word[0...j] had same parity as running except 1 bit (the one we flipped) as this would mean word[j+1...i] had all characters in even count except the one that represents the flipped bit which would be odd in count.\\n\\n**My approach | Use one integer 10 bits to represent a - j\\'s count**\\nI think that it is easy to apply bit manipulation left shift << to represent a - j\\'s count. For example, j\\'s count can be represented using 1 or 0 to represent odd or even. And it is easy to find the bit to represent \\'j\\' count using bit expression: 1 << (\\'j\\' - \\'a\\'). \\n\\nAnother bit manipulation is XOR, using C# ^ operator to include all 10 bits in one integer. \\n\\nAfter short review of those two bit manipulation, it is ready to go over the following C# code. \\n\\n**Edge case | 0 has count 1, empty string \"\"**\\nIt is important to add this edge case in the code:\\n```\\nmap.Add(0, 1);\\n```\\n\\nThe following C# code passes online judge. \\n\\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _1915_number_of_wonderful_substrings\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            var result = WonderfulSubstrings(\"aabb\");\\n        }        \\n        \\n        /// <summary>\\n        /// study code\\n        /// https://leetcode.com/problems/number-of-wonderful-substrings/discuss/1299523/C%2B%2B-Bit-Vector-%2B-Prefix-Parities-(Similar-to-Prefix-Sums)\\n        /// </summary>\\n        /// <param name=\"word\"></param>\\n        /// <returns></returns>\\n        public static long WonderfulSubstrings(string word)\\n        {         \\n            // using an integer with 10 bits to represent a - j\\'s count in odd or even count \\n            // key - integer with 10 bits, value - how many prefix substrings have the key value\\n            var map = new Dictionary<int, int>();\\n\\n            // caught by online judge, failed test case: \"aba\", should return 4, but 1\\n            map.Add(0, 1);\\n\\n\\t\\t    int running = 0;\\n            long result = 0;\\n\\n            foreach(var w in word) \\n            {\\n\\t\\t\\t    // Update the running parity\\n                running ^= 1 << (int)(w - \\'a\\');                \\n\\n                for (char c = \\'a\\'; c <= \\'j\\'; c++)\\n                {\\n                    var keyOneDiff = running ^ (1 << (c - \\'a\\'));\\n                    if (map.ContainsKey(keyOneDiff))\\n                    {\\n                        // exclusive or ^\\n                        result += map[keyOneDiff];\\n                    }                    \\n                }\\n\\t\\t\\t\\t\\n\\t\\t\\t    // Add counts of substrings with all characters with even counts.\\n\\t\\t\\t    // As seen in observation we need count of prefix parities with same parities as current running parity.\\n                if (!map.ContainsKey(running))\\n                {\\n                    map.Add(running, 0);\\n                }\\n\\n                result += map[running];\\n\\t\\t\\t\\n\\t\\t\\t    // Update the counts for next future iterations.\\n                map[running]++;\\n            }\\n\\n            return result;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nmap.Add(0, 1);\\n```\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _1915_number_of_wonderful_substrings\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            var result = WonderfulSubstrings(\"aabb\");\\n        }        \\n        \\n        /// <summary>\\n        /// study code\\n        /// https://leetcode.com/problems/number-of-wonderful-substrings/discuss/1299523/C%2B%2B-Bit-Vector-%2B-Prefix-Parities-(Similar-to-Prefix-Sums)\\n        /// </summary>\\n        /// <param name=\"word\"></param>\\n        /// <returns></returns>\\n        public static long WonderfulSubstrings(string word)\\n        {         \\n            // using an integer with 10 bits to represent a - j\\'s count in odd or even count \\n            // key - integer with 10 bits, value - how many prefix substrings have the key value\\n            var map = new Dictionary<int, int>();\\n\\n            // caught by online judge, failed test case: \"aba\", should return 4, but 1\\n            map.Add(0, 1);\\n\\n\\t\\t    int running = 0;\\n            long result = 0;\\n\\n            foreach(var w in word) \\n            {\\n\\t\\t\\t    // Update the running parity\\n                running ^= 1 << (int)(w - \\'a\\');                \\n\\n                for (char c = \\'a\\'; c <= \\'j\\'; c++)\\n                {\\n                    var keyOneDiff = running ^ (1 << (c - \\'a\\'));\\n                    if (map.ContainsKey(keyOneDiff))\\n                    {\\n                        // exclusive or ^\\n                        result += map[keyOneDiff];\\n                    }                    \\n                }\\n\\t\\t\\t\\t\\n\\t\\t\\t    // Add counts of substrings with all characters with even counts.\\n\\t\\t\\t    // As seen in observation we need count of prefix parities with same parities as current running parity.\\n                if (!map.ContainsKey(running))\\n                {\\n                    map.Add(running, 0);\\n                }\\n\\n                result += map[running];\\n\\t\\t\\t\\n\\t\\t\\t    // Update the counts for next future iterations.\\n                map[running]++;\\n            }\\n\\n            return result;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1938383,
                "title": "fast-and-easy",
                "content": "```\\npublic class Solution {\\n    public long WonderfulSubstrings(string word) {\\n        long[] cnt = new long[1024];\\n        long mask = 0, res = 0;\\n        cnt[0]=1;  //for start with empty string which have repeated once\\n        foreach (char ch in word) {\\n            mask ^= 1 << (ch - \\'a\\');\\n            res += cnt[mask];\\n            for (int i = 0; i < 10; i++) //count all even masks if it\\'s odd or vice versa\\n                res += cnt[mask ^ (1 << i)];\\n            cnt[mask]++;\\n        }\\n        return res;\\n    }\\n}\\n```\\nO(10n)",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public long WonderfulSubstrings(string word) {\\n        long[] cnt = new long[1024];\\n        long mask = 0, res = 0;\\n        cnt[0]=1;  //for start with empty string which have repeated once\\n        foreach (char ch in word) {\\n            mask ^= 1 << (ch - \\'a\\');\\n            res += cnt[mask];\\n            for (int i = 0; i < 10; i++) //count all even masks if it\\'s odd or vice versa\\n                res += cnt[mask ^ (1 << i)];\\n            cnt[mask]++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1914716,
                "title": "easy-c-code",
                "content": "similar to question :-number of subarrays with given sum;\\n```\\n// whem we are at a index i we try to find the number of substring starting from 0 and ending at index<i and having bitmax such at its xor with current bitmax == 0 or any power of 2\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string wd) {\\n        \\n        int n=wd.length();\\n        \\n        unordered_map<int,ll>mp;\\n        mp[0]=1;\\n        ll ans=0;\\n        int bit=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            bit=bit^(1<<(wd[i]-\\'a\\'));\\n            \\n            if(bit==0)\\n            {\\n        \\n                ans+=mp[0];\\n                for(int j=0;j<10;j++)\\n                    ans+=mp[(1<<j)];\\n                \\n            }\\n            else if((bit&(bit-1))==0)\\n            {\\n               \\n                 ans+=mp[0];\\n               for(int j=0;j<10;j++)\\n                 ans+=mp[(bit|(1<<j))];\\n            }\\n            else\\n            {\\n                ans+=mp[bit];\\n                for(int j=0;j<10;j++)\\n                        ans+=mp[bit^(1<<j)];\\n                    \\n            }\\n            mp[bit]++;\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\n// whem we are at a index i we try to find the number of substring starting from 0 and ending at index<i and having bitmax such at its xor with current bitmax == 0 or any power of 2\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string wd) {\\n        \\n        int n=wd.length();\\n        \\n        unordered_map<int,ll>mp;\\n        mp[0]=1;\\n        ll ans=0;\\n        int bit=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            bit=bit^(1<<(wd[i]-\\'a\\'));\\n            \\n            if(bit==0)\\n            {\\n        \\n                ans+=mp[0];\\n                for(int j=0;j<10;j++)\\n                    ans+=mp[(1<<j)];\\n                \\n            }\\n            else if((bit&(bit-1))==0)\\n            {\\n               \\n                 ans+=mp[0];\\n               for(int j=0;j<10;j++)\\n                 ans+=mp[(bit|(1<<j))];\\n            }\\n            else\\n            {\\n                ans+=mp[bit];\\n                for(int j=0;j<10;j++)\\n                        ans+=mp[bit^(1<<j)];\\n                    \\n            }\\n            mp[bit]++;\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1878804,
                "title": "java-solution-bit-mask",
                "content": "```\\nclass Solution {\\n    public long wonderfulSubstrings(String word) {\\n        int[] count = new int[1024];\\n        long res = 0;\\n        int cur = 0;\\n        count[0] = 1;\\n        for (int i = 0; i < word.length(); i++) {\\n            cur ^= 1 << (word.charAt(i) - \\'a\\');\\n            res += count[cur];\\n            for (int j = 0; j < 10; j++) {\\n                res += count[cur ^ (1 << j)];\\n            }\\n            ++count[cur];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long wonderfulSubstrings(String word) {\\n        int[] count = new int[1024];\\n        long res = 0;\\n        int cur = 0;\\n        count[0] = 1;\\n        for (int i = 0; i < word.length(); i++) {\\n            cur ^= 1 << (word.charAt(i) - \\'a\\');\\n            res += count[cur];\\n            for (int j = 0; j < 10; j++) {\\n                res += count[cur ^ (1 << j)];\\n            }\\n            ++count[cur];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1817741,
                "title": "bitmasking-c",
                "content": "Similar Problems->\\nhttps://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/\\n[https://leetcode.com/problems/find-longest-awesome-substring/](http://)\\n```\\nclass Solution {\\npublic:\\n    \\n    long long wonderfulSubstrings(string word){\\n        unordered_map<int,int> indices ;\\n        int mask = 0 ; //can be upto 2^10 == 1024 ;\\n        long long ans = 0 ;\\n        indices[0] = 1 ;\\n        \\n        for(int i = 0 ; i < word.size() ; ++i ){\\n\\t\\t\\t//0->even occurence\\n\\t\\t\\t//1-> odd occurence\\n\\t\\t\\t//toggle the current bit \\n            mask ^= 1 << (word[i]-\\'a\\') ;\\n            ans += indices[mask] ;\\n            indices[mask] ++ ;\\n            \\n\\t\\t\\t//now toggle one by one all the bits in mask\\n            for(int j = 0 ; j < 10 ; j++ ){\\n                int tester = mask ^ (1 << j) ;\\n                ans += indices[tester] ;\\n            }\\n        }\\n        \\n        return ans ;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long wonderfulSubstrings(string word){\\n        unordered_map<int,int> indices ;\\n        int mask = 0 ; //can be upto 2^10 == 1024 ;\\n        long long ans = 0 ;\\n        indices[0] = 1 ;\\n        \\n        for(int i = 0 ; i < word.size() ; ++i ){\\n\\t\\t\\t//0->even occurence\\n\\t\\t\\t//1-> odd occurence\\n\\t\\t\\t//toggle the current bit \\n            mask ^= 1 << (word[i]-\\'a\\') ;\\n            ans += indices[mask] ;\\n            indices[mask] ++ ;\\n            \\n\\t\\t\\t//now toggle one by one all the bits in mask\\n            for(int j = 0 ; j < 10 ; j++ ){\\n                int tester = mask ^ (1 << j) ;\\n                ans += indices[tester] ;\\n            }\\n        }\\n        \\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1764243,
                "title": "python-3-used-counter-and-accumulate",
                "content": "\\n```\\n    def wonderfulSubstrings(self, word: str) -> int:\\n        \\n        dictO = { c: i for i,c in enumerate(\"abcdefghij\") }\\n\\n        listBM = [ 1<<dictO[c] for c in word ]\\n        listA = [0]+list( accumulate(listBM, lambda a,b: a^b ) )\\n        \\n        retV = 0\\n        cntrA = Counter(listA)\\n        listK = list(cntrA.keys())\\n        for bm in listK:\\n            cB = cntrA[bm]\\n            retV += cB*(cB-1)//2\\n            for i in range(10):\\n                retV += cB*cntrA[bm^(1<<i)]\\n            del cntrA[bm]\\n        return retV\\n```",
                "solutionTags": [],
                "code": "```\\n    def wonderfulSubstrings(self, word: str) -> int:\\n        \\n        dictO = { c: i for i,c in enumerate(\"abcdefghij\") }\\n\\n        listBM = [ 1<<dictO[c] for c in word ]\\n        listA = [0]+list( accumulate(listBM, lambda a,b: a^b ) )\\n        \\n        retV = 0\\n        cntrA = Counter(listA)\\n        listK = list(cntrA.keys())\\n        for bm in listK:\\n            cB = cntrA[bm]\\n            retV += cB*(cB-1)//2\\n            for i in range(10):\\n                retV += cB*cntrA[bm^(1<<i)]\\n            del cntrA[bm]\\n        return retV\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1691505,
                "title": "golang",
                "content": "```\\nfunc wonderfulSubstrings(word string) int64 {\\n    res := 0\\n    mask := 0\\n    dict := make(map[int]int)\\n    dict[0] = 1\\n    for i := 0; i < len(word); i++ {\\n        mask ^= 1 << int(word[i] - \\'a\\')      \\n        res += dict[mask]          \\n        for j := 0; j < 10; j++ {\\n            res += dict[mask ^ (1 << j)]\\n        }\\n        dict[mask]++ \\n    }\\n    return int64(res)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc wonderfulSubstrings(word string) int64 {\\n    res := 0\\n    mask := 0\\n    dict := make(map[int]int)\\n    dict[0] = 1\\n    for i := 0; i < len(word); i++ {\\n        mask ^= 1 << int(word[i] - \\'a\\')      \\n        res += dict[mask]          \\n        for j := 0; j < 10; j++ {\\n            res += dict[mask ^ (1 << j)]\\n        }\\n        dict[mask]++ \\n    }\\n    return int64(res)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1638310,
                "title": "java-o-n-solution",
                "content": "```\\nclass Solution {\\n    public long wonderfulSubstrings(String word) {\\n        long[] count = new long[1024];\\n        count[0]=1;\\n        int cur = 0;\\n        long res=0L;\\n        for(char c: word.toCharArray()) {\\n            int idx= c-\\'a\\';\\n            cur^=1<<idx;\\n            res+=count[cur]++;\\n            for(int i=0;i<10;i++) {\\n                int temp = cur ^ (1<<i);\\n                res+=count[temp];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long wonderfulSubstrings(String word) {\\n        long[] count = new long[1024];\\n        count[0]=1;\\n        int cur = 0;\\n        long res=0L;\\n        for(char c: word.toCharArray()) {\\n            int idx= c-\\'a\\';\\n            cur^=1<<idx;\\n            res+=count[cur]++;\\n            for(int i=0;i<10;i++) {\\n                int temp = cur ^ (1<<i);\\n                res+=count[temp];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1622215,
                "title": "ruby-and-rust-solutions-both-beat-100-100",
                "content": "```\\n# @param {String} word\\n# @return {Integer}\\ndef wonderful_substrings(word)\\n  mask = 0\\n  suf = Array.new(1024, 0)\\n  word.chars.sum do |c|\\n    suf[mask] += 1\\n    mask ^= 1 << (c.ord - 97)\\n    (-1..9).sum { suf[mask ^ (1 << _1)] }\\n  end\\nend\\n```\\n\\nRust\\n\\n```\\nuse std::iter::once;\\n\\nimpl Solution {\\n    pub fn wonderful_substrings(word: String) -> i64 {\\n        let mut mask = 0usize;\\n        let mut suf = [0i64; 1024];\\n        word.as_bytes()\\n            .iter()\\n            .map(|c| {\\n                suf[mask] += 1;\\n                mask ^= 1 << (c - 97);\\n                (0..=9)\\n                    .map(|i| mask ^ (1 << i))\\n                    .chain(once(mask))\\n                    .map(|i| suf[i])\\n                    .sum::<i64>()\\n            })\\n            .sum::<i64>()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {String} word\\n# @return {Integer}\\ndef wonderful_substrings(word)\\n  mask = 0\\n  suf = Array.new(1024, 0)\\n  word.chars.sum do |c|\\n    suf[mask] += 1\\n    mask ^= 1 << (c.ord - 97)\\n    (-1..9).sum { suf[mask ^ (1 << _1)] }\\n  end\\nend\\n```\n```\\nuse std::iter::once;\\n\\nimpl Solution {\\n    pub fn wonderful_substrings(word: String) -> i64 {\\n        let mut mask = 0usize;\\n        let mut suf = [0i64; 1024];\\n        word.as_bytes()\\n            .iter()\\n            .map(|c| {\\n                suf[mask] += 1;\\n                mask ^= 1 << (c - 97);\\n                (0..=9)\\n                    .map(|i| mask ^ (1 << i))\\n                    .chain(once(mask))\\n                    .map(|i| suf[i])\\n                    .sum::<i64>()\\n            })\\n            .sum::<i64>()\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1595283,
                "title": "running",
                "content": "**time:** `O(N)`; **space:** `O(1)`\\n```\\nlong long wonderfulSubstrings(string w)\\n{\\n\\tlong long out{};\\n\\tunordered_map<int, int>m{{0,1}};\\n\\tfor(int d{}; const auto & c : w)\\n\\t{\\n\\t\\td ^= 1<<(c-\\'a\\');\\n\\t\\tout += m[d]++; \\n\\t\\tfor(auto t{0}; t<10; ++t) out += m[d^(1<<t)];\\n\\t}\\n\\treturn out;\\n}\\n```\\n||\\n```\\nlong long wonderfulSubstrings(string w)\\n{\\n\\tlong long out{};\\n\\tint m[1024]{1};\\n\\tfor(int d{}; const auto & c : w)\\n\\t{\\n\\t\\td ^= 1<<(c-\\'a\\');\\n\\t\\tout += m[d]++; \\n\\t\\tfor(auto t{0}; t<10; ++t) out += m[d^(1<<t)];\\n\\t}\\n\\treturn out;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nlong long wonderfulSubstrings(string w)\\n{\\n\\tlong long out{};\\n\\tunordered_map<int, int>m{{0,1}};\\n\\tfor(int d{}; const auto & c : w)\\n\\t{\\n\\t\\td ^= 1<<(c-\\'a\\');\\n\\t\\tout += m[d]++; \\n\\t\\tfor(auto t{0}; t<10; ++t) out += m[d^(1<<t)];\\n\\t}\\n\\treturn out;\\n}\\n```\n```\\nlong long wonderfulSubstrings(string w)\\n{\\n\\tlong long out{};\\n\\tint m[1024]{1};\\n\\tfor(int d{}; const auto & c : w)\\n\\t{\\n\\t\\td ^= 1<<(c-\\'a\\');\\n\\t\\tout += m[d]++; \\n\\t\\tfor(auto t{0}; t<10; ++t) out += m[d^(1<<t)];\\n\\t}\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1534394,
                "title": "c-bitmask",
                "content": "Refer this wonderful post for explanation.\\nhttps://leetcode.com/problems/number-of-wonderful-substrings/discuss/1299773/Intuitive-explanation-easy-to-understand\\nsharing my code.\\n\\n```\\n\\tlong long wonderfulSubstrings(string word) {\\n        int m[1<<10];\\n        memset(m, 0, sizeof(m));\\n        m[0] = 1;\\n        long long count=0, mask=0;\\n        for(auto &c : word) {\\n            mask ^= 1<<(c-\\'a\\');\\n            for(int i=0; i<10; i++) count += m[mask^(1<<i)];\\n            count += m[mask]++;\\n        }\\n        return count;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\tlong long wonderfulSubstrings(string word) {\\n        int m[1<<10];\\n        memset(m, 0, sizeof(m));\\n        m[0] = 1;\\n        long long count=0, mask=0;\\n        for(auto &c : word) {\\n            mask ^= 1<<(c-\\'a\\');\\n            for(int i=0; i<10; i++) count += m[mask^(1<<i)];\\n            count += m[mask]++;\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1494493,
                "title": "golang-xor-solution",
                "content": "```go\\nfunc wonderfulSubstrings(word string) int64 {\\n\\thash := make(map[int64]int64)\\n\\tmagic := int64(0)\\n\\tcount := int64(0)\\n\\t// initial hash, empty string\\'s magic is 0\\n\\thash[0] = 1\\n\\tfor _, v := range word {\\n\\t\\tmagic ^= 1 << (v-\\'a\\')\\n\\t\\t// without odd elem\\n\\t\\tcount += hash[magic]\\n\\t\\t// within one odd elem\\n\\t\\tfor i := 0; i < 10; i++ {\\n\\t\\t\\tcount += hash[magic^(1<<i)]\\n\\t\\t}\\n\\t\\thash[magic]++\\n\\t}\\n\\treturn count\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Bitmask"
                ],
                "code": "```go\\nfunc wonderfulSubstrings(word string) int64 {\\n\\thash := make(map[int64]int64)\\n\\tmagic := int64(0)\\n\\tcount := int64(0)\\n\\t// initial hash, empty string\\'s magic is 0\\n\\thash[0] = 1\\n\\tfor _, v := range word {\\n\\t\\tmagic ^= 1 << (v-\\'a\\')\\n\\t\\t// without odd elem\\n\\t\\tcount += hash[magic]\\n\\t\\t// within one odd elem\\n\\t\\tfor i := 0; i < 10; i++ {\\n\\t\\t\\tcount += hash[magic^(1<<i)]\\n\\t\\t}\\n\\t\\thash[magic]++\\n\\t}\\n\\treturn count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1480638,
                "title": "c-bitmask-prefix-sum-hashtable",
                "content": "```\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string word) {\\n        int i, j;\\n        long long ans = 0;\\n        vector<int>bitMap(10);\\n        for(i = 0; i < 10; i++){\\n            bitMap[i] = 1 << i;\\n        }\\n        unordered_map<int, int>hashMap;\\n        hashMap[0] = 1;\\n        int xorValue = 0;\\n        for(i = 0; i < word.length(); i++){\\n            xorValue ^= bitMap[word[i] - \\'a\\'];\\n            ans += hashMap[xorValue];\\n            for(j = 0; j < 10; j++){\\n                char x = \\'a\\' + j;\\n                int k = xorValue ^ bitMap[x - \\'a\\'];\\n                ans += hashMap[k];\\n            }\\n            hashMap[xorValue]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string word) {\\n        int i, j;\\n        long long ans = 0;\\n        vector<int>bitMap(10);\\n        for(i = 0; i < 10; i++){\\n            bitMap[i] = 1 << i;\\n        }\\n        unordered_map<int, int>hashMap;\\n        hashMap[0] = 1;\\n        int xorValue = 0;\\n        for(i = 0; i < word.length(); i++){\\n            xorValue ^= bitMap[word[i] - \\'a\\'];\\n            ans += hashMap[xorValue];\\n            for(j = 0; j < 10; j++){\\n                char x = \\'a\\' + j;\\n                int k = xorValue ^ bitMap[x - \\'a\\'];\\n                ans += hashMap[k];\\n            }\\n            hashMap[xorValue]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1468114,
                "title": "c-perfix-xor-bitmasking-commented-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string str) {\\n      long long ans=0;\\n      int idx=0;  long long xorsum=0;\\n      unordered_map<long long,long long>mp;\\n      mp[xorsum]++;\\n      while(idx<str.length()){\\n         xorsum=xorsum^(1<<(str[idx]-\\'a\\'));\\n          // if xor is repeating it means it is having even ouccrences of all elements\\n          // after the previos ouccerence of xor.\\n         if(mp.find(xorsum)!=mp.end())\\n             ans+=mp[xorsum];\\n          mp[xorsum]++;\\n          // if xor will have at most 1 odd character than check by xoring with (a to j)\\n          // check correspondingly in the map\\n          for(int i=0;i<10;i++){\\n              long long temp=xorsum;\\n              temp=temp^(1<<i);\\n              if(mp.find(temp)!=mp.end())\\n                  ans+=mp[temp];\\n          }\\n          idx++;\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string str) {\\n      long long ans=0;\\n      int idx=0;  long long xorsum=0;\\n      unordered_map<long long,long long>mp;\\n      mp[xorsum]++;\\n      while(idx<str.length()){\\n         xorsum=xorsum^(1<<(str[idx]-\\'a\\'));\\n          // if xor is repeating it means it is having even ouccrences of all elements\\n          // after the previos ouccerence of xor.\\n         if(mp.find(xorsum)!=mp.end())\\n             ans+=mp[xorsum];\\n          mp[xorsum]++;\\n          // if xor will have at most 1 odd character than check by xoring with (a to j)\\n          // check correspondingly in the map\\n          for(int i=0;i<10;i++){\\n              long long temp=xorsum;\\n              temp=temp^(1<<i);\\n              if(mp.find(temp)!=mp.end())\\n                  ans+=mp[temp];\\n          }\\n          idx++;\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1458246,
                "title": "prefix-sum-bit-representation-to-compress-the-space-with-some-optimizations-in-comments",
                "content": "```scala\\n  def wonderfulSubstrings(word: String): Long = {\\n    var count = 0L\\n    type int = Int\\n\\n    var max = \\'a\\'    \\n    word.toCharArray.foreach(c => { if (c > max) max = c })   // find the max char, so that we can reduce the possible number of chars a bit \\n    val tchar = max - \\'a\\' + 1\\n    val cs    = Array.ofDim[int](tchar)    // use 0/1 represent the odd or even \\n    import scala.collection.mutable.{HashMap, HashSet}\\n    val set = new HashSet[Char]    // always only check with existed char\\n    val map = new HashMap[int, Long]\\n\\n    def f(cs: Array[int], one: int): int = {\\n      var x = 0\\n      (0 until tchar).map(i => {\\n        val t = if (i != one) {\\n          cs(i)\\n        } else { if (cs(i) == 1) 0 else 1 }\\n        if (t == 1) x = (x | (1 << i))\\n      })\\n      x\\n    }\\n\\n    map += (0 -> 1L)\\n\\n    word.toCharArray.foreach(c => {\\n\\n      cs(c - \\'a\\') ^= 1\\n      set += c\\n\\n      (-1 until tchar).foreach(one => {\\n        if (one == -1 || set.contains((\\'a\\' + one).toChar))\\n          count += map.getOrElse(f(cs, one), 0L)\\n      })\\n      val curr = f(cs, -1)\\n\\n      map.put(curr, map.getOrElse(curr, 0L) + 1L)\\n\\n    })\\n\\n    count\\n  }\\n```",
                "solutionTags": [],
                "code": "```scala\\n  def wonderfulSubstrings(word: String): Long = {\\n    var count = 0L\\n    type int = Int\\n\\n    var max = \\'a\\'    \\n    word.toCharArray.foreach(c => { if (c > max) max = c })   // find the max char, so that we can reduce the possible number of chars a bit \\n    val tchar = max - \\'a\\' + 1\\n    val cs    = Array.ofDim[int](tchar)    // use 0/1 represent the odd or even \\n    import scala.collection.mutable.{HashMap, HashSet}\\n    val set = new HashSet[Char]    // always only check with existed char\\n    val map = new HashMap[int, Long]\\n\\n    def f(cs: Array[int], one: int): int = {\\n      var x = 0\\n      (0 until tchar).map(i => {\\n        val t = if (i != one) {\\n          cs(i)\\n        } else { if (cs(i) == 1) 0 else 1 }\\n        if (t == 1) x = (x | (1 << i))\\n      })\\n      x\\n    }\\n\\n    map += (0 -> 1L)\\n\\n    word.toCharArray.foreach(c => {\\n\\n      cs(c - \\'a\\') ^= 1\\n      set += c\\n\\n      (-1 until tchar).foreach(one => {\\n        if (one == -1 || set.contains((\\'a\\' + one).toChar))\\n          count += map.getOrElse(f(cs, one), 0L)\\n      })\\n      val curr = f(cs, -1)\\n\\n      map.put(curr, map.getOrElse(curr, 0L) + 1L)\\n\\n    })\\n\\n    count\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1414555,
                "title": "50-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string word) {\\n        int n=word.size();\\n        vector<int> dp(n);\\n        vector<int> cnt(1<<10, 0);\\n        dp[0]=1<<(word[0]-\\'a\\');\\n        cnt[dp[0]]=1; cnt[0]=1;\\n        long long int ans=1;\\n        for(int i=1; i<n; i++) {\\n            dp[i]=dp[i-1]^(1<<(word[i]-\\'a\\'));\\n            ans+=cnt[dp[i]];\\n            for(int j=0; j<10; j++) {\\n                ans+=cnt[dp[i]^(1<<j)];\\n            }\\n            cnt[dp[i]]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string word) {\\n        int n=word.size();\\n        vector<int> dp(n);\\n        vector<int> cnt(1<<10, 0);\\n        dp[0]=1<<(word[0]-\\'a\\');\\n        cnt[dp[0]]=1; cnt[0]=1;\\n        long long int ans=1;\\n        for(int i=1; i<n; i++) {\\n            dp[i]=dp[i-1]^(1<<(word[i]-\\'a\\'));\\n            ans+=cnt[dp[i]];\\n            for(int j=0; j<10; j++) {\\n                ans+=cnt[dp[i]^(1<<j)];\\n            }\\n            cnt[dp[i]]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1412662,
                "title": "c-soltuion",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    long long wonderfulSubstrings(string s) \\n    {\\n        int n=s.size();\\n        map<long long,long long>mp;\\n        mp[0]=1;\\n        long long count=0;\\n        long long mask=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            mask=mask^(1<<(s[i]-\\'a\\'));\\n            if(mp.count(mask))\\n            {\\n                count+=mp[mask];\\n            }\\n            for(char j=\\'a\\';j<=\\'j\\';j++)\\n            {\\n                long long x=mask^(1<<(j-\\'a\\'));\\n                if(mp.count(x))\\n                {\\n                    count+=mp[x];\\n                }\\n            }\\n            mp[mask]++;\\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    long long wonderfulSubstrings(string s) \\n    {\\n        int n=s.size();\\n        map<long long,long long>mp;\\n        mp[0]=1;\\n        long long count=0;\\n        long long mask=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            mask=mask^(1<<(s[i]-\\'a\\'));\\n            if(mp.count(mask))\\n            {\\n                count+=mp[mask];\\n            }\\n            for(char j=\\'a\\';j<=\\'j\\';j++)\\n            {\\n                long long x=mask^(1<<(j-\\'a\\'));\\n                if(mp.count(x))\\n                {\\n                    count+=mp[x];\\n                }\\n            }\\n            mp[mask]++;\\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1412294,
                "title": "python-prefix-sum-no-bit-vector-slow-but-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def wonderfulSubstrings(self, word: str) -> int:\\n        prefix = collections.defaultdict(int)\\n        prefix[(0,0,0,0,0,0,0,0,0,0)] = 1\\n        count = {c: 0 for c in \\'abcdefghij\\'}\\n        ans = 0\\n        for letter in word:\\n            count[letter]+=1\\n            current = [count[c]%2 for c in \\'abcdefghij\\']\\n            currentAsTuple = tuple(current)\\n            for i, subletter in enumerate(\\'abcdefghij\\'):\\n                prev = current[i]\\n                current[i] = (count[subletter]+1)%2\\n                ans+=prefix[tuple(current)]\\n                current[i] = prev\\n            ans+=prefix[currentAsTuple]\\n            prefix[currentAsTuple]+=1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def wonderfulSubstrings(self, word: str) -> int:\\n        prefix = collections.defaultdict(int)\\n        prefix[(0,0,0,0,0,0,0,0,0,0)] = 1\\n        count = {c: 0 for c in \\'abcdefghij\\'}\\n        ans = 0\\n        for letter in word:\\n            count[letter]+=1\\n            current = [count[c]%2 for c in \\'abcdefghij\\']\\n            currentAsTuple = tuple(current)\\n            for i, subletter in enumerate(\\'abcdefghij\\'):\\n                prev = current[i]\\n                current[i] = (count[subletter]+1)%2\\n                ans+=prefix[tuple(current)]\\n                current[i] = prev\\n            ans+=prefix[currentAsTuple]\\n            prefix[currentAsTuple]+=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1404944,
                "title": "26-n",
                "content": "```\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string s) \\n    {\\n       int bits = 0;\\n       unordered_map<int,int> um;\\n       int a[26] = {0};\\n       long long int ans = 0;\\n       um[0]++;\\n       for(int i = 0;i < s.size();i++){\\n           int index = s[i]-\\'a\\';\\n           a[index]++;\\n           bits = bits^(1<<index);\\n           ans += solve(um,bits);\\n           um[bits]++;\\n       }\\n       return ans;\\n    }\\n    int solve(unordered_map<int,int>& um,int bits){\\n        int ans = 0;\\n        for(int i = 0;i < 10;i++){\\n           int a =  bits^(1<<i);\\n           if(um.find(a)!=um.end())\\n            ans += um[a];  \\n        }\\n        if(um.find(bits) != um.end())\\n        ans += um[bits];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string s) \\n    {\\n       int bits = 0;\\n       unordered_map<int,int> um;\\n       int a[26] = {0};\\n       long long int ans = 0;\\n       um[0]++;\\n       for(int i = 0;i < s.size();i++){\\n           int index = s[i]-\\'a\\';\\n           a[index]++;\\n           bits = bits^(1<<index);\\n           ans += solve(um,bits);\\n           um[bits]++;\\n       }\\n       return ans;\\n    }\\n    int solve(unordered_map<int,int>& um,int bits){\\n        int ans = 0;\\n        for(int i = 0;i < 10;i++){\\n           int a =  bits^(1<<i);\\n           if(um.find(a)!=um.end())\\n            ans += um[a];  \\n        }\\n        if(um.find(bits) != um.end())\\n        ans += um[bits];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1352473,
                "title": "c-easy-bitset-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n\\tlong long wonderfulSubstrings(string word) {\\n\\t\\tmap<long long, long long>m;\\n\\t\\tbitset<26> f(0), occur(0); long long cnt = 0;\\n\\t\\tm[(long long)(f.to_ulong())]++;\\n\\t\\tfor (long long i = 0; i < (long long)word.size(); i++) {\\n\\t\\t\\toccur[word[i] - \\'a\\'] = 1;\\n\\t\\t\\tf[word[i] - \\'a\\'] = !f[word[i] - \\'a\\'];\\n//             one change\\n\\t\\t\\tfor (long long j = 0; j < 26; j++)if (occur[j]) {\\n\\t\\t\\t\\t\\tf[j] = !f[j];\\n\\t\\t\\t\\t\\tcnt += m[(long long)(f.to_ulong())];\\n\\t\\t\\t\\t\\tf[j] = !f[j];\\n\\t\\t\\t\\t}\\n//             no change\\n\\t\\t\\tcnt += m[(long long)(f.to_ulong())]++;\\n\\t\\t}\\n\\t\\treturn cnt;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tlong long wonderfulSubstrings(string word) {\\n\\t\\tmap<long long, long long>m;\\n\\t\\tbitset<26> f(0), occur(0); long long cnt = 0;\\n\\t\\tm[(long long)(f.to_ulong())]++;\\n\\t\\tfor (long long i = 0; i < (long long)word.size(); i++) {\\n\\t\\t\\toccur[word[i] - \\'a\\'] = 1;\\n\\t\\t\\tf[word[i] - \\'a\\'] = !f[word[i] - \\'a\\'];\\n//             one change\\n\\t\\t\\tfor (long long j = 0; j < 26; j++)if (occur[j]) {\\n\\t\\t\\t\\t\\tf[j] = !f[j];\\n\\t\\t\\t\\t\\tcnt += m[(long long)(f.to_ulong())];\\n\\t\\t\\t\\t\\tf[j] = !f[j];\\n\\t\\t\\t\\t}\\n//             no change\\n\\t\\t\\tcnt += m[(long long)(f.to_ulong())]++;\\n\\t\\t}\\n\\t\\treturn cnt;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1310105,
                "title": "scala-solution-bit-mask",
                "content": "```\\n\\tdef wonderfulSubstrings(word: String): Long = {\\n        var count = 0L\\n        val map = scala.collection.mutable.Map[Int,Int]().withDefaultValue(0)\\n        map(0) = 1\\n        var mask = 0\\n        word.foreach{c =>\\n            mask = mask^(1 << (c-\\'a\\'))\\n            //For checking all even chars substring, as if we find same mask/parity earlier that means all the substring in between had even chars, as even-even = even and odd-odd=even\\n            count += map(mask)\\n            \\n            \\n            //Check for max 1 odd occurence, just see if the parity by toggling one bit is also seen before, which adds 1 to the result. We just need to test with 1 possible unique char so we can check the possible letter/index 0 to 9 the word\\n            for(n <- 0 to 9){\\n                val oddMask = mask^(1 << n)\\n                count += map(oddMask)\\n            }\\n            map(mask) += 1\\n        }\\n        count\\n    }\\n```\\t",
                "solutionTags": [],
                "code": "```\\n\\tdef wonderfulSubstrings(word: String): Long = {\\n        var count = 0L\\n        val map = scala.collection.mutable.Map[Int,Int]().withDefaultValue(0)\\n        map(0) = 1\\n        var mask = 0\\n        word.foreach{c =>\\n            mask = mask^(1 << (c-\\'a\\'))\\n            //For checking all even chars substring, as if we find same mask/parity earlier that means all the substring in between had even chars, as even-even = even and odd-odd=even\\n            count += map(mask)\\n            \\n            \\n            //Check for max 1 odd occurence, just see if the parity by toggling one bit is also seen before, which adds 1 to the result. We just need to test with 1 possible unique char so we can check the possible letter/index 0 to 9 the word\\n            for(n <- 0 to 9){\\n                val oddMask = mask^(1 << n)\\n                count += map(oddMask)\\n            }\\n            map(mask) += 1\\n        }\\n        count\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1308168,
                "title": "java-10-lines-99",
                "content": "```\\npublic long wonderfulSubstrings(String word) {\\n\\tint cnt[]= new int[1024];\\n\\tcnt[0]= 1;\\n\\tlong ans= 0;\\n\\tfor(int pm=0, n= word.length(), i=0; i<n; i++){\\n\\t\\tpm^= 1<<(word.charAt(i)-\\'a\\');\\n\\t\\tfor(int b=1; b<1024; b<<=1) ans+= cnt[pm^b]; \\n\\t\\tans+= cnt[pm]++;\\n\\t}\\n\\treturn ans;\\n}",
                "solutionTags": [],
                "code": "```\\npublic long wonderfulSubstrings(String word) {\\n\\tint cnt[]= new int[1024];\\n\\tcnt[0]= 1;\\n\\tlong ans= 0;\\n\\tfor(int pm=0, n= word.length(), i=0; i<n; i++){\\n\\t\\tpm^= 1<<(word.charAt(i)-\\'a\\');\\n\\t\\tfor(int b=1; b<1024; b<<=1) ans+= cnt[pm^b]; \\n\\t\\tans+= cnt[pm]++;\\n\\t}\\n\\treturn ans;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1306533,
                "title": "c-bitsets-and-bitmasks-simple-solution",
                "content": "For each prefix, calculate frequency of characters from \\'a\\' to \\'j\\' and create a bitmask with 1 representing as odd frequency and 0 representing even frequency..\\nThen look for the number of substrings that have ended before current index and have either same bitmask or a bitmask with one bit flipped...\\nThese bitmasks will give Wonderful substrings\\n\\n```\\nclass Solution {\\nprivate:\\n    // frequency map for each bitmask\\n    unordered_map<int,long long> fm;\\npublic:\\n    long long wonderfulSubstrings(string word) {\\n        // bitset for representing odd and even frequencies from \\'a\\' to \\'j\\'\\n        bitset<10> bit(0);\\n        // initializing for zero frequency of all characters\\n        fm[0]++;\\n        long long ans=0;\\n        for(auto x:word){\\n            // the current character\\'s bit will flip because it gets an increment by 1 \\n            bit[x-\\'a\\']=~bit[x-\\'a\\'];\\n            // calculating equivalent integer value from bitset\\n            int mask=(int)(bit.to_ulong());\\n            // all the substrings starting from the indices with the same bitset value will be a wonderful substring as it will contain only even frequencies\\n            ans+=fm[mask];\\n            // also all the substrings starting from the indices having a diffence of only one bitset flipped will also be wonderful as it will contain only one odd character in it\\n            for(int i=0;i<10;i++){\\n                bit[i]= ~bit[i];\\n                ans+=fm[(int)(bit.to_ulong())];\\n                bit[i]= ~bit[i];\\n            }\\n            // at last increment the frequency of current mask\\n            fm[mask]++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    // frequency map for each bitmask\\n    unordered_map<int,long long> fm;\\npublic:\\n    long long wonderfulSubstrings(string word) {\\n        // bitset for representing odd and even frequencies from \\'a\\' to \\'j\\'\\n        bitset<10> bit(0);\\n        // initializing for zero frequency of all characters\\n        fm[0]++;\\n        long long ans=0;\\n        for(auto x:word){\\n            // the current character\\'s bit will flip because it gets an increment by 1 \\n            bit[x-\\'a\\']=~bit[x-\\'a\\'];\\n            // calculating equivalent integer value from bitset\\n            int mask=(int)(bit.to_ulong());\\n            // all the substrings starting from the indices with the same bitset value will be a wonderful substring as it will contain only even frequencies\\n            ans+=fm[mask];\\n            // also all the substrings starting from the indices having a diffence of only one bitset flipped will also be wonderful as it will contain only one odd character in it\\n            for(int i=0;i<10;i++){\\n                bit[i]= ~bit[i];\\n                ans+=fm[(int)(bit.to_ulong())];\\n                bit[i]= ~bit[i];\\n            }\\n            // at last increment the frequency of current mask\\n            fm[mask]++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1306107,
                "title": "swift-solution",
                "content": "For each prefix of the `word` let\\'s calc parity `mask`. i-th bit in `mask` correcpond to i-th char in `a...j`. If i-th bit is 0, then i-th char parity is even. If i-th bit is 1, then i-th char parity is odd.\\n\\nLet\\'s find the other prefixes whose masks differs from the current prefix mask by at most one bit.\\n```\\nclass Solution {\\n    func wonderfulSubstrings(_ word: String) -> Int {\\n        let word = word.map({ Int($0.asciiValue ?? 97) - 97 }) // a...j -> 0...9\\n        let maxChar = 10 // j is 10-th char\\n        var mask = 0 // prefix patiry mask\\n        var dict = [Int](repeating: 0, count: 1 << maxChar) // prefix parity mask counts\\n        var result = 0 // number of wonderful substrings\\n        dict[0] = 1 // for empty substring at start\\n        for char in word {\\n            mask ^= 1 << char // change char parity in mask\\n            result += dict[mask] // prior substrings with same parity mask\\n            for i in 0..<maxChar {\\n                result += dict[mask ^ (1 << i)] // prior substrings with one-bit-diff parity mask\\n            }\\n            dict[mask] += 1 // remember parity mask\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func wonderfulSubstrings(_ word: String) -> Int {\\n        let word = word.map({ Int($0.asciiValue ?? 97) - 97 }) // a...j -> 0...9\\n        let maxChar = 10 // j is 10-th char\\n        var mask = 0 // prefix patiry mask\\n        var dict = [Int](repeating: 0, count: 1 << maxChar) // prefix parity mask counts\\n        var result = 0 // number of wonderful substrings\\n        dict[0] = 1 // for empty substring at start\\n        for char in word {\\n            mask ^= 1 << char // change char parity in mask\\n            result += dict[mask] // prior substrings with same parity mask\\n            for i in 0..<maxChar {\\n                result += dict[mask ^ (1 << i)] // prior substrings with one-bit-diff parity mask\\n            }\\n            dict[mask] += 1 // remember parity mask\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1304803,
                "title": "c-100-time-using-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    long long wonderfulSubstrings(string word) {\\n        ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0);\\n        int cnt[1024]={1};\\n        long res=0;\\n        int n=word.length();\\n        int mask=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int ch=word[i]-\\'a\\';\\n            mask^=(1<<ch);\\n            res+=cnt[mask];//adding prev with same parity\\n            for(int j=0;j<10;j++)\\n            {\\n                res+=cnt[ mask ^ (1<<j) ];//adding prev with one parity different\\n            }\\n            cnt[mask]++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long wonderfulSubstrings(string word) {\\n        ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0);\\n        int cnt[1024]={1};\\n        long res=0;\\n        int n=word.length();\\n        int mask=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int ch=word[i]-\\'a\\';\\n            mask^=(1<<ch);\\n            res+=cnt[mask];//adding prev with same parity\\n            for(int j=0;j<10;j++)\\n            {\\n                res+=cnt[ mask ^ (1<<j) ];//adding prev with one parity different\\n            }\\n            cnt[mask]++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1303571,
                "title": "c-1915-number-of-wonderful-substrings",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string word) {\\n        long long ans = 0; \\n        int mask = 0; \\n        unordered_map<int, long long> freq = {{0, 1}}; \\n        \\n        for (auto& ch : word) {\\n            mask ^= 1 << (ch - \\'a\\'); \\n            ans += freq[mask]; \\n            for (int i = 0; i < 10; ++i) \\n                ans += freq[mask ^ (1 << i)]; \\n            ++freq[mask]; \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string word) {\\n        long long ans = 0; \\n        int mask = 0; \\n        unordered_map<int, long long> freq = {{0, 1}}; \\n        \\n        for (auto& ch : word) {\\n            mask ^= 1 << (ch - \\'a\\'); \\n            ans += freq[mask]; \\n            for (int i = 0; i < 10; ++i) \\n                ans += freq[mask ^ (1 << i)]; \\n            ++freq[mask]; \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1302115,
                "title": "bitmasking-c-faster-than-100-00-of-c-online-submissions",
                "content": "```\\nlong long wonderfulSubstrings(string word) {\\n        long long count[1024]={0};\\n        long long mask = 0;\\n        count[0] = 1;\\n        long long ans = 0;\\n        for(auto c:word){\\n            long long t = 1 << (c-\\'a\\');\\n            mask  ^= t;\\n            ans += count[mask]; // for even number of chars\\n            for(int i=0;i<10;i++){\\n                ans += count[mask^(1<<i)];   // for odd chars\\n            }\\n            count[mask]++;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nlong long wonderfulSubstrings(string word) {\\n        long long count[1024]={0};\\n        long long mask = 0;\\n        count[0] = 1;\\n        long long ans = 0;\\n        for(auto c:word){\\n            long long t = 1 << (c-\\'a\\');\\n            mask  ^= t;\\n            ans += count[mask]; // for even number of chars\\n            for(int i=0;i<10;i++){\\n                ans += count[mask^(1<<i)];   // for odd chars\\n            }\\n            count[mask]++;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1301666,
                "title": "javascript-bitmask-dp",
                "content": "```javascript\\nvar wonderfulSubstrings = function(word) {\\n    // create a bitmask for all wonderful substrings\\n    const allWonderfulSubstringsBitmask = new Array(11);\\n    for (let i = 0; i < 10; i++) {\\n        allWonderfulSubstringsBitmask[i] = 1 << i;\\n    }\\n    allWonderfulSubstringsBitmask[10] = 0;\\n    \\n    // create an array that will count how many times we see a bitmask\\n    const numTimesEachBitmask = new Array(2 ** 11).fill(0);\\n    \\n    const aCharCode = 97;   // \\'a\\'.charCodeAt(0)\\n    let bitMask = 0;\\n    let numWonderfulSubstrings = 0;\\n    for (let i = 0; i < word.length; i++) {\\n        // record the previous bitmask\\n        numTimesEachBitmask[bitMask]++;\\n\\n        // flip the bit for the character\\n        const charCode = word.charCodeAt(i);\\n        const charBitMask = 1 << (charCode - aCharCode);\\n        bitMask ^= charBitMask;\\n        \\n        // with the current bitmask, find the complimentary bitmask that will make the bitmask a\\n        // wonderful substring and add the number of times the complimentary value was seen\\n        for (const wonderfulSubstringsBitmask of allWonderfulSubstringsBitmask) {\\n            const complimentaryBitmask = wonderfulSubstringsBitmask ^ bitMask\\n            numWonderfulSubstrings += numTimesEachBitmask[complimentaryBitmask];\\n        }\\n    }\\n    return numWonderfulSubstrings;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Bit Manipulation"
                ],
                "code": "```javascript\\nvar wonderfulSubstrings = function(word) {\\n    // create a bitmask for all wonderful substrings\\n    const allWonderfulSubstringsBitmask = new Array(11);\\n    for (let i = 0; i < 10; i++) {\\n        allWonderfulSubstringsBitmask[i] = 1 << i;\\n    }\\n    allWonderfulSubstringsBitmask[10] = 0;\\n    \\n    // create an array that will count how many times we see a bitmask\\n    const numTimesEachBitmask = new Array(2 ** 11).fill(0);\\n    \\n    const aCharCode = 97;   // \\'a\\'.charCodeAt(0)\\n    let bitMask = 0;\\n    let numWonderfulSubstrings = 0;\\n    for (let i = 0; i < word.length; i++) {\\n        // record the previous bitmask\\n        numTimesEachBitmask[bitMask]++;\\n\\n        // flip the bit for the character\\n        const charCode = word.charCodeAt(i);\\n        const charBitMask = 1 << (charCode - aCharCode);\\n        bitMask ^= charBitMask;\\n        \\n        // with the current bitmask, find the complimentary bitmask that will make the bitmask a\\n        // wonderful substring and add the number of times the complimentary value was seen\\n        for (const wonderfulSubstringsBitmask of allWonderfulSubstringsBitmask) {\\n            const complimentaryBitmask = wonderfulSubstringsBitmask ^ bitMask\\n            numWonderfulSubstrings += numTimesEachBitmask[complimentaryBitmask];\\n        }\\n    }\\n    return numWonderfulSubstrings;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1301636,
                "title": "c-using-trie-data-structure-o-n-10-10-solution",
                "content": "So the idea is to maintain a mask of whether the number is appeared odd times or even times.\\nSo for any substring ending at i. we need to find all the index j < i such that the mask on j follows : \\n\\nmask[i]^mask[j] contains only 1 set bit or zero set bit. we can traverse on all possible required mask which is only 10 + 1 (for mask = 0).\\n\\nthen in trie. we can easily find the number of masks having desired mask to make mask[i] zor equal to the required bit if you\\'re familiar enough with trie data structure. You can see the code if you want to see the implementation.\\n\\n```\\ntypedef struct data\\n{\\n    data* bit[2];\\n    int pref_cnt = 0; //0 means nothing here\\n}trie;\\ntrie* head;\\n\\nvoid insert(int x){\\n    trie* curr = head;\\n    for(int i=31;i>=0;i--){\\n        int b = (x >> i) & 1;\\n        if(!curr->bit[b]) curr->bit[b] = new trie();\\n        curr = curr->bit[b];\\n        curr->pref_cnt++;\\n    }\\n}\\n\\nint find(int x, int make){\\n    trie* curr = head;\\n    for(int shift = 31; shift >= 0; shift--){\\n        int currbit = (x >> shift) & 1;\\n        int currbitofmake = (make >> shift) & 1;\\n        int req;\\n        if(currbitofmake == 0) req = currbit;\\n        else req = 1 - currbit;\\n        if(curr->bit[req]){\\n            curr = curr->bit[req];\\n        }\\n        else return 0;\\n    }\\n    return curr->pref_cnt;\\n}\\n\\nvoid test_case() {\\n    int n; cin >> n;\\n    vector<int> a(n); for(int i=0;i<n;i++) cin >> a[i], a[i]--;\\n    int mask = 0;\\n    head = new trie();\\n    int ans = 0;\\n    insert(mask);\\n    for(int i=0;i<n;i++){\\n        mask = mask ^ (1 << a[i]);\\n        for(int j=0;j<10;j++){\\n            ans += find(mask,1<<j);\\n        }\\n        ans += find(mask,0);\\n        insert(mask);\\n    }\\n    cout << ans << endl;\\n}\\n```",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```\\ntypedef struct data\\n{\\n    data* bit[2];\\n    int pref_cnt = 0; //0 means nothing here\\n}trie;\\ntrie* head;\\n\\nvoid insert(int x){\\n    trie* curr = head;\\n    for(int i=31;i>=0;i--){\\n        int b = (x >> i) & 1;\\n        if(!curr->bit[b]) curr->bit[b] = new trie();\\n        curr = curr->bit[b];\\n        curr->pref_cnt++;\\n    }\\n}\\n\\nint find(int x, int make){\\n    trie* curr = head;\\n    for(int shift = 31; shift >= 0; shift--){\\n        int currbit = (x >> shift) & 1;\\n        int currbitofmake = (make >> shift) & 1;\\n        int req;\\n        if(currbitofmake == 0) req = currbit;\\n        else req = 1 - currbit;\\n        if(curr->bit[req]){\\n            curr = curr->bit[req];\\n        }\\n        else return 0;\\n    }\\n    return curr->pref_cnt;\\n}\\n\\nvoid test_case() {\\n    int n; cin >> n;\\n    vector<int> a(n); for(int i=0;i<n;i++) cin >> a[i], a[i]--;\\n    int mask = 0;\\n    head = new trie();\\n    int ans = 0;\\n    insert(mask);\\n    for(int i=0;i<n;i++){\\n        mask = mask ^ (1 << a[i]);\\n        for(int j=0;j<10;j++){\\n            ans += find(mask,1<<j);\\n        }\\n        ans += find(mask,0);\\n        insert(mask);\\n    }\\n    cout << ans << endl;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1301549,
                "title": "java-bitmask-prefix-intuition-from-prefix-sum",
                "content": "```\\nclass Solution {\\n    public long wonderfulSubstrings(String word) {\\n        Map<Integer, Long> map = new HashMap<>();\\n        map.put(0, 1l);\\n        int val = 0;\\n        long res = 0;\\n        for(char c : word.toCharArray()) {\\n            int idx = c - \\'a\\';\\n            val ^= (1 << idx);\\n            if(map.containsKey(val)) {\\n                res += map.get(val);\\n            }\\n            \\n            for(int i = 0; i < 10; ++i) {\\n                int mask = val ^ (1 << i);\\n                if(map.containsKey(mask)) {\\n                    res += map.get(mask);\\n                }\\n            }\\n            map.put(val, map.getOrDefault(val, 0l) + 1);\\n        }\\n        \\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long wonderfulSubstrings(String word) {\\n        Map<Integer, Long> map = new HashMap<>();\\n        map.put(0, 1l);\\n        int val = 0;\\n        long res = 0;\\n        for(char c : word.toCharArray()) {\\n            int idx = c - \\'a\\';\\n            val ^= (1 << idx);\\n            if(map.containsKey(val)) {\\n                res += map.get(val);\\n            }\\n            \\n            for(int i = 0; i < 10; ++i) {\\n                int mask = val ^ (1 << i);\\n                if(map.containsKey(mask)) {\\n                    res += map.get(mask);\\n                }\\n            }\\n            map.put(val, map.getOrDefault(val, 0l) + 1);\\n        }\\n        \\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1301215,
                "title": "c-100-cpp-bitmasking-8-lines-code",
                "content": "```\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string word) {\\n        long long int dp[1<<11],ans=(1<<11)-1,n=word.size(),res=0;\\n        memset(dp,0,sizeof(dp));\\n        dp[ans]+=1;\\n        for (int i=0;i<n;i++){\\n            ans^=(1<<(word[i]-\\'a\\'));\\n            res+=dp[ans];\\n            for (int j=0;j<11;j++)\\n            res+=dp[ans^(1<<j)];\\n            dp[ans]+=1;\\n        }\\n        return res;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long wonderfulSubstrings(string word) {\\n        long long int dp[1<<11],ans=(1<<11)-1,n=word.size(),res=0;\\n        memset(dp,0,sizeof(dp));\\n        dp[ans]+=1;\\n        for (int i=0;i<n;i++){\\n            ans^=(1<<(word[i]-\\'a\\'));\\n            res+=dp[ans];\\n            for (int j=0;j<11;j++)\\n            res+=dp[ans^(1<<j)];\\n            dp[ans]+=1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1301195,
                "title": "python-easiest-soln-bit-masking",
                "content": "```\\nclass Solution:\\n    def wonderfulSubstrings(self, word: str) -> int:\\n        dp=defaultdict(int)\\n        ans=2**(26)-1\\n        kk=ans\\n        dp[ans]=1\\n        n=len(word)\\n        res=0\\n        l=[2**i for i in range(26)]\\n        for i in range(n):\\n            ans^=2**(ord(word[i])-97)\\n            if (dp[ans]!=0):\\n                res+=dp[ans]\\n            ma=0\\n            for j in l:\\n                ff=ans\\n                ff^=j\\n                ma+=dp[ff]\\n            res+=ma\\n            dp[ans]+=1\\n        return res",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def wonderfulSubstrings(self, word: str) -> int:\\n        dp=defaultdict(int)\\n        ans=2**(26)-1\\n        kk=ans\\n        dp[ans]=1\\n        n=len(word)\\n        res=0\\n        l=[2**i for i in range(26)]\\n        for i in range(n):\\n            ans^=2**(ord(word[i])-97)\\n            if (dp[ans]!=0):\\n                res+=dp[ans]\\n            ma=0\\n            for j in l:\\n                ff=ans\\n                ff^=j\\n                ma+=dp[ff]\\n            res+=ma\\n            dp[ans]+=1\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1300891,
                "title": "python-3-prefix-bit-mask",
                "content": "```\\nclass Solution:\\n    def wonderfulSubstrings(self, word: str) -> int:\\n        n = len(word)\\n        mask = 0\\n        prefix = defaultdict(int)\\n        prefix[0] += 1\\n        ans = 0\\n        for w in word:\\n            mask ^= 1 << (ord(w) - ord(\\'a\\'))\\n            # no difference\\n            ans += prefix[mask]\\n            for i in range(10):\\n                # only differed by one digit \\n                tmp = mask ^ (1 << i)\\n                ans += prefix[tmp]\\n            prefix[mask] += 1\\n        return ans\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def wonderfulSubstrings(self, word: str) -> int:\\n        n = len(word)\\n        mask = 0\\n        prefix = defaultdict(int)\\n        prefix[0] += 1\\n        ans = 0\\n        for w in word:\\n            mask ^= 1 << (ord(w) - ord(\\'a\\'))\\n            # no difference\\n            ans += prefix[mask]\\n            for i in range(10):\\n                # only differed by one digit \\n                tmp = mask ^ (1 << i)\\n                ans += prefix[tmp]\\n            prefix[mask] += 1\\n        return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 1300583,
                "title": "c-concise-o-n-dp-solution-beats-100-with-explanation-and-comment",
                "content": "Idea:\\n1. Use bit mask to save the parity of \\'a\\'~\\'j\\' for each prefix (eg. var current)\\n2. Use total array to save the number of bit mask states up to now\\n3. Sum up the valid substrings (those differ in 0 or 1 bit with current state)\\n```\\nlong long wonderfulSubstrings(string& word) \\n{\\n\\tlong long result=0;\\n\\tint n=word.length(),total[1024]={0},current=0;\\n\\n\\ttotal[0]=1;\\n\\tfor(int i=0;i<n;i++)\\n\\t{\\n\\t\\tcurrent^=1<<(word[i]-\\'a\\'); // current state\\n\\t\\tresult+=total[current]; // differ in 0 bit\\n\\t\\tfor(int j=0;j<10;j++) result+=total[current^(1<<j)]; // differ in 1 bit\\n\\t\\ttotal[current]++; // accumulate current state into states count\\n\\t}\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nlong long wonderfulSubstrings(string& word) \\n{\\n\\tlong long result=0;\\n\\tint n=word.length(),total[1024]={0},current=0;\\n\\n\\ttotal[0]=1;\\n\\tfor(int i=0;i<n;i++)\\n\\t{\\n\\t\\tcurrent^=1<<(word[i]-\\'a\\'); // current state\\n\\t\\tresult+=total[current]; // differ in 0 bit\\n\\t\\tfor(int j=0;j<10;j++) result+=total[current^(1<<j)]; // differ in 1 bit\\n\\t\\ttotal[current]++; // accumulate current state into states count\\n\\t}\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1300369,
                "title": "c-bitmask-with-explanation",
                "content": "```\\nbool ok(int tmp){\\n    int ct=0;\\n    for(int i=0;i<10;i++) if(tmp&(1<<i)) ct++;\\n    return ct<=1;       //  ct=0 if every character has even frequency\\n    //  ct=1  if exactly one character has odd frequency\\n}\\n\\nclass Solution {\\npublic:\\nlong long wonderfulSubstrings(string s){\\n    unordered_map<int,int> mp;\\n    long long tmp=0,ans=0;\\n    for(int i=0;i<s.size();i++){\\n        int cur=s[i]-\\'a\\';\\n        tmp^=(1<<cur);\\n        ans+=mp[tmp];                               //  all characters are even in the substring formed by substracting a prefix string from s[0]~s[i] \\n        for(int i=0;i<10;i++) ans+=mp[tmp^(1<<i)];  //  \\'i\\'th character is odd in the substring formed by substracting a prefix string from s[0]~s[i]\\n        //  uptill now, we have only counted those substrings formed by substracting a prefix string from s[0]~s[i]\\n        //  However, s[0]~s[i] can also be wonderful string. So, using below line to count it\\n        ans+=ok(tmp);\\n        mp[tmp]++;\\n    }\\n    return ans;\\n}\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nbool ok(int tmp){\\n    int ct=0;\\n    for(int i=0;i<10;i++) if(tmp&(1<<i)) ct++;\\n    return ct<=1;       //  ct=0 if every character has even frequency\\n    //  ct=1  if exactly one character has odd frequency\\n}\\n\\nclass Solution {\\npublic:\\nlong long wonderfulSubstrings(string s){\\n    unordered_map<int,int> mp;\\n    long long tmp=0,ans=0;\\n    for(int i=0;i<s.size();i++){\\n        int cur=s[i]-\\'a\\';\\n        tmp^=(1<<cur);\\n        ans+=mp[tmp];                               //  all characters are even in the substring formed by substracting a prefix string from s[0]~s[i] \\n        for(int i=0;i<10;i++) ans+=mp[tmp^(1<<i)];  //  \\'i\\'th character is odd in the substring formed by substracting a prefix string from s[0]~s[i]\\n        //  uptill now, we have only counted those substrings formed by substracting a prefix string from s[0]~s[i]\\n        //  However, s[0]~s[i] can also be wonderful string. So, using below line to count it\\n        ans+=ok(tmp);\\n        mp[tmp]++;\\n    }\\n    return ans;\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1300291,
                "title": "c-bitmask",
                "content": "```\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string word) {\\n        int n=word.length();\\n        map<int,int>mp;\\n        mp[0]=1;\\n        int mask=0;\\n        long long cnt=0;\\n        int cpy=0;\\n        for(int i=0;i<n;i++){\\n            int val=word[i]-\\'a\\';\\n            mask^=(1<<val);\\n            if(mp[mask]!=0) cnt+=mp[mask];\\n            for(int bit=0;bit<=9;bit++){\\n                cpy=mask;\\n                cpy^=(1<<bit);\\n                if(mp[cpy]!=0){\\n                    cnt+=mp[cpy];\\n                }\\n            }\\n            mp[mask]++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string word) {\\n        int n=word.length();\\n        map<int,int>mp;\\n        mp[0]=1;\\n        int mask=0;\\n        long long cnt=0;\\n        int cpy=0;\\n        for(int i=0;i<n;i++){\\n            int val=word[i]-\\'a\\';\\n            mask^=(1<<val);\\n            if(mp[mask]!=0) cnt+=mp[mask];\\n            for(int bit=0;bit<=9;bit++){\\n                cpy=mask;\\n                cpy^=(1<<bit);\\n                if(mp[cpy]!=0){\\n                    cnt+=mp[cpy];\\n                }\\n            }\\n            mp[mask]++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1300164,
                "title": "c-bitmasks-prefix-sum-90ms",
                "content": "Create a mask where ith bit represents whether the ith character is odd or not in the prefix of string. We iterate in the array and update the bit masks accordingly.\\n\\nAfter that we need to find mask which are one bit apart fromt this mask and sum their frequency. We can also use an existing mask similar to current mask therefore add its frequency as well. \\n\\n```\\nlong long wonderfulSubstrings(string word) {\\n    int n = word.length();\\n    vector<int> freq(1050, 0); // for counting mask\\'s frequency\\n    freq[0] = 1; // initially no odd character in mask\\n\\n    long long ans = 0, mask = 0;\\n    for(int i = 1;i <= n;i++){\\n        int val = word[i - 1] - \\'a\\';\\n\\n        // update mask\\n        mask ^= 1<<val;\\n\\n        // calculate similar occurences\\n        ans += freq[mask];\\n\\n        // either add or remove this character and count existing occurences\\n        for(int j = 0;j < 10;j++){\\n            mask ^= 1<<j;\\n            ans += freq[mask];\\n            mask ^= 1<<j;\\n        }\\n\\n        freq[mask]++;\\n    }\\n\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nlong long wonderfulSubstrings(string word) {\\n    int n = word.length();\\n    vector<int> freq(1050, 0); // for counting mask\\'s frequency\\n    freq[0] = 1; // initially no odd character in mask\\n\\n    long long ans = 0, mask = 0;\\n    for(int i = 1;i <= n;i++){\\n        int val = word[i - 1] - \\'a\\';\\n\\n        // update mask\\n        mask ^= 1<<val;\\n\\n        // calculate similar occurences\\n        ans += freq[mask];\\n\\n        // either add or remove this character and count existing occurences\\n        for(int j = 0;j < 10;j++){\\n            mask ^= 1<<j;\\n            ans += freq[mask];\\n            mask ^= 1<<j;\\n        }\\n\\n        freq[mask]++;\\n    }\\n\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1300148,
                "title": "simple-c-solution-with-comments-using-bitmask-and-prefix",
                "content": "```\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string s) {\\n        int n=s.length();\\n        unordered_map<int,int> m;\\n        m[0]++;\\n        vector<int> f(10,0);\\n        long long ans=0;\\n        for(int i=0;i<n;i++){\\n            // increase the freq of the char\\n            f[s[i]-\\'a\\']++;\\n            int cur=0;\\n            // convert into a number whose bits in binary is set only if the freq is odd\\n            for(int j=0;j<10;j++){\\n                if(f[j]&1) cur|=(1<<j);\\n            }\\n            // check if the number is already present in the map\\n            if(m.count(cur)) ans+=m[cur];\\n            // try to invert only 1 bit and check for the solution as we can have atmost one letter with odd freq\\n            for(int j=0;j<10;j++){\\n                int c=cur;\\n                if(c&(1<<j)){ // if current bit is set\\n                    int x=~(1<<j);\\n                    c&=x;\\n                }\\n                else{ // if current bit is unset\\n                    c|=(1<<j);\\n                }\\n                if(m.count(c)) ans+=m[c];\\n            }\\n            m[cur]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string s) {\\n        int n=s.length();\\n        unordered_map<int,int> m;\\n        m[0]++;\\n        vector<int> f(10,0);\\n        long long ans=0;\\n        for(int i=0;i<n;i++){\\n            // increase the freq of the char\\n            f[s[i]-\\'a\\']++;\\n            int cur=0;\\n            // convert into a number whose bits in binary is set only if the freq is odd\\n            for(int j=0;j<10;j++){\\n                if(f[j]&1) cur|=(1<<j);\\n            }\\n            // check if the number is already present in the map\\n            if(m.count(cur)) ans+=m[cur];\\n            // try to invert only 1 bit and check for the solution as we can have atmost one letter with odd freq\\n            for(int j=0;j<10;j++){\\n                int c=cur;\\n                if(c&(1<<j)){ // if current bit is set\\n                    int x=~(1<<j);\\n                    c&=x;\\n                }\\n                else{ // if current bit is unset\\n                    c|=(1<<j);\\n                }\\n                if(m.count(c)) ans+=m[c];\\n            }\\n            m[cur]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1300060,
                "title": "javascript-bitmask-108ms",
                "content": "```\\nconst asi = (c) => c.charCodeAt();\\nconst wonderfulSubstrings = (s) => {\\n    let res = 0;\\n    let f = Array(2 ** 10).fill(0);\\n    f[0] = 1; // count array\\n    let cur = res = 0;\\n    for (const c of s) {\\n        cur ^= 1 << asi(c) - 97; // get Hash (the set bit for a character.), update prefix parity\\n        res += f[cur];\\n        for (let i = 0; i < 10; i++) { // a ~ j\\n            res += f[cur ^ 1 << i]; // 1 << i get Hash\\n        }\\n        f[cur]++;\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bitmask"
                ],
                "code": "```\\nconst asi = (c) => c.charCodeAt();\\nconst wonderfulSubstrings = (s) => {\\n    let res = 0;\\n    let f = Array(2 ** 10).fill(0);\\n    f[0] = 1; // count array\\n    let cur = res = 0;\\n    for (const c of s) {\\n        cur ^= 1 << asi(c) - 97; // get Hash (the set bit for a character.), update prefix parity\\n        res += f[cur];\\n        for (let i = 0; i < 10; i++) { // a ~ j\\n            res += f[cur ^ 1 << i]; // 1 << i get Hash\\n        }\\n        f[cur]++;\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1300050,
                "title": "similar-with-subarray-sum-equals-k-issue-o-10n-o-n-java",
                "content": "You must know how to do https://leetcode.com/problems/subarray-sum-equals-k/ with HashMap.\\n\\nThis problem is very similar with it.\\nBut it\\'s not just checking if map contains one value or not. Instead, it needs to check multiple values. \\n\\nThe map\\'s key is P[i], which is a integer number, the value is the frequency of this number.\\nP[i] means the numbers (only 0 or 1) of each characters from [0,i] in `word`. \\nFor example: `aba`\\nP[0]=1 means [a:1, b:0,c:0, d:0, e:0, f:0, g:0, h:0, i:0, j:0]\\nP[1]=3 means [a:1, b:1,c:0, d:0, e:0, f:0, g:0, h:0, i:0, j:0]\\nP[2]=2 means [a:0, b:1,c:0, d:0, e:0, f:0, g:0, h:0, i:0, j:0]\\n\\nFor each i (0<=i<word.length()), we know the total numbers of each character, and of course, we know the represent number P[i]\\n\\nThen, for each j (0<=j<i), P[j],\\nif (P[i]^P[j]) results in at most 1 bit, then we know the sub array from [j+1,i] is the result.\\n\\nFor example:\\nP[j]: [a:0, b:0,c:1, d:0, e:0, f:1, g:1, h:0, i:0, j:0]\\nP[i]: [a:0, b:0,c:1, d:0, e:1, f:1, g:1, h:0, i:0, j:0]\\nFind a subarray [j+1,i], during the subarray, at most `e` is odd\\n\\nOf course, you can\\'t loop the j, it will TLE.\\nBut we can try to forloop every bit of P[i] to help you find present numbers P[j]. Then add the frequency \\n\\n```\\nclass Solution {\\n long validNums(int num,  Map<Integer, Long> numbers) {\\n        long res = numbers.getOrDefault(num, 0L);\\n        //for loop to change i-th bit\\n        for(int i=0;i<10;i++) {\\n            int t = (int)Math.pow(2, i);\\n            int and = (num & t);\\n            if(and > 0) { //if this bit is 1\\n                int sub = num - t; //change this bit as 0\\n                res+=numbers.getOrDefault(sub, 0L);\\n            } else { //if this bit is 0\\n                int add = num + t; //change this bit as 1\\n                res+=numbers.getOrDefault(add, 0L);\\n            }\\n        }\\n        return res;\\n    }\\n    public long wonderfulSubstrings(String word) {\\n        Map<Integer, Long> numbers = new HashMap<>();\\n\\n        long result = 0;\\n        int sum = 0;\\n        numbers.put(0, 1L);\\n        for(int i=0;i<word.length();i++) {\\n            int j=word.charAt(i)-\\'a\\';\\n            int k = (int)Math.pow(2, j);\\n            sum = (sum ^ k);\\n\\n            result += validNums(sum, numbers);\\n            numbers.put(sum, numbers.getOrDefault(sum, 0L) + 1);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n long validNums(int num,  Map<Integer, Long> numbers) {\\n        long res = numbers.getOrDefault(num, 0L);\\n        //for loop to change i-th bit\\n        for(int i=0;i<10;i++) {\\n            int t = (int)Math.pow(2, i);\\n            int and = (num & t);\\n            if(and > 0) { //if this bit is 1\\n                int sub = num - t; //change this bit as 0\\n                res+=numbers.getOrDefault(sub, 0L);\\n            } else { //if this bit is 0\\n                int add = num + t; //change this bit as 1\\n                res+=numbers.getOrDefault(add, 0L);\\n            }\\n        }\\n        return res;\\n    }\\n    public long wonderfulSubstrings(String word) {\\n        Map<Integer, Long> numbers = new HashMap<>();\\n\\n        long result = 0;\\n        int sum = 0;\\n        numbers.put(0, 1L);\\n        for(int i=0;i<word.length();i++) {\\n            int j=word.charAt(i)-\\'a\\';\\n            int k = (int)Math.pow(2, j);\\n            sum = (sum ^ k);\\n\\n            result += validNums(sum, numbers);\\n            numbers.put(sum, numbers.getOrDefault(sum, 0L) + 1);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1299767,
                "title": "c-bitmask-prefix-sum",
                "content": "```c++\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string word) {\\n        long long count = 0;\\n        long int mask = 0;\\n        int n = word.size();\\n        unordered_map<int,long int>m;\\n        m[0] = 1;\\n        for(auto &i : word){\\n            int curr = i - \\'a\\';\\n            mask = mask^(1<<curr);\\n            for(int bit = 0;bit<=10;bit++){\\n                long int temp = mask^(1<<bit);\\n                if(m[temp] > 0){\\n                    count+=m[temp];\\n                }\\n            }\\n            count+=m[mask];\\n            m[mask]++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string word) {\\n        long long count = 0;\\n        long int mask = 0;\\n        int n = word.size();\\n        unordered_map<int,long int>m;\\n        m[0] = 1;\\n        for(auto &i : word){\\n            int curr = i - \\'a\\';\\n            mask = mask^(1<<curr);\\n            for(int bit = 0;bit<=10;bit++){\\n                long int temp = mask^(1<<bit);\\n                if(m[temp] > 0){\\n                    count+=m[temp];\\n                }\\n            }\\n            count+=m[mask];\\n            m[mask]++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1299703,
                "title": "c-prefix-bit-mask",
                "content": "```\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string word) {\\n        long long ans=0;\\n        int state=0;\\n        unordered_map<int,long long>prefix;\\n        prefix[0]++;\\n        for(int i=0;i<word.size();i++)\\n        {\\n            state=state^(1<<(word[i]-\\'a\\'));\\n            ans+=prefix[state];\\n            for(int i=0;i<11;i++)\\n            {\\n                int now=state^(1<<i);\\n                ans+=prefix[now];\\n            }\\n            prefix[state]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string word) {\\n        long long ans=0;\\n        int state=0;\\n        unordered_map<int,long long>prefix;\\n        prefix[0]++;\\n        for(int i=0;i<word.size();i++)\\n        {\\n            state=state^(1<<(word[i]-\\'a\\'));\\n            ans+=prefix[state];\\n            for(int i=0;i<11;i++)\\n            {\\n                int now=state^(1<<i);\\n                ans+=prefix[now];\\n            }\\n            prefix[state]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1299673,
                "title": "why-this-is-showing-tle-as-when-same-tle-input-while-testing-it-gives-output-plz-help",
                "content": "\\n    long long wonderfulSubstrings(string word) {\\n        int n=word.size();\\n         long long ans=0;\\n        for(int i=0;i<n;i++)\\n        {   \\n            vector<int> v(26,0);\\n            // v[word[i]-\\'a\\'];\\n            long long c=0;\\n            for(int j=i;j<n;j++)\\n            {\\n                 \\n             v[word[j]-\\'a\\']++;\\n             if( v[word[j]-\\'a\\']%2==0)\\n                 c--;\\n             else\\n                c++;\\n            if(c<=1)\\n              ans++;  \\n                // cout<<endl;\\n            }\\n            \\n            \\n        }\\n        \\n       \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "\\n    long long wonderfulSubstrings(string word) {\\n        int n=word.size();\\n         long long ans=0;\\n        for(int i=0;i<n;i++)\\n        {   \\n            vector<int> v(26,0);\\n            // v[word[i]-\\'a\\'];\\n            long long c=0;\\n            for(int j=i;j<n;j++)\\n            {\\n                 \\n             v[word[j]-\\'a\\']++;\\n             if( v[word[j]-\\'a\\']%2==0)\\n                 c--;\\n             else\\n                c++;\\n            if(c<=1)\\n              ans++;  \\n                // cout<<endl;\\n            }\\n            \\n            \\n        }\\n        \\n       \\n        return ans;\\n    }\\n};",
                "codeTag": "C++"
            },
            {
                "id": 1299534,
                "title": "what-is-wrong-in-this-solution-please-help",
                "content": "class Solution {\\npublic:\\n    \\n    bool task(string s)\\n    {\\n        int n = s.length();\\n        int c = 0;\\n        unordered_map<char,int>mp;\\n        for(int i=0 ;i<n ;i++)\\n            mp[s[i]]++;\\n        for(auto x:mp)\\n        {\\n            if((x.second%2)!=0)\\n                c++;\\n        }\\n        if(c<=1)\\n            return true;\\n        return false;\\n    }\\n    \\n    long long wonderfulSubstrings(string s) \\n    {\\n      int n = s.length();\\n      int dp[n][n];\\n      memset(dp,0,sizeof(dp));\\n      long long count = 0;\\n      for(int g=0 ;g<n ;g++)\\n      {\\n          for(int i=0 ,j=g ;j<n ;i++,j++)\\n          {\\n              if(g==0)\\n              {\\n                  dp[i][j] = 1;\\n              }\\n              else if(g==1)\\n              {\\n                  if(s[i]!=s[j])\\n                      dp[i][j] = 0;\\n                  else\\n                  {\\n                      dp[i][j]  = 1;\\n                  }\\n              }\\n              else{\\n                  string check = s.substr(i,j+1);\\n                  bool f = task(check);\\n                  if(f==true)\\n                  {\\n                      dp[i][j] = 1;\\n                  }\\n                  else\\n                      dp[i][j] = 0;\\n              }\\n          }\\n      }\\n      for(int i=0 ;i<n ;i++)\\n      {\\n          for(int j=0 ;j<n ;j++)\\n          {\\n              if(dp[i][j]==1)\\n                  count++;\\n          }\\n      }\\n      return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    bool task(string s)\\n    {\\n        int n = s.length();\\n        int c = 0;\\n        unordered_map<char,int>mp;\\n        for(int i=0 ;i<n ;i++)\\n            mp[s[i]]++;\\n        for(auto x:mp)\\n        {\\n            if((x.second%2)!=0)\\n                c++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1299517,
                "title": "c-easy-bitmask-dp-o-n",
                "content": "```\\n#define rep(i,a,b) for(int i=a;i<b;i++)\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string word) {\\n        vector<int> dp(10,0);\\n        long long ans=0;\\n        long long m1[1<<11];\\n        rep(i,0,1<<11-1) m1[i]=0;\\n        m1[0]++;\\n        for(int i=0;i<word.size();i++){\\n            dp[word[i]-\\'a\\']++;\\n            int s=0;\\n            rep(j,0,10) s+=(dp[j]%2==1?1<<j:0);\\n            m1[s]++;\\n            ans+= (m1[s]-1);\\n            rep(j,0,10) s=s^(1<<j),ans+=m1[s],s=s^(1<<j);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define rep(i,a,b) for(int i=a;i<b;i++)\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string word) {\\n        vector<int> dp(10,0);\\n        long long ans=0;\\n        long long m1[1<<11];\\n        rep(i,0,1<<11-1) m1[i]=0;\\n        m1[0]++;\\n        for(int i=0;i<word.size();i++){\\n            dp[word[i]-\\'a\\']++;\\n            int s=0;\\n            rep(j,0,10) s+=(dp[j]%2==1?1<<j:0);\\n            m1[s]++;\\n            ans+= (m1[s]-1);\\n            rep(j,0,10) s=s^(1<<j),ans+=m1[s],s=s^(1<<j);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1658407,
                "title": "c-bitmask-hash-table-xor",
                "content": "Use `prefix` to store the status of prefix sequence. \\nThe lowest 10 bits in `prefix` represents from `a` to `j`, and `1` represents odd number of time and `0` represents even number of time.\\n\\nUse `count` to store the count of all prefix bitmasks.\\n\\nIf a bitmask is **actually one bit different** from the `prefix`, the substring is a wonderful substring. (`tmp` in code)\\n\\nAnd do not forget to count `prefix` itself. (no letter appears an odd number of times.)\\n\\nTime: O(n)\\nSpace: O(n)\\n\\n```\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string word) {\\n        int n = word.size(), prefix = 0;\\n        long long res = 0;\\n        unordered_map<int,int> count;\\n        count[0] = 1;\\n        for (auto &c : word) {\\n            prefix ^= (1 << (c - \\'a\\'));\\n            \\n            for (int i = 0; i < 10; i++) {\\n                auto tmp = prefix ^ (1 << i);\\n                res += count[tmp];\\n            }\\n            \\n            res += count[prefix]++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long wonderfulSubstrings(string word) {\\n        int n = word.size(), prefix = 0;\\n        long long res = 0;\\n        unordered_map<int,int> count;\\n        count[0] = 1;\\n        for (auto &c : word) {\\n            prefix ^= (1 << (c - \\'a\\'));\\n            \\n            for (int i = 0; i < 10; i++) {\\n                auto tmp = prefix ^ (1 << i);\\n                res += count[tmp];\\n            }\\n            \\n            res += count[prefix]++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1570492,
                "content": [
                    {
                        "username": "yyoon",
                        "content": "Can you guys tell me why \\'aa\\' is wonderful word?\\n\\nI can\\'t understand what the question is saying."
                    },
                    {
                        "username": "madhuram241002",
                        "content": "ATMOST 1 means 1 or less than 1 (which is 0)"
                    },
                    {
                        "username": "ashitranjan1402",
                        "content": "Has anyone solved it using Sliding WIndow?"
                    },
                    {
                        "username": "huikinglam02",
                        "content": "The real deal of this problem is to realize the setup for linear DP: we don't need to record mask for all substrings ending at s[i]. We only need to record the mask of s[:i] and the relevant substrings are counted by dp[mask ^0] and dp[mask ^ (1 << ind)] because if s[j:i] satisfy the condition, dp would have been calculated before."
                    },
                    {
                        "username": "marcjeffs6",
                        "content": "To beat timelimit, do need to avoid finding all the substrings? How?"
                    },
                    {
                        "username": "harshitajaiswal",
                        "content": "not able to understand example 2 how \"aabb\" -> \"aabb\" is a wonderful string"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@pkinvincible](/pkinvincible) bcoz each char is present even times"
                    },
                    {
                        "username": "pkinvincible",
                        "content": "because there is a zero odd counts, which is less than 1 (at most 1)"
                    }
                ]
            },
            {
                "id": 1575463,
                "content": [
                    {
                        "username": "yyoon",
                        "content": "Can you guys tell me why \\'aa\\' is wonderful word?\\n\\nI can\\'t understand what the question is saying."
                    },
                    {
                        "username": "madhuram241002",
                        "content": "ATMOST 1 means 1 or less than 1 (which is 0)"
                    },
                    {
                        "username": "ashitranjan1402",
                        "content": "Has anyone solved it using Sliding WIndow?"
                    },
                    {
                        "username": "huikinglam02",
                        "content": "The real deal of this problem is to realize the setup for linear DP: we don't need to record mask for all substrings ending at s[i]. We only need to record the mask of s[:i] and the relevant substrings are counted by dp[mask ^0] and dp[mask ^ (1 << ind)] because if s[j:i] satisfy the condition, dp would have been calculated before."
                    },
                    {
                        "username": "marcjeffs6",
                        "content": "To beat timelimit, do need to avoid finding all the substrings? How?"
                    },
                    {
                        "username": "harshitajaiswal",
                        "content": "not able to understand example 2 how \"aabb\" -> \"aabb\" is a wonderful string"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@pkinvincible](/pkinvincible) bcoz each char is present even times"
                    },
                    {
                        "username": "pkinvincible",
                        "content": "because there is a zero odd counts, which is less than 1 (at most 1)"
                    }
                ]
            },
            {
                "id": 2070442,
                "content": [
                    {
                        "username": "yyoon",
                        "content": "Can you guys tell me why \\'aa\\' is wonderful word?\\n\\nI can\\'t understand what the question is saying."
                    },
                    {
                        "username": "madhuram241002",
                        "content": "ATMOST 1 means 1 or less than 1 (which is 0)"
                    },
                    {
                        "username": "ashitranjan1402",
                        "content": "Has anyone solved it using Sliding WIndow?"
                    },
                    {
                        "username": "huikinglam02",
                        "content": "The real deal of this problem is to realize the setup for linear DP: we don't need to record mask for all substrings ending at s[i]. We only need to record the mask of s[:i] and the relevant substrings are counted by dp[mask ^0] and dp[mask ^ (1 << ind)] because if s[j:i] satisfy the condition, dp would have been calculated before."
                    },
                    {
                        "username": "marcjeffs6",
                        "content": "To beat timelimit, do need to avoid finding all the substrings? How?"
                    },
                    {
                        "username": "harshitajaiswal",
                        "content": "not able to understand example 2 how \"aabb\" -> \"aabb\" is a wonderful string"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@pkinvincible](/pkinvincible) bcoz each char is present even times"
                    },
                    {
                        "username": "pkinvincible",
                        "content": "because there is a zero odd counts, which is less than 1 (at most 1)"
                    }
                ]
            },
            {
                "id": 1983454,
                "content": [
                    {
                        "username": "yyoon",
                        "content": "Can you guys tell me why \\'aa\\' is wonderful word?\\n\\nI can\\'t understand what the question is saying."
                    },
                    {
                        "username": "madhuram241002",
                        "content": "ATMOST 1 means 1 or less than 1 (which is 0)"
                    },
                    {
                        "username": "ashitranjan1402",
                        "content": "Has anyone solved it using Sliding WIndow?"
                    },
                    {
                        "username": "huikinglam02",
                        "content": "The real deal of this problem is to realize the setup for linear DP: we don't need to record mask for all substrings ending at s[i]. We only need to record the mask of s[:i] and the relevant substrings are counted by dp[mask ^0] and dp[mask ^ (1 << ind)] because if s[j:i] satisfy the condition, dp would have been calculated before."
                    },
                    {
                        "username": "marcjeffs6",
                        "content": "To beat timelimit, do need to avoid finding all the substrings? How?"
                    },
                    {
                        "username": "harshitajaiswal",
                        "content": "not able to understand example 2 how \"aabb\" -> \"aabb\" is a wonderful string"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@pkinvincible](/pkinvincible) bcoz each char is present even times"
                    },
                    {
                        "username": "pkinvincible",
                        "content": "because there is a zero odd counts, which is less than 1 (at most 1)"
                    }
                ]
            },
            {
                "id": 1916642,
                "content": [
                    {
                        "username": "yyoon",
                        "content": "Can you guys tell me why \\'aa\\' is wonderful word?\\n\\nI can\\'t understand what the question is saying."
                    },
                    {
                        "username": "madhuram241002",
                        "content": "ATMOST 1 means 1 or less than 1 (which is 0)"
                    },
                    {
                        "username": "ashitranjan1402",
                        "content": "Has anyone solved it using Sliding WIndow?"
                    },
                    {
                        "username": "huikinglam02",
                        "content": "The real deal of this problem is to realize the setup for linear DP: we don't need to record mask for all substrings ending at s[i]. We only need to record the mask of s[:i] and the relevant substrings are counted by dp[mask ^0] and dp[mask ^ (1 << ind)] because if s[j:i] satisfy the condition, dp would have been calculated before."
                    },
                    {
                        "username": "marcjeffs6",
                        "content": "To beat timelimit, do need to avoid finding all the substrings? How?"
                    },
                    {
                        "username": "harshitajaiswal",
                        "content": "not able to understand example 2 how \"aabb\" -> \"aabb\" is a wonderful string"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@pkinvincible](/pkinvincible) bcoz each char is present even times"
                    },
                    {
                        "username": "pkinvincible",
                        "content": "because there is a zero odd counts, which is less than 1 (at most 1)"
                    }
                ]
            }
        ]
    }
]