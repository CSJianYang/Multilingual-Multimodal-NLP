[
    {
        "title": "Minimum Window Substring",
        "question_content": "Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \"\".\nThe testcases will be generated such that the answer is unique.\n&nbsp;\nExample 1:\n\nInput: s = \"ADOBECODEBANC\", t = \"ABC\"\nOutput: \"BANC\"\nExplanation: The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string t.\n\nExample 2:\n\nInput: s = \"a\", t = \"a\"\nOutput: \"a\"\nExplanation: The entire string s is the minimum window.\n\nExample 3:\n\nInput: s = \"a\", t = \"aa\"\nOutput: \"\"\nExplanation: Both 'a's from t must be included in the window.\nSince the largest window of s only has one 'a', return empty string.\n\n&nbsp;\nConstraints:\n\n\tm == s.length\n\tn == t.length\n\t1 <= m, n <= 105\n\ts and t consist of uppercase and lowercase English letters.\n\n&nbsp;\nFollow up: Could you find an algorithm that runs in O(m + n) time?",
        "solutions": [
            {
                "id": 26808,
                "title": "here-is-a-10-line-template-that-can-solve-most-substring-problems",
                "content": "I will first give the solution then show you the magic template.\\n\\n**The code of solving this problem is below. It might be the shortest among all solutions provided in Discuss**.\\n\\n    string minWindow(string s, string t) {\\n            vector<int> map(128,0);\\n            for(auto c: t) map[c]++;\\n            int counter=t.size(), begin=0, end=0, d=INT_MAX, head=0;\\n            while(end<s.size()){\\n                if(map[s[end++]]-->0) counter--; //in t\\n                while(counter==0){ //valid\\n                    if(end-begin<d)  d=end-(head=begin);\\n                    if(map[s[begin++]]++==0) counter++;  //make it invalid\\n                }  \\n            }\\n            return d==INT_MAX? \"\":s.substr(head, d);\\n        }\\n\\n**Here comes the template.**\\n\\nFor most substring problem, we are given a string and need to find a substring of it which satisfy some restrictions. A general way is to use a hashmap assisted with two pointers. The template is given below.\\n \\n\\n    int findSubstring(string s){\\n            vector<int> map(128,0);\\n            int counter; // check whether the substring is valid\\n            int begin=0, end=0; //two pointers, one point to tail and one  head\\n            int d; //the length of substring\\n\\n            for() { /* initialize the hash map here */ }\\n    \\n            while(end<s.size()){\\n\\n                if(map[s[end++]]-- ?){  /* modify counter here */ }\\n    \\n                while(/* counter condition */){ \\n                     \\n                     /* update d here if finding minimum*/\\n\\n                    //increase begin to make it invalid/valid again\\n                    \\n                    if(map[s[begin++]]++ ?){ /*modify counter here*/ }\\n                }  \\n  \\n                /* update d here if finding maximum*/\\n            }\\n            return d;\\n      }\\n\\n*One thing needs to be mentioned is that when asked to find maximum substring, we should update maximum after the inner while loop to guarantee that the substring is valid. On the other hand, when asked to find minimum substring, we should update minimum inside the inner while loop.*\\n\\n\\nThe code of solving **Longest Substring with At Most Two Distinct Characters** is below:\\n\\n    int lengthOfLongestSubstringTwoDistinct(string s) {\\n            vector<int> map(128, 0);\\n            int counter=0, begin=0, end=0, d=0; \\n            while(end<s.size()){\\n                if(map[s[end++]]++==0) counter++;\\n                while(counter>2) if(map[s[begin++]]--==1) counter--;\\n                d=max(d, end-begin);\\n            }\\n            return d;\\n        }\\n\\nThe code of solving **Longest Substring Without Repeating Characters** is below:\\n\\n**Update 01.04.2016, thanks @weiyi3 for advise.**\\n\\n    int lengthOfLongestSubstring(string s) {\\n            vector<int> map(128,0);\\n            int counter=0, begin=0, end=0, d=0; \\n            while(end<s.size()){\\n                if(map[s[end++]]++>0) counter++; \\n                while(counter>0) if(map[s[begin++]]-->1) counter--;\\n                d=max(d, end-begin); //while valid, update d\\n            }\\n            return d;\\n        }\\n    \\nI think this post deserves some upvotes! : )",
                "solutionTags": [
                    "String"
                ],
                "code": "I will first give the solution then show you the magic template.\\n\\n**The code of solving this problem is below. It might be the shortest among all solutions provided in Discuss**.\\n\\n    string minWindow(string s, string t) {\\n            vector<int> map(128,0);\\n            for(auto c: t) map[c]++;\\n            int counter=t.size(), begin=0, end=0, d=INT_MAX, head=0;\\n            while(end<s.size()){\\n                if(map[s[end++]]-->0) counter--; //in t\\n                while(counter==0){ //valid\\n                    if(end-begin<d)  d=end-(head=begin);\\n                    if(map[s[begin++]]++==0) counter++;  //make it invalid\\n                }  \\n            }\\n            return d==INT_MAX? \"\":s.substr(head, d);\\n        }\\n\\n**Here comes the template.**\\n\\nFor most substring problem, we are given a string and need to find a substring of it which satisfy some restrictions. A general way is to use a hashmap assisted with two pointers. The template is given below.\\n \\n\\n    int findSubstring(string s){\\n            vector<int> map(128,0);\\n            int counter; // check whether the substring is valid\\n            int begin=0, end=0; //two pointers, one point to tail and one  head\\n            int d; //the length of substring\\n\\n            for() { /* initialize the hash map here */ }\\n    \\n            while(end<s.size()){\\n\\n                if(map[s[end++]]-- ?){  /* modify counter here */ }\\n    \\n                while(/* counter condition */){ \\n                     \\n                     /* update d here if finding minimum*/\\n\\n                    //increase begin to make it invalid/valid again\\n                    \\n                    if(map[s[begin++]]++ ?){ /*modify counter here*/ }\\n                }  \\n  \\n                /* update d here if finding maximum*/\\n            }\\n            return d;\\n      }\\n\\n*One thing needs to be mentioned is that when asked to find maximum substring, we should update maximum after the inner while loop to guarantee that the substring is valid. On the other hand, when asked to find minimum substring, we should update minimum inside the inner while loop.*\\n\\n\\nThe code of solving **Longest Substring with At Most Two Distinct Characters** is below:\\n\\n    int lengthOfLongestSubstringTwoDistinct(string s) {\\n            vector<int> map(128, 0);\\n            int counter=0, begin=0, end=0, d=0; \\n            while(end<s.size()){\\n                if(map[s[end++]]++==0) counter++;\\n                while(counter>2) if(map[s[begin++]]--==1) counter--;\\n                d=max(d, end-begin);\\n            }\\n            return d;\\n        }\\n\\nThe code of solving **Longest Substring Without Repeating Characters** is below:\\n\\n**Update 01.04.2016, thanks @weiyi3 for advise.**\\n\\n    int lengthOfLongestSubstring(string s) {\\n            vector<int> map(128,0);\\n            int counter=0, begin=0, end=0, d=0; \\n            while(end<s.size()){\\n                if(map[s[end++]]++>0) counter++; \\n                while(counter>0) if(map[s[begin++]]-->1) counter--;\\n                d=max(d, end-begin); //while valid, update d\\n            }\\n            return d;\\n        }\\n    \\nI think this post deserves some upvotes! : )",
                "codeTag": "Unknown"
            },
            {
                "id": 3164335,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        vector<int> map(128,0);\\n        for (char c : t) {\\n            map[c]++;\\n        }\\n\\n        int counter = t.size(), begin = 0, end = 0, d = INT_MAX, head = 0;\\n        while (end < s.size()){\\n            if (map[s[end++]]-- > 0) {\\n                counter--;\\n            }\\n            while (counter == 0) {\\n                if (end - begin < d) {\\n                    head = begin;\\n                    d = end - head;\\n                }\\n                if (map[s[begin++]]++ == 0) {\\n                    counter++;\\n                }\\n            }  \\n        }\\n        return d == INT_MAX ? \"\" : s.substr(head, d);\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def minWindow(self, s: str, t: str) -> str:\\n        if len(s) < len(t):\\n            return \"\"\\n        needstr = collections.defaultdict(int)\\n        for ch in t:\\n            needstr[ch] += 1\\n        needcnt = len(t)\\n        res = (0, float(\\'inf\\'))\\n        start = 0\\n        for end, ch in enumerate(s):\\n            if needstr[ch] > 0:\\n                needcnt -= 1\\n            needstr[ch] -= 1\\n            if needcnt == 0:\\n                while True:\\n                    tmp = s[start]\\n                    if needstr[tmp] == 0:\\n                        break\\n                    needstr[tmp] += 1\\n                    start += 1\\n                if end - start < res[1] - res[0]:\\n                    res = (start, end)\\n                needstr[s[start]] += 1\\n                needcnt += 1\\n                start += 1\\n        return \\'\\' if res[1] > len(s) else s[res[0]:res[1]+1]\\n```\\n\\n```Java []\\nclass Solution {\\n    public String minWindow(String s, String t) {\\n        if (s == null || t == null || s.length() ==0 || t.length() == 0 ||\\n                s.length() < t.length()) {\\n            return new String();\\n        }\\n        int[] map = new int[128];\\n        int count = t.length();\\n        int start = 0, end = 0, minLen = Integer.MAX_VALUE,startIndex =0;\\n        for (char c :t.toCharArray()) {\\n            map[c]++;\\n        }\\n        char[] chS = s.toCharArray();\\n        while (end < chS.length) {\\n            if (map[chS[end++]]-- >0) {\\n                count--;\\n            }\\n            while (count == 0) {\\n                if (end - start < minLen) {\\n                    startIndex = start;\\n                    minLen = end - start;\\n                }\\n                if (map[chS[start++]]++ == 0) {\\n                    count++;\\n                }\\n            }\\n        }\\n\\n        return minLen == Integer.MAX_VALUE? new String():\\n                new String(chS,startIndex,minLen);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        vector<int> map(128,0);\\n        for (char c : t) {\\n            map[c]++;\\n        }\\n\\n        int counter = t.size(), begin = 0, end = 0, d = INT_MAX, head = 0;\\n        while (end < s.size()){\\n            if (map[s[end++]]-- > 0) {\\n                counter--;\\n            }\\n            while (counter == 0) {\\n                if (end - begin < d) {\\n                    head = begin;\\n                    d = end - head;\\n                }\\n                if (map[s[begin++]]++ == 0) {\\n                    counter++;\\n                }\\n            }  \\n        }\\n        return d == INT_MAX ? \"\" : s.substr(head, d);\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def minWindow(self, s: str, t: str) -> str:\\n        if len(s) < len(t):\\n            return \"\"\\n        needstr = collections.defaultdict(int)\\n        for ch in t:\\n            needstr[ch] += 1\\n        needcnt = len(t)\\n        res = (0, float(\\'inf\\'))\\n        start = 0\\n        for end, ch in enumerate(s):\\n            if needstr[ch] > 0:\\n                needcnt -= 1\\n            needstr[ch] -= 1\\n            if needcnt == 0:\\n                while True:\\n                    tmp = s[start]\\n                    if needstr[tmp] == 0:\\n                        break\\n                    needstr[tmp] += 1\\n                    start += 1\\n                if end - start < res[1] - res[0]:\\n                    res = (start, end)\\n                needstr[s[start]] += 1\\n                needcnt += 1\\n                start += 1\\n        return \\'\\' if res[1] > len(s) else s[res[0]:res[1]+1]\\n```\n```Java []\\nclass Solution {\\n    public String minWindow(String s, String t) {\\n        if (s == null || t == null || s.length() ==0 || t.length() == 0 ||\\n                s.length() < t.length()) {\\n            return new String();\\n        }\\n        int[] map = new int[128];\\n        int count = t.length();\\n        int start = 0, end = 0, minLen = Integer.MAX_VALUE,startIndex =0;\\n        for (char c :t.toCharArray()) {\\n            map[c]++;\\n        }\\n        char[] chS = s.toCharArray();\\n        while (end < chS.length) {\\n            if (map[chS[end++]]-- >0) {\\n                count--;\\n            }\\n            while (count == 0) {\\n                if (end - start < minLen) {\\n                    startIndex = start;\\n                    minLen = end - start;\\n                }\\n                if (map[chS[start++]]++ == 0) {\\n                    count++;\\n                }\\n            }\\n        }\\n\\n        return minLen == Integer.MAX_VALUE? new String():\\n                new String(chS,startIndex,minLen);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 26804,
                "title": "12-lines-python",
                "content": "The current window is `s[i:j]` and the result window is `s[I:J]`. In `need[c]` I store how many times I need character `c` (can be negative) and `missing` tells how many characters are still missing. In the loop, first add the new character to the window. Then, if nothing is missing, remove as much as possible from the window start and then update the result.\\n\\n    def minWindow(self, s, t):\\n        need, missing = collections.Counter(t), len(t)\\n        i = I = J = 0\\n        for j, c in enumerate(s, 1):\\n            missing -= need[c] > 0\\n            need[c] -= 1\\n            if not missing:\\n                while i < j and need[s[i]] < 0:\\n                    need[s[i]] += 1\\n                    i += 1\\n                if not J or j - i <= J - I:\\n                    I, J = i, j\\n        return s[I:J]",
                "solutionTags": [
                    "Python"
                ],
                "code": "The current window is `s[i:j]` and the result window is `s[I:J]`. In `need[c]` I store how many times I need character `c` (can be negative) and `missing` tells how many characters are still missing. In the loop, first add the new character to the window. Then, if nothing is missing, remove as much as possible from the window start and then update the result.\\n\\n    def minWindow(self, s, t):\\n        need, missing = collections.Counter(t), len(t)\\n        i = I = J = 0\\n        for j, c in enumerate(s, 1):\\n            missing -= need[c] > 0\\n            need[c] -= 1\\n            if not missing:\\n                while i < j and need[s[i]] < 0:\\n                    need[s[i]] += 1\\n                    i += 1\\n                if not J or j - i <= J - I:\\n                    I, J = i, j\\n        return s[I:J]",
                "codeTag": "Python3"
            },
            {
                "id": 26810,
                "title": "java-solution-using-two-pointers-hashmap",
                "content": "    public class Solution {\\n    public String minWindow(String s, String t) {\\n        if(s == null || s.length() < t.length() || s.length() == 0){\\n            return \"\";\\n        }\\n        HashMap<Character,Integer> map = new HashMap<Character,Integer>();\\n        for(char c : t.toCharArray()){\\n            if(map.containsKey(c)){\\n                map.put(c,map.get(c)+1);\\n            }else{\\n                map.put(c,1);\\n            }\\n        }\\n        int left = 0;\\n        int minLeft = 0;\\n        int minLen = s.length()+1;\\n        int count = 0;\\n        for(int right = 0; right < s.length(); right++){\\n            if(map.containsKey(s.charAt(right))){\\n                map.put(s.charAt(right),map.get(s.charAt(right))-1);\\n                if(map.get(s.charAt(right)) >= 0){\\n                    count ++;\\n                }\\n                while(count == t.length()){\\n                    if(right-left+1 < minLen){\\n                        minLeft = left;\\n                        minLen = right-left+1;\\n                    }\\n                    if(map.containsKey(s.charAt(left))){\\n                        map.put(s.charAt(left),map.get(s.charAt(left))+1);\\n                        if(map.get(s.charAt(left)) > 0){\\n                            count --;\\n                        }\\n                    }\\n                    left ++ ;\\n                }\\n            }\\n        }\\n        if(minLen>s.length())  \\n        {  \\n            return \"\";  \\n        }  \\n        \\n        return s.substring(minLeft,minLeft+minLen);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String minWindow(String s, String t) {\\n        if(s == null || s.length() < t.length() || s.length() == 0){\\n            return \"\";\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 266059,
                "title": "why-you-failed-the-last-test-case-an-interesting-bug-when-i-used-two-hashmaps-in-java",
                "content": "The logic of my code is just as most other people, to use two HashMap to count t and s. \\nI encountered an interesting bug. The code is as following:\\n```\\n\\npublic String minWindow(String s, String t) {\\n        char[] ss = s.toCharArray();\\n        char[] tt = t.toCharArray();\\n        Map<Character, Integer> map_s = new HashMap<>();\\n        Map<Character, Integer> map_t = new HashMap<>();\\n        int end = 0;\\n        for (int i = 0; i < tt.length; i++) {\\n            char c = tt[i];\\n            map_t.put(c, map_t.getOrDefault(c, 0) + 1);\\n            if (!map_s.containsKey(c) || map_s.get(c) < map_t.get(c)) { \\n                while(end < ss.length && ss[end] != c) {\\n                    map_s.put(ss[end], map_s.getOrDefault(ss[end], 0) + 1);\\n                    end++;\\n                }\\n                if (end == ss.length) return \"\";\\n                map_s.put(c, map_t.get(c));\\n                end++;\\n            }\\n        }\\n        int min = end;\\n        int st = 0;\\n        for (int i = 0; i < end; i++) {\\n            char c = ss[i];\\n            if (c == \\'m\\') {\\n                if (!map_s.containsKey(c) || !map_t.containsKey(c)) continue;\\n                if (map_s.get(c) == 423 && map_t.get(c) == 423 && map_s.get(c) != map_t.get(c)) {\\n                    System.out.println(\"What the hell is going on here?\");\\n                }\\n            }\\n            if (map_t.containsKey(c)) {\\n                if (map_s.get(c) == map_t.get(c)) {\\n                    if (end - i < min) {\\n                        st = i;\\n                        min = end - i;\\n                    }\\n                    while(end < ss.length && ss[end] != c) {\\n                        if (map_t.containsKey(ss[end])) map_s.put(ss[end], map_s.get(ss[end]) + 1);\\n                        end++;\\n                    }\\n                    if (end == ss.length) break;\\n                    end++;\\n                } else {\\n                    map_s.put(c, map_s.get(c) - 1);\\n                }\\n            }\\n        }\\n        return s.substring(st, st + min);\\n    }\\n```\\n\\nIf you copy paste my code, you\\'ll see it passes 267/268 but fails at the last test case. And you\\'ll see in the last test case, \\nthe code will outpu :\"What the hell is going on here?\".\\n\\nThe algorithm logic of my code is 100% correct. But something wrong happened in the implementation. As you see, when map_s.get(c) == 423 &&  map_t.get(c) == 423, actuall map_s.get(c) != map_t.get(c). Interesting and annoying(it took me a few hours to discover this bug T_T), but why?\\n\\nThe reason is when you put into maps some int value as Integer, the autoboxing process calls the \\'valueOf()\\' method. The \\'valueOf()\\' function would return the reference of the object from Integer cache if the value is in the range of -128~127. However, like in the above test case, the two values are 423, then \\'valueOf()\\' function return two different references when we put 423 into the two maps. In this case, the two Integers, both has value of 423, are two different objects, and they are not == to each other! \\n\\nSo guys we should really be careful when compare two Integer objects instead of two int!!!",
                "solutionTags": [],
                "code": "```\\n\\npublic String minWindow(String s, String t) {\\n        char[] ss = s.toCharArray();\\n        char[] tt = t.toCharArray();\\n        Map<Character, Integer> map_s = new HashMap<>();\\n        Map<Character, Integer> map_t = new HashMap<>();\\n        int end = 0;\\n        for (int i = 0; i < tt.length; i++) {\\n            char c = tt[i];\\n            map_t.put(c, map_t.getOrDefault(c, 0) + 1);\\n            if (!map_s.containsKey(c) || map_s.get(c) < map_t.get(c)) { \\n                while(end < ss.length && ss[end] != c) {\\n                    map_s.put(ss[end], map_s.getOrDefault(ss[end], 0) + 1);\\n                    end++;\\n                }\\n                if (end == ss.length) return \"\";\\n                map_s.put(c, map_t.get(c));\\n                end++;\\n            }\\n        }\\n        int min = end;\\n        int st = 0;\\n        for (int i = 0; i < end; i++) {\\n            char c = ss[i];\\n            if (c == \\'m\\') {\\n                if (!map_s.containsKey(c) || !map_t.containsKey(c)) continue;\\n                if (map_s.get(c) == 423 && map_t.get(c) == 423 && map_s.get(c) != map_t.get(c)) {\\n                    System.out.println(\"What the hell is going on here?\");\\n                }\\n            }\\n            if (map_t.containsKey(c)) {\\n                if (map_s.get(c) == map_t.get(c)) {\\n                    if (end - i < min) {\\n                        st = i;\\n                        min = end - i;\\n                    }\\n                    while(end < ss.length && ss[end] != c) {\\n                        if (map_t.containsKey(ss[end])) map_s.put(ss[end], map_s.get(ss[end]) + 1);\\n                        end++;\\n                    }\\n                    if (end == ss.length) break;\\n                    end++;\\n                } else {\\n                    map_s.put(c, map_s.get(c) - 1);\\n                }\\n            }\\n        }\\n        return s.substring(st, st + min);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 26917,
                "title": "16ms-simple-and-neat-c-solution-only-using-a-vector-detailed-explanation",
                "content": " 1. Initialize a vector called `remaining`, which contains the needed\\n    matching numbers of each character in `s`. \\n 2. If there are still\\n        characters needed to be contained (increment `i` in this case),\\n        decrease the matching number of that character and check if it is\\n        still non-negative. If it is, then it is the character in `t`, so\\n        decrease the total required number `required`.  \\n 3. If there is no more\\n            characters required (increment `start` in this case),  record `min`\\n            and `left` if a smaller length is found. Recover the number of this\\n            character in the `remaining` and if it is a character in `t`\\n            increase `required`.\\n\\n\\n----------\\n\\n    class Solution {\\n    public:\\n        string minWindow(string s, string t) {\\n            if (s.size() == 0 || t.size() == 0) return \"\";\\n            vector<int> remaining(128, 0);\\n            int required = t.size();\\n            for (int i = 0; i < required; i++) remaining[t[i]]++;\\n            // left is the start index of the min-length substring ever found\\n            int min = INT_MAX, start = 0, left = 0, i = 0;\\n            while(i <= s.size() && start < s.size()) {\\n                if(required) {\\n                    if (i == s.size()) break;\\n                    remaining[s[i]]--;\\n                    if (remaining[s[i]] >= 0) required--;\\n                    i++;\\n                } else {\\n                    if (i - start < min) {\\n                        min = i -start;\\n                        left = start;\\n                    }\\n                    remaining[s[start]]++;\\n                    if (remaining[s[start]] > 0) required++;\\n                    start++;\\n                }\\n            }\\n            return min == INT_MAX? \"\" : s.substr(left, min);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string minWindow(string s, string t) {\\n            if (s.size() == 0 || t.size() == 0) return \"\";\\n            vector<int> remaining(128, 0);\\n            int required = t.size();\\n            for (int i = 0; i < required; i++) remaining[t[i]]++;\\n            // left is the start index of the min-length substring ever found\\n            int min = INT_MAX, start = 0, left = 0, i = 0;\\n            while(i <= s.size() && start < s.size()) {\\n                if(required) {\\n                    if (i == s.size()) break;\\n                    remaining[s[i]]--;\\n                    if (remaining[s[i]] >= 0) required--;\\n                    i++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 226911,
                "title": "python-two-pointer-sliding-window-with-explanation",
                "content": "The idea is we use a variable-length sliding window which is gradually applied across the string. We use two pointers: start and end to mark the sliding window.  We start by fixing the start pointer and moving the end pointer to the right. The way we determine the current window is a valid one is by checking if all the target letters have been found in the current window. If we are in a valid sliding window, we first make note of the  sliding window of the most minimum length we have seen so far. Next we try to contract the sliding window by moving the start pointer. If the sliding window continues to be valid, we note the new minimum sliding window. If it becomes invalid (all letters of the target have been bypassed), we break out of the inner loop and go back to moving the end pointer to the right.\\n\\n```python\\ndef found_target(target_len):\\n    return target_len == 0\\n\\nclass Solution(object):\\n    def minWindow(self, search_string, target):\\n        \"\"\"\\n        :type s: str\\n        :type t: str\\n        :rtype: str\\n        \"\"\"\\n        target_letter_counts = collections.Counter(target)\\n        start = 0\\n        end = 0\\n        min_window = \"\"\\n        target_len = len(target)        \\n        \\n        for end in range(len(search_string)):\\n\\t\\t\\t# If we see a target letter, decrease the total target letter count\\n\\t\\t\\tif target_letter_counts[search_string[end]] > 0:\\n                target_len -= 1\\n\\n            # Decrease the letter count for the current letter\\n\\t\\t\\t# If the letter is not a target letter, the count just becomes -ve\\n\\t\\t\\ttarget_letter_counts[search_string[end]] -= 1\\n            \\n\\t\\t\\t# If all letters in the target are found:\\n            while found_target(target_len):\\n                window_len = end - start + 1\\n                if not min_window or window_len < len(min_window):\\n\\t\\t\\t\\t\\t# Note the new minimum window\\n                    min_window = search_string[start : end + 1]\\n                    \\n\\t\\t\\t\\t# Increase the letter count of the current letter\\n                target_letter_counts[search_string[start]] += 1\\n                \\n\\t\\t\\t\\t# If all target letters have been seen and now, a target letter is seen with count > 0\\n\\t\\t\\t\\t# Increase the target length to be found. This will break out of the loop\\n                if target_letter_counts[search_string[start]] > 0:\\n                    target_len += 1\\n                    \\n                start+=1\\n                \\n        return min_window\\n```",
                "solutionTags": [],
                "code": "```python\\ndef found_target(target_len):\\n    return target_len == 0\\n\\nclass Solution(object):\\n    def minWindow(self, search_string, target):\\n        \"\"\"\\n        :type s: str\\n        :type t: str\\n        :rtype: str\\n        \"\"\"\\n        target_letter_counts = collections.Counter(target)\\n        start = 0\\n        end = 0\\n        min_window = \"\"\\n        target_len = len(target)        \\n        \\n        for end in range(len(search_string)):\\n\\t\\t\\t# If we see a target letter, decrease the total target letter count\\n\\t\\t\\tif target_letter_counts[search_string[end]] > 0:\\n                target_len -= 1\\n\\n            # Decrease the letter count for the current letter\\n\\t\\t\\t# If the letter is not a target letter, the count just becomes -ve\\n\\t\\t\\ttarget_letter_counts[search_string[end]] -= 1\\n            \\n\\t\\t\\t# If all letters in the target are found:\\n            while found_target(target_len):\\n                window_len = end - start + 1\\n                if not min_window or window_len < len(min_window):\\n\\t\\t\\t\\t\\t# Note the new minimum window\\n                    min_window = search_string[start : end + 1]\\n                    \\n\\t\\t\\t\\t# Increase the letter count of the current letter\\n                target_letter_counts[search_string[start]] += 1\\n                \\n\\t\\t\\t\\t# If all target letters have been seen and now, a target letter is seen with count > 0\\n\\t\\t\\t\\t# Increase the target length to be found. This will break out of the loop\\n                if target_letter_counts[search_string[start]] > 0:\\n                    target_len += 1\\n                    \\n                start+=1\\n                \\n        return min_window\\n```",
                "codeTag": "Java"
            },
            {
                "id": 26840,
                "title": "sharing-my-straightforward-o-n-solution-with-explanation",
                "content": "    string minWindow(string S, string T) {\\n        string result;\\n        if(S.empty() || T.empty()){\\n            return result;\\n        }\\n        unordered_map<char, int> map;\\n        unordered_map<char, int> window;\\n        for(int i = 0; i < T.length(); i++){\\n            map[T[i]]++;\\n        }\\n        int minLength = INT_MAX;\\n        int letterCounter = 0;\\n        for(int slow = 0, fast = 0; fast < S.length(); fast++){\\n            char c = S[fast];\\n            if(map.find(c) != map.end()){\\n                window[c]++;\\n                if(window[c] <= map[c]){\\n                    letterCounter++;\\n                }\\n            }\\n            if(letterCounter >= T.length()){\\n                while(map.find(S[slow]) == map.end() || window[S[slow]] > map[S[slow]]){\\n                    window[S[slow]]--;\\n                    slow++;\\n                }\\n                if(fast - slow + 1 < minLength){\\n                    minLength = fast - slow + 1;\\n                    result = S.substr(slow, minLength);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\nThere are three key variables in my solution: \\n\\n    unordered_map <char, int> map; unordered_map<char, int> window; int letterCounter;\\n\\nvariable \"map\" is used to indicate what characters and how many characters are in T.\\n\\nvariable \"window\" is to indicate what characters and how many characters are between pointer \"slow\" and pointer \"fast\".\\n\\nNow let's start.\\n\\nThe first For loop is used to construct variable \"map\".\\n\\nThe second For loop is used to find the minimum window.\\n\\nThe first thing we should do in the second For loop is to find a window which can cover T. I use \"letterCounter\" to be a monitor. If \"letterCounter\" is equal to T.length(), then we find this window. Before that, only the first If clause can be executed. However, after we find this window, the second If clause can also be executed. \\n\\nIn the second If clause, we move \"slow\" forward in order to shrink the window size. Every time finding a smaller window, I update the result. \\n\\nAt the end of program, I return result, which is the minimum window.",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Two Pointers"
                ],
                "code": "    string minWindow(string S, string T) {\\n        string result;\\n        if(S.empty() || T.empty()){\\n            return result;\\n        }\\n        unordered_map<char, int> map;\\n        unordered_map<char, int> window;\\n        for(int i = 0; i < T.length(); i++){\\n            map[T[i]]++;\\n        }\\n        int minLength = INT_MAX;\\n        int letterCounter = 0;\\n        for(int slow = 0, fast = 0; fast < S.length(); fast++){\\n            char c = S[fast];\\n            if(map.find(c) != map.end()){\\n                window[c]++;\\n                if(window[c] <= map[c]){\\n                    letterCounter++;\\n                }\\n            }\\n            if(letterCounter >= T.length()){\\n                while(map.find(S[slow]) == map.end() || window[S[slow]] > map[S[slow]]){\\n                    window[S[slow]]--;\\n                    slow++;\\n                }\\n                if(fast - slow + 1 < minLength){\\n                    minLength = fast - slow + 1;\\n                    result = S.substr(slow, minLength);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\nThere are three key variables in my solution: \\n\\n    unordered_map <char, int> map; unordered_map<char, int> window; int letterCounter;\\n\\nvariable \"map\" is used to indicate what characters and how many characters are in T.\\n\\nvariable \"window\" is to indicate what characters and how many characters are between pointer \"slow\" and pointer \"fast\".\\n\\nNow let's start.\\n\\nThe first For loop is used to construct variable \"map\".\\n\\nThe second For loop is used to find the minimum window.\\n\\nThe first thing we should do in the second For loop is to find a window which can cover T. I use \"letterCounter\" to be a monitor. If \"letterCounter\" is equal to T.length(), then we find this window. Before that, only the first If clause can be executed. However, after we find this window, the second If clause can also be executed. \\n\\nIn the second If clause, we move \"slow\" forward in order to shrink the window size. Every time finding a smaller window, I update the result. \\n\\nAt the end of program, I return result, which is the minimum window.",
                "codeTag": "Unknown"
            },
            {
                "id": 26805,
                "title": "accepted-o-n-solution",
                "content": "    class Solution {\\n    public:\\n        string minWindow(string S, string T) {\\n            if (S.empty() || T.empty())\\n            {\\n                return \"\";\\n            }\\n            int count = T.size();\\n            int require[128] = {0};\\n            bool chSet[128] = {false};\\n            for (int i = 0; i < count; ++i)\\n            {\\n                require[T[i]]++;\\n                chSet[T[i]] = true;\\n            }\\n            int i = -1;\\n            int j = 0;\\n            int minLen = INT_MAX;\\n            int minIdx = 0;\\n            while (i < (int)S.size() && j < (int)S.size())\\n            {\\n                if (count)\\n                {\\n                    i++;\\n                    require[S[i]]--;\\n                    if (chSet[S[i]] && require[S[i]] >= 0)\\n                    {\\n                        count--;\\n                    }\\n                }\\n                else\\n                {\\n                    if (minLen > i - j + 1)\\n                    {\\n                        minLen = i - j + 1;\\n                        minIdx = j;\\n                    }\\n                    require[S[j]]++;\\n                    if (chSet[S[j]] && require[S[j]] > 0)\\n                    {\\n                        count++;\\n                    }\\n                    j++;\\n                }\\n            }\\n            if (minLen == INT_MAX)\\n            {\\n                return \"\";\\n            }\\n            return S.substr(minIdx, minLen);\\n        }\\n    };\\n\\nImplementation of [mike3's idea][1]\\n\\nrunning time : 56ms.\\n\\n\\n  [1]: https://oj.leetcode.com/discuss/5469/is-the-length-of-t-considered-constant-or-m",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string minWindow(string S, string T) {\\n            if (S.empty() || T.empty())\\n            {\\n                return \"\";\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 968611,
                "title": "simple-python-sliding-window-solution-with-detailed-explanation",
                "content": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def minWindow(self, s: str, t: str) -> str:\\n        \\'\\'\\'\\n        Keep t_counter of char counts in t\\n        \\n        We make a sliding window across s, tracking the char counts in s_counter\\n        We keep track of matches, the number of chars with matching counts in s_counter and t_counter\\n        Increment or decrement matches based on how the sliding window changes\\n        When matches == len(t_counter.keys()), we have a valid window. Update the answer accordingly\\n        \\n        How we slide the window:\\n        Extend when matches < chars, because we can only get a valid window by adding more.\\n        Contract when matches == chars, because we could possibly do better than the current window.\\n        \\n        How we update matches:\\n        This only applies if t_counter[x] > 0.\\n        If s_counter[x] is increased to match t_counter[x], matches += 1\\n        If s_counter[x] is increased to be more than t_counter[x], do nothing\\n        If s_counter[x] is decreased to be t_counter[x] - 1, matches -= 1\\n        If s_counter[x] is decreased to be less than t_counter[x] - 1, do nothing\\n        \\n        Analysis:\\n        O(s + t) time: O(t) to build t_counter, then O(s) to move our sliding window across s. Each index is only visited twice.\\n        O(s + t) space: O(t) space for t_counter and O(s) space for s_counter\\n        \\'\\'\\'\\n        \\n        if not s or not t or len(s) < len(t):\\n            return \\'\\'\\n        \\n        t_counter = Counter(t)\\n        chars = len(t_counter.keys())\\n        \\n        s_counter = Counter()\\n        matches = 0\\n        \\n        answer = \\'\\'\\n        \\n        i = 0\\n        j = -1 # make j = -1 to start, so we can move it forward and put s[0] in s_counter in the extend phase \\n        \\n        while i < len(s):\\n            \\n            # extend\\n            if matches < chars:\\n                \\n                # since we don\\'t have enough matches and j is at the end of the string, we have no way to increase matches\\n                if j == len(s) - 1:\\n                    return answer\\n                \\n                j += 1\\n                s_counter[s[j]] += 1\\n                if t_counter[s[j]] > 0 and s_counter[s[j]] == t_counter[s[j]]:\\n                    matches += 1\\n\\n            # contract\\n            else:\\n                s_counter[s[i]] -= 1\\n                if t_counter[s[i]] > 0 and s_counter[s[i]] == t_counter[s[i]] - 1:\\n                    matches -= 1\\n                i += 1\\n                \\n            # update answer\\n            if matches == chars:\\n                if not answer:\\n                    answer = s[i:j+1]\\n                elif (j - i + 1) < len(answer):\\n                    answer = s[i:j+1]\\n        \\n        return answer\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def minWindow(self, s: str, t: str) -> str:\\n        \\'\\'\\'\\n        Keep t_counter of char counts in t\\n        \\n        We make a sliding window across s, tracking the char counts in s_counter\\n        We keep track of matches, the number of chars with matching counts in s_counter and t_counter\\n        Increment or decrement matches based on how the sliding window changes\\n        When matches == len(t_counter.keys()), we have a valid window. Update the answer accordingly\\n        \\n        How we slide the window:\\n        Extend when matches < chars, because we can only get a valid window by adding more.\\n        Contract when matches == chars, because we could possibly do better than the current window.\\n        \\n        How we update matches:\\n        This only applies if t_counter[x] > 0.\\n        If s_counter[x] is increased to match t_counter[x], matches += 1\\n        If s_counter[x] is increased to be more than t_counter[x], do nothing\\n        If s_counter[x] is decreased to be t_counter[x] - 1, matches -= 1\\n        If s_counter[x] is decreased to be less than t_counter[x] - 1, do nothing\\n        \\n        Analysis:\\n        O(s + t) time: O(t) to build t_counter, then O(s) to move our sliding window across s. Each index is only visited twice.\\n        O(s + t) space: O(t) space for t_counter and O(s) space for s_counter\\n        \\'\\'\\'\\n        \\n        if not s or not t or len(s) < len(t):\\n            return \\'\\'\\n        \\n        t_counter = Counter(t)\\n        chars = len(t_counter.keys())\\n        \\n        s_counter = Counter()\\n        matches = 0\\n        \\n        answer = \\'\\'\\n        \\n        i = 0\\n        j = -1 # make j = -1 to start, so we can move it forward and put s[0] in s_counter in the extend phase \\n        \\n        while i < len(s):\\n            \\n            # extend\\n            if matches < chars:\\n                \\n                # since we don\\'t have enough matches and j is at the end of the string, we have no way to increase matches\\n                if j == len(s) - 1:\\n                    return answer\\n                \\n                j += 1\\n                s_counter[s[j]] += 1\\n                if t_counter[s[j]] > 0 and s_counter[s[j]] == t_counter[s[j]]:\\n                    matches += 1\\n\\n            # contract\\n            else:\\n                s_counter[s[i]] -= 1\\n                if t_counter[s[i]] > 0 and s_counter[s[i]] == t_counter[s[i]] - 1:\\n                    matches -= 1\\n                i += 1\\n                \\n            # update answer\\n            if matches == chars:\\n                if not answer:\\n                    answer = s[i:j+1]\\n                elif (j - i + 1) < len(answer):\\n                    answer = s[i:j+1]\\n        \\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 483132,
                "title": "c-short-sliding-window-solution-with-explanation",
                "content": "```\\n    string minWindow(string s, string t) {\\n        unordered_map<char, int> letters; //unordered map for storing the characters in t that we need to check for in s\\n        for(auto c : t) letters[c]++; \\n        int count = 0; //counts number of t\\'s letters in current window\\n        int low = 0, min_length = INT_MAX, min_start = 0;     \\n        for(int high = 0; high<s.length(); high++) {\\n            if(letters[s[high]] > 0) count++; //means that this letter is in t   \\n            letters[s[high]]--; //reduce the count for the letter on which we are currently \\n            if(count == t.length()) { //if current windows contains all of the letters in t\\n                while(low < high && letters[s[low]] < 0) letters[s[low]]++, low++; //move low ahead if its not of any significance\\n                if(min_length > high-low) min_length = high-(min_start=low)+1; //update the min length\\n                letters[s[low++]]++; //move low ahaead and also increment the value\\n                count--; //count-- as we are moving low ahead & low pointed to a char in t before\\n            }\\n        }\\n        return min_length == INT_MAX ? \"\" : s.substr(min_start, min_length); //check for edge case & return the result\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\n    string minWindow(string s, string t) {\\n        unordered_map<char, int> letters; //unordered map for storing the characters in t that we need to check for in s\\n        for(auto c : t) letters[c]++; \\n        int count = 0; //counts number of t\\'s letters in current window\\n        int low = 0, min_length = INT_MAX, min_start = 0;     \\n        for(int high = 0; high<s.length(); high++) {\\n            if(letters[s[high]] > 0) count++; //means that this letter is in t   \\n            letters[s[high]]--; //reduce the count for the letter on which we are currently \\n            if(count == t.length()) { //if current windows contains all of the letters in t\\n                while(low < high && letters[s[low]] < 0) letters[s[low]]++, low++; //move low ahead if its not of any significance\\n                if(min_length > high-low) min_length = high-(min_start=low)+1; //update the min length\\n                letters[s[low++]]++; //move low ahaead and also increment the value\\n                count--; //count-- as we are moving low ahead & low pointed to a char in t before\\n            }\\n        }\\n        return min_length == INT_MAX ? \"\" : s.substr(min_start, min_length); //check for edge case & return the result\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 26811,
                "title": "share-my-neat-java-solution",
                "content": "    public String minWindow(String S, String T) {\\n        if(S==null||S.isEmpty()||T==null||T.isEmpty()) return \"\";\\n        int i=0, j=0;\\n        int[] Tmap=new int[256];\\n        int[] Smap=new int[256];\\n        for(int k=0; k< T.length(); k++){\\n            Tmap[T.charAt(k)]++;\\n        }\\n        int found=0;\\n        int length=Integer.MAX_VALUE;\\n        String res=\"\";\\n        while(j<S.length()){\\n            if(found<T.length()){\\n                if(Tmap[S.charAt(j)]>0){\\n                    Smap[S.charAt(j)]++;\\n                    if(Smap[S.charAt(j)]<=Tmap[S.charAt(j)]){\\n                        found++;\\n                    }\\n                }\\n                j++;\\n            }\\n            while(found==T.length()){\\n                if(j-i<length){\\n                    length=j-i; res=S.substring(i,j);\\n                }\\n                if(Tmap[S.charAt(i)]>0){\\n                    Smap[S.charAt(i)]--;\\n                    if(Smap[S.charAt(i)]<Tmap[S.charAt(i)]){\\n                        found--;\\n                    }\\n                }\\n                i++;\\n            }\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public String minWindow(String S, String T) {\\n        if(S==null||S.isEmpty()||T==null||T.isEmpty()) return \"\";\\n        int i=0, j=0;\\n        int[] Tmap=new int[256];\\n        int[] Smap=new int[256];\\n        for(int k=0; k< T.length(); k++){\\n            Tmap[T.charAt(k)]++;\\n        }\\n        int found=0;\\n        int length=Integer.MAX_VALUE;\\n        String res=\"\";\\n        while(j<S.length()){\\n            if(found<T.length()){\\n                if(Tmap[S.charAt(j)]>0){\\n                    Smap[S.charAt(j)]++;\\n                    if(Smap[S.charAt(j)]<=Tmap[S.charAt(j)]){\\n                        found++;\\n                    }\\n                }\\n                j++;\\n            }\\n            while(found==T.length()){\\n                if(j-i<length){\\n                    length=j-i; res=S.substring(i,j);\\n                }\\n                if(Tmap[S.charAt(i)]>0){\\n                    Smap[S.charAt(i)]--;\\n                    if(Smap[S.charAt(i)]<Tmap[S.charAt(i)]){\\n                        found--;\\n                    }\\n                }\\n                i++;\\n            }\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1891931,
                "title": "sliding-window-approach-with-full-explanation-in-c",
                "content": "\\n> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistakes please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Here we\\u2019re storing all the characters from string t to an unordered_map ***mp***.\\n- We are taking 3 variables, ans(to store the size of the minimum substring), start(to store the start index) & count(to store the map size, if it became 0 that means we got a substring)\\n- Now taking 2 pointers i & j, we\\u2019ll iterate using j & will decrement the element count in map.\\n- if at any point the value became 0 that means we got all the elements of that char till now, so we\\u2019ll decrement the size of the count.\\n- In this way, we will decrement and once the count will be 0 if there is a  substring with all the elements present.\\n- Now we\\u2019ll increment i and check if there is possible to remove any more characters and get smaller substrings.\\n- We\\u2019ll store the smaller length to ans & store the ith index in the start variable. Also, we\\u2019ll add the element to our map and increment the count variable if it became greater than 0.\\n- Now if the ans have some length except int_max, then return the substring from start index to length of ans. Else return empty string.\\n- **Time complexity:** O(m), where m is the length of string s.\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        int m=s.size(), n=t.size();\\n        unordered_map<char, int> mp;\\n        \\n        int ans = INT_MAX; \\n        int start = 0; \\n        \\n        for(auto x:t)\\n            mp[x]++;\\n        \\n        int count = mp.size();\\n        \\n        int i = 0, j = 0;\\n\\n        while (j < s.length()) {\\n            mp[s[j]]--;\\n            if (mp[s[j]] == 0)\\n                count--;\\n\\n            if (count == 0) {\\n                while (count == 0) {\\n                    if (ans > j - i + 1) {\\n                        ans = j - i + 1;\\n                        start = i;\\n                    }\\n                    mp[s[i]]++;\\n                    if (mp[s[i]] > 0)\\n                        count++;\\n\\n                    i++;\\n                }\\n            }\\n            j++;\\n        }\\n        if (ans != INT_MAX)\\n            return s.substr(start, ans);\\n        else\\n            return \"\";\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        int m=s.size(), n=t.size();\\n        unordered_map<char, int> mp;\\n        \\n        int ans = INT_MAX; \\n        int start = 0; \\n        \\n        for(auto x:t)\\n            mp[x]++;\\n        \\n        int count = mp.size();\\n        \\n        int i = 0, j = 0;\\n\\n        while (j < s.length()) {\\n            mp[s[j]]--;\\n            if (mp[s[j]] == 0)\\n                count--;\\n\\n            if (count == 0) {\\n                while (count == 0) {\\n                    if (ans > j - i + 1) {\\n                        ans = j - i + 1;\\n                        start = i;\\n                    }\\n                    mp[s[i]]++;\\n                    if (mp[s[i]] > 0)\\n                        count++;\\n\\n                    i++;\\n                }\\n            }\\n            j++;\\n        }\\n        if (ans != INT_MAX)\\n            return s.substr(start, ans);\\n        else\\n            return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1045266,
                "title": "python-my-advice",
                "content": "My advice for solving this problem is to:\\n* Understand the intuition and what to do at a high level\\n* Try to implement your own solution WITHOUT copying anyone elses\\n* This is how you will learn\\n* You will remember high level concepts, but never line for line code\\n\\nIntuition:\\n* Two pointers, left and right\\n* Both start from 0,0\\n* Increase right pointer until valid window is found\\n* Decrease left pointer until window is no longer valid\\n* Add the minimum length window you\\'ve found to your results\\n* Continue increasing right pointer, pretty much repeating what we did above\\n* Return the minimum length of your results\\n\\n\\nMy code is AC but definitely not optimal, so I have some more learning & practice to do. I just wanted to share that by trying to implement & solve most of the problem yourself (after learning the high level concept), your learning is massive.\\n\\n\\n```python\\nfrom collections import Counter\\n\\n\\nclass Solution:\\n    def minWindow(self, s: str, t: str) -> str:\\n        \\n        # Define variables\\n        s_count, t_count = Counter(), Counter(t)\\n        \\n        l, r = 0, 0\\n        \\n        results = []\\n        \\n        while r <= len(s)-1:\\n                                    \\n            # Find valid window\\n            s_count[s[r]] += 1            \\n            r += 1\\n            if s_count & t_count != t_count:\\n                continue\\n                \\n            # Minimize this window\\n            while l < r:\\n                s_count[s[l]] -= 1 \\n                l += 1\\n                if s_count & t_count == t_count:\\n                    continue\\n                results.append(s[l-1:r])\\n                break\\n            \\n            \\n        # Return result\\n        if not results:\\n            return \"\"        \\n        return min(results, key=len)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nfrom collections import Counter\\n\\n\\nclass Solution:\\n    def minWindow(self, s: str, t: str) -> str:\\n        \\n        # Define variables\\n        s_count, t_count = Counter(), Counter(t)\\n        \\n        l, r = 0, 0\\n        \\n        results = []\\n        \\n        while r <= len(s)-1:\\n                                    \\n            # Find valid window\\n            s_count[s[r]] += 1            \\n            r += 1\\n            if s_count & t_count != t_count:\\n                continue\\n                \\n            # Minimize this window\\n            while l < r:\\n                s_count[s[l]] -= 1 \\n                l += 1\\n                if s_count & t_count == t_count:\\n                    continue\\n                results.append(s[l-1:r])\\n                break\\n            \\n            \\n        # Return result\\n        if not results:\\n            return \"\"        \\n        return min(results, key=len)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 617888,
                "title": "c-solution-68ms-explanation",
                "content": "```\\nWe are going to use a two pointer approach to solve this.\\n\\nThe idea here is that \\n1. We will store the characters of t in a map lets say mapt.\\n2. We will have two pointers l and r.\\n3. Whille we traverse through s we check if the character is found in mapt If so we will store the character into another hash map lets say maps.\\n4. If the mapped charcter freq of s is less than or equal to mapt we increment a letter counter variable that will let us know when we have reached the t string size.\\n5. We try to find the smallest substring which contains all chracters in t using a while loop.\\n\\n S = \"ADOBECODEBANC\" and T = \"ABC\"\\n\\n mapt\\n A -> 1\\n B -> 1\\n C -> 1\\n\\n We keep l=0 and traverse S with r.\\n\\n \"ADOBECODEBANC\"\\n  ^\\n  |\\n  r \\n\\nas A is present in t we use another map for s to store A into the hashmap\\n\\nmaps\\nA->1\\nwe have another variable lettercounter that keeps track of the size.\\nlettercounter\\n1\\n\\n \"ADOBECODEBANC\"\\n   ^\\n   |\\n   r\\nAs D isnt present in t we just continue traversing.\\n\\n \"ADOBECODEBANC\"\\n    ^\\n    |\\n    r\\nSame as the above step.\\n\\n \"ADOBECODEBANC\"\\n     ^\\n     |\\n     r   \\nAs B is present in map t\\n\\nmaps\\nA->1\\nB->1\\n\\nlettercounter\\n2\\n\\n \"ADOBECODEBANC\"\\n      ^\\n      |\\n      r\\n \"ADOBECODEBANC\"\\n       ^\\n       |\\n       r\\nC is present in mapt\\n\\nmaps\\nA->1\\nB->1\\nC->1\\n\\nlettercounter\\n3\\nas lettercount is equal to t.size We will try shortening the substring\\n\\nAs there is only 1 A in s and t and A is the first character we cant reduce the size.\\n\\nSo out best bet currently would the substring\\nans=  \"ADOBEC\"\\n\\nWe continue traversing and checking the above steps.\\n\\n\\n    string minWindow(string s, string t) {\\n        unordered_map<char,int> map1;\\n        unordered_map<char,int> map2;\\n        int check=INT_MAX;\\n        string result;\\n        for(char &ch:t)map1[ch]++;\\n        int slow=0,fast=0,lettercounter=0;\\n        for(;fast<s.length();fast++)\\n        {\\n            char ch=s[fast];\\n            if(map1.find(ch)!=map1.end())\\n            {\\n                map2[ch]++;\\n            if(map2[ch]<=map1[ch])\\n                lettercounter++;\\n            }\\n            if(lettercounter>=t.length())\\n            {\\n                while(map1.find(s[slow])==map1.end()||map2[s[slow]]>map1[s[slow]])\\n                {\\n                    map2[s[slow]]--;\\n                    slow++;\\n                }\\n                if(fast-slow+1<check)\\n                {\\n                    check=fast-slow+1;\\n                    result=s.substr(slow,check);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nWe are going to use a two pointer approach to solve this.\\n\\nThe idea here is that \\n1. We will store the characters of t in a map lets say mapt.\\n2. We will have two pointers l and r.\\n3. Whille we traverse through s we check if the character is found in mapt If so we will store the character into another hash map lets say maps.\\n4. If the mapped charcter freq of s is less than or equal to mapt we increment a letter counter variable that will let us know when we have reached the t string size.\\n5. We try to find the smallest substring which contains all chracters in t using a while loop.\\n\\n S = \"ADOBECODEBANC\" and T = \"ABC\"\\n\\n mapt\\n A -> 1\\n B -> 1\\n C -> 1\\n\\n We keep l=0 and traverse S with r.\\n\\n \"ADOBECODEBANC\"\\n  ^\\n  |\\n  r \\n\\nas A is present in t we use another map for s to store A into the hashmap\\n\\nmaps\\nA->1\\nwe have another variable lettercounter that keeps track of the size.\\nlettercounter\\n1\\n\\n \"ADOBECODEBANC\"\\n   ^\\n   |\\n   r\\nAs D isnt present in t we just continue traversing.\\n\\n \"ADOBECODEBANC\"\\n    ^\\n    |\\n    r\\nSame as the above step.\\n\\n \"ADOBECODEBANC\"\\n     ^\\n     |\\n     r   \\nAs B is present in map t\\n\\nmaps\\nA->1\\nB->1\\n\\nlettercounter\\n2\\n\\n \"ADOBECODEBANC\"\\n      ^\\n      |\\n      r\\n \"ADOBECODEBANC\"\\n       ^\\n       |\\n       r\\nC is present in mapt\\n\\nmaps\\nA->1\\nB->1\\nC->1\\n\\nlettercounter\\n3\\nas lettercount is equal to t.size We will try shortening the substring\\n\\nAs there is only 1 A in s and t and A is the first character we cant reduce the size.\\n\\nSo out best bet currently would the substring\\nans=  \"ADOBEC\"\\n\\nWe continue traversing and checking the above steps.\\n\\n\\n    string minWindow(string s, string t) {\\n        unordered_map<char,int> map1;\\n        unordered_map<char,int> map2;\\n        int check=INT_MAX;\\n        string result;\\n        for(char &ch:t)map1[ch]++;\\n        int slow=0,fast=0,lettercounter=0;\\n        for(;fast<s.length();fast++)\\n        {\\n            char ch=s[fast];\\n            if(map1.find(ch)!=map1.end())\\n            {\\n                map2[ch]++;\\n            if(map2[ch]<=map1[ch])\\n                lettercounter++;\\n            }\\n            if(lettercounter>=t.length())\\n            {\\n                while(map1.find(s[slow])==map1.end()||map2[s[slow]]>map1[s[slow]])\\n                {\\n                    map2[s[slow]]--;\\n                    slow++;\\n                }\\n                if(fast-slow+1<check)\\n                {\\n                    check=fast-slow+1;\\n                    result=s.substr(slow,check);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 26835,
                "title": "java-4ms-bit-97-6",
                "content": "Basically, there are two pointers for windows sliding. One for exploiting new matched substring, other pointer for expiring previous substring.\\n\\n    public String minWindow(String s, String t) {\\n            char[] s_array = s.toCharArray();\\n            char[] t_array = t.toCharArray();\\n            int[] map = new int[256];\\n            int end = 0;\\n            int start = 0;\\n            int min_length = Integer.MAX_VALUE;\\n            for(int i = 0; i < t_array.length; i++)\\n                map[t_array[i]] ++;\\n            int count = t_array.length;\\n            int min_start = 0;\\n            while(end < s_array.length)\\n            {\\n                if(map[s_array[end]] > 0)\\n                {\\n                    count--;\\n                }\\n                map[s_array[end]] --;\\n                while(count == 0)\\n                {\\n                    if((end - start + 1) < min_length)\\n                    {\\n                        min_length = end - start + 1;\\n                        min_start = start;\\n                    }\\n                    map[s_array[start]] ++;\\n                    if(map[s_array[start]] > 0){\\n                        count ++;\\n                    }\\n                    start++;\\n                }\\n                end ++;\\n    \\n            }\\n            if( min_start+min_length > s_array.length)\\n                return \"\";\\n            return s.substring(min_start, min_start+min_length);\\n        }",
                "solutionTags": [],
                "code": "Basically, there are two pointers for windows sliding. One for exploiting new matched substring, other pointer for expiring previous substring.\\n\\n    public String minWindow(String s, String t) {\\n            char[] s_array = s.toCharArray();\\n            char[] t_array = t.toCharArray();\\n            int[] map = new int[256];\\n            int end = 0;\\n            int start = 0;\\n            int min_length = Integer.MAX_VALUE;\\n            for(int i = 0; i < t_array.length; i++)\\n                map[t_array[i]] ++;\\n            int count = t_array.length;\\n            int min_start = 0;\\n            while(end < s_array.length)\\n            {\\n                if(map[s_array[end]] > 0)\\n                {\\n                    count--;\\n                }\\n                map[s_array[end]] --;\\n                while(count == 0)\\n                {\\n                    if((end - start + 1) < min_length)\\n                    {\\n                        min_length = end - start + 1;\\n                        min_start = start;\\n                    }\\n                    map[s_array[start]] ++;\\n                    if(map[s_array[start]] > 0){\\n                        count ++;\\n                    }\\n                    start++;\\n                }\\n                end ++;\\n    \\n            }\\n            if( min_start+min_length > s_array.length)\\n                return \"\";\\n            return s.substring(min_start, min_start+min_length);\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 2730839,
                "title": "c-advance-sliding-window-fast",
                "content": "**Please upvote, your one upvote makes me happy**\\n\\n^____^\\n\\n**Here is the code**\\n\\n```\\nclass Solution {\\npublic:\\n\\n    string minWindow(string str, string pat) {\\n           \\n    int len1 = str.length();\\n    int len2 = pat.length();\\n        \\n    const int no_of_chars = 256;\\n\\n    if (len1 < len2) {\\n        return \"\";\\n    }\\n\\n    int hash_pat[no_of_chars] = { 0 };\\n    int hash_str[no_of_chars] = { 0 };\\n\\n    \\n    for (int i = 0; i < len2; i++)\\n        hash_pat[pat[i]]++;\\n\\n    int start = 0, start_index = -1, min_len = INT_MAX;\\n\\n    int count = 0; \\n    for (int j = 0; j < len1; j++) {\\n        hash_str[str[j]]++;\\n\\n        if (hash_str[str[j]] <= hash_pat[str[j]])\\n            count++;\\n\\n        if (count == len2) {\\n          \\n            while (hash_str[str[start]]\\n                       > hash_pat[str[start]]\\n                   || hash_pat[str[start]] == 0) {\\n\\n                if (hash_str[str[start]]\\n                    > hash_pat[str[start]])\\n                    hash_str[str[start]]--;\\n                start++;\\n            }\\n\\n            int len_window = j - start + 1;\\n            if (min_len > len_window) {\\n                min_len = len_window;\\n                start_index = start;\\n            }\\n        }\\n    }\\n\\n    if (start_index == -1) {\\n     \\n        return \"\";\\n    }\\n\\n    return str.substr(start_index, min_len);\\n\\n    }\\n};\\n```\\n\\n**Keep coding Keep upvoting**",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    string minWindow(string str, string pat) {\\n           \\n    int len1 = str.length();\\n    int len2 = pat.length();\\n        \\n    const int no_of_chars = 256;\\n\\n    if (len1 < len2) {\\n        return \"\";\\n    }\\n\\n    int hash_pat[no_of_chars] = { 0 };\\n    int hash_str[no_of_chars] = { 0 };\\n\\n    \\n    for (int i = 0; i < len2; i++)\\n        hash_pat[pat[i]]++;\\n\\n    int start = 0, start_index = -1, min_len = INT_MAX;\\n\\n    int count = 0; \\n    for (int j = 0; j < len1; j++) {\\n        hash_str[str[j]]++;\\n\\n        if (hash_str[str[j]] <= hash_pat[str[j]])\\n            count++;\\n\\n        if (count == len2) {\\n          \\n            while (hash_str[str[start]]\\n                       > hash_pat[str[start]]\\n                   || hash_pat[str[start]] == 0) {\\n\\n                if (hash_str[str[start]]\\n                    > hash_pat[str[start]])\\n                    hash_str[str[start]]--;\\n                start++;\\n            }\\n\\n            int len_window = j - start + 1;\\n            if (min_len > len_window) {\\n                min_len = len_window;\\n                start_index = start;\\n            }\\n        }\\n    }\\n\\n    if (start_index == -1) {\\n     \\n        return \"\";\\n    }\\n\\n    return str.substr(start_index, min_len);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 170594,
                "title": "simple-python-solution-beats-99-with-detailed-explanation",
                "content": "The key idea is how you update the tracking variables. There are four essentials variables to track: 1. remaing length of a match 2. The position of previous matched first element 3. start_position of returned answer 4. end_position of returned answer. \\n\\nAnd a dictionary to count the occurrence of characters is useful.\\n\\n```\\nclass Solution(object):\\n    def minWindow(self, s, t):\\n        \"\"\"\\n        :type s: str\\n        :type t: str\\n        :rtype: str\\n        \"\"\"\\n        # Defaultdict is very useful in this problem, though i don\\'t like to import modules\\n        target_count_dict = collections.defaultdict(int)\\n        for ch in t:\\n            target_count_dict[ch] += 1\\n        remain_missing = len(t)\\n        start_pos, end_pos = 0, float(\\'inf\\')\\n        current_start = 0\\n        \\n        # Enumerate function makes current_end indexes from 1\\n        for current_end, ch in enumerate(s, 1):\\n            # Whenever we encounter a character, no matter ch in target or not, we minus 1 in count dictionary\\n            # But, only when ch is in target, we minus the length of remain_missing\\n            # When the remain_missing is 0, we find a potential solution.\\n            if target_count_dict[ch] > 0:\\n                remain_missing -= 1\\n            target_count_dict[ch] -= 1\\n            \\n            if remain_missing == 0:\\n                # Remove redundant character\\n                # Try to find the fist position in s that makes target_count_dict value equals 0\\n                # Which means we can\\'t skip this character in s when returning answer\\n                while target_count_dict[s[current_start]] < 0:\\n                    target_count_dict[s[current_start]] += 1\\n                    current_start += 1\\n                if current_end - current_start < end_pos - start_pos:\\n                    start_pos, end_pos = current_start, current_end\\n                \\n                # We need to add 1 to current_start, and the correspondence value in dictionary, is because\\n                # this is the first character of the potential answer. So, in future iteration, when we encounter this character,\\n                # We can remove this currently first character to try to find a shorter answer.\\n                target_count_dict[s[current_start]] += 1\\n                remain_missing += 1\\n                current_start += 1\\n        \\n        return s[start_pos:end_pos] if end_pos != float(\\'inf\\') else \"\"\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minWindow(self, s, t):\\n        \"\"\"\\n        :type s: str\\n        :type t: str\\n        :rtype: str\\n        \"\"\"\\n        # Defaultdict is very useful in this problem, though i don\\'t like to import modules\\n        target_count_dict = collections.defaultdict(int)\\n        for ch in t:\\n            target_count_dict[ch] += 1\\n        remain_missing = len(t)\\n        start_pos, end_pos = 0, float(\\'inf\\')\\n        current_start = 0\\n        \\n        # Enumerate function makes current_end indexes from 1\\n        for current_end, ch in enumerate(s, 1):\\n            # Whenever we encounter a character, no matter ch in target or not, we minus 1 in count dictionary\\n            # But, only when ch is in target, we minus the length of remain_missing\\n            # When the remain_missing is 0, we find a potential solution.\\n            if target_count_dict[ch] > 0:\\n                remain_missing -= 1\\n            target_count_dict[ch] -= 1\\n            \\n            if remain_missing == 0:\\n                # Remove redundant character\\n                # Try to find the fist position in s that makes target_count_dict value equals 0\\n                # Which means we can\\'t skip this character in s when returning answer\\n                while target_count_dict[s[current_start]] < 0:\\n                    target_count_dict[s[current_start]] += 1\\n                    current_start += 1\\n                if current_end - current_start < end_pos - start_pos:\\n                    start_pos, end_pos = current_start, current_end\\n                \\n                # We need to add 1 to current_start, and the correspondence value in dictionary, is because\\n                # this is the first character of the potential answer. So, in future iteration, when we encounter this character,\\n                # We can remove this currently first character to try to find a shorter answer.\\n                target_count_dict[s[current_start]] += 1\\n                remain_missing += 1\\n                current_start += 1\\n        \\n        return s[start_pos:end_pos] if end_pos != float(\\'inf\\') else \"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1496754,
                "title": "java-tc-o-s-t-sc-o-t-space-optimized-sliding-window-using-two-pointers",
                "content": "```java\\n/**\\n * Space-optimized Sliding Window using Two Pointers\\n *\\n * Time Complexity: O(S + T)\\n *\\n * Space Complexity: O(T)\\n *\\n * S = length of String s. T = length of String t\\n */\\nclass Solution1 {\\n    public String minWindow(String s, String t) {\\n        if (s == null || t == null) {\\n            throw new IllegalArgumentException(\"Input string is null\");\\n        }\\n        if (s.length() < t.length() || t.length() == 0) {\\n            return \"\";\\n        }\\n\\n        HashMap<Character, Integer> map = new HashMap<>();\\n        for (int i = 0; i < t.length(); i++) {\\n            map.put(t.charAt(i), map.getOrDefault(t.charAt(i), 0) + 1);\\n        }\\n\\n        int start = 0;\\n        int end = 0;\\n        int charTLeft = t.length();\\n        int minStart = 0;\\n        int minLen = Integer.MAX_VALUE;\\n\\n        while (end < s.length()) {\\n            char eChar = s.charAt(end);\\n            if (map.containsKey(eChar)) {\\n                int count = map.get(eChar);\\n                if (count > 0) {\\n                    charTLeft--;\\n                }\\n                map.put(eChar, count - 1);\\n            }\\n            end++;\\n\\n            while (charTLeft == 0) {\\n                if (minLen > end - start) {\\n                    minLen = end - start;\\n                    minStart = start;\\n                }\\n                char sChar = s.charAt(start);\\n                if (map.containsKey(sChar)) {\\n                    int count = map.get(sChar);\\n                    if (count == 0) {\\n                        charTLeft++;\\n                    }\\n                    map.put(sChar, count + 1);\\n                }\\n                start++;\\n            }\\n        }\\n\\n        return minLen == Integer.MAX_VALUE ? \"\" : s.substring(minStart, minStart + minLen);\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other Sliding Window questions on LeetCode:\\n- [340. Longest Substring with At Most K Distinct Characters](https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/discuss/1496838/Java-or-TC:-O(N)-or-SC:-O(K)-or-One-Pass-Sliding-Window-using-LinkedHashMap)\\n- [159. Longest Substring with At Most Two Distinct Characters](https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/discuss/1496840/Java-or-TC:-O(N)-or-SC:-O(1)-or-One-Pass-Sliding-Window-using-LinkedHashMap)\\n- [438. Find All Anagrams in a String](https://leetcode.com/problems/find-all-anagrams-in-a-string/discuss/1500039/Java-or-TC:-O(S+P)-or-SC:-O(1)-or-Sliding-window-solution)\\n- [3. Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/discuss/1500874/Java-or-TC:-O(N)-or-SC:-O(1)-or-Sliding-Window-using-HashMap-and-Two-Pointers)\\n- [209. Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/discuss/1500877/Java-or-Both-O(N)-and-O(N-logN)-solutions-with-O(1)-space-or-Sliding-Window-and-Binary-Search-solutions)\\n- [219. Contains Duplicate II](https://leetcode.com/problems/contains-duplicate-ii/discuss/1500887/Java-or-TC:-O(N)-or-SC:-O(min(N-K))-or-Sliding-Window-using-HashSet)\\n- [220. Contains Duplicate III](https://leetcode.com/problems/contains-duplicate-iii/discuss/1500895/Java-or-TC:-O(N)-or-SC:-O(min(NK))-or-Sliding-Window-using-Buckets)\\n- [567. Permutation in String](https://leetcode.com/problems/permutation-in-string/discuss/1500902/Java-or-TC:-O(S2)-or-SC:-O(1)-or-Constant-space-Sliding-Window-solution)\\n- [239. Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/discuss/1506048/Java-or-TC:-O(N)-or-SC:-O(K)-or-Using-Deque-as-Sliding-Window)\\n- [480. Sliding Window Median](https://leetcode.com/problems/sliding-window-median/discuss/1507981/Java-or-TC:-O(N*logK)-or-SC:-(K)-or-Optimized-sliding-window-using-TreeSet)\\n- [487. Max Consecutive Ones II](https://leetcode.com/problems/max-consecutive-ones-ii/discuss/1508045/Java-or-TC:-O(N)-or-SC:-O(1)-or-Four-solutions-with-Follow-up-handled)\\n- [1004. Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/discuss/1508044/Java-or-TC:-O(N)-or-SC:-O(1)-or-One-Pass-Optimized-Sliding-Window)\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String",
                    "Sliding Window"
                ],
                "code": "```java\\n/**\\n * Space-optimized Sliding Window using Two Pointers\\n *\\n * Time Complexity: O(S + T)\\n *\\n * Space Complexity: O(T)\\n *\\n * S = length of String s. T = length of String t\\n */\\nclass Solution1 {\\n    public String minWindow(String s, String t) {\\n        if (s == null || t == null) {\\n            throw new IllegalArgumentException(\"Input string is null\");\\n        }\\n        if (s.length() < t.length() || t.length() == 0) {\\n            return \"\";\\n        }\\n\\n        HashMap<Character, Integer> map = new HashMap<>();\\n        for (int i = 0; i < t.length(); i++) {\\n            map.put(t.charAt(i), map.getOrDefault(t.charAt(i), 0) + 1);\\n        }\\n\\n        int start = 0;\\n        int end = 0;\\n        int charTLeft = t.length();\\n        int minStart = 0;\\n        int minLen = Integer.MAX_VALUE;\\n\\n        while (end < s.length()) {\\n            char eChar = s.charAt(end);\\n            if (map.containsKey(eChar)) {\\n                int count = map.get(eChar);\\n                if (count > 0) {\\n                    charTLeft--;\\n                }\\n                map.put(eChar, count - 1);\\n            }\\n            end++;\\n\\n            while (charTLeft == 0) {\\n                if (minLen > end - start) {\\n                    minLen = end - start;\\n                    minStart = start;\\n                }\\n                char sChar = s.charAt(start);\\n                if (map.containsKey(sChar)) {\\n                    int count = map.get(sChar);\\n                    if (count == 0) {\\n                        charTLeft++;\\n                    }\\n                    map.put(sChar, count + 1);\\n                }\\n                start++;\\n            }\\n        }\\n\\n        return minLen == Integer.MAX_VALUE ? \"\" : s.substring(minStart, minStart + minLen);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1721617,
                "title": "simple-java-solution-sliding-window",
                "content": "Kindly upvote, if it helps you!\\n```\\n public String minWindow(String s, String t) {\\n        String result = \"\";\\n        if(s.length() < t.length())\\n            return result;\\n        int minWindow = Integer.MAX_VALUE;\\n\\t\\t//We will use two variables \\'have\\' & \\'need\\' to keep a track whether the characters \\n\\t\\t//we need have been encountered.\\n        int need = t.length();\\n        int have = 0;\\n\\t\\t//Two hashmaps are used to store the character count.\\n        Map<Character, Integer> sMap = new HashMap();\\n        Map<Character, Integer> tMap = new HashMap();\\n        for(int i=0; i<t.length(); i++){\\n            char ch = t.charAt(i);\\n            tMap.put(ch, tMap.getOrDefault(ch,0)+1);\\n        }\\n        int windowStart = 0;\\n        for(int windowEnd = 0; windowEnd<s.length(); windowEnd++){\\n            char ch = s.charAt(windowEnd);\\n            sMap.put(ch, sMap.getOrDefault(ch,0)+1);\\n\\t\\t\\t//if we have encountered a useful character, we will increment have variable.\\n            if(tMap.containsKey(ch) && sMap.get(ch)<=(tMap.get(ch))){\\n                have++;\\n            }\\n\\t\\t\\t//if have is equals to the need, means we got a substring in s having all the character of t\\n            while(have==need){\\n\\t\\t\\t\\t//check if its the mimimum substring till now\\n                if(minWindow > windowEnd-windowStart+1){\\n                    minWindow = windowEnd-windowStart+1;\\n                    result = s.substring(windowStart, windowEnd+1);\\n                }\\n\\t\\t\\t\\t//now we will check, can we do better\\n\\t\\t\\t\\t//is there a shorter substring\\n                char charToRemove = s.charAt(windowStart);\\n                if(sMap.get(charToRemove) == 1){\\n                    sMap.remove(charToRemove);\\n                }else{\\n                sMap.put(charToRemove, sMap.get(charToRemove)-1);\\n                }\\n                windowStart++;\\n\\t\\t\\t\\t//if we remove a useful char, decrementing have varaible\\n                if(tMap.containsKey(charToRemove) && sMap.getOrDefault(charToRemove,0)<(tMap.get(charToRemove))){\\n                    have--;\\n                }\\n            }\\n        }\\n        return result;\\n    }",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "Kindly upvote, if it helps you!\\n```\\n public String minWindow(String s, String t) {\\n        String result = \"\";\\n        if(s.length() < t.length())\\n            return result;\\n        int minWindow = Integer.MAX_VALUE;\\n\\t\\t//We will use two variables \\'have\\' & \\'need\\' to keep a track whether the characters \\n\\t\\t//we need have been encountered.\\n        int need = t.length();\\n        int have = 0;\\n\\t\\t//Two hashmaps are used to store the character count.\\n        Map<Character, Integer> sMap = new HashMap();\\n        Map<Character, Integer> tMap = new HashMap();\\n        for(int i=0; i<t.length(); i++){\\n            char ch = t.charAt(i);\\n            tMap.put(ch, tMap.getOrDefault(ch,0)+1);\\n        }\\n        int windowStart = 0;\\n        for(int windowEnd = 0; windowEnd<s.length(); windowEnd++){\\n            char ch = s.charAt(windowEnd);\\n            sMap.put(ch, sMap.getOrDefault(ch,0)+1);\\n\\t\\t\\t//if we have encountered a useful character, we will increment have variable.\\n            if(tMap.containsKey(ch) && sMap.get(ch)<=(tMap.get(ch))){\\n                have++;\\n            }\\n\\t\\t\\t//if have is equals to the need, means we got a substring in s having all the character of t\\n            while(have==need){\\n\\t\\t\\t\\t//check if its the mimimum substring till now\\n                if(minWindow > windowEnd-windowStart+1){\\n                    minWindow = windowEnd-windowStart+1;\\n                    result = s.substring(windowStart, windowEnd+1);\\n                }\\n\\t\\t\\t\\t//now we will check, can we do better\\n\\t\\t\\t\\t//is there a shorter substring\\n                char charToRemove = s.charAt(windowStart);\\n                if(sMap.get(charToRemove) == 1){\\n                    sMap.remove(charToRemove);\\n                }else{\\n                sMap.put(charToRemove, sMap.get(charToRemove)-1);\\n                }\\n                windowStart++;\\n\\t\\t\\t\\t//if we remove a useful char, decrementing have varaible\\n                if(tMap.containsKey(charToRemove) && sMap.getOrDefault(charToRemove,0)<(tMap.get(charToRemove))){\\n                    have--;\\n                }\\n            }\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 26971,
                "title": "three-o-n-concise-implemetation-according-to-leetcode-oj-discuss",
                "content": "    // according to http://leetcode.com/2010/11/finding-minimum-window-in-s-which.html\\n    // finds the first window that satisfies the constraint\\n    // then continue maintaining the constraint throughout\\n    // time complexity O(2N)\\n    string minWindow(string S, string T) {\\n        int m = S.size(), n = T.size();\\n        if (n <= 0 || m < n)\\n            return \"\";\\n        \\n        int require[128] = {0}, found[128] = {0};\\n        for (int k = 0; k < n; ++k) require[T[k]]++;\\n        \\n        int count = 0;\\n        int minLen = INT_MAX, minIndex = 0;\\n        for (int s = 0, e = 0; e < m; ++e) {\\n            // skip characters not in T\\n            if (require[S[e]] == 0) continue;\\n            if (++found[S[e]] <= require[S[e]]) count++;\\n            \\n            // windows constrain is sastisfied\\n            if (count == n) {\\n                // advance begin index as far as possible\\n                // stop when advancing breaks window constraint\\n                while (require[S[s]] == 0 || found[S[s]] > require[S[s]]) {\\n                    if (found[S[s]] > require[S[s]]) found[S[s]]--;\\n                    ++s;\\n                }\\n                // update minmum window\\n                if (e - s + 1 < minLen) {\\n                    minLen = e - s + 1;\\n                    minIndex = s;\\n                }\\n            }\\n        }\\n        \\n        if (minLen == INT_MAX) return \"\";\\n        return S.substr(minIndex, minLen); \\n    }\\n    \\n    string minWindow(string S, string T) {\\n        int m = S.size(), n = T.size();\\n        if (n <= 0 || m < n)\\n            return \"\";\\n        \\n        int require[128] = {0}, chSet[128] = {0};\\n        for (int k = 0; k < n; ++k) {\\n            require[T[k]]++;\\n            chSet[T[k]] = 1;\\n        }\\n        \\n        int minLen = INT_MAX, minIndex = 0;\\n        int i = -1, j = 0;\\n        while (i < m && j < m) {\\n            if (n) {\\n                ++i;\\n                require[S[i]]--;\\n                if (chSet[S[i]] && require[S[i]] >= 0) n--;\\n            }\\n            else {\\n                if (minLen > i - j + 1) {\\n                    minLen = i - j + 1;\\n                    minIndex = j;\\n                }\\n                require[S[j]]++;\\n                if (chSet[S[j]] && require[S[j]] > 0) n++;\\n                ++j;\\n            }\\n        }\\n        \\n        if (minLen == INT_MAX) return \"\";\\n        return S.substr(minIndex, minLen);\\n    }\\n\\n    // the most concise one\\n    // maintain a window with two pointers (left side and right side)\\n    string minWindow(string S, string T) {\\n        int m = S.size(), n = T.size();\\n        if (n <= 0 || m < n) return \"\";\\n        \\n        int require[128] = {0};\\n        for (int i = 0; i < n; ++i) require[T[i]]++;\\n        \\n        int count = 0;\\n        int minLen = INT_MAX, minIndex = 0;\\n        for (int s = 0, e = 0; e < m; ++e) {\\n            require[S[e]]--;\\n            if (require[S[e]] >= 0) count++;\\n            while (count == n) {\\n                if (e - s + 1 < minLen) {\\n                    minLen = e - s + 1;\\n                    minIndex = s;\\n                }\\n                require[S[s]]++;\\n                if (require[S[s]] > 0) count--;\\n                s++;\\n            }\\n        }\\n        \\n        if (minLen == INT_MAX) return \"\";\\n        return S.substr(minIndex, minLen); \\n    }",
                "solutionTags": [],
                "code": "    // according to http://leetcode.com/2010/11/finding-minimum-window-in-s-which.html\\n    // finds the first window that satisfies the constraint\\n    // then continue maintaining the constraint throughout\\n    // time complexity O(2N)\\n    string minWindow(string S, string T) {\\n        int m = S.size(), n = T.size();\\n        if (n <= 0 || m < n)\\n            return \"\";\\n        \\n        int require[128] = {0}, found[128] = {0};\\n        for (int k = 0; k < n; ++k) require[T[k]]++;\\n        \\n        int count = 0;\\n        int minLen = INT_MAX, minIndex = 0;\\n        for (int s = 0, e = 0; e < m; ++e) {\\n            // skip characters not in T\\n            if (require[S[e]] == 0) continue;\\n            if (++found[S[e]] <= require[S[e]]) count++;\\n            \\n            // windows constrain is sastisfied\\n            if (count == n) {\\n                // advance begin index as far as possible\\n                // stop when advancing breaks window constraint\\n                while (require[S[s]] == 0 || found[S[s]] > require[S[s]]) {\\n                    if (found[S[s]] > require[S[s]]) found[S[s]]--;\\n                    ++s;\\n                }\\n                // update minmum window\\n                if (e - s + 1 < minLen) {\\n                    minLen = e - s + 1;\\n                    minIndex = s;\\n                }\\n            }\\n        }\\n        \\n        if (minLen == INT_MAX) return \"\";\\n        return S.substr(minIndex, minLen); \\n    }\\n    \\n    string minWindow(string S, string T) {\\n        int m = S.size(), n = T.size();\\n        if (n <= 0 || m < n)\\n            return \"\";\\n        \\n        int require[128] = {0}, chSet[128] = {0};\\n        for (int k = 0; k < n; ++k) {\\n            require[T[k]]++;\\n            chSet[T[k]] = 1;\\n        }\\n        \\n        int minLen = INT_MAX, minIndex = 0;\\n        int i = -1, j = 0;\\n        while (i < m && j < m) {\\n            if (n) {\\n                ++i;\\n                require[S[i]]--;\\n                if (chSet[S[i]] && require[S[i]] >= 0) n--;\\n            }\\n            else {\\n                if (minLen > i - j + 1) {\\n                    minLen = i - j + 1;\\n                    minIndex = j;\\n                }\\n                require[S[j]]++;\\n                if (chSet[S[j]] && require[S[j]] > 0) n++;\\n                ++j;\\n            }\\n        }\\n        \\n        if (minLen == INT_MAX) return \"\";\\n        return S.substr(minIndex, minLen);\\n    }\\n\\n    // the most concise one\\n    // maintain a window with two pointers (left side and right side)\\n    string minWindow(string S, string T) {\\n        int m = S.size(), n = T.size();\\n        if (n <= 0 || m < n) return \"\";\\n        \\n        int require[128] = {0};\\n        for (int i = 0; i < n; ++i) require[T[i]]++;\\n        \\n        int count = 0;\\n        int minLen = INT_MAX, minIndex = 0;\\n        for (int s = 0, e = 0; e < m; ++e) {\\n            require[S[e]]--;\\n            if (require[S[e]] >= 0) count++;\\n            while (count == n) {\\n                if (e - s + 1 < minLen) {\\n                    minLen = e - s + 1;\\n                    minIndex = s;\\n                }\\n                require[S[s]]++;\\n                if (require[S[s]] > 0) count--;\\n                s++;\\n            }\\n        }\\n        \\n        if (minLen == INT_MAX) return \"\";\\n        return S.substr(minIndex, minLen); \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3417295,
                "title": "c-java-python-sliding-window-fully-explained-hash-table-string",
                "content": "# Intuition:\\nThe problem asks to find the minimum window in s that contains all the characters of t. One way to approach this problem is to use a sliding window technique. We can maintain a window that starts from the beginning of s and moves forward until it contains all the characters of t. Once we have such a window, we can try to shrink it by moving the window\\'s start pointer forward while still keeping all the characters of t in the window. This will give us the minimum window.\\n\\n#Approach:\\n\\n1. Check if s is shorter than t. If it is, there is no possible solution, and we return an empty string.\\n2. Create a frequency map of characters in t.\\n3. Initialize count, start, min_length, and min_start to 0.\\n4. Traverse the string s using the end pointer.\\n5. If the current character in s is present in the frequency map, increment the count.\\n6. Decrement the frequency of the current character in the frequency map.\\n7. If the count equals the length of t, it means we have found a window that contains all characters of t. Now we try to shrink the window by moving the start pointer forward until the window still contains all the characters of t.\\n8. If the length of the current window is smaller than the minimum length so far, update the minimum length and the minimum start.\\n9. Increment the frequency of the character at the start pointer and decrement the count.\\n10. Return the minimum window or an empty string if no window exists.\\n# Complexity:\\n- Time complexity: O(N), where N is the length of the string s. We traverse the string s once.\\n- Space complexity: O(M), where M is the length of the string t. We create a frequency map of characters in t.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        if(s.size() < t.size()){\\n            return \"\";\\n        }\\n        unordered_map<char,int> map;\\n        for(int i=0;i<t.size();i++){\\n            map[t[i]]++;\\n        }\\n        int count=0,start=0,min_length = INT_MAX, min_start = 0;\\n        for(int end=0; end<s.size(); end++){\\n            if(map[s[end]]>0){\\n                count++;\\n            }\\n            map[s[end]]--; \\n            if(count == t.length()) { \\n                while(start < end && map[s[start]] < 0){\\n                    map[s[start]]++, start++;\\n                } \\n                if(min_length > end-start){\\n                    min_length = end-(min_start=start)+1; \\n                }\\n                map[s[start++]]++; \\n                count--;\\n            }\\n        }\\n        return min_length == INT_MAX ? \"\" : s.substr(min_start, min_length);\\n    }\\n};\\n```\\n# JAVA\\n```\\nclass Solution {\\n    public String minWindow(String s, String t) {\\n        if(s.length() < t.length()){\\n            return \"\";\\n        }\\n        Map<Character,Integer> map = new HashMap<>();\\n        for(int i=0;i<t.length();i++){\\n            map.put(t.charAt(i), map.getOrDefault(t.charAt(i), 0) + 1);\\n        }\\n        int count=0,start=0,min_length = Integer.MAX_VALUE, min_start = 0;\\n        for(int end=0; end<s.length(); end++){\\n            if(map.containsKey(s.charAt(end))){\\n                if(map.get(s.charAt(end))>0){\\n                    count++;\\n                }\\n                map.put(s.charAt(end), map.get(s.charAt(end))-1); \\n            }\\n            if(count == t.length()) { \\n                while(start < end && (!map.containsKey(s.charAt(start)) || map.get(s.charAt(start)) < 0)){\\n                    if(map.containsKey(s.charAt(start))){\\n                        map.put(s.charAt(start), map.get(s.charAt(start))+1);\\n                    }\\n                    start++;\\n                } \\n                if(min_length > end-start+1){\\n                    min_length = end-(min_start=start)+1; \\n                }\\n                if(map.containsKey(s.charAt(start))){\\n                    map.put(s.charAt(start), map.get(s.charAt(start))+1);\\n                }\\n                count--;\\n                start++;\\n            }\\n        }\\n        return min_length == Integer.MAX_VALUE ? \"\" : s.substring(min_start, min_start+min_length);\\n    }\\n}\\n\\n```\\n# Python\\n```\\nclass Solution(object):\\n    def minWindow(self, s, t):\\n        if len(s) < len(t):\\n            return \"\"\\n        map = {}\\n        for char in t:\\n            if char in map:\\n                map[char] += 1\\n            else:\\n                map[char] = 1\\n        count = 0\\n        start = 0\\n        min_length = float(\"inf\")\\n        min_start = 0\\n        for end in range(len(s)):\\n            if s[end] in map:\\n                map[s[end]] -= 1\\n                if map[s[end]] >= 0:\\n                    count += 1\\n            while count == len(t):\\n                if min_length > end - start + 1:\\n                    min_length = end - start + 1\\n                    min_start = start\\n                if s[start] in map:\\n                    map[s[start]] += 1\\n                    if map[s[start]] > 0:\\n                        count -= 1\\n                start += 1\\n        return \"\" if min_length == float(\"inf\") else s[min_start:min_start+min_length]\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        if(s.size() < t.size()){\\n            return \"\";\\n        }\\n        unordered_map<char,int> map;\\n        for(int i=0;i<t.size();i++){\\n            map[t[i]]++;\\n        }\\n        int count=0,start=0,min_length = INT_MAX, min_start = 0;\\n        for(int end=0; end<s.size(); end++){\\n            if(map[s[end]]>0){\\n                count++;\\n            }\\n            map[s[end]]--; \\n            if(count == t.length()) { \\n                while(start < end && map[s[start]] < 0){\\n                    map[s[start]]++, start++;\\n                } \\n                if(min_length > end-start){\\n                    min_length = end-(min_start=start)+1; \\n                }\\n                map[s[start++]]++; \\n                count--;\\n            }\\n        }\\n        return min_length == INT_MAX ? \"\" : s.substr(min_start, min_length);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public String minWindow(String s, String t) {\\n        if(s.length() < t.length()){\\n            return \"\";\\n        }\\n        Map<Character,Integer> map = new HashMap<>();\\n        for(int i=0;i<t.length();i++){\\n            map.put(t.charAt(i), map.getOrDefault(t.charAt(i), 0) + 1);\\n        }\\n        int count=0,start=0,min_length = Integer.MAX_VALUE, min_start = 0;\\n        for(int end=0; end<s.length(); end++){\\n            if(map.containsKey(s.charAt(end))){\\n                if(map.get(s.charAt(end))>0){\\n                    count++;\\n                }\\n                map.put(s.charAt(end), map.get(s.charAt(end))-1); \\n            }\\n            if(count == t.length()) { \\n                while(start < end && (!map.containsKey(s.charAt(start)) || map.get(s.charAt(start)) < 0)){\\n                    if(map.containsKey(s.charAt(start))){\\n                        map.put(s.charAt(start), map.get(s.charAt(start))+1);\\n                    }\\n                    start++;\\n                } \\n                if(min_length > end-start+1){\\n                    min_length = end-(min_start=start)+1; \\n                }\\n                if(map.containsKey(s.charAt(start))){\\n                    map.put(s.charAt(start), map.get(s.charAt(start))+1);\\n                }\\n                count--;\\n                start++;\\n            }\\n        }\\n        return min_length == Integer.MAX_VALUE ? \"\" : s.substring(min_start, min_start+min_length);\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def minWindow(self, s, t):\\n        if len(s) < len(t):\\n            return \"\"\\n        map = {}\\n        for char in t:\\n            if char in map:\\n                map[char] += 1\\n            else:\\n                map[char] = 1\\n        count = 0\\n        start = 0\\n        min_length = float(\"inf\")\\n        min_start = 0\\n        for end in range(len(s)):\\n            if s[end] in map:\\n                map[s[end]] -= 1\\n                if map[s[end]] >= 0:\\n                    count += 1\\n            while count == len(t):\\n                if min_length > end - start + 1:\\n                    min_length = end - start + 1\\n                    min_start = start\\n                if s[start] in map:\\n                    map[s[start]] += 1\\n                    if map[s[start]] > 0:\\n                        count -= 1\\n                start += 1\\n        return \"\" if min_length == float(\"inf\") else s[min_start:min_start+min_length]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 411388,
                "title": "javascript-solution-w-detailed-comments",
                "content": "``` javascript\\nvar minWindowSlidingWindow = function (s, t) {\\n\\t// `right` is -1 since every loop, we start by expanding the right boundary\\n\\t// setting this to -1 ensures that we will check the first char on the first time\\n    let min = \"\", left = 0, right = -1;\\n    let map = {};\\n\\t\\n\\t// this creates a map for the characters we need to include in the substring\\n\\t// we store the character and its count since it can be repeated\\n\\t// for example: \"BAAC\"\\n    t.split(\\'\\').forEach(element => {\\n        if (map[element]==null) map[element] = 1;\\n        else map[element] = map[element] + 1;\\n    });\\n\\t\\n\\t// sets how many different characters we still have\\n\\t// for example: given the input \"BAAC\", we still have 3 different characters need to check\\n    let count = Object.keys(map).length;\\n\\n    while (right <= s.length) {\\n\\t\\t// found a valid substring\\n        if (count == 0) {\\n\\t\\t\\n\\t\\t\\t// try to shift left boudary to the right, this means the very left character will be removed\\n\\t\\t\\t// because of this, we need to check whats the affect by removing that character, \\n            let current = s[left];\\n\\t\\t\\t\\n\\t\\t\\t// if this chacter is in our map, it means we ll need to find another one in the future\\n            if (map[current] != null) map[current]++;\\n\\t\\t\\t\\n\\t\\t\\t// * we must have the condition `>0` because for case like \"BBBA...\", count for B could be negative\\n            if (map[current] > 0) count++;    \\n\\t\\t\\t\\n            let temp = s.substring(left, right+1)\\n            if (min == \"\") min = temp;\\n            else min = min.length<temp.length?min:temp;\\n\\t\\t\\t\\n            left++;\\n        } else {\\n            right++;\\n            let current = s[right];\\n\\t\\t\\t\\n\\t\\t\\t// decrease the count for this character\\n            if (map[current] != null) map[current]--;\\n\\t\\t\\t\\n            if (map[current] == 0) count--;\\n        }\\n    }\\n    return min;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\nvar minWindowSlidingWindow = function (s, t) {\\n\\t// `right` is -1 since every loop, we start by expanding the right boundary\\n\\t// setting this to -1 ensures that we will check the first char on the first time\\n    let min = \"\", left = 0, right = -1;\\n    let map = {};\\n\\t\\n\\t// this creates a map for the characters we need to include in the substring\\n\\t// we store the character and its count since it can be repeated\\n\\t// for example: \"BAAC\"\\n    t.split(\\'\\').forEach(element => {\\n        if (map[element]==null) map[element] = 1;\\n        else map[element] = map[element] + 1;\\n    });\\n\\t\\n\\t// sets how many different characters we still have\\n\\t// for example: given the input \"BAAC\", we still have 3 different characters need to check\\n    let count = Object.keys(map).length;\\n\\n    while (right <= s.length) {\\n\\t\\t// found a valid substring\\n        if (count == 0) {\\n\\t\\t\\n\\t\\t\\t// try to shift left boudary to the right, this means the very left character will be removed\\n\\t\\t\\t// because of this, we need to check whats the affect by removing that character, \\n            let current = s[left];\\n\\t\\t\\t\\n\\t\\t\\t// if this chacter is in our map, it means we ll need to find another one in the future\\n            if (map[current] != null) map[current]++;\\n\\t\\t\\t\\n\\t\\t\\t// * we must have the condition `>0` because for case like \"BBBA...\", count for B could be negative\\n            if (map[current] > 0) count++;    \\n\\t\\t\\t\\n            let temp = s.substring(left, right+1)\\n            if (min == \"\") min = temp;\\n            else min = min.length<temp.length?min:temp;\\n\\t\\t\\t\\n            left++;\\n        } else {\\n            right++;\\n            let current = s[right];\\n\\t\\t\\t\\n\\t\\t\\t// decrease the count for this character\\n            if (map[current] != null) map[current]--;\\n\\t\\t\\t\\n            if (map[current] == 0) count--;\\n        }\\n    }\\n    return min;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 26919,
                "title": "accepted-python-solution-using-hashtable",
                "content": "    class Solution:\\n        # @return a string\\n        def minWindow(self, S, T):\\n            indices = {}\\n            for char in T:\\n                indices[char] = []\\n            miss = list(T)\\n            start = 0\\n            end = len(S)\\n            for i in range(len(S)):\\n                if S[i] in T:\\n                    if S[i] not in miss and indices[S[i]] != []:\\n                        indices[S[i]].pop(0)\\n                    elif S[i] in miss:\\n                        miss.remove(S[i])\\n                    indices[S[i]].append(i)\\n                if miss == []:\\n                    maximum = max([x[-1] for x in indices.values()])\\n                    minimum = min([x[0] for x in indices.values()])\\n                    if maximum-minimum+1 < end-start+1:\\n                        start = minimum\\n                        end = maximum\\n            if miss != []:\\n                return \"\"\\n            else:\\n                return S[start:end+1]\\n\\nBasically I kept a dictionary to record the index of each character of T. Each time I found a window, (when miss == []), I checked the length of this window by subtracting the maximum index and the minimum index of the characters. If this window is the smallest one so far, I record its beginning and ending index as \"start\" and \"end.\"",
                "solutionTags": [],
                "code": "class Solution:\\n        # @return a string\\n        def minWindow(self, S, T):\\n            indices = {}",
                "codeTag": "Java"
            },
            {
                "id": 2730755,
                "title": "super-easy-java-solution-or-or-100-faster-or-or-easy-to-understand",
                "content": "# Looking for Contribution in Hacktoberfest\\n## You are welcomed to contribute in my Repos:-\\n# GITHUB LINK --> [Yaduttam95](https://github.com/Yaduttam95)\\n# All PRs are getting accepted...\\n\\n# Please upvote if Helpful\\n```\\nclass Solution {\\n    public String minWindow(String s, String t) {\\n        \\n        \\n        if(s==\"\" || t==\"\")\\n            return \"\";\\n        if(s==null || t==null)\\n            return \"\";\\n        \\n        int n = s.length();\\n        int m = t.length();\\n        \\n        \\n        int freq[] = new int[128];\\n        int characters = 0;\\n        \\n        for(int i=0;i<m;i++){\\n            freq[t.charAt(i)]++;\\n            characters++;\\n        }\\n        \\n        int start =0, end = 0;\\n        int min_length = Integer.MAX_VALUE;\\n        int start_index = 0;\\n        \\n        while(end < n){\\n            \\n            if(freq[s.charAt(end)]>0)\\n                characters--;\\n            freq[s.charAt(end)]--;\\n            end++;\\n            \\n            while(characters==0){\\n                \\n                if(min_length>end-start){\\n                    min_length = end-start;\\n                    start_index = start;\\n                }\\n                freq[s.charAt(start)]++;\\n                if(freq[s.charAt(start)]>0){\\n                    characters++;\\n                }\\n                start++;\\n                \\n            }\\n            \\n        }\\n        \\n        return min_length == Integer.MAX_VALUE? \"\" : s.substring(start_index,start_index+min_length);\\n        \\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/80bbe098-1d13-4e79-aba4-ff5f3522de19_1666336493.7066479.png)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String minWindow(String s, String t) {\\n        \\n        \\n        if(s==\"\" || t==\"\")\\n            return \"\";\\n        if(s==null || t==null)\\n            return \"\";\\n        \\n        int n = s.length();\\n        int m = t.length();\\n        \\n        \\n        int freq[] = new int[128];\\n        int characters = 0;\\n        \\n        for(int i=0;i<m;i++){\\n            freq[t.charAt(i)]++;\\n            characters++;\\n        }\\n        \\n        int start =0, end = 0;\\n        int min_length = Integer.MAX_VALUE;\\n        int start_index = 0;\\n        \\n        while(end < n){\\n            \\n            if(freq[s.charAt(end)]>0)\\n                characters--;\\n            freq[s.charAt(end)]--;\\n            end++;\\n            \\n            while(characters==0){\\n                \\n                if(min_length>end-start){\\n                    min_length = end-start;\\n                    start_index = start;\\n                }\\n                freq[s.charAt(start)]++;\\n                if(freq[s.charAt(start)]>0){\\n                    characters++;\\n                }\\n                start++;\\n                \\n            }\\n            \\n        }\\n        \\n        return min_length == Integer.MAX_VALUE? \"\" : s.substring(start_index,start_index+min_length);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 286584,
                "title": "python-easy-to-understand",
                "content": "```python\\ndef min_window(S: str, T: str) -> str:\\n    \"\"\"\\n    Minimum Window Substring\\n\\n    :param str S:\\n    :param str T:\\n    :return str:\\n    \"\"\"\\n    Tc = Counter(T)\\n    Sc = Counter()\\n\\n    best_i = -sys.maxsize\\n    best_j = sys.maxsize\\n\\n    i = 0\\n\\n    for j, char in enumerate(S):\\n        Sc[char] += 1\\n\\n        while Sc & Tc == Tc:\\n            if j - i < best_j - best_i:\\n                best_i, best_j = i, j\\n\\n            Sc[S[i]] -= 1\\n            i += 1\\n\\n    return S[best_i : best_j + 1] if best_j - best_i < len(S) else \"\"\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\ndef min_window(S: str, T: str) -> str:\\n    \"\"\"\\n    Minimum Window Substring\\n\\n    :param str S:\\n    :param str T:\\n    :return str:\\n    \"\"\"\\n    Tc = Counter(T)\\n    Sc = Counter()\\n\\n    best_i = -sys.maxsize\\n    best_j = sys.maxsize\\n\\n    i = 0\\n\\n    for j, char in enumerate(S):\\n        Sc[char] += 1\\n\\n        while Sc & Tc == Tc:\\n            if j - i < best_j - best_i:\\n                best_i, best_j = i, j\\n\\n            Sc[S[i]] -= 1\\n            i += 1\\n\\n    return S[best_i : best_j + 1] if best_j - best_i < len(S) else \"\"\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1404507,
                "title": "minimum-window-substring-using-map-w-explanation-c-python-java",
                "content": "**IDEA**\\nThe solution is a bit intuitive. We keep expanding the window by moving the right pointer. When the window has all the desired characters, we contract (if possible) and save the smallest window till now.\\n`The answer is the smallest desirable window.`\\n\\n**EXAMPLE**\\nFor eg. `S = \"ABAACBAB\" T = \"ABC\"`. Then our answer window is `\"ACB\"` and shown below is one of the possible desirable windows.\\n![image](https://assets.leetcode.com/users/images/aa5e8ecb-faa5-4542-ba85-4c3c0b986b8d_1629012971.6332936.png)\\n\\n**ALGORITHM**\\n*BASE CASE-*\\nIf either s or t is null then we can\\u2019t find any common window between them.\\n\\n*ELSE-*\\n* We start with two pointers, `leftleft` and `rightright` initially pointing to the first element of the string SS.\\n* We use the `rightright pointer` to expand the window until we get a desirable window i.e. a window that contains all of the characters of TT.\\n* Once we have a window with all the characters, we can move the left pointer ahead one by one. \\n\\t* \\tIf the window is still a desirable one we keep on updating the minimum window size.\\n\\t* \\tIf the window is not desirable any more, we repeat step 2 onwards.\\n\\n**SOLUTION**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n       unordered_map<char,int> mp;\\n        for(auto ch:t)\\n        {\\n            mp[ch]++;\\n        }\\n        int dist=mp.size() ;\\n        unordered_map<char,int> window;\\n        int count = 0 , ll = 0 , rr = 0 ;\\n        int l = 0 , r = 0 , ans = INT_MAX ;\\n        while(r<s.length())\\n        {\\n            window[s[r]]++ ;\\n            if(mp.count(s[r]) and mp[s[r]]==window[s[r]])\\n            {\\n                    count++;\\n            }\\n            r++;\\n            while(count == dist and l < r)\\n            {\\n                if(ans > r-l)\\n                {\\n                    ans= r - l ;\\n                    ll = l ;\\n                    rr = r ;\\n                }\\n                window[s[l]]-- ;\\n                if(mp.count(s[l]) and window[s[l]] < mp[s[l]])\\n                {\\n                        count--;\\n                }\\n                l++;\\n            }\\n        }\\n        return s.substr(ll,rr-ll);\\n    }\\n};\\n```\\n`In Python`\\n```\\nclass Solution(object):\\n    def minWindow(self, s, t):\\n        \"\"\"\\n        :type s: str\\n        :type t: str\\n        :rtype: str\\n        \"\"\"\\n        if not t or not s:\\n            return \"\"\\n\\n        dict_t = Counter(t)\\n        required = len(dict_t)\\n        l, r = 0, 0\\n        formed = 0\\n        window_counts = {}\\n        ans = float(\"inf\"), None, None\\n        while r < len(s):\\n            character = s[r]\\n            window_counts[character] = window_counts.get(character, 0) + 1\\n            if character in dict_t and window_counts[character] == dict_t[character]:\\n                formed += 1\\n            while l <= r and formed == required:\\n                character = s[l]\\n\\n                # Save the smallest window until now.\\n                if r - l + 1 < ans[0]:\\n                    ans = (r - l + 1, l, r)\\n\\n                window_counts[character] -= 1\\n                if character in dict_t and window_counts[character] < dict_t[character]:\\n                    formed -= 1\\n                l += 1    \\n\\n            r += 1    \\n        return \"\" if ans[0] == float(\"inf\") else s[ans[1] : ans[2] + 1]\\n\\n```\\n`In JAVA`\\n```\\nclass Solution {\\n    public String minWindow(String s, String t) {\\n        if(s==null || t==null)\\n        {\\n            return \"\";\\n        }\\n        HashMap<Character,Integer> map = new HashMap<Character,Integer>();\\n        for(char c : t.toCharArray())\\n        {\\n            if(map.containsKey(c))\\n            {\\n                map.put(c,map.get(c)+1);\\n            }\\n            else\\n            {\\n                map.put(c,1);\\n            }\\n        }\\n        int left = 0 , minLeft = 0, minLen = s.length() + 1 ;\\n        int count = 0;\\n        for(int right = 0; right < s.length(); right++)\\n        {\\n            if(map.containsKey(s.charAt(right)))\\n            {\\n                map.put(s.charAt(right),map.get(s.charAt(right))-1);\\n                if(map.get(s.charAt(right)) >= 0)\\n                {\\n                    count ++;\\n                }\\n                while(count == t.length())\\n                {\\n                    if(right-left+1 < minLen)\\n                    {\\n                        minLeft = left;\\n                        minLen = right-left+1;\\n                    }\\n                    if(map.containsKey(s.charAt(left)))\\n                    {\\n                        map.put(s.charAt(left),map.get(s.charAt(left))+1);\\n                        if(map.get(s.charAt(left)) > 0)\\n                        {\\n                            count --;\\n                        }\\n                    }\\n                    left++ ;\\n                }\\n            }\\n        }\\n        return minLen > s.length() ? \"\" : s.substring(minLeft,minLeft+minLen);\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n       unordered_map<char,int> mp;\\n        for(auto ch:t)\\n        {\\n            mp[ch]++;\\n        }\\n        int dist=mp.size() ;\\n        unordered_map<char,int> window;\\n        int count = 0 , ll = 0 , rr = 0 ;\\n        int l = 0 , r = 0 , ans = INT_MAX ;\\n        while(r<s.length())\\n        {\\n            window[s[r]]++ ;\\n            if(mp.count(s[r]) and mp[s[r]]==window[s[r]])\\n            {\\n                    count++;\\n            }\\n            r++;\\n            while(count == dist and l < r)\\n            {\\n                if(ans > r-l)\\n                {\\n                    ans= r - l ;\\n                    ll = l ;\\n                    rr = r ;\\n                }\\n                window[s[l]]-- ;\\n                if(mp.count(s[l]) and window[s[l]] < mp[s[l]])\\n                {\\n                        count--;\\n                }\\n                l++;\\n            }\\n        }\\n        return s.substr(ll,rr-ll);\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def minWindow(self, s, t):\\n        \"\"\"\\n        :type s: str\\n        :type t: str\\n        :rtype: str\\n        \"\"\"\\n        if not t or not s:\\n            return \"\"\\n\\n        dict_t = Counter(t)\\n        required = len(dict_t)\\n        l, r = 0, 0\\n        formed = 0\\n        window_counts = {}\\n        ans = float(\"inf\"), None, None\\n        while r < len(s):\\n            character = s[r]\\n            window_counts[character] = window_counts.get(character, 0) + 1\\n            if character in dict_t and window_counts[character] == dict_t[character]:\\n                formed += 1\\n            while l <= r and formed == required:\\n                character = s[l]\\n\\n                # Save the smallest window until now.\\n                if r - l + 1 < ans[0]:\\n                    ans = (r - l + 1, l, r)\\n\\n                window_counts[character] -= 1\\n                if character in dict_t and window_counts[character] < dict_t[character]:\\n                    formed -= 1\\n                l += 1    \\n\\n            r += 1    \\n        return \"\" if ans[0] == float(\"inf\") else s[ans[1] : ans[2] + 1]\\n\\n```\n```\\nclass Solution {\\n    public String minWindow(String s, String t) {\\n        if(s==null || t==null)\\n        {\\n            return \"\";\\n        }\\n        HashMap<Character,Integer> map = new HashMap<Character,Integer>();\\n        for(char c : t.toCharArray())\\n        {\\n            if(map.containsKey(c))\\n            {\\n                map.put(c,map.get(c)+1);\\n            }\\n            else\\n            {\\n                map.put(c,1);\\n            }\\n        }\\n        int left = 0 , minLeft = 0, minLen = s.length() + 1 ;\\n        int count = 0;\\n        for(int right = 0; right < s.length(); right++)\\n        {\\n            if(map.containsKey(s.charAt(right)))\\n            {\\n                map.put(s.charAt(right),map.get(s.charAt(right))-1);\\n                if(map.get(s.charAt(right)) >= 0)\\n                {\\n                    count ++;\\n                }\\n                while(count == t.length())\\n                {\\n                    if(right-left+1 < minLen)\\n                    {\\n                        minLeft = left;\\n                        minLen = right-left+1;\\n                    }\\n                    if(map.containsKey(s.charAt(left)))\\n                    {\\n                        map.put(s.charAt(left),map.get(s.charAt(left))+1);\\n                        if(map.get(s.charAt(left)) > 0)\\n                        {\\n                            count --;\\n                        }\\n                    }\\n                    left++ ;\\n                }\\n            }\\n        }\\n        return minLen > s.length() ? \"\" : s.substring(minLeft,minLeft+minLen);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1404497,
                "title": "python-o-n-m-sliding-window-explained",
                "content": "The idea of sliding window with 2 pointers: we create counter `cnt_t` is frequencies how many time s we need to take each symbol, for example for `abca` we have `a:2, b:1, c:1`. We create also `cnt_s` as empty counter, which will keep information about frequencies is current window `[beg, end)` - not that we do not include `end`. To quickly understand how many symbols have good frequency, we have `found` variable. Now, we can have two options to change our window:\\n\\n1. If `found == len(cnt_t)`, it means that we have in our window all symbols we want: no need to extend it to the right: we will shrink it to the left. We need to update our `ans`, where we keep pair `(end - beg, beg)` , then we look at the first element `old = s[beg]` and if we have `cnt_s[old] == cnt_t[old]` it means that we have exactly the right frequency for this symbol. So, when we move `beg` one position to the right, we need to decrease `found by one. Finally, we decrease frequency by one and more `beg` to the right.\\n2.  In the opposite case, first we check if `end == len(s)` and if it is true, we break. Then we look at the new symbol `new = s[end]` (because it was not included, windows are `[beg, end)`. We check if `cnt_s[new] == cnt_t[new] - 1` and if it is the case, it means, that when we add new symbol we need to increase `found` by one. Then we increase frequency and move `end` one position to the right.\\n\\n#### Complexity\\nTime complexity is `O(m + n)`, becuse on each step we move `beg` or `end` one point to the right. Space complexity is `O(A)`, where `A` is the size of alphabet.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def minWindow(self, s, t):\\n        beg, end = 0, 0\\n        ans, found = (float(\"inf\"), 0), 0\\n        cnt_t, cnt_s = Counter(t), Counter()\\n        while end <= len(s):\\n            if found == len(cnt_t):\\n                ans = min(ans, (end - beg, beg))\\n                old = s[beg]\\n                if cnt_s[old] == cnt_t[old]: found -= 1\\n                cnt_s[old] -= 1\\n                beg += 1\\n            else:\\n                if end == len(s): break\\n                new = s[end]\\n                if cnt_s[new] == cnt_t[new] - 1: found += 1\\n                cnt_s[new] += 1\\n                end += 1\\n        \\n        return s[ans[1]:ans[0]+ans[1]] if ans[0] != float(\"inf\") else \"\"\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```python\\nclass Solution:\\n    def minWindow(self, s, t):\\n        beg, end = 0, 0\\n        ans, found = (float(\"inf\"), 0), 0\\n        cnt_t, cnt_s = Counter(t), Counter()\\n        while end <= len(s):\\n            if found == len(cnt_t):\\n                ans = min(ans, (end - beg, beg))\\n                old = s[beg]\\n                if cnt_s[old] == cnt_t[old]: found -= 1\\n                cnt_s[old] -= 1\\n                beg += 1\\n            else:\\n                if end == len(s): break\\n                new = s[end]\\n                if cnt_s[new] == cnt_t[new] - 1: found += 1\\n                cnt_s[new] += 1\\n                end += 1\\n        \\n        return s[ans[1]:ans[0]+ans[1]] if ans[0] != float(\"inf\") else \"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 934026,
                "title": "explained-easy-to-understand-code-with-comments-3ms",
                "content": "```\\nclass Solution {\\n    public String minWindow(String s, String t) {\\n        int[] count = new int[128];\\n\\n        // Count the characters in t\\n        for (char ch : t.toCharArray()) count[ch]++;\\n\\n        char[] sourceStr = s.toCharArray();\\n        String windowString = \"\";\\n        int windowLeft = 0, windowRight = 0, charsFoundInWindow = 0,\\n                totalCharsToFind = t.length(), minWindowLen = Integer.MAX_VALUE;\\n        while (windowRight < sourceStr.length) {\\n            int currentChar = sourceStr[windowRight];\\n            // Reduce the count of current character\\n            count[currentChar]--;\\n            // If current character\\'s count is greater than or equal to 0 if it was also present in target string t\\n            // and we can say that we have found that character in current window so we increment charsFoundInWindow\\n            if (count[currentChar] >= 0) {\\n                charsFoundInWindow++;\\n            }\\n\\n            // If we found a window containing all characters of t, find if it\\'s smaller than the smallest window\\n            // If yes, store the window in windowString to return finally.\\n            while (charsFoundInWindow == totalCharsToFind) {\\n                int currentWindowLen = windowRight - windowLeft + 1;\\n                if(minWindowLen > currentWindowLen) {\\n                    minWindowLen = currentWindowLen;\\n                    windowString = s.substring(windowLeft, windowRight + 1);\\n                }\\n                // Now we need to reduce the window size from left to further look for smaller windows.\\n                // The current leftmost character was already visited by right pointer windowRight earlier\\n                // and we had reduced its count in count[]. So now we increment it because\\n                // we need the count of that character in the remaining window.\\n                count[sourceStr[windowLeft]]++;\\n                // Now if the last character is greater than 0, it means that character was present in t but\\n                // is not present in current window so we have to decrement charsFoundInWindow\\n                if (count[sourceStr[windowLeft]] > 0) {\\n                    charsFoundInWindow--;\\n                }\\n                windowLeft++;\\n            }\\n            windowRight++;\\n        }\\n        return windowString;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public String minWindow(String s, String t) {\\n        int[] count = new int[128];\\n\\n        // Count the characters in t\\n        for (char ch : t.toCharArray()) count[ch]++;\\n\\n        char[] sourceStr = s.toCharArray();\\n        String windowString = \"\";\\n        int windowLeft = 0, windowRight = 0, charsFoundInWindow = 0,\\n                totalCharsToFind = t.length(), minWindowLen = Integer.MAX_VALUE;\\n        while (windowRight < sourceStr.length) {\\n            int currentChar = sourceStr[windowRight];\\n            // Reduce the count of current character\\n            count[currentChar]--;\\n            // If current character\\'s count is greater than or equal to 0 if it was also present in target string t\\n            // and we can say that we have found that character in current window so we increment charsFoundInWindow\\n            if (count[currentChar] >= 0) {\\n                charsFoundInWindow++;\\n            }\\n\\n            // If we found a window containing all characters of t, find if it\\'s smaller than the smallest window\\n            // If yes, store the window in windowString to return finally.\\n            while (charsFoundInWindow == totalCharsToFind) {\\n                int currentWindowLen = windowRight - windowLeft + 1;\\n                if(minWindowLen > currentWindowLen) {\\n                    minWindowLen = currentWindowLen;\\n                    windowString = s.substring(windowLeft, windowRight + 1);\\n                }\\n                // Now we need to reduce the window size from left to further look for smaller windows.\\n                // The current leftmost character was already visited by right pointer windowRight earlier\\n                // and we had reduced its count in count[]. So now we increment it because\\n                // we need the count of that character in the remaining window.\\n                count[sourceStr[windowLeft]]++;\\n                // Now if the last character is greater than 0, it means that character was present in t but\\n                // is not present in current window so we have to decrement charsFoundInWindow\\n                if (count[sourceStr[windowLeft]] > 0) {\\n                    charsFoundInWindow--;\\n                }\\n                windowLeft++;\\n            }\\n            windowRight++;\\n        }\\n        return windowString;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1522115,
                "title": "here-is-my-c-code-with-line-by-line-explanation-as-comments",
                "content": "Please **Upvote** if you find it useful\\n\\n```\\nstring minWindow(string s, string t) {\\n    \\n    //This result variable will store the string which we will return\\n    string result;\\n\\n    //It will check if any of the two string is empty and return empty string result\\n    if(s.empty() || t.empty()){\\n        return result;\\n    }\\n\\n    //These 2 unorders maps will store frequency of characters in t string and windows\\n    unordered_map<char, int> map;\\n    unordered_map<char, int> window;\\n\\n    //It will update the frequency of each charater of string t int map;\\n    for(int i = 0; i < t.length(); i++){\\n        map[t[i]]++;\\n    }\\n\\n    //variable to store minimum length of result string\\n    int minLength = INT_MAX;\\n\\n    //counter\\n    int letterCounter = 0;\\n    \\n    for(int slow = 0, fast = 0; fast < s.length(); fast++){\\n        \\n        //This c variable will store each character of string s according to the fast pointer movement starting from 0\\n        char c = s[fast];\\n\\n        //If current character of \"s\" is available in map that consists of string \"t\" characters\\n        if(map.find(c) != map.end()){\\n            //store that character in current window and increase the counter by 1\\n            window[c]++;\\n            //This if condition will execute only if there is need to fulfill required charters from map to window and increase the letter counter\\n            if(window[c] <= map[c]){\\n                letterCounter++;\\n            }\\n        }\\n\\n        //This condition we have found the result in current window\\n        if(letterCounter >= t.length()){\\n            while (map.find(s[slow]) == map.end() || window[s[slow]] > map[s[slow]])\\n            {\\n                //This will start decreasing frequency of extra character in window\\n                window[s[slow]]--;\\n\\n                //and move slow pointer\\n                slow++;\\n            }\\n\\n            //It will update the minimum required substring\\n            if(fast-slow + 1 < minLength){\\n                minLength = fast - slow + 1;\\n                //It will update the result string\\n                result = s.substr(slow, minLength);\\n            }\\n        }\\n    }\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nstring minWindow(string s, string t) {\\n    \\n    //This result variable will store the string which we will return\\n    string result;\\n\\n    //It will check if any of the two string is empty and return empty string result\\n    if(s.empty() || t.empty()){\\n        return result;\\n    }\\n\\n    //These 2 unorders maps will store frequency of characters in t string and windows\\n    unordered_map<char, int> map;\\n    unordered_map<char, int> window;\\n\\n    //It will update the frequency of each charater of string t int map;\\n    for(int i = 0; i < t.length(); i++){\\n        map[t[i]]++;\\n    }\\n\\n    //variable to store minimum length of result string\\n    int minLength = INT_MAX;\\n\\n    //counter\\n    int letterCounter = 0;\\n    \\n    for(int slow = 0, fast = 0; fast < s.length(); fast++){\\n        \\n        //This c variable will store each character of string s according to the fast pointer movement starting from 0\\n        char c = s[fast];\\n\\n        //If current character of \"s\" is available in map that consists of string \"t\" characters\\n        if(map.find(c) != map.end()){\\n            //store that character in current window and increase the counter by 1\\n            window[c]++;\\n            //This if condition will execute only if there is need to fulfill required charters from map to window and increase the letter counter\\n            if(window[c] <= map[c]){\\n                letterCounter++;\\n            }\\n        }\\n\\n        //This condition we have found the result in current window\\n        if(letterCounter >= t.length()){\\n            while (map.find(s[slow]) == map.end() || window[s[slow]] > map[s[slow]])\\n            {\\n                //This will start decreasing frequency of extra character in window\\n                window[s[slow]]--;\\n\\n                //and move slow pointer\\n                slow++;\\n            }\\n\\n            //It will update the minimum required substring\\n            if(fast-slow + 1 < minLength){\\n                minLength = fast - slow + 1;\\n                //It will update the result string\\n                result = s.substr(slow, minLength);\\n            }\\n        }\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 308436,
                "title": "java-beats-100",
                "content": "```java\\nclass Solution {\\n    public String minWindow(String s, String t) {\\n        if(s.isEmpty()) return \"\";\\n        int[] need = new int[128];\\n        for(char c : t.toCharArray()) need[c]++;\\n        char[] a = s.toCharArray();\\n        int r = 0, l = 0, missing = t.length(), i = 0, j = 0;\\n        while(r < s.length()){\\n            if(need[a[r]] > 0) missing --;\\n            need[a[r]]--;\\n            r ++;\\n            while(missing == 0){\\n                if(j == 0 || (r - l) < (j - i)){\\n                    j = r;\\n                    i = l;\\n                }\\n                need[a[l]]++;\\n                if(need[a[l]] > 0) missing++;\\n                l++;\\n            }\\n        }\\n        return s.substring(i, j);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public String minWindow(String s, String t) {\\n        if(s.isEmpty()) return \"\";\\n        int[] need = new int[128];\\n        for(char c : t.toCharArray()) need[c]++;\\n        char[] a = s.toCharArray();\\n        int r = 0, l = 0, missing = t.length(), i = 0, j = 0;\\n        while(r < s.length()){\\n            if(need[a[r]] > 0) missing --;\\n            need[a[r]]--;\\n            r ++;\\n            while(missing == 0){\\n                if(j == 0 || (r - l) < (j - i)){\\n                    j = r;\\n                    i = l;\\n                }\\n                need[a[l]]++;\\n                if(need[a[l]] > 0) missing++;\\n                l++;\\n            }\\n        }\\n        return s.substring(i, j);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 26888,
                "title": "simple-javascript-solution-with-comments",
                "content": "    function minWindow(s, t) {\\n        var ans = '';\\n        \\n        // 1. process hashmap\\n        var map = {};\\n        t.split('').forEach(ch => map[ch] = (map[ch] || 0) + 1);\\n        var count = Object.keys(map).length;\\n        \\n        // 2. traverse s to find boundaries\\n        // both l & r are inclusive\\n        var l = 0;\\n        var r = -1;\\n        \\n        while (r < s.length) {\\n            if (count === 0) {\\n                // good condition\\n                // l~r contains t\\n                \\n                // update ans\\n                if (!ans || r - l + 1 < ans.length) {\\n                    ans = s.slice(l, r + 1);\\n                }\\n                \\n                // get rid of curr ch and then move l\\n                if (map[s[l]] !== undefined) {\\n                    map[s[l]]++;\\n                }\\n                if (map[s[l]] > 0) {\\n                    count++;\\n                }\\n                l++;\\n                \\n            } else {\\n                // bad condition\\n                // l~r doesn't contain t\\n                \\n                // move r and add new ch\\n                r++;\\n                if (map[s[r]] !== undefined) {\\n                    map[s[r]]--;\\n                }\\n                if (map[s[r]] === 0) {\\n                    count--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "    function minWindow(s, t) {\\n        var ans = '';\\n        \\n        // 1. process hashmap\\n        var map = {};\\n        t.split('').forEach(ch => map[ch] = (map[ch] || 0) + 1);\\n        var count = Object.keys(map).length;\\n        \\n        // 2. traverse s to find boundaries\\n        // both l & r are inclusive\\n        var l = 0;\\n        var r = -1;\\n        \\n        while (r < s.length) {\\n            if (count === 0) {\\n                // good condition\\n                // l~r contains t\\n                \\n                // update ans\\n                if (!ans || r - l + 1 < ans.length) {\\n                    ans = s.slice(l, r + 1);\\n                }\\n                \\n                // get rid of curr ch and then move l\\n                if (map[s[l]] !== undefined) {\\n                    map[s[l]]++;\\n                }\\n                if (map[s[l]] > 0) {\\n                    count++;\\n                }\\n                l++;\\n                \\n            } else {\\n                // bad condition\\n                // l~r doesn't contain t\\n                \\n                // move r and add new ch\\n                r++;\\n                if (map[s[r]] !== undefined) {\\n                    map[s[r]]--;\\n                }\\n                if (map[s[r]] === 0) {\\n                    count--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 262626,
                "title": "python-easy-to-understand-no-weird-tricks",
                "content": "```\\nimport collections\\nclass Solution(object):\\n    def minWindow(self, s, t):\\n        \"\"\"\\n        :type s: str\\n        :type t: str\\n        :rtype: str\\n        \"\"\"\\n        if len(s) < len(t):\\n            return \"\"\\n        \\n        hashmap = collections.Counter(t)\\n        counter = len(t)\\n        min_window = \"\"\\n        start, end = 0, 0\\n        \\n        \\n        for end in range(len(s)):\\n            if hashmap[s[end]] > 0:\\n                counter -= 1\\n            hashmap[s[end]] -= 1\\n            \\n            while counter == 0:\\n                length = end - start + 1\\n                \\n                if not min_window or len(min_window) > length:\\n                    min_window = s[start:end+1]\\n                \\n                hashmap[s[start]] += 1\\n\\n                if hashmap[s[start]] > 0:\\n                    counter += 1\\n                \\n                start += 1\\n        return min_window\\n                \\n                \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nimport collections\\nclass Solution(object):\\n    def minWindow(self, s, t):\\n        \"\"\"\\n        :type s: str\\n        :type t: str\\n        :rtype: str\\n        \"\"\"\\n        if len(s) < len(t):\\n            return \"\"\\n        \\n        hashmap = collections.Counter(t)\\n        counter = len(t)\\n        min_window = \"\"\\n        start, end = 0, 0\\n        \\n        \\n        for end in range(len(s)):\\n            if hashmap[s[end]] > 0:\\n                counter -= 1\\n            hashmap[s[end]] -= 1\\n            \\n            while counter == 0:\\n                length = end - start + 1\\n                \\n                if not min_window or len(min_window) > length:\\n                    min_window = s[start:end+1]\\n                \\n                hashmap[s[start]] += 1\\n\\n                if hashmap[s[start]] > 0:\\n                    counter += 1\\n                \\n                start += 1\\n        return min_window\\n                \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 26902,
                "title": "o-n-java-sliding-window-solution-with-explanation",
                "content": "**Sliding Window Solution:**\\n\\n    1) Spread the right pointer until it satisfies the requirement  \\n    2) Shrink the left pointer to get the minimum range \\n    3) Keep the above steps.\\n\\n**Time complexity = O(2n) = O(n)**\\n\\nThere're 2 loops: for loop of i, while loop of j. As j only steps forward, never steps backward. So time complexity = O(n) + O(n) = O(2n) = O(n)\\n\\n**JAVA Code:**  \\n \\nA little trick is using two arrays to count the characters in s and t, instead of HashMap, to avoid TLE.\\n\\n    boolean sContainsT(int mapS[], int mapT[]) {// Runtime = O(256) = O(1)\\n        for (int i = 0; i < mapT.length; i++) {// s should cover all characters in t\\n            if (mapT[i] > mapS[i])\\n                return false; \\n        }           \\n        return true;\\n    }\\n    \\n    public String minWindow(String s, String t) {   \\n        int mapS[] = new int[256];// Count characters in s\\n        int mapT[] = new int[256];// Count characters in t      \\n        for (char ch : t.toCharArray())\\n            mapT[ch]++;\\n    \\n        String res = \"\";\\n        int right = 0, min = Integer.MAX_VALUE;         \\n        for (int i = 0; i < s.length(); i++) {// Two pointers of the sliding window: i(left), right\\n            while (right < s.length() && !sContainsT(mapS, mapT)) {// Extend the right pointer of the sliding window\\n                mapS[s.charAt(right)]++;\\n                right++;\\n            }\\n            if (sContainsT(mapS, mapT) && min > right - i + 1) {\\n                res = s.substring(i, right);\\n                min = right - i + 1;\\n            }\\n            mapS[s.charAt(i)]--;// Shrink the left pointer from i to i + 1\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "**Sliding Window Solution:**\\n\\n    1) Spread the right pointer until it satisfies the requirement  \\n    2) Shrink the left pointer to get the minimum range \\n    3) Keep the above steps.\\n\\n**Time complexity = O(2n) = O(n)**\\n\\nThere're 2 loops: for loop of i, while loop of j. As j only steps forward, never steps backward. So time complexity = O(n) + O(n) = O(2n) = O(n)\\n\\n**JAVA Code:**  \\n \\nA little trick is using two arrays to count the characters in s and t, instead of HashMap, to avoid TLE.\\n\\n    boolean sContainsT(int mapS[], int mapT[]) {// Runtime = O(256) = O(1)\\n        for (int i = 0; i < mapT.length; i++) {// s should cover all characters in t\\n            if (mapT[i] > mapS[i])\\n                return false; \\n        }           \\n        return true;\\n    }\\n    \\n    public String minWindow(String s, String t) {   \\n        int mapS[] = new int[256];// Count characters in s\\n        int mapT[] = new int[256];// Count characters in t      \\n        for (char ch : t.toCharArray())\\n            mapT[ch]++;\\n    \\n        String res = \"\";\\n        int right = 0, min = Integer.MAX_VALUE;         \\n        for (int i = 0; i < s.length(); i++) {// Two pointers of the sliding window: i(left), right\\n            while (right < s.length() && !sContainsT(mapS, mapT)) {// Extend the right pointer of the sliding window\\n                mapS[s.charAt(right)]++;\\n                right++;\\n            }\\n            if (sContainsT(mapS, mapT) && min > right - i + 1) {\\n                res = s.substring(i, right);\\n                min = right - i + 1;\\n            }\\n            mapS[s.charAt(i)]--;// Shrink the left pointer from i to i + 1\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 746521,
                "title": "a-visualized-first-principles-approach-for-better-understanding",
                "content": "Heres a visualization techinque that might help you get a better idea of the solution. \\n\\nImagine the strings (henceforth **S** and **T**) as a long chain of characters\\n\\nFirst we will build a tool that will help us extract information about the target string **T**\\n\\nWe will extract 2 pieces of info from **T** - \\nfirst how many characters there are in T and what is the frequency of each character. \\n\\nWe focus on these 2 pieces of information because any substring in S that must contain T should satisfy 2 criteria: a. Have all the characters in T, b. Match the character frequency of T \\n\\n![image](https://assets.leetcode.com/users/images/820ea541-2611-43a1-b5dd-7c1e3dbcd3db_1595282693.3528335.png)\\n\\nSo Rem is the total number of characters remaining, and each characters frequency is the count of each char that is required. \\n\\nNext we will use this \"tool\" and run a sliding window over **S** to get to point where REM is 0. The points where REM is 0 are our windows where we have found all the characters that are present in T and match the same frequency. \\n\\nWe will continue expanding our window as long as REM is postive.\\nAt a step when Rem is <=0 we will start shrinking our window from the start until REM stays below or equal to 0. This will help us find our minimum length substring \\n\\n\\n\\nIt is important to note that the variable REM is changed **ONLY** when we see a character in **S** that is present in our tool. Then it can be that either: \\n\\na. We are expanding our window and the frequency of the matching character is postive in our tool. In this case required character frequency and REM are decreased **OR**\\nb. We are shirinking our window and the frequency of the matching character is negative in our tool. In this case character frequency is increased and REM is increased. \\n \\n A run of the two steps above is shown below: \\n \\n ![image](https://assets.leetcode.com/users/images/6ebd8d03-49a4-4d7f-9f56-e5e1eb802f76_1595286128.92845.png)\\n ![image](https://assets.leetcode.com/users/images/9ba7034b-a161-4f61-be1b-72ee02fe0b1a_1595286137.6609843.png)\\n ![image](https://assets.leetcode.com/users/images/25e7dd70-2fef-411b-b1e2-20d768333bdb_1595286143.7318404.png)\\n ![image](https://assets.leetcode.com/users/images/15297ab5-1fa0-4343-a086-ddcebb07896d_1595286150.1999655.png)\\n![image](https://assets.leetcode.com/users/images/0d3d1ff7-b774-4682-b363-d3ab0127ae1a_1595286158.0941873.png)\\n![image](https://assets.leetcode.com/users/images/a4acb697-8e09-410f-a251-a6526b44161b_1595286163.2758465.png)\\n![image](https://assets.leetcode.com/users/images/9d52686a-2a67-47fe-b73a-023a4e6807fa_1595286169.876245.png)\\n![image](https://assets.leetcode.com/users/images/eb854cfe-65e3-4ed8-bf22-6d9336345502_1595286176.810449.png)\\n![image](https://assets.leetcode.com/users/images/2c079361-d3bc-4118-9709-c207a514ec11_1595286181.926014.png)\\n![image](https://assets.leetcode.com/users/images/115728db-9b24-4050-890a-fb2fed90e207_1595286188.157475.png)\\n![image](https://assets.leetcode.com/users/images/9d478daa-bf71-4e96-88cc-090d7e9b96d4_1595286193.4163616.png)\\n![image](https://assets.leetcode.com/users/images/5cc7c448-6b32-4c6a-833d-b62a847d4ac9_1595286198.9250457.png)\\n![image](https://assets.leetcode.com/users/images/a3c3a564-6375-4c4c-9ed3-ef7fd7220455_1595286205.0798516.png)\\n![image](https://assets.leetcode.com/users/images/d84c131e-318e-41a9-9f58-2f1564c93669_1595286211.780769.png)\\n![image](https://assets.leetcode.com/users/images/599bd4a0-fd18-4367-8305-7bc7b83b38be_1595286217.9472275.png)\\n\\nHeres a corresponding AC solution in golang\\n```\\nfunc minWindow(s string, t string) string {\\n    rem := 0\\n    counter := make(map[byte]int)\\n    for i := range t {\\n        rem++\\n        counter[t[i]]++\\n    }\\n    if rem > len(s) {\\n        return \"\"\\n    }\\n    var ret = string(make([]byte, len(s)))\\n    start, end := 0,0\\n    for end < len(s){\\n        if v,ok := counter[s[end]] ;ok {\\n            if v>0 {\\n                rem--\\n            }\\n            counter[s[end]]--\\n        }\\n        for rem <= 0 {\\n            if len(ret) >= len(s[start:end+1]) {\\n                ret = s[start:end+1]\\n            }\\n            if _,ok := counter[s[start]] ;ok {\\n                counter[s[start]]++\\n                if counter[s[start]] > 0 {\\n                    rem++    \\n                }  \\n            }\\n            start++\\n        }\\n        end++\\n    }\\n    \\n    if ret == string(make([]byte, len(s))) {\\n        return \"\"\\n    }\\n    return ret\\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Go"
                ],
                "code": "Heres a visualization techinque that might help you get a better idea of the solution. \\n\\nImagine the strings (henceforth **S** and **T**) as a long chain of characters\\n\\nFirst we will build a tool that will help us extract information about the target string **T**\\n\\nWe will extract 2 pieces of info from **T** - \\nfirst how many characters there are in T and what is the frequency of each character. \\n\\nWe focus on these 2 pieces of information because any substring in S that must contain T should satisfy 2 criteria: a. Have all the characters in T, b. Match the character frequency of T \\n\\n![image](https://assets.leetcode.com/users/images/820ea541-2611-43a1-b5dd-7c1e3dbcd3db_1595282693.3528335.png)\\n\\nSo Rem is the total number of characters remaining, and each characters frequency is the count of each char that is required. \\n\\nNext we will use this \"tool\" and run a sliding window over **S** to get to point where REM is 0. The points where REM is 0 are our windows where we have found all the characters that are present in T and match the same frequency. \\n\\nWe will continue expanding our window as long as REM is postive.\\nAt a step when Rem is <=0 we will start shrinking our window from the start until REM stays below or equal to 0. This will help us find our minimum length substring \\n\\n\\n\\nIt is important to note that the variable REM is changed **ONLY** when we see a character in **S** that is present in our tool. Then it can be that either: \\n\\na. We are expanding our window and the frequency of the matching character is postive in our tool. In this case required character frequency and REM are decreased **OR**\\nb. We are shirinking our window and the frequency of the matching character is negative in our tool. In this case character frequency is increased and REM is increased. \\n \\n A run of the two steps above is shown below: \\n \\n ![image](https://assets.leetcode.com/users/images/6ebd8d03-49a4-4d7f-9f56-e5e1eb802f76_1595286128.92845.png)\\n ![image](https://assets.leetcode.com/users/images/9ba7034b-a161-4f61-be1b-72ee02fe0b1a_1595286137.6609843.png)\\n ![image](https://assets.leetcode.com/users/images/25e7dd70-2fef-411b-b1e2-20d768333bdb_1595286143.7318404.png)\\n ![image](https://assets.leetcode.com/users/images/15297ab5-1fa0-4343-a086-ddcebb07896d_1595286150.1999655.png)\\n![image](https://assets.leetcode.com/users/images/0d3d1ff7-b774-4682-b363-d3ab0127ae1a_1595286158.0941873.png)\\n![image](https://assets.leetcode.com/users/images/a4acb697-8e09-410f-a251-a6526b44161b_1595286163.2758465.png)\\n![image](https://assets.leetcode.com/users/images/9d52686a-2a67-47fe-b73a-023a4e6807fa_1595286169.876245.png)\\n![image](https://assets.leetcode.com/users/images/eb854cfe-65e3-4ed8-bf22-6d9336345502_1595286176.810449.png)\\n![image](https://assets.leetcode.com/users/images/2c079361-d3bc-4118-9709-c207a514ec11_1595286181.926014.png)\\n![image](https://assets.leetcode.com/users/images/115728db-9b24-4050-890a-fb2fed90e207_1595286188.157475.png)\\n![image](https://assets.leetcode.com/users/images/9d478daa-bf71-4e96-88cc-090d7e9b96d4_1595286193.4163616.png)\\n![image](https://assets.leetcode.com/users/images/5cc7c448-6b32-4c6a-833d-b62a847d4ac9_1595286198.9250457.png)\\n![image](https://assets.leetcode.com/users/images/a3c3a564-6375-4c4c-9ed3-ef7fd7220455_1595286205.0798516.png)\\n![image](https://assets.leetcode.com/users/images/d84c131e-318e-41a9-9f58-2f1564c93669_1595286211.780769.png)\\n![image](https://assets.leetcode.com/users/images/599bd4a0-fd18-4367-8305-7bc7b83b38be_1595286217.9472275.png)\\n\\nHeres a corresponding AC solution in golang\\n```\\nfunc minWindow(s string, t string) string {\\n    rem := 0\\n    counter := make(map[byte]int)\\n    for i := range t {\\n        rem++\\n        counter[t[i]]++\\n    }\\n    if rem > len(s) {\\n        return \"\"\\n    }\\n    var ret = string(make([]byte, len(s)))\\n    start, end := 0,0\\n    for end < len(s){\\n        if v,ok := counter[s[end]] ;ok {\\n            if v>0 {\\n                rem--\\n            }\\n            counter[s[end]]--\\n        }\\n        for rem <= 0 {\\n            if len(ret) >= len(s[start:end+1]) {\\n                ret = s[start:end+1]\\n            }\\n            if _,ok := counter[s[start]] ;ok {\\n                counter[s[start]]++\\n                if counter[s[start]] > 0 {\\n                    rem++    \\n                }  \\n            }\\n            start++\\n        }\\n        end++\\n    }\\n    \\n    if ret == string(make([]byte, len(s))) {\\n        return \"\"\\n    }\\n    return ret\\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 389880,
                "title": "easy-peasy-python-comments-solution",
                "content": "\\tdef minWindow(self, s: str, t: str) -> str:\\n        ln_s = len(s)\\n        ln_t = len(t)\\n        if ln_s == 0 or ln_t == 0 or ln_t > ln_s:\\n            return \"\"\\n        dct = {}\\n        for ch in t:\\n            dct[ch] = dct.get(ch, 0) + 1\\n        \\n        i = j = 0\\n        minWindow = ln_s + 1\\n        output = \"\"\\n        \\n        #ln_t will act as my counter.\\n        while i < ln_s:\\n            if s[i] in dct:\\n                # count how many needed chars are decremented\\n                if dct[s[i]] > 0:\\n                    ln_t -= 1\\n                    \\n                # decrement from the dict even if it leads to negative\\n                # so that I can take care of cases such as \"AZBBCA\" where I\\n                # need to find \"ABC\"\\n                dct[s[i]] -= 1\\n            \\n            # shrink the window size\\n            # and get the result and make it non-valid window\\n            # so that I can look forward\\n            while ln_t == 0:\\n                if i - j + 1 < minWindow:\\n                    minWindow = i - j + 1\\n                    output = s[j: i+1]\\n                \\n                if s[j] in dct:\\n                    dct[s[j]] += 1\\n                    \\n                    # I added a char from shrinking window\\n                    # which is needed for me to get \"T\"\\n                    if dct[s[j]] > 0:\\n                        ln_t += 1\\n                    \\n                j += 1\\n                    \\n            i += 1\\n        \\n        return \"\" if minWindow == ln_s + 1 else output",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "\\tdef minWindow(self, s: str, t: str) -> str:\\n        ln_s = len(s)\\n        ln_t = len(t)\\n        if ln_s == 0 or ln_t == 0 or ln_t > ln_s:\\n            return \"\"\\n        dct = {}\\n        for ch in t:\\n            dct[ch] = dct.get(ch, 0) + 1\\n        \\n        i = j = 0\\n        minWindow = ln_s + 1\\n        output = \"\"\\n        \\n        #ln_t will act as my counter.\\n        while i < ln_s:\\n            if s[i] in dct:\\n                # count how many needed chars are decremented\\n                if dct[s[i]] > 0:\\n                    ln_t -= 1\\n                    \\n                # decrement from the dict even if it leads to negative\\n                # so that I can take care of cases such as \"AZBBCA\" where I\\n                # need to find \"ABC\"\\n                dct[s[i]] -= 1\\n            \\n            # shrink the window size\\n            # and get the result and make it non-valid window\\n            # so that I can look forward\\n            while ln_t == 0:\\n                if i - j + 1 < minWindow:\\n                    minWindow = i - j + 1\\n                    output = s[j: i+1]\\n                \\n                if s[j] in dct:\\n                    dct[s[j]] += 1\\n                    \\n                    # I added a char from shrinking window\\n                    # which is needed for me to get \"T\"\\n                    if dct[s[j]] > 0:\\n                        ln_t += 1\\n                    \\n                j += 1\\n                    \\n            i += 1\\n        \\n        return \"\" if minWindow == ln_s + 1 else output",
                "codeTag": "Python3"
            },
            {
                "id": 1007092,
                "title": "python-o-n-and-o-t-with-explanation",
                "content": "```\\nTime Complexity: O(N)\\nSpace Complexity: O(T)\\n```\\n\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def minWindow(self, s: str, t: str) -> str:\\n\\t\\t# Count number of occurrences of each character from target string.\\n        t=Counter(t)   \\n\\t\\t\\n        #This will store number of unique characters in target string e.g \"aba\": 2, \"abc\": 3\\n\\t\\tcount=len(t)    \\n\\t\\t\\n\\t\\t# Sliding window initialization\\n\\t\\ti, j=0, 0  \\n\\t\\t\\n\\t\\t# Minimum size of the window where all characters from target string are found\\n        mini_window=float(\\'inf\\')  \\n\\t\\t\\n\\t\\t# Return answer\\n        mini_word=\"\"\\n        \\n        while j < len(s):\\n\\t\\t\\n\\t\\t\\t# The following loop will run till we get all occourences of target characters in the window\\n\\t\\t\\t# size of s[i: j], this is indicated if the count hits 0.\\n            while j < len(s) and count != 0:  \\n                if s[j] in t:\\n                    t[s[j]] -= 1\\n                    if t[s[j]] == 0:\\n                        count -= 1\\n                j += 1\\n            \\n\\t\\t\\t# Now since we have a window from s[i: j] containing all characters from target string.\\n\\t\\t\\t# We will try to reduce the string until one character goes missing\\n\\t\\t\\t# And concurrently store the minimum string containing all characters from traget string.\\n            while i <= j and count==0:\\n                if mini_window > j-i:\\n                    mini_word=s[i: j]\\n                    mini_window = j-i # j-i is minimum window size.\\n\\n                if s[i] in t:\\n                    t[s[i]] += 1\\n                    \\n                    if t[s[i]] >=1:\\n                        count += 1    \\n                i += 1\\n\\t\\t\\n\\t\\t# Finally return the answer we received\\n        return mini_word\\n```\\n\\n**UPVOTE IF YOU LIKED THE EXPLANATION OR COMMENT THE EDIT IF ANY**",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nTime Complexity: O(N)\\nSpace Complexity: O(T)\\n```\n```\\nfrom collections import Counter\\nclass Solution:\\n    def minWindow(self, s: str, t: str) -> str:\\n\\t\\t# Count number of occurrences of each character from target string.\\n        t=Counter(t)   \\n\\t\\t\\n        #This will store number of unique characters in target string e.g \"aba\": 2, \"abc\": 3\\n\\t\\tcount=len(t)    \\n\\t\\t\\n\\t\\t# Sliding window initialization\\n\\t\\ti, j=0, 0  \\n\\t\\t\\n\\t\\t# Minimum size of the window where all characters from target string are found\\n        mini_window=float(\\'inf\\')  \\n\\t\\t\\n\\t\\t# Return answer\\n        mini_word=\"\"\\n        \\n        while j < len(s):\\n\\t\\t\\n\\t\\t\\t# The following loop will run till we get all occourences of target characters in the window\\n\\t\\t\\t# size of s[i: j], this is indicated if the count hits 0.\\n            while j < len(s) and count != 0:  \\n                if s[j] in t:\\n                    t[s[j]] -= 1\\n                    if t[s[j]] == 0:\\n                        count -= 1\\n                j += 1\\n            \\n\\t\\t\\t# Now since we have a window from s[i: j] containing all characters from target string.\\n\\t\\t\\t# We will try to reduce the string until one character goes missing\\n\\t\\t\\t# And concurrently store the minimum string containing all characters from traget string.\\n            while i <= j and count==0:\\n                if mini_window > j-i:\\n                    mini_word=s[i: j]\\n                    mini_window = j-i # j-i is minimum window size.\\n\\n                if s[i] in t:\\n                    t[s[i]] += 1\\n                    \\n                    if t[s[i]] >=1:\\n                        count += 1    \\n                i += 1\\n\\t\\t\\n\\t\\t# Finally return the answer we received\\n        return mini_word\\n```",
                "codeTag": "Java"
            },
            {
                "id": 889531,
                "title": "c-sliding-window-simple-and-easy-to-understand-with-explanation-o-n-time-complexity",
                "content": "1. Make two frequency count array and store the frequency of t initially\\n2. If character match with the characters of t, increment the count variable\\n3. if count==length of t (t_len) => we found a window with all characters of t\\n4. Minimize the window size by removing extra characters from the start of window (using win_left for this).\\n5. Keep updating window of smaller length \\n6. Print substring of the smallest window found.\\n\\n```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        int s_len=s.length();\\n        int t_len=t.length();\\n        \\n        vector<int> freq_t(256,0);\\n        vector<int> freq_s(256,0);\\n        for(int i=0;i<t_len;i++)\\n            freq_t[t[i]]++;\\n        \\n        int win_left=0;               //Current window will always be [win_left,i]\\n        int ans=INT_MAX,ans_left;     //Track smallest window\\n        int count=0;                  //For tracking number of characters encountered of string t in string s\\n\\t\\t\\n\\t\\t\\n        for(int i=0;i<s_len;i++){\\n            if(freq_t[s[i]]>0 && freq_t[s[i]]>freq_s[s[i]])\\n                count++;\\n            freq_s[s[i]]++;\\n            if(count==t_len){ \\n                /*\\n\\t\\t\\t\\tAll characters required are in current window\\n                Now , try to minimize window by removing extra character at the start of window\\n                */\\n\\t\\t\\t\\t\\n                while(win_left<i &&         //Extra frequency or zero frequency characters\\n                      (freq_t[s[win_left]]<freq_s[s[win_left]] || freq_t[s[win_left]]==0)){\\n                    \\n                    if(freq_t[s[win_left]]<freq_s[s[win_left]])\\n                        freq_s[s[win_left]]--;\\n                    win_left++;\\n                }\\n                if(ans>(i-win_left+1)){\\n                    ans=(i-win_left+1);\\n                    ans_left=win_left;    \\n                }\\n            }\\n        }\\n        if(ans==INT_MAX)\\n            return \"\";\\n        return s.substr(ans_left,ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        int s_len=s.length();\\n        int t_len=t.length();\\n        \\n        vector<int> freq_t(256,0);\\n        vector<int> freq_s(256,0);\\n        for(int i=0;i<t_len;i++)\\n            freq_t[t[i]]++;\\n        \\n        int win_left=0;               //Current window will always be [win_left,i]\\n        int ans=INT_MAX,ans_left;     //Track smallest window\\n        int count=0;                  //For tracking number of characters encountered of string t in string s\\n\\t\\t\\n\\t\\t\\n        for(int i=0;i<s_len;i++){\\n            if(freq_t[s[i]]>0 && freq_t[s[i]]>freq_s[s[i]])\\n                count++;\\n            freq_s[s[i]]++;\\n            if(count==t_len){ \\n                /*\\n\\t\\t\\t\\tAll characters required are in current window\\n                Now , try to minimize window by removing extra character at the start of window\\n                */\\n\\t\\t\\t\\t\\n                while(win_left<i &&         //Extra frequency or zero frequency characters\\n                      (freq_t[s[win_left]]<freq_s[s[win_left]] || freq_t[s[win_left]]==0)){\\n                    \\n                    if(freq_t[s[win_left]]<freq_s[s[win_left]])\\n                        freq_s[s[win_left]]--;\\n                    win_left++;\\n                }\\n                if(ans>(i-win_left+1)){\\n                    ans=(i-win_left+1);\\n                    ans_left=win_left;    \\n                }\\n            }\\n        }\\n        if(ans==INT_MAX)\\n            return \"\";\\n        return s.substr(ans_left,ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145460,
                "title": "c-easiest-beginner-friendly-sol-sliding-window",
                "content": "# Intuition of this Problem:\\nReference - https://leetcode.com/problems/minimum-window-substring/solutions/26808/here-is-a-10-line-template-that-can-solve-most-substring-problems/?orderBy=hot\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**NOTE - PLEASE READ APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Approach for this Problem:\\n1. Initialize a map of size 128 to store the frequency of each character in string t.\\n2. Use a counter to keep track of the number of characters in t that have not been found in s yet.\\n3. Use two pointers, begin and end, to traverse the string s.\\n4. Increment the end pointer until a character is found in t and decrement the frequency of that character in the map. If the frequency of the character in the map becomes zero, decrement the counter.\\n5. When the counter reaches zero, it means that all the characters in t have been found in s. Start incrementing the begin pointer until the frequency of the character in the map becomes greater than zero.\\n6. Increment the counter when this happens.\\n7. Update the minimum window length and starting position if a new minimum window is found.\\n8. Repeat steps 3-5 until the end pointer has reached the end of string s.\\n9. Return the minimum window substring or an empty string if no such window exists.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Humble Request:\\n- If my solution is helpful to you then please **UPVOTE** my solution, your **UPVOTE** motivates me to post such kind of solution.\\n- Please let me know in comments if there is need to do any improvement in my approach, code....anything.\\n- **Let\\'s connect on** https://www.linkedin.com/in/abhinash-singh-1b851b188\\n\\n![57jfh9.jpg](https://assets.leetcode.com/users/images/c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg)\\n\\n# Code:\\n```C++ []\\n//shorter version\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        vector<int> map(128,0);\\n        for (auto c : t) map[c]++;\\n        int counter = t.size(), begin = 0, end = 0, d = INT_MAX, head = 0;\\n        while (end < s.size()){\\n            if (map[s[end++]]-- > 0) counter--; //in t\\n            while (counter == 0){ //valid\\n                if (end - begin<d)  d = end - (head = begin);\\n                if (map[s[begin++]]++ == 0) counter++;  //make it invalid\\n            }  \\n        }\\n        return d == INT_MAX ? \"\" : s.substr(head, d);\\n    }\\n};\\n```\\n```C++ []\\n//detailed version\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n\\t    vector<int> m(128, 0);\\n\\t    // Statistic for count of char in t\\n\\t    for (auto c : t) \\n            m[c]++;\\n\\t    // counter represents the number of chars of t to be found in s.\\n\\t    int start = 0, end = 0, counter = t.size(), minStart = 0, minLen = INT_MAX;\\n\\t    int size = s.size(); \\n\\t\\n\\t    // Move end to find a valid window.\\n\\t    while (end < size) {\\n\\t\\t    // If char in s exists in t, decrease counter\\n\\t\\t    if (m[s[end]] > 0)\\n\\t\\t\\t    counter--;\\n\\t\\t    // Decrease m[s[end]]. If char does not exist in t, m[s[end]] will be negative.\\n\\t\\t    m[s[end]]--;\\n\\t\\t    end++;\\n\\t\\t    // When we found a valid window, move start to find smaller window.\\n\\t\\t    while (counter == 0) {\\n\\t\\t\\t    if (end - start < minLen) {\\n\\t\\t\\t\\t    minStart = start;\\n\\t\\t\\t\\t    minLen = end - start;\\n\\t\\t\\t    }\\n\\t\\t\\t    m[s[start]]++;\\n\\t\\t\\t    // When char exists in t, increase counter.\\n\\t\\t\\t    if (m[s[start]] > 0)\\n\\t\\t\\t\\t    counter++;\\n\\t\\t\\t    start++;\\n\\t\\t    }\\n\\t    }\\n\\t    if (minLen != INT_MAX)\\n\\t\\t    return s.substr(minStart, minLen);\\n\\t    return \"\";\\n    }\\n};\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity: **O(|s| + |t|)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**, as the size of the map is constant and the space required is independent of the size of s and t.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Sliding Window"
                ],
                "code": "```C++ []\\n//shorter version\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        vector<int> map(128,0);\\n        for (auto c : t) map[c]++;\\n        int counter = t.size(), begin = 0, end = 0, d = INT_MAX, head = 0;\\n        while (end < s.size()){\\n            if (map[s[end++]]-- > 0) counter--; //in t\\n            while (counter == 0){ //valid\\n                if (end - begin<d)  d = end - (head = begin);\\n                if (map[s[begin++]]++ == 0) counter++;  //make it invalid\\n            }  \\n        }\\n        return d == INT_MAX ? \"\" : s.substr(head, d);\\n    }\\n};\\n```\n```C++ []\\n//detailed version\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n\\t    vector<int> m(128, 0);\\n\\t    // Statistic for count of char in t\\n\\t    for (auto c : t) \\n            m[c]++;\\n\\t    // counter represents the number of chars of t to be found in s.\\n\\t    int start = 0, end = 0, counter = t.size(), minStart = 0, minLen = INT_MAX;\\n\\t    int size = s.size(); \\n\\t\\n\\t    // Move end to find a valid window.\\n\\t    while (end < size) {\\n\\t\\t    // If char in s exists in t, decrease counter\\n\\t\\t    if (m[s[end]] > 0)\\n\\t\\t\\t    counter--;\\n\\t\\t    // Decrease m[s[end]]. If char does not exist in t, m[s[end]] will be negative.\\n\\t\\t    m[s[end]]--;\\n\\t\\t    end++;\\n\\t\\t    // When we found a valid window, move start to find smaller window.\\n\\t\\t    while (counter == 0) {\\n\\t\\t\\t    if (end - start < minLen) {\\n\\t\\t\\t\\t    minStart = start;\\n\\t\\t\\t\\t    minLen = end - start;\\n\\t\\t\\t    }\\n\\t\\t\\t    m[s[start]]++;\\n\\t\\t\\t    // When char exists in t, increase counter.\\n\\t\\t\\t    if (m[s[start]] > 0)\\n\\t\\t\\t\\t    counter++;\\n\\t\\t\\t    start++;\\n\\t\\t    }\\n\\t    }\\n\\t    if (minLen != INT_MAX)\\n\\t\\t    return s.substr(minStart, minLen);\\n\\t    return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2730813,
                "title": "java-100-2ms-clean-code-w-video-explanation",
                "content": "*Please **Upvote** if you find the explanation helpful*\\n\\n**Video Explanation**\\n[Minimum Window Substring | YouTube](https://www.youtube.com/watch?v=vVSEJuN6BHA&feature=youtu.be)\\n\\n**Java Solution**\\n```\\n//2ms\\n\\nclass Solution {\\n    public String minWindow(String s, String t) {\\n        int [] map = new int[128];\\n        for (char c : t.toCharArray()) {\\n            map[c]++;\\n        }\\n        int start = 0, end = 0, minStart = 0, minLen = Integer.MAX_VALUE, counter = t.length();\\n        while (end < s.length()) {\\n              final char c1 = s.charAt(end);\\n              if (map[c1] > 0) counter--;\\n              map[c1]--;\\n              end++;\\n              while (counter == 0) {\\n                    if (minLen > end - start) {\\n                          minLen = end - start;\\n                          minStart = start;\\n                    }\\n                    final char c2 = s.charAt(start);\\n                    map[c2]++;\\n                    if (map[c2] > 0) counter++;\\n                    start++;\\n              }\\n        }\\n\\n        return minLen == Integer.MAX_VALUE ? \"\" : s.substring(minStart, minStart + minLen);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\n//2ms\\n\\nclass Solution {\\n    public String minWindow(String s, String t) {\\n        int [] map = new int[128];\\n        for (char c : t.toCharArray()) {\\n            map[c]++;\\n        }\\n        int start = 0, end = 0, minStart = 0, minLen = Integer.MAX_VALUE, counter = t.length();\\n        while (end < s.length()) {\\n              final char c1 = s.charAt(end);\\n              if (map[c1] > 0) counter--;\\n              map[c1]--;\\n              end++;\\n              while (counter == 0) {\\n                    if (minLen > end - start) {\\n                          minLen = end - start;\\n                          minStart = start;\\n                    }\\n                    final char c2 = s.charAt(start);\\n                    map[c2]++;\\n                    if (map[c2] > 0) counter++;\\n                    start++;\\n              }\\n        }\\n\\n        return minLen == Integer.MAX_VALUE ? \"\" : s.substring(minStart, minStart + minLen);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2731147,
                "title": "c-sliding-window-map-string-easy-explanation-simple",
                "content": "# Approach \\n- Sliding Window Technique!!\\n- Map for storing Frequency\\n\\n# Complexity\\n- Time complexity: O(m+n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    // Sliding Window Approach\\n    // Time Complexity:- O(m+n)\\n    // Space Complexity:- O(n)\\n    \\n    string minWindow(string s, string t) {\\n        vector<string> ans;\\n        map<char,int> mp;\\n\\n        // Storing frequency of each character resent in t string\\n        for(auto i: t){\\n            mp[i]++;\\n        }\\n\\n        // Starting Point of window\\n        int i=0;\\n        // Ending Point of window\\n        int j=0;\\n        int count=mp.size();\\n        // st and mini for storing starting and ending point of our resultant substring\\n        int st=0;\\n        int mini=INT_MAX;\\n\\n        // Actual Approach\\n        while(j<s.size()){\\n            mp[s[j]]--;\\n\\n            if(mp[s[j]]==0){\\n                count--;\\n            }\\n\\n            if(count==0){\\n                while(count==0){\\n                   if((j-i+1)<mini){\\n                       mini=j-i+1;\\n                       st=i;\\n                   }\\n\\n                   mp[s[i]]++;\\n\\n                   if(mp[s[i]]>0){\\n                       count++;\\n                   }\\n\\n                   i++;\\n                }\\n            }\\n            \\n            j++;\\n        }\\n      \\n        // If No valid ans possible return empty string else return the final substring \\n        if(mini==INT_MAX){\\n            return \"\";\\n        }\\n        else{\\n            return s.substr(st,mini);\\n        }\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Ordered Map",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // Sliding Window Approach\\n    // Time Complexity:- O(m+n)\\n    // Space Complexity:- O(n)\\n    \\n    string minWindow(string s, string t) {\\n        vector<string> ans;\\n        map<char,int> mp;\\n\\n        // Storing frequency of each character resent in t string\\n        for(auto i: t){\\n            mp[i]++;\\n        }\\n\\n        // Starting Point of window\\n        int i=0;\\n        // Ending Point of window\\n        int j=0;\\n        int count=mp.size();\\n        // st and mini for storing starting and ending point of our resultant substring\\n        int st=0;\\n        int mini=INT_MAX;\\n\\n        // Actual Approach\\n        while(j<s.size()){\\n            mp[s[j]]--;\\n\\n            if(mp[s[j]]==0){\\n                count--;\\n            }\\n\\n            if(count==0){\\n                while(count==0){\\n                   if((j-i+1)<mini){\\n                       mini=j-i+1;\\n                       st=i;\\n                   }\\n\\n                   mp[s[i]]++;\\n\\n                   if(mp[s[i]]>0){\\n                       count++;\\n                   }\\n\\n                   i++;\\n                }\\n            }\\n            \\n            j++;\\n        }\\n      \\n        // If No valid ans possible return empty string else return the final substring \\n        if(mini==INT_MAX){\\n            return \"\";\\n        }\\n        else{\\n            return s.substr(st,mini);\\n        }\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1689996,
                "title": "c-aditya-verma-solution",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    string minWindow(string s, string t)\\n    {\\n        unordered_map<char, int> mp;\\n        for (int i = 0; i < t.size(); i++)\\n        {\\n            mp[t[i]]++;\\n        }\\n        int count = mp.size();\\n        string ans;\\n\\n        int mini = INT_MAX;\\n\\n        int i = 0;\\n        int j = 0;\\n\\n        while (j < s.size())\\n        {\\n\\n            if (mp.find(s[j]) != mp.end())\\n            {\\n                mp[s[j]]--;\\n                if (mp[s[j]] == 0)\\n                {\\n                    count--;\\n                }\\n            }\\n\\n            while (count == 0)\\n            {\\n                if (mini > j - i + 1)\\n                {\\n                    mini = min(mini, j - i + 1);\\n                    ans = s.substr(i, j - i + 1);\\n                }\\n                if (mp.find(s[i]) != mp.end())\\n                {\\n                    mp[s[i]]++;\\n                    if (mp[s[i]] == 1)\\n                    {\\n                        count++;\\n                    }\\n                }\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n\\t```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    string minWindow(string s, string t)\\n    {\\n        unordered_map<char, int> mp;\\n        for (int i = 0; i < t.size(); i++)\\n        {\\n            mp[t[i]]++;\\n        }\\n        int count = mp.size();\\n        string ans;\\n\\n        int mini = INT_MAX;\\n\\n        int i = 0;\\n        int j = 0;\\n\\n        while (j < s.size())\\n        {\\n\\n            if (mp.find(s[j]) != mp.end())\\n            {\\n                mp[s[j]]--;\\n                if (mp[s[j]] == 0)\\n                {\\n                    count--;\\n                }\\n            }\\n\\n            while (count == 0)\\n            {\\n                if (mini > j - i + 1)\\n                {\\n                    mini = min(mini, j - i + 1);\\n                    ans = s.substr(i, j - i + 1);\\n                }\\n                if (mp.find(s[i]) != mp.end())\\n                {\\n                    mp[s[i]]++;\\n                    if (mp[s[i]] == 1)\\n                    {\\n                        count++;\\n                    }\\n                }\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 846595,
                "title": "c-2-approaches-for-hashmap-way-too-much-commenting-and-explanation",
                "content": "**The idea of sliding window is this:**\\n1. Start two pointers - begin and end, both at 0.\\n2. Keep begin constant. Move end (i.e., do end++) till the condition is satisfied.\\n3. Once the condition is satisfied, move the begin pointer (do begin++) for as long as the condition is still satisfied. Update the minLength and keep a track of where the start pointer is at for that particular length. If its smaller than a previous length, update it. If not, continue with resizing the window as below:\\n4. Move end pointer to the right till the condition is satisfied again.\\n5. Once the entire string is traversed, use the minStart pointer and minlength to get the substring.\\n\\n**Checking the condition:**\\n* Now, the condition to satisfy here is - all chars (including duplicates) of string t are in the substring of s that we are processing. How do we check this? We need something like a hashcode. So build a hashtable/hashmap for t with it\\'s chars and their respective frequencies. \\n* Okay, now we need something similar for the substring we are processing so we can compare them both. Two ways to do this - create a plain vanilla hashmap for the substring or, use the map of t and use a counter to indicate number of chars to be matched. The second one is troubling for me. Its a bit too much to wrap my head around. nevertheless, code for both approaches are below:\\n\\n**WITH TWO HASHMAPS**\\n```\\nclass Solution {\\nprivate:\\n    bool isMatchingHashCode(map<char,int>& smap,map<char,int>& tmap){\\n        for(auto it = tmap.begin(); it != tmap.end(); ++it){\\n            char c= it->first; int freq = it->second;\\n            if(smap[c] <freq)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\npublic:\\n    string minWindow(string s, string t) {\\n        \\n        map<char,int> tmap,smap;\\n        for(char c : t) tmap[c]++;\\n        //tmap is the hashcode\\n        \\n        int start=0,end=0,counter=t.size(),minStart=0,minLen=INT_MAX;\\n        // counter represents the number of chars of t to be found in s.\\n        int size = s.size();\\n        \\n        while(end<size){\\n            smap[s[end]]++;; //add the freq of the char to smap \\n            end++; //window to the right\\n            \\n            //by this time, if we have reached the matching substring, we will start resizing. If not, then the window has been expanded on the right size and its proceeding\\n            while(isMatchingHashCode(smap,tmap)){\\n                if(end-start<minLen){\\n                    minStart=start;\\n                    minLen = end-start;\\n                } //update the head and tail and length if needed, else, continue resizing\\n                smap[s[start]]--; //going left \\n                start++;\\n            }\\n            \\n        }\\n        \\n        if(minLen!=INT_MAX){\\n            return s.substr(minStart,minLen);\\n        }\\n        return \"\";\\n        \\n    }\\n};\\n```\\n\\nThis one is super slow. Comparing the two maps over and over takes time. \\nHere is the second approach:\\n\\n**USING ONE HASHMAP**\\n(Though i do understand this now, i dont think this comes to me intuitively. How does one develop this intuition? Please help me understand this. Thanks in advance!)\\n```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        vector<int> tfreq(128,0);\\n        for(char c : t) tfreq[c]++;\\n        //tfreq is the hashcode\\n        \\n        int start=0,end=0,counter=t.size(),minStart=0,minLen=INT_MAX;\\n        // counter represents the number of chars of t to be found in s.\\n        int size = s.size();\\n        \\n        while(end<size){\\n            //if character in s exists in t => i.e., if char exists in t, the freq would be positive. (0if non-existent, -ve never happens)\\n            if(tfreq[s[end]]>0){\\n                counter--; //no.of chars to be found is 1 less now\\n            }\\n            tfreq[s[end]]--; //reduce the freq of that char regardless of its presence in t\\n            //if the char is not in t, it will result in negative frequency. later as we move the start pointer to the left, we will increase the freq of this char. So we will essentially cancel out all the subtractions we do on the char \\n            end++; //window to the right\\n            \\n            //by this time, if we have reached the matching substring, we will start resizing. If not, then the window has been expanded on the right size and its proceeding\\n            //when counter=0, tfreq should have all 0s\\n            while(counter==0){\\n                if(end-start<minLen){\\n                    minStart=start;\\n                    minLen = end-start;\\n                } //update the head and tail and length if needed, and then continue resizing\\n                tfreq[s[start]]++; \\n                /*if the char existed in t already, then freq would be greater than 0. Otherwise it will be 0 or less than 0as we reduced the frequency of the char earlier regardless of it being in t or not*/\\n                if(tfreq[s[start]]>0) counter++;\\n                start++;\\n            }\\n            \\n        }\\n        if(minLen!=INT_MAX){\\n            return s.substr(minStart,minLen);\\n        }\\n        return \"\";\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool isMatchingHashCode(map<char,int>& smap,map<char,int>& tmap){\\n        for(auto it = tmap.begin(); it != tmap.end(); ++it){\\n            char c= it->first; int freq = it->second;\\n            if(smap[c] <freq)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\npublic:\\n    string minWindow(string s, string t) {\\n        \\n        map<char,int> tmap,smap;\\n        for(char c : t) tmap[c]++;\\n        //tmap is the hashcode\\n        \\n        int start=0,end=0,counter=t.size(),minStart=0,minLen=INT_MAX;\\n        // counter represents the number of chars of t to be found in s.\\n        int size = s.size();\\n        \\n        while(end<size){\\n            smap[s[end]]++;; //add the freq of the char to smap \\n            end++; //window to the right\\n            \\n            //by this time, if we have reached the matching substring, we will start resizing. If not, then the window has been expanded on the right size and its proceeding\\n            while(isMatchingHashCode(smap,tmap)){\\n                if(end-start<minLen){\\n                    minStart=start;\\n                    minLen = end-start;\\n                } //update the head and tail and length if needed, else, continue resizing\\n                smap[s[start]]--; //going left \\n                start++;\\n            }\\n            \\n        }\\n        \\n        if(minLen!=INT_MAX){\\n            return s.substr(minStart,minLen);\\n        }\\n        return \"\";\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        vector<int> tfreq(128,0);\\n        for(char c : t) tfreq[c]++;\\n        //tfreq is the hashcode\\n        \\n        int start=0,end=0,counter=t.size(),minStart=0,minLen=INT_MAX;\\n        // counter represents the number of chars of t to be found in s.\\n        int size = s.size();\\n        \\n        while(end<size){\\n            //if character in s exists in t => i.e., if char exists in t, the freq would be positive. (0if non-existent, -ve never happens)\\n            if(tfreq[s[end]]>0){\\n                counter--; //no.of chars to be found is 1 less now\\n            }\\n            tfreq[s[end]]--; //reduce the freq of that char regardless of its presence in t\\n            //if the char is not in t, it will result in negative frequency. later as we move the start pointer to the left, we will increase the freq of this char. So we will essentially cancel out all the subtractions we do on the char \\n            end++; //window to the right\\n            \\n            //by this time, if we have reached the matching substring, we will start resizing. If not, then the window has been expanded on the right size and its proceeding\\n            //when counter=0, tfreq should have all 0s\\n            while(counter==0){\\n                if(end-start<minLen){\\n                    minStart=start;\\n                    minLen = end-start;\\n                } //update the head and tail and length if needed, and then continue resizing\\n                tfreq[s[start]]++; \\n                /*if the char existed in t already, then freq would be greater than 0. Otherwise it will be 0 or less than 0as we reduced the frequency of the char earlier regardless of it being in t or not*/\\n                if(tfreq[s[start]]>0) counter++;\\n                start++;\\n            }\\n            \\n        }\\n        if(minLen!=INT_MAX){\\n            return s.substr(minStart,minLen);\\n        }\\n        return \"\";\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 344533,
                "title": "simple-python-two-pointer-solution",
                "content": "Please see and vote for my solutions for these similar problems.\\n[1208. Get Equal Substrings Within Budget](https://leetcode.com/problems/get-equal-substrings-within-budget/discuss/392901/Simple-Python-moving-window)\\n[3. Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/discuss/348137/Simple-Python-two-pointer-solution-(52ms-beat-97.94))\\n[159. Longest Substring with At Most Two Distinct Characters](https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/discuss/348157/Simple-Python-two-pointer-solution)\\n[340. Longest Substring with At Most K Distinct Characters](https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/discuss/348216/Simple-Python-two-pointer-solution-(72-ms-beat-94.93))\\n[992. Subarrays with K Different Integers](https://leetcode.com/problems/subarrays-with-k-different-integers/discuss/348984/Different-Python-two-pointer-solutions)\\n[424. Longest Repeating Character Replacement](https://leetcode.com/problems/longest-repeating-character-replacement/discuss/363071/Simple-Python-two-pointer-solution)\\n[209. Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/discuss/344476/Simple-Python-two-pointer-solution)\\n[713. Subarray Product Less Than K](https://leetcode.com/problems/subarray-product-less-than-k/discuss/344245/Simple-Python-solution-(beat-94.59))\\n[76. Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/discuss/344533/Simple-Python-two-pointer-solution)\\n\\nSolution 1:\\nKeep a moving window expand while curr_freqs < freqs , then shrink while curr_freqs >= freqs.\\nEach time after shrinking, update the minimal window.\\nWhere curr_freqs >= freqs means all([curr_freqs[c] >= freqs[c] for c in freqs]).\\n```\\n    def minWindow(self, s: str, t: str) -> str:\\n        freqs = collections.Counter(t)\\n        curr_freqs = {c: 0 for c in freqs}\\n        res, res_len = \"\", float(\\'inf\\')\\n        left = 0\\n        for right in range(len(s)):\\n            if s[right] in freqs:\\n                curr_freqs[s[right]] += 1\\n                while all([curr_freqs[c] >= freqs[c] for c in freqs]):\\n                    if right - left + 1 < res_len:\\n                        res_len = right - left + 1\\n                        res = s[left:right+1]\\n                    if s[left] in freqs:\\n                        curr_freqs[s[left]] -= 1\\n                    left += 1\\n        return res\\n```\\n\\nSolution 2: improve the efficiency of all([curr_freqs[c] >= freqs[c] for c in freqs])\\n```\\n    def minWindow(self, s: str, t: str) -> str:\\n        need = collections.Counter(t)\\n        missing = sum(need.values())\\n        res, res_len = \"\", float(\\'inf\\')\\n        left = 0\\n        for right in range(len(s)):\\n            if s[right] in need:\\n                missing -= need[s[right]] > 0\\n                need[s[right]] -= 1\\n                while missing == 0:\\n                    if right - left + 1 < res_len:\\n                        res_len = right - left + 1\\n                        res = s[left:right+1]\\n                    if s[left] in need:\\n                        missing += need[s[left]] >= 0\\n                        need[s[left]] += 1\\n                    left += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def minWindow(self, s: str, t: str) -> str:\\n        freqs = collections.Counter(t)\\n        curr_freqs = {c: 0 for c in freqs}\\n        res, res_len = \"\", float(\\'inf\\')\\n        left = 0\\n        for right in range(len(s)):\\n            if s[right] in freqs:\\n                curr_freqs[s[right]] += 1\\n                while all([curr_freqs[c] >= freqs[c] for c in freqs]):\\n                    if right - left + 1 < res_len:\\n                        res_len = right - left + 1\\n                        res = s[left:right+1]\\n                    if s[left] in freqs:\\n                        curr_freqs[s[left]] -= 1\\n                    left += 1\\n        return res\\n```\n```\\n    def minWindow(self, s: str, t: str) -> str:\\n        need = collections.Counter(t)\\n        missing = sum(need.values())\\n        res, res_len = \"\", float(\\'inf\\')\\n        left = 0\\n        for right in range(len(s)):\\n            if s[right] in need:\\n                missing -= need[s[right]] > 0\\n                need[s[right]] -= 1\\n                while missing == 0:\\n                    if right - left + 1 < res_len:\\n                        res_len = right - left + 1\\n                        res = s[left:right+1]\\n                    if s[left] in need:\\n                        missing += need[s[left]] >= 0\\n                        need[s[left]] += 1\\n                    left += 1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3140920,
                "title": "c-easiest-beginner-friendly-sol-sliding-window",
                "content": "# Intuition of this Problem:\\nReference - https://leetcode.com/problems/minimum-window-substring/solutions/26808/here-is-a-10-line-template-that-can-solve-most-substring-problems/?orderBy=hot\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**NOTE - PLEASE READ APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Approach for this Problem:\\n1. Create a vector of size 128, m, to store the count of characters in string t.\\n2. Initialize start and end pointers, counter and variables minStart and minLen to store the starting position and length of the minimum window substring.\\n3. Traverse the string s from the end pointer and increase the end pointer until you find a valid window:\\n4. If the current character in s exists in t, decrease the counter.\\n5. Decrease the value of the current character in m.\\n6. If a valid window is found, move the start pointer to find a smaller window:\\n7. If the current window size is smaller than the minimum length found so far, update the minimum length and start position.\\n8. Increase the value of the current character in m.\\n9. If the current character exists in t, increase the counter.\\n10. Repeat steps 3 and 4 until the end pointer reaches the end of the string s.\\n11. If the minimum length is not equal to INT_MAX, return the minimum window substring, otherwise return an empty string.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Humble Request:\\n- If my solution is helpful to you then please **UPVOTE** my solution, your **UPVOTE** motivates me to post such kind of solution.\\n- Please let me know in comments if there is need to do any improvement in my approach, code....anything.\\n- **Let\\'s connect on** https://www.linkedin.com/in/abhinash-singh-1b851b188\\n\\n![57jfh9.jpg](https://assets.leetcode.com/users/images/c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg)\\n\\n# Code:\\n```C++ []\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n\\t    vector<int> m(128, 0);\\n\\t    // Statistic for count of char in t\\n\\t    for (auto c : t) \\n            m[c]++;\\n\\t    // counter represents the number of chars of t to be found in s.\\n\\t    int start = 0, end = 0, counter = t.size(), minStart = 0, minLen = INT_MAX;\\n\\t    int size = s.size();\\n\\t\\n\\t    // Move end to find a valid window.\\n\\t    while (end < size) {\\n\\t\\t    // If char in s exists in t, decrease counter\\n\\t\\t    if (m[s[end]] > 0)\\n\\t\\t\\t    counter--;\\n\\t\\t    // Decrease m[s[end]]. If char does not exist in t, m[s[end]] will be negative.\\n\\t\\t    m[s[end]]--;\\n\\t\\t    end++;\\n\\t\\t    // When we found a valid window, move start to find smaller window.\\n\\t\\t    while (counter == 0) {\\n\\t\\t\\t    if (end - start < minLen) {\\n\\t\\t\\t\\t    minStart = start;\\n\\t\\t\\t\\t    minLen = end - start;\\n\\t\\t\\t    }\\n\\t\\t\\t    m[s[start]]++;\\n\\t\\t\\t    // When char exists in t, increase counter.\\n\\t\\t\\t    if (m[s[start]] > 0)\\n\\t\\t\\t\\t    counter++;\\n\\t\\t\\t    start++;\\n\\t\\t    }\\n\\t    }\\n\\t    if (minLen != INT_MAX)\\n\\t\\t    return s.substr(minStart, minLen);\\n\\t    return \"\";\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public String minWindow(String s, String t) {\\n        int[] m = new int[128];\\n        for (char c : t.toCharArray()) \\n            m[c]++;\\n        int start = 0, end = 0, counter = t.length(), minStart = 0, minLen = Integer.MAX_VALUE;\\n        int size = s.length();\\n        while (end < size) {\\n            if (m[s.charAt(end++)]-- > 0) \\n                counter--;\\n            while (counter == 0) {\\n                if (end - start < minLen) {\\n                    minStart = start;\\n                    minLen = end - start;\\n                }\\n                if (m[s.charAt(start++)]++ == 0) \\n                    counter++;\\n            }\\n        }\\n        return minLen == Integer.MAX_VALUE ? \"\" : s.substring(minStart, minStart + minLen);\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def minWindow(self, s: str, t: str) -> str:\\n        m = [0] * 128\\n        for c in t:\\n            m[ord(c)] += 1\\n        start = 0\\n        end = 0\\n        counter = len(t)\\n        minStart = 0\\n        minLen = float(\\'inf\\')\\n        size = len(s)\\n        while end < size:\\n            if m[ord(s[end])] > 0:\\n                counter -= 1\\n            m[ord(s[end])] -= 1\\n            end += 1\\n            while counter == 0:\\n                if end - start < minLen:\\n                    minStart = start\\n                    minLen = end - start\\n                m[ord(s[start])] += 1\\n                if m[ord(s[start])] > 0:\\n                    counter\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity: **O(n)**, where n is the length of the input string s. This is because the while loop runs at most 2n times in the worst case (when all characters of s are different from t).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**, as the size of the frequency vector is fixed at 128. This is because the ASCII character set has only 128 characters. The size of other variables used in the algorithm is constant and does not grow with the input size.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n\\t    vector<int> m(128, 0);\\n\\t    // Statistic for count of char in t\\n\\t    for (auto c : t) \\n            m[c]++;\\n\\t    // counter represents the number of chars of t to be found in s.\\n\\t    int start = 0, end = 0, counter = t.size(), minStart = 0, minLen = INT_MAX;\\n\\t    int size = s.size();\\n\\t\\n\\t    // Move end to find a valid window.\\n\\t    while (end < size) {\\n\\t\\t    // If char in s exists in t, decrease counter\\n\\t\\t    if (m[s[end]] > 0)\\n\\t\\t\\t    counter--;\\n\\t\\t    // Decrease m[s[end]]. If char does not exist in t, m[s[end]] will be negative.\\n\\t\\t    m[s[end]]--;\\n\\t\\t    end++;\\n\\t\\t    // When we found a valid window, move start to find smaller window.\\n\\t\\t    while (counter == 0) {\\n\\t\\t\\t    if (end - start < minLen) {\\n\\t\\t\\t\\t    minStart = start;\\n\\t\\t\\t\\t    minLen = end - start;\\n\\t\\t\\t    }\\n\\t\\t\\t    m[s[start]]++;\\n\\t\\t\\t    // When char exists in t, increase counter.\\n\\t\\t\\t    if (m[s[start]] > 0)\\n\\t\\t\\t\\t    counter++;\\n\\t\\t\\t    start++;\\n\\t\\t    }\\n\\t    }\\n\\t    if (minLen != INT_MAX)\\n\\t\\t    return s.substr(minStart, minLen);\\n\\t    return \"\";\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public String minWindow(String s, String t) {\\n        int[] m = new int[128];\\n        for (char c : t.toCharArray()) \\n            m[c]++;\\n        int start = 0, end = 0, counter = t.length(), minStart = 0, minLen = Integer.MAX_VALUE;\\n        int size = s.length();\\n        while (end < size) {\\n            if (m[s.charAt(end++)]-- > 0) \\n                counter--;\\n            while (counter == 0) {\\n                if (end - start < minLen) {\\n                    minStart = start;\\n                    minLen = end - start;\\n                }\\n                if (m[s.charAt(start++)]++ == 0) \\n                    counter++;\\n            }\\n        }\\n        return minLen == Integer.MAX_VALUE ? \"\" : s.substring(minStart, minStart + minLen);\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def minWindow(self, s: str, t: str) -> str:\\n        m = [0] * 128\\n        for c in t:\\n            m[ord(c)] += 1\\n        start = 0\\n        end = 0\\n        counter = len(t)\\n        minStart = 0\\n        minLen = float(\\'inf\\')\\n        size = len(s)\\n        while end < size:\\n            if m[ord(s[end])] > 0:\\n                counter -= 1\\n            m[ord(s[end])] -= 1\\n            end += 1\\n            while counter == 0:\\n                if end - start < minLen:\\n                    minStart = start\\n                    minLen = end - start\\n                m[ord(s[start])] += 1\\n                if m[ord(s[start])] > 0:\\n                    counter\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2301430,
                "title": "javascript-simple-sliding-window-hash-map-solution",
                "content": "Time Complexity: O(S + T) where S and T are the respective lengths of strings `s` and `t`\\nSpace Complexity: O(S + T)\\n\\n**Intuition**\\n\\nThis is actually very similar to the [Permutation in String](https://leetcode.com/problems/permutation-in-string/) problem.  The difference is that we don\\'t match based on string length since we aren\\'t finding an exact permutation/anagram.  Instead, we want the minimal substring which means that we move our window based on finding the smallest possible solution that takes care of the counts of all the characters in `t`.  However, instead of keeping track of checking the exact count of each character each time we encounter a matching a character in `s`, we instead only need to keep track of how many unique characters there are in `t` and when a unique character goes down to 0 (or less, since having more characters than we need is okay too).  Since the length only goes down each time a character reaches exactly 0, we will never reach the count of all unique characters until every unique character has reached 0.\\n\\nThe key insight is that once we find the first substring that satisfies the condition, we need to start moving the left part of the window until we have the minimal substring that satisfies it since we don\\'t necessarily need all the characters on the left.  In the test case provided:\\n\\n`s = \"ADOBECODEBANC\"`\\n`t = \"ABC\"`\\n\\nThe minimal substring is just `BANC`, but we won\\'t encounter it until we\\'ve covered all of s.  At that point, we need to trim our substring from the left until we get to the minimal substring which can be accomplished with a while loop that moves the left pointer while the substring condition is true.\\n\\n```\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @return {string}\\n */\\nvar minWindow = function(s, t) {\\n    if (t.length > s.length) return \\'\\';\\n    \\n    const neededChars = {};\\n    \\n    for (let char of t) {\\n        neededChars[char] = (neededChars[char] || 0) + 1;\\n    }\\n    \\n    let left = 0;\\n    let right = 0;\\n    let neededLength = Object.keys(neededChars).length;\\n    let substring = \\'\\';\\n    \\n    while (right < s.length) {\\n        const rightChar = s[right];\\n        neededChars[rightChar]--;\\n        if (neededChars[rightChar] === 0) neededLength--;\\n        \\n        while (neededLength === 0) {\\n            if (!substring || substring.length > right - left + 1) {\\n                substring = s.slice(left, right + 1);\\n            }\\n            \\n            const leftChar = s[left];\\n            // If the leftChar in charMap is at exactly 0 before being \\n            // incremented, we now need more leftChars so that its count\\n            // in charMap goes down to exactly 0\\n            if (neededChars[leftChar] === 0) {\\n                neededLength++;\\n            }\\n            neededChars[leftChar]++;\\n            left++;\\n               \\n        }\\n        \\n        right++;\\n    }\\n    \\n    return substring;\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/4032e631-c774-42ff-b1ed-531364b99c7e_1658188062.4109056.png)\\n",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @return {string}\\n */\\nvar minWindow = function(s, t) {\\n    if (t.length > s.length) return \\'\\';\\n    \\n    const neededChars = {};\\n    \\n    for (let char of t) {\\n        neededChars[char] = (neededChars[char] || 0) + 1;\\n    }\\n    \\n    let left = 0;\\n    let right = 0;\\n    let neededLength = Object.keys(neededChars).length;\\n    let substring = \\'\\';\\n    \\n    while (right < s.length) {\\n        const rightChar = s[right];\\n        neededChars[rightChar]--;\\n        if (neededChars[rightChar] === 0) neededLength--;\\n        \\n        while (neededLength === 0) {\\n            if (!substring || substring.length > right - left + 1) {\\n                substring = s.slice(left, right + 1);\\n            }\\n            \\n            const leftChar = s[left];\\n            // If the leftChar in charMap is at exactly 0 before being \\n            // incremented, we now need more leftChars so that its count\\n            // in charMap goes down to exactly 0\\n            if (neededChars[leftChar] === 0) {\\n                neededLength++;\\n            }\\n            neededChars[leftChar]++;\\n            left++;\\n               \\n        }\\n        \\n        right++;\\n    }\\n    \\n    return substring;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2181426,
                "title": "logical-comments-easy-c-code-including-logical-comments",
                "content": "# Easy to understand code with complete comments:\\n\\n```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        unordered_map<char, int>mp;\\n        \\n        // keeping track of common char b/w s ans t\\n        for(auto i : t)\\n            mp[i]++;\\n        \\n        int start = 0,end =0;   // starting and ending of window\\n        int minlen = INT_MAX, minstart = 0;\\n        int count = t.size();   // variable to track when our window becomes valid\\n        int s_size = s.size();\\n        \\n        while(end<s_size)\\n        {\\n            \\n            if(mp[s[end]]>0)    // possible only for char common b/w s and t\\n                count--;\\n            \\n            mp[s[end]]--; // adding char to window and decreasing the mapping\\n            end++;          //move end forward\\n            \\n            while(count==0) // possible answer only here\\n            {\\n                if(end - start < minlen)  // window length minimization\\n                {\\n                    minlen = end - start;\\n                    minstart = start;\\n                }\\n                \\n                mp[s[start]]++; // removing char from window and increasing the mapping\\n                \\n                if(mp[s[start]]>0)  // possible only for the common chars and hence increase its count to make window invalid\\n                    count++;\\n                \\n                start++;    // move start forward\\n            }\\n            \\n        }\\n        \\n        if (minlen != INT_MAX)\\n\\t\\t    return s.substr(minstart, minlen);\\n\\t    return \"\";  // happens when s.size() < t.size()\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        unordered_map<char, int>mp;\\n        \\n        // keeping track of common char b/w s ans t\\n        for(auto i : t)\\n            mp[i]++;\\n        \\n        int start = 0,end =0;   // starting and ending of window\\n        int minlen = INT_MAX, minstart = 0;\\n        int count = t.size();   // variable to track when our window becomes valid\\n        int s_size = s.size();\\n        \\n        while(end<s_size)\\n        {\\n            \\n            if(mp[s[end]]>0)    // possible only for char common b/w s and t\\n                count--;\\n            \\n            mp[s[end]]--; // adding char to window and decreasing the mapping\\n            end++;          //move end forward\\n            \\n            while(count==0) // possible answer only here\\n            {\\n                if(end - start < minlen)  // window length minimization\\n                {\\n                    minlen = end - start;\\n                    minstart = start;\\n                }\\n                \\n                mp[s[start]]++; // removing char from window and increasing the mapping\\n                \\n                if(mp[s[start]]>0)  // possible only for the common chars and hence increase its count to make window invalid\\n                    count++;\\n                \\n                start++;    // move start forward\\n            }\\n            \\n        }\\n        \\n        if (minlen != INT_MAX)\\n\\t\\t    return s.substr(minstart, minlen);\\n\\t    return \"\";  // happens when s.size() < t.size()\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1360317,
                "title": "simple-c-solution-sliding-window-hashmap-explained-clearly-with-comments",
                "content": "\\n```\\n string minWindow(string s, string t) {\\n        // Initialize minl as INT_MAX\\n        int minl = INT_MAX;\\n        \\n        // Map to keep count of all characters of t \\n        unordered_map <int, int> mp;\\n        for(auto ch: t) mp[ch]++;\\n        \\n        // Sliding Window Approach\\n        // Let c be the count of chars of t in a particular window. Initialize as 0\\n        // start be the start of the current window\\n        // end be the end of current window\\n        // minstart be the start for the minimum window found yet.\\n        \\n        int c = 0;\\n        \\n        int start = 0;\\n        int minstart = 0;\\n        \\n        for(int end = 0; end<s.length(); end++)\\n        {\\n            if(mp[s[end]]>0) c++;\\n            mp[s[end]]--; \\n            \\n            // continue untill c equals length of t or when current window has all characters of t in it\\n            if(c==t.length())\\n            {\\n                // Note that negative values in map indicate the key char is not present in t, but present in s. And hence leading chars in s with negative values are insignificant.\\n                \\n                while(start<end && mp[s[start]]<0){\\n                    mp[s[start]]++;\\n                    start++;\\n                }\\n                \\n                if(end-start+1<minl)\\n                {\\n                    minl = end-start+1;\\n                    minstart = start;\\n                }\\n                \\n                // reduce the window size by incrementing start, reducing mp[s[start]] value, and reducing c\\n    \\n                mp[s[start]]++;\\n                start++;\\n                c--;\\n            }\\n        }\\n        \\n        if(minl==INT_MAX) return \"\";\\n        return s.substr(minstart, minl);\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\n string minWindow(string s, string t) {\\n        // Initialize minl as INT_MAX\\n        int minl = INT_MAX;\\n        \\n        // Map to keep count of all characters of t \\n        unordered_map <int, int> mp;\\n        for(auto ch: t) mp[ch]++;\\n        \\n        // Sliding Window Approach\\n        // Let c be the count of chars of t in a particular window. Initialize as 0\\n        // start be the start of the current window\\n        // end be the end of current window\\n        // minstart be the start for the minimum window found yet.\\n        \\n        int c = 0;\\n        \\n        int start = 0;\\n        int minstart = 0;\\n        \\n        for(int end = 0; end<s.length(); end++)\\n        {\\n            if(mp[s[end]]>0) c++;\\n            mp[s[end]]--; \\n            \\n            // continue untill c equals length of t or when current window has all characters of t in it\\n            if(c==t.length())\\n            {\\n                // Note that negative values in map indicate the key char is not present in t, but present in s. And hence leading chars in s with negative values are insignificant.\\n                \\n                while(start<end && mp[s[start]]<0){\\n                    mp[s[start]]++;\\n                    start++;\\n                }\\n                \\n                if(end-start+1<minl)\\n                {\\n                    minl = end-start+1;\\n                    minstart = start;\\n                }\\n                \\n                // reduce the window size by incrementing start, reducing mp[s[start]] value, and reducing c\\n    \\n                mp[s[start]]++;\\n                start++;\\n                c--;\\n            }\\n        }\\n        \\n        if(minl==INT_MAX) return \"\";\\n        return s.substr(minstart, minl);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 553734,
                "title": "javascript-96-66-better-used-char-array-instead-if-hash-map",
                "content": "```\\nvar minWindow = function(s, t) {\\n    \\n    let arr = new Array(128).fill(0); // Ascii charSet array to store count\\n    let result = [-Infinity, Infinity] // result not yet known\\n    let missing = t.length; // missing words initially\\n    \\n    for(let i=0; i < t.length; i++){ // increase the count in arr\\n        arr[t.charCodeAt(i)]++\\n    }\\n     \\n    let start = 0;\\n    \\n    for(let end = 0; end < s.length; end++){ // start from 0 and then expand\\n        if(arr[s.charCodeAt(end)] > 0){ // element present in t then decrese missing\\n            missing--\\n        }\\n        \\n        arr[s.charCodeAt(end)]-- // if not present in t then make it negative\\n        \\n        while(missing == 0){ // start decrementing start to check the best option\\n             if(result[1]-result[0] > end - start){ // store the best answer always\\n                result[1] = end; result[0] = start\\n            }\\n            \\n           \\n            arr[s.charCodeAt(start)]++ \\n            if(arr[s.charCodeAt(start)] > 0){ // if the char is present in t\\n                missing++\\n            }\\n          \\n            start++ \\n        }\\n        \\n        \\n    }\\n    \\n    return result[1] == Infinity ? \"\" : s.slice(result[0], result[1]+1);\\n    \\n};",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nvar minWindow = function(s, t) {\\n    \\n    let arr = new Array(128).fill(0); // Ascii charSet array to store count\\n    let result = [-Infinity, Infinity] // result not yet known\\n    let missing = t.length; // missing words initially\\n    \\n    for(let i=0; i < t.length; i++){ // increase the count in arr\\n        arr[t.charCodeAt(i)]++\\n    }\\n     \\n    let start = 0;\\n    \\n    for(let end = 0; end < s.length; end++){ // start from 0 and then expand\\n        if(arr[s.charCodeAt(end)] > 0){ // element present in t then decrese missing\\n            missing--\\n        }\\n        \\n        arr[s.charCodeAt(end)]-- // if not present in t then make it negative\\n        \\n        while(missing == 0){ // start decrementing start to check the best option\\n             if(result[1]-result[0] > end - start){ // store the best answer always\\n                result[1] = end; result[0] = start\\n            }\\n            \\n           \\n            arr[s.charCodeAt(start)]++ \\n            if(arr[s.charCodeAt(start)] > 0){ // if the char is present in t\\n                missing++\\n            }\\n          \\n            start++ \\n        }\\n        \\n        \\n    }\\n    \\n    return result[1] == Infinity ? \"\" : s.slice(result[0], result[1]+1);\\n    \\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 141591,
                "title": "sliding-window-thinking-process",
                "content": "> For example\\n```\\ne.g. S = \"ADOBECODEBANC\", T = \"ABC\"\\n          ADOBEC \\n\\t         BECODEBA \\n               CODEBA\\n                   BANC\\nThe substrings above are candidates for the result.\\n```\\n> In Brute Force, \\n```\\nfor left in [0: sLen - 1]\\n  for right in [left*: sLen - 1]\\n    if (canCover()) \\n\\t  update minLen and minStr\\n\\t  break\\n```\\n> After observation, there is no need to reset right to left here*\\n> If canCover, we move left forward until !canCover, we move right forward\\n```\\nfor left in [0: sLen - 1]\\n  while (right < sLen && !canCover()) \\n\\tright++\\n  update minLen and minStr\\n  left++\\n```\\n> So we use the Sliding Window technique to generate these candidates. \\n****\\n```\\n    private int[] charToFreqT; // Map char to freq in t\\n    \\n    public String minWindow(String s, String t) {\\n        // Corner case\\n        if (s.isEmpty() || t.isEmpty()) return \"\";\\n        \\n        buildCharToFreqT(t);\\n        \\n        int sLen = s.length(), minLen = Integer.MAX_VALUE, left = 0, right = 0;\\n        String minStr = \"\"; // Final result\\n        \\n        charToFreqT[s.charAt(0)]--;\\n        \\n        while (left <= right) { \\n            while (right < sLen && !canCover()) { \\n                right++;\\n                if (right < sLen) charToFreqT[s.charAt(right)]--;\\n            }\\n            if (right == sLen) break;\\n            // Update min by current window [left, right]\\n            if (right - left + 1 < minLen) {\\n                minLen = right - left + 1;\\n                minStr = s.substring(left, right + 1);\\n            }\\n            charToFreqT[s.charAt(left)]++;\\n            left++;\\n        }\\n        \\n        return minStr;\\n    }\\n    \\n    private void buildCharToFreqT(String t) {\\n        charToFreqT = new int[256];\\n        for (char ch : t.toCharArray()) {\\n            charToFreqT[ch]++;\\n        }\\n    }\\n    \\n    private boolean canCover() {\\n        // For each key in charToFreqT, charToFreqS contains and value >= T\\n        for (int freq : charToFreqT) {\\n            if (freq > 0) return false;\\n        }\\n        return true;\\n    }\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [],
                "code": "```\\ne.g. S = \"ADOBECODEBANC\", T = \"ABC\"\\n          ADOBEC \\n\\t         BECODEBA \\n               CODEBA\\n                   BANC\\nThe substrings above are candidates for the result.\\n```\n```\\nfor left in [0: sLen - 1]\\n  for right in [left*: sLen - 1]\\n    if (canCover()) \\n\\t  update minLen and minStr\\n\\t  break\\n```\n```\\nfor left in [0: sLen - 1]\\n  while (right < sLen && !canCover()) \\n\\tright++\\n  update minLen and minStr\\n  left++\\n```\n```\\n    private int[] charToFreqT; // Map char to freq in t\\n    \\n    public String minWindow(String s, String t) {\\n        // Corner case\\n        if (s.isEmpty() || t.isEmpty()) return \"\";\\n        \\n        buildCharToFreqT(t);\\n        \\n        int sLen = s.length(), minLen = Integer.MAX_VALUE, left = 0, right = 0;\\n        String minStr = \"\"; // Final result\\n        \\n        charToFreqT[s.charAt(0)]--;\\n        \\n        while (left <= right) { \\n            while (right < sLen && !canCover()) { \\n                right++;\\n                if (right < sLen) charToFreqT[s.charAt(right)]--;\\n            }\\n            if (right == sLen) break;\\n            // Update min by current window [left, right]\\n            if (right - left + 1 < minLen) {\\n                minLen = right - left + 1;\\n                minStr = s.substring(left, right + 1);\\n            }\\n            charToFreqT[s.charAt(left)]++;\\n            left++;\\n        }\\n        \\n        return minStr;\\n    }\\n    \\n    private void buildCharToFreqT(String t) {\\n        charToFreqT = new int[256];\\n        for (char ch : t.toCharArray()) {\\n            charToFreqT[ch]++;\\n        }\\n    }\\n    \\n    private boolean canCover() {\\n        // For each key in charToFreqT, charToFreqS contains and value >= T\\n        for (int freq : charToFreqT) {\\n            if (freq > 0) return false;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 26938,
                "title": "my-12ms-simple-c-code-o-1-space-o-n-time",
                "content": "Just used an array dict to count the occurence of the letters in t. To distinguish the letters that are not in t, we initialize dict with -slen and for those letters  that are not in t, their corresponding elements in dict will be -slen. For example, t=\"abc\", then dict['a']= dict['b']=dict['c']=1, while the others, such as dict['d'] = -slen. so if dict[x] == -slen, we know x is not in t. Of course, you can use an  unordered_map to simplify the logic, but it is much slower.\\nAfter building dict, we scan the string s, we use start to track the starting point of the current window and move i forward: we decrease dict[s[i]], if s[i] is a letter in t and in the current window we don't find all the occurence of s[i] (i.e. (--dict[s[i]]>=0) ), then s[i] will be counted as one letter of t. we decrease count by 1 and if count ==0 (i.e.  --count ==0),  it means we find all the letters of t in the current window. Then we move start to find the minium window, if s[start] is not in t (dict[s[start]]<= -slen ) or if we have more than enough such letters in the current window (i.e. (++dict[s[start]] <= 0,  for example, s= aaab, t= ab, say start = 0, i=3, then in that case dict[s[0]] = -1, so we can move start to 1 (so dict[s[0]] = 0), and stop at 2 (dict[s[0]] = 1)). After while, we find start of the minium window ending at i, then we compare such window with the one we found so far (with length minL and starts at minS). If it is shorter than minL, update minL and minS. At last, we increase start and count, and continue the search. \\nSince we have to move i and start through s, the complexity is O(N) \\n\\n    class Solution {\\n    public:\\n        string minWindow(string s, string t) {\\n            int slen = s.size(), tlen = t.size(), i, start=0, count, minL = INT_MAX, minS;\\n            int dict[128];\\n            fill_n(dict,128,-slen);\\n            for(i=0;i<tlen;++i) dict[t[i]] = dict[t[i]]>0? (dict[t[i]]+1):1;\\n            \\n            for(i=0, count = tlen; i<slen;++i)\\n            {\\n                if( (--dict[s[i]]>=0) && (--count == 0) )\\n                {\\n                    while(dict[s[start]]<=-slen || (++dict[s[start]] <= 0) ) ++start;\\n                    if(minL>i-start+1)\\n                    {\\n                        minL = i-start+1;\\n                        minS = start; \\n                    }\\n                    count=1;\\n                    ++start;\\n                }\\n            }\\n            return minL==INT_MAX? \"\":s.substr(minS, minL);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string minWindow(string s, string t) {\\n            int slen = s.size(), tlen = t.size(), i, start=0, count, minL = INT_MAX, minS;\\n            int dict[128];\\n            fill_n(dict,128,-slen);\\n            for(i=0;i<tlen;++i) dict[t[i]] = dict[t[i]]>0? (dict[t[i]]+1):1;\\n            \\n            for(i=0, count = tlen; i<slen;++i)\\n            {\\n                if( (--dict[s[i]]>=0) && (--count == 0) )\\n                {\\n                    while(dict[s[start]]<=-slen || (++dict[s[start]] <= 0) ) ++start;\\n                    if(minL>i-start+1)\\n                    {\\n                        minL = i-start+1;\\n                        minS = start; \\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1918853,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func minWindow(_ s: String, _ t: String) -> String {\\n        guard s.count >= t.count else { return \"\" }\\n        \\n        let sChars = Array(s)\\n        let tChars = Array(t)\\n        \\n        let indexs = validIndexs(sChars, tChars)\\n        guard s.count >= t.count else { return \"\" }\\n        \\n        let target = targetChars(tChars)\\n        let firstMatchIndex = firstMatch(sChars, indexs, target) \\n        var start = firstMatchIndex.0\\n        var end = firstMatchIndex.1\\n        \\n        if end == -1 {\\n            return \"\"\\n        }\\n        \\n        var tmp: [Character: Int] = [:]\\n        for i in indexs {\\n            if i < indexs[start] {\\n                continue\\n            }\\n            \\n            if i > indexs[end] {\\n                break\\n            }\\n            \\n            let c = sChars[i]\\n            if let _ = tmp[c] {\\n                tmp[c]! += 1 \\n            \\n            } else {\\n                tmp[c] = 1\\n            }\\n        }\\n        \\n        var minLength = indexs[end] - indexs[start]\\n        var minStart = start\\n        \\n        while end < indexs.count {\\n            //  start +1\\n            let c = sChars[indexs[start]]\\n            \\n            if tmp[c]! > target[c]! {\\n                start += 1\\n                tmp[c]! -= 1\\n                let currentLength = indexs[end] - indexs[start]\\n                minLength = minLength < currentLength ? minLength : currentLength\\n                minStart = minLength < currentLength ? minStart : start\\n                continue\\n            \\n            } else {\\n                start += 1\\n                tmp[c]! -= 1\\n                end += 1\\n                while end < indexs.count {\\n                    let e = sChars[indexs[end]]\\n                    tmp[e]! += 1\\n                    if e == c {\\n                        let currentLength = indexs[end] - indexs[start]\\n                        minLength = minLength < currentLength ? minLength : currentLength\\n                        minStart = minLength < currentLength ? minStart : start\\n                        break\\n                    }\\n                    end += 1\\n                }  \\n            }\\n        }\\n        \\n        return Array(sChars[indexs[minStart]...indexs[minStart] + minLength]).join(\"\")\\n    }\\n\\n    \\n    func firstMatch(_ s: [Character], _ indexs: [Int], _ target: [Character: Int]) -> (Int, Int) {\\n        var target = target\\n        var tmp = -1\\n        \\n        func reachTarget() -> Bool {\\n            var res = true\\n            for (_, value) in target {\\n                if value > 0 {\\n                    res = false\\n                    break\\n                }\\n            }\\n            return res\\n        }\\n        \\n        for (i, index) in indexs.enumerated() {\\n            target[s[index]]! -= 1\\n            if reachTarget() {\\n                tmp = i\\n                break\\n            }\\n        }\\n        \\n        return (0, tmp)\\n    }\\n    \\n\\n    func validIndexs(_ s: [Character], _ t: [Character]) -> [Int] {\\n        var res: [Int] = []\\n        \\n        for (i, c) in s.enumerated() {\\n            if t.contains(c) { res.append(i) }\\n        }\\n        \\n        return res\\n    }\\n\\n    \\n    func targetChars(_ t: [Character]) -> [Character: Int] {\\n        var map: [Character: Int] = [:]\\n        \\n        for c in t {\\n            if let _ = map[c] { map[c]! += 1 } else { map[c] = 1 }\\n        }\\n        \\n        return map\\n    }\\n\\n}\\n\\n\\nextension Array {\\n    func join(_ s: String) -> String {\\n        guard self.count > 0 else { return \"\" }\\n        if self.count == 1 { return \"\\\\(self[0])\" }\\n        var string = \"\"\\n\\n        for i in 0..<self.count - 1 { string += \"\\\\(self[i])\\\\(s)\" }\\n        \\n        string += \"\\\\(self[self.count - 1])\"\\n        return string\\n    }\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minWindow(_ s: String, _ t: String) -> String {\\n        guard s.count >= t.count else { return \"\" }\\n        \\n        let sChars = Array(s)\\n        let tChars = Array(t)\\n        \\n        let indexs = validIndexs(sChars, tChars)\\n        guard s.count >= t.count else { return \"\" }\\n        \\n        let target = targetChars(tChars)\\n        let firstMatchIndex = firstMatch(sChars, indexs, target) \\n        var start = firstMatchIndex.0\\n        var end = firstMatchIndex.1\\n        \\n        if end == -1 {\\n            return \"\"\\n        }\\n        \\n        var tmp: [Character: Int] = [:]\\n        for i in indexs {\\n            if i < indexs[start] {\\n                continue\\n            }\\n            \\n            if i > indexs[end] {\\n                break\\n            }\\n            \\n            let c = sChars[i]\\n            if let _ = tmp[c] {\\n                tmp[c]! += 1 \\n            \\n            } else {\\n                tmp[c] = 1\\n            }\\n        }\\n        \\n        var minLength = indexs[end] - indexs[start]\\n        var minStart = start\\n        \\n        while end < indexs.count {\\n            //  start +1\\n            let c = sChars[indexs[start]]\\n            \\n            if tmp[c]! > target[c]! {\\n                start += 1\\n                tmp[c]! -= 1\\n                let currentLength = indexs[end] - indexs[start]\\n                minLength = minLength < currentLength ? minLength : currentLength\\n                minStart = minLength < currentLength ? minStart : start\\n                continue\\n            \\n            } else {\\n                start += 1\\n                tmp[c]! -= 1\\n                end += 1\\n                while end < indexs.count {\\n                    let e = sChars[indexs[end]]\\n                    tmp[e]! += 1\\n                    if e == c {\\n                        let currentLength = indexs[end] - indexs[start]\\n                        minLength = minLength < currentLength ? minLength : currentLength\\n                        minStart = minLength < currentLength ? minStart : start\\n                        break\\n                    }\\n                    end += 1\\n                }  \\n            }\\n        }\\n        \\n        return Array(sChars[indexs[minStart]...indexs[minStart] + minLength]).join(\"\")\\n    }\\n\\n    \\n    func firstMatch(_ s: [Character], _ indexs: [Int], _ target: [Character: Int]) -> (Int, Int) {\\n        var target = target\\n        var tmp = -1\\n        \\n        func reachTarget() -> Bool {\\n            var res = true\\n            for (_, value) in target {\\n                if value > 0 {\\n                    res = false\\n                    break\\n                }\\n            }\\n            return res\\n        }\\n        \\n        for (i, index) in indexs.enumerated() {\\n            target[s[index]]! -= 1\\n            if reachTarget() {\\n                tmp = i\\n                break\\n            }\\n        }\\n        \\n        return (0, tmp)\\n    }\\n    \\n\\n    func validIndexs(_ s: [Character], _ t: [Character]) -> [Int] {\\n        var res: [Int] = []\\n        \\n        for (i, c) in s.enumerated() {\\n            if t.contains(c) { res.append(i) }\\n        }\\n        \\n        return res\\n    }\\n\\n    \\n    func targetChars(_ t: [Character]) -> [Character: Int] {\\n        var map: [Character: Int] = [:]\\n        \\n        for c in t {\\n            if let _ = map[c] { map[c]! += 1 } else { map[c] = 1 }\\n        }\\n        \\n        return map\\n    }\\n\\n}\\n\\n\\nextension Array {\\n    func join(_ s: String) -> String {\\n        guard self.count > 0 else { return \"\" }\\n        if self.count == 1 { return \"\\\\(self[0])\" }\\n        var string = \"\"\\n\\n        for i in 0..<self.count - 1 { string += \"\\\\(self[i])\\\\(s)\" }\\n        \\n        string += \"\\\\(self[self.count - 1])\"\\n        return string\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 26814,
                "title": "o-n-5ms-java-solution-beats-93-18",
                "content": "This solution adopts the idea described in this [LeetCode article][1]. It explains this O(n) solution very well. Because of that article, I kept the comments simple. I highly suggest you to read it before trying this code.\\n\\n    public class Solution {\\n      public String minWindow(String s, String t) {\\n        char[] needToFind = new char[256];\\n        char[] hasFound = new char[256];\\n        int sLen = s.length();\\n        int tLen = t.length();\\n        int count = 0;\\n        int optLen = Integer.MAX_VALUE; // opt stands for optimal\\n        int optBegin = 0;\\n        int optEnd = 0;\\n        for (int i = 0; i < tLen; i++) { // gives a counter for each character in t\\n          needToFind[t.charAt(i)]++;\\n        }\\n        for (int begin = 0, end = 0; end < sLen; end++) {\\n          if (needToFind[s.charAt(end)] == 0) { // skips irrelevant char\\n            continue;\\n          }\\n          char currEnd = s.charAt(end); // the char at the end\\n          hasFound[currEnd]++;\\n          if (hasFound[currEnd] <= needToFind[currEnd]) {\\n            count++;\\n          }\\n          if (count == tLen) { // pauses end, moves beginning to the right as much as possible\\n            char currBegin = s.charAt(begin); // char at begin\\n            while (hasFound[currBegin] > needToFind[currBegin] || needToFind[currBegin] == 0) {\\n              if (hasFound[currBegin] > needToFind[currBegin]) {\\n                hasFound[currBegin]--;\\n              }\\n              begin++;\\n              currBegin = s.charAt(begin);\\n            }\\n            if (optLen > end - begin + 1) { // if current length is smaller, update our optimum solution\\n              optLen = end - begin + 1;\\n              optBegin = begin;\\n              optEnd = end;\\n            }\\n          }\\n        }\\n        if (count != tLen) {\\n          return \"\";\\n        }\\n        return s.substring(optBegin, optEnd + 1);\\n      }\\n    }\\n\\n  [1]: http://articles.leetcode.com/finding-minimum-window-in-s-which/",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n      public String minWindow(String s, String t) {\\n        char[] needToFind = new char[256];\\n        char[] hasFound = new char[256];\\n        int sLen = s.length();\\n        int tLen = t.length();\\n        int count = 0;\\n        int optLen = Integer.MAX_VALUE; // opt stands for optimal\\n        int optBegin = 0;\\n        int optEnd = 0;\\n        for (int i = 0; i < tLen; i++) { // gives a counter for each character in t\\n          needToFind[t.charAt(i)]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2730928,
                "title": "simple-python-o-n-sliding-window-explained-with-example",
                "content": "**O(N) Sliding Window Python Solution with Counter**\\n```\\ndef minWindow(self, s: str, t: str) -> str:\\n\\ttCounter = Counter(t) # counter for t to check with\\n\\twindow = Counter() # sliding window\\n\\tans = \"\" # answer\\n\\tlast = 0 # last index in our window\\n\\tfor i,char in enumerate(s):\\n\\t\\twindow[char] = window.get(char,0)+1 # add this character to our window\\n\\t\\twhile window >= tCounter: # while we have all the necessary characters in our window\\n\\t\\t\\tif ans == \"\" or i - last < len(ans): # if the answer is better than our last one\\n\\t\\t\\t\\tans = s[last:i+1] # update ans\\n\\t\\t\\twindow[s[last]] -= 1 # remove the last element from our counter\\n\\t\\t\\tlast += 1 # move the last index forward\\n\\treturn ans # return answer\\n```\\n**Explanation**\\nThe basic idea of this solution is to use a sliding window, ```window```, to keep track of the elements we are looking at (from ```last``` to ```i```, inclusive). While this window has all the necessary counters (```window >= tCounter```), we update the answer if the length of our window, ```i - last```, is less than the length of the answer. We remove the last character when this is true to see if we can use a shorter window.\\n\\n**Example**\\nTo help understand how this algorithm works, let\\'s consider the first example given in the problem:\\n```\\ns = \"ADOBECODEBANC\", t = \"ABC\"\\ntCounter = Counter({\\'A\\': 1, \\'B\\': 1, \\'C\\': 1})\\n\\ni = 0, char = A\\nwindow = Counter({\\'A\\': 1}), from \"A\"\\nwe don\\'t have all the characters in tCounter!\\n\\ni = 1, char = D\\nwindow = Counter({\\'A\\': 1, \\'D\\': 1}), from \"AD\"\\nwe don\\'t have all the characters in tCounter!\\n\\ni = 2, char = O\\nwindow = Counter({\\'A\\': 1, \\'D\\': 1, \\'O\\': 1}), from \"ADO\"\\nwe don\\'t have all the characters in tCounter!\\n\\ni = 3, char = B\\nwindow = Counter({\\'A\\': 1, \\'D\\': 1, \\'O\\': 1, \\'B\\': 1}), from \"ADOB\"\\nwe don\\'t have all the characters in tCounter!\\n\\ni = 4, char = E\\nwindow = Counter({\\'A\\': 1, \\'D\\': 1, \\'O\\': 1, \\'B\\': 1, \\'E\\': 1}), from \"ADOBE\"\\nwe don\\'t have all the characters in tCounter!\\n\\ni = 5, char = C\\nwindow = Counter({\\'A\\': 1, \\'D\\': 1, \\'O\\': 1, \\'B\\': 1, \\'E\\': 1, \\'C\\': 1}), from \"ADOBEC\"\\nthe window contains all necessary elements\\nwe need to update our answer now! \\u2013\\u2013> ans = \"ADOBEC\"\\nremove the last element, \"A\"\\nnow window = Counter({\\'D\\': 1, \\'O\\': 1, \\'B\\': 1, \\'E\\': 1, \\'C\\': 1, \\'A\\': 0}), from \"DOBEC\"\\n\\ni = 6, char = O\\nwindow = Counter({\\'O\\': 2, \\'D\\': 1, \\'B\\': 1, \\'E\\': 1, \\'C\\': 1, \\'A\\': 0}), from \"DOBECO\"\\nwe don\\'t have all the characters in tCounter!\\n\\ni = 7, char = D\\nwindow = Counter({\\'D\\': 2, \\'O\\': 2, \\'B\\': 1, \\'E\\': 1, \\'C\\': 1, \\'A\\': 0}), from \"DOBECOD\"\\nwe don\\'t have all the characters in tCounter!\\n\\ni = 8, char = E\\nwindow = Counter({\\'D\\': 2, \\'O\\': 2, \\'E\\': 2, \\'B\\': 1, \\'C\\': 1, \\'A\\': 0}), from \"DOBECODE\"\\nwe don\\'t have all the characters in tCounter!\\n\\ni = 9, char = B\\nwindow = Counter({\\'D\\': 2, \\'O\\': 2, \\'B\\': 2, \\'E\\': 2, \\'C\\': 1, \\'A\\': 0}), from \"DOBECODEB\"\\nwe don\\'t have all the characters in tCounter!\\n\\ni = 10, char = A\\nwindow = Counter({\\'D\\': 2, \\'O\\': 2, \\'B\\': 2, \\'E\\': 2, \\'A\\': 1, \\'C\\': 1}), from \"DOBECODEBA\"\\nthe window contains all necessary elements\\nhowever, the window length is longer than our answer so we don\\'t update it\\nremove the last element, \"D\"\\nnow window = Counter({\\'O\\': 2, \\'B\\': 2, \\'E\\': 2, \\'A\\': 1, \\'D\\': 1, \\'C\\': 1}), from \"OBECODEBA\"\\n\\nthe window contains all necessary elements\\nhowever, the window length is longer than our answer so we don\\'t update it\\nremove the last element, \"O\"\\nnow window = Counter({\\'B\\': 2, \\'E\\': 2, \\'A\\': 1, \\'D\\': 1, \\'O\\': 1, \\'C\\': 1}), from \"BECODEBA\"\\n\\nthe window contains all necessary elements\\nhowever, the window length is longer than our answer so we don\\'t update it\\nremove the last element, \"B\"\\nnow window = Counter({\\'E\\': 2, \\'A\\': 1, \\'D\\': 1, \\'O\\': 1, \\'B\\': 1, \\'C\\': 1}), from \"ECODEBA\"\\n\\nthe window contains all necessary elements\\nhowever, the window length is longer than our answer so we don\\'t update it\\nremove the last element, \"E\"\\nnow window = Counter({\\'A\\': 1, \\'D\\': 1, \\'O\\': 1, \\'B\\': 1, \\'E\\': 1, \\'C\\': 1}), from \"CODEBA\"\\n\\nthe window contains all necessary elements\\nwe need to update our answer now! \\u2013\\u2013> ans = \"CODEBA\"\\nremove the last element, \"C\"\\nnow window = Counter({\\'A\\': 1, \\'D\\': 1, \\'O\\': 1, \\'B\\': 1, \\'E\\': 1, \\'C\\': 0}), from \"ODEBA\"\\n\\ni = 11, char = N\\nwindow = Counter({\\'A\\': 1, \\'D\\': 1, \\'O\\': 1, \\'B\\': 1, \\'E\\': 1, \\'N\\': 1, \\'C\\': 0}), from \"ODEBAN\"\\nwe don\\'t have all the characters in tCounter!\\n\\ni = 12, char = C\\nwindow = Counter({\\'A\\': 1, \\'D\\': 1, \\'O\\': 1, \\'B\\': 1, \\'E\\': 1, \\'C\\': 1, \\'N\\': 1}), from \"ODEBANC\"\\nthe window contains all necessary elements\\nhowever, the window length is longer than our answer so we don\\'t update it\\nremove the last element, \"O\"\\nnow window = Counter({\\'A\\': 1, \\'D\\': 1, \\'B\\': 1, \\'E\\': 1, \\'C\\': 1, \\'N\\': 1, \\'O\\': 0}), from \"DEBANC\"\\n\\nthe window contains all necessary elements\\nwe need to update our answer now! \\u2013\\u2013> ans = \"DEBANC\"\\nremove the last element, \"D\"\\nnow window = Counter({\\'A\\': 1, \\'B\\': 1, \\'E\\': 1, \\'C\\': 1, \\'N\\': 1, \\'D\\': 0, \\'O\\': 0}), from \"EBANC\"\\n\\nthe window contains all necessary elements\\nwe need to update our answer now! \\u2013\\u2013> ans = \"EBANC\"\\nremove the last element, \"E\"\\nnow window = Counter({\\'A\\': 1, \\'B\\': 1, \\'C\\': 1, \\'N\\': 1, \\'D\\': 0, \\'O\\': 0, \\'E\\': 0}), from \"BANC\"\\n\\nthe window contains all necessary elements\\nwe need to update our answer now! \\u2013\\u2013> ans = \"BANC\"\\nremove the last element, \"B\"\\nnow window = Counter({\\'A\\': 1, \\'C\\': 1, \\'N\\': 1, \\'D\\': 0, \\'O\\': 0, \\'B\\': 0, \\'E\\': 0}), from \"ANC\"\\n\\nreturn \"BANC\"\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\ndef minWindow(self, s: str, t: str) -> str:\\n\\ttCounter = Counter(t) # counter for t to check with\\n\\twindow = Counter() # sliding window\\n\\tans = \"\" # answer\\n\\tlast = 0 # last index in our window\\n\\tfor i,char in enumerate(s):\\n\\t\\twindow[char] = window.get(char,0)+1 # add this character to our window\\n\\t\\twhile window >= tCounter: # while we have all the necessary characters in our window\\n\\t\\t\\tif ans == \"\" or i - last < len(ans): # if the answer is better than our last one\\n\\t\\t\\t\\tans = s[last:i+1] # update ans\\n\\t\\t\\twindow[s[last]] -= 1 # remove the last element from our counter\\n\\t\\t\\tlast += 1 # move the last index forward\\n\\treturn ans # return answer\\n```\n```window```\n```last```\n```i```\n```window >= tCounter```\n```i - last```\n```\\ns = \"ADOBECODEBANC\", t = \"ABC\"\\ntCounter = Counter({\\'A\\': 1, \\'B\\': 1, \\'C\\': 1})\\n\\ni = 0, char = A\\nwindow = Counter({\\'A\\': 1}), from \"A\"\\nwe don\\'t have all the characters in tCounter!\\n\\ni = 1, char = D\\nwindow = Counter({\\'A\\': 1, \\'D\\': 1}), from \"AD\"\\nwe don\\'t have all the characters in tCounter!\\n\\ni = 2, char = O\\nwindow = Counter({\\'A\\': 1, \\'D\\': 1, \\'O\\': 1}), from \"ADO\"\\nwe don\\'t have all the characters in tCounter!\\n\\ni = 3, char = B\\nwindow = Counter({\\'A\\': 1, \\'D\\': 1, \\'O\\': 1, \\'B\\': 1}), from \"ADOB\"\\nwe don\\'t have all the characters in tCounter!\\n\\ni = 4, char = E\\nwindow = Counter({\\'A\\': 1, \\'D\\': 1, \\'O\\': 1, \\'B\\': 1, \\'E\\': 1}), from \"ADOBE\"\\nwe don\\'t have all the characters in tCounter!\\n\\ni = 5, char = C\\nwindow = Counter({\\'A\\': 1, \\'D\\': 1, \\'O\\': 1, \\'B\\': 1, \\'E\\': 1, \\'C\\': 1}), from \"ADOBEC\"\\nthe window contains all necessary elements\\nwe need to update our answer now! \\u2013\\u2013> ans = \"ADOBEC\"\\nremove the last element, \"A\"\\nnow window = Counter({\\'D\\': 1, \\'O\\': 1, \\'B\\': 1, \\'E\\': 1, \\'C\\': 1, \\'A\\': 0}), from \"DOBEC\"\\n\\ni = 6, char = O\\nwindow = Counter({\\'O\\': 2, \\'D\\': 1, \\'B\\': 1, \\'E\\': 1, \\'C\\': 1, \\'A\\': 0}), from \"DOBECO\"\\nwe don\\'t have all the characters in tCounter!\\n\\ni = 7, char = D\\nwindow = Counter({\\'D\\': 2, \\'O\\': 2, \\'B\\': 1, \\'E\\': 1, \\'C\\': 1, \\'A\\': 0}), from \"DOBECOD\"\\nwe don\\'t have all the characters in tCounter!\\n\\ni = 8, char = E\\nwindow = Counter({\\'D\\': 2, \\'O\\': 2, \\'E\\': 2, \\'B\\': 1, \\'C\\': 1, \\'A\\': 0}), from \"DOBECODE\"\\nwe don\\'t have all the characters in tCounter!\\n\\ni = 9, char = B\\nwindow = Counter({\\'D\\': 2, \\'O\\': 2, \\'B\\': 2, \\'E\\': 2, \\'C\\': 1, \\'A\\': 0}), from \"DOBECODEB\"\\nwe don\\'t have all the characters in tCounter!\\n\\ni = 10, char = A\\nwindow = Counter({\\'D\\': 2, \\'O\\': 2, \\'B\\': 2, \\'E\\': 2, \\'A\\': 1, \\'C\\': 1}), from \"DOBECODEBA\"\\nthe window contains all necessary elements\\nhowever, the window length is longer than our answer so we don\\'t update it\\nremove the last element, \"D\"\\nnow window = Counter({\\'O\\': 2, \\'B\\': 2, \\'E\\': 2, \\'A\\': 1, \\'D\\': 1, \\'C\\': 1}), from \"OBECODEBA\"\\n\\nthe window contains all necessary elements\\nhowever, the window length is longer than our answer so we don\\'t update it\\nremove the last element, \"O\"\\nnow window = Counter({\\'B\\': 2, \\'E\\': 2, \\'A\\': 1, \\'D\\': 1, \\'O\\': 1, \\'C\\': 1}), from \"BECODEBA\"\\n\\nthe window contains all necessary elements\\nhowever, the window length is longer than our answer so we don\\'t update it\\nremove the last element, \"B\"\\nnow window = Counter({\\'E\\': 2, \\'A\\': 1, \\'D\\': 1, \\'O\\': 1, \\'B\\': 1, \\'C\\': 1}), from \"ECODEBA\"\\n\\nthe window contains all necessary elements\\nhowever, the window length is longer than our answer so we don\\'t update it\\nremove the last element, \"E\"\\nnow window = Counter({\\'A\\': 1, \\'D\\': 1, \\'O\\': 1, \\'B\\': 1, \\'E\\': 1, \\'C\\': 1}), from \"CODEBA\"\\n\\nthe window contains all necessary elements\\nwe need to update our answer now! \\u2013\\u2013> ans = \"CODEBA\"\\nremove the last element, \"C\"\\nnow window = Counter({\\'A\\': 1, \\'D\\': 1, \\'O\\': 1, \\'B\\': 1, \\'E\\': 1, \\'C\\': 0}), from \"ODEBA\"\\n\\ni = 11, char = N\\nwindow = Counter({\\'A\\': 1, \\'D\\': 1, \\'O\\': 1, \\'B\\': 1, \\'E\\': 1, \\'N\\': 1, \\'C\\': 0}), from \"ODEBAN\"\\nwe don\\'t have all the characters in tCounter!\\n\\ni = 12, char = C\\nwindow = Counter({\\'A\\': 1, \\'D\\': 1, \\'O\\': 1, \\'B\\': 1, \\'E\\': 1, \\'C\\': 1, \\'N\\': 1}), from \"ODEBANC\"\\nthe window contains all necessary elements\\nhowever, the window length is longer than our answer so we don\\'t update it\\nremove the last element, \"O\"\\nnow window = Counter({\\'A\\': 1, \\'D\\': 1, \\'B\\': 1, \\'E\\': 1, \\'C\\': 1, \\'N\\': 1, \\'O\\': 0}), from \"DEBANC\"\\n\\nthe window contains all necessary elements\\nwe need to update our answer now! \\u2013\\u2013> ans = \"DEBANC\"\\nremove the last element, \"D\"\\nnow window = Counter({\\'A\\': 1, \\'B\\': 1, \\'E\\': 1, \\'C\\': 1, \\'N\\': 1, \\'D\\': 0, \\'O\\': 0}), from \"EBANC\"\\n\\nthe window contains all necessary elements\\nwe need to update our answer now! \\u2013\\u2013> ans = \"EBANC\"\\nremove the last element, \"E\"\\nnow window = Counter({\\'A\\': 1, \\'B\\': 1, \\'C\\': 1, \\'N\\': 1, \\'D\\': 0, \\'O\\': 0, \\'E\\': 0}), from \"BANC\"\\n\\nthe window contains all necessary elements\\nwe need to update our answer now! \\u2013\\u2013> ans = \"BANC\"\\nremove the last element, \"B\"\\nnow window = Counter({\\'A\\': 1, \\'C\\': 1, \\'N\\': 1, \\'D\\': 0, \\'O\\': 0, \\'B\\': 0, \\'E\\': 0}), from \"ANC\"\\n\\nreturn \"BANC\"\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2029821,
                "title": "the-most-easy-sliding-window-solution",
                "content": "```\\nstring minWindow(string s, string t) {\\n        string res = \"\";\\n        if(s.size() < t.size()) return res;\\n        unordered_map<char, int> umap;\\n        for(auto it: t) umap[it]++;\\n        int i=0, j=0;\\n        int length = INT_MAX, count = umap.size();\\n        while(j<s.size()){\\n            if(umap.find(s[j])!=umap.end()){\\n                umap[s[j]]--;\\n                if(umap[s[j]]==0) count--;\\n            }\\n            if(count > 0) j++;\\n            else if(count == 0){\\n                while(count==0){\\n                    if(umap.find(s[i])!=umap.end()){\\n                        if(j-i+1 < length){\\n                            length = j-i+1;\\n                            res = s.substr(i, j-i+1);\\n                        }\\n                        umap[s[i]]++;\\n                        if(umap[s[i]] > 0) count++;\\n                    }\\n                    i++;\\n                }\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nstring minWindow(string s, string t) {\\n        string res = \"\";\\n        if(s.size() < t.size()) return res;\\n        unordered_map<char, int> umap;\\n        for(auto it: t) umap[it]++;\\n        int i=0, j=0;\\n        int length = INT_MAX, count = umap.size();\\n        while(j<s.size()){\\n            if(umap.find(s[j])!=umap.end()){\\n                umap[s[j]]--;\\n                if(umap[s[j]]==0) count--;\\n            }\\n            if(count > 0) j++;\\n            else if(count == 0){\\n                while(count==0){\\n                    if(umap.find(s[i])!=umap.end()){\\n                        if(j-i+1 < length){\\n                            length = j-i+1;\\n                            res = s.substr(i, j-i+1);\\n                        }\\n                        umap[s[i]]++;\\n                        if(umap[s[i]] > 0) count++;\\n                    }\\n                    i++;\\n                }\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 26926,
                "title": "share-my-neat-and-easy-understand-python-solution-in-o-n",
                "content": "    class Solution(object):\\n        '''\\n        b -- begin index of window; e -- end index of window.\\n        example: S=\"acbbaca\", T=\"aba\"\\n        \\n        0 1 2 3 4 5 6\\n        a c b b a c a\\n        \\n        initially, b=e=0\\n        a:2\\n        b:1\\n        pc=2 (positive count. pc>0 indicates that there are element in T yet to find, that is, current window is not legit.)\\n        \\n        expanding:\\n        b=0,e=0  b=0,e=2  b=0,e=3                 b=0,e=4  b=0,e=6\\n        a:1      a:1      a:1                     a:0      a:-1     \\n        b:1      b:0      b:-1(more b than need)  b:-1     b:-1\\n        pc=2     pc=1     pc=1                    pc=0     pc=0\\n                                                  [0:4]    [0:6]\\n        \\n        shrinking:\\n        b=2,e=6  b=3,e=6  \\n        a:0      a:0\\n        b:-1     b:0\\n        pc=0     pc=0\\n        [2:6]    [3:6]\\n        \\n        then expanding... and so on.\\n        '''\\n        def minWindow(self, s, t):\\n            \"\"\"\\n            :type s: str\\n            :type t: str\\n            :rtype: str\\n            \"\"\"\\n            m = {}\\n            pc = 0  # positive count\\n            for c in t:\\n                if not c in m:\\n                    m[c] = 1\\n                    pc += 1\\n                else:\\n                    m[c] += 1\\n            \\n            b = e = 0\\n            w = [-1, -1]  # ret str = [w[0], w[1]), left inclusive, right not.\\n            while True:\\n                if e<len(s) and b<=e and pc>0:  # expand\\n                    if s[e] in m:  # what if including char @ index e?\\n                        m[s[e]] -= 1\\n                        if m[s[e]]==0:  # previously m[s[e]]==1, of course pc-=1\\n                            pc -= 1\\n                    e += 1\\n                elif b<=e and pc==0:  # shrink\\n                    if w[0]==-1 or e-b<w[1]-w[0]:\\n                        w[0], w[1] = b, e\\n                    if s[b] in m:  # what if excluding char @ index b?\\n                        m[s[b]] += 1\\n                        if m[s[b]] == 1:  # previously m[s[b]]==0, of course pc+=1\\n                            pc += 1\\n                    b += 1\\n                else:\\n                    break\\n            \\n            if w[0]==-1:\\n                return \"\"\\n            else:\\n                return s[w[0]:w[1]]",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution(object):\\n        '''\\n        b -- begin index of window; e -- end index of window.\\n        example: S=\"acbbaca\", T=\"aba\"\\n        \\n        0 1 2 3 4 5 6\\n        a c b b a c a\\n        \\n        initially, b=e=0\\n        a:2\\n        b:1\\n        pc=2 (positive count. pc>0 indicates that there are element in T yet to find, that is, current window is not legit.)\\n        \\n        expanding:\\n        b=0,e=0  b=0,e=2  b=0,e=3                 b=0,e=4  b=0,e=6\\n        a:1      a:1      a:1                     a:0      a:-1     \\n        b:1      b:0      b:-1(more b than need)  b:-1     b:-1\\n        pc=2     pc=1     pc=1                    pc=0     pc=0\\n                                                  [0:4]    [0:6]\\n        \\n        shrinking:\\n        b=2,e=6  b=3,e=6  \\n        a:0      a:0\\n        b:-1     b:0\\n        pc=0     pc=0\\n        [2:6]    [3:6]\\n        \\n        then expanding... and so on.\\n        '''\\n        def minWindow(self, s, t):\\n            \"\"\"\\n            :type s: str\\n            :type t: str\\n            :rtype: str\\n            \"\"\"\\n            m = {}",
                "codeTag": "Java"
            },
            {
                "id": 3751472,
                "title": "super-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhttps://www.youtube.com/watch?v=_t8kq_RpiPU\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        unordered_map<char,int> hast_s;\\n        unordered_map<char,int> hast_t;\\n        if(s.length()<t.length()) return \"\";\\n\\n        for(int i=0;i<t.length();i++){\\n            hast_t[t[i]]++;\\n        }\\n        \\n         int count=0, start=0,start_ind=-1,min_length=INT_MAX;\\n        for(int i=0;i<s.length();i++){\\n            hast_s[s[i]]++;\\n            if(hast_s[s[i]] <= hast_t[s[i]])count++;\\n\\n            if(count==t.length()){\\n                while(hast_s[s[start]]>hast_t[s[start]]){\\n                    hast_s[s[start]]--;\\n                    start++;  \\n                }\\n                if(min_length>i-start+1){\\n                   min_length= i-start+1;\\n                   start_ind=start;\\n                }\\n            }\\n        }\\n        if(start_ind == -1)return \"\";\\n        else return s.substr(start_ind , min_length);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        unordered_map<char,int> hast_s;\\n        unordered_map<char,int> hast_t;\\n        if(s.length()<t.length()) return \"\";\\n\\n        for(int i=0;i<t.length();i++){\\n            hast_t[t[i]]++;\\n        }\\n        \\n         int count=0, start=0,start_ind=-1,min_length=INT_MAX;\\n        for(int i=0;i<s.length();i++){\\n            hast_s[s[i]]++;\\n            if(hast_s[s[i]] <= hast_t[s[i]])count++;\\n\\n            if(count==t.length()){\\n                while(hast_s[s[start]]>hast_t[s[start]]){\\n                    hast_s[s[start]]--;\\n                    start++;  \\n                }\\n                if(min_length>i-start+1){\\n                   min_length= i-start+1;\\n                   start_ind=start;\\n                }\\n            }\\n        }\\n        if(start_ind == -1)return \"\";\\n        else return s.substr(start_ind , min_length);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2732150,
                "title": "python-rust-c-fast-concise-using-two-pointer-sliding-window-with-detailed-comments",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs a two-pointer sliding window approach to search for the minimum substring. Time complexity is linear: **O(n+m)**. Space complexity is linear: **O(n)**. \\n\\n| Language | Runtime | Memory |\\n|---|---|---|\\n| [**Python**](https://leetcode.com/submissions/detail/827879845/) | **105 ms (92.26%)** | **14.6 MB  (83.90%)** |\\n| [**Rust**](https://leetcode.com/submissions/detail/827849495/) | **0 ms (100.00%)** | **2.2 MB (69.33%)** |\\n| [**C++**](https://leetcode.com/submissions/detail/827877701/) | **0 ms (100.00%)** | **7.8 MB  (68.10%)** |\\n\\n<iframe src=\"https://leetcode.com/playground/gqPFE9ur/shared\" frameBorder=\"0\" width=\"800\" height=\"600\"></iframe>\\n",
                "solutionTags": [
                    "Python",
                    "C",
                    "Rust"
                ],
                "code": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs a two-pointer sliding window approach to search for the minimum substring. Time complexity is linear: **O(n+m)**. Space complexity is linear: **O(n)**. \\n\\n| Language | Runtime | Memory |\\n|---|---|---|\\n| [**Python**](https://leetcode.com/submissions/detail/827879845/) | **105 ms (92.26%)** | **14.6 MB  (83.90%)** |\\n| [**Rust**](https://leetcode.com/submissions/detail/827849495/) | **0 ms (100.00%)** | **2.2 MB (69.33%)** |\\n| [**C++**](https://leetcode.com/submissions/detail/827877701/) | **0 ms (100.00%)** | **7.8 MB  (68.10%)** |\\n\\n<iframe src=\"https://leetcode.com/playground/gqPFE9ur/shared\" frameBorder=\"0\" width=\"800\" height=\"600\"></iframe>\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2731110,
                "title": "python-s-simple-and-easy-to-understand-solution-using-sliding-window-99-faster",
                "content": "**\\uD83D\\uDD3C IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n\\n```\\nclass Solution:\\n    def minWindow(self, s: str, t: str) -> str:\\n        lookup = Counter(t)\\n        mx = float(\"inf\")\\n        output = \"\"\\n        S = len(s)\\n        start, end = 0, 0\\n        count = len(lookup)\\n        \\n        while end < S:\\n            \\n            # End Pointer\\n            while end < S and count != 0:\\n                if s[end] in lookup:\\n                    lookup[s[end]] -= 1\\n                    if lookup[s[end]] == 0:\\n                        count -=1\\n                end += 1\\n                \\n            # Start Pointer\\n            while start <= end and count == 0:\\n                \\n                if end-start < mx:\\n                    mx = end - start\\n                    output = s[start:end]\\n                \\n                if s[start] in lookup:\\n                    lookup[s[start]] += 1\\n                    if lookup[s[start]] > 0:\\n                        count += 1\\n                \\n                start += 1\\n        \\n        return output\\n```\\n**If you\\'re interested in learning Python, check out my blog. https://www.python-techs.com/**\\n\\n**Thank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def minWindow(self, s: str, t: str) -> str:\\n        lookup = Counter(t)\\n        mx = float(\"inf\")\\n        output = \"\"\\n        S = len(s)\\n        start, end = 0, 0\\n        count = len(lookup)\\n        \\n        while end < S:\\n            \\n            # End Pointer\\n            while end < S and count != 0:\\n                if s[end] in lookup:\\n                    lookup[s[end]] -= 1\\n                    if lookup[s[end]] == 0:\\n                        count -=1\\n                end += 1\\n                \\n            # Start Pointer\\n            while start <= end and count == 0:\\n                \\n                if end-start < mx:\\n                    mx = end - start\\n                    output = s[start:end]\\n                \\n                if s[start] in lookup:\\n                    lookup[s[start]] += 1\\n                    if lookup[s[start]] > 0:\\n                        count += 1\\n                \\n                start += 1\\n        \\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2731095,
                "title": "brute-force-to-optimal-sliding-window-c",
                "content": "# Brute Force\\n```\\nclass Solution {\\n    bool check(unordered_map<char, int> &mp, unordered_map<char, int> &m) {\\n        if(m.size() < mp.size()) return false;\\n        for(auto i : m) {\\n            if(i.second < mp[i.first]) return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    string minWindow(string s, string t) {\\n        unordered_map<char, int> mp, m;\\n        for(char c : t) mp[c]++;\\n\\n        int i = 0, d = INT_MAX;\\n        string ans;\\n        for(int j=0; j<s.size(); j++) {\\n            if(mp.find(s[j]) != mp.end()) m[s[j]]++;\\n            while(check(mp, m)) {\\n                if(j - i + 1 < d) d = j - i + 1, ans = s.substr(i, j - i + 1);\\n                if(m.find(s[i]) != m.end()) m[s[i]]--;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# Optimal\\n```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        unordered_map<char, int> m;\\n        for(char c : t) m[c]++;\\n\\n        int i = 0, d = INT_MAX, cnt = m.size();\\n        string ans;\\n        for(int j=0; j<s.size(); j++) {\\n            if(m.find(s[j]) != m.end()) {\\n                m[s[j]]--;\\n                if(!m[s[j]]) cnt--;\\n            }\\n            while(!cnt) {\\n                if(j - i + 1 < d) d = j - i + 1, ans = s.substr(i, j - i + 1);\\n                if(m.find(s[i]) != m.end()) {\\n                    m[s[i]]++;\\n                    if(m[s[i]] > 0) cnt++;\\n                }\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    bool check(unordered_map<char, int> &mp, unordered_map<char, int> &m) {\\n        if(m.size() < mp.size()) return false;\\n        for(auto i : m) {\\n            if(i.second < mp[i.first]) return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    string minWindow(string s, string t) {\\n        unordered_map<char, int> mp, m;\\n        for(char c : t) mp[c]++;\\n\\n        int i = 0, d = INT_MAX;\\n        string ans;\\n        for(int j=0; j<s.size(); j++) {\\n            if(mp.find(s[j]) != mp.end()) m[s[j]]++;\\n            while(check(mp, m)) {\\n                if(j - i + 1 < d) d = j - i + 1, ans = s.substr(i, j - i + 1);\\n                if(m.find(s[i]) != m.end()) m[s[i]]--;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        unordered_map<char, int> m;\\n        for(char c : t) m[c]++;\\n\\n        int i = 0, d = INT_MAX, cnt = m.size();\\n        string ans;\\n        for(int j=0; j<s.size(); j++) {\\n            if(m.find(s[j]) != m.end()) {\\n                m[s[j]]--;\\n                if(!m[s[j]]) cnt--;\\n            }\\n            while(!cnt) {\\n                if(j - i + 1 < d) d = j - i + 1, ans = s.substr(i, j - i + 1);\\n                if(m.find(s[i]) != m.end()) {\\n                    m[s[i]]++;\\n                    if(m[s[i]] > 0) cnt++;\\n                }\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2730996,
                "title": "c-easy-daily-leetcoding-challenge-22nd-october-2022",
                "content": "# Easy to Understand\\n**If understand the sol^n then Please Upvote**\\n```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        if (s.size() < t.size() or s.empty()) {\\n            return \"\";\\n        }\\n        \\n        int i = 0, j = 0;\\n        int start = -1, len = INT_MAX;\\n        std::vector<int> m(128, 0);\\n        \\n        // Push elements of t into hash table.\\n        for (auto c : t) {\\n            m[c]++;\\n        }\\n        \\n        while (j < s.size()) {\\n            if (isFound(m)) {\\n                // Current string contains all characters of t,\\n                // then we start to shrink it from left.\\n                if (j - i < len) {\\n                    start = i;\\n                    len = j - i;\\n                }\\n                m[s[i++]]++;\\n                continue;\\n            }\\n            // Current string doesn\\'t contain all characters of t,\\n            // so we need to extend it and do checking in the next iteration.\\n            m[s[j++]]--;\\n        }\\n        \\n        // Try to shrink the last found string.\\n        while (isFound(m)) {\\n            if (j - i < len) {\\n                start = i;\\n                len = j - i;\\n            }\\n            m[s[i++]]++;\\n        }\\n        \\n        if (start != -1) {\\n            return s.substr(start, len);\\n        }\\n        return \"\";\\n    }\\n\\nprivate:\\n    // If all values of hash table are <= 0,\\n    // it means all characters of t are included in current string\\n    bool isFound(const std::vector<int>& m) {\\n        return std::all_of(m.begin(), m.end(), [](int i) { return i <= 0; });\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        if (s.size() < t.size() or s.empty()) {\\n            return \"\";\\n        }\\n        \\n        int i = 0, j = 0;\\n        int start = -1, len = INT_MAX;\\n        std::vector<int> m(128, 0);\\n        \\n        // Push elements of t into hash table.\\n        for (auto c : t) {\\n            m[c]++;\\n        }\\n        \\n        while (j < s.size()) {\\n            if (isFound(m)) {\\n                // Current string contains all characters of t,\\n                // then we start to shrink it from left.\\n                if (j - i < len) {\\n                    start = i;\\n                    len = j - i;\\n                }\\n                m[s[i++]]++;\\n                continue;\\n            }\\n            // Current string doesn\\'t contain all characters of t,\\n            // so we need to extend it and do checking in the next iteration.\\n            m[s[j++]]--;\\n        }\\n        \\n        // Try to shrink the last found string.\\n        while (isFound(m)) {\\n            if (j - i < len) {\\n                start = i;\\n                len = j - i;\\n            }\\n            m[s[i++]]++;\\n        }\\n        \\n        if (start != -1) {\\n            return s.substr(start, len);\\n        }\\n        return \"\";\\n    }\\n\\nprivate:\\n    // If all values of hash table are <= 0,\\n    // it means all characters of t are included in current string\\n    bool isFound(const std::vector<int>& m) {\\n        return std::all_of(m.begin(), m.end(), [](int i) { return i <= 0; });\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2331141,
                "title": "java-slidingwindow-hashmap-twopointer-solution",
                "content": "***plz... upvote! if you find my solution helpful.***\\n\\nStatus: **Accepted***\\nRuntime: 4 ms\\nMemory Usage: 43.9 MB\\nAll test cases passed.\\n\\n[<iframe src=\"https://leetcode.com/playground/jpJPCeKg/shared\" frameBorder=\"0\" width=\"800\" height=\"600\"></iframe>](http://)",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "***plz... upvote! if you find my solution helpful.***\\n\\nStatus: **Accepted***\\nRuntime: 4 ms\\nMemory Usage: 43.9 MB\\nAll test cases passed.\\n\\n[<iframe src=\"https://leetcode.com/playground/jpJPCeKg/shared\" frameBorder=\"0\" width=\"800\" height=\"600\"></iframe>](http://)",
                "codeTag": "Unknown"
            },
            {
                "id": 2146591,
                "title": "java-2-pointer-sliding-window-simple-explanation",
                "content": "# \\uD83D\\uDCCC 2 pointer Sliding window with 2 Hashmaps \\uD83D\\uDC49\\uD83C\\uDFFB \\'Acquired\\' and \\'Required\\' \\n\\n   ## \\u2705 At any point of time we will find : Minimum window substring starting from ith index (i.e. first pointer )\\n   \\n \\u270D\\uD83C\\uDFFB **Notations** : \\n1.   acquired -> Hashmap containing details of current window elements\\n2.   required -> HashMap containing details of required no. of elements\\n3.   i -> left / back   pointer\\n4.   j -> right / front  pointer\\n   \\n   \\uD83C\\uDFAF **Logic** :\\n   \\n   step 1 :  Keep moving the front pointer (j) until your window do not contains all the required elements\\n   step 2 : Note the current window size and update the ans ( if required )\\n   step 3 : Once your window contain all the required elements, keep moving the back pointer (i) till your window contains all the                       req. elements and keep on updating the ans and \\'acquired\\' hashmap accordingly.\\n   step 4 : repeat step 1\\n \\n   \\n   \\n   \\n```\\nclass Solution {\\n    public String minWindow(String s, String t) {\\n        int l = s.length();\\n        int m = t.length();\\n        \\n        HashMap<Character,Integer> required = new HashMap<>();\\n        for(char c : t.toCharArray())\\n        {\\n            int ov = required.getOrDefault(c, 0);\\n            required.put(c, ov+1);\\n        }\\n        \\n        HashMap<Character,Integer> acquired = new HashMap<>();\\n        int min = Integer.MAX_VALUE;\\n        String ans=\"\";\\n        int i = 0;\\n        int j=0;\\n        int found = 0;\\n        while(i<l)\\n        {\\n            while(j<l && found!=m)\\n            {\\n                char cc = s.charAt(j);\\n                if(required.containsKey(cc))  // one useful character we have found\\n                {\\n                    int ov = acquired.getOrDefault(cc, 0);\\n                    acquired.put(cc, ov+1);\\n                    if(acquired.get(cc) > required.get(cc)){}  // character was found more than its requirement\\n                    else found += 1;\\n                } \\n                j++;\\n            }\\n            \\n            int window_size = j-i;\\n            if(found==m && window_size<min)\\n            {\\n                min = window_size;\\n                ans = s.substring(i,j);\\n            }\\n            \\n            if(required.containsKey(s.charAt(i))) // useful character we might loose\\n            {\\n                int ov = acquired.get(s.charAt(i));\\n                acquired.put(s.charAt(i), ov-1);\\n                if(acquired.get(s.charAt(i)) < required.get(s.charAt(i))) found -= 1;  // we lost one useful character\\n            }\\n            \\n            i++;\\n            \\n        }\\n        \\n      return ans;\\n    }\\n}\\n```\\n\\n\\uD83D\\uDCCC Please upvote if you lked the approach \\uD83D\\uDE0A\\uD83D\\uDE42",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public String minWindow(String s, String t) {\\n        int l = s.length();\\n        int m = t.length();\\n        \\n        HashMap<Character,Integer> required = new HashMap<>();\\n        for(char c : t.toCharArray())\\n        {\\n            int ov = required.getOrDefault(c, 0);\\n            required.put(c, ov+1);\\n        }\\n        \\n        HashMap<Character,Integer> acquired = new HashMap<>();\\n        int min = Integer.MAX_VALUE;\\n        String ans=\"\";\\n        int i = 0;\\n        int j=0;\\n        int found = 0;\\n        while(i<l)\\n        {\\n            while(j<l && found!=m)\\n            {\\n                char cc = s.charAt(j);\\n                if(required.containsKey(cc))  // one useful character we have found\\n                {\\n                    int ov = acquired.getOrDefault(cc, 0);\\n                    acquired.put(cc, ov+1);\\n                    if(acquired.get(cc) > required.get(cc)){}  // character was found more than its requirement\\n                    else found += 1;\\n                } \\n                j++;\\n            }\\n            \\n            int window_size = j-i;\\n            if(found==m && window_size<min)\\n            {\\n                min = window_size;\\n                ans = s.substring(i,j);\\n            }\\n            \\n            if(required.containsKey(s.charAt(i))) // useful character we might loose\\n            {\\n                int ov = acquired.get(s.charAt(i));\\n                acquired.put(s.charAt(i), ov-1);\\n                if(acquired.get(s.charAt(i)) < required.get(s.charAt(i))) found -= 1;  // we lost one useful character\\n            }\\n            \\n            i++;\\n            \\n        }\\n        \\n      return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1850485,
                "title": "sliding-window-c-solution",
                "content": "Using a sliding window to increase the right boundary to include more elements. Once the sliding window includes all elements in the target array, try to increase the left boundary to decrease the size of the window until the window doesn\\'t include all elements in the target array. Repeat the previous steps till the right boundary of the window reaches the end of the original array.\\n\\nThe mistake I had in my submission:\\n1. when updating the minimum length of the window, I used right - left + 1, but actually I increased right before when updating the right boundary of the window.\\n2. when updating the left boundary, I used valid ==  t.size(). I forgot the target array could have repeated elements. I should use need.size(), which is the size of the map. All keys are unique.\\n\\n```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        unordered_map<char, int> need, window;\\n        \\n        for(char c : t)\\n            need[c]++;\\n        \\n        int left = 0, right = 0, valid = 0;\\n        int start = 0, len = INT_MAX;\\n        \\n        while(right < s.size())\\n        {\\n            char c = s[right];\\n            right++;\\n            \\n            if(need.count(c))\\n            {\\n                window[c]++;\\n                if(window[c] == need[c])\\n                    valid++;\\n            }\\n            \\n            while(valid == need.size())\\n            {\\n                if(right - left < len)\\n                {\\n                    start = left;\\n                    len = right - left;\\n                }\\n                \\n                char c = s[left];\\n                \\n                if(need.count(c))\\n                {\\n                    if(window[c] == need[c])\\n                        valid--;\\n                    window[c]--;\\n                }\\n                left++;\\n            }\\n        }\\n        \\n        return len == INT_MAX ? \"\" : s.substr(start, len);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        unordered_map<char, int> need, window;\\n        \\n        for(char c : t)\\n            need[c]++;\\n        \\n        int left = 0, right = 0, valid = 0;\\n        int start = 0, len = INT_MAX;\\n        \\n        while(right < s.size())\\n        {\\n            char c = s[right];\\n            right++;\\n            \\n            if(need.count(c))\\n            {\\n                window[c]++;\\n                if(window[c] == need[c])\\n                    valid++;\\n            }\\n            \\n            while(valid == need.size())\\n            {\\n                if(right - left < len)\\n                {\\n                    start = left;\\n                    len = right - left;\\n                }\\n                \\n                char c = s[left];\\n                \\n                if(need.count(c))\\n                {\\n                    if(window[c] == need[c])\\n                        valid--;\\n                    window[c]--;\\n                }\\n                left++;\\n            }\\n        }\\n        \\n        return len == INT_MAX ? \"\" : s.substr(start, len);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1776992,
                "title": "js-optimized-solution-with-explanations-o-t-s-time-o-t-s-space",
                "content": "# Note\\n- Should be pretty straight forward if you did these problems before: [567-permutation-in-string](https://leetcode.com/problems/permutation-in-string/), [438. Find All Anagrams in a String](https://leetcode.com/problems/find-all-anagrams-in-a-string/)\\n- Do those first.\\n- Here is the idea:\\n1. create a hashmap that counts character frequency of t\\n2. use two pointers to define your window size\\n3. whenever you encounter a character in s that is in your hashmap, decrease the count. When the count is 0, it means that you used up the required amount of this character. Therefore you increase your \"match\" count.\\n4. When match is equal to numbers of keys in your hashmap, it means that you have a solution. Notice that \"uniqueChars\" is the number of keys in the hashmap.\\n5. when you have a solution, try to decrease your window size by increasing the left pointer until the window is no longer a solution.\\n6. record the solution you had before\\n\\n# Big O Analysis\\n- Time: O(t) time to build the hashmap. O(s+s) for  window sliding since in the worst case the right and left pointer loop through the entire string s once. Therefore overall time complexity is O(t + s)\\n- Space: O(t) for the hashmap in the worst case. O(s) for the answer in the worst case if s is a permutation of t. Therefore overall space complexity is O(t+s)\\n\\n```javascript\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @return {string}\\n */\\nvar minWindow = function(s, t) {\\n  // count t\\'s frequency of its characters\\n  let map = {}, uniqueChars = 0;\\n  for (let char of t) {\\n    if (char in map) {\\n      map[char] += 1;\\n    } else {\\n      map[char] = 1;\\n      uniqueChars += 1;\\n    }\\n  }\\n  \\n  let ans = \\'\\';\\n  let left = 0, match = 0;\\n  for (let right = 0; right < s.length; right++) {\\n    let rightChar = s[right];\\n    if (rightChar in map) {\\n      map[rightChar] -= 1;\\n      if (map[rightChar] === 0) match += 1;\\n    }\\n    \\n    if (match === uniqueChars) { // there is a solution\\n      // try to shrink the window from the left\\n      while (match === uniqueChars) {\\n        let leftChar = s[left++];\\n        if (map[leftChar] === 0) match -= 1;\\n        map[leftChar] += 1;\\n      }\\n      \\n      // record the solution, notice that you need to use left-1 instead of left when slicing\\n      let solution = s.slice(left-1, right+1);\\n      ans = (ans === \\'\\')? solution: (ans.length > solution.length)? solution: ans;\\n    }\\n  }\\n  return ans;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```javascript\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @return {string}\\n */\\nvar minWindow = function(s, t) {\\n  // count t\\'s frequency of its characters\\n  let map = {}, uniqueChars = 0;\\n  for (let char of t) {\\n    if (char in map) {\\n      map[char] += 1;\\n    } else {\\n      map[char] = 1;\\n      uniqueChars += 1;\\n    }\\n  }\\n  \\n  let ans = \\'\\';\\n  let left = 0, match = 0;\\n  for (let right = 0; right < s.length; right++) {\\n    let rightChar = s[right];\\n    if (rightChar in map) {\\n      map[rightChar] -= 1;\\n      if (map[rightChar] === 0) match += 1;\\n    }\\n    \\n    if (match === uniqueChars) { // there is a solution\\n      // try to shrink the window from the left\\n      while (match === uniqueChars) {\\n        let leftChar = s[left++];\\n        if (map[leftChar] === 0) match -= 1;\\n        map[leftChar] += 1;\\n      }\\n      \\n      // record the solution, notice that you need to use left-1 instead of left when slicing\\n      let solution = s.slice(left-1, right+1);\\n      ans = (ans === \\'\\')? solution: (ans.length > solution.length)? solution: ans;\\n    }\\n  }\\n  return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1496743,
                "title": "aditya-verma-approach-easy-hashmap-with-sliding-window-minimum-window-substring",
                "content": "```\\nif (t.length() > s.length()) {\\n  return \"\";\\n}\\n\\nif (s == t)\\n  return s;\\nunordered_map < char, int > m;\\n\\nfor (auto it: t) {\\n  m[it]++;\\n}\\n\\nint cnt = m.size();\\nint i = 0;\\nint j = 0;\\nint ans = INT_MAX;\\nint start = -1;\\nint end = -1;\\nwhile (j < s.length()) {\\n  if (m.find(s[j]) != m.end()) {\\n    m[s[j]]--;\\n    if (m[s[j]] == 0)\\n      cnt--;\\n  }\\n\\n  if (cnt == 0) {\\n    if (j - i + 1 < ans) {\\n      start = i;\\n      end = j;\\n      ans = j - i + 1;\\n    }\\n\\n    while (cnt == 0) {\\n      if (m.find(s[i]) != m.end()) {\\n\\n        m[s[i]]++;\\n        if (m[s[i]] > 0)\\n          cnt++;\\n\\n      }\\n      i++;\\n      if (j - i + 1 < ans && cnt == 0) {\\n        start = i;\\n        end = j;\\n        ans = j - i + 1;\\n      }\\n    }\\n  }\\n\\n  j++;\\n}\\n\\nstring sans = \"\";\\nif (start == -1 && end == -1) {\\n\\n  return sans;\\n}\\n\\nfor (int i = start; i <= end; i++) {\\n\\n  sans += s[i];\\n}\\n\\nreturn sans;\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nif (t.length() > s.length()) {\\n  return \"\";\\n}\\n\\nif (s == t)\\n  return s;\\nunordered_map < char, int > m;\\n\\nfor (auto it: t) {\\n  m[it]++;\\n}\\n\\nint cnt = m.size();\\nint i = 0;\\nint j = 0;\\nint ans = INT_MAX;\\nint start = -1;\\nint end = -1;\\nwhile (j < s.length()) {\\n  if (m.find(s[j]) != m.end()) {\\n    m[s[j]]--;\\n    if (m[s[j]] == 0)\\n      cnt--;\\n  }\\n\\n  if (cnt == 0) {\\n    if (j - i + 1 < ans) {\\n      start = i;\\n      end = j;\\n      ans = j - i + 1;\\n    }\\n\\n    while (cnt == 0) {\\n      if (m.find(s[i]) != m.end()) {\\n\\n        m[s[i]]++;\\n        if (m[s[i]] > 0)\\n          cnt++;\\n\\n      }\\n      i++;\\n      if (j - i + 1 < ans && cnt == 0) {\\n        start = i;\\n        end = j;\\n        ans = j - i + 1;\\n      }\\n    }\\n  }\\n\\n  j++;\\n}\\n\\nstring sans = \"\";\\nif (start == -1 && end == -1) {\\n\\n  return sans;\\n}\\n\\nfor (int i = start; i <= end; i++) {\\n\\n  sans += s[i];\\n}\\n\\nreturn sans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1407321,
                "title": "python-3-from-brute-force-to-sliding-window-3-solutions-o-n",
                "content": "**Solution 1: Brute force**\\n```python\\nclass Solution:\\n    def minWindow(self, s: str, t: str) -> str:\\n        def isCover(cnt1, cnt2): # return True if all characters in cnt2 is covered by cnt1\\n            for k, v in cnt2.items():\\n                if cnt1[k] < v:\\n                    return False\\n            return True\\n\\n        n = len(s)\\n        cntT = Counter(t)\\n        ansStartIdx = 0\\n        ansSize = math.inf\\n        for i in range(n):\\n            cnt = Counter()\\n            for j in range(i, n):\\n                cnt[s[j]] += 1\\n                if isCover(cnt, cntT):\\n                    if ansSize > j - i + 1:\\n                        ansSize = j - i + 1\\n                        ansStartIdx = i\\n                    break\\n\\n        if ansSize == math.inf:\\n            return \"\"\\n        return s[ansStartIdx:ansStartIdx+ansSize]\\n```\\n**Complexity**\\n- Time: `O(N^2 + M)`, where `N <= 10^5` is length of string `s`, `M <= 10^5` is length of string `t`.\\n- Space: `O(1)`\\n\\n----\\n**Solution 2: Sliding Window**\\n```python\\nclass Solution:\\n    def minWindow(self, s: str, t: str) -> str:\\n        def isCover(cnt1, cnt2): # return True if all characters in cnt2 is covered by cnt1\\n            for k, v in cnt2.items():\\n                if cnt1[k] < v:\\n                    return False\\n            return True\\n\\n        cntT = Counter(t)\\n        cnt = Counter()\\n        l = 0\\n        ansSize = math.inf\\n        ansStartIdx = 0\\n        for r, c in enumerate(s):\\n            cnt[c] += 1\\n            while isCover(cnt, cntT):\\n                if ansSize > r - l + 1:\\n                    ansSize = r - l + 1\\n                    ansStartIdx = l\\n                cnt[s[l]] -= 1\\n                l += 1\\n        if ansSize == math.inf:\\n            return \"\"\\n        return s[ansStartIdx : ansStartIdx + ansSize]\\n```\\n\\n**Complexity**\\n- Time: `O(26 * N + M)`, where `N <= 10^5` is length of string `s`, `M <= 10^5` is length of string `t`.\\n- Space: `O(1)`\\n\\n----\\n**Solution 3: Sliding Window (Optimized)**\\n```python\\nclass Solution:\\n    def minWindow(self, s: str, t: str) -> str:\\n        cnt = Counter(t)\\n        consumedTarget = len(cnt)\\n        consumed = 0\\n\\n        l = 0\\n        ansSize = math.inf\\n        ansStartIdx = 0\\n        for r, c in enumerate(s):\\n            cnt[c] -= 1\\n            if cnt[c] == 0:\\n                consumed += 1\\n\\n            while consumed == consumedTarget:  # check if conver all chars of string `t`\\n                if ansSize > r - l + 1:\\n                    ansSize = r - l + 1\\n                    ansStartIdx = l\\n                if cnt[s[l]] == 0:\\n                    consumed -= 1\\n                cnt[s[l]] += 1\\n                l += 1\\n\\n        if ansSize == math.inf:\\n            return \"\"\\n        return s[ansStartIdx : ansStartIdx + ansSize]\\n```\\n\\n**Complexity**\\n- Time: `O(N + M)`, where `N <= 10^5` is length of string `s`, `M <= 10^5` is length of string `t`.\\n- Space: `O(1)`",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```python\\nclass Solution:\\n    def minWindow(self, s: str, t: str) -> str:\\n        def isCover(cnt1, cnt2): # return True if all characters in cnt2 is covered by cnt1\\n            for k, v in cnt2.items():\\n                if cnt1[k] < v:\\n                    return False\\n            return True\\n\\n        n = len(s)\\n        cntT = Counter(t)\\n        ansStartIdx = 0\\n        ansSize = math.inf\\n        for i in range(n):\\n            cnt = Counter()\\n            for j in range(i, n):\\n                cnt[s[j]] += 1\\n                if isCover(cnt, cntT):\\n                    if ansSize > j - i + 1:\\n                        ansSize = j - i + 1\\n                        ansStartIdx = i\\n                    break\\n\\n        if ansSize == math.inf:\\n            return \"\"\\n        return s[ansStartIdx:ansStartIdx+ansSize]\\n```\n```python\\nclass Solution:\\n    def minWindow(self, s: str, t: str) -> str:\\n        def isCover(cnt1, cnt2): # return True if all characters in cnt2 is covered by cnt1\\n            for k, v in cnt2.items():\\n                if cnt1[k] < v:\\n                    return False\\n            return True\\n\\n        cntT = Counter(t)\\n        cnt = Counter()\\n        l = 0\\n        ansSize = math.inf\\n        ansStartIdx = 0\\n        for r, c in enumerate(s):\\n            cnt[c] += 1\\n            while isCover(cnt, cntT):\\n                if ansSize > r - l + 1:\\n                    ansSize = r - l + 1\\n                    ansStartIdx = l\\n                cnt[s[l]] -= 1\\n                l += 1\\n        if ansSize == math.inf:\\n            return \"\"\\n        return s[ansStartIdx : ansStartIdx + ansSize]\\n```\n```python\\nclass Solution:\\n    def minWindow(self, s: str, t: str) -> str:\\n        cnt = Counter(t)\\n        consumedTarget = len(cnt)\\n        consumed = 0\\n\\n        l = 0\\n        ansSize = math.inf\\n        ansStartIdx = 0\\n        for r, c in enumerate(s):\\n            cnt[c] -= 1\\n            if cnt[c] == 0:\\n                consumed += 1\\n\\n            while consumed == consumedTarget:  # check if conver all chars of string `t`\\n                if ansSize > r - l + 1:\\n                    ansSize = r - l + 1\\n                    ansStartIdx = l\\n                if cnt[s[l]] == 0:\\n                    consumed -= 1\\n                cnt[s[l]] += 1\\n                l += 1\\n\\n        if ansSize == math.inf:\\n            return \"\"\\n        return s[ansStartIdx : ansStartIdx + ansSize]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1405567,
                "title": "c-commented-easy-to-understand-sliding-window-map",
                "content": "```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t)\\n    {\\n        unordered_map<char, int> mapt; // For frequency of characters of string t\\n        for(auto ch : t)\\n        {\\n            mapt[ch]++;\\n        }\\n        unordered_map<char, int> maps; // For frequency of characters of string s\\n        int n = s.length();\\n        string ans = \"\";\\n        int k = 0;\\n        int counter = 0;          // To count whether we have got all the characters of string t in string s\\n        int i= -1;\\n        int j = -1;\\n        while(k<n)\\n        {\\n            \\n            // Acquire\\n            while(i < n-1 && counter != t.size())\\n            {\\n                i++;\\n                maps[s[i]]++;\\n                \\n                if(maps[s[i]] <= mapt[s[i]])    // If the acquired character is matched, increased the count\\n                {\\n                    counter++;\\n                }\\n                \\n            }\\n            \\n            //Store ans and Release\\n            while(j < i && counter == t.size())\\n            {\\n                j++;\\n                string pans = s.substr(j, i-j+1);     // Potential answer\\n                \\n                if(ans.size()== 0 || ans.size() > pans.size())\\n                { \\n                    ans = pans;        // If size of potential answer is less than answer, update the answer\\n                }\\n                \\n                if(maps[s[j]] == 1)\\n                {\\n                    maps.erase(s[j]);\\n                }\\n                else maps[s[j]]--;\\n                \\n                if(maps[s[j]] < mapt[s[j]])     // If the released character is matched, decreased the count\\n                {\\n                    counter--;\\n                }   \\n            }\\n            k++;\\n        }\\n        return ans;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t)\\n    {\\n        unordered_map<char, int> mapt; // For frequency of characters of string t\\n        for(auto ch : t)\\n        {\\n            mapt[ch]++;\\n        }\\n        unordered_map<char, int> maps; // For frequency of characters of string s\\n        int n = s.length();\\n        string ans = \"\";\\n        int k = 0;\\n        int counter = 0;          // To count whether we have got all the characters of string t in string s\\n        int i= -1;\\n        int j = -1;\\n        while(k<n)\\n        {\\n            \\n            // Acquire\\n            while(i < n-1 && counter != t.size())\\n            {\\n                i++;\\n                maps[s[i]]++;\\n                \\n                if(maps[s[i]] <= mapt[s[i]])    // If the acquired character is matched, increased the count\\n                {\\n                    counter++;\\n                }\\n                \\n            }\\n            \\n            //Store ans and Release\\n            while(j < i && counter == t.size())\\n            {\\n                j++;\\n                string pans = s.substr(j, i-j+1);     // Potential answer\\n                \\n                if(ans.size()== 0 || ans.size() > pans.size())\\n                { \\n                    ans = pans;        // If size of potential answer is less than answer, update the answer\\n                }\\n                \\n                if(maps[s[j]] == 1)\\n                {\\n                    maps.erase(s[j]);\\n                }\\n                else maps[s[j]]--;\\n                \\n                if(maps[s[j]] < mapt[s[j]])     // If the released character is matched, decreased the count\\n                {\\n                    counter--;\\n                }   \\n            }\\n            k++;\\n        }\\n        return ans;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 811818,
                "title": "template-for-sliding-window-problems",
                "content": "Inspired by the top post, I create my own template for sliding window problems. I feel it is more generic and is good for all the sliding window problems I studied so far.\\n\\n**The template**\\n```\\nwhile(r<n) {\\n\\t//process r\\n\\twhile(r cannot move) {\\n\\t\\t//process l to free r\\n\\t\\tl++;\\n\\t}\\n\\t//process r\\n\\tr++;\\n}\\n```\\n[**3. Longest Substring Without Repeating Characters**](https://leetcode.com/problems/longest-substring-without-repeating-characters/discuss/950438/Sliding-window-template)\\n```\\n\\tpublic int lengthOfLongestSubstring(String s) {\\n        int l=0, r=0, max = 0;\\n        boolean[] window = new boolean[256];\\n        while(r<s.length()) {\\n            char c = s.charAt(r);\\n            while(window[c]) {\\n                max = Math.max(max, r-l);\\n                window[s.charAt(l)]=false;\\n                l++;    \\n            }\\n            window[c] = true;\\n            r++;\\n        }\\n        return Math.max(max,r-l);\\n    }\\n```\\n**76. Minimum Window Substring**\\n```\\n\\tpublic String minWindow(String s, String t) {\\n        int l=0, r=0, tn=t.length(), sn=s.length(), start=0, len=sn+1;\\n        int[] count=new int[256];\\n        for(int i=0;i<tn;i++) \\n            count[t.charAt(i)]++;  \\n        while(r<sn) {\\n            if(count[s.charAt(r)]-->0) tn--;\\n            while(tn==0) { //count[] all neg or 0, r at last element in window\\n                if(count[s.charAt(l)]++==0) {\\n                    tn=1;\\n                    if(r-l+1<len) { //l at 1st element in window\\n                        start=l;\\n                        len=r-l+1;\\n                    }\\n                }\\n                l++;  \\n            }\\n            r++;\\n        }\\n        return len==sn+1?\"\":s.substring(start,start+len);\\n    }\\n```\\n**159. Longest Substring with At Most Two Distinct Characters**\\n```\\n\\tpublic int lengthOfLongestSubstringTwoDistinct(String s) {\\n        int l=0, r=0, types=0, len=0;\\n        int[] count = new int[256];\\n        while(r<s.length()) {\\n            if(count[s.charAt(r)]++==0) {\\n                types++;    \\n            }\\n            while(types==3) {\\n                len = Math.max(len, r-l);\\n                if(count[s.charAt(l)]--==1) {\\n                    types--;\\n                }\\n                l++;\\n            }\\n            r++;\\n        }\\n        return Math.max(len, r-l);\\n    }\\n```\\n **[209. Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/discuss/59141/Evolve-from-brute-force-to-optimal)**\\n```\\n\\tpublic int minSubArrayLen(int s, int[] nums) {\\n        int l=0,r=0,n=nums.length,res=n+1,sum=0;\\n        while(r<n) {\\n            sum+=nums[r];\\n            while(sum>=s) {\\n                res=Math.min(res,r-l+1); //can be here or outside depdending on the context  \\n                sum-=nums[l];\\n                l++;\\n            }\\n            r++;\\n        }\\n        return res==n+1?0:res;\\n    }\\n```\\n**340. Longest Substring with At Most K Distinct Characters**\\n```\\n\\tpublic int lengthOfLongestSubstringKDistinct(String s, int k) {\\n        int l=0, r=0, types=0, len=0;\\n        int[] count = new int[256];\\n        while(r<s.length()) {\\n            if(count[s.charAt(r)]++==0) {\\n                types++;    \\n            }\\n            while(types==k+1) {\\n                len = Math.max(len, r-l);\\n                if(count[s.charAt(l)]--==1) {\\n                    types--;\\n                }\\n                l++;\\n            }\\n            r++;\\n        }\\n        return Math.max(len, r-l);\\n    }\\n```\\n**[904. Fruit Into Baskets](https://leetcode.com/problems/fruit-into-baskets/discuss/1000442/Sliding-window-template)**\\n```\\n\\tpublic int totalFruit(int[] tree) {\\n        int l=0, r=0, n = tree.length, types=0, len=0;\\n        int[] count = new int[n];\\n        while(r<n) {\\n            if(count[tree[r]]++==0) {\\n                types++;    \\n            }\\n            while(types==3) {\\n                len = Math.max(len, r-l);\\n                if(count[tree[l]]--==1) {\\n                    types--;\\n                }\\n                l++;\\n            }\\n            r++;\\n        }\\n        return Math.max(len, r-l);\\n    }\\n```\\n**[1004. Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/discuss/929117/Evolve-from-brute-force-to-optimal)**\\n```\\n\\tpublic int longestOnes(int[] A, int K) {\\n        int l=0,r=0,sum=0,max=-1;\\n        while(r<A.length) {\\n            sum+=A[r];\\n            while(sum+K<r-l+1) {\\n                max=Math.max(max,r-l);\\n                sum-=A[l];\\n                l++;\\n            }\\n            r++;\\n        }\\n        return Math.max(max,r-l);\\n    }\\n```\\n[**1610. Maximum Number of Visible Points**](https://leetcode.com/problems/maximum-number-of-visible-points/discuss/926504/Template-for-sliding-window-problems)\\n```\\n\\tpublic int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        List<Double> arcs=new ArrayList<>();\\n        int ovlp=0;\\n        for(List<Integer> point:points) {\\n            int dx=point.get(0)-location.get(0), dy=point.get(1)-location.get(1);\\n            if(dx==0&&dy==0) ovlp++;\\n            else arcs.add(Math.atan2(dx,dy));\\n        }\\n        Collections.sort(arcs);\\n        int n=arcs.size();\\n        for(int i=0;i<n;i++)\\n            arcs.add(arcs.get(i)+2*Math.PI);\\n        double arc=Math.PI*angle/180;\\n        int l=0, r=0, max=0;\\n        while(r<n*2) {\\n            while(arcs.get(r)-arcs.get(l)>arc) {\\n                max=Math.max(r-l,max);\\n                l++;    \\n            }\\n            r++;\\n        }\\n        return max+ovlp;\\n    }\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nwhile(r<n) {\\n\\t//process r\\n\\twhile(r cannot move) {\\n\\t\\t//process l to free r\\n\\t\\tl++;\\n\\t}\\n\\t//process r\\n\\tr++;\\n}\\n```\n```\\n\\tpublic int lengthOfLongestSubstring(String s) {\\n        int l=0, r=0, max = 0;\\n        boolean[] window = new boolean[256];\\n        while(r<s.length()) {\\n            char c = s.charAt(r);\\n            while(window[c]) {\\n                max = Math.max(max, r-l);\\n                window[s.charAt(l)]=false;\\n                l++;    \\n            }\\n            window[c] = true;\\n            r++;\\n        }\\n        return Math.max(max,r-l);\\n    }\\n```\n```\\n\\tpublic String minWindow(String s, String t) {\\n        int l=0, r=0, tn=t.length(), sn=s.length(), start=0, len=sn+1;\\n        int[] count=new int[256];\\n        for(int i=0;i<tn;i++) \\n            count[t.charAt(i)]++;  \\n        while(r<sn) {\\n            if(count[s.charAt(r)]-->0) tn--;\\n            while(tn==0) { //count[] all neg or 0, r at last element in window\\n                if(count[s.charAt(l)]++==0) {\\n                    tn=1;\\n                    if(r-l+1<len) { //l at 1st element in window\\n                        start=l;\\n                        len=r-l+1;\\n                    }\\n                }\\n                l++;  \\n            }\\n            r++;\\n        }\\n        return len==sn+1?\"\":s.substring(start,start+len);\\n    }\\n```\n```\\n\\tpublic int lengthOfLongestSubstringTwoDistinct(String s) {\\n        int l=0, r=0, types=0, len=0;\\n        int[] count = new int[256];\\n        while(r<s.length()) {\\n            if(count[s.charAt(r)]++==0) {\\n                types++;    \\n            }\\n            while(types==3) {\\n                len = Math.max(len, r-l);\\n                if(count[s.charAt(l)]--==1) {\\n                    types--;\\n                }\\n                l++;\\n            }\\n            r++;\\n        }\\n        return Math.max(len, r-l);\\n    }\\n```\n```\\n\\tpublic int minSubArrayLen(int s, int[] nums) {\\n        int l=0,r=0,n=nums.length,res=n+1,sum=0;\\n        while(r<n) {\\n            sum+=nums[r];\\n            while(sum>=s) {\\n                res=Math.min(res,r-l+1); //can be here or outside depdending on the context  \\n                sum-=nums[l];\\n                l++;\\n            }\\n            r++;\\n        }\\n        return res==n+1?0:res;\\n    }\\n```\n```\\n\\tpublic int lengthOfLongestSubstringKDistinct(String s, int k) {\\n        int l=0, r=0, types=0, len=0;\\n        int[] count = new int[256];\\n        while(r<s.length()) {\\n            if(count[s.charAt(r)]++==0) {\\n                types++;    \\n            }\\n            while(types==k+1) {\\n                len = Math.max(len, r-l);\\n                if(count[s.charAt(l)]--==1) {\\n                    types--;\\n                }\\n                l++;\\n            }\\n            r++;\\n        }\\n        return Math.max(len, r-l);\\n    }\\n```\n```\\n\\tpublic int totalFruit(int[] tree) {\\n        int l=0, r=0, n = tree.length, types=0, len=0;\\n        int[] count = new int[n];\\n        while(r<n) {\\n            if(count[tree[r]]++==0) {\\n                types++;    \\n            }\\n            while(types==3) {\\n                len = Math.max(len, r-l);\\n                if(count[tree[l]]--==1) {\\n                    types--;\\n                }\\n                l++;\\n            }\\n            r++;\\n        }\\n        return Math.max(len, r-l);\\n    }\\n```\n```\\n\\tpublic int longestOnes(int[] A, int K) {\\n        int l=0,r=0,sum=0,max=-1;\\n        while(r<A.length) {\\n            sum+=A[r];\\n            while(sum+K<r-l+1) {\\n                max=Math.max(max,r-l);\\n                sum-=A[l];\\n                l++;\\n            }\\n            r++;\\n        }\\n        return Math.max(max,r-l);\\n    }\\n```\n```\\n\\tpublic int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        List<Double> arcs=new ArrayList<>();\\n        int ovlp=0;\\n        for(List<Integer> point:points) {\\n            int dx=point.get(0)-location.get(0), dy=point.get(1)-location.get(1);\\n            if(dx==0&&dy==0) ovlp++;\\n            else arcs.add(Math.atan2(dx,dy));\\n        }\\n        Collections.sort(arcs);\\n        int n=arcs.size();\\n        for(int i=0;i<n;i++)\\n            arcs.add(arcs.get(i)+2*Math.PI);\\n        double arc=Math.PI*angle/180;\\n        int l=0, r=0, max=0;\\n        while(r<n*2) {\\n            while(arcs.get(r)-arcs.get(l)>arc) {\\n                max=Math.max(r-l,max);\\n                l++;    \\n            }\\n            r++;\\n        }\\n        return max+ovlp;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 26887,
                "title": "c-post-referred-to-top-voted-post",
                "content": "First, thanks the post from @vinceyuan\\n\\nHere I just try explain it carefully so to help some beginners to better understand the inspiring ideas behind the solution.\\n\\nPreprocessing step:\\n\\nstore the condition variable in the unordered_map\\n\\nWhile loop step:\\n\\n       check sub-conditions, update global variable\\n\\n       for the satisfying condition, we can move the start pointer \\n       forward to calculate all the possible solution.\\n\\nI do think this solution is really not easy to us to implement all by our self. \\n\\nThe only way to better grasp this solution is to write it many times by yourself.\\n\\nHere is the C++ implementation:\\n\\n\\n    class Solution {\\n    public:\\n        string minWindow(string s, string t) {\\n            vector<int> v(128, 0);\\n            for(auto c:t) v[c]++;\\n            int start=0, end=0, counter=t.size();\\n            int minStart=0, minLen=INT_MAX;\\n            int len=s.size();\\n            while(end<len){\\n                if(v[s[end]]>0)  counter--;\\n                v[s[end]]--;\\n                end++;\\n                while(counter==0){\\n                    if(end-start<minLen){\\n                        minStart=start;\\n                        minLen=end-start;\\n                    }\\n                    v[s[start]]++;\\n                    if(v[s[start]]>0)  counter++;\\n                    start++;\\n                }\\n            }\\n            if(minLen!=INT_MAX)\\n                return s.substr(minStart, minLen);\\n            return \"\";\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string minWindow(string s, string t) {\\n            vector<int> v(128, 0);\\n            for(auto c:t) v[c]++;\\n            int start=0, end=0, counter=t.size();\\n            int minStart=0, minLen=INT_MAX;\\n            int len=s.size();\\n            while(end<len){\\n                if(v[s[end]]>0)  counter--;\\n                v[s[end]]--;\\n                end++;\\n                while(counter==0){\\n                    if(end-start<minLen){\\n                        minStart=start;\\n                        minLen=end-start;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2730665,
                "title": "java-easy-solution-with-explanation-90-faster-code-hashmap",
                "content": "```\\nclass Solution {\\n    public String minWindow(String s, String t) {\\n        \\n        if (t.length() > s.length() || t.equals(\"\"))\\n            return \"\";\\n        \\n        Map<Character, Integer> tMap = new HashMap<>();\\n        Map<Character, Integer> sMap = new HashMap<>();\\n        \\n        for(char c : t.toCharArray()){\\n            tMap.put(c, tMap.getOrDefault(c, 0) + 1);\\n            sMap.put(c, 0);\\n        }\\n        \\n        int start=0, matched=0;\\n        int minLength = s.length();\\n        int[] result = new int[]{-1,-1};\\n\\t\\t\\n        for (int end=0; end < s.length(); end++){\\n            char curr = s.charAt(end);\\n            \\n            // Check if current char is present in target, then update character count in source map\\n            if(tMap.containsKey(curr)){\\n                sMap.put(curr, sMap.get(curr) + 1);            \\n                if(sMap.get(curr).equals(tMap.get(curr)))\\n                    matched++;\\n            }\\n            \\n            // When a valid window is found, try to reduce it until a valid window is not found\\n            if(matched == tMap.size()){\\n                // Iterate until the window is not valid\\n                while(matched == tMap.size()){\\n                    char first = s.charAt(start++);\\n                    // If current char is a character in target, \\n                    // then reduce its count from the sMap as we\\'ll reduce its count\\n                    if(sMap.containsKey(first)){\\n                        sMap.put(first, sMap.get(first) - 1);\\n                        // If count of first char in window < count in tMap, then reduce the matched count\\n                        if(sMap.get(first) < tMap.get(first))\\n                            matched--;\\n                    }\\n                }\\n                // Update length if current length is smaller than previous\\n                // Note - Check 1 character before start index as the start idx was already incremented in the while loop\\n                if (end - (start - 1) < minLength){\\n                    minLength = end - (start - 1) + 1;\\n                    result[0] = start - 1;\\n                    result[1] = end;\\n                }\\n            }\\n        }\\n        return result[0] != -1 ? s.substring(result[0], result[1] + 1) : \"\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String minWindow(String s, String t) {\\n        \\n        if (t.length() > s.length() || t.equals(\"\"))\\n            return \"\";\\n        \\n        Map<Character, Integer> tMap = new HashMap<>();\\n        Map<Character, Integer> sMap = new HashMap<>();\\n        \\n        for(char c : t.toCharArray()){\\n            tMap.put(c, tMap.getOrDefault(c, 0) + 1);\\n            sMap.put(c, 0);\\n        }\\n        \\n        int start=0, matched=0;\\n        int minLength = s.length();\\n        int[] result = new int[]{-1,-1};\\n\\t\\t\\n        for (int end=0; end < s.length(); end++){\\n            char curr = s.charAt(end);\\n            \\n            // Check if current char is present in target, then update character count in source map\\n            if(tMap.containsKey(curr)){\\n                sMap.put(curr, sMap.get(curr) + 1);            \\n                if(sMap.get(curr).equals(tMap.get(curr)))\\n                    matched++;\\n            }\\n            \\n            // When a valid window is found, try to reduce it until a valid window is not found\\n            if(matched == tMap.size()){\\n                // Iterate until the window is not valid\\n                while(matched == tMap.size()){\\n                    char first = s.charAt(start++);\\n                    // If current char is a character in target, \\n                    // then reduce its count from the sMap as we\\'ll reduce its count\\n                    if(sMap.containsKey(first)){\\n                        sMap.put(first, sMap.get(first) - 1);\\n                        // If count of first char in window < count in tMap, then reduce the matched count\\n                        if(sMap.get(first) < tMap.get(first))\\n                            matched--;\\n                    }\\n                }\\n                // Update length if current length is smaller than previous\\n                // Note - Check 1 character before start index as the start idx was already incremented in the while loop\\n                if (end - (start - 1) < minLength){\\n                    minLength = end - (start - 1) + 1;\\n                    result[0] = start - 1;\\n                    result[1] = end;\\n                }\\n            }\\n        }\\n        return result[0] != -1 ? s.substring(result[0], result[1] + 1) : \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2469153,
                "title": "c-well-commented-code-upvote-plss",
                "content": "```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        int m=s.size();\\n        int n=t.size();\\n        \\n        unordered_map<char,int>mp;\\n        \\n        int ans=INT_MAX;\\n        int start=0;\\n        \\n        for(auto x:t){\\n            mp[x]++;\\n        }\\n        \\n        int cnt=mp.size();\\n        int i=0;\\n        int j=0;\\n        \\n        while(j<m){\\n            //reduce the frequency of elements\\n            mp[s[j]]--;\\n            if(mp[s[j]]==0){\\n                cnt--;\\n            }\\n            //if cnt 0 means size of map is 0 which means potential answer found\\n            if(cnt==0){\\n                while(cnt==0){\\n                    //update the minimum length of string\\n                    if(ans>j-i+1){\\n                        ans=min(j-i+1, ans);\\n                        start=i;\\n                    }\\n                    //now reducing the window size and removing extra elements\\n                    mp[s[i]]++;\\n                    //if mp[s[i]] > 0 that means size of map will also increase so increase the count as well\\n                    if(mp[s[i]]>0){\\n                        cnt++;\\n                    }\\n                    //reduce the window size\\n                    i++;\\n                }\\n            }\\n//the above while loop is for potential answer now as soon as we loose our potential answer by doing i++ again start increasing the window by j++ for a new potential answer\\n            j++;\\n        }\\n//if ans not equal to int max means ans found so take the substring from start = i and size of substring will be length of ans;\\n        if (ans != INT_MAX)\\n            return s.substr(start, ans);\\n        else\\n            //otherwise return empty string\\n            return \"\";\\n    }\\n};\\n//please upvote if you find it useful\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        int m=s.size();\\n        int n=t.size();\\n        \\n        unordered_map<char,int>mp;\\n        \\n        int ans=INT_MAX;\\n        int start=0;\\n        \\n        for(auto x:t){\\n            mp[x]++;\\n        }\\n        \\n        int cnt=mp.size();\\n        int i=0;\\n        int j=0;\\n        \\n        while(j<m){\\n            //reduce the frequency of elements\\n            mp[s[j]]--;\\n            if(mp[s[j]]==0){\\n                cnt--;\\n            }\\n            //if cnt 0 means size of map is 0 which means potential answer found\\n            if(cnt==0){\\n                while(cnt==0){\\n                    //update the minimum length of string\\n                    if(ans>j-i+1){\\n                        ans=min(j-i+1, ans);\\n                        start=i;\\n                    }\\n                    //now reducing the window size and removing extra elements\\n                    mp[s[i]]++;\\n                    //if mp[s[i]] > 0 that means size of map will also increase so increase the count as well\\n                    if(mp[s[i]]>0){\\n                        cnt++;\\n                    }\\n                    //reduce the window size\\n                    i++;\\n                }\\n            }\\n//the above while loop is for potential answer now as soon as we loose our potential answer by doing i++ again start increasing the window by j++ for a new potential answer\\n            j++;\\n        }\\n//if ans not equal to int max means ans found so take the substring from start = i and size of substring will be length of ans;\\n        if (ans != INT_MAX)\\n            return s.substr(start, ans);\\n        else\\n            //otherwise return empty string\\n            return \"\";\\n    }\\n};\\n//please upvote if you find it useful\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2175290,
                "title": "sliding-window-c-aditya-verma-solution",
                "content": "Here\\'s the aditya verma\\'s approach:\\n\\n```\\n    string minWindow(string s, string t) {\\n        if(s.length()<t.length())\\n            return \"\";\\n        \\n        unordered_map<char,int>umap;\\n        int i=0,j=0,mn=INT_MAX,count=0;\\n        string res=\"\";\\n        \\n        for(int i=0;i<t.length();i++)\\n            umap[t[i]]++;\\n        \\n        count=umap.size();\\n        //SW\\n        while(j<s.length()){\\n            //cals\\n            if(umap.find(s[j])!=umap.end()){\\n                umap[s[j]]--;\\n                //decrease count if val is 0\\n                if(umap[s[j]]==0)\\n                    count--;\\n            }\\n\\n            //window hit\\n            if(count==0){\\n                if(mn>j-i+1){\\n                    mn=j-i+1;\\n                    res=s.substr(i,mn);\\n                    }\\n                \\n                while(i<=j && count==0){\\n                    if(umap.find(s[i])!=umap.end()){\\n                        umap[s[i]]++;\\n                        \\n                        if(umap[s[i]]==1){\\n                            if(mn>j-i+1){\\n                                mn=j-i+1;\\n                                res=s.substr(i,mn);\\n                            }\\n                            count++;\\n                        }\\n                    }\\n                    i++;\\n                }\\n            }\\n            j++;\\n        }\\n        if(mn==INT_MAX)\\n            return \"\";\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\n    string minWindow(string s, string t) {\\n        if(s.length()<t.length())\\n            return \"\";\\n        \\n        unordered_map<char,int>umap;\\n        int i=0,j=0,mn=INT_MAX,count=0;\\n        string res=\"\";\\n        \\n        for(int i=0;i<t.length();i++)\\n            umap[t[i]]++;\\n        \\n        count=umap.size();\\n        //SW\\n        while(j<s.length()){\\n            //cals\\n            if(umap.find(s[j])!=umap.end()){\\n                umap[s[j]]--;\\n                //decrease count if val is 0\\n                if(umap[s[j]]==0)\\n                    count--;\\n            }\\n\\n            //window hit\\n            if(count==0){\\n                if(mn>j-i+1){\\n                    mn=j-i+1;\\n                    res=s.substr(i,mn);\\n                    }\\n                \\n                while(i<=j && count==0){\\n                    if(umap.find(s[i])!=umap.end()){\\n                        umap[s[i]]++;\\n                        \\n                        if(umap[s[i]]==1){\\n                            if(mn>j-i+1){\\n                                mn=j-i+1;\\n                                res=s.substr(i,mn);\\n                            }\\n                            count++;\\n                        }\\n                    }\\n                    i++;\\n                }\\n            }\\n            j++;\\n        }\\n        if(mn==INT_MAX)\\n            return \"\";\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1619986,
                "title": "c-hashmap-sliding-window-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n\\t\\t// Create a map to staore the count of chars in t\\n        unordered_map <char, int> mp;\\n        for(char c : t)\\n            mp[c]++;\\n        \\n\\t\\t// Approach:\\n\\t\\t// 1. Find the first substring window in s with all the characters in t.\\n\\t\\t// 2. Once the window is found, remaining (rem) chars in t will become 0 then :\\n\\t\\t//    a. check the current window for min-window-size. \\n\\t\\t//    b. start reducing the window size, with incrementing the count of chars in s\\n\\t\\t//    c. if any increment in map-count increases more than 0, means that char was found in t, \\n\\t\\t//       so increase the rem value\\n\\t\\t\\n        int rem = t.length();\\n        int l = 0, r = 0, minStart = 0, minLen = INT_MAX;\\n        while(r < s.length()) {\\n            // find the first window\\n            if(--mp[s[r]] >= 0) rem--;\\n            r++;\\n\\t\\t\\t\\n            // Once the first window is found, squeeze the window\\n            // if duplicate characters are available, find new window\\n            while(rem == 0) {\\n                if(r - l < minLen) {\\n                    minLen = r - l;\\n                    minStart = l;\\n                }\\n                if(++mp[s[l]] > 0) rem++;\\n                l++;\\n            }\\n        }\\n        \\n        return minLen < INT_MAX ? s.substr(minStart, minLen) : \"\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n\\t\\t// Create a map to staore the count of chars in t\\n        unordered_map <char, int> mp;\\n        for(char c : t)\\n            mp[c]++;\\n        \\n\\t\\t// Approach:\\n\\t\\t// 1. Find the first substring window in s with all the characters in t.\\n\\t\\t// 2. Once the window is found, remaining (rem) chars in t will become 0 then :\\n\\t\\t//    a. check the current window for min-window-size. \\n\\t\\t//    b. start reducing the window size, with incrementing the count of chars in s\\n\\t\\t//    c. if any increment in map-count increases more than 0, means that char was found in t, \\n\\t\\t//       so increase the rem value\\n\\t\\t\\n        int rem = t.length();\\n        int l = 0, r = 0, minStart = 0, minLen = INT_MAX;\\n        while(r < s.length()) {\\n            // find the first window\\n            if(--mp[s[r]] >= 0) rem--;\\n            r++;\\n\\t\\t\\t\\n            // Once the first window is found, squeeze the window\\n            // if duplicate characters are available, find new window\\n            while(rem == 0) {\\n                if(r - l < minLen) {\\n                    minLen = r - l;\\n                    minStart = l;\\n                }\\n                if(++mp[s[l]] > 0) rem++;\\n                l++;\\n            }\\n        }\\n        \\n        return minLen < INT_MAX ? s.substr(minStart, minLen) : \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1261378,
                "title": "c-sliding-window-using-arrays",
                "content": "Runtime: 8 ms\\n\\n```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        \\n        //frequency mapping\\n        int FP[256]={0};\\n        int FS[256]={0};\\n        int cnt=0;\\n        int start=0; //left contraction\\n        int start_idx=-1 ;//for best window\\n        int min_so_far=INT_MAX;\\n        \\n        for(int i=0;i<t.length();i++){\\n            FP[t[i]]++;\\n        }\\n        \\n        //sliding window algo\\n        for(int i=0;i<s.length();i++){\\n        //expand window by including current character\\n        \\n            char ch=s[i];\\n            FS[ch]++;\\n            //count how many characters have been matched till now\\n            if(FP[ch]!=0 and FS[ch]<=FP[ch]){\\n                cnt+=1;\\n            }\\n            //if all characters are found in current window then start contracting\\n            \\n            if(cnt==t.length()){\\n                \\n                //start contracting \\n                while(FP[s[start]]==0 or FS[s[start]]>FP[s[start]]){\\n                    FS[s[start]]--;\\n                    start++;\\n                }\\n            \\n                int window_size=i-start+1;\\n                if(window_size<min_so_far){\\n                    min_so_far=window_size;\\n                    start_idx=start;\\n                }\\n            }\\n        \\n        }\\n        if(start_idx==-1){\\n            return \"\";\\n        }\\n        return s.substr(start_idx,min_so_far);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        \\n        //frequency mapping\\n        int FP[256]={0};\\n        int FS[256]={0};\\n        int cnt=0;\\n        int start=0; //left contraction\\n        int start_idx=-1 ;//for best window\\n        int min_so_far=INT_MAX;\\n        \\n        for(int i=0;i<t.length();i++){\\n            FP[t[i]]++;\\n        }\\n        \\n        //sliding window algo\\n        for(int i=0;i<s.length();i++){\\n        //expand window by including current character\\n        \\n            char ch=s[i];\\n            FS[ch]++;\\n            //count how many characters have been matched till now\\n            if(FP[ch]!=0 and FS[ch]<=FP[ch]){\\n                cnt+=1;\\n            }\\n            //if all characters are found in current window then start contracting\\n            \\n            if(cnt==t.length()){\\n                \\n                //start contracting \\n                while(FP[s[start]]==0 or FS[s[start]]>FP[s[start]]){\\n                    FS[s[start]]--;\\n                    start++;\\n                }\\n            \\n                int window_size=i-start+1;\\n                if(window_size<min_so_far){\\n                    min_so_far=window_size;\\n                    start_idx=start;\\n                }\\n            }\\n        \\n        }\\n        if(start_idx==-1){\\n            return \"\";\\n        }\\n        return s.substr(start_idx,min_so_far);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 957620,
                "title": "ruby-solution-with-comments",
                "content": "```\\ndef min_window(s, t)\\n  chars_need = {}\\n    \\n  # Put every char we need into a hash, key being the char, and value being its occurances\\n  t.each_char { |char|  chars_need.key?(char) ? chars_need[char] += 1 : chars_need[char] = 1 }\\n\\n  # Initialize a variable to keep track of how many characters we are missing\\n  missing = t.length\\n\\n  left = 0\\n  right = 0\\n  length_of_smallest_window = ::Float::INFINITY\\n  window = \\'\\'\\n\\n  # While we haven\\'t made it through the entire string\\n  while right < s.length\\n    # If the character we are on is a character we need\\n    if chars_need.key?(s[right])\\n      # Decrement missing, since we found a character we need\\n      missing -= 1 if chars_need[s[right]].positive?\\n      # Decrement the number of occurances in our hash, so it will tell us how many more of that char we will need\\n      chars_need[s[right]] -= 1\\n    end\\n\\n    right += 1\\n\\n    # If we\\'ve found all the characters we need\\n    while missing.zero?\\n    # If we need the character that our left pointer is at (note the next if block is executed before we incremenet left. So if the current window is truly the smallest, we won\\'t lost its value, because the next if block uses left and right as they currently are, before updating them.)\\n      if chars_need.key?(s[left])\\n        # Increment missing and the number of occurances in our hash, since we\\'re going to be moving this pointer forward, thus not accounting for a character we need\\n        missing += 1 if chars_need[s[left]] >= 0\\n        chars_need[s[left]] += 1\\n      end\\n\\n    # If the length of this window is smaller than the smallest window we\\'ve found thus far\\n      if right - left < length_of_smallest_window\\n    # Update the length and the window itself\\n        window = s[left...right]\\n        length_of_smallest_window = window.length\\n      end\\n    # Finally, we move the left pointer.\\n      left += 1\\n    end\\n  end\\n  window\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef min_window(s, t)\\n  chars_need = {}\\n    \\n  # Put every char we need into a hash, key being the char, and value being its occurances\\n  t.each_char { |char|  chars_need.key?(char) ? chars_need[char] += 1 : chars_need[char] = 1 }\\n\\n  # Initialize a variable to keep track of how many characters we are missing\\n  missing = t.length\\n\\n  left = 0\\n  right = 0\\n  length_of_smallest_window = ::Float::INFINITY\\n  window = \\'\\'\\n\\n  # While we haven\\'t made it through the entire string\\n  while right < s.length\\n    # If the character we are on is a character we need\\n    if chars_need.key?(s[right])\\n      # Decrement missing, since we found a character we need\\n      missing -= 1 if chars_need[s[right]].positive?\\n      # Decrement the number of occurances in our hash, so it will tell us how many more of that char we will need\\n      chars_need[s[right]] -= 1\\n    end\\n\\n    right += 1\\n\\n    # If we\\'ve found all the characters we need\\n    while missing.zero?\\n    # If we need the character that our left pointer is at (note the next if block is executed before we incremenet left. So if the current window is truly the smallest, we won\\'t lost its value, because the next if block uses left and right as they currently are, before updating them.)\\n      if chars_need.key?(s[left])\\n        # Increment missing and the number of occurances in our hash, since we\\'re going to be moving this pointer forward, thus not accounting for a character we need\\n        missing += 1 if chars_need[s[left]] >= 0\\n        chars_need[s[left]] += 1\\n      end\\n\\n    # If the length of this window is smaller than the smallest window we\\'ve found thus far\\n      if right - left < length_of_smallest_window\\n    # Update the length and the window itself\\n        window = s[left...right]\\n        length_of_smallest_window = window.length\\n      end\\n    # Finally, we move the left pointer.\\n      left += 1\\n    end\\n  end\\n  window\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 496041,
                "title": "javascript-sliding-window",
                "content": "```\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @return {string}\\n */\\nvar minWindow = function(s, t) {\\n    \\n    // lets create a map to store the frequency of each window char\\n    const map = new Map();\\n    \\n    // set the map count\\n    for (let i = 0; i < t.length; i++)\\n    {\\n    if (map.has(t.charAt(i)))\\n        {\\n        map.set(t.charAt(i), map.get(t.charAt(i)) + 1)\\n        } else \\n            {\\n                map.set(t.charAt(i), 1)\\n            }\\n    }\\n    \\n    let begin = 0, end = 0, counter = map.size, len = Number.MAX_VALUE, ans = \\'\\';\\n    \\n    // since end is starting at 0, we will loop while end is smaller than the length of the string to examime\\n    while(end < s.length)\\n    {\\n        // lets get the end char, which for the first iteration, is really the starting char in the string\\n        const endChar = s.charAt(end);\\n        \\n       // if the map has the char, lets decrement the count by 1. If the count is 0, we can decrement the overall counter \\n       if (map.has(endChar)){\\n           map.set(endChar, map.get(endChar) - 1);\\n           if (map.get(endChar) === 0) counter --;\\n       }\\n        \\n        // slide the end character to the right\\n        end++;\\n\\n        // if all characters have been viewed in the substring as many times as needed, continue\\n        while (counter === 0){\\n            // calculate new length, if smaller than previous, set new length and answer\\n            if (end - begin < len){\\n                len = end - begin;\\n                ans = s.substring(begin, end);\\n            }\\n            \\n            // start char sliding to the right. for first iteration will be str.charAt(0)\\n            let startChar = s.charAt(begin);\\n            \\n            // if this character is part of the map, set its count up one\\n            if (map.has(startChar)){\\n                map.set(startChar, map.get(startChar) + 1)\\n                // if the count of one of the characters is greater than one, set the counter up again.\\n                if (map.get(startChar) > 0) counter++;\\n                \\n            }\\n            \\n            // slide begin to the right\\n            begin++;\\n        }\\n        \\n    }\\n    \\n    return ans;\\n    \\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @return {string}\\n */\\nvar minWindow = function(s, t) {\\n    \\n    // lets create a map to store the frequency of each window char\\n    const map = new Map();\\n    \\n    // set the map count\\n    for (let i = 0; i < t.length; i++)\\n    {\\n    if (map.has(t.charAt(i)))\\n        {\\n        map.set(t.charAt(i), map.get(t.charAt(i)) + 1)\\n        } else \\n            {\\n                map.set(t.charAt(i), 1)\\n            }\\n    }\\n    \\n    let begin = 0, end = 0, counter = map.size, len = Number.MAX_VALUE, ans = \\'\\';\\n    \\n    // since end is starting at 0, we will loop while end is smaller than the length of the string to examime\\n    while(end < s.length)\\n    {\\n        // lets get the end char, which for the first iteration, is really the starting char in the string\\n        const endChar = s.charAt(end);\\n        \\n       // if the map has the char, lets decrement the count by 1. If the count is 0, we can decrement the overall counter \\n       if (map.has(endChar)){\\n           map.set(endChar, map.get(endChar) - 1);\\n           if (map.get(endChar) === 0) counter --;\\n       }\\n        \\n        // slide the end character to the right\\n        end++;\\n\\n        // if all characters have been viewed in the substring as many times as needed, continue\\n        while (counter === 0){\\n            // calculate new length, if smaller than previous, set new length and answer\\n            if (end - begin < len){\\n                len = end - begin;\\n                ans = s.substring(begin, end);\\n            }\\n            \\n            // start char sliding to the right. for first iteration will be str.charAt(0)\\n            let startChar = s.charAt(begin);\\n            \\n            // if this character is part of the map, set its count up one\\n            if (map.has(startChar)){\\n                map.set(startChar, map.get(startChar) + 1)\\n                // if the count of one of the characters is greater than one, set the counter up again.\\n                if (map.get(startChar) > 0) counter++;\\n                \\n            }\\n            \\n            // slide begin to the right\\n            begin++;\\n        }\\n        \\n    }\\n    \\n    return ans;\\n    \\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 26896,
                "title": "the-fast-7ms-o-n-java-solution-use-only-one-array-without-map",
                "content": "    public String minWindow(String s, String t) {\\n        if (t.length() <= 0 || s.length() < t.length()) return \"\";\\n        int start = 0, end = 0, i = 0, j = 0, count = t.length(), min = s.length()+1;\\n        int[] table = new int[256];\\n        \\n        for(int k = 0; k<count; k++){\\n            char c = t.charAt(k);\\n            table[c]++;\\n        }\\n        for(int k = 0; k<256; k++){\\n            if(table[k]<1)\\n                table[k]=Integer.MIN_VALUE;\\n        }\\n        while(end<s.length()){\\n            while(end<s.length()&&count>0){\\n                char c = s.charAt(end++);\\n                if(table[c]!=Integer.MIN_VALUE){\\n                    if(table[c]>0)\\n                        count--;\\n                   table[c]--;\\n                }\\n            }\\n            if(count>0) break;\\n            while(start<s.length()&&count<=0){\\n                char c = s.charAt(start++);\\n                if(table[c]!=Integer.MIN_VALUE){\\n                    if(table[c]>=0)\\n                        count++;\\n                   table[c]++;\\n                }\\n            }\\n            if(end-start+1<min){\\n                min = end-start+1;\\n                i = start-1;\\n                j = end;\\n            }\\n        }\\n        return min==s.length()+1 ? \"\" : s.substring(i,j);\\n    }",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "    public String minWindow(String s, String t) {\\n        if (t.length() <= 0 || s.length() < t.length()) return \"\";\\n        int start = 0, end = 0, i = 0, j = 0, count = t.length(), min = s.length()+1;\\n        int[] table = new int[256];\\n        \\n        for(int k = 0; k<count; k++){\\n            char c = t.charAt(k);\\n            table[c]++;\\n        }\\n        for(int k = 0; k<256; k++){\\n            if(table[k]<1)\\n                table[k]=Integer.MIN_VALUE;\\n        }\\n        while(end<s.length()){\\n            while(end<s.length()&&count>0){\\n                char c = s.charAt(end++);\\n                if(table[c]!=Integer.MIN_VALUE){\\n                    if(table[c]>0)\\n                        count--;\\n                   table[c]--;\\n                }\\n            }\\n            if(count>0) break;\\n            while(start<s.length()&&count<=0){\\n                char c = s.charAt(start++);\\n                if(table[c]!=Integer.MIN_VALUE){\\n                    if(table[c]>=0)\\n                        count++;\\n                   table[c]++;\\n                }\\n            }\\n            if(end-start+1<min){\\n                min = end-start+1;\\n                i = start-1;\\n                j = end;\\n            }\\n        }\\n        return min==s.length()+1 ? \"\" : s.substring(i,j);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 26920,
                "title": "python-20-lines-ac-o-n-solution",
                "content": "Idea is pretty simple, keep two pointers left and right.\\n\\n If s[left:right] has all chars in T, calculate distance and keep answer, then move left pointer.\\n\\n If s[left:right] doesn't have all chars in T, move right pointer.\\n\\n\\n    class Solution:\\n    # @param {string} s\\n    # @param {string} t\\n    # @return {string}\\n    # sliding window problem\\n    # count all chars in string T\\n    # left pointer point to string which has been processed\\n    # right pointer point to string, which has not been processed\\n    # 1.if all window from left to right contains all string T(counter values all less then or equal to 0)\\n    #   calculate min window length, and keep answer\\n    #   then move left pointer\\n    # 2.else there are missing string in current answer\\n    #   move right pointer\\n    #   update counter\\n    # repeat 1, 2 steps until right is equal to len(s), then break it\\n    def minWindow(self, s, t):\\n        left, right = 0, 0\\n        # count T chars\\n        counter = collections.defaultdict(int)\\n        for a in t:\\n            counter[a] += 1\\n        \\n        minwindow = len(s) + 1\\n        answer = None\\n        \\n        while right <= len(s):\\n            # check all chars in T are in the current answer\\n            if all(map(lambda x: True if x<=0 else False, counter.values())):\\n                if minwindow > right-left:\\n                    minwindow = right-left\\n                    answer = s[left:right]\\n                char = s[left]\\n                if char in counter:\\n                    counter[char] += 1\\n                left += 1\\n            else:\\n                if right == len(s):\\n                    break\\n                char = s[right]\\n                if char in counter:\\n                    counter[char] -= 1\\n                right += 1\\n                \\n        return answer if answer else ''",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    # @param {string}",
                "codeTag": "Java"
            },
            {
                "id": 3643413,
                "title": "explained-simple-and-clear-python3-code",
                "content": "\\n# Approach\\n\\nThe solution utilizes a sliding window approach to find the minimum window substring in string s that includes all characters from string t.\\n\\nInitially, the algorithm initializes the necessary data structures to keep track of character counts. It iterates through s to identify the leftmost character in s that is also present in t, which becomes the starting point of the window.\\n\\nAs the algorithm progresses, it moves the right pointer to expand the window, incrementing the count of characters from t encountered along the way. Whenever the current window contains all the required characters from t, it checks if it is the smallest window encountered so far and updates the result accordingly.\\n\\nTo find the next potential window, the algorithm shifts the left pointer while maintaining the validity of the window. It decrements the count of the character at the left pointer and moves the left pointer to the next valid position until the condition of including all characters from t is no longer satisfied.\\n\\nThe process continues until the right pointer reaches the end of s. Finally, the algorithm returns the result, which represents the minimum window substring containing all characters from t. If no such substring is found, an empty string is returned.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minWindow(self, s: str, t: str) -> str:\\n        ans=\"\"\\n        occ = collections.Counter(t)\\n        track = dict()\\n\\n        def test():\\n            for key, val in occ.items():\\n                if val >track[key]:\\n                    return False\\n            return True\\n\\n        #init\\n        for k in occ.keys():\\n            track.update({k : 0})\\n        #first look\\n        left=0\\n        right=0\\n        for i in range(len(s)):\\n            if s[i] in occ.keys():\\n                left=i\\n                break\\n        \\n        for i in range(left,len(s)):\\n            \\n            #move right\\n            right=i\\n            if s[i] in occ.keys():\\n                track.update({s[i]:track[s[i]]+1})\\n                while test():\\n                    w=s[left:right+1]\\n                    if ans==\"\" or len(w)<len(ans):\\n                        ans=w\\n                    #move left\\n                    track.update({s[left]:track[s[left]]-1})\\n\\n                    for j in range(left+1,right+1):\\n                        if s[j] in occ.keys():\\n                            left=j\\n                            break\\n        if (test()):\\n            if ans==\"\" or len(w)<len(ans):\\n                ans=w\\n        return ans\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minWindow(self, s: str, t: str) -> str:\\n        ans=\"\"\\n        occ = collections.Counter(t)\\n        track = dict()\\n\\n        def test():\\n            for key, val in occ.items():\\n                if val >track[key]:\\n                    return False\\n            return True\\n\\n        #init\\n        for k in occ.keys():\\n            track.update({k : 0})\\n        #first look\\n        left=0\\n        right=0\\n        for i in range(len(s)):\\n            if s[i] in occ.keys():\\n                left=i\\n                break\\n        \\n        for i in range(left,len(s)):\\n            \\n            #move right\\n            right=i\\n            if s[i] in occ.keys():\\n                track.update({s[i]:track[s[i]]+1})\\n                while test():\\n                    w=s[left:right+1]\\n                    if ans==\"\" or len(w)<len(ans):\\n                        ans=w\\n                    #move left\\n                    track.update({s[left]:track[s[left]]-1})\\n\\n                    for j in range(left+1,right+1):\\n                        if s[j] in occ.keys():\\n                            left=j\\n                            break\\n        if (test()):\\n            if ans==\"\" or len(w)<len(ans):\\n                ans=w\\n        return ans\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613719,
                "title": "c-simple",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int> &tmp,vector<int> &cnt){\\n        for(int i = 0; i < 256; i++){\\n            if(tmp[i]<cnt[i]){return false;}\\n        }\\n        return true;\\n    }\\n    string minWindow(string& s, string& t) {\\n        if(s.length()<t.length())return \"\";\\n        vector<int> cnt(260,0);\\n        for(auto &i: t){\\n            cnt[i]++;\\n        }\\n        int i = 0, j = 0, n = s.length();\\n        vector<int> tmp(260,0);\\n        string ans = \"\";\\n        int a = -1, b = n;\\n        while(i<n){\\n            tmp[s[i]]++;\\n            while(j<=i && check(tmp,cnt)){\\n                if(i-j+1 <= b){\\n                    b = i-j+1;\\n                    a = j;\\n                }\\n                tmp[s[j]]--;\\n                j++;\\n            }\\n            i++;\\n        }\\n        if(a==-1)return \"\";\\n        return s.substr(a,b);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Two Pointers",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int> &tmp,vector<int> &cnt){\\n        for(int i = 0; i < 256; i++){\\n            if(tmp[i]<cnt[i]){return false;}\\n        }\\n        return true;\\n    }\\n    string minWindow(string& s, string& t) {\\n        if(s.length()<t.length())return \"\";\\n        vector<int> cnt(260,0);\\n        for(auto &i: t){\\n            cnt[i]++;\\n        }\\n        int i = 0, j = 0, n = s.length();\\n        vector<int> tmp(260,0);\\n        string ans = \"\";\\n        int a = -1, b = n;\\n        while(i<n){\\n            tmp[s[i]]++;\\n            while(j<=i && check(tmp,cnt)){\\n                if(i-j+1 <= b){\\n                    b = i-j+1;\\n                    a = j;\\n                }\\n                tmp[s[j]]--;\\n                j++;\\n            }\\n            i++;\\n        }\\n        if(a==-1)return \"\";\\n        return s.substr(a,b);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328125,
                "title": "accepted-c-solution-sliding-window-aditya-verma-sir-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        unordered_map<char, int> mp;\\n        for(auto it:t){\\n            mp[it]++;\\n        }\\n        int cnt=mp.size();\\n\\n        string ans=\"\";\\n        int len=INT_MAX;\\n        int i=0, j=0;\\n        int n=s.size();\\n        while(j<n){\\n            if(mp.count(s[j])>0){\\n                mp[s[j]]--;\\n                if(mp[s[j]]==0){\\n                    cnt--;\\n                }\\n            }\\n            if(cnt==0){\\n                if(len>j-i+1){\\n                    ans = s.substr(i, j-i+1);\\n                    len = ans.size();\\n                }\\n                while(cnt==0){\\n                    if(mp.count(s[i])>0){\\n                        mp[s[i]]++;\\n                        if(mp[s[i]]==1){\\n                            cnt++;\\n                            if(len>j-i+1){\\n                    ans = s.substr(i, j-i+1);\\n                    len = ans.size();\\n                }\\n                        }\\n                    }\\n                    i++;\\n                }\\n                \\n                j++;\\n            }\\n            else{\\n                j++;\\n            }\\n\\n        }\\n       \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        unordered_map<char, int> mp;\\n        for(auto it:t){\\n            mp[it]++;\\n        }\\n        int cnt=mp.size();\\n\\n        string ans=\"\";\\n        int len=INT_MAX;\\n        int i=0, j=0;\\n        int n=s.size();\\n        while(j<n){\\n            if(mp.count(s[j])>0){\\n                mp[s[j]]--;\\n                if(mp[s[j]]==0){\\n                    cnt--;\\n                }\\n            }\\n            if(cnt==0){\\n                if(len>j-i+1){\\n                    ans = s.substr(i, j-i+1);\\n                    len = ans.size();\\n                }\\n                while(cnt==0){\\n                    if(mp.count(s[i])>0){\\n                        mp[s[i]]++;\\n                        if(mp[s[i]]==1){\\n                            cnt++;\\n                            if(len>j-i+1){\\n                    ans = s.substr(i, j-i+1);\\n                    len = ans.size();\\n                }\\n                        }\\n                    }\\n                    i++;\\n                }\\n                \\n                j++;\\n            }\\n            else{\\n                j++;\\n            }\\n\\n        }\\n       \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2733409,
                "title": "aditya-verma-s-approach-c-easy-sliding-window-solution-tc-o-n-sc-o-n",
                "content": "**Upvote If It Helps**\\n\\n*Ask me in comments if you have any doubts \\uD83D\\uDE03*\\n\\n```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        unordered_map<char, int> mp;\\n        for (auto i: t) mp[i]++;\\n        //Creating Variables\\n        int ans = INT_MAX;\\n        int i = 0, j = 0;\\n        int count = mp.size();\\n        int start = 0;\\n        // starting to  solve\\n\\n        while (j < s.length())\\n        {\\n            // CALCULATION STEP (As Aditya\\'s general format)\\n            mp[s[j]]--;\\n            if (mp[s[j]] == 0) count--;\\n            // trying to minimize the window size after getting a candidate for answer\\n            if (count == 0)\\n            {\\n                while (count == 0)\\n                {\\n                    if (ans > j - i + 1)\\n                    {\\n                        ans = j - i + 1; //updating the answer\\n                        start = i;\\n                    }\\n\\n                    mp[s[i]]++;\\n                    if (mp[s[i]] > 0)\\n                        count++;\\n                    i++;\\n                }\\n            }\\n            j++;\\n        }\\n        if(ans!= INT_MAX) \\n            return s.substr(start, ans);\\n        else\\n            return \"\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        unordered_map<char, int> mp;\\n        for (auto i: t) mp[i]++;\\n        //Creating Variables\\n        int ans = INT_MAX;\\n        int i = 0, j = 0;\\n        int count = mp.size();\\n        int start = 0;\\n        // starting to  solve\\n\\n        while (j < s.length())\\n        {\\n            // CALCULATION STEP (As Aditya\\'s general format)\\n            mp[s[j]]--;\\n            if (mp[s[j]] == 0) count--;\\n            // trying to minimize the window size after getting a candidate for answer\\n            if (count == 0)\\n            {\\n                while (count == 0)\\n                {\\n                    if (ans > j - i + 1)\\n                    {\\n                        ans = j - i + 1; //updating the answer\\n                        start = i;\\n                    }\\n\\n                    mp[s[i]]++;\\n                    if (mp[s[i]] > 0)\\n                        count++;\\n                    i++;\\n                }\\n            }\\n            j++;\\n        }\\n        if(ans!= INT_MAX) \\n            return s.substr(start, ans);\\n        else\\n            return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2425961,
                "title": "java-sliding-window-aditya-verma",
                "content": "```\\nclass Solution {\\n    public String minWindow(String s, String t) {\\n        \\n        Map<Character, Integer> map = new HashMap<>();\\n        for(char ch: t.toCharArray())\\n            map.put(ch, map.getOrDefault(ch, 0) + 1);\\n        \\n        int count = map.size(), ansLength = Integer.MAX_VALUE;\\n        String ans = \"\";\\n        \\n        int i = 0, j = 0;\\n        while(j < s.length()) {\\n            \\n            char cur = s.charAt(j);\\n            if(map.containsKey(cur)) {\\n                map.put(cur, map.get(cur) - 1);\\n                if(map.get(cur) == 0) count--;\\n            }\\n            \\n            if(count > 0)\\n                j++;\\n            \\n            else if(count == 0) {  \\n                  \\n                while(count == 0) {\\n                    \\n                    if(j-i+1 < ansLength) {\\n                        ansLength = j-i+1;\\n                        ans = s.substring(i, j+1);\\n                    }\\n                    \\n                    char rm = s.charAt(i);\\n                    if(map.containsKey(rm)) {\\n                        map.put(rm, map.get(rm) + 1);\\n                        if(map.get(rm) == 1) count++;\\n                    }  \\n                    \\n                    i++;    \\n                }  \\n                \\n                j++;  \\n            }\\n        }\\n        \\n        return ans;\\n         \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public String minWindow(String s, String t) {\\n        \\n        Map<Character, Integer> map = new HashMap<>();\\n        for(char ch: t.toCharArray())\\n            map.put(ch, map.getOrDefault(ch, 0) + 1);\\n        \\n        int count = map.size(), ansLength = Integer.MAX_VALUE;\\n        String ans = \"\";\\n        \\n        int i = 0, j = 0;\\n        while(j < s.length()) {\\n            \\n            char cur = s.charAt(j);\\n            if(map.containsKey(cur)) {\\n                map.put(cur, map.get(cur) - 1);\\n                if(map.get(cur) == 0) count--;\\n            }\\n            \\n            if(count > 0)\\n                j++;\\n            \\n            else if(count == 0) {  \\n                  \\n                while(count == 0) {\\n                    \\n                    if(j-i+1 < ansLength) {\\n                        ansLength = j-i+1;\\n                        ans = s.substring(i, j+1);\\n                    }\\n                    \\n                    char rm = s.charAt(i);\\n                    if(map.containsKey(rm)) {\\n                        map.put(rm, map.get(rm) + 1);\\n                        if(map.get(rm) == 1) count++;\\n                    }  \\n                    \\n                    i++;    \\n                }  \\n                \\n                j++;  \\n            }\\n        }\\n        \\n        return ans;\\n         \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1741533,
                "title": "easy-to-follow-python3-solution-sliding-window-and-counter",
                "content": "Using the sliding window technique.\\nWe say a substring s contains the string t, if s contains enough of each character present in t.\\n```\\nclass Solution:\\n    def minWindow(self, s: str, t: str) -> str:\\n\\n        # Checks if all the characters from t are contained in the substring s.\\n        # count_s = Counter(s), and count_t = Counter(t)\\n        def t_is_in_substr(count_s: Counter, count_t: Counter) -> bool:            \\n            for char in count_t:\\n                if count_s[char] < count_t[char]:\\n                    return False\\n            return True\\n        \\n        m = len(s)\\n        n = len(t)\\n        \\n        # Counters for s and t\\n        count_s = Counter(s)\\n        count_t = Counter(t)\\n        \\n        # If t is not within the entire string s, we\\'re out\\n        if not t_is_in_substr(count_s, count_t):\\n            return \\'\\'\\n        \\n        # Initialize left and right pointers, and the Counter for substring window\\n        count_s = Counter(s[0:1])\\n        left = 0\\n        right = 0\\n        \\n        # To save partial answers. Worst case scenario we need the whole string s.\\n        # We already know all characters of t are contained in it if we got this far\\n        curr = (m, s)\\n        \\n        # While we can still move left AND right, we try to find a smaller window.\\n        # If either is not possible to move, we already had the last possible minimal\\n        # window in the previous iteration\\n        while m - left >= n and right < m - 1:\\n            \\n            # Moves right pointer to the right (and updates counter_s) until there\\n            # are enough characters in substring s[left:right + 1] so that t is \\n            # contained in it (i.e. rightmost character is strictly necessary)\\n            while not t_is_in_substr(count_s, count_t) and right < m - 1:\\n                right += 1\\n                count_s[s[right]] += 1\\n            \\n            # Moves left pointer to the right (and updates counter_s) right until\\n            # the point where s[left:right + 1] no longer contains t (i.e. leftmost\\n            # character was strictly necessary)\\n            while t_is_in_substr(count_s, count_t):\\n                count_s[s[left]] -= 1\\n                left += 1\\n            \\n            # Check size of current window. Keep if smallest so far                    \\n            if right - left + 1 < curr[0]:\\n                curr = (right - left + 1, s[left - 1:right + 1])\\n            \\n        return curr[1]\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def minWindow(self, s: str, t: str) -> str:\\n\\n        # Checks if all the characters from t are contained in the substring s.\\n        # count_s = Counter(s), and count_t = Counter(t)\\n        def t_is_in_substr(count_s: Counter, count_t: Counter) -> bool:            \\n            for char in count_t:\\n                if count_s[char] < count_t[char]:\\n                    return False\\n            return True\\n        \\n        m = len(s)\\n        n = len(t)\\n        \\n        # Counters for s and t\\n        count_s = Counter(s)\\n        count_t = Counter(t)\\n        \\n        # If t is not within the entire string s, we\\'re out\\n        if not t_is_in_substr(count_s, count_t):\\n            return \\'\\'\\n        \\n        # Initialize left and right pointers, and the Counter for substring window\\n        count_s = Counter(s[0:1])\\n        left = 0\\n        right = 0\\n        \\n        # To save partial answers. Worst case scenario we need the whole string s.\\n        # We already know all characters of t are contained in it if we got this far\\n        curr = (m, s)\\n        \\n        # While we can still move left AND right, we try to find a smaller window.\\n        # If either is not possible to move, we already had the last possible minimal\\n        # window in the previous iteration\\n        while m - left >= n and right < m - 1:\\n            \\n            # Moves right pointer to the right (and updates counter_s) until there\\n            # are enough characters in substring s[left:right + 1] so that t is \\n            # contained in it (i.e. rightmost character is strictly necessary)\\n            while not t_is_in_substr(count_s, count_t) and right < m - 1:\\n                right += 1\\n                count_s[s[right]] += 1\\n            \\n            # Moves left pointer to the right (and updates counter_s) right until\\n            # the point where s[left:right + 1] no longer contains t (i.e. leftmost\\n            # character was strictly necessary)\\n            while t_is_in_substr(count_s, count_t):\\n                count_s[s[left]] -= 1\\n                left += 1\\n            \\n            # Check size of current window. Keep if smallest so far                    \\n            if right - left + 1 < curr[0]:\\n                curr = (right - left + 1, s[left - 1:right + 1])\\n            \\n        return curr[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1680580,
                "title": "swift-solution-using-a-sliding-window",
                "content": "It\\'s easy to think this needs a sliding window, but hard to maintain a bug-free one.\\n\\nKey points:\\n\\n1. The range is `[Left, right)`.\\n2. When `validCount` equals to `need.count()`, it means `window` equals to `need`.\\n3. The condition when the sliding window begins to shrink is different, which is depended on the details.\\n\\n```swift\\n    func minWindow(_ s: String, _ t: String) -> String {\\n        guard s.count >= t.count else {\\n            return \"\"\\n        }\\n        var left = 0 \\n        var right = 0\\n\\n        var need: [Character: Int] = [:]\\n        for char in t {\\n            need[char, default: 0] += 1\\n        }\\n        var window: [Character: Int] = [:]\\n\\n        // string convert to [char]\\n        var sChars: [Character] = [Character](s)\\n        var tChars: [Character] = [Character](t)\\n        \\n        // fitable count\\n        var validCount = 0\\n        var minLength = Int.max\\n        \\n        // the start and end index of the answer\\n        var start = 0\\n\\n        while right < s.count {\\n            // expand\\n            var curChar = sChars[right]\\n            right += 1\\n\\n            // update data\\n            if let curCharCount = need[curChar] {\\n                window[curChar, default: 0] += 1\\n                if window[curChar] == curCharCount {\\n                    validCount += 1\\n                }\\n            }\\n\\n            // shrink\\n            while validCount == need.count {\\n                // save one possible answer \\n                if right - left < minLength {\\n                    start = left\\n                    minLength = right - left\\n                }\\n\\n                // begin to shrink range\\n                curChar = sChars[left]\\n                left += 1\\n\\n                // update data\\n                if let curCharCount = need[curChar] {\\n                    if window[curChar] == curCharCount {\\n                        validCount -= 1\\n                    }\\n                    window[curChar, default: 0] -= 1\\n                }\\n            }\\n        }\\n\\n        return minLength == Int.max ? \"\" : String(sChars[start..<start + minLength])\\n    }\\n```\\n\\n\\n",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\n    func minWindow(_ s: String, _ t: String) -> String {\\n        guard s.count >= t.count else {\\n            return \"\"\\n        }\\n        var left = 0 \\n        var right = 0\\n\\n        var need: [Character: Int] = [:]\\n        for char in t {\\n            need[char, default: 0] += 1\\n        }\\n        var window: [Character: Int] = [:]\\n\\n        // string convert to [char]\\n        var sChars: [Character] = [Character](s)\\n        var tChars: [Character] = [Character](t)\\n        \\n        // fitable count\\n        var validCount = 0\\n        var minLength = Int.max\\n        \\n        // the start and end index of the answer\\n        var start = 0\\n\\n        while right < s.count {\\n            // expand\\n            var curChar = sChars[right]\\n            right += 1\\n\\n            // update data\\n            if let curCharCount = need[curChar] {\\n                window[curChar, default: 0] += 1\\n                if window[curChar] == curCharCount {\\n                    validCount += 1\\n                }\\n            }\\n\\n            // shrink\\n            while validCount == need.count {\\n                // save one possible answer \\n                if right - left < minLength {\\n                    start = left\\n                    minLength = right - left\\n                }\\n\\n                // begin to shrink range\\n                curChar = sChars[left]\\n                left += 1\\n\\n                // update data\\n                if let curCharCount = need[curChar] {\\n                    if window[curChar] == curCharCount {\\n                        validCount -= 1\\n                    }\\n                    window[curChar, default: 0] -= 1\\n                }\\n            }\\n        }\\n\\n        return minLength == Int.max ? \"\" : String(sChars[start..<start + minLength])\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1535816,
                "title": "c-sliding-window-technique-easy-to-understand",
                "content": "class Solution {\\npublic:\\n\\n    string minWindow(string s, string t) {\\n        vector<int> map(128,0);\\n        int i=0,j=0,n=s.length(),m=t.length(),len=INT_MAX,count=0;\\n        string ans=\"\";\\n        if(s==t){\\n            return s;\\n        }\\n        if(m>n){\\n            return ans;\\n        }\\n        for(int i=0;i<m;i++){\\n            map[t[i]]++;\\n        }\\n        while(j<n){\\n            if(map[s[j++]]-->0){\\n                count++;\\n            }\\n            while(count==m){\\n                if(j-i<len){\\n                    len=j-i;\\n                    ans=s.substr(i,j-i);\\n                }\\n                if(map[s[i++]]++>-1){\\n                    count--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    string minWindow(string s, string t) {\\n        vector<int> map(128,0);\\n        int i=0,j=0,n=s.length(),m=t.length(),len=INT_MAX,count=0;\\n        string ans=\"\";\\n        if(s==t){\\n            return s;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 897656,
                "title": "easy-js-solution-sliding-window",
                "content": "```\\nvar minWindow = function(s, t) {\\n    let m = new Map();\\n    for (let i = 0; i < t.length; i++) {\\n        m.set(t[i], m.get(t[i]) + 1 || 1);\\n    }\\n    let start = 0, end = 0;\\n    let minStart = null, minEnd = null;\\n    let uniqueChars = m.size; // # of unique characters in t\\n    while (end < s.length) {\\n        if (m.has(s[end])) {\\n            m.set(s[end], m.get(s[end]) - 1);\\n            // unique chars to collect decrements by 1\\n            if (m.get(s[end]) === 0) {\\n                uniqueChars -= 1;\\n            }\\n        }\\n        while (uniqueChars === 0 && start <= end) {\\n            if (minStart === null || minEnd - minStart > end - start) {\\n                minStart = start;\\n                minEnd = end;    \\n            }\\n            if (m.has(s[start])) {\\n                m.set(s[start], m.get(s[start]) + 1); \\n                // unique chars to collect increments by 1\\n                if (m.get(s[start]) === 1) {\\n                    uniqueChars += 1;\\n                }\\n            }\\n            start++;\\n        }\\n        end++;\\n    }\\n    return minStart === null ? \"\" : s.substring(minStart, minEnd + 1);\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minWindow = function(s, t) {\\n    let m = new Map();\\n    for (let i = 0; i < t.length; i++) {\\n        m.set(t[i], m.get(t[i]) + 1 || 1);\\n    }\\n    let start = 0, end = 0;\\n    let minStart = null, minEnd = null;\\n    let uniqueChars = m.size; // # of unique characters in t\\n    while (end < s.length) {\\n        if (m.has(s[end])) {\\n            m.set(s[end], m.get(s[end]) - 1);\\n            // unique chars to collect decrements by 1\\n            if (m.get(s[end]) === 0) {\\n                uniqueChars -= 1;\\n            }\\n        }\\n        while (uniqueChars === 0 && start <= end) {\\n            if (minStart === null || minEnd - minStart > end - start) {\\n                minStart = start;\\n                minEnd = end;    \\n            }\\n            if (m.has(s[start])) {\\n                m.set(s[start], m.get(s[start]) + 1); \\n                // unique chars to collect increments by 1\\n                if (m.get(s[start]) === 1) {\\n                    uniqueChars += 1;\\n                }\\n            }\\n            start++;\\n        }\\n        end++;\\n    }\\n    return minStart === null ? \"\" : s.substring(minStart, minEnd + 1);\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 489178,
                "title": "easy-to-understand-python-solution-sliding-window",
                "content": "```\\nclass Solution:\\n    def minWindow(self, s: str, t: str) -> str:\\n        need = collections.Counter(t)\\n        l,r,i,j,missing = 0,0,0,0, len(t)\\n        while r < len(s):\\n            if need[s[r]] >0:\\n                missing -=1\\n            need[s[r]]-=1 \\n            r+=1\\n                \\n            while missing == 0:\\n                if j==0 or r-l < j-i:\\n                    i,j=l,r\\n                need[s[l]]+=1\\n                if need[s[l]]>0:\\n                    missing +=1\\n                l += 1\\n        return s[i:j]\\n                    \\n                \\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minWindow(self, s: str, t: str) -> str:\\n        need = collections.Counter(t)\\n        l,r,i,j,missing = 0,0,0,0, len(t)\\n        while r < len(s):\\n            if need[s[r]] >0:\\n                missing -=1\\n            need[s[r]]-=1 \\n            r+=1\\n                \\n            while missing == 0:\\n                if j==0 or r-l < j-i:\\n                    i,j=l,r\\n                need[s[l]]+=1\\n                if need[s[l]]>0:\\n                    missing +=1\\n                l += 1\\n        return s[i:j]\\n                    \\n                \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 267005,
                "title": "java-short-solution",
                "content": "```\\n    public String minWindow(String s, String t) {\\n        int[] count = new int[128];\\n        for(char c : t.toCharArray()) count[c]++;\\n        \\n        int min = s.length() + 1, i = 0, j = 0, remain = t.length();\\n        \\n        String res = \"\";\\n        while(i < s.length()) {\\n            if(--count[s.charAt(i++)] >= 0) remain--;\\n            while(remain == 0) {\\n                if(i - j < min) {\\n                    min = i - j;\\n                    res = s.substring(j, i);\\n                }\\n                if(++count[s.charAt(j++)] > 0) remain++;;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n```\\n    public String minWindow(String s, String t) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        for(char c : t.toCharArray()) map.put(c, map.getOrDefault(c, 0) + 1);\\n        int count = map.size();\\n        \\n        int i = 0, j = 0, min = s.length() + 1;\\n        String res = \"\";\\n\\n        while(i < s.length()) {\\n            char c = s.charAt(i++);\\n            if(!map.containsKey(c)) continue;\\n            map.put(c, map.get(c) - 1);\\n            if(map.get(c) == 0) count--;\\n\\n            while(count == 0) {\\n                while(j < i && !map.containsKey(s.charAt(j))) j++;\\n                if(i-j < min) {\\n                    min = i - j;\\n                    res = s.substring(j, i);\\n                }\\n                char c1 = s.charAt(j);\\n                map.put(c1, map.get(c1) + 1);\\n                if(map.get(c1) > 0) count++;\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String minWindow(String s, String t) {\\n        int[] count = new int[128];\\n        for(char c : t.toCharArray()) count[c]++;\\n        \\n        int min = s.length() + 1, i = 0, j = 0, remain = t.length();\\n        \\n        String res = \"\";\\n        while(i < s.length()) {\\n            if(--count[s.charAt(i++)] >= 0) remain--;\\n            while(remain == 0) {\\n                if(i - j < min) {\\n                    min = i - j;\\n                    res = s.substring(j, i);\\n                }\\n                if(++count[s.charAt(j++)] > 0) remain++;;\\n            }\\n        }\\n        return res;\\n    }\\n```\n```\\n    public String minWindow(String s, String t) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        for(char c : t.toCharArray()) map.put(c, map.getOrDefault(c, 0) + 1);\\n        int count = map.size();\\n        \\n        int i = 0, j = 0, min = s.length() + 1;\\n        String res = \"\";\\n\\n        while(i < s.length()) {\\n            char c = s.charAt(i++);\\n            if(!map.containsKey(c)) continue;\\n            map.put(c, map.get(c) - 1);\\n            if(map.get(c) == 0) count--;\\n\\n            while(count == 0) {\\n                while(j < i && !map.containsKey(s.charAt(j))) j++;\\n                if(i-j < min) {\\n                    min = i - j;\\n                    res = s.substring(j, i);\\n                }\\n                char c1 = s.charAt(j);\\n                map.put(c1, map.get(c1) + 1);\\n                if(map.get(c1) > 0) count++;\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 26821,
                "title": "java-version-if-you-have-trouble-reading-highest-uprated-post-u4e2d-u6587-u7248",
                "content": "\\u6211\\u89c9\\u5f97\\u8fd9\\u9898\\u7684\\u7cbe\\u9ad3\\u5728\\u4e8e\\u8bb0\\u5f55\\u5b57\\u7b26\\u51fa\\u73b0\\u5b57\\u6570\\u7684Map\\u53ef\\u4ee5\\u8bb0\\u5f55\\u8d1f\\u6570\\uff0c\\u4e5f\\u5c31\\u662f\\u8bf4\\u67d0\\u4e2a\\u5b57\\u7b26\\u88ab\\u8fc7\\u591a\\u7528\\u4e86\\uff0c\\u4e4b\\u524d\\u672c\\u4eba\\u4e5f\\u662f\\u6ca1\\u60f3\\u5230\\u80fd\\u8bb0\\u5f55\\u8d1f\\u6570, \\u6240\\u4ee5\\u611f\\u89c9s=\\u201cbba\\u201d t=\"ab\" \\u8fd9\\u79cd\\u60c5\\u51b5\\u4e0d\\u77e5\\u5982\\u4f55\\u89e3\\u3002\\u6211\\u60f3\\u5927\\u5bb6\\u5e94\\u8be5\\u5bf9\\u53cc\\u6307\\u9488\\u8fd9\\u79cd\\u89e3\\u6cd5\\u5e94\\u8be5\\u6ca1\\u6709\\u4ec0\\u4e48\\u95ee\\u9898\\u3002\\u8bf7\\u770b\\u4ee3\\u7801\\uff1a\\n\\nThe key for this problem should be tracking how every char is used in t. In particular, everytime when a char is used, we do map[end_ch]--. If map[end_ch] becomes negative, this means the char is over used. And when moving the left pointer right, we should increase map[start_ch]++ until we find map[start_ch] is positive. If we don't record if a char is overused, we cannot solve cases like s = \"bba\", t = \"ab\".\\n```\\n    public String minWindow(String s, String t) {\\n        if (s == null || t == null) return \"\";\\n        int[] map = new int[256];\\n        for (char c : t.toCharArray()) map[c]++;\\n        \\n        int start = 0, remainingChar = t.length();\\n        int minLen = Integer.MAX_VALUE,  minLenStartIdx = 0;\\n        for (int end = 0; end < s.length(); end++) {\\n            char end_ch = s.charAt(end);\\n            \\n            if (map[end_ch] > 0) remainingChar--;//\\u82e5\\u8fd9\\u4e2a\\u5b57\\u7b26\\u6709\\u4f59\\u989d,\\u4f7f\\u7528\\u4ee5\\u540e\\u9700\\u8981\\u51cf\\u51cf\\u6211\\u4eec\\u5269\\u4f59\\u53ef\\u7528\\u5b57\\u7b26\\u7684\\u6570\\u91cf:remainingChar\\n            map[end_ch]--;//\\u78b0\\u5230\\u4efb\\u610f\\u5b57\\u7b26,\\u4f7f\\u7528\\u8fc7\\u5c31\\u8981\\u51cf\\u51cf\\n            \\n            while (remainingChar == 0 && start < s.length()) {\\n                if (minLen > end-start+1) {//\\u627e\\u5230\\u6bd4\\u76ee\\u524d\\u7684\\u66f4\\u4f18\\u89e3,\\u8bb0\\u5f55\\u4e4b\\n                    minLen = end-start+1;\\n                    minLenStartIdx = start;\\n                }\\n                \\n                char start_ch = s.charAt(start);\\n                map[start_ch]++;\\n                if ( map[start_ch] > 0) remainingChar++;//\\u8fd9\\u91cc\\u5173\\u952e,start\\u6307\\u7684\\u5b57\\u7b26\\u5df2\\u7ecf\\u88ab\\u52a0\\u52a0,\\u5982\\u679c\\u8fd9\\u65f6\\u5019\\u8fd8\\u4e0d\\u5927\\u4e8e0,\\u8bf4\\u660e\\u8fd9\\u4e2a\\u5b57\\u7b26\\u88ab\\u8fc7\\u591a\\u4f7f\\u7528\\u4e86,remainingChar\\u5c31\\u4e0d\\u80fd\\u589e\\u52a0\\n                start++;\\n            }\\n        }\\n        \\n        return minLen == Integer.MAX_VALUE ? \"\" : s.substring(minLenStartIdx, minLenStartIdx+minLen);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String minWindow(String s, String t) {\\n        if (s == null || t == null) return \"\";\\n        int[] map = new int[256];\\n        for (char c : t.toCharArray()) map[c]++;\\n        \\n        int start = 0, remainingChar = t.length();\\n        int minLen = Integer.MAX_VALUE,  minLenStartIdx = 0;\\n        for (int end = 0; end < s.length(); end++) {\\n            char end_ch = s.charAt(end);\\n            \\n            if (map[end_ch] > 0) remainingChar--;//\\u82e5\\u8fd9\\u4e2a\\u5b57\\u7b26\\u6709\\u4f59\\u989d,\\u4f7f\\u7528\\u4ee5\\u540e\\u9700\\u8981\\u51cf\\u51cf\\u6211\\u4eec\\u5269\\u4f59\\u53ef\\u7528\\u5b57\\u7b26\\u7684\\u6570\\u91cf:remainingChar\\n            map[end_ch]--;//\\u78b0\\u5230\\u4efb\\u610f\\u5b57\\u7b26,\\u4f7f\\u7528\\u8fc7\\u5c31\\u8981\\u51cf\\u51cf\\n            \\n            while (remainingChar == 0 && start < s.length()) {\\n                if (minLen > end-start+1) {//\\u627e\\u5230\\u6bd4\\u76ee\\u524d\\u7684\\u66f4\\u4f18\\u89e3,\\u8bb0\\u5f55\\u4e4b\\n                    minLen = end-start+1;\\n                    minLenStartIdx = start;\\n                }\\n                \\n                char start_ch = s.charAt(start);\\n                map[start_ch]++;\\n                if ( map[start_ch] > 0) remainingChar++;//\\u8fd9\\u91cc\\u5173\\u952e,start\\u6307\\u7684\\u5b57\\u7b26\\u5df2\\u7ecf\\u88ab\\u52a0\\u52a0,\\u5982\\u679c\\u8fd9\\u65f6\\u5019\\u8fd8\\u4e0d\\u5927\\u4e8e0,\\u8bf4\\u660e\\u8fd9\\u4e2a\\u5b57\\u7b26\\u88ab\\u8fc7\\u591a\\u4f7f\\u7528\\u4e86,remainingChar\\u5c31\\u4e0d\\u80fd\\u589e\\u52a0\\n                start++;\\n            }\\n        }\\n        \\n        return minLen == Integer.MAX_VALUE ? \"\" : s.substring(minLenStartIdx, minLenStartIdx+minLen);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 26892,
                "title": "accepted-as-best-in-c",
                "content": "    #define LEN  128\\n    char* minWindow(char* s, char* t)\\n    {\\n        int counter[LEN] = {0};\\n        int start=0, end=0, tLen=strlen(t), sLen=strlen(s);\\n        int minStart=0, minLen=INT_MAX;\\n        for(int i = 0; i < LEN; i++) counter[i] = -sLen; //distinguish the letter in and not in t;\\n        for(int i = 0; t[i]; i++) counter[t[i]] = 0;\\n        for(int i = 0; t[i]; i++) counter[t[i]]++;\\n        while(end < sLen)\\n        {\\n            if(counter[s[end]]-- > 0) tLen--;\\n            end++; //move to the next character;\\n            while(tLen == 0) //a valid substring;\\n            {\\n                if(end-start < minLen) //collect the minimal only;\\n                    minStart=start, minLen=end-start;\\n                counter[s[start]]++;\\n                if(counter[s[start]] > 0) tLen++; //if s[start] is in t;\\n                start++; //move forward by ignoring s[start];\\n            }\\n        }\\n        if(minLen != INT_MAX)\\n        {\\n            char* t = (char*)malloc(sizeof(char)*(minLen+1));\\n            *t = '\\\\0';\\n            strncat(t, s+minStart, minLen);\\n            return t;\\n        }\\n        return \"\";\\n    }",
                "solutionTags": [],
                "code": "    #define LEN  128\\n    char* minWindow(char* s, char* t)\\n    {\\n        int counter[LEN] = {0};\\n        int start=0, end=0, tLen=strlen(t), sLen=strlen(s);\\n        int minStart=0, minLen=INT_MAX;\\n        for(int i = 0; i < LEN; i++) counter[i] = -sLen; //distinguish the letter in and not in t;\\n        for(int i = 0; t[i]; i++) counter[t[i]] = 0;\\n        for(int i = 0; t[i]; i++) counter[t[i]]++;\\n        while(end < sLen)\\n        {\\n            if(counter[s[end]]-- > 0) tLen--;\\n            end++; //move to the next character;\\n            while(tLen == 0) //a valid substring;\\n            {\\n                if(end-start < minLen) //collect the minimal only;\\n                    minStart=start, minLen=end-start;\\n                counter[s[start]]++;\\n                if(counter[s[start]] > 0) tLen++; //if s[start] is in t;\\n                start++; //move forward by ignoring s[start];\\n            }\\n        }\\n        if(minLen != INT_MAX)\\n        {\\n            char* t = (char*)malloc(sizeof(char)*(minLen+1));\\n            *t = '\\\\0';\\n            strncat(t, s+minStart, minLen);\\n            return t;\\n        }\\n        return \"\";\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 26894,
                "title": "simple-c-solution-12ms",
                "content": "\\n\\n    class Solution {\\n    public:\\n        string minWindow(string s, string t) {\\n            \\n            int hashmap[256] = {0};\\n            int m = s.size(), n = t.size();\\n            \\n            for (int i = 0; i < n; ++ i) {\\n                hashmap[t[i]] ++;\\n            }\\n            \\n            int minLen = -1, len = 0, validLen = 0;\\n            int start = 0, min_start;\\n    \\n            for (int i = 0; i < m; ++ i) {\\n                \\n                if (hashmap[s[i]] > 0) validLen ++;\\n                hashmap[s[i]] --;\\n                len ++;\\n    \\n                while (hashmap[s[start]] < 0) {\\n                    hashmap[s[start]] ++;\\n                    start ++;\\n                    len --;\\n                }\\n                \\n                if (validLen == n && (len < minLen || minLen == -1)) {\\n                    minLen = len;\\n                    min_start = start;\\n                }\\n            }\\n            \\n            if (validLen < n) return \"\";\\n            \\n            return s.substr(min_start, minLen);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string minWindow(string s, string t) {\\n            \\n            int hashmap[256] = {0}",
                "codeTag": "Java"
            },
            {
                "id": 26889,
                "title": "accepted-solution-for-your-reference",
                "content": "    public String minWindow(String S, String T) {\\n        int[] result = new int[] {-1, S.length()};\\n        int counter = 0;\\n        Map<Character, Integer> expected = new HashMap<>();\\n        Map<Character, Integer> window = new HashMap<>();\\n        \\n        for (int i = 0; i < T.length(); i++) {\\n            if (!expected.containsKey(T.charAt(i))) expected.put(T.charAt(i), 0);\\n            expected.put(T.charAt(i), expected.get(T.charAt(i)) + 1);\\n        }\\n        for (int i = 0, j = 0; j < S.length(); j++) {\\n            char cur = S.charAt(j);\\n            if (expected.containsKey(cur)) {\\n                if (!window.containsKey(cur)) window.put(cur, 0);\\n                window.put(cur, window.get(cur) + 1);\\n                if (window.get(cur) <= expected.get(cur)) counter++;\\n                if (counter == T.length()) {\\n                    char remove = S.charAt(i);\\n                    while (!expected.containsKey(remove) || window.get(remove) > expected.get(remove)){\\n                        if (expected.containsKey(remove)) window.put(remove, window.get(remove) - 1);\\n                        remove = S.charAt(++i);;\\n                    }\\n                    if (j - i < result[1] - result[0]) result = new int[]{i, j};\\n                }\\n            }\\n        }\\n        return result[1] - result[0] < S.length() ? S.substring(result[0], result[1] + 1) : \"\";\\n    }\\n\\nCount the number of every character in T. Go through the S and maintain a window to store characters met before. Use a variable counter to keep track of the valid characters in T. If counter reaches T.length, shrink the window if necessary.",
                "solutionTags": [
                    "String"
                ],
                "code": "    public String minWindow(String S, String T) {\\n        int[] result = new int[] {-1, S.length()};\\n        int counter = 0;\\n        Map<Character, Integer> expected = new HashMap<>();\\n        Map<Character, Integer> window = new HashMap<>();\\n        \\n        for (int i = 0; i < T.length(); i++) {\\n            if (!expected.containsKey(T.charAt(i))) expected.put(T.charAt(i), 0);\\n            expected.put(T.charAt(i), expected.get(T.charAt(i)) + 1);\\n        }\\n        for (int i = 0, j = 0; j < S.length(); j++) {\\n            char cur = S.charAt(j);\\n            if (expected.containsKey(cur)) {\\n                if (!window.containsKey(cur)) window.put(cur, 0);\\n                window.put(cur, window.get(cur) + 1);\\n                if (window.get(cur) <= expected.get(cur)) counter++;\\n                if (counter == T.length()) {\\n                    char remove = S.charAt(i);\\n                    while (!expected.containsKey(remove) || window.get(remove) > expected.get(remove)){\\n                        if (expected.containsKey(remove)) window.put(remove, window.get(remove) - 1);\\n                        remove = S.charAt(++i);;\\n                    }\\n                    if (j - i < result[1] - result[0]) result = new int[]{i, j};\\n                }\\n            }\\n        }\\n        return result[1] - result[0] < S.length() ? S.substring(result[0], result[1] + 1) : \"\";\\n    }\\n\\nCount the number of every character in T. Go through the S and maintain a window to store characters met before. Use a variable counter to keep track of the valid characters in T. If counter reaches T.length, shrink the window if necessary.",
                "codeTag": "Unknown"
            },
            {
                "id": 3378616,
                "title": "java-2-pointers-with-explanation-and-dry-run",
                "content": "**Intuition:** Use 2 pointers that signify the start and end of the acceptable window. If all characters of `t` are in `s` then start decreasing the size of the window to check if it is still an acceptable window.\\n\\n**Code:**\\n```Java\\nclass Solution\\n{\\n    public String minWindow(String s, String t) \\n    {\\n        int[] count = new int[128];\\n        for(char c: t.toCharArray())\\n            count[c]++;\\n        int start = 0, end = 0, minStart = 0, minLen = Integer.MAX_VALUE, counter = t.length();\\n        while(end < s.length())\\n        {\\n            char c1 = s.charAt(end);\\n            \\n            // if character in s is in t\\n            if(count[c1] > 0)\\n                counter--;\\n            count[c1]--;\\n            // increase window size to search for similar characters\\n            end++;\\n\\n            //Once we have the characters in t in the substring we currently we have in s, we start decreasing the size of the window to get the minimum size.\\n            while(counter == 0)\\n            {\\n                if(minLen > end - start)\\n                {\\n                    minLen = end - start;\\n                    minStart = start;\\n                }\\n                char c2 = s.charAt(start);\\n                count[c2]++; // since we are decreasing the size of the window, we are removing the character from the hashmap for t, all non present characters were negative, hence we add here.\\n                if(count[c2] > 0)// if the character is present in t and not in s, the count[c2] will be negative\\n                    counter++;\\n      \\n                start++;//we keep decreasing the size of the window as long as we have all characters in t in s \\n            }\\n            \\n        }\\n        return minLen == Integer.MAX_VALUE ? \"\": s.substring(minStart, minStart + minLen);\\n        \\n    }\\n}\\n```\\n\\n**Dry Run:**\\n```\\nend = 1, counter = 2\\n---------------\\nend = 2, counter = 2\\n---------------\\nend = 3, counter = 2\\n---------------\\nend = 4, counter = 1\\n---------------\\nend = 5, counter = 1\\n---------------\\nend = 6, counter = 0\\nc2 = A, count[c2] = 1, counter = 1, ADOBEC\\n//we increase start here and since A gets removed, all characters of t are not in s now, hence we start increasing the window again\\n---------------\\nend = 7, counter = 1\\n---------------\\nend = 8, counter = 1\\n---------------\\nend = 9, counter = 1\\n---------------\\nend = 10, counter = 1\\n---------------\\nend = 11, counter = 0\\nc2 = D, count[c2] = -1, counter = 0, DOBECODEBA\\nc2 = O, count[c2] = -1, counter = 0, OBECODEBA\\nc2 = B, count[c2] = 0, counter = 0, BECODEBA\\nc2 = E, count[c2] = -1, counter = 0, ECODEBA\\nc2 = C, count[c2] = 1, counter = 1, CODEBA\\n//we increase start here and since C gets removed, all characters of t are not in s now, hence we start increasing the window again\\n---------------\\nend = 12, counter = 1\\n---------------\\nend = 13, counter = 0\\nc2 = O, count[c2] = 0, counter = 0, ODEBANC\\nc2 = D, count[c2] = 0, counter = 0, DEBANC\\nc2 = E, count[c2] = 0, counter = 0, EBANC\\nc2 = B, count[c2] = 1, counter = 1, BANC\\n//we increase start here and since B gets removed, all characters of t are not in s now, hence we start increasing the window again\\n---------------\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```Java\\nclass Solution\\n{\\n    public String minWindow(String s, String t) \\n    {\\n        int[] count = new int[128];\\n        for(char c: t.toCharArray())\\n            count[c]++;\\n        int start = 0, end = 0, minStart = 0, minLen = Integer.MAX_VALUE, counter = t.length();\\n        while(end < s.length())\\n        {\\n            char c1 = s.charAt(end);\\n            \\n            // if character in s is in t\\n            if(count[c1] > 0)\\n                counter--;\\n            count[c1]--;\\n            // increase window size to search for similar characters\\n            end++;\\n\\n            //Once we have the characters in t in the substring we currently we have in s, we start decreasing the size of the window to get the minimum size.\\n            while(counter == 0)\\n            {\\n                if(minLen > end - start)\\n                {\\n                    minLen = end - start;\\n                    minStart = start;\\n                }\\n                char c2 = s.charAt(start);\\n                count[c2]++; // since we are decreasing the size of the window, we are removing the character from the hashmap for t, all non present characters were negative, hence we add here.\\n                if(count[c2] > 0)// if the character is present in t and not in s, the count[c2] will be negative\\n                    counter++;\\n      \\n                start++;//we keep decreasing the size of the window as long as we have all characters in t in s \\n            }\\n            \\n        }\\n        return minLen == Integer.MAX_VALUE ? \"\": s.substring(minStart, minStart + minLen);\\n        \\n    }\\n}\\n```\n```\\nend = 1, counter = 2\\n---------------\\nend = 2, counter = 2\\n---------------\\nend = 3, counter = 2\\n---------------\\nend = 4, counter = 1\\n---------------\\nend = 5, counter = 1\\n---------------\\nend = 6, counter = 0\\nc2 = A, count[c2] = 1, counter = 1, ADOBEC\\n//we increase start here and since A gets removed, all characters of t are not in s now, hence we start increasing the window again\\n---------------\\nend = 7, counter = 1\\n---------------\\nend = 8, counter = 1\\n---------------\\nend = 9, counter = 1\\n---------------\\nend = 10, counter = 1\\n---------------\\nend = 11, counter = 0\\nc2 = D, count[c2] = -1, counter = 0, DOBECODEBA\\nc2 = O, count[c2] = -1, counter = 0, OBECODEBA\\nc2 = B, count[c2] = 0, counter = 0, BECODEBA\\nc2 = E, count[c2] = -1, counter = 0, ECODEBA\\nc2 = C, count[c2] = 1, counter = 1, CODEBA\\n//we increase start here and since C gets removed, all characters of t are not in s now, hence we start increasing the window again\\n---------------\\nend = 12, counter = 1\\n---------------\\nend = 13, counter = 0\\nc2 = O, count[c2] = 0, counter = 0, ODEBANC\\nc2 = D, count[c2] = 0, counter = 0, DEBANC\\nc2 = E, count[c2] = 0, counter = 0, EBANC\\nc2 = B, count[c2] = 1, counter = 1, BANC\\n//we increase start here and since B gets removed, all characters of t are not in s now, hence we start increasing the window again\\n---------------\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3378328,
                "title": "easy-solution-cpp-explained",
                "content": "1. Take a map and store \\'t\\' string in map\\n2. iterate over the whole string using i=0,j=0\\n3. Now decrease the occurence of jth in map\\n4. maintain a count which can tells the needed window size acheived or not\\n5. if count =0 ==> ans acheived but lets optimise it \\n6. now while count =0 check i and increase its occurence with count and update ans to min window size\\n7. now iterate over rest of the string to find min window \\n8. just return the needed substring\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        int i=0,j=0;\\n        int ans=INT_MAX;\\n        map<char,int>mp;\\n//store elements in map\\n        for(auto i:t){\\n            mp[i]++;\\n        }\\n        int start=0;\\n        int count = mp.size();\\n        while(j < s.size()){\\n//decrease occurence of jth element\\n                mp[s[j]]--;\\n\\n            if(mp[s[j]] == 0){\\n                count--;\\n            }\\n//window achieved\\n            if(count == 0){\\n//lets optimise it \\n                while(count == 0){\\n//update ans to min window \\n                    if (ans > j-i+1) {\\n                        ans = j-i+1;\\n                        start=i;\\n                    }\\n//after removing ith --> increase its count becoz its removed\\n                        mp[s[i]]++;\\n//now check for count need to be update or not\\n                        if(mp[s[i]] > 0){\\n                            count++;\\n                        }\\n                    \\n                    i++;\\n                }\\n                \\n            }\\n            j++;\\n        }\\n//return the needed output\\n        if(ans != INT_MAX){\\n            return s.substr(start,ans);\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        int i=0,j=0;\\n        int ans=INT_MAX;\\n        map<char,int>mp;\\n//store elements in map\\n        for(auto i:t){\\n            mp[i]++;\\n        }\\n        int start=0;\\n        int count = mp.size();\\n        while(j < s.size()){\\n//decrease occurence of jth element\\n                mp[s[j]]--;\\n\\n            if(mp[s[j]] == 0){\\n                count--;\\n            }\\n//window achieved\\n            if(count == 0){\\n//lets optimise it \\n                while(count == 0){\\n//update ans to min window \\n                    if (ans > j-i+1) {\\n                        ans = j-i+1;\\n                        start=i;\\n                    }\\n//after removing ith --> increase its count becoz its removed\\n                        mp[s[i]]++;\\n//now check for count need to be update or not\\n                        if(mp[s[i]] > 0){\\n                            count++;\\n                        }\\n                    \\n                    i++;\\n                }\\n                \\n            }\\n            j++;\\n        }\\n//return the needed output\\n        if(ans != INT_MAX){\\n            return s.substr(start,ans);\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2915481,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        if(t.size()>s.size())\\n            return \"\";\\n        unordered_map<char,int> mp;\\n        for(auto a:t)\\n            mp[a]++;\\n        int i=0,j=0, cnt=t.size();\\n        int st=0;\\n        int ans=INT_MAX;\\n        while(j<s.size())\\n        {\\n            mp[s[j]]--;\\n            if(mp[s[j]]>=0)\\n                cnt--;\\n            j++;\\n            while(cnt==0)\\n            {\\n                mp[s[i]]++;\\n                if(ans>(j-i))\\n                {\\n                    ans=j-i;\\n                    st=i;\\n                }\\n                if(mp[s[i]]>0)\\n                    cnt++;\\n                i++;\\n            }\\n        }\\n        return ans==INT_MAX?\"\":s.substr(st,ans);\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        if(t.size()>s.size())\\n            return \"\";\\n        unordered_map<char,int> mp;\\n        for(auto a:t)\\n            mp[a]++;\\n        int i=0,j=0, cnt=t.size();\\n        int st=0;\\n        int ans=INT_MAX;\\n        while(j<s.size())\\n        {\\n            mp[s[j]]--;\\n            if(mp[s[j]]>=0)\\n                cnt--;\\n            j++;\\n            while(cnt==0)\\n            {\\n                mp[s[i]]++;\\n                if(ans>(j-i))\\n                {\\n                    ans=j-i;\\n                    st=i;\\n                }\\n                if(mp[s[i]]>0)\\n                    cnt++;\\n                i++;\\n            }\\n        }\\n        return ans==INT_MAX?\"\":s.substr(st,ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2731723,
                "title": "c-fast-sliding-window-0ms",
                "content": "For today\\'s problem I only have a single approach to offer, but it\\'s a fast one.\\n\\n# Approach 1: sliding window\\n\\nThis approach using a single char frequency map ```cnt``` and the variable ```nz``` (non zero values in ```cnt```) to decide if we have a match.\\n\\n```cpp\\n    static string minWindow(const string& s, const string& t) {\\n        if (size(s) < size(t)) return \"\";\\n        \\n        array<int, 128> cnt = {};\\n        int nz = 0;  // How many \"non zero\" values do we have in |cnt|.\\n        for (char ch : t) {\\n            if (!cnt[ch]--) --nz;\\n        }\\n        \\n        // Open the window.\\n        for (int i = 0; i < size(t); ++i) {\\n            if (!++cnt[s[i]]) ++nz;\\n        }\\n        // Do we have a match already?\\n        if (!nz) return s.substr(0, size(t));\\n        \\n        // Slide the window.\\n        int start = -1;\\n        int min_len = numeric_limits<int>::max();\\n        for (int l = 0, r = size(t); r < size(s); ++r) {\\n            if (!++cnt[s[r]]) ++nz;\\n            // While we have a match, shrink the window.\\n            while (!nz) {\\n                int len = r - l + 1;\\n                if (len < min_len) {\\n                    start = l;\\n                    min_len = len;\\n                }\\n                if (!cnt[s[l++]]--) --nz;\\n            }\\n        }\\n        \\n        return start != -1 ? s.substr(start, min_len) : \"\";\\n    }\\n```\\n\\n**Complexity Analysis**\\n  * Time complexity: $$O(n)$$ as we are looking at each char in ```s``` at most twice\\n  * Space complexity: $$O(1)$$\\n\\n\\n# Appenxing: slower / easier to understand sliding window\\n\\nSimilar idea as above, but the matching code is a lot slower, but easier to understand.\\n\\n```cpp\\n    static string minWindow(const string& s, const string& t) {\\n        if (size(s) < size(t)) return \"\";\\n        \\n        array<int, 128> pat = {};\\n        for (char ch : t) ++pat[ch];\\n        \\n        array<int, 128> wnd = {};\\n        \\n        // Open the window.\\n        for (int i = 0; i < size(t); ++i) ++wnd[s[i]];\\n        \\n        auto ismatch = [&]() {\\n            for (char ch = \\'A\\'; ch <= \\'z\\'; ++ch) {\\n                if (pat[ch] > wnd[ch]) return false;\\n            }\\n            return true;\\n        };\\n        \\n        if (ismatch()) return s.substr(0, size(t));\\n        \\n        // Slide the window.\\n        int start = -1;\\n        int min_len = numeric_limits<int>::max();\\n        for (int l = 0, r = size(t); r < size(s); ++r) {\\n            ++wnd[s[r]];\\n            while (ismatch()) {\\n                int len = r - l + 1;\\n                if (len < min_len) {\\n                    start = l;\\n                    min_len = len;\\n                }\\n                --wnd[s[l++]];\\n            }\\n        }\\n        \\n        return start != -1 ? s.substr(start, min_len) : \"\";\\n    }\\n```\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an upvote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```cnt```\n```nz```\n```cnt```\n```cpp\\n    static string minWindow(const string& s, const string& t) {\\n        if (size(s) < size(t)) return \"\";\\n        \\n        array<int, 128> cnt = {};\\n        int nz = 0;  // How many \"non zero\" values do we have in |cnt|.\\n        for (char ch : t) {\\n            if (!cnt[ch]--) --nz;\\n        }\\n        \\n        // Open the window.\\n        for (int i = 0; i < size(t); ++i) {\\n            if (!++cnt[s[i]]) ++nz;\\n        }\\n        // Do we have a match already?\\n        if (!nz) return s.substr(0, size(t));\\n        \\n        // Slide the window.\\n        int start = -1;\\n        int min_len = numeric_limits<int>::max();\\n        for (int l = 0, r = size(t); r < size(s); ++r) {\\n            if (!++cnt[s[r]]) ++nz;\\n            // While we have a match, shrink the window.\\n            while (!nz) {\\n                int len = r - l + 1;\\n                if (len < min_len) {\\n                    start = l;\\n                    min_len = len;\\n                }\\n                if (!cnt[s[l++]]--) --nz;\\n            }\\n        }\\n        \\n        return start != -1 ? s.substr(start, min_len) : \"\";\\n    }\\n```\n```s```\n```cpp\\n    static string minWindow(const string& s, const string& t) {\\n        if (size(s) < size(t)) return \"\";\\n        \\n        array<int, 128> pat = {};\\n        for (char ch : t) ++pat[ch];\\n        \\n        array<int, 128> wnd = {};\\n        \\n        // Open the window.\\n        for (int i = 0; i < size(t); ++i) ++wnd[s[i]];\\n        \\n        auto ismatch = [&]() {\\n            for (char ch = \\'A\\'; ch <= \\'z\\'; ++ch) {\\n                if (pat[ch] > wnd[ch]) return false;\\n            }\\n            return true;\\n        };\\n        \\n        if (ismatch()) return s.substr(0, size(t));\\n        \\n        // Slide the window.\\n        int start = -1;\\n        int min_len = numeric_limits<int>::max();\\n        for (int l = 0, r = size(t); r < size(s); ++r) {\\n            ++wnd[s[r]];\\n            while (ismatch()) {\\n                int len = r - l + 1;\\n                if (len < min_len) {\\n                    start = l;\\n                    min_len = len;\\n                }\\n                --wnd[s[l++]];\\n            }\\n        }\\n        \\n        return start != -1 ? s.substr(start, min_len) : \"\";\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2731308,
                "title": "java-hashmap-two-pointers-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public String minWindow(String s, String t) {\\n        int m=s.length(),n=t.length();\\n        String ans=\"\";\\n        if(n>m || n==0 || m==0){\\n            return \"\";\\n        }\\n        \\n        //for frequency of chars in string t\\n        HashMap<Character,Integer> hm1=new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            hm1.put(t.charAt(i),hm1.getOrDefault(t.charAt(i),0)+1);\\n        }\\n        \\n        //for freq of chars in string s\\n        HashMap<Character,Integer> hm2=new HashMap<>();\\n        int start=0,end=0;\\n        int matchCount=0;\\n        int minLen=Integer.MAX_VALUE,minStart=0;\\n        \\n        while(end<m){\\n            \\n            //acquire characters\\n            char ch=s.charAt(end);\\n            if(hm1.containsKey(ch)){\\n                if(hm2.containsKey(ch)){\\n                    if(hm2.get(ch)<hm1.get(ch)){\\n                        matchCount++;\\n                    }\\n                    hm2.put(ch,hm2.get(ch)+1);\\n                }\\n                else{\\n                    matchCount++;\\n                    hm2.put(ch,1);\\n                }\\n            }\\n            end++;\\n            \\n            //release chracters till matchCount=n and update length after each char\\n            while(matchCount==n){\\n                if((end-start)<minLen){\\n                    minLen=end-start;\\n                    minStart=start;\\n                }\\n                char chS=s.charAt(start);\\n                if(hm1.containsKey(chS)){\\n                    if(hm2.get(chS)>hm1.get(chS)){\\n                        hm2.put(chS,hm2.get(chS)-1);\\n                    }\\n                    else{\\n                        hm2.put(chS,hm2.get(chS)-1);\\n                        matchCount--;\\n                    }\\n                }\\n                start++;\\n            }\\n            \\n        }\\n        \\n        if(minLen==Integer.MAX_VALUE){\\n            return \"\";\\n        }\\n        return s.substring(minStart,minStart+minLen);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public String minWindow(String s, String t) {\\n        int m=s.length(),n=t.length();\\n        String ans=\"\";\\n        if(n>m || n==0 || m==0){\\n            return \"\";\\n        }\\n        \\n        //for frequency of chars in string t\\n        HashMap<Character,Integer> hm1=new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            hm1.put(t.charAt(i),hm1.getOrDefault(t.charAt(i),0)+1);\\n        }\\n        \\n        //for freq of chars in string s\\n        HashMap<Character,Integer> hm2=new HashMap<>();\\n        int start=0,end=0;\\n        int matchCount=0;\\n        int minLen=Integer.MAX_VALUE,minStart=0;\\n        \\n        while(end<m){\\n            \\n            //acquire characters\\n            char ch=s.charAt(end);\\n            if(hm1.containsKey(ch)){\\n                if(hm2.containsKey(ch)){\\n                    if(hm2.get(ch)<hm1.get(ch)){\\n                        matchCount++;\\n                    }\\n                    hm2.put(ch,hm2.get(ch)+1);\\n                }\\n                else{\\n                    matchCount++;\\n                    hm2.put(ch,1);\\n                }\\n            }\\n            end++;\\n            \\n            //release chracters till matchCount=n and update length after each char\\n            while(matchCount==n){\\n                if((end-start)<minLen){\\n                    minLen=end-start;\\n                    minStart=start;\\n                }\\n                char chS=s.charAt(start);\\n                if(hm1.containsKey(chS)){\\n                    if(hm2.get(chS)>hm1.get(chS)){\\n                        hm2.put(chS,hm2.get(chS)-1);\\n                    }\\n                    else{\\n                        hm2.put(chS,hm2.get(chS)-1);\\n                        matchCount--;\\n                    }\\n                }\\n                start++;\\n            }\\n            \\n        }\\n        \\n        if(minLen==Integer.MAX_VALUE){\\n            return \"\";\\n        }\\n        return s.substring(minStart,minStart+minLen);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1928501,
                "title": "c-sliding-window-hashmap-o-n-easy-solution",
                "content": "1) sliding window problem \\n2) use 2 pointers left and right and traverse upon string \"s\"(keep increasing size of window)\\n3) if relevant letter(exists in t)  is found in s count it scount[s[right]]++ ,also count total number of letters found uptil now \\n4) if more letters have been found than required,try decreasing window size ,otherwise the window size will keep on increasing.\\n5) **window size can be decreased when** \\n* either the left most element is irrelevant(doesnt occur in t)\\n* or the leftmost element count is more than required (occurs again in string s  ) \\nwhen decreasing window size make sure to reduce count of leftmost char in s as now they dont exist in the window \\n6) otherwise keep on increasing window size from right \\n7) also update minwindow left and right indices to later on get resultant string \\n\\nHere is the code :\\n\\n\\tclass Solution {\\n\\tpublic:\\n    string minWindow(string s, string t) {\\n        \\n       if(s.size()<t.size()) return \"\";\\n        unordered_map<char,int> tcount;\\n        unordered_map<char,int> scount;\\n       \\n        for(int i=0;i<t.size();i++) tcount[t[i]]++;\\n        \\n        int left=0,right=0,letter=0;\\n        int ansright=100000,ansleft=1;\\n        \\n        //keep on increasing size of window \\n        for(int right=0;right<s.size();right++){\\n            //if relevant letter(also exists in t ) found in s ,\\n            //count the it\\n            if(tcount.find(s[right])!=tcount.end()){\\n                scount[s[right]]++;\\n                \\n                if(scount[s[right]]<=tcount[s[right]])\\n                    letter++;\\n            }\\n            \\n            //if more letters found in s  than required\\n            //try reducing size of the window \\n            if(letter>=t.size()){\\n                //leftmost element irrelevant(doesnt exist in s) or \\n                //leftmost element has more occurence in s \\n                while(tcount.find(s[left])==tcount.end() || scount[s[left]]>tcount[s[left]]){\\n                    scount[s[left]]--;\\n                    left++;\\n                }\\n                \\n                //update min indices \\n                if(right-left+1<ansright-ansleft+1)\\n                    ansright=right,ansleft=left;\\n            }\\n        }\\n        \\n        string res;\\n        if(ansright==100000) return \"\";\\n        for(int i=ansleft;i<=ansright;i++) res+=s[i];\\n        \\n        return res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    string minWindow(string s, string t) {\\n        \\n       if(s.size()<t.size()) return \"\";\\n        unordered_map<char,int> tcount;\\n        unordered_map<char,int> scount;\\n       \\n        for(int i=0;i<t.size();i++) tcount[t[i]]++;\\n        \\n        int left=0,right=0,letter=0;\\n        int ansright=100000,ansleft=1;\\n        \\n        //keep on increasing size of window \\n        for(int right=0;right<s.size();right++){\\n            //if relevant letter(also exists in t ) found in s ,\\n            //count the it\\n            if(tcount.find(s[right])!=tcount.end()){\\n                scount[s[right]]++;\\n                \\n                if(scount[s[right]]<=tcount[s[right]])\\n                    letter++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1916790,
                "title": "c-3-solutions-1-2-maps-1-array-o-n-time-easy-clean-code",
                "content": "**1. Using 2 unordered maps**\\nTime - O(n)\\nSpace - O(256) (max of 256 characters can be there in map)\\n```\\n    string minWindow(string s, string t) {\\n        \\n        int beg=0,mn=INT_MAX;\\n        int c=0,in=-1;\\n        int ns=s.length(),nt=t.length();\\n        unordered_map<char,int> m1,m2;\\n        int i;\\n        \\n        for(i=0;i<nt;i++)\\n            m1[t[i]]++;\\n        \\n        \\n        for(i=0;i<ns;i++)\\n        {\\n            if(c<nt)\\n            {\\n                m2[s[i]]++;\\n                \\n                if(m1.find(s[i])!=m1.end() && m2[s[i]]<=m1[s[i]])\\n                    c++;\\n            }\\n            \\n            while(c==nt && beg<=i)\\n            {\\n                if(i-beg+1<mn)\\n                {\\n                    mn=i-beg+1;\\n                    in=beg;\\n                }\\n                m2[s[beg]]--;\\n                \\n                if(m1.find(s[beg])!=m1.end() && m2[s[beg]]<m1[s[beg]])\\n                    c--;\\n                \\n                beg++;\\n            }\\n        }\\n        \\n        if(mn==INT_MAX)\\n            return \"\";\\n        \\n        return s.substr(in,mn);\\n    }\\n```\\n\\n**2. Using 1 unordered map**\\nTime - O(n)\\nSpace - O(256) (max of 256 characters can be there in map)\\n```\\n    string minWindow(string s, string t)\\n    {\\n        int ns=s.length(),nt=t.length();\\n        int c=0,beg=0;\\n        int mn=INT_MAX,in=-1;        \\n        int i;\\n        unordered_map<char,int> m;\\n        \\n        for(i=0;i<nt;i++)\\n            m[t[i]]++;\\n        \\n        for(i=0;i<ns;i++)\\n        {\\n            m[s[i]]--;\\n            \\n            if(m[s[i]]>=0)\\n                c++;\\n            \\n            while(c==nt && beg<=i)\\n            {\\n                if(i-beg+1<mn)\\n                {\\n                    mn=i-beg+1;\\n                    in=beg;\\n                }\\n                \\n                m[s[beg]]++;\\n                if(m[s[beg]]>0)\\n                    c--;\\n                \\n                beg++;\\n            }\\n        }\\n        \\n        if(mn==INT_MAX)\\n            return \"\";\\n        \\n        return s.substr(in,mn);\\n    }\\n```\\n\\n**3. Using freq array (fastest)**\\nTime - O(n)\\nSpace - O(256) (max of 256 characters can be there in map)\\n```\\n    string minWindow(string s, string t)\\n    {\\n        int ns=s.length(),nt=t.length();\\n        int c=0,beg=0;\\n        int mn=INT_MAX,in=-1;        \\n        int i;\\n        int f[256]={0};\\n        \\n        for(i=0;i<nt;i++)\\n            f[t[i]]++;\\n        \\n        for(i=0;i<ns;i++)\\n        {\\n            f[s[i]]--;\\n            \\n            if(f[s[i]]>=0)\\n                c++;\\n            \\n            while(c==nt && beg<=i)\\n            {\\n                if(i-beg+1<mn)\\n                {\\n                    mn=i-beg+1;\\n                    in=beg;\\n                }\\n                \\n                f[s[beg]]++;\\n                if(f[s[beg]]>0)\\n                    c--;\\n                \\n                beg++;\\n            }\\n        }\\n        \\n        if(mn==INT_MAX)\\n            return \"\";\\n        \\n        return s.substr(in,mn);\\n    }\\n```\\n\\n**Do share our views & upvote if you like !!!** \\uD83D\\uDE04",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\n    string minWindow(string s, string t) {\\n        \\n        int beg=0,mn=INT_MAX;\\n        int c=0,in=-1;\\n        int ns=s.length(),nt=t.length();\\n        unordered_map<char,int> m1,m2;\\n        int i;\\n        \\n        for(i=0;i<nt;i++)\\n            m1[t[i]]++;\\n        \\n        \\n        for(i=0;i<ns;i++)\\n        {\\n            if(c<nt)\\n            {\\n                m2[s[i]]++;\\n                \\n                if(m1.find(s[i])!=m1.end() && m2[s[i]]<=m1[s[i]])\\n                    c++;\\n            }\\n            \\n            while(c==nt && beg<=i)\\n            {\\n                if(i-beg+1<mn)\\n                {\\n                    mn=i-beg+1;\\n                    in=beg;\\n                }\\n                m2[s[beg]]--;\\n                \\n                if(m1.find(s[beg])!=m1.end() && m2[s[beg]]<m1[s[beg]])\\n                    c--;\\n                \\n                beg++;\\n            }\\n        }\\n        \\n        if(mn==INT_MAX)\\n            return \"\";\\n        \\n        return s.substr(in,mn);\\n    }\\n```\n```\\n    string minWindow(string s, string t)\\n    {\\n        int ns=s.length(),nt=t.length();\\n        int c=0,beg=0;\\n        int mn=INT_MAX,in=-1;        \\n        int i;\\n        unordered_map<char,int> m;\\n        \\n        for(i=0;i<nt;i++)\\n            m[t[i]]++;\\n        \\n        for(i=0;i<ns;i++)\\n        {\\n            m[s[i]]--;\\n            \\n            if(m[s[i]]>=0)\\n                c++;\\n            \\n            while(c==nt && beg<=i)\\n            {\\n                if(i-beg+1<mn)\\n                {\\n                    mn=i-beg+1;\\n                    in=beg;\\n                }\\n                \\n                m[s[beg]]++;\\n                if(m[s[beg]]>0)\\n                    c--;\\n                \\n                beg++;\\n            }\\n        }\\n        \\n        if(mn==INT_MAX)\\n            return \"\";\\n        \\n        return s.substr(in,mn);\\n    }\\n```\n```\\n    string minWindow(string s, string t)\\n    {\\n        int ns=s.length(),nt=t.length();\\n        int c=0,beg=0;\\n        int mn=INT_MAX,in=-1;        \\n        int i;\\n        int f[256]={0};\\n        \\n        for(i=0;i<nt;i++)\\n            f[t[i]]++;\\n        \\n        for(i=0;i<ns;i++)\\n        {\\n            f[s[i]]--;\\n            \\n            if(f[s[i]]>=0)\\n                c++;\\n            \\n            while(c==nt && beg<=i)\\n            {\\n                if(i-beg+1<mn)\\n                {\\n                    mn=i-beg+1;\\n                    in=beg;\\n                }\\n                \\n                f[s[beg]]++;\\n                if(f[s[beg]]>0)\\n                    c--;\\n                \\n                beg++;\\n            }\\n        }\\n        \\n        if(mn==INT_MAX)\\n            return \"\";\\n        \\n        return s.substr(in,mn);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1800028,
                "title": "c-sliding-window-two-pointers-clean-code",
                "content": "**Time Complexity : O ( n + m )\\nSpace Complexity : O ( n ) \\nRuntime : 68 ms \\nMemory : 8 MB**\\n\\n```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        \\n        int n=s.size();\\n        int m=t.size();\\n        string res=\"\";\\n        \\n        if(n<m)\\n            return res;\\n        \\n         map<char,int>patternHash,stringHash;\\n        for(auto it:t)\\n            patternHash[it]++;\\n        \\n        \\n        int i=0;\\n        int j=0;\\n        int count=0;\\n        int len=INT_MAX;\\n        int startIndex=-1;\\n        \\n        while(j<n)\\n        {\\n            stringHash[s[j]]++;\\n            \\n            if(stringHash[s[j]]<=patternHash[s[j]])\\n            {\\n                count++;\\n            }\\n            if(count==m)\\n            {\\n                \\n              //  cout<<i<<\" \"<<j<<endl;\\n                \\n                while(stringHash[s[i]]>patternHash[s[i]] or \\n                     patternHash[s[i]]==0)\\n                {\\n                    \\n                    if(stringHash[s[i]]>patternHash[s[i]])\\n                    stringHash[s[i]]--;\\n                    \\n                    i++;\\n                    \\n                }\\n                //cout<<i<<endl;\\n                \\n                int found=j-i+1;\\n                if(len>found)\\n                {\\n                    len=found;\\n                    startIndex=i;\\n                }\\n               \\n            }\\n            j++;\\n        }\\n        if(startIndex==-1)\\n            return \"\";\\n        // cout<<startIndex<<\" \"<<len<<endl;\\n        return s.substr(startIndex,len);\\n        \\n    }\\n};\\n```\\n\\n**Pls upvote the solution if you found helpful, it means a lot.\\nAlso comment down your doubts.\\nHappy Coding : )**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        \\n        int n=s.size();\\n        int m=t.size();\\n        string res=\"\";\\n        \\n        if(n<m)\\n            return res;\\n        \\n         map<char,int>patternHash,stringHash;\\n        for(auto it:t)\\n            patternHash[it]++;\\n        \\n        \\n        int i=0;\\n        int j=0;\\n        int count=0;\\n        int len=INT_MAX;\\n        int startIndex=-1;\\n        \\n        while(j<n)\\n        {\\n            stringHash[s[j]]++;\\n            \\n            if(stringHash[s[j]]<=patternHash[s[j]])\\n            {\\n                count++;\\n            }\\n            if(count==m)\\n            {\\n                \\n              //  cout<<i<<\" \"<<j<<endl;\\n                \\n                while(stringHash[s[i]]>patternHash[s[i]] or \\n                     patternHash[s[i]]==0)\\n                {\\n                    \\n                    if(stringHash[s[i]]>patternHash[s[i]])\\n                    stringHash[s[i]]--;\\n                    \\n                    i++;\\n                    \\n                }\\n                //cout<<i<<endl;\\n                \\n                int found=j-i+1;\\n                if(len>found)\\n                {\\n                    len=found;\\n                    startIndex=i;\\n                }\\n               \\n            }\\n            j++;\\n        }\\n        if(startIndex==-1)\\n            return \"\";\\n        // cout<<startIndex<<\" \"<<len<<endl;\\n        return s.substr(startIndex,len);\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1404614,
                "title": "c-sliding-window-easy-to-understand",
                "content": "**IDEA**\\nWe keep expanding the window by moving the right pointer. When the window has all the desired characters, we contract (if possible) and save the smallest window till now.\\n`The answer is the smallest desirable window.`\\n\\u200B\\n**EXAMPLE**\\nFor eg. `S = \"ABAACBAB\" T = \"ABC\"`. Then our answer window is `\"ACB\"` and shown below is one of the possible desirable windows.\\n![image](https://assets.leetcode.com/users/images/aa5e8ecb-faa5-4542-ba85-4c3c0b986b8d_1629012971.6332936.png)\\n\\n\\u200B**ALGORITHM**\\n* We start with two pointers, `leftleft` and `rightright` initially pointing to the first element of the string S.\\n* We use the `rightright pointer` to expand the window until we get a desirable window i.e. a window that contains all of the characters of T.\\n* Once we have a window with all the characters, we can move the left pointer ahead one by one. \\n\\t* \\tIf the window is still a desirable one we keep on updating the minimum window size.\\n\\t* \\tIf the window is not desirable any more, we repeat step 2 onwards.\\n\\n**SOLUTION**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n       unordered_map<char,int> mp;\\n        for(auto ch:t)\\n        {\\n            mp[ch]++;\\n        }\\n        int dist=mp.size() ;\\n        unordered_map<char,int> window;\\n        int count = 0 , ll = 0 , rr = 0 ;\\n        int l = 0 , r = 0 , ans = INT_MAX ;\\n        while(r<s.length())\\n        {\\n            window[s[r]]++ ;\\n            if(mp.count(s[r]) and mp[s[r]]==window[s[r]])\\n            {\\n                    count++;\\n            }\\n            r++;\\n            while(count == dist and l < r)\\n            {\\n                if(ans > r-l)\\n                {\\n                    ans= r - l ;\\n                    ll = l ;\\n                    rr = r ;\\n                }\\n                window[s[l]]-- ;\\n                if(mp.count(s[l]) and window[s[l]] < mp[s[l]])\\n                {\\n                        count--;\\n                }\\n                l++;\\n            }\\n        }\\n        return s.substr(ll,rr-ll);\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n       unordered_map<char,int> mp;\\n        for(auto ch:t)\\n        {\\n            mp[ch]++;\\n        }\\n        int dist=mp.size() ;\\n        unordered_map<char,int> window;\\n        int count = 0 , ll = 0 , rr = 0 ;\\n        int l = 0 , r = 0 , ans = INT_MAX ;\\n        while(r<s.length())\\n        {\\n            window[s[r]]++ ;\\n            if(mp.count(s[r]) and mp[s[r]]==window[s[r]])\\n            {\\n                    count++;\\n            }\\n            r++;\\n            while(count == dist and l < r)\\n            {\\n                if(ans > r-l)\\n                {\\n                    ans= r - l ;\\n                    ll = l ;\\n                    rr = r ;\\n                }\\n                window[s[l]]-- ;\\n                if(mp.count(s[l]) and window[s[l]] < mp[s[l]])\\n                {\\n                        count--;\\n                }\\n                l++;\\n            }\\n        }\\n        return s.substr(ll,rr-ll);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 960091,
                "title": "python-3",
                "content": "```\\ndef minWindow(self, s: str, t: str) -> str:\\n\\td=collections.Counter(t)\\n\\tbase=collections.Counter(s)\\n\\tfor x in d.keys():\\n\\t\\tif base[x]<d[x]:\\n\\t\\t\\treturn \"\"\\n\\tk=d.keys()\\n\\ti,j=0,0\\n\\tn=len(s)\\n\\tr=[0,0]\\n\\tans=n\\n\\tkey=[]\\n\\tres=[n-1,0]\\n\\twhile j<n:\\n\\t\\tif s[j] in k:\\n\\t\\t\\td[s[j]]-=1\\n\\t\\t\\tkey.append([s[j],j])\\n\\t\\t\\tif max(d.values())<=0:\\n\\t\\t\\t\\twhile d[key[0][0]]<0:\\n\\t\\t\\t\\t\\ttmp=key.pop(0)\\n\\t\\t\\t\\t\\td[tmp[0]]+=1\\n\\t\\t\\t\\t\\ti=tmp[1]+1\\n\\t\\t\\t\\tif key[-1][1]-key[0][1]+1<ans:\\n\\t\\t\\t\\t\\tans=key[-1][1]-key[0][1]+1\\n\\t\\t\\t\\t\\tres=[key[-1][1],key[0][1]]\\n\\t\\tj+=1\\n\\treturn s[res[1]:res[0]+1]\\n\\t```",
                "solutionTags": [],
                "code": "```\\ndef minWindow(self, s: str, t: str) -> str:\\n\\td=collections.Counter(t)\\n\\tbase=collections.Counter(s)\\n\\tfor x in d.keys():\\n\\t\\tif base[x]<d[x]:\\n\\t\\t\\treturn \"\"\\n\\tk=d.keys()\\n\\ti,j=0,0\\n\\tn=len(s)\\n\\tr=[0,0]\\n\\tans=n\\n\\tkey=[]\\n\\tres=[n-1,0]\\n\\twhile j<n:\\n\\t\\tif s[j] in k:\\n\\t\\t\\td[s[j]]-=1\\n\\t\\t\\tkey.append([s[j],j])\\n\\t\\t\\tif max(d.values())<=0:\\n\\t\\t\\t\\twhile d[key[0][0]]<0:\\n\\t\\t\\t\\t\\ttmp=key.pop(0)\\n\\t\\t\\t\\t\\td[tmp[0]]+=1\\n\\t\\t\\t\\t\\ti=tmp[1]+1\\n\\t\\t\\t\\tif key[-1][1]-key[0][1]+1<ans:\\n\\t\\t\\t\\t\\tans=key[-1][1]-key[0][1]+1\\n\\t\\t\\t\\t\\tres=[key[-1][1],key[0][1]]\\n\\t\\tj+=1\\n\\treturn s[res[1]:res[0]+1]\\n\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 670791,
                "title": "javascript-using-sliding-window-detailed-comments",
                "content": "```\\nvar minWindow = function(s, t) {\\n    \\n    /*\\n    \\n    Get the count of each character in t.\\n    \\n    Why? The count of each character indicates which character\\n\\tis found and not found when we expand and minimize the window.\\n    \\n    */\\n     \\n    const tCharsCount = {};\\n    \\n    for(const char of t) { \\n        tCharsCount[char] = 1 + (tCharsCount[char] || 0);\\n    }\\n    \\n    // Keep track of the number of characters we need to find in s.\\n    let numCharsToFind = t.length; \\n    \\n    // Keep track of the minimum length of the resulting substring.\\n    let minLen = Infinity;\\n    \\n    // Keep track of the start index of the resulting substring.\\n    let minStartIdx = 0;\\n    \\n    // Increasing \"start\" will minimize our window\\n    let start = 0;\\n    \\n    // Increasing \"end\" will help search for characters in s that exist in t\\n    let end = 0; \\n    \\n    \\n    // Search through s until we reach the end of s\\n    while(end < s.length) {\\n        \\n        /*\\n        \\n        If a letter in s at index \"end\" exists in t, \\n        we decrease the number of characters we need to find\\n        \\n        */\\n        \\n        const sChar = s[end]; \\n        \\n        if (tCharsCount[sChar] > 0) numCharsToFind--;\\n        \\n        \\n        /*\\n        \\n        We also decrease the count of the corresponding letter in our frequency counter. \\n        \\n        Why? Remember, this is a window. When we expand and minimize the size of the window, \\n        the number of characters left is an indicator of how many characters we need to find and have already found.\\n        \\n        */\\n        \\n        tCharsCount[sChar]--;\\n        \\n        end++; // continue exploring each character in s\\n        \\n        \\n        /*\\n        \\n        When we find all the characters, \"start\" through \"end\" will be our window of a substring that meets our requirements. \\n        Now we need to make sure the window is the MINIMUM length substring that meets our requirements. \\n        \\n        The following while loop will update \"minLen\" everytime we find a shorter length substring.\\n        We also minimize our window by increasing \"start\".\\n        \\n        */\\n        \\n        while(numCharsToFind === 0) {\\n            \\n            // Update our minimum length and starting index if the window is a smaller window than the previous.\\n            const windowLength = end - start;\\n            \\n            if (windowLength < minLen) {\\n                minLen = windowLength;\\n                minStartIdx = start;\\n            }\\n            \\n            /*\\n            \\n            Now we need to minimize the window starting at the \"start\" index of s.\\n            For each index in s, we increase the count of a letter if it\\'s a letter in t, \\n            and increase the number of characters we need to find overall.\\n            \\n            Why? Each time we minimize our window, the number of characters that we need to find increases too. \\n            As our window travels through s, each iteration needs information on what character has been found and not found. \\n            \\n            \\n            */\\n    \\n            const sChar = s[start];\\n            \\n            /*  increase the count of character (if it exists in t) \\n            because we lose a character each time we minimize the window */\\n            tCharsCount[sChar]++;\\n            \\n            /*  increase the overall number of characters to find\\n            in the next window search (if char is in t) */\\n            if (tCharsCount[sChar] > 0) numCharsToFind++;\\n            \\n            // minimize window\\n            start++; \\n        }\\n    }\\n    \\n    // If we found a substring return the substring at the starting index with a minimum length.\\n    return minLen === Infinity ? \"\" : s.substr(minStartIdx, minLen);\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nvar minWindow = function(s, t) {\\n    \\n    /*\\n    \\n    Get the count of each character in t.\\n    \\n    Why? The count of each character indicates which character\\n\\tis found and not found when we expand and minimize the window.\\n    \\n    */\\n     \\n    const tCharsCount = {};\\n    \\n    for(const char of t) { \\n        tCharsCount[char] = 1 + (tCharsCount[char] || 0);\\n    }\\n    \\n    // Keep track of the number of characters we need to find in s.\\n    let numCharsToFind = t.length; \\n    \\n    // Keep track of the minimum length of the resulting substring.\\n    let minLen = Infinity;\\n    \\n    // Keep track of the start index of the resulting substring.\\n    let minStartIdx = 0;\\n    \\n    // Increasing \"start\" will minimize our window\\n    let start = 0;\\n    \\n    // Increasing \"end\" will help search for characters in s that exist in t\\n    let end = 0; \\n    \\n    \\n    // Search through s until we reach the end of s\\n    while(end < s.length) {\\n        \\n        /*\\n        \\n        If a letter in s at index \"end\" exists in t, \\n        we decrease the number of characters we need to find\\n        \\n        */\\n        \\n        const sChar = s[end]; \\n        \\n        if (tCharsCount[sChar] > 0) numCharsToFind--;\\n        \\n        \\n        /*\\n        \\n        We also decrease the count of the corresponding letter in our frequency counter. \\n        \\n        Why? Remember, this is a window. When we expand and minimize the size of the window, \\n        the number of characters left is an indicator of how many characters we need to find and have already found.\\n        \\n        */\\n        \\n        tCharsCount[sChar]--;\\n        \\n        end++; // continue exploring each character in s\\n        \\n        \\n        /*\\n        \\n        When we find all the characters, \"start\" through \"end\" will be our window of a substring that meets our requirements. \\n        Now we need to make sure the window is the MINIMUM length substring that meets our requirements. \\n        \\n        The following while loop will update \"minLen\" everytime we find a shorter length substring.\\n        We also minimize our window by increasing \"start\".\\n        \\n        */\\n        \\n        while(numCharsToFind === 0) {\\n            \\n            // Update our minimum length and starting index if the window is a smaller window than the previous.\\n            const windowLength = end - start;\\n            \\n            if (windowLength < minLen) {\\n                minLen = windowLength;\\n                minStartIdx = start;\\n            }\\n            \\n            /*\\n            \\n            Now we need to minimize the window starting at the \"start\" index of s.\\n            For each index in s, we increase the count of a letter if it\\'s a letter in t, \\n            and increase the number of characters we need to find overall.\\n            \\n            Why? Each time we minimize our window, the number of characters that we need to find increases too. \\n            As our window travels through s, each iteration needs information on what character has been found and not found. \\n            \\n            \\n            */\\n    \\n            const sChar = s[start];\\n            \\n            /*  increase the count of character (if it exists in t) \\n            because we lose a character each time we minimize the window */\\n            tCharsCount[sChar]++;\\n            \\n            /*  increase the overall number of characters to find\\n            in the next window search (if char is in t) */\\n            if (tCharsCount[sChar] > 0) numCharsToFind++;\\n            \\n            // minimize window\\n            start++; \\n        }\\n    }\\n    \\n    // If we found a substring return the substring at the starting index with a minimum length.\\n    return minLen === Infinity ? \"\" : s.substr(minStartIdx, minLen);\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 590806,
                "title": "c-sliding-window",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring minWindow(string s, string t) {\\n\\t\\t\\tunordered_map<char,int> need;\\n\\t\\t\\tunordered_map<char,int> wind;\\n\\t\\t\\tstring ans=\"\";\\n\\t\\t\\tint temp=INT_MAX;\\n\\n\\t\\t\\tfor(int i=0;i<t.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tneed[t[i]]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tint match=0;\\n\\n\\t\\t\\tint right=0;\\n\\t\\t\\tint left=0;\\n\\t\\t\\twhile(right<s.size())\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(need.count(s[right]))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\twind[s[right]]++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif(need.count(s[right]) && wind[s[right]]==need[s[right]])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmatch++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\twhile(match==need.size() && left<=right)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(temp>right-left+1)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ttemp=right-left+1;\\n\\t\\t\\t\\t\\t\\tans=s.substr(left,right-left+1);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(need.count(s[left]))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\twind[s[left]]--;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t//automatically add keys to need if don\\'t use need.count(s[left])\\n\\t\\t\\t\\t\\tif(need.count(s[left]) && wind[s[left]]<need[s[left]])// super nasty bug \\n\\t\\t\\t\\t\\t{\\n\\n\\t\\t\\t\\t\\t\\tmatch--;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tleft++;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tright++;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring minWindow(string s, string t) {\\n\\t\\t\\tunordered_map<char,int> need;\\n\\t\\t\\tunordered_map<char,int> wind;\\n\\t\\t\\tstring ans=\"\";\\n\\t\\t\\tint temp=INT_MAX;\\n\\n\\t\\t\\tfor(int i=0;i<t.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tneed[t[i]]++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 568718,
                "title": "readable-kotlin-solution",
                "content": "```\\nclass Solution {\\n    fun minWindow(string: String, t: String): String {\\n        val charFreqInWindow = mutableMapOf<Char, Int>()\\n        val charFreqInT = t.groupingBy { it }.eachCount().toMutableMap()\\n\\n        var result = \"\"\\n        var start = 0\\n        var end = 0\\n        \\n        while(end < string.count()) {\\n            charFreqInWindow.add(string[end++])\\n            \\n            if(charFreqInWindow.containsAllChars(charFreqInT)) {\\n                while(charFreqInWindow.containsAllChars(charFreqInT)) charFreqInWindow.subtract(string[start++])\\n                \\n                if(result == \"\" || end - start < result.count()) result = string.substring(start - 1, end)    \\n            }\\n        }\\n        \\n        return result\\n    }\\n    \\n    fun MutableMap<Char, Int>.add(char: Char) = add(char, 1)\\n    fun MutableMap<Char, Int>.subtract(char: Char) { \\n        if(get(char) == 1) remove(char) else add(char, -1) \\n    }\\n    fun MutableMap<Char, Int>.add(char: Char, count: Int) = put(char, getOrElse(char) { 0 } + count)\\n    fun MutableMap<Char, Int>.containsAllChars(other: Map<Char, Int>) = other.all { (char, count) ->\\n        count <= get(char) ?: 0\\n    }\\n}\\n```\\n\\nI have used this basic pattern for all vairable length sliding window problems I have encounterd.  There was a post a while back about the pattern but I have not been able to find the link after 15 minutes.  You can use Kotlin\\'s windowed() function for fixed length ones.  \\n\\nSometimes solutions posted on this platform are very concise and fine for competitive programming but sacrifice readability.  I feel that this solution gives a good balance of readability, without comments, while still being pretty concise.  However, it is not the fastest solution.",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun minWindow(string: String, t: String): String {\\n        val charFreqInWindow = mutableMapOf<Char, Int>()\\n        val charFreqInT = t.groupingBy { it }.eachCount().toMutableMap()\\n\\n        var result = \"\"\\n        var start = 0\\n        var end = 0\\n        \\n        while(end < string.count()) {\\n            charFreqInWindow.add(string[end++])\\n            \\n            if(charFreqInWindow.containsAllChars(charFreqInT)) {\\n                while(charFreqInWindow.containsAllChars(charFreqInT)) charFreqInWindow.subtract(string[start++])\\n                \\n                if(result == \"\" || end - start < result.count()) result = string.substring(start - 1, end)    \\n            }\\n        }\\n        \\n        return result\\n    }\\n    \\n    fun MutableMap<Char, Int>.add(char: Char) = add(char, 1)\\n    fun MutableMap<Char, Int>.subtract(char: Char) { \\n        if(get(char) == 1) remove(char) else add(char, -1) \\n    }\\n    fun MutableMap<Char, Int>.add(char: Char, count: Int) = put(char, getOrElse(char) { 0 } + count)\\n    fun MutableMap<Char, Int>.containsAllChars(other: Map<Char, Int>) = other.all { (char, count) ->\\n        count <= get(char) ?: 0\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 568132,
                "title": "c-sliding-window-solution",
                "content": "\\n**Complexity**\\n* Time: O(N + M) where N is the length of string s, M is the length of string t. Each character in s and t will be visited once.\\n* Space: O(M). dictionary will hold characters of string t.\\n\\n```\\npublic class Solution {\\n    public string MinWindow(string s, string t) {\\n        \\n        Dictionary<char,int> dic = new Dictionary<char,int>();\\n        foreach(char c in t)\\n        {\\n            if(dic.ContainsKey(c))\\n                dic[c]++;\\n            else\\n                dic.Add(c, 1);\\n        }\\n        \\n        int left = 0, right = 0, minlen = s.Length + 1, counter = dic.Count;\\n        string res = \"\";\\n        \\n        while(right < s.Length)\\n        {\\n            char rightChar = s[right];\\n            if(dic.ContainsKey(rightChar))\\n            {\\n                dic[rightChar]--;\\n                if(dic[rightChar] == 0)\\n                    counter--;\\n            }\\n            right++;\\n            \\n            while(counter == 0)\\n            {\\n                if(right - left < minlen)\\n                {\\n                    minlen = right - left;\\n                    res = s.Substring(left, minlen);\\n                }\\n                char leftChar = s[left];\\n                if(dic.ContainsKey(leftChar))\\n                {\\n                    dic[leftChar]++;\\n                    if(dic[leftChar] > 0)\\n                        counter++;\\n                }       \\n                left++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n\\nSolution is similar to [438. Find All Anagrams in a String](https://leetcode.com/problems/find-all-anagrams-in-a-string/)",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string MinWindow(string s, string t) {\\n        \\n        Dictionary<char,int> dic = new Dictionary<char,int>();\\n        foreach(char c in t)\\n        {\\n            if(dic.ContainsKey(c))\\n                dic[c]++;\\n            else\\n                dic.Add(c, 1);\\n        }\\n        \\n        int left = 0, right = 0, minlen = s.Length + 1, counter = dic.Count;\\n        string res = \"\";\\n        \\n        while(right < s.Length)\\n        {\\n            char rightChar = s[right];\\n            if(dic.ContainsKey(rightChar))\\n            {\\n                dic[rightChar]--;\\n                if(dic[rightChar] == 0)\\n                    counter--;\\n            }\\n            right++;\\n            \\n            while(counter == 0)\\n            {\\n                if(right - left < minlen)\\n                {\\n                    minlen = right - left;\\n                    res = s.Substring(left, minlen);\\n                }\\n                char leftChar = s[left];\\n                if(dic.ContainsKey(leftChar))\\n                {\\n                    dic[leftChar]++;\\n                    if(dic[leftChar] > 0)\\n                        counter++;\\n                }       \\n                left++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 540289,
                "title": "c",
                "content": "```\\npublic class Solution {\\n    public string MinWindow(string s, string t) {\\n        Dictionary<char, int> table = new Dictionary<char, int>();\\n\\n            // initialize frequency table for t\\n            foreach (char c in t)\\n            {\\n                if (table.ContainsKey(c))\\n                {\\n                    table[c]++;\\n                }\\n                else\\n                {\\n                    table.Add(c, 1);\\n                }\\n            }\\n\\n            // initialize sliding window\\n            int begin = 0, end = 0;\\n            int counter = table.Count;\\n            int len = int.MaxValue;\\n\\n            string ans = \"\";\\n\\n            // start sliding window\\n            while (end < s.Length)\\n            {\\n                char endchar = s[end];\\n\\n                // if current char found in table, decrement count\\n                if (table.ContainsKey(endchar))\\n                {\\n                    table[endchar]--;\\n                    if (table[endchar] == 0) counter--;\\n                }\\n\\n                end++;\\n                while (counter == 0)\\n                {\\n                    if (end - begin < len)\\n                    {\\n                        len = end - begin;\\n                        ans = s.Substring(begin, end - begin);\\n                    }\\n                    char startchar = s[begin];\\n\\n                    if (table.ContainsKey(startchar))\\n                    {\\n                        table[startchar]++;\\n                        if (table[startchar] > 0) counter++;\\n                    }\\n\\n                    begin++;\\n                }\\n            }\\n\\n            return ans;\\n\\n    }    \\n  \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string MinWindow(string s, string t) {\\n        Dictionary<char, int> table = new Dictionary<char, int>();\\n\\n            // initialize frequency table for t\\n            foreach (char c in t)\\n            {\\n                if (table.ContainsKey(c))\\n                {\\n                    table[c]++;\\n                }\\n                else\\n                {\\n                    table.Add(c, 1);\\n                }\\n            }\\n\\n            // initialize sliding window\\n            int begin = 0, end = 0;\\n            int counter = table.Count;\\n            int len = int.MaxValue;\\n\\n            string ans = \"\";\\n\\n            // start sliding window\\n            while (end < s.Length)\\n            {\\n                char endchar = s[end];\\n\\n                // if current char found in table, decrement count\\n                if (table.ContainsKey(endchar))\\n                {\\n                    table[endchar]--;\\n                    if (table[endchar] == 0) counter--;\\n                }\\n\\n                end++;\\n                while (counter == 0)\\n                {\\n                    if (end - begin < len)\\n                    {\\n                        len = end - begin;\\n                        ans = s.Substring(begin, end - begin);\\n                    }\\n                    char startchar = s[begin];\\n\\n                    if (table.ContainsKey(startchar))\\n                    {\\n                        table[startchar]++;\\n                        if (table[startchar] > 0) counter++;\\n                    }\\n\\n                    begin++;\\n                }\\n            }\\n\\n            return ans;\\n\\n    }    \\n  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 310344,
                "title": "java-faster-than-96-95",
                "content": "*Marked region can help you to understand the code.*\\nThe time complexity is O(n(traverse)+n(minimize)) = O(2n) = O(n)\\n\\nThe main idea is:\\n1. Use window(here is two pointer) to include all the pattern(t).\\n2. Once the window contains all the pattern(t). Minimize the window.\\n3. Once we release the recording-buffer(HashMap), which means we can search the next possibility.\\n\\nFor example:\\ns: A C B A B C\\nt: A B\\nbuffer: (A, 1), (B, 1)\\n\\ni=0\\nleft = 0\\ns: [(A)] C B A B C\\nmap: (A, 1-1=0), (B, 1)\\n\\ni=1\\nleft = 0\\ns: (A) [C] B A B C\\nmap: (A, 0), (B, 1)\\n\\ni=2\\nleft = 0\\ns: (A) C [B] A B C\\nmap: (A, 0), (B, 1-1=0)\\n[Notice] All of values in the map is being taken. \\nStart Minimize\\n{\\nleft = 0\\nword = s.charAt(left)\\ns: (A) C [B] A B C\\nmap[word] = map[word]+1 // release\\nif map[word]>0, which means we currently find the possible solution. \\nRecord it and move the left pointer to the next. \\ncurrent: A C B\\n}\\n\\ni=3\\nleft = 1\\ns: A (C) B [A] B C\\nmap: (A, 1-1=0), (B, 0)\\ncurrent: A C B\\nStart Minimize\\n{\\nleft = 1\\nword = s.charAt(left)\\ns: A (C) B [A] B C\\nmap[word] = map[word]+1 // release, if matched\\n\\nleft = 2\\nword = s.charAt(left)\\ns: A C (B) [A] B C\\nmap[word] = map[word]+1 // release, matched \\'B\\'\\nif map[word]>0, which means we currently find the possible solution. \\nRecord it and move the left pointer to the next. \\nRecording: len(B A) is less than the current.\\ncurrent = B A\\n}\\n\\ni=4\\nleft = 3\\ns: A C B (A) [B] C\\nmap: (A, 0), (B, 0)\\ncurrent: B A\\nMinimize {\\ns: A C B (A) [B] C\\nmap: (A, 0+1=1), (B, 0)\\nrecording: A B\\nlen(A B) is not less than the current.\\n}\\n\\ni=5\\nleft = 4\\ns: A C B A (B) [C]\\nmap: (A, 1), (B, 0)\\ncurrent: B A\\nBecause [C] is not in the map, so we move right pointer i to the next i=6.\\ni>s.length(), jump out the loop.\\n\\nResult: B A\\n\\n```\\nclass Solution {\\n    public String minWindow(String s, String t) {\\n        // HashMap<Character, Integer> map = new HashMap<>();\\n        int[] map = new int[128];\\n        for (char c : t.toCharArray()) {\\n            // map.put(c, map.getOrDefault(c, 0)+1);\\n            map[c] += 1;\\n        }\\n        int begin = 0;\\n        int len = Integer.MAX_VALUE;\\n        int count = t.length();\\n        for (int left=0, right=0; right<s.length(); right++) {\\n            char c = s.charAt(right);\\n            // if (map.containsKey(c)) {\\n            //     map.replace(c, map.get(c)-1);\\n            //     if (map.get(c)>=0)\\n            //         count--;\\n            // }\\n            map[c]--;\\n            if(map[c]>=0) count--; \\n            while (count == 0) {\\n                char lc = s.charAt(left);\\n                // if (map.containsKey(lc)) {\\n                //     if (right-left+1<len) {\\n                //         begin = left;\\n                //         len = right-left+1;\\n                //     }\\n                //     map.replace(lc, map.get(lc)+1);\\n                //     if (map.get(lc)>0) count++;\\n                // }\\n                map[lc]++;\\n                if (map[lc]>0) {\\n                    if (right-left+1<len) {\\n                        begin = left;\\n                        len = right-left+1;\\n                    }\\n                    count++;\\n                }\\n                left++;\\n            }\\n        }\\n        return len==Integer.MAX_VALUE?\"\":s.substring(begin, begin+len);\\n    }\\n}\\n```\\nhere is clean version:\\n```\\nclass Solution {\\n    public String minWindow(String s, String t) {\\n        int[] map = new int[128];\\n        for (char c : t.toCharArray()) {\\n            map[c] += 1;\\n        }\\n        int begin = 0;\\n        int len = Integer.MAX_VALUE;\\n        int count = t.length();\\n        for (int left=0, right=0; right<s.length(); right++) {\\n            char c = s.charAt(right);\\n            map[c]--;\\n            if(map[c]>=0) count--; \\n            while (count == 0) {\\n                char lc = s.charAt(left);\\n                map[lc]++;\\n                if (map[lc]>0) {\\n                    if (right-left+1<len) {\\n                        begin = left;\\n                        len = right-left+1;\\n                    }\\n                    count++;\\n                }\\n                left++;\\n            }\\n        }\\n        return len==Integer.MAX_VALUE?\"\":s.substring(begin, begin+len);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public String minWindow(String s, String t) {\\n        // HashMap<Character, Integer> map = new HashMap<>();\\n        int[] map = new int[128];\\n        for (char c : t.toCharArray()) {\\n            // map.put(c, map.getOrDefault(c, 0)+1);\\n            map[c] += 1;\\n        }\\n        int begin = 0;\\n        int len = Integer.MAX_VALUE;\\n        int count = t.length();\\n        for (int left=0, right=0; right<s.length(); right++) {\\n            char c = s.charAt(right);\\n            // if (map.containsKey(c)) {\\n            //     map.replace(c, map.get(c)-1);\\n            //     if (map.get(c)>=0)\\n            //         count--;\\n            // }\\n            map[c]--;\\n            if(map[c]>=0) count--; \\n            while (count == 0) {\\n                char lc = s.charAt(left);\\n                // if (map.containsKey(lc)) {\\n                //     if (right-left+1<len) {\\n                //         begin = left;\\n                //         len = right-left+1;\\n                //     }\\n                //     map.replace(lc, map.get(lc)+1);\\n                //     if (map.get(lc)>0) count++;\\n                // }\\n                map[lc]++;\\n                if (map[lc]>0) {\\n                    if (right-left+1<len) {\\n                        begin = left;\\n                        len = right-left+1;\\n                    }\\n                    count++;\\n                }\\n                left++;\\n            }\\n        }\\n        return len==Integer.MAX_VALUE?\"\":s.substring(begin, begin+len);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String minWindow(String s, String t) {\\n        int[] map = new int[128];\\n        for (char c : t.toCharArray()) {\\n            map[c] += 1;\\n        }\\n        int begin = 0;\\n        int len = Integer.MAX_VALUE;\\n        int count = t.length();\\n        for (int left=0, right=0; right<s.length(); right++) {\\n            char c = s.charAt(right);\\n            map[c]--;\\n            if(map[c]>=0) count--; \\n            while (count == 0) {\\n                char lc = s.charAt(left);\\n                map[lc]++;\\n                if (map[lc]>0) {\\n                    if (right-left+1<len) {\\n                        begin = left;\\n                        len = right-left+1;\\n                    }\\n                    count++;\\n                }\\n                left++;\\n            }\\n        }\\n        return len==Integer.MAX_VALUE?\"\":s.substring(begin, begin+len);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 304161,
                "title": "python3-sliding-window",
                "content": "## Thought process\\n- extend `end` to right\\n- check whether the condition is satisfied\\n\\t- if satisfied, try to shrink the window by moving `start` index to right\\n\\t- when satisfied, update the length and result\\n\\t- when not satisfied again -> continue extending `end`\\n\\n- use a counter for the frequency of characters\\n- use another counter to record how many unique characters have been matched (satisfied the requirements)\\n\\n```py\\nclass Solution:\\n    def minWindow(self, s: str, t: str) -> str:\\n        candidates = collections.Counter(t)\\n        required = len(candidates)\\n        matched = 0\\n        counter = collections.Counter()\\n        min_length = float(\\'inf\\')\\n        res = \"\"\\n        start = 0\\n        \\n        for end, c in enumerate(s):\\n            if c in candidates:\\n                counter[c] += 1\\n                if counter[c] == candidates[c]:\\n                    matched += 1\\n            while matched == required:\\n                if end - start + 1 < min_length:\\n                    res = s[start:end+1]\\n                    min_length = end - start + 1\\n                if s[start] in candidates:\\n                    counter[s[start]] -= 1\\n                    if counter[s[start]] < candidates[s[start]]:\\n                        matched -= 1\\n                start += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```py\\nclass Solution:\\n    def minWindow(self, s: str, t: str) -> str:\\n        candidates = collections.Counter(t)\\n        required = len(candidates)\\n        matched = 0\\n        counter = collections.Counter()\\n        min_length = float(\\'inf\\')\\n        res = \"\"\\n        start = 0\\n        \\n        for end, c in enumerate(s):\\n            if c in candidates:\\n                counter[c] += 1\\n                if counter[c] == candidates[c]:\\n                    matched += 1\\n            while matched == required:\\n                if end - start + 1 < min_length:\\n                    res = s[start:end+1]\\n                    min_length = end - start + 1\\n                if s[start] in candidates:\\n                    counter[s[start]] -= 1\\n                    if counter[s[start]] < candidates[s[start]]:\\n                        matched -= 1\\n                start += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294874,
                "title": "swift-solution",
                "content": "```\\nclass Solution {\\n    func minWindow(_ s: String, _ t: String) -> String {\\n        var needMap = [Character:Int]()\\n        for char in s {\\n            needMap[char] = 0\\n        }\\n        for char in t {\\n            if needMap[char] != nil {\\n                needMap[char] = needMap[char]! + 1\\n            }\\n            else {\\n                 needMap[char] = 1\\n            }\\n        }\\n        \\n        var start = 0\\n        var end = 0\\n        var minLength = Int.max\\n        var minStart = 0\\n        var missing = t.count\\n        var s = Array(s)\\n        \\n        while(end < s.count) {\\n            let current = s[end]\\n            if(needMap[current]! > 0) {\\n                missing -= 1\\n            }\\n            needMap[current] = needMap[current]! - 1\\n            \\n            while(missing == 0) {\\n                if(minLength > end - start + 1) {\\n                    minLength =  end - start + 1\\n                    minStart = start\\n                }\\n                \\n                let head = s[start]\\n                if(needMap[head]! >= 0) {\\n                    missing += 1\\n                }\\n                needMap[head] = needMap[head]! + 1\\n                start += 1\\n            }\\n            end += 1\\n        }\\n        \\n        return minLength == Int.max ? \"\" : String(s[minStart..<minStart + minLength])\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minWindow(_ s: String, _ t: String) -> String {\\n        var needMap = [Character:Int]()\\n        for char in s {\\n            needMap[char] = 0\\n        }\\n        for char in t {\\n            if needMap[char] != nil {\\n                needMap[char] = needMap[char]! + 1\\n            }\\n            else {\\n                 needMap[char] = 1\\n            }\\n        }\\n        \\n        var start = 0\\n        var end = 0\\n        var minLength = Int.max\\n        var minStart = 0\\n        var missing = t.count\\n        var s = Array(s)\\n        \\n        while(end < s.count) {\\n            let current = s[end]\\n            if(needMap[current]! > 0) {\\n                missing -= 1\\n            }\\n            needMap[current] = needMap[current]! - 1\\n            \\n            while(missing == 0) {\\n                if(minLength > end - start + 1) {\\n                    minLength =  end - start + 1\\n                    minStart = start\\n                }\\n                \\n                let head = s[start]\\n                if(needMap[head]! >= 0) {\\n                    missing += 1\\n                }\\n                needMap[head] = needMap[head]! + 1\\n                start += 1\\n            }\\n            end += 1\\n        }\\n        \\n        return minLength == Int.max ? \"\" : String(s[minStart..<minStart + minLength])\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 238043,
                "title": "python-solution",
                "content": "We use the sliding window approach. We first use a dictionary `dicT` to count the number of occurrences of each character in `t`. We initialize two pointers `i = 0`, `j = 0`. We iterate `i` in `range(len(s))`, and maintain a dictionary `dicS` which counts the number of occurrences of characters in `s[j:i+1]` that also appear in `t`. We also maintain a hashset `rec`, which records the characters `char` in `s[j:i+1]` that has `dicS[char] >= dicT[char]`.\\n\\nWe can deduce whether `s[j:i+1]` contains all the characters in `t` by checking if `len(rec) == len(dicT)`. Once this condition holds, we know `s[j:i+1]` contains all the characters in `t` (and probably more), so we can move the left pointer `j` to the right and update `dicS` and `rec` each step if necessary, until `len(rec) < len(dicT)`. Then we know that `s[j-1:i+1]` is minimum window ending with `s[j]` that contains all the characters in `t`. By taking the minimum over `i` of all minimum windows, we get the minimum window in `s` which contains all the characters in `t`.\\n\\nTime complexity: `O(len(s)+len(t))`, space complexity: `O(len(s)+len(t))`.\\n\\n```\\nclass Solution:\\n    def minWindow(self, s, t):\\n        \"\"\"\\n        :type s: str\\n        :type t: str\\n        :rtype: str\\n        \"\"\"\\n        dicT = collections.Counter(t)\\n        dicS = {}\\n        rec = set()\\n        j = 0\\n        res = float(\\'inf\\')\\n        for i, c in enumerate(s):\\n            if c not in dicS:\\n                dicS[c] = 1\\n            else:\\n                dicS[c] += 1\\n            if c in dicT and dicT[c] <= dicS[c]:\\n                rec.add(c)\\n                while len(rec) == len(dicT):\\n                    dicS[s[j]] -= 1\\n                    if s[j] in dicT and dicT[s[j]] > dicS[s[j]]:\\n                        rec.remove(s[j])\\n                        if res > i-j+1:\\n                            start = j\\n                            end = i\\n                            res = i-j+1\\n                    j += 1\\n        if res == float(\\'inf\\'):\\n            return \"\"\\n        return s[start:end+1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minWindow(self, s, t):\\n        \"\"\"\\n        :type s: str\\n        :type t: str\\n        :rtype: str\\n        \"\"\"\\n        dicT = collections.Counter(t)\\n        dicS = {}\\n        rec = set()\\n        j = 0\\n        res = float(\\'inf\\')\\n        for i, c in enumerate(s):\\n            if c not in dicS:\\n                dicS[c] = 1\\n            else:\\n                dicS[c] += 1\\n            if c in dicT and dicT[c] <= dicS[c]:\\n                rec.add(c)\\n                while len(rec) == len(dicT):\\n                    dicS[s[j]] -= 1\\n                    if s[j] in dicT and dicT[s[j]] > dicS[s[j]]:\\n                        rec.remove(s[j])\\n                        if res > i-j+1:\\n                            start = j\\n                            end = i\\n                            res = i-j+1\\n                    j += 1\\n        if res == float(\\'inf\\'):\\n            return \"\"\\n        return s[start:end+1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 198126,
                "title": "a-question-about-using-intvalue",
                "content": "If I don\\'t use intValue(), I will pass 267/268. But why?  \\nI think java should help me with autoboxing and unboxing.\\nThx!\\n```\\nclass Solution {\\n    int minLength = Integer.MAX_VALUE;\\n    int minLeft = 0, minRight = 0;\\n    \\n    public String minWindow(String s, String t) {\\n        HashMap<Character, Integer> dict = new HashMap<Character, Integer>();\\n        for (char c : t.toCharArray()) {\\n            dict.put(c, dict.getOrDefault(c, 0) + 1);\\n        }\\n        int sizeDict = dict.size();\\n        \\n        HashMap<Character, Integer> count = new HashMap<Character, Integer>();\\n        int left = 0;\\n        int formed = 0;\\n        \\n        for (int right = 0; right < s.length(); right++) {\\n            char rightChar = s.charAt(right);\\n            count.put(rightChar, count.getOrDefault(rightChar, 0) + 1);\\n            if (dict.containsKey(rightChar) && count.get(rightChar).intValue() == dict.get(rightChar).intValue()) {\\n                formed++;\\n            }\\n            while (left <= right && formed == sizeDict) {\\n                char leftChar = s.charAt(left);\\n                if (formed == sizeDict) {\\n                    if (minLength > right - left + 1) {\\n                        minLength = right - left + 1;\\n                        minLeft = left;\\n                        minRight = right;\\n                    }\\n                }\\n                count.put(leftChar, count.get(leftChar) - 1);\\n                if (dict.containsKey(leftChar) && count.get(leftChar).intValue() < dict.get(leftChar).intValue()) {\\n                    formed--;\\n                }\\n                left++;\\n            }\\n        }\\n        return minLength == Integer.MAX_VALUE ? \"\" : s.substring(minLeft, minRight + 1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int minLength = Integer.MAX_VALUE;\\n    int minLeft = 0, minRight = 0;\\n    \\n    public String minWindow(String s, String t) {\\n        HashMap<Character, Integer> dict = new HashMap<Character, Integer>();\\n        for (char c : t.toCharArray()) {\\n            dict.put(c, dict.getOrDefault(c, 0) + 1);\\n        }\\n        int sizeDict = dict.size();\\n        \\n        HashMap<Character, Integer> count = new HashMap<Character, Integer>();\\n        int left = 0;\\n        int formed = 0;\\n        \\n        for (int right = 0; right < s.length(); right++) {\\n            char rightChar = s.charAt(right);\\n            count.put(rightChar, count.getOrDefault(rightChar, 0) + 1);\\n            if (dict.containsKey(rightChar) && count.get(rightChar).intValue() == dict.get(rightChar).intValue()) {\\n                formed++;\\n            }\\n            while (left <= right && formed == sizeDict) {\\n                char leftChar = s.charAt(left);\\n                if (formed == sizeDict) {\\n                    if (minLength > right - left + 1) {\\n                        minLength = right - left + 1;\\n                        minLeft = left;\\n                        minRight = right;\\n                    }\\n                }\\n                count.put(leftChar, count.get(leftChar) - 1);\\n                if (dict.containsKey(leftChar) && count.get(leftChar).intValue() < dict.get(leftChar).intValue()) {\\n                    formed--;\\n                }\\n                left++;\\n            }\\n        }\\n        return minLength == Integer.MAX_VALUE ? \"\" : s.substring(minLeft, minRight + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 144396,
                "title": "o-n-sliding-window-solution-with-explanation",
                "content": "I keep a count of the count of letters in T. I also keep a count of letters in our sliding window.  We add characters to the end of the sliding window until we contain all or more characters than T.  The comparison in hasAllIn takes 58 steps which is a constant growth rate of O(1) and we go through the loop N times.  While our sliding windows contains all or more characters than T we keep popping off the front and decrementing the character\\'s counts until it doesn\\'t (until hasAllIn fails). I keeping track of our minimum length start and finish (Be careful not to compute the substring here, .substring is O(n)). Repeat until we\\'ve checked every place.\\n\\nI used 58 because the ascii values from A-z range between 58 values.  If the input could include anything you could use 128 without affecting the growth rate.\\n```\\nclass Solution {\\n    public String minWindow(String s, String t) {\\n        int[] count = new int[58];\\n        int [] tCount = new int[58];\\n        Deque<Character> window = new LinkedList<>();\\n        for(Character c: t.toCharArray()){\\n            ++tCount[c-\\'A\\'];\\n        }\\n        int minStart=0;\\n        int minEnd=0;\\n        int min=Integer.MAX_VALUE;\\n        int start=0;\\n        for(int i=0; i<s.length();++i){\\n            char c = s.charAt(i);\\n            window.addLast(c);\\n            ++count[c-\\'A\\'];\\n            while(hasAllIn(count,tCount)){\\n                if(i-start<min){\\n                    minEnd=i;\\n                    minStart=start;\\n                    min=i-start;\\n                }\\n                char old = window.removeFirst();\\n                --count[old-\\'A\\'];\\n                ++start;\\n            }\\n        }\\n        if(min==Integer.MAX_VALUE)return \"\";\\n        return s.substring(minStart,minEnd+1);\\n    }\\n    public boolean hasAllIn(int[] one, int[] two){\\n        for(int i=0; i<58;++i){\\n            if(one[i]<two[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String minWindow(String s, String t) {\\n        int[] count = new int[58];\\n        int [] tCount = new int[58];\\n        Deque<Character> window = new LinkedList<>();\\n        for(Character c: t.toCharArray()){\\n            ++tCount[c-\\'A\\'];\\n        }\\n        int minStart=0;\\n        int minEnd=0;\\n        int min=Integer.MAX_VALUE;\\n        int start=0;\\n        for(int i=0; i<s.length();++i){\\n            char c = s.charAt(i);\\n            window.addLast(c);\\n            ++count[c-\\'A\\'];\\n            while(hasAllIn(count,tCount)){\\n                if(i-start<min){\\n                    minEnd=i;\\n                    minStart=start;\\n                    min=i-start;\\n                }\\n                char old = window.removeFirst();\\n                --count[old-\\'A\\'];\\n                ++start;\\n            }\\n        }\\n        if(min==Integer.MAX_VALUE)return \"\";\\n        return s.substring(minStart,minEnd+1);\\n    }\\n    public boolean hasAllIn(int[] one, int[] two){\\n        for(int i=0; i<58;++i){\\n            if(one[i]<two[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 26822,
                "title": "share-my-o-n-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        unordered_map<char, int>m;\\n        int i = 0, j = 0, count = 0, minLen = INT_MAX;\\n        string res = \"\";\\n        for(auto x: t) m[x]++, count++;\\n        while(j < s.size()){\\n            if(m[s[j++]]-- > 0) count--;\\n            if(count == 0){\\n                while(m[s[i]] < 0) m[s[i++]]++;\\n                int len = j - i;\\n                if(len < minLen){\\n                    minLen = len;\\n                    res = s.substr(i, len);\\n                }\\n                m[s[i++]]++;\\n                count++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        unordered_map<char, int>m;\\n        int i = 0, j = 0, count = 0, minLen = INT_MAX;\\n        string res = \"\";\\n        for(auto x: t) m[x]++, count++;\\n        while(j < s.size()){\\n            if(m[s[j++]]-- > 0) count--;\\n            if(count == 0){\\n                while(m[s[i]] < 0) m[s[i++]]++;\\n                int len = j - i;\\n                if(len < minLen){\\n                    minLen = len;\\n                    res = s.substr(i, len);\\n                }\\n                m[s[i++]]++;\\n                count++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 26922,
                "title": "python-in-o-n-with-2-pointers",
                "content": "\\n    def minWindow(self, s, t):\\n        count = 0\\n        m = {}\\n        for c in t:\\n            if c not in m:\\n                count += 1\\n                m[c] = 0\\n            m[c] += 1\\n        \\n        start = 0\\n        size = len(s)\\n        ansLen = size + 1\\n        ans = ''\\n        for end in xrange(size):\\n            if s[end] not in m:\\n                continue\\n            m[s[end]] -= 1\\n            if m[s[end]] == 0:\\n                count -= 1\\n                \\n            while count == 0:\\n                if end - start + 1 < ansLen:\\n                    ansLen = end-start+1\\n                    ans = s[start:end+1]\\n                startC = s[start]\\n                start += 1\\n                if startC not in m:\\n                    continue\\n                m[startC] += 1\\n                if m[startC] == 1:\\n                    count += 1\\n                    break\\n                    \\n        if ansLen == size + 1:\\n            return ''\\n        return ans",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "\\n    def minWindow(self, s, t):\\n        count = 0\\n        m = {}\\n        for c in t:\\n            if c not in m:\\n                count += 1\\n                m[c] = 0\\n            m[c] += 1\\n        \\n        start = 0\\n        size = len(s)\\n        ansLen = size + 1\\n        ans = ''\\n        for end in xrange(size):\\n            if s[end] not in m:\\n                continue\\n            m[s[end]] -= 1\\n            if m[s[end]] == 0:\\n                count -= 1\\n                \\n            while count == 0:\\n                if end - start + 1 < ansLen:\\n                    ansLen = end-start+1\\n                    ans = s[start:end+1]\\n                startC = s[start]\\n                start += 1\\n                if startC not in m:\\n                    continue\\n                m[startC] += 1\\n                if m[startC] == 1:\\n                    count += 1\\n                    break\\n                    \\n        if ansLen == size + 1:\\n            return ''\\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 26955,
                "title": "clear-java-solution-with-explanation",
                "content": "Use a map to store <char,int> pair from T, name it pattern.\\n\\nUse a map to store <char, int> pair from S, name it cur (current set).\\n\\nFind a match when each char->int in cur is no less than each char->int in pattern!\\n\\nUse a queue to keep track of all valid character positions. Go through String S, once a valid character was met, enqueue. Once a matched pattern and cur was found, dequeue.\\n\\n    public class Solution {\\n        public String minWindow(String S, String T) {\\n            Map<Character, Integer> pattern = new HashMap<Character, Integer>();\\n            Map<Character, Integer> cur = new HashMap<Character, Integer>();\\n            Queue<Integer> queue = new LinkedList<Integer>();\\n            int min = Integer.MAX_VALUE;\\n            int begin = 0, end = 0;\\n            \\n            // fill in pattern by T\\n            for(int i = 0;i < T.length();i++) addToMap(pattern, T.charAt(i));\\n            \\n            // initialize current set\\n            for(int i = 0;i < T.length();i++) cur.put(T.charAt(i), 0);\\n            \\n            // go through S to match the pattern by minimum length\\n            for(int i = 0;i < S.length();i++){\\n                if(pattern.containsKey(S.charAt(i))){\\n                    queue.add(i);\\n                    addToMap(cur, S.charAt(i));\\n                    // check if pattern is matched\\n                    while(isMatch(pattern, cur)){  /* Important Code! */\\n                        if(i - queue.peek() < min){\\n                            min = i - queue.peek();\\n                            begin = queue.peek();\\n                            end = i+1;\\n                        }\\n                        cur.put(S.charAt(queue.peek()), cur.get(S.charAt(queue.peek()))-1);\\n                        queue.poll();\\n                    }\\n                }\\n            }\\n            \\n            return end > begin?S.substring(begin, end):\"\";\\n        }\\n        \\n        private void addToMap(Map<Character, Integer> map, Character c){\\n            if(map.containsKey(c))\\n                map.put(c, map.get(c)+1);\\n            else\\n                map.put(c,1);\\n        }\\n        \\n        private boolean isMatch(Map<Character, Integer> p, Map<Character, Integer> cur){\\n            for(Map.Entry<Character, Integer> entry: p.entrySet())\\n                if(cur.get((char)entry.getKey()) < (int)entry.getValue()) return false;\\n            return true;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public String minWindow(String S, String T) {\\n            Map<Character, Integer> pattern = new HashMap<Character, Integer>();\\n            Map<Character, Integer> cur = new HashMap<Character, Integer>();\\n            Queue<Integer> queue = new LinkedList<Integer>();\\n            int min = Integer.MAX_VALUE;\\n            int begin = 0, end = 0;\\n            \\n            // fill in pattern by T\\n            for(int i = 0;i < T.length();i++) addToMap(pattern, T.charAt(i));\\n            \\n            // initialize current set\\n            for(int i = 0;i < T.length();i++) cur.put(T.charAt(i), 0);\\n            \\n            // go through S to match the pattern by minimum length\\n            for(int i = 0;i < S.length();i++){\\n                if(pattern.containsKey(S.charAt(i))){\\n                    queue.add(i);\\n                    addToMap(cur, S.charAt(i));\\n                    // check if pattern is matched\\n                    while(isMatch(pattern, cur)){  /* Important Code! */\\n                        if(i - queue.peek() < min){\\n                            min = i - queue.peek();\\n                            begin = queue.peek();\\n                            end = i+1;\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 3787365,
                "title": "sliding-window-easy-java-solution-clean-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public String minWindow(String s, String t) {\\n        \\n        HashMap<Character, Integer> map = new HashMap<>();\\n        int start = 0;\\n        int end = 0;\\n        int count = 0;\\n        StringBuilder ans = new StringBuilder();\\n        int min = Integer.MAX_VALUE;\\n\\n        for(int i = 0; i < t.length(); i++) {\\n            if(map.containsKey(t.charAt(i))) {\\n                map.put(t.charAt(i), map.get(t.charAt(i)) + 1);\\n            }\\n            else {\\n                map.put(t.charAt(i), 1);\\n                count++;\\n            }\\n        }\\n\\n        while(end < s.length()) {\\n            char chEnd = s.charAt(end);\\n            if(map.containsKey(chEnd)) {\\n                map.put(chEnd, map.get(chEnd) - 1);\\n                if(map.get(chEnd) == 0) {\\n                    count--;\\n                }\\n            }\\n\\n            if(count == 0) {\\n                while(count == 0) {\\n                    if(map.containsKey(s.charAt(start))) {\\n                        if(map.get(s.charAt(start)) < 0) {\\n                            map.put(s.charAt(start), map.get(s.charAt(start)) + 1);\\n                        }\\n                        else if(map.get(s.charAt(start)) == 0) {\\n                            if(end - start + 1 < min) {\\n                                min = end - start + 1;\\n                                ans.setLength(0);\\n                                for(int i = start; i < end + 1; i++) {\\n                                    ans.append(s.charAt(i));\\n                                }\\n                            }\\n                            map.put(s.charAt(start), map.get(s.charAt(start)) + 1);\\n                            if(map.get(s.charAt(start)) == 1) {\\n                                count++;\\n                            }\\n                        }\\n                    }\\n                    start++;\\n                }\\n            }\\n            end++;\\n        }\\n        return ans.toString();\\n    }\\n}\\n```\\n\\n![cat.jpeg](https://assets.leetcode.com/users/images/11a6b25d-fa54-42db-9ab7-4996ef15fa35_1689764966.3548434.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String minWindow(String s, String t) {\\n        \\n        HashMap<Character, Integer> map = new HashMap<>();\\n        int start = 0;\\n        int end = 0;\\n        int count = 0;\\n        StringBuilder ans = new StringBuilder();\\n        int min = Integer.MAX_VALUE;\\n\\n        for(int i = 0; i < t.length(); i++) {\\n            if(map.containsKey(t.charAt(i))) {\\n                map.put(t.charAt(i), map.get(t.charAt(i)) + 1);\\n            }\\n            else {\\n                map.put(t.charAt(i), 1);\\n                count++;\\n            }\\n        }\\n\\n        while(end < s.length()) {\\n            char chEnd = s.charAt(end);\\n            if(map.containsKey(chEnd)) {\\n                map.put(chEnd, map.get(chEnd) - 1);\\n                if(map.get(chEnd) == 0) {\\n                    count--;\\n                }\\n            }\\n\\n            if(count == 0) {\\n                while(count == 0) {\\n                    if(map.containsKey(s.charAt(start))) {\\n                        if(map.get(s.charAt(start)) < 0) {\\n                            map.put(s.charAt(start), map.get(s.charAt(start)) + 1);\\n                        }\\n                        else if(map.get(s.charAt(start)) == 0) {\\n                            if(end - start + 1 < min) {\\n                                min = end - start + 1;\\n                                ans.setLength(0);\\n                                for(int i = start; i < end + 1; i++) {\\n                                    ans.append(s.charAt(i));\\n                                }\\n                            }\\n                            map.put(s.charAt(start), map.get(s.charAt(start)) + 1);\\n                            if(map.get(s.charAt(start)) == 1) {\\n                                count++;\\n                            }\\n                        }\\n                    }\\n                    start++;\\n                }\\n            }\\n            end++;\\n        }\\n        return ans.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483872,
                "title": "aditya-verma-c",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n         unordered_map<char, int> mp;\\n        for(auto it:t){\\n            mp[it]++;\\n        }\\n        int cnt=mp.size();\\n\\n        string ans=\"\";\\n        int len=INT_MAX;\\n        int i=0, j=0;\\n        int n=s.size();\\n        while(j<n){\\n            if(mp.count(s[j])>0){\\n                mp[s[j]]--;\\n                if(mp[s[j]]==0){\\n                    cnt--;\\n                }\\n            }\\n            if(cnt==0){\\n                if(len>j-i+1){\\n                    ans = s.substr(i, j-i+1);\\n                    len = ans.size();\\n                }\\n                while(cnt==0){\\n                    if(mp.count(s[i])>0){\\n                        mp[s[i]]++;\\n                        if(mp[s[i]]==1){\\n                            cnt++;\\n                            if(len>j-i+1){\\n                    ans = s.substr(i, j-i+1);\\n                    len = ans.size();\\n                }\\n                        }\\n                    }\\n                    i++;\\n                }\\n                \\n                j++;\\n            }\\n            else{\\n                j++;\\n            }\\n\\n        }\\n       \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n         unordered_map<char, int> mp;\\n        for(auto it:t){\\n            mp[it]++;\\n        }\\n        int cnt=mp.size();\\n\\n        string ans=\"\";\\n        int len=INT_MAX;\\n        int i=0, j=0;\\n        int n=s.size();\\n        while(j<n){\\n            if(mp.count(s[j])>0){\\n                mp[s[j]]--;\\n                if(mp[s[j]]==0){\\n                    cnt--;\\n                }\\n            }\\n            if(cnt==0){\\n                if(len>j-i+1){\\n                    ans = s.substr(i, j-i+1);\\n                    len = ans.size();\\n                }\\n                while(cnt==0){\\n                    if(mp.count(s[i])>0){\\n                        mp[s[i]]++;\\n                        if(mp[s[i]]==1){\\n                            cnt++;\\n                            if(len>j-i+1){\\n                    ans = s.substr(i, j-i+1);\\n                    len = ans.size();\\n                }\\n                        }\\n                    }\\n                    i++;\\n                }\\n                \\n                j++;\\n            }\\n            else{\\n                j++;\\n            }\\n\\n        }\\n       \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3289819,
                "title": "easy-acquire-release-approach-detailed-explanation",
                "content": "# Intuition\\nThe idea is to solve the problem using Acquire and Release approach. Here, we will keep on acquring characters till we meet the requirements and then release.\\n\\n# Approach\\n\\n**DS used and their purpose :**\\n```\\nString ans = \"\";                 // -> to store the answer.\\nint i = -1;                     //  -> 1st pointer\\nint j = -1;                    //  -> 1st pointer\\nint matchCount = 0;       // -> to keep a count of matching conditions\\nint reqCount = t.length(); // -> count of required conditiongs \\nHashMap<Character,Integer> map2 // -> frequency map of String t\\nHashMap<Character,Integer> map1 // -> explained below :)\\n```\\n**Part 1 :**\\n```\\nHashMap<Character, Integer> map2 = new HashMap<>();\\n        for(char ch : t.toCharArray()) {\\n            map2.put(ch, map2.getOrDefault(ch, 0) + 1);\\n        }\\n```\\n\\nThis part simples creates a frequency map for String t. This will be used to compare whether we meet the conditions or not. conditions being we match the frequency of each char.\\n\\n**Part 2 :**\\n```\\n// acquire\\nwhile(i<s.length()-1 && matchCount < reqCount) {\\n    i++;\\n    char ch = s.charAt(i);\\n    map1.put(ch, map1.getOrDefault(ch, 0) + 1);\\n\\n    if(map1.getOrDefault(ch, 0) <= map2.getOrDefault(ch, 0)) {\\n        matchCount++;\\n    }\\n\\n    flag1 = true;\\n}\\n```\\nThis is the Acquire part. Here we simply, add a element in the map1 and check if matches the requirements or not. Suppose, t = \"ABC\", and we just put A in the map. So we needed an A, so if its the first A, then it helps to meet the requirements and therefore we will increase the matchCount. Because matchCount is keeping track of the requirements. When matchCount becomes equal to reqCount, we get a potential answer. \\n\\nThat is what the if condition does. It checks whether the character add was required or not. \\n\\nThis while loop breaks when we matchcount == reqcount.\\n\\n**Part 3 :**\\n\\n```\\n// collect answer\\nString pans = s.substring(j+1, i+1);\\nif(ans.length()==0 || pans.length()<ans.length()){\\n    ans = pans;\\n}\\n\\n```\\nHere, we collect the answer.  j = -1, and i is now at the last index of a possible answer. \\n\\nThe if condition here updates the answer if we find a smaller answer.\\n\\n**Part 4 :**\\n\\n```\\n// release\\nj++;\\nchar ch = s.charAt(j);\\nif(map1.get(ch) == 1) {\\n    map1.remove(ch);\\n}\\nelse {\\n    map1.put(ch, map1.get(ch)-1);\\n}\\n\\nif(map1.getOrDefault(ch,0) < map2.getOrDefault(ch,0)) {\\n    matchCount--;\\n}\\n\\nflag2 = true;\\n}\\n```\\n\\nThis is the release part. When a potential answer is found, its time to release chars and find a smaller answer. So we increment j and decrease its count. Now we have to check if we violated our requirments. So the if condition does that. If it violates, we decrement matchCount--.\\n\\n\\n**Hope this helps\\u2764\\uFE0F**\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public String minWindow(String s, String t) {\\n        String ans = \"\";\\n        int matchCount = 0;\\n        int reqCount = t.length();\\n        int i = -1;\\n        int j = -1;\\n\\n        HashMap<Character, Integer> map2 = new HashMap<>();\\n        for(char ch : t.toCharArray()) {\\n            map2.put(ch, map2.getOrDefault(ch, 0) + 1);\\n        }\\n        HashMap<Character,Integer> map1 = new HashMap<>();\\n    \\n        while(true) {\\n\\n            boolean flag1 = false;\\n            boolean flag2 = false; \\n\\n            //acquire\\n            while(i<s.length()-1 && matchCount < reqCount) {\\n                i++;\\n                char ch = s.charAt(i);\\n                map1.put(ch, map1.getOrDefault(ch, 0) + 1);\\n\\n                if(map1.getOrDefault(ch, 0) <= map2.getOrDefault(ch, 0)) {\\n                    matchCount++;\\n                }\\n\\n                flag1 = true;\\n            }\\n\\n            //Collect answer and release\\n            while(j < i && matchCount == reqCount) {\\n\\n                // collect answer\\n                String pans = s.substring(j+1, i+1);\\n                if(ans.length()==0 || pans.length()<ans.length()){\\n                    ans = pans;\\n                }\\n\\n                // release\\n                j++;\\n                char ch = s.charAt(j);\\n                if(map1.get(ch) == 1) {\\n                    map1.remove(ch);\\n                }\\n                else {\\n                    map1.put(ch, map1.get(ch)-1);\\n                }\\n\\n                if(map1.getOrDefault(ch,0) < map2.getOrDefault(ch,0)) {\\n                    matchCount--;\\n                }\\n\\n                flag2 = true;\\n            }\\n\\n            if(flag1 == false && flag2 == false) {\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Sliding Window",
                    "Counting"
                ],
                "code": "```\\nString ans = \"\";                 // -> to store the answer.\\nint i = -1;                     //  -> 1st pointer\\nint j = -1;                    //  -> 1st pointer\\nint matchCount = 0;       // -> to keep a count of matching conditions\\nint reqCount = t.length(); // -> count of required conditiongs \\nHashMap<Character,Integer> map2 // -> frequency map of String t\\nHashMap<Character,Integer> map1 // -> explained below :)\\n```\n```\\nHashMap<Character, Integer> map2 = new HashMap<>();\\n        for(char ch : t.toCharArray()) {\\n            map2.put(ch, map2.getOrDefault(ch, 0) + 1);\\n        }\\n```\n```\\n// acquire\\nwhile(i<s.length()-1 && matchCount < reqCount) {\\n    i++;\\n    char ch = s.charAt(i);\\n    map1.put(ch, map1.getOrDefault(ch, 0) + 1);\\n\\n    if(map1.getOrDefault(ch, 0) <= map2.getOrDefault(ch, 0)) {\\n        matchCount++;\\n    }\\n\\n    flag1 = true;\\n}\\n```\n```\\n// collect answer\\nString pans = s.substring(j+1, i+1);\\nif(ans.length()==0 || pans.length()<ans.length()){\\n    ans = pans;\\n}\\n\\n```\n```\\n// release\\nj++;\\nchar ch = s.charAt(j);\\nif(map1.get(ch) == 1) {\\n    map1.remove(ch);\\n}\\nelse {\\n    map1.put(ch, map1.get(ch)-1);\\n}\\n\\nif(map1.getOrDefault(ch,0) < map2.getOrDefault(ch,0)) {\\n    matchCount--;\\n}\\n\\nflag2 = true;\\n}\\n```\n```\\nclass Solution {\\n    public String minWindow(String s, String t) {\\n        String ans = \"\";\\n        int matchCount = 0;\\n        int reqCount = t.length();\\n        int i = -1;\\n        int j = -1;\\n\\n        HashMap<Character, Integer> map2 = new HashMap<>();\\n        for(char ch : t.toCharArray()) {\\n            map2.put(ch, map2.getOrDefault(ch, 0) + 1);\\n        }\\n        HashMap<Character,Integer> map1 = new HashMap<>();\\n    \\n        while(true) {\\n\\n            boolean flag1 = false;\\n            boolean flag2 = false; \\n\\n            //acquire\\n            while(i<s.length()-1 && matchCount < reqCount) {\\n                i++;\\n                char ch = s.charAt(i);\\n                map1.put(ch, map1.getOrDefault(ch, 0) + 1);\\n\\n                if(map1.getOrDefault(ch, 0) <= map2.getOrDefault(ch, 0)) {\\n                    matchCount++;\\n                }\\n\\n                flag1 = true;\\n            }\\n\\n            //Collect answer and release\\n            while(j < i && matchCount == reqCount) {\\n\\n                // collect answer\\n                String pans = s.substring(j+1, i+1);\\n                if(ans.length()==0 || pans.length()<ans.length()){\\n                    ans = pans;\\n                }\\n\\n                // release\\n                j++;\\n                char ch = s.charAt(j);\\n                if(map1.get(ch) == 1) {\\n                    map1.remove(ch);\\n                }\\n                else {\\n                    map1.put(ch, map1.get(ch)-1);\\n                }\\n\\n                if(map1.getOrDefault(ch,0) < map2.getOrDefault(ch,0)) {\\n                    matchCount--;\\n                }\\n\\n                flag2 = true;\\n            }\\n\\n            if(flag1 == false && flag2 == false) {\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3188315,
                "title": "python-easy-sliding-window-dictionary",
                "content": "```\\nclass Solution:\\n    def minWindow(self, s: str, t: str) -> str:\\n        d=Counter(t)\\n        c=len(d)\\n        i=start=0\\n        n=len(s)\\n        ans=n+1\\n        for j in range(n):\\n            if s[j] in d:\\n                d[s[j]]-=1\\n                if d[s[j]]==0:\\n                    c-=1            \\n            while c==0:\\n                if ans>j-i+1:\\n                    ans=j-i+1\\n                    start=i\\n                if s[i] in d:\\n                    d[s[i]]+=1\\n                    if d[s[i]]>0:\\n                        c+=1\\n                i+=1\\n        if ans>n:\\n            return \"\"\\n        return s[start:start+ans]\\n```\\n\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def minWindow(self, s: str, t: str) -> str:\\n        d=Counter(t)\\n        c=len(d)\\n        i=start=0\\n        n=len(s)\\n        ans=n+1\\n        for j in range(n):\\n            if s[j] in d:\\n                d[s[j]]-=1\\n                if d[s[j]]==0:\\n                    c-=1            \\n            while c==0:\\n                if ans>j-i+1:\\n                    ans=j-i+1\\n                    start=i\\n                if s[i] in d:\\n                    d[s[i]]+=1\\n                    if d[s[i]]>0:\\n                        c+=1\\n                i+=1\\n        if ans>n:\\n            return \"\"\\n        return s[start:start+ans]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2967615,
                "title": "c-optimized-sliding-window-map-detail-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Sliding Window (Type : variable window)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n##### ***\\u2705 Use of unordered map***\\n- Traverse \\'t\\' and find the count of all characters\\n\\n##### ***\\u2705 Use of \\'startIndex\\' and \\'endIndex\\' variable***\\n- we are storing start and end indexes of answer string\\n- to later on return the string\\n\\n##### ***\\u2705 Use of \\'size\\' and \\'minSize\\' variable***\\n- To find minimum window substring, \\n- We have to compare between sizes\\n\\n##### ***\\u2705 Use of \\'Bool Flag\\' variable***\\n- 1 :-\\n- If here \\'flag == false\\', means we never actually got answer window\\n- so because of that, now the valuse in \\'startIndex\\', \\'endIndex\\' are\\n- 0 and 0 (The values they are intialized with) so return empty string\\n- 2 :-\\n- Else here \\'flag == true\\' means we actually got answer window\\n- so use \\'startIndex\\' and \\'endIndex\\' to find Answer substring\\n\\n***If you find this helpful, Please Upvote \\uD83D\\uDD3C\\nThank You !***\\n\\n### ***C++ Code :***\\n```\\nclass Solution {\\npublic:\\n    \\n    string minWindow(string s, string t) {\\n        \\n        // Base Case\\n        if(s.length() < t.length()) return \"\";\\n        \\n        unordered_map<char, int> m;\\n        for(int i=0; i<t.length(); i++) m[t[i]]++;\\n        int count = m.size();\\n        \\n        int startIndex = 0, endIndex = 0;\\n        bool flag = false;\\n        \\n        int size;\\n        int minSize = INT_MAX;\\n        \\n        int i=0, j=0;\\n        while(j<s.length()) {\\n            \\n            // if(m[s[j]] > 0) { // Dont check like this (in this Que)\\n            // bcoz here, we are going to use \\'negative count\\' of key as well\\n            if( m.find(s[j]) != m.end() ) { // check like this\\n                m[s[j]]--; // using \\'j\\' pointer\\n                if(m[s[j]] == 0) count--;\\n            }\\n            \\n            if(count == 0) {\\n                \\n                while(count == 0) {\\n                    if( m.find(s[i]) != m.end() ) { // Check with \\'i\\' pointer\\n                        m[s[i]]++;\\n                        if(m[s[i]] == 1) count++;\\n                    }\\n                    i++;\\n                }\\n                \\n                size = j-i; // Actually it is : size = j-(i-1)+1;\\n                \\n                // change value of \\'startIndex\\' & \\'endIndex\\' only when\\n                // \\'size\\' is less than \\'minSize\\'\\n                if(size < minSize) {\\n                    minSize = size;\\n                    startIndex = i-1;\\n                    endIndex = j;\\n                    \\n                    flag = true;\\n                }\\n            }\\n            j++;\\n        }\\n        \\n        if(flag == false) return \"\";\\n        \\n        return s.substr(startIndex, endIndex-startIndex+1);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    string minWindow(string s, string t) {\\n        \\n        // Base Case\\n        if(s.length() < t.length()) return \"\";\\n        \\n        unordered_map<char, int> m;\\n        for(int i=0; i<t.length(); i++) m[t[i]]++;\\n        int count = m.size();\\n        \\n        int startIndex = 0, endIndex = 0;\\n        bool flag = false;\\n        \\n        int size;\\n        int minSize = INT_MAX;\\n        \\n        int i=0, j=0;\\n        while(j<s.length()) {\\n            \\n            // if(m[s[j]] > 0) { // Dont check like this (in this Que)\\n            // bcoz here, we are going to use \\'negative count\\' of key as well\\n            if( m.find(s[j]) != m.end() ) { // check like this\\n                m[s[j]]--; // using \\'j\\' pointer\\n                if(m[s[j]] == 0) count--;\\n            }\\n            \\n            if(count == 0) {\\n                \\n                while(count == 0) {\\n                    if( m.find(s[i]) != m.end() ) { // Check with \\'i\\' pointer\\n                        m[s[i]]++;\\n                        if(m[s[i]] == 1) count++;\\n                    }\\n                    i++;\\n                }\\n                \\n                size = j-i; // Actually it is : size = j-(i-1)+1;\\n                \\n                // change value of \\'startIndex\\' & \\'endIndex\\' only when\\n                // \\'size\\' is less than \\'minSize\\'\\n                if(size < minSize) {\\n                    minSize = size;\\n                    startIndex = i-1;\\n                    endIndex = j;\\n                    \\n                    flag = true;\\n                }\\n            }\\n            j++;\\n        }\\n        \\n        if(flag == false) return \"\";\\n        \\n        return s.substr(startIndex, endIndex-startIndex+1);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2964273,
                "title": "properly-commented-c-solution-sliding-window-algorithm-beats-100-in-both-t-and-s",
                "content": "# Intuition\\nSliding Window Algorithm\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nProperly commented (Approach)\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(128) constant\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// CONDITION : 1. Minimum Window (j - i + 1)\\n//             2. All of t should be in s (Which we can track using \\n// counter)\\nclass Solution {\\n    public:\\n    string minWindow(string s, string t) {\\n        int m[128] = {};\\n\\n        // Storing all characters into a map\\n        for(auto x : t) m[x]++;\\n\\n        // Counter: Stores how many characters we need to make a valid window\\n        int i = 0, j = 0, start = 0, len = INT_MAX, counter = t.size(), n = s.size(); \\n        \\n        // check for every valid index\\n        while(j < n){\\n            //! j calculations\\n            // if the current element exists in t: then the counter will decrease...\\n            if(m[s[j]] > 0) counter--;\\n\\n            // if the current element doesn\\'t exist in t: then m[s[j]] will be negative: if it exists, then it can be positive\\n            m[s[j]]--;            \\n\\n            // If you found the valid window\\n            while(counter == 0){\\n                if(len > j - i + 1){\\n                    len = j - i + 1;\\n                    start = i;\\n                }\\n\\n                // Shrinking: Window\\n                //! Removing i\\'s calculations\\n                // If s[i] exist in the target string then, it will be perfect zero... now, after increment, it will become +ve\\n                // If s[i] doesn\\'t exist in the target string, then its already will be negative: as it was never incremented in first for \"for loop\" before while one. \\n                // Also, it was decremented in the while loop. So, m[s[i]] will surely be negative.\\n                \\n                // But s[i] which exist in the target string will become positive. As we skipped the s[i] character so we will increment the counter as we need s[i] later to make a valid window. \\n                m[s[i]]++;\\n\\n                // If m[s[i]] becomes positive, only we will increase the counter as we are sliding the window.\\n                if(m[s[i]] > 0) counter++;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return len == INT_MAX ? \"\" : s.substr(start, len);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\n// CONDITION : 1. Minimum Window (j - i + 1)\\n//             2. All of t should be in s (Which we can track using \\n// counter)\\nclass Solution {\\n    public:\\n    string minWindow(string s, string t) {\\n        int m[128] = {};\\n\\n        // Storing all characters into a map\\n        for(auto x : t) m[x]++;\\n\\n        // Counter: Stores how many characters we need to make a valid window\\n        int i = 0, j = 0, start = 0, len = INT_MAX, counter = t.size(), n = s.size(); \\n        \\n        // check for every valid index\\n        while(j < n){\\n            //! j calculations\\n            // if the current element exists in t: then the counter will decrease...\\n            if(m[s[j]] > 0) counter--;\\n\\n            // if the current element doesn\\'t exist in t: then m[s[j]] will be negative: if it exists, then it can be positive\\n            m[s[j]]--;            \\n\\n            // If you found the valid window\\n            while(counter == 0){\\n                if(len > j - i + 1){\\n                    len = j - i + 1;\\n                    start = i;\\n                }\\n\\n                // Shrinking: Window\\n                //! Removing i\\'s calculations\\n                // If s[i] exist in the target string then, it will be perfect zero... now, after increment, it will become +ve\\n                // If s[i] doesn\\'t exist in the target string, then its already will be negative: as it was never incremented in first for \"for loop\" before while one. \\n                // Also, it was decremented in the while loop. So, m[s[i]] will surely be negative.\\n                \\n                // But s[i] which exist in the target string will become positive. As we skipped the s[i] character so we will increment the counter as we need s[i] later to make a valid window. \\n                m[s[i]]++;\\n\\n                // If m[s[i]] becomes positive, only we will increase the counter as we are sliding the window.\\n                if(m[s[i]] > 0) counter++;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return len == INT_MAX ? \"\" : s.substr(start, len);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2733556,
                "title": "python-most-efficient-98-fast-99-memory-short-with-easy-explanation",
                "content": "\\n```\\ndef minWindow(self, s: str, t: str) -> str:\\n        if t == \"\": return t\\n        countT, window = defaultdict(int), defaultdict(int)\\n        for c in t: # store required dict\\n            countT[c]+=1\\n            \\n        l = 0 # left of current window   \\n        have, need = 0, len(countT) # unique char, have and need\\n        min_window = float(\\'inf\\') \\n        res = [-1, -1]\\n        \\n        for r in range(len(s)): # for every char in s\\n            char = s[r]\\n            window[char]+=1 # add char in window\\n            \\n            # if char is our need and if we get exact count required, increment have\\n            if char in countT and window[char]==countT[char]:\\n                have +=1\\n            \\n            # while we have all needed -  shrink window from left to get best, store min length\\n            while have == need:\\n                \\n                # store minimum window\\n                if (r-l+1) < min_window:\\n                    min_window = (r-l+1)\\n                    res = [l, r]\\n                \\n                window[s[l]]-=1\\n                # decrement have if removed char was needed and its cnt less that required\\n                if s[l] in countT and window[s[l]]<countT[s[l]]:\\n                    have-=1\\n                # shrink more\\n                l+=1\\n        l, r = res\\n        return s[l:r+1] if min_window!= float(\\'inf\\') else \"\"\\n```",
                "solutionTags": [
                    "Python",
                    "Hash Table",
                    "Two Pointers"
                ],
                "code": "```\\ndef minWindow(self, s: str, t: str) -> str:\\n        if t == \"\": return t\\n        countT, window = defaultdict(int), defaultdict(int)\\n        for c in t: # store required dict\\n            countT[c]+=1\\n            \\n        l = 0 # left of current window   \\n        have, need = 0, len(countT) # unique char, have and need\\n        min_window = float(\\'inf\\') \\n        res = [-1, -1]\\n        \\n        for r in range(len(s)): # for every char in s\\n            char = s[r]\\n            window[char]+=1 # add char in window\\n            \\n            # if char is our need and if we get exact count required, increment have\\n            if char in countT and window[char]==countT[char]:\\n                have +=1\\n            \\n            # while we have all needed -  shrink window from left to get best, store min length\\n            while have == need:\\n                \\n                # store minimum window\\n                if (r-l+1) < min_window:\\n                    min_window = (r-l+1)\\n                    res = [l, r]\\n                \\n                window[s[l]]-=1\\n                # decrement have if removed char was needed and its cnt less that required\\n                if s[l] in countT and window[s[l]]<countT[s[l]]:\\n                    have-=1\\n                # shrink more\\n                l+=1\\n        l, r = res\\n        return s[l:r+1] if min_window!= float(\\'inf\\') else \"\"\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2730874,
                "title": "python-sliding-window-with-deque-and-counter",
                "content": "Code explained in comments.\\n\\n```\\nclass Solution:\\n    def minWindow(self, s: str, t: str) -> str:\\n        # get counts of chars in t\\n        t_counts = Counter(t)\\n        # create a counter for keeping track of chars in w\\n        w = Counter()\\n        # keep track of shortest answer found so far\\n        r = \\'\\'\\n        # keep track of which characters we have in the current window\\n        window = deque()\\n        for ch in s:\\n            # add current character to window\\n            window.append(ch)\\n            # increment count in window\\n            w[ch] += 1\\n            # check if predicate is satisfied (window contains all chars in t)\\n            if all(w[c] >= t_counts[c] for c in t_counts.keys()):\\n                # remove unnecessary (superfluous) chars\\n                while window and w[window[0]] > t_counts[window[0]]:\\n                    w[window.popleft()] -= 1\\n                # record this new answer only if it is shorter than a previous answer\\n                # (or if no previous answer exists)\\n                if r == \\'\\' or len(window) < len(r):\\n                    r = \\'\\'.join(window)\\n                # remove the last added char so we can keep looking for more substrings\\n                if window:\\n                    w[window.popleft()] -= 1\\n           \\n        return r\\n```",
                "solutionTags": [
                    "Python",
                    "Queue",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def minWindow(self, s: str, t: str) -> str:\\n        # get counts of chars in t\\n        t_counts = Counter(t)\\n        # create a counter for keeping track of chars in w\\n        w = Counter()\\n        # keep track of shortest answer found so far\\n        r = \\'\\'\\n        # keep track of which characters we have in the current window\\n        window = deque()\\n        for ch in s:\\n            # add current character to window\\n            window.append(ch)\\n            # increment count in window\\n            w[ch] += 1\\n            # check if predicate is satisfied (window contains all chars in t)\\n            if all(w[c] >= t_counts[c] for c in t_counts.keys()):\\n                # remove unnecessary (superfluous) chars\\n                while window and w[window[0]] > t_counts[window[0]]:\\n                    w[window.popleft()] -= 1\\n                # record this new answer only if it is shorter than a previous answer\\n                # (or if no previous answer exists)\\n                if r == \\'\\' or len(window) < len(r):\\n                    r = \\'\\'.join(window)\\n                # remove the last added char so we can keep looking for more substrings\\n                if window:\\n                    w[window.popleft()] -= 1\\n           \\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2574565,
                "title": "javascript-minimum-window-substring-o-n-with-comments",
                "content": "```\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @return {string}\\n */\\nvar minWindow = function(s, t) {\\n    // create hashmap to hold up our frequncy letters in pattern\\n    const fc={};\\n    let start=0, minLength=s.length+1, matches=0, substrStart=0;\\n    \\n    for (let i=0; i<t.length;i++){\\n        let char=t[i];\\n        fc[char]? fc[char]++: fc[char]=1;\\n    }\\n    \\n    // expand the window so that one window has all our pattern letters\\n    for (let end=0; end<s.length; end++){\\n        let right=s[end];\\n        \\n        if(right in fc){\\n            fc[right]--;\\n            if (fc[right]>=0) matches++;\\n        }\\n        \\n        // keep track of length once we have all pattern in a window\\n        // at same time, shrink the window knoking out from the start\\n        // after kicking out, re-check the matches, if no effect, capture the new length, otherwise expand window\\n        while (matches === t.length){\\n            if (minLength>end-start+1){\\n                minLength=end-start+1;\\n                substrStart=start;\\n            }\\n            \\n            let left=s[start];\\n            start++;\\n            if(left in fc){\\n                if(fc[left]===0) matches--;\\n                fc[left]++;\\n            }\\n        }\\n    }\\n    \\n    if (minLength>s.length) return \\'\\';\\n    return s.substring(substrStart, minLength+substrStart);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @return {string}\\n */\\nvar minWindow = function(s, t) {\\n    // create hashmap to hold up our frequncy letters in pattern\\n    const fc={};\\n    let start=0, minLength=s.length+1, matches=0, substrStart=0;\\n    \\n    for (let i=0; i<t.length;i++){\\n        let char=t[i];\\n        fc[char]? fc[char]++: fc[char]=1;\\n    }\\n    \\n    // expand the window so that one window has all our pattern letters\\n    for (let end=0; end<s.length; end++){\\n        let right=s[end];\\n        \\n        if(right in fc){\\n            fc[right]--;\\n            if (fc[right]>=0) matches++;\\n        }\\n        \\n        // keep track of length once we have all pattern in a window\\n        // at same time, shrink the window knoking out from the start\\n        // after kicking out, re-check the matches, if no effect, capture the new length, otherwise expand window\\n        while (matches === t.length){\\n            if (minLength>end-start+1){\\n                minLength=end-start+1;\\n                substrStart=start;\\n            }\\n            \\n            let left=s[start];\\n            start++;\\n            if(left in fc){\\n                if(fc[left]===0) matches--;\\n                fc[left]++;\\n            }\\n        }\\n    }\\n    \\n    if (minLength>s.length) return \\'\\';\\n    return s.substring(substrStart, minLength+substrStart);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2515070,
                "title": "detailed-cpp-solution-with-comments-easy-approach",
                "content": "**IF YOU FIND THIS SOLUTION HELPFUL PLEASE UPVOTE**\\n\\t\\n\\t\\n\\t string minWindow(string s, string t) {\\n        //creating a map to store the count and frequency of the string t\\n        map<char,int> mp;\\n        int i=0, j=0;\\n        // variable to store the length of the required substring\\n        int mini=INT_MAX;\\n        // iterating through the string t and maintaining the count of the variable in the map\\n        for(auto x: t)\\n            mp[x]++;\\n        int count=mp.size();\\n        string ans = \"\";\\n        int n = s.length();\\n        while(j<n)\\n        {\\n        // if the current character of string s is present in the map then decresing the count of that variable\\n        // and if the count of any variable becomes 0 then decreasing the count to check how many character of string t we found in string s.\\n           if(mp.find(s[j]) != mp.end())\\n           {\\n               // here we are decreasing the count pf any character. \\n               // there are three possible values for any character -ve , 0 , +ve.\\n               // 0 :- means we have found as many time a character in string s as many time it is required           (present in string t).\\n               // +ve :- means we want more occurences of the character (for example if count of character \\'t\\'   is 3 then we want 3 more \\'t\\' in string s).\\n               // -ve :- means we have extra frequency of that particular character(this is very useful when we     are trying to minimize our window size).\\n               mp[s[j]]--;\\n               if(mp[s[j]]==0)\\n                   count--;\\n           }\\n         // step where we find the candidate for answer\\n        // when count == 0 that means we found each character of string t in string s therfore answer.\\n           while(count==0)\\n           {\\n               if(mini>j-i+1)\\n               {\\n                   mini = min(mini,j-i+1); // updating the answer \\n                   ans = s.substr(i,j-i+1);// storing the required string and keep updating it\\n               }\\n               if(mp.find(s[i])!=mp.end())\\n               {\\n                   mp[s[i]]++;\\n                   if(mp[s[i]]==1)\\n                       count++;\\n               }\\n              i++;\\n           }\\n           j++;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "**IF YOU FIND THIS SOLUTION HELPFUL PLEASE UPVOTE**\\n\\t\\n\\t\\n\\t string minWindow(string s, string t) {\\n        //creating a map to store the count and frequency of the string t\\n        map<char,int> mp;\\n        int i=0, j=0;\\n        // variable to store the length of the required substring\\n        int mini=INT_MAX;\\n        // iterating through the string t and maintaining the count of the variable in the map\\n        for(auto x: t)\\n            mp[x]++;\\n        int count=mp.size();\\n        string ans = \"\";\\n        int n = s.length();\\n        while(j<n)\\n        {\\n        // if the current character of string s is present in the map then decresing the count of that variable\\n        // and if the count of any variable becomes 0 then decreasing the count to check how many character of string t we found in string s.\\n           if(mp.find(s[j]) != mp.end())\\n           {\\n               // here we are decreasing the count pf any character. \\n               // there are three possible values for any character -ve , 0 , +ve.\\n               // 0 :- means we have found as many time a character in string s as many time it is required           (present in string t).\\n               // +ve :- means we want more occurences of the character (for example if count of character \\'t\\'   is 3 then we want 3 more \\'t\\' in string s).\\n               // -ve :- means we have extra frequency of that particular character(this is very useful when we     are trying to minimize our window size).\\n               mp[s[j]]--;\\n               if(mp[s[j]]==0)\\n                   count--;\\n           }\\n         // step where we find the candidate for answer\\n        // when count == 0 that means we found each character of string t in string s therfore answer.\\n           while(count==0)\\n           {\\n               if(mini>j-i+1)\\n               {\\n                   mini = min(mini,j-i+1); // updating the answer \\n                   ans = s.substr(i,j-i+1);// storing the required string and keep updating it\\n               }\\n               if(mp.find(s[i])!=mp.end())\\n               {\\n                   mp[s[i]]++;\\n                   if(mp[s[i]]==1)\\n                       count++;\\n               }\\n              i++;\\n           }\\n           j++;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2287632,
                "title": "python-39-ms-beats-100-two-pointers-hashmap-explanation",
                "content": "# Explanation:\\nOur goal is to find the smallest substring in a string (we\\'ll call it strFull) which contains all of the letters from a second given string (we\\'ll call it strChars).\\nIn order to do this we will use two pointers. One will point to the beginning of a possible substring, and the other will point to the end. The general idea is that when we start we need to keep moving our right pointer until we have found all of the characters that we are looking for. This will become our inital answer and we will save the left and right pointers at this position (our first, potential best, subarray). From here we can move our left pointer all the way to the next character in the string that we know we need, each time that our subarray once again contains all characters we compare it to our best subarray so far, if new subarray is shorter then it becomes our best subarray. Continue this cycle of moving right pointer then left pointer until right pointer reaches end of strFull.\\n\\n![image](https://assets.leetcode.com/users/images/ce6e16bd-ed07-430e-b7e4-afff82998999_1657918898.312708.png)\\n\\nFound all three characters, move left pointer to the right until it arrives at a character from strChars.\\n\\n![image](https://assets.leetcode.com/users/images/9a0ab1bc-09aa-45eb-92b8-992f9a99e5c8_1657918828.042923.png)\\n\\n\\n\\nBecause our left pointer jumped from the first instance of a character that we need, to the second, we know that our subarray is only missing one single important character, which is the character that our left pointer was previously pointing to. Naturally we must now move our right pointer until we find that missing character.\\n\\n![image](https://assets.leetcode.com/users/images/2c9d9ffe-33db-4cbb-9106-d9834e6e7bdf_1657918725.7380726.png)\\n\\nContinue this cycle until the right pointer is at the end of strFull and the left pointer has caught up. If we have found a subarray of strFull containing all the characters we need from strChars then we can return the shortest. If we haven\\'t then we return \"\"\\n\\n# Code Pieces:\\n# \\nWe need to maintain five different variables throughout the program:\\n\\n**countRemaining (int):** How many more characters we need to find in order to have a subarray containing all characters from strChars\\n\\n**ansStart (int):** The start index of the best subarray of strFull that we have found so far\\n\\n**ansEnd(int):** The end index of the best subarray of strFull that we have found so far\\n\\n**startIndex(int):** Our left pointer, pointing to the start of our current subarray\\n\\n**targCharsRemaining(HashMap):** This will store key value pairs where each key is a character we have found in strFull and the value is **how many we have found so far versus how many we need**. A **zero value** for a character means we have found **exactly how many we need.** A **positive** value means that we are still **looking for more** of this character. A **negative** value means we have found **more of this character than we need**. As such our HashMap should initially hold a value equal to the number of a character that we need to find, and zero for every other character. \\n\\n```\\n\\t\\tcountRemaining = len(strChars)\\n        ansStart,ansEnd = 0, float(\\'inf\\')\\n        targCharsRemaining = collections.defaultdict(int)\\n        \\n        for ch in strChars:\\n            targCharsRemaining[ch] +=1\\n        \\n        startIndex = 0\\n```\\nWe will want to try our right pointer in every position, starting at one\\n\\n```\\n\\t\\tfor endIndex, ch in enumerate(strFull, 1):\\n```\\n\\nCheck the character at our right pointer to see if its a character we are looking for. If it is then we know there is one less character that we are looking for. Whether or not we were looking for it, we found it. So that means the value of the character in our HashMap should go down one. \\n\\n```\\n\\t\\t\\tif targCharsRemaining[ch] > 0:\\n                countRemaining -= 1\\n                \\n            targCharsRemaining[ch] -=1\\n```\\n\\nIf we found a character that we were looking for, and it turns out to be the last character we were looking for\\n\\n```\\n\\t\\tif countRemaining == 0:\\n```\\nwe want to move our left pointer to the right until we find a character whose HashMap value is 0 (meaning our subarray needs to contain this letter and we can\\'t move our left pointer any further yet). As our left pointer moves past each character be sure to increase the HashMap value\\nfor that character by one because it is no longer within our subarray.\\n\\n```\\n\\t\\twhile targCharsRemaining[strFull[startIndex]] < 0:\\n                    targCharsRemaining[strFull[startIndex]] += 1\\n                    startIndex +=1\\n```\\n\\nOnce our left pointer has arrived at a point of interest (meaning we once again have a subarray containing all the characters we are looking for) then check if our current subarray is shorter than the previous shortest subarray, in which case it becomes our new shortest subarray.\\n\\n```\\n\\t\\t\\t\\tif endIndex - startIndex < ansEnd - ansStart:\\n                    ansStart, ansEnd = startIndex, endIndex\\n```\\n\\nOnce we have checked if the current subarray is our best subarray so far we may move on by moving our left pointer one spot to the right. This means we need to add one to our HashMaps value for the left pointer character because it is going to slip outside of our subarray, then move left pointer one spot to the right, and because we know at this point our left pointer was a character of interest that we are losing we must add one to the number of characters we are looking for.\\n\\n```\\n                targCharsRemaining[strFull[startIndex]] += 1\\n                startIndex += 1\\n                countRemaining += 1\\n```\\n\\nFinally, if our initial value for best subarray pointer was never replaced (it will always be replaced if the all of the characters are in strFull because when we compare current substring to best substring so far, initially the best substring is set to infinite length) return \"\" otherwise return the shortest substring that we found\\n\\n```\\nreturn strFull[ansStart:ansEnd] if ansEnd != float(\\'inf\\') else \"\"\\n```\\n\\n# All Together:\\n```\\nclass Solution(object):\\n    def minWindow(self, strFull, strChars):\\n\\n        countRemaining = len(strChars)\\n        ansStart,ansEnd = 0, float(\\'inf\\')\\n        targCharsRemaining = collections.defaultdict(int)\\n        \\n        for ch in strChars:\\n            targCharsRemaining[ch] +=1\\n        \\n        startIndex = 0\\n\\n        for endIndex, ch in enumerate(strFull, 1):\\n            \\n            if targCharsRemaining[ch] > 0:\\n                countRemaining -= 1\\n                \\n            targCharsRemaining[ch] -=1\\n            \\n            if countRemaining == 0:\\n                \\n                while targCharsRemaining[strFull[startIndex]] < 0:\\n                    targCharsRemaining[strFull[startIndex]] += 1\\n                    startIndex +=1\\n                    \\n                if endIndex - startIndex < ansEnd - ansStart:\\n                    ansStart, ansEnd = startIndex, endIndex\\n                    \\n                targCharsRemaining[strFull[startIndex]] += 1\\n                startIndex += 1\\n                countRemaining += 1\\n                \\n        return strFull[ansStart:ansEnd] if ansEnd != float(\\'inf\\') else \"\"\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\n\\t\\tcountRemaining = len(strChars)\\n        ansStart,ansEnd = 0, float(\\'inf\\')\\n        targCharsRemaining = collections.defaultdict(int)\\n        \\n        for ch in strChars:\\n            targCharsRemaining[ch] +=1\\n        \\n        startIndex = 0\\n```\n```\\n\\t\\tfor endIndex, ch in enumerate(strFull, 1):\\n```\n```\\n\\t\\t\\tif targCharsRemaining[ch] > 0:\\n                countRemaining -= 1\\n                \\n            targCharsRemaining[ch] -=1\\n```\n```\\n\\t\\tif countRemaining == 0:\\n```\n```\\n\\t\\twhile targCharsRemaining[strFull[startIndex]] < 0:\\n                    targCharsRemaining[strFull[startIndex]] += 1\\n                    startIndex +=1\\n```\n```\\n\\t\\t\\t\\tif endIndex - startIndex < ansEnd - ansStart:\\n                    ansStart, ansEnd = startIndex, endIndex\\n```\n```\\n                targCharsRemaining[strFull[startIndex]] += 1\\n                startIndex += 1\\n                countRemaining += 1\\n```\n```\\nreturn strFull[ansStart:ansEnd] if ansEnd != float(\\'inf\\') else \"\"\\n```\n```\\nclass Solution(object):\\n    def minWindow(self, strFull, strChars):\\n\\n        countRemaining = len(strChars)\\n        ansStart,ansEnd = 0, float(\\'inf\\')\\n        targCharsRemaining = collections.defaultdict(int)\\n        \\n        for ch in strChars:\\n            targCharsRemaining[ch] +=1\\n        \\n        startIndex = 0\\n\\n        for endIndex, ch in enumerate(strFull, 1):\\n            \\n            if targCharsRemaining[ch] > 0:\\n                countRemaining -= 1\\n                \\n            targCharsRemaining[ch] -=1\\n            \\n            if countRemaining == 0:\\n                \\n                while targCharsRemaining[strFull[startIndex]] < 0:\\n                    targCharsRemaining[strFull[startIndex]] += 1\\n                    startIndex +=1\\n                    \\n                if endIndex - startIndex < ansEnd - ansStart:\\n                    ansStart, ansEnd = startIndex, endIndex\\n                    \\n                targCharsRemaining[strFull[startIndex]] += 1\\n                startIndex += 1\\n                countRemaining += 1\\n                \\n        return strFull[ansStart:ansEnd] if ansEnd != float(\\'inf\\') else \"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2181842,
                "title": "sliding-window-java",
                "content": "```\\nclass Solution {\\n    public String minWindow(String s, String t) {\\n                HashMap<Character,Integer> map = new HashMap<>();\\n        for(int i = 0; i < t.length(); i++){\\n            map.put(t.charAt(i),map.getOrDefault(t.charAt(i),0)+1);\\n        }\\n\\n        int i = 0;\\n        int j = 0;\\n        int count = map.size();\\n        int minimumI = 0;\\n        int minimumJ = 0;\\n        int minimum = Integer.MAX_VALUE;\\n\\n        while(j < s.length()) {\\n\\n//            Calculations for j\\n            if (map.containsKey(s.charAt(j))) {\\n                map.put(s.charAt(j), map.get(s.charAt(j)) - 1);\\n                if (map.get(s.charAt(j)) == 0) {\\n                    count--;\\n                }\\n            }\\n\\n//            Check if count is greater than 0. Count will never be less than 0\\n            if (count > 0) {\\n                j++;\\n            }\\n\\n//            Check if condition meets k\\n            else{\\n                while (count == 0) {\\n                    if (minimum > j - i + 1) {\\n                        minimum = j - i + 1;\\n                        minimumI = i;\\n// As endIndex of substring is exclusive and if we do +1 in return \\n// So, if empty return is to be returned then too it will return 1st character of the string. \\n// So if we find the answer then only we will mark it as j+1.\\n// If answer is not found by our calculations, then as minimumI and minimumJ are zero only, so it will return empty substring.\\n\\t\\t\\t\\t\\t\\t\\n                        minimumJ = j + 1;\\n                    }\\n                    if(map.containsKey(s.charAt(i))){\\n                        map.put(s.charAt(i), map.get(s.charAt(i)) + 1);\\n                        if(map.get(s.charAt(i))== 1){\\n                          count++;\\n                        }\\n                    }\\n                    i++;\\n                }\\n                j++;\\n            }\\n        }\\n        return s.substring(minimumI,minimumJ);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public String minWindow(String s, String t) {\\n                HashMap<Character,Integer> map = new HashMap<>();\\n        for(int i = 0; i < t.length(); i++){\\n            map.put(t.charAt(i),map.getOrDefault(t.charAt(i),0)+1);\\n        }\\n\\n        int i = 0;\\n        int j = 0;\\n        int count = map.size();\\n        int minimumI = 0;\\n        int minimumJ = 0;\\n        int minimum = Integer.MAX_VALUE;\\n\\n        while(j < s.length()) {\\n\\n//            Calculations for j\\n            if (map.containsKey(s.charAt(j))) {\\n                map.put(s.charAt(j), map.get(s.charAt(j)) - 1);\\n                if (map.get(s.charAt(j)) == 0) {\\n                    count--;\\n                }\\n            }\\n\\n//            Check if count is greater than 0. Count will never be less than 0\\n            if (count > 0) {\\n                j++;\\n            }\\n\\n//            Check if condition meets k\\n            else{\\n                while (count == 0) {\\n                    if (minimum > j - i + 1) {\\n                        minimum = j - i + 1;\\n                        minimumI = i;\\n// As endIndex of substring is exclusive and if we do +1 in return \\n// So, if empty return is to be returned then too it will return 1st character of the string. \\n// So if we find the answer then only we will mark it as j+1.\\n// If answer is not found by our calculations, then as minimumI and minimumJ are zero only, so it will return empty substring.\\n\\t\\t\\t\\t\\t\\t\\n                        minimumJ = j + 1;\\n                    }\\n                    if(map.containsKey(s.charAt(i))){\\n                        map.put(s.charAt(i), map.get(s.charAt(i)) + 1);\\n                        if(map.get(s.charAt(i))== 1){\\n                          count++;\\n                        }\\n                    }\\n                    i++;\\n                }\\n                j++;\\n            }\\n        }\\n        return s.substring(minimumI,minimumJ);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1702092,
                "title": "c-o-n-m-time",
                "content": "```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        // cnt is the count of every characters in `t`\\n        unordered_map<char, int> cnt;\\n        for (char &x : t) {\\n            cnt[x]++;\\n        }\\n            \\n        int n = s.size(), m = cnt.size();\\n        \\n        // `st` contains all the characters whose frequency in the current window is atleast \\n        // the frequency of the same characters in the string `t`\\n        set<char> st;\\n        \\n        // `ans.first` is the length of the window and `ans.second` is the starting index of the window\\n        pair<int, int> ans{n + 1, 0};\\n        \\n        // `j` is the starting index of the current window\\n        int j = 0;\\n        \\n        // `cur` stores the frquency of every character in the current window\\n        unordered_map<char, int> cur;\\n        \\n        for (int i = 0; i < n; i++) {\\n            // including `i`th character in the current window\\n            char &ch = s[i];\\n            cur[ch]++;\\n            // if frequency of `ch` in the current window reached the frequency in the string `t`,\\n            // let\\'s include it in the set `st`\\n            if (cur[ch] == cnt[ch]) {\\n                st.insert(ch);\\n            }\\n            \\n            // try removing unneccessary characters from the left end \\n            while (j < i && cur[s[j]] > cnt[s[j]]) {\\n                cur[s[j]]--;\\n                j++;\\n            }\\n            \\n            // if the window has all the characters, consider it for the answer\\n            if (st.size() == m)\\n                ans = min(ans, pair(i - j + 1, j));\\n        }\\n        \\n        // this means we never found a working window having all the characters in the required amount\\n        if (ans.first > n) {\\n            return \"\";\\n        }\\n        \\n        // s.substr takes two parameters, 1st: the starting index and 2nd: the length of the substring\\n        return s.substr(ans.second, ans.first);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        // cnt is the count of every characters in `t`\\n        unordered_map<char, int> cnt;\\n        for (char &x : t) {\\n            cnt[x]++;\\n        }\\n            \\n        int n = s.size(), m = cnt.size();\\n        \\n        // `st` contains all the characters whose frequency in the current window is atleast \\n        // the frequency of the same characters in the string `t`\\n        set<char> st;\\n        \\n        // `ans.first` is the length of the window and `ans.second` is the starting index of the window\\n        pair<int, int> ans{n + 1, 0};\\n        \\n        // `j` is the starting index of the current window\\n        int j = 0;\\n        \\n        // `cur` stores the frquency of every character in the current window\\n        unordered_map<char, int> cur;\\n        \\n        for (int i = 0; i < n; i++) {\\n            // including `i`th character in the current window\\n            char &ch = s[i];\\n            cur[ch]++;\\n            // if frequency of `ch` in the current window reached the frequency in the string `t`,\\n            // let\\'s include it in the set `st`\\n            if (cur[ch] == cnt[ch]) {\\n                st.insert(ch);\\n            }\\n            \\n            // try removing unneccessary characters from the left end \\n            while (j < i && cur[s[j]] > cnt[s[j]]) {\\n                cur[s[j]]--;\\n                j++;\\n            }\\n            \\n            // if the window has all the characters, consider it for the answer\\n            if (st.size() == m)\\n                ans = min(ans, pair(i - j + 1, j));\\n        }\\n        \\n        // this means we never found a working window having all the characters in the required amount\\n        if (ans.first > n) {\\n            return \"\";\\n        }\\n        \\n        // s.substr takes two parameters, 1st: the starting index and 2nd: the length of the substring\\n        return s.substr(ans.second, ans.first);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1519849,
                "title": "9-lines-no-any-lib-functions-too-easy",
                "content": "```\\nchar* minWindow(char* s, char* t) {\\n    int tChars[\\'z\\' + 1] = {0}, count = 0, minLen = INT_MAX;\\n    char* p = s, *q = s;\\n    while (t[count]) tChars[t[count++]]++;  //ABCB -> tChars = {1 2 1}: the amounts of chars we need; count = 4 here: the total amount\\n    while (*q) {                  \\n        if (-- tChars[*q++] >= 0)      count--; \\n        while (tChars[*p] < 0)         tChars[*p++]++;\\n        if (!count && q - p < minLen)  minLen = q - (s = p);\\n    }\\n    return !(*(s + (minLen == INT_MAX ? 0 : minLen)) = 0) ? s : s;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nchar* minWindow(char* s, char* t) {\\n    int tChars[\\'z\\' + 1] = {0}, count = 0, minLen = INT_MAX;\\n    char* p = s, *q = s;\\n    while (t[count]) tChars[t[count++]]++;  //ABCB -> tChars = {1 2 1}: the amounts of chars we need; count = 4 here: the total amount\\n    while (*q) {                  \\n        if (-- tChars[*q++] >= 0)      count--; \\n        while (tChars[*p] < 0)         tChars[*p++]++;\\n        if (!count && q - p < minLen)  minLen = q - (s = p);\\n    }\\n    return !(*(s + (minLen == INT_MAX ? 0 : minLen)) = 0) ? s : s;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1470483,
                "title": "sliding-window-with-unordered-map-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        unordered_map<char,int> hash;\\n        for(auto i:t) hash[i] += 1;\\n        int count = hash.size();\\n        int i=0;\\n        int j=0;\\n        string ans = \"\";\\n        while(i<s.length()){\\n            if(hash.count(s[i])){\\n                hash[s[i]] -= 1;\\n                if(!hash[s[i]]) count--;\\n            }\\n            if(!count){\\n                if(ans.empty()) ans = s.substr(j,i-j+1);\\n                if(i-j+1 < ans.length()) ans = s.substr(j,i-j+1);\\n                while(!hash.count(s[j]) || hash[s[j]] < 0){\\n                    if(hash.count(s[j]) && hash[s[j]] < 0){\\n                        hash[s[j]] ++;\\n                        if(hash[s[j]] > 0) count++;\\n                    }\\n                    j++;\\n                    if(i-j+1 < ans.length()) ans = s.substr(j,i-j+1);\\n                }\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        unordered_map<char,int> hash;\\n        for(auto i:t) hash[i] += 1;\\n        int count = hash.size();\\n        int i=0;\\n        int j=0;\\n        string ans = \"\";\\n        while(i<s.length()){\\n            if(hash.count(s[i])){\\n                hash[s[i]] -= 1;\\n                if(!hash[s[i]]) count--;\\n            }\\n            if(!count){\\n                if(ans.empty()) ans = s.substr(j,i-j+1);\\n                if(i-j+1 < ans.length()) ans = s.substr(j,i-j+1);\\n                while(!hash.count(s[j]) || hash[s[j]] < 0){\\n                    if(hash.count(s[j]) && hash[s[j]] < 0){\\n                        hash[s[j]] ++;\\n                        if(hash[s[j]] > 0) count++;\\n                    }\\n                    j++;\\n                    if(i-j+1 < ans.length()) ans = s.substr(j,i-j+1);\\n                }\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1254147,
                "title": "sliding-window-o-n",
                "content": "```\\n    def minWindow(self, s: str, t: str) -> str:\\n        from collections import defaultdict\\n        counter_t = defaultdict(int)\\n        for ch in t:\\n            counter_t[ch] += 1\\n        cnt, left = 0, 0\\n        res, min_len = \\'\\', len(s) + 1\\n        for i, ch in enumerate(s):\\n            counter_t[ch] -= 1\\n            if counter_t[ch] >= 0: # when ch is in t\\n                cnt += 1\\n            while cnt == len(t):\\n                if i - left + 1 < min_len: # get the minimum substring\\n                    res = s[left:i + 1]\\n                    min_len = len(res)\\n                counter_t[s[left]] += 1\\n                if counter_t[s[left]] > 0: # when the left char of substring is in t\\n                    cnt -= 1\\n                left += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\n    def minWindow(self, s: str, t: str) -> str:\\n        from collections import defaultdict\\n        counter_t = defaultdict(int)\\n        for ch in t:\\n            counter_t[ch] += 1\\n        cnt, left = 0, 0\\n        res, min_len = \\'\\', len(s) + 1\\n        for i, ch in enumerate(s):\\n            counter_t[ch] -= 1\\n            if counter_t[ch] >= 0: # when ch is in t\\n                cnt += 1\\n            while cnt == len(t):\\n                if i - left + 1 < min_len: # get the minimum substring\\n                    res = s[left:i + 1]\\n                    min_len = len(res)\\n                counter_t[s[left]] += 1\\n                if counter_t[s[left]] > 0: # when the left char of substring is in t\\n                    cnt -= 1\\n                left += 1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1217104,
                "title": "c-solution-using-sliding-window-o-n-time-complexity-using-map",
                "content": "\\n\\n```\\n string minWindow(string s, string t) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n        \\n        map<char,int>m1;\\n        for(int i=0;i<t.length();i++){\\n            m1[t[i]]++;   \\n        }\\n        string str_ans=\"\";\\n        int count=m1.size();\\n        int ans=0,mn=INT_MAX;\\n        int i=0,j=0;\\n        int n=s.length();\\n        \\n        while(j<n){\\n            if(m1.find(s[j])!=m1.end()){\\n                m1[s[j]]--;\\n                if(m1[s[j]]==0){\\n                   count--;\\n                 }\\n            }\\n            \\n           \\n            if(count>0){\\n                j++;\\n            }else if(count==0){\\n                ans=j-i+1;\\n                if(mn>ans){\\n                    mn=ans;\\n                    str_ans=s.substr(i,mn);\\n                }\\n                while(i<j&&count==0){\\n                    if(m1.find(s[i])!=m1.end()){\\n                        m1[s[i]]++;\\n                        \\n                        if(m1[s[i]]>0){\\n                          count++;\\n                        }\\n                    }\\n                    i++;\\n                    if(mn>j-i+1&&count==0){\\n                        mn=j-i+1;\\n                        str_ans=s.substr(i,mn);\\n                    }\\n                }\\n                j++;\\n            }\\n        }\\n              \\n        return str_ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n string minWindow(string s, string t) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n        \\n        map<char,int>m1;\\n        for(int i=0;i<t.length();i++){\\n            m1[t[i]]++;   \\n        }\\n        string str_ans=\"\";\\n        int count=m1.size();\\n        int ans=0,mn=INT_MAX;\\n        int i=0,j=0;\\n        int n=s.length();\\n        \\n        while(j<n){\\n            if(m1.find(s[j])!=m1.end()){\\n                m1[s[j]]--;\\n                if(m1[s[j]]==0){\\n                   count--;\\n                 }\\n            }\\n            \\n           \\n            if(count>0){\\n                j++;\\n            }else if(count==0){\\n                ans=j-i+1;\\n                if(mn>ans){\\n                    mn=ans;\\n                    str_ans=s.substr(i,mn);\\n                }\\n                while(i<j&&count==0){\\n                    if(m1.find(s[i])!=m1.end()){\\n                        m1[s[i]]++;\\n                        \\n                        if(m1[s[i]]>0){\\n                          count++;\\n                        }\\n                    }\\n                    i++;\\n                    if(mn>j-i+1&&count==0){\\n                        mn=j-i+1;\\n                        str_ans=s.substr(i,mn);\\n                    }\\n                }\\n                j++;\\n            }\\n        }\\n              \\n        return str_ans;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1141129,
                "title": "javascript-sliding-window-faster-than-96-26",
                "content": "```\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @return {string}\\n */\\nvar minWindow = function(s, t) {\\n    let map = {},\\n        start = 0,\\n        matched = 0,\\n        minLength = Infinity,\\n        substrStart = 0;\\n    for (let i = 0; i < t.length; i ++) {\\n        let char = t[i];\\n        if(!(char in map)) map[char] = 0;\\n        map[char] ++;\\n    }\\n    \\n    for (let end = 0; end < s.length; end ++) {\\n        let right = s[end];\\n        if (right in map) {\\n            map[right] --;\\n            if (map[right] >= 0) matched ++\\n        }\\n        while (matched === t.length) {\\n            if (minLength > end - start + 1) {\\n                minLength = end - start + 1;\\n                substrStart = start\\n            }\\n            let left = s[start]\\n            start ++;\\n            if (left in map) {\\n                if (map[left] === 0) matched --;\\n                map[left] ++;\\n            }\\n        }     \\n    }\\n    \\n    return minLength > s.length ? \\'\\' : s.substring(substrStart, substrStart + minLength);\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @return {string}\\n */\\nvar minWindow = function(s, t) {\\n    let map = {},\\n        start = 0,\\n        matched = 0,\\n        minLength = Infinity,\\n        substrStart = 0;\\n    for (let i = 0; i < t.length; i ++) {\\n        let char = t[i];\\n        if(!(char in map)) map[char] = 0;\\n        map[char] ++;\\n    }\\n    \\n    for (let end = 0; end < s.length; end ++) {\\n        let right = s[end];\\n        if (right in map) {\\n            map[right] --;\\n            if (map[right] >= 0) matched ++\\n        }\\n        while (matched === t.length) {\\n            if (minLength > end - start + 1) {\\n                minLength = end - start + 1;\\n                substrStart = start\\n            }\\n            let left = s[start]\\n            start ++;\\n            if (left in map) {\\n                if (map[left] === 0) matched --;\\n                map[left] ++;\\n            }\\n        }     \\n    }\\n    \\n    return minLength > s.length ? \\'\\' : s.substring(substrStart, substrStart + minLength);\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1130888,
                "title": "java-based-on-top-voted-solution",
                "content": "This solution is based on,\\nhttps://leetcode.com/problems/minimum-window-substring/discuss/26808/Here-is-a-10-line-template-that-can-solve-most-\\'substring\\'-problems\\n\\nModified it a little for better understanding and readability and, expanded multiple increment conditions (in single statement) present in above article.\\n\\n```\\nclass Solution {\\n    \\n    public String minWindow(String s, String t) {\\n        int[] map = new int[128]; // Contains frequency of characters in string \\'t\\'\\n        \\n        for (int i = 0 ; i < t.length() ; i++) {\\n            map[t.charAt(i)] += 1;      \\n        }\\n        \\n        int reqCount = t.length(); // Required number of characters of string \\'t\\' to be present in string \\'s\\' to make a candidate solution\\n        \\n        // minLength : Length of the final solution\\n        // head : start index of final solution\\n        // start : start index of candidate solution\\n        // end : end index of candidate solution\\n        int start = 0, end = 0, minLength = Integer.MAX_VALUE, head = 0;\\n        \\n        while (end < s.length()) {\\n            if (map[s.charAt(end)] > 0) {\\n                // If this character (of string \\'s\\') is present in \\'t\\' then, decrement (by 1) required number of characters to form candidate solution\\n                reqCount--;\\n            }\\n            \\n            // Decrement character\\'s frequency by 1. Note that the frequency of characters which are not present in \\'t\\' will become negative.\\n            map[s.charAt(end)]--;\\n            end++;\\n            \\n            while (reqCount == 0) { // This evaluates to true only when s[start, end) is a candidate solution\\n                if (minLength > (end - start)) { // Update if final solution has greater length than our current candidate solution\\n                    minLength = end - start;\\n                    head = start;\\n                }\\n                \\n                // Increment character\\'s frequency by 1. Note that the frequency of characters which are not present in \\'t\\' will become negative or, atmost 0. \\n                map[s.charAt(start)]++;\\n                \\n                /* Q. Why (map[s.charAt(start)] > 0)  ?\\n                   A. Because only the characters present in string \\'t\\' will  ever evaluate to a positive value. Rest will either be negative or 0.\\n                */\\n                if (map[s.charAt(start)] > 0) {\\n                    reqCount++; // We have removed one of the characters which must be present to form a candidate solution, so increment \\'reqCount\\' by 1.\\n                }   \\n                start++; \\n            }\\n        }\\n        return (minLength == Integer.MAX_VALUE) ? \"\" : s.substring(head, head + minLength);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public String minWindow(String s, String t) {\\n        int[] map = new int[128]; // Contains frequency of characters in string \\'t\\'\\n        \\n        for (int i = 0 ; i < t.length() ; i++) {\\n            map[t.charAt(i)] += 1;      \\n        }\\n        \\n        int reqCount = t.length(); // Required number of characters of string \\'t\\' to be present in string \\'s\\' to make a candidate solution\\n        \\n        // minLength : Length of the final solution\\n        // head : start index of final solution\\n        // start : start index of candidate solution\\n        // end : end index of candidate solution\\n        int start = 0, end = 0, minLength = Integer.MAX_VALUE, head = 0;\\n        \\n        while (end < s.length()) {\\n            if (map[s.charAt(end)] > 0) {\\n                // If this character (of string \\'s\\') is present in \\'t\\' then, decrement (by 1) required number of characters to form candidate solution\\n                reqCount--;\\n            }\\n            \\n            // Decrement character\\'s frequency by 1. Note that the frequency of characters which are not present in \\'t\\' will become negative.\\n            map[s.charAt(end)]--;\\n            end++;\\n            \\n            while (reqCount == 0) { // This evaluates to true only when s[start, end) is a candidate solution\\n                if (minLength > (end - start)) { // Update if final solution has greater length than our current candidate solution\\n                    minLength = end - start;\\n                    head = start;\\n                }\\n                \\n                // Increment character\\'s frequency by 1. Note that the frequency of characters which are not present in \\'t\\' will become negative or, atmost 0. \\n                map[s.charAt(start)]++;\\n                \\n                /* Q. Why (map[s.charAt(start)] > 0)  ?\\n                   A. Because only the characters present in string \\'t\\' will  ever evaluate to a positive value. Rest will either be negative or 0.\\n                */\\n                if (map[s.charAt(start)] > 0) {\\n                    reqCount++; // We have removed one of the characters which must be present to form a candidate solution, so increment \\'reqCount\\' by 1.\\n                }   \\n                start++; \\n            }\\n        }\\n        return (minLength == Integer.MAX_VALUE) ? \"\" : s.substring(head, head + minLength);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 314704,
                "title": "c-99-beat-sliding-window-technique-o-n-no-duplicating-kodez",
                "content": "```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        \\n        if (t.size() <= 0) { return 0; }\\n        if (s.size() <= 0) { return \"\"; }\\n        \\n        int aCount[256];\\n        memset(aCount, 0, sizeof(aCount));\\n        \\n        int aLetterCount = 0;\\n        for (int i=0;i<t.size();i++) {\\n            aCount[t[i]]++;\\n            if (aCount[t[i]] == 1) { ++aLetterCount; }\\n        }\\n        \\n        int aUsed[256];\\n        memset(aUsed, 0, sizeof(aUsed));\\n        int aUsedLetterCount = 0;\\n        \\n        int aCap = s.size() - t.size() + 1;\\n        \\n        int aStart = 0;\\n        int aEnd = 0;\\n        \\n        int aBestStart = -1;\\n        int aBestEnd = 0;\\n        int aBestLen = s.size() + 1;\\n        \\n        while (aStart < aCap) {\\n            \\n            //First move the end of the window until we have the whole word...\\n            while (aEnd < s.size() && aUsedLetterCount < aLetterCount) {\\n                if (aCount[s[aEnd]] > 0) {\\n                    if (++aUsed[s[aEnd]] == aCount[s[aEnd]]) {\\n                        if (++aUsedLetterCount == aLetterCount) {\\n                            aEnd++;\\n                            break;\\n                        }\\n                    }\\n                }\\n                aEnd += 1;\\n            }\\n            \\n            if (aUsedLetterCount != aLetterCount) { break; }\\n            \\n            //Now move the front of the sliding window until we lose our word.....\\n            while (aStart < aEnd && aUsedLetterCount == aLetterCount) {\\n                int aLen = aEnd - aStart;\\n                if (aLen < aBestLen) {\\n                    aBestStart = aStart;\\n                    aBestEnd = aEnd;\\n                    aBestLen = aLen;\\n                }\\n                \\n                //Advance the front...\\n                if (aCount[s[aStart]] > 0) {\\n                    \\n                    if (aUsed[s[aStart]]-- == aCount[s[aStart]]) {\\n                        if (aUsedLetterCount-- == aLetterCount) {\\n                            aStart++;\\n                            break;\\n                        }\\n                    }\\n                }\\n                aStart++;\\n            }\\n        }\\n        \\n        if (aBestStart == -1) { return \"\"; }\\n        return s.substr(aBestStart, aBestEnd - aBestStart);\\n    }\\n};\\n```\\n\\nKaboom, baby, took me a while even the 2nd time. LOL. Need to exercise that brain more.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        \\n        if (t.size() <= 0) { return 0; }\\n        if (s.size() <= 0) { return \"\"; }\\n        \\n        int aCount[256];\\n        memset(aCount, 0, sizeof(aCount));\\n        \\n        int aLetterCount = 0;\\n        for (int i=0;i<t.size();i++) {\\n            aCount[t[i]]++;\\n            if (aCount[t[i]] == 1) { ++aLetterCount; }\\n        }\\n        \\n        int aUsed[256];\\n        memset(aUsed, 0, sizeof(aUsed));\\n        int aUsedLetterCount = 0;\\n        \\n        int aCap = s.size() - t.size() + 1;\\n        \\n        int aStart = 0;\\n        int aEnd = 0;\\n        \\n        int aBestStart = -1;\\n        int aBestEnd = 0;\\n        int aBestLen = s.size() + 1;\\n        \\n        while (aStart < aCap) {\\n            \\n            //First move the end of the window until we have the whole word...\\n            while (aEnd < s.size() && aUsedLetterCount < aLetterCount) {\\n                if (aCount[s[aEnd]] > 0) {\\n                    if (++aUsed[s[aEnd]] == aCount[s[aEnd]]) {\\n                        if (++aUsedLetterCount == aLetterCount) {\\n                            aEnd++;\\n                            break;\\n                        }\\n                    }\\n                }\\n                aEnd += 1;\\n            }\\n            \\n            if (aUsedLetterCount != aLetterCount) { break; }\\n            \\n            //Now move the front of the sliding window until we lose our word.....\\n            while (aStart < aEnd && aUsedLetterCount == aLetterCount) {\\n                int aLen = aEnd - aStart;\\n                if (aLen < aBestLen) {\\n                    aBestStart = aStart;\\n                    aBestEnd = aEnd;\\n                    aBestLen = aLen;\\n                }\\n                \\n                //Advance the front...\\n                if (aCount[s[aStart]] > 0) {\\n                    \\n                    if (aUsed[s[aStart]]-- == aCount[s[aStart]]) {\\n                        if (aUsedLetterCount-- == aLetterCount) {\\n                            aStart++;\\n                            break;\\n                        }\\n                    }\\n                }\\n                aStart++;\\n            }\\n        }\\n        \\n        if (aBestStart == -1) { return \"\"; }\\n        return s.substr(aBestStart, aBestEnd - aBestStart);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 311927,
                "title": "c-classic-solution",
                "content": "```\\n    string minWindow(string s, string t) \\n    {\\n        // index final result\\n        int start = -1, end = INT_MAX-1;\\n        \\n        // anagrame process\\n        unordered_map<char, int> seen;        \\n        \\n        for(int i=0; i<t.size(); ++i) seen[t[i]]++;\\n        int count = seen.size();\\n        \\n        int low = 0, high = -1, length = s.size(); \\n        while(high < length)\\n        {\\n            //extend or reduce window\\n            bool extend = count > 0;\\n            int i = extend ? ++high : low++;\\n\\n            if(seen.find(s[i]) != seen.end())\\n            {                \\n                if(extend)  {seen[s[i]]--; if(seen[s[i]]==0) count--;}\\n                else        {if(seen[s[i]]==0) count++; seen[s[i]]++;}\\n            }        \\n            // Update minimum window\\n            if(count==0 && end-start > high-low)\\n            { \\n                end = high; start = low;\\n            }\\n        }   \\n        return start==-1 ? \"\" : s.substr(start, end-start+1);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    string minWindow(string s, string t) \\n    {\\n        // index final result\\n        int start = -1, end = INT_MAX-1;\\n        \\n        // anagrame process\\n        unordered_map<char, int> seen;        \\n        \\n        for(int i=0; i<t.size(); ++i) seen[t[i]]++;\\n        int count = seen.size();\\n        \\n        int low = 0, high = -1, length = s.size(); \\n        while(high < length)\\n        {\\n            //extend or reduce window\\n            bool extend = count > 0;\\n            int i = extend ? ++high : low++;\\n\\n            if(seen.find(s[i]) != seen.end())\\n            {                \\n                if(extend)  {seen[s[i]]--; if(seen[s[i]]==0) count--;}\\n                else        {if(seen[s[i]]==0) count++; seen[s[i]]++;}\\n            }        \\n            // Update minimum window\\n            if(count==0 && end-start > high-low)\\n            { \\n                end = high; start = low;\\n            }\\n        }   \\n        return start==-1 ? \"\" : s.substr(start, end-start+1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 159206,
                "title": "here-is-a-longer-version-of-most-up-voted-solution-to-help-people-to-understand-moving-window",
                "content": "```\\nclass Solution {\\npublic:\\n    // This is a typical moving window solution which is exactly the same idea of the most upvoted discussion.\\n    // But with more comments and easier to read for people to try to understand the mechanism.\\n    string minWindow(string s, string t) {\\n        // This keeps a per character count map for string t. \\n        // Since there are only 256 characters we use a vector<int> size of 256 and initlaize all count to 0.\\n        std::vector<int> map(256, 0);\\n        \\n        // Populate count map for characters from t\\n        for (const auto c : t) {\\n            map[c]++;\\n        }\\n        \\n        // This represents how many characters are in t. \\n        // It also indicates we need to find this many matches to cover all characters of t. We will keep advancing\\n        // the end of moving window and decrement this count once a chracter from t is found. Increment this count \\n        // when we advancing the begin of moving window, once a character from t is moving out of the window.\\n        int count = t.length();\\n        \\n        // Begin index of our moving window\\n        int begin = 0;\\n        // End index of our moving window\\n        int end = 0;\\n        // Init minimal window size to -1 to indeicate we have not found any match yet\\n        int minWindow = -1;\\n        // Similar to minWindow\\n        int minWindowStart = -1;\\n        \\n        // Whenver the end of mloving window hasn\\'t hit limit, we can alwasy run the algorithm.\\n        while (end < s.size()) {\\n            // Now take a look at the end of the moving window.\\n            // Decrement map count. If before decrement it was bigger than 0, we know it is one of the characters in t.\\n            // In that case, we decrement count as well. \\n            // Otherwise, it is a character not in t, and we just let count in the map become negative. When they move \\n            // out of window, and the map cunt is negative, we know they are characters we don\\'t care. \\n            if (map[s[end]]-- > 0) {\\n                count --;\\n            }\\n            \\n            // If count is 0, that means we have encountered all characters from t in the moving window.\\n            // Remember we have been advancing the end of moving window, so it is time to advance the begin of moving window.\\n            // So we can narrow it down. Of course we only do this when count continue to be 0. Once it becomes begger than zero\\n            // our condition doesn\\'t satisfy anymore, we need to go back to outter loop to advance end of moving window again.\\n            while (count == 0) {\\n                // Calculate moving window size\\n                int curWindow = end - begin + 1;\\n                // If minimal window size hasn\\'t been set or current widnow size is smaller than previous one,\\n                // set minimal window and remember the start index\\n                if ((minWindow == -1) || (curWindow < minWindow)) {\\n                    minWindow = curWindow;\\n                    minWindowStart = begin;\\n                }\\n                // Now we will try to advance the begin of moving window.\\n                // First take a look at it and increment map count. Before increment if it was 0 or bigger, it means it is one of \\n                // the characters from t, so we need to increment count as well. Otherwise it is character we don\\'t care.\\n                // In fact, the condition can be further tightened to if (map[s[begin]]++ == 0) just like the mopst upvoted solution.\\n                // I will let readers to find out why.\\n                if (map[s[begin]]++ >= 0) {\\n                    count ++;\\n                }\\n                // Finally advance begin of moving window.\\n                // Note after this we go back to while (count == 0)\\n                begin++;\\n            }\\n            \\n            // We finished narrowing down by advancing begin of moving window. \\n            // At this point count is no longer 0, and we need to advance end of our moving window.\\n            // After this we go back to outter loop.\\n            end++;\\n        }\\n        \\n        if (minWindow == -1) {\\n            return \"\";\\n        } else {\\n            return s.substr(minWindowStart, minWindow);\\n        }\\n    }\\n    // The algorithm, since we only advance end and begin of window from 0 to end of s. We know time complexity is O(n).\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // This is a typical moving window solution which is exactly the same idea of the most upvoted discussion.\\n    // But with more comments and easier to read for people to try to understand the mechanism.\\n    string minWindow(string s, string t) {\\n        // This keeps a per character count map for string t. \\n        // Since there are only 256 characters we use a vector<int> size of 256 and initlaize all count to 0.\\n        std::vector<int> map(256, 0);\\n        \\n        // Populate count map for characters from t\\n        for (const auto c : t) {\\n            map[c]++;\\n        }\\n        \\n        // This represents how many characters are in t. \\n        // It also indicates we need to find this many matches to cover all characters of t. We will keep advancing\\n        // the end of moving window and decrement this count once a chracter from t is found. Increment this count \\n        // when we advancing the begin of moving window, once a character from t is moving out of the window.\\n        int count = t.length();\\n        \\n        // Begin index of our moving window\\n        int begin = 0;\\n        // End index of our moving window\\n        int end = 0;\\n        // Init minimal window size to -1 to indeicate we have not found any match yet\\n        int minWindow = -1;\\n        // Similar to minWindow\\n        int minWindowStart = -1;\\n        \\n        // Whenver the end of mloving window hasn\\'t hit limit, we can alwasy run the algorithm.\\n        while (end < s.size()) {\\n            // Now take a look at the end of the moving window.\\n            // Decrement map count. If before decrement it was bigger than 0, we know it is one of the characters in t.\\n            // In that case, we decrement count as well. \\n            // Otherwise, it is a character not in t, and we just let count in the map become negative. When they move \\n            // out of window, and the map cunt is negative, we know they are characters we don\\'t care. \\n            if (map[s[end]]-- > 0) {\\n                count --;\\n            }\\n            \\n            // If count is 0, that means we have encountered all characters from t in the moving window.\\n            // Remember we have been advancing the end of moving window, so it is time to advance the begin of moving window.\\n            // So we can narrow it down. Of course we only do this when count continue to be 0. Once it becomes begger than zero\\n            // our condition doesn\\'t satisfy anymore, we need to go back to outter loop to advance end of moving window again.\\n            while (count == 0) {\\n                // Calculate moving window size\\n                int curWindow = end - begin + 1;\\n                // If minimal window size hasn\\'t been set or current widnow size is smaller than previous one,\\n                // set minimal window and remember the start index\\n                if ((minWindow == -1) || (curWindow < minWindow)) {\\n                    minWindow = curWindow;\\n                    minWindowStart = begin;\\n                }\\n                // Now we will try to advance the begin of moving window.\\n                // First take a look at it and increment map count. Before increment if it was 0 or bigger, it means it is one of \\n                // the characters from t, so we need to increment count as well. Otherwise it is character we don\\'t care.\\n                // In fact, the condition can be further tightened to if (map[s[begin]]++ == 0) just like the mopst upvoted solution.\\n                // I will let readers to find out why.\\n                if (map[s[begin]]++ >= 0) {\\n                    count ++;\\n                }\\n                // Finally advance begin of moving window.\\n                // Note after this we go back to while (count == 0)\\n                begin++;\\n            }\\n            \\n            // We finished narrowing down by advancing begin of moving window. \\n            // At this point count is no longer 0, and we need to advance end of our moving window.\\n            // After this we go back to outter loop.\\n            end++;\\n        }\\n        \\n        if (minWindow == -1) {\\n            return \"\";\\n        } else {\\n            return s.substr(minWindowStart, minWindow);\\n        }\\n    }\\n    // The algorithm, since we only advance end and begin of window from 0 to end of s. We know time complexity is O(n).\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 26856,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Minimum Window Substring**https://leetcode.com/problems/minimum-window-substring/\\n\\n**Algorithm**\\n* The key thing to note here is that characters in t are not supposed to be unique.\\n* S = \"aa\". T = \"aa\" - Solution is \"aa\".\\n* We keep two pointers start and end initialized to 0.\\n* Now move the end pointer to the right unitl we find a solution.\\n* When we find a solution, we try to optimize it - we move the start pointer as much as we can to right without breaking the constraints.\\n```\\nfrom collections import Counter, defaultdict\\nclass Solution(object):\\n    def minWindow(self, s, t):\\n        \"\"\"\\n        :type s: str\\n        :type t: str\\n        :rtype: str\\n        \"\"\"\\n        st, c1, min_so_far, result, fmap = 0, Counter(t), len(s)+1, \"\", defaultdict(int)\\n        unique_ch = len(c1)\\n        for end in range(len(s)):\\n            if s[end] in c1:\\n                fmap[s[end]] += 1\\n                if fmap[s[end]] == c1[s[end]]:\\n                    unique_ch -= 1\\n                while st <= end and unique_ch == 0:\\n                    if end - st + 1 < min_so_far:\\n                        min_so_far, result = end - st + 1, s[st:end+1]\\n                    if s[st] in fmap:\\n                        fmap[s[st]] -= 1\\n                        if fmap[s[st]] < c1[s[st]]:\\n                            unique_ch += 1\\n                    st += 1\\n        return result\\n```\\n\\n**General Pattern to solve 2 pointer problems**\\n```\\nstart, end = 0, len(input)\\n// data-structures for your problem\\nfor end in range(len(input)):\\n    if input[end] contributes to extending the solution:\\n        update the impact of including input[end]\\n        while st <= end and input[st:end+1] is a valid solution:\\n            update for optimal solution\\n            update for the impact of removing input[start]\\n            start += 1\\n\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter, defaultdict\\nclass Solution(object):\\n    def minWindow(self, s, t):\\n        \"\"\"\\n        :type s: str\\n        :type t: str\\n        :rtype: str\\n        \"\"\"\\n        st, c1, min_so_far, result, fmap = 0, Counter(t), len(s)+1, \"\", defaultdict(int)\\n        unique_ch = len(c1)\\n        for end in range(len(s)):\\n            if s[end] in c1:\\n                fmap[s[end]] += 1\\n                if fmap[s[end]] == c1[s[end]]:\\n                    unique_ch -= 1\\n                while st <= end and unique_ch == 0:\\n                    if end - st + 1 < min_so_far:\\n                        min_so_far, result = end - st + 1, s[st:end+1]\\n                    if s[st] in fmap:\\n                        fmap[s[st]] -= 1\\n                        if fmap[s[st]] < c1[s[st]]:\\n                            unique_ch += 1\\n                    st += 1\\n        return result\\n```\n```\\nstart, end = 0, len(input)\\n// data-structures for your problem\\nfor end in range(len(input)):\\n    if input[end] contributes to extending the solution:\\n        update the impact of including input[end]\\n        while st <= end and input[st:end+1] is a valid solution:\\n            update for optimal solution\\n            update for the impact of removing input[start]\\n            start += 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 26968,
                "title": "python-o-n-solution-164ms",
                "content": "Two steps:\\n\\n1. Find the first minimum window that covers all letters in T, with `start` and `end` points to the starting and ending point of the minimum window;\\n\\n2. Discard the letter x at `start` and advance to the next letter if it's in T, advance `end` until it points to the same discarded letter x\\n\\n\\nNote: during step 1 and 2, advancing pointers may come to letters that are in T, use hash table `extra` to keep track of these letters. When the discarded letter is in `extra`, a window is found without advancing the `end` pointer.  \\n\\nString `S` is only traversed once, so the time complexity is O(n), two hash tables `to_find` and `extra` have space O(m).\\n    \\n \\n    def minWindow(self, S, T):\\n        letters = set(T)\\n        ls = len(S)\\n        \\n        # find the first substring that works\\n        first_match = self.first_match(S, T)\\n        if not first_match:\\n            return ''\\n        else:\\n            start, end, extra = first_match\\n            min_window = (end - start, start, end)\\n        \\n        # traverse the string and update start and end\\n        while start < end < ls:\\n            discard = S[start]\\n            \\n            # move start on to the next letter\\n            while start < end:\\n                start += 1\\n                if S[start] in letters:\\n                    break\\n            \\n            # if discarded letter has extra, no need update end    \\n            if discard in extra:\\n                extra[discard] -= 1\\n                if extra[discard] == 0:\\n                    extra.pop(discard)\\n                min_window = min(min_window, (end - start, start, end))\\n                continue\\n            \\n            # otherwise move end until it points to the discarded letter\\n            while end < ls:\\n                end += 1\\n                if end == ls:\\n                    continue\\n                \\n                letter = S[end]\\n                if letter == discard:\\n                    min_window = min(min_window, (end - start, start, end))\\n                    break\\n                \\n                if letter in letters:\\n                    extra[letter] += 1\\n\\n        _, start, end = min_window\\n        return S[start: end + 1]\\n        \\n    def first_match(self, S, T):\\n        letters = set(T)\\n        to_find = collections.defaultdict(lambda: 0)\\n        extra = collections.defaultdict(lambda: 0)\\n        \\n        # build hash table\\n        for i in T:\\n            to_find[i] += 1\\n        \\n        # find the start position\\n        for index, letter in enumerate(S):\\n            if letter in to_find:\\n                start = index\\n                break\\n        else:\\n            return False\\n            \\n        # find the end position\\n        for index, letter in enumerate(S[start:], start):\\n            if letter not in letters:\\n                continue\\n            if letter in to_find:\\n                to_find[letter] -= 1\\n                if to_find[letter] == 0:\\n                    to_find.pop(letter)\\n            else:\\n                extra[letter] += 1\\n            if not to_find:\\n                end = index\\n                break\\n        else:\\n            return False\\n        return start, end, extra",
                "solutionTags": [
                    "Python"
                ],
                "code": "Two steps:\\n\\n1. Find the first minimum window that covers all letters in T, with `start` and `end` points to the starting and ending point of the minimum window;\\n\\n2. Discard the letter x at `start` and advance to the next letter if it's in T, advance `end` until it points to the same discarded letter x\\n\\n\\nNote: during step 1 and 2, advancing pointers may come to letters that are in T, use hash table `extra` to keep track of these letters. When the discarded letter is in `extra`, a window is found without advancing the `end` pointer.  \\n\\nString `S` is only traversed once, so the time complexity is O(n), two hash tables `to_find` and `extra` have space O(m).\\n    \\n \\n    def minWindow(self, S, T):\\n        letters = set(T)\\n        ls = len(S)\\n        \\n        # find the first substring that works\\n        first_match = self.first_match(S, T)\\n        if not first_match:\\n            return ''\\n        else:\\n            start, end, extra = first_match\\n            min_window = (end - start, start, end)\\n        \\n        # traverse the string and update start and end\\n        while start < end < ls:\\n            discard = S[start]\\n            \\n            # move start on to the next letter\\n            while start < end:\\n                start += 1\\n                if S[start] in letters:\\n                    break\\n            \\n            # if discarded letter has extra, no need update end    \\n            if discard in extra:\\n                extra[discard] -= 1\\n                if extra[discard] == 0:\\n                    extra.pop(discard)\\n                min_window = min(min_window, (end - start, start, end))\\n                continue\\n            \\n            # otherwise move end until it points to the discarded letter\\n            while end < ls:\\n                end += 1\\n                if end == ls:\\n                    continue\\n                \\n                letter = S[end]\\n                if letter == discard:\\n                    min_window = min(min_window, (end - start, start, end))\\n                    break\\n                \\n                if letter in letters:\\n                    extra[letter] += 1\\n\\n        _, start, end = min_window\\n        return S[start: end + 1]\\n        \\n    def first_match(self, S, T):\\n        letters = set(T)\\n        to_find = collections.defaultdict(lambda: 0)\\n        extra = collections.defaultdict(lambda: 0)\\n        \\n        # build hash table\\n        for i in T:\\n            to_find[i] += 1\\n        \\n        # find the start position\\n        for index, letter in enumerate(S):\\n            if letter in to_find:\\n                start = index\\n                break\\n        else:\\n            return False\\n            \\n        # find the end position\\n        for index, letter in enumerate(S[start:], start):\\n            if letter not in letters:\\n                continue\\n            if letter in to_find:\\n                to_find[letter] -= 1\\n                if to_find[letter] == 0:\\n                    to_find.pop(letter)\\n            else:\\n                extra[letter] += 1\\n            if not to_find:\\n                end = index\\n                break\\n        else:\\n            return False\\n        return start, end, extra",
                "codeTag": "Python3"
            },
            {
                "id": 3948899,
                "title": "hashmap-java-two-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(S)$$  ... S = s.length\\n\\n- Space complexity:\\n$$O(T)$$   ... T = t.length\\n\\n# Code\\n```\\nclass Solution {\\n    public String minWindow(String s, String t) \\n    {\\n        if(s == null || s.length() < t.length() || s.length() == 0)\\n        {\\n            return \"\";\\n        }\\n        Map<Character, Integer> map = new HashMap<>();\\n        for(char c: t.toCharArray())\\n        {\\n            if(map.containsKey(c))\\n                map.put(c, map.get(c)+1);\\n            else\\n                map.put(c, 1);\\n        }\\n        // mapCounter = 0 denotes condition is satiffied and we got solution\\n        int mapCounter = map.size();\\n        int n = s.length();\\n        int l = 0, r = 0;  // two pointers\\n        int start = 0, maxLen = 0;\\n        for(r = 0; r < n; r++)\\n        {\\n            char curR = s.charAt(r);\\n            if(map.containsKey(curR))\\n            {\\n                map.put(curR, map.get(curR)-1);\\n                if(map.get(curR) == 0)\\n                    mapCounter--;\\n                \\n                // got soltion\\n                if(mapCounter == 0)\\n                {\\n                    // finding better solution by shifting left pointer\\n                    while(l < n && mapCounter == 0)\\n                    {\\n                        char curL = s.charAt(l);\\n                        if(map.containsKey(curL))\\n                        {\\n                            map.put(curL, map.get(curL)+1);\\n                            if(map.get(curL) > 0)\\n                                mapCounter++;\\n                        }\\n                        l++;\\n                    }\\n                    // getting best solution\\n                    if(maxLen > r-l+2 || maxLen == 0)\\n                    {\\n                        maxLen = (r-l) + 2;\\n                        start = l-1;\\n                    }\\n                }\\n            }\\n        }\\n        return s.substring(start, start+maxLen);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public String minWindow(String s, String t) \\n    {\\n        if(s == null || s.length() < t.length() || s.length() == 0)\\n        {\\n            return \"\";\\n        }\\n        Map<Character, Integer> map = new HashMap<>();\\n        for(char c: t.toCharArray())\\n        {\\n            if(map.containsKey(c))\\n                map.put(c, map.get(c)+1);\\n            else\\n                map.put(c, 1);\\n        }\\n        // mapCounter = 0 denotes condition is satiffied and we got solution\\n        int mapCounter = map.size();\\n        int n = s.length();\\n        int l = 0, r = 0;  // two pointers\\n        int start = 0, maxLen = 0;\\n        for(r = 0; r < n; r++)\\n        {\\n            char curR = s.charAt(r);\\n            if(map.containsKey(curR))\\n            {\\n                map.put(curR, map.get(curR)-1);\\n                if(map.get(curR) == 0)\\n                    mapCounter--;\\n                \\n                // got soltion\\n                if(mapCounter == 0)\\n                {\\n                    // finding better solution by shifting left pointer\\n                    while(l < n && mapCounter == 0)\\n                    {\\n                        char curL = s.charAt(l);\\n                        if(map.containsKey(curL))\\n                        {\\n                            map.put(curL, map.get(curL)+1);\\n                            if(map.get(curL) > 0)\\n                                mapCounter++;\\n                        }\\n                        l++;\\n                    }\\n                    // getting best solution\\n                    if(maxLen > r-l+2 || maxLen == 0)\\n                    {\\n                        maxLen = (r-l) + 2;\\n                        start = l-1;\\n                    }\\n                }\\n            }\\n        }\\n        return s.substring(start, start+maxLen);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3898665,
                "title": "c-optimal-solution-beats-99-5-detailed-explanation",
                "content": "# Intuition\\nThe problem requires finding the minimum window in string `s` that contains all characters from string `t`. To solve this, we can use a sliding window approach. We will maintain two pointers, `i` and `j`, which represent the left and right boundaries of the current window. We will also maintain two arrays, `map` and `window`, to track the frequency of characters in string `t` and the current window, respectively. Additionally, we will use a variable `count` to keep track of how many distinct characters from `t` are currently present in the window.\\n\\n# Approach\\n1. Create an array `map` of size 256 to store the frequency of characters in string `t`.\\n2. Traverse through string `t` and update the `map` array with the frequency of each character.\\n3. Initialize variables `count`, `i`, `start`, `end`, and `ans`. `count` will keep track of the number of distinct characters in the current window. `i` will represent the left boundary of the window. `start` and `end` will store the indices of the minimum window found, and `ans` will store the length of the minimum window.\\n4. Iterate through string `s` using pointer `j` from 0 to `m-1`, where `m` is the size of string `s`.\\n   a. Update the `window` array with the frequency of the character at index `j`.\\n   b. If the frequency of the character at index `j` is less than or equal to its frequency in `map`, increment the `count`.\\n   c. If `count` equals the size of string `t`, it means all characters from `t` are present in the current window. Now, we need to shrink the window from the left side until we no longer have all characters from `t` in the window while maintaining the minimum window size.\\n       - Increment `i` and decrease the frequency of the character at index `i` in the `window` array.\\n       - Continue incrementing `i` until the frequency of the character at index `i` in the `window` array becomes less than its frequency in the `map` array.\\n       - Update the `ans`, `start`, and `end` variables with the current window size and indices if the current window size is smaller than the previous minimum.\\n       - Decrement the `count` since we removed a character from the window.\\n5. After the loop, if `start` is still -1, it means no valid window was found, so return an empty string. Otherwise, extract the substring from `s` using the indices `start` and `end` to obtain the minimum window.\\n6. Return the minimum window substring.\\n\\n# Complexity\\n- Time complexity: $$ O(m + n) $$, where m is the size of string `s` and n is the size of string `t`. The loop through string `s` takes O(m) time, and the loop through string `t` takes O(n) time.\\n- Space complexity: $$O(1)$$, since the `map` and `window` arrays have a constant size of 256 characters, and the additional variables used are constant.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        int m = s.size();\\n        int n = t.size();\\n        if (n > m) return \"\";  // Handle the case where t is longer than s\\n\\n        int map[256] = {0};  // Create an array to store the frequency of characters in string t\\n        for (char c : t) {\\n            map[c]++;\\n        }\\n        int count = 0;  // Count of distinct characters in the current window\\n\\n        int window[256] = {0};  // Create an array to track the frequency of characters in the current window\\n        int i = 0, start = -1, end = -1, ans = INT_MAX;  // Initialize pointers and variables\\n\\n        for (int j = 0; j < m; j++) {\\n            window[s[j]]++;  // Expand the window by adding character at index j\\n            if (window[s[j]] <= map[s[j]]) {\\n                count++;  // Increment count if the character is present in t\\n            }\\n            if (count == n) {  // If all characters of t are present in the window\\n                while (map[s[i]] == 0 || window[s[i]] > map[s[i]]) {\\n                    window[s[i]]--;\\n                    i++;  // Contract the window from the left side\\n                }\\n                if ((j - i + 1) < ans) {\\n                    ans = j - i + 1;\\n                    start = i;\\n                    end = j;  // Update the minimum window indices\\n                }\\n                window[s[i]]--;\\n                i++;\\n                count--;\\n            }\\n        }\\n        if (start == -1) return \"\";  // No valid window found\\n        string final = \"\";\\n        for (int x = start; x <= end; x++) {\\n            final += s[x];  // Extract the minimum window substring\\n        }\\n        return final;\\n    }\\n};\\n\\n```\\n\\nDo upvote if it helps.",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Two Pointers",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        int m = s.size();\\n        int n = t.size();\\n        if (n > m) return \"\";  // Handle the case where t is longer than s\\n\\n        int map[256] = {0};  // Create an array to store the frequency of characters in string t\\n        for (char c : t) {\\n            map[c]++;\\n        }\\n        int count = 0;  // Count of distinct characters in the current window\\n\\n        int window[256] = {0};  // Create an array to track the frequency of characters in the current window\\n        int i = 0, start = -1, end = -1, ans = INT_MAX;  // Initialize pointers and variables\\n\\n        for (int j = 0; j < m; j++) {\\n            window[s[j]]++;  // Expand the window by adding character at index j\\n            if (window[s[j]] <= map[s[j]]) {\\n                count++;  // Increment count if the character is present in t\\n            }\\n            if (count == n) {  // If all characters of t are present in the window\\n                while (map[s[i]] == 0 || window[s[i]] > map[s[i]]) {\\n                    window[s[i]]--;\\n                    i++;  // Contract the window from the left side\\n                }\\n                if ((j - i + 1) < ans) {\\n                    ans = j - i + 1;\\n                    start = i;\\n                    end = j;  // Update the minimum window indices\\n                }\\n                window[s[i]]--;\\n                i++;\\n                count--;\\n            }\\n        }\\n        if (start == -1) return \"\";  // No valid window found\\n        string final = \"\";\\n        for (int x = start; x <= end; x++) {\\n            final += s[x];  // Extract the minimum window substring\\n        }\\n        return final;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845867,
                "title": "most-intuitive-standard-sliding-window-approach-clean-code-using-two-maps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing two maps \\n- map_s\\n- map_t\\n\\nNow check for given condition **if \\'t\\' exist inside of current window** while sliding through window on \\'s\\' string ***(standard sliding window technique)***.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO( n * map_t.size() )\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO( n+m )\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //check function to check if \"t\" is a substring in curr_s substring \\n    bool check(map<char,int> &map_s,map<char,int> &map_t){\\n        for(auto &itr: map_t){\\n            if(map_s[itr.first] < itr.second) return false;\\n        }\\n        return true;\\n    }\\n    string minWindow(string s, string t) {\\n        if(s.size() < t.size() ){\\n            return \"\";\\n        }\\n        if(s == t) return s;\\n        int resulti = 0;\\n        int anslen  = INT_MAX;\\n        int i=0;\\n        int j=0;\\n        int n = s.size();\\n        map<char,int> map_t;\\n        map<char,int> map_s;\\n        for(auto &itr:t){ //feed string \\'t\\' into map_t\\n            map_t[itr]++;\\n        }\\n        //sliding window\\n        while(j<n){\\n            map_s[s[j]]++;\\n            while(check(map_s,map_t)){\\n                if(j-i+1 <= anslen){\\n                    anslen = j-i+1;\\n                    resulti = i;\\n                }\\n                map_s[s[i]]--;\\n                if(map_s[s[i]]==0) map_s.erase(s[i]);\\n                i++;\\n            }\\n            j++;\\n        }\\n        if(anslen==INT_MAX) return \"\";\\n        return s.substr(resulti,anslen);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Ordered Map",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //check function to check if \"t\" is a substring in curr_s substring \\n    bool check(map<char,int> &map_s,map<char,int> &map_t){\\n        for(auto &itr: map_t){\\n            if(map_s[itr.first] < itr.second) return false;\\n        }\\n        return true;\\n    }\\n    string minWindow(string s, string t) {\\n        if(s.size() < t.size() ){\\n            return \"\";\\n        }\\n        if(s == t) return s;\\n        int resulti = 0;\\n        int anslen  = INT_MAX;\\n        int i=0;\\n        int j=0;\\n        int n = s.size();\\n        map<char,int> map_t;\\n        map<char,int> map_s;\\n        for(auto &itr:t){ //feed string \\'t\\' into map_t\\n            map_t[itr]++;\\n        }\\n        //sliding window\\n        while(j<n){\\n            map_s[s[j]]++;\\n            while(check(map_s,map_t)){\\n                if(j-i+1 <= anslen){\\n                    anslen = j-i+1;\\n                    resulti = i;\\n                }\\n                map_s[s[i]]--;\\n                if(map_s[s[i]]==0) map_s.erase(s[i]);\\n                i++;\\n            }\\n            j++;\\n        }\\n        if(anslen==INT_MAX) return \"\";\\n        return s.substr(resulti,anslen);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3813957,
                "title": "c-sliding-window-easy-to-understand-with-intuition-hashmap",
                "content": "**APPROACH**\\nSo the basic intuition lies on the fact that:-\\n**s=ADOBECODEBANC**\\n      0 1 2 3 4 5 6 7 8 9 10\\n**t = ABC**\\n       0 1 2\\n\\t   \\nNow, if i=0 and j=0, we can shrink the window only if the character pointing to i has frequency more than that present in t .Like if i points to 0 and j points to 6 then frequency of s[i] i.e A is 1 and frequency of A in t is also 1 so we can\\'t shrink the window till now , \\nbut when j points to 8 then since frequency of s[i] i.e A is more than that present in t then we can shrink it .\\nI hope You got the intuition, now proceed this way .\\n(you can try to dry run this code and you will understand the logic and here i,m providing 2 codes the one which passes 265/267 testcases and another one that got accepted! :)\\n**HERE THE CODE:**\\n\\n  ** Accepted CODE**\\n   ```\\n   class Solution {\\npublic:\\n   \\n    string minWindow(string s, string t) {\\n        if(t.size()>s.size())return \"\";\\n        int n=s.size();\\n        unordered_map<char,int>mp;\\n        unordered_map<char,int>mp2;\\n        for(auto it: t){\\n            mp[it]++;\\n        }\\n        int j=0;\\n        int i=0;\\n        int ans=1e9;\\n        int final_i=-1;\\n        int final_j=-1;\\n        while(j<n){\\n            mp2[s[j]]++;\\n            while( i<n && j<n && mp.find(s[i])==mp.end() ){\\n                mp2[s[i]]--;\\n                if(mp2[s[i]]==0)mp2.erase(s[i]);\\n                i++;\\n            }\\n           \\n                while(i<n && mp2[s[i]]>mp[s[i]]){\\n                    mp2[s[i]]--;\\n                    i++;\\n                }\\n          \\n               bool f=0;\\n               for(auto it: mp){\\n                   char c=it.first;\\n                   int freq=it.second;\\n                   if(mp2.find(c)==mp2.end())f=1;\\n                   else{\\n                      if(mp2[c]<mp[c])f=1;\\n                       \\n                   }\\n               }\\n               if(f==0){\\n                   if(j-i+1<ans){\\n                       final_i=i;\\n                       final_j=j;\\n                       ans=min(ans,j-i+1);\\n                   }\\n               }\\n        \\n            j++;\\n        }\\n        if(final_i==-1 && final_j==-1)return \"\";\\nreturn s.substr(final_i,final_j-final_i+1);\\n       \\n    }\\n};\\n```\\n**TLE CODE:**\\n```\\nclass Solution {\\npublic:\\n    bool check(int i,int j,string s, string t){\\n        unordered_map<char,int> mp1;\\n        for(auto it: t){\\n            mp1[it]++;\\n        }\\n        unordered_map<char,int>mp2;\\n        for(int ind=i;ind<=j;ind++){\\n            mp2[s[ind]]++;\\n        }\\n        for(auto it: mp1){\\n            char a=it.first;\\n            int freq=it.second;\\n            if(mp2.find(a)==mp2.end())return false;\\n            else{\\n                if(mp2[a]<freq)return false;\\n            }\\n        }\\n        return true;\\n    }\\n    string minWindow(string s, string t) {\\n        if(t.size()>s.size())return \"\";\\n        int n=s.size();\\n        unordered_map<char,int>mp;\\n        unordered_map<char,int>mp2;\\n        for(auto it: t){\\n            mp[it]++;\\n        }\\n        int j=0;\\n        int i=0;\\n        int ans=1e9;\\n        int final_i;\\n        int final_j;\\n        while(j<n){\\n            mp2[s[j]]++;\\n            while(mp.find(s[i])==mp.end()){\\n                mp[s[i]]--;\\n                if(mp[s[i]]==0)mp.erase(s[i]);\\n                i++;\\n            }\\n           \\n                while(mp2[s[i]]>mp[s[i]]){\\n                    mp2[s[i]]--;\\n                    i++;\\n                }\\n                \\n               \\n         \\n            \\n           if(check(i,j,s,t)){\\n               if(j-i+1<ans){\\n                   ans=j-i+1;\\n                   final_i=i;\\n                   final_j=j;\\n               }}\\n            j++;\\n        }\\nreturn s.substr(final_i,final_j-final_i+1);\\n       \\n    }\\n};\\n```\\nUPVOTE IF LIKED ! :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\n   class Solution {\\npublic:\\n   \\n    string minWindow(string s, string t) {\\n        if(t.size()>s.size())return \"\";\\n        int n=s.size();\\n        unordered_map<char,int>mp;\\n        unordered_map<char,int>mp2;\\n        for(auto it: t){\\n            mp[it]++;\\n        }\\n        int j=0;\\n        int i=0;\\n        int ans=1e9;\\n        int final_i=-1;\\n        int final_j=-1;\\n        while(j<n){\\n            mp2[s[j]]++;\\n            while( i<n && j<n && mp.find(s[i])==mp.end() ){\\n                mp2[s[i]]--;\\n                if(mp2[s[i]]==0)mp2.erase(s[i]);\\n                i++;\\n            }\\n           \\n                while(i<n && mp2[s[i]]>mp[s[i]]){\\n                    mp2[s[i]]--;\\n                    i++;\\n                }\\n          \\n               bool f=0;\\n               for(auto it: mp){\\n                   char c=it.first;\\n                   int freq=it.second;\\n                   if(mp2.find(c)==mp2.end())f=1;\\n                   else{\\n                      if(mp2[c]<mp[c])f=1;\\n                       \\n                   }\\n               }\\n               if(f==0){\\n                   if(j-i+1<ans){\\n                       final_i=i;\\n                       final_j=j;\\n                       ans=min(ans,j-i+1);\\n                   }\\n               }\\n        \\n            j++;\\n        }\\n        if(final_i==-1 && final_j==-1)return \"\";\\nreturn s.substr(final_i,final_j-final_i+1);\\n       \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool check(int i,int j,string s, string t){\\n        unordered_map<char,int> mp1;\\n        for(auto it: t){\\n            mp1[it]++;\\n        }\\n        unordered_map<char,int>mp2;\\n        for(int ind=i;ind<=j;ind++){\\n            mp2[s[ind]]++;\\n        }\\n        for(auto it: mp1){\\n            char a=it.first;\\n            int freq=it.second;\\n            if(mp2.find(a)==mp2.end())return false;\\n            else{\\n                if(mp2[a]<freq)return false;\\n            }\\n        }\\n        return true;\\n    }\\n    string minWindow(string s, string t) {\\n        if(t.size()>s.size())return \"\";\\n        int n=s.size();\\n        unordered_map<char,int>mp;\\n        unordered_map<char,int>mp2;\\n        for(auto it: t){\\n            mp[it]++;\\n        }\\n        int j=0;\\n        int i=0;\\n        int ans=1e9;\\n        int final_i;\\n        int final_j;\\n        while(j<n){\\n            mp2[s[j]]++;\\n            while(mp.find(s[i])==mp.end()){\\n                mp[s[i]]--;\\n                if(mp[s[i]]==0)mp.erase(s[i]);\\n                i++;\\n            }\\n           \\n                while(mp2[s[i]]>mp[s[i]]){\\n                    mp2[s[i]]--;\\n                    i++;\\n                }\\n                \\n               \\n         \\n            \\n           if(check(i,j,s,t)){\\n               if(j-i+1<ans){\\n                   ans=j-i+1;\\n                   final_i=i;\\n                   final_j=j;\\n               }}\\n            j++;\\n        }\\nreturn s.substr(final_i,final_j-final_i+1);\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3770576,
                "title": "c-easy-to-understand-sliding-window",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(unordered_map<char , int> &ofstr, unordered_map<char , int>&oftemp){\\n        for(auto x : oftemp){\\n            if(ofstr[x.first] < oftemp[x.first])return false;\\n        }\\n        return true;\\n    }\\n    pair<int,int> solve(string &str , string &temp){\\n             unordered_map<char , int> ofstr;\\n             unordered_map<char , int> oftemp;\\n             for(auto x : temp)oftemp[x]++;\\n             int i = -1;\\n             int j = -1;\\n             int n = str.size();\\n             int index = -1;\\n             int size = INT_MAX;\\n             while(true){\\n                 bool flag1 = false;\\n                 bool flag2 = false;\\n                 while(i+1<n){\\n                     flag1 = true;\\n                     i++;\\n                     ofstr[str[i]]++;\\n                     if(isValid(ofstr , oftemp)){\\n                         break;\\n                     }\\n                 }\\n                 cout<<i<<\"  \"<<j<<endl;\\n                 while(j+1<n && isValid(ofstr , oftemp)){\\n                    flag2 = true;\\n                    if(size > (i - j)){\\n                             size = (i - j);\\n                             index = j + 1;\\n                     }\\n                     j++;\\n                     ofstr[str[j]]--;\\n                 }\\n                 if(flag1 == false && flag2==false)break;\\n             }\\n             return {index , size};\\n    }\\n    string minWindow(string s, string t) {\\n        pair<int,int> temp = solve(s , t);\\n        if(temp.first == -1) return \"\";\\n        int index = temp.first;\\n        int size = temp.second;\\n        return s.substr(index , size);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(unordered_map<char , int> &ofstr, unordered_map<char , int>&oftemp){\\n        for(auto x : oftemp){\\n            if(ofstr[x.first] < oftemp[x.first])return false;\\n        }\\n        return true;\\n    }\\n    pair<int,int> solve(string &str , string &temp){\\n             unordered_map<char , int> ofstr;\\n             unordered_map<char , int> oftemp;\\n             for(auto x : temp)oftemp[x]++;\\n             int i = -1;\\n             int j = -1;\\n             int n = str.size();\\n             int index = -1;\\n             int size = INT_MAX;\\n             while(true){\\n                 bool flag1 = false;\\n                 bool flag2 = false;\\n                 while(i+1<n){\\n                     flag1 = true;\\n                     i++;\\n                     ofstr[str[i]]++;\\n                     if(isValid(ofstr , oftemp)){\\n                         break;\\n                     }\\n                 }\\n                 cout<<i<<\"  \"<<j<<endl;\\n                 while(j+1<n && isValid(ofstr , oftemp)){\\n                    flag2 = true;\\n                    if(size > (i - j)){\\n                             size = (i - j);\\n                             index = j + 1;\\n                     }\\n                     j++;\\n                     ofstr[str[j]]--;\\n                 }\\n                 if(flag1 == false && flag2==false)break;\\n             }\\n             return {index , size};\\n    }\\n    string minWindow(string s, string t) {\\n        pair<int,int> temp = solve(s , t);\\n        if(temp.first == -1) return \"\";\\n        int index = temp.first;\\n        int size = temp.second;\\n        return s.substr(index , size);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3757266,
                "title": "my-array-based-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe goal is to find the minimum window in the string s that contains all the characters of string t.\\n\\n**Initial Length Check:**\\n\\nIf t is longer than s, we immediately return an empty string because it\\'s impossible for s to contain a substring that covers all of t.\\n\\n**Character Mapping:**\\n\\nConstruct a frequency map for the characters of t. This serves as a reference to understand how many of each character we need.\\n\\n**Initialize First Window:**\\n\\nStart by considering a substring of s that\\'s of the same length as t. We then track the frequency of the characters in this initial window.\\n\\n**Immediate Match:**\\n\\nIf this initial window matches t, we found our shortest window immediately.\\n\\n**Sliding Window Algorithm:**\\n\\nWe employ a two-pointer method, where left and right act as the boundaries of our current window.\\nWe extend our window to the right by adding characters to it.\\nWe then try to shrink our window from the left to find the minimum possible window that still satisfies the requirement. This involves removing characters from the start and checking if the window is still valid.\\nThe window is valid if it still contains all characters of t with their appropriate frequencies.\\n\\n**Utility Function:**\\n\\nThe checkMap function serves to verify if the current window contains all characters of t.\\n\\n**Result:**\\n\\nAfter iterating through s, the smallest valid window is returned. If no such window is found, an empty string is returned.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String minWindow(String s, String t) {\\n        if (t.length() > s.length()) {\\n            return \"\";\\n        }\\n\\n        int map[] = new int[128], len = t.length();\\n\\n        for (int i = 0; i < len; i++) {\\n            map[t.charAt(i)]++;\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        String min = null;\\n        int currMap[] = new int[128];\\n\\n        for (int i = 0; i < len; i++) {\\n            sb.append(s.charAt(i));\\n            currMap[s.charAt(i)]++;\\n        }\\n\\n        if (Arrays.equals(currMap, map)) {\\n            return sb.toString();\\n        }\\n\\n        int left = 0, right = len;\\n        while (right < s.length()) {\\n            sb.append(s.charAt(right));\\n            currMap[s.charAt(right)]++;\\n\\n            while (checkMap(currMap, map)) {\\n                if (min == null || sb.length() < min.length()) {\\n                    min = sb.toString();\\n                }\\n                currMap[s.charAt(left)]--;\\n                sb.deleteCharAt(0);\\n                left++;\\n            }\\n            right++;\\n        }\\n\\n        return min == null ? \"\" : min;\\n    }\\n    \\n    public boolean checkMap(int[] currMap, int[] map) {\\n        for (int i = 0; i < currMap.length; i++) {\\n            if (currMap[i] < map[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public String minWindow(String s, String t) {\\n        if (t.length() > s.length()) {\\n            return \"\";\\n        }\\n\\n        int map[] = new int[128], len = t.length();\\n\\n        for (int i = 0; i < len; i++) {\\n            map[t.charAt(i)]++;\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        String min = null;\\n        int currMap[] = new int[128];\\n\\n        for (int i = 0; i < len; i++) {\\n            sb.append(s.charAt(i));\\n            currMap[s.charAt(i)]++;\\n        }\\n\\n        if (Arrays.equals(currMap, map)) {\\n            return sb.toString();\\n        }\\n\\n        int left = 0, right = len;\\n        while (right < s.length()) {\\n            sb.append(s.charAt(right));\\n            currMap[s.charAt(right)]++;\\n\\n            while (checkMap(currMap, map)) {\\n                if (min == null || sb.length() < min.length()) {\\n                    min = sb.toString();\\n                }\\n                currMap[s.charAt(left)]--;\\n                sb.deleteCharAt(0);\\n                left++;\\n            }\\n            right++;\\n        }\\n\\n        return min == null ? \"\" : min;\\n    }\\n    \\n    public boolean checkMap(int[] currMap, int[] map) {\\n        for (int i = 0; i < currMap.length; i++) {\\n            if (currMap[i] < map[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3755584,
                "title": "java-sliding-window-approach-easily-understandable-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public String minWindow(String s, String t) {\\n        if(s.length()==0 || t.length()==0 || s.length()<t.length()){\\n            return new String();\\n        }\\n        int[] map = new int[128];\\n        char[] sArray = s.toCharArray();\\n        char[] tArray = t.toCharArray();\\n\\n        for(char i : tArray){\\n            map[i]++;\\n        }\\n        int left = 0;\\n        int right=0;\\n        int count = t.length();\\n        int minStart = 0;\\n        int minLength=Integer.MAX_VALUE;\\n        \\n        while(right<s.length()){\\n            if(map[sArray[right]] >0){\\n                count--;\\n            }\\n            map[sArray[right]]--;\\n\\n            while(count==0){\\n                if(right-left+1 < minLength){\\n                    minLength = right-left+1;\\n                    minStart = left;\\n                }\\n                map[sArray[left]]++;\\n                if(map[sArray[left]] > 0){\\n                    count++;\\n                }\\n                left++;\\n            }\\n            right++;\\n        }\\n        if(minLength>s.length()){\\n            return new String();\\n        }else{\\n            return s.substring(minStart, minStart+minLength);\\n        }\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public String minWindow(String s, String t) {\\n        if(s.length()==0 || t.length()==0 || s.length()<t.length()){\\n            return new String();\\n        }\\n        int[] map = new int[128];\\n        char[] sArray = s.toCharArray();\\n        char[] tArray = t.toCharArray();\\n\\n        for(char i : tArray){\\n            map[i]++;\\n        }\\n        int left = 0;\\n        int right=0;\\n        int count = t.length();\\n        int minStart = 0;\\n        int minLength=Integer.MAX_VALUE;\\n        \\n        while(right<s.length()){\\n            if(map[sArray[right]] >0){\\n                count--;\\n            }\\n            map[sArray[right]]--;\\n\\n            while(count==0){\\n                if(right-left+1 < minLength){\\n                    minLength = right-left+1;\\n                    minStart = left;\\n                }\\n                map[sArray[left]]++;\\n                if(map[sArray[left]] > 0){\\n                    count++;\\n                }\\n                left++;\\n            }\\n            right++;\\n        }\\n        if(minLength>s.length()){\\n            return new String();\\n        }else{\\n            return s.substring(minStart, minStart+minLength);\\n        }\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735531,
                "title": "python-solution-easy-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUsing 2 Hashmap and sliding window... \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minWindow(self, s: str, t: str) -> str:\\n        if (len(s) < len(t)):\\n            return \"\"\\n\\n        org = dict()\\n\\n        for val in t:\\n            org[val] = 1 + org.get(val, 0)\\n        \\n        hmap = dict()\\n        l, r = 0, 0\\n\\n        def isValid(hmap):\\n            cnt = 0\\n\\n            for i, j in hmap.items():\\n                if i in org and j >= org[i]:\\n                    cnt += 1\\n\\n            if (cnt != len(org)):\\n                return False\\n\\n            return True\\n\\n        min_val = inf\\n        start, end = -1, -1\\n\\n        for r, r_val in enumerate(s):\\n\\n            hmap[r_val] = 1 + hmap.get(r_val, 0)\\n\\n            while (l <= r and isValid(hmap)):\\n\\n                if min_val > r - l + 1:\\n                    min_val = r - l + 1\\n                    start, end = l, r + 1\\n\\n                hmap[s[l]] -= 1\\n                l += 1\\n\\n        return s[start : end]\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def minWindow(self, s: str, t: str) -> str:\\n        if (len(s) < len(t)):\\n            return \"\"\\n\\n        org = dict()\\n\\n        for val in t:\\n            org[val] = 1 + org.get(val, 0)\\n        \\n        hmap = dict()\\n        l, r = 0, 0\\n\\n        def isValid(hmap):\\n            cnt = 0\\n\\n            for i, j in hmap.items():\\n                if i in org and j >= org[i]:\\n                    cnt += 1\\n\\n            if (cnt != len(org)):\\n                return False\\n\\n            return True\\n\\n        min_val = inf\\n        start, end = -1, -1\\n\\n        for r, r_val in enumerate(s):\\n\\n            hmap[r_val] = 1 + hmap.get(r_val, 0)\\n\\n            while (l <= r and isValid(hmap)):\\n\\n                if min_val > r - l + 1:\\n                    min_val = r - l + 1\\n                    start, end = l, r + 1\\n\\n                hmap[s[l]] -= 1\\n                l += 1\\n\\n        return s[start : end]\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1570665,
                "content": [
                    {
                        "username": "pilot_n_programmer",
                        "content": "Got this problem at FB yesterday.\\nI solved it sometime ago on leetcode but during the interview I failed to do it.\\nIt was a second problem to solve, 20 mins left and all this time pressure+stress made me to panic.\\nI would expect that two problems in 45 mins would be Easy and Medium or worst case Medium/Medium but got Medium and Hard. \\nMoral of the story: don\\'t expect that you will get the same complexity tasks like others usually get - I find it is sort of lottery. Prepare for worst to make it done! And don\\'t stress or panic - it doesn\\'t help. Good luck everyone!"
                    },
                    {
                        "username": "Gracemann280",
                        "content": "i thought easy+medium was the usual so its better to expect medium /medium and some hard IG \\uD83E\\uDD27"
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this is brutal to ask in a short interview.. its not hard conceptually, but implementing it is a pain."
                    },
                    {
                        "username": "khuzii",
                        "content": "Hey can you please help me with this code? I am getting runtime error.\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        if(t.size() > s.size())  {\\n            return \"\";\\n        }\\n        map<char, int> mp;\\n        for(int i=0; i<t.size(); i++)  {\\n            mp.insert({t[i], i});\\n        }\\n        string ans;\\n        int minl= s.size()+1;\\n        string x=t;\\n        for(int i=0; i<t.size(); i++)  {\\n            x[i]=\\'#\\';\\n        }\\n        for(int i=0; i<s.size(); i++)  { \\n            string temp= \"\";\\n            string td= t;\\n            for(int j= i; j<s.size(); j++)  {\\n                if(t.find(s[j])!=string::npos && td!=x)  {\\n                    temp += s[j];\\n                    int y= td.find(s[j]);\\n                    td[y]= \\'#\\';\\n                }\\n                else if(td != x && temp.size()!=0)  {\\n                    temp += s[j];\\n                }\\n                else if(td == x)  {\\n                    if(minl > temp.size())  {\\n                        ans= temp;\\n                        minl= temp.size();\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "what\\'s u buddy\\n"
                    },
                    {
                        "username": "BamesJorn",
                        "content": "Have you tried it again?\\nIf yes - what were the questions?"
                    },
                    {
                        "username": "harrypotter0",
                        "content": "Here are the other sliding window problems to practice:\\n\\nhttps://leetcode.com/problems/sliding-window-maximum/\\nhttps://leetcode.com/problems/minimum-size-subarray-sum/\\nhttps://leetcode.com/problems/minimum-window-substring/\\nhttps://leetcode.com/problems/maximum-length-of-repeated-subarray/\\n\\n\\n\\n"
                    },
                    {
                        "username": "sandipan72",
                        "content": "thanks for the resources bro"
                    },
                    {
                        "username": "bhavesh1201",
                        "content": "thanks mate\\n"
                    },
                    {
                        "username": "petia",
                        "content": "I don\\'t know if it is just me, but I am really tired of the poor explanations of LC problems. Quite often we do not have any input restrictions and bounds. In this problem we don\\'t know if we expect duplicate characters in T, if we are looking for each distinct character of T in S, or literally every single one (i.e. T=\"aa\" and S=\"a\" - is this valid S or not...). Every time I need to submit my code to get to yet another failing test because there is some unmentioned restriction or requirement. In a real interview if this is the case I would ask clarifying questions, obviously this is not an option in this case. So annoying!"
                    },
                    {
                        "username": "trqkkr",
                        "content": "they purposefully try to word things in confusing ways too!"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Totally agree. They are frustrating in my opinion. I got lost with the \"BANC\" result myself. They also did not mention anything about case sensitivity. For the t=\"aa\" I think they want you to find exactly what is in t inside the s, in other words, 2 \\'a\\' characters in t should be found as well in \\'s\\'"
                    },
                    {
                        "username": "RyanYibingJia",
                        "content": "Just be careful for object `Integer`, using `Integer.intValue()` to compare the value of it.\\n\\n"
                    },
                    {
                        "username": "isamnagi",
                        "content": "This helped a lot for me. I cldnt get passed 266 but with this was able too... here is more context if anyone would like. basically, if you compare to Integers, you are comparing there references not there values... ints compare values.. https://stackoverflow.com/questions/4428774/why-java-does-not-see-that-integers-are-equal"
                    },
                    {
                        "username": "matcovic",
                        "content": "It really feels bad when you come up with a solution spending hours, only to receive a TLE on the last test cases with a 10^5 input size!"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "[@user5190JH](/user5190JH) Bro, that may be because you are using a quadratic time algorithm. Same with me. Try to find out a linear!"
                    },
                    {
                        "username": "sujal1245",
                        "content": "Same. 265/267 test cases passed. Now stuck due to TLE ;( Don\\'t want to look up the solution, will try to figure where I could improve."
                    },
                    {
                        "username": "khuzii",
                        "content": "Hey can you please help me with this code? It is giving runtime error.\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        if(t.size() > s.size())  {\\n            return \"\";\\n        }\\n        map<char, int> mp;\\n        for(int i=0; i<t.size(); i++)  {\\n            mp.insert({t[i], i});\\n        }\\n        string ans;\\n        int minl= s.size()+1;\\n        string x=t;\\n        for(int i=0; i<t.size(); i++)  {\\n            x[i]=\\'#\\';\\n        }\\n        for(int i=0; i<s.size(); i++)  { \\n            string temp= \"\";\\n            string td= t;\\n            for(int j= i; j<s.size(); j++)  {\\n                if(t.find(s[j])!=string::npos && td!=x)  {\\n                    temp += s[j];\\n                    int y= td.find(s[j]);\\n                    td[y]= \\'#\\';\\n                }\\n                else if(td != x && temp.size()!=0)  {\\n                    temp += s[j];\\n                }\\n                else if(td == x)  {\\n                    if(minl > temp.size())  {\\n                        ans= temp;\\n                        minl= temp.size();\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "bhanujggandhi",
                        "content": "Do not maintain the string variable and update it every time you find a better minimum substring. **Instead maintain pointers and create substring only once, otherwise there will be TLE/MLE**"
                    },
                    {
                        "username": "abhaydkumar80",
                        "content": "thanks I was stuck in this as well."
                    },
                    {
                        "username": "Shivi_Singh25",
                        "content": "Thank you. I was stuck there. But can you please explain why does that happen?\\n"
                    },
                    {
                        "username": "vineetsai3479",
                        "content": "it worked thanks"
                    },
                    {
                        "username": "hugjobk",
                        "content": "string object is just a pointer. It is very cheap to copy a string"
                    },
                    {
                        "username": "jtimberlakers",
                        "content": " \\n\\nThe Discription is \" Given a string S and a string T, find the minimum window in S which will contain all the characters in T \"\\n\\n \\n\\nsuppose S is \"a\", T is \"aa\"\\n\\n \\n\\nI think the answer should be \"a\" , the character in T is just \"a\", and S contain it. but the test answer is \"\". \\nshould the \"a\" character be twice in the window??"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": " I dunno if it was edited, but there\\'s the \"(including duplicates)\" part in the problem description."
                    },
                    {
                        "username": "conradkun",
                        "content": "Duplicates matter, so S would have to at least have 2 \\'a\\'."
                    },
                    {
                        "username": "ayushabg",
                        "content": "Very Badly written Description! I solved the problem believing that we need to match exact frequencies of characters in t in substrings of s. Only to find test case 192 failing. \\n\"aaaaaaaaaaaabbbbbcdd\", \"abcdd\"  -> \"abbbbbcdd\""
                    },
                    {
                        "username": "JoeDoba",
                        "content": "Why leetcode takes this problem as \"Hard\" which is marked as\"Easy\" in CodeSignal :)"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "How is this easy?"
                    },
                    {
                        "username": "isaackleinman",
                        "content": "It wasn\\'t clear to me from the description that the string `t` can have the same character repeated more than once, and all of these repeats have to be accounted for in `s`. \\n\\nThe description should make this clear."
                    },
                    {
                        "username": "lazarevzubov",
                        "content": " I dunno if it was edited, but there\\'s the \"(including duplicates)\" part in the problem description."
                    }
                ]
            },
            {
                "id": 1566848,
                "content": [
                    {
                        "username": "pilot_n_programmer",
                        "content": "Got this problem at FB yesterday.\\nI solved it sometime ago on leetcode but during the interview I failed to do it.\\nIt was a second problem to solve, 20 mins left and all this time pressure+stress made me to panic.\\nI would expect that two problems in 45 mins would be Easy and Medium or worst case Medium/Medium but got Medium and Hard. \\nMoral of the story: don\\'t expect that you will get the same complexity tasks like others usually get - I find it is sort of lottery. Prepare for worst to make it done! And don\\'t stress or panic - it doesn\\'t help. Good luck everyone!"
                    },
                    {
                        "username": "Gracemann280",
                        "content": "i thought easy+medium was the usual so its better to expect medium /medium and some hard IG \\uD83E\\uDD27"
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this is brutal to ask in a short interview.. its not hard conceptually, but implementing it is a pain."
                    },
                    {
                        "username": "khuzii",
                        "content": "Hey can you please help me with this code? I am getting runtime error.\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        if(t.size() > s.size())  {\\n            return \"\";\\n        }\\n        map<char, int> mp;\\n        for(int i=0; i<t.size(); i++)  {\\n            mp.insert({t[i], i});\\n        }\\n        string ans;\\n        int minl= s.size()+1;\\n        string x=t;\\n        for(int i=0; i<t.size(); i++)  {\\n            x[i]=\\'#\\';\\n        }\\n        for(int i=0; i<s.size(); i++)  { \\n            string temp= \"\";\\n            string td= t;\\n            for(int j= i; j<s.size(); j++)  {\\n                if(t.find(s[j])!=string::npos && td!=x)  {\\n                    temp += s[j];\\n                    int y= td.find(s[j]);\\n                    td[y]= \\'#\\';\\n                }\\n                else if(td != x && temp.size()!=0)  {\\n                    temp += s[j];\\n                }\\n                else if(td == x)  {\\n                    if(minl > temp.size())  {\\n                        ans= temp;\\n                        minl= temp.size();\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "what\\'s u buddy\\n"
                    },
                    {
                        "username": "BamesJorn",
                        "content": "Have you tried it again?\\nIf yes - what were the questions?"
                    },
                    {
                        "username": "harrypotter0",
                        "content": "Here are the other sliding window problems to practice:\\n\\nhttps://leetcode.com/problems/sliding-window-maximum/\\nhttps://leetcode.com/problems/minimum-size-subarray-sum/\\nhttps://leetcode.com/problems/minimum-window-substring/\\nhttps://leetcode.com/problems/maximum-length-of-repeated-subarray/\\n\\n\\n\\n"
                    },
                    {
                        "username": "sandipan72",
                        "content": "thanks for the resources bro"
                    },
                    {
                        "username": "bhavesh1201",
                        "content": "thanks mate\\n"
                    },
                    {
                        "username": "petia",
                        "content": "I don\\'t know if it is just me, but I am really tired of the poor explanations of LC problems. Quite often we do not have any input restrictions and bounds. In this problem we don\\'t know if we expect duplicate characters in T, if we are looking for each distinct character of T in S, or literally every single one (i.e. T=\"aa\" and S=\"a\" - is this valid S or not...). Every time I need to submit my code to get to yet another failing test because there is some unmentioned restriction or requirement. In a real interview if this is the case I would ask clarifying questions, obviously this is not an option in this case. So annoying!"
                    },
                    {
                        "username": "trqkkr",
                        "content": "they purposefully try to word things in confusing ways too!"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Totally agree. They are frustrating in my opinion. I got lost with the \"BANC\" result myself. They also did not mention anything about case sensitivity. For the t=\"aa\" I think they want you to find exactly what is in t inside the s, in other words, 2 \\'a\\' characters in t should be found as well in \\'s\\'"
                    },
                    {
                        "username": "RyanYibingJia",
                        "content": "Just be careful for object `Integer`, using `Integer.intValue()` to compare the value of it.\\n\\n"
                    },
                    {
                        "username": "isamnagi",
                        "content": "This helped a lot for me. I cldnt get passed 266 but with this was able too... here is more context if anyone would like. basically, if you compare to Integers, you are comparing there references not there values... ints compare values.. https://stackoverflow.com/questions/4428774/why-java-does-not-see-that-integers-are-equal"
                    },
                    {
                        "username": "matcovic",
                        "content": "It really feels bad when you come up with a solution spending hours, only to receive a TLE on the last test cases with a 10^5 input size!"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "[@user5190JH](/user5190JH) Bro, that may be because you are using a quadratic time algorithm. Same with me. Try to find out a linear!"
                    },
                    {
                        "username": "sujal1245",
                        "content": "Same. 265/267 test cases passed. Now stuck due to TLE ;( Don\\'t want to look up the solution, will try to figure where I could improve."
                    },
                    {
                        "username": "khuzii",
                        "content": "Hey can you please help me with this code? It is giving runtime error.\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        if(t.size() > s.size())  {\\n            return \"\";\\n        }\\n        map<char, int> mp;\\n        for(int i=0; i<t.size(); i++)  {\\n            mp.insert({t[i], i});\\n        }\\n        string ans;\\n        int minl= s.size()+1;\\n        string x=t;\\n        for(int i=0; i<t.size(); i++)  {\\n            x[i]=\\'#\\';\\n        }\\n        for(int i=0; i<s.size(); i++)  { \\n            string temp= \"\";\\n            string td= t;\\n            for(int j= i; j<s.size(); j++)  {\\n                if(t.find(s[j])!=string::npos && td!=x)  {\\n                    temp += s[j];\\n                    int y= td.find(s[j]);\\n                    td[y]= \\'#\\';\\n                }\\n                else if(td != x && temp.size()!=0)  {\\n                    temp += s[j];\\n                }\\n                else if(td == x)  {\\n                    if(minl > temp.size())  {\\n                        ans= temp;\\n                        minl= temp.size();\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "bhanujggandhi",
                        "content": "Do not maintain the string variable and update it every time you find a better minimum substring. **Instead maintain pointers and create substring only once, otherwise there will be TLE/MLE**"
                    },
                    {
                        "username": "abhaydkumar80",
                        "content": "thanks I was stuck in this as well."
                    },
                    {
                        "username": "Shivi_Singh25",
                        "content": "Thank you. I was stuck there. But can you please explain why does that happen?\\n"
                    },
                    {
                        "username": "vineetsai3479",
                        "content": "it worked thanks"
                    },
                    {
                        "username": "hugjobk",
                        "content": "string object is just a pointer. It is very cheap to copy a string"
                    },
                    {
                        "username": "jtimberlakers",
                        "content": " \\n\\nThe Discription is \" Given a string S and a string T, find the minimum window in S which will contain all the characters in T \"\\n\\n \\n\\nsuppose S is \"a\", T is \"aa\"\\n\\n \\n\\nI think the answer should be \"a\" , the character in T is just \"a\", and S contain it. but the test answer is \"\". \\nshould the \"a\" character be twice in the window??"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": " I dunno if it was edited, but there\\'s the \"(including duplicates)\" part in the problem description."
                    },
                    {
                        "username": "conradkun",
                        "content": "Duplicates matter, so S would have to at least have 2 \\'a\\'."
                    },
                    {
                        "username": "ayushabg",
                        "content": "Very Badly written Description! I solved the problem believing that we need to match exact frequencies of characters in t in substrings of s. Only to find test case 192 failing. \\n\"aaaaaaaaaaaabbbbbcdd\", \"abcdd\"  -> \"abbbbbcdd\""
                    },
                    {
                        "username": "JoeDoba",
                        "content": "Why leetcode takes this problem as \"Hard\" which is marked as\"Easy\" in CodeSignal :)"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "How is this easy?"
                    },
                    {
                        "username": "isaackleinman",
                        "content": "It wasn\\'t clear to me from the description that the string `t` can have the same character repeated more than once, and all of these repeats have to be accounted for in `s`. \\n\\nThe description should make this clear."
                    },
                    {
                        "username": "lazarevzubov",
                        "content": " I dunno if it was edited, but there\\'s the \"(including duplicates)\" part in the problem description."
                    }
                ]
            },
            {
                "id": 1565295,
                "content": [
                    {
                        "username": "pilot_n_programmer",
                        "content": "Got this problem at FB yesterday.\\nI solved it sometime ago on leetcode but during the interview I failed to do it.\\nIt was a second problem to solve, 20 mins left and all this time pressure+stress made me to panic.\\nI would expect that two problems in 45 mins would be Easy and Medium or worst case Medium/Medium but got Medium and Hard. \\nMoral of the story: don\\'t expect that you will get the same complexity tasks like others usually get - I find it is sort of lottery. Prepare for worst to make it done! And don\\'t stress or panic - it doesn\\'t help. Good luck everyone!"
                    },
                    {
                        "username": "Gracemann280",
                        "content": "i thought easy+medium was the usual so its better to expect medium /medium and some hard IG \\uD83E\\uDD27"
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this is brutal to ask in a short interview.. its not hard conceptually, but implementing it is a pain."
                    },
                    {
                        "username": "khuzii",
                        "content": "Hey can you please help me with this code? I am getting runtime error.\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        if(t.size() > s.size())  {\\n            return \"\";\\n        }\\n        map<char, int> mp;\\n        for(int i=0; i<t.size(); i++)  {\\n            mp.insert({t[i], i});\\n        }\\n        string ans;\\n        int minl= s.size()+1;\\n        string x=t;\\n        for(int i=0; i<t.size(); i++)  {\\n            x[i]=\\'#\\';\\n        }\\n        for(int i=0; i<s.size(); i++)  { \\n            string temp= \"\";\\n            string td= t;\\n            for(int j= i; j<s.size(); j++)  {\\n                if(t.find(s[j])!=string::npos && td!=x)  {\\n                    temp += s[j];\\n                    int y= td.find(s[j]);\\n                    td[y]= \\'#\\';\\n                }\\n                else if(td != x && temp.size()!=0)  {\\n                    temp += s[j];\\n                }\\n                else if(td == x)  {\\n                    if(minl > temp.size())  {\\n                        ans= temp;\\n                        minl= temp.size();\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "what\\'s u buddy\\n"
                    },
                    {
                        "username": "BamesJorn",
                        "content": "Have you tried it again?\\nIf yes - what were the questions?"
                    },
                    {
                        "username": "harrypotter0",
                        "content": "Here are the other sliding window problems to practice:\\n\\nhttps://leetcode.com/problems/sliding-window-maximum/\\nhttps://leetcode.com/problems/minimum-size-subarray-sum/\\nhttps://leetcode.com/problems/minimum-window-substring/\\nhttps://leetcode.com/problems/maximum-length-of-repeated-subarray/\\n\\n\\n\\n"
                    },
                    {
                        "username": "sandipan72",
                        "content": "thanks for the resources bro"
                    },
                    {
                        "username": "bhavesh1201",
                        "content": "thanks mate\\n"
                    },
                    {
                        "username": "petia",
                        "content": "I don\\'t know if it is just me, but I am really tired of the poor explanations of LC problems. Quite often we do not have any input restrictions and bounds. In this problem we don\\'t know if we expect duplicate characters in T, if we are looking for each distinct character of T in S, or literally every single one (i.e. T=\"aa\" and S=\"a\" - is this valid S or not...). Every time I need to submit my code to get to yet another failing test because there is some unmentioned restriction or requirement. In a real interview if this is the case I would ask clarifying questions, obviously this is not an option in this case. So annoying!"
                    },
                    {
                        "username": "trqkkr",
                        "content": "they purposefully try to word things in confusing ways too!"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Totally agree. They are frustrating in my opinion. I got lost with the \"BANC\" result myself. They also did not mention anything about case sensitivity. For the t=\"aa\" I think they want you to find exactly what is in t inside the s, in other words, 2 \\'a\\' characters in t should be found as well in \\'s\\'"
                    },
                    {
                        "username": "RyanYibingJia",
                        "content": "Just be careful for object `Integer`, using `Integer.intValue()` to compare the value of it.\\n\\n"
                    },
                    {
                        "username": "isamnagi",
                        "content": "This helped a lot for me. I cldnt get passed 266 but with this was able too... here is more context if anyone would like. basically, if you compare to Integers, you are comparing there references not there values... ints compare values.. https://stackoverflow.com/questions/4428774/why-java-does-not-see-that-integers-are-equal"
                    },
                    {
                        "username": "matcovic",
                        "content": "It really feels bad when you come up with a solution spending hours, only to receive a TLE on the last test cases with a 10^5 input size!"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "[@user5190JH](/user5190JH) Bro, that may be because you are using a quadratic time algorithm. Same with me. Try to find out a linear!"
                    },
                    {
                        "username": "sujal1245",
                        "content": "Same. 265/267 test cases passed. Now stuck due to TLE ;( Don\\'t want to look up the solution, will try to figure where I could improve."
                    },
                    {
                        "username": "khuzii",
                        "content": "Hey can you please help me with this code? It is giving runtime error.\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        if(t.size() > s.size())  {\\n            return \"\";\\n        }\\n        map<char, int> mp;\\n        for(int i=0; i<t.size(); i++)  {\\n            mp.insert({t[i], i});\\n        }\\n        string ans;\\n        int minl= s.size()+1;\\n        string x=t;\\n        for(int i=0; i<t.size(); i++)  {\\n            x[i]=\\'#\\';\\n        }\\n        for(int i=0; i<s.size(); i++)  { \\n            string temp= \"\";\\n            string td= t;\\n            for(int j= i; j<s.size(); j++)  {\\n                if(t.find(s[j])!=string::npos && td!=x)  {\\n                    temp += s[j];\\n                    int y= td.find(s[j]);\\n                    td[y]= \\'#\\';\\n                }\\n                else if(td != x && temp.size()!=0)  {\\n                    temp += s[j];\\n                }\\n                else if(td == x)  {\\n                    if(minl > temp.size())  {\\n                        ans= temp;\\n                        minl= temp.size();\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "bhanujggandhi",
                        "content": "Do not maintain the string variable and update it every time you find a better minimum substring. **Instead maintain pointers and create substring only once, otherwise there will be TLE/MLE**"
                    },
                    {
                        "username": "abhaydkumar80",
                        "content": "thanks I was stuck in this as well."
                    },
                    {
                        "username": "Shivi_Singh25",
                        "content": "Thank you. I was stuck there. But can you please explain why does that happen?\\n"
                    },
                    {
                        "username": "vineetsai3479",
                        "content": "it worked thanks"
                    },
                    {
                        "username": "hugjobk",
                        "content": "string object is just a pointer. It is very cheap to copy a string"
                    },
                    {
                        "username": "jtimberlakers",
                        "content": " \\n\\nThe Discription is \" Given a string S and a string T, find the minimum window in S which will contain all the characters in T \"\\n\\n \\n\\nsuppose S is \"a\", T is \"aa\"\\n\\n \\n\\nI think the answer should be \"a\" , the character in T is just \"a\", and S contain it. but the test answer is \"\". \\nshould the \"a\" character be twice in the window??"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": " I dunno if it was edited, but there\\'s the \"(including duplicates)\" part in the problem description."
                    },
                    {
                        "username": "conradkun",
                        "content": "Duplicates matter, so S would have to at least have 2 \\'a\\'."
                    },
                    {
                        "username": "ayushabg",
                        "content": "Very Badly written Description! I solved the problem believing that we need to match exact frequencies of characters in t in substrings of s. Only to find test case 192 failing. \\n\"aaaaaaaaaaaabbbbbcdd\", \"abcdd\"  -> \"abbbbbcdd\""
                    },
                    {
                        "username": "JoeDoba",
                        "content": "Why leetcode takes this problem as \"Hard\" which is marked as\"Easy\" in CodeSignal :)"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "How is this easy?"
                    },
                    {
                        "username": "isaackleinman",
                        "content": "It wasn\\'t clear to me from the description that the string `t` can have the same character repeated more than once, and all of these repeats have to be accounted for in `s`. \\n\\nThe description should make this clear."
                    },
                    {
                        "username": "lazarevzubov",
                        "content": " I dunno if it was edited, but there\\'s the \"(including duplicates)\" part in the problem description."
                    }
                ]
            },
            {
                "id": 1566179,
                "content": [
                    {
                        "username": "pilot_n_programmer",
                        "content": "Got this problem at FB yesterday.\\nI solved it sometime ago on leetcode but during the interview I failed to do it.\\nIt was a second problem to solve, 20 mins left and all this time pressure+stress made me to panic.\\nI would expect that two problems in 45 mins would be Easy and Medium or worst case Medium/Medium but got Medium and Hard. \\nMoral of the story: don\\'t expect that you will get the same complexity tasks like others usually get - I find it is sort of lottery. Prepare for worst to make it done! And don\\'t stress or panic - it doesn\\'t help. Good luck everyone!"
                    },
                    {
                        "username": "Gracemann280",
                        "content": "i thought easy+medium was the usual so its better to expect medium /medium and some hard IG \\uD83E\\uDD27"
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this is brutal to ask in a short interview.. its not hard conceptually, but implementing it is a pain."
                    },
                    {
                        "username": "khuzii",
                        "content": "Hey can you please help me with this code? I am getting runtime error.\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        if(t.size() > s.size())  {\\n            return \"\";\\n        }\\n        map<char, int> mp;\\n        for(int i=0; i<t.size(); i++)  {\\n            mp.insert({t[i], i});\\n        }\\n        string ans;\\n        int minl= s.size()+1;\\n        string x=t;\\n        for(int i=0; i<t.size(); i++)  {\\n            x[i]=\\'#\\';\\n        }\\n        for(int i=0; i<s.size(); i++)  { \\n            string temp= \"\";\\n            string td= t;\\n            for(int j= i; j<s.size(); j++)  {\\n                if(t.find(s[j])!=string::npos && td!=x)  {\\n                    temp += s[j];\\n                    int y= td.find(s[j]);\\n                    td[y]= \\'#\\';\\n                }\\n                else if(td != x && temp.size()!=0)  {\\n                    temp += s[j];\\n                }\\n                else if(td == x)  {\\n                    if(minl > temp.size())  {\\n                        ans= temp;\\n                        minl= temp.size();\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "what\\'s u buddy\\n"
                    },
                    {
                        "username": "BamesJorn",
                        "content": "Have you tried it again?\\nIf yes - what were the questions?"
                    },
                    {
                        "username": "harrypotter0",
                        "content": "Here are the other sliding window problems to practice:\\n\\nhttps://leetcode.com/problems/sliding-window-maximum/\\nhttps://leetcode.com/problems/minimum-size-subarray-sum/\\nhttps://leetcode.com/problems/minimum-window-substring/\\nhttps://leetcode.com/problems/maximum-length-of-repeated-subarray/\\n\\n\\n\\n"
                    },
                    {
                        "username": "sandipan72",
                        "content": "thanks for the resources bro"
                    },
                    {
                        "username": "bhavesh1201",
                        "content": "thanks mate\\n"
                    },
                    {
                        "username": "petia",
                        "content": "I don\\'t know if it is just me, but I am really tired of the poor explanations of LC problems. Quite often we do not have any input restrictions and bounds. In this problem we don\\'t know if we expect duplicate characters in T, if we are looking for each distinct character of T in S, or literally every single one (i.e. T=\"aa\" and S=\"a\" - is this valid S or not...). Every time I need to submit my code to get to yet another failing test because there is some unmentioned restriction or requirement. In a real interview if this is the case I would ask clarifying questions, obviously this is not an option in this case. So annoying!"
                    },
                    {
                        "username": "trqkkr",
                        "content": "they purposefully try to word things in confusing ways too!"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Totally agree. They are frustrating in my opinion. I got lost with the \"BANC\" result myself. They also did not mention anything about case sensitivity. For the t=\"aa\" I think they want you to find exactly what is in t inside the s, in other words, 2 \\'a\\' characters in t should be found as well in \\'s\\'"
                    },
                    {
                        "username": "RyanYibingJia",
                        "content": "Just be careful for object `Integer`, using `Integer.intValue()` to compare the value of it.\\n\\n"
                    },
                    {
                        "username": "isamnagi",
                        "content": "This helped a lot for me. I cldnt get passed 266 but with this was able too... here is more context if anyone would like. basically, if you compare to Integers, you are comparing there references not there values... ints compare values.. https://stackoverflow.com/questions/4428774/why-java-does-not-see-that-integers-are-equal"
                    },
                    {
                        "username": "matcovic",
                        "content": "It really feels bad when you come up with a solution spending hours, only to receive a TLE on the last test cases with a 10^5 input size!"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "[@user5190JH](/user5190JH) Bro, that may be because you are using a quadratic time algorithm. Same with me. Try to find out a linear!"
                    },
                    {
                        "username": "sujal1245",
                        "content": "Same. 265/267 test cases passed. Now stuck due to TLE ;( Don\\'t want to look up the solution, will try to figure where I could improve."
                    },
                    {
                        "username": "khuzii",
                        "content": "Hey can you please help me with this code? It is giving runtime error.\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        if(t.size() > s.size())  {\\n            return \"\";\\n        }\\n        map<char, int> mp;\\n        for(int i=0; i<t.size(); i++)  {\\n            mp.insert({t[i], i});\\n        }\\n        string ans;\\n        int minl= s.size()+1;\\n        string x=t;\\n        for(int i=0; i<t.size(); i++)  {\\n            x[i]=\\'#\\';\\n        }\\n        for(int i=0; i<s.size(); i++)  { \\n            string temp= \"\";\\n            string td= t;\\n            for(int j= i; j<s.size(); j++)  {\\n                if(t.find(s[j])!=string::npos && td!=x)  {\\n                    temp += s[j];\\n                    int y= td.find(s[j]);\\n                    td[y]= \\'#\\';\\n                }\\n                else if(td != x && temp.size()!=0)  {\\n                    temp += s[j];\\n                }\\n                else if(td == x)  {\\n                    if(minl > temp.size())  {\\n                        ans= temp;\\n                        minl= temp.size();\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "bhanujggandhi",
                        "content": "Do not maintain the string variable and update it every time you find a better minimum substring. **Instead maintain pointers and create substring only once, otherwise there will be TLE/MLE**"
                    },
                    {
                        "username": "abhaydkumar80",
                        "content": "thanks I was stuck in this as well."
                    },
                    {
                        "username": "Shivi_Singh25",
                        "content": "Thank you. I was stuck there. But can you please explain why does that happen?\\n"
                    },
                    {
                        "username": "vineetsai3479",
                        "content": "it worked thanks"
                    },
                    {
                        "username": "hugjobk",
                        "content": "string object is just a pointer. It is very cheap to copy a string"
                    },
                    {
                        "username": "jtimberlakers",
                        "content": " \\n\\nThe Discription is \" Given a string S and a string T, find the minimum window in S which will contain all the characters in T \"\\n\\n \\n\\nsuppose S is \"a\", T is \"aa\"\\n\\n \\n\\nI think the answer should be \"a\" , the character in T is just \"a\", and S contain it. but the test answer is \"\". \\nshould the \"a\" character be twice in the window??"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": " I dunno if it was edited, but there\\'s the \"(including duplicates)\" part in the problem description."
                    },
                    {
                        "username": "conradkun",
                        "content": "Duplicates matter, so S would have to at least have 2 \\'a\\'."
                    },
                    {
                        "username": "ayushabg",
                        "content": "Very Badly written Description! I solved the problem believing that we need to match exact frequencies of characters in t in substrings of s. Only to find test case 192 failing. \\n\"aaaaaaaaaaaabbbbbcdd\", \"abcdd\"  -> \"abbbbbcdd\""
                    },
                    {
                        "username": "JoeDoba",
                        "content": "Why leetcode takes this problem as \"Hard\" which is marked as\"Easy\" in CodeSignal :)"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "How is this easy?"
                    },
                    {
                        "username": "isaackleinman",
                        "content": "It wasn\\'t clear to me from the description that the string `t` can have the same character repeated more than once, and all of these repeats have to be accounted for in `s`. \\n\\nThe description should make this clear."
                    },
                    {
                        "username": "lazarevzubov",
                        "content": " I dunno if it was edited, but there\\'s the \"(including duplicates)\" part in the problem description."
                    }
                ]
            },
            {
                "id": 1782747,
                "content": [
                    {
                        "username": "pilot_n_programmer",
                        "content": "Got this problem at FB yesterday.\\nI solved it sometime ago on leetcode but during the interview I failed to do it.\\nIt was a second problem to solve, 20 mins left and all this time pressure+stress made me to panic.\\nI would expect that two problems in 45 mins would be Easy and Medium or worst case Medium/Medium but got Medium and Hard. \\nMoral of the story: don\\'t expect that you will get the same complexity tasks like others usually get - I find it is sort of lottery. Prepare for worst to make it done! And don\\'t stress or panic - it doesn\\'t help. Good luck everyone!"
                    },
                    {
                        "username": "Gracemann280",
                        "content": "i thought easy+medium was the usual so its better to expect medium /medium and some hard IG \\uD83E\\uDD27"
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this is brutal to ask in a short interview.. its not hard conceptually, but implementing it is a pain."
                    },
                    {
                        "username": "khuzii",
                        "content": "Hey can you please help me with this code? I am getting runtime error.\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        if(t.size() > s.size())  {\\n            return \"\";\\n        }\\n        map<char, int> mp;\\n        for(int i=0; i<t.size(); i++)  {\\n            mp.insert({t[i], i});\\n        }\\n        string ans;\\n        int minl= s.size()+1;\\n        string x=t;\\n        for(int i=0; i<t.size(); i++)  {\\n            x[i]=\\'#\\';\\n        }\\n        for(int i=0; i<s.size(); i++)  { \\n            string temp= \"\";\\n            string td= t;\\n            for(int j= i; j<s.size(); j++)  {\\n                if(t.find(s[j])!=string::npos && td!=x)  {\\n                    temp += s[j];\\n                    int y= td.find(s[j]);\\n                    td[y]= \\'#\\';\\n                }\\n                else if(td != x && temp.size()!=0)  {\\n                    temp += s[j];\\n                }\\n                else if(td == x)  {\\n                    if(minl > temp.size())  {\\n                        ans= temp;\\n                        minl= temp.size();\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "what\\'s u buddy\\n"
                    },
                    {
                        "username": "BamesJorn",
                        "content": "Have you tried it again?\\nIf yes - what were the questions?"
                    },
                    {
                        "username": "harrypotter0",
                        "content": "Here are the other sliding window problems to practice:\\n\\nhttps://leetcode.com/problems/sliding-window-maximum/\\nhttps://leetcode.com/problems/minimum-size-subarray-sum/\\nhttps://leetcode.com/problems/minimum-window-substring/\\nhttps://leetcode.com/problems/maximum-length-of-repeated-subarray/\\n\\n\\n\\n"
                    },
                    {
                        "username": "sandipan72",
                        "content": "thanks for the resources bro"
                    },
                    {
                        "username": "bhavesh1201",
                        "content": "thanks mate\\n"
                    },
                    {
                        "username": "petia",
                        "content": "I don\\'t know if it is just me, but I am really tired of the poor explanations of LC problems. Quite often we do not have any input restrictions and bounds. In this problem we don\\'t know if we expect duplicate characters in T, if we are looking for each distinct character of T in S, or literally every single one (i.e. T=\"aa\" and S=\"a\" - is this valid S or not...). Every time I need to submit my code to get to yet another failing test because there is some unmentioned restriction or requirement. In a real interview if this is the case I would ask clarifying questions, obviously this is not an option in this case. So annoying!"
                    },
                    {
                        "username": "trqkkr",
                        "content": "they purposefully try to word things in confusing ways too!"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Totally agree. They are frustrating in my opinion. I got lost with the \"BANC\" result myself. They also did not mention anything about case sensitivity. For the t=\"aa\" I think they want you to find exactly what is in t inside the s, in other words, 2 \\'a\\' characters in t should be found as well in \\'s\\'"
                    },
                    {
                        "username": "RyanYibingJia",
                        "content": "Just be careful for object `Integer`, using `Integer.intValue()` to compare the value of it.\\n\\n"
                    },
                    {
                        "username": "isamnagi",
                        "content": "This helped a lot for me. I cldnt get passed 266 but with this was able too... here is more context if anyone would like. basically, if you compare to Integers, you are comparing there references not there values... ints compare values.. https://stackoverflow.com/questions/4428774/why-java-does-not-see-that-integers-are-equal"
                    },
                    {
                        "username": "matcovic",
                        "content": "It really feels bad when you come up with a solution spending hours, only to receive a TLE on the last test cases with a 10^5 input size!"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "[@user5190JH](/user5190JH) Bro, that may be because you are using a quadratic time algorithm. Same with me. Try to find out a linear!"
                    },
                    {
                        "username": "sujal1245",
                        "content": "Same. 265/267 test cases passed. Now stuck due to TLE ;( Don\\'t want to look up the solution, will try to figure where I could improve."
                    },
                    {
                        "username": "khuzii",
                        "content": "Hey can you please help me with this code? It is giving runtime error.\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        if(t.size() > s.size())  {\\n            return \"\";\\n        }\\n        map<char, int> mp;\\n        for(int i=0; i<t.size(); i++)  {\\n            mp.insert({t[i], i});\\n        }\\n        string ans;\\n        int minl= s.size()+1;\\n        string x=t;\\n        for(int i=0; i<t.size(); i++)  {\\n            x[i]=\\'#\\';\\n        }\\n        for(int i=0; i<s.size(); i++)  { \\n            string temp= \"\";\\n            string td= t;\\n            for(int j= i; j<s.size(); j++)  {\\n                if(t.find(s[j])!=string::npos && td!=x)  {\\n                    temp += s[j];\\n                    int y= td.find(s[j]);\\n                    td[y]= \\'#\\';\\n                }\\n                else if(td != x && temp.size()!=0)  {\\n                    temp += s[j];\\n                }\\n                else if(td == x)  {\\n                    if(minl > temp.size())  {\\n                        ans= temp;\\n                        minl= temp.size();\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "bhanujggandhi",
                        "content": "Do not maintain the string variable and update it every time you find a better minimum substring. **Instead maintain pointers and create substring only once, otherwise there will be TLE/MLE**"
                    },
                    {
                        "username": "abhaydkumar80",
                        "content": "thanks I was stuck in this as well."
                    },
                    {
                        "username": "Shivi_Singh25",
                        "content": "Thank you. I was stuck there. But can you please explain why does that happen?\\n"
                    },
                    {
                        "username": "vineetsai3479",
                        "content": "it worked thanks"
                    },
                    {
                        "username": "hugjobk",
                        "content": "string object is just a pointer. It is very cheap to copy a string"
                    },
                    {
                        "username": "jtimberlakers",
                        "content": " \\n\\nThe Discription is \" Given a string S and a string T, find the minimum window in S which will contain all the characters in T \"\\n\\n \\n\\nsuppose S is \"a\", T is \"aa\"\\n\\n \\n\\nI think the answer should be \"a\" , the character in T is just \"a\", and S contain it. but the test answer is \"\". \\nshould the \"a\" character be twice in the window??"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": " I dunno if it was edited, but there\\'s the \"(including duplicates)\" part in the problem description."
                    },
                    {
                        "username": "conradkun",
                        "content": "Duplicates matter, so S would have to at least have 2 \\'a\\'."
                    },
                    {
                        "username": "ayushabg",
                        "content": "Very Badly written Description! I solved the problem believing that we need to match exact frequencies of characters in t in substrings of s. Only to find test case 192 failing. \\n\"aaaaaaaaaaaabbbbbcdd\", \"abcdd\"  -> \"abbbbbcdd\""
                    },
                    {
                        "username": "JoeDoba",
                        "content": "Why leetcode takes this problem as \"Hard\" which is marked as\"Easy\" in CodeSignal :)"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "How is this easy?"
                    },
                    {
                        "username": "isaackleinman",
                        "content": "It wasn\\'t clear to me from the description that the string `t` can have the same character repeated more than once, and all of these repeats have to be accounted for in `s`. \\n\\nThe description should make this clear."
                    },
                    {
                        "username": "lazarevzubov",
                        "content": " I dunno if it was edited, but there\\'s the \"(including duplicates)\" part in the problem description."
                    }
                ]
            },
            {
                "id": 1741463,
                "content": [
                    {
                        "username": "pilot_n_programmer",
                        "content": "Got this problem at FB yesterday.\\nI solved it sometime ago on leetcode but during the interview I failed to do it.\\nIt was a second problem to solve, 20 mins left and all this time pressure+stress made me to panic.\\nI would expect that two problems in 45 mins would be Easy and Medium or worst case Medium/Medium but got Medium and Hard. \\nMoral of the story: don\\'t expect that you will get the same complexity tasks like others usually get - I find it is sort of lottery. Prepare for worst to make it done! And don\\'t stress or panic - it doesn\\'t help. Good luck everyone!"
                    },
                    {
                        "username": "Gracemann280",
                        "content": "i thought easy+medium was the usual so its better to expect medium /medium and some hard IG \\uD83E\\uDD27"
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this is brutal to ask in a short interview.. its not hard conceptually, but implementing it is a pain."
                    },
                    {
                        "username": "khuzii",
                        "content": "Hey can you please help me with this code? I am getting runtime error.\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        if(t.size() > s.size())  {\\n            return \"\";\\n        }\\n        map<char, int> mp;\\n        for(int i=0; i<t.size(); i++)  {\\n            mp.insert({t[i], i});\\n        }\\n        string ans;\\n        int minl= s.size()+1;\\n        string x=t;\\n        for(int i=0; i<t.size(); i++)  {\\n            x[i]=\\'#\\';\\n        }\\n        for(int i=0; i<s.size(); i++)  { \\n            string temp= \"\";\\n            string td= t;\\n            for(int j= i; j<s.size(); j++)  {\\n                if(t.find(s[j])!=string::npos && td!=x)  {\\n                    temp += s[j];\\n                    int y= td.find(s[j]);\\n                    td[y]= \\'#\\';\\n                }\\n                else if(td != x && temp.size()!=0)  {\\n                    temp += s[j];\\n                }\\n                else if(td == x)  {\\n                    if(minl > temp.size())  {\\n                        ans= temp;\\n                        minl= temp.size();\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "what\\'s u buddy\\n"
                    },
                    {
                        "username": "BamesJorn",
                        "content": "Have you tried it again?\\nIf yes - what were the questions?"
                    },
                    {
                        "username": "harrypotter0",
                        "content": "Here are the other sliding window problems to practice:\\n\\nhttps://leetcode.com/problems/sliding-window-maximum/\\nhttps://leetcode.com/problems/minimum-size-subarray-sum/\\nhttps://leetcode.com/problems/minimum-window-substring/\\nhttps://leetcode.com/problems/maximum-length-of-repeated-subarray/\\n\\n\\n\\n"
                    },
                    {
                        "username": "sandipan72",
                        "content": "thanks for the resources bro"
                    },
                    {
                        "username": "bhavesh1201",
                        "content": "thanks mate\\n"
                    },
                    {
                        "username": "petia",
                        "content": "I don\\'t know if it is just me, but I am really tired of the poor explanations of LC problems. Quite often we do not have any input restrictions and bounds. In this problem we don\\'t know if we expect duplicate characters in T, if we are looking for each distinct character of T in S, or literally every single one (i.e. T=\"aa\" and S=\"a\" - is this valid S or not...). Every time I need to submit my code to get to yet another failing test because there is some unmentioned restriction or requirement. In a real interview if this is the case I would ask clarifying questions, obviously this is not an option in this case. So annoying!"
                    },
                    {
                        "username": "trqkkr",
                        "content": "they purposefully try to word things in confusing ways too!"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Totally agree. They are frustrating in my opinion. I got lost with the \"BANC\" result myself. They also did not mention anything about case sensitivity. For the t=\"aa\" I think they want you to find exactly what is in t inside the s, in other words, 2 \\'a\\' characters in t should be found as well in \\'s\\'"
                    },
                    {
                        "username": "RyanYibingJia",
                        "content": "Just be careful for object `Integer`, using `Integer.intValue()` to compare the value of it.\\n\\n"
                    },
                    {
                        "username": "isamnagi",
                        "content": "This helped a lot for me. I cldnt get passed 266 but with this was able too... here is more context if anyone would like. basically, if you compare to Integers, you are comparing there references not there values... ints compare values.. https://stackoverflow.com/questions/4428774/why-java-does-not-see-that-integers-are-equal"
                    },
                    {
                        "username": "matcovic",
                        "content": "It really feels bad when you come up with a solution spending hours, only to receive a TLE on the last test cases with a 10^5 input size!"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "[@user5190JH](/user5190JH) Bro, that may be because you are using a quadratic time algorithm. Same with me. Try to find out a linear!"
                    },
                    {
                        "username": "sujal1245",
                        "content": "Same. 265/267 test cases passed. Now stuck due to TLE ;( Don\\'t want to look up the solution, will try to figure where I could improve."
                    },
                    {
                        "username": "khuzii",
                        "content": "Hey can you please help me with this code? It is giving runtime error.\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        if(t.size() > s.size())  {\\n            return \"\";\\n        }\\n        map<char, int> mp;\\n        for(int i=0; i<t.size(); i++)  {\\n            mp.insert({t[i], i});\\n        }\\n        string ans;\\n        int minl= s.size()+1;\\n        string x=t;\\n        for(int i=0; i<t.size(); i++)  {\\n            x[i]=\\'#\\';\\n        }\\n        for(int i=0; i<s.size(); i++)  { \\n            string temp= \"\";\\n            string td= t;\\n            for(int j= i; j<s.size(); j++)  {\\n                if(t.find(s[j])!=string::npos && td!=x)  {\\n                    temp += s[j];\\n                    int y= td.find(s[j]);\\n                    td[y]= \\'#\\';\\n                }\\n                else if(td != x && temp.size()!=0)  {\\n                    temp += s[j];\\n                }\\n                else if(td == x)  {\\n                    if(minl > temp.size())  {\\n                        ans= temp;\\n                        minl= temp.size();\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "bhanujggandhi",
                        "content": "Do not maintain the string variable and update it every time you find a better minimum substring. **Instead maintain pointers and create substring only once, otherwise there will be TLE/MLE**"
                    },
                    {
                        "username": "abhaydkumar80",
                        "content": "thanks I was stuck in this as well."
                    },
                    {
                        "username": "Shivi_Singh25",
                        "content": "Thank you. I was stuck there. But can you please explain why does that happen?\\n"
                    },
                    {
                        "username": "vineetsai3479",
                        "content": "it worked thanks"
                    },
                    {
                        "username": "hugjobk",
                        "content": "string object is just a pointer. It is very cheap to copy a string"
                    },
                    {
                        "username": "jtimberlakers",
                        "content": " \\n\\nThe Discription is \" Given a string S and a string T, find the minimum window in S which will contain all the characters in T \"\\n\\n \\n\\nsuppose S is \"a\", T is \"aa\"\\n\\n \\n\\nI think the answer should be \"a\" , the character in T is just \"a\", and S contain it. but the test answer is \"\". \\nshould the \"a\" character be twice in the window??"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": " I dunno if it was edited, but there\\'s the \"(including duplicates)\" part in the problem description."
                    },
                    {
                        "username": "conradkun",
                        "content": "Duplicates matter, so S would have to at least have 2 \\'a\\'."
                    },
                    {
                        "username": "ayushabg",
                        "content": "Very Badly written Description! I solved the problem believing that we need to match exact frequencies of characters in t in substrings of s. Only to find test case 192 failing. \\n\"aaaaaaaaaaaabbbbbcdd\", \"abcdd\"  -> \"abbbbbcdd\""
                    },
                    {
                        "username": "JoeDoba",
                        "content": "Why leetcode takes this problem as \"Hard\" which is marked as\"Easy\" in CodeSignal :)"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "How is this easy?"
                    },
                    {
                        "username": "isaackleinman",
                        "content": "It wasn\\'t clear to me from the description that the string `t` can have the same character repeated more than once, and all of these repeats have to be accounted for in `s`. \\n\\nThe description should make this clear."
                    },
                    {
                        "username": "lazarevzubov",
                        "content": " I dunno if it was edited, but there\\'s the \"(including duplicates)\" part in the problem description."
                    }
                ]
            },
            {
                "id": 1565943,
                "content": [
                    {
                        "username": "pilot_n_programmer",
                        "content": "Got this problem at FB yesterday.\\nI solved it sometime ago on leetcode but during the interview I failed to do it.\\nIt was a second problem to solve, 20 mins left and all this time pressure+stress made me to panic.\\nI would expect that two problems in 45 mins would be Easy and Medium or worst case Medium/Medium but got Medium and Hard. \\nMoral of the story: don\\'t expect that you will get the same complexity tasks like others usually get - I find it is sort of lottery. Prepare for worst to make it done! And don\\'t stress or panic - it doesn\\'t help. Good luck everyone!"
                    },
                    {
                        "username": "Gracemann280",
                        "content": "i thought easy+medium was the usual so its better to expect medium /medium and some hard IG \\uD83E\\uDD27"
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this is brutal to ask in a short interview.. its not hard conceptually, but implementing it is a pain."
                    },
                    {
                        "username": "khuzii",
                        "content": "Hey can you please help me with this code? I am getting runtime error.\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        if(t.size() > s.size())  {\\n            return \"\";\\n        }\\n        map<char, int> mp;\\n        for(int i=0; i<t.size(); i++)  {\\n            mp.insert({t[i], i});\\n        }\\n        string ans;\\n        int minl= s.size()+1;\\n        string x=t;\\n        for(int i=0; i<t.size(); i++)  {\\n            x[i]=\\'#\\';\\n        }\\n        for(int i=0; i<s.size(); i++)  { \\n            string temp= \"\";\\n            string td= t;\\n            for(int j= i; j<s.size(); j++)  {\\n                if(t.find(s[j])!=string::npos && td!=x)  {\\n                    temp += s[j];\\n                    int y= td.find(s[j]);\\n                    td[y]= \\'#\\';\\n                }\\n                else if(td != x && temp.size()!=0)  {\\n                    temp += s[j];\\n                }\\n                else if(td == x)  {\\n                    if(minl > temp.size())  {\\n                        ans= temp;\\n                        minl= temp.size();\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "what\\'s u buddy\\n"
                    },
                    {
                        "username": "BamesJorn",
                        "content": "Have you tried it again?\\nIf yes - what were the questions?"
                    },
                    {
                        "username": "harrypotter0",
                        "content": "Here are the other sliding window problems to practice:\\n\\nhttps://leetcode.com/problems/sliding-window-maximum/\\nhttps://leetcode.com/problems/minimum-size-subarray-sum/\\nhttps://leetcode.com/problems/minimum-window-substring/\\nhttps://leetcode.com/problems/maximum-length-of-repeated-subarray/\\n\\n\\n\\n"
                    },
                    {
                        "username": "sandipan72",
                        "content": "thanks for the resources bro"
                    },
                    {
                        "username": "bhavesh1201",
                        "content": "thanks mate\\n"
                    },
                    {
                        "username": "petia",
                        "content": "I don\\'t know if it is just me, but I am really tired of the poor explanations of LC problems. Quite often we do not have any input restrictions and bounds. In this problem we don\\'t know if we expect duplicate characters in T, if we are looking for each distinct character of T in S, or literally every single one (i.e. T=\"aa\" and S=\"a\" - is this valid S or not...). Every time I need to submit my code to get to yet another failing test because there is some unmentioned restriction or requirement. In a real interview if this is the case I would ask clarifying questions, obviously this is not an option in this case. So annoying!"
                    },
                    {
                        "username": "trqkkr",
                        "content": "they purposefully try to word things in confusing ways too!"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Totally agree. They are frustrating in my opinion. I got lost with the \"BANC\" result myself. They also did not mention anything about case sensitivity. For the t=\"aa\" I think they want you to find exactly what is in t inside the s, in other words, 2 \\'a\\' characters in t should be found as well in \\'s\\'"
                    },
                    {
                        "username": "RyanYibingJia",
                        "content": "Just be careful for object `Integer`, using `Integer.intValue()` to compare the value of it.\\n\\n"
                    },
                    {
                        "username": "isamnagi",
                        "content": "This helped a lot for me. I cldnt get passed 266 but with this was able too... here is more context if anyone would like. basically, if you compare to Integers, you are comparing there references not there values... ints compare values.. https://stackoverflow.com/questions/4428774/why-java-does-not-see-that-integers-are-equal"
                    },
                    {
                        "username": "matcovic",
                        "content": "It really feels bad when you come up with a solution spending hours, only to receive a TLE on the last test cases with a 10^5 input size!"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "[@user5190JH](/user5190JH) Bro, that may be because you are using a quadratic time algorithm. Same with me. Try to find out a linear!"
                    },
                    {
                        "username": "sujal1245",
                        "content": "Same. 265/267 test cases passed. Now stuck due to TLE ;( Don\\'t want to look up the solution, will try to figure where I could improve."
                    },
                    {
                        "username": "khuzii",
                        "content": "Hey can you please help me with this code? It is giving runtime error.\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        if(t.size() > s.size())  {\\n            return \"\";\\n        }\\n        map<char, int> mp;\\n        for(int i=0; i<t.size(); i++)  {\\n            mp.insert({t[i], i});\\n        }\\n        string ans;\\n        int minl= s.size()+1;\\n        string x=t;\\n        for(int i=0; i<t.size(); i++)  {\\n            x[i]=\\'#\\';\\n        }\\n        for(int i=0; i<s.size(); i++)  { \\n            string temp= \"\";\\n            string td= t;\\n            for(int j= i; j<s.size(); j++)  {\\n                if(t.find(s[j])!=string::npos && td!=x)  {\\n                    temp += s[j];\\n                    int y= td.find(s[j]);\\n                    td[y]= \\'#\\';\\n                }\\n                else if(td != x && temp.size()!=0)  {\\n                    temp += s[j];\\n                }\\n                else if(td == x)  {\\n                    if(minl > temp.size())  {\\n                        ans= temp;\\n                        minl= temp.size();\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "bhanujggandhi",
                        "content": "Do not maintain the string variable and update it every time you find a better minimum substring. **Instead maintain pointers and create substring only once, otherwise there will be TLE/MLE**"
                    },
                    {
                        "username": "abhaydkumar80",
                        "content": "thanks I was stuck in this as well."
                    },
                    {
                        "username": "Shivi_Singh25",
                        "content": "Thank you. I was stuck there. But can you please explain why does that happen?\\n"
                    },
                    {
                        "username": "vineetsai3479",
                        "content": "it worked thanks"
                    },
                    {
                        "username": "hugjobk",
                        "content": "string object is just a pointer. It is very cheap to copy a string"
                    },
                    {
                        "username": "jtimberlakers",
                        "content": " \\n\\nThe Discription is \" Given a string S and a string T, find the minimum window in S which will contain all the characters in T \"\\n\\n \\n\\nsuppose S is \"a\", T is \"aa\"\\n\\n \\n\\nI think the answer should be \"a\" , the character in T is just \"a\", and S contain it. but the test answer is \"\". \\nshould the \"a\" character be twice in the window??"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": " I dunno if it was edited, but there\\'s the \"(including duplicates)\" part in the problem description."
                    },
                    {
                        "username": "conradkun",
                        "content": "Duplicates matter, so S would have to at least have 2 \\'a\\'."
                    },
                    {
                        "username": "ayushabg",
                        "content": "Very Badly written Description! I solved the problem believing that we need to match exact frequencies of characters in t in substrings of s. Only to find test case 192 failing. \\n\"aaaaaaaaaaaabbbbbcdd\", \"abcdd\"  -> \"abbbbbcdd\""
                    },
                    {
                        "username": "JoeDoba",
                        "content": "Why leetcode takes this problem as \"Hard\" which is marked as\"Easy\" in CodeSignal :)"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "How is this easy?"
                    },
                    {
                        "username": "isaackleinman",
                        "content": "It wasn\\'t clear to me from the description that the string `t` can have the same character repeated more than once, and all of these repeats have to be accounted for in `s`. \\n\\nThe description should make this clear."
                    },
                    {
                        "username": "lazarevzubov",
                        "content": " I dunno if it was edited, but there\\'s the \"(including duplicates)\" part in the problem description."
                    }
                ]
            },
            {
                "id": 1654586,
                "content": [
                    {
                        "username": "pilot_n_programmer",
                        "content": "Got this problem at FB yesterday.\\nI solved it sometime ago on leetcode but during the interview I failed to do it.\\nIt was a second problem to solve, 20 mins left and all this time pressure+stress made me to panic.\\nI would expect that two problems in 45 mins would be Easy and Medium or worst case Medium/Medium but got Medium and Hard. \\nMoral of the story: don\\'t expect that you will get the same complexity tasks like others usually get - I find it is sort of lottery. Prepare for worst to make it done! And don\\'t stress or panic - it doesn\\'t help. Good luck everyone!"
                    },
                    {
                        "username": "Gracemann280",
                        "content": "i thought easy+medium was the usual so its better to expect medium /medium and some hard IG \\uD83E\\uDD27"
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this is brutal to ask in a short interview.. its not hard conceptually, but implementing it is a pain."
                    },
                    {
                        "username": "khuzii",
                        "content": "Hey can you please help me with this code? I am getting runtime error.\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        if(t.size() > s.size())  {\\n            return \"\";\\n        }\\n        map<char, int> mp;\\n        for(int i=0; i<t.size(); i++)  {\\n            mp.insert({t[i], i});\\n        }\\n        string ans;\\n        int minl= s.size()+1;\\n        string x=t;\\n        for(int i=0; i<t.size(); i++)  {\\n            x[i]=\\'#\\';\\n        }\\n        for(int i=0; i<s.size(); i++)  { \\n            string temp= \"\";\\n            string td= t;\\n            for(int j= i; j<s.size(); j++)  {\\n                if(t.find(s[j])!=string::npos && td!=x)  {\\n                    temp += s[j];\\n                    int y= td.find(s[j]);\\n                    td[y]= \\'#\\';\\n                }\\n                else if(td != x && temp.size()!=0)  {\\n                    temp += s[j];\\n                }\\n                else if(td == x)  {\\n                    if(minl > temp.size())  {\\n                        ans= temp;\\n                        minl= temp.size();\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "what\\'s u buddy\\n"
                    },
                    {
                        "username": "BamesJorn",
                        "content": "Have you tried it again?\\nIf yes - what were the questions?"
                    },
                    {
                        "username": "harrypotter0",
                        "content": "Here are the other sliding window problems to practice:\\n\\nhttps://leetcode.com/problems/sliding-window-maximum/\\nhttps://leetcode.com/problems/minimum-size-subarray-sum/\\nhttps://leetcode.com/problems/minimum-window-substring/\\nhttps://leetcode.com/problems/maximum-length-of-repeated-subarray/\\n\\n\\n\\n"
                    },
                    {
                        "username": "sandipan72",
                        "content": "thanks for the resources bro"
                    },
                    {
                        "username": "bhavesh1201",
                        "content": "thanks mate\\n"
                    },
                    {
                        "username": "petia",
                        "content": "I don\\'t know if it is just me, but I am really tired of the poor explanations of LC problems. Quite often we do not have any input restrictions and bounds. In this problem we don\\'t know if we expect duplicate characters in T, if we are looking for each distinct character of T in S, or literally every single one (i.e. T=\"aa\" and S=\"a\" - is this valid S or not...). Every time I need to submit my code to get to yet another failing test because there is some unmentioned restriction or requirement. In a real interview if this is the case I would ask clarifying questions, obviously this is not an option in this case. So annoying!"
                    },
                    {
                        "username": "trqkkr",
                        "content": "they purposefully try to word things in confusing ways too!"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Totally agree. They are frustrating in my opinion. I got lost with the \"BANC\" result myself. They also did not mention anything about case sensitivity. For the t=\"aa\" I think they want you to find exactly what is in t inside the s, in other words, 2 \\'a\\' characters in t should be found as well in \\'s\\'"
                    },
                    {
                        "username": "RyanYibingJia",
                        "content": "Just be careful for object `Integer`, using `Integer.intValue()` to compare the value of it.\\n\\n"
                    },
                    {
                        "username": "isamnagi",
                        "content": "This helped a lot for me. I cldnt get passed 266 but with this was able too... here is more context if anyone would like. basically, if you compare to Integers, you are comparing there references not there values... ints compare values.. https://stackoverflow.com/questions/4428774/why-java-does-not-see-that-integers-are-equal"
                    },
                    {
                        "username": "matcovic",
                        "content": "It really feels bad when you come up with a solution spending hours, only to receive a TLE on the last test cases with a 10^5 input size!"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "[@user5190JH](/user5190JH) Bro, that may be because you are using a quadratic time algorithm. Same with me. Try to find out a linear!"
                    },
                    {
                        "username": "sujal1245",
                        "content": "Same. 265/267 test cases passed. Now stuck due to TLE ;( Don\\'t want to look up the solution, will try to figure where I could improve."
                    },
                    {
                        "username": "khuzii",
                        "content": "Hey can you please help me with this code? It is giving runtime error.\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        if(t.size() > s.size())  {\\n            return \"\";\\n        }\\n        map<char, int> mp;\\n        for(int i=0; i<t.size(); i++)  {\\n            mp.insert({t[i], i});\\n        }\\n        string ans;\\n        int minl= s.size()+1;\\n        string x=t;\\n        for(int i=0; i<t.size(); i++)  {\\n            x[i]=\\'#\\';\\n        }\\n        for(int i=0; i<s.size(); i++)  { \\n            string temp= \"\";\\n            string td= t;\\n            for(int j= i; j<s.size(); j++)  {\\n                if(t.find(s[j])!=string::npos && td!=x)  {\\n                    temp += s[j];\\n                    int y= td.find(s[j]);\\n                    td[y]= \\'#\\';\\n                }\\n                else if(td != x && temp.size()!=0)  {\\n                    temp += s[j];\\n                }\\n                else if(td == x)  {\\n                    if(minl > temp.size())  {\\n                        ans= temp;\\n                        minl= temp.size();\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "bhanujggandhi",
                        "content": "Do not maintain the string variable and update it every time you find a better minimum substring. **Instead maintain pointers and create substring only once, otherwise there will be TLE/MLE**"
                    },
                    {
                        "username": "abhaydkumar80",
                        "content": "thanks I was stuck in this as well."
                    },
                    {
                        "username": "Shivi_Singh25",
                        "content": "Thank you. I was stuck there. But can you please explain why does that happen?\\n"
                    },
                    {
                        "username": "vineetsai3479",
                        "content": "it worked thanks"
                    },
                    {
                        "username": "hugjobk",
                        "content": "string object is just a pointer. It is very cheap to copy a string"
                    },
                    {
                        "username": "jtimberlakers",
                        "content": " \\n\\nThe Discription is \" Given a string S and a string T, find the minimum window in S which will contain all the characters in T \"\\n\\n \\n\\nsuppose S is \"a\", T is \"aa\"\\n\\n \\n\\nI think the answer should be \"a\" , the character in T is just \"a\", and S contain it. but the test answer is \"\". \\nshould the \"a\" character be twice in the window??"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": " I dunno if it was edited, but there\\'s the \"(including duplicates)\" part in the problem description."
                    },
                    {
                        "username": "conradkun",
                        "content": "Duplicates matter, so S would have to at least have 2 \\'a\\'."
                    },
                    {
                        "username": "ayushabg",
                        "content": "Very Badly written Description! I solved the problem believing that we need to match exact frequencies of characters in t in substrings of s. Only to find test case 192 failing. \\n\"aaaaaaaaaaaabbbbbcdd\", \"abcdd\"  -> \"abbbbbcdd\""
                    },
                    {
                        "username": "JoeDoba",
                        "content": "Why leetcode takes this problem as \"Hard\" which is marked as\"Easy\" in CodeSignal :)"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "How is this easy?"
                    },
                    {
                        "username": "isaackleinman",
                        "content": "It wasn\\'t clear to me from the description that the string `t` can have the same character repeated more than once, and all of these repeats have to be accounted for in `s`. \\n\\nThe description should make this clear."
                    },
                    {
                        "username": "lazarevzubov",
                        "content": " I dunno if it was edited, but there\\'s the \"(including duplicates)\" part in the problem description."
                    }
                ]
            },
            {
                "id": 1570179,
                "content": [
                    {
                        "username": "pilot_n_programmer",
                        "content": "Got this problem at FB yesterday.\\nI solved it sometime ago on leetcode but during the interview I failed to do it.\\nIt was a second problem to solve, 20 mins left and all this time pressure+stress made me to panic.\\nI would expect that two problems in 45 mins would be Easy and Medium or worst case Medium/Medium but got Medium and Hard. \\nMoral of the story: don\\'t expect that you will get the same complexity tasks like others usually get - I find it is sort of lottery. Prepare for worst to make it done! And don\\'t stress or panic - it doesn\\'t help. Good luck everyone!"
                    },
                    {
                        "username": "Gracemann280",
                        "content": "i thought easy+medium was the usual so its better to expect medium /medium and some hard IG \\uD83E\\uDD27"
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this is brutal to ask in a short interview.. its not hard conceptually, but implementing it is a pain."
                    },
                    {
                        "username": "khuzii",
                        "content": "Hey can you please help me with this code? I am getting runtime error.\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        if(t.size() > s.size())  {\\n            return \"\";\\n        }\\n        map<char, int> mp;\\n        for(int i=0; i<t.size(); i++)  {\\n            mp.insert({t[i], i});\\n        }\\n        string ans;\\n        int minl= s.size()+1;\\n        string x=t;\\n        for(int i=0; i<t.size(); i++)  {\\n            x[i]=\\'#\\';\\n        }\\n        for(int i=0; i<s.size(); i++)  { \\n            string temp= \"\";\\n            string td= t;\\n            for(int j= i; j<s.size(); j++)  {\\n                if(t.find(s[j])!=string::npos && td!=x)  {\\n                    temp += s[j];\\n                    int y= td.find(s[j]);\\n                    td[y]= \\'#\\';\\n                }\\n                else if(td != x && temp.size()!=0)  {\\n                    temp += s[j];\\n                }\\n                else if(td == x)  {\\n                    if(minl > temp.size())  {\\n                        ans= temp;\\n                        minl= temp.size();\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "what\\'s u buddy\\n"
                    },
                    {
                        "username": "BamesJorn",
                        "content": "Have you tried it again?\\nIf yes - what were the questions?"
                    },
                    {
                        "username": "harrypotter0",
                        "content": "Here are the other sliding window problems to practice:\\n\\nhttps://leetcode.com/problems/sliding-window-maximum/\\nhttps://leetcode.com/problems/minimum-size-subarray-sum/\\nhttps://leetcode.com/problems/minimum-window-substring/\\nhttps://leetcode.com/problems/maximum-length-of-repeated-subarray/\\n\\n\\n\\n"
                    },
                    {
                        "username": "sandipan72",
                        "content": "thanks for the resources bro"
                    },
                    {
                        "username": "bhavesh1201",
                        "content": "thanks mate\\n"
                    },
                    {
                        "username": "petia",
                        "content": "I don\\'t know if it is just me, but I am really tired of the poor explanations of LC problems. Quite often we do not have any input restrictions and bounds. In this problem we don\\'t know if we expect duplicate characters in T, if we are looking for each distinct character of T in S, or literally every single one (i.e. T=\"aa\" and S=\"a\" - is this valid S or not...). Every time I need to submit my code to get to yet another failing test because there is some unmentioned restriction or requirement. In a real interview if this is the case I would ask clarifying questions, obviously this is not an option in this case. So annoying!"
                    },
                    {
                        "username": "trqkkr",
                        "content": "they purposefully try to word things in confusing ways too!"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Totally agree. They are frustrating in my opinion. I got lost with the \"BANC\" result myself. They also did not mention anything about case sensitivity. For the t=\"aa\" I think they want you to find exactly what is in t inside the s, in other words, 2 \\'a\\' characters in t should be found as well in \\'s\\'"
                    },
                    {
                        "username": "RyanYibingJia",
                        "content": "Just be careful for object `Integer`, using `Integer.intValue()` to compare the value of it.\\n\\n"
                    },
                    {
                        "username": "isamnagi",
                        "content": "This helped a lot for me. I cldnt get passed 266 but with this was able too... here is more context if anyone would like. basically, if you compare to Integers, you are comparing there references not there values... ints compare values.. https://stackoverflow.com/questions/4428774/why-java-does-not-see-that-integers-are-equal"
                    },
                    {
                        "username": "matcovic",
                        "content": "It really feels bad when you come up with a solution spending hours, only to receive a TLE on the last test cases with a 10^5 input size!"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "[@user5190JH](/user5190JH) Bro, that may be because you are using a quadratic time algorithm. Same with me. Try to find out a linear!"
                    },
                    {
                        "username": "sujal1245",
                        "content": "Same. 265/267 test cases passed. Now stuck due to TLE ;( Don\\'t want to look up the solution, will try to figure where I could improve."
                    },
                    {
                        "username": "khuzii",
                        "content": "Hey can you please help me with this code? It is giving runtime error.\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        if(t.size() > s.size())  {\\n            return \"\";\\n        }\\n        map<char, int> mp;\\n        for(int i=0; i<t.size(); i++)  {\\n            mp.insert({t[i], i});\\n        }\\n        string ans;\\n        int minl= s.size()+1;\\n        string x=t;\\n        for(int i=0; i<t.size(); i++)  {\\n            x[i]=\\'#\\';\\n        }\\n        for(int i=0; i<s.size(); i++)  { \\n            string temp= \"\";\\n            string td= t;\\n            for(int j= i; j<s.size(); j++)  {\\n                if(t.find(s[j])!=string::npos && td!=x)  {\\n                    temp += s[j];\\n                    int y= td.find(s[j]);\\n                    td[y]= \\'#\\';\\n                }\\n                else if(td != x && temp.size()!=0)  {\\n                    temp += s[j];\\n                }\\n                else if(td == x)  {\\n                    if(minl > temp.size())  {\\n                        ans= temp;\\n                        minl= temp.size();\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "bhanujggandhi",
                        "content": "Do not maintain the string variable and update it every time you find a better minimum substring. **Instead maintain pointers and create substring only once, otherwise there will be TLE/MLE**"
                    },
                    {
                        "username": "abhaydkumar80",
                        "content": "thanks I was stuck in this as well."
                    },
                    {
                        "username": "Shivi_Singh25",
                        "content": "Thank you. I was stuck there. But can you please explain why does that happen?\\n"
                    },
                    {
                        "username": "vineetsai3479",
                        "content": "it worked thanks"
                    },
                    {
                        "username": "hugjobk",
                        "content": "string object is just a pointer. It is very cheap to copy a string"
                    },
                    {
                        "username": "jtimberlakers",
                        "content": " \\n\\nThe Discription is \" Given a string S and a string T, find the minimum window in S which will contain all the characters in T \"\\n\\n \\n\\nsuppose S is \"a\", T is \"aa\"\\n\\n \\n\\nI think the answer should be \"a\" , the character in T is just \"a\", and S contain it. but the test answer is \"\". \\nshould the \"a\" character be twice in the window??"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": " I dunno if it was edited, but there\\'s the \"(including duplicates)\" part in the problem description."
                    },
                    {
                        "username": "conradkun",
                        "content": "Duplicates matter, so S would have to at least have 2 \\'a\\'."
                    },
                    {
                        "username": "ayushabg",
                        "content": "Very Badly written Description! I solved the problem believing that we need to match exact frequencies of characters in t in substrings of s. Only to find test case 192 failing. \\n\"aaaaaaaaaaaabbbbbcdd\", \"abcdd\"  -> \"abbbbbcdd\""
                    },
                    {
                        "username": "JoeDoba",
                        "content": "Why leetcode takes this problem as \"Hard\" which is marked as\"Easy\" in CodeSignal :)"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "How is this easy?"
                    },
                    {
                        "username": "isaackleinman",
                        "content": "It wasn\\'t clear to me from the description that the string `t` can have the same character repeated more than once, and all of these repeats have to be accounted for in `s`. \\n\\nThe description should make this clear."
                    },
                    {
                        "username": "lazarevzubov",
                        "content": " I dunno if it was edited, but there\\'s the \"(including duplicates)\" part in the problem description."
                    }
                ]
            },
            {
                "id": 1567399,
                "content": [
                    {
                        "username": "pilot_n_programmer",
                        "content": "Got this problem at FB yesterday.\\nI solved it sometime ago on leetcode but during the interview I failed to do it.\\nIt was a second problem to solve, 20 mins left and all this time pressure+stress made me to panic.\\nI would expect that two problems in 45 mins would be Easy and Medium or worst case Medium/Medium but got Medium and Hard. \\nMoral of the story: don\\'t expect that you will get the same complexity tasks like others usually get - I find it is sort of lottery. Prepare for worst to make it done! And don\\'t stress or panic - it doesn\\'t help. Good luck everyone!"
                    },
                    {
                        "username": "Gracemann280",
                        "content": "i thought easy+medium was the usual so its better to expect medium /medium and some hard IG \\uD83E\\uDD27"
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this is brutal to ask in a short interview.. its not hard conceptually, but implementing it is a pain."
                    },
                    {
                        "username": "khuzii",
                        "content": "Hey can you please help me with this code? I am getting runtime error.\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        if(t.size() > s.size())  {\\n            return \"\";\\n        }\\n        map<char, int> mp;\\n        for(int i=0; i<t.size(); i++)  {\\n            mp.insert({t[i], i});\\n        }\\n        string ans;\\n        int minl= s.size()+1;\\n        string x=t;\\n        for(int i=0; i<t.size(); i++)  {\\n            x[i]=\\'#\\';\\n        }\\n        for(int i=0; i<s.size(); i++)  { \\n            string temp= \"\";\\n            string td= t;\\n            for(int j= i; j<s.size(); j++)  {\\n                if(t.find(s[j])!=string::npos && td!=x)  {\\n                    temp += s[j];\\n                    int y= td.find(s[j]);\\n                    td[y]= \\'#\\';\\n                }\\n                else if(td != x && temp.size()!=0)  {\\n                    temp += s[j];\\n                }\\n                else if(td == x)  {\\n                    if(minl > temp.size())  {\\n                        ans= temp;\\n                        minl= temp.size();\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "what\\'s u buddy\\n"
                    },
                    {
                        "username": "BamesJorn",
                        "content": "Have you tried it again?\\nIf yes - what were the questions?"
                    },
                    {
                        "username": "harrypotter0",
                        "content": "Here are the other sliding window problems to practice:\\n\\nhttps://leetcode.com/problems/sliding-window-maximum/\\nhttps://leetcode.com/problems/minimum-size-subarray-sum/\\nhttps://leetcode.com/problems/minimum-window-substring/\\nhttps://leetcode.com/problems/maximum-length-of-repeated-subarray/\\n\\n\\n\\n"
                    },
                    {
                        "username": "sandipan72",
                        "content": "thanks for the resources bro"
                    },
                    {
                        "username": "bhavesh1201",
                        "content": "thanks mate\\n"
                    },
                    {
                        "username": "petia",
                        "content": "I don\\'t know if it is just me, but I am really tired of the poor explanations of LC problems. Quite often we do not have any input restrictions and bounds. In this problem we don\\'t know if we expect duplicate characters in T, if we are looking for each distinct character of T in S, or literally every single one (i.e. T=\"aa\" and S=\"a\" - is this valid S or not...). Every time I need to submit my code to get to yet another failing test because there is some unmentioned restriction or requirement. In a real interview if this is the case I would ask clarifying questions, obviously this is not an option in this case. So annoying!"
                    },
                    {
                        "username": "trqkkr",
                        "content": "they purposefully try to word things in confusing ways too!"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Totally agree. They are frustrating in my opinion. I got lost with the \"BANC\" result myself. They also did not mention anything about case sensitivity. For the t=\"aa\" I think they want you to find exactly what is in t inside the s, in other words, 2 \\'a\\' characters in t should be found as well in \\'s\\'"
                    },
                    {
                        "username": "RyanYibingJia",
                        "content": "Just be careful for object `Integer`, using `Integer.intValue()` to compare the value of it.\\n\\n"
                    },
                    {
                        "username": "isamnagi",
                        "content": "This helped a lot for me. I cldnt get passed 266 but with this was able too... here is more context if anyone would like. basically, if you compare to Integers, you are comparing there references not there values... ints compare values.. https://stackoverflow.com/questions/4428774/why-java-does-not-see-that-integers-are-equal"
                    },
                    {
                        "username": "matcovic",
                        "content": "It really feels bad when you come up with a solution spending hours, only to receive a TLE on the last test cases with a 10^5 input size!"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "[@user5190JH](/user5190JH) Bro, that may be because you are using a quadratic time algorithm. Same with me. Try to find out a linear!"
                    },
                    {
                        "username": "sujal1245",
                        "content": "Same. 265/267 test cases passed. Now stuck due to TLE ;( Don\\'t want to look up the solution, will try to figure where I could improve."
                    },
                    {
                        "username": "khuzii",
                        "content": "Hey can you please help me with this code? It is giving runtime error.\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        if(t.size() > s.size())  {\\n            return \"\";\\n        }\\n        map<char, int> mp;\\n        for(int i=0; i<t.size(); i++)  {\\n            mp.insert({t[i], i});\\n        }\\n        string ans;\\n        int minl= s.size()+1;\\n        string x=t;\\n        for(int i=0; i<t.size(); i++)  {\\n            x[i]=\\'#\\';\\n        }\\n        for(int i=0; i<s.size(); i++)  { \\n            string temp= \"\";\\n            string td= t;\\n            for(int j= i; j<s.size(); j++)  {\\n                if(t.find(s[j])!=string::npos && td!=x)  {\\n                    temp += s[j];\\n                    int y= td.find(s[j]);\\n                    td[y]= \\'#\\';\\n                }\\n                else if(td != x && temp.size()!=0)  {\\n                    temp += s[j];\\n                }\\n                else if(td == x)  {\\n                    if(minl > temp.size())  {\\n                        ans= temp;\\n                        minl= temp.size();\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "bhanujggandhi",
                        "content": "Do not maintain the string variable and update it every time you find a better minimum substring. **Instead maintain pointers and create substring only once, otherwise there will be TLE/MLE**"
                    },
                    {
                        "username": "abhaydkumar80",
                        "content": "thanks I was stuck in this as well."
                    },
                    {
                        "username": "Shivi_Singh25",
                        "content": "Thank you. I was stuck there. But can you please explain why does that happen?\\n"
                    },
                    {
                        "username": "vineetsai3479",
                        "content": "it worked thanks"
                    },
                    {
                        "username": "hugjobk",
                        "content": "string object is just a pointer. It is very cheap to copy a string"
                    },
                    {
                        "username": "jtimberlakers",
                        "content": " \\n\\nThe Discription is \" Given a string S and a string T, find the minimum window in S which will contain all the characters in T \"\\n\\n \\n\\nsuppose S is \"a\", T is \"aa\"\\n\\n \\n\\nI think the answer should be \"a\" , the character in T is just \"a\", and S contain it. but the test answer is \"\". \\nshould the \"a\" character be twice in the window??"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": " I dunno if it was edited, but there\\'s the \"(including duplicates)\" part in the problem description."
                    },
                    {
                        "username": "conradkun",
                        "content": "Duplicates matter, so S would have to at least have 2 \\'a\\'."
                    },
                    {
                        "username": "ayushabg",
                        "content": "Very Badly written Description! I solved the problem believing that we need to match exact frequencies of characters in t in substrings of s. Only to find test case 192 failing. \\n\"aaaaaaaaaaaabbbbbcdd\", \"abcdd\"  -> \"abbbbbcdd\""
                    },
                    {
                        "username": "JoeDoba",
                        "content": "Why leetcode takes this problem as \"Hard\" which is marked as\"Easy\" in CodeSignal :)"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "How is this easy?"
                    },
                    {
                        "username": "isaackleinman",
                        "content": "It wasn\\'t clear to me from the description that the string `t` can have the same character repeated more than once, and all of these repeats have to be accounted for in `s`. \\n\\nThe description should make this clear."
                    },
                    {
                        "username": "lazarevzubov",
                        "content": " I dunno if it was edited, but there\\'s the \"(including duplicates)\" part in the problem description."
                    }
                ]
            },
            {
                "id": 1570665,
                "content": [
                    {
                        "username": "pilot_n_programmer",
                        "content": "Got this problem at FB yesterday.\\nI solved it sometime ago on leetcode but during the interview I failed to do it.\\nIt was a second problem to solve, 20 mins left and all this time pressure+stress made me to panic.\\nI would expect that two problems in 45 mins would be Easy and Medium or worst case Medium/Medium but got Medium and Hard. \\nMoral of the story: don\\'t expect that you will get the same complexity tasks like others usually get - I find it is sort of lottery. Prepare for worst to make it done! And don\\'t stress or panic - it doesn\\'t help. Good luck everyone!"
                    },
                    {
                        "username": "Gracemann280",
                        "content": "i thought easy+medium was the usual so its better to expect medium /medium and some hard IG \\uD83E\\uDD27"
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this is brutal to ask in a short interview.. its not hard conceptually, but implementing it is a pain."
                    },
                    {
                        "username": "khuzii",
                        "content": "Hey can you please help me with this code? I am getting runtime error.\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        if(t.size() > s.size())  {\\n            return \"\";\\n        }\\n        map<char, int> mp;\\n        for(int i=0; i<t.size(); i++)  {\\n            mp.insert({t[i], i});\\n        }\\n        string ans;\\n        int minl= s.size()+1;\\n        string x=t;\\n        for(int i=0; i<t.size(); i++)  {\\n            x[i]=\\'#\\';\\n        }\\n        for(int i=0; i<s.size(); i++)  { \\n            string temp= \"\";\\n            string td= t;\\n            for(int j= i; j<s.size(); j++)  {\\n                if(t.find(s[j])!=string::npos && td!=x)  {\\n                    temp += s[j];\\n                    int y= td.find(s[j]);\\n                    td[y]= \\'#\\';\\n                }\\n                else if(td != x && temp.size()!=0)  {\\n                    temp += s[j];\\n                }\\n                else if(td == x)  {\\n                    if(minl > temp.size())  {\\n                        ans= temp;\\n                        minl= temp.size();\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "what\\'s u buddy\\n"
                    },
                    {
                        "username": "BamesJorn",
                        "content": "Have you tried it again?\\nIf yes - what were the questions?"
                    },
                    {
                        "username": "harrypotter0",
                        "content": "Here are the other sliding window problems to practice:\\n\\nhttps://leetcode.com/problems/sliding-window-maximum/\\nhttps://leetcode.com/problems/minimum-size-subarray-sum/\\nhttps://leetcode.com/problems/minimum-window-substring/\\nhttps://leetcode.com/problems/maximum-length-of-repeated-subarray/\\n\\n\\n\\n"
                    },
                    {
                        "username": "sandipan72",
                        "content": "thanks for the resources bro"
                    },
                    {
                        "username": "bhavesh1201",
                        "content": "thanks mate\\n"
                    },
                    {
                        "username": "petia",
                        "content": "I don\\'t know if it is just me, but I am really tired of the poor explanations of LC problems. Quite often we do not have any input restrictions and bounds. In this problem we don\\'t know if we expect duplicate characters in T, if we are looking for each distinct character of T in S, or literally every single one (i.e. T=\"aa\" and S=\"a\" - is this valid S or not...). Every time I need to submit my code to get to yet another failing test because there is some unmentioned restriction or requirement. In a real interview if this is the case I would ask clarifying questions, obviously this is not an option in this case. So annoying!"
                    },
                    {
                        "username": "trqkkr",
                        "content": "they purposefully try to word things in confusing ways too!"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Totally agree. They are frustrating in my opinion. I got lost with the \"BANC\" result myself. They also did not mention anything about case sensitivity. For the t=\"aa\" I think they want you to find exactly what is in t inside the s, in other words, 2 \\'a\\' characters in t should be found as well in \\'s\\'"
                    },
                    {
                        "username": "RyanYibingJia",
                        "content": "Just be careful for object `Integer`, using `Integer.intValue()` to compare the value of it.\\n\\n"
                    },
                    {
                        "username": "isamnagi",
                        "content": "This helped a lot for me. I cldnt get passed 266 but with this was able too... here is more context if anyone would like. basically, if you compare to Integers, you are comparing there references not there values... ints compare values.. https://stackoverflow.com/questions/4428774/why-java-does-not-see-that-integers-are-equal"
                    },
                    {
                        "username": "matcovic",
                        "content": "It really feels bad when you come up with a solution spending hours, only to receive a TLE on the last test cases with a 10^5 input size!"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "[@user5190JH](/user5190JH) Bro, that may be because you are using a quadratic time algorithm. Same with me. Try to find out a linear!"
                    },
                    {
                        "username": "sujal1245",
                        "content": "Same. 265/267 test cases passed. Now stuck due to TLE ;( Don\\'t want to look up the solution, will try to figure where I could improve."
                    },
                    {
                        "username": "khuzii",
                        "content": "Hey can you please help me with this code? It is giving runtime error.\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        if(t.size() > s.size())  {\\n            return \"\";\\n        }\\n        map<char, int> mp;\\n        for(int i=0; i<t.size(); i++)  {\\n            mp.insert({t[i], i});\\n        }\\n        string ans;\\n        int minl= s.size()+1;\\n        string x=t;\\n        for(int i=0; i<t.size(); i++)  {\\n            x[i]=\\'#\\';\\n        }\\n        for(int i=0; i<s.size(); i++)  { \\n            string temp= \"\";\\n            string td= t;\\n            for(int j= i; j<s.size(); j++)  {\\n                if(t.find(s[j])!=string::npos && td!=x)  {\\n                    temp += s[j];\\n                    int y= td.find(s[j]);\\n                    td[y]= \\'#\\';\\n                }\\n                else if(td != x && temp.size()!=0)  {\\n                    temp += s[j];\\n                }\\n                else if(td == x)  {\\n                    if(minl > temp.size())  {\\n                        ans= temp;\\n                        minl= temp.size();\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "bhanujggandhi",
                        "content": "Do not maintain the string variable and update it every time you find a better minimum substring. **Instead maintain pointers and create substring only once, otherwise there will be TLE/MLE**"
                    },
                    {
                        "username": "abhaydkumar80",
                        "content": "thanks I was stuck in this as well."
                    },
                    {
                        "username": "Shivi_Singh25",
                        "content": "Thank you. I was stuck there. But can you please explain why does that happen?\\n"
                    },
                    {
                        "username": "vineetsai3479",
                        "content": "it worked thanks"
                    },
                    {
                        "username": "hugjobk",
                        "content": "string object is just a pointer. It is very cheap to copy a string"
                    },
                    {
                        "username": "jtimberlakers",
                        "content": " \\n\\nThe Discription is \" Given a string S and a string T, find the minimum window in S which will contain all the characters in T \"\\n\\n \\n\\nsuppose S is \"a\", T is \"aa\"\\n\\n \\n\\nI think the answer should be \"a\" , the character in T is just \"a\", and S contain it. but the test answer is \"\". \\nshould the \"a\" character be twice in the window??"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": " I dunno if it was edited, but there\\'s the \"(including duplicates)\" part in the problem description."
                    },
                    {
                        "username": "conradkun",
                        "content": "Duplicates matter, so S would have to at least have 2 \\'a\\'."
                    },
                    {
                        "username": "ayushabg",
                        "content": "Very Badly written Description! I solved the problem believing that we need to match exact frequencies of characters in t in substrings of s. Only to find test case 192 failing. \\n\"aaaaaaaaaaaabbbbbcdd\", \"abcdd\"  -> \"abbbbbcdd\""
                    },
                    {
                        "username": "JoeDoba",
                        "content": "Why leetcode takes this problem as \"Hard\" which is marked as\"Easy\" in CodeSignal :)"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "How is this easy?"
                    },
                    {
                        "username": "isaackleinman",
                        "content": "It wasn\\'t clear to me from the description that the string `t` can have the same character repeated more than once, and all of these repeats have to be accounted for in `s`. \\n\\nThe description should make this clear."
                    },
                    {
                        "username": "lazarevzubov",
                        "content": " I dunno if it was edited, but there\\'s the \"(including duplicates)\" part in the problem description."
                    }
                ]
            },
            {
                "id": 1566848,
                "content": [
                    {
                        "username": "pilot_n_programmer",
                        "content": "Got this problem at FB yesterday.\\nI solved it sometime ago on leetcode but during the interview I failed to do it.\\nIt was a second problem to solve, 20 mins left and all this time pressure+stress made me to panic.\\nI would expect that two problems in 45 mins would be Easy and Medium or worst case Medium/Medium but got Medium and Hard. \\nMoral of the story: don\\'t expect that you will get the same complexity tasks like others usually get - I find it is sort of lottery. Prepare for worst to make it done! And don\\'t stress or panic - it doesn\\'t help. Good luck everyone!"
                    },
                    {
                        "username": "Gracemann280",
                        "content": "i thought easy+medium was the usual so its better to expect medium /medium and some hard IG \\uD83E\\uDD27"
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this is brutal to ask in a short interview.. its not hard conceptually, but implementing it is a pain."
                    },
                    {
                        "username": "khuzii",
                        "content": "Hey can you please help me with this code? I am getting runtime error.\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        if(t.size() > s.size())  {\\n            return \"\";\\n        }\\n        map<char, int> mp;\\n        for(int i=0; i<t.size(); i++)  {\\n            mp.insert({t[i], i});\\n        }\\n        string ans;\\n        int minl= s.size()+1;\\n        string x=t;\\n        for(int i=0; i<t.size(); i++)  {\\n            x[i]=\\'#\\';\\n        }\\n        for(int i=0; i<s.size(); i++)  { \\n            string temp= \"\";\\n            string td= t;\\n            for(int j= i; j<s.size(); j++)  {\\n                if(t.find(s[j])!=string::npos && td!=x)  {\\n                    temp += s[j];\\n                    int y= td.find(s[j]);\\n                    td[y]= \\'#\\';\\n                }\\n                else if(td != x && temp.size()!=0)  {\\n                    temp += s[j];\\n                }\\n                else if(td == x)  {\\n                    if(minl > temp.size())  {\\n                        ans= temp;\\n                        minl= temp.size();\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "what\\'s u buddy\\n"
                    },
                    {
                        "username": "BamesJorn",
                        "content": "Have you tried it again?\\nIf yes - what were the questions?"
                    },
                    {
                        "username": "harrypotter0",
                        "content": "Here are the other sliding window problems to practice:\\n\\nhttps://leetcode.com/problems/sliding-window-maximum/\\nhttps://leetcode.com/problems/minimum-size-subarray-sum/\\nhttps://leetcode.com/problems/minimum-window-substring/\\nhttps://leetcode.com/problems/maximum-length-of-repeated-subarray/\\n\\n\\n\\n"
                    },
                    {
                        "username": "sandipan72",
                        "content": "thanks for the resources bro"
                    },
                    {
                        "username": "bhavesh1201",
                        "content": "thanks mate\\n"
                    },
                    {
                        "username": "petia",
                        "content": "I don\\'t know if it is just me, but I am really tired of the poor explanations of LC problems. Quite often we do not have any input restrictions and bounds. In this problem we don\\'t know if we expect duplicate characters in T, if we are looking for each distinct character of T in S, or literally every single one (i.e. T=\"aa\" and S=\"a\" - is this valid S or not...). Every time I need to submit my code to get to yet another failing test because there is some unmentioned restriction or requirement. In a real interview if this is the case I would ask clarifying questions, obviously this is not an option in this case. So annoying!"
                    },
                    {
                        "username": "trqkkr",
                        "content": "they purposefully try to word things in confusing ways too!"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Totally agree. They are frustrating in my opinion. I got lost with the \"BANC\" result myself. They also did not mention anything about case sensitivity. For the t=\"aa\" I think they want you to find exactly what is in t inside the s, in other words, 2 \\'a\\' characters in t should be found as well in \\'s\\'"
                    },
                    {
                        "username": "RyanYibingJia",
                        "content": "Just be careful for object `Integer`, using `Integer.intValue()` to compare the value of it.\\n\\n"
                    },
                    {
                        "username": "isamnagi",
                        "content": "This helped a lot for me. I cldnt get passed 266 but with this was able too... here is more context if anyone would like. basically, if you compare to Integers, you are comparing there references not there values... ints compare values.. https://stackoverflow.com/questions/4428774/why-java-does-not-see-that-integers-are-equal"
                    },
                    {
                        "username": "matcovic",
                        "content": "It really feels bad when you come up with a solution spending hours, only to receive a TLE on the last test cases with a 10^5 input size!"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "[@user5190JH](/user5190JH) Bro, that may be because you are using a quadratic time algorithm. Same with me. Try to find out a linear!"
                    },
                    {
                        "username": "sujal1245",
                        "content": "Same. 265/267 test cases passed. Now stuck due to TLE ;( Don\\'t want to look up the solution, will try to figure where I could improve."
                    },
                    {
                        "username": "khuzii",
                        "content": "Hey can you please help me with this code? It is giving runtime error.\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        if(t.size() > s.size())  {\\n            return \"\";\\n        }\\n        map<char, int> mp;\\n        for(int i=0; i<t.size(); i++)  {\\n            mp.insert({t[i], i});\\n        }\\n        string ans;\\n        int minl= s.size()+1;\\n        string x=t;\\n        for(int i=0; i<t.size(); i++)  {\\n            x[i]=\\'#\\';\\n        }\\n        for(int i=0; i<s.size(); i++)  { \\n            string temp= \"\";\\n            string td= t;\\n            for(int j= i; j<s.size(); j++)  {\\n                if(t.find(s[j])!=string::npos && td!=x)  {\\n                    temp += s[j];\\n                    int y= td.find(s[j]);\\n                    td[y]= \\'#\\';\\n                }\\n                else if(td != x && temp.size()!=0)  {\\n                    temp += s[j];\\n                }\\n                else if(td == x)  {\\n                    if(minl > temp.size())  {\\n                        ans= temp;\\n                        minl= temp.size();\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "bhanujggandhi",
                        "content": "Do not maintain the string variable and update it every time you find a better minimum substring. **Instead maintain pointers and create substring only once, otherwise there will be TLE/MLE**"
                    },
                    {
                        "username": "abhaydkumar80",
                        "content": "thanks I was stuck in this as well."
                    },
                    {
                        "username": "Shivi_Singh25",
                        "content": "Thank you. I was stuck there. But can you please explain why does that happen?\\n"
                    },
                    {
                        "username": "vineetsai3479",
                        "content": "it worked thanks"
                    },
                    {
                        "username": "hugjobk",
                        "content": "string object is just a pointer. It is very cheap to copy a string"
                    },
                    {
                        "username": "jtimberlakers",
                        "content": " \\n\\nThe Discription is \" Given a string S and a string T, find the minimum window in S which will contain all the characters in T \"\\n\\n \\n\\nsuppose S is \"a\", T is \"aa\"\\n\\n \\n\\nI think the answer should be \"a\" , the character in T is just \"a\", and S contain it. but the test answer is \"\". \\nshould the \"a\" character be twice in the window??"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": " I dunno if it was edited, but there\\'s the \"(including duplicates)\" part in the problem description."
                    },
                    {
                        "username": "conradkun",
                        "content": "Duplicates matter, so S would have to at least have 2 \\'a\\'."
                    },
                    {
                        "username": "ayushabg",
                        "content": "Very Badly written Description! I solved the problem believing that we need to match exact frequencies of characters in t in substrings of s. Only to find test case 192 failing. \\n\"aaaaaaaaaaaabbbbbcdd\", \"abcdd\"  -> \"abbbbbcdd\""
                    },
                    {
                        "username": "JoeDoba",
                        "content": "Why leetcode takes this problem as \"Hard\" which is marked as\"Easy\" in CodeSignal :)"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "How is this easy?"
                    },
                    {
                        "username": "isaackleinman",
                        "content": "It wasn\\'t clear to me from the description that the string `t` can have the same character repeated more than once, and all of these repeats have to be accounted for in `s`. \\n\\nThe description should make this clear."
                    },
                    {
                        "username": "lazarevzubov",
                        "content": " I dunno if it was edited, but there\\'s the \"(including duplicates)\" part in the problem description."
                    }
                ]
            },
            {
                "id": 1565295,
                "content": [
                    {
                        "username": "pilot_n_programmer",
                        "content": "Got this problem at FB yesterday.\\nI solved it sometime ago on leetcode but during the interview I failed to do it.\\nIt was a second problem to solve, 20 mins left and all this time pressure+stress made me to panic.\\nI would expect that two problems in 45 mins would be Easy and Medium or worst case Medium/Medium but got Medium and Hard. \\nMoral of the story: don\\'t expect that you will get the same complexity tasks like others usually get - I find it is sort of lottery. Prepare for worst to make it done! And don\\'t stress or panic - it doesn\\'t help. Good luck everyone!"
                    },
                    {
                        "username": "Gracemann280",
                        "content": "i thought easy+medium was the usual so its better to expect medium /medium and some hard IG \\uD83E\\uDD27"
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this is brutal to ask in a short interview.. its not hard conceptually, but implementing it is a pain."
                    },
                    {
                        "username": "khuzii",
                        "content": "Hey can you please help me with this code? I am getting runtime error.\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        if(t.size() > s.size())  {\\n            return \"\";\\n        }\\n        map<char, int> mp;\\n        for(int i=0; i<t.size(); i++)  {\\n            mp.insert({t[i], i});\\n        }\\n        string ans;\\n        int minl= s.size()+1;\\n        string x=t;\\n        for(int i=0; i<t.size(); i++)  {\\n            x[i]=\\'#\\';\\n        }\\n        for(int i=0; i<s.size(); i++)  { \\n            string temp= \"\";\\n            string td= t;\\n            for(int j= i; j<s.size(); j++)  {\\n                if(t.find(s[j])!=string::npos && td!=x)  {\\n                    temp += s[j];\\n                    int y= td.find(s[j]);\\n                    td[y]= \\'#\\';\\n                }\\n                else if(td != x && temp.size()!=0)  {\\n                    temp += s[j];\\n                }\\n                else if(td == x)  {\\n                    if(minl > temp.size())  {\\n                        ans= temp;\\n                        minl= temp.size();\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "what\\'s u buddy\\n"
                    },
                    {
                        "username": "BamesJorn",
                        "content": "Have you tried it again?\\nIf yes - what were the questions?"
                    },
                    {
                        "username": "harrypotter0",
                        "content": "Here are the other sliding window problems to practice:\\n\\nhttps://leetcode.com/problems/sliding-window-maximum/\\nhttps://leetcode.com/problems/minimum-size-subarray-sum/\\nhttps://leetcode.com/problems/minimum-window-substring/\\nhttps://leetcode.com/problems/maximum-length-of-repeated-subarray/\\n\\n\\n\\n"
                    },
                    {
                        "username": "sandipan72",
                        "content": "thanks for the resources bro"
                    },
                    {
                        "username": "bhavesh1201",
                        "content": "thanks mate\\n"
                    },
                    {
                        "username": "petia",
                        "content": "I don\\'t know if it is just me, but I am really tired of the poor explanations of LC problems. Quite often we do not have any input restrictions and bounds. In this problem we don\\'t know if we expect duplicate characters in T, if we are looking for each distinct character of T in S, or literally every single one (i.e. T=\"aa\" and S=\"a\" - is this valid S or not...). Every time I need to submit my code to get to yet another failing test because there is some unmentioned restriction or requirement. In a real interview if this is the case I would ask clarifying questions, obviously this is not an option in this case. So annoying!"
                    },
                    {
                        "username": "trqkkr",
                        "content": "they purposefully try to word things in confusing ways too!"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Totally agree. They are frustrating in my opinion. I got lost with the \"BANC\" result myself. They also did not mention anything about case sensitivity. For the t=\"aa\" I think they want you to find exactly what is in t inside the s, in other words, 2 \\'a\\' characters in t should be found as well in \\'s\\'"
                    },
                    {
                        "username": "RyanYibingJia",
                        "content": "Just be careful for object `Integer`, using `Integer.intValue()` to compare the value of it.\\n\\n"
                    },
                    {
                        "username": "isamnagi",
                        "content": "This helped a lot for me. I cldnt get passed 266 but with this was able too... here is more context if anyone would like. basically, if you compare to Integers, you are comparing there references not there values... ints compare values.. https://stackoverflow.com/questions/4428774/why-java-does-not-see-that-integers-are-equal"
                    },
                    {
                        "username": "matcovic",
                        "content": "It really feels bad when you come up with a solution spending hours, only to receive a TLE on the last test cases with a 10^5 input size!"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "[@user5190JH](/user5190JH) Bro, that may be because you are using a quadratic time algorithm. Same with me. Try to find out a linear!"
                    },
                    {
                        "username": "sujal1245",
                        "content": "Same. 265/267 test cases passed. Now stuck due to TLE ;( Don\\'t want to look up the solution, will try to figure where I could improve."
                    },
                    {
                        "username": "khuzii",
                        "content": "Hey can you please help me with this code? It is giving runtime error.\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        if(t.size() > s.size())  {\\n            return \"\";\\n        }\\n        map<char, int> mp;\\n        for(int i=0; i<t.size(); i++)  {\\n            mp.insert({t[i], i});\\n        }\\n        string ans;\\n        int minl= s.size()+1;\\n        string x=t;\\n        for(int i=0; i<t.size(); i++)  {\\n            x[i]=\\'#\\';\\n        }\\n        for(int i=0; i<s.size(); i++)  { \\n            string temp= \"\";\\n            string td= t;\\n            for(int j= i; j<s.size(); j++)  {\\n                if(t.find(s[j])!=string::npos && td!=x)  {\\n                    temp += s[j];\\n                    int y= td.find(s[j]);\\n                    td[y]= \\'#\\';\\n                }\\n                else if(td != x && temp.size()!=0)  {\\n                    temp += s[j];\\n                }\\n                else if(td == x)  {\\n                    if(minl > temp.size())  {\\n                        ans= temp;\\n                        minl= temp.size();\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "bhanujggandhi",
                        "content": "Do not maintain the string variable and update it every time you find a better minimum substring. **Instead maintain pointers and create substring only once, otherwise there will be TLE/MLE**"
                    },
                    {
                        "username": "abhaydkumar80",
                        "content": "thanks I was stuck in this as well."
                    },
                    {
                        "username": "Shivi_Singh25",
                        "content": "Thank you. I was stuck there. But can you please explain why does that happen?\\n"
                    },
                    {
                        "username": "vineetsai3479",
                        "content": "it worked thanks"
                    },
                    {
                        "username": "hugjobk",
                        "content": "string object is just a pointer. It is very cheap to copy a string"
                    },
                    {
                        "username": "jtimberlakers",
                        "content": " \\n\\nThe Discription is \" Given a string S and a string T, find the minimum window in S which will contain all the characters in T \"\\n\\n \\n\\nsuppose S is \"a\", T is \"aa\"\\n\\n \\n\\nI think the answer should be \"a\" , the character in T is just \"a\", and S contain it. but the test answer is \"\". \\nshould the \"a\" character be twice in the window??"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": " I dunno if it was edited, but there\\'s the \"(including duplicates)\" part in the problem description."
                    },
                    {
                        "username": "conradkun",
                        "content": "Duplicates matter, so S would have to at least have 2 \\'a\\'."
                    },
                    {
                        "username": "ayushabg",
                        "content": "Very Badly written Description! I solved the problem believing that we need to match exact frequencies of characters in t in substrings of s. Only to find test case 192 failing. \\n\"aaaaaaaaaaaabbbbbcdd\", \"abcdd\"  -> \"abbbbbcdd\""
                    },
                    {
                        "username": "JoeDoba",
                        "content": "Why leetcode takes this problem as \"Hard\" which is marked as\"Easy\" in CodeSignal :)"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "How is this easy?"
                    },
                    {
                        "username": "isaackleinman",
                        "content": "It wasn\\'t clear to me from the description that the string `t` can have the same character repeated more than once, and all of these repeats have to be accounted for in `s`. \\n\\nThe description should make this clear."
                    },
                    {
                        "username": "lazarevzubov",
                        "content": " I dunno if it was edited, but there\\'s the \"(including duplicates)\" part in the problem description."
                    }
                ]
            },
            {
                "id": 1566179,
                "content": [
                    {
                        "username": "pilot_n_programmer",
                        "content": "Got this problem at FB yesterday.\\nI solved it sometime ago on leetcode but during the interview I failed to do it.\\nIt was a second problem to solve, 20 mins left and all this time pressure+stress made me to panic.\\nI would expect that two problems in 45 mins would be Easy and Medium or worst case Medium/Medium but got Medium and Hard. \\nMoral of the story: don\\'t expect that you will get the same complexity tasks like others usually get - I find it is sort of lottery. Prepare for worst to make it done! And don\\'t stress or panic - it doesn\\'t help. Good luck everyone!"
                    },
                    {
                        "username": "Gracemann280",
                        "content": "i thought easy+medium was the usual so its better to expect medium /medium and some hard IG \\uD83E\\uDD27"
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this is brutal to ask in a short interview.. its not hard conceptually, but implementing it is a pain."
                    },
                    {
                        "username": "khuzii",
                        "content": "Hey can you please help me with this code? I am getting runtime error.\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        if(t.size() > s.size())  {\\n            return \"\";\\n        }\\n        map<char, int> mp;\\n        for(int i=0; i<t.size(); i++)  {\\n            mp.insert({t[i], i});\\n        }\\n        string ans;\\n        int minl= s.size()+1;\\n        string x=t;\\n        for(int i=0; i<t.size(); i++)  {\\n            x[i]=\\'#\\';\\n        }\\n        for(int i=0; i<s.size(); i++)  { \\n            string temp= \"\";\\n            string td= t;\\n            for(int j= i; j<s.size(); j++)  {\\n                if(t.find(s[j])!=string::npos && td!=x)  {\\n                    temp += s[j];\\n                    int y= td.find(s[j]);\\n                    td[y]= \\'#\\';\\n                }\\n                else if(td != x && temp.size()!=0)  {\\n                    temp += s[j];\\n                }\\n                else if(td == x)  {\\n                    if(minl > temp.size())  {\\n                        ans= temp;\\n                        minl= temp.size();\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "what\\'s u buddy\\n"
                    },
                    {
                        "username": "BamesJorn",
                        "content": "Have you tried it again?\\nIf yes - what were the questions?"
                    },
                    {
                        "username": "harrypotter0",
                        "content": "Here are the other sliding window problems to practice:\\n\\nhttps://leetcode.com/problems/sliding-window-maximum/\\nhttps://leetcode.com/problems/minimum-size-subarray-sum/\\nhttps://leetcode.com/problems/minimum-window-substring/\\nhttps://leetcode.com/problems/maximum-length-of-repeated-subarray/\\n\\n\\n\\n"
                    },
                    {
                        "username": "sandipan72",
                        "content": "thanks for the resources bro"
                    },
                    {
                        "username": "bhavesh1201",
                        "content": "thanks mate\\n"
                    },
                    {
                        "username": "petia",
                        "content": "I don\\'t know if it is just me, but I am really tired of the poor explanations of LC problems. Quite often we do not have any input restrictions and bounds. In this problem we don\\'t know if we expect duplicate characters in T, if we are looking for each distinct character of T in S, or literally every single one (i.e. T=\"aa\" and S=\"a\" - is this valid S or not...). Every time I need to submit my code to get to yet another failing test because there is some unmentioned restriction or requirement. In a real interview if this is the case I would ask clarifying questions, obviously this is not an option in this case. So annoying!"
                    },
                    {
                        "username": "trqkkr",
                        "content": "they purposefully try to word things in confusing ways too!"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Totally agree. They are frustrating in my opinion. I got lost with the \"BANC\" result myself. They also did not mention anything about case sensitivity. For the t=\"aa\" I think they want you to find exactly what is in t inside the s, in other words, 2 \\'a\\' characters in t should be found as well in \\'s\\'"
                    },
                    {
                        "username": "RyanYibingJia",
                        "content": "Just be careful for object `Integer`, using `Integer.intValue()` to compare the value of it.\\n\\n"
                    },
                    {
                        "username": "isamnagi",
                        "content": "This helped a lot for me. I cldnt get passed 266 but with this was able too... here is more context if anyone would like. basically, if you compare to Integers, you are comparing there references not there values... ints compare values.. https://stackoverflow.com/questions/4428774/why-java-does-not-see-that-integers-are-equal"
                    },
                    {
                        "username": "matcovic",
                        "content": "It really feels bad when you come up with a solution spending hours, only to receive a TLE on the last test cases with a 10^5 input size!"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "[@user5190JH](/user5190JH) Bro, that may be because you are using a quadratic time algorithm. Same with me. Try to find out a linear!"
                    },
                    {
                        "username": "sujal1245",
                        "content": "Same. 265/267 test cases passed. Now stuck due to TLE ;( Don\\'t want to look up the solution, will try to figure where I could improve."
                    },
                    {
                        "username": "khuzii",
                        "content": "Hey can you please help me with this code? It is giving runtime error.\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        if(t.size() > s.size())  {\\n            return \"\";\\n        }\\n        map<char, int> mp;\\n        for(int i=0; i<t.size(); i++)  {\\n            mp.insert({t[i], i});\\n        }\\n        string ans;\\n        int minl= s.size()+1;\\n        string x=t;\\n        for(int i=0; i<t.size(); i++)  {\\n            x[i]=\\'#\\';\\n        }\\n        for(int i=0; i<s.size(); i++)  { \\n            string temp= \"\";\\n            string td= t;\\n            for(int j= i; j<s.size(); j++)  {\\n                if(t.find(s[j])!=string::npos && td!=x)  {\\n                    temp += s[j];\\n                    int y= td.find(s[j]);\\n                    td[y]= \\'#\\';\\n                }\\n                else if(td != x && temp.size()!=0)  {\\n                    temp += s[j];\\n                }\\n                else if(td == x)  {\\n                    if(minl > temp.size())  {\\n                        ans= temp;\\n                        minl= temp.size();\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "bhanujggandhi",
                        "content": "Do not maintain the string variable and update it every time you find a better minimum substring. **Instead maintain pointers and create substring only once, otherwise there will be TLE/MLE**"
                    },
                    {
                        "username": "abhaydkumar80",
                        "content": "thanks I was stuck in this as well."
                    },
                    {
                        "username": "Shivi_Singh25",
                        "content": "Thank you. I was stuck there. But can you please explain why does that happen?\\n"
                    },
                    {
                        "username": "vineetsai3479",
                        "content": "it worked thanks"
                    },
                    {
                        "username": "hugjobk",
                        "content": "string object is just a pointer. It is very cheap to copy a string"
                    },
                    {
                        "username": "jtimberlakers",
                        "content": " \\n\\nThe Discription is \" Given a string S and a string T, find the minimum window in S which will contain all the characters in T \"\\n\\n \\n\\nsuppose S is \"a\", T is \"aa\"\\n\\n \\n\\nI think the answer should be \"a\" , the character in T is just \"a\", and S contain it. but the test answer is \"\". \\nshould the \"a\" character be twice in the window??"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": " I dunno if it was edited, but there\\'s the \"(including duplicates)\" part in the problem description."
                    },
                    {
                        "username": "conradkun",
                        "content": "Duplicates matter, so S would have to at least have 2 \\'a\\'."
                    },
                    {
                        "username": "ayushabg",
                        "content": "Very Badly written Description! I solved the problem believing that we need to match exact frequencies of characters in t in substrings of s. Only to find test case 192 failing. \\n\"aaaaaaaaaaaabbbbbcdd\", \"abcdd\"  -> \"abbbbbcdd\""
                    },
                    {
                        "username": "JoeDoba",
                        "content": "Why leetcode takes this problem as \"Hard\" which is marked as\"Easy\" in CodeSignal :)"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "How is this easy?"
                    },
                    {
                        "username": "isaackleinman",
                        "content": "It wasn\\'t clear to me from the description that the string `t` can have the same character repeated more than once, and all of these repeats have to be accounted for in `s`. \\n\\nThe description should make this clear."
                    },
                    {
                        "username": "lazarevzubov",
                        "content": " I dunno if it was edited, but there\\'s the \"(including duplicates)\" part in the problem description."
                    }
                ]
            },
            {
                "id": 1782747,
                "content": [
                    {
                        "username": "pilot_n_programmer",
                        "content": "Got this problem at FB yesterday.\\nI solved it sometime ago on leetcode but during the interview I failed to do it.\\nIt was a second problem to solve, 20 mins left and all this time pressure+stress made me to panic.\\nI would expect that two problems in 45 mins would be Easy and Medium or worst case Medium/Medium but got Medium and Hard. \\nMoral of the story: don\\'t expect that you will get the same complexity tasks like others usually get - I find it is sort of lottery. Prepare for worst to make it done! And don\\'t stress or panic - it doesn\\'t help. Good luck everyone!"
                    },
                    {
                        "username": "Gracemann280",
                        "content": "i thought easy+medium was the usual so its better to expect medium /medium and some hard IG \\uD83E\\uDD27"
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this is brutal to ask in a short interview.. its not hard conceptually, but implementing it is a pain."
                    },
                    {
                        "username": "khuzii",
                        "content": "Hey can you please help me with this code? I am getting runtime error.\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        if(t.size() > s.size())  {\\n            return \"\";\\n        }\\n        map<char, int> mp;\\n        for(int i=0; i<t.size(); i++)  {\\n            mp.insert({t[i], i});\\n        }\\n        string ans;\\n        int minl= s.size()+1;\\n        string x=t;\\n        for(int i=0; i<t.size(); i++)  {\\n            x[i]=\\'#\\';\\n        }\\n        for(int i=0; i<s.size(); i++)  { \\n            string temp= \"\";\\n            string td= t;\\n            for(int j= i; j<s.size(); j++)  {\\n                if(t.find(s[j])!=string::npos && td!=x)  {\\n                    temp += s[j];\\n                    int y= td.find(s[j]);\\n                    td[y]= \\'#\\';\\n                }\\n                else if(td != x && temp.size()!=0)  {\\n                    temp += s[j];\\n                }\\n                else if(td == x)  {\\n                    if(minl > temp.size())  {\\n                        ans= temp;\\n                        minl= temp.size();\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "what\\'s u buddy\\n"
                    },
                    {
                        "username": "BamesJorn",
                        "content": "Have you tried it again?\\nIf yes - what were the questions?"
                    },
                    {
                        "username": "harrypotter0",
                        "content": "Here are the other sliding window problems to practice:\\n\\nhttps://leetcode.com/problems/sliding-window-maximum/\\nhttps://leetcode.com/problems/minimum-size-subarray-sum/\\nhttps://leetcode.com/problems/minimum-window-substring/\\nhttps://leetcode.com/problems/maximum-length-of-repeated-subarray/\\n\\n\\n\\n"
                    },
                    {
                        "username": "sandipan72",
                        "content": "thanks for the resources bro"
                    },
                    {
                        "username": "bhavesh1201",
                        "content": "thanks mate\\n"
                    },
                    {
                        "username": "petia",
                        "content": "I don\\'t know if it is just me, but I am really tired of the poor explanations of LC problems. Quite often we do not have any input restrictions and bounds. In this problem we don\\'t know if we expect duplicate characters in T, if we are looking for each distinct character of T in S, or literally every single one (i.e. T=\"aa\" and S=\"a\" - is this valid S or not...). Every time I need to submit my code to get to yet another failing test because there is some unmentioned restriction or requirement. In a real interview if this is the case I would ask clarifying questions, obviously this is not an option in this case. So annoying!"
                    },
                    {
                        "username": "trqkkr",
                        "content": "they purposefully try to word things in confusing ways too!"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Totally agree. They are frustrating in my opinion. I got lost with the \"BANC\" result myself. They also did not mention anything about case sensitivity. For the t=\"aa\" I think they want you to find exactly what is in t inside the s, in other words, 2 \\'a\\' characters in t should be found as well in \\'s\\'"
                    },
                    {
                        "username": "RyanYibingJia",
                        "content": "Just be careful for object `Integer`, using `Integer.intValue()` to compare the value of it.\\n\\n"
                    },
                    {
                        "username": "isamnagi",
                        "content": "This helped a lot for me. I cldnt get passed 266 but with this was able too... here is more context if anyone would like. basically, if you compare to Integers, you are comparing there references not there values... ints compare values.. https://stackoverflow.com/questions/4428774/why-java-does-not-see-that-integers-are-equal"
                    },
                    {
                        "username": "matcovic",
                        "content": "It really feels bad when you come up with a solution spending hours, only to receive a TLE on the last test cases with a 10^5 input size!"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "[@user5190JH](/user5190JH) Bro, that may be because you are using a quadratic time algorithm. Same with me. Try to find out a linear!"
                    },
                    {
                        "username": "sujal1245",
                        "content": "Same. 265/267 test cases passed. Now stuck due to TLE ;( Don\\'t want to look up the solution, will try to figure where I could improve."
                    },
                    {
                        "username": "khuzii",
                        "content": "Hey can you please help me with this code? It is giving runtime error.\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        if(t.size() > s.size())  {\\n            return \"\";\\n        }\\n        map<char, int> mp;\\n        for(int i=0; i<t.size(); i++)  {\\n            mp.insert({t[i], i});\\n        }\\n        string ans;\\n        int minl= s.size()+1;\\n        string x=t;\\n        for(int i=0; i<t.size(); i++)  {\\n            x[i]=\\'#\\';\\n        }\\n        for(int i=0; i<s.size(); i++)  { \\n            string temp= \"\";\\n            string td= t;\\n            for(int j= i; j<s.size(); j++)  {\\n                if(t.find(s[j])!=string::npos && td!=x)  {\\n                    temp += s[j];\\n                    int y= td.find(s[j]);\\n                    td[y]= \\'#\\';\\n                }\\n                else if(td != x && temp.size()!=0)  {\\n                    temp += s[j];\\n                }\\n                else if(td == x)  {\\n                    if(minl > temp.size())  {\\n                        ans= temp;\\n                        minl= temp.size();\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "bhanujggandhi",
                        "content": "Do not maintain the string variable and update it every time you find a better minimum substring. **Instead maintain pointers and create substring only once, otherwise there will be TLE/MLE**"
                    },
                    {
                        "username": "abhaydkumar80",
                        "content": "thanks I was stuck in this as well."
                    },
                    {
                        "username": "Shivi_Singh25",
                        "content": "Thank you. I was stuck there. But can you please explain why does that happen?\\n"
                    },
                    {
                        "username": "vineetsai3479",
                        "content": "it worked thanks"
                    },
                    {
                        "username": "hugjobk",
                        "content": "string object is just a pointer. It is very cheap to copy a string"
                    },
                    {
                        "username": "jtimberlakers",
                        "content": " \\n\\nThe Discription is \" Given a string S and a string T, find the minimum window in S which will contain all the characters in T \"\\n\\n \\n\\nsuppose S is \"a\", T is \"aa\"\\n\\n \\n\\nI think the answer should be \"a\" , the character in T is just \"a\", and S contain it. but the test answer is \"\". \\nshould the \"a\" character be twice in the window??"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": " I dunno if it was edited, but there\\'s the \"(including duplicates)\" part in the problem description."
                    },
                    {
                        "username": "conradkun",
                        "content": "Duplicates matter, so S would have to at least have 2 \\'a\\'."
                    },
                    {
                        "username": "ayushabg",
                        "content": "Very Badly written Description! I solved the problem believing that we need to match exact frequencies of characters in t in substrings of s. Only to find test case 192 failing. \\n\"aaaaaaaaaaaabbbbbcdd\", \"abcdd\"  -> \"abbbbbcdd\""
                    },
                    {
                        "username": "JoeDoba",
                        "content": "Why leetcode takes this problem as \"Hard\" which is marked as\"Easy\" in CodeSignal :)"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "How is this easy?"
                    },
                    {
                        "username": "isaackleinman",
                        "content": "It wasn\\'t clear to me from the description that the string `t` can have the same character repeated more than once, and all of these repeats have to be accounted for in `s`. \\n\\nThe description should make this clear."
                    },
                    {
                        "username": "lazarevzubov",
                        "content": " I dunno if it was edited, but there\\'s the \"(including duplicates)\" part in the problem description."
                    }
                ]
            },
            {
                "id": 1741463,
                "content": [
                    {
                        "username": "pilot_n_programmer",
                        "content": "Got this problem at FB yesterday.\\nI solved it sometime ago on leetcode but during the interview I failed to do it.\\nIt was a second problem to solve, 20 mins left and all this time pressure+stress made me to panic.\\nI would expect that two problems in 45 mins would be Easy and Medium or worst case Medium/Medium but got Medium and Hard. \\nMoral of the story: don\\'t expect that you will get the same complexity tasks like others usually get - I find it is sort of lottery. Prepare for worst to make it done! And don\\'t stress or panic - it doesn\\'t help. Good luck everyone!"
                    },
                    {
                        "username": "Gracemann280",
                        "content": "i thought easy+medium was the usual so its better to expect medium /medium and some hard IG \\uD83E\\uDD27"
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this is brutal to ask in a short interview.. its not hard conceptually, but implementing it is a pain."
                    },
                    {
                        "username": "khuzii",
                        "content": "Hey can you please help me with this code? I am getting runtime error.\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        if(t.size() > s.size())  {\\n            return \"\";\\n        }\\n        map<char, int> mp;\\n        for(int i=0; i<t.size(); i++)  {\\n            mp.insert({t[i], i});\\n        }\\n        string ans;\\n        int minl= s.size()+1;\\n        string x=t;\\n        for(int i=0; i<t.size(); i++)  {\\n            x[i]=\\'#\\';\\n        }\\n        for(int i=0; i<s.size(); i++)  { \\n            string temp= \"\";\\n            string td= t;\\n            for(int j= i; j<s.size(); j++)  {\\n                if(t.find(s[j])!=string::npos && td!=x)  {\\n                    temp += s[j];\\n                    int y= td.find(s[j]);\\n                    td[y]= \\'#\\';\\n                }\\n                else if(td != x && temp.size()!=0)  {\\n                    temp += s[j];\\n                }\\n                else if(td == x)  {\\n                    if(minl > temp.size())  {\\n                        ans= temp;\\n                        minl= temp.size();\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "what\\'s u buddy\\n"
                    },
                    {
                        "username": "BamesJorn",
                        "content": "Have you tried it again?\\nIf yes - what were the questions?"
                    },
                    {
                        "username": "harrypotter0",
                        "content": "Here are the other sliding window problems to practice:\\n\\nhttps://leetcode.com/problems/sliding-window-maximum/\\nhttps://leetcode.com/problems/minimum-size-subarray-sum/\\nhttps://leetcode.com/problems/minimum-window-substring/\\nhttps://leetcode.com/problems/maximum-length-of-repeated-subarray/\\n\\n\\n\\n"
                    },
                    {
                        "username": "sandipan72",
                        "content": "thanks for the resources bro"
                    },
                    {
                        "username": "bhavesh1201",
                        "content": "thanks mate\\n"
                    },
                    {
                        "username": "petia",
                        "content": "I don\\'t know if it is just me, but I am really tired of the poor explanations of LC problems. Quite often we do not have any input restrictions and bounds. In this problem we don\\'t know if we expect duplicate characters in T, if we are looking for each distinct character of T in S, or literally every single one (i.e. T=\"aa\" and S=\"a\" - is this valid S or not...). Every time I need to submit my code to get to yet another failing test because there is some unmentioned restriction or requirement. In a real interview if this is the case I would ask clarifying questions, obviously this is not an option in this case. So annoying!"
                    },
                    {
                        "username": "trqkkr",
                        "content": "they purposefully try to word things in confusing ways too!"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Totally agree. They are frustrating in my opinion. I got lost with the \"BANC\" result myself. They also did not mention anything about case sensitivity. For the t=\"aa\" I think they want you to find exactly what is in t inside the s, in other words, 2 \\'a\\' characters in t should be found as well in \\'s\\'"
                    },
                    {
                        "username": "RyanYibingJia",
                        "content": "Just be careful for object `Integer`, using `Integer.intValue()` to compare the value of it.\\n\\n"
                    },
                    {
                        "username": "isamnagi",
                        "content": "This helped a lot for me. I cldnt get passed 266 but with this was able too... here is more context if anyone would like. basically, if you compare to Integers, you are comparing there references not there values... ints compare values.. https://stackoverflow.com/questions/4428774/why-java-does-not-see-that-integers-are-equal"
                    },
                    {
                        "username": "matcovic",
                        "content": "It really feels bad when you come up with a solution spending hours, only to receive a TLE on the last test cases with a 10^5 input size!"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "[@user5190JH](/user5190JH) Bro, that may be because you are using a quadratic time algorithm. Same with me. Try to find out a linear!"
                    },
                    {
                        "username": "sujal1245",
                        "content": "Same. 265/267 test cases passed. Now stuck due to TLE ;( Don\\'t want to look up the solution, will try to figure where I could improve."
                    },
                    {
                        "username": "khuzii",
                        "content": "Hey can you please help me with this code? It is giving runtime error.\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        if(t.size() > s.size())  {\\n            return \"\";\\n        }\\n        map<char, int> mp;\\n        for(int i=0; i<t.size(); i++)  {\\n            mp.insert({t[i], i});\\n        }\\n        string ans;\\n        int minl= s.size()+1;\\n        string x=t;\\n        for(int i=0; i<t.size(); i++)  {\\n            x[i]=\\'#\\';\\n        }\\n        for(int i=0; i<s.size(); i++)  { \\n            string temp= \"\";\\n            string td= t;\\n            for(int j= i; j<s.size(); j++)  {\\n                if(t.find(s[j])!=string::npos && td!=x)  {\\n                    temp += s[j];\\n                    int y= td.find(s[j]);\\n                    td[y]= \\'#\\';\\n                }\\n                else if(td != x && temp.size()!=0)  {\\n                    temp += s[j];\\n                }\\n                else if(td == x)  {\\n                    if(minl > temp.size())  {\\n                        ans= temp;\\n                        minl= temp.size();\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "bhanujggandhi",
                        "content": "Do not maintain the string variable and update it every time you find a better minimum substring. **Instead maintain pointers and create substring only once, otherwise there will be TLE/MLE**"
                    },
                    {
                        "username": "abhaydkumar80",
                        "content": "thanks I was stuck in this as well."
                    },
                    {
                        "username": "Shivi_Singh25",
                        "content": "Thank you. I was stuck there. But can you please explain why does that happen?\\n"
                    },
                    {
                        "username": "vineetsai3479",
                        "content": "it worked thanks"
                    },
                    {
                        "username": "hugjobk",
                        "content": "string object is just a pointer. It is very cheap to copy a string"
                    },
                    {
                        "username": "jtimberlakers",
                        "content": " \\n\\nThe Discription is \" Given a string S and a string T, find the minimum window in S which will contain all the characters in T \"\\n\\n \\n\\nsuppose S is \"a\", T is \"aa\"\\n\\n \\n\\nI think the answer should be \"a\" , the character in T is just \"a\", and S contain it. but the test answer is \"\". \\nshould the \"a\" character be twice in the window??"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": " I dunno if it was edited, but there\\'s the \"(including duplicates)\" part in the problem description."
                    },
                    {
                        "username": "conradkun",
                        "content": "Duplicates matter, so S would have to at least have 2 \\'a\\'."
                    },
                    {
                        "username": "ayushabg",
                        "content": "Very Badly written Description! I solved the problem believing that we need to match exact frequencies of characters in t in substrings of s. Only to find test case 192 failing. \\n\"aaaaaaaaaaaabbbbbcdd\", \"abcdd\"  -> \"abbbbbcdd\""
                    },
                    {
                        "username": "JoeDoba",
                        "content": "Why leetcode takes this problem as \"Hard\" which is marked as\"Easy\" in CodeSignal :)"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "How is this easy?"
                    },
                    {
                        "username": "isaackleinman",
                        "content": "It wasn\\'t clear to me from the description that the string `t` can have the same character repeated more than once, and all of these repeats have to be accounted for in `s`. \\n\\nThe description should make this clear."
                    },
                    {
                        "username": "lazarevzubov",
                        "content": " I dunno if it was edited, but there\\'s the \"(including duplicates)\" part in the problem description."
                    }
                ]
            },
            {
                "id": 1565943,
                "content": [
                    {
                        "username": "pilot_n_programmer",
                        "content": "Got this problem at FB yesterday.\\nI solved it sometime ago on leetcode but during the interview I failed to do it.\\nIt was a second problem to solve, 20 mins left and all this time pressure+stress made me to panic.\\nI would expect that two problems in 45 mins would be Easy and Medium or worst case Medium/Medium but got Medium and Hard. \\nMoral of the story: don\\'t expect that you will get the same complexity tasks like others usually get - I find it is sort of lottery. Prepare for worst to make it done! And don\\'t stress or panic - it doesn\\'t help. Good luck everyone!"
                    },
                    {
                        "username": "Gracemann280",
                        "content": "i thought easy+medium was the usual so its better to expect medium /medium and some hard IG \\uD83E\\uDD27"
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this is brutal to ask in a short interview.. its not hard conceptually, but implementing it is a pain."
                    },
                    {
                        "username": "khuzii",
                        "content": "Hey can you please help me with this code? I am getting runtime error.\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        if(t.size() > s.size())  {\\n            return \"\";\\n        }\\n        map<char, int> mp;\\n        for(int i=0; i<t.size(); i++)  {\\n            mp.insert({t[i], i});\\n        }\\n        string ans;\\n        int minl= s.size()+1;\\n        string x=t;\\n        for(int i=0; i<t.size(); i++)  {\\n            x[i]=\\'#\\';\\n        }\\n        for(int i=0; i<s.size(); i++)  { \\n            string temp= \"\";\\n            string td= t;\\n            for(int j= i; j<s.size(); j++)  {\\n                if(t.find(s[j])!=string::npos && td!=x)  {\\n                    temp += s[j];\\n                    int y= td.find(s[j]);\\n                    td[y]= \\'#\\';\\n                }\\n                else if(td != x && temp.size()!=0)  {\\n                    temp += s[j];\\n                }\\n                else if(td == x)  {\\n                    if(minl > temp.size())  {\\n                        ans= temp;\\n                        minl= temp.size();\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "what\\'s u buddy\\n"
                    },
                    {
                        "username": "BamesJorn",
                        "content": "Have you tried it again?\\nIf yes - what were the questions?"
                    },
                    {
                        "username": "harrypotter0",
                        "content": "Here are the other sliding window problems to practice:\\n\\nhttps://leetcode.com/problems/sliding-window-maximum/\\nhttps://leetcode.com/problems/minimum-size-subarray-sum/\\nhttps://leetcode.com/problems/minimum-window-substring/\\nhttps://leetcode.com/problems/maximum-length-of-repeated-subarray/\\n\\n\\n\\n"
                    },
                    {
                        "username": "sandipan72",
                        "content": "thanks for the resources bro"
                    },
                    {
                        "username": "bhavesh1201",
                        "content": "thanks mate\\n"
                    },
                    {
                        "username": "petia",
                        "content": "I don\\'t know if it is just me, but I am really tired of the poor explanations of LC problems. Quite often we do not have any input restrictions and bounds. In this problem we don\\'t know if we expect duplicate characters in T, if we are looking for each distinct character of T in S, or literally every single one (i.e. T=\"aa\" and S=\"a\" - is this valid S or not...). Every time I need to submit my code to get to yet another failing test because there is some unmentioned restriction or requirement. In a real interview if this is the case I would ask clarifying questions, obviously this is not an option in this case. So annoying!"
                    },
                    {
                        "username": "trqkkr",
                        "content": "they purposefully try to word things in confusing ways too!"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Totally agree. They are frustrating in my opinion. I got lost with the \"BANC\" result myself. They also did not mention anything about case sensitivity. For the t=\"aa\" I think they want you to find exactly what is in t inside the s, in other words, 2 \\'a\\' characters in t should be found as well in \\'s\\'"
                    },
                    {
                        "username": "RyanYibingJia",
                        "content": "Just be careful for object `Integer`, using `Integer.intValue()` to compare the value of it.\\n\\n"
                    },
                    {
                        "username": "isamnagi",
                        "content": "This helped a lot for me. I cldnt get passed 266 but with this was able too... here is more context if anyone would like. basically, if you compare to Integers, you are comparing there references not there values... ints compare values.. https://stackoverflow.com/questions/4428774/why-java-does-not-see-that-integers-are-equal"
                    },
                    {
                        "username": "matcovic",
                        "content": "It really feels bad when you come up with a solution spending hours, only to receive a TLE on the last test cases with a 10^5 input size!"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "[@user5190JH](/user5190JH) Bro, that may be because you are using a quadratic time algorithm. Same with me. Try to find out a linear!"
                    },
                    {
                        "username": "sujal1245",
                        "content": "Same. 265/267 test cases passed. Now stuck due to TLE ;( Don\\'t want to look up the solution, will try to figure where I could improve."
                    },
                    {
                        "username": "khuzii",
                        "content": "Hey can you please help me with this code? It is giving runtime error.\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        if(t.size() > s.size())  {\\n            return \"\";\\n        }\\n        map<char, int> mp;\\n        for(int i=0; i<t.size(); i++)  {\\n            mp.insert({t[i], i});\\n        }\\n        string ans;\\n        int minl= s.size()+1;\\n        string x=t;\\n        for(int i=0; i<t.size(); i++)  {\\n            x[i]=\\'#\\';\\n        }\\n        for(int i=0; i<s.size(); i++)  { \\n            string temp= \"\";\\n            string td= t;\\n            for(int j= i; j<s.size(); j++)  {\\n                if(t.find(s[j])!=string::npos && td!=x)  {\\n                    temp += s[j];\\n                    int y= td.find(s[j]);\\n                    td[y]= \\'#\\';\\n                }\\n                else if(td != x && temp.size()!=0)  {\\n                    temp += s[j];\\n                }\\n                else if(td == x)  {\\n                    if(minl > temp.size())  {\\n                        ans= temp;\\n                        minl= temp.size();\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "bhanujggandhi",
                        "content": "Do not maintain the string variable and update it every time you find a better minimum substring. **Instead maintain pointers and create substring only once, otherwise there will be TLE/MLE**"
                    },
                    {
                        "username": "abhaydkumar80",
                        "content": "thanks I was stuck in this as well."
                    },
                    {
                        "username": "Shivi_Singh25",
                        "content": "Thank you. I was stuck there. But can you please explain why does that happen?\\n"
                    },
                    {
                        "username": "vineetsai3479",
                        "content": "it worked thanks"
                    },
                    {
                        "username": "hugjobk",
                        "content": "string object is just a pointer. It is very cheap to copy a string"
                    },
                    {
                        "username": "jtimberlakers",
                        "content": " \\n\\nThe Discription is \" Given a string S and a string T, find the minimum window in S which will contain all the characters in T \"\\n\\n \\n\\nsuppose S is \"a\", T is \"aa\"\\n\\n \\n\\nI think the answer should be \"a\" , the character in T is just \"a\", and S contain it. but the test answer is \"\". \\nshould the \"a\" character be twice in the window??"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": " I dunno if it was edited, but there\\'s the \"(including duplicates)\" part in the problem description."
                    },
                    {
                        "username": "conradkun",
                        "content": "Duplicates matter, so S would have to at least have 2 \\'a\\'."
                    },
                    {
                        "username": "ayushabg",
                        "content": "Very Badly written Description! I solved the problem believing that we need to match exact frequencies of characters in t in substrings of s. Only to find test case 192 failing. \\n\"aaaaaaaaaaaabbbbbcdd\", \"abcdd\"  -> \"abbbbbcdd\""
                    },
                    {
                        "username": "JoeDoba",
                        "content": "Why leetcode takes this problem as \"Hard\" which is marked as\"Easy\" in CodeSignal :)"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "How is this easy?"
                    },
                    {
                        "username": "isaackleinman",
                        "content": "It wasn\\'t clear to me from the description that the string `t` can have the same character repeated more than once, and all of these repeats have to be accounted for in `s`. \\n\\nThe description should make this clear."
                    },
                    {
                        "username": "lazarevzubov",
                        "content": " I dunno if it was edited, but there\\'s the \"(including duplicates)\" part in the problem description."
                    }
                ]
            },
            {
                "id": 1654586,
                "content": [
                    {
                        "username": "pilot_n_programmer",
                        "content": "Got this problem at FB yesterday.\\nI solved it sometime ago on leetcode but during the interview I failed to do it.\\nIt was a second problem to solve, 20 mins left and all this time pressure+stress made me to panic.\\nI would expect that two problems in 45 mins would be Easy and Medium or worst case Medium/Medium but got Medium and Hard. \\nMoral of the story: don\\'t expect that you will get the same complexity tasks like others usually get - I find it is sort of lottery. Prepare for worst to make it done! And don\\'t stress or panic - it doesn\\'t help. Good luck everyone!"
                    },
                    {
                        "username": "Gracemann280",
                        "content": "i thought easy+medium was the usual so its better to expect medium /medium and some hard IG \\uD83E\\uDD27"
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this is brutal to ask in a short interview.. its not hard conceptually, but implementing it is a pain."
                    },
                    {
                        "username": "khuzii",
                        "content": "Hey can you please help me with this code? I am getting runtime error.\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        if(t.size() > s.size())  {\\n            return \"\";\\n        }\\n        map<char, int> mp;\\n        for(int i=0; i<t.size(); i++)  {\\n            mp.insert({t[i], i});\\n        }\\n        string ans;\\n        int minl= s.size()+1;\\n        string x=t;\\n        for(int i=0; i<t.size(); i++)  {\\n            x[i]=\\'#\\';\\n        }\\n        for(int i=0; i<s.size(); i++)  { \\n            string temp= \"\";\\n            string td= t;\\n            for(int j= i; j<s.size(); j++)  {\\n                if(t.find(s[j])!=string::npos && td!=x)  {\\n                    temp += s[j];\\n                    int y= td.find(s[j]);\\n                    td[y]= \\'#\\';\\n                }\\n                else if(td != x && temp.size()!=0)  {\\n                    temp += s[j];\\n                }\\n                else if(td == x)  {\\n                    if(minl > temp.size())  {\\n                        ans= temp;\\n                        minl= temp.size();\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "what\\'s u buddy\\n"
                    },
                    {
                        "username": "BamesJorn",
                        "content": "Have you tried it again?\\nIf yes - what were the questions?"
                    },
                    {
                        "username": "harrypotter0",
                        "content": "Here are the other sliding window problems to practice:\\n\\nhttps://leetcode.com/problems/sliding-window-maximum/\\nhttps://leetcode.com/problems/minimum-size-subarray-sum/\\nhttps://leetcode.com/problems/minimum-window-substring/\\nhttps://leetcode.com/problems/maximum-length-of-repeated-subarray/\\n\\n\\n\\n"
                    },
                    {
                        "username": "sandipan72",
                        "content": "thanks for the resources bro"
                    },
                    {
                        "username": "bhavesh1201",
                        "content": "thanks mate\\n"
                    },
                    {
                        "username": "petia",
                        "content": "I don\\'t know if it is just me, but I am really tired of the poor explanations of LC problems. Quite often we do not have any input restrictions and bounds. In this problem we don\\'t know if we expect duplicate characters in T, if we are looking for each distinct character of T in S, or literally every single one (i.e. T=\"aa\" and S=\"a\" - is this valid S or not...). Every time I need to submit my code to get to yet another failing test because there is some unmentioned restriction or requirement. In a real interview if this is the case I would ask clarifying questions, obviously this is not an option in this case. So annoying!"
                    },
                    {
                        "username": "trqkkr",
                        "content": "they purposefully try to word things in confusing ways too!"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Totally agree. They are frustrating in my opinion. I got lost with the \"BANC\" result myself. They also did not mention anything about case sensitivity. For the t=\"aa\" I think they want you to find exactly what is in t inside the s, in other words, 2 \\'a\\' characters in t should be found as well in \\'s\\'"
                    },
                    {
                        "username": "RyanYibingJia",
                        "content": "Just be careful for object `Integer`, using `Integer.intValue()` to compare the value of it.\\n\\n"
                    },
                    {
                        "username": "isamnagi",
                        "content": "This helped a lot for me. I cldnt get passed 266 but with this was able too... here is more context if anyone would like. basically, if you compare to Integers, you are comparing there references not there values... ints compare values.. https://stackoverflow.com/questions/4428774/why-java-does-not-see-that-integers-are-equal"
                    },
                    {
                        "username": "matcovic",
                        "content": "It really feels bad when you come up with a solution spending hours, only to receive a TLE on the last test cases with a 10^5 input size!"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "[@user5190JH](/user5190JH) Bro, that may be because you are using a quadratic time algorithm. Same with me. Try to find out a linear!"
                    },
                    {
                        "username": "sujal1245",
                        "content": "Same. 265/267 test cases passed. Now stuck due to TLE ;( Don\\'t want to look up the solution, will try to figure where I could improve."
                    },
                    {
                        "username": "khuzii",
                        "content": "Hey can you please help me with this code? It is giving runtime error.\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        if(t.size() > s.size())  {\\n            return \"\";\\n        }\\n        map<char, int> mp;\\n        for(int i=0; i<t.size(); i++)  {\\n            mp.insert({t[i], i});\\n        }\\n        string ans;\\n        int minl= s.size()+1;\\n        string x=t;\\n        for(int i=0; i<t.size(); i++)  {\\n            x[i]=\\'#\\';\\n        }\\n        for(int i=0; i<s.size(); i++)  { \\n            string temp= \"\";\\n            string td= t;\\n            for(int j= i; j<s.size(); j++)  {\\n                if(t.find(s[j])!=string::npos && td!=x)  {\\n                    temp += s[j];\\n                    int y= td.find(s[j]);\\n                    td[y]= \\'#\\';\\n                }\\n                else if(td != x && temp.size()!=0)  {\\n                    temp += s[j];\\n                }\\n                else if(td == x)  {\\n                    if(minl > temp.size())  {\\n                        ans= temp;\\n                        minl= temp.size();\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "bhanujggandhi",
                        "content": "Do not maintain the string variable and update it every time you find a better minimum substring. **Instead maintain pointers and create substring only once, otherwise there will be TLE/MLE**"
                    },
                    {
                        "username": "abhaydkumar80",
                        "content": "thanks I was stuck in this as well."
                    },
                    {
                        "username": "Shivi_Singh25",
                        "content": "Thank you. I was stuck there. But can you please explain why does that happen?\\n"
                    },
                    {
                        "username": "vineetsai3479",
                        "content": "it worked thanks"
                    },
                    {
                        "username": "hugjobk",
                        "content": "string object is just a pointer. It is very cheap to copy a string"
                    },
                    {
                        "username": "jtimberlakers",
                        "content": " \\n\\nThe Discription is \" Given a string S and a string T, find the minimum window in S which will contain all the characters in T \"\\n\\n \\n\\nsuppose S is \"a\", T is \"aa\"\\n\\n \\n\\nI think the answer should be \"a\" , the character in T is just \"a\", and S contain it. but the test answer is \"\". \\nshould the \"a\" character be twice in the window??"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": " I dunno if it was edited, but there\\'s the \"(including duplicates)\" part in the problem description."
                    },
                    {
                        "username": "conradkun",
                        "content": "Duplicates matter, so S would have to at least have 2 \\'a\\'."
                    },
                    {
                        "username": "ayushabg",
                        "content": "Very Badly written Description! I solved the problem believing that we need to match exact frequencies of characters in t in substrings of s. Only to find test case 192 failing. \\n\"aaaaaaaaaaaabbbbbcdd\", \"abcdd\"  -> \"abbbbbcdd\""
                    },
                    {
                        "username": "JoeDoba",
                        "content": "Why leetcode takes this problem as \"Hard\" which is marked as\"Easy\" in CodeSignal :)"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "How is this easy?"
                    },
                    {
                        "username": "isaackleinman",
                        "content": "It wasn\\'t clear to me from the description that the string `t` can have the same character repeated more than once, and all of these repeats have to be accounted for in `s`. \\n\\nThe description should make this clear."
                    },
                    {
                        "username": "lazarevzubov",
                        "content": " I dunno if it was edited, but there\\'s the \"(including duplicates)\" part in the problem description."
                    }
                ]
            },
            {
                "id": 1570179,
                "content": [
                    {
                        "username": "pilot_n_programmer",
                        "content": "Got this problem at FB yesterday.\\nI solved it sometime ago on leetcode but during the interview I failed to do it.\\nIt was a second problem to solve, 20 mins left and all this time pressure+stress made me to panic.\\nI would expect that two problems in 45 mins would be Easy and Medium or worst case Medium/Medium but got Medium and Hard. \\nMoral of the story: don\\'t expect that you will get the same complexity tasks like others usually get - I find it is sort of lottery. Prepare for worst to make it done! And don\\'t stress or panic - it doesn\\'t help. Good luck everyone!"
                    },
                    {
                        "username": "Gracemann280",
                        "content": "i thought easy+medium was the usual so its better to expect medium /medium and some hard IG \\uD83E\\uDD27"
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this is brutal to ask in a short interview.. its not hard conceptually, but implementing it is a pain."
                    },
                    {
                        "username": "khuzii",
                        "content": "Hey can you please help me with this code? I am getting runtime error.\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        if(t.size() > s.size())  {\\n            return \"\";\\n        }\\n        map<char, int> mp;\\n        for(int i=0; i<t.size(); i++)  {\\n            mp.insert({t[i], i});\\n        }\\n        string ans;\\n        int minl= s.size()+1;\\n        string x=t;\\n        for(int i=0; i<t.size(); i++)  {\\n            x[i]=\\'#\\';\\n        }\\n        for(int i=0; i<s.size(); i++)  { \\n            string temp= \"\";\\n            string td= t;\\n            for(int j= i; j<s.size(); j++)  {\\n                if(t.find(s[j])!=string::npos && td!=x)  {\\n                    temp += s[j];\\n                    int y= td.find(s[j]);\\n                    td[y]= \\'#\\';\\n                }\\n                else if(td != x && temp.size()!=0)  {\\n                    temp += s[j];\\n                }\\n                else if(td == x)  {\\n                    if(minl > temp.size())  {\\n                        ans= temp;\\n                        minl= temp.size();\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "what\\'s u buddy\\n"
                    },
                    {
                        "username": "BamesJorn",
                        "content": "Have you tried it again?\\nIf yes - what were the questions?"
                    },
                    {
                        "username": "harrypotter0",
                        "content": "Here are the other sliding window problems to practice:\\n\\nhttps://leetcode.com/problems/sliding-window-maximum/\\nhttps://leetcode.com/problems/minimum-size-subarray-sum/\\nhttps://leetcode.com/problems/minimum-window-substring/\\nhttps://leetcode.com/problems/maximum-length-of-repeated-subarray/\\n\\n\\n\\n"
                    },
                    {
                        "username": "sandipan72",
                        "content": "thanks for the resources bro"
                    },
                    {
                        "username": "bhavesh1201",
                        "content": "thanks mate\\n"
                    },
                    {
                        "username": "petia",
                        "content": "I don\\'t know if it is just me, but I am really tired of the poor explanations of LC problems. Quite often we do not have any input restrictions and bounds. In this problem we don\\'t know if we expect duplicate characters in T, if we are looking for each distinct character of T in S, or literally every single one (i.e. T=\"aa\" and S=\"a\" - is this valid S or not...). Every time I need to submit my code to get to yet another failing test because there is some unmentioned restriction or requirement. In a real interview if this is the case I would ask clarifying questions, obviously this is not an option in this case. So annoying!"
                    },
                    {
                        "username": "trqkkr",
                        "content": "they purposefully try to word things in confusing ways too!"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Totally agree. They are frustrating in my opinion. I got lost with the \"BANC\" result myself. They also did not mention anything about case sensitivity. For the t=\"aa\" I think they want you to find exactly what is in t inside the s, in other words, 2 \\'a\\' characters in t should be found as well in \\'s\\'"
                    },
                    {
                        "username": "RyanYibingJia",
                        "content": "Just be careful for object `Integer`, using `Integer.intValue()` to compare the value of it.\\n\\n"
                    },
                    {
                        "username": "isamnagi",
                        "content": "This helped a lot for me. I cldnt get passed 266 but with this was able too... here is more context if anyone would like. basically, if you compare to Integers, you are comparing there references not there values... ints compare values.. https://stackoverflow.com/questions/4428774/why-java-does-not-see-that-integers-are-equal"
                    },
                    {
                        "username": "matcovic",
                        "content": "It really feels bad when you come up with a solution spending hours, only to receive a TLE on the last test cases with a 10^5 input size!"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "[@user5190JH](/user5190JH) Bro, that may be because you are using a quadratic time algorithm. Same with me. Try to find out a linear!"
                    },
                    {
                        "username": "sujal1245",
                        "content": "Same. 265/267 test cases passed. Now stuck due to TLE ;( Don\\'t want to look up the solution, will try to figure where I could improve."
                    },
                    {
                        "username": "khuzii",
                        "content": "Hey can you please help me with this code? It is giving runtime error.\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        if(t.size() > s.size())  {\\n            return \"\";\\n        }\\n        map<char, int> mp;\\n        for(int i=0; i<t.size(); i++)  {\\n            mp.insert({t[i], i});\\n        }\\n        string ans;\\n        int minl= s.size()+1;\\n        string x=t;\\n        for(int i=0; i<t.size(); i++)  {\\n            x[i]=\\'#\\';\\n        }\\n        for(int i=0; i<s.size(); i++)  { \\n            string temp= \"\";\\n            string td= t;\\n            for(int j= i; j<s.size(); j++)  {\\n                if(t.find(s[j])!=string::npos && td!=x)  {\\n                    temp += s[j];\\n                    int y= td.find(s[j]);\\n                    td[y]= \\'#\\';\\n                }\\n                else if(td != x && temp.size()!=0)  {\\n                    temp += s[j];\\n                }\\n                else if(td == x)  {\\n                    if(minl > temp.size())  {\\n                        ans= temp;\\n                        minl= temp.size();\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "bhanujggandhi",
                        "content": "Do not maintain the string variable and update it every time you find a better minimum substring. **Instead maintain pointers and create substring only once, otherwise there will be TLE/MLE**"
                    },
                    {
                        "username": "abhaydkumar80",
                        "content": "thanks I was stuck in this as well."
                    },
                    {
                        "username": "Shivi_Singh25",
                        "content": "Thank you. I was stuck there. But can you please explain why does that happen?\\n"
                    },
                    {
                        "username": "vineetsai3479",
                        "content": "it worked thanks"
                    },
                    {
                        "username": "hugjobk",
                        "content": "string object is just a pointer. It is very cheap to copy a string"
                    },
                    {
                        "username": "jtimberlakers",
                        "content": " \\n\\nThe Discription is \" Given a string S and a string T, find the minimum window in S which will contain all the characters in T \"\\n\\n \\n\\nsuppose S is \"a\", T is \"aa\"\\n\\n \\n\\nI think the answer should be \"a\" , the character in T is just \"a\", and S contain it. but the test answer is \"\". \\nshould the \"a\" character be twice in the window??"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": " I dunno if it was edited, but there\\'s the \"(including duplicates)\" part in the problem description."
                    },
                    {
                        "username": "conradkun",
                        "content": "Duplicates matter, so S would have to at least have 2 \\'a\\'."
                    },
                    {
                        "username": "ayushabg",
                        "content": "Very Badly written Description! I solved the problem believing that we need to match exact frequencies of characters in t in substrings of s. Only to find test case 192 failing. \\n\"aaaaaaaaaaaabbbbbcdd\", \"abcdd\"  -> \"abbbbbcdd\""
                    },
                    {
                        "username": "JoeDoba",
                        "content": "Why leetcode takes this problem as \"Hard\" which is marked as\"Easy\" in CodeSignal :)"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "How is this easy?"
                    },
                    {
                        "username": "isaackleinman",
                        "content": "It wasn\\'t clear to me from the description that the string `t` can have the same character repeated more than once, and all of these repeats have to be accounted for in `s`. \\n\\nThe description should make this clear."
                    },
                    {
                        "username": "lazarevzubov",
                        "content": " I dunno if it was edited, but there\\'s the \"(including duplicates)\" part in the problem description."
                    }
                ]
            },
            {
                "id": 1567399,
                "content": [
                    {
                        "username": "pilot_n_programmer",
                        "content": "Got this problem at FB yesterday.\\nI solved it sometime ago on leetcode but during the interview I failed to do it.\\nIt was a second problem to solve, 20 mins left and all this time pressure+stress made me to panic.\\nI would expect that two problems in 45 mins would be Easy and Medium or worst case Medium/Medium but got Medium and Hard. \\nMoral of the story: don\\'t expect that you will get the same complexity tasks like others usually get - I find it is sort of lottery. Prepare for worst to make it done! And don\\'t stress or panic - it doesn\\'t help. Good luck everyone!"
                    },
                    {
                        "username": "Gracemann280",
                        "content": "i thought easy+medium was the usual so its better to expect medium /medium and some hard IG \\uD83E\\uDD27"
                    },
                    {
                        "username": "dQw4w9WgXcQ",
                        "content": "this is brutal to ask in a short interview.. its not hard conceptually, but implementing it is a pain."
                    },
                    {
                        "username": "khuzii",
                        "content": "Hey can you please help me with this code? I am getting runtime error.\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        if(t.size() > s.size())  {\\n            return \"\";\\n        }\\n        map<char, int> mp;\\n        for(int i=0; i<t.size(); i++)  {\\n            mp.insert({t[i], i});\\n        }\\n        string ans;\\n        int minl= s.size()+1;\\n        string x=t;\\n        for(int i=0; i<t.size(); i++)  {\\n            x[i]=\\'#\\';\\n        }\\n        for(int i=0; i<s.size(); i++)  { \\n            string temp= \"\";\\n            string td= t;\\n            for(int j= i; j<s.size(); j++)  {\\n                if(t.find(s[j])!=string::npos && td!=x)  {\\n                    temp += s[j];\\n                    int y= td.find(s[j]);\\n                    td[y]= \\'#\\';\\n                }\\n                else if(td != x && temp.size()!=0)  {\\n                    temp += s[j];\\n                }\\n                else if(td == x)  {\\n                    if(minl > temp.size())  {\\n                        ans= temp;\\n                        minl= temp.size();\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "what\\'s u buddy\\n"
                    },
                    {
                        "username": "BamesJorn",
                        "content": "Have you tried it again?\\nIf yes - what were the questions?"
                    },
                    {
                        "username": "harrypotter0",
                        "content": "Here are the other sliding window problems to practice:\\n\\nhttps://leetcode.com/problems/sliding-window-maximum/\\nhttps://leetcode.com/problems/minimum-size-subarray-sum/\\nhttps://leetcode.com/problems/minimum-window-substring/\\nhttps://leetcode.com/problems/maximum-length-of-repeated-subarray/\\n\\n\\n\\n"
                    },
                    {
                        "username": "sandipan72",
                        "content": "thanks for the resources bro"
                    },
                    {
                        "username": "bhavesh1201",
                        "content": "thanks mate\\n"
                    },
                    {
                        "username": "petia",
                        "content": "I don\\'t know if it is just me, but I am really tired of the poor explanations of LC problems. Quite often we do not have any input restrictions and bounds. In this problem we don\\'t know if we expect duplicate characters in T, if we are looking for each distinct character of T in S, or literally every single one (i.e. T=\"aa\" and S=\"a\" - is this valid S or not...). Every time I need to submit my code to get to yet another failing test because there is some unmentioned restriction or requirement. In a real interview if this is the case I would ask clarifying questions, obviously this is not an option in this case. So annoying!"
                    },
                    {
                        "username": "trqkkr",
                        "content": "they purposefully try to word things in confusing ways too!"
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "Totally agree. They are frustrating in my opinion. I got lost with the \"BANC\" result myself. They also did not mention anything about case sensitivity. For the t=\"aa\" I think they want you to find exactly what is in t inside the s, in other words, 2 \\'a\\' characters in t should be found as well in \\'s\\'"
                    },
                    {
                        "username": "RyanYibingJia",
                        "content": "Just be careful for object `Integer`, using `Integer.intValue()` to compare the value of it.\\n\\n"
                    },
                    {
                        "username": "isamnagi",
                        "content": "This helped a lot for me. I cldnt get passed 266 but with this was able too... here is more context if anyone would like. basically, if you compare to Integers, you are comparing there references not there values... ints compare values.. https://stackoverflow.com/questions/4428774/why-java-does-not-see-that-integers-are-equal"
                    },
                    {
                        "username": "matcovic",
                        "content": "It really feels bad when you come up with a solution spending hours, only to receive a TLE on the last test cases with a 10^5 input size!"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "[@user5190JH](/user5190JH) Bro, that may be because you are using a quadratic time algorithm. Same with me. Try to find out a linear!"
                    },
                    {
                        "username": "sujal1245",
                        "content": "Same. 265/267 test cases passed. Now stuck due to TLE ;( Don\\'t want to look up the solution, will try to figure where I could improve."
                    },
                    {
                        "username": "khuzii",
                        "content": "Hey can you please help me with this code? It is giving runtime error.\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        if(t.size() > s.size())  {\\n            return \"\";\\n        }\\n        map<char, int> mp;\\n        for(int i=0; i<t.size(); i++)  {\\n            mp.insert({t[i], i});\\n        }\\n        string ans;\\n        int minl= s.size()+1;\\n        string x=t;\\n        for(int i=0; i<t.size(); i++)  {\\n            x[i]=\\'#\\';\\n        }\\n        for(int i=0; i<s.size(); i++)  { \\n            string temp= \"\";\\n            string td= t;\\n            for(int j= i; j<s.size(); j++)  {\\n                if(t.find(s[j])!=string::npos && td!=x)  {\\n                    temp += s[j];\\n                    int y= td.find(s[j]);\\n                    td[y]= \\'#\\';\\n                }\\n                else if(td != x && temp.size()!=0)  {\\n                    temp += s[j];\\n                }\\n                else if(td == x)  {\\n                    if(minl > temp.size())  {\\n                        ans= temp;\\n                        minl= temp.size();\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "bhanujggandhi",
                        "content": "Do not maintain the string variable and update it every time you find a better minimum substring. **Instead maintain pointers and create substring only once, otherwise there will be TLE/MLE**"
                    },
                    {
                        "username": "abhaydkumar80",
                        "content": "thanks I was stuck in this as well."
                    },
                    {
                        "username": "Shivi_Singh25",
                        "content": "Thank you. I was stuck there. But can you please explain why does that happen?\\n"
                    },
                    {
                        "username": "vineetsai3479",
                        "content": "it worked thanks"
                    },
                    {
                        "username": "hugjobk",
                        "content": "string object is just a pointer. It is very cheap to copy a string"
                    },
                    {
                        "username": "jtimberlakers",
                        "content": " \\n\\nThe Discription is \" Given a string S and a string T, find the minimum window in S which will contain all the characters in T \"\\n\\n \\n\\nsuppose S is \"a\", T is \"aa\"\\n\\n \\n\\nI think the answer should be \"a\" , the character in T is just \"a\", and S contain it. but the test answer is \"\". \\nshould the \"a\" character be twice in the window??"
                    },
                    {
                        "username": "lazarevzubov",
                        "content": " I dunno if it was edited, but there\\'s the \"(including duplicates)\" part in the problem description."
                    },
                    {
                        "username": "conradkun",
                        "content": "Duplicates matter, so S would have to at least have 2 \\'a\\'."
                    },
                    {
                        "username": "ayushabg",
                        "content": "Very Badly written Description! I solved the problem believing that we need to match exact frequencies of characters in t in substrings of s. Only to find test case 192 failing. \\n\"aaaaaaaaaaaabbbbbcdd\", \"abcdd\"  -> \"abbbbbcdd\""
                    },
                    {
                        "username": "JoeDoba",
                        "content": "Why leetcode takes this problem as \"Hard\" which is marked as\"Easy\" in CodeSignal :)"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "How is this easy?"
                    },
                    {
                        "username": "isaackleinman",
                        "content": "It wasn\\'t clear to me from the description that the string `t` can have the same character repeated more than once, and all of these repeats have to be accounted for in `s`. \\n\\nThe description should make this clear."
                    },
                    {
                        "username": "lazarevzubov",
                        "content": " I dunno if it was edited, but there\\'s the \"(including duplicates)\" part in the problem description."
                    }
                ]
            },
            {
                "id": 1766862,
                "content": [
                    {
                        "username": "MyPing0",
                        "content": "If you are stuck on the really long test cases, like #266, make sure you are using either .equals() or .intValue() when trying to compare the values in your HashMap\\'s\\n\\nhttps://stackoverflow.com/questions/4428774/why-java-does-not-see-that-integers-are-equal"
                    },
                    {
                        "username": "altonchan1998",
                        "content": "omg thx so much!! just spent hours struggling what mistake i made."
                    },
                    {
                        "username": "Colston",
                        "content": "HELP\nWhy does my code work except for the last test case 266/267 where it returns an empty string instead of the answer? [Submission Here](https://leetcode.com/problems/minimum-window-substring/submissions/887136199/ \"Submission\")\n\n[@MyPing0](/MyPing0)'s comment solved my problem:\nhttps://stackoverflow.com/questions/4428774/why-java-does-not-see-that-integers-are-equal"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thank you [@Colston](/Colston) the link in  your comment helped me solve the last testcase :)"
                    },
                    {
                        "username": "Lou1s",
                        "content": "I faced this follow up in one interview. Can anyone provide your thoughts? Thank you!"
                    },
                    {
                        "username": "dlwogns0128",
                        "content": "Why is sample case s=\"A\" t=\"\" and expected = \"A\" ?\\n\\nI don\\'t understand :(\\n\\nt has no character so I think expected = \"\" because it is minimum length having all characters in t."
                    },
                    {
                        "username": "manmohan145",
                        "content": "i have passed 266 /267 with this solution.Can anyone tell me why it is failing one case?\\n\\nclass Solution {\\n    public String minWindow(String s, String t) {\\n     Map<Character,Integer> m=new HashMap<>();\\n     Map<Character,Integer> sMap=new HashMap<>();\\n     int have=0;\\n     int need=0;\\n     int r=0;\\n     int l=0;\\n     int [] result=new int []{-1,-1};\\n     int anslen=Integer.MAX_VALUE;\\n     if(t==\"\")\\n     {\\n         return \"\";\\n     }\\n     for(char c:t.toCharArray())\\n     {\\n         sMap.put(c,sMap.getOrDefault(c,0)+1);\\n     }\\n     need=sMap.size();\\n     for(r=0;r<s.length();r++)\\n     {\\n        //  System.out.println(have);\\n         Character curr=s.charAt(r);\\n         m.put(curr,m.getOrDefault(curr,0)+1);\\n\\n         if(sMap.containsKey(curr) && m.get(curr)==sMap.get(curr))\\n         {\\n             have+=1;\\n         }\\n         while(have==need){\\n            //  System.out.println(\"A\");\\n             if(r-l+1<anslen)\\n             {\\n                 anslen=r-l+1;\\n                 result[0]=l;\\n             result[1]=r;\\n            //  System.out.println(result[0]+\"B\"+result[1]);\\n             }\\n             m.put(s.charAt(l),m.get(s.charAt(l))-1);\\n             if(sMap.containsKey(s.charAt(l)) && m.get(s.charAt(l))<sMap.get(s.charAt(l)))\\n             {\\n                 have-=1;\\n             }\\n             l+=1;\\n         }\\n     }\\n     return anslen==Integer.MAX_VALUE?\"\":s.substring(result[0],result[1]+1);\\n}\\n}"
                    },
                    {
                        "username": "mystiquecoder",
                        "content": "[@ashhh97](/ashhh97) facing same issue? to solution to this?"
                    },
                    {
                        "username": "ashhh97",
                        "content": "hi, I have the same problem, did you figure it out? "
                    },
                    {
                        "username": "gracelan",
                        "content": "I think the question just doesn\\'t include enough information and it is so confused. At least the description should point out that **T may contains dup, and substring should also contains at least such number for every character, and also char is case sensitive. **"
                    },
                    {
                        "username": "dh2019",
                        "content": "The question is confusing. The test case that I failed is this: s = \"a\", t =\"aa\". My output was \"a\", the expected output was \"\". All letters in t are just letter a. Then my outpput is correct. Anybody else had the same problem?"
                    },
                    {
                        "username": "Anmol_Soni",
                        "content": "if t.length() is greater than s.length() return \"\""
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "what they really want is for you to find the exact characters. if t has \"aa\" then s should have at least 2 \\'a\\' characters. the s has only one character, it means there is no match."
                    },
                    {
                        "username": "liudongtony",
                        "content": "I know the problems are different, but I still attempt to try to solve it with KMP algorithm.\\nAnyone have any idea?"
                    },
                    {
                        "username": "lzhao",
                        "content": "The problem asks for a solution in O(n), and I assume n is the size of S. Is a solution in O(n * m) acceptable?"
                    },
                    {
                        "username": "whyalwaysme",
                        "content": "The description of this problem is VERY ambigious. It doesn\\'t clearly say if characters in string T are all distinct/unique. If they\\'re not unique, what does \"contain all the characters in T\" mean? Say, if S is \"a\" and T is \"aa\", should we consider that S contains all characters in T?"
                    }
                ]
            },
            {
                "id": 1778374,
                "content": [
                    {
                        "username": "MyPing0",
                        "content": "If you are stuck on the really long test cases, like #266, make sure you are using either .equals() or .intValue() when trying to compare the values in your HashMap\\'s\\n\\nhttps://stackoverflow.com/questions/4428774/why-java-does-not-see-that-integers-are-equal"
                    },
                    {
                        "username": "altonchan1998",
                        "content": "omg thx so much!! just spent hours struggling what mistake i made."
                    },
                    {
                        "username": "Colston",
                        "content": "HELP\nWhy does my code work except for the last test case 266/267 where it returns an empty string instead of the answer? [Submission Here](https://leetcode.com/problems/minimum-window-substring/submissions/887136199/ \"Submission\")\n\n[@MyPing0](/MyPing0)'s comment solved my problem:\nhttps://stackoverflow.com/questions/4428774/why-java-does-not-see-that-integers-are-equal"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thank you [@Colston](/Colston) the link in  your comment helped me solve the last testcase :)"
                    },
                    {
                        "username": "Lou1s",
                        "content": "I faced this follow up in one interview. Can anyone provide your thoughts? Thank you!"
                    },
                    {
                        "username": "dlwogns0128",
                        "content": "Why is sample case s=\"A\" t=\"\" and expected = \"A\" ?\\n\\nI don\\'t understand :(\\n\\nt has no character so I think expected = \"\" because it is minimum length having all characters in t."
                    },
                    {
                        "username": "manmohan145",
                        "content": "i have passed 266 /267 with this solution.Can anyone tell me why it is failing one case?\\n\\nclass Solution {\\n    public String minWindow(String s, String t) {\\n     Map<Character,Integer> m=new HashMap<>();\\n     Map<Character,Integer> sMap=new HashMap<>();\\n     int have=0;\\n     int need=0;\\n     int r=0;\\n     int l=0;\\n     int [] result=new int []{-1,-1};\\n     int anslen=Integer.MAX_VALUE;\\n     if(t==\"\")\\n     {\\n         return \"\";\\n     }\\n     for(char c:t.toCharArray())\\n     {\\n         sMap.put(c,sMap.getOrDefault(c,0)+1);\\n     }\\n     need=sMap.size();\\n     for(r=0;r<s.length();r++)\\n     {\\n        //  System.out.println(have);\\n         Character curr=s.charAt(r);\\n         m.put(curr,m.getOrDefault(curr,0)+1);\\n\\n         if(sMap.containsKey(curr) && m.get(curr)==sMap.get(curr))\\n         {\\n             have+=1;\\n         }\\n         while(have==need){\\n            //  System.out.println(\"A\");\\n             if(r-l+1<anslen)\\n             {\\n                 anslen=r-l+1;\\n                 result[0]=l;\\n             result[1]=r;\\n            //  System.out.println(result[0]+\"B\"+result[1]);\\n             }\\n             m.put(s.charAt(l),m.get(s.charAt(l))-1);\\n             if(sMap.containsKey(s.charAt(l)) && m.get(s.charAt(l))<sMap.get(s.charAt(l)))\\n             {\\n                 have-=1;\\n             }\\n             l+=1;\\n         }\\n     }\\n     return anslen==Integer.MAX_VALUE?\"\":s.substring(result[0],result[1]+1);\\n}\\n}"
                    },
                    {
                        "username": "mystiquecoder",
                        "content": "[@ashhh97](/ashhh97) facing same issue? to solution to this?"
                    },
                    {
                        "username": "ashhh97",
                        "content": "hi, I have the same problem, did you figure it out? "
                    },
                    {
                        "username": "gracelan",
                        "content": "I think the question just doesn\\'t include enough information and it is so confused. At least the description should point out that **T may contains dup, and substring should also contains at least such number for every character, and also char is case sensitive. **"
                    },
                    {
                        "username": "dh2019",
                        "content": "The question is confusing. The test case that I failed is this: s = \"a\", t =\"aa\". My output was \"a\", the expected output was \"\". All letters in t are just letter a. Then my outpput is correct. Anybody else had the same problem?"
                    },
                    {
                        "username": "Anmol_Soni",
                        "content": "if t.length() is greater than s.length() return \"\""
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "what they really want is for you to find the exact characters. if t has \"aa\" then s should have at least 2 \\'a\\' characters. the s has only one character, it means there is no match."
                    },
                    {
                        "username": "liudongtony",
                        "content": "I know the problems are different, but I still attempt to try to solve it with KMP algorithm.\\nAnyone have any idea?"
                    },
                    {
                        "username": "lzhao",
                        "content": "The problem asks for a solution in O(n), and I assume n is the size of S. Is a solution in O(n * m) acceptable?"
                    },
                    {
                        "username": "whyalwaysme",
                        "content": "The description of this problem is VERY ambigious. It doesn\\'t clearly say if characters in string T are all distinct/unique. If they\\'re not unique, what does \"contain all the characters in T\" mean? Say, if S is \"a\" and T is \"aa\", should we consider that S contains all characters in T?"
                    }
                ]
            },
            {
                "id": 1568213,
                "content": [
                    {
                        "username": "MyPing0",
                        "content": "If you are stuck on the really long test cases, like #266, make sure you are using either .equals() or .intValue() when trying to compare the values in your HashMap\\'s\\n\\nhttps://stackoverflow.com/questions/4428774/why-java-does-not-see-that-integers-are-equal"
                    },
                    {
                        "username": "altonchan1998",
                        "content": "omg thx so much!! just spent hours struggling what mistake i made."
                    },
                    {
                        "username": "Colston",
                        "content": "HELP\nWhy does my code work except for the last test case 266/267 where it returns an empty string instead of the answer? [Submission Here](https://leetcode.com/problems/minimum-window-substring/submissions/887136199/ \"Submission\")\n\n[@MyPing0](/MyPing0)'s comment solved my problem:\nhttps://stackoverflow.com/questions/4428774/why-java-does-not-see-that-integers-are-equal"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thank you [@Colston](/Colston) the link in  your comment helped me solve the last testcase :)"
                    },
                    {
                        "username": "Lou1s",
                        "content": "I faced this follow up in one interview. Can anyone provide your thoughts? Thank you!"
                    },
                    {
                        "username": "dlwogns0128",
                        "content": "Why is sample case s=\"A\" t=\"\" and expected = \"A\" ?\\n\\nI don\\'t understand :(\\n\\nt has no character so I think expected = \"\" because it is minimum length having all characters in t."
                    },
                    {
                        "username": "manmohan145",
                        "content": "i have passed 266 /267 with this solution.Can anyone tell me why it is failing one case?\\n\\nclass Solution {\\n    public String minWindow(String s, String t) {\\n     Map<Character,Integer> m=new HashMap<>();\\n     Map<Character,Integer> sMap=new HashMap<>();\\n     int have=0;\\n     int need=0;\\n     int r=0;\\n     int l=0;\\n     int [] result=new int []{-1,-1};\\n     int anslen=Integer.MAX_VALUE;\\n     if(t==\"\")\\n     {\\n         return \"\";\\n     }\\n     for(char c:t.toCharArray())\\n     {\\n         sMap.put(c,sMap.getOrDefault(c,0)+1);\\n     }\\n     need=sMap.size();\\n     for(r=0;r<s.length();r++)\\n     {\\n        //  System.out.println(have);\\n         Character curr=s.charAt(r);\\n         m.put(curr,m.getOrDefault(curr,0)+1);\\n\\n         if(sMap.containsKey(curr) && m.get(curr)==sMap.get(curr))\\n         {\\n             have+=1;\\n         }\\n         while(have==need){\\n            //  System.out.println(\"A\");\\n             if(r-l+1<anslen)\\n             {\\n                 anslen=r-l+1;\\n                 result[0]=l;\\n             result[1]=r;\\n            //  System.out.println(result[0]+\"B\"+result[1]);\\n             }\\n             m.put(s.charAt(l),m.get(s.charAt(l))-1);\\n             if(sMap.containsKey(s.charAt(l)) && m.get(s.charAt(l))<sMap.get(s.charAt(l)))\\n             {\\n                 have-=1;\\n             }\\n             l+=1;\\n         }\\n     }\\n     return anslen==Integer.MAX_VALUE?\"\":s.substring(result[0],result[1]+1);\\n}\\n}"
                    },
                    {
                        "username": "mystiquecoder",
                        "content": "[@ashhh97](/ashhh97) facing same issue? to solution to this?"
                    },
                    {
                        "username": "ashhh97",
                        "content": "hi, I have the same problem, did you figure it out? "
                    },
                    {
                        "username": "gracelan",
                        "content": "I think the question just doesn\\'t include enough information and it is so confused. At least the description should point out that **T may contains dup, and substring should also contains at least such number for every character, and also char is case sensitive. **"
                    },
                    {
                        "username": "dh2019",
                        "content": "The question is confusing. The test case that I failed is this: s = \"a\", t =\"aa\". My output was \"a\", the expected output was \"\". All letters in t are just letter a. Then my outpput is correct. Anybody else had the same problem?"
                    },
                    {
                        "username": "Anmol_Soni",
                        "content": "if t.length() is greater than s.length() return \"\""
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "what they really want is for you to find the exact characters. if t has \"aa\" then s should have at least 2 \\'a\\' characters. the s has only one character, it means there is no match."
                    },
                    {
                        "username": "liudongtony",
                        "content": "I know the problems are different, but I still attempt to try to solve it with KMP algorithm.\\nAnyone have any idea?"
                    },
                    {
                        "username": "lzhao",
                        "content": "The problem asks for a solution in O(n), and I assume n is the size of S. Is a solution in O(n * m) acceptable?"
                    },
                    {
                        "username": "whyalwaysme",
                        "content": "The description of this problem is VERY ambigious. It doesn\\'t clearly say if characters in string T are all distinct/unique. If they\\'re not unique, what does \"contain all the characters in T\" mean? Say, if S is \"a\" and T is \"aa\", should we consider that S contains all characters in T?"
                    }
                ]
            },
            {
                "id": 1568142,
                "content": [
                    {
                        "username": "MyPing0",
                        "content": "If you are stuck on the really long test cases, like #266, make sure you are using either .equals() or .intValue() when trying to compare the values in your HashMap\\'s\\n\\nhttps://stackoverflow.com/questions/4428774/why-java-does-not-see-that-integers-are-equal"
                    },
                    {
                        "username": "altonchan1998",
                        "content": "omg thx so much!! just spent hours struggling what mistake i made."
                    },
                    {
                        "username": "Colston",
                        "content": "HELP\nWhy does my code work except for the last test case 266/267 where it returns an empty string instead of the answer? [Submission Here](https://leetcode.com/problems/minimum-window-substring/submissions/887136199/ \"Submission\")\n\n[@MyPing0](/MyPing0)'s comment solved my problem:\nhttps://stackoverflow.com/questions/4428774/why-java-does-not-see-that-integers-are-equal"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thank you [@Colston](/Colston) the link in  your comment helped me solve the last testcase :)"
                    },
                    {
                        "username": "Lou1s",
                        "content": "I faced this follow up in one interview. Can anyone provide your thoughts? Thank you!"
                    },
                    {
                        "username": "dlwogns0128",
                        "content": "Why is sample case s=\"A\" t=\"\" and expected = \"A\" ?\\n\\nI don\\'t understand :(\\n\\nt has no character so I think expected = \"\" because it is minimum length having all characters in t."
                    },
                    {
                        "username": "manmohan145",
                        "content": "i have passed 266 /267 with this solution.Can anyone tell me why it is failing one case?\\n\\nclass Solution {\\n    public String minWindow(String s, String t) {\\n     Map<Character,Integer> m=new HashMap<>();\\n     Map<Character,Integer> sMap=new HashMap<>();\\n     int have=0;\\n     int need=0;\\n     int r=0;\\n     int l=0;\\n     int [] result=new int []{-1,-1};\\n     int anslen=Integer.MAX_VALUE;\\n     if(t==\"\")\\n     {\\n         return \"\";\\n     }\\n     for(char c:t.toCharArray())\\n     {\\n         sMap.put(c,sMap.getOrDefault(c,0)+1);\\n     }\\n     need=sMap.size();\\n     for(r=0;r<s.length();r++)\\n     {\\n        //  System.out.println(have);\\n         Character curr=s.charAt(r);\\n         m.put(curr,m.getOrDefault(curr,0)+1);\\n\\n         if(sMap.containsKey(curr) && m.get(curr)==sMap.get(curr))\\n         {\\n             have+=1;\\n         }\\n         while(have==need){\\n            //  System.out.println(\"A\");\\n             if(r-l+1<anslen)\\n             {\\n                 anslen=r-l+1;\\n                 result[0]=l;\\n             result[1]=r;\\n            //  System.out.println(result[0]+\"B\"+result[1]);\\n             }\\n             m.put(s.charAt(l),m.get(s.charAt(l))-1);\\n             if(sMap.containsKey(s.charAt(l)) && m.get(s.charAt(l))<sMap.get(s.charAt(l)))\\n             {\\n                 have-=1;\\n             }\\n             l+=1;\\n         }\\n     }\\n     return anslen==Integer.MAX_VALUE?\"\":s.substring(result[0],result[1]+1);\\n}\\n}"
                    },
                    {
                        "username": "mystiquecoder",
                        "content": "[@ashhh97](/ashhh97) facing same issue? to solution to this?"
                    },
                    {
                        "username": "ashhh97",
                        "content": "hi, I have the same problem, did you figure it out? "
                    },
                    {
                        "username": "gracelan",
                        "content": "I think the question just doesn\\'t include enough information and it is so confused. At least the description should point out that **T may contains dup, and substring should also contains at least such number for every character, and also char is case sensitive. **"
                    },
                    {
                        "username": "dh2019",
                        "content": "The question is confusing. The test case that I failed is this: s = \"a\", t =\"aa\". My output was \"a\", the expected output was \"\". All letters in t are just letter a. Then my outpput is correct. Anybody else had the same problem?"
                    },
                    {
                        "username": "Anmol_Soni",
                        "content": "if t.length() is greater than s.length() return \"\""
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "what they really want is for you to find the exact characters. if t has \"aa\" then s should have at least 2 \\'a\\' characters. the s has only one character, it means there is no match."
                    },
                    {
                        "username": "liudongtony",
                        "content": "I know the problems are different, but I still attempt to try to solve it with KMP algorithm.\\nAnyone have any idea?"
                    },
                    {
                        "username": "lzhao",
                        "content": "The problem asks for a solution in O(n), and I assume n is the size of S. Is a solution in O(n * m) acceptable?"
                    },
                    {
                        "username": "whyalwaysme",
                        "content": "The description of this problem is VERY ambigious. It doesn\\'t clearly say if characters in string T are all distinct/unique. If they\\'re not unique, what does \"contain all the characters in T\" mean? Say, if S is \"a\" and T is \"aa\", should we consider that S contains all characters in T?"
                    }
                ]
            },
            {
                "id": 1895065,
                "content": [
                    {
                        "username": "MyPing0",
                        "content": "If you are stuck on the really long test cases, like #266, make sure you are using either .equals() or .intValue() when trying to compare the values in your HashMap\\'s\\n\\nhttps://stackoverflow.com/questions/4428774/why-java-does-not-see-that-integers-are-equal"
                    },
                    {
                        "username": "altonchan1998",
                        "content": "omg thx so much!! just spent hours struggling what mistake i made."
                    },
                    {
                        "username": "Colston",
                        "content": "HELP\nWhy does my code work except for the last test case 266/267 where it returns an empty string instead of the answer? [Submission Here](https://leetcode.com/problems/minimum-window-substring/submissions/887136199/ \"Submission\")\n\n[@MyPing0](/MyPing0)'s comment solved my problem:\nhttps://stackoverflow.com/questions/4428774/why-java-does-not-see-that-integers-are-equal"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thank you [@Colston](/Colston) the link in  your comment helped me solve the last testcase :)"
                    },
                    {
                        "username": "Lou1s",
                        "content": "I faced this follow up in one interview. Can anyone provide your thoughts? Thank you!"
                    },
                    {
                        "username": "dlwogns0128",
                        "content": "Why is sample case s=\"A\" t=\"\" and expected = \"A\" ?\\n\\nI don\\'t understand :(\\n\\nt has no character so I think expected = \"\" because it is minimum length having all characters in t."
                    },
                    {
                        "username": "manmohan145",
                        "content": "i have passed 266 /267 with this solution.Can anyone tell me why it is failing one case?\\n\\nclass Solution {\\n    public String minWindow(String s, String t) {\\n     Map<Character,Integer> m=new HashMap<>();\\n     Map<Character,Integer> sMap=new HashMap<>();\\n     int have=0;\\n     int need=0;\\n     int r=0;\\n     int l=0;\\n     int [] result=new int []{-1,-1};\\n     int anslen=Integer.MAX_VALUE;\\n     if(t==\"\")\\n     {\\n         return \"\";\\n     }\\n     for(char c:t.toCharArray())\\n     {\\n         sMap.put(c,sMap.getOrDefault(c,0)+1);\\n     }\\n     need=sMap.size();\\n     for(r=0;r<s.length();r++)\\n     {\\n        //  System.out.println(have);\\n         Character curr=s.charAt(r);\\n         m.put(curr,m.getOrDefault(curr,0)+1);\\n\\n         if(sMap.containsKey(curr) && m.get(curr)==sMap.get(curr))\\n         {\\n             have+=1;\\n         }\\n         while(have==need){\\n            //  System.out.println(\"A\");\\n             if(r-l+1<anslen)\\n             {\\n                 anslen=r-l+1;\\n                 result[0]=l;\\n             result[1]=r;\\n            //  System.out.println(result[0]+\"B\"+result[1]);\\n             }\\n             m.put(s.charAt(l),m.get(s.charAt(l))-1);\\n             if(sMap.containsKey(s.charAt(l)) && m.get(s.charAt(l))<sMap.get(s.charAt(l)))\\n             {\\n                 have-=1;\\n             }\\n             l+=1;\\n         }\\n     }\\n     return anslen==Integer.MAX_VALUE?\"\":s.substring(result[0],result[1]+1);\\n}\\n}"
                    },
                    {
                        "username": "mystiquecoder",
                        "content": "[@ashhh97](/ashhh97) facing same issue? to solution to this?"
                    },
                    {
                        "username": "ashhh97",
                        "content": "hi, I have the same problem, did you figure it out? "
                    },
                    {
                        "username": "gracelan",
                        "content": "I think the question just doesn\\'t include enough information and it is so confused. At least the description should point out that **T may contains dup, and substring should also contains at least such number for every character, and also char is case sensitive. **"
                    },
                    {
                        "username": "dh2019",
                        "content": "The question is confusing. The test case that I failed is this: s = \"a\", t =\"aa\". My output was \"a\", the expected output was \"\". All letters in t are just letter a. Then my outpput is correct. Anybody else had the same problem?"
                    },
                    {
                        "username": "Anmol_Soni",
                        "content": "if t.length() is greater than s.length() return \"\""
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "what they really want is for you to find the exact characters. if t has \"aa\" then s should have at least 2 \\'a\\' characters. the s has only one character, it means there is no match."
                    },
                    {
                        "username": "liudongtony",
                        "content": "I know the problems are different, but I still attempt to try to solve it with KMP algorithm.\\nAnyone have any idea?"
                    },
                    {
                        "username": "lzhao",
                        "content": "The problem asks for a solution in O(n), and I assume n is the size of S. Is a solution in O(n * m) acceptable?"
                    },
                    {
                        "username": "whyalwaysme",
                        "content": "The description of this problem is VERY ambigious. It doesn\\'t clearly say if characters in string T are all distinct/unique. If they\\'re not unique, what does \"contain all the characters in T\" mean? Say, if S is \"a\" and T is \"aa\", should we consider that S contains all characters in T?"
                    }
                ]
            },
            {
                "id": 1568210,
                "content": [
                    {
                        "username": "MyPing0",
                        "content": "If you are stuck on the really long test cases, like #266, make sure you are using either .equals() or .intValue() when trying to compare the values in your HashMap\\'s\\n\\nhttps://stackoverflow.com/questions/4428774/why-java-does-not-see-that-integers-are-equal"
                    },
                    {
                        "username": "altonchan1998",
                        "content": "omg thx so much!! just spent hours struggling what mistake i made."
                    },
                    {
                        "username": "Colston",
                        "content": "HELP\nWhy does my code work except for the last test case 266/267 where it returns an empty string instead of the answer? [Submission Here](https://leetcode.com/problems/minimum-window-substring/submissions/887136199/ \"Submission\")\n\n[@MyPing0](/MyPing0)'s comment solved my problem:\nhttps://stackoverflow.com/questions/4428774/why-java-does-not-see-that-integers-are-equal"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thank you [@Colston](/Colston) the link in  your comment helped me solve the last testcase :)"
                    },
                    {
                        "username": "Lou1s",
                        "content": "I faced this follow up in one interview. Can anyone provide your thoughts? Thank you!"
                    },
                    {
                        "username": "dlwogns0128",
                        "content": "Why is sample case s=\"A\" t=\"\" and expected = \"A\" ?\\n\\nI don\\'t understand :(\\n\\nt has no character so I think expected = \"\" because it is minimum length having all characters in t."
                    },
                    {
                        "username": "manmohan145",
                        "content": "i have passed 266 /267 with this solution.Can anyone tell me why it is failing one case?\\n\\nclass Solution {\\n    public String minWindow(String s, String t) {\\n     Map<Character,Integer> m=new HashMap<>();\\n     Map<Character,Integer> sMap=new HashMap<>();\\n     int have=0;\\n     int need=0;\\n     int r=0;\\n     int l=0;\\n     int [] result=new int []{-1,-1};\\n     int anslen=Integer.MAX_VALUE;\\n     if(t==\"\")\\n     {\\n         return \"\";\\n     }\\n     for(char c:t.toCharArray())\\n     {\\n         sMap.put(c,sMap.getOrDefault(c,0)+1);\\n     }\\n     need=sMap.size();\\n     for(r=0;r<s.length();r++)\\n     {\\n        //  System.out.println(have);\\n         Character curr=s.charAt(r);\\n         m.put(curr,m.getOrDefault(curr,0)+1);\\n\\n         if(sMap.containsKey(curr) && m.get(curr)==sMap.get(curr))\\n         {\\n             have+=1;\\n         }\\n         while(have==need){\\n            //  System.out.println(\"A\");\\n             if(r-l+1<anslen)\\n             {\\n                 anslen=r-l+1;\\n                 result[0]=l;\\n             result[1]=r;\\n            //  System.out.println(result[0]+\"B\"+result[1]);\\n             }\\n             m.put(s.charAt(l),m.get(s.charAt(l))-1);\\n             if(sMap.containsKey(s.charAt(l)) && m.get(s.charAt(l))<sMap.get(s.charAt(l)))\\n             {\\n                 have-=1;\\n             }\\n             l+=1;\\n         }\\n     }\\n     return anslen==Integer.MAX_VALUE?\"\":s.substring(result[0],result[1]+1);\\n}\\n}"
                    },
                    {
                        "username": "mystiquecoder",
                        "content": "[@ashhh97](/ashhh97) facing same issue? to solution to this?"
                    },
                    {
                        "username": "ashhh97",
                        "content": "hi, I have the same problem, did you figure it out? "
                    },
                    {
                        "username": "gracelan",
                        "content": "I think the question just doesn\\'t include enough information and it is so confused. At least the description should point out that **T may contains dup, and substring should also contains at least such number for every character, and also char is case sensitive. **"
                    },
                    {
                        "username": "dh2019",
                        "content": "The question is confusing. The test case that I failed is this: s = \"a\", t =\"aa\". My output was \"a\", the expected output was \"\". All letters in t are just letter a. Then my outpput is correct. Anybody else had the same problem?"
                    },
                    {
                        "username": "Anmol_Soni",
                        "content": "if t.length() is greater than s.length() return \"\""
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "what they really want is for you to find the exact characters. if t has \"aa\" then s should have at least 2 \\'a\\' characters. the s has only one character, it means there is no match."
                    },
                    {
                        "username": "liudongtony",
                        "content": "I know the problems are different, but I still attempt to try to solve it with KMP algorithm.\\nAnyone have any idea?"
                    },
                    {
                        "username": "lzhao",
                        "content": "The problem asks for a solution in O(n), and I assume n is the size of S. Is a solution in O(n * m) acceptable?"
                    },
                    {
                        "username": "whyalwaysme",
                        "content": "The description of this problem is VERY ambigious. It doesn\\'t clearly say if characters in string T are all distinct/unique. If they\\'re not unique, what does \"contain all the characters in T\" mean? Say, if S is \"a\" and T is \"aa\", should we consider that S contains all characters in T?"
                    }
                ]
            },
            {
                "id": 1568173,
                "content": [
                    {
                        "username": "MyPing0",
                        "content": "If you are stuck on the really long test cases, like #266, make sure you are using either .equals() or .intValue() when trying to compare the values in your HashMap\\'s\\n\\nhttps://stackoverflow.com/questions/4428774/why-java-does-not-see-that-integers-are-equal"
                    },
                    {
                        "username": "altonchan1998",
                        "content": "omg thx so much!! just spent hours struggling what mistake i made."
                    },
                    {
                        "username": "Colston",
                        "content": "HELP\nWhy does my code work except for the last test case 266/267 where it returns an empty string instead of the answer? [Submission Here](https://leetcode.com/problems/minimum-window-substring/submissions/887136199/ \"Submission\")\n\n[@MyPing0](/MyPing0)'s comment solved my problem:\nhttps://stackoverflow.com/questions/4428774/why-java-does-not-see-that-integers-are-equal"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thank you [@Colston](/Colston) the link in  your comment helped me solve the last testcase :)"
                    },
                    {
                        "username": "Lou1s",
                        "content": "I faced this follow up in one interview. Can anyone provide your thoughts? Thank you!"
                    },
                    {
                        "username": "dlwogns0128",
                        "content": "Why is sample case s=\"A\" t=\"\" and expected = \"A\" ?\\n\\nI don\\'t understand :(\\n\\nt has no character so I think expected = \"\" because it is minimum length having all characters in t."
                    },
                    {
                        "username": "manmohan145",
                        "content": "i have passed 266 /267 with this solution.Can anyone tell me why it is failing one case?\\n\\nclass Solution {\\n    public String minWindow(String s, String t) {\\n     Map<Character,Integer> m=new HashMap<>();\\n     Map<Character,Integer> sMap=new HashMap<>();\\n     int have=0;\\n     int need=0;\\n     int r=0;\\n     int l=0;\\n     int [] result=new int []{-1,-1};\\n     int anslen=Integer.MAX_VALUE;\\n     if(t==\"\")\\n     {\\n         return \"\";\\n     }\\n     for(char c:t.toCharArray())\\n     {\\n         sMap.put(c,sMap.getOrDefault(c,0)+1);\\n     }\\n     need=sMap.size();\\n     for(r=0;r<s.length();r++)\\n     {\\n        //  System.out.println(have);\\n         Character curr=s.charAt(r);\\n         m.put(curr,m.getOrDefault(curr,0)+1);\\n\\n         if(sMap.containsKey(curr) && m.get(curr)==sMap.get(curr))\\n         {\\n             have+=1;\\n         }\\n         while(have==need){\\n            //  System.out.println(\"A\");\\n             if(r-l+1<anslen)\\n             {\\n                 anslen=r-l+1;\\n                 result[0]=l;\\n             result[1]=r;\\n            //  System.out.println(result[0]+\"B\"+result[1]);\\n             }\\n             m.put(s.charAt(l),m.get(s.charAt(l))-1);\\n             if(sMap.containsKey(s.charAt(l)) && m.get(s.charAt(l))<sMap.get(s.charAt(l)))\\n             {\\n                 have-=1;\\n             }\\n             l+=1;\\n         }\\n     }\\n     return anslen==Integer.MAX_VALUE?\"\":s.substring(result[0],result[1]+1);\\n}\\n}"
                    },
                    {
                        "username": "mystiquecoder",
                        "content": "[@ashhh97](/ashhh97) facing same issue? to solution to this?"
                    },
                    {
                        "username": "ashhh97",
                        "content": "hi, I have the same problem, did you figure it out? "
                    },
                    {
                        "username": "gracelan",
                        "content": "I think the question just doesn\\'t include enough information and it is so confused. At least the description should point out that **T may contains dup, and substring should also contains at least such number for every character, and also char is case sensitive. **"
                    },
                    {
                        "username": "dh2019",
                        "content": "The question is confusing. The test case that I failed is this: s = \"a\", t =\"aa\". My output was \"a\", the expected output was \"\". All letters in t are just letter a. Then my outpput is correct. Anybody else had the same problem?"
                    },
                    {
                        "username": "Anmol_Soni",
                        "content": "if t.length() is greater than s.length() return \"\""
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "what they really want is for you to find the exact characters. if t has \"aa\" then s should have at least 2 \\'a\\' characters. the s has only one character, it means there is no match."
                    },
                    {
                        "username": "liudongtony",
                        "content": "I know the problems are different, but I still attempt to try to solve it with KMP algorithm.\\nAnyone have any idea?"
                    },
                    {
                        "username": "lzhao",
                        "content": "The problem asks for a solution in O(n), and I assume n is the size of S. Is a solution in O(n * m) acceptable?"
                    },
                    {
                        "username": "whyalwaysme",
                        "content": "The description of this problem is VERY ambigious. It doesn\\'t clearly say if characters in string T are all distinct/unique. If they\\'re not unique, what does \"contain all the characters in T\" mean? Say, if S is \"a\" and T is \"aa\", should we consider that S contains all characters in T?"
                    }
                ]
            },
            {
                "id": 1571180,
                "content": [
                    {
                        "username": "MyPing0",
                        "content": "If you are stuck on the really long test cases, like #266, make sure you are using either .equals() or .intValue() when trying to compare the values in your HashMap\\'s\\n\\nhttps://stackoverflow.com/questions/4428774/why-java-does-not-see-that-integers-are-equal"
                    },
                    {
                        "username": "altonchan1998",
                        "content": "omg thx so much!! just spent hours struggling what mistake i made."
                    },
                    {
                        "username": "Colston",
                        "content": "HELP\nWhy does my code work except for the last test case 266/267 where it returns an empty string instead of the answer? [Submission Here](https://leetcode.com/problems/minimum-window-substring/submissions/887136199/ \"Submission\")\n\n[@MyPing0](/MyPing0)'s comment solved my problem:\nhttps://stackoverflow.com/questions/4428774/why-java-does-not-see-that-integers-are-equal"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thank you [@Colston](/Colston) the link in  your comment helped me solve the last testcase :)"
                    },
                    {
                        "username": "Lou1s",
                        "content": "I faced this follow up in one interview. Can anyone provide your thoughts? Thank you!"
                    },
                    {
                        "username": "dlwogns0128",
                        "content": "Why is sample case s=\"A\" t=\"\" and expected = \"A\" ?\\n\\nI don\\'t understand :(\\n\\nt has no character so I think expected = \"\" because it is minimum length having all characters in t."
                    },
                    {
                        "username": "manmohan145",
                        "content": "i have passed 266 /267 with this solution.Can anyone tell me why it is failing one case?\\n\\nclass Solution {\\n    public String minWindow(String s, String t) {\\n     Map<Character,Integer> m=new HashMap<>();\\n     Map<Character,Integer> sMap=new HashMap<>();\\n     int have=0;\\n     int need=0;\\n     int r=0;\\n     int l=0;\\n     int [] result=new int []{-1,-1};\\n     int anslen=Integer.MAX_VALUE;\\n     if(t==\"\")\\n     {\\n         return \"\";\\n     }\\n     for(char c:t.toCharArray())\\n     {\\n         sMap.put(c,sMap.getOrDefault(c,0)+1);\\n     }\\n     need=sMap.size();\\n     for(r=0;r<s.length();r++)\\n     {\\n        //  System.out.println(have);\\n         Character curr=s.charAt(r);\\n         m.put(curr,m.getOrDefault(curr,0)+1);\\n\\n         if(sMap.containsKey(curr) && m.get(curr)==sMap.get(curr))\\n         {\\n             have+=1;\\n         }\\n         while(have==need){\\n            //  System.out.println(\"A\");\\n             if(r-l+1<anslen)\\n             {\\n                 anslen=r-l+1;\\n                 result[0]=l;\\n             result[1]=r;\\n            //  System.out.println(result[0]+\"B\"+result[1]);\\n             }\\n             m.put(s.charAt(l),m.get(s.charAt(l))-1);\\n             if(sMap.containsKey(s.charAt(l)) && m.get(s.charAt(l))<sMap.get(s.charAt(l)))\\n             {\\n                 have-=1;\\n             }\\n             l+=1;\\n         }\\n     }\\n     return anslen==Integer.MAX_VALUE?\"\":s.substring(result[0],result[1]+1);\\n}\\n}"
                    },
                    {
                        "username": "mystiquecoder",
                        "content": "[@ashhh97](/ashhh97) facing same issue? to solution to this?"
                    },
                    {
                        "username": "ashhh97",
                        "content": "hi, I have the same problem, did you figure it out? "
                    },
                    {
                        "username": "gracelan",
                        "content": "I think the question just doesn\\'t include enough information and it is so confused. At least the description should point out that **T may contains dup, and substring should also contains at least such number for every character, and also char is case sensitive. **"
                    },
                    {
                        "username": "dh2019",
                        "content": "The question is confusing. The test case that I failed is this: s = \"a\", t =\"aa\". My output was \"a\", the expected output was \"\". All letters in t are just letter a. Then my outpput is correct. Anybody else had the same problem?"
                    },
                    {
                        "username": "Anmol_Soni",
                        "content": "if t.length() is greater than s.length() return \"\""
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "what they really want is for you to find the exact characters. if t has \"aa\" then s should have at least 2 \\'a\\' characters. the s has only one character, it means there is no match."
                    },
                    {
                        "username": "liudongtony",
                        "content": "I know the problems are different, but I still attempt to try to solve it with KMP algorithm.\\nAnyone have any idea?"
                    },
                    {
                        "username": "lzhao",
                        "content": "The problem asks for a solution in O(n), and I assume n is the size of S. Is a solution in O(n * m) acceptable?"
                    },
                    {
                        "username": "whyalwaysme",
                        "content": "The description of this problem is VERY ambigious. It doesn\\'t clearly say if characters in string T are all distinct/unique. If they\\'re not unique, what does \"contain all the characters in T\" mean? Say, if S is \"a\" and T is \"aa\", should we consider that S contains all characters in T?"
                    }
                ]
            },
            {
                "id": 1568896,
                "content": [
                    {
                        "username": "MyPing0",
                        "content": "If you are stuck on the really long test cases, like #266, make sure you are using either .equals() or .intValue() when trying to compare the values in your HashMap\\'s\\n\\nhttps://stackoverflow.com/questions/4428774/why-java-does-not-see-that-integers-are-equal"
                    },
                    {
                        "username": "altonchan1998",
                        "content": "omg thx so much!! just spent hours struggling what mistake i made."
                    },
                    {
                        "username": "Colston",
                        "content": "HELP\nWhy does my code work except for the last test case 266/267 where it returns an empty string instead of the answer? [Submission Here](https://leetcode.com/problems/minimum-window-substring/submissions/887136199/ \"Submission\")\n\n[@MyPing0](/MyPing0)'s comment solved my problem:\nhttps://stackoverflow.com/questions/4428774/why-java-does-not-see-that-integers-are-equal"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thank you [@Colston](/Colston) the link in  your comment helped me solve the last testcase :)"
                    },
                    {
                        "username": "Lou1s",
                        "content": "I faced this follow up in one interview. Can anyone provide your thoughts? Thank you!"
                    },
                    {
                        "username": "dlwogns0128",
                        "content": "Why is sample case s=\"A\" t=\"\" and expected = \"A\" ?\\n\\nI don\\'t understand :(\\n\\nt has no character so I think expected = \"\" because it is minimum length having all characters in t."
                    },
                    {
                        "username": "manmohan145",
                        "content": "i have passed 266 /267 with this solution.Can anyone tell me why it is failing one case?\\n\\nclass Solution {\\n    public String minWindow(String s, String t) {\\n     Map<Character,Integer> m=new HashMap<>();\\n     Map<Character,Integer> sMap=new HashMap<>();\\n     int have=0;\\n     int need=0;\\n     int r=0;\\n     int l=0;\\n     int [] result=new int []{-1,-1};\\n     int anslen=Integer.MAX_VALUE;\\n     if(t==\"\")\\n     {\\n         return \"\";\\n     }\\n     for(char c:t.toCharArray())\\n     {\\n         sMap.put(c,sMap.getOrDefault(c,0)+1);\\n     }\\n     need=sMap.size();\\n     for(r=0;r<s.length();r++)\\n     {\\n        //  System.out.println(have);\\n         Character curr=s.charAt(r);\\n         m.put(curr,m.getOrDefault(curr,0)+1);\\n\\n         if(sMap.containsKey(curr) && m.get(curr)==sMap.get(curr))\\n         {\\n             have+=1;\\n         }\\n         while(have==need){\\n            //  System.out.println(\"A\");\\n             if(r-l+1<anslen)\\n             {\\n                 anslen=r-l+1;\\n                 result[0]=l;\\n             result[1]=r;\\n            //  System.out.println(result[0]+\"B\"+result[1]);\\n             }\\n             m.put(s.charAt(l),m.get(s.charAt(l))-1);\\n             if(sMap.containsKey(s.charAt(l)) && m.get(s.charAt(l))<sMap.get(s.charAt(l)))\\n             {\\n                 have-=1;\\n             }\\n             l+=1;\\n         }\\n     }\\n     return anslen==Integer.MAX_VALUE?\"\":s.substring(result[0],result[1]+1);\\n}\\n}"
                    },
                    {
                        "username": "mystiquecoder",
                        "content": "[@ashhh97](/ashhh97) facing same issue? to solution to this?"
                    },
                    {
                        "username": "ashhh97",
                        "content": "hi, I have the same problem, did you figure it out? "
                    },
                    {
                        "username": "gracelan",
                        "content": "I think the question just doesn\\'t include enough information and it is so confused. At least the description should point out that **T may contains dup, and substring should also contains at least such number for every character, and also char is case sensitive. **"
                    },
                    {
                        "username": "dh2019",
                        "content": "The question is confusing. The test case that I failed is this: s = \"a\", t =\"aa\". My output was \"a\", the expected output was \"\". All letters in t are just letter a. Then my outpput is correct. Anybody else had the same problem?"
                    },
                    {
                        "username": "Anmol_Soni",
                        "content": "if t.length() is greater than s.length() return \"\""
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "what they really want is for you to find the exact characters. if t has \"aa\" then s should have at least 2 \\'a\\' characters. the s has only one character, it means there is no match."
                    },
                    {
                        "username": "liudongtony",
                        "content": "I know the problems are different, but I still attempt to try to solve it with KMP algorithm.\\nAnyone have any idea?"
                    },
                    {
                        "username": "lzhao",
                        "content": "The problem asks for a solution in O(n), and I assume n is the size of S. Is a solution in O(n * m) acceptable?"
                    },
                    {
                        "username": "whyalwaysme",
                        "content": "The description of this problem is VERY ambigious. It doesn\\'t clearly say if characters in string T are all distinct/unique. If they\\'re not unique, what does \"contain all the characters in T\" mean? Say, if S is \"a\" and T is \"aa\", should we consider that S contains all characters in T?"
                    }
                ]
            },
            {
                "id": 1566842,
                "content": [
                    {
                        "username": "MyPing0",
                        "content": "If you are stuck on the really long test cases, like #266, make sure you are using either .equals() or .intValue() when trying to compare the values in your HashMap\\'s\\n\\nhttps://stackoverflow.com/questions/4428774/why-java-does-not-see-that-integers-are-equal"
                    },
                    {
                        "username": "altonchan1998",
                        "content": "omg thx so much!! just spent hours struggling what mistake i made."
                    },
                    {
                        "username": "Colston",
                        "content": "HELP\nWhy does my code work except for the last test case 266/267 where it returns an empty string instead of the answer? [Submission Here](https://leetcode.com/problems/minimum-window-substring/submissions/887136199/ \"Submission\")\n\n[@MyPing0](/MyPing0)'s comment solved my problem:\nhttps://stackoverflow.com/questions/4428774/why-java-does-not-see-that-integers-are-equal"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thank you [@Colston](/Colston) the link in  your comment helped me solve the last testcase :)"
                    },
                    {
                        "username": "Lou1s",
                        "content": "I faced this follow up in one interview. Can anyone provide your thoughts? Thank you!"
                    },
                    {
                        "username": "dlwogns0128",
                        "content": "Why is sample case s=\"A\" t=\"\" and expected = \"A\" ?\\n\\nI don\\'t understand :(\\n\\nt has no character so I think expected = \"\" because it is minimum length having all characters in t."
                    },
                    {
                        "username": "manmohan145",
                        "content": "i have passed 266 /267 with this solution.Can anyone tell me why it is failing one case?\\n\\nclass Solution {\\n    public String minWindow(String s, String t) {\\n     Map<Character,Integer> m=new HashMap<>();\\n     Map<Character,Integer> sMap=new HashMap<>();\\n     int have=0;\\n     int need=0;\\n     int r=0;\\n     int l=0;\\n     int [] result=new int []{-1,-1};\\n     int anslen=Integer.MAX_VALUE;\\n     if(t==\"\")\\n     {\\n         return \"\";\\n     }\\n     for(char c:t.toCharArray())\\n     {\\n         sMap.put(c,sMap.getOrDefault(c,0)+1);\\n     }\\n     need=sMap.size();\\n     for(r=0;r<s.length();r++)\\n     {\\n        //  System.out.println(have);\\n         Character curr=s.charAt(r);\\n         m.put(curr,m.getOrDefault(curr,0)+1);\\n\\n         if(sMap.containsKey(curr) && m.get(curr)==sMap.get(curr))\\n         {\\n             have+=1;\\n         }\\n         while(have==need){\\n            //  System.out.println(\"A\");\\n             if(r-l+1<anslen)\\n             {\\n                 anslen=r-l+1;\\n                 result[0]=l;\\n             result[1]=r;\\n            //  System.out.println(result[0]+\"B\"+result[1]);\\n             }\\n             m.put(s.charAt(l),m.get(s.charAt(l))-1);\\n             if(sMap.containsKey(s.charAt(l)) && m.get(s.charAt(l))<sMap.get(s.charAt(l)))\\n             {\\n                 have-=1;\\n             }\\n             l+=1;\\n         }\\n     }\\n     return anslen==Integer.MAX_VALUE?\"\":s.substring(result[0],result[1]+1);\\n}\\n}"
                    },
                    {
                        "username": "mystiquecoder",
                        "content": "[@ashhh97](/ashhh97) facing same issue? to solution to this?"
                    },
                    {
                        "username": "ashhh97",
                        "content": "hi, I have the same problem, did you figure it out? "
                    },
                    {
                        "username": "gracelan",
                        "content": "I think the question just doesn\\'t include enough information and it is so confused. At least the description should point out that **T may contains dup, and substring should also contains at least such number for every character, and also char is case sensitive. **"
                    },
                    {
                        "username": "dh2019",
                        "content": "The question is confusing. The test case that I failed is this: s = \"a\", t =\"aa\". My output was \"a\", the expected output was \"\". All letters in t are just letter a. Then my outpput is correct. Anybody else had the same problem?"
                    },
                    {
                        "username": "Anmol_Soni",
                        "content": "if t.length() is greater than s.length() return \"\""
                    },
                    {
                        "username": "FadiZaarouri",
                        "content": "what they really want is for you to find the exact characters. if t has \"aa\" then s should have at least 2 \\'a\\' characters. the s has only one character, it means there is no match."
                    },
                    {
                        "username": "liudongtony",
                        "content": "I know the problems are different, but I still attempt to try to solve it with KMP algorithm.\\nAnyone have any idea?"
                    },
                    {
                        "username": "lzhao",
                        "content": "The problem asks for a solution in O(n), and I assume n is the size of S. Is a solution in O(n * m) acceptable?"
                    },
                    {
                        "username": "whyalwaysme",
                        "content": "The description of this problem is VERY ambigious. It doesn\\'t clearly say if characters in string T are all distinct/unique. If they\\'re not unique, what does \"contain all the characters in T\" mean? Say, if S is \"a\" and T is \"aa\", should we consider that S contains all characters in T?"
                    }
                ]
            },
            {
                "id": 1685683,
                "content": [
                    {
                        "username": "ananya_gt",
                        "content": "I keep getting the \"time limit exceeded\" error. I pass 264/267 test cases, but can\\'t debug this. Does anyone know what might be causing this?\\n"
                    },
                    {
                        "username": "archerfx",
                        "content": "It maybe the same problem as me. [Refer this comment](https://leetcode.com/problems/minimum-window-substring/discussion/comments/1719243)"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02 imagine getting this question in a live interview having never heard it before and answering it correctly on the spot in less than 45 minutes \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Solving it under 45 mins without knowing the algorithm is just great. In this case there is no reason for the interviewer to reject the candidate."
                    },
                    {
                        "username": "Lettuce16",
                        "content": "Then you are a genius :D :D :D"
                    },
                    {
                        "username": "mukunda-",
                        "content": "A lot of these problems are leaving me with questions about constraints. Like this one, what characters are valid?"
                    },
                    {
                        "username": "matthewYen",
                        "content": "my code failed on this test case:\\n\\ns = \\'a\\'\\nt = \\'aa\\'\\n\\nexpected output is: \\'\\'\\nmy output is: \\'a\\'\\n\\nThus, I read the question again. Didn\\'t find a sentence tells me that the window should take duplicated characters into consideration... \\nI feel sad because I need to re-write my code T_T"
                    },
                    {
                        "username": "buyNoWhiteSheep",
                        "content": "\"aaaaaaaaaaaabbbbbcdd\", \"abcdd\""
                    },
                    {
                        "username": "Pratham_Upadhyay",
                        "content": "It feels amazing when you can solve a hard question all by yourself! It brings great happiness, right? If you managed to do it on your own, give yourself a thumbs-up! \\uD83C\\uDF1F"
                    },
                    {
                        "username": "preethivuchuru27916",
                        "content": "I got 265/267 test cases pass successfully. My code solution is of time complexity O(m + n). Still I get the time limit exceeded for the last 2 test cases."
                    },
                    {
                        "username": "cruz-heredia",
                        "content": "s = \"cbbbacccccbbbacbabbabacbabbbabaacbaccccbcbcbcca\"\\nt = \"abcbcabaacccababacbabcacbc\"\\n\\nhas multiple solutions, you should pick the rightmost one."
                    },
                    {
                        "username": "bumate90",
                        "content": "Hm, the time constraints are really tight.\\nI stopwatched the release build of my solution and\\nit returns the correct answer in 38ms, yet I get TLE when I try to submit.\\ns =\"caccaacaaaabbcaccaccc\"\\nt =\"acccacbccc\""
                    },
                    {
                        "username": "harshraj_305",
                        "content": "my problem got memory time exceeded on the test case 266/267\\ni don\\'t know how to solve the issue.\\n\\nhere is the test case \\n[testcase here](https://leetcode.com/submissions/detail/859730878/)"
                    },
                    {
                        "username": "alice0217",
                        "content": "[@Sterling Archer](/archerfx) Thank you for this hint! One thing I realize is that if the solution is O(m+n) but running small sample cases results in more than 0ms, it should be improved to avoid TLE"
                    },
                    {
                        "username": "archerfx",
                        "content": "You have the same problem as me.  You are updating ansStr here everytime there is update in length. It will create string copy everytime resulting in more memory usage. \\n`ansStr = s.substr(i, j-i+1);`\\n\\nYou can modify your code to maybe track min string\\'s starting index and length and return the appropriate substring at the end."
                    }
                ]
            },
            {
                "id": 1656533,
                "content": [
                    {
                        "username": "ananya_gt",
                        "content": "I keep getting the \"time limit exceeded\" error. I pass 264/267 test cases, but can\\'t debug this. Does anyone know what might be causing this?\\n"
                    },
                    {
                        "username": "archerfx",
                        "content": "It maybe the same problem as me. [Refer this comment](https://leetcode.com/problems/minimum-window-substring/discussion/comments/1719243)"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02 imagine getting this question in a live interview having never heard it before and answering it correctly on the spot in less than 45 minutes \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Solving it under 45 mins without knowing the algorithm is just great. In this case there is no reason for the interviewer to reject the candidate."
                    },
                    {
                        "username": "Lettuce16",
                        "content": "Then you are a genius :D :D :D"
                    },
                    {
                        "username": "mukunda-",
                        "content": "A lot of these problems are leaving me with questions about constraints. Like this one, what characters are valid?"
                    },
                    {
                        "username": "matthewYen",
                        "content": "my code failed on this test case:\\n\\ns = \\'a\\'\\nt = \\'aa\\'\\n\\nexpected output is: \\'\\'\\nmy output is: \\'a\\'\\n\\nThus, I read the question again. Didn\\'t find a sentence tells me that the window should take duplicated characters into consideration... \\nI feel sad because I need to re-write my code T_T"
                    },
                    {
                        "username": "buyNoWhiteSheep",
                        "content": "\"aaaaaaaaaaaabbbbbcdd\", \"abcdd\""
                    },
                    {
                        "username": "Pratham_Upadhyay",
                        "content": "It feels amazing when you can solve a hard question all by yourself! It brings great happiness, right? If you managed to do it on your own, give yourself a thumbs-up! \\uD83C\\uDF1F"
                    },
                    {
                        "username": "preethivuchuru27916",
                        "content": "I got 265/267 test cases pass successfully. My code solution is of time complexity O(m + n). Still I get the time limit exceeded for the last 2 test cases."
                    },
                    {
                        "username": "cruz-heredia",
                        "content": "s = \"cbbbacccccbbbacbabbabacbabbbabaacbaccccbcbcbcca\"\\nt = \"abcbcabaacccababacbabcacbc\"\\n\\nhas multiple solutions, you should pick the rightmost one."
                    },
                    {
                        "username": "bumate90",
                        "content": "Hm, the time constraints are really tight.\\nI stopwatched the release build of my solution and\\nit returns the correct answer in 38ms, yet I get TLE when I try to submit.\\ns =\"caccaacaaaabbcaccaccc\"\\nt =\"acccacbccc\""
                    },
                    {
                        "username": "harshraj_305",
                        "content": "my problem got memory time exceeded on the test case 266/267\\ni don\\'t know how to solve the issue.\\n\\nhere is the test case \\n[testcase here](https://leetcode.com/submissions/detail/859730878/)"
                    },
                    {
                        "username": "alice0217",
                        "content": "[@Sterling Archer](/archerfx) Thank you for this hint! One thing I realize is that if the solution is O(m+n) but running small sample cases results in more than 0ms, it should be improved to avoid TLE"
                    },
                    {
                        "username": "archerfx",
                        "content": "You have the same problem as me.  You are updating ansStr here everytime there is update in length. It will create string copy everytime resulting in more memory usage. \\n`ansStr = s.substr(i, j-i+1);`\\n\\nYou can modify your code to maybe track min string\\'s starting index and length and return the appropriate substring at the end."
                    }
                ]
            },
            {
                "id": 1569849,
                "content": [
                    {
                        "username": "ananya_gt",
                        "content": "I keep getting the \"time limit exceeded\" error. I pass 264/267 test cases, but can\\'t debug this. Does anyone know what might be causing this?\\n"
                    },
                    {
                        "username": "archerfx",
                        "content": "It maybe the same problem as me. [Refer this comment](https://leetcode.com/problems/minimum-window-substring/discussion/comments/1719243)"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02 imagine getting this question in a live interview having never heard it before and answering it correctly on the spot in less than 45 minutes \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Solving it under 45 mins without knowing the algorithm is just great. In this case there is no reason for the interviewer to reject the candidate."
                    },
                    {
                        "username": "Lettuce16",
                        "content": "Then you are a genius :D :D :D"
                    },
                    {
                        "username": "mukunda-",
                        "content": "A lot of these problems are leaving me with questions about constraints. Like this one, what characters are valid?"
                    },
                    {
                        "username": "matthewYen",
                        "content": "my code failed on this test case:\\n\\ns = \\'a\\'\\nt = \\'aa\\'\\n\\nexpected output is: \\'\\'\\nmy output is: \\'a\\'\\n\\nThus, I read the question again. Didn\\'t find a sentence tells me that the window should take duplicated characters into consideration... \\nI feel sad because I need to re-write my code T_T"
                    },
                    {
                        "username": "buyNoWhiteSheep",
                        "content": "\"aaaaaaaaaaaabbbbbcdd\", \"abcdd\""
                    },
                    {
                        "username": "Pratham_Upadhyay",
                        "content": "It feels amazing when you can solve a hard question all by yourself! It brings great happiness, right? If you managed to do it on your own, give yourself a thumbs-up! \\uD83C\\uDF1F"
                    },
                    {
                        "username": "preethivuchuru27916",
                        "content": "I got 265/267 test cases pass successfully. My code solution is of time complexity O(m + n). Still I get the time limit exceeded for the last 2 test cases."
                    },
                    {
                        "username": "cruz-heredia",
                        "content": "s = \"cbbbacccccbbbacbabbabacbabbbabaacbaccccbcbcbcca\"\\nt = \"abcbcabaacccababacbabcacbc\"\\n\\nhas multiple solutions, you should pick the rightmost one."
                    },
                    {
                        "username": "bumate90",
                        "content": "Hm, the time constraints are really tight.\\nI stopwatched the release build of my solution and\\nit returns the correct answer in 38ms, yet I get TLE when I try to submit.\\ns =\"caccaacaaaabbcaccaccc\"\\nt =\"acccacbccc\""
                    },
                    {
                        "username": "harshraj_305",
                        "content": "my problem got memory time exceeded on the test case 266/267\\ni don\\'t know how to solve the issue.\\n\\nhere is the test case \\n[testcase here](https://leetcode.com/submissions/detail/859730878/)"
                    },
                    {
                        "username": "alice0217",
                        "content": "[@Sterling Archer](/archerfx) Thank you for this hint! One thing I realize is that if the solution is O(m+n) but running small sample cases results in more than 0ms, it should be improved to avoid TLE"
                    },
                    {
                        "username": "archerfx",
                        "content": "You have the same problem as me.  You are updating ansStr here everytime there is update in length. It will create string copy everytime resulting in more memory usage. \\n`ansStr = s.substr(i, j-i+1);`\\n\\nYou can modify your code to maybe track min string\\'s starting index and length and return the appropriate substring at the end."
                    }
                ]
            },
            {
                "id": 1569380,
                "content": [
                    {
                        "username": "ananya_gt",
                        "content": "I keep getting the \"time limit exceeded\" error. I pass 264/267 test cases, but can\\'t debug this. Does anyone know what might be causing this?\\n"
                    },
                    {
                        "username": "archerfx",
                        "content": "It maybe the same problem as me. [Refer this comment](https://leetcode.com/problems/minimum-window-substring/discussion/comments/1719243)"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02 imagine getting this question in a live interview having never heard it before and answering it correctly on the spot in less than 45 minutes \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Solving it under 45 mins without knowing the algorithm is just great. In this case there is no reason for the interviewer to reject the candidate."
                    },
                    {
                        "username": "Lettuce16",
                        "content": "Then you are a genius :D :D :D"
                    },
                    {
                        "username": "mukunda-",
                        "content": "A lot of these problems are leaving me with questions about constraints. Like this one, what characters are valid?"
                    },
                    {
                        "username": "matthewYen",
                        "content": "my code failed on this test case:\\n\\ns = \\'a\\'\\nt = \\'aa\\'\\n\\nexpected output is: \\'\\'\\nmy output is: \\'a\\'\\n\\nThus, I read the question again. Didn\\'t find a sentence tells me that the window should take duplicated characters into consideration... \\nI feel sad because I need to re-write my code T_T"
                    },
                    {
                        "username": "buyNoWhiteSheep",
                        "content": "\"aaaaaaaaaaaabbbbbcdd\", \"abcdd\""
                    },
                    {
                        "username": "Pratham_Upadhyay",
                        "content": "It feels amazing when you can solve a hard question all by yourself! It brings great happiness, right? If you managed to do it on your own, give yourself a thumbs-up! \\uD83C\\uDF1F"
                    },
                    {
                        "username": "preethivuchuru27916",
                        "content": "I got 265/267 test cases pass successfully. My code solution is of time complexity O(m + n). Still I get the time limit exceeded for the last 2 test cases."
                    },
                    {
                        "username": "cruz-heredia",
                        "content": "s = \"cbbbacccccbbbacbabbabacbabbbabaacbaccccbcbcbcca\"\\nt = \"abcbcabaacccababacbabcacbc\"\\n\\nhas multiple solutions, you should pick the rightmost one."
                    },
                    {
                        "username": "bumate90",
                        "content": "Hm, the time constraints are really tight.\\nI stopwatched the release build of my solution and\\nit returns the correct answer in 38ms, yet I get TLE when I try to submit.\\ns =\"caccaacaaaabbcaccaccc\"\\nt =\"acccacbccc\""
                    },
                    {
                        "username": "harshraj_305",
                        "content": "my problem got memory time exceeded on the test case 266/267\\ni don\\'t know how to solve the issue.\\n\\nhere is the test case \\n[testcase here](https://leetcode.com/submissions/detail/859730878/)"
                    },
                    {
                        "username": "alice0217",
                        "content": "[@Sterling Archer](/archerfx) Thank you for this hint! One thing I realize is that if the solution is O(m+n) but running small sample cases results in more than 0ms, it should be improved to avoid TLE"
                    },
                    {
                        "username": "archerfx",
                        "content": "You have the same problem as me.  You are updating ansStr here everytime there is update in length. It will create string copy everytime resulting in more memory usage. \\n`ansStr = s.substr(i, j-i+1);`\\n\\nYou can modify your code to maybe track min string\\'s starting index and length and return the appropriate substring at the end."
                    }
                ]
            },
            {
                "id": 1571178,
                "content": [
                    {
                        "username": "ananya_gt",
                        "content": "I keep getting the \"time limit exceeded\" error. I pass 264/267 test cases, but can\\'t debug this. Does anyone know what might be causing this?\\n"
                    },
                    {
                        "username": "archerfx",
                        "content": "It maybe the same problem as me. [Refer this comment](https://leetcode.com/problems/minimum-window-substring/discussion/comments/1719243)"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02 imagine getting this question in a live interview having never heard it before and answering it correctly on the spot in less than 45 minutes \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Solving it under 45 mins without knowing the algorithm is just great. In this case there is no reason for the interviewer to reject the candidate."
                    },
                    {
                        "username": "Lettuce16",
                        "content": "Then you are a genius :D :D :D"
                    },
                    {
                        "username": "mukunda-",
                        "content": "A lot of these problems are leaving me with questions about constraints. Like this one, what characters are valid?"
                    },
                    {
                        "username": "matthewYen",
                        "content": "my code failed on this test case:\\n\\ns = \\'a\\'\\nt = \\'aa\\'\\n\\nexpected output is: \\'\\'\\nmy output is: \\'a\\'\\n\\nThus, I read the question again. Didn\\'t find a sentence tells me that the window should take duplicated characters into consideration... \\nI feel sad because I need to re-write my code T_T"
                    },
                    {
                        "username": "buyNoWhiteSheep",
                        "content": "\"aaaaaaaaaaaabbbbbcdd\", \"abcdd\""
                    },
                    {
                        "username": "Pratham_Upadhyay",
                        "content": "It feels amazing when you can solve a hard question all by yourself! It brings great happiness, right? If you managed to do it on your own, give yourself a thumbs-up! \\uD83C\\uDF1F"
                    },
                    {
                        "username": "preethivuchuru27916",
                        "content": "I got 265/267 test cases pass successfully. My code solution is of time complexity O(m + n). Still I get the time limit exceeded for the last 2 test cases."
                    },
                    {
                        "username": "cruz-heredia",
                        "content": "s = \"cbbbacccccbbbacbabbabacbabbbabaacbaccccbcbcbcca\"\\nt = \"abcbcabaacccababacbabcacbc\"\\n\\nhas multiple solutions, you should pick the rightmost one."
                    },
                    {
                        "username": "bumate90",
                        "content": "Hm, the time constraints are really tight.\\nI stopwatched the release build of my solution and\\nit returns the correct answer in 38ms, yet I get TLE when I try to submit.\\ns =\"caccaacaaaabbcaccaccc\"\\nt =\"acccacbccc\""
                    },
                    {
                        "username": "harshraj_305",
                        "content": "my problem got memory time exceeded on the test case 266/267\\ni don\\'t know how to solve the issue.\\n\\nhere is the test case \\n[testcase here](https://leetcode.com/submissions/detail/859730878/)"
                    },
                    {
                        "username": "alice0217",
                        "content": "[@Sterling Archer](/archerfx) Thank you for this hint! One thing I realize is that if the solution is O(m+n) but running small sample cases results in more than 0ms, it should be improved to avoid TLE"
                    },
                    {
                        "username": "archerfx",
                        "content": "You have the same problem as me.  You are updating ansStr here everytime there is update in length. It will create string copy everytime resulting in more memory usage. \\n`ansStr = s.substr(i, j-i+1);`\\n\\nYou can modify your code to maybe track min string\\'s starting index and length and return the appropriate substring at the end."
                    }
                ]
            },
            {
                "id": 1998245,
                "content": [
                    {
                        "username": "ananya_gt",
                        "content": "I keep getting the \"time limit exceeded\" error. I pass 264/267 test cases, but can\\'t debug this. Does anyone know what might be causing this?\\n"
                    },
                    {
                        "username": "archerfx",
                        "content": "It maybe the same problem as me. [Refer this comment](https://leetcode.com/problems/minimum-window-substring/discussion/comments/1719243)"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02 imagine getting this question in a live interview having never heard it before and answering it correctly on the spot in less than 45 minutes \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Solving it under 45 mins without knowing the algorithm is just great. In this case there is no reason for the interviewer to reject the candidate."
                    },
                    {
                        "username": "Lettuce16",
                        "content": "Then you are a genius :D :D :D"
                    },
                    {
                        "username": "mukunda-",
                        "content": "A lot of these problems are leaving me with questions about constraints. Like this one, what characters are valid?"
                    },
                    {
                        "username": "matthewYen",
                        "content": "my code failed on this test case:\\n\\ns = \\'a\\'\\nt = \\'aa\\'\\n\\nexpected output is: \\'\\'\\nmy output is: \\'a\\'\\n\\nThus, I read the question again. Didn\\'t find a sentence tells me that the window should take duplicated characters into consideration... \\nI feel sad because I need to re-write my code T_T"
                    },
                    {
                        "username": "buyNoWhiteSheep",
                        "content": "\"aaaaaaaaaaaabbbbbcdd\", \"abcdd\""
                    },
                    {
                        "username": "Pratham_Upadhyay",
                        "content": "It feels amazing when you can solve a hard question all by yourself! It brings great happiness, right? If you managed to do it on your own, give yourself a thumbs-up! \\uD83C\\uDF1F"
                    },
                    {
                        "username": "preethivuchuru27916",
                        "content": "I got 265/267 test cases pass successfully. My code solution is of time complexity O(m + n). Still I get the time limit exceeded for the last 2 test cases."
                    },
                    {
                        "username": "cruz-heredia",
                        "content": "s = \"cbbbacccccbbbacbabbabacbabbbabaacbaccccbcbcbcca\"\\nt = \"abcbcabaacccababacbabcacbc\"\\n\\nhas multiple solutions, you should pick the rightmost one."
                    },
                    {
                        "username": "bumate90",
                        "content": "Hm, the time constraints are really tight.\\nI stopwatched the release build of my solution and\\nit returns the correct answer in 38ms, yet I get TLE when I try to submit.\\ns =\"caccaacaaaabbcaccaccc\"\\nt =\"acccacbccc\""
                    },
                    {
                        "username": "harshraj_305",
                        "content": "my problem got memory time exceeded on the test case 266/267\\ni don\\'t know how to solve the issue.\\n\\nhere is the test case \\n[testcase here](https://leetcode.com/submissions/detail/859730878/)"
                    },
                    {
                        "username": "alice0217",
                        "content": "[@Sterling Archer](/archerfx) Thank you for this hint! One thing I realize is that if the solution is O(m+n) but running small sample cases results in more than 0ms, it should be improved to avoid TLE"
                    },
                    {
                        "username": "archerfx",
                        "content": "You have the same problem as me.  You are updating ansStr here everytime there is update in length. It will create string copy everytime resulting in more memory usage. \\n`ansStr = s.substr(i, j-i+1);`\\n\\nYou can modify your code to maybe track min string\\'s starting index and length and return the appropriate substring at the end."
                    }
                ]
            },
            {
                "id": 1862613,
                "content": [
                    {
                        "username": "ananya_gt",
                        "content": "I keep getting the \"time limit exceeded\" error. I pass 264/267 test cases, but can\\'t debug this. Does anyone know what might be causing this?\\n"
                    },
                    {
                        "username": "archerfx",
                        "content": "It maybe the same problem as me. [Refer this comment](https://leetcode.com/problems/minimum-window-substring/discussion/comments/1719243)"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02 imagine getting this question in a live interview having never heard it before and answering it correctly on the spot in less than 45 minutes \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Solving it under 45 mins without knowing the algorithm is just great. In this case there is no reason for the interviewer to reject the candidate."
                    },
                    {
                        "username": "Lettuce16",
                        "content": "Then you are a genius :D :D :D"
                    },
                    {
                        "username": "mukunda-",
                        "content": "A lot of these problems are leaving me with questions about constraints. Like this one, what characters are valid?"
                    },
                    {
                        "username": "matthewYen",
                        "content": "my code failed on this test case:\\n\\ns = \\'a\\'\\nt = \\'aa\\'\\n\\nexpected output is: \\'\\'\\nmy output is: \\'a\\'\\n\\nThus, I read the question again. Didn\\'t find a sentence tells me that the window should take duplicated characters into consideration... \\nI feel sad because I need to re-write my code T_T"
                    },
                    {
                        "username": "buyNoWhiteSheep",
                        "content": "\"aaaaaaaaaaaabbbbbcdd\", \"abcdd\""
                    },
                    {
                        "username": "Pratham_Upadhyay",
                        "content": "It feels amazing when you can solve a hard question all by yourself! It brings great happiness, right? If you managed to do it on your own, give yourself a thumbs-up! \\uD83C\\uDF1F"
                    },
                    {
                        "username": "preethivuchuru27916",
                        "content": "I got 265/267 test cases pass successfully. My code solution is of time complexity O(m + n). Still I get the time limit exceeded for the last 2 test cases."
                    },
                    {
                        "username": "cruz-heredia",
                        "content": "s = \"cbbbacccccbbbacbabbabacbabbbabaacbaccccbcbcbcca\"\\nt = \"abcbcabaacccababacbabcacbc\"\\n\\nhas multiple solutions, you should pick the rightmost one."
                    },
                    {
                        "username": "bumate90",
                        "content": "Hm, the time constraints are really tight.\\nI stopwatched the release build of my solution and\\nit returns the correct answer in 38ms, yet I get TLE when I try to submit.\\ns =\"caccaacaaaabbcaccaccc\"\\nt =\"acccacbccc\""
                    },
                    {
                        "username": "harshraj_305",
                        "content": "my problem got memory time exceeded on the test case 266/267\\ni don\\'t know how to solve the issue.\\n\\nhere is the test case \\n[testcase here](https://leetcode.com/submissions/detail/859730878/)"
                    },
                    {
                        "username": "alice0217",
                        "content": "[@Sterling Archer](/archerfx) Thank you for this hint! One thing I realize is that if the solution is O(m+n) but running small sample cases results in more than 0ms, it should be improved to avoid TLE"
                    },
                    {
                        "username": "archerfx",
                        "content": "You have the same problem as me.  You are updating ansStr here everytime there is update in length. It will create string copy everytime resulting in more memory usage. \\n`ansStr = s.substr(i, j-i+1);`\\n\\nYou can modify your code to maybe track min string\\'s starting index and length and return the appropriate substring at the end."
                    }
                ]
            },
            {
                "id": 1765589,
                "content": [
                    {
                        "username": "ananya_gt",
                        "content": "I keep getting the \"time limit exceeded\" error. I pass 264/267 test cases, but can\\'t debug this. Does anyone know what might be causing this?\\n"
                    },
                    {
                        "username": "archerfx",
                        "content": "It maybe the same problem as me. [Refer this comment](https://leetcode.com/problems/minimum-window-substring/discussion/comments/1719243)"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02 imagine getting this question in a live interview having never heard it before and answering it correctly on the spot in less than 45 minutes \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Solving it under 45 mins without knowing the algorithm is just great. In this case there is no reason for the interviewer to reject the candidate."
                    },
                    {
                        "username": "Lettuce16",
                        "content": "Then you are a genius :D :D :D"
                    },
                    {
                        "username": "mukunda-",
                        "content": "A lot of these problems are leaving me with questions about constraints. Like this one, what characters are valid?"
                    },
                    {
                        "username": "matthewYen",
                        "content": "my code failed on this test case:\\n\\ns = \\'a\\'\\nt = \\'aa\\'\\n\\nexpected output is: \\'\\'\\nmy output is: \\'a\\'\\n\\nThus, I read the question again. Didn\\'t find a sentence tells me that the window should take duplicated characters into consideration... \\nI feel sad because I need to re-write my code T_T"
                    },
                    {
                        "username": "buyNoWhiteSheep",
                        "content": "\"aaaaaaaaaaaabbbbbcdd\", \"abcdd\""
                    },
                    {
                        "username": "Pratham_Upadhyay",
                        "content": "It feels amazing when you can solve a hard question all by yourself! It brings great happiness, right? If you managed to do it on your own, give yourself a thumbs-up! \\uD83C\\uDF1F"
                    },
                    {
                        "username": "preethivuchuru27916",
                        "content": "I got 265/267 test cases pass successfully. My code solution is of time complexity O(m + n). Still I get the time limit exceeded for the last 2 test cases."
                    },
                    {
                        "username": "cruz-heredia",
                        "content": "s = \"cbbbacccccbbbacbabbabacbabbbabaacbaccccbcbcbcca\"\\nt = \"abcbcabaacccababacbabcacbc\"\\n\\nhas multiple solutions, you should pick the rightmost one."
                    },
                    {
                        "username": "bumate90",
                        "content": "Hm, the time constraints are really tight.\\nI stopwatched the release build of my solution and\\nit returns the correct answer in 38ms, yet I get TLE when I try to submit.\\ns =\"caccaacaaaabbcaccaccc\"\\nt =\"acccacbccc\""
                    },
                    {
                        "username": "harshraj_305",
                        "content": "my problem got memory time exceeded on the test case 266/267\\ni don\\'t know how to solve the issue.\\n\\nhere is the test case \\n[testcase here](https://leetcode.com/submissions/detail/859730878/)"
                    },
                    {
                        "username": "alice0217",
                        "content": "[@Sterling Archer](/archerfx) Thank you for this hint! One thing I realize is that if the solution is O(m+n) but running small sample cases results in more than 0ms, it should be improved to avoid TLE"
                    },
                    {
                        "username": "archerfx",
                        "content": "You have the same problem as me.  You are updating ansStr here everytime there is update in length. It will create string copy everytime resulting in more memory usage. \\n`ansStr = s.substr(i, j-i+1);`\\n\\nYou can modify your code to maybe track min string\\'s starting index and length and return the appropriate substring at the end."
                    }
                ]
            },
            {
                "id": 1761787,
                "content": [
                    {
                        "username": "ananya_gt",
                        "content": "I keep getting the \"time limit exceeded\" error. I pass 264/267 test cases, but can\\'t debug this. Does anyone know what might be causing this?\\n"
                    },
                    {
                        "username": "archerfx",
                        "content": "It maybe the same problem as me. [Refer this comment](https://leetcode.com/problems/minimum-window-substring/discussion/comments/1719243)"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02 imagine getting this question in a live interview having never heard it before and answering it correctly on the spot in less than 45 minutes \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Solving it under 45 mins without knowing the algorithm is just great. In this case there is no reason for the interviewer to reject the candidate."
                    },
                    {
                        "username": "Lettuce16",
                        "content": "Then you are a genius :D :D :D"
                    },
                    {
                        "username": "mukunda-",
                        "content": "A lot of these problems are leaving me with questions about constraints. Like this one, what characters are valid?"
                    },
                    {
                        "username": "matthewYen",
                        "content": "my code failed on this test case:\\n\\ns = \\'a\\'\\nt = \\'aa\\'\\n\\nexpected output is: \\'\\'\\nmy output is: \\'a\\'\\n\\nThus, I read the question again. Didn\\'t find a sentence tells me that the window should take duplicated characters into consideration... \\nI feel sad because I need to re-write my code T_T"
                    },
                    {
                        "username": "buyNoWhiteSheep",
                        "content": "\"aaaaaaaaaaaabbbbbcdd\", \"abcdd\""
                    },
                    {
                        "username": "Pratham_Upadhyay",
                        "content": "It feels amazing when you can solve a hard question all by yourself! It brings great happiness, right? If you managed to do it on your own, give yourself a thumbs-up! \\uD83C\\uDF1F"
                    },
                    {
                        "username": "preethivuchuru27916",
                        "content": "I got 265/267 test cases pass successfully. My code solution is of time complexity O(m + n). Still I get the time limit exceeded for the last 2 test cases."
                    },
                    {
                        "username": "cruz-heredia",
                        "content": "s = \"cbbbacccccbbbacbabbabacbabbbabaacbaccccbcbcbcca\"\\nt = \"abcbcabaacccababacbabcacbc\"\\n\\nhas multiple solutions, you should pick the rightmost one."
                    },
                    {
                        "username": "bumate90",
                        "content": "Hm, the time constraints are really tight.\\nI stopwatched the release build of my solution and\\nit returns the correct answer in 38ms, yet I get TLE when I try to submit.\\ns =\"caccaacaaaabbcaccaccc\"\\nt =\"acccacbccc\""
                    },
                    {
                        "username": "harshraj_305",
                        "content": "my problem got memory time exceeded on the test case 266/267\\ni don\\'t know how to solve the issue.\\n\\nhere is the test case \\n[testcase here](https://leetcode.com/submissions/detail/859730878/)"
                    },
                    {
                        "username": "alice0217",
                        "content": "[@Sterling Archer](/archerfx) Thank you for this hint! One thing I realize is that if the solution is O(m+n) but running small sample cases results in more than 0ms, it should be improved to avoid TLE"
                    },
                    {
                        "username": "archerfx",
                        "content": "You have the same problem as me.  You are updating ansStr here everytime there is update in length. It will create string copy everytime resulting in more memory usage. \\n`ansStr = s.substr(i, j-i+1);`\\n\\nYou can modify your code to maybe track min string\\'s starting index and length and return the appropriate substring at the end."
                    }
                ]
            },
            {
                "id": 1717030,
                "content": [
                    {
                        "username": "ananya_gt",
                        "content": "I keep getting the \"time limit exceeded\" error. I pass 264/267 test cases, but can\\'t debug this. Does anyone know what might be causing this?\\n"
                    },
                    {
                        "username": "archerfx",
                        "content": "It maybe the same problem as me. [Refer this comment](https://leetcode.com/problems/minimum-window-substring/discussion/comments/1719243)"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02 imagine getting this question in a live interview having never heard it before and answering it correctly on the spot in less than 45 minutes \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Solving it under 45 mins without knowing the algorithm is just great. In this case there is no reason for the interviewer to reject the candidate."
                    },
                    {
                        "username": "Lettuce16",
                        "content": "Then you are a genius :D :D :D"
                    },
                    {
                        "username": "mukunda-",
                        "content": "A lot of these problems are leaving me with questions about constraints. Like this one, what characters are valid?"
                    },
                    {
                        "username": "matthewYen",
                        "content": "my code failed on this test case:\\n\\ns = \\'a\\'\\nt = \\'aa\\'\\n\\nexpected output is: \\'\\'\\nmy output is: \\'a\\'\\n\\nThus, I read the question again. Didn\\'t find a sentence tells me that the window should take duplicated characters into consideration... \\nI feel sad because I need to re-write my code T_T"
                    },
                    {
                        "username": "buyNoWhiteSheep",
                        "content": "\"aaaaaaaaaaaabbbbbcdd\", \"abcdd\""
                    },
                    {
                        "username": "Pratham_Upadhyay",
                        "content": "It feels amazing when you can solve a hard question all by yourself! It brings great happiness, right? If you managed to do it on your own, give yourself a thumbs-up! \\uD83C\\uDF1F"
                    },
                    {
                        "username": "preethivuchuru27916",
                        "content": "I got 265/267 test cases pass successfully. My code solution is of time complexity O(m + n). Still I get the time limit exceeded for the last 2 test cases."
                    },
                    {
                        "username": "cruz-heredia",
                        "content": "s = \"cbbbacccccbbbacbabbabacbabbbabaacbaccccbcbcbcca\"\\nt = \"abcbcabaacccababacbabcacbc\"\\n\\nhas multiple solutions, you should pick the rightmost one."
                    },
                    {
                        "username": "bumate90",
                        "content": "Hm, the time constraints are really tight.\\nI stopwatched the release build of my solution and\\nit returns the correct answer in 38ms, yet I get TLE when I try to submit.\\ns =\"caccaacaaaabbcaccaccc\"\\nt =\"acccacbccc\""
                    },
                    {
                        "username": "harshraj_305",
                        "content": "my problem got memory time exceeded on the test case 266/267\\ni don\\'t know how to solve the issue.\\n\\nhere is the test case \\n[testcase here](https://leetcode.com/submissions/detail/859730878/)"
                    },
                    {
                        "username": "alice0217",
                        "content": "[@Sterling Archer](/archerfx) Thank you for this hint! One thing I realize is that if the solution is O(m+n) but running small sample cases results in more than 0ms, it should be improved to avoid TLE"
                    },
                    {
                        "username": "archerfx",
                        "content": "You have the same problem as me.  You are updating ansStr here everytime there is update in length. It will create string copy everytime resulting in more memory usage. \\n`ansStr = s.substr(i, j-i+1);`\\n\\nYou can modify your code to maybe track min string\\'s starting index and length and return the appropriate substring at the end."
                    }
                ]
            },
            {
                "id": 1639342,
                "content": [
                    {
                        "username": "caodanbobo",
                        "content": "Questions about testcase No.266.\\nI am using two maps to store the count of each charatcers in String s and t, and when one of the charaters\\' count match i will do something. the code is like this:\\n if(map.get(c)==window.get(c)){\\n  //...\\n}\\nhowever it doesn\\'t work in th testcase 266.\\nthis code has to be modified to:\\nint size1=map.get(c);\\nint size2=window.get(c);\\nif(size1==size2){\\n  //...\\n}\\nanyone know the reason behind this?\\n"
                    },
                    {
                        "username": "nsd99",
                        "content": "How do i know what is case 266?"
                    },
                    {
                        "username": "MrZydeco",
                        "content": "This is a poorly worded problem. When the requirement \"in complexity O(N)\" is imposed,  is N:\\n\\t(1) the length of S?\\n\\t(2) the length of T?\\n\\t(3) the sum of the lengths of S and T?\\n\\t\\nAnd is it space or time complexity?\\n\\nMy best guess is that the author meant \"letting N be the length of S, your solution must have time complexity O(N).\"\\n\\nDoes anybody care about this>\\n"
                    },
                    {
                        "username": "zongzx",
                        "content": "What does this test case mean?\\n\"a\"\\n\"aa\"\\nExpected output: \"\"\\n\\nThanks!"
                    },
                    {
                        "username": "Worm4047",
                        "content": "I understood how the first part of the time complexity comes from S, but how does the second part come from T too?"
                    },
                    {
                        "username": "tprakash2014",
                        "content": "Input \"a\" \"aa\"\\nOutput \"a\"\\nExpected \"\"\\n\\nI above expectation is incorrect. It must be \"a\", any thoughts?"
                    },
                    {
                        "username": "zhangwei0119",
                        "content": "My solution returns \"a\", but expected one is \"\"."
                    },
                    {
                        "username": "zhjeff",
                        "content": "Only after reading the solution, it turns out that duplicated chars in T must be considered.\\n"
                    },
                    {
                        "username": "zhangwei0119",
                        "content": "failed with input \"a\" and \"aa\". my output is \"a\" and the expected output is \"\".  Obviously, \"a\" can cover all characters in t."
                    },
                    {
                        "username": "sruzic",
                        "content": "I assume it is length of string S, but it is not hard to explicitly write it."
                    },
                    {
                        "username": "mlgb",
                        "content": "> If there is no such window in S that covers all characters in T, return the **emtpy** string \"\". \\n\\nShouldn't it be empty?:)"
                    }
                ]
            },
            {
                "id": 1574009,
                "content": [
                    {
                        "username": "caodanbobo",
                        "content": "Questions about testcase No.266.\\nI am using two maps to store the count of each charatcers in String s and t, and when one of the charaters\\' count match i will do something. the code is like this:\\n if(map.get(c)==window.get(c)){\\n  //...\\n}\\nhowever it doesn\\'t work in th testcase 266.\\nthis code has to be modified to:\\nint size1=map.get(c);\\nint size2=window.get(c);\\nif(size1==size2){\\n  //...\\n}\\nanyone know the reason behind this?\\n"
                    },
                    {
                        "username": "nsd99",
                        "content": "How do i know what is case 266?"
                    },
                    {
                        "username": "MrZydeco",
                        "content": "This is a poorly worded problem. When the requirement \"in complexity O(N)\" is imposed,  is N:\\n\\t(1) the length of S?\\n\\t(2) the length of T?\\n\\t(3) the sum of the lengths of S and T?\\n\\t\\nAnd is it space or time complexity?\\n\\nMy best guess is that the author meant \"letting N be the length of S, your solution must have time complexity O(N).\"\\n\\nDoes anybody care about this>\\n"
                    },
                    {
                        "username": "zongzx",
                        "content": "What does this test case mean?\\n\"a\"\\n\"aa\"\\nExpected output: \"\"\\n\\nThanks!"
                    },
                    {
                        "username": "Worm4047",
                        "content": "I understood how the first part of the time complexity comes from S, but how does the second part come from T too?"
                    },
                    {
                        "username": "tprakash2014",
                        "content": "Input \"a\" \"aa\"\\nOutput \"a\"\\nExpected \"\"\\n\\nI above expectation is incorrect. It must be \"a\", any thoughts?"
                    },
                    {
                        "username": "zhangwei0119",
                        "content": "My solution returns \"a\", but expected one is \"\"."
                    },
                    {
                        "username": "zhjeff",
                        "content": "Only after reading the solution, it turns out that duplicated chars in T must be considered.\\n"
                    },
                    {
                        "username": "zhangwei0119",
                        "content": "failed with input \"a\" and \"aa\". my output is \"a\" and the expected output is \"\".  Obviously, \"a\" can cover all characters in t."
                    },
                    {
                        "username": "sruzic",
                        "content": "I assume it is length of string S, but it is not hard to explicitly write it."
                    },
                    {
                        "username": "mlgb",
                        "content": "> If there is no such window in S that covers all characters in T, return the **emtpy** string \"\". \\n\\nShouldn't it be empty?:)"
                    }
                ]
            },
            {
                "id": 1573182,
                "content": [
                    {
                        "username": "caodanbobo",
                        "content": "Questions about testcase No.266.\\nI am using two maps to store the count of each charatcers in String s and t, and when one of the charaters\\' count match i will do something. the code is like this:\\n if(map.get(c)==window.get(c)){\\n  //...\\n}\\nhowever it doesn\\'t work in th testcase 266.\\nthis code has to be modified to:\\nint size1=map.get(c);\\nint size2=window.get(c);\\nif(size1==size2){\\n  //...\\n}\\nanyone know the reason behind this?\\n"
                    },
                    {
                        "username": "nsd99",
                        "content": "How do i know what is case 266?"
                    },
                    {
                        "username": "MrZydeco",
                        "content": "This is a poorly worded problem. When the requirement \"in complexity O(N)\" is imposed,  is N:\\n\\t(1) the length of S?\\n\\t(2) the length of T?\\n\\t(3) the sum of the lengths of S and T?\\n\\t\\nAnd is it space or time complexity?\\n\\nMy best guess is that the author meant \"letting N be the length of S, your solution must have time complexity O(N).\"\\n\\nDoes anybody care about this>\\n"
                    },
                    {
                        "username": "zongzx",
                        "content": "What does this test case mean?\\n\"a\"\\n\"aa\"\\nExpected output: \"\"\\n\\nThanks!"
                    },
                    {
                        "username": "Worm4047",
                        "content": "I understood how the first part of the time complexity comes from S, but how does the second part come from T too?"
                    },
                    {
                        "username": "tprakash2014",
                        "content": "Input \"a\" \"aa\"\\nOutput \"a\"\\nExpected \"\"\\n\\nI above expectation is incorrect. It must be \"a\", any thoughts?"
                    },
                    {
                        "username": "zhangwei0119",
                        "content": "My solution returns \"a\", but expected one is \"\"."
                    },
                    {
                        "username": "zhjeff",
                        "content": "Only after reading the solution, it turns out that duplicated chars in T must be considered.\\n"
                    },
                    {
                        "username": "zhangwei0119",
                        "content": "failed with input \"a\" and \"aa\". my output is \"a\" and the expected output is \"\".  Obviously, \"a\" can cover all characters in t."
                    },
                    {
                        "username": "sruzic",
                        "content": "I assume it is length of string S, but it is not hard to explicitly write it."
                    },
                    {
                        "username": "mlgb",
                        "content": "> If there is no such window in S that covers all characters in T, return the **emtpy** string \"\". \\n\\nShouldn't it be empty?:)"
                    }
                ]
            },
            {
                "id": 1573110,
                "content": [
                    {
                        "username": "caodanbobo",
                        "content": "Questions about testcase No.266.\\nI am using two maps to store the count of each charatcers in String s and t, and when one of the charaters\\' count match i will do something. the code is like this:\\n if(map.get(c)==window.get(c)){\\n  //...\\n}\\nhowever it doesn\\'t work in th testcase 266.\\nthis code has to be modified to:\\nint size1=map.get(c);\\nint size2=window.get(c);\\nif(size1==size2){\\n  //...\\n}\\nanyone know the reason behind this?\\n"
                    },
                    {
                        "username": "nsd99",
                        "content": "How do i know what is case 266?"
                    },
                    {
                        "username": "MrZydeco",
                        "content": "This is a poorly worded problem. When the requirement \"in complexity O(N)\" is imposed,  is N:\\n\\t(1) the length of S?\\n\\t(2) the length of T?\\n\\t(3) the sum of the lengths of S and T?\\n\\t\\nAnd is it space or time complexity?\\n\\nMy best guess is that the author meant \"letting N be the length of S, your solution must have time complexity O(N).\"\\n\\nDoes anybody care about this>\\n"
                    },
                    {
                        "username": "zongzx",
                        "content": "What does this test case mean?\\n\"a\"\\n\"aa\"\\nExpected output: \"\"\\n\\nThanks!"
                    },
                    {
                        "username": "Worm4047",
                        "content": "I understood how the first part of the time complexity comes from S, but how does the second part come from T too?"
                    },
                    {
                        "username": "tprakash2014",
                        "content": "Input \"a\" \"aa\"\\nOutput \"a\"\\nExpected \"\"\\n\\nI above expectation is incorrect. It must be \"a\", any thoughts?"
                    },
                    {
                        "username": "zhangwei0119",
                        "content": "My solution returns \"a\", but expected one is \"\"."
                    },
                    {
                        "username": "zhjeff",
                        "content": "Only after reading the solution, it turns out that duplicated chars in T must be considered.\\n"
                    },
                    {
                        "username": "zhangwei0119",
                        "content": "failed with input \"a\" and \"aa\". my output is \"a\" and the expected output is \"\".  Obviously, \"a\" can cover all characters in t."
                    },
                    {
                        "username": "sruzic",
                        "content": "I assume it is length of string S, but it is not hard to explicitly write it."
                    },
                    {
                        "username": "mlgb",
                        "content": "> If there is no such window in S that covers all characters in T, return the **emtpy** string \"\". \\n\\nShouldn't it be empty?:)"
                    }
                ]
            },
            {
                "id": 1572769,
                "content": [
                    {
                        "username": "caodanbobo",
                        "content": "Questions about testcase No.266.\\nI am using two maps to store the count of each charatcers in String s and t, and when one of the charaters\\' count match i will do something. the code is like this:\\n if(map.get(c)==window.get(c)){\\n  //...\\n}\\nhowever it doesn\\'t work in th testcase 266.\\nthis code has to be modified to:\\nint size1=map.get(c);\\nint size2=window.get(c);\\nif(size1==size2){\\n  //...\\n}\\nanyone know the reason behind this?\\n"
                    },
                    {
                        "username": "nsd99",
                        "content": "How do i know what is case 266?"
                    },
                    {
                        "username": "MrZydeco",
                        "content": "This is a poorly worded problem. When the requirement \"in complexity O(N)\" is imposed,  is N:\\n\\t(1) the length of S?\\n\\t(2) the length of T?\\n\\t(3) the sum of the lengths of S and T?\\n\\t\\nAnd is it space or time complexity?\\n\\nMy best guess is that the author meant \"letting N be the length of S, your solution must have time complexity O(N).\"\\n\\nDoes anybody care about this>\\n"
                    },
                    {
                        "username": "zongzx",
                        "content": "What does this test case mean?\\n\"a\"\\n\"aa\"\\nExpected output: \"\"\\n\\nThanks!"
                    },
                    {
                        "username": "Worm4047",
                        "content": "I understood how the first part of the time complexity comes from S, but how does the second part come from T too?"
                    },
                    {
                        "username": "tprakash2014",
                        "content": "Input \"a\" \"aa\"\\nOutput \"a\"\\nExpected \"\"\\n\\nI above expectation is incorrect. It must be \"a\", any thoughts?"
                    },
                    {
                        "username": "zhangwei0119",
                        "content": "My solution returns \"a\", but expected one is \"\"."
                    },
                    {
                        "username": "zhjeff",
                        "content": "Only after reading the solution, it turns out that duplicated chars in T must be considered.\\n"
                    },
                    {
                        "username": "zhangwei0119",
                        "content": "failed with input \"a\" and \"aa\". my output is \"a\" and the expected output is \"\".  Obviously, \"a\" can cover all characters in t."
                    },
                    {
                        "username": "sruzic",
                        "content": "I assume it is length of string S, but it is not hard to explicitly write it."
                    },
                    {
                        "username": "mlgb",
                        "content": "> If there is no such window in S that covers all characters in T, return the **emtpy** string \"\". \\n\\nShouldn't it be empty?:)"
                    }
                ]
            },
            {
                "id": 1571176,
                "content": [
                    {
                        "username": "caodanbobo",
                        "content": "Questions about testcase No.266.\\nI am using two maps to store the count of each charatcers in String s and t, and when one of the charaters\\' count match i will do something. the code is like this:\\n if(map.get(c)==window.get(c)){\\n  //...\\n}\\nhowever it doesn\\'t work in th testcase 266.\\nthis code has to be modified to:\\nint size1=map.get(c);\\nint size2=window.get(c);\\nif(size1==size2){\\n  //...\\n}\\nanyone know the reason behind this?\\n"
                    },
                    {
                        "username": "nsd99",
                        "content": "How do i know what is case 266?"
                    },
                    {
                        "username": "MrZydeco",
                        "content": "This is a poorly worded problem. When the requirement \"in complexity O(N)\" is imposed,  is N:\\n\\t(1) the length of S?\\n\\t(2) the length of T?\\n\\t(3) the sum of the lengths of S and T?\\n\\t\\nAnd is it space or time complexity?\\n\\nMy best guess is that the author meant \"letting N be the length of S, your solution must have time complexity O(N).\"\\n\\nDoes anybody care about this>\\n"
                    },
                    {
                        "username": "zongzx",
                        "content": "What does this test case mean?\\n\"a\"\\n\"aa\"\\nExpected output: \"\"\\n\\nThanks!"
                    },
                    {
                        "username": "Worm4047",
                        "content": "I understood how the first part of the time complexity comes from S, but how does the second part come from T too?"
                    },
                    {
                        "username": "tprakash2014",
                        "content": "Input \"a\" \"aa\"\\nOutput \"a\"\\nExpected \"\"\\n\\nI above expectation is incorrect. It must be \"a\", any thoughts?"
                    },
                    {
                        "username": "zhangwei0119",
                        "content": "My solution returns \"a\", but expected one is \"\"."
                    },
                    {
                        "username": "zhjeff",
                        "content": "Only after reading the solution, it turns out that duplicated chars in T must be considered.\\n"
                    },
                    {
                        "username": "zhangwei0119",
                        "content": "failed with input \"a\" and \"aa\". my output is \"a\" and the expected output is \"\".  Obviously, \"a\" can cover all characters in t."
                    },
                    {
                        "username": "sruzic",
                        "content": "I assume it is length of string S, but it is not hard to explicitly write it."
                    },
                    {
                        "username": "mlgb",
                        "content": "> If there is no such window in S that covers all characters in T, return the **emtpy** string \"\". \\n\\nShouldn't it be empty?:)"
                    }
                ]
            },
            {
                "id": 1572362,
                "content": [
                    {
                        "username": "caodanbobo",
                        "content": "Questions about testcase No.266.\\nI am using two maps to store the count of each charatcers in String s and t, and when one of the charaters\\' count match i will do something. the code is like this:\\n if(map.get(c)==window.get(c)){\\n  //...\\n}\\nhowever it doesn\\'t work in th testcase 266.\\nthis code has to be modified to:\\nint size1=map.get(c);\\nint size2=window.get(c);\\nif(size1==size2){\\n  //...\\n}\\nanyone know the reason behind this?\\n"
                    },
                    {
                        "username": "nsd99",
                        "content": "How do i know what is case 266?"
                    },
                    {
                        "username": "MrZydeco",
                        "content": "This is a poorly worded problem. When the requirement \"in complexity O(N)\" is imposed,  is N:\\n\\t(1) the length of S?\\n\\t(2) the length of T?\\n\\t(3) the sum of the lengths of S and T?\\n\\t\\nAnd is it space or time complexity?\\n\\nMy best guess is that the author meant \"letting N be the length of S, your solution must have time complexity O(N).\"\\n\\nDoes anybody care about this>\\n"
                    },
                    {
                        "username": "zongzx",
                        "content": "What does this test case mean?\\n\"a\"\\n\"aa\"\\nExpected output: \"\"\\n\\nThanks!"
                    },
                    {
                        "username": "Worm4047",
                        "content": "I understood how the first part of the time complexity comes from S, but how does the second part come from T too?"
                    },
                    {
                        "username": "tprakash2014",
                        "content": "Input \"a\" \"aa\"\\nOutput \"a\"\\nExpected \"\"\\n\\nI above expectation is incorrect. It must be \"a\", any thoughts?"
                    },
                    {
                        "username": "zhangwei0119",
                        "content": "My solution returns \"a\", but expected one is \"\"."
                    },
                    {
                        "username": "zhjeff",
                        "content": "Only after reading the solution, it turns out that duplicated chars in T must be considered.\\n"
                    },
                    {
                        "username": "zhangwei0119",
                        "content": "failed with input \"a\" and \"aa\". my output is \"a\" and the expected output is \"\".  Obviously, \"a\" can cover all characters in t."
                    },
                    {
                        "username": "sruzic",
                        "content": "I assume it is length of string S, but it is not hard to explicitly write it."
                    },
                    {
                        "username": "mlgb",
                        "content": "> If there is no such window in S that covers all characters in T, return the **emtpy** string \"\". \\n\\nShouldn't it be empty?:)"
                    }
                ]
            },
            {
                "id": 1571177,
                "content": [
                    {
                        "username": "caodanbobo",
                        "content": "Questions about testcase No.266.\\nI am using two maps to store the count of each charatcers in String s and t, and when one of the charaters\\' count match i will do something. the code is like this:\\n if(map.get(c)==window.get(c)){\\n  //...\\n}\\nhowever it doesn\\'t work in th testcase 266.\\nthis code has to be modified to:\\nint size1=map.get(c);\\nint size2=window.get(c);\\nif(size1==size2){\\n  //...\\n}\\nanyone know the reason behind this?\\n"
                    },
                    {
                        "username": "nsd99",
                        "content": "How do i know what is case 266?"
                    },
                    {
                        "username": "MrZydeco",
                        "content": "This is a poorly worded problem. When the requirement \"in complexity O(N)\" is imposed,  is N:\\n\\t(1) the length of S?\\n\\t(2) the length of T?\\n\\t(3) the sum of the lengths of S and T?\\n\\t\\nAnd is it space or time complexity?\\n\\nMy best guess is that the author meant \"letting N be the length of S, your solution must have time complexity O(N).\"\\n\\nDoes anybody care about this>\\n"
                    },
                    {
                        "username": "zongzx",
                        "content": "What does this test case mean?\\n\"a\"\\n\"aa\"\\nExpected output: \"\"\\n\\nThanks!"
                    },
                    {
                        "username": "Worm4047",
                        "content": "I understood how the first part of the time complexity comes from S, but how does the second part come from T too?"
                    },
                    {
                        "username": "tprakash2014",
                        "content": "Input \"a\" \"aa\"\\nOutput \"a\"\\nExpected \"\"\\n\\nI above expectation is incorrect. It must be \"a\", any thoughts?"
                    },
                    {
                        "username": "zhangwei0119",
                        "content": "My solution returns \"a\", but expected one is \"\"."
                    },
                    {
                        "username": "zhjeff",
                        "content": "Only after reading the solution, it turns out that duplicated chars in T must be considered.\\n"
                    },
                    {
                        "username": "zhangwei0119",
                        "content": "failed with input \"a\" and \"aa\". my output is \"a\" and the expected output is \"\".  Obviously, \"a\" can cover all characters in t."
                    },
                    {
                        "username": "sruzic",
                        "content": "I assume it is length of string S, but it is not hard to explicitly write it."
                    },
                    {
                        "username": "mlgb",
                        "content": "> If there is no such window in S that covers all characters in T, return the **emtpy** string \"\". \\n\\nShouldn't it be empty?:)"
                    }
                ]
            },
            {
                "id": 1571179,
                "content": [
                    {
                        "username": "caodanbobo",
                        "content": "Questions about testcase No.266.\\nI am using two maps to store the count of each charatcers in String s and t, and when one of the charaters\\' count match i will do something. the code is like this:\\n if(map.get(c)==window.get(c)){\\n  //...\\n}\\nhowever it doesn\\'t work in th testcase 266.\\nthis code has to be modified to:\\nint size1=map.get(c);\\nint size2=window.get(c);\\nif(size1==size2){\\n  //...\\n}\\nanyone know the reason behind this?\\n"
                    },
                    {
                        "username": "nsd99",
                        "content": "How do i know what is case 266?"
                    },
                    {
                        "username": "MrZydeco",
                        "content": "This is a poorly worded problem. When the requirement \"in complexity O(N)\" is imposed,  is N:\\n\\t(1) the length of S?\\n\\t(2) the length of T?\\n\\t(3) the sum of the lengths of S and T?\\n\\t\\nAnd is it space or time complexity?\\n\\nMy best guess is that the author meant \"letting N be the length of S, your solution must have time complexity O(N).\"\\n\\nDoes anybody care about this>\\n"
                    },
                    {
                        "username": "zongzx",
                        "content": "What does this test case mean?\\n\"a\"\\n\"aa\"\\nExpected output: \"\"\\n\\nThanks!"
                    },
                    {
                        "username": "Worm4047",
                        "content": "I understood how the first part of the time complexity comes from S, but how does the second part come from T too?"
                    },
                    {
                        "username": "tprakash2014",
                        "content": "Input \"a\" \"aa\"\\nOutput \"a\"\\nExpected \"\"\\n\\nI above expectation is incorrect. It must be \"a\", any thoughts?"
                    },
                    {
                        "username": "zhangwei0119",
                        "content": "My solution returns \"a\", but expected one is \"\"."
                    },
                    {
                        "username": "zhjeff",
                        "content": "Only after reading the solution, it turns out that duplicated chars in T must be considered.\\n"
                    },
                    {
                        "username": "zhangwei0119",
                        "content": "failed with input \"a\" and \"aa\". my output is \"a\" and the expected output is \"\".  Obviously, \"a\" can cover all characters in t."
                    },
                    {
                        "username": "sruzic",
                        "content": "I assume it is length of string S, but it is not hard to explicitly write it."
                    },
                    {
                        "username": "mlgb",
                        "content": "> If there is no such window in S that covers all characters in T, return the **emtpy** string \"\". \\n\\nShouldn't it be empty?:)"
                    }
                ]
            },
            {
                "id": 1571175,
                "content": [
                    {
                        "username": "caodanbobo",
                        "content": "Questions about testcase No.266.\\nI am using two maps to store the count of each charatcers in String s and t, and when one of the charaters\\' count match i will do something. the code is like this:\\n if(map.get(c)==window.get(c)){\\n  //...\\n}\\nhowever it doesn\\'t work in th testcase 266.\\nthis code has to be modified to:\\nint size1=map.get(c);\\nint size2=window.get(c);\\nif(size1==size2){\\n  //...\\n}\\nanyone know the reason behind this?\\n"
                    },
                    {
                        "username": "nsd99",
                        "content": "How do i know what is case 266?"
                    },
                    {
                        "username": "MrZydeco",
                        "content": "This is a poorly worded problem. When the requirement \"in complexity O(N)\" is imposed,  is N:\\n\\t(1) the length of S?\\n\\t(2) the length of T?\\n\\t(3) the sum of the lengths of S and T?\\n\\t\\nAnd is it space or time complexity?\\n\\nMy best guess is that the author meant \"letting N be the length of S, your solution must have time complexity O(N).\"\\n\\nDoes anybody care about this>\\n"
                    },
                    {
                        "username": "zongzx",
                        "content": "What does this test case mean?\\n\"a\"\\n\"aa\"\\nExpected output: \"\"\\n\\nThanks!"
                    },
                    {
                        "username": "Worm4047",
                        "content": "I understood how the first part of the time complexity comes from S, but how does the second part come from T too?"
                    },
                    {
                        "username": "tprakash2014",
                        "content": "Input \"a\" \"aa\"\\nOutput \"a\"\\nExpected \"\"\\n\\nI above expectation is incorrect. It must be \"a\", any thoughts?"
                    },
                    {
                        "username": "zhangwei0119",
                        "content": "My solution returns \"a\", but expected one is \"\"."
                    },
                    {
                        "username": "zhjeff",
                        "content": "Only after reading the solution, it turns out that duplicated chars in T must be considered.\\n"
                    },
                    {
                        "username": "zhangwei0119",
                        "content": "failed with input \"a\" and \"aa\". my output is \"a\" and the expected output is \"\".  Obviously, \"a\" can cover all characters in t."
                    },
                    {
                        "username": "sruzic",
                        "content": "I assume it is length of string S, but it is not hard to explicitly write it."
                    },
                    {
                        "username": "mlgb",
                        "content": "> If there is no such window in S that covers all characters in T, return the **emtpy** string \"\". \\n\\nShouldn't it be empty?:)"
                    }
                ]
            },
            {
                "id": 2062351,
                "content": [
                    {
                        "username": "sanjusabu066",
                        "content": "TEST CASE #265 TLE\\nDO NOT UPDATE THE STRING EVERYTIME, YOUR CONDITION IS TRUE.\\nInstead maintain two pointers minstart and minend and return s.substring(minstart, minend+1);"
                    },
                    {
                        "username": "202211079",
                        "content": "How come \\'BANC\\' is there in output but N is even not part of t!!!!!\\n "
                    },
                    {
                        "username": "ranaujjawal692",
                        "content": "very excited solved it by myself without any help \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "rs02",
                        "content": "Guys after reading the description, I think we might have to find the minimum window substring of s or whatever that means."
                    },
                    {
                        "username": "pramodmallik",
                        "content": "class Solution {\\npublic:\\nstring fans;\\n    bool possible(map<char,int> &m,map<char,int> &chk){\\n        for(auto it:m){\\n            if(chk[it.first]<it.second)\\n            return false;\\n        }\\n        return true;\\n    }\\n    string minWindow(string s, string t) {\\n        map<char,int>m;\\n        for(auto it:t){\\n            m[it]++;\\n        }\\n        int i=0,j=0;\\n        int ans=100001;\\n        vector<int>v(2,-1);\\n        map<char,int>chk;\\n        string res;\\n        int start=0;\\n        while(j<s.size()){\\n            chk[s[j]]++;\\n            while(possible(m,chk)){\\n                if(ans>(j-i+1)){\\n                    ans=j-i+1;\\n                    res=s.substr(i,ans); //DOUBT\\n                }\\n                chk[s[i]]--;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return res;\\n        \\n    }\\n};\\n\\ncan anyone explain why substr function (mentioned as DOUBT) gives MLE in the above code.????"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "can someone please help me with the below code, it works perfectly in dry run but isn\\'t giving correct answer!\\n```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        unordered_map<char , int> mp;\\n        for (char c : t) {\\n            mp[c]++;\\n        }\\n\\n        int count = t.size();\\n        int start = 0;\\n        int end = 0;\\n        int d = INT_MAX;\\n\\n        while(end < s.size()){\\n            if(mp.find(s[end]) != mp.end()){\\n                mp[s[end]]--;\\n                if(mp[s[end]] == 0){\\n                    count--;\\n                }\\n                while(mp[s[end]] < 0 ){\\n                    if(mp.find(s[start]) != mp.end()) mp[s[start]]++;\\n                    if(mp[s[start]] > 0) count++;\\n                    start++;\\n                }\\n\\n                if(count == 0){\\n                    \\n                    while(mp.find(s[start]) == mp.end()){\\n                        start++;\\n                    }\\n\\n                    d = min(d, end - start + 1);\\n                }\\n            }\\n\\n            \\n            end++;\\n        }\\n        \\n        \\n\\n\\n        return d == INT_MAX ? \"\" : s.substr(start, d);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mdglankush565",
                        "content": "Its giving me memory limit exceeded can anyone help to how to correct it.\\n` string minWindow(string s, string t) {\\n        int n=s.length(),m=t.length();\\n        if(n<m)\\n            return \"\";\\n        int match=0,desire=m;\\n        unordered_map<char,long> freq,mp;\\n        for(auto i:t)   freq[i]++;\\n        string res=s;\\n        int i=0,j=0;\\n        bool flag=0;\\n        while(true){\\n            bool f1=0,f2=0;\\n            while(i<n && match<desire){\\n                if(freq[s[i]]>mp[s[i]])\\n                    match++;\\n                if(freq[s[i]])\\n                    mp[s[i]]++;\\n                i++;\\n                f1=1;\\n            }\\n            if(match==desire && (res.length()>i-j || res.length()==i-j && s.find(res[0])>=j )){\\n                res=s.substr(j,i-j);\\n                flag=1;\\n            }\\n            while(j<i && match==desire){\\n                if(freq[s[j]]==mp[s[j]] && freq[s[j]]!=0)\\n                    match--;\\n                if(freq[s[j]])\\n                    mp[s[j]]--;\\n                j++;\\n                if(match==desire && (res.length()>i-j || res.length()==i-j && s.find(res[0])>=j )){\\n                    res=s.substr(j,i-j);\\n                    flag=1;\\n                }\\n                f2=1;\\n            }\\n            if(!f1 && !f2)\\n                break;\\n        }\\n        if(flag)\\n            return res;\\n        return \"\";\\n    }`"
                    },
                    {
                        "username": "fOOl_404",
                        "content": "Don\\'t make a string and don\\'t keep adding further characters to it, it will probably give TLE. Just keep track of the starting index of minimum window of a string."
                    },
                    {
                        "username": "hugjobk",
                        "content": "Tips for O(n) solution:\\n- You need to maintain 2 pointers for `begin` and `end` of the `substring`\\n(1) Move the `end` pointer forward and increase the `counter` by one every time you find a character in `t` (do not increase the `counter` if you have enough number of that character)\\n(2) Stop moving the `end` pointer when `c == len(t)`; now the `substring` contains enough number of character in `t`\\n(3) Move the `begin` pointer forward until you find a character that if you remove it from the `substring`, that substring won\\'t be valid anymore\\n(4) Now you find a possible minWindow, compare it with the global minWindow and continue the process from step (1)"
                    },
                    {
                        "username": "tj3n123",
                        "content": "The steps 3 is surprisingly hard, kinda struggle here, have to remove each word while still need to count the min and matched word + it\\'s count"
                    },
                    {
                        "username": "idonnoit",
                        "content": "I noticed that in the Python editor here if you try to access a non-existent key it returns 0:\\nmy_dict[\"foo\"] -> 0\\nBut according to Python doc when a key is not in the dict, it will raise a KeyError.\\n\\nDoes LC use a customized Python version that modified the default dict behavior? This change indeed makes the code cleaner.\\n"
                    }
                ]
            },
            {
                "id": 2045176,
                "content": [
                    {
                        "username": "sanjusabu066",
                        "content": "TEST CASE #265 TLE\\nDO NOT UPDATE THE STRING EVERYTIME, YOUR CONDITION IS TRUE.\\nInstead maintain two pointers minstart and minend and return s.substring(minstart, minend+1);"
                    },
                    {
                        "username": "202211079",
                        "content": "How come \\'BANC\\' is there in output but N is even not part of t!!!!!\\n "
                    },
                    {
                        "username": "ranaujjawal692",
                        "content": "very excited solved it by myself without any help \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "rs02",
                        "content": "Guys after reading the description, I think we might have to find the minimum window substring of s or whatever that means."
                    },
                    {
                        "username": "pramodmallik",
                        "content": "class Solution {\\npublic:\\nstring fans;\\n    bool possible(map<char,int> &m,map<char,int> &chk){\\n        for(auto it:m){\\n            if(chk[it.first]<it.second)\\n            return false;\\n        }\\n        return true;\\n    }\\n    string minWindow(string s, string t) {\\n        map<char,int>m;\\n        for(auto it:t){\\n            m[it]++;\\n        }\\n        int i=0,j=0;\\n        int ans=100001;\\n        vector<int>v(2,-1);\\n        map<char,int>chk;\\n        string res;\\n        int start=0;\\n        while(j<s.size()){\\n            chk[s[j]]++;\\n            while(possible(m,chk)){\\n                if(ans>(j-i+1)){\\n                    ans=j-i+1;\\n                    res=s.substr(i,ans); //DOUBT\\n                }\\n                chk[s[i]]--;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return res;\\n        \\n    }\\n};\\n\\ncan anyone explain why substr function (mentioned as DOUBT) gives MLE in the above code.????"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "can someone please help me with the below code, it works perfectly in dry run but isn\\'t giving correct answer!\\n```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        unordered_map<char , int> mp;\\n        for (char c : t) {\\n            mp[c]++;\\n        }\\n\\n        int count = t.size();\\n        int start = 0;\\n        int end = 0;\\n        int d = INT_MAX;\\n\\n        while(end < s.size()){\\n            if(mp.find(s[end]) != mp.end()){\\n                mp[s[end]]--;\\n                if(mp[s[end]] == 0){\\n                    count--;\\n                }\\n                while(mp[s[end]] < 0 ){\\n                    if(mp.find(s[start]) != mp.end()) mp[s[start]]++;\\n                    if(mp[s[start]] > 0) count++;\\n                    start++;\\n                }\\n\\n                if(count == 0){\\n                    \\n                    while(mp.find(s[start]) == mp.end()){\\n                        start++;\\n                    }\\n\\n                    d = min(d, end - start + 1);\\n                }\\n            }\\n\\n            \\n            end++;\\n        }\\n        \\n        \\n\\n\\n        return d == INT_MAX ? \"\" : s.substr(start, d);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mdglankush565",
                        "content": "Its giving me memory limit exceeded can anyone help to how to correct it.\\n` string minWindow(string s, string t) {\\n        int n=s.length(),m=t.length();\\n        if(n<m)\\n            return \"\";\\n        int match=0,desire=m;\\n        unordered_map<char,long> freq,mp;\\n        for(auto i:t)   freq[i]++;\\n        string res=s;\\n        int i=0,j=0;\\n        bool flag=0;\\n        while(true){\\n            bool f1=0,f2=0;\\n            while(i<n && match<desire){\\n                if(freq[s[i]]>mp[s[i]])\\n                    match++;\\n                if(freq[s[i]])\\n                    mp[s[i]]++;\\n                i++;\\n                f1=1;\\n            }\\n            if(match==desire && (res.length()>i-j || res.length()==i-j && s.find(res[0])>=j )){\\n                res=s.substr(j,i-j);\\n                flag=1;\\n            }\\n            while(j<i && match==desire){\\n                if(freq[s[j]]==mp[s[j]] && freq[s[j]]!=0)\\n                    match--;\\n                if(freq[s[j]])\\n                    mp[s[j]]--;\\n                j++;\\n                if(match==desire && (res.length()>i-j || res.length()==i-j && s.find(res[0])>=j )){\\n                    res=s.substr(j,i-j);\\n                    flag=1;\\n                }\\n                f2=1;\\n            }\\n            if(!f1 && !f2)\\n                break;\\n        }\\n        if(flag)\\n            return res;\\n        return \"\";\\n    }`"
                    },
                    {
                        "username": "fOOl_404",
                        "content": "Don\\'t make a string and don\\'t keep adding further characters to it, it will probably give TLE. Just keep track of the starting index of minimum window of a string."
                    },
                    {
                        "username": "hugjobk",
                        "content": "Tips for O(n) solution:\\n- You need to maintain 2 pointers for `begin` and `end` of the `substring`\\n(1) Move the `end` pointer forward and increase the `counter` by one every time you find a character in `t` (do not increase the `counter` if you have enough number of that character)\\n(2) Stop moving the `end` pointer when `c == len(t)`; now the `substring` contains enough number of character in `t`\\n(3) Move the `begin` pointer forward until you find a character that if you remove it from the `substring`, that substring won\\'t be valid anymore\\n(4) Now you find a possible minWindow, compare it with the global minWindow and continue the process from step (1)"
                    },
                    {
                        "username": "tj3n123",
                        "content": "The steps 3 is surprisingly hard, kinda struggle here, have to remove each word while still need to count the min and matched word + it\\'s count"
                    },
                    {
                        "username": "idonnoit",
                        "content": "I noticed that in the Python editor here if you try to access a non-existent key it returns 0:\\nmy_dict[\"foo\"] -> 0\\nBut according to Python doc when a key is not in the dict, it will raise a KeyError.\\n\\nDoes LC use a customized Python version that modified the default dict behavior? This change indeed makes the code cleaner.\\n"
                    }
                ]
            },
            {
                "id": 2039440,
                "content": [
                    {
                        "username": "sanjusabu066",
                        "content": "TEST CASE #265 TLE\\nDO NOT UPDATE THE STRING EVERYTIME, YOUR CONDITION IS TRUE.\\nInstead maintain two pointers minstart and minend and return s.substring(minstart, minend+1);"
                    },
                    {
                        "username": "202211079",
                        "content": "How come \\'BANC\\' is there in output but N is even not part of t!!!!!\\n "
                    },
                    {
                        "username": "ranaujjawal692",
                        "content": "very excited solved it by myself without any help \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "rs02",
                        "content": "Guys after reading the description, I think we might have to find the minimum window substring of s or whatever that means."
                    },
                    {
                        "username": "pramodmallik",
                        "content": "class Solution {\\npublic:\\nstring fans;\\n    bool possible(map<char,int> &m,map<char,int> &chk){\\n        for(auto it:m){\\n            if(chk[it.first]<it.second)\\n            return false;\\n        }\\n        return true;\\n    }\\n    string minWindow(string s, string t) {\\n        map<char,int>m;\\n        for(auto it:t){\\n            m[it]++;\\n        }\\n        int i=0,j=0;\\n        int ans=100001;\\n        vector<int>v(2,-1);\\n        map<char,int>chk;\\n        string res;\\n        int start=0;\\n        while(j<s.size()){\\n            chk[s[j]]++;\\n            while(possible(m,chk)){\\n                if(ans>(j-i+1)){\\n                    ans=j-i+1;\\n                    res=s.substr(i,ans); //DOUBT\\n                }\\n                chk[s[i]]--;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return res;\\n        \\n    }\\n};\\n\\ncan anyone explain why substr function (mentioned as DOUBT) gives MLE in the above code.????"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "can someone please help me with the below code, it works perfectly in dry run but isn\\'t giving correct answer!\\n```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        unordered_map<char , int> mp;\\n        for (char c : t) {\\n            mp[c]++;\\n        }\\n\\n        int count = t.size();\\n        int start = 0;\\n        int end = 0;\\n        int d = INT_MAX;\\n\\n        while(end < s.size()){\\n            if(mp.find(s[end]) != mp.end()){\\n                mp[s[end]]--;\\n                if(mp[s[end]] == 0){\\n                    count--;\\n                }\\n                while(mp[s[end]] < 0 ){\\n                    if(mp.find(s[start]) != mp.end()) mp[s[start]]++;\\n                    if(mp[s[start]] > 0) count++;\\n                    start++;\\n                }\\n\\n                if(count == 0){\\n                    \\n                    while(mp.find(s[start]) == mp.end()){\\n                        start++;\\n                    }\\n\\n                    d = min(d, end - start + 1);\\n                }\\n            }\\n\\n            \\n            end++;\\n        }\\n        \\n        \\n\\n\\n        return d == INT_MAX ? \"\" : s.substr(start, d);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mdglankush565",
                        "content": "Its giving me memory limit exceeded can anyone help to how to correct it.\\n` string minWindow(string s, string t) {\\n        int n=s.length(),m=t.length();\\n        if(n<m)\\n            return \"\";\\n        int match=0,desire=m;\\n        unordered_map<char,long> freq,mp;\\n        for(auto i:t)   freq[i]++;\\n        string res=s;\\n        int i=0,j=0;\\n        bool flag=0;\\n        while(true){\\n            bool f1=0,f2=0;\\n            while(i<n && match<desire){\\n                if(freq[s[i]]>mp[s[i]])\\n                    match++;\\n                if(freq[s[i]])\\n                    mp[s[i]]++;\\n                i++;\\n                f1=1;\\n            }\\n            if(match==desire && (res.length()>i-j || res.length()==i-j && s.find(res[0])>=j )){\\n                res=s.substr(j,i-j);\\n                flag=1;\\n            }\\n            while(j<i && match==desire){\\n                if(freq[s[j]]==mp[s[j]] && freq[s[j]]!=0)\\n                    match--;\\n                if(freq[s[j]])\\n                    mp[s[j]]--;\\n                j++;\\n                if(match==desire && (res.length()>i-j || res.length()==i-j && s.find(res[0])>=j )){\\n                    res=s.substr(j,i-j);\\n                    flag=1;\\n                }\\n                f2=1;\\n            }\\n            if(!f1 && !f2)\\n                break;\\n        }\\n        if(flag)\\n            return res;\\n        return \"\";\\n    }`"
                    },
                    {
                        "username": "fOOl_404",
                        "content": "Don\\'t make a string and don\\'t keep adding further characters to it, it will probably give TLE. Just keep track of the starting index of minimum window of a string."
                    },
                    {
                        "username": "hugjobk",
                        "content": "Tips for O(n) solution:\\n- You need to maintain 2 pointers for `begin` and `end` of the `substring`\\n(1) Move the `end` pointer forward and increase the `counter` by one every time you find a character in `t` (do not increase the `counter` if you have enough number of that character)\\n(2) Stop moving the `end` pointer when `c == len(t)`; now the `substring` contains enough number of character in `t`\\n(3) Move the `begin` pointer forward until you find a character that if you remove it from the `substring`, that substring won\\'t be valid anymore\\n(4) Now you find a possible minWindow, compare it with the global minWindow and continue the process from step (1)"
                    },
                    {
                        "username": "tj3n123",
                        "content": "The steps 3 is surprisingly hard, kinda struggle here, have to remove each word while still need to count the min and matched word + it\\'s count"
                    },
                    {
                        "username": "idonnoit",
                        "content": "I noticed that in the Python editor here if you try to access a non-existent key it returns 0:\\nmy_dict[\"foo\"] -> 0\\nBut according to Python doc when a key is not in the dict, it will raise a KeyError.\\n\\nDoes LC use a customized Python version that modified the default dict behavior? This change indeed makes the code cleaner.\\n"
                    }
                ]
            },
            {
                "id": 2029483,
                "content": [
                    {
                        "username": "sanjusabu066",
                        "content": "TEST CASE #265 TLE\\nDO NOT UPDATE THE STRING EVERYTIME, YOUR CONDITION IS TRUE.\\nInstead maintain two pointers minstart and minend and return s.substring(minstart, minend+1);"
                    },
                    {
                        "username": "202211079",
                        "content": "How come \\'BANC\\' is there in output but N is even not part of t!!!!!\\n "
                    },
                    {
                        "username": "ranaujjawal692",
                        "content": "very excited solved it by myself without any help \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "rs02",
                        "content": "Guys after reading the description, I think we might have to find the minimum window substring of s or whatever that means."
                    },
                    {
                        "username": "pramodmallik",
                        "content": "class Solution {\\npublic:\\nstring fans;\\n    bool possible(map<char,int> &m,map<char,int> &chk){\\n        for(auto it:m){\\n            if(chk[it.first]<it.second)\\n            return false;\\n        }\\n        return true;\\n    }\\n    string minWindow(string s, string t) {\\n        map<char,int>m;\\n        for(auto it:t){\\n            m[it]++;\\n        }\\n        int i=0,j=0;\\n        int ans=100001;\\n        vector<int>v(2,-1);\\n        map<char,int>chk;\\n        string res;\\n        int start=0;\\n        while(j<s.size()){\\n            chk[s[j]]++;\\n            while(possible(m,chk)){\\n                if(ans>(j-i+1)){\\n                    ans=j-i+1;\\n                    res=s.substr(i,ans); //DOUBT\\n                }\\n                chk[s[i]]--;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return res;\\n        \\n    }\\n};\\n\\ncan anyone explain why substr function (mentioned as DOUBT) gives MLE in the above code.????"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "can someone please help me with the below code, it works perfectly in dry run but isn\\'t giving correct answer!\\n```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        unordered_map<char , int> mp;\\n        for (char c : t) {\\n            mp[c]++;\\n        }\\n\\n        int count = t.size();\\n        int start = 0;\\n        int end = 0;\\n        int d = INT_MAX;\\n\\n        while(end < s.size()){\\n            if(mp.find(s[end]) != mp.end()){\\n                mp[s[end]]--;\\n                if(mp[s[end]] == 0){\\n                    count--;\\n                }\\n                while(mp[s[end]] < 0 ){\\n                    if(mp.find(s[start]) != mp.end()) mp[s[start]]++;\\n                    if(mp[s[start]] > 0) count++;\\n                    start++;\\n                }\\n\\n                if(count == 0){\\n                    \\n                    while(mp.find(s[start]) == mp.end()){\\n                        start++;\\n                    }\\n\\n                    d = min(d, end - start + 1);\\n                }\\n            }\\n\\n            \\n            end++;\\n        }\\n        \\n        \\n\\n\\n        return d == INT_MAX ? \"\" : s.substr(start, d);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mdglankush565",
                        "content": "Its giving me memory limit exceeded can anyone help to how to correct it.\\n` string minWindow(string s, string t) {\\n        int n=s.length(),m=t.length();\\n        if(n<m)\\n            return \"\";\\n        int match=0,desire=m;\\n        unordered_map<char,long> freq,mp;\\n        for(auto i:t)   freq[i]++;\\n        string res=s;\\n        int i=0,j=0;\\n        bool flag=0;\\n        while(true){\\n            bool f1=0,f2=0;\\n            while(i<n && match<desire){\\n                if(freq[s[i]]>mp[s[i]])\\n                    match++;\\n                if(freq[s[i]])\\n                    mp[s[i]]++;\\n                i++;\\n                f1=1;\\n            }\\n            if(match==desire && (res.length()>i-j || res.length()==i-j && s.find(res[0])>=j )){\\n                res=s.substr(j,i-j);\\n                flag=1;\\n            }\\n            while(j<i && match==desire){\\n                if(freq[s[j]]==mp[s[j]] && freq[s[j]]!=0)\\n                    match--;\\n                if(freq[s[j]])\\n                    mp[s[j]]--;\\n                j++;\\n                if(match==desire && (res.length()>i-j || res.length()==i-j && s.find(res[0])>=j )){\\n                    res=s.substr(j,i-j);\\n                    flag=1;\\n                }\\n                f2=1;\\n            }\\n            if(!f1 && !f2)\\n                break;\\n        }\\n        if(flag)\\n            return res;\\n        return \"\";\\n    }`"
                    },
                    {
                        "username": "fOOl_404",
                        "content": "Don\\'t make a string and don\\'t keep adding further characters to it, it will probably give TLE. Just keep track of the starting index of minimum window of a string."
                    },
                    {
                        "username": "hugjobk",
                        "content": "Tips for O(n) solution:\\n- You need to maintain 2 pointers for `begin` and `end` of the `substring`\\n(1) Move the `end` pointer forward and increase the `counter` by one every time you find a character in `t` (do not increase the `counter` if you have enough number of that character)\\n(2) Stop moving the `end` pointer when `c == len(t)`; now the `substring` contains enough number of character in `t`\\n(3) Move the `begin` pointer forward until you find a character that if you remove it from the `substring`, that substring won\\'t be valid anymore\\n(4) Now you find a possible minWindow, compare it with the global minWindow and continue the process from step (1)"
                    },
                    {
                        "username": "tj3n123",
                        "content": "The steps 3 is surprisingly hard, kinda struggle here, have to remove each word while still need to count the min and matched word + it\\'s count"
                    },
                    {
                        "username": "idonnoit",
                        "content": "I noticed that in the Python editor here if you try to access a non-existent key it returns 0:\\nmy_dict[\"foo\"] -> 0\\nBut according to Python doc when a key is not in the dict, it will raise a KeyError.\\n\\nDoes LC use a customized Python version that modified the default dict behavior? This change indeed makes the code cleaner.\\n"
                    }
                ]
            },
            {
                "id": 2028723,
                "content": [
                    {
                        "username": "sanjusabu066",
                        "content": "TEST CASE #265 TLE\\nDO NOT UPDATE THE STRING EVERYTIME, YOUR CONDITION IS TRUE.\\nInstead maintain two pointers minstart and minend and return s.substring(minstart, minend+1);"
                    },
                    {
                        "username": "202211079",
                        "content": "How come \\'BANC\\' is there in output but N is even not part of t!!!!!\\n "
                    },
                    {
                        "username": "ranaujjawal692",
                        "content": "very excited solved it by myself without any help \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "rs02",
                        "content": "Guys after reading the description, I think we might have to find the minimum window substring of s or whatever that means."
                    },
                    {
                        "username": "pramodmallik",
                        "content": "class Solution {\\npublic:\\nstring fans;\\n    bool possible(map<char,int> &m,map<char,int> &chk){\\n        for(auto it:m){\\n            if(chk[it.first]<it.second)\\n            return false;\\n        }\\n        return true;\\n    }\\n    string minWindow(string s, string t) {\\n        map<char,int>m;\\n        for(auto it:t){\\n            m[it]++;\\n        }\\n        int i=0,j=0;\\n        int ans=100001;\\n        vector<int>v(2,-1);\\n        map<char,int>chk;\\n        string res;\\n        int start=0;\\n        while(j<s.size()){\\n            chk[s[j]]++;\\n            while(possible(m,chk)){\\n                if(ans>(j-i+1)){\\n                    ans=j-i+1;\\n                    res=s.substr(i,ans); //DOUBT\\n                }\\n                chk[s[i]]--;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return res;\\n        \\n    }\\n};\\n\\ncan anyone explain why substr function (mentioned as DOUBT) gives MLE in the above code.????"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "can someone please help me with the below code, it works perfectly in dry run but isn\\'t giving correct answer!\\n```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        unordered_map<char , int> mp;\\n        for (char c : t) {\\n            mp[c]++;\\n        }\\n\\n        int count = t.size();\\n        int start = 0;\\n        int end = 0;\\n        int d = INT_MAX;\\n\\n        while(end < s.size()){\\n            if(mp.find(s[end]) != mp.end()){\\n                mp[s[end]]--;\\n                if(mp[s[end]] == 0){\\n                    count--;\\n                }\\n                while(mp[s[end]] < 0 ){\\n                    if(mp.find(s[start]) != mp.end()) mp[s[start]]++;\\n                    if(mp[s[start]] > 0) count++;\\n                    start++;\\n                }\\n\\n                if(count == 0){\\n                    \\n                    while(mp.find(s[start]) == mp.end()){\\n                        start++;\\n                    }\\n\\n                    d = min(d, end - start + 1);\\n                }\\n            }\\n\\n            \\n            end++;\\n        }\\n        \\n        \\n\\n\\n        return d == INT_MAX ? \"\" : s.substr(start, d);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mdglankush565",
                        "content": "Its giving me memory limit exceeded can anyone help to how to correct it.\\n` string minWindow(string s, string t) {\\n        int n=s.length(),m=t.length();\\n        if(n<m)\\n            return \"\";\\n        int match=0,desire=m;\\n        unordered_map<char,long> freq,mp;\\n        for(auto i:t)   freq[i]++;\\n        string res=s;\\n        int i=0,j=0;\\n        bool flag=0;\\n        while(true){\\n            bool f1=0,f2=0;\\n            while(i<n && match<desire){\\n                if(freq[s[i]]>mp[s[i]])\\n                    match++;\\n                if(freq[s[i]])\\n                    mp[s[i]]++;\\n                i++;\\n                f1=1;\\n            }\\n            if(match==desire && (res.length()>i-j || res.length()==i-j && s.find(res[0])>=j )){\\n                res=s.substr(j,i-j);\\n                flag=1;\\n            }\\n            while(j<i && match==desire){\\n                if(freq[s[j]]==mp[s[j]] && freq[s[j]]!=0)\\n                    match--;\\n                if(freq[s[j]])\\n                    mp[s[j]]--;\\n                j++;\\n                if(match==desire && (res.length()>i-j || res.length()==i-j && s.find(res[0])>=j )){\\n                    res=s.substr(j,i-j);\\n                    flag=1;\\n                }\\n                f2=1;\\n            }\\n            if(!f1 && !f2)\\n                break;\\n        }\\n        if(flag)\\n            return res;\\n        return \"\";\\n    }`"
                    },
                    {
                        "username": "fOOl_404",
                        "content": "Don\\'t make a string and don\\'t keep adding further characters to it, it will probably give TLE. Just keep track of the starting index of minimum window of a string."
                    },
                    {
                        "username": "hugjobk",
                        "content": "Tips for O(n) solution:\\n- You need to maintain 2 pointers for `begin` and `end` of the `substring`\\n(1) Move the `end` pointer forward and increase the `counter` by one every time you find a character in `t` (do not increase the `counter` if you have enough number of that character)\\n(2) Stop moving the `end` pointer when `c == len(t)`; now the `substring` contains enough number of character in `t`\\n(3) Move the `begin` pointer forward until you find a character that if you remove it from the `substring`, that substring won\\'t be valid anymore\\n(4) Now you find a possible minWindow, compare it with the global minWindow and continue the process from step (1)"
                    },
                    {
                        "username": "tj3n123",
                        "content": "The steps 3 is surprisingly hard, kinda struggle here, have to remove each word while still need to count the min and matched word + it\\'s count"
                    },
                    {
                        "username": "idonnoit",
                        "content": "I noticed that in the Python editor here if you try to access a non-existent key it returns 0:\\nmy_dict[\"foo\"] -> 0\\nBut according to Python doc when a key is not in the dict, it will raise a KeyError.\\n\\nDoes LC use a customized Python version that modified the default dict behavior? This change indeed makes the code cleaner.\\n"
                    }
                ]
            },
            {
                "id": 2019296,
                "content": [
                    {
                        "username": "sanjusabu066",
                        "content": "TEST CASE #265 TLE\\nDO NOT UPDATE THE STRING EVERYTIME, YOUR CONDITION IS TRUE.\\nInstead maintain two pointers minstart and minend and return s.substring(minstart, minend+1);"
                    },
                    {
                        "username": "202211079",
                        "content": "How come \\'BANC\\' is there in output but N is even not part of t!!!!!\\n "
                    },
                    {
                        "username": "ranaujjawal692",
                        "content": "very excited solved it by myself without any help \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "rs02",
                        "content": "Guys after reading the description, I think we might have to find the minimum window substring of s or whatever that means."
                    },
                    {
                        "username": "pramodmallik",
                        "content": "class Solution {\\npublic:\\nstring fans;\\n    bool possible(map<char,int> &m,map<char,int> &chk){\\n        for(auto it:m){\\n            if(chk[it.first]<it.second)\\n            return false;\\n        }\\n        return true;\\n    }\\n    string minWindow(string s, string t) {\\n        map<char,int>m;\\n        for(auto it:t){\\n            m[it]++;\\n        }\\n        int i=0,j=0;\\n        int ans=100001;\\n        vector<int>v(2,-1);\\n        map<char,int>chk;\\n        string res;\\n        int start=0;\\n        while(j<s.size()){\\n            chk[s[j]]++;\\n            while(possible(m,chk)){\\n                if(ans>(j-i+1)){\\n                    ans=j-i+1;\\n                    res=s.substr(i,ans); //DOUBT\\n                }\\n                chk[s[i]]--;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return res;\\n        \\n    }\\n};\\n\\ncan anyone explain why substr function (mentioned as DOUBT) gives MLE in the above code.????"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "can someone please help me with the below code, it works perfectly in dry run but isn\\'t giving correct answer!\\n```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        unordered_map<char , int> mp;\\n        for (char c : t) {\\n            mp[c]++;\\n        }\\n\\n        int count = t.size();\\n        int start = 0;\\n        int end = 0;\\n        int d = INT_MAX;\\n\\n        while(end < s.size()){\\n            if(mp.find(s[end]) != mp.end()){\\n                mp[s[end]]--;\\n                if(mp[s[end]] == 0){\\n                    count--;\\n                }\\n                while(mp[s[end]] < 0 ){\\n                    if(mp.find(s[start]) != mp.end()) mp[s[start]]++;\\n                    if(mp[s[start]] > 0) count++;\\n                    start++;\\n                }\\n\\n                if(count == 0){\\n                    \\n                    while(mp.find(s[start]) == mp.end()){\\n                        start++;\\n                    }\\n\\n                    d = min(d, end - start + 1);\\n                }\\n            }\\n\\n            \\n            end++;\\n        }\\n        \\n        \\n\\n\\n        return d == INT_MAX ? \"\" : s.substr(start, d);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mdglankush565",
                        "content": "Its giving me memory limit exceeded can anyone help to how to correct it.\\n` string minWindow(string s, string t) {\\n        int n=s.length(),m=t.length();\\n        if(n<m)\\n            return \"\";\\n        int match=0,desire=m;\\n        unordered_map<char,long> freq,mp;\\n        for(auto i:t)   freq[i]++;\\n        string res=s;\\n        int i=0,j=0;\\n        bool flag=0;\\n        while(true){\\n            bool f1=0,f2=0;\\n            while(i<n && match<desire){\\n                if(freq[s[i]]>mp[s[i]])\\n                    match++;\\n                if(freq[s[i]])\\n                    mp[s[i]]++;\\n                i++;\\n                f1=1;\\n            }\\n            if(match==desire && (res.length()>i-j || res.length()==i-j && s.find(res[0])>=j )){\\n                res=s.substr(j,i-j);\\n                flag=1;\\n            }\\n            while(j<i && match==desire){\\n                if(freq[s[j]]==mp[s[j]] && freq[s[j]]!=0)\\n                    match--;\\n                if(freq[s[j]])\\n                    mp[s[j]]--;\\n                j++;\\n                if(match==desire && (res.length()>i-j || res.length()==i-j && s.find(res[0])>=j )){\\n                    res=s.substr(j,i-j);\\n                    flag=1;\\n                }\\n                f2=1;\\n            }\\n            if(!f1 && !f2)\\n                break;\\n        }\\n        if(flag)\\n            return res;\\n        return \"\";\\n    }`"
                    },
                    {
                        "username": "fOOl_404",
                        "content": "Don\\'t make a string and don\\'t keep adding further characters to it, it will probably give TLE. Just keep track of the starting index of minimum window of a string."
                    },
                    {
                        "username": "hugjobk",
                        "content": "Tips for O(n) solution:\\n- You need to maintain 2 pointers for `begin` and `end` of the `substring`\\n(1) Move the `end` pointer forward and increase the `counter` by one every time you find a character in `t` (do not increase the `counter` if you have enough number of that character)\\n(2) Stop moving the `end` pointer when `c == len(t)`; now the `substring` contains enough number of character in `t`\\n(3) Move the `begin` pointer forward until you find a character that if you remove it from the `substring`, that substring won\\'t be valid anymore\\n(4) Now you find a possible minWindow, compare it with the global minWindow and continue the process from step (1)"
                    },
                    {
                        "username": "tj3n123",
                        "content": "The steps 3 is surprisingly hard, kinda struggle here, have to remove each word while still need to count the min and matched word + it\\'s count"
                    },
                    {
                        "username": "idonnoit",
                        "content": "I noticed that in the Python editor here if you try to access a non-existent key it returns 0:\\nmy_dict[\"foo\"] -> 0\\nBut according to Python doc when a key is not in the dict, it will raise a KeyError.\\n\\nDoes LC use a customized Python version that modified the default dict behavior? This change indeed makes the code cleaner.\\n"
                    }
                ]
            },
            {
                "id": 1987650,
                "content": [
                    {
                        "username": "sanjusabu066",
                        "content": "TEST CASE #265 TLE\\nDO NOT UPDATE THE STRING EVERYTIME, YOUR CONDITION IS TRUE.\\nInstead maintain two pointers minstart and minend and return s.substring(minstart, minend+1);"
                    },
                    {
                        "username": "202211079",
                        "content": "How come \\'BANC\\' is there in output but N is even not part of t!!!!!\\n "
                    },
                    {
                        "username": "ranaujjawal692",
                        "content": "very excited solved it by myself without any help \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "rs02",
                        "content": "Guys after reading the description, I think we might have to find the minimum window substring of s or whatever that means."
                    },
                    {
                        "username": "pramodmallik",
                        "content": "class Solution {\\npublic:\\nstring fans;\\n    bool possible(map<char,int> &m,map<char,int> &chk){\\n        for(auto it:m){\\n            if(chk[it.first]<it.second)\\n            return false;\\n        }\\n        return true;\\n    }\\n    string minWindow(string s, string t) {\\n        map<char,int>m;\\n        for(auto it:t){\\n            m[it]++;\\n        }\\n        int i=0,j=0;\\n        int ans=100001;\\n        vector<int>v(2,-1);\\n        map<char,int>chk;\\n        string res;\\n        int start=0;\\n        while(j<s.size()){\\n            chk[s[j]]++;\\n            while(possible(m,chk)){\\n                if(ans>(j-i+1)){\\n                    ans=j-i+1;\\n                    res=s.substr(i,ans); //DOUBT\\n                }\\n                chk[s[i]]--;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return res;\\n        \\n    }\\n};\\n\\ncan anyone explain why substr function (mentioned as DOUBT) gives MLE in the above code.????"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "can someone please help me with the below code, it works perfectly in dry run but isn\\'t giving correct answer!\\n```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        unordered_map<char , int> mp;\\n        for (char c : t) {\\n            mp[c]++;\\n        }\\n\\n        int count = t.size();\\n        int start = 0;\\n        int end = 0;\\n        int d = INT_MAX;\\n\\n        while(end < s.size()){\\n            if(mp.find(s[end]) != mp.end()){\\n                mp[s[end]]--;\\n                if(mp[s[end]] == 0){\\n                    count--;\\n                }\\n                while(mp[s[end]] < 0 ){\\n                    if(mp.find(s[start]) != mp.end()) mp[s[start]]++;\\n                    if(mp[s[start]] > 0) count++;\\n                    start++;\\n                }\\n\\n                if(count == 0){\\n                    \\n                    while(mp.find(s[start]) == mp.end()){\\n                        start++;\\n                    }\\n\\n                    d = min(d, end - start + 1);\\n                }\\n            }\\n\\n            \\n            end++;\\n        }\\n        \\n        \\n\\n\\n        return d == INT_MAX ? \"\" : s.substr(start, d);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mdglankush565",
                        "content": "Its giving me memory limit exceeded can anyone help to how to correct it.\\n` string minWindow(string s, string t) {\\n        int n=s.length(),m=t.length();\\n        if(n<m)\\n            return \"\";\\n        int match=0,desire=m;\\n        unordered_map<char,long> freq,mp;\\n        for(auto i:t)   freq[i]++;\\n        string res=s;\\n        int i=0,j=0;\\n        bool flag=0;\\n        while(true){\\n            bool f1=0,f2=0;\\n            while(i<n && match<desire){\\n                if(freq[s[i]]>mp[s[i]])\\n                    match++;\\n                if(freq[s[i]])\\n                    mp[s[i]]++;\\n                i++;\\n                f1=1;\\n            }\\n            if(match==desire && (res.length()>i-j || res.length()==i-j && s.find(res[0])>=j )){\\n                res=s.substr(j,i-j);\\n                flag=1;\\n            }\\n            while(j<i && match==desire){\\n                if(freq[s[j]]==mp[s[j]] && freq[s[j]]!=0)\\n                    match--;\\n                if(freq[s[j]])\\n                    mp[s[j]]--;\\n                j++;\\n                if(match==desire && (res.length()>i-j || res.length()==i-j && s.find(res[0])>=j )){\\n                    res=s.substr(j,i-j);\\n                    flag=1;\\n                }\\n                f2=1;\\n            }\\n            if(!f1 && !f2)\\n                break;\\n        }\\n        if(flag)\\n            return res;\\n        return \"\";\\n    }`"
                    },
                    {
                        "username": "fOOl_404",
                        "content": "Don\\'t make a string and don\\'t keep adding further characters to it, it will probably give TLE. Just keep track of the starting index of minimum window of a string."
                    },
                    {
                        "username": "hugjobk",
                        "content": "Tips for O(n) solution:\\n- You need to maintain 2 pointers for `begin` and `end` of the `substring`\\n(1) Move the `end` pointer forward and increase the `counter` by one every time you find a character in `t` (do not increase the `counter` if you have enough number of that character)\\n(2) Stop moving the `end` pointer when `c == len(t)`; now the `substring` contains enough number of character in `t`\\n(3) Move the `begin` pointer forward until you find a character that if you remove it from the `substring`, that substring won\\'t be valid anymore\\n(4) Now you find a possible minWindow, compare it with the global minWindow and continue the process from step (1)"
                    },
                    {
                        "username": "tj3n123",
                        "content": "The steps 3 is surprisingly hard, kinda struggle here, have to remove each word while still need to count the min and matched word + it\\'s count"
                    },
                    {
                        "username": "idonnoit",
                        "content": "I noticed that in the Python editor here if you try to access a non-existent key it returns 0:\\nmy_dict[\"foo\"] -> 0\\nBut according to Python doc when a key is not in the dict, it will raise a KeyError.\\n\\nDoes LC use a customized Python version that modified the default dict behavior? This change indeed makes the code cleaner.\\n"
                    }
                ]
            },
            {
                "id": 1979152,
                "content": [
                    {
                        "username": "sanjusabu066",
                        "content": "TEST CASE #265 TLE\\nDO NOT UPDATE THE STRING EVERYTIME, YOUR CONDITION IS TRUE.\\nInstead maintain two pointers minstart and minend and return s.substring(minstart, minend+1);"
                    },
                    {
                        "username": "202211079",
                        "content": "How come \\'BANC\\' is there in output but N is even not part of t!!!!!\\n "
                    },
                    {
                        "username": "ranaujjawal692",
                        "content": "very excited solved it by myself without any help \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "rs02",
                        "content": "Guys after reading the description, I think we might have to find the minimum window substring of s or whatever that means."
                    },
                    {
                        "username": "pramodmallik",
                        "content": "class Solution {\\npublic:\\nstring fans;\\n    bool possible(map<char,int> &m,map<char,int> &chk){\\n        for(auto it:m){\\n            if(chk[it.first]<it.second)\\n            return false;\\n        }\\n        return true;\\n    }\\n    string minWindow(string s, string t) {\\n        map<char,int>m;\\n        for(auto it:t){\\n            m[it]++;\\n        }\\n        int i=0,j=0;\\n        int ans=100001;\\n        vector<int>v(2,-1);\\n        map<char,int>chk;\\n        string res;\\n        int start=0;\\n        while(j<s.size()){\\n            chk[s[j]]++;\\n            while(possible(m,chk)){\\n                if(ans>(j-i+1)){\\n                    ans=j-i+1;\\n                    res=s.substr(i,ans); //DOUBT\\n                }\\n                chk[s[i]]--;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return res;\\n        \\n    }\\n};\\n\\ncan anyone explain why substr function (mentioned as DOUBT) gives MLE in the above code.????"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "can someone please help me with the below code, it works perfectly in dry run but isn\\'t giving correct answer!\\n```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        unordered_map<char , int> mp;\\n        for (char c : t) {\\n            mp[c]++;\\n        }\\n\\n        int count = t.size();\\n        int start = 0;\\n        int end = 0;\\n        int d = INT_MAX;\\n\\n        while(end < s.size()){\\n            if(mp.find(s[end]) != mp.end()){\\n                mp[s[end]]--;\\n                if(mp[s[end]] == 0){\\n                    count--;\\n                }\\n                while(mp[s[end]] < 0 ){\\n                    if(mp.find(s[start]) != mp.end()) mp[s[start]]++;\\n                    if(mp[s[start]] > 0) count++;\\n                    start++;\\n                }\\n\\n                if(count == 0){\\n                    \\n                    while(mp.find(s[start]) == mp.end()){\\n                        start++;\\n                    }\\n\\n                    d = min(d, end - start + 1);\\n                }\\n            }\\n\\n            \\n            end++;\\n        }\\n        \\n        \\n\\n\\n        return d == INT_MAX ? \"\" : s.substr(start, d);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mdglankush565",
                        "content": "Its giving me memory limit exceeded can anyone help to how to correct it.\\n` string minWindow(string s, string t) {\\n        int n=s.length(),m=t.length();\\n        if(n<m)\\n            return \"\";\\n        int match=0,desire=m;\\n        unordered_map<char,long> freq,mp;\\n        for(auto i:t)   freq[i]++;\\n        string res=s;\\n        int i=0,j=0;\\n        bool flag=0;\\n        while(true){\\n            bool f1=0,f2=0;\\n            while(i<n && match<desire){\\n                if(freq[s[i]]>mp[s[i]])\\n                    match++;\\n                if(freq[s[i]])\\n                    mp[s[i]]++;\\n                i++;\\n                f1=1;\\n            }\\n            if(match==desire && (res.length()>i-j || res.length()==i-j && s.find(res[0])>=j )){\\n                res=s.substr(j,i-j);\\n                flag=1;\\n            }\\n            while(j<i && match==desire){\\n                if(freq[s[j]]==mp[s[j]] && freq[s[j]]!=0)\\n                    match--;\\n                if(freq[s[j]])\\n                    mp[s[j]]--;\\n                j++;\\n                if(match==desire && (res.length()>i-j || res.length()==i-j && s.find(res[0])>=j )){\\n                    res=s.substr(j,i-j);\\n                    flag=1;\\n                }\\n                f2=1;\\n            }\\n            if(!f1 && !f2)\\n                break;\\n        }\\n        if(flag)\\n            return res;\\n        return \"\";\\n    }`"
                    },
                    {
                        "username": "fOOl_404",
                        "content": "Don\\'t make a string and don\\'t keep adding further characters to it, it will probably give TLE. Just keep track of the starting index of minimum window of a string."
                    },
                    {
                        "username": "hugjobk",
                        "content": "Tips for O(n) solution:\\n- You need to maintain 2 pointers for `begin` and `end` of the `substring`\\n(1) Move the `end` pointer forward and increase the `counter` by one every time you find a character in `t` (do not increase the `counter` if you have enough number of that character)\\n(2) Stop moving the `end` pointer when `c == len(t)`; now the `substring` contains enough number of character in `t`\\n(3) Move the `begin` pointer forward until you find a character that if you remove it from the `substring`, that substring won\\'t be valid anymore\\n(4) Now you find a possible minWindow, compare it with the global minWindow and continue the process from step (1)"
                    },
                    {
                        "username": "tj3n123",
                        "content": "The steps 3 is surprisingly hard, kinda struggle here, have to remove each word while still need to count the min and matched word + it\\'s count"
                    },
                    {
                        "username": "idonnoit",
                        "content": "I noticed that in the Python editor here if you try to access a non-existent key it returns 0:\\nmy_dict[\"foo\"] -> 0\\nBut according to Python doc when a key is not in the dict, it will raise a KeyError.\\n\\nDoes LC use a customized Python version that modified the default dict behavior? This change indeed makes the code cleaner.\\n"
                    }
                ]
            },
            {
                "id": 1967190,
                "content": [
                    {
                        "username": "sanjusabu066",
                        "content": "TEST CASE #265 TLE\\nDO NOT UPDATE THE STRING EVERYTIME, YOUR CONDITION IS TRUE.\\nInstead maintain two pointers minstart and minend and return s.substring(minstart, minend+1);"
                    },
                    {
                        "username": "202211079",
                        "content": "How come \\'BANC\\' is there in output but N is even not part of t!!!!!\\n "
                    },
                    {
                        "username": "ranaujjawal692",
                        "content": "very excited solved it by myself without any help \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "rs02",
                        "content": "Guys after reading the description, I think we might have to find the minimum window substring of s or whatever that means."
                    },
                    {
                        "username": "pramodmallik",
                        "content": "class Solution {\\npublic:\\nstring fans;\\n    bool possible(map<char,int> &m,map<char,int> &chk){\\n        for(auto it:m){\\n            if(chk[it.first]<it.second)\\n            return false;\\n        }\\n        return true;\\n    }\\n    string minWindow(string s, string t) {\\n        map<char,int>m;\\n        for(auto it:t){\\n            m[it]++;\\n        }\\n        int i=0,j=0;\\n        int ans=100001;\\n        vector<int>v(2,-1);\\n        map<char,int>chk;\\n        string res;\\n        int start=0;\\n        while(j<s.size()){\\n            chk[s[j]]++;\\n            while(possible(m,chk)){\\n                if(ans>(j-i+1)){\\n                    ans=j-i+1;\\n                    res=s.substr(i,ans); //DOUBT\\n                }\\n                chk[s[i]]--;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return res;\\n        \\n    }\\n};\\n\\ncan anyone explain why substr function (mentioned as DOUBT) gives MLE in the above code.????"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "can someone please help me with the below code, it works perfectly in dry run but isn\\'t giving correct answer!\\n```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        unordered_map<char , int> mp;\\n        for (char c : t) {\\n            mp[c]++;\\n        }\\n\\n        int count = t.size();\\n        int start = 0;\\n        int end = 0;\\n        int d = INT_MAX;\\n\\n        while(end < s.size()){\\n            if(mp.find(s[end]) != mp.end()){\\n                mp[s[end]]--;\\n                if(mp[s[end]] == 0){\\n                    count--;\\n                }\\n                while(mp[s[end]] < 0 ){\\n                    if(mp.find(s[start]) != mp.end()) mp[s[start]]++;\\n                    if(mp[s[start]] > 0) count++;\\n                    start++;\\n                }\\n\\n                if(count == 0){\\n                    \\n                    while(mp.find(s[start]) == mp.end()){\\n                        start++;\\n                    }\\n\\n                    d = min(d, end - start + 1);\\n                }\\n            }\\n\\n            \\n            end++;\\n        }\\n        \\n        \\n\\n\\n        return d == INT_MAX ? \"\" : s.substr(start, d);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mdglankush565",
                        "content": "Its giving me memory limit exceeded can anyone help to how to correct it.\\n` string minWindow(string s, string t) {\\n        int n=s.length(),m=t.length();\\n        if(n<m)\\n            return \"\";\\n        int match=0,desire=m;\\n        unordered_map<char,long> freq,mp;\\n        for(auto i:t)   freq[i]++;\\n        string res=s;\\n        int i=0,j=0;\\n        bool flag=0;\\n        while(true){\\n            bool f1=0,f2=0;\\n            while(i<n && match<desire){\\n                if(freq[s[i]]>mp[s[i]])\\n                    match++;\\n                if(freq[s[i]])\\n                    mp[s[i]]++;\\n                i++;\\n                f1=1;\\n            }\\n            if(match==desire && (res.length()>i-j || res.length()==i-j && s.find(res[0])>=j )){\\n                res=s.substr(j,i-j);\\n                flag=1;\\n            }\\n            while(j<i && match==desire){\\n                if(freq[s[j]]==mp[s[j]] && freq[s[j]]!=0)\\n                    match--;\\n                if(freq[s[j]])\\n                    mp[s[j]]--;\\n                j++;\\n                if(match==desire && (res.length()>i-j || res.length()==i-j && s.find(res[0])>=j )){\\n                    res=s.substr(j,i-j);\\n                    flag=1;\\n                }\\n                f2=1;\\n            }\\n            if(!f1 && !f2)\\n                break;\\n        }\\n        if(flag)\\n            return res;\\n        return \"\";\\n    }`"
                    },
                    {
                        "username": "fOOl_404",
                        "content": "Don\\'t make a string and don\\'t keep adding further characters to it, it will probably give TLE. Just keep track of the starting index of minimum window of a string."
                    },
                    {
                        "username": "hugjobk",
                        "content": "Tips for O(n) solution:\\n- You need to maintain 2 pointers for `begin` and `end` of the `substring`\\n(1) Move the `end` pointer forward and increase the `counter` by one every time you find a character in `t` (do not increase the `counter` if you have enough number of that character)\\n(2) Stop moving the `end` pointer when `c == len(t)`; now the `substring` contains enough number of character in `t`\\n(3) Move the `begin` pointer forward until you find a character that if you remove it from the `substring`, that substring won\\'t be valid anymore\\n(4) Now you find a possible minWindow, compare it with the global minWindow and continue the process from step (1)"
                    },
                    {
                        "username": "tj3n123",
                        "content": "The steps 3 is surprisingly hard, kinda struggle here, have to remove each word while still need to count the min and matched word + it\\'s count"
                    },
                    {
                        "username": "idonnoit",
                        "content": "I noticed that in the Python editor here if you try to access a non-existent key it returns 0:\\nmy_dict[\"foo\"] -> 0\\nBut according to Python doc when a key is not in the dict, it will raise a KeyError.\\n\\nDoes LC use a customized Python version that modified the default dict behavior? This change indeed makes the code cleaner.\\n"
                    }
                ]
            },
            {
                "id": 1855971,
                "content": [
                    {
                        "username": "sanjusabu066",
                        "content": "TEST CASE #265 TLE\\nDO NOT UPDATE THE STRING EVERYTIME, YOUR CONDITION IS TRUE.\\nInstead maintain two pointers minstart and minend and return s.substring(minstart, minend+1);"
                    },
                    {
                        "username": "202211079",
                        "content": "How come \\'BANC\\' is there in output but N is even not part of t!!!!!\\n "
                    },
                    {
                        "username": "ranaujjawal692",
                        "content": "very excited solved it by myself without any help \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "rs02",
                        "content": "Guys after reading the description, I think we might have to find the minimum window substring of s or whatever that means."
                    },
                    {
                        "username": "pramodmallik",
                        "content": "class Solution {\\npublic:\\nstring fans;\\n    bool possible(map<char,int> &m,map<char,int> &chk){\\n        for(auto it:m){\\n            if(chk[it.first]<it.second)\\n            return false;\\n        }\\n        return true;\\n    }\\n    string minWindow(string s, string t) {\\n        map<char,int>m;\\n        for(auto it:t){\\n            m[it]++;\\n        }\\n        int i=0,j=0;\\n        int ans=100001;\\n        vector<int>v(2,-1);\\n        map<char,int>chk;\\n        string res;\\n        int start=0;\\n        while(j<s.size()){\\n            chk[s[j]]++;\\n            while(possible(m,chk)){\\n                if(ans>(j-i+1)){\\n                    ans=j-i+1;\\n                    res=s.substr(i,ans); //DOUBT\\n                }\\n                chk[s[i]]--;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return res;\\n        \\n    }\\n};\\n\\ncan anyone explain why substr function (mentioned as DOUBT) gives MLE in the above code.????"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "can someone please help me with the below code, it works perfectly in dry run but isn\\'t giving correct answer!\\n```\\nclass Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        unordered_map<char , int> mp;\\n        for (char c : t) {\\n            mp[c]++;\\n        }\\n\\n        int count = t.size();\\n        int start = 0;\\n        int end = 0;\\n        int d = INT_MAX;\\n\\n        while(end < s.size()){\\n            if(mp.find(s[end]) != mp.end()){\\n                mp[s[end]]--;\\n                if(mp[s[end]] == 0){\\n                    count--;\\n                }\\n                while(mp[s[end]] < 0 ){\\n                    if(mp.find(s[start]) != mp.end()) mp[s[start]]++;\\n                    if(mp[s[start]] > 0) count++;\\n                    start++;\\n                }\\n\\n                if(count == 0){\\n                    \\n                    while(mp.find(s[start]) == mp.end()){\\n                        start++;\\n                    }\\n\\n                    d = min(d, end - start + 1);\\n                }\\n            }\\n\\n            \\n            end++;\\n        }\\n        \\n        \\n\\n\\n        return d == INT_MAX ? \"\" : s.substr(start, d);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mdglankush565",
                        "content": "Its giving me memory limit exceeded can anyone help to how to correct it.\\n` string minWindow(string s, string t) {\\n        int n=s.length(),m=t.length();\\n        if(n<m)\\n            return \"\";\\n        int match=0,desire=m;\\n        unordered_map<char,long> freq,mp;\\n        for(auto i:t)   freq[i]++;\\n        string res=s;\\n        int i=0,j=0;\\n        bool flag=0;\\n        while(true){\\n            bool f1=0,f2=0;\\n            while(i<n && match<desire){\\n                if(freq[s[i]]>mp[s[i]])\\n                    match++;\\n                if(freq[s[i]])\\n                    mp[s[i]]++;\\n                i++;\\n                f1=1;\\n            }\\n            if(match==desire && (res.length()>i-j || res.length()==i-j && s.find(res[0])>=j )){\\n                res=s.substr(j,i-j);\\n                flag=1;\\n            }\\n            while(j<i && match==desire){\\n                if(freq[s[j]]==mp[s[j]] && freq[s[j]]!=0)\\n                    match--;\\n                if(freq[s[j]])\\n                    mp[s[j]]--;\\n                j++;\\n                if(match==desire && (res.length()>i-j || res.length()==i-j && s.find(res[0])>=j )){\\n                    res=s.substr(j,i-j);\\n                    flag=1;\\n                }\\n                f2=1;\\n            }\\n            if(!f1 && !f2)\\n                break;\\n        }\\n        if(flag)\\n            return res;\\n        return \"\";\\n    }`"
                    },
                    {
                        "username": "fOOl_404",
                        "content": "Don\\'t make a string and don\\'t keep adding further characters to it, it will probably give TLE. Just keep track of the starting index of minimum window of a string."
                    },
                    {
                        "username": "hugjobk",
                        "content": "Tips for O(n) solution:\\n- You need to maintain 2 pointers for `begin` and `end` of the `substring`\\n(1) Move the `end` pointer forward and increase the `counter` by one every time you find a character in `t` (do not increase the `counter` if you have enough number of that character)\\n(2) Stop moving the `end` pointer when `c == len(t)`; now the `substring` contains enough number of character in `t`\\n(3) Move the `begin` pointer forward until you find a character that if you remove it from the `substring`, that substring won\\'t be valid anymore\\n(4) Now you find a possible minWindow, compare it with the global minWindow and continue the process from step (1)"
                    },
                    {
                        "username": "tj3n123",
                        "content": "The steps 3 is surprisingly hard, kinda struggle here, have to remove each word while still need to count the min and matched word + it\\'s count"
                    },
                    {
                        "username": "idonnoit",
                        "content": "I noticed that in the Python editor here if you try to access a non-existent key it returns 0:\\nmy_dict[\"foo\"] -> 0\\nBut according to Python doc when a key is not in the dict, it will raise a KeyError.\\n\\nDoes LC use a customized Python version that modified the default dict behavior? This change indeed makes the code cleaner.\\n"
                    }
                ]
            },
            {
                "id": 1855857,
                "content": [
                    {
                        "username": "khuzii",
                        "content": "Hello, can anybody help why this code is giving runtime error?\\nIt\\'ll be really helpful :)\\n\\n class Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        if(t.size() > s.size())  {\\n            return \"\";\\n        }\\n        map<char, int> mp;\\n        for(int i=0; i<t.size(); i++)  {\\n            mp.insert({t[i], i});\\n        }\\n        string ans;\\n        int minl= s.size()+1;\\n        string x=t;\\n        for(int i=0; i<t.size(); i++)  {\\n            x[i]=\\'#\\';\\n        }\\n        for(int i=0; i<s.size(); i++)  { \\n            string temp= \"\";\\n            string td= t;\\n            for(int j= i; j<s.size(); j++)  {\\n                if(t.find(s[j])!=string::npos && td!=x)  {\\n                    temp += s[j];\\n                    int y= td.find(s[j]);\\n                    td[y]= \\'#\\';\\n                }\\n                else if(td != x && temp.size()!=0)  {\\n                    temp += s[j];\\n                }\\n                else if(td == x)  {\\n                    if(minl > temp.size())  {\\n                        ans= temp;\\n                        minl= temp.size();\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangfred",
                        "content": "Can anyone shed a light what\\'s wrong with this solution? It passed all my local cases, but failed when submitting. The failing case is with a huge s and huge t when submitting that I cannot post here.\\n\\npublic String minWindow(String s, String t) {\\n        if(t==null || t.length()==0 || t.length() > s.length()) return \"\";\\n        Map<Character, Integer> tmap = new HashMap<>();\\n        for(char c : t.toCharArray()){\\n            tmap.merge(c, 1, (v1, v2)-> v1 + v2);\\n        }\\n\\n        Map<Character, Integer> smap = new HashMap<>();\\n        int[] sub = new int[2];\\n        int subLength = Integer.MAX_VALUE;\\n        int l=0, have = 0, need = tmap.size();\\n        for(int r=0; r<s.length(); r++){\\n            char c = s.charAt(r);\\n            smap.merge(c, 1, (v1, v2)-> v1 + v2);\\n            //find the first char\\n            if(tmap.containsKey(c) && smap.get(c)==tmap.get(c)){\\n                have++;\\n            }\\n            while(have == need){\\n                if((r-l+1) < subLength){\\n                    subLength = r-l+1;\\n                    sub[0]=l;\\n                    sub[1]=r;\\n                }\\n                char lc = s.charAt(l);\\n                smap.merge(lc, -1, (v1, v2)->v1 + v2);\\n                l++;\\n                if(tmap.containsKey(lc) && tmap.get(lc) > smap.get(lc)){\\n                    have--;\\n                }\\n            }\\n        }\\n        return subLength==Integer.MAX_VALUE? \"\" : s.substring(sub[0], sub[1]+1);\\n    }\\n\\n "
                    },
                    {
                        "username": "isanghaessi",
                        "content": "I think I found leetcode running machine bug.\\n\\nI\\'m not sure this code would accepted.\\nBut, This code runs differently between leetocde and vscode at local.\\n  My code will print start and end point in while block. I think it must print exactly same deque variable. but, in leetcode it\\'s different.\\n  Also, I print when put some element to deque variable.\\n\\n```\\nfrom collections import *\\n\\nclass Solution:\\n    def minWindow(self, s: str, t: str) -> str:\\n        def checkAllIn(_dict):\\n            for ct in tDict:\\n                if ct not in _dict or _dict[ct] < tDict[ct]:\\n\\n                    return False\\n\\n            return True\\n\\n        \\n        result = s\\n        tDict = dict(Counter(t))\\n        toSee = deque([0])\\n        while len(toSee) > 0:\\n            print(\\'start\\', toSee)\\n            l = toSee.popleft()\\n            r = l\\n            currentDict = defaultdict(int)\\n            while r < len(s) and r + 1 - l < len(result) and not checkAllIn(currentDict):\\n                if r > l and s[r] in t and r not in toSee:\\n                    print(\\'put at up\\', r)\\n                    toSee.append(r)\\n                currentDict[s[r]] += 1\\n                r += 1\\n            if checkAllIn(currentDict) and r - l < len(result):\\n                result = s[l:r]\\n            if len(toSee) == 0 and r < len(s):\\n                print(\\'put at down\\', r)\\n                toSee.append(r)\\n            print(\\'end\\', toSee)\\n\\n        return result if checkAllIn(dict(Counter(result))) else \\'\\'\\n```\\n\\nI ran this code with first test case of this problem.\\n\\n> s = \\'ADOBECODEBANC\\'\\n> t = \\'ABC\\'\\n\\n- My vscode run with no **infinite loop**\\n\\n> start deque([0])\\nput at up 3\\nput at up 5\\nend deque([3, 5])\\nstart deque([3, 5])\\nend deque([5])\\nstart deque([5])\\nput at up 9\\nend deque([9])\\nstart deque([9])\\nput at up 10\\nput at up 12\\nend deque([10, 12])\\nstart deque([10, 12])\\nend deque([12])\\nstart deque([12])\\nend deque([])\\n\\n- but, in leetcode it falls **infinite loop**\\n\\n> start deque([0])\\nput at up 3\\nput at up 5\\nend deque([3, 5])\\nstart deque([3, 5])\\nend deque([5])\\nstart deque([5])\\nput at up 9\\nend deque([9])\\nstart deque([9])\\nput at up 10\\nput at up 12\\nend deque([10, 12])\\nstart deque([10, 12])\\nend deque([12])\\nstart deque([12])\\nend deque([])\\nstart deque([0])    <- why this element is here...?\\nput at down 0\\nend deque([0])\\nstart deque([0])\\nput at down 0\\n...\\n\\nWhat am I wrong...?"
                    },
                    {
                        "username": "jappi_jsl",
                        "content": " `\n\nclass Solution {\npublic:\n\n    bool isSame(vector<int>smap , vector<int>tmap){\n        for(int i=0;i<tmap.size();i++){\n            if(tmap[i] != smap[i]) return false;\n        }\n        return true;\n    }\n\n    string minWindow(string s, string t) {\n        string ans=\"\";\n        vector<int>smap(256,0),tmap(256,0);\n        for(auto i:t) {\n            if(i>='A' && i<='Z') tmap[i-'A']++;\n            else tmap[i-'a']++;\n        }\n        int mini = INT_MAX;\n        int i=0,j=0;\n        int n=s.length();\n        while(j<n){\n            if(s[j]>='A' && s[j]<='Z') smap[s[j]-'A']++;\n            else smap[s[j]-'a']++;\n            if(!isSame(smap,tmap)) j++;\n            else{\n                while(isSame(smap,tmap)){\n                    if(j-i+1<mini){\n                        mini=j-i+1;\n                        ans=s.substr(i,j-i+1);\n                    }\n                    if(s[i]>='A' && s[i]<='Z') smap[s[i]-'A']--;\n                    else smap[s[i]-'a']--;\n                    i++;\n                }\n                j++;\n            }\n\n        }\n        return ans;\n    }\n};\n\n`\nInput:\ns->  \"ADOBECODEBANC\"\n\nt-> \"ABC\"\n\nOutput: \"\"\n\n\nCan you Please help me to find where I'm Going wrong"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "choj",
                        "content": "An elaborate form of LC #3."
                    },
                    {
                        "username": "archerfx",
                        "content": "Not sure why I am getting TLE (for the input with large number of a's \n. Please help!\nAs far as I understand it should be (2*10^5) * 66 operations in the worst case.\n[Submission here](https://leetcode.com/problems/minimum-window-substring/submissions/861076437/) \n "
                    },
                    {
                        "username": "archerfx",
                        "content": "got it. I was making curAnsStr with every update in minimum string length. It was causing memory limit exceeded. \\n[Updated Submission here](https://leetcode.com/problems/minimum-window-substring/submissions/861092606/)"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "How the Integer object (in java) play with us!  :(\\nBE CAREFUL for object Integer, use Integer.intValue() to compare the values of Two Integer...\\n\\n Actually, In Byte range i.e. [-128,127]  two Integers compare their values. Out of this range [-128,127] ,two Integers starts comparing their references not their value. so we need intValue() function to compare when we have to compare values out of range [-128,127].\\nWhereas two int are always comparable (get compared by its value automatically)."
                    },
                    {
                        "username": "ryabkin",
                        "content": "Don't use Python's Counters, they are not optimal, for e.g. you can subtract them and check len(cs-ct) == 0"
                    },
                    {
                        "username": "Bish-AFC",
                        "content": "Best I could do, managed 264 / 266 cases but spent waaaay too long doing it. Tried without looking at any other submissions and pretty happy, though it is in terrible need of optimisation. Wasn\\'t a clean-sweep but there will always be next time."
                    },
                    {
                        "username": "Lettuce16",
                        "content": "I managed 265/266 :D However the last one is due to Time Limit :( Mine is also terrible :)"
                    }
                ]
            },
            {
                "id": 1854122,
                "content": [
                    {
                        "username": "khuzii",
                        "content": "Hello, can anybody help why this code is giving runtime error?\\nIt\\'ll be really helpful :)\\n\\n class Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        if(t.size() > s.size())  {\\n            return \"\";\\n        }\\n        map<char, int> mp;\\n        for(int i=0; i<t.size(); i++)  {\\n            mp.insert({t[i], i});\\n        }\\n        string ans;\\n        int minl= s.size()+1;\\n        string x=t;\\n        for(int i=0; i<t.size(); i++)  {\\n            x[i]=\\'#\\';\\n        }\\n        for(int i=0; i<s.size(); i++)  { \\n            string temp= \"\";\\n            string td= t;\\n            for(int j= i; j<s.size(); j++)  {\\n                if(t.find(s[j])!=string::npos && td!=x)  {\\n                    temp += s[j];\\n                    int y= td.find(s[j]);\\n                    td[y]= \\'#\\';\\n                }\\n                else if(td != x && temp.size()!=0)  {\\n                    temp += s[j];\\n                }\\n                else if(td == x)  {\\n                    if(minl > temp.size())  {\\n                        ans= temp;\\n                        minl= temp.size();\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangfred",
                        "content": "Can anyone shed a light what\\'s wrong with this solution? It passed all my local cases, but failed when submitting. The failing case is with a huge s and huge t when submitting that I cannot post here.\\n\\npublic String minWindow(String s, String t) {\\n        if(t==null || t.length()==0 || t.length() > s.length()) return \"\";\\n        Map<Character, Integer> tmap = new HashMap<>();\\n        for(char c : t.toCharArray()){\\n            tmap.merge(c, 1, (v1, v2)-> v1 + v2);\\n        }\\n\\n        Map<Character, Integer> smap = new HashMap<>();\\n        int[] sub = new int[2];\\n        int subLength = Integer.MAX_VALUE;\\n        int l=0, have = 0, need = tmap.size();\\n        for(int r=0; r<s.length(); r++){\\n            char c = s.charAt(r);\\n            smap.merge(c, 1, (v1, v2)-> v1 + v2);\\n            //find the first char\\n            if(tmap.containsKey(c) && smap.get(c)==tmap.get(c)){\\n                have++;\\n            }\\n            while(have == need){\\n                if((r-l+1) < subLength){\\n                    subLength = r-l+1;\\n                    sub[0]=l;\\n                    sub[1]=r;\\n                }\\n                char lc = s.charAt(l);\\n                smap.merge(lc, -1, (v1, v2)->v1 + v2);\\n                l++;\\n                if(tmap.containsKey(lc) && tmap.get(lc) > smap.get(lc)){\\n                    have--;\\n                }\\n            }\\n        }\\n        return subLength==Integer.MAX_VALUE? \"\" : s.substring(sub[0], sub[1]+1);\\n    }\\n\\n "
                    },
                    {
                        "username": "isanghaessi",
                        "content": "I think I found leetcode running machine bug.\\n\\nI\\'m not sure this code would accepted.\\nBut, This code runs differently between leetocde and vscode at local.\\n  My code will print start and end point in while block. I think it must print exactly same deque variable. but, in leetcode it\\'s different.\\n  Also, I print when put some element to deque variable.\\n\\n```\\nfrom collections import *\\n\\nclass Solution:\\n    def minWindow(self, s: str, t: str) -> str:\\n        def checkAllIn(_dict):\\n            for ct in tDict:\\n                if ct not in _dict or _dict[ct] < tDict[ct]:\\n\\n                    return False\\n\\n            return True\\n\\n        \\n        result = s\\n        tDict = dict(Counter(t))\\n        toSee = deque([0])\\n        while len(toSee) > 0:\\n            print(\\'start\\', toSee)\\n            l = toSee.popleft()\\n            r = l\\n            currentDict = defaultdict(int)\\n            while r < len(s) and r + 1 - l < len(result) and not checkAllIn(currentDict):\\n                if r > l and s[r] in t and r not in toSee:\\n                    print(\\'put at up\\', r)\\n                    toSee.append(r)\\n                currentDict[s[r]] += 1\\n                r += 1\\n            if checkAllIn(currentDict) and r - l < len(result):\\n                result = s[l:r]\\n            if len(toSee) == 0 and r < len(s):\\n                print(\\'put at down\\', r)\\n                toSee.append(r)\\n            print(\\'end\\', toSee)\\n\\n        return result if checkAllIn(dict(Counter(result))) else \\'\\'\\n```\\n\\nI ran this code with first test case of this problem.\\n\\n> s = \\'ADOBECODEBANC\\'\\n> t = \\'ABC\\'\\n\\n- My vscode run with no **infinite loop**\\n\\n> start deque([0])\\nput at up 3\\nput at up 5\\nend deque([3, 5])\\nstart deque([3, 5])\\nend deque([5])\\nstart deque([5])\\nput at up 9\\nend deque([9])\\nstart deque([9])\\nput at up 10\\nput at up 12\\nend deque([10, 12])\\nstart deque([10, 12])\\nend deque([12])\\nstart deque([12])\\nend deque([])\\n\\n- but, in leetcode it falls **infinite loop**\\n\\n> start deque([0])\\nput at up 3\\nput at up 5\\nend deque([3, 5])\\nstart deque([3, 5])\\nend deque([5])\\nstart deque([5])\\nput at up 9\\nend deque([9])\\nstart deque([9])\\nput at up 10\\nput at up 12\\nend deque([10, 12])\\nstart deque([10, 12])\\nend deque([12])\\nstart deque([12])\\nend deque([])\\nstart deque([0])    <- why this element is here...?\\nput at down 0\\nend deque([0])\\nstart deque([0])\\nput at down 0\\n...\\n\\nWhat am I wrong...?"
                    },
                    {
                        "username": "jappi_jsl",
                        "content": " `\n\nclass Solution {\npublic:\n\n    bool isSame(vector<int>smap , vector<int>tmap){\n        for(int i=0;i<tmap.size();i++){\n            if(tmap[i] != smap[i]) return false;\n        }\n        return true;\n    }\n\n    string minWindow(string s, string t) {\n        string ans=\"\";\n        vector<int>smap(256,0),tmap(256,0);\n        for(auto i:t) {\n            if(i>='A' && i<='Z') tmap[i-'A']++;\n            else tmap[i-'a']++;\n        }\n        int mini = INT_MAX;\n        int i=0,j=0;\n        int n=s.length();\n        while(j<n){\n            if(s[j]>='A' && s[j]<='Z') smap[s[j]-'A']++;\n            else smap[s[j]-'a']++;\n            if(!isSame(smap,tmap)) j++;\n            else{\n                while(isSame(smap,tmap)){\n                    if(j-i+1<mini){\n                        mini=j-i+1;\n                        ans=s.substr(i,j-i+1);\n                    }\n                    if(s[i]>='A' && s[i]<='Z') smap[s[i]-'A']--;\n                    else smap[s[i]-'a']--;\n                    i++;\n                }\n                j++;\n            }\n\n        }\n        return ans;\n    }\n};\n\n`\nInput:\ns->  \"ADOBECODEBANC\"\n\nt-> \"ABC\"\n\nOutput: \"\"\n\n\nCan you Please help me to find where I'm Going wrong"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "choj",
                        "content": "An elaborate form of LC #3."
                    },
                    {
                        "username": "archerfx",
                        "content": "Not sure why I am getting TLE (for the input with large number of a's \n. Please help!\nAs far as I understand it should be (2*10^5) * 66 operations in the worst case.\n[Submission here](https://leetcode.com/problems/minimum-window-substring/submissions/861076437/) \n "
                    },
                    {
                        "username": "archerfx",
                        "content": "got it. I was making curAnsStr with every update in minimum string length. It was causing memory limit exceeded. \\n[Updated Submission here](https://leetcode.com/problems/minimum-window-substring/submissions/861092606/)"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "How the Integer object (in java) play with us!  :(\\nBE CAREFUL for object Integer, use Integer.intValue() to compare the values of Two Integer...\\n\\n Actually, In Byte range i.e. [-128,127]  two Integers compare their values. Out of this range [-128,127] ,two Integers starts comparing their references not their value. so we need intValue() function to compare when we have to compare values out of range [-128,127].\\nWhereas two int are always comparable (get compared by its value automatically)."
                    },
                    {
                        "username": "ryabkin",
                        "content": "Don't use Python's Counters, they are not optimal, for e.g. you can subtract them and check len(cs-ct) == 0"
                    },
                    {
                        "username": "Bish-AFC",
                        "content": "Best I could do, managed 264 / 266 cases but spent waaaay too long doing it. Tried without looking at any other submissions and pretty happy, though it is in terrible need of optimisation. Wasn\\'t a clean-sweep but there will always be next time."
                    },
                    {
                        "username": "Lettuce16",
                        "content": "I managed 265/266 :D However the last one is due to Time Limit :( Mine is also terrible :)"
                    }
                ]
            },
            {
                "id": 1786997,
                "content": [
                    {
                        "username": "khuzii",
                        "content": "Hello, can anybody help why this code is giving runtime error?\\nIt\\'ll be really helpful :)\\n\\n class Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        if(t.size() > s.size())  {\\n            return \"\";\\n        }\\n        map<char, int> mp;\\n        for(int i=0; i<t.size(); i++)  {\\n            mp.insert({t[i], i});\\n        }\\n        string ans;\\n        int minl= s.size()+1;\\n        string x=t;\\n        for(int i=0; i<t.size(); i++)  {\\n            x[i]=\\'#\\';\\n        }\\n        for(int i=0; i<s.size(); i++)  { \\n            string temp= \"\";\\n            string td= t;\\n            for(int j= i; j<s.size(); j++)  {\\n                if(t.find(s[j])!=string::npos && td!=x)  {\\n                    temp += s[j];\\n                    int y= td.find(s[j]);\\n                    td[y]= \\'#\\';\\n                }\\n                else if(td != x && temp.size()!=0)  {\\n                    temp += s[j];\\n                }\\n                else if(td == x)  {\\n                    if(minl > temp.size())  {\\n                        ans= temp;\\n                        minl= temp.size();\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangfred",
                        "content": "Can anyone shed a light what\\'s wrong with this solution? It passed all my local cases, but failed when submitting. The failing case is with a huge s and huge t when submitting that I cannot post here.\\n\\npublic String minWindow(String s, String t) {\\n        if(t==null || t.length()==0 || t.length() > s.length()) return \"\";\\n        Map<Character, Integer> tmap = new HashMap<>();\\n        for(char c : t.toCharArray()){\\n            tmap.merge(c, 1, (v1, v2)-> v1 + v2);\\n        }\\n\\n        Map<Character, Integer> smap = new HashMap<>();\\n        int[] sub = new int[2];\\n        int subLength = Integer.MAX_VALUE;\\n        int l=0, have = 0, need = tmap.size();\\n        for(int r=0; r<s.length(); r++){\\n            char c = s.charAt(r);\\n            smap.merge(c, 1, (v1, v2)-> v1 + v2);\\n            //find the first char\\n            if(tmap.containsKey(c) && smap.get(c)==tmap.get(c)){\\n                have++;\\n            }\\n            while(have == need){\\n                if((r-l+1) < subLength){\\n                    subLength = r-l+1;\\n                    sub[0]=l;\\n                    sub[1]=r;\\n                }\\n                char lc = s.charAt(l);\\n                smap.merge(lc, -1, (v1, v2)->v1 + v2);\\n                l++;\\n                if(tmap.containsKey(lc) && tmap.get(lc) > smap.get(lc)){\\n                    have--;\\n                }\\n            }\\n        }\\n        return subLength==Integer.MAX_VALUE? \"\" : s.substring(sub[0], sub[1]+1);\\n    }\\n\\n "
                    },
                    {
                        "username": "isanghaessi",
                        "content": "I think I found leetcode running machine bug.\\n\\nI\\'m not sure this code would accepted.\\nBut, This code runs differently between leetocde and vscode at local.\\n  My code will print start and end point in while block. I think it must print exactly same deque variable. but, in leetcode it\\'s different.\\n  Also, I print when put some element to deque variable.\\n\\n```\\nfrom collections import *\\n\\nclass Solution:\\n    def minWindow(self, s: str, t: str) -> str:\\n        def checkAllIn(_dict):\\n            for ct in tDict:\\n                if ct not in _dict or _dict[ct] < tDict[ct]:\\n\\n                    return False\\n\\n            return True\\n\\n        \\n        result = s\\n        tDict = dict(Counter(t))\\n        toSee = deque([0])\\n        while len(toSee) > 0:\\n            print(\\'start\\', toSee)\\n            l = toSee.popleft()\\n            r = l\\n            currentDict = defaultdict(int)\\n            while r < len(s) and r + 1 - l < len(result) and not checkAllIn(currentDict):\\n                if r > l and s[r] in t and r not in toSee:\\n                    print(\\'put at up\\', r)\\n                    toSee.append(r)\\n                currentDict[s[r]] += 1\\n                r += 1\\n            if checkAllIn(currentDict) and r - l < len(result):\\n                result = s[l:r]\\n            if len(toSee) == 0 and r < len(s):\\n                print(\\'put at down\\', r)\\n                toSee.append(r)\\n            print(\\'end\\', toSee)\\n\\n        return result if checkAllIn(dict(Counter(result))) else \\'\\'\\n```\\n\\nI ran this code with first test case of this problem.\\n\\n> s = \\'ADOBECODEBANC\\'\\n> t = \\'ABC\\'\\n\\n- My vscode run with no **infinite loop**\\n\\n> start deque([0])\\nput at up 3\\nput at up 5\\nend deque([3, 5])\\nstart deque([3, 5])\\nend deque([5])\\nstart deque([5])\\nput at up 9\\nend deque([9])\\nstart deque([9])\\nput at up 10\\nput at up 12\\nend deque([10, 12])\\nstart deque([10, 12])\\nend deque([12])\\nstart deque([12])\\nend deque([])\\n\\n- but, in leetcode it falls **infinite loop**\\n\\n> start deque([0])\\nput at up 3\\nput at up 5\\nend deque([3, 5])\\nstart deque([3, 5])\\nend deque([5])\\nstart deque([5])\\nput at up 9\\nend deque([9])\\nstart deque([9])\\nput at up 10\\nput at up 12\\nend deque([10, 12])\\nstart deque([10, 12])\\nend deque([12])\\nstart deque([12])\\nend deque([])\\nstart deque([0])    <- why this element is here...?\\nput at down 0\\nend deque([0])\\nstart deque([0])\\nput at down 0\\n...\\n\\nWhat am I wrong...?"
                    },
                    {
                        "username": "jappi_jsl",
                        "content": " `\n\nclass Solution {\npublic:\n\n    bool isSame(vector<int>smap , vector<int>tmap){\n        for(int i=0;i<tmap.size();i++){\n            if(tmap[i] != smap[i]) return false;\n        }\n        return true;\n    }\n\n    string minWindow(string s, string t) {\n        string ans=\"\";\n        vector<int>smap(256,0),tmap(256,0);\n        for(auto i:t) {\n            if(i>='A' && i<='Z') tmap[i-'A']++;\n            else tmap[i-'a']++;\n        }\n        int mini = INT_MAX;\n        int i=0,j=0;\n        int n=s.length();\n        while(j<n){\n            if(s[j]>='A' && s[j]<='Z') smap[s[j]-'A']++;\n            else smap[s[j]-'a']++;\n            if(!isSame(smap,tmap)) j++;\n            else{\n                while(isSame(smap,tmap)){\n                    if(j-i+1<mini){\n                        mini=j-i+1;\n                        ans=s.substr(i,j-i+1);\n                    }\n                    if(s[i]>='A' && s[i]<='Z') smap[s[i]-'A']--;\n                    else smap[s[i]-'a']--;\n                    i++;\n                }\n                j++;\n            }\n\n        }\n        return ans;\n    }\n};\n\n`\nInput:\ns->  \"ADOBECODEBANC\"\n\nt-> \"ABC\"\n\nOutput: \"\"\n\n\nCan you Please help me to find where I'm Going wrong"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "choj",
                        "content": "An elaborate form of LC #3."
                    },
                    {
                        "username": "archerfx",
                        "content": "Not sure why I am getting TLE (for the input with large number of a's \n. Please help!\nAs far as I understand it should be (2*10^5) * 66 operations in the worst case.\n[Submission here](https://leetcode.com/problems/minimum-window-substring/submissions/861076437/) \n "
                    },
                    {
                        "username": "archerfx",
                        "content": "got it. I was making curAnsStr with every update in minimum string length. It was causing memory limit exceeded. \\n[Updated Submission here](https://leetcode.com/problems/minimum-window-substring/submissions/861092606/)"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "How the Integer object (in java) play with us!  :(\\nBE CAREFUL for object Integer, use Integer.intValue() to compare the values of Two Integer...\\n\\n Actually, In Byte range i.e. [-128,127]  two Integers compare their values. Out of this range [-128,127] ,two Integers starts comparing their references not their value. so we need intValue() function to compare when we have to compare values out of range [-128,127].\\nWhereas two int are always comparable (get compared by its value automatically)."
                    },
                    {
                        "username": "ryabkin",
                        "content": "Don't use Python's Counters, they are not optimal, for e.g. you can subtract them and check len(cs-ct) == 0"
                    },
                    {
                        "username": "Bish-AFC",
                        "content": "Best I could do, managed 264 / 266 cases but spent waaaay too long doing it. Tried without looking at any other submissions and pretty happy, though it is in terrible need of optimisation. Wasn\\'t a clean-sweep but there will always be next time."
                    },
                    {
                        "username": "Lettuce16",
                        "content": "I managed 265/266 :D However the last one is due to Time Limit :( Mine is also terrible :)"
                    }
                ]
            },
            {
                "id": 1769686,
                "content": [
                    {
                        "username": "khuzii",
                        "content": "Hello, can anybody help why this code is giving runtime error?\\nIt\\'ll be really helpful :)\\n\\n class Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        if(t.size() > s.size())  {\\n            return \"\";\\n        }\\n        map<char, int> mp;\\n        for(int i=0; i<t.size(); i++)  {\\n            mp.insert({t[i], i});\\n        }\\n        string ans;\\n        int minl= s.size()+1;\\n        string x=t;\\n        for(int i=0; i<t.size(); i++)  {\\n            x[i]=\\'#\\';\\n        }\\n        for(int i=0; i<s.size(); i++)  { \\n            string temp= \"\";\\n            string td= t;\\n            for(int j= i; j<s.size(); j++)  {\\n                if(t.find(s[j])!=string::npos && td!=x)  {\\n                    temp += s[j];\\n                    int y= td.find(s[j]);\\n                    td[y]= \\'#\\';\\n                }\\n                else if(td != x && temp.size()!=0)  {\\n                    temp += s[j];\\n                }\\n                else if(td == x)  {\\n                    if(minl > temp.size())  {\\n                        ans= temp;\\n                        minl= temp.size();\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangfred",
                        "content": "Can anyone shed a light what\\'s wrong with this solution? It passed all my local cases, but failed when submitting. The failing case is with a huge s and huge t when submitting that I cannot post here.\\n\\npublic String minWindow(String s, String t) {\\n        if(t==null || t.length()==0 || t.length() > s.length()) return \"\";\\n        Map<Character, Integer> tmap = new HashMap<>();\\n        for(char c : t.toCharArray()){\\n            tmap.merge(c, 1, (v1, v2)-> v1 + v2);\\n        }\\n\\n        Map<Character, Integer> smap = new HashMap<>();\\n        int[] sub = new int[2];\\n        int subLength = Integer.MAX_VALUE;\\n        int l=0, have = 0, need = tmap.size();\\n        for(int r=0; r<s.length(); r++){\\n            char c = s.charAt(r);\\n            smap.merge(c, 1, (v1, v2)-> v1 + v2);\\n            //find the first char\\n            if(tmap.containsKey(c) && smap.get(c)==tmap.get(c)){\\n                have++;\\n            }\\n            while(have == need){\\n                if((r-l+1) < subLength){\\n                    subLength = r-l+1;\\n                    sub[0]=l;\\n                    sub[1]=r;\\n                }\\n                char lc = s.charAt(l);\\n                smap.merge(lc, -1, (v1, v2)->v1 + v2);\\n                l++;\\n                if(tmap.containsKey(lc) && tmap.get(lc) > smap.get(lc)){\\n                    have--;\\n                }\\n            }\\n        }\\n        return subLength==Integer.MAX_VALUE? \"\" : s.substring(sub[0], sub[1]+1);\\n    }\\n\\n "
                    },
                    {
                        "username": "isanghaessi",
                        "content": "I think I found leetcode running machine bug.\\n\\nI\\'m not sure this code would accepted.\\nBut, This code runs differently between leetocde and vscode at local.\\n  My code will print start and end point in while block. I think it must print exactly same deque variable. but, in leetcode it\\'s different.\\n  Also, I print when put some element to deque variable.\\n\\n```\\nfrom collections import *\\n\\nclass Solution:\\n    def minWindow(self, s: str, t: str) -> str:\\n        def checkAllIn(_dict):\\n            for ct in tDict:\\n                if ct not in _dict or _dict[ct] < tDict[ct]:\\n\\n                    return False\\n\\n            return True\\n\\n        \\n        result = s\\n        tDict = dict(Counter(t))\\n        toSee = deque([0])\\n        while len(toSee) > 0:\\n            print(\\'start\\', toSee)\\n            l = toSee.popleft()\\n            r = l\\n            currentDict = defaultdict(int)\\n            while r < len(s) and r + 1 - l < len(result) and not checkAllIn(currentDict):\\n                if r > l and s[r] in t and r not in toSee:\\n                    print(\\'put at up\\', r)\\n                    toSee.append(r)\\n                currentDict[s[r]] += 1\\n                r += 1\\n            if checkAllIn(currentDict) and r - l < len(result):\\n                result = s[l:r]\\n            if len(toSee) == 0 and r < len(s):\\n                print(\\'put at down\\', r)\\n                toSee.append(r)\\n            print(\\'end\\', toSee)\\n\\n        return result if checkAllIn(dict(Counter(result))) else \\'\\'\\n```\\n\\nI ran this code with first test case of this problem.\\n\\n> s = \\'ADOBECODEBANC\\'\\n> t = \\'ABC\\'\\n\\n- My vscode run with no **infinite loop**\\n\\n> start deque([0])\\nput at up 3\\nput at up 5\\nend deque([3, 5])\\nstart deque([3, 5])\\nend deque([5])\\nstart deque([5])\\nput at up 9\\nend deque([9])\\nstart deque([9])\\nput at up 10\\nput at up 12\\nend deque([10, 12])\\nstart deque([10, 12])\\nend deque([12])\\nstart deque([12])\\nend deque([])\\n\\n- but, in leetcode it falls **infinite loop**\\n\\n> start deque([0])\\nput at up 3\\nput at up 5\\nend deque([3, 5])\\nstart deque([3, 5])\\nend deque([5])\\nstart deque([5])\\nput at up 9\\nend deque([9])\\nstart deque([9])\\nput at up 10\\nput at up 12\\nend deque([10, 12])\\nstart deque([10, 12])\\nend deque([12])\\nstart deque([12])\\nend deque([])\\nstart deque([0])    <- why this element is here...?\\nput at down 0\\nend deque([0])\\nstart deque([0])\\nput at down 0\\n...\\n\\nWhat am I wrong...?"
                    },
                    {
                        "username": "jappi_jsl",
                        "content": " `\n\nclass Solution {\npublic:\n\n    bool isSame(vector<int>smap , vector<int>tmap){\n        for(int i=0;i<tmap.size();i++){\n            if(tmap[i] != smap[i]) return false;\n        }\n        return true;\n    }\n\n    string minWindow(string s, string t) {\n        string ans=\"\";\n        vector<int>smap(256,0),tmap(256,0);\n        for(auto i:t) {\n            if(i>='A' && i<='Z') tmap[i-'A']++;\n            else tmap[i-'a']++;\n        }\n        int mini = INT_MAX;\n        int i=0,j=0;\n        int n=s.length();\n        while(j<n){\n            if(s[j]>='A' && s[j]<='Z') smap[s[j]-'A']++;\n            else smap[s[j]-'a']++;\n            if(!isSame(smap,tmap)) j++;\n            else{\n                while(isSame(smap,tmap)){\n                    if(j-i+1<mini){\n                        mini=j-i+1;\n                        ans=s.substr(i,j-i+1);\n                    }\n                    if(s[i]>='A' && s[i]<='Z') smap[s[i]-'A']--;\n                    else smap[s[i]-'a']--;\n                    i++;\n                }\n                j++;\n            }\n\n        }\n        return ans;\n    }\n};\n\n`\nInput:\ns->  \"ADOBECODEBANC\"\n\nt-> \"ABC\"\n\nOutput: \"\"\n\n\nCan you Please help me to find where I'm Going wrong"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "choj",
                        "content": "An elaborate form of LC #3."
                    },
                    {
                        "username": "archerfx",
                        "content": "Not sure why I am getting TLE (for the input with large number of a's \n. Please help!\nAs far as I understand it should be (2*10^5) * 66 operations in the worst case.\n[Submission here](https://leetcode.com/problems/minimum-window-substring/submissions/861076437/) \n "
                    },
                    {
                        "username": "archerfx",
                        "content": "got it. I was making curAnsStr with every update in minimum string length. It was causing memory limit exceeded. \\n[Updated Submission here](https://leetcode.com/problems/minimum-window-substring/submissions/861092606/)"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "How the Integer object (in java) play with us!  :(\\nBE CAREFUL for object Integer, use Integer.intValue() to compare the values of Two Integer...\\n\\n Actually, In Byte range i.e. [-128,127]  two Integers compare their values. Out of this range [-128,127] ,two Integers starts comparing their references not their value. so we need intValue() function to compare when we have to compare values out of range [-128,127].\\nWhereas two int are always comparable (get compared by its value automatically)."
                    },
                    {
                        "username": "ryabkin",
                        "content": "Don't use Python's Counters, they are not optimal, for e.g. you can subtract them and check len(cs-ct) == 0"
                    },
                    {
                        "username": "Bish-AFC",
                        "content": "Best I could do, managed 264 / 266 cases but spent waaaay too long doing it. Tried without looking at any other submissions and pretty happy, though it is in terrible need of optimisation. Wasn\\'t a clean-sweep but there will always be next time."
                    },
                    {
                        "username": "Lettuce16",
                        "content": "I managed 265/266 :D However the last one is due to Time Limit :( Mine is also terrible :)"
                    }
                ]
            },
            {
                "id": 1768450,
                "content": [
                    {
                        "username": "khuzii",
                        "content": "Hello, can anybody help why this code is giving runtime error?\\nIt\\'ll be really helpful :)\\n\\n class Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        if(t.size() > s.size())  {\\n            return \"\";\\n        }\\n        map<char, int> mp;\\n        for(int i=0; i<t.size(); i++)  {\\n            mp.insert({t[i], i});\\n        }\\n        string ans;\\n        int minl= s.size()+1;\\n        string x=t;\\n        for(int i=0; i<t.size(); i++)  {\\n            x[i]=\\'#\\';\\n        }\\n        for(int i=0; i<s.size(); i++)  { \\n            string temp= \"\";\\n            string td= t;\\n            for(int j= i; j<s.size(); j++)  {\\n                if(t.find(s[j])!=string::npos && td!=x)  {\\n                    temp += s[j];\\n                    int y= td.find(s[j]);\\n                    td[y]= \\'#\\';\\n                }\\n                else if(td != x && temp.size()!=0)  {\\n                    temp += s[j];\\n                }\\n                else if(td == x)  {\\n                    if(minl > temp.size())  {\\n                        ans= temp;\\n                        minl= temp.size();\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangfred",
                        "content": "Can anyone shed a light what\\'s wrong with this solution? It passed all my local cases, but failed when submitting. The failing case is with a huge s and huge t when submitting that I cannot post here.\\n\\npublic String minWindow(String s, String t) {\\n        if(t==null || t.length()==0 || t.length() > s.length()) return \"\";\\n        Map<Character, Integer> tmap = new HashMap<>();\\n        for(char c : t.toCharArray()){\\n            tmap.merge(c, 1, (v1, v2)-> v1 + v2);\\n        }\\n\\n        Map<Character, Integer> smap = new HashMap<>();\\n        int[] sub = new int[2];\\n        int subLength = Integer.MAX_VALUE;\\n        int l=0, have = 0, need = tmap.size();\\n        for(int r=0; r<s.length(); r++){\\n            char c = s.charAt(r);\\n            smap.merge(c, 1, (v1, v2)-> v1 + v2);\\n            //find the first char\\n            if(tmap.containsKey(c) && smap.get(c)==tmap.get(c)){\\n                have++;\\n            }\\n            while(have == need){\\n                if((r-l+1) < subLength){\\n                    subLength = r-l+1;\\n                    sub[0]=l;\\n                    sub[1]=r;\\n                }\\n                char lc = s.charAt(l);\\n                smap.merge(lc, -1, (v1, v2)->v1 + v2);\\n                l++;\\n                if(tmap.containsKey(lc) && tmap.get(lc) > smap.get(lc)){\\n                    have--;\\n                }\\n            }\\n        }\\n        return subLength==Integer.MAX_VALUE? \"\" : s.substring(sub[0], sub[1]+1);\\n    }\\n\\n "
                    },
                    {
                        "username": "isanghaessi",
                        "content": "I think I found leetcode running machine bug.\\n\\nI\\'m not sure this code would accepted.\\nBut, This code runs differently between leetocde and vscode at local.\\n  My code will print start and end point in while block. I think it must print exactly same deque variable. but, in leetcode it\\'s different.\\n  Also, I print when put some element to deque variable.\\n\\n```\\nfrom collections import *\\n\\nclass Solution:\\n    def minWindow(self, s: str, t: str) -> str:\\n        def checkAllIn(_dict):\\n            for ct in tDict:\\n                if ct not in _dict or _dict[ct] < tDict[ct]:\\n\\n                    return False\\n\\n            return True\\n\\n        \\n        result = s\\n        tDict = dict(Counter(t))\\n        toSee = deque([0])\\n        while len(toSee) > 0:\\n            print(\\'start\\', toSee)\\n            l = toSee.popleft()\\n            r = l\\n            currentDict = defaultdict(int)\\n            while r < len(s) and r + 1 - l < len(result) and not checkAllIn(currentDict):\\n                if r > l and s[r] in t and r not in toSee:\\n                    print(\\'put at up\\', r)\\n                    toSee.append(r)\\n                currentDict[s[r]] += 1\\n                r += 1\\n            if checkAllIn(currentDict) and r - l < len(result):\\n                result = s[l:r]\\n            if len(toSee) == 0 and r < len(s):\\n                print(\\'put at down\\', r)\\n                toSee.append(r)\\n            print(\\'end\\', toSee)\\n\\n        return result if checkAllIn(dict(Counter(result))) else \\'\\'\\n```\\n\\nI ran this code with first test case of this problem.\\n\\n> s = \\'ADOBECODEBANC\\'\\n> t = \\'ABC\\'\\n\\n- My vscode run with no **infinite loop**\\n\\n> start deque([0])\\nput at up 3\\nput at up 5\\nend deque([3, 5])\\nstart deque([3, 5])\\nend deque([5])\\nstart deque([5])\\nput at up 9\\nend deque([9])\\nstart deque([9])\\nput at up 10\\nput at up 12\\nend deque([10, 12])\\nstart deque([10, 12])\\nend deque([12])\\nstart deque([12])\\nend deque([])\\n\\n- but, in leetcode it falls **infinite loop**\\n\\n> start deque([0])\\nput at up 3\\nput at up 5\\nend deque([3, 5])\\nstart deque([3, 5])\\nend deque([5])\\nstart deque([5])\\nput at up 9\\nend deque([9])\\nstart deque([9])\\nput at up 10\\nput at up 12\\nend deque([10, 12])\\nstart deque([10, 12])\\nend deque([12])\\nstart deque([12])\\nend deque([])\\nstart deque([0])    <- why this element is here...?\\nput at down 0\\nend deque([0])\\nstart deque([0])\\nput at down 0\\n...\\n\\nWhat am I wrong...?"
                    },
                    {
                        "username": "jappi_jsl",
                        "content": " `\n\nclass Solution {\npublic:\n\n    bool isSame(vector<int>smap , vector<int>tmap){\n        for(int i=0;i<tmap.size();i++){\n            if(tmap[i] != smap[i]) return false;\n        }\n        return true;\n    }\n\n    string minWindow(string s, string t) {\n        string ans=\"\";\n        vector<int>smap(256,0),tmap(256,0);\n        for(auto i:t) {\n            if(i>='A' && i<='Z') tmap[i-'A']++;\n            else tmap[i-'a']++;\n        }\n        int mini = INT_MAX;\n        int i=0,j=0;\n        int n=s.length();\n        while(j<n){\n            if(s[j]>='A' && s[j]<='Z') smap[s[j]-'A']++;\n            else smap[s[j]-'a']++;\n            if(!isSame(smap,tmap)) j++;\n            else{\n                while(isSame(smap,tmap)){\n                    if(j-i+1<mini){\n                        mini=j-i+1;\n                        ans=s.substr(i,j-i+1);\n                    }\n                    if(s[i]>='A' && s[i]<='Z') smap[s[i]-'A']--;\n                    else smap[s[i]-'a']--;\n                    i++;\n                }\n                j++;\n            }\n\n        }\n        return ans;\n    }\n};\n\n`\nInput:\ns->  \"ADOBECODEBANC\"\n\nt-> \"ABC\"\n\nOutput: \"\"\n\n\nCan you Please help me to find where I'm Going wrong"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "choj",
                        "content": "An elaborate form of LC #3."
                    },
                    {
                        "username": "archerfx",
                        "content": "Not sure why I am getting TLE (for the input with large number of a's \n. Please help!\nAs far as I understand it should be (2*10^5) * 66 operations in the worst case.\n[Submission here](https://leetcode.com/problems/minimum-window-substring/submissions/861076437/) \n "
                    },
                    {
                        "username": "archerfx",
                        "content": "got it. I was making curAnsStr with every update in minimum string length. It was causing memory limit exceeded. \\n[Updated Submission here](https://leetcode.com/problems/minimum-window-substring/submissions/861092606/)"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "How the Integer object (in java) play with us!  :(\\nBE CAREFUL for object Integer, use Integer.intValue() to compare the values of Two Integer...\\n\\n Actually, In Byte range i.e. [-128,127]  two Integers compare their values. Out of this range [-128,127] ,two Integers starts comparing their references not their value. so we need intValue() function to compare when we have to compare values out of range [-128,127].\\nWhereas two int are always comparable (get compared by its value automatically)."
                    },
                    {
                        "username": "ryabkin",
                        "content": "Don't use Python's Counters, they are not optimal, for e.g. you can subtract them and check len(cs-ct) == 0"
                    },
                    {
                        "username": "Bish-AFC",
                        "content": "Best I could do, managed 264 / 266 cases but spent waaaay too long doing it. Tried without looking at any other submissions and pretty happy, though it is in terrible need of optimisation. Wasn\\'t a clean-sweep but there will always be next time."
                    },
                    {
                        "username": "Lettuce16",
                        "content": "I managed 265/266 :D However the last one is due to Time Limit :( Mine is also terrible :)"
                    }
                ]
            },
            {
                "id": 1740622,
                "content": [
                    {
                        "username": "khuzii",
                        "content": "Hello, can anybody help why this code is giving runtime error?\\nIt\\'ll be really helpful :)\\n\\n class Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        if(t.size() > s.size())  {\\n            return \"\";\\n        }\\n        map<char, int> mp;\\n        for(int i=0; i<t.size(); i++)  {\\n            mp.insert({t[i], i});\\n        }\\n        string ans;\\n        int minl= s.size()+1;\\n        string x=t;\\n        for(int i=0; i<t.size(); i++)  {\\n            x[i]=\\'#\\';\\n        }\\n        for(int i=0; i<s.size(); i++)  { \\n            string temp= \"\";\\n            string td= t;\\n            for(int j= i; j<s.size(); j++)  {\\n                if(t.find(s[j])!=string::npos && td!=x)  {\\n                    temp += s[j];\\n                    int y= td.find(s[j]);\\n                    td[y]= \\'#\\';\\n                }\\n                else if(td != x && temp.size()!=0)  {\\n                    temp += s[j];\\n                }\\n                else if(td == x)  {\\n                    if(minl > temp.size())  {\\n                        ans= temp;\\n                        minl= temp.size();\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangfred",
                        "content": "Can anyone shed a light what\\'s wrong with this solution? It passed all my local cases, but failed when submitting. The failing case is with a huge s and huge t when submitting that I cannot post here.\\n\\npublic String minWindow(String s, String t) {\\n        if(t==null || t.length()==0 || t.length() > s.length()) return \"\";\\n        Map<Character, Integer> tmap = new HashMap<>();\\n        for(char c : t.toCharArray()){\\n            tmap.merge(c, 1, (v1, v2)-> v1 + v2);\\n        }\\n\\n        Map<Character, Integer> smap = new HashMap<>();\\n        int[] sub = new int[2];\\n        int subLength = Integer.MAX_VALUE;\\n        int l=0, have = 0, need = tmap.size();\\n        for(int r=0; r<s.length(); r++){\\n            char c = s.charAt(r);\\n            smap.merge(c, 1, (v1, v2)-> v1 + v2);\\n            //find the first char\\n            if(tmap.containsKey(c) && smap.get(c)==tmap.get(c)){\\n                have++;\\n            }\\n            while(have == need){\\n                if((r-l+1) < subLength){\\n                    subLength = r-l+1;\\n                    sub[0]=l;\\n                    sub[1]=r;\\n                }\\n                char lc = s.charAt(l);\\n                smap.merge(lc, -1, (v1, v2)->v1 + v2);\\n                l++;\\n                if(tmap.containsKey(lc) && tmap.get(lc) > smap.get(lc)){\\n                    have--;\\n                }\\n            }\\n        }\\n        return subLength==Integer.MAX_VALUE? \"\" : s.substring(sub[0], sub[1]+1);\\n    }\\n\\n "
                    },
                    {
                        "username": "isanghaessi",
                        "content": "I think I found leetcode running machine bug.\\n\\nI\\'m not sure this code would accepted.\\nBut, This code runs differently between leetocde and vscode at local.\\n  My code will print start and end point in while block. I think it must print exactly same deque variable. but, in leetcode it\\'s different.\\n  Also, I print when put some element to deque variable.\\n\\n```\\nfrom collections import *\\n\\nclass Solution:\\n    def minWindow(self, s: str, t: str) -> str:\\n        def checkAllIn(_dict):\\n            for ct in tDict:\\n                if ct not in _dict or _dict[ct] < tDict[ct]:\\n\\n                    return False\\n\\n            return True\\n\\n        \\n        result = s\\n        tDict = dict(Counter(t))\\n        toSee = deque([0])\\n        while len(toSee) > 0:\\n            print(\\'start\\', toSee)\\n            l = toSee.popleft()\\n            r = l\\n            currentDict = defaultdict(int)\\n            while r < len(s) and r + 1 - l < len(result) and not checkAllIn(currentDict):\\n                if r > l and s[r] in t and r not in toSee:\\n                    print(\\'put at up\\', r)\\n                    toSee.append(r)\\n                currentDict[s[r]] += 1\\n                r += 1\\n            if checkAllIn(currentDict) and r - l < len(result):\\n                result = s[l:r]\\n            if len(toSee) == 0 and r < len(s):\\n                print(\\'put at down\\', r)\\n                toSee.append(r)\\n            print(\\'end\\', toSee)\\n\\n        return result if checkAllIn(dict(Counter(result))) else \\'\\'\\n```\\n\\nI ran this code with first test case of this problem.\\n\\n> s = \\'ADOBECODEBANC\\'\\n> t = \\'ABC\\'\\n\\n- My vscode run with no **infinite loop**\\n\\n> start deque([0])\\nput at up 3\\nput at up 5\\nend deque([3, 5])\\nstart deque([3, 5])\\nend deque([5])\\nstart deque([5])\\nput at up 9\\nend deque([9])\\nstart deque([9])\\nput at up 10\\nput at up 12\\nend deque([10, 12])\\nstart deque([10, 12])\\nend deque([12])\\nstart deque([12])\\nend deque([])\\n\\n- but, in leetcode it falls **infinite loop**\\n\\n> start deque([0])\\nput at up 3\\nput at up 5\\nend deque([3, 5])\\nstart deque([3, 5])\\nend deque([5])\\nstart deque([5])\\nput at up 9\\nend deque([9])\\nstart deque([9])\\nput at up 10\\nput at up 12\\nend deque([10, 12])\\nstart deque([10, 12])\\nend deque([12])\\nstart deque([12])\\nend deque([])\\nstart deque([0])    <- why this element is here...?\\nput at down 0\\nend deque([0])\\nstart deque([0])\\nput at down 0\\n...\\n\\nWhat am I wrong...?"
                    },
                    {
                        "username": "jappi_jsl",
                        "content": " `\n\nclass Solution {\npublic:\n\n    bool isSame(vector<int>smap , vector<int>tmap){\n        for(int i=0;i<tmap.size();i++){\n            if(tmap[i] != smap[i]) return false;\n        }\n        return true;\n    }\n\n    string minWindow(string s, string t) {\n        string ans=\"\";\n        vector<int>smap(256,0),tmap(256,0);\n        for(auto i:t) {\n            if(i>='A' && i<='Z') tmap[i-'A']++;\n            else tmap[i-'a']++;\n        }\n        int mini = INT_MAX;\n        int i=0,j=0;\n        int n=s.length();\n        while(j<n){\n            if(s[j]>='A' && s[j]<='Z') smap[s[j]-'A']++;\n            else smap[s[j]-'a']++;\n            if(!isSame(smap,tmap)) j++;\n            else{\n                while(isSame(smap,tmap)){\n                    if(j-i+1<mini){\n                        mini=j-i+1;\n                        ans=s.substr(i,j-i+1);\n                    }\n                    if(s[i]>='A' && s[i]<='Z') smap[s[i]-'A']--;\n                    else smap[s[i]-'a']--;\n                    i++;\n                }\n                j++;\n            }\n\n        }\n        return ans;\n    }\n};\n\n`\nInput:\ns->  \"ADOBECODEBANC\"\n\nt-> \"ABC\"\n\nOutput: \"\"\n\n\nCan you Please help me to find where I'm Going wrong"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "choj",
                        "content": "An elaborate form of LC #3."
                    },
                    {
                        "username": "archerfx",
                        "content": "Not sure why I am getting TLE (for the input with large number of a's \n. Please help!\nAs far as I understand it should be (2*10^5) * 66 operations in the worst case.\n[Submission here](https://leetcode.com/problems/minimum-window-substring/submissions/861076437/) \n "
                    },
                    {
                        "username": "archerfx",
                        "content": "got it. I was making curAnsStr with every update in minimum string length. It was causing memory limit exceeded. \\n[Updated Submission here](https://leetcode.com/problems/minimum-window-substring/submissions/861092606/)"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "How the Integer object (in java) play with us!  :(\\nBE CAREFUL for object Integer, use Integer.intValue() to compare the values of Two Integer...\\n\\n Actually, In Byte range i.e. [-128,127]  two Integers compare their values. Out of this range [-128,127] ,two Integers starts comparing their references not their value. so we need intValue() function to compare when we have to compare values out of range [-128,127].\\nWhereas two int are always comparable (get compared by its value automatically)."
                    },
                    {
                        "username": "ryabkin",
                        "content": "Don't use Python's Counters, they are not optimal, for e.g. you can subtract them and check len(cs-ct) == 0"
                    },
                    {
                        "username": "Bish-AFC",
                        "content": "Best I could do, managed 264 / 266 cases but spent waaaay too long doing it. Tried without looking at any other submissions and pretty happy, though it is in terrible need of optimisation. Wasn\\'t a clean-sweep but there will always be next time."
                    },
                    {
                        "username": "Lettuce16",
                        "content": "I managed 265/266 :D However the last one is due to Time Limit :( Mine is also terrible :)"
                    }
                ]
            },
            {
                "id": 1719243,
                "content": [
                    {
                        "username": "khuzii",
                        "content": "Hello, can anybody help why this code is giving runtime error?\\nIt\\'ll be really helpful :)\\n\\n class Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        if(t.size() > s.size())  {\\n            return \"\";\\n        }\\n        map<char, int> mp;\\n        for(int i=0; i<t.size(); i++)  {\\n            mp.insert({t[i], i});\\n        }\\n        string ans;\\n        int minl= s.size()+1;\\n        string x=t;\\n        for(int i=0; i<t.size(); i++)  {\\n            x[i]=\\'#\\';\\n        }\\n        for(int i=0; i<s.size(); i++)  { \\n            string temp= \"\";\\n            string td= t;\\n            for(int j= i; j<s.size(); j++)  {\\n                if(t.find(s[j])!=string::npos && td!=x)  {\\n                    temp += s[j];\\n                    int y= td.find(s[j]);\\n                    td[y]= \\'#\\';\\n                }\\n                else if(td != x && temp.size()!=0)  {\\n                    temp += s[j];\\n                }\\n                else if(td == x)  {\\n                    if(minl > temp.size())  {\\n                        ans= temp;\\n                        minl= temp.size();\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangfred",
                        "content": "Can anyone shed a light what\\'s wrong with this solution? It passed all my local cases, but failed when submitting. The failing case is with a huge s and huge t when submitting that I cannot post here.\\n\\npublic String minWindow(String s, String t) {\\n        if(t==null || t.length()==0 || t.length() > s.length()) return \"\";\\n        Map<Character, Integer> tmap = new HashMap<>();\\n        for(char c : t.toCharArray()){\\n            tmap.merge(c, 1, (v1, v2)-> v1 + v2);\\n        }\\n\\n        Map<Character, Integer> smap = new HashMap<>();\\n        int[] sub = new int[2];\\n        int subLength = Integer.MAX_VALUE;\\n        int l=0, have = 0, need = tmap.size();\\n        for(int r=0; r<s.length(); r++){\\n            char c = s.charAt(r);\\n            smap.merge(c, 1, (v1, v2)-> v1 + v2);\\n            //find the first char\\n            if(tmap.containsKey(c) && smap.get(c)==tmap.get(c)){\\n                have++;\\n            }\\n            while(have == need){\\n                if((r-l+1) < subLength){\\n                    subLength = r-l+1;\\n                    sub[0]=l;\\n                    sub[1]=r;\\n                }\\n                char lc = s.charAt(l);\\n                smap.merge(lc, -1, (v1, v2)->v1 + v2);\\n                l++;\\n                if(tmap.containsKey(lc) && tmap.get(lc) > smap.get(lc)){\\n                    have--;\\n                }\\n            }\\n        }\\n        return subLength==Integer.MAX_VALUE? \"\" : s.substring(sub[0], sub[1]+1);\\n    }\\n\\n "
                    },
                    {
                        "username": "isanghaessi",
                        "content": "I think I found leetcode running machine bug.\\n\\nI\\'m not sure this code would accepted.\\nBut, This code runs differently between leetocde and vscode at local.\\n  My code will print start and end point in while block. I think it must print exactly same deque variable. but, in leetcode it\\'s different.\\n  Also, I print when put some element to deque variable.\\n\\n```\\nfrom collections import *\\n\\nclass Solution:\\n    def minWindow(self, s: str, t: str) -> str:\\n        def checkAllIn(_dict):\\n            for ct in tDict:\\n                if ct not in _dict or _dict[ct] < tDict[ct]:\\n\\n                    return False\\n\\n            return True\\n\\n        \\n        result = s\\n        tDict = dict(Counter(t))\\n        toSee = deque([0])\\n        while len(toSee) > 0:\\n            print(\\'start\\', toSee)\\n            l = toSee.popleft()\\n            r = l\\n            currentDict = defaultdict(int)\\n            while r < len(s) and r + 1 - l < len(result) and not checkAllIn(currentDict):\\n                if r > l and s[r] in t and r not in toSee:\\n                    print(\\'put at up\\', r)\\n                    toSee.append(r)\\n                currentDict[s[r]] += 1\\n                r += 1\\n            if checkAllIn(currentDict) and r - l < len(result):\\n                result = s[l:r]\\n            if len(toSee) == 0 and r < len(s):\\n                print(\\'put at down\\', r)\\n                toSee.append(r)\\n            print(\\'end\\', toSee)\\n\\n        return result if checkAllIn(dict(Counter(result))) else \\'\\'\\n```\\n\\nI ran this code with first test case of this problem.\\n\\n> s = \\'ADOBECODEBANC\\'\\n> t = \\'ABC\\'\\n\\n- My vscode run with no **infinite loop**\\n\\n> start deque([0])\\nput at up 3\\nput at up 5\\nend deque([3, 5])\\nstart deque([3, 5])\\nend deque([5])\\nstart deque([5])\\nput at up 9\\nend deque([9])\\nstart deque([9])\\nput at up 10\\nput at up 12\\nend deque([10, 12])\\nstart deque([10, 12])\\nend deque([12])\\nstart deque([12])\\nend deque([])\\n\\n- but, in leetcode it falls **infinite loop**\\n\\n> start deque([0])\\nput at up 3\\nput at up 5\\nend deque([3, 5])\\nstart deque([3, 5])\\nend deque([5])\\nstart deque([5])\\nput at up 9\\nend deque([9])\\nstart deque([9])\\nput at up 10\\nput at up 12\\nend deque([10, 12])\\nstart deque([10, 12])\\nend deque([12])\\nstart deque([12])\\nend deque([])\\nstart deque([0])    <- why this element is here...?\\nput at down 0\\nend deque([0])\\nstart deque([0])\\nput at down 0\\n...\\n\\nWhat am I wrong...?"
                    },
                    {
                        "username": "jappi_jsl",
                        "content": " `\n\nclass Solution {\npublic:\n\n    bool isSame(vector<int>smap , vector<int>tmap){\n        for(int i=0;i<tmap.size();i++){\n            if(tmap[i] != smap[i]) return false;\n        }\n        return true;\n    }\n\n    string minWindow(string s, string t) {\n        string ans=\"\";\n        vector<int>smap(256,0),tmap(256,0);\n        for(auto i:t) {\n            if(i>='A' && i<='Z') tmap[i-'A']++;\n            else tmap[i-'a']++;\n        }\n        int mini = INT_MAX;\n        int i=0,j=0;\n        int n=s.length();\n        while(j<n){\n            if(s[j]>='A' && s[j]<='Z') smap[s[j]-'A']++;\n            else smap[s[j]-'a']++;\n            if(!isSame(smap,tmap)) j++;\n            else{\n                while(isSame(smap,tmap)){\n                    if(j-i+1<mini){\n                        mini=j-i+1;\n                        ans=s.substr(i,j-i+1);\n                    }\n                    if(s[i]>='A' && s[i]<='Z') smap[s[i]-'A']--;\n                    else smap[s[i]-'a']--;\n                    i++;\n                }\n                j++;\n            }\n\n        }\n        return ans;\n    }\n};\n\n`\nInput:\ns->  \"ADOBECODEBANC\"\n\nt-> \"ABC\"\n\nOutput: \"\"\n\n\nCan you Please help me to find where I'm Going wrong"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "choj",
                        "content": "An elaborate form of LC #3."
                    },
                    {
                        "username": "archerfx",
                        "content": "Not sure why I am getting TLE (for the input with large number of a's \n. Please help!\nAs far as I understand it should be (2*10^5) * 66 operations in the worst case.\n[Submission here](https://leetcode.com/problems/minimum-window-substring/submissions/861076437/) \n "
                    },
                    {
                        "username": "archerfx",
                        "content": "got it. I was making curAnsStr with every update in minimum string length. It was causing memory limit exceeded. \\n[Updated Submission here](https://leetcode.com/problems/minimum-window-substring/submissions/861092606/)"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "How the Integer object (in java) play with us!  :(\\nBE CAREFUL for object Integer, use Integer.intValue() to compare the values of Two Integer...\\n\\n Actually, In Byte range i.e. [-128,127]  two Integers compare their values. Out of this range [-128,127] ,two Integers starts comparing their references not their value. so we need intValue() function to compare when we have to compare values out of range [-128,127].\\nWhereas two int are always comparable (get compared by its value automatically)."
                    },
                    {
                        "username": "ryabkin",
                        "content": "Don't use Python's Counters, they are not optimal, for e.g. you can subtract them and check len(cs-ct) == 0"
                    },
                    {
                        "username": "Bish-AFC",
                        "content": "Best I could do, managed 264 / 266 cases but spent waaaay too long doing it. Tried without looking at any other submissions and pretty happy, though it is in terrible need of optimisation. Wasn\\'t a clean-sweep but there will always be next time."
                    },
                    {
                        "username": "Lettuce16",
                        "content": "I managed 265/266 :D However the last one is due to Time Limit :( Mine is also terrible :)"
                    }
                ]
            },
            {
                "id": 1714562,
                "content": [
                    {
                        "username": "khuzii",
                        "content": "Hello, can anybody help why this code is giving runtime error?\\nIt\\'ll be really helpful :)\\n\\n class Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        if(t.size() > s.size())  {\\n            return \"\";\\n        }\\n        map<char, int> mp;\\n        for(int i=0; i<t.size(); i++)  {\\n            mp.insert({t[i], i});\\n        }\\n        string ans;\\n        int minl= s.size()+1;\\n        string x=t;\\n        for(int i=0; i<t.size(); i++)  {\\n            x[i]=\\'#\\';\\n        }\\n        for(int i=0; i<s.size(); i++)  { \\n            string temp= \"\";\\n            string td= t;\\n            for(int j= i; j<s.size(); j++)  {\\n                if(t.find(s[j])!=string::npos && td!=x)  {\\n                    temp += s[j];\\n                    int y= td.find(s[j]);\\n                    td[y]= \\'#\\';\\n                }\\n                else if(td != x && temp.size()!=0)  {\\n                    temp += s[j];\\n                }\\n                else if(td == x)  {\\n                    if(minl > temp.size())  {\\n                        ans= temp;\\n                        minl= temp.size();\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangfred",
                        "content": "Can anyone shed a light what\\'s wrong with this solution? It passed all my local cases, but failed when submitting. The failing case is with a huge s and huge t when submitting that I cannot post here.\\n\\npublic String minWindow(String s, String t) {\\n        if(t==null || t.length()==0 || t.length() > s.length()) return \"\";\\n        Map<Character, Integer> tmap = new HashMap<>();\\n        for(char c : t.toCharArray()){\\n            tmap.merge(c, 1, (v1, v2)-> v1 + v2);\\n        }\\n\\n        Map<Character, Integer> smap = new HashMap<>();\\n        int[] sub = new int[2];\\n        int subLength = Integer.MAX_VALUE;\\n        int l=0, have = 0, need = tmap.size();\\n        for(int r=0; r<s.length(); r++){\\n            char c = s.charAt(r);\\n            smap.merge(c, 1, (v1, v2)-> v1 + v2);\\n            //find the first char\\n            if(tmap.containsKey(c) && smap.get(c)==tmap.get(c)){\\n                have++;\\n            }\\n            while(have == need){\\n                if((r-l+1) < subLength){\\n                    subLength = r-l+1;\\n                    sub[0]=l;\\n                    sub[1]=r;\\n                }\\n                char lc = s.charAt(l);\\n                smap.merge(lc, -1, (v1, v2)->v1 + v2);\\n                l++;\\n                if(tmap.containsKey(lc) && tmap.get(lc) > smap.get(lc)){\\n                    have--;\\n                }\\n            }\\n        }\\n        return subLength==Integer.MAX_VALUE? \"\" : s.substring(sub[0], sub[1]+1);\\n    }\\n\\n "
                    },
                    {
                        "username": "isanghaessi",
                        "content": "I think I found leetcode running machine bug.\\n\\nI\\'m not sure this code would accepted.\\nBut, This code runs differently between leetocde and vscode at local.\\n  My code will print start and end point in while block. I think it must print exactly same deque variable. but, in leetcode it\\'s different.\\n  Also, I print when put some element to deque variable.\\n\\n```\\nfrom collections import *\\n\\nclass Solution:\\n    def minWindow(self, s: str, t: str) -> str:\\n        def checkAllIn(_dict):\\n            for ct in tDict:\\n                if ct not in _dict or _dict[ct] < tDict[ct]:\\n\\n                    return False\\n\\n            return True\\n\\n        \\n        result = s\\n        tDict = dict(Counter(t))\\n        toSee = deque([0])\\n        while len(toSee) > 0:\\n            print(\\'start\\', toSee)\\n            l = toSee.popleft()\\n            r = l\\n            currentDict = defaultdict(int)\\n            while r < len(s) and r + 1 - l < len(result) and not checkAllIn(currentDict):\\n                if r > l and s[r] in t and r not in toSee:\\n                    print(\\'put at up\\', r)\\n                    toSee.append(r)\\n                currentDict[s[r]] += 1\\n                r += 1\\n            if checkAllIn(currentDict) and r - l < len(result):\\n                result = s[l:r]\\n            if len(toSee) == 0 and r < len(s):\\n                print(\\'put at down\\', r)\\n                toSee.append(r)\\n            print(\\'end\\', toSee)\\n\\n        return result if checkAllIn(dict(Counter(result))) else \\'\\'\\n```\\n\\nI ran this code with first test case of this problem.\\n\\n> s = \\'ADOBECODEBANC\\'\\n> t = \\'ABC\\'\\n\\n- My vscode run with no **infinite loop**\\n\\n> start deque([0])\\nput at up 3\\nput at up 5\\nend deque([3, 5])\\nstart deque([3, 5])\\nend deque([5])\\nstart deque([5])\\nput at up 9\\nend deque([9])\\nstart deque([9])\\nput at up 10\\nput at up 12\\nend deque([10, 12])\\nstart deque([10, 12])\\nend deque([12])\\nstart deque([12])\\nend deque([])\\n\\n- but, in leetcode it falls **infinite loop**\\n\\n> start deque([0])\\nput at up 3\\nput at up 5\\nend deque([3, 5])\\nstart deque([3, 5])\\nend deque([5])\\nstart deque([5])\\nput at up 9\\nend deque([9])\\nstart deque([9])\\nput at up 10\\nput at up 12\\nend deque([10, 12])\\nstart deque([10, 12])\\nend deque([12])\\nstart deque([12])\\nend deque([])\\nstart deque([0])    <- why this element is here...?\\nput at down 0\\nend deque([0])\\nstart deque([0])\\nput at down 0\\n...\\n\\nWhat am I wrong...?"
                    },
                    {
                        "username": "jappi_jsl",
                        "content": " `\n\nclass Solution {\npublic:\n\n    bool isSame(vector<int>smap , vector<int>tmap){\n        for(int i=0;i<tmap.size();i++){\n            if(tmap[i] != smap[i]) return false;\n        }\n        return true;\n    }\n\n    string minWindow(string s, string t) {\n        string ans=\"\";\n        vector<int>smap(256,0),tmap(256,0);\n        for(auto i:t) {\n            if(i>='A' && i<='Z') tmap[i-'A']++;\n            else tmap[i-'a']++;\n        }\n        int mini = INT_MAX;\n        int i=0,j=0;\n        int n=s.length();\n        while(j<n){\n            if(s[j]>='A' && s[j]<='Z') smap[s[j]-'A']++;\n            else smap[s[j]-'a']++;\n            if(!isSame(smap,tmap)) j++;\n            else{\n                while(isSame(smap,tmap)){\n                    if(j-i+1<mini){\n                        mini=j-i+1;\n                        ans=s.substr(i,j-i+1);\n                    }\n                    if(s[i]>='A' && s[i]<='Z') smap[s[i]-'A']--;\n                    else smap[s[i]-'a']--;\n                    i++;\n                }\n                j++;\n            }\n\n        }\n        return ans;\n    }\n};\n\n`\nInput:\ns->  \"ADOBECODEBANC\"\n\nt-> \"ABC\"\n\nOutput: \"\"\n\n\nCan you Please help me to find where I'm Going wrong"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "choj",
                        "content": "An elaborate form of LC #3."
                    },
                    {
                        "username": "archerfx",
                        "content": "Not sure why I am getting TLE (for the input with large number of a's \n. Please help!\nAs far as I understand it should be (2*10^5) * 66 operations in the worst case.\n[Submission here](https://leetcode.com/problems/minimum-window-substring/submissions/861076437/) \n "
                    },
                    {
                        "username": "archerfx",
                        "content": "got it. I was making curAnsStr with every update in minimum string length. It was causing memory limit exceeded. \\n[Updated Submission here](https://leetcode.com/problems/minimum-window-substring/submissions/861092606/)"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "How the Integer object (in java) play with us!  :(\\nBE CAREFUL for object Integer, use Integer.intValue() to compare the values of Two Integer...\\n\\n Actually, In Byte range i.e. [-128,127]  two Integers compare their values. Out of this range [-128,127] ,two Integers starts comparing their references not their value. so we need intValue() function to compare when we have to compare values out of range [-128,127].\\nWhereas two int are always comparable (get compared by its value automatically)."
                    },
                    {
                        "username": "ryabkin",
                        "content": "Don't use Python's Counters, they are not optimal, for e.g. you can subtract them and check len(cs-ct) == 0"
                    },
                    {
                        "username": "Bish-AFC",
                        "content": "Best I could do, managed 264 / 266 cases but spent waaaay too long doing it. Tried without looking at any other submissions and pretty happy, though it is in terrible need of optimisation. Wasn\\'t a clean-sweep but there will always be next time."
                    },
                    {
                        "username": "Lettuce16",
                        "content": "I managed 265/266 :D However the last one is due to Time Limit :( Mine is also terrible :)"
                    }
                ]
            },
            {
                "id": 1697168,
                "content": [
                    {
                        "username": "khuzii",
                        "content": "Hello, can anybody help why this code is giving runtime error?\\nIt\\'ll be really helpful :)\\n\\n class Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        if(t.size() > s.size())  {\\n            return \"\";\\n        }\\n        map<char, int> mp;\\n        for(int i=0; i<t.size(); i++)  {\\n            mp.insert({t[i], i});\\n        }\\n        string ans;\\n        int minl= s.size()+1;\\n        string x=t;\\n        for(int i=0; i<t.size(); i++)  {\\n            x[i]=\\'#\\';\\n        }\\n        for(int i=0; i<s.size(); i++)  { \\n            string temp= \"\";\\n            string td= t;\\n            for(int j= i; j<s.size(); j++)  {\\n                if(t.find(s[j])!=string::npos && td!=x)  {\\n                    temp += s[j];\\n                    int y= td.find(s[j]);\\n                    td[y]= \\'#\\';\\n                }\\n                else if(td != x && temp.size()!=0)  {\\n                    temp += s[j];\\n                }\\n                else if(td == x)  {\\n                    if(minl > temp.size())  {\\n                        ans= temp;\\n                        minl= temp.size();\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangfred",
                        "content": "Can anyone shed a light what\\'s wrong with this solution? It passed all my local cases, but failed when submitting. The failing case is with a huge s and huge t when submitting that I cannot post here.\\n\\npublic String minWindow(String s, String t) {\\n        if(t==null || t.length()==0 || t.length() > s.length()) return \"\";\\n        Map<Character, Integer> tmap = new HashMap<>();\\n        for(char c : t.toCharArray()){\\n            tmap.merge(c, 1, (v1, v2)-> v1 + v2);\\n        }\\n\\n        Map<Character, Integer> smap = new HashMap<>();\\n        int[] sub = new int[2];\\n        int subLength = Integer.MAX_VALUE;\\n        int l=0, have = 0, need = tmap.size();\\n        for(int r=0; r<s.length(); r++){\\n            char c = s.charAt(r);\\n            smap.merge(c, 1, (v1, v2)-> v1 + v2);\\n            //find the first char\\n            if(tmap.containsKey(c) && smap.get(c)==tmap.get(c)){\\n                have++;\\n            }\\n            while(have == need){\\n                if((r-l+1) < subLength){\\n                    subLength = r-l+1;\\n                    sub[0]=l;\\n                    sub[1]=r;\\n                }\\n                char lc = s.charAt(l);\\n                smap.merge(lc, -1, (v1, v2)->v1 + v2);\\n                l++;\\n                if(tmap.containsKey(lc) && tmap.get(lc) > smap.get(lc)){\\n                    have--;\\n                }\\n            }\\n        }\\n        return subLength==Integer.MAX_VALUE? \"\" : s.substring(sub[0], sub[1]+1);\\n    }\\n\\n "
                    },
                    {
                        "username": "isanghaessi",
                        "content": "I think I found leetcode running machine bug.\\n\\nI\\'m not sure this code would accepted.\\nBut, This code runs differently between leetocde and vscode at local.\\n  My code will print start and end point in while block. I think it must print exactly same deque variable. but, in leetcode it\\'s different.\\n  Also, I print when put some element to deque variable.\\n\\n```\\nfrom collections import *\\n\\nclass Solution:\\n    def minWindow(self, s: str, t: str) -> str:\\n        def checkAllIn(_dict):\\n            for ct in tDict:\\n                if ct not in _dict or _dict[ct] < tDict[ct]:\\n\\n                    return False\\n\\n            return True\\n\\n        \\n        result = s\\n        tDict = dict(Counter(t))\\n        toSee = deque([0])\\n        while len(toSee) > 0:\\n            print(\\'start\\', toSee)\\n            l = toSee.popleft()\\n            r = l\\n            currentDict = defaultdict(int)\\n            while r < len(s) and r + 1 - l < len(result) and not checkAllIn(currentDict):\\n                if r > l and s[r] in t and r not in toSee:\\n                    print(\\'put at up\\', r)\\n                    toSee.append(r)\\n                currentDict[s[r]] += 1\\n                r += 1\\n            if checkAllIn(currentDict) and r - l < len(result):\\n                result = s[l:r]\\n            if len(toSee) == 0 and r < len(s):\\n                print(\\'put at down\\', r)\\n                toSee.append(r)\\n            print(\\'end\\', toSee)\\n\\n        return result if checkAllIn(dict(Counter(result))) else \\'\\'\\n```\\n\\nI ran this code with first test case of this problem.\\n\\n> s = \\'ADOBECODEBANC\\'\\n> t = \\'ABC\\'\\n\\n- My vscode run with no **infinite loop**\\n\\n> start deque([0])\\nput at up 3\\nput at up 5\\nend deque([3, 5])\\nstart deque([3, 5])\\nend deque([5])\\nstart deque([5])\\nput at up 9\\nend deque([9])\\nstart deque([9])\\nput at up 10\\nput at up 12\\nend deque([10, 12])\\nstart deque([10, 12])\\nend deque([12])\\nstart deque([12])\\nend deque([])\\n\\n- but, in leetcode it falls **infinite loop**\\n\\n> start deque([0])\\nput at up 3\\nput at up 5\\nend deque([3, 5])\\nstart deque([3, 5])\\nend deque([5])\\nstart deque([5])\\nput at up 9\\nend deque([9])\\nstart deque([9])\\nput at up 10\\nput at up 12\\nend deque([10, 12])\\nstart deque([10, 12])\\nend deque([12])\\nstart deque([12])\\nend deque([])\\nstart deque([0])    <- why this element is here...?\\nput at down 0\\nend deque([0])\\nstart deque([0])\\nput at down 0\\n...\\n\\nWhat am I wrong...?"
                    },
                    {
                        "username": "jappi_jsl",
                        "content": " `\n\nclass Solution {\npublic:\n\n    bool isSame(vector<int>smap , vector<int>tmap){\n        for(int i=0;i<tmap.size();i++){\n            if(tmap[i] != smap[i]) return false;\n        }\n        return true;\n    }\n\n    string minWindow(string s, string t) {\n        string ans=\"\";\n        vector<int>smap(256,0),tmap(256,0);\n        for(auto i:t) {\n            if(i>='A' && i<='Z') tmap[i-'A']++;\n            else tmap[i-'a']++;\n        }\n        int mini = INT_MAX;\n        int i=0,j=0;\n        int n=s.length();\n        while(j<n){\n            if(s[j]>='A' && s[j]<='Z') smap[s[j]-'A']++;\n            else smap[s[j]-'a']++;\n            if(!isSame(smap,tmap)) j++;\n            else{\n                while(isSame(smap,tmap)){\n                    if(j-i+1<mini){\n                        mini=j-i+1;\n                        ans=s.substr(i,j-i+1);\n                    }\n                    if(s[i]>='A' && s[i]<='Z') smap[s[i]-'A']--;\n                    else smap[s[i]-'a']--;\n                    i++;\n                }\n                j++;\n            }\n\n        }\n        return ans;\n    }\n};\n\n`\nInput:\ns->  \"ADOBECODEBANC\"\n\nt-> \"ABC\"\n\nOutput: \"\"\n\n\nCan you Please help me to find where I'm Going wrong"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "choj",
                        "content": "An elaborate form of LC #3."
                    },
                    {
                        "username": "archerfx",
                        "content": "Not sure why I am getting TLE (for the input with large number of a's \n. Please help!\nAs far as I understand it should be (2*10^5) * 66 operations in the worst case.\n[Submission here](https://leetcode.com/problems/minimum-window-substring/submissions/861076437/) \n "
                    },
                    {
                        "username": "archerfx",
                        "content": "got it. I was making curAnsStr with every update in minimum string length. It was causing memory limit exceeded. \\n[Updated Submission here](https://leetcode.com/problems/minimum-window-substring/submissions/861092606/)"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "How the Integer object (in java) play with us!  :(\\nBE CAREFUL for object Integer, use Integer.intValue() to compare the values of Two Integer...\\n\\n Actually, In Byte range i.e. [-128,127]  two Integers compare their values. Out of this range [-128,127] ,two Integers starts comparing their references not their value. so we need intValue() function to compare when we have to compare values out of range [-128,127].\\nWhereas two int are always comparable (get compared by its value automatically)."
                    },
                    {
                        "username": "ryabkin",
                        "content": "Don't use Python's Counters, they are not optimal, for e.g. you can subtract them and check len(cs-ct) == 0"
                    },
                    {
                        "username": "Bish-AFC",
                        "content": "Best I could do, managed 264 / 266 cases but spent waaaay too long doing it. Tried without looking at any other submissions and pretty happy, though it is in terrible need of optimisation. Wasn\\'t a clean-sweep but there will always be next time."
                    },
                    {
                        "username": "Lettuce16",
                        "content": "I managed 265/266 :D However the last one is due to Time Limit :( Mine is also terrible :)"
                    }
                ]
            },
            {
                "id": 1655101,
                "content": [
                    {
                        "username": "khuzii",
                        "content": "Hello, can anybody help why this code is giving runtime error?\\nIt\\'ll be really helpful :)\\n\\n class Solution {\\npublic:\\n    string minWindow(string s, string t) {\\n        if(t.size() > s.size())  {\\n            return \"\";\\n        }\\n        map<char, int> mp;\\n        for(int i=0; i<t.size(); i++)  {\\n            mp.insert({t[i], i});\\n        }\\n        string ans;\\n        int minl= s.size()+1;\\n        string x=t;\\n        for(int i=0; i<t.size(); i++)  {\\n            x[i]=\\'#\\';\\n        }\\n        for(int i=0; i<s.size(); i++)  { \\n            string temp= \"\";\\n            string td= t;\\n            for(int j= i; j<s.size(); j++)  {\\n                if(t.find(s[j])!=string::npos && td!=x)  {\\n                    temp += s[j];\\n                    int y= td.find(s[j]);\\n                    td[y]= \\'#\\';\\n                }\\n                else if(td != x && temp.size()!=0)  {\\n                    temp += s[j];\\n                }\\n                else if(td == x)  {\\n                    if(minl > temp.size())  {\\n                        ans= temp;\\n                        minl= temp.size();\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangfred",
                        "content": "Can anyone shed a light what\\'s wrong with this solution? It passed all my local cases, but failed when submitting. The failing case is with a huge s and huge t when submitting that I cannot post here.\\n\\npublic String minWindow(String s, String t) {\\n        if(t==null || t.length()==0 || t.length() > s.length()) return \"\";\\n        Map<Character, Integer> tmap = new HashMap<>();\\n        for(char c : t.toCharArray()){\\n            tmap.merge(c, 1, (v1, v2)-> v1 + v2);\\n        }\\n\\n        Map<Character, Integer> smap = new HashMap<>();\\n        int[] sub = new int[2];\\n        int subLength = Integer.MAX_VALUE;\\n        int l=0, have = 0, need = tmap.size();\\n        for(int r=0; r<s.length(); r++){\\n            char c = s.charAt(r);\\n            smap.merge(c, 1, (v1, v2)-> v1 + v2);\\n            //find the first char\\n            if(tmap.containsKey(c) && smap.get(c)==tmap.get(c)){\\n                have++;\\n            }\\n            while(have == need){\\n                if((r-l+1) < subLength){\\n                    subLength = r-l+1;\\n                    sub[0]=l;\\n                    sub[1]=r;\\n                }\\n                char lc = s.charAt(l);\\n                smap.merge(lc, -1, (v1, v2)->v1 + v2);\\n                l++;\\n                if(tmap.containsKey(lc) && tmap.get(lc) > smap.get(lc)){\\n                    have--;\\n                }\\n            }\\n        }\\n        return subLength==Integer.MAX_VALUE? \"\" : s.substring(sub[0], sub[1]+1);\\n    }\\n\\n "
                    },
                    {
                        "username": "isanghaessi",
                        "content": "I think I found leetcode running machine bug.\\n\\nI\\'m not sure this code would accepted.\\nBut, This code runs differently between leetocde and vscode at local.\\n  My code will print start and end point in while block. I think it must print exactly same deque variable. but, in leetcode it\\'s different.\\n  Also, I print when put some element to deque variable.\\n\\n```\\nfrom collections import *\\n\\nclass Solution:\\n    def minWindow(self, s: str, t: str) -> str:\\n        def checkAllIn(_dict):\\n            for ct in tDict:\\n                if ct not in _dict or _dict[ct] < tDict[ct]:\\n\\n                    return False\\n\\n            return True\\n\\n        \\n        result = s\\n        tDict = dict(Counter(t))\\n        toSee = deque([0])\\n        while len(toSee) > 0:\\n            print(\\'start\\', toSee)\\n            l = toSee.popleft()\\n            r = l\\n            currentDict = defaultdict(int)\\n            while r < len(s) and r + 1 - l < len(result) and not checkAllIn(currentDict):\\n                if r > l and s[r] in t and r not in toSee:\\n                    print(\\'put at up\\', r)\\n                    toSee.append(r)\\n                currentDict[s[r]] += 1\\n                r += 1\\n            if checkAllIn(currentDict) and r - l < len(result):\\n                result = s[l:r]\\n            if len(toSee) == 0 and r < len(s):\\n                print(\\'put at down\\', r)\\n                toSee.append(r)\\n            print(\\'end\\', toSee)\\n\\n        return result if checkAllIn(dict(Counter(result))) else \\'\\'\\n```\\n\\nI ran this code with first test case of this problem.\\n\\n> s = \\'ADOBECODEBANC\\'\\n> t = \\'ABC\\'\\n\\n- My vscode run with no **infinite loop**\\n\\n> start deque([0])\\nput at up 3\\nput at up 5\\nend deque([3, 5])\\nstart deque([3, 5])\\nend deque([5])\\nstart deque([5])\\nput at up 9\\nend deque([9])\\nstart deque([9])\\nput at up 10\\nput at up 12\\nend deque([10, 12])\\nstart deque([10, 12])\\nend deque([12])\\nstart deque([12])\\nend deque([])\\n\\n- but, in leetcode it falls **infinite loop**\\n\\n> start deque([0])\\nput at up 3\\nput at up 5\\nend deque([3, 5])\\nstart deque([3, 5])\\nend deque([5])\\nstart deque([5])\\nput at up 9\\nend deque([9])\\nstart deque([9])\\nput at up 10\\nput at up 12\\nend deque([10, 12])\\nstart deque([10, 12])\\nend deque([12])\\nstart deque([12])\\nend deque([])\\nstart deque([0])    <- why this element is here...?\\nput at down 0\\nend deque([0])\\nstart deque([0])\\nput at down 0\\n...\\n\\nWhat am I wrong...?"
                    },
                    {
                        "username": "jappi_jsl",
                        "content": " `\n\nclass Solution {\npublic:\n\n    bool isSame(vector<int>smap , vector<int>tmap){\n        for(int i=0;i<tmap.size();i++){\n            if(tmap[i] != smap[i]) return false;\n        }\n        return true;\n    }\n\n    string minWindow(string s, string t) {\n        string ans=\"\";\n        vector<int>smap(256,0),tmap(256,0);\n        for(auto i:t) {\n            if(i>='A' && i<='Z') tmap[i-'A']++;\n            else tmap[i-'a']++;\n        }\n        int mini = INT_MAX;\n        int i=0,j=0;\n        int n=s.length();\n        while(j<n){\n            if(s[j]>='A' && s[j]<='Z') smap[s[j]-'A']++;\n            else smap[s[j]-'a']++;\n            if(!isSame(smap,tmap)) j++;\n            else{\n                while(isSame(smap,tmap)){\n                    if(j-i+1<mini){\n                        mini=j-i+1;\n                        ans=s.substr(i,j-i+1);\n                    }\n                    if(s[i]>='A' && s[i]<='Z') smap[s[i]-'A']--;\n                    else smap[s[i]-'a']--;\n                    i++;\n                }\n                j++;\n            }\n\n        }\n        return ans;\n    }\n};\n\n`\nInput:\ns->  \"ADOBECODEBANC\"\n\nt-> \"ABC\"\n\nOutput: \"\"\n\n\nCan you Please help me to find where I'm Going wrong"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "choj",
                        "content": "An elaborate form of LC #3."
                    },
                    {
                        "username": "archerfx",
                        "content": "Not sure why I am getting TLE (for the input with large number of a's \n. Please help!\nAs far as I understand it should be (2*10^5) * 66 operations in the worst case.\n[Submission here](https://leetcode.com/problems/minimum-window-substring/submissions/861076437/) \n "
                    },
                    {
                        "username": "archerfx",
                        "content": "got it. I was making curAnsStr with every update in minimum string length. It was causing memory limit exceeded. \\n[Updated Submission here](https://leetcode.com/problems/minimum-window-substring/submissions/861092606/)"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "How the Integer object (in java) play with us!  :(\\nBE CAREFUL for object Integer, use Integer.intValue() to compare the values of Two Integer...\\n\\n Actually, In Byte range i.e. [-128,127]  two Integers compare their values. Out of this range [-128,127] ,two Integers starts comparing their references not their value. so we need intValue() function to compare when we have to compare values out of range [-128,127].\\nWhereas two int are always comparable (get compared by its value automatically)."
                    },
                    {
                        "username": "ryabkin",
                        "content": "Don't use Python's Counters, they are not optimal, for e.g. you can subtract them and check len(cs-ct) == 0"
                    },
                    {
                        "username": "Bish-AFC",
                        "content": "Best I could do, managed 264 / 266 cases but spent waaaay too long doing it. Tried without looking at any other submissions and pretty happy, though it is in terrible need of optimisation. Wasn\\'t a clean-sweep but there will always be next time."
                    },
                    {
                        "username": "Lettuce16",
                        "content": "I managed 265/266 :D However the last one is due to Time Limit :( Mine is also terrible :)"
                    }
                ]
            }
        ]
    }
]