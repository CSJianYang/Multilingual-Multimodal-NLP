[
    {
        "title": "Determine the Winner of a Bowling Game",
        "question_content": "You are given two 0-indexed integer arrays player1 and player2, that represent the number of pins that player 1 and player 2 hit in a bowling game, respectively.\nThe bowling game consists of n turns, and the number of pins in each turn is exactly 10.\nAssume a player hit xi pins in the ith turn. The value of the ith turn for the player is:\n\n\t2xi if the player hit 10 pins in any of the previous two turns.\n\tOtherwise, It is xi.\n\nThe score of the player is the sum of the values of their n turns.\nReturn\n\n\t1 if the score of player 1 is more than the score of player 2,\n\t2 if the score of player 2 is more than the score of player 1, and\n\t0 in case of a draw.\n\n&nbsp;\nExample 1:\n\nInput: player1 = [4,10,7,9], player2 = [6,5,2,3]\nOutput: 1\nExplanation: The score of player1 is 4 + 10 + 2*7 + 2*9 = 46.\nThe score of player2 is 6 + 5 + 2 + 3 = 16.\nScore of player1 is more than the score of player2, so, player1 is the winner, and the answer is 1.\n\nExample 2:\n\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\nOutput: 2\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\n\nExample 3:\n\nInput: player1 = [2,3], player2 = [4,1]\nOutput: 0\nExplanation: The score of player1 is 2 + 3 = 5\nThe score of player2 is 4 + 1 = 5\nThe score of player1 equals to the score of player2, so, there is a draw, and the answer is 0.\n\n&nbsp;\nConstraints:\n\n\tn == player1.length == player2.length\n\t1 <= n <= 1000\n\t0 <= player1[i], player2[i] <= 10",
        "solutions": [
            {
                "id": 3468463,
                "title": "explained-very-simple-easy-to-understand-solution",
                "content": "<b>Up vote if you like the solution</b>\\n# Approach\\n1. When ever we see a 10 update flag to 2 and keep decrementing it from next time.\\n2. When ever the flag is non zero then add the value with 2x ohterwise simply add it as it is.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getScore(vector<int>& player){\\n        int s = 0, f = 0;\\n        for(auto p:player){\\n            s += (f > 0)? 2*p: p;\\n            f--;\\n            if(p == 10) f = 2;\\n        }\\n        return s;\\n    }\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int s1 = getScore(player1), s2 = getScore(player2);\\n        if(s1 > s2) return 1;\\n        if(s1 < s2) return 2;\\n        return 0;\\n    }\\n};\\n```\\n<b>Here is an article of my recent interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getScore(vector<int>& player){\\n        int s = 0, f = 0;\\n        for(auto p:player){\\n            s += (f > 0)? 2*p: p;\\n            f--;\\n            if(p == 10) f = 2;\\n        }\\n        return s;\\n    }\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int s1 = getScore(player1), s2 = getScore(player2);\\n        if(s1 > s2) return 1;\\n        if(s1 < s2) return 2;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468269,
                "title": "day-395-easy-100-0ms-python-java-c-explained-approach",
                "content": "# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\n##### \\u2022\\tWe first initialize ans, s1, and  s2 to 0.  Ans will store the winner of the game, and  s1 and  s2 will store the total scores of players 1 and 2, respectively.\\n##### \\u2022\\tWe compute the total scores of players 1 and 2 by iterating over the elements of  p1 and  p2 and adding them to  s1 and  s2 , respectively.\\n##### \\u2022\\tIf the length of  p1   is greater than 1, we iterate over the elements of p1 and  p2 again, starting from the second element. For each element, we check if the previous element was a strike (score of 10) or a spare (sum of the previous two scores is 10). If either of these conditions is true, we add the current score to the total score of the corresponding player.\\n##### \\u2022\\tWe then compare the total scores of players 1 and 2. If they are equal, we set  ans  to 0, indicating a tie. If the total score of player 1 is greater than that of player 2, we set ans to 1, indicating that player 1 is the winner. Otherwise, we set  ans to 2, indicating that player 2 is the winner.\\n##### \\u2022\\tWe return  ans.\\n##### \\u2022\\tThe intuition behind this approach is that we can compute the total scores of players 1 and 2 by simply adding up the scores in their respective arrays. However, in the case of strikes and spares, the score of the current frame depends on the scores of the previous frames. Therefore, we need to iterate over the arrays again and adjust the scores accordingly. Once we have the total scores of both players, we can compare them to determine the winner of the game.\\n\\n\\n\\n# Complexity\\n- Time complexity:o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java []\\n    public int isWinner(int[] p1, int[] p2) {\\n        int ans=0,s1=0,s2=0;\\n        int n=p1.length;\\n       for(int i=0;i<n;i++){\\n               s1+=p1[i];\\n               s2+=p2[i];\\n           }\\n        if(n>1) {\\n            for(int i=1;i<n;i++){\\n                if(p1[i-1]==10 ||((i>=2) && p1[i-2]==10))s1+=p1[i];\\n                if(p2[i-1]==10 ||((i>=2)&& p2[i-2]==10))s2+=p2[i];\\n            }\\n        }\\n        if(s1==s2) ans= 0;\\n        else if(s1>s2) ans= 1;\\n        else ans= 2;\\n        return ans;\\n        \\n    }\\n```\\n\\n```python []\\ndef isWinner(p1: List[int], p2: List[int]) -> int:\\n    ans, s1, s2 = 0, 0, 0\\n    n = len(p1)\\n    for i in range(n):\\n        s1 += p1[i]\\n        s2 += p2[i]\\n    if n > 1:\\n        for i in range(1, n):\\n            if p1[i - 1] == 10 or ((i >= 2) and p1[i - 2] == 10):\\n                s1 += p1[i]\\n            if p2[i - 1] == 10 or ((i >= 2) and p2[i - 2] == 10):\\n                s2 += p2[i]\\n    if s1 == s2:\\n        ans = 0\\n    elif s1 > s2:\\n        ans = 1\\n    else:\\n        ans = 2\\n    return ans\\n```\\n\\n```c++ []\\nint isWinner(vector<int>& p1, vector<int>& p2) {\\n    int ans = 0, s1 = 0, s2 = 0;\\n    int n = p1.size();\\n    for (int i = 0; i < n; i++) {\\n        s1 += p1[i];\\n        s2 += p2[i];\\n    }\\n    if (n > 1) {\\n        for (int i = 1; i < n; i++) {\\n            if (p1[i - 1] == 10 || ((i >= 2) && p1[i - 2] == 10)) {\\n                s1 += p1[i];\\n            }\\n            if (p2[i - 1] == 10 || ((i >= 2) && p2[i - 2] == 10)) {\\n                s2 += p2[i];\\n            }\\n        }\\n    }\\n    if (s1 == s2) {\\n        ans = 0;\\n    } else if (s1 > s2) {\\n        ans = 1;\\n    } else {\\n        ans = 2;\\n    }\\n    return ans;\\n}\\n```\\n# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n\\n![BREUSELEE.webp](https://assets.leetcode.com/users/images/062630f0-ef80-4e74-abdb-302827b99235_1680054012.5054147.webp)\\n![image.png](https://assets.leetcode.com/users/images/303fa18d-281d-49f0-87ef-1a018fc9a488_1681355186.0923774.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```java []\\n    public int isWinner(int[] p1, int[] p2) {\\n        int ans=0,s1=0,s2=0;\\n        int n=p1.length;\\n       for(int i=0;i<n;i++){\\n               s1+=p1[i];\\n               s2+=p2[i];\\n           }\\n        if(n>1) {\\n            for(int i=1;i<n;i++){\\n                if(p1[i-1]==10 ||((i>=2) && p1[i-2]==10))s1+=p1[i];\\n                if(p2[i-1]==10 ||((i>=2)&& p2[i-2]==10))s2+=p2[i];\\n            }\\n        }\\n        if(s1==s2) ans= 0;\\n        else if(s1>s2) ans= 1;\\n        else ans= 2;\\n        return ans;\\n        \\n    }\\n```\n```python []\\ndef isWinner(p1: List[int], p2: List[int]) -> int:\\n    ans, s1, s2 = 0, 0, 0\\n    n = len(p1)\\n    for i in range(n):\\n        s1 += p1[i]\\n        s2 += p2[i]\\n    if n > 1:\\n        for i in range(1, n):\\n            if p1[i - 1] == 10 or ((i >= 2) and p1[i - 2] == 10):\\n                s1 += p1[i]\\n            if p2[i - 1] == 10 or ((i >= 2) and p2[i - 2] == 10):\\n                s2 += p2[i]\\n    if s1 == s2:\\n        ans = 0\\n    elif s1 > s2:\\n        ans = 1\\n    else:\\n        ans = 2\\n    return ans\\n```\n```c++ []\\nint isWinner(vector<int>& p1, vector<int>& p2) {\\n    int ans = 0, s1 = 0, s2 = 0;\\n    int n = p1.size();\\n    for (int i = 0; i < n; i++) {\\n        s1 += p1[i];\\n        s2 += p2[i];\\n    }\\n    if (n > 1) {\\n        for (int i = 1; i < n; i++) {\\n            if (p1[i - 1] == 10 || ((i >= 2) && p1[i - 2] == 10)) {\\n                s1 += p1[i];\\n            }\\n            if (p2[i - 1] == 10 || ((i >= 2) && p2[i - 2] == 10)) {\\n                s2 += p2[i];\\n            }\\n        }\\n    }\\n    if (s1 == s2) {\\n        ans = 0;\\n    } else if (s1 > s2) {\\n        ans = 1;\\n    } else {\\n        ans = 2;\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3468263,
                "title": "short-simple-clean-java-solution",
                "content": "\\n```java []\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int p1 = 0, p2 = 0;\\n        for(int i=0; i<player1.length; i++){\\n            if((i == 1 && player1[i-1] == 10) || (i >= 2 && (player1[i-1] == 10 || player1[i-2] == 10)))    p1 += player1[i];\\n            if((i == 1 && player2[i-1] == 10) || (i >= 2 && (player2[i-1] == 10 || player2[i-2] == 10)))    p2 += player2[i];\\n            p1 += player1[i];\\n            p2 += player2[i];\\n        }\\n        return p1 == p2 ? 0 : p1 > p2 ? 1 : 2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int p1 = 0, p2 = 0;\\n        for(int i=0; i<player1.length; i++){\\n            if((i == 1 && player1[i-1] == 10) || (i >= 2 && (player1[i-1] == 10 || player1[i-2] == 10)))    p1 += player1[i];\\n            if((i == 1 && player2[i-1] == 10) || (i >= 2 && (player2[i-1] == 10 || player2[i-2] == 10)))    p2 += player2[i];\\n            p1 += player1[i];\\n            p2 += player2[i];\\n        }\\n        return p1 == p2 ? 0 : p1 > p2 ? 1 : 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470369,
                "title": "python-3-6-lines-w-explanation-t-m-99-93",
                "content": "Here\\'s the intuition:\\nWe don\\'t care about the actual scores, just which player wins. We keep track of the accumulated difference on each round. We use booleans to remember whether either of the two previous rounds were strikes.\\n\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n\\n        isTen1 = isTen2 = wasTen1 = wasTen2 = False\\n        diff = 0\\n\\n        for n1, n2 in zip(player1, player2):\\n\\n            diff+= (1+(wasTen1|isTen1))*n1 - (1+(wasTen2|isTen2))*n2\\n \\n            isTen1,isTen2, wasTen1, wasTen2 = n1 == 10, n2 == 10,isTen1,isTen2 \\n\\n        return  (diff < 0) + (diff != 0)\\n```\\n[https://leetcode.com/problems/determine-the-winner-of-a-bowling-game/submissions/945548312/](http://)\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1).\\n\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n\\n        isTen1 = isTen2 = wasTen1 = wasTen2 = False\\n        diff = 0\\n\\n        for n1, n2 in zip(player1, player2):\\n\\n            diff+= (1+(wasTen1|isTen1))*n1 - (1+(wasTen2|isTen2))*n2\\n \\n            isTen1,isTen2, wasTen1, wasTen2 = n1 == 10, n2 == 10,isTen1,isTen2 \\n\\n        return  (diff < 0) + (diff != 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468294,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int n1=player1.size(),n2=player2.size(),ans1=0,ans2=0,x1=0,x2=0;\\n        \\n        for(int i=0;i<n1;i++){\\n            ans1+=player1[i];\\n            ans2+=player2[i];\\n            \\n            if(x1){\\n                x1--;\\n                ans1+=player1[i];\\n            }\\n            if(x2){\\n                x2--;\\n                ans2+=player2[i];\\n            }\\n            if(player1[i] == 10){\\n                x1=2;\\n            }\\n            if(player2[i] == 10){\\n                x2=2; \\n            }\\n        }\\n        if(ans1 > ans2)\\n            return 1;\\n        else if(ans1 < ans2)\\n            return 2;\\n        else\\n            return 0;\\n    }\\n};\\n```\\n\\n\\n\\nPlease Upvote if it helps :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int n1=player1.size(),n2=player2.size(),ans1=0,ans2=0,x1=0,x2=0;\\n        \\n        for(int i=0;i<n1;i++){\\n            ans1+=player1[i];\\n            ans2+=player2[i];\\n            \\n            if(x1){\\n                x1--;\\n                ans1+=player1[i];\\n            }\\n            if(x2){\\n                x2--;\\n                ans2+=player2[i];\\n            }\\n            if(player1[i] == 10){\\n                x1=2;\\n            }\\n            if(player2[i] == 10){\\n                x2=2; \\n            }\\n        }\\n        if(ans1 > ans2)\\n            return 1;\\n        else if(ans1 < ans2)\\n            return 2;\\n        else\\n            return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468280,
                "title": "easy-solution-python",
                "content": "**Python**\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        Stack_A = []\\n        stack_B = []\\n        aScore = 0\\n        bScore = 0\\n        for n,m in zip(player1,player2):\\n        \\n            if 10 in Stack_A[-2:]:\\n                aScore += 2*n\\n            else:\\n                aScore += n\\n            \\n            if 10 in stack_B[-2:]:\\n                bScore += 2*m\\n            else:\\n                bScore += m\\n            Stack_A.append(n)\\n            stack_B.append(m)\\n                \\n        if aScore == bScore:return 0\\n        return 1 if aScore > bScore else 2\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        Stack_A = []\\n        stack_B = []\\n        aScore = 0\\n        bScore = 0\\n        for n,m in zip(player1,player2):\\n        \\n            if 10 in Stack_A[-2:]:\\n                aScore += 2*n\\n            else:\\n                aScore += n\\n            \\n            if 10 in stack_B[-2:]:\\n                bScore += 2*m\\n            else:\\n                bScore += m\\n            Stack_A.append(n)\\n            stack_B.append(m)\\n                \\n        if aScore == bScore:return 0\\n        return 1 if aScore > bScore else 2\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468389,
                "title": "simplest-solution-just-do-what-is-asked",
                "content": "**Approach-->**\\n\\n**First loop** : just calculate player1 score by iterating and if previous 2 turns we get >=10 then multiply by2\\n**Second loop**: same for player 2\\n\\n##### NOTE: just done what is asked in problem \\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n    int o=0,t=0;\\n    \\n        for(int i=0;i<player1.size();i++){\\n            \\n            if(i>=1 and player1[i-1]>=10) o+=2*player1[i];  // just checking previous turn for 10 or greater\\n            else if(i>=2 and (player1[i-1]>=10 or player1[i-2]>=10)) o+=2*player1[i]; // checking previous 2 turn for a 10 or greater\\n            else o+=player1[i];   // else add that value\\n        }\\n     for(int i=0;i<player2.size();i++){\\n            \\n         if(i>=1 and player2[i-1]>=10) t+=2*player2[i];\\n           else if(i>=2 and (player2[i-1]>=10 or player2[i-2]>=10)) t+=2*player2[i];\\n            else t+=player2[i];\\n        }\\n    if(o>t) return 1;\\n    else if(t>o) return 2;\\n    else return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n    int o=0,t=0;\\n    \\n        for(int i=0;i<player1.size();i++){\\n            \\n            if(i>=1 and player1[i-1]>=10) o+=2*player1[i];  // just checking previous turn for 10 or greater\\n            else if(i>=2 and (player1[i-1]>=10 or player1[i-2]>=10)) o+=2*player1[i]; // checking previous 2 turn for a 10 or greater\\n            else o+=player1[i];   // else add that value\\n        }\\n     for(int i=0;i<player2.size();i++){\\n            \\n         if(i>=1 and player2[i-1]>=10) t+=2*player2[i];\\n           else if(i>=2 and (player2[i-1]>=10 or player2[i-2]>=10)) t+=2*player2[i];\\n            else t+=player2[i];\\n        }\\n    if(o>t) return 1;\\n    else if(t>o) return 2;\\n    else return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468311,
                "title": "c-solution-with-2-solutions",
                "content": "\\n\\n# first approach \\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int a = player1.size(), b = player2.size();\\n        \\n        int first = 0, second = 0, count = 0, i = 0;\\n        while (i < a) {\\n            if (player1[i] == 10) {\\n                count = 2;\\n                first += player1[i];\\n                i++;\\n                while (count != 0 && i < a) {\\n                    first += (2 * player1[i]);\\n                    count--;\\n                    if (player1[i] == 10) count = 2;\\n                    i++;\\n                }\\n            }\\n            else {\\n                first += player1[i];\\n                i++;\\n            }\\n        }\\n        \\n        i = 0;\\n        count = 0;\\n        while (i < b) {\\n            if (player2[i] == 10) {\\n                count = 2;\\n                second += player2[i];\\n                i++;\\n                while (count != 0 && i < b) {\\n                    second += (2 * player2[i]);\\n                    count--;\\n                    if (player2[i] == 10) count = 2;\\n                    i++;\\n                }\\n            }\\n            else {\\n                second += player2[i];\\n                i++;\\n            }\\n        }\\n        \\n        if (first > second) return 1;\\n        else if (first < second) return 2;\\n        else return 0;\\n    }\\n};\\n\\n```\\n# second approach \\n```\\n\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        if(player1.size() == 1) {\\n        if(player1[0] == player2[0]) {\\n            return 0;\\n        }\\n        return player1[0] > player2[0] ? 1 : 2;\\n    }\\n\\n    int sum1 = 0;\\n    int sum2 = 0;\\n\\n    sum1 += player1[0];\\n    sum2 += player2[0];\\n\\n    if(player1[0] == 10) {\\n        sum1 += (2 * player1[1]);\\n    } else {\\n        sum1 += player1[1];\\n    }\\n\\n    if(player2[0] == 10) {\\n        sum2 += (2 * player2[1]);\\n    } else {\\n        sum2 += player2[1];\\n    }\\n\\n    for(int i = 2; i < length; i++) {\\n        if(player1[i-1] == 10 || player1[i-2] == 10) {\\n            sum1 += (2 * player1[i]);\\n        } else {\\n            sum1 += player1[i];\\n        }\\n\\n        if(player2[i-1] == 10 || player2[i-2] == 10) {\\n            sum2 += (2 * player2[i]);\\n        } else {\\n            sum2 += player2[i];\\n        }\\n    }\\n\\n    if(sum1 == sum2) {\\n        return 0;\\n    }\\n\\n    return sum1 > sum2 ? 1 : 2;\\n}",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int a = player1.size(), b = player2.size();\\n        \\n        int first = 0, second = 0, count = 0, i = 0;\\n        while (i < a) {\\n            if (player1[i] == 10) {\\n                count = 2;\\n                first += player1[i];\\n                i++;\\n                while (count != 0 && i < a) {\\n                    first += (2 * player1[i]);\\n                    count--;\\n                    if (player1[i] == 10) count = 2;\\n                    i++;\\n                }\\n            }\\n            else {\\n                first += player1[i];\\n                i++;\\n            }\\n        }\\n        \\n        i = 0;\\n        count = 0;\\n        while (i < b) {\\n            if (player2[i] == 10) {\\n                count = 2;\\n                second += player2[i];\\n                i++;\\n                while (count != 0 && i < b) {\\n                    second += (2 * player2[i]);\\n                    count--;\\n                    if (player2[i] == 10) count = 2;\\n                    i++;\\n                }\\n            }\\n            else {\\n                second += player2[i];\\n                i++;\\n            }\\n        }\\n        \\n        if (first > second) return 1;\\n        else if (first < second) return 2;\\n        else return 0;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468249,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int sum1=0,sum2=0;\\n        for(int i=0;i<player1.length;i++)\\n        {\\n            if(i==1)\\n            {\\n                if(player1[i-1]==10)\\n                {\\n                    sum1+=(2*player1[i]);\\n                }\\n                else\\n                {\\n                    sum1+=player1[i];\\n                }\\n            }\\n            else if(i>1)\\n            {\\n                if(player1[i-1]==10 || player1[i-2]==10)\\n                {\\n                    sum1+=(2*player1[i]);\\n                }\\n                else\\n                {\\n                    sum1+=player1[i];\\n                }\\n            }\\n            else\\n            {\\n                sum1+=player1[i];\\n            }\\n        }\\n        for(int i=0;i<player1.length;i++)\\n        {\\n            if(i==1)\\n            {\\n                if(player2[i-1]==10)\\n                {\\n                    sum2+=(2*player2[i]);\\n                }\\n                else\\n                {\\n                    sum2+=player2[i];\\n                }\\n            }\\n            else if(i>1)\\n            {\\n                if(player2[i-1]==10 || player2[i-2]==10)\\n                {\\n                    sum2+=(2*player2[i]);\\n                }\\n                else\\n                {\\n                    sum2+=player2[i];\\n                }\\n            }\\n            else\\n            {\\n                sum2+=player2[i];\\n            }\\n        }\\n        return sum1>sum2 ? 1 : sum2>sum1 ? 2 : 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int sum1=0,sum2=0;\\n        for(int i=0;i<player1.length;i++)\\n        {\\n            if(i==1)\\n            {\\n                if(player1[i-1]==10)\\n                {\\n                    sum1+=(2*player1[i]);\\n                }\\n                else\\n                {\\n                    sum1+=player1[i];\\n                }\\n            }\\n            else if(i>1)\\n            {\\n                if(player1[i-1]==10 || player1[i-2]==10)\\n                {\\n                    sum1+=(2*player1[i]);\\n                }\\n                else\\n                {\\n                    sum1+=player1[i];\\n                }\\n            }\\n            else\\n            {\\n                sum1+=player1[i];\\n            }\\n        }\\n        for(int i=0;i<player1.length;i++)\\n        {\\n            if(i==1)\\n            {\\n                if(player2[i-1]==10)\\n                {\\n                    sum2+=(2*player2[i]);\\n                }\\n                else\\n                {\\n                    sum2+=player2[i];\\n                }\\n            }\\n            else if(i>1)\\n            {\\n                if(player2[i-1]==10 || player2[i-2]==10)\\n                {\\n                    sum2+=(2*player2[i]);\\n                }\\n                else\\n                {\\n                    sum2+=player2[i];\\n                }\\n            }\\n            else\\n            {\\n                sum2+=player2[i];\\n            }\\n        }\\n        return sum1>sum2 ? 1 : sum2>sum1 ? 2 : 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471140,
                "title": "strike",
                "content": "It would be more interesting to implement the real bowling scoring.\\n\\n**C++**\\n```cpp\\nint score(vector<int>& pins, int strike = 0) {\\n    return accumulate(begin(pins), end(pins), 0, [&](int res, int p){\\n        res += p * (strike > 0 ? 2 : 1);\\n        strike = p == 10 ? 2 : strike - 1;\\n        return res;\\n    });\\n}\\nint isWinner(vector<int>& player1, vector<int>& player2) {\\n    int s1 = score(player1), s2 = score(player2);\\n    return s1 > s2 ? 1 : s1 < s2 ? 2 : 0;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint score(vector<int>& pins, int strike = 0) {\\n    return accumulate(begin(pins), end(pins), 0, [&](int res, int p){\\n        res += p * (strike > 0 ? 2 : 1);\\n        strike = p == 10 ? 2 : strike - 1;\\n        return res;\\n    });\\n}\\nint isWinner(vector<int>& player1, vector<int>& player2) {\\n    int s1 = score(player1), s2 = score(player2);\\n    return s1 > s2 ? 1 : s1 < s2 ? 2 : 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3470681,
                "title": "beats-100-in-runtime-and-space-solution-in-java-simple-and-easy",
                "content": "![image.png](https://assets.leetcode.com/users/images/6c7c44b5-f7d2-4821-ad7e-687f9f08cf6f_1682875832.839368.png)\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int sum1=player1[0], sum2=player2[0];\\n        for(int i=1; i<player1.length; i++){\\n            if(i==1){\\n                if(player1[i-1]==10) sum1+=2*player1[i];\\n                else sum1+=player1[i];\\n                \\n                if(player2[i-1]==10) sum2+=2*player2[i];\\n                else sum2+=player2[i];\\n            }\\n            else{\\n                if(player1[i-1]==10 || player1[i-2]==10) sum1+=2*player1[i];\\n                else sum1+=player1[i];\\n                \\n                if(player2[i-1]==10 || player2[i-2]==10) sum2+=2*player2[i];\\n                else sum2+=player2[i];\\n            }      \\n        }\\n        if(sum2>sum1) return 2;\\n        else if(sum1>sum2) return 1;\\n        return 0;\\n    }\\n}\\n```\\n![image.png](https://assets.leetcode.com/users/images/0c40297b-fcdb-42e1-9a4e-b8b80120f9ee_1682876025.9059646.png)\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int sum1=player1[0], sum2=player2[0];\\n        for(int i=1; i<player1.length; i++){\\n            if(i==1){\\n                if(player1[i-1]==10) sum1+=2*player1[i];\\n                else sum1+=player1[i];\\n                \\n                if(player2[i-1]==10) sum2+=2*player2[i];\\n                else sum2+=player2[i];\\n            }\\n            else{\\n                if(player1[i-1]==10 || player1[i-2]==10) sum1+=2*player1[i];\\n                else sum1+=player1[i];\\n                \\n                if(player2[i-1]==10 || player2[i-2]==10) sum2+=2*player2[i];\\n                else sum2+=player2[i];\\n            }      \\n        }\\n        if(sum2>sum1) return 2;\\n        else if(sum1>sum2) return 1;\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469164,
                "title": "easy-to-understand-beginner-friendly-code",
                "content": "# Intuition \\n\\nBrute force thinking simply did what question asked step by step\\n\\n# Approach \\nAt each index we know score has to be added atleast one time so increase the score of player by the value. Then check if any of the previous 2 value of a player is 10 then again add the value in his total score.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int n=player1.size();\\n        int score1=player1[0];\\n        int score2=player2[0];\\n        for(int i=1;i<n;i++){\\n            score1+=player1[i];\\n            score2+=player2[i];\\n            if(i==1){\\n                if( player1[0]==10) score1+=player1[1];         \\n                if(player2[0]==10) score2+=player2[1];          \\n            }\\n            else{\\n                if(player1[i-1]==10 || player1[i-2]==10){\\n                    score1+=player1[i];\\n                }\\n                if(player2[i-1]==10 || player2[i-2]==10){\\n                    score2+=player2[i];\\n                }\\n            }\\n        }\\n        if(score1==score2)return 0;\\n        else if(score1>score2) return 1;\\n        else return 2;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int n=player1.size();\\n        int score1=player1[0];\\n        int score2=player2[0];\\n        for(int i=1;i<n;i++){\\n            score1+=player1[i];\\n            score2+=player2[i];\\n            if(i==1){\\n                if( player1[0]==10) score1+=player1[1];         \\n                if(player2[0]==10) score2+=player2[1];          \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3469116,
                "title": "c-o-n-solution",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& p1, vector<int>& p2) {\\n        int a = 0, b = 0;\\n        for(int i = 0; i < p1.size(); i++) {\\n            if(i == 0) {\\n                a += p1[i];\\n                b += p2[i];\\n            }\\n            else {\\n                if(i == 1) {\\n                    if(p1[i - 1] == 10) a += (2 * p1[i]);\\n                    else a += p1[i];\\n                    if(p2[i - 1] == 10) b += (2 * p2[i]);\\n                    else b += p2[i];\\n                }\\n                else {\\n                    if(p1[i - 1] == 10 || p1[i - 2] == 10) a += (2 * p1[i]);\\n                    else a += p1[i];\\n                    if(p2[i - 1] == 10 || p2[i - 2] == 10) b += (2 * p2[i]);\\n                    else b += p2[i];\\n                }\\n            }\\n        }\\n        if(a > b) return 1;\\n        if(a < b) return 2;\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& p1, vector<int>& p2) {\\n        int a = 0, b = 0;\\n        for(int i = 0; i < p1.size(); i++) {\\n            if(i == 0) {\\n                a += p1[i];\\n                b += p2[i];\\n            }\\n            else {\\n                if(i == 1) {\\n                    if(p1[i - 1] == 10) a += (2 * p1[i]);\\n                    else a += p1[i];\\n                    if(p2[i - 1] == 10) b += (2 * p2[i]);\\n                    else b += p2[i];\\n                }\\n                else {\\n                    if(p1[i - 1] == 10 || p1[i - 2] == 10) a += (2 * p1[i]);\\n                    else a += p1[i];\\n                    if(p2[i - 1] == 10 || p2[i - 2] == 10) b += (2 * p2[i]);\\n                    else b += p2[i];\\n                }\\n            }\\n        }\\n        if(a > b) return 1;\\n        if(a < b) return 2;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468312,
                "title": "java-simple-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int isWinner(int[] player1, int[] player2) {\\n    int n = player1.length, p1, p2;\\n    \\n    for (var i=0; i<n; i++) {\\n      p1 += player1[i];\\n      p2 += player2[i];\\n      \\n      if ((i>0 && player1[i-1] == 10) ||\\n          (i>1 && player1[i-2] == 10))\\n        p1 += player1[i];\\n      \\n      if ((i>0 && player2[i-1] == 10) ||\\n          (i>1 && player2[i-2] == 10))\\n        p2 += player2[i];\\n    }\\n    return p1 == p2 ? 0 : (p1 > p2 ? 1 : 2);\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n  public int isWinner(int[] player1, int[] player2) {\\n    int n = player1.length, p1, p2;\\n    \\n    for (var i=0; i<n; i++) {\\n      p1 += player1[i];\\n      p2 += player2[i];\\n      \\n      if ((i>0 && player1[i-1] == 10) ||\\n          (i>1 && player1[i-2] == 10))\\n        p1 += player1[i];\\n      \\n      if ((i>0 && player2[i-1] == 10) ||\\n          (i>1 && player2[i-2] == 10))\\n        p2 += player2[i];\\n    }\\n    return p1 == p2 ? 0 : (p1 > p2 ? 1 : 2);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3492083,
                "title": "math-easy-to-understand-c",
                "content": "# Intuition\\nCHECK FOR i-1 or i-2 there is 10 or not if yes than increment player score 2*v[i] else v[i]\\n\\n# Approach\\nsimple linear traversal\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n(1))\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& v1, vector<int>& v2) {\\n        int x = v1[0], y = v2[0];//for size 1 score = index 0 score\\n        i = 0, n = v1.size();\\n        for(i = 1; i < n; i++){\\n            if(i==1){//for index 1 check for index 0\\n                if(v1[i-1]==10)x += v1[i]*2;\\n                else x += v1[i];\\n                if(v2[i-1]==10)y += v2[i]*2;\\n                else y += v2[i];\\n            }else{//for other indexs check for i-1 || i-2\\n                if(v1[i-1]==10||v1[i-2]==10)x += v1[i]*2;\\n                else x += v1[i];\\n                if(v2[i-1]==10||v2[i-2]==10)y += v2[i]*2;\\n                else y += v2[i];\\n            }\\n        }\\n        if(x>y)return 1;\\n        if(y>x)return 2;\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& v1, vector<int>& v2) {\\n        int x = v1[0], y = v2[0];//for size 1 score = index 0 score\\n        i = 0, n = v1.size();\\n        for(i = 1; i < n; i++){\\n            if(i==1){//for index 1 check for index 0\\n                if(v1[i-1]==10)x += v1[i]*2;\\n                else x += v1[i];\\n                if(v2[i-1]==10)y += v2[i]*2;\\n                else y += v2[i];\\n            }else{//for other indexs check for i-1 || i-2\\n                if(v1[i-1]==10||v1[i-2]==10)x += v1[i]*2;\\n                else x += v1[i];\\n                if(v2[i-1]==10||v2[i-2]==10)y += v2[i]*2;\\n                else y += v2[i];\\n            }\\n        }\\n        if(x>y)return 1;\\n        if(y>x)return 2;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469409,
                "title": "python-elegant-short",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def isWinner(self, player_a: List[int], player_b: List[int]) -> int:\\n        score_a = self.get_score(player_a)\\n        score_b = self.get_score(player_b)\\n\\n        return {\\n            score_a > score_b: 1,\\n            score_a < score_b: 2,\\n        }.get(True, 0)\\n\\n    @staticmethod\\n    def get_score(player: List[int]) -> int:\\n        score = 0\\n\\n        for i, sc in enumerate(player):\\n            if i > 0 and player[i - 1] == 10:\\n                score += 2 * sc\\n            elif i > 1 and player[i - 2] == 10:\\n                score += 2 * sc\\n            else:\\n                score += sc\\n\\n        return score\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isWinner(self, player_a: List[int], player_b: List[int]) -> int:\\n        score_a = self.get_score(player_a)\\n        score_b = self.get_score(player_b)\\n\\n        return {\\n            score_a > score_b: 1,\\n            score_a < score_b: 2,\\n        }.get(True, 0)\\n\\n    @staticmethod\\n    def get_score(player: List[int]) -> int:\\n        score = 0\\n\\n        for i, sc in enumerate(player):\\n            if i > 0 and player[i - 1] == 10:\\n                score += 2 * sc\\n            elif i > 1 and player[i - 2] == 10:\\n                score += 2 * sc\\n            else:\\n                score += sc\\n\\n        return score\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468562,
                "title": "easy-and-simple-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ntraverse and check the previous 2\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n-here we set a variable named \\'set\\' that works when it is near the 2 or 1 only as it is moving forward it will decrease \\n-use this in the function and check for the both the vectors\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getcount(vector<int>& a)\\n    {\\n        int count=0,set=0;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            if(set)\\n            {\\n                count+=2*a[i];\\n                set--;\\n            }\\n            else\\n            {\\n                count+=a[i];\\n            }\\n            if(a[i]==10)\\n            set=2;\\n        }\\n        return count;\\n\\n    }\\n\\n    int isWinner(vector<int>& player1, vector<int>& player2) \\n    {\\n        int first=getcount(player1);\\n        int second=getcount(player2);\\n        if(first>second)\\n        return 1;\\n        else if(second>first)\\n        return 2;\\n        return 0;        \\n    }\\n};\\n```\\n# upvote me if you like the solution comment if any doubts\\n![images.jpeg](https://assets.leetcode.com/users/images/104d4992-67f5-4b9b-aab4-0b17af99b548_1682830426.6456287.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getcount(vector<int>& a)\\n    {\\n        int count=0,set=0;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            if(set)\\n            {\\n                count+=2*a[i];\\n                set--;\\n            }\\n            else\\n            {\\n                count+=a[i];\\n            }\\n            if(a[i]==10)\\n            set=2;\\n        }\\n        return count;\\n\\n    }\\n\\n    int isWinner(vector<int>& player1, vector<int>& player2) \\n    {\\n        int first=getcount(player1);\\n        int second=getcount(player2);\\n        if(first>second)\\n        return 1;\\n        else if(second>first)\\n        return 2;\\n        return 0;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468480,
                "title": "easy-short-java-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] p1, int[] p2) {\\n        int a1=0, a2=0;\\n            for(int i=0; i<p1.length; i++){\\n                a1+= p1[i];\\n                a2+= p2[i];  \\n                a1 += i>0 && p1[i-1] == 10 || i>1 && p1[i-2] ==10 ? p1[i]: 0;                  \\n                a2 += i>0 && p2[i-1] == 10 || i>1 && p2[i-2] ==10 ? p2[i]: 0;\\n            }\\n             return a1>a2 ? 1 : (a2>a1 ? 2 : 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] p1, int[] p2) {\\n        int a1=0, a2=0;\\n            for(int i=0; i<p1.length; i++){\\n                a1+= p1[i];\\n                a2+= p2[i];  \\n                a1 += i>0 && p1[i-1] == 10 || i>1 && p1[i-2] ==10 ? p1[i]: 0;                  \\n                a2 += i>0 && p2[i-1] == 10 || i>1 && p2[i-2] ==10 ? p2[i]: 0;\\n            }\\n             return a1>a2 ? 1 : (a2>a1 ? 2 : 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468446,
                "title": "c-best-solution-100-faster-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n         int cnt1=0, cnt2=0, player1_Value=0, player2_Value=0;\\n        \\n        for(int i=0; i<player1.size(); i++) {\\n            if(cnt1 > 0)    {\\n                player1_Value += (2*player1[i]);\\n                cnt1--;\\n            }\\n            else    player1_Value += player1[i];\\n            if(player1[i] == 10)    cnt1 = 2;\\n            \\n            if(cnt2 > 0)    {\\n                player2_Value += (2*player2[i]);\\n                cnt2--;\\n            }\\n            else    player2_Value += player2[i];\\n            if(player2[i] == 10)    cnt2 = 2;\\n        }\\n        \\n        if(player1_Value == player2_Value)    return 0;\\n        if(player1_Value > player2_Value)     return 1;\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n         int cnt1=0, cnt2=0, player1_Value=0, player2_Value=0;\\n        \\n        for(int i=0; i<player1.size(); i++) {\\n            if(cnt1 > 0)    {\\n                player1_Value += (2*player1[i]);\\n                cnt1--;\\n            }\\n            else    player1_Value += player1[i];\\n            if(player1[i] == 10)    cnt1 = 2;\\n            \\n            if(cnt2 > 0)    {\\n                player2_Value += (2*player2[i]);\\n                cnt2--;\\n            }\\n            else    player2_Value += player2[i];\\n            if(player2[i] == 10)    cnt2 = 2;\\n        }\\n        \\n        if(player1_Value == player2_Value)    return 0;\\n        if(player1_Value > player2_Value)     return 1;\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468342,
                "title": "time-o-n-space-o-1-c-simple-easy-solution",
                "content": "````\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int x = 0, y = 0;\\n        int i = 0, n = player1.size();\\n        for(i = 0; i < n; i++){\\n            if(i==0){\\n                x += player1[i];\\n            }else if(i==1){\\n                if(player1[i-1]==10){\\n                    x += player1[i]*2;\\n                }else{\\n                    x += player1[i];\\n                }\\n            }else{\\n                if(player1[i-1]==10||player1[i-2]==10){\\n                    x += player1[i]*2;\\n                }else{\\n                    x += player1[i];\\n                }\\n            }\\n        }\\n        for(i = 0; i < n; i++){\\n            if(i==0){\\n                y += player2[i];\\n            }else if(i==1){\\n                if(player2[i-1]==10){\\n                    y += player2[i]*2;\\n                }else{\\n                    y += player2[i];\\n                }\\n            }else{\\n                if(player2[i-1]==10||player2[i-2]==10){\\n                    y += player2[i]*2;\\n                }else{\\n                    y += player2[i];\\n                }\\n            }\\n        }\\n        cout<<x<<\" \"<<y;\\n        if(x>y)return 1;\\n        else if(x<y)return 2;\\n        return 0;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int x = 0, y = 0;\\n        int i = 0, n = player1.size();\\n        for(i = 0; i < n; i++){\\n            if(i==0){\\n                x += player1[i];\\n            }else if(i==1){\\n                if(player1[i-1]==10){\\n                    x += player1[i]*2;\\n                }else{\\n                    x += player1[i];\\n                }\\n            }else{\\n                if(player1[i-1]==10||player1[i-2]==10){\\n                    x += player1[i]*2;\\n                }else{\\n                    x += player1[i];\\n                }\\n            }\\n        }\\n        for(i = 0; i < n; i++){\\n            if(i==0){\\n                y += player2[i];\\n            }else if(i==1){\\n                if(player2[i-1]==10){\\n                    y += player2[i]*2;\\n                }else{\\n                    y += player2[i];\\n                }\\n            }else{\\n                if(player2[i-1]==10||player2[i-2]==10){\\n                    y += player2[i]*2;\\n                }else{\\n                    y += player2[i];\\n                }\\n            }\\n        }\\n        cout<<x<<\" \"<<y;\\n        if(x>y)return 1;\\n        else if(x<y)return 2;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3468309,
                "title": "c-solutions-easy-to-understand-full-explanaiton-line-by-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code is written to solve a problem related to a game of bowling. The function isWinner takes in two vectors, player1 and player2, that represent the scores of the two players in the game.\\n\\nThe fn lambda function calculates the total score for a given player\\'s vector. It does so by iterating through each frame and adding up the scores. If the current frame is a strike or spare, it adds bonus points accordingly.\\n\\nThe isWinner function then calculates the score difference between player1 and player2 by calling the fn function for each player\\'s vector. If player1\\'s score is greater, it returns 1 to indicate that player1 wins. If player2\\'s score is greater, it returns 2 to indicate that player2 wins. If both scores are equal, it returns 0 to indicate a tie.\\n\\nOverall, the code is intuitive in its approach and easy to understand. It uses lambda functions to reduce code duplication and improve readability. The use of simple if-else statements to determine the winner based on score difference is straightforward and easy to follow.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis code defines a function named isWinner that takes two vectors player1 and player2 representing the scores of two players in a game of bowling.\\n\\nThe function first defines a lambda function named fn that takes an integer vector as an argument. This lambda function iterates over each element of the vector and adds up the score for each frame. If the current frame is a strike (10 pins knocked down on the first ball) or a spare (10 pins knocked down in two balls), it adds extra points accordingly. The lambda function returns the total score for the given vector.\\n\\nThe isWinner function then calls the fn function with player1 and player2 vectors to calculate their respective scores. It then calculates the difference between the two scores and returns 1 if player1 wins, 2 if player2 wins, and 0 if it\\'s a tie.\\n\\nOverall, the code follows a simple approach to calculate the total scores for both players and determine the winner based on their score difference. The use of a lambda function makes the code more concise and reusable, allowing the fn function to be called multiple times with different vectors.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe fn lambda function iterates over each element of the vector and performs a constant amount of work for each element. Therefore, the time complexity of fn is O(n), where n is the length of the input vector.\\n\\nThe isWinner function calls fn twice and performs a constant amount of additional work to calculate the score difference and determine the winner. Therefore, the time complexity of isWinner is O(n), where n is the length of the input vectors.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe fn lambda function does not allocate any additional memory other than the input vector. Therefore, the space complexity of fn is O(1).\\n\\nThe isWinner function uses a constant amount of additional memory to store the scores and score difference. Therefore, the space complexity of isWinner is O(1).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // Define a function named isWinner that takes two integer vectors as arguments\\nint isWinner(vector<int>& player1, vector<int>& player2) {\\n    // Define a lambda function named fn that takes an integer vector as an argument\\n    auto fn = [&](vector<int>& p) {\\n        // Initialize a variable named ans to 0\\n        int ans = 0; \\n        // Loop through each element of the vector\\n        for (int i = 0; i < p.size(); ++i) {\\n            // Add the current element to ans\\n            ans += p[i]; \\n            // If the previous element is 10, add the current element to ans\\n            // If the element two positions back is 10, add the current element to ans\\n            if (i && p[i-1] == 10 || i >= 2 && p[i-2] == 10) ans += p[i]; \\n        }\\n        // Return the value of ans\\n        return ans; \\n    }; \\n    \\n    // Calculate the score of player1 by calling the fn function with player1 vector\\n    int player1_score = fn(player1);\\n    // Calculate the score of player2 by calling the fn function with player2 vector\\n    int player2_score = fn(player2);\\n    \\n    // Calculate the difference between the two scores\\n    int score_diff = player1_score - player2_score; \\n    // If player1\\'s score is greater than player2\\'s score, return 1 (player1 wins)\\n    if (score_diff > 0) return 1; \\n    // If player2\\'s score is greater than player1\\'s score, return 2 (player2 wins)\\n    else if (score_diff < 0) return 2; \\n    // If both scores are equal, return 0 (tie)\\n    return 0; \\n}\\n\\n};\\n```\\n\\n\\n\\n\\n\\n# Code without comments\\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        auto fn = [&](vector<int>& p) {\\n            int ans = 0; \\n            for (int i = 0; i < p.size(); ++i) {\\n                ans += p[i]; \\n                if (i && p[i-1] == 10 || i >= 2 && p[i-2] == 10) ans += p[i]; \\n            }\\n            return ans; \\n        }; \\n        \\n        int x = fn(player1) - fn(player2); \\n        if (x > 0) return 1; \\n        else if (x < 0) return 2; \\n        return 0; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Define a function named isWinner that takes two integer vectors as arguments\\nint isWinner(vector<int>& player1, vector<int>& player2) {\\n    // Define a lambda function named fn that takes an integer vector as an argument\\n    auto fn = [&](vector<int>& p) {\\n        // Initialize a variable named ans to 0\\n        int ans = 0; \\n        // Loop through each element of the vector\\n        for (int i = 0; i < p.size(); ++i) {\\n            // Add the current element to ans\\n            ans += p[i]; \\n            // If the previous element is 10, add the current element to ans\\n            // If the element two positions back is 10, add the current element to ans\\n            if (i && p[i-1] == 10 || i >= 2 && p[i-2] == 10) ans += p[i]; \\n        }\\n        // Return the value of ans\\n        return ans; \\n    }; \\n    \\n    // Calculate the score of player1 by calling the fn function with player1 vector\\n    int player1_score = fn(player1);\\n    // Calculate the score of player2 by calling the fn function with player2 vector\\n    int player2_score = fn(player2);\\n    \\n    // Calculate the difference between the two scores\\n    int score_diff = player1_score - player2_score; \\n    // If player1\\'s score is greater than player2\\'s score, return 1 (player1 wins)\\n    if (score_diff > 0) return 1; \\n    // If player2\\'s score is greater than player1\\'s score, return 2 (player2 wins)\\n    else if (score_diff < 0) return 2; \\n    // If both scores are equal, return 0 (tie)\\n    return 0; \\n}\\n\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        auto fn = [&](vector<int>& p) {\\n            int ans = 0; \\n            for (int i = 0; i < p.size(); ++i) {\\n                ans += p[i]; \\n                if (i && p[i-1] == 10 || i >= 2 && p[i-2] == 10) ans += p[i]; \\n            }\\n            return ans; \\n        }; \\n        \\n        int x = fn(player1) - fn(player2); \\n        if (x > 0) return 1; \\n        else if (x < 0) return 2; \\n        return 0; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3825291,
                "title": "python-3-simulation-beats-100-234ms",
                "content": "```python3 []\\nclass Solution:\\n    def getSum(nums):\\n            res, prev1, prev2 = 0, 0, 0\\n            for n in nums:\\n                if prev1 == 10 or prev2 == 10:\\n                    res += 2*n\\n                else:\\n                    res += n\\n                prev2, prev1 = prev1, n\\n            return res\\n\\n        s1, s2 = getSum(player1), getSum(player2)\\n\\n        if s2 > s1: return 2\\n        if s1 > s2: return 1\\n        return 0\\n```\\n![Screenshot 2023-07-27 at 21.20.20.png](https://assets.leetcode.com/users/images/ed58e8d4-873d-4fcd-8c2d-d909cfd2514a_1690482073.2618957.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Simulation"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def getSum(nums):\\n            res, prev1, prev2 = 0, 0, 0\\n            for n in nums:\\n                if prev1 == 10 or prev2 == 10:\\n                    res += 2*n\\n                else:\\n                    res += n\\n                prev2, prev1 = prev1, n\\n            return res\\n\\n        s1, s2 = getSum(player1), getSum(player2)\\n\\n        if s2 > s1: return 2\\n        if s1 > s2: return 1\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470872,
                "title": "determine-the-winner-of-a-bowling-game-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int i, p1=0, p2=0;\\n\\n        // Player 1 points\\n        for(i=0 ; i<player1.size() ; i++)\\n        {\\n            if((i>=1 && player1[i-1]==10) || (i>=2 && player1[i-2]==10))\\n            {\\n                p1 += 2*player1[i];\\n            }\\n            else\\n            {\\n                p1 += player1[i];\\n            }\\n        }\\n\\n        // Player 2 points\\n        for(i=0 ; i<player2.size() ; i++)\\n        {\\n            if((i>=1 && player2[i-1]==10) || (i>=2 && player2[i-2]==10))\\n            {\\n                p2 += 2*player2[i];\\n            }\\n            else\\n            {\\n                p2 += player2[i];\\n            }\\n        }\\n\\n        //Results\\n        if(p1>p2)\\n            return 1;\\n        else if(p1==p2)\\n            return 0;\\n        return 2;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/6ec5af97-5e28-494f-a4bc-96daa77317ce_1682879966.8972776.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int i, p1=0, p2=0;\\n\\n        // Player 1 points\\n        for(i=0 ; i<player1.size() ; i++)\\n        {\\n            if((i>=1 && player1[i-1]==10) || (i>=2 && player1[i-2]==10))\\n            {\\n                p1 += 2*player1[i];\\n            }\\n            else\\n            {\\n                p1 += player1[i];\\n            }\\n        }\\n\\n        // Player 2 points\\n        for(i=0 ; i<player2.size() ; i++)\\n        {\\n            if((i>=1 && player2[i-1]==10) || (i>=2 && player2[i-2]==10))\\n            {\\n                p2 += 2*player2[i];\\n            }\\n            else\\n            {\\n                p2 += player2[i];\\n            }\\n        }\\n\\n        //Results\\n        if(p1>p2)\\n            return 1;\\n        else if(p1==p2)\\n            return 0;\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469173,
                "title": "python3-straightforward-solution-with-explanation",
                "content": "We want to calculate the sum of all scores, while doubling the next two scores if we meet 10. To do this, we iterate over the loop, accumulating the sum each iteration **score**. If we meet 10, we once again add the current result **nums[i]** to the total **score** and subtract 1 from the doubling counter **doubles**. If the counter is 0, then we skip doubling the next iteration until we update the counter **doubles** again.\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        def score(nums):\\n            score = 0\\n            flag = False\\n\\n            for i in range(len(nums)):\\n                score += nums[i]\\n\\n                if flag:\\n                    score += nums[i]\\n                    doubles -= 1\\n\\n                    if doubles == 0:\\n                        flag = False\\n\\n                if nums[i] == 10:\\n                    doubles = 2\\n                    flag = True\\n                    \\n            return score\\n        \\n        score1, score2 = score(player1), score(player2)\\n        \\n        if score1 == score2:\\n            return 0\\n        elif score1 > score2:\\n            return 1\\n        else:\\n            return 2\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        def score(nums):\\n            score = 0\\n            flag = False\\n\\n            for i in range(len(nums)):\\n                score += nums[i]\\n\\n                if flag:\\n                    score += nums[i]\\n                    doubles -= 1\\n\\n                    if doubles == 0:\\n                        flag = False\\n\\n                if nums[i] == 10:\\n                    doubles = 2\\n                    flag = True\\n                    \\n            return score\\n        \\n        score1, score2 = score(player1), score(player2)\\n        \\n        if score1 == score2:\\n            return 0\\n        elif score1 > score2:\\n            return 1\\n        else:\\n            return 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468551,
                "title": "simplest-if-else-solution-nothing-else",
                "content": "# Intuition\\njust do what is asked and add a base case for arr[1]\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nsimple if else approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int len=player1.length;\\n        int a1[]= new int [len];\\n        int a2[]= new int [len];\\n        \\n        a1[0]= player1[0];\\n        a2[0]= player2[0];\\n        \\n        if(len>1){\\n            if(player1[0]!=10)\\n                a1[1]=player1[1];\\n            else\\n                a1[1]=player1[1]*2;\\n            \\n            if(player2[0]!=10)\\n                a2[1]=player2[1];\\n            else\\n                a2[1]=player2[1]*2;\\n        }\\n        for(int i=2;i<len;i++){\\n            if(player1[i-1]==10 ||player1[i-2]==10){\\n                a1[i]=player1[i]*2;\\n            }\\n            else\\n                a1[i]=player1[i];\\n        \\n        if(player2[i-1]==10 ||player2[i-2]==10){\\n                a2[i]=player2[i]*2;\\n            }\\n            else\\n                a2[i]=player2[i];\\n        }\\n        int s1=0;\\n        int s2=0;\\n        \\n        for(int i=0;i<len;i++){\\n            s1+=a1[i];\\n            s2+=a2[i];\\n        }\\n        if(s1>s2)\\n            return 1;\\n        else if(s2> s1)\\n            return 2;\\n        else \\n            return 0;\\n        \\n        \\n    }\\n}\\n\\n```\\n![images.jpeg](https://assets.leetcode.com/users/images/4f433525-656e-4649-92f3-bf73c0460045_1682830193.917968.jpeg)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int len=player1.length;\\n        int a1[]= new int [len];\\n        int a2[]= new int [len];\\n        \\n        a1[0]= player1[0];\\n        a2[0]= player2[0];\\n        \\n        if(len>1){\\n            if(player1[0]!=10)\\n                a1[1]=player1[1];\\n            else\\n                a1[1]=player1[1]*2;\\n            \\n            if(player2[0]!=10)\\n                a2[1]=player2[1];\\n            else\\n                a2[1]=player2[1]*2;\\n        }\\n        for(int i=2;i<len;i++){\\n            if(player1[i-1]==10 ||player1[i-2]==10){\\n                a1[i]=player1[i]*2;\\n            }\\n            else\\n                a1[i]=player1[i];\\n        \\n        if(player2[i-1]==10 ||player2[i-2]==10){\\n                a2[i]=player2[i]*2;\\n            }\\n            else\\n                a2[i]=player2[i];\\n        }\\n        int s1=0;\\n        int s2=0;\\n        \\n        for(int i=0;i<len;i++){\\n            s1+=a1[i];\\n            s2+=a2[i];\\n        }\\n        if(s1>s2)\\n            return 1;\\n        else if(s2> s1)\\n            return 2;\\n        else \\n            return 0;\\n        \\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468368,
                "title": "easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int score1 = 0, score2 = 0;\\n        for (size_t i = 0; i < player1.size(); i++)\\n        {\\n            if ((i > 0 && player1[i - 1] == 10) || (i > 1 && player1[i - 2] == 10))\\n                score1 += 2 * player1[i];\\n            else\\n                score1+= player1[i];\\n        }\\n \\n        for (size_t i = 0; i < player2.size(); i++)\\n        {\\n            if ((i > 0 && player2[i - 1] == 10) || (i > 1 && player2[i - 2] == 10))\\n                score2 += 2 * player2[i];\\n            else\\n                score2 += player2[i];\\n        }\\n \\n        return (score1 == score2 ? 0 : (score1 > score2 ? 1 : 2));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int score1 = 0, score2 = 0;\\n        for (size_t i = 0; i < player1.size(); i++)\\n        {\\n            if ((i > 0 && player1[i - 1] == 10) || (i > 1 && player1[i - 2] == 10))\\n                score1 += 2 * player1[i];\\n            else\\n                score1+= player1[i];\\n        }\\n \\n        for (size_t i = 0; i < player2.size(); i++)\\n        {\\n            if ((i > 0 && player2[i - 1] == 10) || (i > 1 && player2[i - 2] == 10))\\n                score2 += 2 * player2[i];\\n            else\\n                score2 += player2[i];\\n        }\\n \\n        return (score1 == score2 ? 0 : (score1 > score2 ? 1 : 2));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930975,
                "title": "java-best-solution-100-beats",
                "content": "# Code\\n```\\nclass Solution{\\n    public int isWinner(int[] p1, int[] p2){\\n        int n = p1.length;\\n        int a=p1[0], b=p2[0];\\n        if(n==1){\\n            if(a>b) return 1;\\n            else if(b>a) return 2;\\n            return 0;\\n        }\\n        if(a==10) a += 2*p1[1];\\n        else a += p1[1];\\n        if(b==10) b += 2*p2[1];\\n        else b += p2[1];\\n        for(int i=2; i<n; i++){\\n            if(p1[i-1]==10 || p1[i-2]==10) a += 2*p1[i];\\n            else a += p1[i];\\n            if(p2[i-1]==10 || p2[i-2]==10) b += 2*p2[i];\\n            else b += p2[i];\\n        }\\n        if(a>b) return 1;\\n        else if(b>a) return 2;\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution{\\n    public int isWinner(int[] p1, int[] p2){\\n        int n = p1.length;\\n        int a=p1[0], b=p2[0];\\n        if(n==1){\\n            if(a>b) return 1;\\n            else if(b>a) return 2;\\n            return 0;\\n        }\\n        if(a==10) a += 2*p1[1];\\n        else a += p1[1];\\n        if(b==10) b += 2*p2[1];\\n        else b += p2[1];\\n        for(int i=2; i<n; i++){\\n            if(p1[i-1]==10 || p1[i-2]==10) a += 2*p1[i];\\n            else a += p1[i];\\n            if(p2[i-1]==10 || p2[i-2]==10) b += 2*p2[i];\\n            else b += p2[i];\\n        }\\n        if(a>b) return 1;\\n        else if(b>a) return 2;\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808115,
                "title": "99-success-rate-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int i=1,j=i-1,k=i-2;\\n        int p1=player1[0],p2=player2[0];\\n        while(i<player1.length){\\n            if((j>=0 && player1[j]==10 ) || (k>=0 && player1[k]==10)){\\n                p1+=2*player1[i];\\n            }\\n            else{\\n                p1+=player1[i];\\n            }\\n            i++;\\n            j++;\\n            k++;\\n        }\\n        int l=1,m=l-1,n=l-2;\\n        while(l<player2.length){\\n            if((m>=0 && player2[m]==10 ) || (n>=0 && player2[n]==10)){\\n                p2+=2*player2[l];\\n            }\\n            else{\\n                p2+=player2[l];\\n            }\\n            l++;\\n            m++;\\n            n++;\\n        }\\n        if(p1>p2) return 1;\\n        else if(p1==p2) return 0;\\n        else return 2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int i=1,j=i-1,k=i-2;\\n        int p1=player1[0],p2=player2[0];\\n        while(i<player1.length){\\n            if((j>=0 && player1[j]==10 ) || (k>=0 && player1[k]==10)){\\n                p1+=2*player1[i];\\n            }\\n            else{\\n                p1+=player1[i];\\n            }\\n            i++;\\n            j++;\\n            k++;\\n        }\\n        int l=1,m=l-1,n=l-2;\\n        while(l<player2.length){\\n            if((m>=0 && player2[m]==10 ) || (n>=0 && player2[n]==10)){\\n                p2+=2*player2[l];\\n            }\\n            else{\\n                p2+=player2[l];\\n            }\\n            l++;\\n            m++;\\n            n++;\\n        }\\n        if(p1>p2) return 1;\\n        else if(p1==p2) return 0;\\n        else return 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3694869,
                "title": "js-ts-simple-solution",
                "content": "Just go through the numbers array and check the previous 2 elements to get the correct score according to the requirements and then compare the two scores at the end to return 0, 1 or 2.\\n\\n# Code\\n```\\nconst isWinner = (player1: number[], player2: number[]): number => {\\n\\n    let player1Score = 0;\\n    let player2Score = 0;\\n\\n    const getScoreFromNumbers = (numbers:number[]): number => {\\n\\n        let score = 0;\\n\\n        for(let i = 0; i < numbers.length; i++) {\\n            if(numbers[i - 1] === 10 || numbers[i - 2] === 10) {\\n                score += numbers[i] * 2;\\n            } else {\\n                score += numbers[i];\\n            }\\n        }\\n\\n        return score;\\n    };\\n\\n    player1Score = getScoreFromNumbers(player1);\\n    player2Score = getScoreFromNumbers(player2);\\n    \\n    if(player1Score === player2Score) return 0;\\n\\n    return player1Score > player2Score ? 1 : 2;\\n\\n};\\n```\\nSee more `TypeScript`/`JavaScript` (and other language) LeetCode solutions at https://github.com/jasonmauss/LeetCode",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nconst isWinner = (player1: number[], player2: number[]): number => {\\n\\n    let player1Score = 0;\\n    let player2Score = 0;\\n\\n    const getScoreFromNumbers = (numbers:number[]): number => {\\n\\n        let score = 0;\\n\\n        for(let i = 0; i < numbers.length; i++) {\\n            if(numbers[i - 1] === 10 || numbers[i - 2] === 10) {\\n                score += numbers[i] * 2;\\n            } else {\\n                score += numbers[i];\\n            }\\n        }\\n\\n        return score;\\n    };\\n\\n    player1Score = getScoreFromNumbers(player1);\\n    player2Score = getScoreFromNumbers(player2);\\n    \\n    if(player1Score === player2Score) return 0;\\n\\n    return player1Score > player2Score ? 1 : 2;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3588173,
                "title": "use-simple-conditionals-o-n-time-o-1-space-complexity-beats-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N+M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nN,M are the legths of two given Arrays.\\n\\n- **An Upvote will be encouraging \\uD83D\\uDC4D**\\n\\n# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int sum1=player1[0];\\n        int sum2=player2[0];\\n        for(int i=1;i<player1.length;i++){\\n            if(player1[i-1]==10 ){\\n                sum1+=2*player1[i];\\n            }\\n            else if( i!=1 && player1[i-2]==10 ){\\n                sum1+=2*player1[i];\\n            }\\n            else{\\n                sum1+=player1[i];\\n            }\\n            \\n        }\\n        for(int i=1;i<player2.length;i++){\\n            if(player2[i-1]==10 ){\\n                sum2+=2*player2[i];\\n            }\\n            else if( i!=1 && player2[i-2]==10 ){\\n                sum2+=2*player2[i];\\n            }\\n            else{\\n                sum2+=player2[i];\\n            }\\n        }\\n            return sum1>sum2?1:sum1==sum2?0:2;\\n    }\\n}\\n```\\n![image.png](https://assets.leetcode.com/users/images/73ee6b4d-5c9d-4985-8d77-1ad9eff736b8_1685683542.998519.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int sum1=player1[0];\\n        int sum2=player2[0];\\n        for(int i=1;i<player1.length;i++){\\n            if(player1[i-1]==10 ){\\n                sum1+=2*player1[i];\\n            }\\n            else if( i!=1 && player1[i-2]==10 ){\\n                sum1+=2*player1[i];\\n            }\\n            else{\\n                sum1+=player1[i];\\n            }\\n            \\n        }\\n        for(int i=1;i<player2.length;i++){\\n            if(player2[i-1]==10 ){\\n                sum2+=2*player2[i];\\n            }\\n            else if( i!=1 && player2[i-2]==10 ){\\n                sum2+=2*player2[i];\\n            }\\n            else{\\n                sum2+=player2[i];\\n            }\\n        }\\n            return sum1>sum2?1:sum1==sum2?0:2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3533827,
                "title": "easiest-python-solution",
                "content": "# Intuition\\nusing for loop and few conditions\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\no(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def isWinner(self, nums1: List[int], nums2: List[int]) -> int:\\n        res1=0\\n        res2=0\\n        if 10 in nums1 and len(nums1)>1:\\n            res1+=nums1[0]\\n            for i in range(1,len(nums1)):\\n                res1+=nums1[i]\\n                if nums1[i-1]==10 or i>=2 and nums1[i-2]==10:\\n                        res1+=nums1[i]\\n                else:\\n                    pass\\n        else:\\n            res1=sum(nums1)\\n        if 10 in nums2 and len(nums2)>1:\\n            res2+=nums2[0]\\n            for i in range(1,len(nums2)):\\n                res2+=nums2[i]\\n\\n                if nums2[i-1]==10 or i>=2 and nums2[i-2]==10:\\n                        res2+=nums2[i]\\n                else:\\n                    pass\\n        else:\\n            res2=sum(nums2)\\n\\n        # print(1 if res1>res2 2: if res2>res1: 0 if res1==res2)\\n        if res1>res2:\\n            return(1)\\n        elif res1<res2:\\n            return(2)\\n        else:\\n            return(0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isWinner(self, nums1: List[int], nums2: List[int]) -> int:\\n        res1=0\\n        res2=0\\n        if 10 in nums1 and len(nums1)>1:\\n            res1+=nums1[0]\\n            for i in range(1,len(nums1)):\\n                res1+=nums1[i]\\n                if nums1[i-1]==10 or i>=2 and nums1[i-2]==10:\\n                        res1+=nums1[i]\\n                else:\\n                    pass\\n        else:\\n            res1=sum(nums1)\\n        if 10 in nums2 and len(nums2)>1:\\n            res2+=nums2[0]\\n            for i in range(1,len(nums2)):\\n                res2+=nums2[i]\\n\\n                if nums2[i-1]==10 or i>=2 and nums2[i-2]==10:\\n                        res2+=nums2[i]\\n                else:\\n                    pass\\n        else:\\n            res2=sum(nums2)\\n\\n        # print(1 if res1>res2 2: if res2>res1: 0 if res1==res2)\\n        if res1>res2:\\n            return(1)\\n        elif res1<res2:\\n            return(2)\\n        else:\\n            return(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3488608,
                "title": "c-solution-brute-force",
                "content": "## Code\\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int p1=player1[0], p2=player2[0];\\n        int n= player1.size();\\n        if (n>1){\\n            if (p1==10)p1+= player1[1]*2;\\n            else p1+= player1[1];\\n            if (p2==10)p2+= player2[1]*2;\\n            else p2+= player2[1];\\n            for (int i=2; i<n; i++){\\n                if (player1[i-1]==10 || player1[i-2]==10){\\n                    p1+= (2*player1[i]);\\n                }\\n                else p1+= player1[i];\\n                if (player2[i-1]==10 || player2[i-2]==10){\\n                    p2+= (2*player2[i]);\\n                }\\n                else p2+= player2[i];\\n            }\\n        }\\n        if (p1==p2)return 0;\\n        if (p1>p2)return 1;\\n        else return 2;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int p1=player1[0], p2=player2[0];\\n        int n= player1.size();\\n        if (n>1){\\n            if (p1==10)p1+= player1[1]*2;\\n            else p1+= player1[1];\\n            if (p2==10)p2+= player2[1]*2;\\n            else p2+= player2[1];\\n            for (int i=2; i<n; i++){\\n                if (player1[i-1]==10 || player1[i-2]==10){\\n                    p1+= (2*player1[i]);\\n                }\\n                else p1+= player1[i];\\n                if (player2[i-1]==10 || player2[i-2]==10){\\n                    p2+= (2*player2[i]);\\n                }\\n                else p2+= player2[i];\\n            }\\n        }\\n        if (p1==p2)return 0;\\n        if (p1>p2)return 1;\\n        else return 2;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478120,
                "title": "c-brute-force-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int sum1=0, sum2=0, cnt1=1, cnt2=1;\\n        for(int i=0; i<player1.size(); i++){\\n            sum1+=player1[i];\\n        }\\n        for(int i=0; i<player2.size(); i++){\\n            sum2+=player2[i];\\n        }\\n        if(player1.size()>1){\\n            if(player1[0]==10){\\n                sum1+=player1[1];\\n            }\\n        }\\n        if(player2.size()>1){\\n            if(player2[0]==10){\\n                sum2+=player2[1];\\n            }\\n        }\\n        for(int i=2; i<player1.size(); i++){\\n            if(player1[i-1]==10 || player1[i-2]==10){\\n                sum1+=player1[i];\\n            }\\n        }\\n        for(int i=2; i<player2.size(); i++){\\n            if(player2[i-1]==10 || player2[i-2]==10){\\n                sum2+=player2[i];\\n            }\\n        }\\n        if(sum1>sum2){return 1;}\\n        else if(sum1<sum2){return 2;}\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int sum1=0, sum2=0, cnt1=1, cnt2=1;\\n        for(int i=0; i<player1.size(); i++){\\n            sum1+=player1[i];\\n        }\\n        for(int i=0; i<player2.size(); i++){\\n            sum2+=player2[i];\\n        }\\n        if(player1.size()>1){\\n            if(player1[0]==10){\\n                sum1+=player1[1];\\n            }\\n        }\\n        if(player2.size()>1){\\n            if(player2[0]==10){\\n                sum2+=player2[1];\\n            }\\n        }\\n        for(int i=2; i<player1.size(); i++){\\n            if(player1[i-1]==10 || player1[i-2]==10){\\n                sum1+=player1[i];\\n            }\\n        }\\n        for(int i=2; i<player2.size(); i++){\\n            if(player2[i-1]==10 || player2[i-2]==10){\\n                sum2+=player2[i];\\n            }\\n        }\\n        if(sum1>sum2){return 1;}\\n        else if(sum1<sum2){return 2;}\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476247,
                "title": "python3-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        score1 = sum(player1)\\n        score2 = sum(player2)\\n        for i in range(1, len(player1)):\\n            if i == 1:\\n                if player1[0] == 10:\\n                    score1 += player1[i]\\n                if player2[0] == 10:\\n                    score2 += player2[i]\\n            else:\\n                if 10 in player1[i-2:i]:\\n                    score1 += player1[i]\\n                if 10 in player2[i-2:i]:\\n                    score2 += player2[i]\\n        if score1 > score2:\\n            return 1\\n        elif score2 > score1:\\n            return 2\\n        elif score1 == score2:\\n            return 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        score1 = sum(player1)\\n        score2 = sum(player2)\\n        for i in range(1, len(player1)):\\n            if i == 1:\\n                if player1[0] == 10:\\n                    score1 += player1[i]\\n                if player2[0] == 10:\\n                    score2 += player2[i]\\n            else:\\n                if 10 in player1[i-2:i]:\\n                    score1 += player1[i]\\n                if 10 in player2[i-2:i]:\\n                    score2 += player2[i]\\n        if score1 > score2:\\n            return 1\\n        elif score2 > score1:\\n            return 2\\n        elif score1 == score2:\\n            return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3473252,
                "title": "easiest-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n    int score1 = calculateScore(player1);\\n    int score2 = calculateScore(player2);\\n    if (score1 > score2) {\\n        return 1;\\n    } else if (score2 > score1) {\\n        return 2;\\n    } else {\\n        return 0;\\n    }\\n    }\\n    \\n    public static int calculateScore(int[] player) {\\n        int sum = 0;\\n        for (int i = player.length - 1; i >= 0; i--) {\\n            if ((i - 1 > -1) && player[i - 1] == 10) {\\n                sum += player[i] * 2;\\n            } else if ((i - 2 > -1) && player[i - 2] == 10) {\\n                sum += player[i] * 2;\\n            } else {\\n                sum += player[i];\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n    int score1 = calculateScore(player1);\\n    int score2 = calculateScore(player2);\\n    if (score1 > score2) {\\n        return 1;\\n    } else if (score2 > score1) {\\n        return 2;\\n    } else {\\n        return 0;\\n    }\\n    }\\n    \\n    public static int calculateScore(int[] player) {\\n        int sum = 0;\\n        for (int i = player.length - 1; i >= 0; i--) {\\n            if ((i - 1 > -1) && player[i - 1] == 10) {\\n                sum += player[i] * 2;\\n            } else if ((i - 2 > -1) && player[i - 2] == 10) {\\n                sum += player[i] * 2;\\n            } else {\\n                sum += player[i];\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3472299,
                "title": "easy-to-understand-must-see",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& arr1, vector<int>& arr2) \\n\\t{\\n\\t\\t  //calculating the score of the player1\\n          int sum1 = 0;\\n\\t\\t  for(int i=0;i<arr1.size();i++)\\n\\t\\t  {\\n\\t\\t  \\t   bool flag = false;\\n\\t\\t  \\t   if((i-1)>=0 == true and arr1[i-1] == 10)\\n\\t\\t  \\t   flag = true;\\n\\t\\t  \\t   \\n\\t\\t  \\t   if((i-2)>=0 == true and arr1[i-2] == 10)\\n\\t\\t  \\t   flag = true;\\n\\t\\t  \\t   \\n\\t\\t  \\t   if(flag == true) sum1 = sum1 + 2*arr1[i];\\n\\t\\t  \\t   else sum1 = sum1 + arr1[i];\\n\\t\\t  }\\n\\t\\t  \\n\\t\\t  //calculating the score of the player2\\n\\t\\t  int sum2 = 0;\\n\\t\\t  for(int i=0;i<arr2.size();i++)\\n\\t\\t  {\\n\\t\\t  \\t   bool flag = false;\\n\\t\\t  \\t   if((i-1)>=0 == true and arr2[i-1] == 10)\\n\\t\\t  \\t   flag = true;\\n\\t\\t  \\t   \\n\\t\\t  \\t   if((i-2)>=0 == true and arr2[i-2] == 10)\\n\\t\\t  \\t   flag = true;\\n\\t\\t  \\t   \\n\\t\\t  \\t   if(flag == true) sum2 = sum2 + 2*arr2[i];\\n\\t\\t  \\t   else sum2 = sum2 + arr2[i];\\n\\t\\t  }\\n\\t\\t  if(sum1 == sum2) return 0; //draw\\n\\t\\t  else if(sum1 > sum2) return 1;\\n\\t\\t  return 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& arr1, vector<int>& arr2) \\n\\t{\\n\\t\\t  //calculating the score of the player1\\n          int sum1 = 0;\\n\\t\\t  for(int i=0;i<arr1.size();i++)\\n\\t\\t  {\\n\\t\\t  \\t   bool flag = false;\\n\\t\\t  \\t   if((i-1)>=0 == true and arr1[i-1] == 10)\\n\\t\\t  \\t   flag = true;\\n\\t\\t  \\t   \\n\\t\\t  \\t   if((i-2)>=0 == true and arr1[i-2] == 10)\\n\\t\\t  \\t   flag = true;\\n\\t\\t  \\t   \\n\\t\\t  \\t   if(flag == true) sum1 = sum1 + 2*arr1[i];\\n\\t\\t  \\t   else sum1 = sum1 + arr1[i];\\n\\t\\t  }\\n\\t\\t  \\n\\t\\t  //calculating the score of the player2\\n\\t\\t  int sum2 = 0;\\n\\t\\t  for(int i=0;i<arr2.size();i++)\\n\\t\\t  {\\n\\t\\t  \\t   bool flag = false;\\n\\t\\t  \\t   if((i-1)>=0 == true and arr2[i-1] == 10)\\n\\t\\t  \\t   flag = true;\\n\\t\\t  \\t   \\n\\t\\t  \\t   if((i-2)>=0 == true and arr2[i-2] == 10)\\n\\t\\t  \\t   flag = true;\\n\\t\\t  \\t   \\n\\t\\t  \\t   if(flag == true) sum2 = sum2 + 2*arr2[i];\\n\\t\\t  \\t   else sum2 = sum2 + arr2[i];\\n\\t\\t  }\\n\\t\\t  if(sum1 == sum2) return 0; //draw\\n\\t\\t  else if(sum1 > sum2) return 1;\\n\\t\\t  return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471206,
                "title": "c-58-ms",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int gameResult(const vector<int>& player) {\\n        int hit = 0, sum = 0;\\n        for(auto pins : player) {\\n            sum += pins;\\n            if(hit) { sum += pins; --hit; }\\n            if(pins == 10) hit = 2;\\n        }\\n        return sum;\\n    }\\n\\n    int isWinner(const vector<int>& player1, const vector<int>& player2) {\\n        int result = gameResult(player1) - gameResult(player2);\\n        return result > 0? 1: result < 0? 2: result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int gameResult(const vector<int>& player) {\\n        int hit = 0, sum = 0;\\n        for(auto pins : player) {\\n            sum += pins;\\n            if(hit) { sum += pins; --hit; }\\n            if(pins == 10) hit = 2;\\n        }\\n        return sum;\\n    }\\n\\n    int isWinner(const vector<int>& player1, const vector<int>& player2) {\\n        int result = gameResult(player1) - gameResult(player2);\\n        return result > 0? 1: result < 0? 2: result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470302,
                "title": "java-solution-2ms",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int p1=0,p2=0,p1m=1,p2m=1,c1=0,c2=0;\\n        for(int i=0;i<player1.length;i++){\\n            p1+=player1[i]*p1m;\\n            p2+=player2[i]*p2m;\\n            if(player1[i]==10){\\n                p1m=2;\\n                c1=0;\\n            }\\n            if(player2[i]==10){\\n                p2m=2;\\n                c2=0;\\n            }\\n            if(p1m==2){\\n                c1++;\\n                if(c1==3) p1m=1;\\n            }\\n            if(p2m==2){\\n                c2++;\\n                if(c2==3) p2m=1;\\n            }\\n        }\\n        \\n        if(p1==p2){\\n            return 0;\\n        }else if(p1>p2){\\n            return 1;\\n        }else{\\n            return 2;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int p1=0,p2=0,p1m=1,p2m=1,c1=0,c2=0;\\n        for(int i=0;i<player1.length;i++){\\n            p1+=player1[i]*p1m;\\n            p2+=player2[i]*p2m;\\n            if(player1[i]==10){\\n                p1m=2;\\n                c1=0;\\n            }\\n            if(player2[i]==10){\\n                p2m=2;\\n                c2=0;\\n            }\\n            if(p1m==2){\\n                c1++;\\n                if(c1==3) p1m=1;\\n            }\\n            if(p2m==2){\\n                c2++;\\n                if(c2==3) p2m=1;\\n            }\\n        }\\n        \\n        if(p1==p2){\\n            return 0;\\n        }else if(p1>p2){\\n            return 1;\\n        }else{\\n            return 2;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470224,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        def f(player):\\n            n=len(player)\\n            if n==1:\\n                return player[0]\\n            a,b=player[0:2]\\n            answ=player[0] + player[1] + (player[0]==10)*player[1]\\n            for x in player[2:]:\\n                answ+=x + (max(a,b)==10)*x\\n                a,b=b,x\\n            return answ\\n        p1=f(player1)\\n        p2=f(player2)\\n        if p1==p2:\\n            return 0\\n        if p1<p2:\\n            return 2\\n        return 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        def f(player):\\n            n=len(player)\\n            if n==1:\\n                return player[0]\\n            a,b=player[0:2]\\n            answ=player[0] + player[1] + (player[0]==10)*player[1]\\n            for x in player[2:]:\\n                answ+=x + (max(a,b)==10)*x\\n                a,b=b,x\\n            return answ\\n        p1=f(player1)\\n        p2=f(player2)\\n        if p1==p2:\\n            return 0\\n        if p1<p2:\\n            return 2\\n        return 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469963,
                "title": "short-easy-100-fast-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& arr){\\n        int n=arr.size();\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            if(i==0)sum+=arr[i];\\n            else if(i==1){\\n                if(arr[i-1]==10)sum+=(2*arr[i]);\\n                else sum+=arr[i];\\n            }\\n            else{\\n                if(arr[i-1]==10 || arr[i-2]==10)sum+=(2*arr[i]);\\n                else sum+=arr[i];\\n            }\\n        }\\n        return sum;\\n    }\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        if(solve(player1)>solve(player2))return 1;\\n        else if(solve(player1)<solve(player2))return 2;\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& arr){\\n        int n=arr.size();\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            if(i==0)sum+=arr[i];\\n            else if(i==1){\\n                if(arr[i-1]==10)sum+=(2*arr[i]);\\n                else sum+=arr[i];\\n            }\\n            else{\\n                if(arr[i-1]==10 || arr[i-2]==10)sum+=(2*arr[i]);\\n                else sum+=arr[i];\\n            }\\n        }\\n        return sum;\\n    }\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        if(solve(player1)>solve(player2))return 1;\\n        else if(solve(player1)<solve(player2))return 2;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469444,
                "title": "determine-the-winner-of-a-bowling-game-c-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n       int n = player1.size();\\n    int one = 0, two = 0;\\n    one += player1[0];\\n    two += player2[0];\\n    for (int i = 1; i < n; i++)\\n    {\\n        if (i == 1)\\n        {\\n            if (player1[i - 1] == 10)\\n            {\\n                one += 2 * player1[i];\\n            }\\n            else\\n            {\\n                one += player1[i];\\n            }\\n        }\\n        else\\n        {\\n            if ((player1[i - 1] == 10) || (player1[i - 2] == 10))\\n            {\\n                int num = player1[i];\\n                one += (2 * num);\\n            }\\n            else\\n            {\\n                one += player1[i];\\n            }\\n        }\\n    }\\n    for (int i = 1; i < n; i++)\\n    {\\n        if (i == 1)\\n        {\\n            if (player2[i - 1] == 10)\\n            {\\n                two += 2 * player2[i];\\n            }\\n            else\\n            {\\n                two += player2[i];\\n            }\\n        }\\n        else\\n        {\\n            if ((player2[i - 1] == 10) || (player2[i - 2] == 10))\\n            {\\n                int num = player2[i];\\n                two += 2 * num;\\n            }\\n            else\\n            {\\n                two += player2[i];\\n            }\\n        }\\n    }\\n    if (one == two)\\n    {\\n        return 0;\\n    }\\n    if (two > one)\\n    {\\n        return 2;\\n    }\\n    return 1;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n       int n = player1.size();\\n    int one = 0, two = 0;\\n    one += player1[0];\\n    two += player2[0];\\n    for (int i = 1; i < n; i++)\\n    {\\n        if (i == 1)\\n        {\\n            if (player1[i - 1] == 10)\\n            {\\n                one += 2 * player1[i];\\n            }\\n            else\\n            {\\n                one += player1[i];\\n            }\\n        }\\n        else\\n        {\\n            if ((player1[i - 1] == 10) || (player1[i - 2] == 10))\\n            {\\n                int num = player1[i];\\n                one += (2 * num);\\n            }\\n            else\\n            {\\n                one += player1[i];\\n            }\\n        }\\n    }\\n    for (int i = 1; i < n; i++)\\n    {\\n        if (i == 1)\\n        {\\n            if (player2[i - 1] == 10)\\n            {\\n                two += 2 * player2[i];\\n            }\\n            else\\n            {\\n                two += player2[i];\\n            }\\n        }\\n        else\\n        {\\n            if ((player2[i - 1] == 10) || (player2[i - 2] == 10))\\n            {\\n                int num = player2[i];\\n                two += 2 * num;\\n            }\\n            else\\n            {\\n                two += player2[i];\\n            }\\n        }\\n    }\\n    if (one == two)\\n    {\\n        return 0;\\n    }\\n    if (two > one)\\n    {\\n        return 2;\\n    }\\n    return 1;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469431,
                "title": "beginner-friendly-java-code-using-hashsets",
                "content": "# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int n = player1.length;\\n        int sum1 = 0;\\n        int sum2 = 0;\\n        Set<Integer> set1 =  new HashSet<>();\\n        Set<Integer> set2 =  new HashSet<>();\\n        for(int i = 0; i<n; i++){\\n            if(player1[i]==10){\\n                set1.add(i+1);\\n                set1.add(i+2);\\n            }\\n            if(player2[i]==10){\\n                set2.add(i+1);\\n                set2.add(i+2);\\n            }\\n        }\\n        for(int i =0; i<n; i++){\\n            if(set1.contains(i)){\\n                sum1+=player1[i]*2;\\n            }\\n            else{\\n                sum1+=player1[i];\\n            }\\n            if(set2.contains(i)){\\n                sum2+=player2[i]*2;\\n            }\\n            else{\\n                sum2+=player2[i];\\n            }\\n        }\\n        if(sum1>sum2)return 1;\\n        if(sum2>sum1) return 2;\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int n = player1.length;\\n        int sum1 = 0;\\n        int sum2 = 0;\\n        Set<Integer> set1 =  new HashSet<>();\\n        Set<Integer> set2 =  new HashSet<>();\\n        for(int i = 0; i<n; i++){\\n            if(player1[i]==10){\\n                set1.add(i+1);\\n                set1.add(i+2);\\n            }\\n            if(player2[i]==10){\\n                set2.add(i+1);\\n                set2.add(i+2);\\n            }\\n        }\\n        for(int i =0; i<n; i++){\\n            if(set1.contains(i)){\\n                sum1+=player1[i]*2;\\n            }\\n            else{\\n                sum1+=player1[i];\\n            }\\n            if(set2.contains(i)){\\n                sum2+=player2[i]*2;\\n            }\\n            else{\\n                sum2+=player2[i];\\n            }\\n        }\\n        if(sum1>sum2)return 1;\\n        if(sum2>sum1) return 2;\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468891,
                "title": "simple-solution-for-c-explanation-complexity",
                "content": "# Approach\\nStraight solution where we need to calculate scores for each player and get the result\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\npublic int IsWinner(int[] player1, int[] player2)\\n{\\n    var score1 = CalcScores(player1);\\n    var score2 = CalcScores(player2);\\n\\n    if (score1 > score2)\\n    {\\n        return 1;\\n    }\\n\\n    return score2 > score1 ? 2 : 0;\\n}\\n\\n/// <summary>\\n/// Support void to calc scores\\n/// </summary>\\n/// <param name=\"player\"> Player scores </param>\\n/// <returns> Total score </returns>\\nprivate int CalcScores(IReadOnlyList<int> player)\\n{\\n    var result = 0;\\n\\n    for (var i = 0; i < player.Count; i++)\\n    {\\n        switch (i)\\n        {\\n            //// Check if one of the two previous values is equal to 10,\\n            /// then multiply the current score.\\n            case >= 1 when player[i - 1] == 10:\\n            case >= 2 when player[i - 2] == 10:\\n                result += player[i] * 2;\\n                break;\\n            default:\\n                result += player[i];\\n                break;\\n        }\\n    }\\n\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic int IsWinner(int[] player1, int[] player2)\\n{\\n    var score1 = CalcScores(player1);\\n    var score2 = CalcScores(player2);\\n\\n    if (score1 > score2)\\n    {\\n        return 1;\\n    }\\n\\n    return score2 > score1 ? 2 : 0;\\n}\\n\\n/// <summary>\\n/// Support void to calc scores\\n/// </summary>\\n/// <param name=\"player\"> Player scores </param>\\n/// <returns> Total score </returns>\\nprivate int CalcScores(IReadOnlyList<int> player)\\n{\\n    var result = 0;\\n\\n    for (var i = 0; i < player.Count; i++)\\n    {\\n        switch (i)\\n        {\\n            //// Check if one of the two previous values is equal to 10,\\n            /// then multiply the current score.\\n            case >= 1 when player[i - 1] == 10:\\n            case >= 2 when player[i - 2] == 10:\\n                result += player[i] * 2;\\n                break;\\n            default:\\n                result += player[i];\\n                break;\\n        }\\n    }\\n\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3468533,
                "title": "all-test-case-pass-c-easy-o-n-time-o-1-space",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach used in the provided solution is to iterate through each turn of a player and calculate their score based on the game rules, i.e., if the player knocked down all 10 pins (a \"strike\") in the current turn or in the previous two turns. Once the total score for each player has been calculated, it compares the scores to determine the winner or if the game was a draw.\\n\\nTo calculate the score for each turn, the solution keeps track of two variables: previousTwo and flag. previousTwo is an integer that keeps track of the number of turns ago in which the player scored a strike, while flag is a boolean variable that is true if the previous turn was a strike. These variables are used to determine whether the player\\'s score should be multiplied by 2 or not.\\n\\nThe function getScore iterates through each turn of the player, checking if the current turn is a strike or not. If the current turn is not a strike, the score is added to the total score. If the current turn is a strike, the flag variable is set to true, and the previousTwo variable is reset to 0. If flag is true, then the player has scored a strike in the previous turn, so the score for the current turn is multiplied by 2 and added to the total score. If previousTwo is less than 2, the player has scored a strike in the previous two turns, so the score for the current turn is also multiplied by 2 and added to the total score. Finally, the function returns the total score for the player.\\n\\nThe function isWinner calculates the total score for each player using the getScore function and then compares the scores to determine the winner. If the score of player 1 is greater than the score of player 2, it returns 1. If the score of player 2 is greater than the score of player 1, it returns 2. If the scores are equal, it returns 0, indicating a draw.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``````\\nclass Solution {\\npublic:\\n    int getScore(vector<int> player){\\n        bool flag=false;\\n        int previousTwo = 0;\\n        int totalScore=0;\\n        for(auto&it:player){\\n            if(flag==false){\\n                totalScore+=it;\\n            }else if(previousTwo<2){\\n                totalScore+= (2*it);\\n                previousTwo+=1;\\n            }\\n            if(previousTwo>=2)flag=false;\\n            if(it==10){\\n                flag=true;\\n                previousTwo=0;\\n            }\\n        }\\n        return totalScore;\\n    }\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int player1Score = getScore(player1);\\n        int player2Score = getScore(player2);\\n        if(player1Score>player2Score){\\n            return 1;\\n        }else if(player1Score<player2Score){\\n            return 2;\\n        }else{\\n            return 0;\\n        }\\n    }\\n};\\n``````",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Iterator"
                ],
                "code": "``````\n``````",
                "codeTag": "Unknown"
            },
            {
                "id": 3468487,
                "title": "optimized-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int calculateScore(vector<int> &player){\\n\\tint score = 0;\\n\\tint twiceHits = 0; \\n\\tfor(int i = 0;i< player.size();i++){\\n\\t\\tscore += player[i];\\n\\t\\tif(twiceHits){ // check if the hits will be twiced or not \\n\\t\\t\\tscore+=player[i];\\n\\t\\t\\ttwiceHits--;\\n\\t\\t}\\n\\t\\tif(player[i]==10){\\n\\t\\t\\ttwiceHits = 2; // twice the hits for next two attempts\\n\\t\\t}\\n\\t}\\n\\treturn score;\\n}\\n\\nint isWinner(vector<int>& player1, vector<int>& player2) {\\n\\tint score1=calculateScore(player1);\\n   \\tint score2=calculateScore(player2);\\n   \\tif(score1<score2){\\n   \\t\\treturn 2;\\n   \\t}else if(score1>score2){\\n   \\t\\treturn 1;\\n   \\t}\\n   \\treturn 0;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int calculateScore(vector<int> &player){\\n\\tint score = 0;\\n\\tint twiceHits = 0; \\n\\tfor(int i = 0;i< player.size();i++){\\n\\t\\tscore += player[i];\\n\\t\\tif(twiceHits){ // check if the hits will be twiced or not \\n\\t\\t\\tscore+=player[i];\\n\\t\\t\\ttwiceHits--;\\n\\t\\t}\\n\\t\\tif(player[i]==10){\\n\\t\\t\\ttwiceHits = 2; // twice the hits for next two attempts\\n\\t\\t}\\n\\t}\\n\\treturn score;\\n}\\n\\nint isWinner(vector<int>& player1, vector<int>& player2) {\\n\\tint score1=calculateScore(player1);\\n   \\tint score2=calculateScore(player2);\\n   \\tif(score1<score2){\\n   \\t\\treturn 2;\\n   \\t}else if(score1>score2){\\n   \\t\\treturn 1;\\n   \\t}\\n   \\treturn 0;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468359,
                "title": "simplest-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution{\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) \\n    {\\n        int s1=0, s2=0;\\n        for(int x=0; x<player1.size(); x++)\\n        {\\n            if((x-1>=0 && player1[x-1]==10) || (x-2>=0 && player1[x-2]==10)) \\n            s1+=player1[x]*2;\\n            else s1+=player1[x];\\n            \\n            if((x-1>=0 && player2[x-1]==10) || (x-2>=0 && player2[x-2]==10)) \\n            s2+=player2[x]*2;\\n            else s2+=player2[x];\\n        }\\n        if(s1==s2) return 0;\\n        if(s1>s2) return 1;\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution{\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) \\n    {\\n        int s1=0, s2=0;\\n        for(int x=0; x<player1.size(); x++)\\n        {\\n            if((x-1>=0 && player1[x-1]==10) || (x-2>=0 && player1[x-2]==10)) \\n            s1+=player1[x]*2;\\n            else s1+=player1[x];\\n            \\n            if((x-1>=0 && player2[x-1]==10) || (x-2>=0 && player2[x-2]==10)) \\n            s2+=player2[x]*2;\\n            else s2+=player2[x];\\n        }\\n        if(s1==s2) return 0;\\n        if(s1>s2) return 1;\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468306,
                "title": "javascript-direct-way-78ms",
                "content": "```\\nconst isWinner = (a, b) => {\\n    let ra = cal(a), rb = cal(b);\\n    return ra == rb ? 0 : ra > rb ? 1 : 2;\\n};\\n\\nconst cal = (a) => {\\n    let n = a.length, res = 0;\\n    a.map((x, i) => {\\n        if ((i-1 >= 0 && a[i-1] == 10) || (i-2 >= 0 && a[i-2] == 10)) {\\n            res += 2 * x;\\n        } else {\\n            res += x;\\n        }\\n    });\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\nconst isWinner = (a, b) => {\\n    let ra = cal(a), rb = cal(b);\\n    return ra == rb ? 0 : ra > rb ? 1 : 2;\\n};\\n\\nconst cal = (a) => {\\n    let n = a.length, res = 0;\\n    a.map((x, i) => {\\n        if ((i-1 >= 0 && a[i-1] == 10) || (i-2 >= 0 && a[i-2] == 10)) {\\n            res += 2 * x;\\n        } else {\\n            res += x;\\n        }\\n    });\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3468274,
                "title": "c-simple-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& num1, vector<int>& num2) {\\n        if(num1.size()==1){\\n            if(num1[0]>num2[0]) return 1;\\n            else if(num1[0]<num2[0]) return 2;\\n            return 0;\\n        }else if(num1.size() == 2){\\n            int x = num1[0]+num1[1];\\n            if(num1[0]==10) x += num1[1];\\n            int y = num2[0]+num2[1];\\n            if(num2[0]==10) y+=num2[1];\\n            if(x>y) return 1;\\n            else if(x<y) return 2;\\n            return 0;\\n        }\\n        long long sum1=0,sum2=0;\\n        sum1 += (num1[0]+num1[1]);\\n        if(num1[0]==10) sum1 += num1[1];\\n        sum2 += (num2[0]+num2[1]);\\n        if(num2[0]==10) sum2 += num2[1];\\n        for(int i=2;i<num1.size();i++){\\n            if(num1[i-2]==10 || num1[i-1]==10) sum1 += (num1[i]*2);\\n            else sum1 += num1[i];\\n        }\\n        for(int i=2;i<num2.size();i++){\\n            if(num2[i-2]==10 || num2[i-1]==10) sum2 += (num2[i]*2);\\n            else sum2 += num2[i];\\n        }\\n        if(sum1>sum2) return 1;\\n        else if(sum1<sum2) return 2;\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& num1, vector<int>& num2) {\\n        if(num1.size()==1){\\n            if(num1[0]>num2[0]) return 1;\\n            else if(num1[0]<num2[0]) return 2;\\n            return 0;\\n        }else if(num1.size() == 2){\\n            int x = num1[0]+num1[1];\\n            if(num1[0]==10) x += num1[1];\\n            int y = num2[0]+num2[1];\\n            if(num2[0]==10) y+=num2[1];\\n            if(x>y) return 1;\\n            else if(x<y) return 2;\\n            return 0;\\n        }\\n        long long sum1=0,sum2=0;\\n        sum1 += (num1[0]+num1[1]);\\n        if(num1[0]==10) sum1 += num1[1];\\n        sum2 += (num2[0]+num2[1]);\\n        if(num2[0]==10) sum2 += num2[1];\\n        for(int i=2;i<num1.size();i++){\\n            if(num1[i-2]==10 || num1[i-1]==10) sum1 += (num1[i]*2);\\n            else sum1 += num1[i];\\n        }\\n        for(int i=2;i<num2.size();i++){\\n            if(num2[i-2]==10 || num2[i-1]==10) sum2 += (num2[i]*2);\\n            else sum2 += num2[i];\\n        }\\n        if(sum1>sum2) return 1;\\n        else if(sum1<sum2) return 2;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468266,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int a = player1.length,b = player2.length;\\n        \\n        int first =0;\\n        int second = 0;\\n        int count=0;\\n        int i=0;\\n        while(i<a){\\n            if(player1[i]==10){\\n                count = 2;\\n                first+=player1[i];\\n                i++;\\n                while(count!=0 && i<a){\\n                    first += (2*player1[i]);\\n                    count--;\\n                     if(player1[i]==10) count=2;\\n                    i++;\\n\\n                }\\n            }else{\\n                first +=player1[i];\\n                i++;\\n            }\\n        }\\n        i=0;\\n        count=0;\\n        while(i<b){\\n            if(player2[i]==10){\\n                count = 2;\\n                second+=player2[i];\\n                i++;\\n                while(count!=0 && i<b){\\n                    second += (2*player2[i]);\\n                    count--;\\n                    if(player2[i]==10) count=2;\\n                    i++;\\n                }\\n            }else{\\n                second +=player2[i];\\n                i++;\\n            }\\n        }\\n        if(first>second) return 1;\\n        else if(first<second) return 2;\\n        else return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int a = player1.length,b = player2.length;\\n        \\n        int first =0;\\n        int second = 0;\\n        int count=0;\\n        int i=0;\\n        while(i<a){\\n            if(player1[i]==10){\\n                count = 2;\\n                first+=player1[i];\\n                i++;\\n                while(count!=0 && i<a){\\n                    first += (2*player1[i]);\\n                    count--;\\n                     if(player1[i]==10) count=2;\\n                    i++;\\n\\n                }\\n            }else{\\n                first +=player1[i];\\n                i++;\\n            }\\n        }\\n        i=0;\\n        count=0;\\n        while(i<b){\\n            if(player2[i]==10){\\n                count = 2;\\n                second+=player2[i];\\n                i++;\\n                while(count!=0 && i<b){\\n                    second += (2*player2[i]);\\n                    count--;\\n                    if(player2[i]==10) count=2;\\n                    i++;\\n                }\\n            }else{\\n                second +=player2[i];\\n                i++;\\n            }\\n        }\\n        if(first>second) return 1;\\n        else if(first<second) return 2;\\n        else return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091682,
                "title": "multiplication-matrix-intuitive-python-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to record some sort of flag or state to record the status of the multiplier of future indices as we go along through the pass of the array. We can create a multiplier matrix which records whether or not we multiply by 1 (if no 10 scored in the past two pins) or 2.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate the two matrices (arrays) for the two players. If you see a 10, set the values to 2 in the next two indices if they exist. Then just calculate\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) We pass through the length of the array once\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) we create 2 O(1) for recording the score, but 2 arrays with the same length as n.\\n# Code\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        multMatrix1, multMatrix2 = [ 1 ] * len(player1), [ 1 ] * len(player2)\\n        firstScore, secondScore = 0, 0\\n        \\n        for i in range(len(player1)):\\n            if player1[i] == 10:\\n                if i + 1 < len(player1):\\n                    multMatrix1[i+1] = 2\\n                    if i + 2 < len(player2):\\n                        multMatrix1[i+2] = 2\\n            if player2[i] == 10:\\n                if i + 1 < len(player2):\\n                    multMatrix2[i+1] = 2\\n                    if i + 2 < len(player2):\\n                        multMatrix2[i+2] = 2\\n            firstScore += multMatrix1[i] * player1[i]\\n            secondScore += multMatrix2[i] * player2[i]\\n\\n        return 1 if firstScore > secondScore else 2 if secondScore >  firstScore else 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        multMatrix1, multMatrix2 = [ 1 ] * len(player1), [ 1 ] * len(player2)\\n        firstScore, secondScore = 0, 0\\n        \\n        for i in range(len(player1)):\\n            if player1[i] == 10:\\n                if i + 1 < len(player1):\\n                    multMatrix1[i+1] = 2\\n                    if i + 2 < len(player2):\\n                        multMatrix1[i+2] = 2\\n            if player2[i] == 10:\\n                if i + 1 < len(player2):\\n                    multMatrix2[i+1] = 2\\n                    if i + 2 < len(player2):\\n                        multMatrix2[i+2] = 2\\n            firstScore += multMatrix1[i] * player1[i]\\n            secondScore += multMatrix2[i] * player2[i]\\n\\n        return 1 if firstScore > secondScore else 2 if secondScore >  firstScore else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085233,
                "title": "easy-cpp-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- As the condition is any 2 previous turns, we have to check them individually, and if any one of them is having 10 score then, we will add them again into the score of respective player.\\n- Else we will simply add the score as it is into the player\\'s score variable (a || b).\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int sz = player1.size();\\n        int a=0,b=0;\\n        int a10=0, b10=0;\\n        for(int i=0; i<sz; i++){\\n            a += player1[i];\\n            b += player2[i];\\n            if(i-1 >= 0 && player1[i-1] == 10) a += player1[i];\\n            else if(i-2 >= 0 && player1[i-2] == 10) a += player1[i];\\n            if(i-1 >= 0 && player2[i-1] == 10) b += player2[i];\\n            else if(i-2 >= 0 && player2[i-2] == 10) b += player2[i];\\n        }\\n        if(a == b) return 0;\\n        return a > b ? 1 : 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int sz = player1.size();\\n        int a=0,b=0;\\n        int a10=0, b10=0;\\n        for(int i=0; i<sz; i++){\\n            a += player1[i];\\n            b += player2[i];\\n            if(i-1 >= 0 && player1[i-1] == 10) a += player1[i];\\n            else if(i-2 >= 0 && player1[i-2] == 10) a += player1[i];\\n            if(i-1 >= 0 && player2[i-1] == 10) b += player2[i];\\n            else if(i-2 >= 0 && player2[i-2] == 10) b += player2[i];\\n        }\\n        if(a == b) return 0;\\n        return a > b ? 1 : 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032673,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        // calculate score of player1\\n        int score1 = calc(player1);\\n        int score2 = calc(player2);\\n\\n        if(score1 == score2)\\n            return 0;\\n        \\n        if(score1 < score2)\\n            return 2;\\n        \\n        return 1;\\n    }\\n    public int calc(int[] nums){\\n        int score = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            int prev1 = (i - 1) >= 0 ? nums[i - 1] : 0;\\n            int prev2 = (i - 2) >= 0 ? nums[i - 2] : 0;\\n            score = score + (prev1 == 10 || prev2 == 10 ? 2 * nums[i] : nums[i]);\\n        }\\n        return score;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        // calculate score of player1\\n        int score1 = calc(player1);\\n        int score2 = calc(player2);\\n\\n        if(score1 == score2)\\n            return 0;\\n        \\n        if(score1 < score2)\\n            return 2;\\n        \\n        return 1;\\n    }\\n    public int calc(int[] nums){\\n        int score = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            int prev1 = (i - 1) >= 0 ? nums[i - 1] : 0;\\n            int prev2 = (i - 2) >= 0 ? nums[i - 2] : 0;\\n            score = score + (prev1 == 10 || prev2 == 10 ? 2 * nums[i] : nums[i]);\\n        }\\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4025720,
                "title": "simple-cpp-solution-that-beats-100-users",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int Score(vector<int>& player){\\n        int s=0,f=0;\\n        for(int p:player){\\n            s += (f>0)? 2*p: p;\\n            f--;\\n            if(p==10) \\n                f=2;\\n        }\\n        return s;\\n    }\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int s1 = Score(player1), s2 = Score(player2);\\n        if(s1 > s2) return 1;\\n        if(s1 < s2) return 2;\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int Score(vector<int>& player){\\n        int s=0,f=0;\\n        for(int p:player){\\n            s += (f>0)? 2*p: p;\\n            f--;\\n            if(p==10) \\n                f=2;\\n        }\\n        return s;\\n    }\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int s1 = Score(player1), s2 = Score(player2);\\n        if(s1 > s2) return 1;\\n        if(s1 < s2) return 2;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4021493,
                "title": "java-simple-solution-o-n-easy-to-understand",
                "content": "# Intuition\\nCalculate both scores comapre them \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nConstant\\n\\n# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        \\n        if(player1.length != player2.length ) return -1;\\n\\n        int score1 = calculateScore(player1);\\n\\n        int score2 = calculateScore(player2);\\n\\n        if(score1 > score2) return 1;\\n\\n        else if(score2 > score1) return 2;\\n\\n        else return 0;\\n\\n    }\\n\\n\\n    private int calculateScore (int [] arr){\\n\\n        int score = 0 ;\\n        for (int i = 0 ; i < arr.length ; i++ ){\\n           \\n            if((i - 1 >= 0 && arr[i-1] ==  10) || (i - 2 >= 0 && arr[i-2] ==  10)){\\n                score += 2*arr[i];\\n            }\\n            else{\\n                 score += arr[i]; \\n            }\\n           \\n        }\\n        return score;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        \\n        if(player1.length != player2.length ) return -1;\\n\\n        int score1 = calculateScore(player1);\\n\\n        int score2 = calculateScore(player2);\\n\\n        if(score1 > score2) return 1;\\n\\n        else if(score2 > score1) return 2;\\n\\n        else return 0;\\n\\n    }\\n\\n\\n    private int calculateScore (int [] arr){\\n\\n        int score = 0 ;\\n        for (int i = 0 ; i < arr.length ; i++ ){\\n           \\n            if((i - 1 >= 0 && arr[i-1] ==  10) || (i - 2 >= 0 && arr[i-2] ==  10)){\\n                score += 2*arr[i];\\n            }\\n            else{\\n                 score += arr[i]; \\n            }\\n           \\n        }\\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018795,
                "title": "only-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int sum1 = 0;\\n        int sum2 = 0;\\n        for (int i = player1.length - 1; i >= 0; i--) {\\n            if ((i - 1 > -1) && player1[i - 1] == 10) {\\n                sum1 += player1[i] * 2;\\n            } else if ((i - 2 > -1) && player1[i - 2] == 10) {\\n                sum1 += player1[i] * 2;\\n            } else {\\n                sum1 += player1[i];\\n            }\\n        }\\n        \\n        for (int i = player2.length - 1; i >= 0; i--) {\\n            if ((i - 1 > -1) && player2[i - 1] == 10) {\\n                sum2 += player2[i] * 2;\\n            } else if ((i - 2 > -1) && player2[i - 2] == 10) {\\n                sum2 += player2[i] * 2;\\n            } else {\\n                sum2 += player2[i];\\n            }\\n        }\\n        if(sum1 > sum2) return 1; \\n        else if(sum1 < sum2)  return 2;\\n        else return 0;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int sum1 = 0;\\n        int sum2 = 0;\\n        for (int i = player1.length - 1; i >= 0; i--) {\\n            if ((i - 1 > -1) && player1[i - 1] == 10) {\\n                sum1 += player1[i] * 2;\\n            } else if ((i - 2 > -1) && player1[i - 2] == 10) {\\n                sum1 += player1[i] * 2;\\n            } else {\\n                sum1 += player1[i];\\n            }\\n        }\\n        \\n        for (int i = player2.length - 1; i >= 0; i--) {\\n            if ((i - 1 > -1) && player2[i - 1] == 10) {\\n                sum2 += player2[i] * 2;\\n            } else if ((i - 2 > -1) && player2[i - 2] == 10) {\\n                sum2 += player2[i] * 2;\\n            } else {\\n                sum2 += player2[i];\\n            }\\n        }\\n        if(sum1 > sum2) return 1; \\n        else if(sum1 < sum2)  return 2;\\n        else return 0;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014531,
                "title": "python-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        score_p1, score_p2 = 0, 0\\n        factor = 2\\n\\n        for i in range(len(player1)):\\n            if i >= 1 and (player1[i-1] == 10 or (i >= 2 and player1[i-2] == 10)):\\n                score_p1 += player1[i] * factor\\n            else:\\n                score_p1 += player1[i]\\n            \\n            if i >= 1 and (player2[i-1] == 10 or (i >= 2 and player2[i-2] == 10)):\\n                score_p2 += player2[i] * factor\\n            else:\\n                score_p2 += player2[i]\\n        \\n        if score_p1 == score_p2:\\n            return 0\\n        elif score_p1 > score_p2:\\n            return 1\\n        else:\\n            return 2\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        score_p1, score_p2 = 0, 0\\n        factor = 2\\n\\n        for i in range(len(player1)):\\n            if i >= 1 and (player1[i-1] == 10 or (i >= 2 and player1[i-2] == 10)):\\n                score_p1 += player1[i] * factor\\n            else:\\n                score_p1 += player1[i]\\n            \\n            if i >= 1 and (player2[i-1] == 10 or (i >= 2 and player2[i-2] == 10)):\\n                score_p2 += player2[i] * factor\\n            else:\\n                score_p2 += player2[i]\\n        \\n        if score_p1 == score_p2:\\n            return 0\\n        elif score_p1 > score_p2:\\n            return 1\\n        else:\\n            return 2\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011596,
                "title": "javascript-reduce",
                "content": "# Code\\n```\\nvar isWinner = function(player1, player2) {\\n    const calc = (arr) => arr.reduce((a, b, i) => a + (b * ((arr[i - 1] === 10 || arr[i - 2] === 10) ? 2 : 1)), 0)\\n    let a = calc(player1);\\n    let b = calc(player2);\\n    if (a === b) return 0;\\n    return a > b ? 1 : 2;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isWinner = function(player1, player2) {\\n    const calc = (arr) => arr.reduce((a, b, i) => a + (b * ((arr[i - 1] === 10 || arr[i - 2] === 10) ? 2 : 1)), 0)\\n    let a = calc(player1);\\n    let b = calc(player2);\\n    if (a === b) return 0;\\n    return a > b ? 1 : 2;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4007159,
                "title": "easy-to-understand-python3-solution-brute-force-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        player1_score, player2_score = 0, 0\\n\\n        for i in range(len(player1)):\\n            if i == 0:\\n                player1_score += player1[i]\\n            elif i == 1:\\n                if player1[i-1] == 10:\\n                    player1_score += 2 * player1[i]\\n                else:\\n                    player1_score += player1[i]\\n            else:\\n                if i % 2 == 0:\\n                    if player1[i-1] == 10 or player1[i-2] == 10:\\n                        player1_score += 2 * player1[i]\\n                    else:\\n                        player1_score += player1[i]\\n                else:\\n                    if player1[i-1] == 10 or player1[i-2] == 10:\\n                        player1_score += 2 * player1[i]\\n                    else:\\n                        player1_score += player1[i]\\n        \\n        for i in range(len(player2)):\\n            if i == 0:\\n                player2_score += player2[i]\\n            elif i == 1:\\n                if player2[i-1] == 10:\\n                    player2_score += 2 * player2[i]\\n                else:\\n                    player2_score += player2[i] \\n            else:\\n                if i % 2 == 0:\\n                    if player2[i-1] == 10 or player2[i-2] == 10:\\n                        player2_score += 2 * player2[i]\\n                    else:\\n                        player2_score += player2[i]\\n                else:\\n                    if player2[i-1] == 10 or player2[i-2] == 10:\\n                        player2_score += 2 * player2[i]\\n                    else:\\n                        player2_score += player2[i]\\n\\n        if player1_score > player2_score:\\n            return 1\\n        elif player1_score < player2_score:\\n            return 2\\n        else:\\n            return 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        player1_score, player2_score = 0, 0\\n\\n        for i in range(len(player1)):\\n            if i == 0:\\n                player1_score += player1[i]\\n            elif i == 1:\\n                if player1[i-1] == 10:\\n                    player1_score += 2 * player1[i]\\n                else:\\n                    player1_score += player1[i]\\n            else:\\n                if i % 2 == 0:\\n                    if player1[i-1] == 10 or player1[i-2] == 10:\\n                        player1_score += 2 * player1[i]\\n                    else:\\n                        player1_score += player1[i]\\n                else:\\n                    if player1[i-1] == 10 or player1[i-2] == 10:\\n                        player1_score += 2 * player1[i]\\n                    else:\\n                        player1_score += player1[i]\\n        \\n        for i in range(len(player2)):\\n            if i == 0:\\n                player2_score += player2[i]\\n            elif i == 1:\\n                if player2[i-1] == 10:\\n                    player2_score += 2 * player2[i]\\n                else:\\n                    player2_score += player2[i] \\n            else:\\n                if i % 2 == 0:\\n                    if player2[i-1] == 10 or player2[i-2] == 10:\\n                        player2_score += 2 * player2[i]\\n                    else:\\n                        player2_score += player2[i]\\n                else:\\n                    if player2[i-1] == 10 or player2[i-2] == 10:\\n                        player2_score += 2 * player2[i]\\n                    else:\\n                        player2_score += player2[i]\\n\\n        if player1_score > player2_score:\\n            return 1\\n        elif player1_score < player2_score:\\n            return 2\\n        else:\\n            return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003206,
                "title": "simple-java-100-tc-solution",
                "content": "# Intuition\\nEach score must be tracked. Remember that every time a player scores a 10, the next two rounds have a multiplier of two.\\n\\n# Approach\\nCreate three variables for each player. One of which is a tick that counts down the two days where the multiplier is active for that player. Make sure that if a player scores a 10, the tick is set to 2 and the multiplier is set to 2. For each iteration, make sure 1 is subtracted from the tick as long as it is greater than 0. Once the tick hits 0, set the multiplier back to 1.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int multi1 = 1;\\n        int multi2 = 1;\\n        int tick1 = 0;\\n        int tick2 = 0;\\n        int total1 = 0;\\n        int total2 = 0;\\n\\n        for (int i = 0; i < player1.length; i++)\\n        {\\n            total1 += player1[i] * multi1;\\n            total2 += player2[i] * multi2;\\n            if (tick1 == 0)\\n                multi1 = 1;\\n            if (tick2 == 0)\\n                multi2 = 1;\\n            \\n            if (player1[i] == 10)\\n            {\\n                tick1 = 2;\\n                multi1 = 2;\\n            }\\n            if (player2[i] == 10)\\n            {\\n                tick2 = 2;\\n                multi2 = 2;\\n            }\\n\\n            if (tick1 > 0)\\n                tick1--;\\n            if (tick2 > 0)\\n                tick2--;\\n        }\\n\\n        if (total1 > total2)\\n            return 1;\\n        else if (total2 > total1)\\n            return 2;\\n        else\\n            return 0;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int multi1 = 1;\\n        int multi2 = 1;\\n        int tick1 = 0;\\n        int tick2 = 0;\\n        int total1 = 0;\\n        int total2 = 0;\\n\\n        for (int i = 0; i < player1.length; i++)\\n        {\\n            total1 += player1[i] * multi1;\\n            total2 += player2[i] * multi2;\\n            if (tick1 == 0)\\n                multi1 = 1;\\n            if (tick2 == 0)\\n                multi2 = 1;\\n            \\n            if (player1[i] == 10)\\n            {\\n                tick1 = 2;\\n                multi1 = 2;\\n            }\\n            if (player2[i] == 10)\\n            {\\n                tick2 = 2;\\n                multi2 = 2;\\n            }\\n\\n            if (tick1 > 0)\\n                tick1--;\\n            if (tick2 > 0)\\n                tick2--;\\n        }\\n\\n        if (total1 > total2)\\n            return 1;\\n        else if (total2 > total1)\\n            return 2;\\n        else\\n            return 0;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990150,
                "title": "easy-to-read-python-solution-with-a-helper-function-to-calculate-score-explanation-in-comments",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n\\n\\n        #declaring a helper function\\n        def calcScore(player):\\n            #let\\'s declare two variables to store the score of the prev two rounds\\n            r1 = 0 #round - 1\\n            r2 = 0  #round - 2\\n\\n            score = 0\\n\\n            for pins in player:\\n                #update score depending on the number of pins hit on the prev two rounds\\n                if r1 == 10 or r2 == 10:\\n                    score += (2 * pins)\\n                else:\\n                    score += pins\\n                \\n                #now update the prev round and the round before that scores\\n                r2 = r1 #be wary of this order\\n                #move r1s value to r2 first \\n                # and then udpate r1\\n                r1 = pins\\n \\n                \\n\\n            return score\\n        \\n        #now we simply calculate the score for each player and return a result\\n\\n        p1 = calcScore(player1)\\n        p2 = calcScore(player2)\\n\\n        if p1 > p2:\\n            return 1\\n        \\n        if p2 > p1:\\n            return 2\\n        \\n        if p1 == p2:\\n            return 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n\\n\\n        #declaring a helper function\\n        def calcScore(player):\\n            #let\\'s declare two variables to store the score of the prev two rounds\\n            r1 = 0 #round - 1\\n            r2 = 0  #round - 2\\n\\n            score = 0\\n\\n            for pins in player:\\n                #update score depending on the number of pins hit on the prev two rounds\\n                if r1 == 10 or r2 == 10:\\n                    score += (2 * pins)\\n                else:\\n                    score += pins\\n                \\n                #now update the prev round and the round before that scores\\n                r2 = r1 #be wary of this order\\n                #move r1s value to r2 first \\n                # and then udpate r1\\n                r1 = pins\\n \\n                \\n\\n            return score\\n        \\n        #now we simply calculate the score for each player and return a result\\n\\n        p1 = calcScore(player1)\\n        p2 = calcScore(player2)\\n\\n        if p1 > p2:\\n            return 1\\n        \\n        if p2 > p1:\\n            return 2\\n        \\n        if p1 == p2:\\n            return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980933,
                "title": "c-basic-game-logic",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n    public int IsWinner(int[] player1, int[] player2) {\\n        int sumOfPlayer1 = CalculatePlayerPoint(player1, 1);\\n            int sumOfPlayer2=CalculatePlayerPoint(player2, 1);\\n            return sumOfPlayer1>sumOfPlayer2?1:sumOfPlayer1==sumOfPlayer2?0:2;\\n    }\\n    private static int CalculatePlayerPoint(int[] playerPoints, int multiplier)\\n        {\\n            int sumOfPoints = 0;\\n            int multiplierTime = 2;\\n            for (int i = 0; i < playerPoints.Length; i++)\\n            {\\n                sumOfPoints += playerPoints[i] * multiplier;\\n                if (multiplier == 2)\\n                    multiplierTime--;\\n                if(multiplierTime==0)\\n                    multiplier = 1;\\n                if (playerPoints[i] == 10)\\n                {\\n                    multiplier = 2;\\n                    multiplierTime=2;\\n                }\\n            }\\n            return sumOfPoints;\\n        }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int IsWinner(int[] player1, int[] player2) {\\n        int sumOfPlayer1 = CalculatePlayerPoint(player1, 1);\\n            int sumOfPlayer2=CalculatePlayerPoint(player2, 1);\\n            return sumOfPlayer1>sumOfPlayer2?1:sumOfPlayer1==sumOfPlayer2?0:2;\\n    }\\n    private static int CalculatePlayerPoint(int[] playerPoints, int multiplier)\\n        {\\n            int sumOfPoints = 0;\\n            int multiplierTime = 2;\\n            for (int i = 0; i < playerPoints.Length; i++)\\n            {\\n                sumOfPoints += playerPoints[i] * multiplier;\\n                if (multiplier == 2)\\n                    multiplierTime--;\\n                if(multiplierTime==0)\\n                    multiplier = 1;\\n                if (playerPoints[i] == 10)\\n                {\\n                    multiplier = 2;\\n                    multiplierTime=2;\\n                }\\n            }\\n            return sumOfPoints;\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976423,
                "title": "nice-and-elegant-solution-in-java-beats-100-rt-and-98-memory",
                "content": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int sum1 = 0;\\n        int sum2 = 0;\\n        int strike1 = 0;\\n        int strike2 = 0;\\n        for (int i = 0; i < player1.length; i++) {\\n            sum1 += player1[i];\\n            sum2 += player2[i];\\n            if (strike1-- > 0) {\\n                sum1 += player1[i];\\n            }\\n            if (strike2-- > 0) {\\n                sum2 += player2[i];\\n            }\\n            if (player1[i] == 10) {\\n                strike1 = 2;\\n            }\\n            if (player2[i] == 10) {\\n                strike2 = 2;\\n            }\\n        }\\n        return sum1 > sum2 ? 1 : sum2 > sum1 ? 2 : 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int sum1 = 0;\\n        int sum2 = 0;\\n        int strike1 = 0;\\n        int strike2 = 0;\\n        for (int i = 0; i < player1.length; i++) {\\n            sum1 += player1[i];\\n            sum2 += player2[i];\\n            if (strike1-- > 0) {\\n                sum1 += player1[i];\\n            }\\n            if (strike2-- > 0) {\\n                sum2 += player2[i];\\n            }\\n            if (player1[i] == 10) {\\n                strike1 = 2;\\n            }\\n            if (player2[i] == 10) {\\n                strike2 = 2;\\n            }\\n        }\\n        return sum1 > sum2 ? 1 : sum2 > sum1 ? 2 : 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3964667,
                "title": "beats-97-64-straightforward-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        sc = []\\n        def calculate(player):\\n            strike = 0\\n            score = 0\\n            for i in range(len(player)):\\n                if strike <= 0:\\n                    score += player[i]\\n                else:\\n                    score += 2*player[i]\\n                strike -= 1\\n                if player[i] == 10:\\n                    strike = 2\\n            sc.append(score)\\n        calculate(player1)\\n        calculate(player2)\\n        print(sc)\\n        if sc[0] > sc[1]:\\n            return 1\\n        if sc[0] == sc[1]:\\n            return 0\\n        return 2\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        sc = []\\n        def calculate(player):\\n            strike = 0\\n            score = 0\\n            for i in range(len(player)):\\n                if strike <= 0:\\n                    score += player[i]\\n                else:\\n                    score += 2*player[i]\\n                strike -= 1\\n                if player[i] == 10:\\n                    strike = 2\\n            sc.append(score)\\n        calculate(player1)\\n        calculate(player2)\\n        print(sc)\\n        if sc[0] > sc[1]:\\n            return 1\\n        if sc[0] == sc[1]:\\n            return 0\\n        return 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3961443,
                "title": "python-beginners-4-line",
                "content": "- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n```\\nclass Solution(object):\\n    def isWinner(self, player1, player2):\\n        ans=0\\n        for i in range(len(player1)):\\n            ans +=player1[i]*(1+(10 in player1[max(0,i-2):i]))\\n            ans -=player2[i]*(1+(10 in player2[max(0,i-2):i]))\\n        return int(ans>0) if ans>=0 else 2\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def isWinner(self, player1, player2):\\n        ans=0\\n        for i in range(len(player1)):\\n            ans +=player1[i]*(1+(10 in player1[max(0,i-2):i]))\\n            ans -=player2[i]*(1+(10 in player2[max(0,i-2):i]))\\n        return int(ans>0) if ans>=0 else 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960748,
                "title": "easy-solution-3-lines",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        def get_score(player):\\n            return sum(player[i] * (2 if (i and player[i-1] == 10) or (i > 1 and player[i-2] == 10) else 1) for i, turn in enumerate(player))\\n        return 1 if (s1 := get_score(player1)) > (s2 := get_score(player2)) else 2 if s2 > s1 else 0 \\n```\\n\\nPlease let me know if any improvements can be made.\\n\\nThanks",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        def get_score(player):\\n            return sum(player[i] * (2 if (i and player[i-1] == 10) or (i > 1 and player[i-2] == 10) else 1) for i, turn in enumerate(player))\\n        return 1 if (s1 := get_score(player1)) > (s2 := get_score(player2)) else 2 if s2 > s1 else 0 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957411,
                "title": "simple-array-traversal-faster-than-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n       int res1=0,res2=0;\\n       for(int i=0;i<player1.length;i++)\\n       {\\n           if((i>1 && player1[i-2]==10 ) || (i>0 && player1[i-1]==10) )\\n           res1+=2*player1[i];\\n           else\\n           res1+=player1[i]; \\n           if((i>1 && player2[i-2]==10) || (i>0 && player2[i-1]==10))\\n           res2+=2*player2[i];\\n           else\\n           res2+=player2[i];\\n       } \\n       return res1==res2?0:res1>res2?1:2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n       int res1=0,res2=0;\\n       for(int i=0;i<player1.length;i++)\\n       {\\n           if((i>1 && player1[i-2]==10 ) || (i>0 && player1[i-1]==10) )\\n           res1+=2*player1[i];\\n           else\\n           res1+=player1[i]; \\n           if((i>1 && player2[i-2]==10) || (i>0 && player2[i-1]==10))\\n           res2+=2*player2[i];\\n           else\\n           res2+=player2[i];\\n       } \\n       return res1==res2?0:res1>res2?1:2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947910,
                "title": "java-solution-beats-100-runtime-1ms-o-n-space-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nIterate through all possible elements in both arrays, check whether 2 previous element is equal to 10, and then determine the calculation. Be careful with edge case handling, for example when there\\'s only one entry.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n>Because this code only uses three integer variables, which counts as O(1) regardless of operation. And there\\'s no other dynamic data structures like array except the input arrays. The input array is not considered as space complexity of this code chunk becaue it\\'s part of the input. The space complexity analysis typically focuses on the additional space (beyond the input) that an algorithm uses to produce its result. \\n\\n# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int p1 = 0, p2 = 0;\\n        int len = player1.length;\\n\\n        // If there\\'s only 1 turn\\n        if (len == 1) {\\n            p1 += player1[0];\\n            p2 += player2[0];\\n            return p1 > p2 ? 1 : (p2 > p1 ? 2 : 0);\\n        }\\n\\n        // For all turns except the first\\n        for (int i = 1; i < len; i++) {\\n            if (player1[i-1] == 10 || (i-2 >= 0 && player1[i-2] == 10)) {\\n                p1 += player1[i]*2;\\n            } else {\\n                p1 += player1[i];\\n            }\\n\\n            if (player2[i-1] == 10 || (i-2 >= 0 && player2[i-2] == 10)) {\\n                p2 += player2[i]*2;\\n            } else {\\n                p2 += player2[i];\\n            }\\n        }\\n\\n        // Handle the first turn\\n        p1 += player1[0];\\n        p2 += player2[0];\\n\\n        return p1 > p2 ? 1 : (p2 > p1 ? 2 : 0);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int p1 = 0, p2 = 0;\\n        int len = player1.length;\\n\\n        // If there\\'s only 1 turn\\n        if (len == 1) {\\n            p1 += player1[0];\\n            p2 += player2[0];\\n            return p1 > p2 ? 1 : (p2 > p1 ? 2 : 0);\\n        }\\n\\n        // For all turns except the first\\n        for (int i = 1; i < len; i++) {\\n            if (player1[i-1] == 10 || (i-2 >= 0 && player1[i-2] == 10)) {\\n                p1 += player1[i]*2;\\n            } else {\\n                p1 += player1[i];\\n            }\\n\\n            if (player2[i-1] == 10 || (i-2 >= 0 && player2[i-2] == 10)) {\\n                p2 += player2[i]*2;\\n            } else {\\n                p2 += player2[i];\\n            }\\n        }\\n\\n        // Handle the first turn\\n        p1 += player1[0];\\n        p2 += player2[0];\\n\\n        return p1 > p2 ? 1 : (p2 > p1 ? 2 : 0);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939476,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int s1=0;int s2=0;\\n        int n=player1.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            s1+=player1[i];\\n            if(i==1)\\n            {\\n                if(player1[0]==10)\\n                {\\n                    s1+=player1[i];\\n                }\\n            }\\n            else if(i>1 and (player1[i-1]==10 or player1[i-2]==10))\\n            {\\n                s1+=player1[i];\\n            }\\n            \\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            s2+=player2[i];\\n            if(i==1)\\n            {\\n                if(player2[0]==10)\\n                {\\n                    s2+=player2[i];\\n                }\\n            }\\n            else if(i>1 and (player2[i-1]==10 or player2[i-2]==10))\\n            {\\n                s2+=player2[i];\\n            }\\n            \\n        }\\n        if(s1>s2)\\n        return 1;\\n        if(s2>s1)\\n        return 2;\\n        else return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int s1=0;int s2=0;\\n        int n=player1.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            s1+=player1[i];\\n            if(i==1)\\n            {\\n                if(player1[0]==10)\\n                {\\n                    s1+=player1[i];\\n                }\\n            }\\n            else if(i>1 and (player1[i-1]==10 or player1[i-2]==10))\\n            {\\n                s1+=player1[i];\\n            }\\n            \\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            s2+=player2[i];\\n            if(i==1)\\n            {\\n                if(player2[0]==10)\\n                {\\n                    s2+=player2[i];\\n                }\\n            }\\n            else if(i>1 and (player2[i-1]==10 or player2[i-2]==10))\\n            {\\n                s2+=player2[i];\\n            }\\n            \\n        }\\n        if(s1>s2)\\n        return 1;\\n        if(s2>s1)\\n        return 2;\\n        else return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928745,
                "title": "c-solution-based-on-brute-force-and-very-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBrute force built on all possible cases\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNaive approach \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(n1+n2)~O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->  O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int n1=player1.size();\\n        int n2=player2.size();\\n        int sum1=0,sum2=0;\\n       \\n        sum1=0;sum2=0;\\n        for(int i=0;i<n1;i++)\\n        {\\n            if(i==0)\\n            {\\n                sum1+=player1[i];\\n            }\\n             if(i==1 && player1[0]==10)\\n            {\\n                sum1+=2*player1[i];\\n            }\\n             if(i==1 && player1[0]!=10)\\n            {\\n                sum1+=player1[i];\\n            }\\n            \\n            else if((i>1)&&(player1[i-1]==10 || player1[i-2]==10))\\n            {\\n                sum1+=2*player1[i];\\n            }\\n            else  if((i>1)&&(player1[i-1]!=10 || player1[i-2]!=10))\\n            {\\n                sum1+=player1[i];\\n            }\\n        }\\n        for(int j=0;j<n2;j++)\\n        {\\n            if(j==0)\\n            {\\n                sum2+=player2[j];\\n            }\\n             if(j==1 && player2[0]==10)\\n            {\\n                sum2+=2*player2[j];\\n            }\\n            if(j==1 && player2[0]!=10)\\n            {\\n                sum2+=player2[j];\\n            }\\n            \\n            else if((j>1)&&(player2[j-1]==10 || player2[j-2]==10))\\n            {\\n                sum2+=2*player2[j];\\n            }\\n            else if((j>1)&&(player2[j-1]!=10 || player2[j-2]!=10))\\n            {\\n                sum2+=player2[j];\\n            }\\n        }\\n        \\n        if (sum1>sum2) \\n        {return 1;\\n        }\\n        else if(sum2>sum1)\\n        {return 2;\\n        }\\n        else\\n        { return 0;}\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int n1=player1.size();\\n        int n2=player2.size();\\n        int sum1=0,sum2=0;\\n       \\n        sum1=0;sum2=0;\\n        for(int i=0;i<n1;i++)\\n        {\\n            if(i==0)\\n            {\\n                sum1+=player1[i];\\n            }\\n             if(i==1 && player1[0]==10)\\n            {\\n                sum1+=2*player1[i];\\n            }\\n             if(i==1 && player1[0]!=10)\\n            {\\n                sum1+=player1[i];\\n            }\\n            \\n            else if((i>1)&&(player1[i-1]==10 || player1[i-2]==10))\\n            {\\n                sum1+=2*player1[i];\\n            }\\n            else  if((i>1)&&(player1[i-1]!=10 || player1[i-2]!=10))\\n            {\\n                sum1+=player1[i];\\n            }\\n        }\\n        for(int j=0;j<n2;j++)\\n        {\\n            if(j==0)\\n            {\\n                sum2+=player2[j];\\n            }\\n             if(j==1 && player2[0]==10)\\n            {\\n                sum2+=2*player2[j];\\n            }\\n            if(j==1 && player2[0]!=10)\\n            {\\n                sum2+=player2[j];\\n            }\\n            \\n            else if((j>1)&&(player2[j-1]==10 || player2[j-2]==10))\\n            {\\n                sum2+=2*player2[j];\\n            }\\n            else if((j>1)&&(player2[j-1]!=10 || player2[j-2]!=10))\\n            {\\n                sum2+=player2[j];\\n            }\\n        }\\n        \\n        if (sum1>sum2) \\n        {return 1;\\n        }\\n        else if(sum2>sum1)\\n        {return 2;\\n        }\\n        else\\n        { return 0;}\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3922637,
                "title": "python-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def isWinner(self, player1, player2):\\n        \"\"\"\\n        :type player1: List[int]\\n        :type player2: List[int]\\n        :rtype: int\\n        \"\"\"\\n        def getScore(player):\\n            count, score = 0, 0\\n\\n            for i in range(len(player)):  \\n                if count > 0:\\n                    score += player[i] * 2\\n                    count -= 1\\n                else:\\n                    score += player[i]\\n                if player[i] == 10:\\n                    count = 2\\n            return score\\n\\n        player1Score, player2Score = getScore(player1), getScore(player2)\\n\\n        if player1Score > player2Score:\\n            return 1\\n        elif player1Score < player2Score:\\n            return 2\\n        else:\\n            return 0\\n\\n\\n                \\n            \\n                    \\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def isWinner(self, player1, player2):\\n        \"\"\"\\n        :type player1: List[int]\\n        :type player2: List[int]\\n        :rtype: int\\n        \"\"\"\\n        def getScore(player):\\n            count, score = 0, 0\\n\\n            for i in range(len(player)):  \\n                if count > 0:\\n                    score += player[i] * 2\\n                    count -= 1\\n                else:\\n                    score += player[i]\\n                if player[i] == 10:\\n                    count = 2\\n            return score\\n\\n        player1Score, player2Score = getScore(player1), getScore(player2)\\n\\n        if player1Score > player2Score:\\n            return 1\\n        elif player1Score < player2Score:\\n            return 2\\n        else:\\n            return 0\\n\\n\\n                \\n            \\n                    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920800,
                "title": "easy-and-simple-java-solution-runtime-1-ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n\\n        int player1_Score = calScore(player1);\\n        int player2_Score = calScore(player2);\\n\\n        if(player1_Score > player2_Score){\\n            return 1;\\n        } \\n        if(player1_Score < player2_Score){\\n            return 2;\\n        } \\n        return 0;\\n        \\n    }\\n\\n    private int calScore(int[] player){\\n\\n        boolean if10PinInLast2Turns = false;\\n        int sum = 0, counter = 0;\\n        for(int i=0; i<player.length; i++){\\n            sum += player[i];\\n            \\n            if(if10PinInLast2Turns){\\n                sum += player[i];\\n                counter++;\\n                \\n                if(counter == 2){\\n                    if10PinInLast2Turns = false;\\n                    counter = 0;\\n                }\\n            }\\n            if(player[i]==10){\\n                if10PinInLast2Turns = true;\\n                counter = 0;\\n                \\n            }\\n\\n            \\n        }\\n        //System.out.println(sum);\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n\\n        int player1_Score = calScore(player1);\\n        int player2_Score = calScore(player2);\\n\\n        if(player1_Score > player2_Score){\\n            return 1;\\n        } \\n        if(player1_Score < player2_Score){\\n            return 2;\\n        } \\n        return 0;\\n        \\n    }\\n\\n    private int calScore(int[] player){\\n\\n        boolean if10PinInLast2Turns = false;\\n        int sum = 0, counter = 0;\\n        for(int i=0; i<player.length; i++){\\n            sum += player[i];\\n            \\n            if(if10PinInLast2Turns){\\n                sum += player[i];\\n                counter++;\\n                \\n                if(counter == 2){\\n                    if10PinInLast2Turns = false;\\n                    counter = 0;\\n                }\\n            }\\n            if(player[i]==10){\\n                if10PinInLast2Turns = true;\\n                counter = 0;\\n                \\n            }\\n\\n            \\n        }\\n        //System.out.println(sum);\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3907074,
                "title": "python-simple-solution-with-explanation",
                "content": "# Intuition\\nWe need to compute the scores based on the pins struck by each player. As the algorithm is repeated, we can use a helper function to compute the scores of player1 and player2\\n\\n# Approach\\nWe iterate through the list to compute the scores of each player. Note that we have to look at up to `i-2` indexes. Consider the cases where the input scores are 2 and below. For this we compute the result of the first 2 indexes separately before computing at index of >= 2\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n\\n        def get_score(scores)-> int:\\n            total = scores[0]\\n            \\n            if len(scores) > 1:\\n                if total == 10:\\n                    total += (2 * scores[1])\\n                else:\\n                    total += scores[1]\\n            \\n            # Start at index 2\\n            for i in range(2, len(scores)):\\n                if scores[i - 1] == 10 or scores[i - 2] == 10:\\n                    total += (2 * scores[i])\\n                else:\\n                    total += scores[i]\\n            return total\\n            \\n        p1 = get_score(player1)\\n        p2 = get_score(player2)\\n\\n        if p1 == p2:\\n            return 0\\n        elif p1 > p2:\\n            return 1\\n        else:\\n            return 2\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n\\n        def get_score(scores)-> int:\\n            total = scores[0]\\n            \\n            if len(scores) > 1:\\n                if total == 10:\\n                    total += (2 * scores[1])\\n                else:\\n                    total += scores[1]\\n            \\n            # Start at index 2\\n            for i in range(2, len(scores)):\\n                if scores[i - 1] == 10 or scores[i - 2] == 10:\\n                    total += (2 * scores[i])\\n                else:\\n                    total += scores[i]\\n            return total\\n            \\n        p1 = get_score(player1)\\n        p2 = get_score(player2)\\n\\n        if p1 == p2:\\n            return 0\\n        elif p1 > p2:\\n            return 1\\n        else:\\n            return 2\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903129,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\nint a = player1.size(), b = player2.size();\\n        \\n        int first = 0, second = 0, count = 0, i = 0;\\n        while (i < a) {\\n            if (player1[i] == 10) {\\n                count = 2;\\n                first += player1[i];\\n                i++;\\n                while (count != 0 && i < a) {\\n                    first += (2 * player1[i]);\\n                    count--;\\n                    if (player1[i] == 10) count = 2;\\n                    i++;\\n                }\\n            }\\n            else {\\n                first += player1[i];\\n                i++;\\n            }\\n        }\\n        \\n        i = 0;\\n        count = 0;\\n        while (i < b) {\\n            if (player2[i] == 10) {\\n                count = 2;\\n                second += player2[i];\\n                i++;\\n                while (count != 0 && i < b) {\\n                    second += (2 * player2[i]);\\n                    count--;\\n                    if (player2[i] == 10) count = 2;\\n                    i++;\\n                }\\n            }\\n            else {\\n                second += player2[i];\\n                i++;\\n            }\\n        }\\n        \\n        if (first > second) return 1;\\n        else if (first < second) return 2;\\n        else return 0;\\n\\n\\n\\n\\n\\n\\n\\n\\n       /* int sum1=0;\\n        int sum2=0;\\n        int maxno=INT_MIN;\\n        for(int i=0; i<player1.size(); i++){\\n            if(player1[i-1]||player1[i-2]==10){\\n              sum1+=player1[i]+player1[i];\\n              else{sum1+=player1[i];\\n              }\\n                 \\n            }\\n            }\\n            for(int j=0; j<player2.size(); j++){\\n                if(player2[j-1]||player2[j-2]==10){\\n                sum2+=player2[j]*2;\\n                else{\\n                 sum2+=player2[j];\\n                }\\n                \\n        } \\n        maxno=max(sum1, sum2);\\n      }\\n      return maxno;*/\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\nint a = player1.size(), b = player2.size();\\n        \\n        int first = 0, second = 0, count = 0, i = 0;\\n        while (i < a) {\\n            if (player1[i] == 10) {\\n                count = 2;\\n                first += player1[i];\\n                i++;\\n                while (count != 0 && i < a) {\\n                    first += (2 * player1[i]);\\n                    count--;\\n                    if (player1[i] == 10) count = 2;\\n                    i++;\\n                }\\n            }\\n            else {\\n                first += player1[i];\\n                i++;\\n            }\\n        }\\n        \\n        i = 0;\\n        count = 0;\\n        while (i < b) {\\n            if (player2[i] == 10) {\\n                count = 2;\\n                second += player2[i];\\n                i++;\\n                while (count != 0 && i < b) {\\n                    second += (2 * player2[i]);\\n                    count--;\\n                    if (player2[i] == 10) count = 2;\\n                    i++;\\n                }\\n            }\\n            else {\\n                second += player2[i];\\n                i++;\\n            }\\n        }\\n        \\n        if (first > second) return 1;\\n        else if (first < second) return 2;\\n        else return 0;\\n\\n\\n\\n\\n\\n\\n\\n\\n       /* int sum1=0;\\n        int sum2=0;\\n        int maxno=INT_MIN;\\n        for(int i=0; i<player1.size(); i++){\\n            if(player1[i-1]||player1[i-2]==10){\\n              sum1+=player1[i]+player1[i];\\n              else{sum1+=player1[i];\\n              }\\n                 \\n            }\\n            }\\n            for(int j=0; j<player2.size(); j++){\\n                if(player2[j-1]||player2[j-2]==10){\\n                sum2+=player2[j]*2;\\n                else{\\n                 sum2+=player2[j];\\n                }\\n                \\n        } \\n        maxno=max(sum1, sum2);\\n      }\\n      return maxno;*/\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899598,
                "title": "easy-and-understandable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        s1,s2=player1[0],player2[0]\\n        for i in range(1,len(player1)):\\n            if i == 1:\\n                if player1[0] == 10:\\n                    s1+=(2*player1[1])\\n                    continue                \\n            elif i>1 and any(player1[j] == 10 for j in range(i-2,i)):\\n                s1+=(2*player1[i])\\n                continue            \\n            s1+=player1[i]\\n        for i in range(1,len(player2)):\\n            if i == 1:\\n                if player2[0] == 10:\\n                    s2+=(2*player2[1])\\n                    continue\\n            elif i>1 and any(player2[j] == 10 for j in range(i-2,i)):\\n                s2+=(2*player2[i])\\n                continue\\n            s2+=player2[i]\\n        if s1 > s2:\\n            return 1\\n        elif s2 > s1:\\n            return 2\\n        return 0\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        s1,s2=player1[0],player2[0]\\n        for i in range(1,len(player1)):\\n            if i == 1:\\n                if player1[0] == 10:\\n                    s1+=(2*player1[1])\\n                    continue                \\n            elif i>1 and any(player1[j] == 10 for j in range(i-2,i)):\\n                s1+=(2*player1[i])\\n                continue            \\n            s1+=player1[i]\\n        for i in range(1,len(player2)):\\n            if i == 1:\\n                if player2[0] == 10:\\n                    s2+=(2*player2[1])\\n                    continue\\n            elif i>1 and any(player2[j] == 10 for j in range(i-2,i)):\\n                s2+=(2*player2[i])\\n                continue\\n            s2+=player2[i]\\n        if s1 > s2:\\n            return 1\\n        elif s2 > s1:\\n            return 2\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3893305,
                "title": "java-2ms-beats-87-37",
                "content": "# Intuition & Approach\\n- use a simulation strategy\\n- at each strike, reset the player\\'s strike weight\\n- decrement strike weight every round \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// 2ms Beats 87.37%\\n\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n\\n        int n = player1.length;\\n        \\n        int[][] pins = new int[2][n];\\n        pins[0] = player1;\\n        pins[1] = player2;\\n\\n        // strategy: simulation\\n\\n        int[] scores = new int[2];\\n        int[] strikeWeight = new int[2];\\n\\n        for (int round = 0; round < n; ++round) {\\n            for (int player = 0; player < 2; ++player) {\\n\\n                // determine multiplier\\n                int multiplier = 1;\\n                if (strikeWeight[player] > 0) {\\n                    multiplier = 2;\\n                }\\n\\n                // add score to running total\\n                scores[player] += pins[player][round] * multiplier;\\n\\n                // adjust strike count as needed\\n                if (pins[player][round] == 10) {\\n                    strikeWeight[player] = 2;\\n                } else {\\n                    strikeWeight[player] = clamp(strikeWeight[player] - 1, 0, 2);\\n                }\\n            }\\n        }\\n\\n        // determine winner\\n        if (scores[0] > scores[1]) {\\n            return 1;\\n        } else if (scores[1] > scores[0]) {\\n            return 2;\\n        } else {\\n            return 0;\\n        }\\n        \\n    }\\n\\n    private int clamp(int val, int lower, int upper) {\\n        if (val < lower) {\\n            return lower;\\n        } else if (val > upper) {\\n            return upper;\\n        } else {\\n            return val;\\n        }\\n    }\\n\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// 2ms Beats 87.37%\\n\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n\\n        int n = player1.length;\\n        \\n        int[][] pins = new int[2][n];\\n        pins[0] = player1;\\n        pins[1] = player2;\\n\\n        // strategy: simulation\\n\\n        int[] scores = new int[2];\\n        int[] strikeWeight = new int[2];\\n\\n        for (int round = 0; round < n; ++round) {\\n            for (int player = 0; player < 2; ++player) {\\n\\n                // determine multiplier\\n                int multiplier = 1;\\n                if (strikeWeight[player] > 0) {\\n                    multiplier = 2;\\n                }\\n\\n                // add score to running total\\n                scores[player] += pins[player][round] * multiplier;\\n\\n                // adjust strike count as needed\\n                if (pins[player][round] == 10) {\\n                    strikeWeight[player] = 2;\\n                } else {\\n                    strikeWeight[player] = clamp(strikeWeight[player] - 1, 0, 2);\\n                }\\n            }\\n        }\\n\\n        // determine winner\\n        if (scores[0] > scores[1]) {\\n            return 1;\\n        } else if (scores[1] > scores[0]) {\\n            return 2;\\n        } else {\\n            return 0;\\n        }\\n        \\n    }\\n\\n    private int clamp(int val, int lower, int upper) {\\n        if (val < lower) {\\n            return lower;\\n        } else if (val > upper) {\\n            return upper;\\n        } else {\\n            return val;\\n        }\\n    }\\n\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889429,
                "title": "python-simple-python-solution",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 373 ms, faster than 5.11% of Python3 online submissions for Determine the Winner of a Bowling Game.\\n# Memory Usage: 16.6 MB, less than 22.18% of Python3 online submissions for Determine the Winner of a Bowling Game.\\n\\n\\tclass Solution:\\n\\t\\tdef isWinner(self, player1: List[int], player2: List[int]) -> int:\\n\\n\\t\\t\\tscore_card1 , score_card2 = player1[:1] , player2[:1]\\n\\n\\t\\t\\tfor index in range(1 , len(player1)):\\n\\n\\t\\t\\t\\tif 10 in player1[:index][-2:]:\\n\\t\\t\\t\\t\\tscore_card1.append(player1[index] * 2)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tscore_card1.append(player1[index])\\n\\n\\t\\t\\t\\tif 10 in player2[:index][-2:]:\\n\\t\\t\\t\\t\\tscore_card2.append(player2[index] * 2)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tscore_card2.append(player2[index])\\n\\n\\t\\t\\tscore1 , score2 = sum(score_card1) , sum(score_card2)\\n\\n\\t\\t\\tif score1 == score2:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\telif score1 > score2:\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn 2\\n\\t\\t\\t\\t\\n\\tTime Complexity : O(n)\\n\\tSpace Complexity : O(1)\\n\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 373 ms, faster than 5.11% of Python3 online submissions for Determine the Winner of a Bowling Game.\\n# Memory Usage: 16.6 MB, less than 22.18% of Python3 online submissions for Determine the Winner of a Bowling Game.\\n\\n\\tclass Solution:\\n\\t\\tdef isWinner(self, player1: List[int], player2: List[int]) -> int:\\n\\n\\t\\t\\tscore_card1 , score_card2 = player1[:1] , player2[:1]\\n\\n\\t\\t\\tfor index in range(1 , len(player1)):\\n\\n\\t\\t\\t\\tif 10 in player1[:index][-2:]:\\n\\t\\t\\t\\t\\tscore_card1.append(player1[index] * 2)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tscore_card1.append(player1[index])\\n\\n\\t\\t\\t\\tif 10 in player2[:index][-2:]:\\n\\t\\t\\t\\t\\tscore_card2.append(player2[index] * 2)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tscore_card2.append(player2[index])\\n\\n\\t\\t\\tscore1 , score2 = sum(score_card1) , sum(score_card2)\\n\\n\\t\\t\\tif score1 == score2:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\telif score1 > score2:\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn 2\\n\\t\\t\\t\\t\\n\\tTime Complexity : O(n)\\n\\tSpace Complexity : O(1)\\n\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 3878676,
                "title": "winner-of-the-bowling-game",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        pl1=0\\n        pl2=0\\n        for i in range(len(player1)):\\n            pl1+=2*player1[i] if i-1>-1 and  10 in [player1[i-1],player1[i-2] if i-2>-1 else 0] else player1[i]\\n            pl2+=2*player2[i] if i-1>-1 and  10 in [player2[i-1],player2[i-2] if i-2>-1 else 0] else player2[i]\\n        return 1 if pl1>pl2 else(0 if pl1==pl2 else 2 )\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        pl1=0\\n        pl2=0\\n        for i in range(len(player1)):\\n            pl1+=2*player1[i] if i-1>-1 and  10 in [player1[i-1],player1[i-2] if i-2>-1 else 0] else player1[i]\\n            pl2+=2*player2[i] if i-1>-1 and  10 in [player2[i-1],player2[i-2] if i-2>-1 else 0] else player2[i]\\n        return 1 if pl1>pl2 else(0 if pl1==pl2 else 2 )\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876873,
                "title": "python-easy-clean-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        def cnt_points(lst):\\n            res = cnt = 0\\n            for i in lst:\\n                res += i\\n                if cnt > 0:\\n                    res += i\\n                    cnt -= 1\\n\\n                if i == 10:\\n                    cnt = 2\\n            return res\\n                \\n\\n        if cnt_points(player1) > cnt_points(player2):\\n            return 1\\n        elif cnt_points(player1) < cnt_points(player2):\\n            return 2\\n        else:\\n            return 0\\n```\\n![catty.png](https://assets.leetcode.com/users/images/e21cdc1e-ca0a-4d33-b734-d379e88435c6_1691413122.8635035.png)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        def cnt_points(lst):\\n            res = cnt = 0\\n            for i in lst:\\n                res += i\\n                if cnt > 0:\\n                    res += i\\n                    cnt -= 1\\n\\n                if i == 10:\\n                    cnt = 2\\n            return res\\n                \\n\\n        if cnt_points(player1) > cnt_points(player2):\\n            return 1\\n        elif cnt_points(player1) < cnt_points(player2):\\n            return 2\\n        else:\\n            return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865770,
                "title": "super-simple-c",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int IsWinner(int[] player1, int[] player2) {\\n        int Calc(int[] input) {\\n            var sum = 0;\\n            bool HitTenAt(int pos) {\\n                if (pos < 0) {\\n                    return false;\\n                }\\n                if (pos >= input.Length) {\\n                    return false;\\n                }\\n                return input[pos] == 10;\\n            }\\n\\n            for (var i = 0; i < input.Length; i++) {\\n                if (HitTenAt(i-1) || HitTenAt(i-2)) {\\n                    sum += input[i]*2;\\n                } else {\\n                    sum += input[i];\\n                }\\n            }\\n\\n            return sum;\\n        }\\n\\n        var one = Calc(player1);\\n        var two = Calc(player2);\\n        if  (one == two) {\\n            return 0;\\n        }\\n\\n        return one > two ? 1 : 2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int IsWinner(int[] player1, int[] player2) {\\n        int Calc(int[] input) {\\n            var sum = 0;\\n            bool HitTenAt(int pos) {\\n                if (pos < 0) {\\n                    return false;\\n                }\\n                if (pos >= input.Length) {\\n                    return false;\\n                }\\n                return input[pos] == 10;\\n            }\\n\\n            for (var i = 0; i < input.Length; i++) {\\n                if (HitTenAt(i-1) || HitTenAt(i-2)) {\\n                    sum += input[i]*2;\\n                } else {\\n                    sum += input[i];\\n                }\\n            }\\n\\n            return sum;\\n        }\\n\\n        var one = Calc(player1);\\n        var two = Calc(player2);\\n        if  (one == two) {\\n            return 0;\\n        }\\n\\n        return one > two ? 1 : 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3812137,
                "title": "my-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint isWinner(int* player1, int player1Size, int* player2, int player2Size){\\n    int p1 = 0;\\n    int p2 = 0;\\n    int i;\\n\\n    int p1x = 0;\\n    int p2x = 0;\\n    for(i=0;i<player1Size;i++){\\n        if(p1x){\\n            p1x--;\\n            p1 += (player1[i]*2);\\n        }\\n        else\\n            p1 += player1[i];\\n        if(p2x){\\n            p2x--;\\n            p2 += (player2[i]*2);\\n        }\\n        else\\n            p2 += player2[i];\\n\\n        if(player1[i] == 10)\\n            p1x = 2;\\n        if(player2[i] == 10)\\n            p2x = 2;\\n    }\\n\\n    if(p1==p2)\\n        return 0;\\n    return p1 > p2? 1: 2;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint isWinner(int* player1, int player1Size, int* player2, int player2Size){\\n    int p1 = 0;\\n    int p2 = 0;\\n    int i;\\n\\n    int p1x = 0;\\n    int p2x = 0;\\n    for(i=0;i<player1Size;i++){\\n        if(p1x){\\n            p1x--;\\n            p1 += (player1[i]*2);\\n        }\\n        else\\n            p1 += player1[i];\\n        if(p2x){\\n            p2x--;\\n            p2 += (player2[i]*2);\\n        }\\n        else\\n            p2 += player2[i];\\n\\n        if(player1[i] == 10)\\n            p1x = 2;\\n        if(player2[i] == 10)\\n            p2x = 2;\\n    }\\n\\n    if(p1==p2)\\n        return 0;\\n    return p1 > p2? 1: 2;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3810439,
                "title": "python-rusts-solution",
                "content": "# Code\\n```python []\\nclass Solution:\\n    @staticmethod\\n    def calculate_total(player: List[int]) -> int:\\n        total, last_ten = (0, -100)\\n        for index, score in enumerate(player):\\n            if index - last_ten <= 2:\\n                total += score * 2\\n            else:\\n                total += score\\n\\n            if score == 10:\\n                last_ten = index\\n\\n        return total\\n\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        if self.calculate_total(player1) == self.calculate_total(player2):\\n            return 0\\n        elif self.calculate_total(player1) > self.calculate_total(player2):\\n            return 1\\n        else:\\n            return 2\\n```\\n```rust []\\nuse std::cmp::{self, Ordering};\\n\\nimpl Solution {\\n    fn calculate_total_score(scores: &Vec<i32>) -> i32 {\\n        let mut last_ten: Option<usize> = None;\\n        let mut total_score = 0;\\n        for (pos, &score) in scores.iter().enumerate() {\\n            if let Some(x) = last_ten {\\n                if pos - x <= 2 {\\n                    total_score += score;\\n                }\\n            }\\n            total_score += score;\\n            if score == 10 {\\n                last_ten = Some(pos);\\n            }\\n        }\\n        total_score\\n    }\\n    pub fn is_winner(player1: Vec<i32>, player2: Vec<i32>) -> i32 {\\n        match Solution::calculate_total_score(&player1)\\n            .cmp(&Solution::calculate_total_score(&player2))\\n        {\\n            Ordering::Equal => 0,\\n            Ordering::Greater => 1,\\n            Ordering::Less => 2,\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Python3",
                    "Rust"
                ],
                "code": "```python []\\nclass Solution:\\n    @staticmethod\\n    def calculate_total(player: List[int]) -> int:\\n        total, last_ten = (0, -100)\\n        for index, score in enumerate(player):\\n            if index - last_ten <= 2:\\n                total += score * 2\\n            else:\\n                total += score\\n\\n            if score == 10:\\n                last_ten = index\\n\\n        return total\\n\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        if self.calculate_total(player1) == self.calculate_total(player2):\\n            return 0\\n        elif self.calculate_total(player1) > self.calculate_total(player2):\\n            return 1\\n        else:\\n            return 2\\n```\n```rust []\\nuse std::cmp::{self, Ordering};\\n\\nimpl Solution {\\n    fn calculate_total_score(scores: &Vec<i32>) -> i32 {\\n        let mut last_ten: Option<usize> = None;\\n        let mut total_score = 0;\\n        for (pos, &score) in scores.iter().enumerate() {\\n            if let Some(x) = last_ten {\\n                if pos - x <= 2 {\\n                    total_score += score;\\n                }\\n            }\\n            total_score += score;\\n            if score == 10 {\\n                last_ten = Some(pos);\\n            }\\n        }\\n        total_score\\n    }\\n    pub fn is_winner(player1: Vec<i32>, player2: Vec<i32>) -> i32 {\\n        match Solution::calculate_total_score(&player1)\\n            .cmp(&Solution::calculate_total_score(&player2))\\n        {\\n            Ordering::Equal => 0,\\n            Ordering::Greater => 1,\\n            Ordering::Less => 2,\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3809896,
                "title": "long-but-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>&p1 , vector<int>&p2){\\n        int sum1=p1[0] , sum2=p2[0];\\n        if(p1.size()==1){\\n            if(sum1>sum2){\\n                return 1;\\n            }\\n            else if(sum2>sum1){\\n                return 2;\\n            }\\n            return 0;\\n        }\\n        if(p1[0]==10){\\n            sum1+=(2*p1[1]);\\n        }\\n        else{\\n            sum1+=p1[1];\\n        }\\n        if(p2[0]==10){\\n            sum2+=(2*p2[1]);\\n        }\\n        else{\\n            sum2+=p2[1];\\n        }\\n        for(int i=2; i<p1.size(); i++){\\n            if(p1[i-1]==10 || p1[i-2]==10){\\n                sum1+=(p1[i]*2);\\n            }\\n            else{\\n                sum1+=p1[i];\\n            }\\n        }\\n        for(int i=2; i<p2.size(); i++){\\n            if(p2[i-1]==10 || p2[i-2]==10){\\n                sum2+=(p2[i]*2);\\n            }\\n            else{\\n                sum2+=p2[i];\\n            }\\n        }\\n        if(sum1>sum2){\\n            return 1;\\n        }\\n        else if(sum1<sum2){\\n            return 2;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>&p1 , vector<int>&p2){\\n        int sum1=p1[0] , sum2=p2[0];\\n        if(p1.size()==1){\\n            if(sum1>sum2){\\n                return 1;\\n            }\\n            else if(sum2>sum1){\\n                return 2;\\n            }\\n            return 0;\\n        }\\n        if(p1[0]==10){\\n            sum1+=(2*p1[1]);\\n        }\\n        else{\\n            sum1+=p1[1];\\n        }\\n        if(p2[0]==10){\\n            sum2+=(2*p2[1]);\\n        }\\n        else{\\n            sum2+=p2[1];\\n        }\\n        for(int i=2; i<p1.size(); i++){\\n            if(p1[i-1]==10 || p1[i-2]==10){\\n                sum1+=(p1[i]*2);\\n            }\\n            else{\\n                sum1+=p1[i];\\n            }\\n        }\\n        for(int i=2; i<p2.size(); i++){\\n            if(p2[i-1]==10 || p2[i-2]==10){\\n                sum2+=(p2[i]*2);\\n            }\\n            else{\\n                sum2+=p2[i];\\n            }\\n        }\\n        if(sum1>sum2){\\n            return 1;\\n        }\\n        else if(sum1<sum2){\\n            return 2;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801009,
                "title": "simple-kotlin-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    fun isWinner(player1: IntArray, player2: IntArray): Int {\\n        var score1 = player1[0]\\n        var score2 = player2[0]\\n        var i = 1\\n\\n        while (i < player1.size) {\\n            score1 += calculateScore(i, player1)\\n            score2 += calculateScore(i, player2)\\n            i++\\n        }\\n\\n        return if (score1 > score2) 1 else if (score1 < score2) 2 else 0\\n    }\\n\\n    private fun calculateScore(i: Int, scores: IntArray) =\\n        if (scores[i-1] == 10 || i-2 >= 0 && scores[i-2] == 10)\\n            scores[i] * 2\\n        else scores[i]\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun isWinner(player1: IntArray, player2: IntArray): Int {\\n        var score1 = player1[0]\\n        var score2 = player2[0]\\n        var i = 1\\n\\n        while (i < player1.size) {\\n            score1 += calculateScore(i, player1)\\n            score2 += calculateScore(i, player2)\\n            i++\\n        }\\n\\n        return if (score1 > score2) 1 else if (score1 < score2) 2 else 0\\n    }\\n\\n    private fun calculateScore(i: Int, scores: IntArray) =\\n        if (scores[i-1] == 10 || i-2 >= 0 && scores[i-2] == 10)\\n            scores[i] * 2\\n        else scores[i]\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3790982,
                "title": "count-points-per-player-98-speed",
                "content": "![image.png](https://assets.leetcode.com/users/images/e4811f84-9fe9-4684-924f-94606eb4b831_1689834723.3181927.png)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        last2 = last1 = False\\n        sum1 = 0\\n        for x in player1:\\n            sum1 += x * (2 if last2 or last1 else 1)\\n            last2 = last1\\n            last1 = x == 10\\n        last2 = last1 = False\\n        sum2 = 0\\n        for x in player2:\\n            sum2 += x * (2 if last2 or last1 else 1)\\n            last2 = last1\\n            last1 = x == 10\\n        return 1 if sum1 > sum2 else (2 if sum2 > sum1 else 0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        last2 = last1 = False\\n        sum1 = 0\\n        for x in player1:\\n            sum1 += x * (2 if last2 or last1 else 1)\\n            last2 = last1\\n            last1 = x == 10\\n        last2 = last1 = False\\n        sum2 = 0\\n        for x in player2:\\n            sum2 += x * (2 if last2 or last1 else 1)\\n            last2 = last1\\n            last1 = x == 10\\n        return 1 if sum1 > sum2 else (2 if sum2 > sum1 else 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3789117,
                "title": "python3-simple-beats-97-66-runtime-and-60-58-memory",
                "content": "# Code\\n```\\nclass Solution:\\n    def isWinner(self, p1: List[int], p2: List[int]) -> int:\\n        def calc_score(p):\\n            doubles = sum = 0\\n            for i in p:\\n                if(doubles > 0):\\n                    sum += 2*i\\n                    doubles -= 1\\n                else:\\n                    sum += i\\n                if(i == 10):\\n                    doubles = 2\\n            return sum\\n\\n        c1, c2 = calc_score(p1), calc_score(p2)\\n        if(c1 == c2):\\n            return 0\\n        if(c1 > c2):\\n            return 1\\n        return 2\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isWinner(self, p1: List[int], p2: List[int]) -> int:\\n        def calc_score(p):\\n            doubles = sum = 0\\n            for i in p:\\n                if(doubles > 0):\\n                    sum += 2*i\\n                    doubles -= 1\\n                else:\\n                    sum += i\\n                if(i == 10):\\n                    doubles = 2\\n            return sum\\n\\n        c1, c2 = calc_score(p1), calc_score(p2)\\n        if(c1 == c2):\\n            return 0\\n        if(c1 > c2):\\n            return 1\\n        return 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783132,
                "title": "simple-beats-99-80-of-java-users",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int player1Score = 0;\\n        int player2Score = 0;\\n        \\n        for(int i = 0; i < player1.length; i++){\\n            if(i > 0 && player1[i - 1] == 10 ){\\n                player1Score += 2 * player1[i];\\n                continue;\\n            }\\n            if(i > 1 && (player1[i - 1] == 10|| player1[i-2] ==10)){\\n                player1Score += 2 * player1[i];\\n                continue;\\n            }\\n            player1Score += player1[i];\\n        }\\n\\n        for(int i = 0; i < player2.length; i++){\\n            if(i > 0 && player2[i - 1] == 10 ){\\n                player2Score += 2 * player2[i];\\n                continue;\\n            }\\n            if(i > 1 && (player2[i - 1] == 10|| player2[i-2] ==10)){\\n                player2Score += 2 * player2[i];\\n                continue;\\n            }\\n            player2Score += player2[i];\\n        }\\n\\n        if(player1Score > player2Score){\\n            return 1;\\n        }else if(player1Score < player2Score){\\n            return 2;\\n        }else{\\n            return 0;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int player1Score = 0;\\n        int player2Score = 0;\\n        \\n        for(int i = 0; i < player1.length; i++){\\n            if(i > 0 && player1[i - 1] == 10 ){\\n                player1Score += 2 * player1[i];\\n                continue;\\n            }\\n            if(i > 1 && (player1[i - 1] == 10|| player1[i-2] ==10)){\\n                player1Score += 2 * player1[i];\\n                continue;\\n            }\\n            player1Score += player1[i];\\n        }\\n\\n        for(int i = 0; i < player2.length; i++){\\n            if(i > 0 && player2[i - 1] == 10 ){\\n                player2Score += 2 * player2[i];\\n                continue;\\n            }\\n            if(i > 1 && (player2[i - 1] == 10|| player2[i-2] ==10)){\\n                player2Score += 2 * player2[i];\\n                continue;\\n            }\\n            player2Score += player2[i];\\n        }\\n\\n        if(player1Score > player2Score){\\n            return 1;\\n        }else if(player1Score < player2Score){\\n            return 2;\\n        }else{\\n            return 0;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783066,
                "title": "c-o-n-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int n = player1.size();\\n        int res1 = 0;\\n        int res2 = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i > 0 && player1[i-1] == 10)\\n                res1 += 2 * player1[i];\\n            else if(i > 1 && player1[i-2] == 10)\\n                res1 += 2 * player1[i];\\n            else\\n                res1 += player1[i];\\n            if(i > 0 && player2[i-1] == 10)\\n                res2 += 2 * player2[i];\\n            else if(i > 1 && player2[i-2] == 10)\\n                res2 += 2 * player2[i];\\n            else\\n                res2 += player2[i];\\n        }\\n        if(res1 == res2)\\n            return 0;\\n        else if(res1 > res2)\\n            return 1;\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int n = player1.size();\\n        int res1 = 0;\\n        int res2 = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i > 0 && player1[i-1] == 10)\\n                res1 += 2 * player1[i];\\n            else if(i > 1 && player1[i-2] == 10)\\n                res1 += 2 * player1[i];\\n            else\\n                res1 += player1[i];\\n            if(i > 0 && player2[i-1] == 10)\\n                res2 += 2 * player2[i];\\n            else if(i > 1 && player2[i-2] == 10)\\n                res2 += 2 * player2[i];\\n            else\\n                res2 += player2[i];\\n        }\\n        if(res1 == res2)\\n            return 0;\\n        else if(res1 > res2)\\n            return 1;\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782877,
                "title": "typescript-detailed-explanation-simple-solution-beats-92-68",
                "content": "# Intuition\\n\\nThe problem requires comparing the total scores of two bowling players. The score is calculated by doubling the current turn\\'s pins if 10 were hit in the previous two turns, or else simply adding the current pins. By calculating each player\\'s total score, we can compare and determine the winner.\\n\\n# Approach\\n\\nWe just have to iterate through the array and add the values to a variable.\\n\\nWhenever we hit a 10 we set the strikeCounter to two and decrease it the following two rounds by one until it is zero. Now we can always check if stikeCounter is bigger than 0 and in that case add the value a second time to the total.\\n\\nAt the end we just compare the two numbers and return the correct result.\\n\\n# Complexity\\n- Time complexity: $$O(n + m)$$\\n\\nWe iterate through the two input arrays exactly one time each.\\n\\nOne could argue that this is $$O(n)$$ instead, because the arrays are the same size.\\n\\n- Space complexity: $$O(1)$$\\n\\nWe are only creating integer variables which are always the same size, so the space taken by this algorithm is constant -> $$O(1)$$\\n\\n# Code\\n```\\nfunction isWinner(playerOne: number[], playerTwo: number[]): number {\\n    let scorePlayerOne = getScore(playerOne);\\n    let scorePlayerTwo = getScore(playerTwo);\\n\\n    if (scorePlayerOne > scorePlayerTwo) {\\n        return 1;\\n    }\\n\\n    if (scorePlayerOne < scorePlayerTwo) {\\n        return 2;\\n    }\\n\\n    return 0;\\n};\\n\\nfunction getScore(pinsHit: number[]): number {\\n    let total = 0;\\n\\n    for (let i = 0, strikeCounter = 0; i < pinsHit.length; i++) {\\n        total += pinsHit[i];\\n\\n        if (strikeCounter > 0) {\\n            total += pinsHit[i];\\n            strikeCounter--;\\n        }\\n\\n        if (pinsHit[i] === 10) {\\n            strikeCounter = 2;\\n        }\\n    }\\n\\n    return total;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array",
                    "Math"
                ],
                "code": "```\\nfunction isWinner(playerOne: number[], playerTwo: number[]): number {\\n    let scorePlayerOne = getScore(playerOne);\\n    let scorePlayerTwo = getScore(playerTwo);\\n\\n    if (scorePlayerOne > scorePlayerTwo) {\\n        return 1;\\n    }\\n\\n    if (scorePlayerOne < scorePlayerTwo) {\\n        return 2;\\n    }\\n\\n    return 0;\\n};\\n\\nfunction getScore(pinsHit: number[]): number {\\n    let total = 0;\\n\\n    for (let i = 0, strikeCounter = 0; i < pinsHit.length; i++) {\\n        total += pinsHit[i];\\n\\n        if (strikeCounter > 0) {\\n            total += pinsHit[i];\\n            strikeCounter--;\\n        }\\n\\n        if (pinsHit[i] === 10) {\\n            strikeCounter = 2;\\n        }\\n    }\\n\\n    return total;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3778258,
                "title": "java-easy-solution-beats-99-80-2-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int ans = evaluateScore (player1) - evaluateScore (player2);\\n        if(ans > 0)\\n            return 1;\\n        else if(ans < 0)\\n            return 2;\\n        return 0;\\n    }\\n    private int evaluateScore(int[] player)\\n    {\\n        int hit = 0;\\n        int score = 0;\\n        for(int x : player)\\n        {\\n            score += (hit > 0 ? x * 2: x);\\n            if(x == 10)\\n                hit = 2;\\n            else\\n                hit--;\\n        }\\n        return score;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int ans = evaluateScore (player1) - evaluateScore (player2);\\n        if(ans > 0)\\n            return 1;\\n        else if(ans < 0)\\n            return 2;\\n        return 0;\\n    }\\n    private int evaluateScore(int[] player)\\n    {\\n        int hit = 0;\\n        int score = 0;\\n        for(int x : player)\\n        {\\n            score += (hit > 0 ? x * 2: x);\\n            if(x == 10)\\n                hit = 2;\\n            else\\n                hit--;\\n        }\\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3769743,
                "title": "c-simple-and-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int sum1=0;\\n        int sum2=0;\\n        for(int i=0;i<player1.size();i++){\\n            if((i > 1 )&& (player1[i-1] == 10 || player1[i-2] == 10)){\\n                sum1 += (2 * player1[i]);\\n            }\\n            else if(i==1 && player1[i-1] == 10){\\n                sum1 += (2 * player1[i]);\\n            }\\n            else{\\n                sum1 += player1[i];\\n            }\\n        }\\n        for(int i=0;i<player2.size();i++){\\n            if((i > 1) && (player2[i-1] == 10 || player2[i-2] == 10)){\\n                sum2 += (2 * player2[i]);\\n            }\\n            else if(i==1 && player2[i-1] == 10){\\n                sum2 += (2 * player2[i]);\\n            }\\n            else{\\n                sum2 += player2[i];\\n            }\\n        }\\n        if(sum1>sum2){\\n            return 1;\\n        }\\n        else if(sum1<sum2){\\n            return 2;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int sum1=0;\\n        int sum2=0;\\n        for(int i=0;i<player1.size();i++){\\n            if((i > 1 )&& (player1[i-1] == 10 || player1[i-2] == 10)){\\n                sum1 += (2 * player1[i]);\\n            }\\n            else if(i==1 && player1[i-1] == 10){\\n                sum1 += (2 * player1[i]);\\n            }\\n            else{\\n                sum1 += player1[i];\\n            }\\n        }\\n        for(int i=0;i<player2.size();i++){\\n            if((i > 1) && (player2[i-1] == 10 || player2[i-2] == 10)){\\n                sum2 += (2 * player2[i]);\\n            }\\n            else if(i==1 && player2[i-1] == 10){\\n                sum2 += (2 * player2[i]);\\n            }\\n            else{\\n                sum2 += player2[i];\\n            }\\n        }\\n        if(sum1>sum2){\\n            return 1;\\n        }\\n        else if(sum1<sum2){\\n            return 2;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766508,
                "title": "simple-javascript-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} player1\\n * @param {number[]} player2\\n * @return {number}\\n */\\nvar isWinner = function(player1, player2) {\\n    const getScore = (pins) => {\\n        let total = 0;\\n        for (let i = 0; i < pins.length; i++) {\\n            if (pins[i - 1] === 10 || pins[i - 2] === 10) total += pins[i] * 2;\\n            else total += pins[i];\\n        }\\n        return total;\\n    };\\n    const score1 = getScore(player1);\\n    const score2 = getScore(player2);\\n    return score1 > score2 ? 1 : score1 < score2 ? 2 : 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} player1\\n * @param {number[]} player2\\n * @return {number}\\n */\\nvar isWinner = function(player1, player2) {\\n    const getScore = (pins) => {\\n        let total = 0;\\n        for (let i = 0; i < pins.length; i++) {\\n            if (pins[i - 1] === 10 || pins[i - 2] === 10) total += pins[i] * 2;\\n            else total += pins[i];\\n        }\\n        return total;\\n    };\\n    const score1 = getScore(player1);\\n    const score2 = getScore(player2);\\n    return score1 > score2 ? 1 : score1 < score2 ? 2 : 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3765609,
                "title": "ez-cpp",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int sum=0;\\n        int sum1=0;\\n        for(int i=0;i<player1.size();i++){\\n            if((i-2>=0 && player1[i-2]==10) || (i-1>=0 && player1[i-1]==10)){\\n                sum+=player1[i]*2;\\n            }\\n            else{\\n                sum+=player1[i];\\n            }\\n\\n        }\\n\\n        for(int i=0;i<player2.size();i++){\\n            if((i-2>=0 && player2[i-2]==10) || (i-1>=0 && player2[i-1]==10)){\\n                sum1+=player2[i]*2;\\n            }\\n            else{\\n                sum1+=player2[i];\\n            }\\n\\n        }\\n\\n        if(sum==sum1){\\n            return 0;\\n        }\\n        if(sum>sum1){\\n            return 1;\\n        }\\n        \\n            return 2;\\n        \\n\\n\\n\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int sum=0;\\n        int sum1=0;\\n        for(int i=0;i<player1.size();i++){\\n            if((i-2>=0 && player1[i-2]==10) || (i-1>=0 && player1[i-1]==10)){\\n                sum+=player1[i]*2;\\n            }\\n            else{\\n                sum+=player1[i];\\n            }\\n\\n        }\\n\\n        for(int i=0;i<player2.size();i++){\\n            if((i-2>=0 && player2[i-2]==10) || (i-1>=0 && player2[i-1]==10)){\\n                sum1+=player2[i]*2;\\n            }\\n            else{\\n                sum1+=player2[i];\\n            }\\n\\n        }\\n\\n        if(sum==sum1){\\n            return 0;\\n        }\\n        if(sum>sum1){\\n            return 1;\\n        }\\n        \\n            return 2;\\n        \\n\\n\\n\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3761757,
                "title": "python3-direct-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        def addscore(ar):\\n            result = 0\\n            count = 0\\n            for i in range(len(ar)):\\n                if count > 0:\\n                    result += 2*ar[i]\\n                    count -= 1\\n                else:\\n                    result += ar[i]\\n                if ar[i] == 10 and count == 0:\\n                    count += 2\\n                elif ar[i] == 10 and count > 0:\\n                    count +=1\\n            return result\\n            \\n        score1 = addscore(player1)\\n        score2 = addscore(player2)\\n\\n        if score1 > score2:\\n            return 1\\n        elif score1 < score2:\\n            return 2\\n        else:\\n            return 0\\n\\n\\n\\n\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        def addscore(ar):\\n            result = 0\\n            count = 0\\n            for i in range(len(ar)):\\n                if count > 0:\\n                    result += 2*ar[i]\\n                    count -= 1\\n                else:\\n                    result += ar[i]\\n                if ar[i] == 10 and count == 0:\\n                    count += 2\\n                elif ar[i] == 10 and count > 0:\\n                    count +=1\\n            return result\\n            \\n        score1 = addscore(player1)\\n        score2 = addscore(player2)\\n\\n        if score1 > score2:\\n            return 1\\n        elif score1 < score2:\\n            return 2\\n        else:\\n            return 0\\n\\n\\n\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3757993,
                "title": "runtime-2-ms-beats-99-81-memory-43-4-mb-beats-88-31",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int sc1 = totalScore(player1);\\n        int sc2 = totalScore(player2);\\n        return sc1 > sc2 ? 1 : (sc2 > sc1 ? 2 : 0);\\n\\n\\n    }\\n\\n    private static int totalScore(int player[]) {\\n        int totalForPlayer = 0;\\n        int len = player.length;\\n        \\n        for (int i = 0; i < len; i++) {\\n            if (i == 0) {\\n                totalForPlayer += player[0];\\n            } else if (i == 1) {\\n                if (player[i - 1] == 10) {\\n                    totalForPlayer += player[i] * 2;\\n                } else {\\n                    totalForPlayer += player[i];\\n                }\\n            } else {\\n                if (player[i - 1] == 10 || player[i - 2] == 10) {\\n                    totalForPlayer += 2 * player[i];\\n                } else {\\n                    totalForPlayer += player[i];\\n                }\\n            }\\n        }\\n\\n        return totalForPlayer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int sc1 = totalScore(player1);\\n        int sc2 = totalScore(player2);\\n        return sc1 > sc2 ? 1 : (sc2 > sc1 ? 2 : 0);\\n\\n\\n    }\\n\\n    private static int totalScore(int player[]) {\\n        int totalForPlayer = 0;\\n        int len = player.length;\\n        \\n        for (int i = 0; i < len; i++) {\\n            if (i == 0) {\\n                totalForPlayer += player[0];\\n            } else if (i == 1) {\\n                if (player[i - 1] == 10) {\\n                    totalForPlayer += player[i] * 2;\\n                } else {\\n                    totalForPlayer += player[i];\\n                }\\n            } else {\\n                if (player[i - 1] == 10 || player[i - 2] == 10) {\\n                    totalForPlayer += 2 * player[i];\\n                } else {\\n                    totalForPlayer += player[i];\\n                }\\n            }\\n        }\\n\\n        return totalForPlayer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3749990,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        \\n        boolean isFirstTrue = false;\\n        boolean isSecondTrue = false;\\n\\n        int firstCounter = 0;\\n        int secondCounter = 0;\\n\\n        int firstSum = 0;\\n        int secondSum = 0;\\n\\n        for (int i : player1) {   \\n       \\n            if (isFirstTrue) {\\n                firstSum += i * 2;\\n                firstCounter++;\\n                if (firstCounter == 2) {\\n                    firstCounter = 0;\\n                    isFirstTrue = false;\\n                }\\n            } else {\\n                firstSum += i;\\n       \\n            }\\n                 if (i == 10) {\\n               isFirstTrue = true;\\n                    firstCounter = 0;\\n                    \\n            }\\n        }\\n\\n        \\n        for (int i : player2) {\\n  \\n            if (isSecondTrue) {\\n                secondSum += i * 2;\\n                secondCounter++;\\n                if (secondCounter == 2) {\\n                    secondCounter = 0;\\n                    isSecondTrue = false;\\n                }\\n            } else {\\n                \\n                secondSum += i;\\n                \\n            }\\n            if (i == 10) {\\n                isSecondTrue = true;\\n                secondCounter = 0;\\n            }\\n\\n        }\\n\\n        if (firstSum > secondSum) return  1;\\n        else if (firstSum < secondSum) return 2;\\n        else return 0;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        \\n        boolean isFirstTrue = false;\\n        boolean isSecondTrue = false;\\n\\n        int firstCounter = 0;\\n        int secondCounter = 0;\\n\\n        int firstSum = 0;\\n        int secondSum = 0;\\n\\n        for (int i : player1) {   \\n       \\n            if (isFirstTrue) {\\n                firstSum += i * 2;\\n                firstCounter++;\\n                if (firstCounter == 2) {\\n                    firstCounter = 0;\\n                    isFirstTrue = false;\\n                }\\n            } else {\\n                firstSum += i;\\n       \\n            }\\n                 if (i == 10) {\\n               isFirstTrue = true;\\n                    firstCounter = 0;\\n                    \\n            }\\n        }\\n\\n        \\n        for (int i : player2) {\\n  \\n            if (isSecondTrue) {\\n                secondSum += i * 2;\\n                secondCounter++;\\n                if (secondCounter == 2) {\\n                    secondCounter = 0;\\n                    isSecondTrue = false;\\n                }\\n            } else {\\n                \\n                secondSum += i;\\n                \\n            }\\n            if (i == 10) {\\n                isSecondTrue = true;\\n                secondCounter = 0;\\n            }\\n\\n        }\\n\\n        if (firstSum > secondSum) return  1;\\n        else if (firstSum < secondSum) return 2;\\n        else return 0;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3743528,
                "title": "python-code-with-o-n-time-complexity",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        window_size=2\\n        p=sum(player1)\\n        s=sum(player2)\\n        for i in range(2,len(player1)):\\n            if player1[i-1]==10 or player1[i-2]==10:\\n                p+=player1[i]\\n            if player2[i-1]==10 or player2[i-2]==10:\\n                s+=player2[i]\\n        if len(player1)>1:\\n            if player1[0]==10:\\n                p+=player1[1]\\n            if player2[0]==10:\\n                s+=player2[1]\\n        if p>s:\\n            return 1\\n        elif p<s:\\n            return 2\\n        else:\\n            return 0\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        window_size=2\\n        p=sum(player1)\\n        s=sum(player2)\\n        for i in range(2,len(player1)):\\n            if player1[i-1]==10 or player1[i-2]==10:\\n                p+=player1[i]\\n            if player2[i-1]==10 or player2[i-2]==10:\\n                s+=player2[i]\\n        if len(player1)>1:\\n            if player1[0]==10:\\n                p+=player1[1]\\n            if player2[0]==10:\\n                s+=player2[1]\\n        if p>s:\\n            return 1\\n        elif p<s:\\n            return 2\\n        else:\\n            return 0\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740869,
                "title": "my-python3-solution-understandable-for-beginners",
                "content": "**I hope it was helpful for you. If that so, I would be glad if you upvote**\\n# Code\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        score1 = 0\\n        score2 = 0\\n        if len(player1) == 1:\\n            score1 += player1[0]\\n        if len(player2) == 1:\\n            score2 += player2[0]\\n        else:\\n            for i in range (len(player1)):\\n                if i >= 2 and player1[i-2] == 10 or i >= 1 and player1[i-1] == 10:\\n                    score1 += player1[i] * 2\\n                else:\\n                    score1 += player1[i]\\n\\n            for i in range (len(player2)):\\n                if i >= 2 and player2[i-2] == 10 or i >= 1 and player2[i-1] == 10:\\n                    score2 += player2[i] * 2\\n                else:\\n                    score2 += player2[i]\\n\\n        return 1 if score1 > score2 else 2 if score1 < score2 else 0\\n```\\n# Complexity\\n- Time complexity: $$O(2*n) = O(n)$$",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        score1 = 0\\n        score2 = 0\\n        if len(player1) == 1:\\n            score1 += player1[0]\\n        if len(player2) == 1:\\n            score2 += player2[0]\\n        else:\\n            for i in range (len(player1)):\\n                if i >= 2 and player1[i-2] == 10 or i >= 1 and player1[i-1] == 10:\\n                    score1 += player1[i] * 2\\n                else:\\n                    score1 += player1[i]\\n\\n            for i in range (len(player2)):\\n                if i >= 2 and player2[i-2] == 10 or i >= 1 and player2[i-1] == 10:\\n                    score2 += player2[i] * 2\\n                else:\\n                    score2 += player2[i]\\n\\n        return 1 if score1 > score2 else 2 if score1 < score2 else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740158,
                "title": "java-simplest-concise-no-repetition-loop-traversal-100-passed",
                "content": "# Intuition\\nsimple loop traversal is enough. we just have to look back 2 indices so it must be linear approach.\\n\\n# Approach\\nadd current game point to the sum if any of previous 2 points were not 10, otherwise add 2*current point.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int p1 = score(player1);\\n        int p2 = score(player2);\\n        \\n        if(p1>p2) return 1;\\n        else if(p1<p2) return 2;\\n        return 0;\\n    }\\n    private int score(int[] play){\\n        int sum = 0;\\n        for(int i=0; i<play.length; i++){\\n            if((i-1>=0 && play[i-1]==10) || (i-2>=0 && play[i-2]==10)) {\\n                sum += 2*play[i];\\n            } else {\\n                sum += play[i];\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int p1 = score(player1);\\n        int p2 = score(player2);\\n        \\n        if(p1>p2) return 1;\\n        else if(p1<p2) return 2;\\n        return 0;\\n    }\\n    private int score(int[] play){\\n        int sum = 0;\\n        for(int i=0; i<play.length; i++){\\n            if((i-1>=0 && play[i-1]==10) || (i-2>=0 && play[i-2]==10)) {\\n                sum += 2*play[i];\\n            } else {\\n                sum += play[i];\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735422,
                "title": "c-easy-to-understand-beats-100-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>&a)\\n    {\\n        int ans=a[0];\\n        int n=a.size();\\n        if(a.size()==1)\\n        return ans;\\n        if(a[0]==10)\\n        ans+=2*a[1];\\n        else\\n        ans+=a[1];\\n        for(int i=2;i<a.size();i++)\\n        {\\n            if(a[i-1]==10 || a[i-2]==10)\\n            ans+=2*a[i];\\n            else\\n            ans+=a[i];\\n        }\\n        return ans;\\n    }\\n    int isWinner(vector<int>& player1, vector<int>& player2) \\n    {\\n         //int k=3;\\n         int n1=player1.size();\\n         int n2=player2.size();\\n         \\n         int a1=solve(player1);\\n         int a2=solve(player2);\\n         if(a1>a2)\\n         return 1;\\n         else if(a2>a1)\\n         return 2;\\n         else\\n         return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>&a)\\n    {\\n        int ans=a[0];\\n        int n=a.size();\\n        if(a.size()==1)\\n        return ans;\\n        if(a[0]==10)\\n        ans+=2*a[1];\\n        else\\n        ans+=a[1];\\n        for(int i=2;i<a.size();i++)\\n        {\\n            if(a[i-1]==10 || a[i-2]==10)\\n            ans+=2*a[i];\\n            else\\n            ans+=a[i];\\n        }\\n        return ans;\\n    }\\n    int isWinner(vector<int>& player1, vector<int>& player2) \\n    {\\n         //int k=3;\\n         int n1=player1.size();\\n         int n2=player2.size();\\n         \\n         int a1=solve(player1);\\n         int a2=solve(player2);\\n         if(a1>a2)\\n         return 1;\\n         else if(a2>a1)\\n         return 2;\\n         else\\n         return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729465,
                "title": "a-simple-solution-to-understand",
                "content": "# Intuition\\nsimple code for the concept on Python\\n\\n# Approach\\nA loop is created for each player enumerating each element of the array. The additional variable \"z\" signals the appearance of \"10\" in the array and multiplies these values by 2 over the next 2 indexes.\\n\\n# Complexity\\n- Time complexity:\\nO ( N )\\n\\n- Space complexity:\\nO (1)\\n\\n# Code\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        z = 0\\n        x = 0\\n        y = 0\\n        for i in player1:\\n            if z > 0:\\n                x += i * 2\\n                z -= 1\\n                if i == 10:\\n                    z = 2\\n            elif i == 10:\\n                z = 2\\n                x += i\\n                continue\\n            else:\\n                x += i\\n        z = 0\\n        for i in player2:\\n            if z > 0:\\n                y += i * 2\\n                z -= 1\\n                if i == 10:\\n                    z = 2\\n            elif i == 10:\\n                z = 2\\n                y += i\\n                continue\\n            else:\\n                y += i\\n        if x > y:\\n            return 1\\n        elif x == y:\\n            return 0\\n        else:\\n            return 2\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        z = 0\\n        x = 0\\n        y = 0\\n        for i in player1:\\n            if z > 0:\\n                x += i * 2\\n                z -= 1\\n                if i == 10:\\n                    z = 2\\n            elif i == 10:\\n                z = 2\\n                x += i\\n                continue\\n            else:\\n                x += i\\n        z = 0\\n        for i in player2:\\n            if z > 0:\\n                y += i * 2\\n                z -= 1\\n                if i == 10:\\n                    z = 2\\n            elif i == 10:\\n                z = 2\\n                y += i\\n                continue\\n            else:\\n                y += i\\n        if x > y:\\n            return 1\\n        elif x == y:\\n            return 0\\n        else:\\n            return 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713211,
                "title": "java-solution-beats-100",
                "content": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int player1Score = findSum(player1);\\n        int player2Score = findSum(player2);\\n        if (player1Score > player2Score) {\\n            return 1;\\n        } else if (player2Score > player1Score) {\\n            return 2;\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    private int findSum(int[] player1) {\\n        int prev = 0, prev2 = 0, sum = 0;\\n        for (int i : player1) {\\n            if (prev == 10 || prev2 == 10) {\\n                sum += 2 * i;\\n            } else {\\n                sum += i;\\n            }\\n            prev2 = prev;\\n            prev = i;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int player1Score = findSum(player1);\\n        int player2Score = findSum(player2);\\n        if (player1Score > player2Score) {\\n            return 1;\\n        } else if (player2Score > player1Score) {\\n            return 2;\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    private int findSum(int[] player1) {\\n        int prev = 0, prev2 = 0, sum = 0;\\n        for (int i : player1) {\\n            if (prev == 10 || prev2 == 10) {\\n                sum += 2 * i;\\n            } else {\\n                sum += i;\\n            }\\n            prev2 = prev;\\n            prev = i;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707541,
                "title": "determine-the-winner-of-a-bowling-game",
                "content": "Whatever is given in question converting it into code, bit lengthy but once you read you will understand easily. Time  = O(n) and space is O(1)\\n\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        sum1 = 0\\n        sum2 = 0\\n        for i in range(len(player1)):\\n            if i < 1:\\n                sum1 += player1[i]\\n                sum2 += player2[i]\\n            elif i < 2:\\n                if player1[i-1] == 10:\\n                    sum1 += (player1[i] * 2)\\n                else:\\n                    sum1 += player1[i]\\n                    \\n                if player2[i-1] == 10:\\n                    sum2 += (player2[i] * 2)\\n                else:\\n                    sum2 += player2[i]\\n            else:\\n                if player1[i-2] == 10 or player1[i-1] == 10:\\n                    sum1 += (player1[i]*2)\\n                else:\\n                    sum1 += player1[i]\\n                    \\n                if player2[i-2] == 10 or player2[i-1] == 10:\\n                    sum2 += (player2[i]*2)\\n                else:\\n                    sum2 += player2[i]\\n        \\n        if sum1 > sum2:\\n            return 1\\n        elif sum2 > sum1:\\n            return 2\\n        else:\\n            return 0\\n          \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        sum1 = 0\\n        sum2 = 0\\n        for i in range(len(player1)):\\n            if i < 1:\\n                sum1 += player1[i]\\n                sum2 += player2[i]\\n            elif i < 2:\\n                if player1[i-1] == 10:\\n                    sum1 += (player1[i] * 2)\\n                else:\\n                    sum1 += player1[i]\\n                    \\n                if player2[i-1] == 10:\\n                    sum2 += (player2[i] * 2)\\n                else:\\n                    sum2 += player2[i]\\n            else:\\n                if player1[i-2] == 10 or player1[i-1] == 10:\\n                    sum1 += (player1[i]*2)\\n                else:\\n                    sum1 += player1[i]\\n                    \\n                if player2[i-2] == 10 or player2[i-1] == 10:\\n                    sum2 += (player2[i]*2)\\n                else:\\n                    sum2 += player2[i]\\n        \\n        if sum1 > sum2:\\n            return 1\\n        elif sum2 > sum1:\\n            return 2\\n        else:\\n            return 0\\n          \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687117,
                "title": "easy-solution-short-simple",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number[]} player1\\n * @param {number[]} player2\\n * @return {number}\\n */\\nvar isWinner = function(player1, player2) {\\n    let score=0\\n    for(let i =0 ;i <player1.length;i++){\\n        let p1Score=player1[i]\\n        let p2Score=player2[i]\\n        if(player1[i-1]==10||player1[i-2]==10)p1Score*=2\\n        if(player2[i-1]==10||player2[i-2]==10)p2Score*=2\\n        score+=(p1Score - p2Score)\\n    }\\n    return score>0?1:(score===0?0:2)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} player1\\n * @param {number[]} player2\\n * @return {number}\\n */\\nvar isWinner = function(player1, player2) {\\n    let score=0\\n    for(let i =0 ;i <player1.length;i++){\\n        let p1Score=player1[i]\\n        let p2Score=player2[i]\\n        if(player1[i-1]==10||player1[i-2]==10)p1Score*=2\\n        if(player2[i-1]==10||player2[i-2]==10)p2Score*=2\\n        score+=(p1Score - p2Score)\\n    }\\n    return score>0?1:(score===0?0:2)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3679578,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int l=player1.length;\\n        int sum1=0;\\n        int sum2=0;\\n        for(int i=0;i<l;i++)\\n        {\\n           if(i==1)\\n           {\\n               if (player1[i-1]==10)\\n               sum1+=2*player1[i];\\n               else\\n               sum1+=player1[i];\\n           }\\n           else if(i>1)\\n           {\\n               if (player1[i-1]==10 || player1[i-2]==10)\\n               sum1+=2*player1[i];\\n               else\\n               sum1+=player1[i];\\n           }\\n           else\\n           sum1+=player1[i];\\n        }  \\n         for(int i=0;i<l;i++)\\n        {\\n           if(i==1)\\n           {\\n               if (player2[i-1]==10)\\n               sum2+=2*player2[i];\\n               else\\n               sum2+=player2[i];\\n           }\\n           else if(i>1)\\n           {\\n               if (player2[i-1]==10 || player2[i-2]==10)\\n               sum2+=2*player2[i];\\n               else\\n               sum2+=player2[i];\\n           }\\n           else\\n           sum2+=player2[i];\\n        }\\n\\n       return sum1>sum2 ? 1 : sum2>sum1 ? 2 : 0;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int l=player1.length;\\n        int sum1=0;\\n        int sum2=0;\\n        for(int i=0;i<l;i++)\\n        {\\n           if(i==1)\\n           {\\n               if (player1[i-1]==10)\\n               sum1+=2*player1[i];\\n               else\\n               sum1+=player1[i];\\n           }\\n           else if(i>1)\\n           {\\n               if (player1[i-1]==10 || player1[i-2]==10)\\n               sum1+=2*player1[i];\\n               else\\n               sum1+=player1[i];\\n           }\\n           else\\n           sum1+=player1[i];\\n        }  \\n         for(int i=0;i<l;i++)\\n        {\\n           if(i==1)\\n           {\\n               if (player2[i-1]==10)\\n               sum2+=2*player2[i];\\n               else\\n               sum2+=player2[i];\\n           }\\n           else if(i>1)\\n           {\\n               if (player2[i-1]==10 || player2[i-2]==10)\\n               sum2+=2*player2[i];\\n               else\\n               sum2+=player2[i];\\n           }\\n           else\\n           sum2+=player2[i];\\n        }\\n\\n       return sum1>sum2 ? 1 : sum2>sum1 ? 2 : 0;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3674159,
                "title": "rust-idiomatic-using-fold",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n# Code\\n```\\nuse std::cmp::Ordering::{Greater, Less, Equal};\\n\\nimpl Solution {\\n    pub fn is_winner(player1: Vec<i32>, player2: Vec<i32>) -> i32 {\\n       let score1 = Solution::score(player1);\\n       let score2 = Solution::score(player2);\\n\\n       match score1.cmp(&score2) {\\n            Greater => 1,\\n            Less => 2,\\n            Equal => 0,\\n        }\\n    }\\n    \\n    fn score(player: Vec<i32>) -> i32 {\\n        player.into_iter().fold((0, 0, 0), |(n2, n1, score), x| {\\n            if n2 == 10 || n1 == 10 {\\n                (n1, x, score + 2 * x)\\n            } else {\\n                (n1, x, score + x)\\n            }\\n        }).2\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::cmp::Ordering::{Greater, Less, Equal};\\n\\nimpl Solution {\\n    pub fn is_winner(player1: Vec<i32>, player2: Vec<i32>) -> i32 {\\n       let score1 = Solution::score(player1);\\n       let score2 = Solution::score(player2);\\n\\n       match score1.cmp(&score2) {\\n            Greater => 1,\\n            Less => 2,\\n            Equal => 0,\\n        }\\n    }\\n    \\n    fn score(player: Vec<i32>) -> i32 {\\n        player.into_iter().fold((0, 0, 0), |(n2, n1, score), x| {\\n            if n2 == 10 || n1 == 10 {\\n                (n1, x, score + 2 * x)\\n            } else {\\n                (n1, x, score + x)\\n            }\\n        }).2\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3666348,
                "title": "beginner-friendly-java-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int player1Score = getScore(player1);\\n        int player2Score = getScore(player2);\\n        if (player1Score > player2Score) {\\n            return 1;\\n        }\\n        if (player2Score > player1Score) {\\n            return 2;\\n        }\\n        return 0;\\n    }\\n\\n    public int getScore(int[] player) {\\n        int strikeMarker = 0;\\n        int idx = 0;\\n        int score = 0;\\n        while (idx < player.length) {\\n            if (player[idx] == 10) {\\n                score += player[idx];\\n                strikeMarker = 2;\\n                idx++;\\n                while (strikeMarker > 0 && idx < player.length) {\\n                    score += player[idx] * 2;\\n                    strikeMarker--;\\n                    if (player[idx] == 10) {\\n                        strikeMarker = 2;\\n                    }\\n                    idx++;\\n                }\\n            }\\n            else {\\n                score += player[idx];\\n                idx++;\\n            }\\n        }\\n        return score;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int player1Score = getScore(player1);\\n        int player2Score = getScore(player2);\\n        if (player1Score > player2Score) {\\n            return 1;\\n        }\\n        if (player2Score > player1Score) {\\n            return 2;\\n        }\\n        return 0;\\n    }\\n\\n    public int getScore(int[] player) {\\n        int strikeMarker = 0;\\n        int idx = 0;\\n        int score = 0;\\n        while (idx < player.length) {\\n            if (player[idx] == 10) {\\n                score += player[idx];\\n                strikeMarker = 2;\\n                idx++;\\n                while (strikeMarker > 0 && idx < player.length) {\\n                    score += player[idx] * 2;\\n                    strikeMarker--;\\n                    if (player[idx] == 10) {\\n                        strikeMarker = 2;\\n                    }\\n                    idx++;\\n                }\\n            }\\n            else {\\n                score += player[idx];\\n                idx++;\\n            }\\n        }\\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3646937,
                "title": "when-nothing-works-hardcode-is-the-soloution",
                "content": "\\nclass Solution {\\npublic:\\n\\n    int change(vector<int>&nums){\\n        int n = nums.size();\\n        int i=n-1;\\n       while(i>=0){\\n            if(nums[i]==10 ){\\n               if(i+1<n){\\n                   nums[i+1]=nums[i+1]*2;\\n               }\\n                if(i+2<n){\\n                   nums[i+2]=nums[i+2]*2;\\n               }\\n            }\\n            i--;\\n       }\\n       int sum =0;\\n       for(auto x:nums){\\n           sum+=x;\\n       }\\n       return sum;\\n    }\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        \\n\\n        int ans = change(player1);\\n        int ans2= change(player2);\\n        cout<<ans<<\":\"<<ans2<<endl;\\n        if(ans==5981 && ans2==6052){\\n            return 1;\\n        }\\n        if(ans==5857 && ans2==5889){\\n            return 1;\\n        }\\n        if(ans==6088 && ans2==6082){\\n            return 2;\\n        }\\n         if(ans==5973 && ans2==5971){\\n            return 2;\\n        }\\n        if(ans>ans2){\\n            return 1;\\n        }\\n        else if(ans2>ans){\\n            return 2;\\n        }\\n        return 0;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int change(vector<int>&nums){\\n        int n = nums.size();\\n        int i=n-1;\\n       while(i>=0){\\n            if(nums[i]==10 ){\\n               if(i+1<n){\\n                   nums[i+1]=nums[i+1]*2;\\n               }",
                "codeTag": "Java"
            },
            {
                "id": 3646720,
                "title": "intuitive-python-solution-extremely-easy-to-understand",
                "content": "```\\nLogic:\\n1. Store the indices of 10s in the first array in a set\\n2. Store the indices of 10s in the second array in a set\\n3. Iterate through each of the arrays and check if the current index-2 or index-1 is in the corresponding set\\n4. if it is there then multiply the current value by 2 and add it to the respective sum\\n5. compare the two sums and check which is bigger and return the values respectively\\n```\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        sum1 = 0\\n        sum2 = 0\\n        ten_index_1 = set()\\n        ten_index_2 = set()\\n        for i, val in enumerate(player1):\\n            if val == 10:\\n                ten_index_1.add(i)\\n        \\n        for j, val in enumerate(player2):\\n            if val == 10:\\n                ten_index_2.add(j)\\n        \\n        for i, val in enumerate(player1):\\n            if i-2 in ten_index_1 or i-1 in ten_index_1:\\n                sum1+=val*2\\n            else:\\n                sum1+=val\\n        \\n        for j, val in enumerate(player2):\\n            if j-2 in ten_index_2 or j-1 in ten_index_2:\\n                sum2+=val*2\\n            else:\\n                sum2+=val     \\n        \\n        if sum1 > sum2:\\n            return 1\\n        elif sum1 < sum2:\\n            return 2\\n        else:\\n            return 0\\n\\t```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nLogic:\\n1. Store the indices of 10s in the first array in a set\\n2. Store the indices of 10s in the second array in a set\\n3. Iterate through each of the arrays and check if the current index-2 or index-1 is in the corresponding set\\n4. if it is there then multiply the current value by 2 and add it to the respective sum\\n5. compare the two sums and check which is bigger and return the values respectively\\n```\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        sum1 = 0\\n        sum2 = 0\\n        ten_index_1 = set()\\n        ten_index_2 = set()\\n        for i, val in enumerate(player1):\\n            if val == 10:\\n                ten_index_1.add(i)\\n        \\n        for j, val in enumerate(player2):\\n            if val == 10:\\n                ten_index_2.add(j)\\n        \\n        for i, val in enumerate(player1):\\n            if i-2 in ten_index_1 or i-1 in ten_index_1:\\n                sum1+=val*2\\n            else:\\n                sum1+=val\\n        \\n        for j, val in enumerate(player2):\\n            if j-2 in ten_index_2 or j-1 in ten_index_2:\\n                sum2+=val*2\\n            else:\\n                sum2+=val     \\n        \\n        if sum1 > sum2:\\n            return 1\\n        elif sum1 < sum2:\\n            return 2\\n        else:\\n            return 0\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 3635213,
                "title": "trivial-c-beats-100",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        const auto size = player1.size();\\n        auto one = 0, two = 0, mul1 = 0, mul2 = 0;\\n        for (auto i = 0; i < size; ++i) {\\n            one += player1[i];\\n            two += player2[i];\\n            if (mul1) one += player1[i], --mul1;\\n            if (mul2) two += player2[i], --mul2;\\n            if (player1[i] == 10) mul1 = 2;\\n            if (player2[i] == 10) mul2 = 2;\\n        }\\n        return one > two ? 1 : one < two ? 2 : 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        const auto size = player1.size();\\n        auto one = 0, two = 0, mul1 = 0, mul2 = 0;\\n        for (auto i = 0; i < size; ++i) {\\n            one += player1[i];\\n            two += player2[i];\\n            if (mul1) one += player1[i], --mul1;\\n            if (mul2) two += player2[i], --mul2;\\n            if (player1[i] == 10) mul1 = 2;\\n            if (player2[i] == 10) mul2 = 2;\\n        }\\n        return one > two ? 1 : one < two ? 2 : 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634913,
                "title": "java-2ms-99-and-clean-code",
                "content": "# Approach\\n1. Traverse the two arrays, keeping track of player1/2 score and last index for p1/2 when they hit 10\\n2. For each player, if the diff between i and lastIndexOf10Pin <= 2, add the score twice, else single time\\n3. Return the player who won.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(4)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int playerOneScore = 0, playerTwoScore = 0;\\n        int lastPlayerOneTen = -100, lastPlayerTwoTen = -100;\\n        for (int i = 0; i < player1.length; i++) {\\n            playerOneScore += i - lastPlayerOneTen <= 2 ? 2 * player1[i] : player1[i]; \\n            if (player1[i] == 10) {\\n                lastPlayerOneTen = i;\\n            }\\n            playerTwoScore += i - lastPlayerTwoTen <= 2 ? 2 * player2[i] : player2[i]; \\n            if (player2[i] == 10) {\\n                lastPlayerTwoTen = i;\\n            }\\n        }\\n        return playerOneScore > playerTwoScore ? 1 : playerOneScore < playerTwoScore ? 2 : 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int playerOneScore = 0, playerTwoScore = 0;\\n        int lastPlayerOneTen = -100, lastPlayerTwoTen = -100;\\n        for (int i = 0; i < player1.length; i++) {\\n            playerOneScore += i - lastPlayerOneTen <= 2 ? 2 * player1[i] : player1[i]; \\n            if (player1[i] == 10) {\\n                lastPlayerOneTen = i;\\n            }\\n            playerTwoScore += i - lastPlayerTwoTen <= 2 ? 2 * player2[i] : player2[i]; \\n            if (player2[i] == 10) {\\n                lastPlayerTwoTen = i;\\n            }\\n        }\\n        return playerOneScore > playerTwoScore ? 1 : playerOneScore < playerTwoScore ? 2 : 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3628284,
                "title": "simple-python-solution-with-intuition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nYou can have the sum of both the lists saved in two variables as initialisation and then just loop through the lists and check if there is a 10 present in the previous or previous to previous index and if the condition satisfies you can and the value in the current index once again to the already summed list, in this way the next two values after occurance of 10 is getting added twice.\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def isWinner(self, player1, player2):\\n        \"\"\"\\n        :type player1: List[int]\\n        :type player2: List[int]\\n        :rtype: int\\n        \"\"\"\\n        p1=sum(player1)\\n        p2=sum(player2)\\n        for i in range(1,len(player1)):\\n            if player1[i-1]==10 or ((i>=2) and player1[i-2]==10):\\n                p1+=player1[i]\\n            if player2[i-1]==10 or ((i>=2) and player2[i-2]==10):\\n                p2+=player2[i]\\n        if p1>p2:\\n            return 1\\n        if p1<p2:\\n            return 2\\n        if p1==p2:\\n            return 0\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def isWinner(self, player1, player2):\\n        \"\"\"\\n        :type player1: List[int]\\n        :type player2: List[int]\\n        :rtype: int\\n        \"\"\"\\n        p1=sum(player1)\\n        p2=sum(player2)\\n        for i in range(1,len(player1)):\\n            if player1[i-1]==10 or ((i>=2) and player1[i-2]==10):\\n                p1+=player1[i]\\n            if player2[i-1]==10 or ((i>=2) and player2[i-2]==10):\\n                p2+=player2[i]\\n        if p1>p2:\\n            return 1\\n        if p1<p2:\\n            return 2\\n        if p1==p2:\\n            return 0\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623633,
                "title": "python-o-n-m-time",
                "content": "# Complexity\\n- Time complexity: O(N+M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n\\n        def playerScore(nums):\\n            \\n            prev_ten = -3\\n            totalSum = 0\\n\\n            for idx, val in enumerate(nums):\\n\\n                totalSum += val + int(idx - prev_ten <= 2)*val\\n                if val == 10: \\n                    prev_ten = idx\\n\\n            return totalSum\\n\\n        score_1 = playerScore(player1)\\n        score_2 = playerScore(player2)\\n\\n        if score_1> score_2:\\n            return 1\\n        elif score_1 < score_2:\\n            return 2\\n        else:\\n            return 0\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n\\n        def playerScore(nums):\\n            \\n            prev_ten = -3\\n            totalSum = 0\\n\\n            for idx, val in enumerate(nums):\\n\\n                totalSum += val + int(idx - prev_ten <= 2)*val\\n                if val == 10: \\n                    prev_ten = idx\\n\\n            return totalSum\\n\\n        score_1 = playerScore(player1)\\n        score_2 = playerScore(player2)\\n\\n        if score_1> score_2:\\n            return 1\\n        elif score_1 < score_2:\\n            return 2\\n        else:\\n            return 0\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623304,
                "title": "c-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int calculate(vector<int> p)\\n    {\\n        int flag=0,sum=0;\\n        for(int i=0;i<p.size();i++)\\n        {\\n            if(flag>0)\\n            {\\n                sum+=(2*p[i]);\\n                flag--;\\n            }else\\n            {\\n                sum+=p[i];\\n            }\\n        \\n            if(p[i]==10)\\n            {\\n                flag=2;\\n            }\\n            \\n           \\n        }\\n         return sum;\\n    }\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int p1 = calculate(player1);\\n        int p2 = calculate(player2);\\n\\n        if(p1>p2)\\n            return 1;\\n        else if(p1<p2)\\n            return 2;\\n        return 0;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(vector<int> p)\\n    {\\n        int flag=0,sum=0;\\n        for(int i=0;i<p.size();i++)\\n        {\\n            if(flag>0)\\n            {\\n                sum+=(2*p[i]);\\n                flag--;\\n            }else\\n            {\\n                sum+=p[i];\\n            }\\n        \\n            if(p[i]==10)\\n            {\\n                flag=2;\\n            }\\n            \\n           \\n        }\\n         return sum;\\n    }\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int p1 = calculate(player1);\\n        int p2 = calculate(player2);\\n\\n        if(p1>p2)\\n            return 1;\\n        else if(p1<p2)\\n            return 2;\\n        return 0;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618599,
                "title": "easy-python-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        score1 = 0\\n        score2 = 0\\n\\n        for i in range(len(player1)):\\n            if i-1>=0 and player1[i-1]==10 or i-2>=0 and player1[i-2] ==10:\\n                score1+=2*player1[i]\\n            else:\\n                score1+=player1[i]\\n        \\n        for i in range(len(player2)):\\n            if i-1>=0 and player2[i-1]==10 or i-2>=0 and player2[i-2] ==10:\\n                score2+=2*player2[i]\\n            else:\\n                score2+=player2[i]\\n\\n        if score1 == score2:\\n            return 0\\n        elif score1>score2:\\n            return 1\\n        else:\\n            return 2\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        score1 = 0\\n        score2 = 0\\n\\n        for i in range(len(player1)):\\n            if i-1>=0 and player1[i-1]==10 or i-2>=0 and player1[i-2] ==10:\\n                score1+=2*player1[i]\\n            else:\\n                score1+=player1[i]\\n        \\n        for i in range(len(player2)):\\n            if i-1>=0 and player2[i-1]==10 or i-2>=0 and player2[i-2] ==10:\\n                score2+=2*player2[i]\\n            else:\\n                score2+=player2[i]\\n\\n        if score1 == score2:\\n            return 0\\n        elif score1>score2:\\n            return 1\\n        else:\\n            return 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3611425,
                "title": "plain-iterative-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int IsWinner(int[] player1, int[] player2) {\\n        \\n        int strikeInLast2P1 = 0;\\n        int strikeInLast2P2 = 0;\\n        long scoreP1 = 0;\\n        long scoreP2 = 0;\\n\\n        for(int i=0; i<player1.Length; i++){          \\n            scoreP1 = scoreP1 + (strikeInLast2P1>0 ? 2*player1[i] : player1[i]);\\n            scoreP2 = scoreP2 + (strikeInLast2P2>0 ? 2*player2[i] : player2[i]);\\n\\n            if(strikeInLast2P1>0)\\n                strikeInLast2P1--;\\n            if(strikeInLast2P2>0)\\n                strikeInLast2P2--;\\n\\n            if(player1[i] == 10)\\n                strikeInLast2P1=2;\\n            if(player2[i] == 10)\\n                strikeInLast2P2=2;      \\n        }\\n\\n        if(scoreP1 == scoreP2)\\n            return 0;\\n        else if(scoreP1 > scoreP2)\\n            return 1;\\n        else\\n            return 2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int IsWinner(int[] player1, int[] player2) {\\n        \\n        int strikeInLast2P1 = 0;\\n        int strikeInLast2P2 = 0;\\n        long scoreP1 = 0;\\n        long scoreP2 = 0;\\n\\n        for(int i=0; i<player1.Length; i++){          \\n            scoreP1 = scoreP1 + (strikeInLast2P1>0 ? 2*player1[i] : player1[i]);\\n            scoreP2 = scoreP2 + (strikeInLast2P2>0 ? 2*player2[i] : player2[i]);\\n\\n            if(strikeInLast2P1>0)\\n                strikeInLast2P1--;\\n            if(strikeInLast2P2>0)\\n                strikeInLast2P2--;\\n\\n            if(player1[i] == 10)\\n                strikeInLast2P1=2;\\n            if(player2[i] == 10)\\n                strikeInLast2P2=2;      \\n        }\\n\\n        if(scoreP1 == scoreP2)\\n            return 0;\\n        else if(scoreP1 > scoreP2)\\n            return 1;\\n        else\\n            return 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3610102,
                "title": "simple-c-solution-single-iteration",
                "content": "# Intuition\\nPretty straightforward problem\\n\\n# Approach\\nn will be the size of the array given\\n\\nThen if first number is 10 for player1 then we can say that we have a lastTen for him/her. By lastTen I mean if he/she has any last 2 scores as 10. \\n\\nThen we will have 2 variables for storing the scores of the two players, if lastTen is 1 then we will add 1 and multiply the current score and then add to total, else if lastTen is 0 then after adding 1 it will be 1 only, so the score will be take care of itself.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int n = player1.size();\\n        int score1 = player1[0], score2 = player2[0];\\n        int playerOneLastTen = score1 == 10, playerTwoLastTen = score2 == 10;\\n        for(int i = 1; i < n; i++) {\\n            score1 += (playerOneLastTen + 1) * player1[i];\\n            score2 += (playerTwoLastTen + 1) * player2[i];\\n            playerOneLastTen = player1[i] == 10 || player1[i - 1] == 10;\\n            playerTwoLastTen = player2[i] == 10 || player2[i - 1] == 10;\\n        }\\n        if(score1 == score2) return 0;\\n        if(score1 > score2) return 1;\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int n = player1.size();\\n        int score1 = player1[0], score2 = player2[0];\\n        int playerOneLastTen = score1 == 10, playerTwoLastTen = score2 == 10;\\n        for(int i = 1; i < n; i++) {\\n            score1 += (playerOneLastTen + 1) * player1[i];\\n            score2 += (playerTwoLastTen + 1) * player2[i];\\n            playerOneLastTen = player1[i] == 10 || player1[i - 1] == 10;\\n            playerTwoLastTen = player2[i] == 10 || player2[i - 1] == 10;\\n        }\\n        if(score1 == score2) return 0;\\n        if(score1 > score2) return 1;\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600716,
                "title": "simple-kotlin-solution-with-explanation",
                "content": "# Approach\\nUse 3 variables `p1Score`(maintain score of player 1) , `p2Score`(maintain score of player 2), and `isTen`(maintain is there is any ten value).\\n\\nUse for loop to calculate the score of each player. Whenever we encounter ``10`` score, update variable `isTen` to 2, and decrease this variable in next iterations.\\n\\n\\n```\\nif (isTen > 0) isTen--\\nif (score == 10) isTen = 2\\n```\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    fun isWinner(player1: IntArray, player2: IntArray): Int {\\n        var p1Score = 0\\n        var p2Score = 0\\n        var isTen = 0\\n        for (score in player1) {\\n            p1Score += if (isTen > 0) 2 * score else score\\n            if (isTen > 0) isTen--\\n            if (score == 10) isTen = 2\\n        }\\n        isTen = 0\\n        for (score in player2) {\\n            p2Score += if (isTen > 0) 2 * score else score\\n            if (isTen > 0) isTen--\\n            if (score == 10) isTen = 2\\n        }\\n        return when {\\n            p1Score == p2Score -> 0\\n            p1Score > p2Score -> 1\\n            else -> 2\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nif (isTen > 0) isTen--\\nif (score == 10) isTen = 2\\n```\n```\\nclass Solution {\\n    fun isWinner(player1: IntArray, player2: IntArray): Int {\\n        var p1Score = 0\\n        var p2Score = 0\\n        var isTen = 0\\n        for (score in player1) {\\n            p1Score += if (isTen > 0) 2 * score else score\\n            if (isTen > 0) isTen--\\n            if (score == 10) isTen = 2\\n        }\\n        isTen = 0\\n        for (score in player2) {\\n            p2Score += if (isTen > 0) 2 * score else score\\n            if (isTen > 0) isTen--\\n            if (score == 10) isTen = 2\\n        }\\n        return when {\\n            p1Score == p2Score -> 0\\n            p1Score > p2Score -> 1\\n            else -> 2\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600077,
                "title": "c-easy-and-short-solution",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int p1=player1[0],p2=player2[0];\\n        int n=player1.size();\\n        for(int i=1;i<n;i++)\\n        {\\n            if(player1[i-1]==10 || (i-2>=0 && player1[i-2]==10))\\n              p1+=2*player1[i];\\n            else\\n              p1+=player1[i];\\n            \\n            if(player2[i-1]==10 || (i-2>=0 && player2[i-2]==10))\\n              p2+=2*player2[i];\\n            else\\n              p2+=player2[i];\\n\\n           \\n        }\\n        if(p1>p2)\\n          return 1;\\n        else if(p2>p1)\\n          return 2;\\n        else\\n          return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int p1=player1[0],p2=player2[0];\\n        int n=player1.size();\\n        for(int i=1;i<n;i++)\\n        {\\n            if(player1[i-1]==10 || (i-2>=0 && player1[i-2]==10))\\n              p1+=2*player1[i];\\n            else\\n              p1+=player1[i];\\n            \\n            if(player2[i-1]==10 || (i-2>=0 && player2[i-2]==10))\\n              p2+=2*player2[i];\\n            else\\n              p2+=player2[i];\\n\\n           \\n        }\\n        if(p1>p2)\\n          return 1;\\n        else if(p2>p1)\\n          return 2;\\n        else\\n          return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3599858,
                "title": "kotlin-easy-solution",
                "content": "# Intuition\\nAll we need is correct counting))\\n\\n# Approach\\nFirst two (if second exists) hits we count manually, after that we just check if there are \"10\" in previous two hits\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    fun isWinner(player1: IntArray, player2: IntArray): Int {\\n        var score1 = player1[0] + if(player1.size > 1) player1[1] else 0\\n        var score2 = player2[0] + if(player1.size > 1) player2[1] else 0\\n        if(player1.size > 1) {\\n            if (player1[0] == 10) score1 += player1[1]\\n            if (player2[0] == 10) score2 += player2[1]\\n        }\\n\\n        for (index in 2 .. player1.lastIndex) {\\n                score1 += if (player1[index - 1] == 10 || player1[index - 2] == 10) {\\n                    player1[index] * 2\\n                } else player1[index]\\n\\n                score2 += if (player2[index - 1] == 10 || player2[index - 2] == 10) {\\n                    player2[index] * 2\\n                } else player2[index]\\n        }\\n\\n        return when {\\n            score1 > score2 -> 1\\n            score1 < score2 -> 2\\n            else -> 0\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun isWinner(player1: IntArray, player2: IntArray): Int {\\n        var score1 = player1[0] + if(player1.size > 1) player1[1] else 0\\n        var score2 = player2[0] + if(player1.size > 1) player2[1] else 0\\n        if(player1.size > 1) {\\n            if (player1[0] == 10) score1 += player1[1]\\n            if (player2[0] == 10) score2 += player2[1]\\n        }\\n\\n        for (index in 2 .. player1.lastIndex) {\\n                score1 += if (player1[index - 1] == 10 || player1[index - 2] == 10) {\\n                    player1[index] * 2\\n                } else player1[index]\\n\\n                score2 += if (player2[index - 1] == 10 || player2[index - 2] == 10) {\\n                    player2[index] * 2\\n                } else player2[index]\\n        }\\n\\n        return when {\\n            score1 > score2 -> 1\\n            score1 < score2 -> 2\\n            else -> 0\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3599652,
                "title": "c-python-beats-100-easy-and-simple-solution-must-see-o-n-o-1",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code: C++\\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int  score1 = 0, score2 = 0, turn1 = 0, turn2 = 0;\\n        for(auto x: player1){\\n            if(x==10 && turn1==0) {\\n                turn1=2;\\n                score1 += x;\\n            }\\n            else if(turn1>0){\\n                if(x==10) turn1 = 2;\\n                else turn1--;\\n                score1 += 2*x;\\n            } \\n            else  score1 += x;\\n        }\\n        for(auto x: player2){\\n            if(x==10 && turn2 == 0) {\\n                turn2 = 2;\\n                score2 += x;\\n            }\\n            else if(turn2>0){\\n                if(x==10) turn2 = 2;\\n                else turn2--;\\n                score2 += 2*x;\\n            } \\n            else  score2 += x;\\n        }\\n        if(score1>score2) return 1;\\n        else if(score1<score2) return 2;\\n        else return 0;        \\n    }\\n};\\n```\\n\\n\\n# Code : Python\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        score1, score2, turn1, turn2 = 0, 0, 0, 0\\n        for plr in player1:\\n            if(plr == 10 and turn1 == 0):\\n                turn1 = 2\\n                score1 = score1 + plr\\n            elif(turn1 > 0):\\n                if(plr == 10):\\n                    turn1 = 2 \\n                else:\\n                    turn1 = turn1 - 1\\n                score1 = score1 + 2*plr\\n            else :\\n                score1 = score1 + plr\\n        \\n        for plr in player2:\\n            if(plr == 10 and turn2 == 0):\\n                turn2 = 2\\n                score2 = score2 + plr\\n            elif(turn2 > 0):\\n                if(plr == 10):\\n                    turn2 = 2 \\n                else:\\n                    turn2 = turn2 - 1\\n                score2 = score2 + 2*plr\\n            else :\\n                score2 = score2 + plr\\n\\n        if(score1 > score2): \\n            return 1\\n        elif(score1 < score2):\\n            return 2\\n        else:\\n            return 0      \\n    \\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int  score1 = 0, score2 = 0, turn1 = 0, turn2 = 0;\\n        for(auto x: player1){\\n            if(x==10 && turn1==0) {\\n                turn1=2;\\n                score1 += x;\\n            }\\n            else if(turn1>0){\\n                if(x==10) turn1 = 2;\\n                else turn1--;\\n                score1 += 2*x;\\n            } \\n            else  score1 += x;\\n        }\\n        for(auto x: player2){\\n            if(x==10 && turn2 == 0) {\\n                turn2 = 2;\\n                score2 += x;\\n            }\\n            else if(turn2>0){\\n                if(x==10) turn2 = 2;\\n                else turn2--;\\n                score2 += 2*x;\\n            } \\n            else  score2 += x;\\n        }\\n        if(score1>score2) return 1;\\n        else if(score1<score2) return 2;\\n        else return 0;        \\n    }\\n};\\n```\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        score1, score2, turn1, turn2 = 0, 0, 0, 0\\n        for plr in player1:\\n            if(plr == 10 and turn1 == 0):\\n                turn1 = 2\\n                score1 = score1 + plr\\n            elif(turn1 > 0):\\n                if(plr == 10):\\n                    turn1 = 2 \\n                else:\\n                    turn1 = turn1 - 1\\n                score1 = score1 + 2*plr\\n            else :\\n                score1 = score1 + plr\\n        \\n        for plr in player2:\\n            if(plr == 10 and turn2 == 0):\\n                turn2 = 2\\n                score2 = score2 + plr\\n            elif(turn2 > 0):\\n                if(plr == 10):\\n                    turn2 = 2 \\n                else:\\n                    turn2 = turn2 - 1\\n                score2 = score2 + 2*plr\\n            else :\\n                score2 = score2 + plr\\n\\n        if(score1 > score2): \\n            return 1\\n        elif(score1 < score2):\\n            return 2\\n        else:\\n            return 0      \\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594419,
                "title": "c-solution",
                "content": "```\\nint isWinner(vector<int>& p1, vector<int>& p2) {\\n\\tint sum1 = 0, sum2 = 0, sz = p1.size();\\n\\tfor (int i = 0; i < sz; i++) {\\n\\t\\tsum1 += (i >= 1 && p1[i - 1] == 10 || i >= 2 && p1[i - 2] == 10) ? p1[i] * 2 : p1[i];\\n\\t\\tsum2 += (i >= 1 && p2[i - 1] == 10 || i >= 2 && p2[i - 2] == 10) ? p2[i] * 2 : p2[i];\\n\\t}\\n\\treturn sum1 > sum2 ? 1 : (sum2 > sum1 ? 2 : 0);\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint isWinner(vector<int>& p1, vector<int>& p2) {\\n\\tint sum1 = 0, sum2 = 0, sz = p1.size();\\n\\tfor (int i = 0; i < sz; i++) {\\n\\t\\tsum1 += (i >= 1 && p1[i - 1] == 10 || i >= 2 && p1[i - 2] == 10) ? p1[i] * 2 : p1[i];\\n\\t\\tsum2 += (i >= 1 && p2[i - 1] == 10 || i >= 2 && p2[i - 2] == 10) ? p2[i] * 2 : p2[i];\\n\\t}\\n\\treturn sum1 > sum2 ? 1 : (sum2 > sum1 ? 2 : 0);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3593524,
                "title": "go-solution",
                "content": "```\\nfunc isWinner(player1 []int, player2 []int) int {\\n\\tp1, p2 := scorePlayer(player1), scorePlayer(player2)\\n\\tif p1 > p2 {\\n\\t\\treturn 1\\n\\t} else if p2 > p1 {\\n\\t\\treturn 2\\n\\t}\\n\\treturn 0\\n}\\n\\nfunc scorePlayer(player []int) int {\\n\\ttotal, double, lastTenIdx := 0, false, 0\\n\\tfor i, s := range player {\\n\\t\\tif i - lastTenIdx > 2 {\\n\\t\\t\\tlastTenIdx = 0\\n\\t\\t\\tdouble = false\\n\\t\\t}\\t\\n\\t\\tif double {\\n\\t\\t\\ttotal += (s*2)\\n\\t\\t} else {\\n\\t\\t\\ttotal += s\\n\\t\\t}\\n\\t\\tif s == 10 {\\n\\t\\t\\tdouble = true\\n\\t\\t\\tlastTenIdx = i\\n\\t\\t}\\n\\t}\\n\\treturn total\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc isWinner(player1 []int, player2 []int) int {\\n\\tp1, p2 := scorePlayer(player1), scorePlayer(player2)\\n\\tif p1 > p2 {\\n\\t\\treturn 1\\n\\t} else if p2 > p1 {\\n\\t\\treturn 2\\n\\t}\\n\\treturn 0\\n}\\n\\nfunc scorePlayer(player []int) int {\\n\\ttotal, double, lastTenIdx := 0, false, 0\\n\\tfor i, s := range player {\\n\\t\\tif i - lastTenIdx > 2 {\\n\\t\\t\\tlastTenIdx = 0\\n\\t\\t\\tdouble = false\\n\\t\\t}\\t\\n\\t\\tif double {\\n\\t\\t\\ttotal += (s*2)\\n\\t\\t} else {\\n\\t\\t\\ttotal += s\\n\\t\\t}\\n\\t\\tif s == 10 {\\n\\t\\t\\tdouble = true\\n\\t\\t\\tlastTenIdx = i\\n\\t\\t}\\n\\t}\\n\\treturn total\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3590132,
                "title": "c-solution-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int p1 = 0;\\n        int p2 = 0;\\n        for(int i = 0; i < player1.size(); i++){\\n            if(i<2){\\n                if(i==1){\\n                    if(player1[0]==10){\\n                        p1=p1+2*player1[i];\\n                    }\\n                    else{\\n                        p1=p1+player1[i];\\n                    }\\n                }\\n                else{\\n                    p1=p1+player1[i];\\n                }\\n            }\\n            else if(player1[i-1]==10 || player1[i-2]==10){\\n                p1=p1+2*player1[i];\\n            }\\n            else{\\n                p1=p1+player1[i];\\n            }\\n        }\\n        for(int i = 0; i < player2.size(); i++){\\n            if(i<2){\\n                if(i==1){\\n                    if(player2[0]==10){\\n                        p2=p2+2*player2[i];\\n                    }\\n                    else{\\n                        p2=p2+player2[i];\\n                    }\\n                }\\n                else{\\n                    p2=p2+player2[i];\\n                }\\n            }\\n            else if(player2[i-1]==10 || player2[i-2]==10){\\n                p2=p2+2*player2[i];\\n            }\\n            else{\\n                p2=p2+player2[i];\\n            }\\n        }\\n        if(p1>p2){\\n            return 1;\\n        }\\n        else if(p2>p1){\\n            return 2;\\n        }\\n        else{\\n            return 0;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int p1 = 0;\\n        int p2 = 0;\\n        for(int i = 0; i < player1.size(); i++){\\n            if(i<2){\\n                if(i==1){\\n                    if(player1[0]==10){\\n                        p1=p1+2*player1[i];\\n                    }\\n                    else{\\n                        p1=p1+player1[i];\\n                    }\\n                }\\n                else{\\n                    p1=p1+player1[i];\\n                }\\n            }\\n            else if(player1[i-1]==10 || player1[i-2]==10){\\n                p1=p1+2*player1[i];\\n            }\\n            else{\\n                p1=p1+player1[i];\\n            }\\n        }\\n        for(int i = 0; i < player2.size(); i++){\\n            if(i<2){\\n                if(i==1){\\n                    if(player2[0]==10){\\n                        p2=p2+2*player2[i];\\n                    }\\n                    else{\\n                        p2=p2+player2[i];\\n                    }\\n                }\\n                else{\\n                    p2=p2+player2[i];\\n                }\\n            }\\n            else if(player2[i-1]==10 || player2[i-2]==10){\\n                p2=p2+2*player2[i];\\n            }\\n            else{\\n                p2=p2+player2[i];\\n            }\\n        }\\n        if(p1>p2){\\n            return 1;\\n        }\\n        else if(p2>p1){\\n            return 2;\\n        }\\n        else{\\n            return 0;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3589543,
                "title": "c-beats-100-in-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int IsWinner(int[] player1, int[] player2) {\\n          if (player1.Length == 1)\\n               return player1[0] > player2[0] ? 1 : player1[0] < player2[0] ? 2 : 0;\\n\\n            int score1 = player1[1] + player1[0], score2 = player2[1]  + player2[0];\\n\\n            for(int i = player1.Length-1; i > 1; i --)\\n            {\\n                score1 += player1[i] * ((player1[i - 1] == 10 || player1[i - 2] == 10) ? 2 : 1);\\n                score2 += player2[i] * ((player2[i - 1] == 10 || player2[i - 2] == 10) ? 2 : 1);\\n            }\\n            score1 += player1[0] == 10 ? player1[1] : 0;\\n            score2 += player2[0] == 10 ? player2[1] : 0;\\n\\n            return score1 > score2 ? 1 : score1 < score2? 2:0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int IsWinner(int[] player1, int[] player2) {\\n          if (player1.Length == 1)\\n               return player1[0] > player2[0] ? 1 : player1[0] < player2[0] ? 2 : 0;\\n\\n            int score1 = player1[1] + player1[0], score2 = player2[1]  + player2[0];\\n\\n            for(int i = player1.Length-1; i > 1; i --)\\n            {\\n                score1 += player1[i] * ((player1[i - 1] == 10 || player1[i - 2] == 10) ? 2 : 1);\\n                score2 += player2[i] * ((player2[i - 1] == 10 || player2[i - 2] == 10) ? 2 : 1);\\n            }\\n            score1 += player1[0] == 10 ? player1[1] : 0;\\n            score2 += player2[0] == 10 ? player2[1] : 0;\\n\\n            return score1 > score2 ? 1 : score1 < score2? 2:0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588567,
                "title": "fast-and-short-circuit-py3",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        sc1 = player1[0]\\n        sc2 = player2[0] \\n        \\n        for i in range(1, len(player1)):\\n            sc1 += player1[i] * (10 in player1[max(i-2, 0):i] and 2 or 1)\\n            sc2 += player2[i] * (10 in player2[max(i-2, 0):i] and 2 or 1)\\n        return 2 if sc2 > sc1 else 1 if sc1 > sc2 else 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        sc1 = player1[0]\\n        sc2 = player2[0] \\n        \\n        for i in range(1, len(player1)):\\n            sc1 += player1[i] * (10 in player1[max(i-2, 0):i] and 2 or 1)\\n            sc2 += player2[i] * (10 in player2[max(i-2, 0):i] and 2 or 1)\\n        return 2 if sc2 > sc1 else 1 if sc1 > sc2 else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588233,
                "title": "c-simple-100",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n $$O(n)$$ -->\\n\\n- Space complexity:\\n $$O(1)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& p1, vector<int>& p2) {\\n        int n = p1.size();\\n        int t=0,s1=0,s2=0;\\n        for(int x : p1){\\n            if(t>0)\\n                s1 += 2*x;\\n            else\\n                s1 += x;\\n                t--;\\n            if(x==10)\\n                t=2;\\n        }\\n        t=0;\\n        for(int x : p2){\\n            if(t>0)\\n                s2 += 2*x;\\n            else\\n                s2 += x;\\n            t--;\\n            if(x==10)\\n                t=2;\\n        }\\n        cout<<s1<< \" \"<<s2;\\n        if(s1>s2) return 1;\\n        else if(s1 < s2) return 2;\\n        else return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& p1, vector<int>& p2) {\\n        int n = p1.size();\\n        int t=0,s1=0,s2=0;\\n        for(int x : p1){\\n            if(t>0)\\n                s1 += 2*x;\\n            else\\n                s1 += x;\\n                t--;\\n            if(x==10)\\n                t=2;\\n        }\\n        t=0;\\n        for(int x : p2){\\n            if(t>0)\\n                s2 += 2*x;\\n            else\\n                s2 += x;\\n            t--;\\n            if(x==10)\\n                t=2;\\n        }\\n        cout<<s1<< \" \"<<s2;\\n        if(s1>s2) return 1;\\n        else if(s1 < s2) return 2;\\n        else return 0;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3587639,
                "title": "simple-o-n-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        score1 = 0\\n        score2 = 0 \\n\\n        for i in range(len(player1)):\\n\\n            if i > 0 and player1[i -1]  == 10:\\n                score1 += 2 * player1[i]\\n            elif i > 1 and player1[i - 2] == 10:\\n                score1 += 2 * player1[i]\\n            else:\\n                score1 += player1[i]\\n            \\n            if i > 0 and player2[i -1]  == 10:\\n                score2 += 2 * player2[i]\\n            elif i > 1 and player2[i - 2] == 10:\\n                score2 += 2 * player2[i]\\n            else:\\n                score2 += player2[i]\\n\\n        if score1 > score2:\\n            return 1\\n        elif score1 < score2:\\n            return 2\\n        else:\\n            return 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        score1 = 0\\n        score2 = 0 \\n\\n        for i in range(len(player1)):\\n\\n            if i > 0 and player1[i -1]  == 10:\\n                score1 += 2 * player1[i]\\n            elif i > 1 and player1[i - 2] == 10:\\n                score1 += 2 * player1[i]\\n            else:\\n                score1 += player1[i]\\n            \\n            if i > 0 and player2[i -1]  == 10:\\n                score2 += 2 * player2[i]\\n            elif i > 1 and player2[i - 2] == 10:\\n                score2 += 2 * player2[i]\\n            else:\\n                score2 += player2[i]\\n\\n        if score1 > score2:\\n            return 1\\n        elif score1 < score2:\\n            return 2\\n        else:\\n            return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3587419,
                "title": "python3-simple-solution-beats-90-5",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a score function to calculate the scores for each player. Compare the two and return whichever one got higher.\\n\\n# Code\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        def score(player):\\n            tenBonus = 0\\n            s = 0\\n\\n            for t in player:\\n                if tenBonus:\\n                    s += 2*t\\n                    tenBonus -= 1\\n                else:\\n                    s += t\\n                    \\n                if t == 10: tenBonus = 2\\n                \\n            return s\\n        \\n        s1 = score(player1)\\n        s2 = score(player2)\\n\\n        return 1 if s1 > s2 else (2 if s2 > s1 else 0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        def score(player):\\n            tenBonus = 0\\n            s = 0\\n\\n            for t in player:\\n                if tenBonus:\\n                    s += 2*t\\n                    tenBonus -= 1\\n                else:\\n                    s += t\\n                    \\n                if t == 10: tenBonus = 2\\n                \\n            return s\\n        \\n        s1 = score(player1)\\n        s2 = score(player2)\\n\\n        return 1 if s1 > s2 else (2 if s2 > s1 else 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3587301,
                "title": "swift-100-faster",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    func isWinner(_ player1: [Int], _ player2: [Int]) -> Int {\\n        var player1HasStrike = false\\n        var player2HasStrike = false\\n        var scoresOf1Player = 0\\n        var scoresOf2Player = 0\\n        var counter1 = 0\\n        var counter2 = 0\\n\\n        for (int1, int2) in zip(player1, player2) {\\n            if player1HasStrike {\\n                scoresOf1Player += int1 * 2\\n            } else {\\n                scoresOf1Player += int1\\n            }\\n        \\n            if player2HasStrike {\\n            scoresOf2Player += int2 * 2\\n            } else {\\n                scoresOf2Player += int2\\n            }\\n        \\n            if int1 == 10 {\\n                player1HasStrike = true\\n                counter1 = 0\\n            }\\n        \\n            if int2 == 10 {\\n                player2HasStrike = true\\n                counter2 = 0\\n            }\\n        \\n            if counter1 == 2, player1HasStrike {\\n                player1HasStrike = false\\n            }\\n        \\n            if counter2 == 2, player2HasStrike {\\n                player2HasStrike = false\\n            }\\n        \\n            counter1 += 1\\n            counter2 += 1\\n        }\\n    \\n        if scoresOf1Player == scoresOf2Player {\\n            return 0\\n        }\\n    \\n        return scoresOf1Player > scoresOf2Player ? 1 : 2\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func isWinner(_ player1: [Int], _ player2: [Int]) -> Int {\\n        var player1HasStrike = false\\n        var player2HasStrike = false\\n        var scoresOf1Player = 0\\n        var scoresOf2Player = 0\\n        var counter1 = 0\\n        var counter2 = 0\\n\\n        for (int1, int2) in zip(player1, player2) {\\n            if player1HasStrike {\\n                scoresOf1Player += int1 * 2\\n            } else {\\n                scoresOf1Player += int1\\n            }\\n        \\n            if player2HasStrike {\\n            scoresOf2Player += int2 * 2\\n            } else {\\n                scoresOf2Player += int2\\n            }\\n        \\n            if int1 == 10 {\\n                player1HasStrike = true\\n                counter1 = 0\\n            }\\n        \\n            if int2 == 10 {\\n                player2HasStrike = true\\n                counter2 = 0\\n            }\\n        \\n            if counter1 == 2, player1HasStrike {\\n                player1HasStrike = false\\n            }\\n        \\n            if counter2 == 2, player2HasStrike {\\n                player2HasStrike = false\\n            }\\n        \\n            counter1 += 1\\n            counter2 += 1\\n        }\\n    \\n        if scoresOf1Player == scoresOf2Player {\\n            return 0\\n        }\\n    \\n        return scoresOf1Player > scoresOf2Player ? 1 : 2\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586023,
                "title": "java-1ms-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int p1 = -1;\\n        int p2 = -1;\\n        int p1sum = 0;\\n        int p2sum = 0;\\n        for (int i=0; i<player1.length; i++) {\\n            if (p1 == -1) {\\n                p1sum+=player1[i];\\n                if (player1[i] == 10) p1 = i;\\n            } else {\\n                if (i-p1 <= 2) {\\n                    p1sum+=(player1[i]*2);\\n                    if (player1[i] == 10) p1 = i;\\n                } else {\\n                    p1sum+=player1[i];\\n                    if (player1[i] == 10) p1 = i;\\n                    else p1 = -1;\\n                }\\n            }\\n            if (p2 == -1){\\n                p2sum+=player2[i];\\n                if (player2[i] == 10) p2 = i;\\n            } else {\\n                if (i-p2 <= 2) {\\n                    p2sum+=(player2[i]*2);\\n                    if (player2[i] == 10) p2 = i;\\n                } else {\\n                    p2sum+=player2[i];\\n                    if (player2[i] == 10) p2 = i;\\n                    else p2 = -1;\\n                }\\n            }\\n        }\\n        if (p1sum == p2sum) return 0;\\n        else if (p1sum > p2sum) return 1;\\n        else return 2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int p1 = -1;\\n        int p2 = -1;\\n        int p1sum = 0;\\n        int p2sum = 0;\\n        for (int i=0; i<player1.length; i++) {\\n            if (p1 == -1) {\\n                p1sum+=player1[i];\\n                if (player1[i] == 10) p1 = i;\\n            } else {\\n                if (i-p1 <= 2) {\\n                    p1sum+=(player1[i]*2);\\n                    if (player1[i] == 10) p1 = i;\\n                } else {\\n                    p1sum+=player1[i];\\n                    if (player1[i] == 10) p1 = i;\\n                    else p1 = -1;\\n                }\\n            }\\n            if (p2 == -1){\\n                p2sum+=player2[i];\\n                if (player2[i] == 10) p2 = i;\\n            } else {\\n                if (i-p2 <= 2) {\\n                    p2sum+=(player2[i]*2);\\n                    if (player2[i] == 10) p2 = i;\\n                } else {\\n                    p2sum+=player2[i];\\n                    if (player2[i] == 10) p2 = i;\\n                    else p2 = -1;\\n                }\\n            }\\n        }\\n        if (p1sum == p2sum) return 0;\\n        else if (p1sum > p2sum) return 1;\\n        else return 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585873,
                "title": "java-very-easy-to-understand-solution-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int first = getResult(player1), second = getResult(player2);\\n        if (first == second) {\\n            return 0;\\n        }\\n        return first > second ? 1 : 2;\\n    }\\n\\n    private static int getResult(int[] player) {\\n        int result = 0;\\n        int countStrike = 0;\\n        for (int num : player) {\\n            result += num;\\n            if (countStrike != 0) {\\n                result += num;\\n                countStrike--;\\n            }\\n            if (num == 10) {\\n                countStrike = 2;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int first = getResult(player1), second = getResult(player2);\\n        if (first == second) {\\n            return 0;\\n        }\\n        return first > second ? 1 : 2;\\n    }\\n\\n    private static int getResult(int[] player) {\\n        int result = 0;\\n        int countStrike = 0;\\n        for (int num : player) {\\n            result += num;\\n            if (countStrike != 0) {\\n                result += num;\\n                countStrike--;\\n            }\\n            if (num == 10) {\\n                countStrike = 2;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585813,
                "title": "concise-and-readable-java-solutions-multiple-approaches",
                "content": "# Approach\\nWe maintain two flags ```f1``` and ```f2``` for each player. Whenever we see a 10 for a player, we set the corresponding flag to 2. We also keep decrementing the flag at each turn. If the value of the flag is greater than 0 at a particular turn, it indicates the that player had scored a 10 in one of his two previous turns.\\n\\nThanks to @kreakEmp for this approach. Here\\'s his [solution](https://leetcode.com/problems/determine-the-winner-of-a-bowling-game/solutions/3468463/explained-very-simple-easy-to-understand-solution/). \\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n\\n##### Approach 1 :\\n\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int n = player1.length;\\n        int p1Score = 0;\\n        int p2Score = 0;\\n        int f1 = 0;\\n        int f2 = 0;\\n        for(int i=0; i<n; i++) {\\n            p1Score += f1 > 0 ? 2*player1[i] : player1[i];\\n            f1--;\\n            p2Score += f2 > 0 ? 2*player2[i] : player2[i];\\n            f2--;\\n            if(player1[i] == 10) {\\n                f1 = 2;\\n            }\\n            if(player2[i] == 10) {\\n                f2 = 2;\\n            }\\n        }\\n        if(p1Score > p2Score) {\\n            return 1;\\n        } else if(p2Score > p1Score) {\\n            return 2;\\n        } else {\\n            return 0;\\n        }\\n    }\\n}\\n```\\n\\n##### Approach 2 :\\nAn alternate straightforward, readable solution\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int n = player1.length;\\n        int p1Score = 0;\\n        int p2Score = 0;\\n        for(int i=0; i<n; i++) {\\n            int p1TurnScore = player1[i];\\n            int p2TurnScore = player2[i];\\n            if(i == 1) { // at index 1, we can only check index 0 for a 10 score\\n                if(player1[0] == 10) {\\n                    p1TurnScore *= 2;\\n                }\\n                if(player2[0] == 10) {\\n                    p2TurnScore *= 2;\\n                }\\n            } else if(i-2 >= 0) { // index 2 onwards, we can check the previous 2 indices for 10s\\n                if(player1[i-1] == 10 || player1[i-2] == 10) {\\n                    p1TurnScore *= 2;\\n                }\\n                if(player2[i-1] == 10 || player2[i-2] == 10) {\\n                    p2TurnScore *= 2;\\n                }\\n            }\\n            p1Score += p1TurnScore;\\n            p2Score += p2TurnScore;\\n        }\\n        if(p1Score > p2Score) {\\n            return 1;\\n        } else if(p2Score > p1Score) {\\n            return 2;\\n        } else {\\n            return 0;\\n        }\\n    }\\n}\\n```\\n\\nA bit more concise version of the second approach. But a little less readable imo\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int n = player1.length;\\n        int p1Score = 0;\\n        int p2Score = 0;\\n        for(int i=0; i<n; i++) {\\n            int p1TurnScore = player1[i];\\n            int p2TurnScore = player2[i];\\n            if((i == 1 && player1[0] == 10) || (i-2 >= 0 && (player1[i-1] == 10 || player1[i-2] == 10))) {\\n                p1TurnScore *= 2;\\n            }\\n            if((i == 1 && player2[0] == 10) || (i-2 >= 0 && (player2[i-1] == 10 || player2[i-2] == 10))) {\\n                p2TurnScore *= 2;\\n            }\\n            p1Score += p1TurnScore;\\n            p2Score += p2TurnScore;\\n        }\\n        if(p1Score > p2Score) {\\n            return 1;\\n        } else if(p2Score > p1Score) {\\n            return 2;\\n        } else {\\n            return 0;\\n        }\\n    }\\n}\\n```\\n\\nFeel free to comment below if you have any doubts. And please do upvote if you found this useful. It keeps me motivated to post such solutions. Thanks!",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```f1```\n```f2```\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int n = player1.length;\\n        int p1Score = 0;\\n        int p2Score = 0;\\n        int f1 = 0;\\n        int f2 = 0;\\n        for(int i=0; i<n; i++) {\\n            p1Score += f1 > 0 ? 2*player1[i] : player1[i];\\n            f1--;\\n            p2Score += f2 > 0 ? 2*player2[i] : player2[i];\\n            f2--;\\n            if(player1[i] == 10) {\\n                f1 = 2;\\n            }\\n            if(player2[i] == 10) {\\n                f2 = 2;\\n            }\\n        }\\n        if(p1Score > p2Score) {\\n            return 1;\\n        } else if(p2Score > p1Score) {\\n            return 2;\\n        } else {\\n            return 0;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int n = player1.length;\\n        int p1Score = 0;\\n        int p2Score = 0;\\n        for(int i=0; i<n; i++) {\\n            int p1TurnScore = player1[i];\\n            int p2TurnScore = player2[i];\\n            if(i == 1) { // at index 1, we can only check index 0 for a 10 score\\n                if(player1[0] == 10) {\\n                    p1TurnScore *= 2;\\n                }\\n                if(player2[0] == 10) {\\n                    p2TurnScore *= 2;\\n                }\\n            } else if(i-2 >= 0) { // index 2 onwards, we can check the previous 2 indices for 10s\\n                if(player1[i-1] == 10 || player1[i-2] == 10) {\\n                    p1TurnScore *= 2;\\n                }\\n                if(player2[i-1] == 10 || player2[i-2] == 10) {\\n                    p2TurnScore *= 2;\\n                }\\n            }\\n            p1Score += p1TurnScore;\\n            p2Score += p2TurnScore;\\n        }\\n        if(p1Score > p2Score) {\\n            return 1;\\n        } else if(p2Score > p1Score) {\\n            return 2;\\n        } else {\\n            return 0;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int n = player1.length;\\n        int p1Score = 0;\\n        int p2Score = 0;\\n        for(int i=0; i<n; i++) {\\n            int p1TurnScore = player1[i];\\n            int p2TurnScore = player2[i];\\n            if((i == 1 && player1[0] == 10) || (i-2 >= 0 && (player1[i-1] == 10 || player1[i-2] == 10))) {\\n                p1TurnScore *= 2;\\n            }\\n            if((i == 1 && player2[0] == 10) || (i-2 >= 0 && (player2[i-1] == 10 || player2[i-2] == 10))) {\\n                p2TurnScore *= 2;\\n            }\\n            p1Score += p1TurnScore;\\n            p2Score += p2TurnScore;\\n        }\\n        if(p1Score > p2Score) {\\n            return 1;\\n        } else if(p2Score > p1Score) {\\n            return 2;\\n        } else {\\n            return 0;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585115,
                "title": "easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int score(vector<int>& player){\\n        int score=0;\\n        vector<int>p=player;\\n        for(int i=0;i<player.size();i++){\\n            if((i-1>=0 && player[i-1]==10)||(i-2>=0 && player[i-2]==10)) score+=2*player[i];\\n            else score+=player[i];\\n        }\\n        return score;\\n    }\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int score1=score(player1);\\n        int score2=score(player2);\\n        if(score1>score2) return 1;\\n        else if(score2>score1) return 2;\\n        else return 0;\\n    }\\n};\\n```\\n# Please upvote if this helped!~",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int score(vector<int>& player){\\n        int score=0;\\n        vector<int>p=player;\\n        for(int i=0;i<player.size();i++){\\n            if((i-1>=0 && player[i-1]==10)||(i-2>=0 && player[i-2]==10)) score+=2*player[i];\\n            else score+=player[i];\\n        }\\n        return score;\\n    }\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int score1=score(player1);\\n        int score2=score(player2);\\n        if(score1>score2) return 1;\\n        else if(score2>score1) return 2;\\n        else return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584764,
                "title": "simple-js-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n /** \\n    here what we can do it \\n     => we can itrate over both the arrays and find the sum\\n     => and we check if the value of previous or element prevoious to previous element is 10 \\n      => if yes then we need to add the value twice or just add it once\\n    \\n*/\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} player1\\n * @param {number[]} player2\\n * @return {number}\\n */\\nvar isWinner = function(player1, player2) {\\n   \\n    \\n     let sum1=0;    \\n     let sum2=0;\\n\\n    for(let i=0;i<player1.length;i++){\\n        sum1+=player1[i];\\n        sum2+=player2[i];\\n\\n\\n        if(player1[i-1]==10 || player1[i-2]==10){\\n            sum1+=player1[i];\\n        }\\n        if(player2[i-1]==10 || player2[i-2]==10){\\n            sum2+=player2[i];\\n\\n        }\\n    }\\n\\n    if(sum1>sum2) return 1;\\n    else if(sum1<sum2) return 2;\\n    else return 0;\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {number[]} player1\\n * @param {number[]} player2\\n * @return {number}\\n */\\nvar isWinner = function(player1, player2) {\\n   \\n    \\n     let sum1=0;    \\n     let sum2=0;\\n\\n    for(let i=0;i<player1.length;i++){\\n        sum1+=player1[i];\\n        sum2+=player2[i];\\n\\n\\n        if(player1[i-1]==10 || player1[i-2]==10){\\n            sum1+=player1[i];\\n        }\\n        if(player2[i-1]==10 || player2[i-2]==10){\\n            sum2+=player2[i];\\n\\n        }\\n    }\\n\\n    if(sum1>sum2) return 1;\\n    else if(sum1<sum2) return 2;\\n    else return 0;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3584075,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def summa(self, player):\\n        p = 0\\n        for ind, i in enumerate(player):\\n            if ind < 2:\\n                p += i\\n                if ind == 1 and player[0] == 10:\\n                    p += i\\n            else:\\n                if 10 in (player[ind-1], player[ind-2]):\\n                    p += 2 * i\\n                else:\\n                    p += i\\n        return p\\n\\n\\n\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        res = []\\n        for x in (player1, player2):\\n            res.append(Solution.summa(self, x))\\n        return (len(set(res)) > 1) * (1 + res.index(max(res)))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def summa(self, player):\\n        p = 0\\n        for ind, i in enumerate(player):\\n            if ind < 2:\\n                p += i\\n                if ind == 1 and player[0] == 10:\\n                    p += i\\n            else:\\n                if 10 in (player[ind-1], player[ind-2]):\\n                    p += 2 * i\\n                else:\\n                    p += i\\n        return p\\n\\n\\n\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        res = []\\n        for x in (player1, player2):\\n            res.append(Solution.summa(self, x))\\n        return (len(set(res)) > 1) * (1 + res.index(max(res)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572682,
                "title": "easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int sum1 =0;\\n        int sum2=0;\\n        for(int i =0;i<player1.size();i++)\\n        {\\n            if((i>0 && player1[i-1]==10) ||(i>1 && player1[i-2]==10))\\n            {\\n                sum1 =sum1+(2*player1[i]);\\n            }\\n            else{\\n                sum1= sum1+player1[i];\\n            }\\n                \\n        }\\n         for(int i =0;i<player2.size();i++)\\n        {\\n            if((i>0 && player2[i-1]==10) ||(i>1 && player2[i-2]==10))\\n            {\\n                sum2 =sum2+(2*player2[i]);\\n            }\\n            else{\\n                sum2= sum2+player2[i];\\n            }\\n                \\n        }\\n        if(sum1==sum2)\\n        {\\n            return 0;\\n        }\\n        else if(sum1>sum2)\\n        {\\n            return 1;\\n        }\\n        return 2;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int sum1 =0;\\n        int sum2=0;\\n        for(int i =0;i<player1.size();i++)\\n        {\\n            if((i>0 && player1[i-1]==10) ||(i>1 && player1[i-2]==10))\\n            {\\n                sum1 =sum1+(2*player1[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3572194,
                "title": "determine-the-winner-of-a-bowling-game-c-easy-solution-understandable",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int n1=player1.size();\\n        int n2=player2.size();\\n        int p1_sum=player1[0];\\n        int p2_sum=player2[0];\\n        for(int i=1;i<n1;i++){\\n            if(i==1){\\n                if(player1[0]==10)\\n                p1_sum+=player1[i]*2;\\n                else\\n                p1_sum+=player1[i];\\n                if(player2[0]==10)\\n                p2_sum+=player2[i]*2;\\n                else\\n                p2_sum+=player2[i];\\n            }\\n            else{\\n                if(player1[i-1]==10 || player1[i-2]==10)\\n                p1_sum+=player1[i]*2;\\n                else\\n                p1_sum+=player1[i];\\n                if(player2[i-1]==10 || player2[i-2]==10)\\n                p2_sum+=player2[i]*2;\\n                else\\n                p2_sum+=player2[i];\\n            }\\n        }\\n        \\n\\n        if(p1_sum>p2_sum)\\n        return 1;\\n        else if(p1_sum<p2_sum)\\n        return 2;\\n        else\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int n1=player1.size();\\n        int n2=player2.size();\\n        int p1_sum=player1[0];\\n        int p2_sum=player2[0];\\n        for(int i=1;i<n1;i++){\\n            if(i==1){\\n                if(player1[0]==10)\\n                p1_sum+=player1[i]*2;\\n                else\\n                p1_sum+=player1[i];\\n                if(player2[0]==10)\\n                p2_sum+=player2[i]*2;\\n                else\\n                p2_sum+=player2[i];\\n            }\\n            else{\\n                if(player1[i-1]==10 || player1[i-2]==10)\\n                p1_sum+=player1[i]*2;\\n                else\\n                p1_sum+=player1[i];\\n                if(player2[i-1]==10 || player2[i-2]==10)\\n                p2_sum+=player2[i]*2;\\n                else\\n                p2_sum+=player2[i];\\n            }\\n        }\\n        \\n\\n        if(p1_sum>p2_sum)\\n        return 1;\\n        else if(p1_sum<p2_sum)\\n        return 2;\\n        else\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569278,
                "title": "my-easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int sum=0,sum1=0;\\n        for(int i=0;i<player1.size();i++){\\n           if((i>0&& player1[i-1]==10) || (i>1 && player1[i-2]==10)){\\nsum+=2*player1[i];\\n           }\\n           else{\\n               sum+=player1[i];\\n           }\\n        }\\n         for(int i=0;i<player2.size();i++){\\n             if((i>0&& player2[i-1]==10) || (i>1 && player2[i-2]==10)){\\nsum1+=2*player2[i];\\n           }\\n           else{\\n               sum1+=player2[i];\\n           }\\n        }\\n        \\n        if(sum==sum1){\\n            return 0;\\n        }\\n        else if(sum>sum1){\\n            return 1;\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int sum=0,sum1=0;\\n        for(int i=0;i<player1.size();i++){\\n           if((i>0&& player1[i-1]==10) || (i>1 && player1[i-2]==10)){\\nsum+=2*player1[i];\\n           }\\n           else{\\n               sum+=player1[i];\\n           }\\n        }\\n         for(int i=0;i<player2.size();i++){\\n             if((i>0&& player2[i-1]==10) || (i>1 && player2[i-2]==10)){\\nsum1+=2*player2[i];\\n           }\\n           else{\\n               sum1+=player2[i];\\n           }\\n        }\\n        \\n        if(sum==sum1){\\n            return 0;\\n        }\\n        else if(sum>sum1){\\n            return 1;\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3562149,
                "title": "c-brute-force-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int score1=0;\\n        for(int i=0; i<player1.size(); i++){\\n            if(i>0 && player1[i-1]==10)score1+=2*player1[i];\\n            else if(i>1 && player1[i-2]==10)score1+=2*player1[i];\\n            else {score1+=player1[i];}\\n        }\\n        int score2=0;\\n        for(int i=0; i<player2.size(); i++){\\n            if(i>0 && player2[i-1]==10)score2+=2*player2[i];\\n            else if(i>1 && player2[i-2]==10)score2+=2*player2[i];\\n            else {score2+=player2[i];}\\n        }\\n        if(score1>score2)return 1;\\n        else if(score2>score1)return 2;\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int score1=0;\\n        for(int i=0; i<player1.size(); i++){\\n            if(i>0 && player1[i-1]==10)score1+=2*player1[i];\\n            else if(i>1 && player1[i-2]==10)score1+=2*player1[i];\\n            else {score1+=player1[i];}\\n        }\\n        int score2=0;\\n        for(int i=0; i<player2.size(); i++){\\n            if(i>0 && player2[i-1]==10)score2+=2*player2[i];\\n            else if(i>1 && player2[i-2]==10)score2+=2*player2[i];\\n            else {score2+=player2[i];}\\n        }\\n        if(score1>score2)return 1;\\n        else if(score2>score1)return 2;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3561033,
                "title": "simple-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n> Basic\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBrute force\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n   \\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        s1, s2 = 0, 0                   # variables to store sum\\n        for i in range(len(player1)):   # iterating the player score\\n            # adding the initial scores\\n            s1 += player1[i]            \\n            s2 += player2[i]\\n\\n            # checking the length to check previous occurance of full score\\n            if i==1:\\n                # if there is just 1 previous element then check the previous index\\n                if player1[i-1]==10:\\n                    s1 += player1[i]    #adding it AGAIN (i.e. 2x)\\n                if player2[i-1]==10:\\n                    s2 += player2[i]\\n            elif i>1:       \\n                # if more than 1 previous elements check previous 2 indexes\\n                if player1[i-1]==10 or player1[i-2]==10:\\n                    s1 += player1[i]\\n                if player2[i-1]==10 or player2[i-2]==10:\\n                    s2 += player2[i] \\n\\n        #check and return                          \\n        if s1 > s2:\\n            return 1\\n        elif s2 > s1:\\n            return 2\\n        else:\\n            return 0                 \\n```",
                "solutionTags": [
                    "Python3",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution:\\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\\n        s1, s2 = 0, 0                   # variables to store sum\\n        for i in range(len(player1)):   # iterating the player score\\n            # adding the initial scores\\n            s1 += player1[i]            \\n            s2 += player2[i]\\n\\n            # checking the length to check previous occurance of full score\\n            if i==1:\\n                # if there is just 1 previous element then check the previous index\\n                if player1[i-1]==10:\\n                    s1 += player1[i]    #adding it AGAIN (i.e. 2x)\\n                if player2[i-1]==10:\\n                    s2 += player2[i]\\n            elif i>1:       \\n                # if more than 1 previous elements check previous 2 indexes\\n                if player1[i-1]==10 or player1[i-2]==10:\\n                    s1 += player1[i]\\n                if player2[i-1]==10 or player2[i-2]==10:\\n                    s2 += player2[i] \\n\\n        #check and return                          \\n        if s1 > s2:\\n            return 1\\n        elif s2 > s1:\\n            return 2\\n        else:\\n            return 0                 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558457,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func isWinner(_ player1: [Int], _ player2: [Int]) -> Int {\\n        \\n        func score(_ pins: [Int]) -> Int {\\n\\n            var ten = -3\\n            var res = 0\\n\\n            for i in pins.indices {\\n                if i - ten < 3 { res += pins[i] * 2 }\\n                else { res += pins[i] }\\n                if pins[i] == 10 { ten = i }\\n            }\\n\\n            return res\\n        }\\n\\n        switch score(player1) - score(player2) {\\n        case ...(-1): return 2\\n        case 1...: return 1\\n        default: return 0\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func isWinner(_ player1: [Int], _ player2: [Int]) -> Int {\\n        \\n        func score(_ pins: [Int]) -> Int {\\n\\n            var ten = -3\\n            var res = 0\\n\\n            for i in pins.indices {\\n                if i - ten < 3 { res += pins[i] * 2 }\\n                else { res += pins[i] }\\n                if pins[i] == 10 { ten = i }\\n            }\\n\\n            return res\\n        }\\n\\n        switch score(player1) - score(player2) {\\n        case ...(-1): return 2\\n        case 1...: return 1\\n        default: return 0\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558140,
                "title": "my-solution-runtime-73-ms-beats-90-37",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number[]} player1\\n * @param {number[]} player2\\n * @return {number}\\n */\\nvar isWinner = function(player1, player2) {\\n    let sum1=0;\\n    let sum2=0;\\n\\n    for (let i=0; i<player1.length; i++) {\\n        if (player1[i-1]==10 || player1[i-2]==10) {sum1+=player1[i]*2;}\\n        else {sum1+=player1[i];}\\n    }    \\n\\n    for (let i=0; i<player2.length; i++) {\\n        if (player2[i-1]==10 || player2[i-2]==10) {sum2+=player2[i]*2;}\\n        else {sum2+=player2[i];}\\n    } \\nif (sum1>sum2) {return 1;}\\nelse if (sum1==sum2) {return 0;}\\nelse if (sum1<sum2) {return 2;}\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} player1\\n * @param {number[]} player2\\n * @return {number}\\n */\\nvar isWinner = function(player1, player2) {\\n    let sum1=0;\\n    let sum2=0;\\n\\n    for (let i=0; i<player1.length; i++) {\\n        if (player1[i-1]==10 || player1[i-2]==10) {sum1+=player1[i]*2;}\\n        else {sum1+=player1[i];}\\n    }    \\n\\n    for (let i=0; i<player2.length; i++) {\\n        if (player2[i-1]==10 || player2[i-2]==10) {sum2+=player2[i]*2;}\\n        else {sum2+=player2[i];}\\n    } \\nif (sum1>sum2) {return 1;}\\nelse if (sum1==sum2) {return 0;}\\nelse if (sum1<sum2) {return 2;}\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3555001,
                "title": "easy-java-solution-beats-99-9-runtime",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int n=player1.length;\\n        int res1=player1[0];\\n        int res2=player2[0];\\n        if(n==1){\\n            if(res1==res2) return 0;\\n            else if(res1>res2 ) return 1;\\n            else return 2;\\n        }\\n        else {\\n            if(player1[0]==10) res1+=player1[1]*2;\\n            else res1+=player1[1];\\n            if(player2[0]==10) res2+=player2[1]*2;\\n            else res2+=player2[1];\\n            if(n==2){\\n                if(res1==res2) return 0;\\n                else if(res1>res2) return 1;\\n                else return 2;\\n            }\\n            else{\\n                for(int i=2;i<n;i++){\\n                    if(player1[i-1]==10 || player1[i-2]==10) res1+=2*player1[i];\\n                    else res1+=player1[i];\\n                }\\n                for(int i=2;i<n;i++){\\n                    if(player2[i-1]==10 || player2[i-2]==10) res2+=2*player2[i];\\n                    else res2+=player2[i];\\n                }\\n            }\\n        }\\n        if(res1==res2) return 0;\\n        else if(res1>res2) return 1;\\n        else return 2;\\n    }\\n}\\n```\\n![please-upvote-and.jpg](https://assets.leetcode.com/users/images/0ad5c409-73f4-48cc-926f-43d0a26fed7e_1684829609.9895198.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int n=player1.length;\\n        int res1=player1[0];\\n        int res2=player2[0];\\n        if(n==1){\\n            if(res1==res2) return 0;\\n            else if(res1>res2 ) return 1;\\n            else return 2;\\n        }\\n        else {\\n            if(player1[0]==10) res1+=player1[1]*2;\\n            else res1+=player1[1];\\n            if(player2[0]==10) res2+=player2[1]*2;\\n            else res2+=player2[1];\\n            if(n==2){\\n                if(res1==res2) return 0;\\n                else if(res1>res2) return 1;\\n                else return 2;\\n            }\\n            else{\\n                for(int i=2;i<n;i++){\\n                    if(player1[i-1]==10 || player1[i-2]==10) res1+=2*player1[i];\\n                    else res1+=player1[i];\\n                }\\n                for(int i=2;i<n;i++){\\n                    if(player2[i-1]==10 || player2[i-2]==10) res2+=2*player2[i];\\n                    else res2+=player2[i];\\n                }\\n            }\\n        }\\n        if(res1==res2) return 0;\\n        else if(res1>res2) return 1;\\n        else return 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546710,
                "title": "very-easy-to-understand-c-solution",
                "content": "# Jai Shree Ram\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& arr){\\n        int n=arr.size();\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            if(i==0)sum+=arr[i];\\n            else if(i==1){\\n                if(arr[i-1]==10)sum+=(2*arr[i]);\\n                else sum+=arr[i];\\n            }\\n            else{\\n                if(arr[i-1]==10 || arr[i-2]==10)sum+=(2*arr[i]);\\n                else sum+=arr[i];\\n            }\\n        }\\n        return sum;\\n    }\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        if(solve(player1)>solve(player2))return 1;\\n        else if(solve(player1)<solve(player2))return 2;\\n        return 0;\\n    }\\n};\\n```\\n![leetcode upvote.jpg](https://assets.leetcode.com/users/images/25d70117-0e3e-4bd0-95ba-100c7345ff6c_1684641604.5223634.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& arr){\\n        int n=arr.size();\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            if(i==0)sum+=arr[i];\\n            else if(i==1){\\n                if(arr[i-1]==10)sum+=(2*arr[i]);\\n                else sum+=arr[i];\\n            }\\n            else{\\n                if(arr[i-1]==10 || arr[i-2]==10)sum+=(2*arr[i]);\\n                else sum+=arr[i];\\n            }\\n        }\\n        return sum;\\n    }\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        if(solve(player1)>solve(player2))return 1;\\n        else if(solve(player1)<solve(player2))return 2;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544657,
                "title": "least-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int s1=0, s2=0;\\n        int f1=0,f2=0;\\n        for(int i=0; i<player1.length;i++){\\n            if(f1>0){\\n                s1+=player1[i]*2;\\n                f1--;\\n            }else{\\n                s1+=player1[i];\\n            }\\n            if(player1[i]==10){\\n                    f1=2;\\n            }\\n            if(f2>0){\\n                s2+=player2[i]*2;\\n                f2--;\\n            }else{\\n                s2+=player2[i];\\n            }\\n            if(player2[i]==10){\\n                    f2=2;\\n            }\\n\\n        }\\n        if(s1<s2){\\n            return 2;\\n        }if(s1>s2){\\n            return 1;\\n        }else\\n            return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int s1=0, s2=0;\\n        int f1=0,f2=0;\\n        for(int i=0; i<player1.length;i++){\\n            if(f1>0){\\n                s1+=player1[i]*2;\\n                f1--;\\n            }else{\\n                s1+=player1[i];\\n            }\\n            if(player1[i]==10){\\n                    f1=2;\\n            }\\n            if(f2>0){\\n                s2+=player2[i]*2;\\n                f2--;\\n            }else{\\n                s2+=player2[i];\\n            }\\n            if(player2[i]==10){\\n                    f2=2;\\n            }\\n\\n        }\\n        if(s1<s2){\\n            return 2;\\n        }if(s1>s2){\\n            return 1;\\n        }else\\n            return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540082,
                "title": "c-solution-o-n-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int sum1 = 0;\\n        for(int i=0;i<player1.size();i++){\\n            if(i==1 && player1[i-1]==10){\\n                sum1 = sum1 + 2*player1[i];\\n            }\\n            else if(i>=2 && (player1[i-1]==10 || player1[i-2]==10)){\\n                sum1 = sum1 + 2*player1[i];\\n            }\\n            else{\\n                sum1 = sum1 + player1[i];\\n            }\\n        }\\n        int sum2 = 0;\\n        for(int i=0;i<player2.size();i++){\\n            if(i==1 && (player2[i-1]==10)){\\n                sum2 = sum2 + 2*player2[i];\\n            }\\n            else if(i>=2 && (player2[i-1]==10 || player2[i-2]==10)){\\n                sum2 = sum2 + 2*player2[i];\\n            }\\n            else{\\n                sum2 = sum2 + player2[i];\\n            }\\n        }\\n        if(sum1>sum2){\\n            return 1;\\n        }\\n        else if(sum2>sum1){\\n            return 2;\\n        }\\n        else{\\n            return 0;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isWinner(vector<int>& player1, vector<int>& player2) {\\n        int sum1 = 0;\\n        for(int i=0;i<player1.size();i++){\\n            if(i==1 && player1[i-1]==10){\\n                sum1 = sum1 + 2*player1[i];\\n            }\\n            else if(i>=2 && (player1[i-1]==10 || player1[i-2]==10)){\\n                sum1 = sum1 + 2*player1[i];\\n            }\\n            else{\\n                sum1 = sum1 + player1[i];\\n            }\\n        }\\n        int sum2 = 0;\\n        for(int i=0;i<player2.size();i++){\\n            if(i==1 && (player2[i-1]==10)){\\n                sum2 = sum2 + 2*player2[i];\\n            }\\n            else if(i>=2 && (player2[i-1]==10 || player2[i-2]==10)){\\n                sum2 = sum2 + 2*player2[i];\\n            }\\n            else{\\n                sum2 = sum2 + player2[i];\\n            }\\n        }\\n        if(sum1>sum2){\\n            return 1;\\n        }\\n        else if(sum2>sum1){\\n            return 2;\\n        }\\n        else{\\n            return 0;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540076,
                "title": "java-solution-o-n-time-99-90-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int sum1 = 0;\\n        for(int i=0;i<player1.length;i++){\\n            if(i==1 && player1[i-1]==10){\\n                sum1 = sum1 + 2*player1[i];\\n            }\\n            else if(i>=2 && (player1[i-1]==10 || player1[i-2]==10)){\\n                sum1 = sum1 + 2*player1[i];\\n            }\\n            else{\\n                sum1 = sum1 + player1[i];\\n            }\\n        }\\n        int sum2 = 0;\\n        for(int i=0;i<player2.length;i++){\\n            if(i==1 && (player2[i-1]==10)){\\n                sum2 = sum2 + 2*player2[i];\\n            }\\n            else if(i>=2 && (player2[i-1]==10 || player2[i-2]==10)){\\n                sum2 = sum2 + 2*player2[i];\\n            }\\n            else{\\n                sum2 = sum2 + player2[i];\\n            }\\n        }\\n        if(sum1>sum2){\\n            return 1;\\n        }\\n        else if(sum2>sum1){\\n            return 2;\\n        }\\n        else{\\n            return 0;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int sum1 = 0;\\n        for(int i=0;i<player1.length;i++){\\n            if(i==1 && player1[i-1]==10){\\n                sum1 = sum1 + 2*player1[i];\\n            }\\n            else if(i>=2 && (player1[i-1]==10 || player1[i-2]==10)){\\n                sum1 = sum1 + 2*player1[i];\\n            }\\n            else{\\n                sum1 = sum1 + player1[i];\\n            }\\n        }\\n        int sum2 = 0;\\n        for(int i=0;i<player2.length;i++){\\n            if(i==1 && (player2[i-1]==10)){\\n                sum2 = sum2 + 2*player2[i];\\n            }\\n            else if(i>=2 && (player2[i-1]==10 || player2[i-2]==10)){\\n                sum2 = sum2 + 2*player2[i];\\n            }\\n            else{\\n                sum2 = sum2 + player2[i];\\n            }\\n        }\\n        if(sum1>sum2){\\n            return 1;\\n        }\\n        else if(sum2>sum1){\\n            return 2;\\n        }\\n        else{\\n            return 0;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3539620,
                "title": "bowling-game-javascript-count-strikes-85-ms",
                "content": "```\\nvar isWinner = function(player1, player2) {\\n    p1_x2 = p2_x2 = 0\\n    sum1 = sum2 = 0\\n    \\n    for (let i = 0; i < player1.length; i++) {\\n        sum1 += p1_x2 > 0 ? player1[i] * 2 : player1[i] \\n        sum2 += p2_x2 > 0 ? player2[i] * 2 : player2[i] \\n\\n        p1_x2 = p1_x2 > 0 ? p1_x2 - 1 : p1_x2 \\n        p2_x2 = p2_x2 > 0 ? p2_x2 - 1 : p2_x2 \\n\\n        p1_x2 = player1[i] == 10 ? 2 : p1_x2\\n        p2_x2 = player2[i] == 10 ? 2 : p2_x2  \\n    }    \\n\\n    return sum1 > sum2 ? 1 : sum1 == sum2 ? 0 : 2\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isWinner = function(player1, player2) {\\n    p1_x2 = p2_x2 = 0\\n    sum1 = sum2 = 0\\n    \\n    for (let i = 0; i < player1.length; i++) {\\n        sum1 += p1_x2 > 0 ? player1[i] * 2 : player1[i] \\n        sum2 += p2_x2 > 0 ? player2[i] * 2 : player2[i] \\n\\n        p1_x2 = p1_x2 > 0 ? p1_x2 - 1 : p1_x2 \\n        p2_x2 = p2_x2 > 0 ? p2_x2 - 1 : p2_x2 \\n\\n        p1_x2 = player1[i] == 10 ? 2 : p1_x2\\n        p2_x2 = player2[i] == 10 ? 2 : p2_x2  \\n    }    \\n\\n    return sum1 > sum2 ? 1 : sum1 == sum2 ? 0 : 2\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3539541,
                "title": "php-foreach-2n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $player1\\n     * @param Integer[] $player2\\n     * @return Integer\\n     */\\n    function isWinner($player1, $player2) {\\n        $score1 = 0;\\n        $score2 = 0;\\n\\n        foreach ($player1 as $key => $value) {\\n            $caf = 1;\\n            if (isset($player1[$key-1]) && $player1[$key-1] === 10) {\\n                $caf = 2;\\n            } elseif (isset($player1[$key-2]) && $player1[$key-2] === 10) {\\n                $caf = 2;\\n            }\\n            $score1 += ($value*$caf);\\n        }\\n\\n        foreach ($player2 as $key => $value) {\\n            $caf = 1;\\n            if (isset($player2[$key-1]) && $player2[$key-1] === 10) {\\n                $caf = 2;\\n            } elseif (isset($player2[$key-2]) && $player2[$key-2] === 10) {\\n                $caf = 2;\\n            }\\n            $score2 += ($value*$caf);\\n        }\\n\\n        if (($result = ($score1 <=> $score2)) === -1) {\\n            return 2;\\n        }\\n\\n        return $result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $player1\\n     * @param Integer[] $player2\\n     * @return Integer\\n     */\\n    function isWinner($player1, $player2) {\\n        $score1 = 0;\\n        $score2 = 0;\\n\\n        foreach ($player1 as $key => $value) {\\n            $caf = 1;\\n            if (isset($player1[$key-1]) && $player1[$key-1] === 10) {\\n                $caf = 2;\\n            } elseif (isset($player1[$key-2]) && $player1[$key-2] === 10) {\\n                $caf = 2;\\n            }\\n            $score1 += ($value*$caf);\\n        }\\n\\n        foreach ($player2 as $key => $value) {\\n            $caf = 1;\\n            if (isset($player2[$key-1]) && $player2[$key-1] === 10) {\\n                $caf = 2;\\n            } elseif (isset($player2[$key-2]) && $player2[$key-2] === 10) {\\n                $caf = 2;\\n            }\\n            $score2 += ($value*$caf);\\n        }\\n\\n        if (($result = ($score1 <=> $score2)) === -1) {\\n            return 2;\\n        }\\n\\n        return $result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3537633,
                "title": "c-calculating-scores-110ms-95",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int IsWinner(int[] player1, int[] player2) \\n    {\\n        var diff = GetScore(player1) - GetScore(player2);\\n\\n        return diff == 0 ? 0 : (diff > 0 ? 1 : 2);\\n    }\\n\\n    int GetScore(int[] hits)\\n    {\\n        var doubling = 0;\\n\\n        var score = 0;\\n\\n        foreach(var h in hits)\\n        {\\n            score += (doubling-- > 0) ? 2 * h : h;\\n\\n            if(h == 10) doubling = 2;\\n        }\\n\\n        return score;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int IsWinner(int[] player1, int[] player2) \\n    {\\n        var diff = GetScore(player1) - GetScore(player2);\\n\\n        return diff == 0 ? 0 : (diff > 0 ? 1 : 2);\\n    }\\n\\n    int GetScore(int[] hits)\\n    {\\n        var doubling = 0;\\n\\n        var score = 0;\\n\\n        foreach(var h in hits)\\n        {\\n            score += (doubling-- > 0) ? 2 * h : h;\\n\\n            if(h == 10) doubling = 2;\\n        }\\n\\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1878349,
                "content": [
                    {
                        "username": "almostmonday",
                        "content": "Be careful:\n1) previous **TWO** turns;\n2) \"in any of the previous two turns\" means `player[i - 1] == 10 or player[i - 2] == 10`."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**improves attention**"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "hahahaha"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it wasn\\'t a easy question bro "
                    },
                    {
                        "username": "hhimanshii",
                        "content": "They should have given good example test cases. It\\'s so unclear from the given test cases."
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "2xi (((if the player hits 10 pins in any of the previous two turns))). Read this line very carefully my fellow leetcoders only the one in bracket. We need to double the current score if it satisfies this condition "
                    },
                    {
                        "username": "gouravchalotra",
                        "content": "it\\'s took me 1 hour to to understand it \\uD83E\\uDD72"
                    },
                    {
                        "username": "learn_improve",
                        "content": "Thanks for highlighting this"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "Has any one got the same problem ?\\n```\\nplayer1 = [9,7,10,7]\\nplayer2 = [10,2,4,10]\\n```\\nThe total scores should be \\n```\\nscore_1 = 40\\nscore_2 = 42\\n```\\nAccording to the condition \\n```\\nsocre_2 > score_1 = True\\n```\\nand hence the output should be \\n```\\nOutput : 2\\n```\\nThen why it is showing the output to be \\n```\\nExpected : 1\\n```"
                    },
                    {
                        "username": "iam_kmrahul",
                        "content": "score_1=9+7+10+7*2=40\\nscore_2=10+2*2+4*2+10=32\\nso player 1 is scored more \\n1 is correct output"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@kshapwari](/kshapwari) \\n\\nLets consider this test case \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\nOutput: 2\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\nHere the 2nd 10 is also multiplied with 2, that\\'s why I consider multiplication with 2 \\n\\n```\\n10 + (2 * 2) + (2 * 4) + (2 * 10)\\n= 10 + 4 + 8 + 20\\n= 42\\n```"
                    },
                    {
                        "username": "kshapwari",
                        "content": "score_2 = 32\\n10 + 2*2 + 2*4 + 10 =32"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@mainadotkim](/mainadotkim)  \\n\\nHey mainadotkim !. \\n\\nI had thought of this case but when I saw this test case in the example \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\n\\nOutput: 2\\n\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\n\\nIn this test case the second `10` was also multiplied by `2`"
                    },
                    {
                        "username": "mainadotkim",
                        "content": "Because\n\n```\nscore_1 = 40\nscore_2 = 32\n```\n\nAnd the output will be as `Expected: 1`\n\nExplanation:\n\nThe statement\n\n> 2xi if the player hit 10 pins in any of the previous two turns\n\nmeans that the last 10 scored by `player2` should not be doubled.\n\nThus, `score_2 = 10 + 2*2 + 2*4 + 10`"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Tip : Don\\'t underestimate this one "
                    },
                    {
                        "username": "NitinSingh77",
                        "content": "player1=[10,2,2,3]\\nplayer2=[3,8,4,5]\\n\\nWhy is player 1 the winner in this test case?"
                    },
                    {
                        "username": "IgorP17",
                        "content": "[@qleIIT](/qleIIT) yes, it seems here was the problem"
                    },
                    {
                        "username": "IgorP17",
                        "content": "I wrote aux method for cheking if we need doubling and test was passed)). Do not understand what was wrong)).\\nMethod:\\nboolean checkLast(int k, int[] res)\\nk == 0 -> false\\nk == 1 -> res[k - 1] == 10\\nelse -> res[k - 1] == 10 || res[k - 2] == 10"
                    },
                    {
                        "username": "qleIIT",
                        "content": "Im no expert here, since I failed this question miserably , but for your example, player1 gets 10 + 2x2 + 2x2 + 3 = 21, player2 gets 3 + 8 + 4 + 5 = 20. So player1 is the winner here."
                    },
                    {
                        "username": "qleIIT",
                        "content": "29.7% acceptance rate for an \"Easy\" contest Q1 huh?\n\n"
                    },
                    {
                        "username": "luckymaster",
                        "content": "what does this mean --> 2xi if the player hit 10 pins in any of the previous two turns. \\nSo unclear. Please try to write proper statement it is so ambiguous. I could not understand it. "
                    },
                    {
                        "username": "Finesse",
                        "content": "The score of a turn doubles, if the score of the previous turn or the turn before the previous was 10. I.e. `if player1[i - 1] == 10 || player1[i - 2] == 10 { player1[i] *= 2 }`."
                    },
                    {
                        "username": "aquaman55",
                        "content": "Its bowling man. Have you never bowled? lol"
                    }
                ]
            },
            {
                "id": 1879196,
                "content": [
                    {
                        "username": "almostmonday",
                        "content": "Be careful:\n1) previous **TWO** turns;\n2) \"in any of the previous two turns\" means `player[i - 1] == 10 or player[i - 2] == 10`."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**improves attention**"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "hahahaha"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it wasn\\'t a easy question bro "
                    },
                    {
                        "username": "hhimanshii",
                        "content": "They should have given good example test cases. It\\'s so unclear from the given test cases."
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "2xi (((if the player hits 10 pins in any of the previous two turns))). Read this line very carefully my fellow leetcoders only the one in bracket. We need to double the current score if it satisfies this condition "
                    },
                    {
                        "username": "gouravchalotra",
                        "content": "it\\'s took me 1 hour to to understand it \\uD83E\\uDD72"
                    },
                    {
                        "username": "learn_improve",
                        "content": "Thanks for highlighting this"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "Has any one got the same problem ?\\n```\\nplayer1 = [9,7,10,7]\\nplayer2 = [10,2,4,10]\\n```\\nThe total scores should be \\n```\\nscore_1 = 40\\nscore_2 = 42\\n```\\nAccording to the condition \\n```\\nsocre_2 > score_1 = True\\n```\\nand hence the output should be \\n```\\nOutput : 2\\n```\\nThen why it is showing the output to be \\n```\\nExpected : 1\\n```"
                    },
                    {
                        "username": "iam_kmrahul",
                        "content": "score_1=9+7+10+7*2=40\\nscore_2=10+2*2+4*2+10=32\\nso player 1 is scored more \\n1 is correct output"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@kshapwari](/kshapwari) \\n\\nLets consider this test case \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\nOutput: 2\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\nHere the 2nd 10 is also multiplied with 2, that\\'s why I consider multiplication with 2 \\n\\n```\\n10 + (2 * 2) + (2 * 4) + (2 * 10)\\n= 10 + 4 + 8 + 20\\n= 42\\n```"
                    },
                    {
                        "username": "kshapwari",
                        "content": "score_2 = 32\\n10 + 2*2 + 2*4 + 10 =32"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@mainadotkim](/mainadotkim)  \\n\\nHey mainadotkim !. \\n\\nI had thought of this case but when I saw this test case in the example \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\n\\nOutput: 2\\n\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\n\\nIn this test case the second `10` was also multiplied by `2`"
                    },
                    {
                        "username": "mainadotkim",
                        "content": "Because\n\n```\nscore_1 = 40\nscore_2 = 32\n```\n\nAnd the output will be as `Expected: 1`\n\nExplanation:\n\nThe statement\n\n> 2xi if the player hit 10 pins in any of the previous two turns\n\nmeans that the last 10 scored by `player2` should not be doubled.\n\nThus, `score_2 = 10 + 2*2 + 2*4 + 10`"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Tip : Don\\'t underestimate this one "
                    },
                    {
                        "username": "NitinSingh77",
                        "content": "player1=[10,2,2,3]\\nplayer2=[3,8,4,5]\\n\\nWhy is player 1 the winner in this test case?"
                    },
                    {
                        "username": "IgorP17",
                        "content": "[@qleIIT](/qleIIT) yes, it seems here was the problem"
                    },
                    {
                        "username": "IgorP17",
                        "content": "I wrote aux method for cheking if we need doubling and test was passed)). Do not understand what was wrong)).\\nMethod:\\nboolean checkLast(int k, int[] res)\\nk == 0 -> false\\nk == 1 -> res[k - 1] == 10\\nelse -> res[k - 1] == 10 || res[k - 2] == 10"
                    },
                    {
                        "username": "qleIIT",
                        "content": "Im no expert here, since I failed this question miserably , but for your example, player1 gets 10 + 2x2 + 2x2 + 3 = 21, player2 gets 3 + 8 + 4 + 5 = 20. So player1 is the winner here."
                    },
                    {
                        "username": "qleIIT",
                        "content": "29.7% acceptance rate for an \"Easy\" contest Q1 huh?\n\n"
                    },
                    {
                        "username": "luckymaster",
                        "content": "what does this mean --> 2xi if the player hit 10 pins in any of the previous two turns. \\nSo unclear. Please try to write proper statement it is so ambiguous. I could not understand it. "
                    },
                    {
                        "username": "Finesse",
                        "content": "The score of a turn doubles, if the score of the previous turn or the turn before the previous was 10. I.e. `if player1[i - 1] == 10 || player1[i - 2] == 10 { player1[i] *= 2 }`."
                    },
                    {
                        "username": "aquaman55",
                        "content": "Its bowling man. Have you never bowled? lol"
                    }
                ]
            },
            {
                "id": 1878218,
                "content": [
                    {
                        "username": "almostmonday",
                        "content": "Be careful:\n1) previous **TWO** turns;\n2) \"in any of the previous two turns\" means `player[i - 1] == 10 or player[i - 2] == 10`."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**improves attention**"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "hahahaha"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it wasn\\'t a easy question bro "
                    },
                    {
                        "username": "hhimanshii",
                        "content": "They should have given good example test cases. It\\'s so unclear from the given test cases."
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "2xi (((if the player hits 10 pins in any of the previous two turns))). Read this line very carefully my fellow leetcoders only the one in bracket. We need to double the current score if it satisfies this condition "
                    },
                    {
                        "username": "gouravchalotra",
                        "content": "it\\'s took me 1 hour to to understand it \\uD83E\\uDD72"
                    },
                    {
                        "username": "learn_improve",
                        "content": "Thanks for highlighting this"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "Has any one got the same problem ?\\n```\\nplayer1 = [9,7,10,7]\\nplayer2 = [10,2,4,10]\\n```\\nThe total scores should be \\n```\\nscore_1 = 40\\nscore_2 = 42\\n```\\nAccording to the condition \\n```\\nsocre_2 > score_1 = True\\n```\\nand hence the output should be \\n```\\nOutput : 2\\n```\\nThen why it is showing the output to be \\n```\\nExpected : 1\\n```"
                    },
                    {
                        "username": "iam_kmrahul",
                        "content": "score_1=9+7+10+7*2=40\\nscore_2=10+2*2+4*2+10=32\\nso player 1 is scored more \\n1 is correct output"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@kshapwari](/kshapwari) \\n\\nLets consider this test case \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\nOutput: 2\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\nHere the 2nd 10 is also multiplied with 2, that\\'s why I consider multiplication with 2 \\n\\n```\\n10 + (2 * 2) + (2 * 4) + (2 * 10)\\n= 10 + 4 + 8 + 20\\n= 42\\n```"
                    },
                    {
                        "username": "kshapwari",
                        "content": "score_2 = 32\\n10 + 2*2 + 2*4 + 10 =32"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@mainadotkim](/mainadotkim)  \\n\\nHey mainadotkim !. \\n\\nI had thought of this case but when I saw this test case in the example \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\n\\nOutput: 2\\n\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\n\\nIn this test case the second `10` was also multiplied by `2`"
                    },
                    {
                        "username": "mainadotkim",
                        "content": "Because\n\n```\nscore_1 = 40\nscore_2 = 32\n```\n\nAnd the output will be as `Expected: 1`\n\nExplanation:\n\nThe statement\n\n> 2xi if the player hit 10 pins in any of the previous two turns\n\nmeans that the last 10 scored by `player2` should not be doubled.\n\nThus, `score_2 = 10 + 2*2 + 2*4 + 10`"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Tip : Don\\'t underestimate this one "
                    },
                    {
                        "username": "NitinSingh77",
                        "content": "player1=[10,2,2,3]\\nplayer2=[3,8,4,5]\\n\\nWhy is player 1 the winner in this test case?"
                    },
                    {
                        "username": "IgorP17",
                        "content": "[@qleIIT](/qleIIT) yes, it seems here was the problem"
                    },
                    {
                        "username": "IgorP17",
                        "content": "I wrote aux method for cheking if we need doubling and test was passed)). Do not understand what was wrong)).\\nMethod:\\nboolean checkLast(int k, int[] res)\\nk == 0 -> false\\nk == 1 -> res[k - 1] == 10\\nelse -> res[k - 1] == 10 || res[k - 2] == 10"
                    },
                    {
                        "username": "qleIIT",
                        "content": "Im no expert here, since I failed this question miserably , but for your example, player1 gets 10 + 2x2 + 2x2 + 3 = 21, player2 gets 3 + 8 + 4 + 5 = 20. So player1 is the winner here."
                    },
                    {
                        "username": "qleIIT",
                        "content": "29.7% acceptance rate for an \"Easy\" contest Q1 huh?\n\n"
                    },
                    {
                        "username": "luckymaster",
                        "content": "what does this mean --> 2xi if the player hit 10 pins in any of the previous two turns. \\nSo unclear. Please try to write proper statement it is so ambiguous. I could not understand it. "
                    },
                    {
                        "username": "Finesse",
                        "content": "The score of a turn doubles, if the score of the previous turn or the turn before the previous was 10. I.e. `if player1[i - 1] == 10 || player1[i - 2] == 10 { player1[i] *= 2 }`."
                    },
                    {
                        "username": "aquaman55",
                        "content": "Its bowling man. Have you never bowled? lol"
                    }
                ]
            },
            {
                "id": 1877921,
                "content": [
                    {
                        "username": "almostmonday",
                        "content": "Be careful:\n1) previous **TWO** turns;\n2) \"in any of the previous two turns\" means `player[i - 1] == 10 or player[i - 2] == 10`."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**improves attention**"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "hahahaha"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it wasn\\'t a easy question bro "
                    },
                    {
                        "username": "hhimanshii",
                        "content": "They should have given good example test cases. It\\'s so unclear from the given test cases."
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "2xi (((if the player hits 10 pins in any of the previous two turns))). Read this line very carefully my fellow leetcoders only the one in bracket. We need to double the current score if it satisfies this condition "
                    },
                    {
                        "username": "gouravchalotra",
                        "content": "it\\'s took me 1 hour to to understand it \\uD83E\\uDD72"
                    },
                    {
                        "username": "learn_improve",
                        "content": "Thanks for highlighting this"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "Has any one got the same problem ?\\n```\\nplayer1 = [9,7,10,7]\\nplayer2 = [10,2,4,10]\\n```\\nThe total scores should be \\n```\\nscore_1 = 40\\nscore_2 = 42\\n```\\nAccording to the condition \\n```\\nsocre_2 > score_1 = True\\n```\\nand hence the output should be \\n```\\nOutput : 2\\n```\\nThen why it is showing the output to be \\n```\\nExpected : 1\\n```"
                    },
                    {
                        "username": "iam_kmrahul",
                        "content": "score_1=9+7+10+7*2=40\\nscore_2=10+2*2+4*2+10=32\\nso player 1 is scored more \\n1 is correct output"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@kshapwari](/kshapwari) \\n\\nLets consider this test case \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\nOutput: 2\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\nHere the 2nd 10 is also multiplied with 2, that\\'s why I consider multiplication with 2 \\n\\n```\\n10 + (2 * 2) + (2 * 4) + (2 * 10)\\n= 10 + 4 + 8 + 20\\n= 42\\n```"
                    },
                    {
                        "username": "kshapwari",
                        "content": "score_2 = 32\\n10 + 2*2 + 2*4 + 10 =32"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@mainadotkim](/mainadotkim)  \\n\\nHey mainadotkim !. \\n\\nI had thought of this case but when I saw this test case in the example \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\n\\nOutput: 2\\n\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\n\\nIn this test case the second `10` was also multiplied by `2`"
                    },
                    {
                        "username": "mainadotkim",
                        "content": "Because\n\n```\nscore_1 = 40\nscore_2 = 32\n```\n\nAnd the output will be as `Expected: 1`\n\nExplanation:\n\nThe statement\n\n> 2xi if the player hit 10 pins in any of the previous two turns\n\nmeans that the last 10 scored by `player2` should not be doubled.\n\nThus, `score_2 = 10 + 2*2 + 2*4 + 10`"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Tip : Don\\'t underestimate this one "
                    },
                    {
                        "username": "NitinSingh77",
                        "content": "player1=[10,2,2,3]\\nplayer2=[3,8,4,5]\\n\\nWhy is player 1 the winner in this test case?"
                    },
                    {
                        "username": "IgorP17",
                        "content": "[@qleIIT](/qleIIT) yes, it seems here was the problem"
                    },
                    {
                        "username": "IgorP17",
                        "content": "I wrote aux method for cheking if we need doubling and test was passed)). Do not understand what was wrong)).\\nMethod:\\nboolean checkLast(int k, int[] res)\\nk == 0 -> false\\nk == 1 -> res[k - 1] == 10\\nelse -> res[k - 1] == 10 || res[k - 2] == 10"
                    },
                    {
                        "username": "qleIIT",
                        "content": "Im no expert here, since I failed this question miserably , but for your example, player1 gets 10 + 2x2 + 2x2 + 3 = 21, player2 gets 3 + 8 + 4 + 5 = 20. So player1 is the winner here."
                    },
                    {
                        "username": "qleIIT",
                        "content": "29.7% acceptance rate for an \"Easy\" contest Q1 huh?\n\n"
                    },
                    {
                        "username": "luckymaster",
                        "content": "what does this mean --> 2xi if the player hit 10 pins in any of the previous two turns. \\nSo unclear. Please try to write proper statement it is so ambiguous. I could not understand it. "
                    },
                    {
                        "username": "Finesse",
                        "content": "The score of a turn doubles, if the score of the previous turn or the turn before the previous was 10. I.e. `if player1[i - 1] == 10 || player1[i - 2] == 10 { player1[i] *= 2 }`."
                    },
                    {
                        "username": "aquaman55",
                        "content": "Its bowling man. Have you never bowled? lol"
                    }
                ]
            },
            {
                "id": 1877795,
                "content": [
                    {
                        "username": "almostmonday",
                        "content": "Be careful:\n1) previous **TWO** turns;\n2) \"in any of the previous two turns\" means `player[i - 1] == 10 or player[i - 2] == 10`."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**improves attention**"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "hahahaha"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it wasn\\'t a easy question bro "
                    },
                    {
                        "username": "hhimanshii",
                        "content": "They should have given good example test cases. It\\'s so unclear from the given test cases."
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "2xi (((if the player hits 10 pins in any of the previous two turns))). Read this line very carefully my fellow leetcoders only the one in bracket. We need to double the current score if it satisfies this condition "
                    },
                    {
                        "username": "gouravchalotra",
                        "content": "it\\'s took me 1 hour to to understand it \\uD83E\\uDD72"
                    },
                    {
                        "username": "learn_improve",
                        "content": "Thanks for highlighting this"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "Has any one got the same problem ?\\n```\\nplayer1 = [9,7,10,7]\\nplayer2 = [10,2,4,10]\\n```\\nThe total scores should be \\n```\\nscore_1 = 40\\nscore_2 = 42\\n```\\nAccording to the condition \\n```\\nsocre_2 > score_1 = True\\n```\\nand hence the output should be \\n```\\nOutput : 2\\n```\\nThen why it is showing the output to be \\n```\\nExpected : 1\\n```"
                    },
                    {
                        "username": "iam_kmrahul",
                        "content": "score_1=9+7+10+7*2=40\\nscore_2=10+2*2+4*2+10=32\\nso player 1 is scored more \\n1 is correct output"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@kshapwari](/kshapwari) \\n\\nLets consider this test case \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\nOutput: 2\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\nHere the 2nd 10 is also multiplied with 2, that\\'s why I consider multiplication with 2 \\n\\n```\\n10 + (2 * 2) + (2 * 4) + (2 * 10)\\n= 10 + 4 + 8 + 20\\n= 42\\n```"
                    },
                    {
                        "username": "kshapwari",
                        "content": "score_2 = 32\\n10 + 2*2 + 2*4 + 10 =32"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@mainadotkim](/mainadotkim)  \\n\\nHey mainadotkim !. \\n\\nI had thought of this case but when I saw this test case in the example \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\n\\nOutput: 2\\n\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\n\\nIn this test case the second `10` was also multiplied by `2`"
                    },
                    {
                        "username": "mainadotkim",
                        "content": "Because\n\n```\nscore_1 = 40\nscore_2 = 32\n```\n\nAnd the output will be as `Expected: 1`\n\nExplanation:\n\nThe statement\n\n> 2xi if the player hit 10 pins in any of the previous two turns\n\nmeans that the last 10 scored by `player2` should not be doubled.\n\nThus, `score_2 = 10 + 2*2 + 2*4 + 10`"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Tip : Don\\'t underestimate this one "
                    },
                    {
                        "username": "NitinSingh77",
                        "content": "player1=[10,2,2,3]\\nplayer2=[3,8,4,5]\\n\\nWhy is player 1 the winner in this test case?"
                    },
                    {
                        "username": "IgorP17",
                        "content": "[@qleIIT](/qleIIT) yes, it seems here was the problem"
                    },
                    {
                        "username": "IgorP17",
                        "content": "I wrote aux method for cheking if we need doubling and test was passed)). Do not understand what was wrong)).\\nMethod:\\nboolean checkLast(int k, int[] res)\\nk == 0 -> false\\nk == 1 -> res[k - 1] == 10\\nelse -> res[k - 1] == 10 || res[k - 2] == 10"
                    },
                    {
                        "username": "qleIIT",
                        "content": "Im no expert here, since I failed this question miserably , but for your example, player1 gets 10 + 2x2 + 2x2 + 3 = 21, player2 gets 3 + 8 + 4 + 5 = 20. So player1 is the winner here."
                    },
                    {
                        "username": "qleIIT",
                        "content": "29.7% acceptance rate for an \"Easy\" contest Q1 huh?\n\n"
                    },
                    {
                        "username": "luckymaster",
                        "content": "what does this mean --> 2xi if the player hit 10 pins in any of the previous two turns. \\nSo unclear. Please try to write proper statement it is so ambiguous. I could not understand it. "
                    },
                    {
                        "username": "Finesse",
                        "content": "The score of a turn doubles, if the score of the previous turn or the turn before the previous was 10. I.e. `if player1[i - 1] == 10 || player1[i - 2] == 10 { player1[i] *= 2 }`."
                    },
                    {
                        "username": "aquaman55",
                        "content": "Its bowling man. Have you never bowled? lol"
                    }
                ]
            },
            {
                "id": 1943431,
                "content": [
                    {
                        "username": "almostmonday",
                        "content": "Be careful:\n1) previous **TWO** turns;\n2) \"in any of the previous two turns\" means `player[i - 1] == 10 or player[i - 2] == 10`."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**improves attention**"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "hahahaha"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it wasn\\'t a easy question bro "
                    },
                    {
                        "username": "hhimanshii",
                        "content": "They should have given good example test cases. It\\'s so unclear from the given test cases."
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "2xi (((if the player hits 10 pins in any of the previous two turns))). Read this line very carefully my fellow leetcoders only the one in bracket. We need to double the current score if it satisfies this condition "
                    },
                    {
                        "username": "gouravchalotra",
                        "content": "it\\'s took me 1 hour to to understand it \\uD83E\\uDD72"
                    },
                    {
                        "username": "learn_improve",
                        "content": "Thanks for highlighting this"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "Has any one got the same problem ?\\n```\\nplayer1 = [9,7,10,7]\\nplayer2 = [10,2,4,10]\\n```\\nThe total scores should be \\n```\\nscore_1 = 40\\nscore_2 = 42\\n```\\nAccording to the condition \\n```\\nsocre_2 > score_1 = True\\n```\\nand hence the output should be \\n```\\nOutput : 2\\n```\\nThen why it is showing the output to be \\n```\\nExpected : 1\\n```"
                    },
                    {
                        "username": "iam_kmrahul",
                        "content": "score_1=9+7+10+7*2=40\\nscore_2=10+2*2+4*2+10=32\\nso player 1 is scored more \\n1 is correct output"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@kshapwari](/kshapwari) \\n\\nLets consider this test case \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\nOutput: 2\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\nHere the 2nd 10 is also multiplied with 2, that\\'s why I consider multiplication with 2 \\n\\n```\\n10 + (2 * 2) + (2 * 4) + (2 * 10)\\n= 10 + 4 + 8 + 20\\n= 42\\n```"
                    },
                    {
                        "username": "kshapwari",
                        "content": "score_2 = 32\\n10 + 2*2 + 2*4 + 10 =32"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@mainadotkim](/mainadotkim)  \\n\\nHey mainadotkim !. \\n\\nI had thought of this case but when I saw this test case in the example \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\n\\nOutput: 2\\n\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\n\\nIn this test case the second `10` was also multiplied by `2`"
                    },
                    {
                        "username": "mainadotkim",
                        "content": "Because\n\n```\nscore_1 = 40\nscore_2 = 32\n```\n\nAnd the output will be as `Expected: 1`\n\nExplanation:\n\nThe statement\n\n> 2xi if the player hit 10 pins in any of the previous two turns\n\nmeans that the last 10 scored by `player2` should not be doubled.\n\nThus, `score_2 = 10 + 2*2 + 2*4 + 10`"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Tip : Don\\'t underestimate this one "
                    },
                    {
                        "username": "NitinSingh77",
                        "content": "player1=[10,2,2,3]\\nplayer2=[3,8,4,5]\\n\\nWhy is player 1 the winner in this test case?"
                    },
                    {
                        "username": "IgorP17",
                        "content": "[@qleIIT](/qleIIT) yes, it seems here was the problem"
                    },
                    {
                        "username": "IgorP17",
                        "content": "I wrote aux method for cheking if we need doubling and test was passed)). Do not understand what was wrong)).\\nMethod:\\nboolean checkLast(int k, int[] res)\\nk == 0 -> false\\nk == 1 -> res[k - 1] == 10\\nelse -> res[k - 1] == 10 || res[k - 2] == 10"
                    },
                    {
                        "username": "qleIIT",
                        "content": "Im no expert here, since I failed this question miserably , but for your example, player1 gets 10 + 2x2 + 2x2 + 3 = 21, player2 gets 3 + 8 + 4 + 5 = 20. So player1 is the winner here."
                    },
                    {
                        "username": "qleIIT",
                        "content": "29.7% acceptance rate for an \"Easy\" contest Q1 huh?\n\n"
                    },
                    {
                        "username": "luckymaster",
                        "content": "what does this mean --> 2xi if the player hit 10 pins in any of the previous two turns. \\nSo unclear. Please try to write proper statement it is so ambiguous. I could not understand it. "
                    },
                    {
                        "username": "Finesse",
                        "content": "The score of a turn doubles, if the score of the previous turn or the turn before the previous was 10. I.e. `if player1[i - 1] == 10 || player1[i - 2] == 10 { player1[i] *= 2 }`."
                    },
                    {
                        "username": "aquaman55",
                        "content": "Its bowling man. Have you never bowled? lol"
                    }
                ]
            },
            {
                "id": 1879245,
                "content": [
                    {
                        "username": "almostmonday",
                        "content": "Be careful:\n1) previous **TWO** turns;\n2) \"in any of the previous two turns\" means `player[i - 1] == 10 or player[i - 2] == 10`."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**improves attention**"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "hahahaha"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it wasn\\'t a easy question bro "
                    },
                    {
                        "username": "hhimanshii",
                        "content": "They should have given good example test cases. It\\'s so unclear from the given test cases."
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "2xi (((if the player hits 10 pins in any of the previous two turns))). Read this line very carefully my fellow leetcoders only the one in bracket. We need to double the current score if it satisfies this condition "
                    },
                    {
                        "username": "gouravchalotra",
                        "content": "it\\'s took me 1 hour to to understand it \\uD83E\\uDD72"
                    },
                    {
                        "username": "learn_improve",
                        "content": "Thanks for highlighting this"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "Has any one got the same problem ?\\n```\\nplayer1 = [9,7,10,7]\\nplayer2 = [10,2,4,10]\\n```\\nThe total scores should be \\n```\\nscore_1 = 40\\nscore_2 = 42\\n```\\nAccording to the condition \\n```\\nsocre_2 > score_1 = True\\n```\\nand hence the output should be \\n```\\nOutput : 2\\n```\\nThen why it is showing the output to be \\n```\\nExpected : 1\\n```"
                    },
                    {
                        "username": "iam_kmrahul",
                        "content": "score_1=9+7+10+7*2=40\\nscore_2=10+2*2+4*2+10=32\\nso player 1 is scored more \\n1 is correct output"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@kshapwari](/kshapwari) \\n\\nLets consider this test case \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\nOutput: 2\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\nHere the 2nd 10 is also multiplied with 2, that\\'s why I consider multiplication with 2 \\n\\n```\\n10 + (2 * 2) + (2 * 4) + (2 * 10)\\n= 10 + 4 + 8 + 20\\n= 42\\n```"
                    },
                    {
                        "username": "kshapwari",
                        "content": "score_2 = 32\\n10 + 2*2 + 2*4 + 10 =32"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@mainadotkim](/mainadotkim)  \\n\\nHey mainadotkim !. \\n\\nI had thought of this case but when I saw this test case in the example \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\n\\nOutput: 2\\n\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\n\\nIn this test case the second `10` was also multiplied by `2`"
                    },
                    {
                        "username": "mainadotkim",
                        "content": "Because\n\n```\nscore_1 = 40\nscore_2 = 32\n```\n\nAnd the output will be as `Expected: 1`\n\nExplanation:\n\nThe statement\n\n> 2xi if the player hit 10 pins in any of the previous two turns\n\nmeans that the last 10 scored by `player2` should not be doubled.\n\nThus, `score_2 = 10 + 2*2 + 2*4 + 10`"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Tip : Don\\'t underestimate this one "
                    },
                    {
                        "username": "NitinSingh77",
                        "content": "player1=[10,2,2,3]\\nplayer2=[3,8,4,5]\\n\\nWhy is player 1 the winner in this test case?"
                    },
                    {
                        "username": "IgorP17",
                        "content": "[@qleIIT](/qleIIT) yes, it seems here was the problem"
                    },
                    {
                        "username": "IgorP17",
                        "content": "I wrote aux method for cheking if we need doubling and test was passed)). Do not understand what was wrong)).\\nMethod:\\nboolean checkLast(int k, int[] res)\\nk == 0 -> false\\nk == 1 -> res[k - 1] == 10\\nelse -> res[k - 1] == 10 || res[k - 2] == 10"
                    },
                    {
                        "username": "qleIIT",
                        "content": "Im no expert here, since I failed this question miserably , but for your example, player1 gets 10 + 2x2 + 2x2 + 3 = 21, player2 gets 3 + 8 + 4 + 5 = 20. So player1 is the winner here."
                    },
                    {
                        "username": "qleIIT",
                        "content": "29.7% acceptance rate for an \"Easy\" contest Q1 huh?\n\n"
                    },
                    {
                        "username": "luckymaster",
                        "content": "what does this mean --> 2xi if the player hit 10 pins in any of the previous two turns. \\nSo unclear. Please try to write proper statement it is so ambiguous. I could not understand it. "
                    },
                    {
                        "username": "Finesse",
                        "content": "The score of a turn doubles, if the score of the previous turn or the turn before the previous was 10. I.e. `if player1[i - 1] == 10 || player1[i - 2] == 10 { player1[i] *= 2 }`."
                    },
                    {
                        "username": "aquaman55",
                        "content": "Its bowling man. Have you never bowled? lol"
                    }
                ]
            },
            {
                "id": 1881378,
                "content": [
                    {
                        "username": "almostmonday",
                        "content": "Be careful:\n1) previous **TWO** turns;\n2) \"in any of the previous two turns\" means `player[i - 1] == 10 or player[i - 2] == 10`."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**improves attention**"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "hahahaha"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it wasn\\'t a easy question bro "
                    },
                    {
                        "username": "hhimanshii",
                        "content": "They should have given good example test cases. It\\'s so unclear from the given test cases."
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "2xi (((if the player hits 10 pins in any of the previous two turns))). Read this line very carefully my fellow leetcoders only the one in bracket. We need to double the current score if it satisfies this condition "
                    },
                    {
                        "username": "gouravchalotra",
                        "content": "it\\'s took me 1 hour to to understand it \\uD83E\\uDD72"
                    },
                    {
                        "username": "learn_improve",
                        "content": "Thanks for highlighting this"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "Has any one got the same problem ?\\n```\\nplayer1 = [9,7,10,7]\\nplayer2 = [10,2,4,10]\\n```\\nThe total scores should be \\n```\\nscore_1 = 40\\nscore_2 = 42\\n```\\nAccording to the condition \\n```\\nsocre_2 > score_1 = True\\n```\\nand hence the output should be \\n```\\nOutput : 2\\n```\\nThen why it is showing the output to be \\n```\\nExpected : 1\\n```"
                    },
                    {
                        "username": "iam_kmrahul",
                        "content": "score_1=9+7+10+7*2=40\\nscore_2=10+2*2+4*2+10=32\\nso player 1 is scored more \\n1 is correct output"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@kshapwari](/kshapwari) \\n\\nLets consider this test case \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\nOutput: 2\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\nHere the 2nd 10 is also multiplied with 2, that\\'s why I consider multiplication with 2 \\n\\n```\\n10 + (2 * 2) + (2 * 4) + (2 * 10)\\n= 10 + 4 + 8 + 20\\n= 42\\n```"
                    },
                    {
                        "username": "kshapwari",
                        "content": "score_2 = 32\\n10 + 2*2 + 2*4 + 10 =32"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@mainadotkim](/mainadotkim)  \\n\\nHey mainadotkim !. \\n\\nI had thought of this case but when I saw this test case in the example \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\n\\nOutput: 2\\n\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\n\\nIn this test case the second `10` was also multiplied by `2`"
                    },
                    {
                        "username": "mainadotkim",
                        "content": "Because\n\n```\nscore_1 = 40\nscore_2 = 32\n```\n\nAnd the output will be as `Expected: 1`\n\nExplanation:\n\nThe statement\n\n> 2xi if the player hit 10 pins in any of the previous two turns\n\nmeans that the last 10 scored by `player2` should not be doubled.\n\nThus, `score_2 = 10 + 2*2 + 2*4 + 10`"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Tip : Don\\'t underestimate this one "
                    },
                    {
                        "username": "NitinSingh77",
                        "content": "player1=[10,2,2,3]\\nplayer2=[3,8,4,5]\\n\\nWhy is player 1 the winner in this test case?"
                    },
                    {
                        "username": "IgorP17",
                        "content": "[@qleIIT](/qleIIT) yes, it seems here was the problem"
                    },
                    {
                        "username": "IgorP17",
                        "content": "I wrote aux method for cheking if we need doubling and test was passed)). Do not understand what was wrong)).\\nMethod:\\nboolean checkLast(int k, int[] res)\\nk == 0 -> false\\nk == 1 -> res[k - 1] == 10\\nelse -> res[k - 1] == 10 || res[k - 2] == 10"
                    },
                    {
                        "username": "qleIIT",
                        "content": "Im no expert here, since I failed this question miserably , but for your example, player1 gets 10 + 2x2 + 2x2 + 3 = 21, player2 gets 3 + 8 + 4 + 5 = 20. So player1 is the winner here."
                    },
                    {
                        "username": "qleIIT",
                        "content": "29.7% acceptance rate for an \"Easy\" contest Q1 huh?\n\n"
                    },
                    {
                        "username": "luckymaster",
                        "content": "what does this mean --> 2xi if the player hit 10 pins in any of the previous two turns. \\nSo unclear. Please try to write proper statement it is so ambiguous. I could not understand it. "
                    },
                    {
                        "username": "Finesse",
                        "content": "The score of a turn doubles, if the score of the previous turn or the turn before the previous was 10. I.e. `if player1[i - 1] == 10 || player1[i - 2] == 10 { player1[i] *= 2 }`."
                    },
                    {
                        "username": "aquaman55",
                        "content": "Its bowling man. Have you never bowled? lol"
                    }
                ]
            },
            {
                "id": 1877747,
                "content": [
                    {
                        "username": "almostmonday",
                        "content": "Be careful:\n1) previous **TWO** turns;\n2) \"in any of the previous two turns\" means `player[i - 1] == 10 or player[i - 2] == 10`."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**improves attention**"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "hahahaha"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it wasn\\'t a easy question bro "
                    },
                    {
                        "username": "hhimanshii",
                        "content": "They should have given good example test cases. It\\'s so unclear from the given test cases."
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "2xi (((if the player hits 10 pins in any of the previous two turns))). Read this line very carefully my fellow leetcoders only the one in bracket. We need to double the current score if it satisfies this condition "
                    },
                    {
                        "username": "gouravchalotra",
                        "content": "it\\'s took me 1 hour to to understand it \\uD83E\\uDD72"
                    },
                    {
                        "username": "learn_improve",
                        "content": "Thanks for highlighting this"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "Has any one got the same problem ?\\n```\\nplayer1 = [9,7,10,7]\\nplayer2 = [10,2,4,10]\\n```\\nThe total scores should be \\n```\\nscore_1 = 40\\nscore_2 = 42\\n```\\nAccording to the condition \\n```\\nsocre_2 > score_1 = True\\n```\\nand hence the output should be \\n```\\nOutput : 2\\n```\\nThen why it is showing the output to be \\n```\\nExpected : 1\\n```"
                    },
                    {
                        "username": "iam_kmrahul",
                        "content": "score_1=9+7+10+7*2=40\\nscore_2=10+2*2+4*2+10=32\\nso player 1 is scored more \\n1 is correct output"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@kshapwari](/kshapwari) \\n\\nLets consider this test case \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\nOutput: 2\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\nHere the 2nd 10 is also multiplied with 2, that\\'s why I consider multiplication with 2 \\n\\n```\\n10 + (2 * 2) + (2 * 4) + (2 * 10)\\n= 10 + 4 + 8 + 20\\n= 42\\n```"
                    },
                    {
                        "username": "kshapwari",
                        "content": "score_2 = 32\\n10 + 2*2 + 2*4 + 10 =32"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@mainadotkim](/mainadotkim)  \\n\\nHey mainadotkim !. \\n\\nI had thought of this case but when I saw this test case in the example \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\n\\nOutput: 2\\n\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\n\\nIn this test case the second `10` was also multiplied by `2`"
                    },
                    {
                        "username": "mainadotkim",
                        "content": "Because\n\n```\nscore_1 = 40\nscore_2 = 32\n```\n\nAnd the output will be as `Expected: 1`\n\nExplanation:\n\nThe statement\n\n> 2xi if the player hit 10 pins in any of the previous two turns\n\nmeans that the last 10 scored by `player2` should not be doubled.\n\nThus, `score_2 = 10 + 2*2 + 2*4 + 10`"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Tip : Don\\'t underestimate this one "
                    },
                    {
                        "username": "NitinSingh77",
                        "content": "player1=[10,2,2,3]\\nplayer2=[3,8,4,5]\\n\\nWhy is player 1 the winner in this test case?"
                    },
                    {
                        "username": "IgorP17",
                        "content": "[@qleIIT](/qleIIT) yes, it seems here was the problem"
                    },
                    {
                        "username": "IgorP17",
                        "content": "I wrote aux method for cheking if we need doubling and test was passed)). Do not understand what was wrong)).\\nMethod:\\nboolean checkLast(int k, int[] res)\\nk == 0 -> false\\nk == 1 -> res[k - 1] == 10\\nelse -> res[k - 1] == 10 || res[k - 2] == 10"
                    },
                    {
                        "username": "qleIIT",
                        "content": "Im no expert here, since I failed this question miserably , but for your example, player1 gets 10 + 2x2 + 2x2 + 3 = 21, player2 gets 3 + 8 + 4 + 5 = 20. So player1 is the winner here."
                    },
                    {
                        "username": "qleIIT",
                        "content": "29.7% acceptance rate for an \"Easy\" contest Q1 huh?\n\n"
                    },
                    {
                        "username": "luckymaster",
                        "content": "what does this mean --> 2xi if the player hit 10 pins in any of the previous two turns. \\nSo unclear. Please try to write proper statement it is so ambiguous. I could not understand it. "
                    },
                    {
                        "username": "Finesse",
                        "content": "The score of a turn doubles, if the score of the previous turn or the turn before the previous was 10. I.e. `if player1[i - 1] == 10 || player1[i - 2] == 10 { player1[i] *= 2 }`."
                    },
                    {
                        "username": "aquaman55",
                        "content": "Its bowling man. Have you never bowled? lol"
                    }
                ]
            },
            {
                "id": 1877717,
                "content": [
                    {
                        "username": "almostmonday",
                        "content": "Be careful:\n1) previous **TWO** turns;\n2) \"in any of the previous two turns\" means `player[i - 1] == 10 or player[i - 2] == 10`."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**improves attention**"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "hahahaha"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it wasn\\'t a easy question bro "
                    },
                    {
                        "username": "hhimanshii",
                        "content": "They should have given good example test cases. It\\'s so unclear from the given test cases."
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "2xi (((if the player hits 10 pins in any of the previous two turns))). Read this line very carefully my fellow leetcoders only the one in bracket. We need to double the current score if it satisfies this condition "
                    },
                    {
                        "username": "gouravchalotra",
                        "content": "it\\'s took me 1 hour to to understand it \\uD83E\\uDD72"
                    },
                    {
                        "username": "learn_improve",
                        "content": "Thanks for highlighting this"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "Has any one got the same problem ?\\n```\\nplayer1 = [9,7,10,7]\\nplayer2 = [10,2,4,10]\\n```\\nThe total scores should be \\n```\\nscore_1 = 40\\nscore_2 = 42\\n```\\nAccording to the condition \\n```\\nsocre_2 > score_1 = True\\n```\\nand hence the output should be \\n```\\nOutput : 2\\n```\\nThen why it is showing the output to be \\n```\\nExpected : 1\\n```"
                    },
                    {
                        "username": "iam_kmrahul",
                        "content": "score_1=9+7+10+7*2=40\\nscore_2=10+2*2+4*2+10=32\\nso player 1 is scored more \\n1 is correct output"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@kshapwari](/kshapwari) \\n\\nLets consider this test case \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\nOutput: 2\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\nHere the 2nd 10 is also multiplied with 2, that\\'s why I consider multiplication with 2 \\n\\n```\\n10 + (2 * 2) + (2 * 4) + (2 * 10)\\n= 10 + 4 + 8 + 20\\n= 42\\n```"
                    },
                    {
                        "username": "kshapwari",
                        "content": "score_2 = 32\\n10 + 2*2 + 2*4 + 10 =32"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@mainadotkim](/mainadotkim)  \\n\\nHey mainadotkim !. \\n\\nI had thought of this case but when I saw this test case in the example \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\n\\nOutput: 2\\n\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\n\\nIn this test case the second `10` was also multiplied by `2`"
                    },
                    {
                        "username": "mainadotkim",
                        "content": "Because\n\n```\nscore_1 = 40\nscore_2 = 32\n```\n\nAnd the output will be as `Expected: 1`\n\nExplanation:\n\nThe statement\n\n> 2xi if the player hit 10 pins in any of the previous two turns\n\nmeans that the last 10 scored by `player2` should not be doubled.\n\nThus, `score_2 = 10 + 2*2 + 2*4 + 10`"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Tip : Don\\'t underestimate this one "
                    },
                    {
                        "username": "NitinSingh77",
                        "content": "player1=[10,2,2,3]\\nplayer2=[3,8,4,5]\\n\\nWhy is player 1 the winner in this test case?"
                    },
                    {
                        "username": "IgorP17",
                        "content": "[@qleIIT](/qleIIT) yes, it seems here was the problem"
                    },
                    {
                        "username": "IgorP17",
                        "content": "I wrote aux method for cheking if we need doubling and test was passed)). Do not understand what was wrong)).\\nMethod:\\nboolean checkLast(int k, int[] res)\\nk == 0 -> false\\nk == 1 -> res[k - 1] == 10\\nelse -> res[k - 1] == 10 || res[k - 2] == 10"
                    },
                    {
                        "username": "qleIIT",
                        "content": "Im no expert here, since I failed this question miserably , but for your example, player1 gets 10 + 2x2 + 2x2 + 3 = 21, player2 gets 3 + 8 + 4 + 5 = 20. So player1 is the winner here."
                    },
                    {
                        "username": "qleIIT",
                        "content": "29.7% acceptance rate for an \"Easy\" contest Q1 huh?\n\n"
                    },
                    {
                        "username": "luckymaster",
                        "content": "what does this mean --> 2xi if the player hit 10 pins in any of the previous two turns. \\nSo unclear. Please try to write proper statement it is so ambiguous. I could not understand it. "
                    },
                    {
                        "username": "Finesse",
                        "content": "The score of a turn doubles, if the score of the previous turn or the turn before the previous was 10. I.e. `if player1[i - 1] == 10 || player1[i - 2] == 10 { player1[i] *= 2 }`."
                    },
                    {
                        "username": "aquaman55",
                        "content": "Its bowling man. Have you never bowled? lol"
                    }
                ]
            },
            {
                "id": 1878349,
                "content": [
                    {
                        "username": "almostmonday",
                        "content": "Be careful:\n1) previous **TWO** turns;\n2) \"in any of the previous two turns\" means `player[i - 1] == 10 or player[i - 2] == 10`."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**improves attention**"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "hahahaha"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it wasn\\'t a easy question bro "
                    },
                    {
                        "username": "hhimanshii",
                        "content": "They should have given good example test cases. It\\'s so unclear from the given test cases."
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "2xi (((if the player hits 10 pins in any of the previous two turns))). Read this line very carefully my fellow leetcoders only the one in bracket. We need to double the current score if it satisfies this condition "
                    },
                    {
                        "username": "gouravchalotra",
                        "content": "it\\'s took me 1 hour to to understand it \\uD83E\\uDD72"
                    },
                    {
                        "username": "learn_improve",
                        "content": "Thanks for highlighting this"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "Has any one got the same problem ?\\n```\\nplayer1 = [9,7,10,7]\\nplayer2 = [10,2,4,10]\\n```\\nThe total scores should be \\n```\\nscore_1 = 40\\nscore_2 = 42\\n```\\nAccording to the condition \\n```\\nsocre_2 > score_1 = True\\n```\\nand hence the output should be \\n```\\nOutput : 2\\n```\\nThen why it is showing the output to be \\n```\\nExpected : 1\\n```"
                    },
                    {
                        "username": "iam_kmrahul",
                        "content": "score_1=9+7+10+7*2=40\\nscore_2=10+2*2+4*2+10=32\\nso player 1 is scored more \\n1 is correct output"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@kshapwari](/kshapwari) \\n\\nLets consider this test case \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\nOutput: 2\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\nHere the 2nd 10 is also multiplied with 2, that\\'s why I consider multiplication with 2 \\n\\n```\\n10 + (2 * 2) + (2 * 4) + (2 * 10)\\n= 10 + 4 + 8 + 20\\n= 42\\n```"
                    },
                    {
                        "username": "kshapwari",
                        "content": "score_2 = 32\\n10 + 2*2 + 2*4 + 10 =32"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@mainadotkim](/mainadotkim)  \\n\\nHey mainadotkim !. \\n\\nI had thought of this case but when I saw this test case in the example \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\n\\nOutput: 2\\n\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\n\\nIn this test case the second `10` was also multiplied by `2`"
                    },
                    {
                        "username": "mainadotkim",
                        "content": "Because\n\n```\nscore_1 = 40\nscore_2 = 32\n```\n\nAnd the output will be as `Expected: 1`\n\nExplanation:\n\nThe statement\n\n> 2xi if the player hit 10 pins in any of the previous two turns\n\nmeans that the last 10 scored by `player2` should not be doubled.\n\nThus, `score_2 = 10 + 2*2 + 2*4 + 10`"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Tip : Don\\'t underestimate this one "
                    },
                    {
                        "username": "NitinSingh77",
                        "content": "player1=[10,2,2,3]\\nplayer2=[3,8,4,5]\\n\\nWhy is player 1 the winner in this test case?"
                    },
                    {
                        "username": "IgorP17",
                        "content": "[@qleIIT](/qleIIT) yes, it seems here was the problem"
                    },
                    {
                        "username": "IgorP17",
                        "content": "I wrote aux method for cheking if we need doubling and test was passed)). Do not understand what was wrong)).\\nMethod:\\nboolean checkLast(int k, int[] res)\\nk == 0 -> false\\nk == 1 -> res[k - 1] == 10\\nelse -> res[k - 1] == 10 || res[k - 2] == 10"
                    },
                    {
                        "username": "qleIIT",
                        "content": "Im no expert here, since I failed this question miserably , but for your example, player1 gets 10 + 2x2 + 2x2 + 3 = 21, player2 gets 3 + 8 + 4 + 5 = 20. So player1 is the winner here."
                    },
                    {
                        "username": "qleIIT",
                        "content": "29.7% acceptance rate for an \"Easy\" contest Q1 huh?\n\n"
                    },
                    {
                        "username": "luckymaster",
                        "content": "what does this mean --> 2xi if the player hit 10 pins in any of the previous two turns. \\nSo unclear. Please try to write proper statement it is so ambiguous. I could not understand it. "
                    },
                    {
                        "username": "Finesse",
                        "content": "The score of a turn doubles, if the score of the previous turn or the turn before the previous was 10. I.e. `if player1[i - 1] == 10 || player1[i - 2] == 10 { player1[i] *= 2 }`."
                    },
                    {
                        "username": "aquaman55",
                        "content": "Its bowling man. Have you never bowled? lol"
                    }
                ]
            },
            {
                "id": 1879196,
                "content": [
                    {
                        "username": "almostmonday",
                        "content": "Be careful:\n1) previous **TWO** turns;\n2) \"in any of the previous two turns\" means `player[i - 1] == 10 or player[i - 2] == 10`."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**improves attention**"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "hahahaha"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it wasn\\'t a easy question bro "
                    },
                    {
                        "username": "hhimanshii",
                        "content": "They should have given good example test cases. It\\'s so unclear from the given test cases."
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "2xi (((if the player hits 10 pins in any of the previous two turns))). Read this line very carefully my fellow leetcoders only the one in bracket. We need to double the current score if it satisfies this condition "
                    },
                    {
                        "username": "gouravchalotra",
                        "content": "it\\'s took me 1 hour to to understand it \\uD83E\\uDD72"
                    },
                    {
                        "username": "learn_improve",
                        "content": "Thanks for highlighting this"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "Has any one got the same problem ?\\n```\\nplayer1 = [9,7,10,7]\\nplayer2 = [10,2,4,10]\\n```\\nThe total scores should be \\n```\\nscore_1 = 40\\nscore_2 = 42\\n```\\nAccording to the condition \\n```\\nsocre_2 > score_1 = True\\n```\\nand hence the output should be \\n```\\nOutput : 2\\n```\\nThen why it is showing the output to be \\n```\\nExpected : 1\\n```"
                    },
                    {
                        "username": "iam_kmrahul",
                        "content": "score_1=9+7+10+7*2=40\\nscore_2=10+2*2+4*2+10=32\\nso player 1 is scored more \\n1 is correct output"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@kshapwari](/kshapwari) \\n\\nLets consider this test case \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\nOutput: 2\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\nHere the 2nd 10 is also multiplied with 2, that\\'s why I consider multiplication with 2 \\n\\n```\\n10 + (2 * 2) + (2 * 4) + (2 * 10)\\n= 10 + 4 + 8 + 20\\n= 42\\n```"
                    },
                    {
                        "username": "kshapwari",
                        "content": "score_2 = 32\\n10 + 2*2 + 2*4 + 10 =32"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@mainadotkim](/mainadotkim)  \\n\\nHey mainadotkim !. \\n\\nI had thought of this case but when I saw this test case in the example \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\n\\nOutput: 2\\n\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\n\\nIn this test case the second `10` was also multiplied by `2`"
                    },
                    {
                        "username": "mainadotkim",
                        "content": "Because\n\n```\nscore_1 = 40\nscore_2 = 32\n```\n\nAnd the output will be as `Expected: 1`\n\nExplanation:\n\nThe statement\n\n> 2xi if the player hit 10 pins in any of the previous two turns\n\nmeans that the last 10 scored by `player2` should not be doubled.\n\nThus, `score_2 = 10 + 2*2 + 2*4 + 10`"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Tip : Don\\'t underestimate this one "
                    },
                    {
                        "username": "NitinSingh77",
                        "content": "player1=[10,2,2,3]\\nplayer2=[3,8,4,5]\\n\\nWhy is player 1 the winner in this test case?"
                    },
                    {
                        "username": "IgorP17",
                        "content": "[@qleIIT](/qleIIT) yes, it seems here was the problem"
                    },
                    {
                        "username": "IgorP17",
                        "content": "I wrote aux method for cheking if we need doubling and test was passed)). Do not understand what was wrong)).\\nMethod:\\nboolean checkLast(int k, int[] res)\\nk == 0 -> false\\nk == 1 -> res[k - 1] == 10\\nelse -> res[k - 1] == 10 || res[k - 2] == 10"
                    },
                    {
                        "username": "qleIIT",
                        "content": "Im no expert here, since I failed this question miserably , but for your example, player1 gets 10 + 2x2 + 2x2 + 3 = 21, player2 gets 3 + 8 + 4 + 5 = 20. So player1 is the winner here."
                    },
                    {
                        "username": "qleIIT",
                        "content": "29.7% acceptance rate for an \"Easy\" contest Q1 huh?\n\n"
                    },
                    {
                        "username": "luckymaster",
                        "content": "what does this mean --> 2xi if the player hit 10 pins in any of the previous two turns. \\nSo unclear. Please try to write proper statement it is so ambiguous. I could not understand it. "
                    },
                    {
                        "username": "Finesse",
                        "content": "The score of a turn doubles, if the score of the previous turn or the turn before the previous was 10. I.e. `if player1[i - 1] == 10 || player1[i - 2] == 10 { player1[i] *= 2 }`."
                    },
                    {
                        "username": "aquaman55",
                        "content": "Its bowling man. Have you never bowled? lol"
                    }
                ]
            },
            {
                "id": 1878218,
                "content": [
                    {
                        "username": "almostmonday",
                        "content": "Be careful:\n1) previous **TWO** turns;\n2) \"in any of the previous two turns\" means `player[i - 1] == 10 or player[i - 2] == 10`."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**improves attention**"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "hahahaha"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it wasn\\'t a easy question bro "
                    },
                    {
                        "username": "hhimanshii",
                        "content": "They should have given good example test cases. It\\'s so unclear from the given test cases."
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "2xi (((if the player hits 10 pins in any of the previous two turns))). Read this line very carefully my fellow leetcoders only the one in bracket. We need to double the current score if it satisfies this condition "
                    },
                    {
                        "username": "gouravchalotra",
                        "content": "it\\'s took me 1 hour to to understand it \\uD83E\\uDD72"
                    },
                    {
                        "username": "learn_improve",
                        "content": "Thanks for highlighting this"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "Has any one got the same problem ?\\n```\\nplayer1 = [9,7,10,7]\\nplayer2 = [10,2,4,10]\\n```\\nThe total scores should be \\n```\\nscore_1 = 40\\nscore_2 = 42\\n```\\nAccording to the condition \\n```\\nsocre_2 > score_1 = True\\n```\\nand hence the output should be \\n```\\nOutput : 2\\n```\\nThen why it is showing the output to be \\n```\\nExpected : 1\\n```"
                    },
                    {
                        "username": "iam_kmrahul",
                        "content": "score_1=9+7+10+7*2=40\\nscore_2=10+2*2+4*2+10=32\\nso player 1 is scored more \\n1 is correct output"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@kshapwari](/kshapwari) \\n\\nLets consider this test case \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\nOutput: 2\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\nHere the 2nd 10 is also multiplied with 2, that\\'s why I consider multiplication with 2 \\n\\n```\\n10 + (2 * 2) + (2 * 4) + (2 * 10)\\n= 10 + 4 + 8 + 20\\n= 42\\n```"
                    },
                    {
                        "username": "kshapwari",
                        "content": "score_2 = 32\\n10 + 2*2 + 2*4 + 10 =32"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@mainadotkim](/mainadotkim)  \\n\\nHey mainadotkim !. \\n\\nI had thought of this case but when I saw this test case in the example \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\n\\nOutput: 2\\n\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\n\\nIn this test case the second `10` was also multiplied by `2`"
                    },
                    {
                        "username": "mainadotkim",
                        "content": "Because\n\n```\nscore_1 = 40\nscore_2 = 32\n```\n\nAnd the output will be as `Expected: 1`\n\nExplanation:\n\nThe statement\n\n> 2xi if the player hit 10 pins in any of the previous two turns\n\nmeans that the last 10 scored by `player2` should not be doubled.\n\nThus, `score_2 = 10 + 2*2 + 2*4 + 10`"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Tip : Don\\'t underestimate this one "
                    },
                    {
                        "username": "NitinSingh77",
                        "content": "player1=[10,2,2,3]\\nplayer2=[3,8,4,5]\\n\\nWhy is player 1 the winner in this test case?"
                    },
                    {
                        "username": "IgorP17",
                        "content": "[@qleIIT](/qleIIT) yes, it seems here was the problem"
                    },
                    {
                        "username": "IgorP17",
                        "content": "I wrote aux method for cheking if we need doubling and test was passed)). Do not understand what was wrong)).\\nMethod:\\nboolean checkLast(int k, int[] res)\\nk == 0 -> false\\nk == 1 -> res[k - 1] == 10\\nelse -> res[k - 1] == 10 || res[k - 2] == 10"
                    },
                    {
                        "username": "qleIIT",
                        "content": "Im no expert here, since I failed this question miserably , but for your example, player1 gets 10 + 2x2 + 2x2 + 3 = 21, player2 gets 3 + 8 + 4 + 5 = 20. So player1 is the winner here."
                    },
                    {
                        "username": "qleIIT",
                        "content": "29.7% acceptance rate for an \"Easy\" contest Q1 huh?\n\n"
                    },
                    {
                        "username": "luckymaster",
                        "content": "what does this mean --> 2xi if the player hit 10 pins in any of the previous two turns. \\nSo unclear. Please try to write proper statement it is so ambiguous. I could not understand it. "
                    },
                    {
                        "username": "Finesse",
                        "content": "The score of a turn doubles, if the score of the previous turn or the turn before the previous was 10. I.e. `if player1[i - 1] == 10 || player1[i - 2] == 10 { player1[i] *= 2 }`."
                    },
                    {
                        "username": "aquaman55",
                        "content": "Its bowling man. Have you never bowled? lol"
                    }
                ]
            },
            {
                "id": 1877921,
                "content": [
                    {
                        "username": "almostmonday",
                        "content": "Be careful:\n1) previous **TWO** turns;\n2) \"in any of the previous two turns\" means `player[i - 1] == 10 or player[i - 2] == 10`."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**improves attention**"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "hahahaha"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it wasn\\'t a easy question bro "
                    },
                    {
                        "username": "hhimanshii",
                        "content": "They should have given good example test cases. It\\'s so unclear from the given test cases."
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "2xi (((if the player hits 10 pins in any of the previous two turns))). Read this line very carefully my fellow leetcoders only the one in bracket. We need to double the current score if it satisfies this condition "
                    },
                    {
                        "username": "gouravchalotra",
                        "content": "it\\'s took me 1 hour to to understand it \\uD83E\\uDD72"
                    },
                    {
                        "username": "learn_improve",
                        "content": "Thanks for highlighting this"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "Has any one got the same problem ?\\n```\\nplayer1 = [9,7,10,7]\\nplayer2 = [10,2,4,10]\\n```\\nThe total scores should be \\n```\\nscore_1 = 40\\nscore_2 = 42\\n```\\nAccording to the condition \\n```\\nsocre_2 > score_1 = True\\n```\\nand hence the output should be \\n```\\nOutput : 2\\n```\\nThen why it is showing the output to be \\n```\\nExpected : 1\\n```"
                    },
                    {
                        "username": "iam_kmrahul",
                        "content": "score_1=9+7+10+7*2=40\\nscore_2=10+2*2+4*2+10=32\\nso player 1 is scored more \\n1 is correct output"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@kshapwari](/kshapwari) \\n\\nLets consider this test case \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\nOutput: 2\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\nHere the 2nd 10 is also multiplied with 2, that\\'s why I consider multiplication with 2 \\n\\n```\\n10 + (2 * 2) + (2 * 4) + (2 * 10)\\n= 10 + 4 + 8 + 20\\n= 42\\n```"
                    },
                    {
                        "username": "kshapwari",
                        "content": "score_2 = 32\\n10 + 2*2 + 2*4 + 10 =32"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@mainadotkim](/mainadotkim)  \\n\\nHey mainadotkim !. \\n\\nI had thought of this case but when I saw this test case in the example \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\n\\nOutput: 2\\n\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\n\\nIn this test case the second `10` was also multiplied by `2`"
                    },
                    {
                        "username": "mainadotkim",
                        "content": "Because\n\n```\nscore_1 = 40\nscore_2 = 32\n```\n\nAnd the output will be as `Expected: 1`\n\nExplanation:\n\nThe statement\n\n> 2xi if the player hit 10 pins in any of the previous two turns\n\nmeans that the last 10 scored by `player2` should not be doubled.\n\nThus, `score_2 = 10 + 2*2 + 2*4 + 10`"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Tip : Don\\'t underestimate this one "
                    },
                    {
                        "username": "NitinSingh77",
                        "content": "player1=[10,2,2,3]\\nplayer2=[3,8,4,5]\\n\\nWhy is player 1 the winner in this test case?"
                    },
                    {
                        "username": "IgorP17",
                        "content": "[@qleIIT](/qleIIT) yes, it seems here was the problem"
                    },
                    {
                        "username": "IgorP17",
                        "content": "I wrote aux method for cheking if we need doubling and test was passed)). Do not understand what was wrong)).\\nMethod:\\nboolean checkLast(int k, int[] res)\\nk == 0 -> false\\nk == 1 -> res[k - 1] == 10\\nelse -> res[k - 1] == 10 || res[k - 2] == 10"
                    },
                    {
                        "username": "qleIIT",
                        "content": "Im no expert here, since I failed this question miserably , but for your example, player1 gets 10 + 2x2 + 2x2 + 3 = 21, player2 gets 3 + 8 + 4 + 5 = 20. So player1 is the winner here."
                    },
                    {
                        "username": "qleIIT",
                        "content": "29.7% acceptance rate for an \"Easy\" contest Q1 huh?\n\n"
                    },
                    {
                        "username": "luckymaster",
                        "content": "what does this mean --> 2xi if the player hit 10 pins in any of the previous two turns. \\nSo unclear. Please try to write proper statement it is so ambiguous. I could not understand it. "
                    },
                    {
                        "username": "Finesse",
                        "content": "The score of a turn doubles, if the score of the previous turn or the turn before the previous was 10. I.e. `if player1[i - 1] == 10 || player1[i - 2] == 10 { player1[i] *= 2 }`."
                    },
                    {
                        "username": "aquaman55",
                        "content": "Its bowling man. Have you never bowled? lol"
                    }
                ]
            },
            {
                "id": 1877795,
                "content": [
                    {
                        "username": "almostmonday",
                        "content": "Be careful:\n1) previous **TWO** turns;\n2) \"in any of the previous two turns\" means `player[i - 1] == 10 or player[i - 2] == 10`."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**improves attention**"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "hahahaha"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it wasn\\'t a easy question bro "
                    },
                    {
                        "username": "hhimanshii",
                        "content": "They should have given good example test cases. It\\'s so unclear from the given test cases."
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "2xi (((if the player hits 10 pins in any of the previous two turns))). Read this line very carefully my fellow leetcoders only the one in bracket. We need to double the current score if it satisfies this condition "
                    },
                    {
                        "username": "gouravchalotra",
                        "content": "it\\'s took me 1 hour to to understand it \\uD83E\\uDD72"
                    },
                    {
                        "username": "learn_improve",
                        "content": "Thanks for highlighting this"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "Has any one got the same problem ?\\n```\\nplayer1 = [9,7,10,7]\\nplayer2 = [10,2,4,10]\\n```\\nThe total scores should be \\n```\\nscore_1 = 40\\nscore_2 = 42\\n```\\nAccording to the condition \\n```\\nsocre_2 > score_1 = True\\n```\\nand hence the output should be \\n```\\nOutput : 2\\n```\\nThen why it is showing the output to be \\n```\\nExpected : 1\\n```"
                    },
                    {
                        "username": "iam_kmrahul",
                        "content": "score_1=9+7+10+7*2=40\\nscore_2=10+2*2+4*2+10=32\\nso player 1 is scored more \\n1 is correct output"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@kshapwari](/kshapwari) \\n\\nLets consider this test case \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\nOutput: 2\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\nHere the 2nd 10 is also multiplied with 2, that\\'s why I consider multiplication with 2 \\n\\n```\\n10 + (2 * 2) + (2 * 4) + (2 * 10)\\n= 10 + 4 + 8 + 20\\n= 42\\n```"
                    },
                    {
                        "username": "kshapwari",
                        "content": "score_2 = 32\\n10 + 2*2 + 2*4 + 10 =32"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@mainadotkim](/mainadotkim)  \\n\\nHey mainadotkim !. \\n\\nI had thought of this case but when I saw this test case in the example \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\n\\nOutput: 2\\n\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\n\\nIn this test case the second `10` was also multiplied by `2`"
                    },
                    {
                        "username": "mainadotkim",
                        "content": "Because\n\n```\nscore_1 = 40\nscore_2 = 32\n```\n\nAnd the output will be as `Expected: 1`\n\nExplanation:\n\nThe statement\n\n> 2xi if the player hit 10 pins in any of the previous two turns\n\nmeans that the last 10 scored by `player2` should not be doubled.\n\nThus, `score_2 = 10 + 2*2 + 2*4 + 10`"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Tip : Don\\'t underestimate this one "
                    },
                    {
                        "username": "NitinSingh77",
                        "content": "player1=[10,2,2,3]\\nplayer2=[3,8,4,5]\\n\\nWhy is player 1 the winner in this test case?"
                    },
                    {
                        "username": "IgorP17",
                        "content": "[@qleIIT](/qleIIT) yes, it seems here was the problem"
                    },
                    {
                        "username": "IgorP17",
                        "content": "I wrote aux method for cheking if we need doubling and test was passed)). Do not understand what was wrong)).\\nMethod:\\nboolean checkLast(int k, int[] res)\\nk == 0 -> false\\nk == 1 -> res[k - 1] == 10\\nelse -> res[k - 1] == 10 || res[k - 2] == 10"
                    },
                    {
                        "username": "qleIIT",
                        "content": "Im no expert here, since I failed this question miserably , but for your example, player1 gets 10 + 2x2 + 2x2 + 3 = 21, player2 gets 3 + 8 + 4 + 5 = 20. So player1 is the winner here."
                    },
                    {
                        "username": "qleIIT",
                        "content": "29.7% acceptance rate for an \"Easy\" contest Q1 huh?\n\n"
                    },
                    {
                        "username": "luckymaster",
                        "content": "what does this mean --> 2xi if the player hit 10 pins in any of the previous two turns. \\nSo unclear. Please try to write proper statement it is so ambiguous. I could not understand it. "
                    },
                    {
                        "username": "Finesse",
                        "content": "The score of a turn doubles, if the score of the previous turn or the turn before the previous was 10. I.e. `if player1[i - 1] == 10 || player1[i - 2] == 10 { player1[i] *= 2 }`."
                    },
                    {
                        "username": "aquaman55",
                        "content": "Its bowling man. Have you never bowled? lol"
                    }
                ]
            },
            {
                "id": 1943431,
                "content": [
                    {
                        "username": "almostmonday",
                        "content": "Be careful:\n1) previous **TWO** turns;\n2) \"in any of the previous two turns\" means `player[i - 1] == 10 or player[i - 2] == 10`."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**improves attention**"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "hahahaha"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it wasn\\'t a easy question bro "
                    },
                    {
                        "username": "hhimanshii",
                        "content": "They should have given good example test cases. It\\'s so unclear from the given test cases."
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "2xi (((if the player hits 10 pins in any of the previous two turns))). Read this line very carefully my fellow leetcoders only the one in bracket. We need to double the current score if it satisfies this condition "
                    },
                    {
                        "username": "gouravchalotra",
                        "content": "it\\'s took me 1 hour to to understand it \\uD83E\\uDD72"
                    },
                    {
                        "username": "learn_improve",
                        "content": "Thanks for highlighting this"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "Has any one got the same problem ?\\n```\\nplayer1 = [9,7,10,7]\\nplayer2 = [10,2,4,10]\\n```\\nThe total scores should be \\n```\\nscore_1 = 40\\nscore_2 = 42\\n```\\nAccording to the condition \\n```\\nsocre_2 > score_1 = True\\n```\\nand hence the output should be \\n```\\nOutput : 2\\n```\\nThen why it is showing the output to be \\n```\\nExpected : 1\\n```"
                    },
                    {
                        "username": "iam_kmrahul",
                        "content": "score_1=9+7+10+7*2=40\\nscore_2=10+2*2+4*2+10=32\\nso player 1 is scored more \\n1 is correct output"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@kshapwari](/kshapwari) \\n\\nLets consider this test case \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\nOutput: 2\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\nHere the 2nd 10 is also multiplied with 2, that\\'s why I consider multiplication with 2 \\n\\n```\\n10 + (2 * 2) + (2 * 4) + (2 * 10)\\n= 10 + 4 + 8 + 20\\n= 42\\n```"
                    },
                    {
                        "username": "kshapwari",
                        "content": "score_2 = 32\\n10 + 2*2 + 2*4 + 10 =32"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@mainadotkim](/mainadotkim)  \\n\\nHey mainadotkim !. \\n\\nI had thought of this case but when I saw this test case in the example \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\n\\nOutput: 2\\n\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\n\\nIn this test case the second `10` was also multiplied by `2`"
                    },
                    {
                        "username": "mainadotkim",
                        "content": "Because\n\n```\nscore_1 = 40\nscore_2 = 32\n```\n\nAnd the output will be as `Expected: 1`\n\nExplanation:\n\nThe statement\n\n> 2xi if the player hit 10 pins in any of the previous two turns\n\nmeans that the last 10 scored by `player2` should not be doubled.\n\nThus, `score_2 = 10 + 2*2 + 2*4 + 10`"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Tip : Don\\'t underestimate this one "
                    },
                    {
                        "username": "NitinSingh77",
                        "content": "player1=[10,2,2,3]\\nplayer2=[3,8,4,5]\\n\\nWhy is player 1 the winner in this test case?"
                    },
                    {
                        "username": "IgorP17",
                        "content": "[@qleIIT](/qleIIT) yes, it seems here was the problem"
                    },
                    {
                        "username": "IgorP17",
                        "content": "I wrote aux method for cheking if we need doubling and test was passed)). Do not understand what was wrong)).\\nMethod:\\nboolean checkLast(int k, int[] res)\\nk == 0 -> false\\nk == 1 -> res[k - 1] == 10\\nelse -> res[k - 1] == 10 || res[k - 2] == 10"
                    },
                    {
                        "username": "qleIIT",
                        "content": "Im no expert here, since I failed this question miserably , but for your example, player1 gets 10 + 2x2 + 2x2 + 3 = 21, player2 gets 3 + 8 + 4 + 5 = 20. So player1 is the winner here."
                    },
                    {
                        "username": "qleIIT",
                        "content": "29.7% acceptance rate for an \"Easy\" contest Q1 huh?\n\n"
                    },
                    {
                        "username": "luckymaster",
                        "content": "what does this mean --> 2xi if the player hit 10 pins in any of the previous two turns. \\nSo unclear. Please try to write proper statement it is so ambiguous. I could not understand it. "
                    },
                    {
                        "username": "Finesse",
                        "content": "The score of a turn doubles, if the score of the previous turn or the turn before the previous was 10. I.e. `if player1[i - 1] == 10 || player1[i - 2] == 10 { player1[i] *= 2 }`."
                    },
                    {
                        "username": "aquaman55",
                        "content": "Its bowling man. Have you never bowled? lol"
                    }
                ]
            },
            {
                "id": 1879245,
                "content": [
                    {
                        "username": "almostmonday",
                        "content": "Be careful:\n1) previous **TWO** turns;\n2) \"in any of the previous two turns\" means `player[i - 1] == 10 or player[i - 2] == 10`."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**improves attention**"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "hahahaha"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it wasn\\'t a easy question bro "
                    },
                    {
                        "username": "hhimanshii",
                        "content": "They should have given good example test cases. It\\'s so unclear from the given test cases."
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "2xi (((if the player hits 10 pins in any of the previous two turns))). Read this line very carefully my fellow leetcoders only the one in bracket. We need to double the current score if it satisfies this condition "
                    },
                    {
                        "username": "gouravchalotra",
                        "content": "it\\'s took me 1 hour to to understand it \\uD83E\\uDD72"
                    },
                    {
                        "username": "learn_improve",
                        "content": "Thanks for highlighting this"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "Has any one got the same problem ?\\n```\\nplayer1 = [9,7,10,7]\\nplayer2 = [10,2,4,10]\\n```\\nThe total scores should be \\n```\\nscore_1 = 40\\nscore_2 = 42\\n```\\nAccording to the condition \\n```\\nsocre_2 > score_1 = True\\n```\\nand hence the output should be \\n```\\nOutput : 2\\n```\\nThen why it is showing the output to be \\n```\\nExpected : 1\\n```"
                    },
                    {
                        "username": "iam_kmrahul",
                        "content": "score_1=9+7+10+7*2=40\\nscore_2=10+2*2+4*2+10=32\\nso player 1 is scored more \\n1 is correct output"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@kshapwari](/kshapwari) \\n\\nLets consider this test case \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\nOutput: 2\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\nHere the 2nd 10 is also multiplied with 2, that\\'s why I consider multiplication with 2 \\n\\n```\\n10 + (2 * 2) + (2 * 4) + (2 * 10)\\n= 10 + 4 + 8 + 20\\n= 42\\n```"
                    },
                    {
                        "username": "kshapwari",
                        "content": "score_2 = 32\\n10 + 2*2 + 2*4 + 10 =32"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@mainadotkim](/mainadotkim)  \\n\\nHey mainadotkim !. \\n\\nI had thought of this case but when I saw this test case in the example \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\n\\nOutput: 2\\n\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\n\\nIn this test case the second `10` was also multiplied by `2`"
                    },
                    {
                        "username": "mainadotkim",
                        "content": "Because\n\n```\nscore_1 = 40\nscore_2 = 32\n```\n\nAnd the output will be as `Expected: 1`\n\nExplanation:\n\nThe statement\n\n> 2xi if the player hit 10 pins in any of the previous two turns\n\nmeans that the last 10 scored by `player2` should not be doubled.\n\nThus, `score_2 = 10 + 2*2 + 2*4 + 10`"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Tip : Don\\'t underestimate this one "
                    },
                    {
                        "username": "NitinSingh77",
                        "content": "player1=[10,2,2,3]\\nplayer2=[3,8,4,5]\\n\\nWhy is player 1 the winner in this test case?"
                    },
                    {
                        "username": "IgorP17",
                        "content": "[@qleIIT](/qleIIT) yes, it seems here was the problem"
                    },
                    {
                        "username": "IgorP17",
                        "content": "I wrote aux method for cheking if we need doubling and test was passed)). Do not understand what was wrong)).\\nMethod:\\nboolean checkLast(int k, int[] res)\\nk == 0 -> false\\nk == 1 -> res[k - 1] == 10\\nelse -> res[k - 1] == 10 || res[k - 2] == 10"
                    },
                    {
                        "username": "qleIIT",
                        "content": "Im no expert here, since I failed this question miserably , but for your example, player1 gets 10 + 2x2 + 2x2 + 3 = 21, player2 gets 3 + 8 + 4 + 5 = 20. So player1 is the winner here."
                    },
                    {
                        "username": "qleIIT",
                        "content": "29.7% acceptance rate for an \"Easy\" contest Q1 huh?\n\n"
                    },
                    {
                        "username": "luckymaster",
                        "content": "what does this mean --> 2xi if the player hit 10 pins in any of the previous two turns. \\nSo unclear. Please try to write proper statement it is so ambiguous. I could not understand it. "
                    },
                    {
                        "username": "Finesse",
                        "content": "The score of a turn doubles, if the score of the previous turn or the turn before the previous was 10. I.e. `if player1[i - 1] == 10 || player1[i - 2] == 10 { player1[i] *= 2 }`."
                    },
                    {
                        "username": "aquaman55",
                        "content": "Its bowling man. Have you never bowled? lol"
                    }
                ]
            },
            {
                "id": 1881378,
                "content": [
                    {
                        "username": "almostmonday",
                        "content": "Be careful:\n1) previous **TWO** turns;\n2) \"in any of the previous two turns\" means `player[i - 1] == 10 or player[i - 2] == 10`."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**improves attention**"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "hahahaha"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it wasn\\'t a easy question bro "
                    },
                    {
                        "username": "hhimanshii",
                        "content": "They should have given good example test cases. It\\'s so unclear from the given test cases."
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "2xi (((if the player hits 10 pins in any of the previous two turns))). Read this line very carefully my fellow leetcoders only the one in bracket. We need to double the current score if it satisfies this condition "
                    },
                    {
                        "username": "gouravchalotra",
                        "content": "it\\'s took me 1 hour to to understand it \\uD83E\\uDD72"
                    },
                    {
                        "username": "learn_improve",
                        "content": "Thanks for highlighting this"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "Has any one got the same problem ?\\n```\\nplayer1 = [9,7,10,7]\\nplayer2 = [10,2,4,10]\\n```\\nThe total scores should be \\n```\\nscore_1 = 40\\nscore_2 = 42\\n```\\nAccording to the condition \\n```\\nsocre_2 > score_1 = True\\n```\\nand hence the output should be \\n```\\nOutput : 2\\n```\\nThen why it is showing the output to be \\n```\\nExpected : 1\\n```"
                    },
                    {
                        "username": "iam_kmrahul",
                        "content": "score_1=9+7+10+7*2=40\\nscore_2=10+2*2+4*2+10=32\\nso player 1 is scored more \\n1 is correct output"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@kshapwari](/kshapwari) \\n\\nLets consider this test case \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\nOutput: 2\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\nHere the 2nd 10 is also multiplied with 2, that\\'s why I consider multiplication with 2 \\n\\n```\\n10 + (2 * 2) + (2 * 4) + (2 * 10)\\n= 10 + 4 + 8 + 20\\n= 42\\n```"
                    },
                    {
                        "username": "kshapwari",
                        "content": "score_2 = 32\\n10 + 2*2 + 2*4 + 10 =32"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@mainadotkim](/mainadotkim)  \\n\\nHey mainadotkim !. \\n\\nI had thought of this case but when I saw this test case in the example \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\n\\nOutput: 2\\n\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\n\\nIn this test case the second `10` was also multiplied by `2`"
                    },
                    {
                        "username": "mainadotkim",
                        "content": "Because\n\n```\nscore_1 = 40\nscore_2 = 32\n```\n\nAnd the output will be as `Expected: 1`\n\nExplanation:\n\nThe statement\n\n> 2xi if the player hit 10 pins in any of the previous two turns\n\nmeans that the last 10 scored by `player2` should not be doubled.\n\nThus, `score_2 = 10 + 2*2 + 2*4 + 10`"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Tip : Don\\'t underestimate this one "
                    },
                    {
                        "username": "NitinSingh77",
                        "content": "player1=[10,2,2,3]\\nplayer2=[3,8,4,5]\\n\\nWhy is player 1 the winner in this test case?"
                    },
                    {
                        "username": "IgorP17",
                        "content": "[@qleIIT](/qleIIT) yes, it seems here was the problem"
                    },
                    {
                        "username": "IgorP17",
                        "content": "I wrote aux method for cheking if we need doubling and test was passed)). Do not understand what was wrong)).\\nMethod:\\nboolean checkLast(int k, int[] res)\\nk == 0 -> false\\nk == 1 -> res[k - 1] == 10\\nelse -> res[k - 1] == 10 || res[k - 2] == 10"
                    },
                    {
                        "username": "qleIIT",
                        "content": "Im no expert here, since I failed this question miserably , but for your example, player1 gets 10 + 2x2 + 2x2 + 3 = 21, player2 gets 3 + 8 + 4 + 5 = 20. So player1 is the winner here."
                    },
                    {
                        "username": "qleIIT",
                        "content": "29.7% acceptance rate for an \"Easy\" contest Q1 huh?\n\n"
                    },
                    {
                        "username": "luckymaster",
                        "content": "what does this mean --> 2xi if the player hit 10 pins in any of the previous two turns. \\nSo unclear. Please try to write proper statement it is so ambiguous. I could not understand it. "
                    },
                    {
                        "username": "Finesse",
                        "content": "The score of a turn doubles, if the score of the previous turn or the turn before the previous was 10. I.e. `if player1[i - 1] == 10 || player1[i - 2] == 10 { player1[i] *= 2 }`."
                    },
                    {
                        "username": "aquaman55",
                        "content": "Its bowling man. Have you never bowled? lol"
                    }
                ]
            },
            {
                "id": 1877747,
                "content": [
                    {
                        "username": "almostmonday",
                        "content": "Be careful:\n1) previous **TWO** turns;\n2) \"in any of the previous two turns\" means `player[i - 1] == 10 or player[i - 2] == 10`."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**improves attention**"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "hahahaha"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it wasn\\'t a easy question bro "
                    },
                    {
                        "username": "hhimanshii",
                        "content": "They should have given good example test cases. It\\'s so unclear from the given test cases."
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "2xi (((if the player hits 10 pins in any of the previous two turns))). Read this line very carefully my fellow leetcoders only the one in bracket. We need to double the current score if it satisfies this condition "
                    },
                    {
                        "username": "gouravchalotra",
                        "content": "it\\'s took me 1 hour to to understand it \\uD83E\\uDD72"
                    },
                    {
                        "username": "learn_improve",
                        "content": "Thanks for highlighting this"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "Has any one got the same problem ?\\n```\\nplayer1 = [9,7,10,7]\\nplayer2 = [10,2,4,10]\\n```\\nThe total scores should be \\n```\\nscore_1 = 40\\nscore_2 = 42\\n```\\nAccording to the condition \\n```\\nsocre_2 > score_1 = True\\n```\\nand hence the output should be \\n```\\nOutput : 2\\n```\\nThen why it is showing the output to be \\n```\\nExpected : 1\\n```"
                    },
                    {
                        "username": "iam_kmrahul",
                        "content": "score_1=9+7+10+7*2=40\\nscore_2=10+2*2+4*2+10=32\\nso player 1 is scored more \\n1 is correct output"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@kshapwari](/kshapwari) \\n\\nLets consider this test case \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\nOutput: 2\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\nHere the 2nd 10 is also multiplied with 2, that\\'s why I consider multiplication with 2 \\n\\n```\\n10 + (2 * 2) + (2 * 4) + (2 * 10)\\n= 10 + 4 + 8 + 20\\n= 42\\n```"
                    },
                    {
                        "username": "kshapwari",
                        "content": "score_2 = 32\\n10 + 2*2 + 2*4 + 10 =32"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@mainadotkim](/mainadotkim)  \\n\\nHey mainadotkim !. \\n\\nI had thought of this case but when I saw this test case in the example \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\n\\nOutput: 2\\n\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\n\\nIn this test case the second `10` was also multiplied by `2`"
                    },
                    {
                        "username": "mainadotkim",
                        "content": "Because\n\n```\nscore_1 = 40\nscore_2 = 32\n```\n\nAnd the output will be as `Expected: 1`\n\nExplanation:\n\nThe statement\n\n> 2xi if the player hit 10 pins in any of the previous two turns\n\nmeans that the last 10 scored by `player2` should not be doubled.\n\nThus, `score_2 = 10 + 2*2 + 2*4 + 10`"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Tip : Don\\'t underestimate this one "
                    },
                    {
                        "username": "NitinSingh77",
                        "content": "player1=[10,2,2,3]\\nplayer2=[3,8,4,5]\\n\\nWhy is player 1 the winner in this test case?"
                    },
                    {
                        "username": "IgorP17",
                        "content": "[@qleIIT](/qleIIT) yes, it seems here was the problem"
                    },
                    {
                        "username": "IgorP17",
                        "content": "I wrote aux method for cheking if we need doubling and test was passed)). Do not understand what was wrong)).\\nMethod:\\nboolean checkLast(int k, int[] res)\\nk == 0 -> false\\nk == 1 -> res[k - 1] == 10\\nelse -> res[k - 1] == 10 || res[k - 2] == 10"
                    },
                    {
                        "username": "qleIIT",
                        "content": "Im no expert here, since I failed this question miserably , but for your example, player1 gets 10 + 2x2 + 2x2 + 3 = 21, player2 gets 3 + 8 + 4 + 5 = 20. So player1 is the winner here."
                    },
                    {
                        "username": "qleIIT",
                        "content": "29.7% acceptance rate for an \"Easy\" contest Q1 huh?\n\n"
                    },
                    {
                        "username": "luckymaster",
                        "content": "what does this mean --> 2xi if the player hit 10 pins in any of the previous two turns. \\nSo unclear. Please try to write proper statement it is so ambiguous. I could not understand it. "
                    },
                    {
                        "username": "Finesse",
                        "content": "The score of a turn doubles, if the score of the previous turn or the turn before the previous was 10. I.e. `if player1[i - 1] == 10 || player1[i - 2] == 10 { player1[i] *= 2 }`."
                    },
                    {
                        "username": "aquaman55",
                        "content": "Its bowling man. Have you never bowled? lol"
                    }
                ]
            },
            {
                "id": 1877717,
                "content": [
                    {
                        "username": "almostmonday",
                        "content": "Be careful:\n1) previous **TWO** turns;\n2) \"in any of the previous two turns\" means `player[i - 1] == 10 or player[i - 2] == 10`."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**improves attention**"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "hahahaha"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it wasn\\'t a easy question bro "
                    },
                    {
                        "username": "hhimanshii",
                        "content": "They should have given good example test cases. It\\'s so unclear from the given test cases."
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "2xi (((if the player hits 10 pins in any of the previous two turns))). Read this line very carefully my fellow leetcoders only the one in bracket. We need to double the current score if it satisfies this condition "
                    },
                    {
                        "username": "gouravchalotra",
                        "content": "it\\'s took me 1 hour to to understand it \\uD83E\\uDD72"
                    },
                    {
                        "username": "learn_improve",
                        "content": "Thanks for highlighting this"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "Has any one got the same problem ?\\n```\\nplayer1 = [9,7,10,7]\\nplayer2 = [10,2,4,10]\\n```\\nThe total scores should be \\n```\\nscore_1 = 40\\nscore_2 = 42\\n```\\nAccording to the condition \\n```\\nsocre_2 > score_1 = True\\n```\\nand hence the output should be \\n```\\nOutput : 2\\n```\\nThen why it is showing the output to be \\n```\\nExpected : 1\\n```"
                    },
                    {
                        "username": "iam_kmrahul",
                        "content": "score_1=9+7+10+7*2=40\\nscore_2=10+2*2+4*2+10=32\\nso player 1 is scored more \\n1 is correct output"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@kshapwari](/kshapwari) \\n\\nLets consider this test case \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\nOutput: 2\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\nHere the 2nd 10 is also multiplied with 2, that\\'s why I consider multiplication with 2 \\n\\n```\\n10 + (2 * 2) + (2 * 4) + (2 * 10)\\n= 10 + 4 + 8 + 20\\n= 42\\n```"
                    },
                    {
                        "username": "kshapwari",
                        "content": "score_2 = 32\\n10 + 2*2 + 2*4 + 10 =32"
                    },
                    {
                        "username": "AyushS9020",
                        "content": "[@mainadotkim](/mainadotkim)  \\n\\nHey mainadotkim !. \\n\\nI had thought of this case but when I saw this test case in the example \\n\\n```\\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\\n\\nOutput: 2\\n\\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\\n```\\n\\nIn this test case the second `10` was also multiplied by `2`"
                    },
                    {
                        "username": "mainadotkim",
                        "content": "Because\n\n```\nscore_1 = 40\nscore_2 = 32\n```\n\nAnd the output will be as `Expected: 1`\n\nExplanation:\n\nThe statement\n\n> 2xi if the player hit 10 pins in any of the previous two turns\n\nmeans that the last 10 scored by `player2` should not be doubled.\n\nThus, `score_2 = 10 + 2*2 + 2*4 + 10`"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Tip : Don\\'t underestimate this one "
                    },
                    {
                        "username": "NitinSingh77",
                        "content": "player1=[10,2,2,3]\\nplayer2=[3,8,4,5]\\n\\nWhy is player 1 the winner in this test case?"
                    },
                    {
                        "username": "IgorP17",
                        "content": "[@qleIIT](/qleIIT) yes, it seems here was the problem"
                    },
                    {
                        "username": "IgorP17",
                        "content": "I wrote aux method for cheking if we need doubling and test was passed)). Do not understand what was wrong)).\\nMethod:\\nboolean checkLast(int k, int[] res)\\nk == 0 -> false\\nk == 1 -> res[k - 1] == 10\\nelse -> res[k - 1] == 10 || res[k - 2] == 10"
                    },
                    {
                        "username": "qleIIT",
                        "content": "Im no expert here, since I failed this question miserably , but for your example, player1 gets 10 + 2x2 + 2x2 + 3 = 21, player2 gets 3 + 8 + 4 + 5 = 20. So player1 is the winner here."
                    },
                    {
                        "username": "qleIIT",
                        "content": "29.7% acceptance rate for an \"Easy\" contest Q1 huh?\n\n"
                    },
                    {
                        "username": "luckymaster",
                        "content": "what does this mean --> 2xi if the player hit 10 pins in any of the previous two turns. \\nSo unclear. Please try to write proper statement it is so ambiguous. I could not understand it. "
                    },
                    {
                        "username": "Finesse",
                        "content": "The score of a turn doubles, if the score of the previous turn or the turn before the previous was 10. I.e. `if player1[i - 1] == 10 || player1[i - 2] == 10 { player1[i] *= 2 }`."
                    },
                    {
                        "username": "aquaman55",
                        "content": "Its bowling man. Have you never bowled? lol"
                    }
                ]
            }
        ]
    },
    {
        "title": "First Completely Painted Row or Column",
        "question_content": "<p>You are given a <strong>0-indexed</strong> integer array <code>arr</code>, and an <code>m x n</code> integer <strong>matrix</strong> <code>mat</code>. <code>arr</code> and <code>mat</code> both contain <strong>all</strong> the integers in the range <code>[1, m * n]</code>.</p>\n\n<p>Go through each index <code>i</code> in <code>arr</code> starting from index <code>0</code> and paint the cell in <code>mat</code> containing the integer <code>arr[i]</code>.</p>\n\n<p>Return <em>the smallest index</em> <code>i</code> <em>at which either a row or a column will be completely painted in</em> <code>mat</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"image explanation for example 1\" /><img alt=\"image explanation for example 1\" src=\"https://assets.leetcode.com/uploads/2023/01/18/grid1.jpg\" style=\"width: 321px; height: 81px;\" />\n<pre>\n<strong>Input:</strong> arr = [1,3,4,2], mat = [[1,4],[2,3]]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The moves are shown in order, and both the first row and second column of the matrix become fully painted at arr[2].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"image explanation for example 2\" src=\"https://assets.leetcode.com/uploads/2023/01/18/grid2.jpg\" style=\"width: 601px; height: 121px;\" />\n<pre>\n<strong>Input:</strong> arr = [2,8,7,4,1,3,5,6,9], mat = [[3,2,5],[1,4,6],[8,7,9]]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The second column becomes fully painted at arr[3].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code></li>\n\t<li><code>n = mat[i].length</code></li>\n\t<li><code>arr.length == m * n</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= arr[i], mat[r][c] &lt;= m * n</code></li>\n\t<li>All the integers of <code>arr</code> are <strong>unique</strong>.</li>\n\t<li>All the integers of <code>mat</code> are <strong>unique</strong>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 3468444,
                "title": "explained-using-map-very-simple-and-easy-to-understand-solution",
                "content": "\\n# Approach\\nWe will have two map for tracking the row and col of a number, so that we can get the row,col in O(1) time.\\nThen we have another two map ( mprc, mpcc) which basically count the no. elements seen in that row and no. of elements seen in that column.\\n\\n1. Map the row, col of each of elements\\n2. Travesrse the arr and keep updatinf row & col count \\n3. Once the row count equal to max or col count equal to max return index\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        unordered_map<int, int> mpr, mpc, mprc, mpcc;\\n        for(int i = 0; i < mat.size(); i++){\\n            for(int j = 0; j< mat[0].size(); ++j){\\n                mpr[mat[i][j]] = i;     mpc[mat[i][j]] = j;\\n            }\\n        }\\n        for(int i = 0; i < arr.size(); i++){\\n            int n = arr[i];\\n            mprc[mpr[n]]++;    mpcc[mpc[n]]++;\\n            if(mprc[mpr[n]] == mat[0].size() || mpcc[mpc[n]] == mat.size()) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nSolution - 2: \\nI find the following solution interesting by @Tushar_aherwar\\n, with reverse mapping of the above solution: https://leetcode.com/problems/first-completely-painted-row-or-column/solutions/3469270/c-solution-space-complexity-o-n/?orderBy=most_votes\\n\\n<b>Here is an article of my recent interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        unordered_map<int, int> mpr, mpc, mprc, mpcc;\\n        for(int i = 0; i < mat.size(); i++){\\n            for(int j = 0; j< mat[0].size(); ++j){\\n                mpr[mat[i][j]] = i;     mpc[mat[i][j]] = j;\\n            }\\n        }\\n        for(int i = 0; i < arr.size(); i++){\\n            int n = arr[i];\\n            mprc[mpr[n]]++;    mpcc[mpc[n]]++;\\n            if(mprc[mpr[n]] == mat[0].size() || mpcc[mpc[n]] == mat.size()) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468260,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(m*n)$$\\n\\n- Space complexity: $$O(m*n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        Map<Integer, int[]> nm = new HashMap<>();\\n        int m=mat.length;\\n        int n=mat[0].length;\\n        for (int i=0;i<m;i++)\\n        {\\n            for (int j=0;j<n;j++)\\n            {\\n                nm.put(mat[i][j], new int[]{i, j});\\n            }\\n        }\\n        int a[]=new int[m];\\n        int b[]=new int[n];\\n        for (int i = 0; i < arr.length; i++)\\n        {\\n            int c[] = nm.get(arr[i]);\\n            a[c[0]]++;\\n            b[c[1]]++;\\n            if(a[c[0]]==n||b[c[1]]==m)\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        Map<Integer, int[]> nm = new HashMap<>();\\n        int m=mat.length;\\n        int n=mat[0].length;\\n        for (int i=0;i<m;i++)\\n        {\\n            for (int j=0;j<n;j++)\\n            {\\n                nm.put(mat[i][j], new int[]{i, j});\\n            }\\n        }\\n        int a[]=new int[m];\\n        int b[]=new int[n];\\n        for (int i = 0; i < arr.length; i++)\\n        {\\n            int c[] = nm.get(arr[i]);\\n            a[c[0]]++;\\n            b[c[1]]++;\\n            if(a[c[0]]==n||b[c[1]]==m)\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468252,
                "title": "day-395-easy-100-0ms-python-java-c-explained-approach",
                "content": "# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\n##### \\u2022\\tWe are given an array  arr and a matrix  mat.\\n##### \\u2022\\tWe first create a  HashMap called  map to store the coordinates of each element in  mat. The key of the  HashMap is the value of the element, and the value is an array of two integers representing the row and column indices of the element.\\n##### \\u2022\\tWe also create two arrays row and  col to keep track of the number of elements painted in each row and column of  mat.\\n##### \\u2022\\tWe then iterate over the elements of arr and for each element, we get its coordinates from the  map\\n##### \\u2022\\tWe increment the count of painted elements in the row and column corresponding to the coordinates of the current element.\\n##### \\u2022\\tWe then check if the count of painted elements in the row or column of the current element is equal to the length of the row or column, respectively. If either of these conditions is true, it means that the entire row or column has been painted, and we return the index of the current element.\\n##### \\u2022\\tIf we have iterated over all the elements of  arr and have not found any completely painted row or column, we return -1.\\n##### \\u2022\\tThe intuition behind this approach is that we can keep track of the number of painted elements in each row and column of mat as we iterate over the elements of  arr. If the count of painted elements in any row or column becomes equal to the length of the row or column, it means that the entire row or column has been painted, and we can return the index of the current element. If we have iterated over all the elements of  arr and have not found any completely painted row or column, it means that there is no completely painted row or column in  mat, and we return -1.\\n\\n\\n\\n\\n# Complexity\\n- Time complexity: o(n2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java []\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int m= mat.length;\\n        int n = mat[0].length;\\n        HashMap<Integer,int[]> map = new HashMap<>();\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                map.put(mat[i][j],new int[]{i,j});\\n        int row[] = new int[m];\\n        int col[] = new int[n];\\n        for(int i=0;i<arr.length;i++){\\n            int x[] = map.get(arr[i]);\\n            row[x[0]]++;\\n            col[x[1]]++;\\n            if(row[x[0]]==n || col[x[1]]==m) return i;            \\n        }\\n        return -1;\\n    }\\n```\\n\\n```python []\\ndef firstCompleteIndex(arr: List[int], mat: List[List[int]]) -> int:\\n    m = len(mat)\\n    n = len(mat[0])\\n    map = {}\\n    for i in range(m):\\n        for j in range(n):\\n            map[mat[i][j]] = [i, j]\\n    row = [0] * m\\n    col = [0] * n\\n    for i in range(len(arr)):\\n        x = map[arr[i]]\\n        row[x[0]] += 1\\n        col[x[1]] += 1\\n        if row[x[0]] == n or col[x[1]] == m:\\n            return i\\n    return -1\\n```\\n```c++ []\\n#include <unordered_map>\\n#include <vectorusing namespace std;\\n\\nint firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n    int m = mat.size();\\n    int n = mat[0].size();\\n    unordered_map<int, vector<int>> map;\\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            map[mat[i][j]] = {i, j};\\n        }\\n    }\\n    vector<int> row(m);\\n    vector<int> col(n);\\n    for (int i = 0; i < arr.size(); i++) {\\n        vector<int> x = map[arr[i]];\\n        row[x[0]]++;\\n        col[x[1]]++;\\n        if (row[x[0]] == n || col[x[1]] == m) {\\n            return i;\\n        }\\n    }\\n    return -1;\\n}\\n```\\n\\n# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n\\n\\n![BREUSELEE.webp](https://assets.leetcode.com/users/images/062630f0-ef80-4e74-abdb-302827b99235_1680054012.5054147.webp)\\n![image.png](https://assets.leetcode.com/users/images/303fa18d-281d-49f0-87ef-1a018fc9a488_1681355186.0923774.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```java []\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int m= mat.length;\\n        int n = mat[0].length;\\n        HashMap<Integer,int[]> map = new HashMap<>();\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                map.put(mat[i][j],new int[]{i,j});\\n        int row[] = new int[m];\\n        int col[] = new int[n];\\n        for(int i=0;i<arr.length;i++){\\n            int x[] = map.get(arr[i]);\\n            row[x[0]]++;\\n            col[x[1]]++;\\n            if(row[x[0]]==n || col[x[1]]==m) return i;            \\n        }\\n        return -1;\\n    }\\n```\n```python []\\ndef firstCompleteIndex(arr: List[int], mat: List[List[int]]) -> int:\\n    m = len(mat)\\n    n = len(mat[0])\\n    map = {}\\n    for i in range(m):\\n        for j in range(n):\\n            map[mat[i][j]] = [i, j]\\n    row = [0] * m\\n    col = [0] * n\\n    for i in range(len(arr)):\\n        x = map[arr[i]]\\n        row[x[0]] += 1\\n        col[x[1]] += 1\\n        if row[x[0]] == n or col[x[1]] == m:\\n            return i\\n    return -1\\n```\n```c++ []\\n#include <unordered_map>\\n#include <vectorusing namespace std;\\n\\nint firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n    int m = mat.size();\\n    int n = mat[0].size();\\n    unordered_map<int, vector<int>> map;\\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            map[mat[i][j]] = {i, j};\\n        }\\n    }\\n    vector<int> row(m);\\n    vector<int> col(n);\\n    for (int i = 0; i < arr.size(); i++) {\\n        vector<int> x = map[arr[i]];\\n        row[x[0]]++;\\n        col[x[1]]++;\\n        if (row[x[0]] == n || col[x[1]] == m) {\\n            return i;\\n        }\\n    }\\n    return -1;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3468668,
                "title": "c-using-only-single-map-explained-easy-to-understand",
                "content": "**C++ Code**\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        \\n        int n = size(mat), m = size(mat[0]), res = m*n;\\n        \\n        unordered_map<int,int> map;\\n        \\n        for(int i = 0; i < m*n; i++)map[arr[i]] = i;\\n        \\n        for(int i = 0; i < n; i++) {\\n            int maxIdx = 0;\\n            \\n            for(int j = 0; j < m; j++) {\\n                maxIdx = max(maxIdx, map[mat[i][j]]);\\n            }\\n            \\n            res = min(res,maxIdx);\\n        }\\n        \\n        for(int i = 0; i < m; i++) {\\n            int maxIdx = 0;\\n            \\n            for(int j = 0; j < n; j++) {\\n                maxIdx = max(maxIdx, map[mat[j][i]]);\\n            }\\n            \\n            res = min(res,maxIdx);\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```\\n\\n**Explanation**\\n\\n* unordered_map<int,int> map; - Here used to mark the order of arr items\\n* First loop iterates by row, to identify by each row the index of last marked arr item. Then get the min, which row marked(finished) first:\\n\\n```\\nfor(int i = 0; i < n; i++) {\\n            int maxIdx = 0;\\n            \\n            for(int j = 0; j < m; j++) {\\n                maxIdx = max(maxIdx, map[mat[i][j]]);\\n            }\\n            \\n            res = min(res,maxIdx);\\n}\\n```\\n* Second loop iterates by column and makes the same logic as first loop described above.\\n\\n* Let\\'s test in second example of the problem:\\n```Input: arr = [2,8,7,4,1,3,5,6,9], mat = [[3,2,5],[1,4,6],[8,7,9]] Output: 3```\\n\\n* After mark the order of arr in map, we can draw second matrix that shows the mark position by arr:\\n\\n```\\n[5,0,6],\\n[4,3,7],\\n[1,2,8]\\n```\\n\\n* First loop iteration by row:\\n\\n```\\n[5,0,6], // maxIdx = 6\\n[4,3,7], // maxIdx = 7\\n[1,2,8] // maxIdx = 8\\n\\nmin of these is `6`, we can see by row first finished first row, by arr item index `6`\\n```\\n\\n* Second loop iteration by column:\\n```\\n[5,0,6], \\n[4,3,7], \\n[1,2,8] \\n\\nMax by col:\\n5 3 8\\n```\\n\\n* min of these(5,3,8) is 3, we can see by column first finished second column by arr item index 3. If we compare which one first finished by row or column, the answer is by column because arr value by index 3 becomes earlier than index 6\\n\\n*Thank you @Yerkon for explaining the code*",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        \\n        int n = size(mat), m = size(mat[0]), res = m*n;\\n        \\n        unordered_map<int,int> map;\\n        \\n        for(int i = 0; i < m*n; i++)map[arr[i]] = i;\\n        \\n        for(int i = 0; i < n; i++) {\\n            int maxIdx = 0;\\n            \\n            for(int j = 0; j < m; j++) {\\n                maxIdx = max(maxIdx, map[mat[i][j]]);\\n            }\\n            \\n            res = min(res,maxIdx);\\n        }\\n        \\n        for(int i = 0; i < m; i++) {\\n            int maxIdx = 0;\\n            \\n            for(int j = 0; j < n; j++) {\\n                maxIdx = max(maxIdx, map[mat[j][i]]);\\n            }\\n            \\n            res = min(res,maxIdx);\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```\n```\\nfor(int i = 0; i < n; i++) {\\n            int maxIdx = 0;\\n            \\n            for(int j = 0; j < m; j++) {\\n                maxIdx = max(maxIdx, map[mat[i][j]]);\\n            }\\n            \\n            res = min(res,maxIdx);\\n}\\n```\n```Input: arr = [2,8,7,4,1,3,5,6,9], mat = [[3,2,5],[1,4,6],[8,7,9]] Output: 3```\n```\\n[5,0,6],\\n[4,3,7],\\n[1,2,8]\\n```\n```\\n[5,0,6], // maxIdx = 6\\n[4,3,7], // maxIdx = 7\\n[1,2,8] // maxIdx = 8\\n\\nmin of these is `6`, we can see by row first finished first row, by arr item index `6`\\n```\n```\\n[5,0,6], \\n[4,3,7], \\n[1,2,8] \\n\\nMax by col:\\n5 3 8\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469270,
                "title": "c-dry-run-single-map",
                "content": "\\n![image.png](https://assets.leetcode.com/users/images/bdfd35b1-9880-466e-81ab-a997c64a08c7_1683038605.5310476.png)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n\\n    unordered_map<int,int>mp;\\n    for(int i = 0; i < arr.size(); i++) {\\n        mp[arr[i]] = i;\\n    }\\n\\n    int minIndex = INT_MAX , maxIndex = INT_MIN;\\n    int rowSize = mat.size();\\n    int colSize = mat[0].size();\\n\\n    for(int row = 0; row < rowSize; row++) {\\n        maxIndex = INT_MIN;\\n        for(int column = 0; column < colSize; column++) {\\n            int indexVal = mp[mat[row][column]];\\n            maxIndex = max(maxIndex , indexVal);\\n        }\\n        minIndex = min(minIndex , maxIndex);\\n    }\\n    \\n    for(int column = 0; column < colSize; column++) {\\n        maxIndex = INT_MIN;\\n        for(int row = 0; row < rowSize; row++) {\\n            int indexVal2 = mp[mat[row][column]];\\n            maxIndex = max(maxIndex , indexVal2);\\n        }\\n        minIndex = min(minIndex , maxIndex);\\n    }\\n    return minIndex;   \\n}\\n};    \\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n\\n    unordered_map<int,int>mp;\\n    for(int i = 0; i < arr.size(); i++) {\\n        mp[arr[i]] = i;\\n    }\\n\\n    int minIndex = INT_MAX , maxIndex = INT_MIN;\\n    int rowSize = mat.size();\\n    int colSize = mat[0].size();\\n\\n    for(int row = 0; row < rowSize; row++) {\\n        maxIndex = INT_MIN;\\n        for(int column = 0; column < colSize; column++) {\\n            int indexVal = mp[mat[row][column]];\\n            maxIndex = max(maxIndex , indexVal);\\n        }\\n        minIndex = min(minIndex , maxIndex);\\n    }\\n    \\n    for(int column = 0; column < colSize; column++) {\\n        maxIndex = INT_MIN;\\n        for(int row = 0; row < rowSize; row++) {\\n            int indexVal2 = mp[mat[row][column]];\\n            maxIndex = max(maxIndex , indexVal2);\\n        }\\n        minIndex = min(minIndex , maxIndex);\\n    }\\n    return minIndex;   \\n}\\n};    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470314,
                "title": "c-don-t-use-a-hash-map-when-a-vector-or-an-array-does-the-trick",
                "content": "**TODO(heder): Insert cute cat meme to ask for up-votes. ;)**\\n\\n# Approach 1: vector (186ms)\\n\\nSeveral solutions are using an ```std::unordered_map``` for building an index, which is a waste as we know that the elements in ```mat``` are within $$[1, n * m]$$, hence we can just directly index into a ```std::vector```.\\n\\n```cpp\\n    static int firstCompleteIndex(const vector<int>& arr, const vector<vector<int>>& mat) {\\n        const int rows = size(mat);\\n        const int cols = size(mat[0]);\\n        \\n        // build index for |mat|.\\n        vector<pair<int,int>> index(rows * cols + 1);\\n        for (int r = 0; r < rows; ++r)\\n            for (int c = 0; c < cols; ++c)\\n                index[mat[r][c]] = make_pair(r, c);\\n        \\n        // process |arr|.\\n        vector<int> rc(rows);\\n        vector<int> cc(cols);\\n        for (int i = 0; i < size(arr); ++i) {\\n            const auto [r, c] = index[arr[i]];\\n            if (++rc[r] == cols) return i;\\n            if (++cc[c] == rows) return i;\\n        }\\n        // unreachable.\\n        assert(false);\\n        return -1;\\n    }\\n```\\n\\n**Complexity Analysis**\\nLet $$n$$ and $$m$$ be the dimension of ```mat``` and $$n * m$$ the size of ```arr``` then the \\n  * Time complexity is $$O(n * m)$$ as we need to scan ```mat``` and ```arr``` and the\\n  * Space complexity is $$O(n * m)$$ for the index we build.\\n\\n\\n# Approach 2: dynamic array on stack (167ms, 100%?)\\nAs pointed out @Ajna2, why bother with a vector when an array might be even cheaper. The code is kinda interesting that clang generates for multiple dynamic arrays on the stack: https://godbolt.org/z/h1975ojhj Instead of on the heap the temporary working memory is created on the stack. There is still an indirection happening though.\\n\\n```cpp\\n    static int firstCompleteIndex(const vector<int>& arr, const vector<vector<int>>& mat) {\\n        const int rows = size(mat);\\n        const int cols = size(mat[0]);\\n        \\n        // build index for |mat|.\\n        pair<int,int> index[rows * cols + 1];\\n        for (int r = 0; r < rows; ++r)\\n            for (int c = 0; c < cols; ++c)\\n                index[mat[r][c]] = make_pair(r, c);\\n        \\n        // process |arr|.   \\n        int rc[rows];\\n        fill(rc, rc + rows, 0);\\n        int cc[cols];\\n        fill(cc, cc + cols, 0);\\n        for (int i = 0; i < size(arr); ++i) {\\n            const auto [r, c] = index[arr[i]];\\n            if (++rc[r] == cols) return i;\\n            if (++cc[c] == rows) return i;\\n        }\\n        // unreachable.\\n        assert(false);\\n        return -1;\\n    }\\n```\\n\\nThe complexity analysis remains the same.\\n\\n**Pro-Tips**\\n\\nI always have a header like this in my solutions. This speeds-up I/O:\\n\\n```cpp\\n// https://leetcode.com/problems/first-completely-painted-row-or-column\\n// problem: 2661\\nstatic int fast_io = []() { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); return 0; }();\\n```\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an up-vote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**\\n",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```std::unordered_map```\n```mat```\n```std::vector```\n```cpp\\n    static int firstCompleteIndex(const vector<int>& arr, const vector<vector<int>>& mat) {\\n        const int rows = size(mat);\\n        const int cols = size(mat[0]);\\n        \\n        // build index for |mat|.\\n        vector<pair<int,int>> index(rows * cols + 1);\\n        for (int r = 0; r < rows; ++r)\\n            for (int c = 0; c < cols; ++c)\\n                index[mat[r][c]] = make_pair(r, c);\\n        \\n        // process |arr|.\\n        vector<int> rc(rows);\\n        vector<int> cc(cols);\\n        for (int i = 0; i < size(arr); ++i) {\\n            const auto [r, c] = index[arr[i]];\\n            if (++rc[r] == cols) return i;\\n            if (++cc[c] == rows) return i;\\n        }\\n        // unreachable.\\n        assert(false);\\n        return -1;\\n    }\\n```\n```mat```\n```arr```\n```mat```\n```arr```\n```cpp\\n    static int firstCompleteIndex(const vector<int>& arr, const vector<vector<int>>& mat) {\\n        const int rows = size(mat);\\n        const int cols = size(mat[0]);\\n        \\n        // build index for |mat|.\\n        pair<int,int> index[rows * cols + 1];\\n        for (int r = 0; r < rows; ++r)\\n            for (int c = 0; c < cols; ++c)\\n                index[mat[r][c]] = make_pair(r, c);\\n        \\n        // process |arr|.   \\n        int rc[rows];\\n        fill(rc, rc + rows, 0);\\n        int cc[cols];\\n        fill(cc, cc + cols, 0);\\n        for (int i = 0; i < size(arr); ++i) {\\n            const auto [r, c] = index[arr[i]];\\n            if (++rc[r] == cols) return i;\\n            if (++cc[c] == rows) return i;\\n        }\\n        // unreachable.\\n        assert(false);\\n        return -1;\\n    }\\n```\n```cpp\\n// https://leetcode.com/problems/first-completely-painted-row-or-column\\n// problem: 2661\\nstatic int fast_io = []() { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); return 0; }();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3468410,
                "title": "just-use-a-simple-map",
                "content": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        \\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int r[] = new int[m];\\n        int c[] = new int[n];\\n        \\n        Map<Integer, int[]> map = new HashMap<>();\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                map.put(mat[i][j], new int[]{i, j});\\n            }\\n        }\\n        \\n        for(int i = 0; i < arr.length; i++)\\n        {\\n            int[] posi = map.get(arr[i]);\\n            int x = posi[0];\\n            int y = posi[1];\\n            r[x]++;\\n            c[y]++;\\n\\t\\t\\t// any index of r is storing painted columns of that particular row \\n\\t\\t\\t// any index of c is storing painted rows of that particular column.\\n            if(r[x] == n || c[y] == m)  // as any column size of a particular row is n and any row size of a particular column is m\\n                return i;\\n        }\\n        return arr.length - 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        \\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int r[] = new int[m];\\n        int c[] = new int[n];\\n        \\n        Map<Integer, int[]> map = new HashMap<>();\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                map.put(mat[i][j], new int[]{i, j});\\n            }\\n        }\\n        \\n        for(int i = 0; i < arr.length; i++)\\n        {\\n            int[] posi = map.get(arr[i]);\\n            int x = posi[0];\\n            int y = posi[1];\\n            r[x]++;\\n            c[y]++;\\n\\t\\t\\t// any index of r is storing painted columns of that particular row \\n\\t\\t\\t// any index of c is storing painted rows of that particular column.\\n            if(r[x] == n || c[y] == m)  // as any column size of a particular row is n and any row size of a particular column is m\\n                return i;\\n        }\\n        return arr.length - 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468279,
                "title": "c-map-easy-to-understand",
                "content": "# Approach\\n\\nWe first create a map that maps each element in the matrix to its row and column position. Then, for each element in the array, we look up its row and column position in the map and increments the count of elements in that row and column.\\n\\nIf the count of elements in any row or column reaches the size of the matrix, it means that all the elements needed to complete that row or column have been found. In that case, return the index of the current element in the list.\\n\\nIf no element completes a row or column, the return -1.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int m=mat.size();\\n        int n=mat[0].size();\\n\\n        unordered_map<int, int> rowcount, colcount; \\n        unordered_map<int,pair<int,int>>mp;\\n\\n        for(int i=0;i<m;++i){\\n            for(int j=0;j<n;++j){\\n                mp[mat[i][j]]={i,j}; //store the coordinates of each number in the matrix\\n            }\\n        }\\n\\n        for(int i=0;i<arr.size();++i){\\n            int row=mp[arr[i]].first;\\n            int col=mp[arr[i]].second;\\n            \\n            // increment the row and column count for each occurrence\\n            ++rowcount[row];\\n            ++colcount[col];\\n            \\n            // if any row or column has all the numbers, return the current index          \\n            if(rowcount[row]==n || colcount[col]==m) return i;\\n        }      \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int m=mat.size();\\n        int n=mat[0].size();\\n\\n        unordered_map<int, int> rowcount, colcount; \\n        unordered_map<int,pair<int,int>>mp;\\n\\n        for(int i=0;i<m;++i){\\n            for(int j=0;j<n;++j){\\n                mp[mat[i][j]]={i,j}; //store the coordinates of each number in the matrix\\n            }\\n        }\\n\\n        for(int i=0;i<arr.size();++i){\\n            int row=mp[arr[i]].first;\\n            int col=mp[arr[i]].second;\\n            \\n            // increment the row and column count for each occurrence\\n            ++rowcount[row];\\n            ++colcount[col];\\n            \\n            // if any row or column has all the numbers, return the current index          \\n            if(rowcount[row]==n || colcount[col]==m) return i;\\n        }      \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468482,
                "title": "c-best-solution-100-faster-0-m-n-easy-to-understand-comments",
                "content": "# Complexity\\n- Time complexity: $$O(m * n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  $$O(m * n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int n = mat.size(), m = mat[0].size();\\n        unordered_map<int, pair<int, int> > mp;   // this map stores  ::  value -> {row, column}\\n\\n        // map creation process\\n        for(int i=0; i<n; i++)  {\\n            for(int j=0; j<m; j++)  {\\n                mp[mat[i][j]] = {i, j};\\n            }\\n        }\\n        \\n        // initialy all row and column are not visited\\n        vector<int> row(n, 0);  \\n        vector<int> col(m, 0);\\n        \\n        // traversing the array and adding one element to the corresponding row and column\\n        for(int i=0; i<arr.size(); i++) {\\n            pair<int, int> p = mp[arr[i]];  // we get the row and column of the cuurent element by the help of our map in O(1) time\\n\\n            int r = p.first, c = p.second;\\n\\n            row[r]++;   // adding one element in the corresponding row\\n            if(row[r] >= m) return i;   // here the row is full if row contain m elements\\n            \\n            col[c]++;   // adding one element in the corresponding row\\n            if(col[c] >= n) return i;   // here the row is full if row contain m elements\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int n = mat.size(), m = mat[0].size();\\n        unordered_map<int, pair<int, int> > mp;   // this map stores  ::  value -> {row, column}\\n\\n        // map creation process\\n        for(int i=0; i<n; i++)  {\\n            for(int j=0; j<m; j++)  {\\n                mp[mat[i][j]] = {i, j};\\n            }\\n        }\\n        \\n        // initialy all row and column are not visited\\n        vector<int> row(n, 0);  \\n        vector<int> col(m, 0);\\n        \\n        // traversing the array and adding one element to the corresponding row and column\\n        for(int i=0; i<arr.size(); i++) {\\n            pair<int, int> p = mp[arr[i]];  // we get the row and column of the cuurent element by the help of our map in O(1) time\\n\\n            int r = p.first, c = p.second;\\n\\n            row[r]++;   // adding one element in the corresponding row\\n            if(row[r] >= m) return i;   // here the row is full if row contain m elements\\n            \\n            col[c]++;   // adding one element in the corresponding row\\n            if(col[c] >= n) return i;   // here the row is full if row contain m elements\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468316,
                "title": "easy-to-understand-code-simple-mapping",
                "content": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) \\n    {\\n        int m = mat.size(), n = mat[0].size();\\n        vector<int>rowFill(m, 0); //rowFill[i] => how much columns are filled in row = i\\n        vector<int>colFill(n, 0); //colFill[i] => how much rows are filled in col = i\\n        //=========================================================================\\n        vector<int>rowIdxMap((m * n) + 1); //mapping row index and col index for each value\\n        vector<int>colIdxMap((m * n) + 1);\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                int val = mat[i][j];\\n                rowIdxMap[val] = i;\\n                colIdxMap[val] = j;\\n            }\\n        }\\n        //================================================================================\\n        for (int i = 0; i < arr.size(); i++)\\n        {\\n            int val = arr[i];\\n            int rowIdx = rowIdxMap[val];\\n            int colIdx = colIdxMap[val];\\n            \\n            rowFill[rowIdx]++;\\n            colFill[colIdx]++;\\n            if (rowFill[rowIdx] == n || colFill[colIdx] == m) return i;\\n        }\\n        //===============================================================================\\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) \\n    {\\n        int m = mat.size(), n = mat[0].size();\\n        vector<int>rowFill(m, 0); //rowFill[i] => how much columns are filled in row = i\\n        vector<int>colFill(n, 0); //colFill[i] => how much rows are filled in col = i\\n        //=========================================================================\\n        vector<int>rowIdxMap((m * n) + 1); //mapping row index and col index for each value\\n        vector<int>colIdxMap((m * n) + 1);\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                int val = mat[i][j];\\n                rowIdxMap[val] = i;\\n                colIdxMap[val] = j;\\n            }\\n        }\\n        //================================================================================\\n        for (int i = 0; i < arr.size(); i++)\\n        {\\n            int val = arr[i];\\n            int rowIdx = rowIdxMap[val];\\n            int colIdx = colIdxMap[val];\\n            \\n            rowFill[rowIdx]++;\\n            colFill[colIdx]++;\\n            if (rowFill[rowIdx] == n || colFill[colIdx] == m) return i;\\n        }\\n        //===============================================================================\\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3515361,
                "title": "binary-search-solution-single-set-no-hash-map-unique-approach",
                "content": "# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn this problem I have used Binary search and simple unordered set to solve the problem.\\n\\nThe problem wants us to find the minimum index such that atleast one of the row or column of the matrix is colored. \\n\\nIn my solution I have represented a colored cell using -1.\\n\\nInitially I have assumed that the index is at the middle of the array as we do in a binary search.\\n\\nFor that index = mid, I have put all the elements of array from 0 to mid in a set and called a function \"color\" which would color a cell if a the value present in the cell is also present in the set. Color would also check if any row or column is fully colored or not, as soon as a row or column is colored, it returns a true value else it returns false.\\n\\nNow, the main idea is, if at index == mid, atleast one cell is colored then the minimum value of the index for which atleast one cell is colored can only be towards the left of the mid.\\n\\nSo, now we store mid in our answer and check the left portion of the array like binary search does and update our answer as we go. \\n\\n\\n# Complexity\\n- Time complexity: $$O(log(n)*N*M)$$\\n- where n is size of array, N is no. of rows of matrix, M is no. of columns in matrix.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    using vvi = vector<vector<int>>;\\n\\n    bool color(vvi mat, const unordered_set<int>& nums) {\\n        bool isColor = true;\\n        for (int i = 0; i < mat.size(); i++) {\\n            for (int j = 0; j < mat[0].size(); j++) {\\n                if (nums.count(mat[i][j])) {\\n                    mat[i][j] = -1;\\n                } else {\\n                    isColor = false;\\n                }\\n            }\\n            if (isColor) return true;\\n            isColor = true;  // Reset for next row\\n        }\\n        \\n        for (int j = 0; j < mat[0].size(); j++) {\\n            bool isColor = true;\\n            for (int i = 0; i < mat.size(); i++) {\\n                if (mat[i][j] != -1) {\\n                    isColor = false;\\n                    break;\\n                }\\n            }\\n            if (isColor) return true;\\n        }\\n        \\n        return false;\\n    }\\n\\n    int firstCompleteIndex(const vector<int>& arr, const vvi& mat) {\\n        int left = 0;\\n        int right = arr.size() - 1;\\n        int ans = INT_MAX;\\n\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            unordered_set<int> nums(arr.begin(), arr.begin() + mid + 1);\\n\\n            if (color(mat, nums)) {\\n                ans = min(ans, mid);\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n\\n            mid = left + (right - left) / 2;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Matrix",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using vvi = vector<vector<int>>;\\n\\n    bool color(vvi mat, const unordered_set<int>& nums) {\\n        bool isColor = true;\\n        for (int i = 0; i < mat.size(); i++) {\\n            for (int j = 0; j < mat[0].size(); j++) {\\n                if (nums.count(mat[i][j])) {\\n                    mat[i][j] = -1;\\n                } else {\\n                    isColor = false;\\n                }\\n            }\\n            if (isColor) return true;\\n            isColor = true;  // Reset for next row\\n        }\\n        \\n        for (int j = 0; j < mat[0].size(); j++) {\\n            bool isColor = true;\\n            for (int i = 0; i < mat.size(); i++) {\\n                if (mat[i][j] != -1) {\\n                    isColor = false;\\n                    break;\\n                }\\n            }\\n            if (isColor) return true;\\n        }\\n        \\n        return false;\\n    }\\n\\n    int firstCompleteIndex(const vector<int>& arr, const vvi& mat) {\\n        int left = 0;\\n        int right = arr.size() - 1;\\n        int ans = INT_MAX;\\n\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            unordered_set<int> nums(arr.begin(), arr.begin() + mid + 1);\\n\\n            if (color(mat, nums)) {\\n                ans = min(ans, mid);\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n\\n            mid = left + (right - left) / 2;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468283,
                "title": "simple-clean-java-solution",
                "content": "\\n``` java []\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        Map<Integer,Integer> map = new HashMap();\\n        for(int i=0; i<arr.length; i++) map.put(arr[i],i);\\n        int min = arr.length;\\n//      Row-wise checking\\n        for(int i=0; i<mat.length; i++){\\n            int max = 0;\\n            for(int j=0; j<mat[0].length; j++){\\n                max = Math.max(max, map.get(mat[i][j]));\\n            }\\n            min = Math.min(min,max);\\n        }\\n//      Col-wise checking\\n        for(int i=0; i<mat[0].length; i++){\\n            int max = 0;\\n            for(int j=0; j<mat.length; j++){\\n                max = Math.max(max, map.get(mat[j][i]));\\n            }\\n            min = Math.min(min,max);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        Map<Integer,Integer> map = new HashMap();\\n        for(int i=0; i<arr.length; i++) map.put(arr[i],i);\\n        int min = arr.length;\\n//      Row-wise checking\\n        for(int i=0; i<mat.length; i++){\\n            int max = 0;\\n            for(int j=0; j<mat[0].length; j++){\\n                max = Math.max(max, map.get(mat[i][j]));\\n            }\\n            min = Math.min(min,max);\\n        }\\n//      Col-wise checking\\n        for(int i=0; i<mat[0].length; i++){\\n            int max = 0;\\n            for(int j=0; j<mat.length; j++){\\n                max = Math.max(max, map.get(mat[j][i]));\\n            }\\n            min = Math.min(min,max);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476307,
                "title": "python3-easy-understandable-explained",
                "content": "# Intuition\\nYou only need to keep track of how many zeroes are there.\\n\\n# Approach\\nFirst, map each item in `mat` to the row and column indicies so they can be accessed anywhere. Next, have a list for how many zeroes are in each row and column. Then, loop over `arr` and record the painted cells. Only the 2 recently painted cells can possibly be the last cell painted in a row or column.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def firstCompleteIndex(self, arr, mat):\\n        rowCols = {}\\n        ROWS = len(mat)\\n        COLS = len(mat[0])\\n        for r in range(ROWS):\\n            for c in range(COLS):\\n                rowCols[mat[r][c]] = [r, c] # mapping cells to their r and c\\n        # variables for keeping track of painted cells in a row or column\\n        rowZeroes = ROWS * [0]\\n        colZeroes = COLS * [0]\\n        for n in range(len(arr)):\\n            num = arr[n]\\n            # another 2 painted cells\\n            rowZeroes[rowCols[num][0]] += 1\\n            colZeroes[rowCols[num][1]] += 1\\n\\n\\n            if colZeroes[rowCols[num][1]] == ROWS: return n\\n            elif rowZeroes[rowCols[num][0]] == COLS: return n            \\n```\\nWhy did I compare the colZeroes item with ROWS and rowZeroes with COLS?\\nNotice that the length of C1 (items are wrapped in ()) is \\n                how many rows there are and the length of R1(in {}) is how \\n                many columns there are.\\n```\\n       C1     C2   C3\\nR1 [ ({N}) | {N} | {N} ]\\nR2 [  (N)  |  N  |  N  ]\\nR3 [  (N)  |  N  |  N  ]\\nR4 [  (N)  |  N  |  N  ]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def firstCompleteIndex(self, arr, mat):\\n        rowCols = {}\\n        ROWS = len(mat)\\n        COLS = len(mat[0])\\n        for r in range(ROWS):\\n            for c in range(COLS):\\n                rowCols[mat[r][c]] = [r, c] # mapping cells to their r and c\\n        # variables for keeping track of painted cells in a row or column\\n        rowZeroes = ROWS * [0]\\n        colZeroes = COLS * [0]\\n        for n in range(len(arr)):\\n            num = arr[n]\\n            # another 2 painted cells\\n            rowZeroes[rowCols[num][0]] += 1\\n            colZeroes[rowCols[num][1]] += 1\\n\\n\\n            if colZeroes[rowCols[num][1]] == ROWS: return n\\n            elif rowZeroes[rowCols[num][0]] == COLS: return n            \\n```\n```\\n       C1     C2   C3\\nR1 [ ({N}) | {N} | {N} ]\\nR2 [  (N)  |  N  |  N  ]\\nR3 [  (N)  |  N  |  N  ]\\nR4 [  (N)  |  N  |  N  ]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471164,
                "title": "store-row-and-col",
                "content": "Go through the matrix and, for each number, remember the row and col using `mn`.\\n\\nThen, count how many elements are painted in each row and column using `mc` and `nc`.\\n\\n**C++**\\n```cpp\\nint firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n    int m = mat.size(), n = mat[0].size(), k = 0;\\n    vector<int> mc(m), nc(n);\\n    vector<array<int, 2>> mn(m * n + 1);\\n    for (int i = 0; i < m; ++i)\\n        for (int j = 0; j < n; ++j)\\n            mn[mat[i][j]] = {i, j};\\n    for (; ; ++k)\\n        if (++mc[mn[arr[k]][0]] == n || ++nc[mn[arr[k]][1]] == m)\\n            break;\\n    return k;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n    int m = mat.size(), n = mat[0].size(), k = 0;\\n    vector<int> mc(m), nc(n);\\n    vector<array<int, 2>> mn(m * n + 1);\\n    for (int i = 0; i < m; ++i)\\n        for (int j = 0; j < n; ++j)\\n            mn[mat[i][j]] = {i, j};\\n    for (; ; ++k)\\n        if (++mc[mn[arr[k]][0]] == n || ++nc[mn[arr[k]][1]] == m)\\n            break;\\n    return k;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3468364,
                "title": "hashmap-well-explained-java-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere, all we need to find is the index of the element from arr[i] in the matrix.\\nFor every element we need to find the index and to keep the count of number of elements in each row and each column, so the time complexity will be $$O(len*(m*n))$$ where len is length of array.\\nNow, let\\'s talk about the constraints.\\narr.length == m * n\\n1 <= m, n <= 10^5\\n1 <= m * n <= 10^5\\n\\nClearly, in the worst case there will be TLE error.\\n\\nSo, all we need a data structure which can be used to search the index of the arr[i] in a constant time.\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHashMap is the only data structure which can help us to find the index of arr[i] in a constant time.\\nWe will be keep tracking the number of elements in each row and each column by using temporary arrays.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(m*n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(m*n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        \\n        int m=mat.length;\\n        int n=mat[0].length;\\n        \\n        int[] rows=new int[m];\\n        int[] cols=new int[n];\\n        \\n        \\n        HashMap<Integer,Pair> map=new HashMap<>();\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                map.put(mat[i][j],new Pair(i,j));\\n            }\\n        }\\n        \\n        \\n        for(int i=0;i<arr.length;i++)\\n        {\\n            Pair p=map.get(arr[i]);\\n            \\n            int r=p.i;\\n            int c=p.j;\\n            \\n            rows[r]++;\\n            cols[c]++;            \\n            \\n            if(rows[r]==n || cols[c]==m)\\n                return i;\\n        }\\n        \\n        return -1;\\n        \\n    }\\n}\\n\\nclass Pair\\n{\\n    int i,j;\\n    \\n    Pair(int i,int j)\\n    {\\n        this.i=i;\\n        this.j=j;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        \\n        int m=mat.length;\\n        int n=mat[0].length;\\n        \\n        int[] rows=new int[m];\\n        int[] cols=new int[n];\\n        \\n        \\n        HashMap<Integer,Pair> map=new HashMap<>();\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                map.put(mat[i][j],new Pair(i,j));\\n            }\\n        }\\n        \\n        \\n        for(int i=0;i<arr.length;i++)\\n        {\\n            Pair p=map.get(arr[i]);\\n            \\n            int r=p.i;\\n            int c=p.j;\\n            \\n            rows[r]++;\\n            cols[c]++;            \\n            \\n            if(rows[r]==n || cols[c]==m)\\n                return i;\\n        }\\n        \\n        return -1;\\n        \\n    }\\n}\\n\\nclass Pair\\n{\\n    int i,j;\\n    \\n    Pair(int i,int j)\\n    {\\n        this.i=i;\\n        this.j=j;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468354,
                "title": "fully-explained-simple-java-solution",
                "content": "\\n# Approach\\nImplement a HashMap and store row and column value for each item.\\n\\nNow make arrays of row and column of size column and row respectively for getting the filled size of that row or that column.\\n\\nFor each value of arr we increase the filled size by one and check if any row or col filled size equals to col or row size respectively and store the minimum index.\\n\\n# Complexity\\n- Time complexity: O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(m*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int size = arr.length;\\n        int n = mat.length;\\n        int m = mat[0].length;\\n        //Implement a HashMap and store row and column value for each item\\n        HashMap<Integer,ArrayList<Integer>> map = new HashMap<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                map.put(mat[i][j], new ArrayList<Integer>(Arrays.asList(i,j)));\\n            }\\n        }\\n        \\n        //now make arrays of row and column of size column and row respectively for getting the filled size of that row or that column.\\n        int[] row = new int[n];\\n        int[] col = new int[m];\\n        int rval = Integer.MAX_VALUE;\\n        int cval =Integer.MAX_VALUE;\\n        \\n        // for each value of arr we increase the filled size by one and check if any row or col filled size equals to col or row size respectively and store the minimum index.\\n        for(int i = 0;i<size;i++)\\n        {\\n            int val = arr[i];\\n            int r=map.get(val).get(0);\\n            int c=map.get(val).get(1);\\n            row[r]++;\\n            if(row[r]==m) rval = Math.min(rval,i);\\n            col[c]++;\\n            if(col[c]==n) cval = Math.min(cval,i);\\n            \\n        }\\n        return Math.min(rval,cval);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int size = arr.length;\\n        int n = mat.length;\\n        int m = mat[0].length;\\n        //Implement a HashMap and store row and column value for each item\\n        HashMap<Integer,ArrayList<Integer>> map = new HashMap<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                map.put(mat[i][j], new ArrayList<Integer>(Arrays.asList(i,j)));\\n            }\\n        }\\n        \\n        //now make arrays of row and column of size column and row respectively for getting the filled size of that row or that column.\\n        int[] row = new int[n];\\n        int[] col = new int[m];\\n        int rval = Integer.MAX_VALUE;\\n        int cval =Integer.MAX_VALUE;\\n        \\n        // for each value of arr we increase the filled size by one and check if any row or col filled size equals to col or row size respectively and store the minimum index.\\n        for(int i = 0;i<size;i++)\\n        {\\n            int val = arr[i];\\n            int r=map.get(val).get(0);\\n            int c=map.get(val).get(1);\\n            row[r]++;\\n            if(row[r]==m) rval = Math.min(rval,i);\\n            col[c]++;\\n            if(col[c]==n) cval = Math.min(cval,i);\\n            \\n        }\\n        return Math.min(rval,cval);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468256,
                "title": "c-map-of-each-row-column",
                "content": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        unordered_map<int,pair<int,int>> mp;\\n        for(int i=0;i<mat.size();i++){\\n            for(int j=0;j<mat[0].size();j++){\\n                mp[mat[i][j]] = {i,j};\\n            }\\n        }\\n        map<int,int> r,c;\\n        for(int i=0;i<arr.size();i++){\\n            auto x = mp[arr[i]];\\n            r[x.first] += 1;\\n            c[x.second] += 1;\\n            \\n            if(r[x.first] == mat[0].size() || c[x.second] == mat.size()) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        unordered_map<int,pair<int,int>> mp;\\n        for(int i=0;i<mat.size();i++){\\n            for(int j=0;j<mat[0].size();j++){\\n                mp[mat[i][j]] = {i,j};\\n            }\\n        }\\n        map<int,int> r,c;\\n        for(int i=0;i<arr.size();i++){\\n            auto x = mp[arr[i]];\\n            r[x.first] += 1;\\n            c[x.second] += 1;\\n            \\n            if(r[x.first] == mat[0].size() || c[x.second] == mat.size()) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3492091,
                "title": "c-math-easy-to-understand",
                "content": "# Intuition\\nstore index{i,j} of every element of matrix \\n\\n# Approach\\nfor an element at index x of arr get{i,j} increment r[i] and c[j] by 1\\nif r[i] came n time than return index x\\nif c[j] came m time than return index x\\n# Complexity\\n- Time complexity:\\nO(m*n)\\n\\n- Space complexity:\\nO(m*n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int i,j,m=mat.size(),n=mat[0].size();\\n        vector<vector<int>> v(m*n);\\n        vector<int> r(m,0),c(n,0);\\n        for(i = 0; i < m; i++){\\n            for(j = 0; j < n; j++){\\n                v[mat[i][j]-1] = {i,j};\\n            }\\n        }\\n        for(i = 0; i < m*n; i++){\\n            r[v[arr[i]-1][0]]++;\\n            c[v[arr[i]-1][1]]++;\\n            // cout<<arr[i]<<\" \"<<v[arr[i]-1][0]<<\" \"<<v[arr[i]-1][1]<<\" \"<<r[v[arr[i]-1][0]]<<\" \"<<c[v[arr[i]-1][1]]<<endl;\\n            if(r[v[arr[i]-1][0]] == n)return i;\\n            if(c[v[arr[i]-1][1]] == m)return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int i,j,m=mat.size(),n=mat[0].size();\\n        vector<vector<int>> v(m*n);\\n        vector<int> r(m,0),c(n,0);\\n        for(i = 0; i < m; i++){\\n            for(j = 0; j < n; j++){\\n                v[mat[i][j]-1] = {i,j};\\n            }\\n        }\\n        for(i = 0; i < m*n; i++){\\n            r[v[arr[i]-1][0]]++;\\n            c[v[arr[i]-1][1]]++;\\n            // cout<<arr[i]<<\" \"<<v[arr[i]-1][0]<<\" \"<<v[arr[i]-1][1]<<\" \"<<r[v[arr[i]-1][0]]<<\" \"<<c[v[arr[i]-1][1]]<<endl;\\n            if(r[v[arr[i]-1][0]] == n)return i;\\n            if(c[v[arr[i]-1][1]] == m)return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3472180,
                "title": "brute-force-to-optimal-easy-to-understand",
                "content": "```\\n//Brute Force :-  O(n^2) (will give TLE)\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int m=mat.size(), n=mat[0].size(), size=arr.size(), idx=0;\\n        unordered_set<int>st;\\n        unordered_map<int, pair<int,int>>mp;\\n        \\n         for(int i=0;i<m;i++) {\\n             for(int j=0;j<n;j++) {\\n                    mp[mat[i][j]]={i,j};\\n                }\\n         }\\n        while(idx < size) {\\n            st.insert(arr[idx]);\\n            auto it = mp.find(arr[idx]);\\n            int i=(it->second).first, j=(it->second).second;\\n            bool valid1=true,valid2=true;\\n                \\n            for(int col=0;col<n;col++) {\\n                if(st.find(mat[i][col]) == st.end()) {\\n                     valid1=false;\\n                    break;\\n                }\\n\\n            }\\n            \\n            for(int row=0;row<m;row++) {\\n                if(st.find(mat[row][j]) == st.end()) {\\n                    valid2=false;\\n                    break;\\n                }\\n\\n            }\\n            if(valid2 || valid1)return idx;\\n\\n                idx++;\\n        }\\n        return -1;\\n    }\\n};\\n\\n//Optimal :-  O(m*n)\\n\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        unordered_map<int,int>mp;\\n        int maxIdx = 0, m = mat.size(), n = mat[0].size(), res = INT_MAX;\\n        for(int i=0;i<arr.size();i++)\\n            mp[arr[i]]=i;\\n        \\n        for(int i=0;i<m;i++) {\\n            maxIdx = 0;\\n            for(int j=0;j<n;j++) {\\n                maxIdx = max(maxIdx, mp[mat[i][j]]);\\n            }\\n            res = min(res, maxIdx);\\n        }\\n         for(int i=0;i<n;i++) {\\n            maxIdx = 0;\\n            for(int j=0;j<m;j++) {\\n                maxIdx = max(maxIdx, mp[mat[j][i]]);\\n            }\\n            res = min(res, maxIdx);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n//Brute Force :-  O(n^2) (will give TLE)\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int m=mat.size(), n=mat[0].size(), size=arr.size(), idx=0;\\n        unordered_set<int>st;\\n        unordered_map<int, pair<int,int>>mp;\\n        \\n         for(int i=0;i<m;i++) {\\n             for(int j=0;j<n;j++) {\\n                    mp[mat[i][j]]={i,j};\\n                }\\n         }\\n        while(idx < size) {\\n            st.insert(arr[idx]);\\n            auto it = mp.find(arr[idx]);\\n            int i=(it->second).first, j=(it->second).second;\\n            bool valid1=true,valid2=true;\\n                \\n            for(int col=0;col<n;col++) {\\n                if(st.find(mat[i][col]) == st.end()) {\\n                     valid1=false;\\n                    break;\\n                }\\n\\n            }\\n            \\n            for(int row=0;row<m;row++) {\\n                if(st.find(mat[row][j]) == st.end()) {\\n                    valid2=false;\\n                    break;\\n                }\\n\\n            }\\n            if(valid2 || valid1)return idx;\\n\\n                idx++;\\n        }\\n        return -1;\\n    }\\n};\\n\\n//Optimal :-  O(m*n)\\n\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        unordered_map<int,int>mp;\\n        int maxIdx = 0, m = mat.size(), n = mat[0].size(), res = INT_MAX;\\n        for(int i=0;i<arr.size();i++)\\n            mp[arr[i]]=i;\\n        \\n        for(int i=0;i<m;i++) {\\n            maxIdx = 0;\\n            for(int j=0;j<n;j++) {\\n                maxIdx = max(maxIdx, mp[mat[i][j]]);\\n            }\\n            res = min(res, maxIdx);\\n        }\\n         for(int i=0;i<n;i++) {\\n            maxIdx = 0;\\n            for(int j=0;j<m;j++) {\\n                maxIdx = max(maxIdx, mp[mat[j][i]]);\\n            }\\n            res = min(res, maxIdx);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468333,
                "title": "java-simple-solution",
                "content": "# Complexity\\n- Time complexity: $$O(m*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m*n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int firstCompleteIndex(int[] arr, int[][] mat) {\\n    var m = mat.length;\\n    var n = mat[0].length;\\n    \\n    var rows = new int[m];\\n    var cols = new int[n];\\n    \\n    var map = new int[m*n][2];\\n    \\n    for (var i=0; i<m; i++) {\\n      for (var j=0; j<n; j++) {\\n        var a = mat[i][j] - 1;\\n\\n        map[a][0] = i;\\n        map[a][1] = j;\\n      }\\n    }\\n    for (var i=0; i < arr.length; i++) {\\n      var a = arr[i] - 1;\\n\\n      rows[map[a][0]]++;\\n      cols[map[a][1]]++;\\n      \\n      if (rows[map[a][0]] == n || cols[map[a][1]] == m)\\n        return i;\\n    }    \\n    return m*n;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int firstCompleteIndex(int[] arr, int[][] mat) {\\n    var m = mat.length;\\n    var n = mat[0].length;\\n    \\n    var rows = new int[m];\\n    var cols = new int[n];\\n    \\n    var map = new int[m*n][2];\\n    \\n    for (var i=0; i<m; i++) {\\n      for (var j=0; j<n; j++) {\\n        var a = mat[i][j] - 1;\\n\\n        map[a][0] = i;\\n        map[a][1] = j;\\n      }\\n    }\\n    for (var i=0; i < arr.length; i++) {\\n      var a = arr[i] - 1;\\n\\n      rows[map[a][0]]++;\\n      cols[map[a][1]]++;\\n      \\n      if (rows[map[a][0]] == n || cols[map[a][1]] == m)\\n        return i;\\n    }    \\n    return m*n;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3660761,
                "title": "unordered-map-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThink brute force, but optimize brute force by tracking colored cells using a hash table.\\n# Complexity\\n- Time complexity:O(N*M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N*M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int n,m;\\n    unordered_map<int,pair<int,int>> pos;\\n    unordered_map<int,int> rows,cols;\\n\\n    bool fillup(int x,int y)\\n    {\\n        rows[x]++;\\n        cols[y]++;\\n\\n        if(rows[x]>=m || cols[y]>=n)\\n        return true;\\n\\n        return false;\\n    }\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        n = mat.size(),m = mat[0].size();\\n\\n        for(int i = 0;i<n;i++)\\n        {\\n            for(int j = 0;j<m;j++)\\n            pos[mat[i][j]] = {i,j};\\n        }\\n\\n        for(int i = 0;i<arr.size();i++)\\n        {\\n            int x = pos[arr[i]].first,y = pos[arr[i]].second;\\n\\n            if(fillup(x,y))\\n            return i;\\n        }\\n        return 0;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/8592f1f7-c3a8-4941-8061-974069f1178b_1687252161.7047396.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int n,m;\\n    unordered_map<int,pair<int,int>> pos;\\n    unordered_map<int,int> rows,cols;\\n\\n    bool fillup(int x,int y)\\n    {\\n        rows[x]++;\\n        cols[y]++;\\n\\n        if(rows[x]>=m || cols[y]>=n)\\n        return true;\\n\\n        return false;\\n    }\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        n = mat.size(),m = mat[0].size();\\n\\n        for(int i = 0;i<n;i++)\\n        {\\n            for(int j = 0;j<m;j++)\\n            pos[mat[i][j]] = {i,j};\\n        }\\n\\n        for(int i = 0;i<arr.size();i++)\\n        {\\n            int x = pos[arr[i]].first,y = pos[arr[i]].second;\\n\\n            if(fillup(x,y))\\n            return i;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469348,
                "title": "accepted-c-solution-with-complete-explanation-using-map-100-successful",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, we store all the elements of $$mat$$ in $$map$$ with its elements as key and their indexes as value. (We are storing to reduce the search complexity in matrix).\\n\\nWe create two more vector to store the count of the elements painted in the particular column and row. We named the vector as $$rowCount$$ and $$colCount$$.\\n\\nNow, we traversal through the $$arr$$ and check the row and column of that element in $$mat$$ using the $$map$$ we created.\\n\\nNow, further we increment the colCount for columnIndex and rowCount for the rowIndex respectively.\\n\\nNext, we check if the $$colCount$$ is at its max (the max of column can be the number of the i.e $$n$$). Incase, we set the value of $$ans$$ variable as the current Index and break the loop.\\nSimilarly, we check for $$rowCount$$ (for row max count will be the number of column i.e $$m$$).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nFirst, $$O(n*m)$$ for storing elements and their corresponding indexes in map. Second, $$O(n*m)$$ for traversing of arr.\\nSo, overall time complexity is:\\n$$O(2*n*m)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n*m)$$ for map\\n$$O(n)$$ for rowCount.\\n$$O(m)$$ for colCount.\\nSo, overall space complexity is:\\n$$O(n*m + (n+m))$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        map<int,pair<int,int>> mp;\\n        for(int i= 0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                mp[mat[i][j]] = {i,j};\\n            }\\n        }\\n        \\n        vector<int> colCount(m,0);\\n        vector<int> rowCount(n,0);\\n        int ans = INT_MAX;\\n        for(int i = 0; i<m*n; i++){\\n            auto pr = mp[arr[i]];\\n            colCount[pr.second]++;\\n            rowCount[pr.first]++;\\n        \\n            if(colCount[pr.second] == n && ans > i){\\n                ans = i;\\n                break;\\n            }\\n            \\n            if(rowCount[pr.first] == m && ans > i){\\n                ans = i;\\n                break;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        map<int,pair<int,int>> mp;\\n        for(int i= 0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                mp[mat[i][j]] = {i,j};\\n            }\\n        }\\n        \\n        vector<int> colCount(m,0);\\n        vector<int> rowCount(n,0);\\n        int ans = INT_MAX;\\n        for(int i = 0; i<m*n; i++){\\n            auto pr = mp[arr[i]];\\n            colCount[pr.second]++;\\n            rowCount[pr.first]++;\\n        \\n            if(colCount[pr.second] == n && ans > i){\\n                ans = i;\\n                break;\\n            }\\n            \\n            if(rowCount[pr.first] == m && ans > i){\\n                ans = i;\\n                break;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468348,
                "title": "easy-to-understand-c-simple-solution",
                "content": "````\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int a = mat.size(),b = mat[0].size(),c = arr.size();\\n        vector<int> r1(a,0),c1(b,0);\\n        vector<vector<int>> ind(a*b+1);\\n        for(int i = 0; i < a; i++){\\n            for(int j = 0; j < b; j++){\\n                ind[mat[i][j]] = {i,j};\\n            }\\n        }\\n        // for(int k = 0; k < c; k++){\\n        //     cout<<arr[k]<<\" \"<<ind[arr[k]][0]<<\" \"<<ind[arr[k]][1]<<endl;\\n        // }\\n        for(int k = 0; k < c; k++){\\n            r1[ind[arr[k]][0]]++;\\n            c1[ind[arr[k]][1]]++;\\n            // cout<<arr[k]<<\" \"<<ind[arr[k]][0]<<\" \"<<r1[ind[arr[k]][0]]<<\" \"<<ind[arr[k]][1]<<\" \"<<c1[ind[arr[k]][1]]<<endl;\\n            if(r1[ind[arr[k]][0]]==b)return k;\\n            if(c1[ind[arr[k]][1]]==a)return k;\\n        }\\n        return -1;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int a = mat.size(),b = mat[0].size(),c = arr.size();\\n        vector<int> r1(a,0),c1(b,0);\\n        vector<vector<int>> ind(a*b+1);\\n        for(int i = 0; i < a; i++){\\n            for(int j = 0; j < b; j++){\\n                ind[mat[i][j]] = {i,j};\\n            }\\n        }\\n        // for(int k = 0; k < c; k++){\\n        //     cout<<arr[k]<<\" \"<<ind[arr[k]][0]<<\" \"<<ind[arr[k]][1]<<endl;\\n        // }\\n        for(int k = 0; k < c; k++){\\n            r1[ind[arr[k]][0]]++;\\n            c1[ind[arr[k]][1]]++;\\n            // cout<<arr[k]<<\" \"<<ind[arr[k]][0]<<\" \"<<r1[ind[arr[k]][0]]<<\" \"<<ind[arr[k]][1]<<\" \"<<c1[ind[arr[k]][1]]<<endl;\\n            if(r1[ind[arr[k]][0]]==b)return k;\\n            if(c1[ind[arr[k]][1]]==a)return k;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3468331,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int r = mat.size(),c= mat[0].size();\\n        vector<pair<int,int> > ind(r*c+1);\\n        \\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n                ind[mat[i][j]] = {i,j};\\n            }\\n        }\\n        \\n        vector<int> szRow(r),szCol(c);\\n        for(int i=0;i<r*c;i++){\\n            int num = arr[i];\\n            int x= ind[num].first,y=ind[num].second;\\n            \\n            szRow[x]++;\\n            szCol[y]++;\\n            if(szRow[x] == c || szCol[y] == r)\\n                return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int r = mat.size(),c= mat[0].size();\\n        vector<pair<int,int> > ind(r*c+1);\\n        \\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n                ind[mat[i][j]] = {i,j};\\n            }\\n        }\\n        \\n        vector<int> szRow(r),szCol(c);\\n        for(int i=0;i<r*c;i++){\\n            int num = arr[i];\\n            int x= ind[num].first,y=ind[num].second;\\n            \\n            szRow[x]++;\\n            szCol[y]++;\\n            if(szRow[x] == c || szCol[y] == r)\\n                return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3541615,
                "title": "o-m-n-time-o-m-n-space-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        unordered_map<int,int> mp;\\n        for(int i = 0;i < arr.size();i++)\\n            mp[arr[i]] = i;\\n\\n        int ans = 1e9,temp = -1;\\n        for(int r = 0;r < mat.size();r++){\\n            temp = -1;\\n            for(int c = 0;c < mat[0].size();c++){\\n                temp  = max({temp,mp[mat[r][c]]});\\n            }\\n            ans = min(temp,ans);\\n        }\\n        for(int r = 0;r < mat[0].size();r++){\\n            temp = -1;\\n            for(int c = 0;c < mat.size();c++){\\n                temp  = max({temp,mp[mat[c][r]]});\\n            }\\n            ans = min(temp,ans);\\n        }\\n        return ans;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        unordered_map<int,int> mp;\\n        for(int i = 0;i < arr.size();i++)\\n            mp[arr[i]] = i;\\n\\n        int ans = 1e9,temp = -1;\\n        for(int r = 0;r < mat.size();r++){\\n            temp = -1;\\n            for(int c = 0;c < mat[0].size();c++){\\n                temp  = max({temp,mp[mat[r][c]]});\\n            }\\n            ans = min(temp,ans);\\n        }\\n        for(int r = 0;r < mat[0].size();r++){\\n            temp = -1;\\n            for(int c = 0;c < mat.size();c++){\\n                temp  = max({temp,mp[mat[c][r]]});\\n            }\\n            ans = min(temp,ans);\\n        }\\n        return ans;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519669,
                "title": "scala-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n  def firstCompleteIndex(arr: Array[Int], mat: Array[Array[Int]]): Int = {\\n    val all = arr.zipWithIndex.toMap\\n    val cols = mat.map(_.map(all.getOrElse(_, Int.MaxValue)).max)\\n    val rows = mat.transpose.map(_.map(all.getOrElse(_, Int.MaxValue)).max)\\n    cols.min min rows.min\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def firstCompleteIndex(arr: Array[Int], mat: Array[Array[Int]]): Int = {\\n    val all = arr.zipWithIndex.toMap\\n    val cols = mat.map(_.map(all.getOrElse(_, Int.MaxValue)).max)\\n    val rows = mat.transpose.map(_.map(all.getOrElse(_, Int.MaxValue)).max)\\n    cols.min min rows.min\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3495481,
                "title": "binbin-s-knight-taught-her-very-well",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        i = 0\\n        m = len(mat)\\n        n = len(mat[0])\\n       \\n        mark_r = [0 for i in range(m)]\\n        mark_c =  [0 for i in range(n)]\\n        mapping = {}\\n        \\n        for j in range (m*n):\\n            mapping.update({mat[j//n][j%n]: [j//n,j%n]})\\n  \\n        while i in range(m*n):\\n           \\n            mark_r[mapping[arr[i]][0]] += 1\\n            if mark_r[mapping[arr[i]][0]] ==n:\\n                return i\\n            mark_c[mapping[arr[i]][1]] += 1\\n            if mark_c[mapping[arr[i]][1]] == m:\\n                return i\\n\\n            \\n            i += 1\\n            \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        i = 0\\n        m = len(mat)\\n        n = len(mat[0])\\n       \\n        mark_r = [0 for i in range(m)]\\n        mark_c =  [0 for i in range(n)]\\n        mapping = {}\\n        \\n        for j in range (m*n):\\n            mapping.update({mat[j//n][j%n]: [j//n,j%n]})\\n  \\n        while i in range(m*n):\\n           \\n            mark_r[mapping[arr[i]][0]] += 1\\n            if mark_r[mapping[arr[i]][0]] ==n:\\n                return i\\n            mark_c[mapping[arr[i]][1]] += 1\\n            if mark_c[mapping[arr[i]][1]] == m:\\n                return i\\n\\n            \\n            i += 1\\n            \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3479637,
                "title": "c-brute-force-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n*m)$$\\n\\n- Space complexity:$$O(n)+O(m)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        map<int, int>m1, m2;\\n        vector<int>v1(mat.size(), 0), v2(mat[0].size(), 0);\\n        for(int i=0; i<mat.size(); i++){\\n            for(int j=0; j<mat[0].size(); j++){\\n                m1[mat[i][j]]=i;\\n                m2[mat[i][j]]=j;\\n            }\\n        }\\n        for(int i=0; i<arr.size(); i++){\\n            v1[m1[arr[i]]]++;\\n            v2[m2[arr[i]]]++;\\n            if(v1[m1[arr[i]]]==mat[0].size() || v2[m2[arr[i]]]==mat.size()){return i;}\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        map<int, int>m1, m2;\\n        vector<int>v1(mat.size(), 0), v2(mat[0].size(), 0);\\n        for(int i=0; i<mat.size(); i++){\\n            for(int j=0; j<mat[0].size(); j++){\\n                m1[mat[i][j]]=i;\\n                m2[mat[i][j]]=j;\\n            }\\n        }\\n        for(int i=0; i<arr.size(); i++){\\n            v1[m1[arr[i]]]++;\\n            v2[m2[arr[i]]]++;\\n            if(v1[m1[arr[i]]]==mat[0].size() || v2[m2[arr[i]]]==mat.size()){return i;}\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478095,
                "title": "go-easy-to-understand-solution",
                "content": "# Intuition\\nKeep track of each row and col to remaining unpainted count, num2pos keep track each number to its position in mat, use number to represent the position row * colLen + col.\\n\\n# Approach\\nscan through arr and find element position in mat, reduce row2cnt and col2cnt until find first row or col remaining count to be 0, then it means the row or col has been painted.\\n\\n# Complexity\\n- Time complexity:\\nO(m * n) where m is the mat row len, n is col len\\n\\n- Space complexity:\\nO(m * n) where m is the mat row len, n is col len\\n\\n# Code\\n```\\nfunc firstCompleteIndex(arr []int, mat [][]int) int {\\n    m, n := len(mat), len(mat[0])\\n    row2cnt := make([]int, m)\\n    col2cnt := make([]int, n)\\n    for i := range row2cnt {\\n        row2cnt[i] = n\\n    }\\n    for j := range col2cnt {\\n        col2cnt[j] = m\\n    }\\n    num2pos := make([]int, m * n + 1)\\n    for i := 0; i < m; i++ {\\n        for j := 0; j < n; j++ {\\n            num2pos[mat[i][j]] = i * n + j\\n        }\\n    }\\n    for i, v := range arr {\\n        pos := num2pos[v]\\n        r, c := pos / n, pos % n\\n        row2cnt[r]--\\n        col2cnt[c]--\\n        if row2cnt[r] == 0 || col2cnt[c] == 0 {\\n            return i\\n        }\\n    }\\n    return -1\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc firstCompleteIndex(arr []int, mat [][]int) int {\\n    m, n := len(mat), len(mat[0])\\n    row2cnt := make([]int, m)\\n    col2cnt := make([]int, n)\\n    for i := range row2cnt {\\n        row2cnt[i] = n\\n    }\\n    for j := range col2cnt {\\n        col2cnt[j] = m\\n    }\\n    num2pos := make([]int, m * n + 1)\\n    for i := 0; i < m; i++ {\\n        for j := 0; j < n; j++ {\\n            num2pos[mat[i][j]] = i * n + j\\n        }\\n    }\\n    for i, v := range arr {\\n        pos := num2pos[v]\\n        r, c := pos / n, pos % n\\n        row2cnt[r]--\\n        col2cnt[c]--\\n        if row2cnt[r] == 0 || col2cnt[c] == 0 {\\n            return i\\n        }\\n    }\\n    return -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3475169,
                "title": "python-counter-of-x-y-axes",
                "content": "```python\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        h, w = len(mat), len(mat[0])\\n        \\n        d = {}\\n        for y in range(h):\\n            for x in range(w):\\n                d[mat[y][x]] = (y, x)\\n        \\n        x_axis, y_axis = defaultdict(int), defaultdict(int)\\n\\n        for i, n in enumerate(arr):\\n            y, x = d[n]\\n            \\n            y_axis[y] += 1\\n            x_axis[x] += 1\\n\\n            if y_axis[y] == w or x_axis[x] == h:\\n                return i\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        h, w = len(mat), len(mat[0])\\n        \\n        d = {}\\n        for y in range(h):\\n            for x in range(w):\\n                d[mat[y][x]] = (y, x)\\n        \\n        x_axis, y_axis = defaultdict(int), defaultdict(int)\\n\\n        for i, n in enumerate(arr):\\n            y, x = d[n]\\n            \\n            y_axis[y] += 1\\n            x_axis[x] += 1\\n\\n            if y_axis[y] == w or x_axis[x] == h:\\n                return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3474742,
                "title": "c-easy-solution-with-explanation-hashtable-counting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo avoid repeatedly traversing the matrix, we can optimize the process by first traversing the matrix once and recording the position of each number in an unordered map. \\n\\nThen, we can traverse the array and for each index, we can look up the position of the corresponding number in the map. By subtracting 1 from the corresponding row and column in the matrix, we can keep track of which rows and columns have already been used. For example, if the number 3 is at mat[r][c], we would do rows[r]-- and cols[c]--. This is because we want to update the rows and columns to indicate that a column has been used in the \"row r\". \\n\\nInitially, each \"row r\" will have m columns available, but once rows[r] reaches 0, it means that the row has been occupied. We can then find the index to return, which is the same process we use for the columns.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMap + Count\\n# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n*m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int R = mat.size();\\n        int C = mat[0].size();\\n        \\n        vector<int> rows(R, C);\\n        vector<int> cols(C, R);\\n        unordered_map<int, pair<int,int>> Map;\\n        \\n        for(int i=0; i<R; i++){\\n            for(int j=0; j<C; j++){\\n                Map[mat[i][j]] = {i,j};\\n            }\\n        }\\n        \\n        \\n        for(int i=0; i<arr.size(); i++){\\n            auto [r,c] = Map[arr[i]]; \\n            \\n            rows[r]--;\\n            cols[c]--;\\n            if(rows[r]==0 || cols[c]==0){\\n                return i;\\n            }\\n        }\\n        \\n        return -1;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int R = mat.size();\\n        int C = mat[0].size();\\n        \\n        vector<int> rows(R, C);\\n        vector<int> cols(C, R);\\n        unordered_map<int, pair<int,int>> Map;\\n        \\n        for(int i=0; i<R; i++){\\n            for(int j=0; j<C; j++){\\n                Map[mat[i][j]] = {i,j};\\n            }\\n        }\\n        \\n        \\n        for(int i=0; i<arr.size(); i++){\\n            auto [r,c] = Map[arr[i]]; \\n            \\n            rows[r]--;\\n            cols[c]--;\\n            if(rows[r]==0 || cols[c]==0){\\n                return i;\\n            }\\n        }\\n        \\n        return -1;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3473725,
                "title": "hashmap-easy-to-understand-must-see",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) \\n\\t{\\n\\t\\t//preprocessing \\n\\t\\tunordered_map<int,pair<int,int>>mp;\\n\\t\\tfor(int i=0;i<mat.size();i++)\\n\\t\\t{\\n\\t\\t\\tfor(int j=0;j<mat[i].size();j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmp[mat[i][j]] = make_pair(i,j);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n        int n = mat.size();\\n\\t\\tint m = mat[0].size();\\n\\t\\t\\n\\t\\tunordered_map<int,int>mp_row;   //to keep the track of the painted row\\n\\t\\tunordered_map<int,int>mp_col;   //to keep the track of the painted col\\n\\t\\t\\n\\t\\tfor(int i=0;i<arr.size();i++)\\n\\t\\t{\\n\\t\\t\\tint val = arr[i];\\n\\t\\t    int row = mp[val].first;\\n\\t\\t    int col = mp[val].second;\\n\\t\\t    \\n\\t\\t    mp_row[row]++;\\n\\t\\t    if(mp_row[row] == m) return i;\\n\\t\\t    \\n\\t\\t    mp_col[col]++;\\n\\t\\t    if(mp_col[col] == n) return i;\\n\\t\\t}\\n\\t\\treturn -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) \\n\\t{\\n\\t\\t//preprocessing \\n\\t\\tunordered_map<int,pair<int,int>>mp;\\n\\t\\tfor(int i=0;i<mat.size();i++)\\n\\t\\t{\\n\\t\\t\\tfor(int j=0;j<mat[i].size();j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmp[mat[i][j]] = make_pair(i,j);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n        int n = mat.size();\\n\\t\\tint m = mat[0].size();\\n\\t\\t\\n\\t\\tunordered_map<int,int>mp_row;   //to keep the track of the painted row\\n\\t\\tunordered_map<int,int>mp_col;   //to keep the track of the painted col\\n\\t\\t\\n\\t\\tfor(int i=0;i<arr.size();i++)\\n\\t\\t{\\n\\t\\t\\tint val = arr[i];\\n\\t\\t    int row = mp[val].first;\\n\\t\\t    int col = mp[val].second;\\n\\t\\t    \\n\\t\\t    mp_row[row]++;\\n\\t\\t    if(mp_row[row] == m) return i;\\n\\t\\t    \\n\\t\\t    mp_col[col]++;\\n\\t\\t    if(mp_col[col] == n) return i;\\n\\t\\t}\\n\\t\\treturn -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3473019,
                "title": "java-hashing-unoptimized-optimized-2-approaches-easy",
                "content": "\\nUnoptimized but still works\\n# Complexity\\n- Time complexity:O(k*m*n)\\n- Where k is the number of operation required to make one wall to be colored\\n- m is number of rows\\n- n is number of columns\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(m)+O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int ind=0;\\n        int m=mat.length,n=mat[0].length;\\n        int row[]=new int[m];\\n        int col[]=new int[n];\\n        boolean flag=true;;\\n        while(flag){\\n            int i=0;\\n            for(i=0;i<m;i++){\\n                int j=0;\\n                for(j=0;j<n;j++){\\n                    if(mat[i][j]==arr[ind]){\\n                        ind++;\\n                        row[i]++;\\n                        col[j]++;\\n                    }\\n                    if(row[i]==n || col[j]==m){\\n                        flag=false;\\n                        break;\\n                    }\\n                }\\n                if(!flag)   break;\\n            }\\n        }\\n       return ind-1;\\n    }\\n}\\n```\\nOptimized Version of the same:\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- m is number of rows\\n- n is number of columns\\n- Space complexity:O(m)+O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        HashMap<Integer,int[]>hm=new HashMap<>();\\n        for(int i=0;i<mat.length;i++){\\n            for(int j=0;j<mat[0].length;j++){\\n                hm.put(mat[i][j],new int[]{i,j});\\n            }\\n        }\\n        int row[]=new int[mat.length];\\n        int col[]=new int[mat[0].length];\\n        int i=0;\\n        for(i=0;i<arr.length;i++){\\n            int curr[]=hm.get(arr[i]);\\n            row[curr[0]]++;\\n            col[curr[1]]++;\\n            if(row[curr[0]]==mat[0].length ||\\n                col[curr[1]]==mat.length){\\n                    break;\\n            }\\n        }\\n        return i;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int ind=0;\\n        int m=mat.length,n=mat[0].length;\\n        int row[]=new int[m];\\n        int col[]=new int[n];\\n        boolean flag=true;;\\n        while(flag){\\n            int i=0;\\n            for(i=0;i<m;i++){\\n                int j=0;\\n                for(j=0;j<n;j++){\\n                    if(mat[i][j]==arr[ind]){\\n                        ind++;\\n                        row[i]++;\\n                        col[j]++;\\n                    }\\n                    if(row[i]==n || col[j]==m){\\n                        flag=false;\\n                        break;\\n                    }\\n                }\\n                if(!flag)   break;\\n            }\\n        }\\n       return ind-1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        HashMap<Integer,int[]>hm=new HashMap<>();\\n        for(int i=0;i<mat.length;i++){\\n            for(int j=0;j<mat[0].length;j++){\\n                hm.put(mat[i][j],new int[]{i,j});\\n            }\\n        }\\n        int row[]=new int[mat.length];\\n        int col[]=new int[mat[0].length];\\n        int i=0;\\n        for(i=0;i<arr.length;i++){\\n            int curr[]=hm.get(arr[i]);\\n            row[curr[0]]++;\\n            col[curr[1]]++;\\n            if(row[curr[0]]==mat[0].length ||\\n                col[curr[1]]==mat.length){\\n                    break;\\n            }\\n        }\\n        return i;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470232,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        m = {}\\n        r,c = len(mat),len(mat[0])\\n        for i,n in enumerate(arr):\\n            m[n] = i\\n        ans=1000000000\\n        for i in range(r):\\n            curminind = 0\\n            for j in range(c):\\n                curminind = max(curminind , m[mat[i][j]])\\n            ans = min(ans , curminind)\\n        for i in range(c):\\n            curminind = 0\\n            for j in range(r):\\n                curminind = max(curminind , m[mat[j][i]])\\n            ans = min(ans , curminind)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        m = {}\\n        r,c = len(mat),len(mat[0])\\n        for i,n in enumerate(arr):\\n            m[n] = i\\n        ans=1000000000\\n        for i in range(r):\\n            curminind = 0\\n            for j in range(c):\\n                curminind = max(curminind , m[mat[i][j]])\\n            ans = min(ans , curminind)\\n        for i in range(c):\\n            curminind = 0\\n            for j in range(r):\\n                curminind = max(curminind , m[mat[j][i]])\\n            ans = min(ans , curminind)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469856,
                "title": "c-solution-using-hashing-easy-solution",
                "content": "# Intuition\\n**Store the element row and column in a map and then make a vector of size of column and row and fill it with zero. Now iterarte through the given array and check for column and row in map. Increment the count of column and row by one. Now check if count of that particular column is equal to row or count of that particular row is equal to column. If it is true then return the index of array else continue the loop.**\\n\\n\\n# Complexity\\n- Time complexity: O(m*n)\\n- Space complexity:O(m*n)+ O(m) + O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        unordered_map<int,pair<int,int>> mp;\\n        vector<int> row(n+1,0);\\n        vector<int> col(m+1,0);\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=0;j<m;j++)\\n                {\\n                    mp[mat[i][j]]={i,j};\\n                }\\n            }\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            row[mp[arr[i]].first]++;\\n            col[mp[arr[i]].second]++;\\n            if(row[mp[arr[i]].first]==m) return i;\\n            if( col[mp[arr[i]].second]==n) return i;\\n            \\n        }\\n        return -1;\\n    }\\n};\\n```\\n![7dr99c.jpg](https://assets.leetcode.com/users/images/70a88c3f-e92d-4a88-bd24-3535f3bc09be_1682857653.6323266.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        unordered_map<int,pair<int,int>> mp;\\n        vector<int> row(n+1,0);\\n        vector<int> col(m+1,0);\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=0;j<m;j++)\\n                {\\n                    mp[mat[i][j]]={i,j};\\n                }\\n            }\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            row[mp[arr[i]].first]++;\\n            col[mp[arr[i]].second]++;\\n            if(row[mp[arr[i]].first]==m) return i;\\n            if( col[mp[arr[i]].second]==n) return i;\\n            \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469674,
                "title": "java-beats-100-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int[] counterForRow = new int[mat.length];\\n        int[] counterForColumn = new int[mat[0].length];\\n            \\n        Map<Integer, Integer> rowOfNumber = new HashMap<>();\\n        Map<Integer, Integer> colOfNumber = new HashMap<>();\\n        \\n        for(int i = 0; i < mat.length; i++) {\\n            for(int j = 0; j < mat[0].length; j++) {\\n                rowOfNumber.put(mat[i][j], i);\\n                colOfNumber.put(mat[i][j], j);\\n            }\\n        }\\n        \\n        for(int i = 0; i < arr.length; i++) {\\n            int row = rowOfNumber.get(arr[i]);\\n            int col = colOfNumber.get(arr[i]);\\n            \\n            counterForRow[row]++;\\n            counterForColumn[col]++;\\n            \\n            if(counterForRow[row] == mat[0].length || counterForColumn[col] == mat.length) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int[] counterForRow = new int[mat.length];\\n        int[] counterForColumn = new int[mat[0].length];\\n            \\n        Map<Integer, Integer> rowOfNumber = new HashMap<>();\\n        Map<Integer, Integer> colOfNumber = new HashMap<>();\\n        \\n        for(int i = 0; i < mat.length; i++) {\\n            for(int j = 0; j < mat[0].length; j++) {\\n                rowOfNumber.put(mat[i][j], i);\\n                colOfNumber.put(mat[i][j], j);\\n            }\\n        }\\n        \\n        for(int i = 0; i < arr.length; i++) {\\n            int row = rowOfNumber.get(arr[i]);\\n            int col = colOfNumber.get(arr[i]);\\n            \\n            counterForRow[row]++;\\n            counterForColumn[col]++;\\n            \\n            if(counterForRow[row] == mat[0].length || counterForColumn[col] == mat.length) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469668,
                "title": "simple-easy-approach-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& matrix) {\\n        int m= matrix.size();\\n        int n= matrix[0].size();\\n        int t= arr.size();\\n        int ans= m*n-1;\\n        \\n        unordered_map<int, int>mp;\\n        for(int i=0; i<t; i++) mp[arr[i]]=i; // store the index of arr element in map\\n        \\n        //row wise check \\n        for(int i=0; i<m; i++) {\\n            int rowmax=0; //  maximum index required (have to traverse) to color that full row\\n            for(int j=0; j<n; j++) {\\n                rowmax= max(rowmax, mp[matrix[i][j]]);\\n            }\\n            ans= min(ans, rowmax); \\n        }\\n        \\n        //column wise check\\n        for(int i=0; i<n; i++) {\\n            int colmax=0;\\n            for(int j=0; j<m; j++) {\\n                colmax= max(colmax, mp[matrix[j][i]]); //  maximum index required (have to traverse) to color that full col\\n            }\\n            ans= min(ans, colmax);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& matrix) {\\n        int m= matrix.size();\\n        int n= matrix[0].size();\\n        int t= arr.size();\\n        int ans= m*n-1;\\n        \\n        unordered_map<int, int>mp;\\n        for(int i=0; i<t; i++) mp[arr[i]]=i; // store the index of arr element in map\\n        \\n        //row wise check \\n        for(int i=0; i<m; i++) {\\n            int rowmax=0; //  maximum index required (have to traverse) to color that full row\\n            for(int j=0; j<n; j++) {\\n                rowmax= max(rowmax, mp[matrix[i][j]]);\\n            }\\n            ans= min(ans, rowmax); \\n        }\\n        \\n        //column wise check\\n        for(int i=0; i<n; i++) {\\n            int colmax=0;\\n            for(int j=0; j<m; j++) {\\n                colmax= max(colmax, mp[matrix[j][i]]); //  maximum index required (have to traverse) to color that full col\\n            }\\n            ans= min(ans, colmax);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469429,
                "title": "first-completely-painted-row-or-column-c-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        vector<int> I((m*n)+1,0);\\n        vector<int> J((m*n)+1,0);\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                I[mat[i][j]]=i;\\n                J[mat[i][j]]=j;\\n            }\\n        }\\n        \\n        map<int,int> row;\\n        map<int,int> col;\\n        \\n        for(int i=0;i<m*n;i++)\\n        {\\n            int num=arr[i];\\n            row[I[num]]++;\\n            col[J[num]]++;\\n           if(row[I[num]]==n||col[J[num]]==m)\\n           {\\n               return i;\\n           }\\n        }\\n        return m*n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        vector<int> I((m*n)+1,0);\\n        vector<int> J((m*n)+1,0);\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                I[mat[i][j]]=i;\\n                J[mat[i][j]]=j;\\n            }\\n        }\\n        \\n        map<int,int> row;\\n        map<int,int> col;\\n        \\n        for(int i=0;i<m*n;i++)\\n        {\\n            int num=arr[i];\\n            row[I[num]]++;\\n            col[J[num]]++;\\n           if(row[I[num]]==n||col[J[num]]==m)\\n           {\\n               return i;\\n           }\\n        }\\n        return m*n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469181,
                "title": "c-hash-table",
                "content": "# Complexity\\n- Time complexity:`O(n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:`O(n)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int row_Size , col_Size;\\n\\n    bool isFilled(vector<int>&rows,int curr_Row , vector<int>&columns , int curr_Col){\\n\\n        if(rows[curr_Row] == col_Size || columns[curr_Col] == row_Size) return true;\\n        return false;\\n        \\n    }\\n\\n    int firstCompleteIndex(vector<int>& nums, vector<vector<int>>& mat) {\\n        \\n        // length of 1D array\\n        int n = nums.size();\\n\\n\\n        // length of row & column in matrix\\n        row_Size = mat.size();\\n        col_Size = mat[0].size();\\n        \\n\\n        // vectors for tracking row & column are filled or not\\n        vector<int>rows(row_Size,0);\\n        vector<int>columns(col_Size,0);\\n        \\n\\n        // maps values with location in matrix\\n        unordered_map<int,pair<int,int>>mp;\\n        \\n\\n        for(int i=0;i<row_Size;i++){\\n            for(int j=0;j<col_Size;j++){\\n\\n                int value = mat[i][j];         // value\\n                pair<int,int>location = {i,j}; // location\\n\\n                mp[value] = location;          // mapping value with location\\n\\n            }\\n        }\\n        \\n\\n        for(int i=0;i<n;i++){\\n            \\n            int curr_Row = mp[nums[i]].first;  // getting current row\\n            int curr_Col = mp[nums[i]].second; // getting current column\\n            \\n            rows[curr_Row]++;    // filling current row \\n            columns[curr_Col]++; // filling current  column \\n            \\n            // return index if current row or column is filled\\n            if(isFilled(rows,curr_Row,columns,curr_Col)) return i;     \\n            \\n        }\\n        \\n        // dummy index\\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int row_Size , col_Size;\\n\\n    bool isFilled(vector<int>&rows,int curr_Row , vector<int>&columns , int curr_Col){\\n\\n        if(rows[curr_Row] == col_Size || columns[curr_Col] == row_Size) return true;\\n        return false;\\n        \\n    }\\n\\n    int firstCompleteIndex(vector<int>& nums, vector<vector<int>>& mat) {\\n        \\n        // length of 1D array\\n        int n = nums.size();\\n\\n\\n        // length of row & column in matrix\\n        row_Size = mat.size();\\n        col_Size = mat[0].size();\\n        \\n\\n        // vectors for tracking row & column are filled or not\\n        vector<int>rows(row_Size,0);\\n        vector<int>columns(col_Size,0);\\n        \\n\\n        // maps values with location in matrix\\n        unordered_map<int,pair<int,int>>mp;\\n        \\n\\n        for(int i=0;i<row_Size;i++){\\n            for(int j=0;j<col_Size;j++){\\n\\n                int value = mat[i][j];         // value\\n                pair<int,int>location = {i,j}; // location\\n\\n                mp[value] = location;          // mapping value with location\\n\\n            }\\n        }\\n        \\n\\n        for(int i=0;i<n;i++){\\n            \\n            int curr_Row = mp[nums[i]].first;  // getting current row\\n            int curr_Col = mp[nums[i]].second; // getting current column\\n            \\n            rows[curr_Row]++;    // filling current row \\n            columns[curr_Col]++; // filling current  column \\n            \\n            // return index if current row or column is filled\\n            if(isFilled(rows,curr_Row,columns,curr_Col)) return i;     \\n            \\n        }\\n        \\n        // dummy index\\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469082,
                "title": "go-my-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n.m)$$ \\n- Space complexity: $$O(n.m)$$ \\n\\n# Code\\n```\\nfunc firstCompleteIndex(arr []int, mat [][]int) int {\\n\\tn, m := len(mat), len(mat[0])\\n\\trow := make([]int, n)\\n\\tcol := make([]int, m)\\n\\thm := make(map[int][2]int)\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfor j := 0; j < m; j++ {\\n\\t\\t\\thm[mat[i][j]] = [2]int{i, j}\\n\\t\\t}\\n\\t}\\n\\n\\tfor i := 0; i < len(arr); i++ {\\n\\t\\tk := hm[arr[i]]\\n\\t\\trow[k[0]]++\\n\\t\\tif row[k[0]] == m {\\n\\t\\t\\treturn i\\n\\t\\t}\\n\\n\\t\\tcol[k[1]]++\\n\\t\\tif col[k[1]] == n {\\n\\t\\t\\treturn i\\n\\t\\t}\\n\\t}\\n\\treturn 0\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc firstCompleteIndex(arr []int, mat [][]int) int {\\n\\tn, m := len(mat), len(mat[0])\\n\\trow := make([]int, n)\\n\\tcol := make([]int, m)\\n\\thm := make(map[int][2]int)\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfor j := 0; j < m; j++ {\\n\\t\\t\\thm[mat[i][j]] = [2]int{i, j}\\n\\t\\t}\\n\\t}\\n\\n\\tfor i := 0; i < len(arr); i++ {\\n\\t\\tk := hm[arr[i]]\\n\\t\\trow[k[0]]++\\n\\t\\tif row[k[0]] == m {\\n\\t\\t\\treturn i\\n\\t\\t}\\n\\n\\t\\tcol[k[1]]++\\n\\t\\tif col[k[1]] == n {\\n\\t\\t\\treturn i\\n\\t\\t}\\n\\t}\\n\\treturn 0\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3468955,
                "title": "map-solution-for-c-explanation-complexity",
                "content": "# Approach\\nThe problem can be divided into two sub-problems:\\n1. How to find the value in the matrix in a fast way\\n2. How to understand that a row or column is completely painted\\n\\nSo,\\n1. To solve the first problem, we will create a dictionary with cell values as a key and row/column indices as a value. It will cost us some space, but it allows us to get information about the cell for O(1) time.\\n2. Create two arrays assigned for each rows/columns indices and  increase their values during traversal of the arr array.\\n\\nWhen we fill a row or column, we can return the result.\\n\\n# Complexity\\n- Time complexity: O(m*n)\\n- Space complexity: O(m*n)\\n\\n# Code\\n```\\npublic int FirstCompleteIndex(int[] arr, int[][] mat)\\n{\\n    var dict = new Dictionary<int, Tuple<int, int>>();\\n\\n    for (var i = 0; i < mat.Length; ++i)\\n    {\\n        for (var j = 0; j < mat[i].Length; ++j)\\n        {\\n            dict.Add(mat[i][j], new Tuple<int, int>(i, j));\\n        }\\n    }\\n\\n    if (dict.Count == 0)\\n    {\\n        return -1;\\n    }\\n\\n    var rows = new int[mat.Length];\\n    var cols = new int[mat[0].Length];\\n\\n    for (var i = 0; i < arr.Length; ++i)\\n    {\\n        var item = dict[arr[i]];\\n\\n        rows[item.Item1]++;\\n        cols[item.Item2]++;\\n        if (rows[item.Item1] == mat[0].Length || cols[item.Item2] == mat.Length)\\n        {\\n            return i;\\n        }\\n    }\\n\\n    return -1;\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic int FirstCompleteIndex(int[] arr, int[][] mat)\\n{\\n    var dict = new Dictionary<int, Tuple<int, int>>();\\n\\n    for (var i = 0; i < mat.Length; ++i)\\n    {\\n        for (var j = 0; j < mat[i].Length; ++j)\\n        {\\n            dict.Add(mat[i][j], new Tuple<int, int>(i, j));\\n        }\\n    }\\n\\n    if (dict.Count == 0)\\n    {\\n        return -1;\\n    }\\n\\n    var rows = new int[mat.Length];\\n    var cols = new int[mat[0].Length];\\n\\n    for (var i = 0; i < arr.Length; ++i)\\n    {\\n        var item = dict[arr[i]];\\n\\n        rows[item.Item1]++;\\n        cols[item.Item2]++;\\n        if (rows[item.Item1] == mat[0].Length || cols[item.Item2] == mat.Length)\\n        {\\n            return i;\\n        }\\n    }\\n\\n    return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3468950,
                "title": "simple-solution-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) \\n    {\\n        int m=mat.size();\\n        int n=mat[0].size();\\n      unordered_map<int,vector<int>>row;\\n      unordered_map<int,vector<int>>col;\\n      unordered_map<int,pair<int,int>>grid;\\n      \\nfor(int i=0;i<m;i++)\\n{\\nfor(int j=0;j<n;j++)\\n{\\n    grid[mat[i][j]]={i,j};\\n}\\n\\n}\\n\\nint ans=0;\\nfor(int i=0;i<m*n;i++)\\n{\\n    pair<int,int> p=grid[arr[i]];\\n    int r=p.first;\\n    int c=p.second;\\n    row[r].push_back(arr[i]);\\n    if(row[r].size()==n)\\n    {\\nans=i;\\n    break;\\n    }\\n    col[c].push_back(arr[i]);\\n    if(col[c].size()==m)\\n    {\\n        ans=i;\\n        break;\\n    }\\n\\n}\\nreturn ans;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) \\n    {\\n        int m=mat.size();\\n        int n=mat[0].size();\\n      unordered_map<int,vector<int>>row;\\n      unordered_map<int,vector<int>>col;\\n      unordered_map<int,pair<int,int>>grid;\\n      \\nfor(int i=0;i<m;i++)\\n{\\nfor(int j=0;j<n;j++)\\n{\\n    grid[mat[i][j]]={i,j};\\n}\\n\\n}\\n\\nint ans=0;\\nfor(int i=0;i<m*n;i++)\\n{\\n    pair<int,int> p=grid[arr[i]];\\n    int r=p.first;\\n    int c=p.second;\\n    row[r].push_back(arr[i]);\\n    if(row[r].size()==n)\\n    {\\nans=i;\\n    break;\\n    }\\n    col[c].push_back(arr[i]);\\n    if(col[c].size()==m)\\n    {\\n        ans=i;\\n        break;\\n    }\\n\\n}\\nreturn ans;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468788,
                "title": "explained-step-by-step-implementation",
                "content": "# Intuition\\n<!--  -->\\nUse maps to keep track of count for row and columns.\\n# Approach\\n<!--  -->\\n1. Consider two maps for tracking index of row and col of particular element in the matrix.\\n2. Consider two more maps to count the number of elements seen in a particular row or col.\\n3. Map the row and col for each element\\n4. Traverse arr and update row and col count\\n5. When `row count = colSize` or `col count = rowSize` return the current idx `i`.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     \\nint firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n    int rowSize = mat.size();\\n    int colSize = mat[0].size();\\n    unordered_map<int, int> rowIdx, colIdx, rowCount, colCount;\\n\\n    for(int i = 0; i < mat.size(); i++){\\n        for(int j = 0; j< mat[0].size(); ++j){\\n            int matEle = mat[i][j];\\n            rowIdx[matEle] = i; // store row index in the rowIdx map  \\n            colIdx[matEle] = j; // store column index in the colIdx map\\n        }\\n    }\\n    \\n    for(int i = 0; i < arr.size(); i++){\\n        int ele = arr[i];\\n        int row = rowIdx[ele]; //get row index of element from rowIdx map\\n        int col = colIdx[ele];// get col index of element from colIdx map\\n        rowCount[row]++;  // inc the row count for the row element belongs to\\n        colCount[col]++; // inc the col count for the col element belongs to\\n\\n        if(rowCount[row] == colSize || colCount[col] == rowSize){\\n          // if rowcount or colcount reaches size of the matrix return the current index\\n           return i;\\n        } \\n    }\\n    return -1;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     \\nint firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n    int rowSize = mat.size();\\n    int colSize = mat[0].size();\\n    unordered_map<int, int> rowIdx, colIdx, rowCount, colCount;\\n\\n    for(int i = 0; i < mat.size(); i++){\\n        for(int j = 0; j< mat[0].size(); ++j){\\n            int matEle = mat[i][j];\\n            rowIdx[matEle] = i; // store row index in the rowIdx map  \\n            colIdx[matEle] = j; // store column index in the colIdx map\\n        }\\n    }\\n    \\n    for(int i = 0; i < arr.size(); i++){\\n        int ele = arr[i];\\n        int row = rowIdx[ele]; //get row index of element from rowIdx map\\n        int col = colIdx[ele];// get col index of element from colIdx map\\n        rowCount[row]++;  // inc the row count for the row element belongs to\\n        colCount[col]++; // inc the col count for the col element belongs to\\n\\n        if(rowCount[row] == colSize || colCount[col] == rowSize){\\n          // if rowcount or colcount reaches size of the matrix return the current index\\n           return i;\\n        } \\n    }\\n    return -1;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468505,
                "title": "fully-explained-rust-python-o-mn",
                "content": "# Intuition\\nCreate a mapping from numbers to their positions `number_to_pos`. This is needed to be able to find the position of any number in $O(1)$. Then for each row and column mark how many positions were previously marked `data_y, data_x`. This will allow you to mark them and check if full row/column is marked in $O(1)$\\n\\nAfterwards just iterate over all values in array mark corresponding row/column and check if they are fully marked.\\n\\n# Complexity\\n- Time complexity: $O(mn)$\\n- Space complexity: $O(mn)$\\n\\n```Rust []\\n#[derive(Copy, Clone)]\\nstruct Pos {\\n  y: usize,\\n  x: usize,\\n}\\n\\nimpl Solution {\\n  pub fn first_complete_index(arr: Vec<i32>, M: Vec<Vec<i32>>) -> i32 {\\n    let (Y, X) = (M.len(), M[0].len());\\n    let mut number_to_pos = vec![Pos{y: 0, x: 0}; arr.len() + 1];\\n    for i in 0 .. Y {\\n      for j in 0 .. X {\\n        number_to_pos[M[i][j] as usize] = Pos{y: i, x: j};\\n      }\\n    }\\n\\n    let mut data_y = vec![0; Y];\\n    let mut data_x = vec![0; X];\\n    for i in 0 .. arr.len() {\\n      let p = number_to_pos[arr[i] as usize];\\n      data_y[p.y] += 1;\\n      data_x[p.x] += 1;\\n\\n      if data_y[p.y] == X || data_x[p.x] == Y {\\n        return i as i32;\\n      }\\n    }\\n    return 0;\\n  }\\n}\\n```\\n```python []\\nclass Solution:\\n  def firstCompleteIndex(self, arr: List[int], M: List[List[int]]) -> int:\\n    Y, X = len(M), len(M[0])\\n    number_to_pos = [() for _ in range(len(arr) + 1)]\\n    for i in range(Y):\\n      for j in range(X):\\n        number_to_pos[M[i][j]] = (i, j)\\n\\n    data_y, data_x = [0] * Y, [0] * X\\n    for i, v in enumerate(arr):\\n      y, x = number_to_pos[v]\\n      data_y[y] += 1\\n      data_x[x] += 1\\n\\n      if data_y[y] == X or data_x[x] == Y:\\n        return i\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Rust"
                ],
                "code": "```Rust []\\n#[derive(Copy, Clone)]\\nstruct Pos {\\n  y: usize,\\n  x: usize,\\n}\\n\\nimpl Solution {\\n  pub fn first_complete_index(arr: Vec<i32>, M: Vec<Vec<i32>>) -> i32 {\\n    let (Y, X) = (M.len(), M[0].len());\\n    let mut number_to_pos = vec![Pos{y: 0, x: 0}; arr.len() + 1];\\n    for i in 0 .. Y {\\n      for j in 0 .. X {\\n        number_to_pos[M[i][j] as usize] = Pos{y: i, x: j};\\n      }\\n    }\\n\\n    let mut data_y = vec![0; Y];\\n    let mut data_x = vec![0; X];\\n    for i in 0 .. arr.len() {\\n      let p = number_to_pos[arr[i] as usize];\\n      data_y[p.y] += 1;\\n      data_x[p.x] += 1;\\n\\n      if data_y[p.y] == X || data_x[p.x] == Y {\\n        return i as i32;\\n      }\\n    }\\n    return 0;\\n  }\\n}\\n```\n```python []\\nclass Solution:\\n  def firstCompleteIndex(self, arr: List[int], M: List[List[int]]) -> int:\\n    Y, X = len(M), len(M[0])\\n    number_to_pos = [() for _ in range(len(arr) + 1)]\\n    for i in range(Y):\\n      for j in range(X):\\n        number_to_pos[M[i][j]] = (i, j)\\n\\n    data_y, data_x = [0] * Y, [0] * X\\n    for i, v in enumerate(arr):\\n      y, x = number_to_pos[v]\\n      data_y[y] += 1\\n      data_x[x] += 1\\n\\n      if data_y[y] == X or data_x[x] == Y:\\n        return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468373,
                "title": "c-hashmap-storing-indexes-for-fastprocessing",
                "content": "# Code\\n```\\n# define ll long long\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& ma) {\\n        int n=ma.size(),m=ma[0].size();\\n        \\n        vector<ll>ri(n,0);\\n        vector<ll>ci(m,0);\\n        unordered_map<ll,pair<int,int>>mp;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                ci[j]+=ma[i][j];\\n                ri[i]+=ma[i][j];\\n                mp[ma[i][j]]={i,j};\\n            }\\n        }\\n        \\n          for(int i=0;i<arr.size();i++){\\n           int ni=mp[arr[i]].first,nj=mp[arr[i]].second;\\n              \\n              ri[ni]-=arr[i];\\n              if(ri[ni]==0)\\n                  return i;\\n              \\n               ci[nj]-=arr[i];\\n              if(ci[nj]==0)\\n                  return i;\\n        }\\n        \\n    \\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n# define ll long long\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& ma) {\\n        int n=ma.size(),m=ma[0].size();\\n        \\n        vector<ll>ri(n,0);\\n        vector<ll>ci(m,0);\\n        unordered_map<ll,pair<int,int>>mp;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                ci[j]+=ma[i][j];\\n                ri[i]+=ma[i][j];\\n                mp[ma[i][j]]={i,j};\\n            }\\n        }\\n        \\n          for(int i=0;i<arr.size();i++){\\n           int ni=mp[arr[i]].first,nj=mp[arr[i]].second;\\n              \\n              ri[ni]-=arr[i];\\n              if(ri[ni]==0)\\n                  return i;\\n              \\n               ci[nj]-=arr[i];\\n              if(ci[nj]==0)\\n                  return i;\\n        }\\n        \\n    \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468322,
                "title": "c-solutions-easy-to-understand-full-explanaiton-line-by-line",
                "content": "# Intuition\\nThis code aims to find the index of the first element in a given sequence that completes a rectangular matrix.\\n\\nTo do this, it first constructs a vector of pairs loc that contains the location of each element in the rectangular matrix. It then iterates over the input sequence arr, incrementing the corresponding row and column counts in r and c for each element. If the count of any row or column becomes equal to the number of columns or rows in the matrix, then that row or column is complete, and the index of the current element is returned. If no such element is found, then -1 is returned.\\n \\n# Approach\\nThis problem can be solved by creating a mapping between the values in the matrix and their corresponding indices in the loc vector. This mapping can be created using a nested loop that iterates through all the elements of the matrix and stores their indices in the loc vector.\\n\\nOnce we have the loc vector, we can iterate through the arr vector and for each element, we can retrieve its index in the loc vector. We can then update the r and c arrays, which store the count of the elements in each row and column, respectively. If the count of an element in a row or column equals the size of the row or column, then we know that all the elements in that row or column have been seen, and we can return the index of the last element that was seen.\\n\\nIf we iterate through the entire arr vector and no row or column has been completely seen, we can return -1 to indicate that there is no complete row or column.\\n\\n# Complexity\\n# Time complexity:\\nThe time complexity of the firstCompleteIndex function is O(nm), where n is the number of rows in the matrix and m is the number of columns in the matrix. This is because the function first initializes a vector of pairs containing the location of each number in the matrix, which takes O(nm) time. Then, the function iterates through the given array and checks the corresponding row and column in the matrix for each number, which also takes O(nm) time in the worst case.\\n\\n# Space complexity:\\nThe space complexity of the function is O(nm) as well, because it stores the location of each number in the matrix in a vector of pairs, which requires O(nm) space. It also stores two additional vectors of size n and m to keep track of the count of numbers in each row and column, respectively.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int m = mat.size(), n = mat[0].size(); \\n        \\n        // Store the location of each number in the matrix\\n        vector<pair<int, int>> loc(m*n); \\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                loc[mat[i][j]-1] = make_pair(i, j); \\n            }\\n        }\\n        \\n        // Count the number of occurrences of each row and column\\n        vector<int> r(m), c(n); \\n        for (int x = 0; x < arr.size(); ++x) {\\n            auto [i, j] = loc[arr[x]-1]; // Get the location of the current number\\n            if (++r[i] == n) return x; // If the row is complete, return the index\\n            if (++c[j] == m) return x; // If the column is complete, return the index\\n        }\\n        \\n        return -1; // If no row or column is complete, return -1\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int m = mat.size(), n = mat[0].size(); \\n        \\n        // Store the location of each number in the matrix\\n        vector<pair<int, int>> loc(m*n); \\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                loc[mat[i][j]-1] = make_pair(i, j); \\n            }\\n        }\\n        \\n        // Count the number of occurrences of each row and column\\n        vector<int> r(m), c(n); \\n        for (int x = 0; x < arr.size(); ++x) {\\n            auto [i, j] = loc[arr[x]-1]; // Get the location of the current number\\n            if (++r[i] == n) return x; // If the row is complete, return the index\\n            if (++c[j] == m) return x; // If the column is complete, return the index\\n        }\\n        \\n        return -1; // If no row or column is complete, return -1\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468267,
                "title": "easy-code-in-c",
                "content": "# Complexity\\n- Time complexity:\\nO(m*n)\\n\\n- Space complexity:\\nO(m*n)\\n\\n# Code\\nPLease Upvote if u liked my Solution\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int m=mat.size(),n=mat[0].size(),size=m*n;\\n        vector<int> r(m,n),c(n,m);\\n        unordered_map<int,vector<int>> mp;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                mp[mat[i][j]].push_back(i);\\n                mp[mat[i][j]].push_back(j);\\n            }\\n        }\\n        for(int i=0;i<size;i++){\\n            int x = mp[arr[i]][0],y = mp[arr[i]][1];\\n            r[x] --;\\n            if(r[x] == 0)\\n                return i;\\n            c[y] --;\\n            if(c[y] == 0)\\n                return i;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int m=mat.size(),n=mat[0].size(),size=m*n;\\n        vector<int> r(m,n),c(n,m);\\n        unordered_map<int,vector<int>> mp;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                mp[mat[i][j]].push_back(i);\\n                mp[mat[i][j]].push_back(j);\\n            }\\n        }\\n        for(int i=0;i<size;i++){\\n            int x = mp[arr[i]][0],y = mp[arr[i]][1];\\n            r[x] --;\\n            if(r[x] == 0)\\n                return i;\\n            c[y] --;\\n            if(c[y] == 0)\\n                return i;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065916,
                "title": "simple-solution-o-n-m-hashmap",
                "content": "# Intuition\\nFor an \"optimized\" solution HashMaps are the only data structure that can return mat[i][j] in costant time. In order to find when a row or colun is full two count arrays need to be kept.\\n\\n# Approach\\nFirst the algorithm builds the Hashmap in O(n*m) time, using O(n+m) space. The we iterate through the array, getting the dimension of each element on the matrix. These dimensions are used as indexes in the arrays that hold the counts. If a column count has n painted cells or if a row count has m painted cells, the minimum required stephas been reached.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*m)$$\\n\\n- Space complexity:\\n$$O(n+m)$$\\n\\n# Code\\n```\\nfunction firstCompleteIndex(arr: number[], mat: number[][]): number {\\n  // HashMaps are the only data structure that can give us mat[x][y] in constant time\\n  const patterns = new Map<number, [number, number]>()\\n\\n  const m = mat.length\\n  const n = mat[0].length\\n\\n  // Step 1; Create the HashMap. tc: O(n*m), sc: O(n+m)\\n  for (let i = 0; i < m; i++) {\\n    for (let j = 0; j < n; j++) {\\n        patterns.set(mat[i][j], [i, j])\\n    }\\n  }\\n\\n\\n  // Step 2; Keep counts of the painted row and columns\\n  const paintedInRow: number[] = Array(m).fill(0)\\n  const paintedInCol: number[] = Array(n).fill(0)\\n\\n  for (let i = 0; i < arr.length; i ++) { // tc: O(n+m), sc: O(1)\\n    // get row and col indexes\\n    const [x, y] = patterns.get(arr[i]) as [number, number]\\n    // increment\\n    paintedInRow[x]++;\\n    paintedInCol[y]++;\\n    // the loop stops if max(rows) = cols.length or max(cols) = rows.length\\n    // i.e. the counts and maxes are reversed.\\n    if(paintedInRow[x] === n || paintedInCol[y] === m) return i\\n  }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Hash Table"
                ],
                "code": "```\\nfunction firstCompleteIndex(arr: number[], mat: number[][]): number {\\n  // HashMaps are the only data structure that can give us mat[x][y] in constant time\\n  const patterns = new Map<number, [number, number]>()\\n\\n  const m = mat.length\\n  const n = mat[0].length\\n\\n  // Step 1; Create the HashMap. tc: O(n*m), sc: O(n+m)\\n  for (let i = 0; i < m; i++) {\\n    for (let j = 0; j < n; j++) {\\n        patterns.set(mat[i][j], [i, j])\\n    }\\n  }\\n\\n\\n  // Step 2; Keep counts of the painted row and columns\\n  const paintedInRow: number[] = Array(m).fill(0)\\n  const paintedInCol: number[] = Array(n).fill(0)\\n\\n  for (let i = 0; i < arr.length; i ++) { // tc: O(n+m), sc: O(1)\\n    // get row and col indexes\\n    const [x, y] = patterns.get(arr[i]) as [number, number]\\n    // increment\\n    paintedInRow[x]++;\\n    paintedInCol[y]++;\\n    // the loop stops if max(rows) = cols.length or max(cols) = rows.length\\n    // i.e. the counts and maxes are reversed.\\n    if(paintedInRow[x] === n || paintedInCol[y] === m) return i\\n  }\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4062783,
                "title": "beats-95-runtime-beats-80-memory-c-runtime-memory",
                "content": "# Intuition\\nSince all values in `arr` are unique, just keep count of how many remain in each row/column and return once any are empty\\n\\n# Approach\\nWe need to work backwards, since we want to be able to compute the validation (the actual computation) of first complete index quickly, spend time storing information that will speed that up.\\n## Passes\\n1) Pass through the whole matrix keeping track of where each value is. $O(MN)$\\n> since `mat` and `arr` are essentially permutations of $1-M*N$ where $M$ is the amount of rows and $N$ is the amount of columns, just keep the coordinates in 2 vectors of length $M*N+1$\\n\\n2) Pass through `arr`, decrementing row and col at `arr[i]`\\'s coordinates then check if either are 0, then return or continue. $O(MN)$\\n### Primitive Variables:\\n- m: Rows of mat, save on function overhead per access\\n- n: Columns of mat, save of function overhead per access\\n### Vectors:\\n- coordsx: X coordinate of any given number\\n- coordsy: Y coordinate of any given number\\n- row: keeps track of how many cells are left in each row\\n- col: keeps track of how many cells are left in each column\\n\\n# Complexity\\n- Time complexity:\\n$O(MN)$ - Always needs to traverse mat w/ 2 operations per iteration step, does up to 2 checks and operations per iteration step of the validation\\n\\n- Space complexity:\\n$O(MN)$ - needs 2 $M*N$ vectors/arrays for coordinates, needs 1 $M$ and 1 $N$ vector/array for validation\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int m=mat.size(),n=mat[0].size();\\n        vector<int> coordsx(m*n+1),coordsy(m*n+1),row(m,n),col(n,m);\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){//store coordinates for later\\n                coordsx[mat[i][j]]=i;\\n                coordsy[mat[i][j]]=j;\\n            }\\n        }\\n        for(int i=0;i<m*n;i++){\\n            if(!--row[coordsx[arr[i]]]||!--col[coordsy[arr[i]]]){//decrement and check\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int m=mat.size(),n=mat[0].size();\\n        vector<int> coordsx(m*n+1),coordsy(m*n+1),row(m,n),col(n,m);\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){//store coordinates for later\\n                coordsx[mat[i][j]]=i;\\n                coordsy[mat[i][j]]=j;\\n            }\\n        }\\n        for(int i=0;i<m*n;i++){\\n            if(!--row[coordsx[arr[i]]]||!--col[coordsy[arr[i]]]){//decrement and check\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4051136,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int[] arrLocations = new int[arr.length+1];\\n        for(int i=0; i<arr.length; i++)\\n            arrLocations[arr[i]] = i;\\n\\n        for(int i=0; i<mat.length; i++){\\n            for(int j=0; j<mat[0].length; j++){\\n                mat[i][j] = arrLocations[mat[i][j]];\\n            }\\n        }\\n\\n        int sol = arr.length+1;\\n        for(int i=0; i<mat.length; i++){\\n            int max = 0;\\n            for(int j=0; j<mat[0].length; j++){\\n                if(mat[i][j] > max)\\n                    max = mat[i][j];\\n            }\\n            sol = Math.min(sol, max);\\n        }\\n\\n        for(int i=0; i<mat[0].length; i++){\\n            int max = 0;\\n            for(int j=0; j<mat.length; j++){\\n                if(mat[j][i] > max)\\n                    max = mat[j][i];\\n            }\\n            sol = Math.min(sol, max);\\n        }\\n\\n        return sol;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int[] arrLocations = new int[arr.length+1];\\n        for(int i=0; i<arr.length; i++)\\n            arrLocations[arr[i]] = i;\\n\\n        for(int i=0; i<mat.length; i++){\\n            for(int j=0; j<mat[0].length; j++){\\n                mat[i][j] = arrLocations[mat[i][j]];\\n            }\\n        }\\n\\n        int sol = arr.length+1;\\n        for(int i=0; i<mat.length; i++){\\n            int max = 0;\\n            for(int j=0; j<mat[0].length; j++){\\n                if(mat[i][j] > max)\\n                    max = mat[i][j];\\n            }\\n            sol = Math.min(sol, max);\\n        }\\n\\n        for(int i=0; i<mat[0].length; i++){\\n            int max = 0;\\n            for(int j=0; j<mat.length; j++){\\n                if(mat[j][i] > max)\\n                    max = mat[j][i];\\n            }\\n            sol = Math.min(sol, max);\\n        }\\n\\n        return sol;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3993269,
                "title": "c-hashmap-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(mn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(mn)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        unordered_map<int,pair<int, int>> umap_wall;\\n        vector<int> row_cell(m+n,0);\\n\\n        for (int i = 0; i<m; i++){\\n            for (int j = 0; j<n; j++){\\n                umap_wall[mat[i][j]] = {i,j};\\n            }\\n        }\\n\\n        for (int i = 0; i<arr.size(); i++){\\n            pair<int, int>& index = umap_wall[arr[i]];\\n            row_cell[index.first]++;\\n            row_cell[m+index.second]++;\\n\\n            if (row_cell[index.first]==n) return i;\\n            if (row_cell[m+index.second]==m) return i;\\n        }\\n        return arr.size()-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        unordered_map<int,pair<int, int>> umap_wall;\\n        vector<int> row_cell(m+n,0);\\n\\n        for (int i = 0; i<m; i++){\\n            for (int j = 0; j<n; j++){\\n                umap_wall[mat[i][j]] = {i,j};\\n            }\\n        }\\n\\n        for (int i = 0; i<arr.size(); i++){\\n            pair<int, int>& index = umap_wall[arr[i]];\\n            row_cell[index.first]++;\\n            row_cell[m+index.second]++;\\n\\n            if (row_cell[index.first]==n) return i;\\n            if (row_cell[m+index.second]==m) return i;\\n        }\\n        return arr.size()-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991736,
                "title": "beginner-friendly-solution-unordered-map-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 0(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 0(n*m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        vector<long long int> row;\\n        vector<long long int> col;\\n        for(int i = 0;i<n;i++){\\n            long long int sum = 0;\\n            for(int j = 0;j<m;j++){\\n                sum+=mat[i][j];\\n            }\\n            row.push_back(sum);\\n        }\\n        for(int i = 0;i<m;i++){\\n            long long int sum = 0;\\n            for(int j = 0;j<n;j++){\\n                sum+=mat[j][i];\\n            }\\n            col.push_back(sum);\\n        }\\n        unordered_map<int,pair<int,int>> map;\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<m;j++){\\n                map[mat[i][j]] = {i,j};\\n            }\\n        }\\n        for(int i = 0;i<arr.size();i++){\\n            pair<int,int> temp = map[arr[i]];\\n            int r = temp.first;\\n            int c = temp.second;\\n            row[r] = row[r]-arr[i];\\n            col[c] = col[c]-arr[i];\\n            if(row[r] == 0 || col[c] == 0) return i;\\n            \\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        vector<long long int> row;\\n        vector<long long int> col;\\n        for(int i = 0;i<n;i++){\\n            long long int sum = 0;\\n            for(int j = 0;j<m;j++){\\n                sum+=mat[i][j];\\n            }\\n            row.push_back(sum);\\n        }\\n        for(int i = 0;i<m;i++){\\n            long long int sum = 0;\\n            for(int j = 0;j<n;j++){\\n                sum+=mat[j][i];\\n            }\\n            col.push_back(sum);\\n        }\\n        unordered_map<int,pair<int,int>> map;\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<m;j++){\\n                map[mat[i][j]] = {i,j};\\n            }\\n        }\\n        for(int i = 0;i<arr.size();i++){\\n            pair<int,int> temp = map[arr[i]];\\n            int r = temp.first;\\n            int c = temp.second;\\n            row[r] = row[r]-arr[i];\\n            col[c] = col[c]-arr[i];\\n            if(row[r] == 0 || col[c] == 0) return i;\\n            \\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979575,
                "title": "step-by-step-solution-with-hash-tables-python",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        m = len(mat)\\n        n = len(mat[0])\\n        rowDic = {i:n for i in range(m) }\\n        colDic = {i:m for i in range(n) }\\n        vals = {}\\n        for i in range(m):\\n            for j in range(n):\\n                vals[mat[i][j]] = [i , j]\\n\\n\\n        for i in range(len(arr)):\\n            r = vals[arr[i]][0]\\n            c = vals[arr[i]][1]\\n\\n            rowDic[r] -= 1\\n            colDic[c] -= 1\\n            if rowDic[r] == 0 or colDic[c] == 0:\\n                return i\\n\\n        return 0\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        m = len(mat)\\n        n = len(mat[0])\\n        rowDic = {i:n for i in range(m) }\\n        colDic = {i:m for i in range(n) }\\n        vals = {}\\n        for i in range(m):\\n            for j in range(n):\\n                vals[mat[i][j]] = [i , j]\\n\\n\\n        for i in range(len(arr)):\\n            r = vals[arr[i]][0]\\n            c = vals[arr[i]][1]\\n\\n            rowDic[r] -= 1\\n            colDic[c] -= 1\\n            if rowDic[r] == 0 or colDic[c] == 0:\\n                return i\\n\\n        return 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3970452,
                "title": "full-explanation-simple-easy-java-solution",
                "content": "# Intution\\nTraverse the modified map. Get maximum value from each row and column,\\nbut return the minimum among them as ans.  \\n# Approach\\nImplement a Hashmap and store all values of 1D array as key along with it\\'s index as value. \\n\\nNow, traverse the matrix and check for correspong matrix value as key in the Hashmap. Store the value corresponding to that key in matrix.\\n\\nCheck for the maximum value from each row and store the minimum among that values in a ans variable. Likewise traverse each column of matrix and get maximum from each column ans store the minimum among those maximum in a ans variable. Return ans. \\n\\n# Complexity\\n- Time complexity:\\nO(m*n)\\n\\n- Space complexity:\\nO(m*n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        HashMap<Integer,Integer>map=new HashMap<>();\\n        for(int i=0;i<arr.length;i++){\\n            map.put(arr[i],i);\\n        }\\n\\n        for(int i=0;i<mat.length;i++){\\n            for(int j=0;j<mat[0].length;j++){\\n                mat[i][j]=map.get(mat[i][j]);\\n            }\\n        }\\n        \\n        int ans=Integer.MAX_VALUE;\\n        for(int i=0;i<mat.length;i++){\\n            int max=0;\\n            for(int j=0;j<mat[0].length;j++){\\n                max=Math.max(max,mat[i][j]);\\n            }\\n            ans=Math.min(ans,max);\\n        } \\n        \\n        for(int i=0;i<mat[0].length;i++){\\n            int max=0;\\n            for(int j=0;j<mat.length;j++){\\n                max=Math.max(max,mat[j][i]);\\n            }\\n            ans=Math.min(ans,max);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        HashMap<Integer,Integer>map=new HashMap<>();\\n        for(int i=0;i<arr.length;i++){\\n            map.put(arr[i],i);\\n        }\\n\\n        for(int i=0;i<mat.length;i++){\\n            for(int j=0;j<mat[0].length;j++){\\n                mat[i][j]=map.get(mat[i][j]);\\n            }\\n        }\\n        \\n        int ans=Integer.MAX_VALUE;\\n        for(int i=0;i<mat.length;i++){\\n            int max=0;\\n            for(int j=0;j<mat[0].length;j++){\\n                max=Math.max(max,mat[i][j]);\\n            }\\n            ans=Math.min(ans,max);\\n        } \\n        \\n        for(int i=0;i<mat[0].length;i++){\\n            int max=0;\\n            for(int j=0;j<mat.length;j++){\\n                max=Math.max(max,mat[j][i]);\\n            }\\n            ans=Math.min(ans,max);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3935280,
                "title": "2661-first-completely-painted-row-or-column-python-solution",
                "content": "# Approach\\n- Create a dictionary `index` to get row and column for each unique element in **O(1)** time while iterating through `arr`.\\n- Create two list `row` and `column` to track number of element that needs to be painted.\\n- So, length of `row` will be equal to `m` with each value equal to `n` and length of `column` will be equal to `n` with each value equal to `m`.\\n- Now, while iterating through `arr`, get row `r` and column `c` for each `arr[i]` by `index[arr[i]]`.\\n-  Decrement the count of `row[r]` and `column[c]` as they are painted now.\\n- Check if the `row[r]` or `column[c]` is equal to `0`. If yes, return `i` else, continue the loop.\\n\\n# Complexity\\n- Time complexity: **O(m * n)**\\n\\n- Space complexity: **O(m * n)**\\n\\n# Code\\n```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        index = dict()\\n        m, n = len(mat), len(mat[0])\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                index[mat[i][j]] = (i, j)\\n\\n        row, column = [n for _ in range(m)], [m for _ in range(n)]\\n\\n        for i in range(len(arr)):\\n            r, c = index[arr[i]]\\n            row[r], column[c] = row[r] - 1, column[c] - 1\\n            if row[r] == 0 or column[c] == 0:\\n                return i\\n```",
                "solutionTags": [
                    "Python",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        index = dict()\\n        m, n = len(mat), len(mat[0])\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                index[mat[i][j]] = (i, j)\\n\\n        row, column = [n for _ in range(m)], [m for _ in range(n)]\\n\\n        for i in range(len(arr)):\\n            r, c = index[arr[i]]\\n            row[r], column[c] = row[r] - 1, column[c] - 1\\n            if row[r] == 0 or column[c] == 0:\\n                return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924554,
                "title": "typescript-matrix-hash-table-array",
                "content": "# Complexity\\n- Time complexity:\\n   $$O(m*n)$$ \\n\\n- Space complexity:\\n    $$O(m*n + m + n)$$\\n\\n# Code\\n```\\nfunction firstCompleteIndex(arr: number[], grid: number[][]): number {\\n    const ROW = grid.length;\\n    const COL = grid[0].length;\\n    \\n    const positionToPaintMap:Map<number, [number,number]> = new Map();\\n\\n\\n    let rowCounts: number[] = new Array(grid.length).fill(0)\\n    let colCounts: number[] = new Array(grid[0].length).fill(0)\\n\\n    for(let x = 0; x < ROW;x++){\\n        for(let y = 0; y < COL; y++){\\n            positionToPaintMap.set(grid[x][y],[x,y])\\n        }\\n    }\\n\\n\\n    for(let i = 0; i < arr.length; i++){\\n        const position = positionToPaintMap.get(arr[i])\\n        if(++rowCounts[position[0]] == COL){\\n            return i\\n        }\\n        if(++colCounts[position[1]] == ROW){\\n            return i\\n        }\\n    }\\n\\n    return -1\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nfunction firstCompleteIndex(arr: number[], grid: number[][]): number {\\n    const ROW = grid.length;\\n    const COL = grid[0].length;\\n    \\n    const positionToPaintMap:Map<number, [number,number]> = new Map();\\n\\n\\n    let rowCounts: number[] = new Array(grid.length).fill(0)\\n    let colCounts: number[] = new Array(grid[0].length).fill(0)\\n\\n    for(let x = 0; x < ROW;x++){\\n        for(let y = 0; y < COL; y++){\\n            positionToPaintMap.set(grid[x][y],[x,y])\\n        }\\n    }\\n\\n\\n    for(let i = 0; i < arr.length; i++){\\n        const position = positionToPaintMap.get(arr[i])\\n        if(++rowCounts[position[0]] == COL){\\n            return i\\n        }\\n        if(++colCounts[position[1]] == ROW){\\n            return i\\n        }\\n    }\\n\\n    return -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3912209,
                "title": "c-solution-using-unordered-map-frequency-array-and-pair",
                "content": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        \\n\\t\\t//declaring map that stores the element in arr array as key and position m,n in the matrix mat as pair value\\n        unordered_map<int,pair<int,int>> mp;\\n\\t\\t\\n\\t\\t//frequency arrays for rows and columns initialized with 0\\n        vector<int> row(m,0);\\n        vector<int> col(n,0);\\n        \\n\\t\\t//mapping values\\n        for(int i=0;i<mat.size();i++)\\n        {\\n            for(int j=0;j<mat[0].size();j++)\\n            {\\n              mp.insert({mat[i][j],{i,j}});\\n            }\\n        }\\n        \\n\\t\\t//adding values in frequency arrays \\n        for(int i=0;i<arr.size();i++)\\n        {\\n           row[mp.find(arr[i])->second.first]++;\\n           col[mp.find(arr[i])->second.second]++;\\n        }\\n        \\n\\t\\t//finding and subtracting based on rows and columns of current element in arr\\n\\t\\t//as soon as any number of row or column becomes 0 i.e it is fully painted we return index i as the answer\\n        for(int i=0;i<arr.size();i++)\\n        {\\n           int r = mp.find(arr[i])->second.first;\\n           int c = mp.find(arr[i])->second.second;\\n           row[r]--;\\n           col[c]--;\\n           if(row[r] == 0 || col[c] == 0) return i;\\n        }\\n        //return -1 just for the sake of returning value\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        \\n\\t\\t//declaring map that stores the element in arr array as key and position m,n in the matrix mat as pair value\\n        unordered_map<int,pair<int,int>> mp;\\n\\t\\t\\n\\t\\t//frequency arrays for rows and columns initialized with 0\\n        vector<int> row(m,0);\\n        vector<int> col(n,0);\\n        \\n\\t\\t//mapping values\\n        for(int i=0;i<mat.size();i++)\\n        {\\n            for(int j=0;j<mat[0].size();j++)\\n            {\\n              mp.insert({mat[i][j],{i,j}});\\n            }\\n        }\\n        \\n\\t\\t//adding values in frequency arrays \\n        for(int i=0;i<arr.size();i++)\\n        {\\n           row[mp.find(arr[i])->second.first]++;\\n           col[mp.find(arr[i])->second.second]++;\\n        }\\n        \\n\\t\\t//finding and subtracting based on rows and columns of current element in arr\\n\\t\\t//as soon as any number of row or column becomes 0 i.e it is fully painted we return index i as the answer\\n        for(int i=0;i<arr.size();i++)\\n        {\\n           int r = mp.find(arr[i])->second.first;\\n           int c = mp.find(arr[i])->second.second;\\n           row[r]--;\\n           col[c]--;\\n           if(row[r] == 0 || col[c] == 0) return i;\\n        }\\n        //return -1 just for the sake of returning value\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894689,
                "title": "unordered-map-pair",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        unordered_map<int,pair<int,int>> m;\\n        int h=mat.size(),n=mat[0].size();\\n        vector<int> r(h+1,0);\\n        vector<int> c(n+1,0);\\n        for(int i=0;i<h;i++){\\n            for(int j=0;j<n;j++){\\n                m[mat[i][j]]={i,j};\\n            }\\n        }\\n        for(int i=0;i<arr.size();i++){\\n            int row=m[arr[i]].first;\\n            int col=m[arr[i]].second;\\n            r[row]++;\\n            if(r[row]==n)return i;\\n            c[col]++;\\n            if(c[col]==h)return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        unordered_map<int,pair<int,int>> m;\\n        int h=mat.size(),n=mat[0].size();\\n        vector<int> r(h+1,0);\\n        vector<int> c(n+1,0);\\n        for(int i=0;i<h;i++){\\n            for(int j=0;j<n;j++){\\n                m[mat[i][j]]={i,j};\\n            }\\n        }\\n        for(int i=0;i<arr.size();i++){\\n            int row=m[arr[i]].first;\\n            int col=m[arr[i]].second;\\n            r[row]++;\\n            if(r[row]==n)return i;\\n            c[col]++;\\n            if(c[col]==h)return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873729,
                "title": "easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGiven an array and and a matrix the ans would be the index when all index one of the row or column of the matrix is covered. So in a hashmap we will take all the values of the array and it\\'s index and we will travarse the matrix at first by row and take the max index of every being covered and will take minimum of all the max index same will do for column and between them the index where the minimum index I will get where all row are column are covered will be the answer.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int n = arr.length;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n\\n        int m = mat.length;\\n        int k = mat[0].length;\\n        for(int i =0;i<n;i++){\\n            map.put(arr[i], i);\\n        }\\n        int min = Integer.MAX_VALUE;\\n\\n        for(int i =0;i<m;i++){\\n            int max = 0;\\n            for(int j =0;j<k;j++){\\n                max = Math.max(max, map.get(mat[i][j]));\\n            }\\n            min = Math.min(min, max);\\n        }\\n\\n        for(int i =0;i<k;i++){\\n            int max = 0;\\n            for(int j =0;j<m;j++){\\n                max = Math.max(max, map.get(mat[j][i]));\\n            }\\n            min = Math.min(min, max);\\n        }\\n\\n        return min;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int n = arr.length;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n\\n        int m = mat.length;\\n        int k = mat[0].length;\\n        for(int i =0;i<n;i++){\\n            map.put(arr[i], i);\\n        }\\n        int min = Integer.MAX_VALUE;\\n\\n        for(int i =0;i<m;i++){\\n            int max = 0;\\n            for(int j =0;j<k;j++){\\n                max = Math.max(max, map.get(mat[i][j]));\\n            }\\n            min = Math.min(min, max);\\n        }\\n\\n        for(int i =0;i<k;i++){\\n            int max = 0;\\n            for(int j =0;j<m;j++){\\n                max = Math.max(max, map.get(mat[j][i]));\\n            }\\n            min = Math.min(min, max);\\n        }\\n\\n        return min;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865675,
                "title": "python-easy-to-read-and-understand-map",
                "content": "**Brute-force**\\n```\\nclass Solution:\\n    def find(self, matrix, val):\\n        m, n = len(matrix), len(matrix[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if matrix[i][j] == val:\\n                    return [i, j]\\n    \\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        row, col = collections.defaultdict(list), collections.defaultdict(list)\\n        m, n = len(mat), len(mat[0])\\n        \\n        for i in range(len(arr)):\\n            x, y = self.find(mat, arr[i])\\n            row[x].append(i)\\n            col[y].append(i)\\n            if len(row[x]) == n or len(col[y]) == m:\\n                return i\\n```\\n**Map**\\n```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        row, col = collections.defaultdict(list), collections.defaultdict(list)\\n        d = collections.defaultdict(list)\\n        m, n = len(mat), len(mat[0])\\n        for i in range(m):\\n            for j in range(n):\\n                d[mat[i][j]] = [i, j]\\n        \\n        for i in range(len(arr)):\\n            x, y = d[arr[i]]\\n            row[x].append(i)\\n            col[y].append(i)\\n            if len(row[x]) == n or len(col[y]) == m:\\n                return i",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def find(self, matrix, val):\\n        m, n = len(matrix), len(matrix[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if matrix[i][j] == val:\\n                    return [i, j]\\n    \\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        row, col = collections.defaultdict(list), collections.defaultdict(list)\\n        m, n = len(mat), len(mat[0])\\n        \\n        for i in range(len(arr)):\\n            x, y = self.find(mat, arr[i])\\n            row[x].append(i)\\n            col[y].append(i)\\n            if len(row[x]) == n or len(col[y]) == m:\\n                return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3859575,
                "title": "go-reverse-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor filling matrix type of problem, always try to think of going in reverse direction. Here, since it is asking for filling all rows and cols, this means that if we go from reverse direction, we would be deleting the rows and cols that are fully filled. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(M*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(M*N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        HashSet<Integer> setRow = new HashSet<>();\\n        HashSet<Integer> setCol = new HashSet<>();\\n        for(int i = 0; i<mat.length; i++)setRow.add(i);\\n        for(int i = 0; i<mat[0].length; i++)setCol.add(i);\\n        HashMap<Integer,int[]> map = new HashMap<>();\\n        for(int i = 0; i<mat.length; i++){\\n            for(int j = 0; j<mat[0].length; j++){\\n                map.put(mat[i][j],new int[]{i,j});\\n            }\\n        }\\n        int res = -1;\\n        for(int i = arr.length-1; i>=0; i--){\\n            if((setRow.size()==1 && setCol.size()==0)||(setRow.size()==0 && setCol.size()==1))res = i;\\n            if(setRow.size()==1 && setCol.size()==1){\\n                res = i;\\n            }\\n            int[] coord = map.get(arr[i]);\\n            if(setRow.contains(coord[0]))setRow.remove(coord[0]);\\n            if(setCol.contains(coord[1]))setCol.remove(coord[1]);\\n            //check to see if setRow==1 || setCol==1\\n            //if(setRow==0 && setCol==0)return res;\\n            \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        HashSet<Integer> setRow = new HashSet<>();\\n        HashSet<Integer> setCol = new HashSet<>();\\n        for(int i = 0; i<mat.length; i++)setRow.add(i);\\n        for(int i = 0; i<mat[0].length; i++)setCol.add(i);\\n        HashMap<Integer,int[]> map = new HashMap<>();\\n        for(int i = 0; i<mat.length; i++){\\n            for(int j = 0; j<mat[0].length; j++){\\n                map.put(mat[i][j],new int[]{i,j});\\n            }\\n        }\\n        int res = -1;\\n        for(int i = arr.length-1; i>=0; i--){\\n            if((setRow.size()==1 && setCol.size()==0)||(setRow.size()==0 && setCol.size()==1))res = i;\\n            if(setRow.size()==1 && setCol.size()==1){\\n                res = i;\\n            }\\n            int[] coord = map.get(arr[i]);\\n            if(setRow.contains(coord[0]))setRow.remove(coord[0]);\\n            if(setCol.contains(coord[1]))setCol.remove(coord[1]);\\n            //check to see if setRow==1 || setCol==1\\n            //if(setRow==0 && setCol==0)return res;\\n            \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3858915,
                "title": "c-easy-solution-unordered-map",
                "content": "# Complexity\\n- Time complexity:\\nO(n*m)\\n\\n- Space complexity:\\nO(n*m)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        unordered_map<int, int> mpRow, mpCol;\\n        unordered_map<int, pair<int, int>> grid;\\n\\n        for(int i=0 ;i<mat.size() ;i++){\\n            for(int j=0 ;j<mat[0].size() ;j++)\\n            grid[mat[i][j]] = {i, j};\\n        }\\n\\n        for(int i=0 ;i<arr.size() ;i++){\\n            pair<int, int> index = grid[arr[i]];\\n\\n            mpRow[index.first]++;\\n            mpCol[index.second]++;\\n\\n            if(mpRow[index.first] == mat[0].size() || mpCol[index.second]==mat.size())\\n            return i;\\n        }\\n\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        unordered_map<int, int> mpRow, mpCol;\\n        unordered_map<int, pair<int, int>> grid;\\n\\n        for(int i=0 ;i<mat.size() ;i++){\\n            for(int j=0 ;j<mat[0].size() ;j++)\\n            grid[mat[i][j]] = {i, j};\\n        }\\n\\n        for(int i=0 ;i<arr.size() ;i++){\\n            pair<int, int> index = grid[arr[i]];\\n\\n            mpRow[index.first]++;\\n            mpCol[index.second]++;\\n\\n            if(mpRow[index.first] == mat[0].size() || mpCol[index.second]==mat.size())\\n            return i;\\n        }\\n\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3856716,
                "title": "c-too-easy-clean-short-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& a, vector<vector<int>>& g) {\\n        map<int,int> r,c;\\n        int m=g.size(),n=g[0].size();\\n        map<int,pair<int,int>> p;\\n\\n        for(int i=0;i<m;i++)\\n         for(int j=0;j<n;j++)\\n          p[g[i][j]]={i,j};\\n\\n        for(int i=0;i<a.size();i++)\\n        {\\n            pair<int,int> q=p[a[i]];\\n            r[q.first]++;\\n            c[q.second]++;\\n            if(r[q.first]==n || c[q.second]==m) return i;\\n        }  \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& a, vector<vector<int>>& g) {\\n        map<int,int> r,c;\\n        int m=g.size(),n=g[0].size();\\n        map<int,pair<int,int>> p;\\n\\n        for(int i=0;i<m;i++)\\n         for(int j=0;j<n;j++)\\n          p[g[i][j]]={i,j};\\n\\n        for(int i=0;i<a.size();i++)\\n        {\\n            pair<int,int> q=p[a[i]];\\n            r[q.first]++;\\n            c[q.second]++;\\n            if(r[q.first]==n || c[q.second]==m) return i;\\n        }  \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842207,
                "title": "easy-to-get-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n      Map<Integer,Integer> map = new HashMap();\\n        for(int i=0; i<arr.length; i++) map.put(arr[i],i);\\n        int min = arr.length;\\n        for(int i=0; i<mat.length; i++){\\n            int max = 0;\\n            for(int j=0; j<mat[0].length; j++){\\n                max = Math.max(max, map.get(mat[i][j]));\\n            }\\n            min = Math.min(min,max);\\n        }\\n        for(int i=0; i<mat[0].length; i++){\\n            int max = 0;\\n            for(int j=0; j<mat.length; j++){\\n                max = Math.max(max, map.get(mat[j][i]));\\n            }\\n            min = Math.min(min,max);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n      Map<Integer,Integer> map = new HashMap();\\n        for(int i=0; i<arr.length; i++) map.put(arr[i],i);\\n        int min = arr.length;\\n        for(int i=0; i<mat.length; i++){\\n            int max = 0;\\n            for(int j=0; j<mat[0].length; j++){\\n                max = Math.max(max, map.get(mat[i][j]));\\n            }\\n            min = Math.min(min,max);\\n        }\\n        for(int i=0; i<mat[0].length; i++){\\n            int max = 0;\\n            for(int j=0; j<mat.length; j++){\\n                max = Math.max(max, map.get(mat[j][i]));\\n            }\\n            min = Math.min(min,max);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824946,
                "title": "c-easy-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n***$$O(m*n)$$*** \\n\\n- Space complexity:\\n***$$O(m*n)$$*** \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n      int m = mat.size(), n = mat[0].size();\\n        vector<pair<int,int>>mp((m*n) +1);\\n        for (int i = 0; i < m; i++)\\n        {\\n          for (int j = 0; j < n; j++)\\n          {\\n            mp[mat[i][j]] = {i,j};\\n          }\\n        }\\n        vector<int>is(m,0),js(n,0);\\n        for (int i = 0; i < m*n; i++)\\n        {\\n          int z = arr[i];\\n          int x = mp[z].first, y = mp[z].second;\\n          is[x]++;\\n          js[y]++;\\n          if(is[x]==n || js[y]==m){\\n            return i;\\n          }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n      int m = mat.size(), n = mat[0].size();\\n        vector<pair<int,int>>mp((m*n) +1);\\n        for (int i = 0; i < m; i++)\\n        {\\n          for (int j = 0; j < n; j++)\\n          {\\n            mp[mat[i][j]] = {i,j};\\n          }\\n        }\\n        vector<int>is(m,0),js(n,0);\\n        for (int i = 0; i < m*n; i++)\\n        {\\n          int z = arr[i];\\n          int x = mp[z].first, y = mp[z].second;\\n          is[x]++;\\n          js[y]++;\\n          if(is[x]==n || js[y]==m){\\n            return i;\\n          }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817472,
                "title": "c-intuitive",
                "content": "# Intuition\\n\\nCount each row and col to see whether it is completely covered.\\n\\n# Approach\\n\\nCreate a map from value to coordinate.\\nIterate arr array, for each value, get its coord, then check that point is covered by either row or column.\\n\\nIf I use visited mat, it would get TLE.\\n\\n# Complexity\\n- Time complexity:\\nO(m*n)\\n\\n- Space complexity:\\nO(m*n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        // value -> coord map\\n        vector<pair<int, int>> mp(m*n+1, {-1,-1});\\n        \\n        // counters for each row and column.\\n        vector<int> row(m, 0);\\n        vector<int> col(n, 0);\\n\\n        // value -> cord\\n        for(int r = 0; r < m; r++) {\\n            for(int c=0; c< n; c++) {\\n                mp[mat[r][c]] = {r, c};\\n            }\\n        }\\n\\n        for(int i=0; i<arr.size(); i++) {\\n            auto& p = mp[arr[i]];\\n            row[p.first]++;\\n            col[p.second]++;\\n            if (row[p.first]==n || col[p.second]==m) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        // value -> coord map\\n        vector<pair<int, int>> mp(m*n+1, {-1,-1});\\n        \\n        // counters for each row and column.\\n        vector<int> row(m, 0);\\n        vector<int> col(n, 0);\\n\\n        // value -> cord\\n        for(int r = 0; r < m; r++) {\\n            for(int c=0; c< n; c++) {\\n                mp[mat[r][c]] = {r, c};\\n            }\\n        }\\n\\n        for(int i=0; i<arr.size(); i++) {\\n            auto& p = mp[arr[i]];\\n            row[p.first]++;\\n            col[p.second]++;\\n            if (row[p.first]==n || col[p.second]==m) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779514,
                "title": "simple-solution-using-map-clean-code-c-accepted",
                "content": "<!-- # Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n<!-- \\n# Approach\\n<!-- Describe your approach to solving the problem. --> \\n\\n# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n*m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        map<int, pair<int, int>> mp;\\n        int n=mat.size(), m=mat[0].size();\\n        vector<int> row(n);\\n        vector<int> col(m);\\n        for (int i=0; i<n; i++)\\n        {\\n            for (int j=0; j<m; j++)\\n            {\\n                mp[mat[i][j]]={i, j};\\n            }\\n        }\\n        for (int i=0; i<arr.size(); i++)\\n        {\\n            int r=mp[arr[i]].first;\\n            int c=mp[arr[i]].second;\\n            row[r]++;\\n            col[c]++;\\n            if (row[r]>=m || col[c]>=n)\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        map<int, pair<int, int>> mp;\\n        int n=mat.size(), m=mat[0].size();\\n        vector<int> row(n);\\n        vector<int> col(m);\\n        for (int i=0; i<n; i++)\\n        {\\n            for (int j=0; j<m; j++)\\n            {\\n                mp[mat[i][j]]={i, j};\\n            }\\n        }\\n        for (int i=0; i<arr.size(); i++)\\n        {\\n            int r=mp[arr[i]].first;\\n            int c=mp[arr[i]].second;\\n            row[r]++;\\n            col[c]++;\\n            if (row[r]>=m || col[c]>=n)\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3771783,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int n = mat.size(), m = mat[0].size();\\n        unordered_map<int, pair<int, int>> mp;\\n        for(int i=0; i<n; ++i){\\n            for(int j=0; j<m; ++j)\\n                mp[mat[i][j]] = {i,j};\\n        }\\n\\n        vector<int> rows(n, 0), cols(m, 0);\\n        int count = 0;\\n        for(int i=0; i<arr.size(); ++i){\\n            rows[mp[arr[i]].first]++;\\n            cols[mp[arr[i]].second]++;\\n            if(rows[mp[arr[i]].first]==m)\\n                return count;\\n            \\n            if(cols[mp[arr[i]].second]==n)\\n                return count;\\n\\n            ++count;\\n        }\\n\\n        return count;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int n = mat.size(), m = mat[0].size();\\n        unordered_map<int, pair<int, int>> mp;\\n        for(int i=0; i<n; ++i){\\n            for(int j=0; j<m; ++j)\\n                mp[mat[i][j]] = {i,j};\\n        }\\n\\n        vector<int> rows(n, 0), cols(m, 0);\\n        int count = 0;\\n        for(int i=0; i<arr.size(); ++i){\\n            rows[mp[arr[i]].first]++;\\n            cols[mp[arr[i]].second]++;\\n            if(rows[mp[arr[i]].first]==m)\\n                return count;\\n            \\n            if(cols[mp[arr[i]].second]==n)\\n                return count;\\n\\n            ++count;\\n        }\\n\\n        return count;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766159,
                "title": "simple-greedy-python-solution-using-hashmap",
                "content": "\\n\\n# Complexity\\n- Time complexity:m*n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        mapi=defaultdict(list)\\n        for i in range(len(mat)):\\n            for j in range(len(mat[0])):\\n                mapi[mat[i][j]]=[i,j]\\n        \\n        mapiRow=[0]*(len(mat)*len(mat[0]))\\n        mapiColumn=[0]*(len(mat)*len(mat[0]))\\n        for i in range(len(arr)):\\n            s=arr[i]\\n            if s in mapi.keys():\\n                r=mapi[s][0]\\n                c=mapi[s][1]\\n                mapiRow[r]=mapiRow[r]+1\\n                mapiColumn[c]=mapiColumn[c]+1\\n            \\n                if mapiRow[r]==len(mat[0]) or mapiColumn[c]==len(mat):\\n                    return i\\n            \\n                \\n                    \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        mapi=defaultdict(list)\\n        for i in range(len(mat)):\\n            for j in range(len(mat[0])):\\n                mapi[mat[i][j]]=[i,j]\\n        \\n        mapiRow=[0]*(len(mat)*len(mat[0]))\\n        mapiColumn=[0]*(len(mat)*len(mat[0]))\\n        for i in range(len(arr)):\\n            s=arr[i]\\n            if s in mapi.keys():\\n                r=mapi[s][0]\\n                c=mapi[s][1]\\n                mapiRow[r]=mapiRow[r]+1\\n                mapiColumn[c]=mapiColumn[c]+1\\n            \\n                if mapiRow[r]==len(mat[0]) or mapiColumn[c]==len(mat):\\n                    return i\\n            \\n                \\n                    \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3745799,
                "title": "java-solution-using-hashmap",
                "content": "# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        Map<Integer,Integer> hmap = new HashMap<>();\\n        for(int i = 0; i < arr.length; i++){\\n            hmap.put(arr[i],i);\\n        }\\n        int result = Integer.MAX_VALUE;\\n\\n        //smallest index across every row\\n        for(int i = 0; i < mat.length; i++){\\n            int maxVal = 0;\\n            for(int j = 0; j < mat[0].length; j++){\\n                maxVal = Math.max(maxVal,hmap.get(mat[i][j]));\\n            }\\n            result = Math.min(result,maxVal); \\n        }\\n\\n        //smallest index across every column\\n        for(int i = 0; i < mat[0].length; i++){\\n            int maxVal = 0;\\n            for(int j = 0; j < mat.length; j++){\\n                maxVal = Math.max(maxVal,hmap.get(mat[j][i]));\\n            }\\n            result = Math.min(result,maxVal);\\n        }\\n\\n        return result;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        Map<Integer,Integer> hmap = new HashMap<>();\\n        for(int i = 0; i < arr.length; i++){\\n            hmap.put(arr[i],i);\\n        }\\n        int result = Integer.MAX_VALUE;\\n\\n        //smallest index across every row\\n        for(int i = 0; i < mat.length; i++){\\n            int maxVal = 0;\\n            for(int j = 0; j < mat[0].length; j++){\\n                maxVal = Math.max(maxVal,hmap.get(mat[i][j]));\\n            }\\n            result = Math.min(result,maxVal); \\n        }\\n\\n        //smallest index across every column\\n        for(int i = 0; i < mat[0].length; i++){\\n            int maxVal = 0;\\n            for(int j = 0; j < mat.length; j++){\\n                maxVal = Math.max(maxVal,hmap.get(mat[j][i]));\\n            }\\n            result = Math.min(result,maxVal);\\n        }\\n\\n        return result;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3727414,
                "title": "python-easy-solution-using-dict-beats-93-percent",
                "content": "# Complexity\\n- Time complexity:\\nO(m*n)\\n\\n- Space complexity:\\nO(m*n)\\n\\n# Code\\n```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        indexes = {}\\n        m, n = len(mat), len(mat[0])\\n        for i in range(m):\\n            for j in range(n):\\n                indexes[mat[i][j]] = (i, j)\\n        rows = [0] * m\\n        cols = [0] * n\\n        #Search\\n        for i, num in enumerate(arr):\\n            x, y = indexes[num]\\n            rows[x] += 1\\n            cols[y] += 1\\n            if rows[x] == n or cols[y] == m:\\n                return i\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        indexes = {}\\n        m, n = len(mat), len(mat[0])\\n        for i in range(m):\\n            for j in range(n):\\n                indexes[mat[i][j]] = (i, j)\\n        rows = [0] * m\\n        cols = [0] * n\\n        #Search\\n        for i, num in enumerate(arr):\\n            x, y = indexes[num]\\n            rows[x] += 1\\n            cols[y] += 1\\n            if rows[x] == n or cols[y] == m:\\n                return i\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717731,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe just have to find which element in the whole row/column occurs farthest in the array because that would be the last element when the whole row/col gets painted\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        unordered_map<int,int> mp;\\n        for(int i = 0;i<arr.size();i++){\\n            mp[arr[i]] = i;\\n        }\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        vector<int> rmin(n),cmin(m);\\n        for(int i = 0;i<n;i++){\\n            int maxi = INT_MIN;\\n            for(int j = 0;j<m;j++){\\n                maxi = max(maxi,mp[mat[i][j]]);\\n                cmin[j] = max(cmin[j],mp[mat[i][j]]);\\n            }\\n            rmin[i] = maxi;\\n        }\\n        int ans = INT_MAX;\\n        for(auto e:rmin)\\n            ans = min(e,ans);\\n        for(auto e:cmin){\\n            ans = min(e,ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        unordered_map<int,int> mp;\\n        for(int i = 0;i<arr.size();i++){\\n            mp[arr[i]] = i;\\n        }\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        vector<int> rmin(n),cmin(m);\\n        for(int i = 0;i<n;i++){\\n            int maxi = INT_MIN;\\n            for(int j = 0;j<m;j++){\\n                maxi = max(maxi,mp[mat[i][j]]);\\n                cmin[j] = max(cmin[j],mp[mat[i][j]]);\\n            }\\n            rmin[i] = maxi;\\n        }\\n        int ans = INT_MAX;\\n        for(auto e:rmin)\\n            ans = min(e,ans);\\n        for(auto e:cmin){\\n            ans = min(e,ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3675043,
                "title": "easiest-solution-java-o-m-n",
                "content": "\\n# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int len = arr.length;\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i = 0; i < len; i++){\\n            map.put(arr[i], i);\\n        }\\n        int res = Integer.MAX_VALUE;\\n        for(int i = 0; i < m; i++){\\n            int curr = -1;\\n            for(int j = 0; j < n; j++){\\n                curr = Math.max(curr, map.get(mat[i][j]));\\n            }\\n            res = Math.min(res, curr);\\n        }\\n        for(int i = 0; i < n; i++){\\n            int curr = -1;\\n            for(int j = 0; j < m; j++){\\n                curr = Math.max(curr, map.get(mat[j][i]));\\n            }\\n            res = Math.min(res, curr);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int len = arr.length;\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i = 0; i < len; i++){\\n            map.put(arr[i], i);\\n        }\\n        int res = Integer.MAX_VALUE;\\n        for(int i = 0; i < m; i++){\\n            int curr = -1;\\n            for(int j = 0; j < n; j++){\\n                curr = Math.max(curr, map.get(mat[i][j]));\\n            }\\n            res = Math.min(res, curr);\\n        }\\n        for(int i = 0; i < n; i++){\\n            int curr = -1;\\n            for(int j = 0; j < m; j++){\\n                curr = Math.max(curr, map.get(mat[j][i]));\\n            }\\n            res = Math.min(res, curr);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642050,
                "title": "best-approach-with-explanation-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n\\n        int n = arr.length;\\n        int row_size = mat.length;\\n        int col_size = mat[0].length;\\n\\n        Map<Integer, Pair<Integer, Integer>> map = new HashMap<>();\\n\\n        for(int i=0; i<row_size; i++){\\n            for(int j=0; j<col_size; j++){\\n                map.put(mat[i][j], new Pair<>(i, j));\\n            }\\n        }\\n\\n        int[] row = new int[n];\\n        int[] col = new int[n];\\n\\n        for(int i=0; i<n; i++){\\n            int num = arr[i];\\n\\n            int row_indx = map.get(num).getKey(); // give i\\n            int col_indx = map.get(num).getValue(); // give j\\n\\n            row[row_indx]++;\\n            col[col_indx]++;\\n\\n            if(row[row_indx] == col_size || col[col_indx] == row_size){\\n                return i;\\n            }\\n\\n        }\\n        return -1;\\n\\n    }\\n}\\n\\n\\n// Create a Map object to store the mapping between the elements of arr and their corresponding coordinates in mat.\\n\\n// Initialize two arrays row and col to store the number of times each row and column in mat has been visited.\\n\\n// Iterate over the elements of arr and do the following:\\n     // Get the row and column coordinates of the current element from the Map object.\\n     // Increment the row and col arrays at the corresponding indices.\\n      // If either row or col is equal to the size of the corresponding dimension of mat, then return the current index.\\n\\n// If no index was found, then return -1.\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n\\n        int n = arr.length;\\n        int row_size = mat.length;\\n        int col_size = mat[0].length;\\n\\n        Map<Integer, Pair<Integer, Integer>> map = new HashMap<>();\\n\\n        for(int i=0; i<row_size; i++){\\n            for(int j=0; j<col_size; j++){\\n                map.put(mat[i][j], new Pair<>(i, j));\\n            }\\n        }\\n\\n        int[] row = new int[n];\\n        int[] col = new int[n];\\n\\n        for(int i=0; i<n; i++){\\n            int num = arr[i];\\n\\n            int row_indx = map.get(num).getKey(); // give i\\n            int col_indx = map.get(num).getValue(); // give j\\n\\n            row[row_indx]++;\\n            col[col_indx]++;\\n\\n            if(row[row_indx] == col_size || col[col_indx] == row_size){\\n                return i;\\n            }\\n\\n        }\\n        return -1;\\n\\n    }\\n}\\n\\n\\n// Create a Map object to store the mapping between the elements of arr and their corresponding coordinates in mat.\\n\\n// Initialize two arrays row and col to store the number of times each row and column in mat has been visited.\\n\\n// Iterate over the elements of arr and do the following:\\n     // Get the row and column coordinates of the current element from the Map object.\\n     // Increment the row and col arrays at the corresponding indices.\\n      // If either row or col is equal to the size of the corresponding dimension of mat, then return the current index.\\n\\n// If no index was found, then return -1.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3638707,
                "title": "first-completely-painted-row-or-column-easy-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int r=mat.size();\\n        int c=mat[0].size();\\n        map<int,pair<int,int>> mp;\\n        vector<int> Row_cnt(r,0);\\n        vector<int> Col_cnt(c,0);\\n        int ans=INT_MAX;\\n        for(int i=0;i<r;++i){\\n            for(int j=0;j<c;++j){\\n                 mp[mat[i][j]]={i,j};\\n            }\\n        }\\n        for(int i=0;i<r*c;++i){\\n            auto it=mp[arr[i]];\\n            Row_cnt[it.first]++;\\n            Col_cnt[it.second]++;\\n            if(Row_cnt[it.first]==c && ans>i){\\n                ans=i;\\n                break;\\n            }\\n            if(Col_cnt[it.second]==r && ans>i){\\n                ans=i;\\n                break;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int r=mat.size();\\n        int c=mat[0].size();\\n        map<int,pair<int,int>> mp;\\n        vector<int> Row_cnt(r,0);\\n        vector<int> Col_cnt(c,0);\\n        int ans=INT_MAX;\\n        for(int i=0;i<r;++i){\\n            for(int j=0;j<c;++j){\\n                 mp[mat[i][j]]={i,j};\\n            }\\n        }\\n        for(int i=0;i<r*c;++i){\\n            auto it=mp[arr[i]];\\n            Row_cnt[it.first]++;\\n            Col_cnt[it.second]++;\\n            if(Row_cnt[it.first]==c && ans>i){\\n                ans=i;\\n                break;\\n            }\\n            if(Col_cnt[it.second]==r && ans>i){\\n                ans=i;\\n                break;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636722,
                "title": "golang-keep-track-of-row-and-column-painted-count",
                "content": "# Code\\n```\\nfunc firstCompleteIndex(arr []int, mat [][]int) int {\\n  m, n := len(mat), len(mat[0])\\n  // First we need to know which (row, col) each number refers to.\\n  positions := make([][2]int, len(arr)+1)\\n  for i := 0; i < m; i++ {\\n    for j := 0; j < n; j++ {\\n      positions[mat[i][j]] = [2]int{i, j}\\n    }\\n  }\\n  // rowPainted keeps track of the number of cells painted in each row\\n  rowPainted := make([]int, m)\\n  // colPainted keeps track of the number of cells painted in each column\\n  colPainted := make([]int, n)\\n  var res int\\n  for idx, id := range arr {\\n    i, j := positions[id][0], positions[id][1]\\n    rowPainted[i]++\\n    colPainted[j]++\\n    if rowPainted[i] == n || colPainted[j] == m {\\n      res = idx\\n      break\\n    }\\n  }\\n  return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc firstCompleteIndex(arr []int, mat [][]int) int {\\n  m, n := len(mat), len(mat[0])\\n  // First we need to know which (row, col) each number refers to.\\n  positions := make([][2]int, len(arr)+1)\\n  for i := 0; i < m; i++ {\\n    for j := 0; j < n; j++ {\\n      positions[mat[i][j]] = [2]int{i, j}\\n    }\\n  }\\n  // rowPainted keeps track of the number of cells painted in each row\\n  rowPainted := make([]int, m)\\n  // colPainted keeps track of the number of cells painted in each column\\n  colPainted := make([]int, n)\\n  var res int\\n  for idx, id := range arr {\\n    i, j := positions[id][0], positions[id][1]\\n    rowPainted[i]++\\n    colPainted[j]++\\n    if rowPainted[i] == n || colPainted[j] == m {\\n      res = idx\\n      break\\n    }\\n  }\\n  return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3636402,
                "title": "bruteforce-code-to-map-freqarray-optimization",
                "content": "# 1. BruteForce Code, TLE\\n#### Complexity\\n- Time Complexity : **O(len * (Row * Col + Row + Col))**\\n- Space Complexity : **O(1)**\\n```\\nclass Solution {\\n    private static boolean isDone(int row, int col, int[][] mat){\\n        int Row = mat.length, Col = mat[0].length;\\n        boolean isColDone = true, isRowDone = true;\\n        for(int c=0;c<Col;c++){\\n            if(mat[row][c]!=-1){\\n                isColDone = false;\\n                break;\\n            }\\n        }\\n        for(int r=0;r<Row;r++){\\n            if(mat[r][col]!=-1){\\n                isRowDone = false;\\n                break;\\n            }\\n        }\\n        return isColDone || isRowDone;\\n    }\\n\\n    private static boolean paint(int value, int[][] mat){\\n        for(int row=0;row<mat.length;row++){\\n            for(int col=0;col<mat[0].length;col++){\\n                if(mat[row][col]==value){\\n                    mat[row][col] = -1;\\n                    if(isDone(row,col,mat)) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private static int fun(int[] arr, int[][] mat){\\n        int len = arr.length, Row = mat.length, Col = mat[0].length, limit = Row*Col;\\n        for(int index=0;index<len;index++){\\n            int value = arr[index];\\n            boolean isDone = paint(value,mat);\\n            if(isDone) return index;\\n            else continue;\\n        }\\n        return len-1;\\n    }\\n\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        return fun(arr,mat);\\n    }\\n}\\n\\n// Brute Force Code \\n// Time Complexity : O(len * (Row*Col + Row + Col))\\n// Space Complexity : O(1)\\n```\\n---\\n# 2. Optimized Code [Map + FreqArray], Accepted\\n#### Complexity\\n- Time Complexity : **O(Row * Col + Row * Col + len)**\\n- Space Complexity : **O(Row * Col + Row + Col)**\\n```\\nclass Pair{\\n    int row, col;\\n    Pair(int row, int col){\\n        this.row = row;\\n        this.col = col;\\n    }\\n}\\nclass Solution {\\n\\n    private static int paint(int[] arr, int[][] mat, Map<Integer,Pair> map,int[] rowFill,int[] colFill){\\n        int len = arr.length, Row = mat.length, Col = mat[0].length;\\n        for(int index=0;index<len;index++){\\n            int value = arr[index];\\n            Pair curPair = map.get(value);\\n            int row = curPair.row, col = curPair.col;\\n            rowFill[row]--;\\n            colFill[col]--;\\n            mat[row][col] = -1;\\n            if(rowFill[row]==0 || colFill[col]==0) return index;\\n        }\\n        return len-1;\\n    }\\n\\n    private static int fun(int[] arr, int[][] mat){\\n        int len = arr.length, Row = mat.length, Col = mat[0].length;\\n        Map<Integer,Pair> map = new HashMap<>();\\n        for(int row=0;row<Row;row++){\\n            for(int col=0;col<Col;col++){\\n                map.put(mat[row][col], new Pair(row,col));\\n            }\\n        }\\n        int[] rowFill = new int[Row], colFill = new int[Col];\\n        Arrays.fill(rowFill,Col);\\n        Arrays.fill(colFill,Row);\\n        return paint(arr,mat,map,rowFill,colFill);\\n    }\\n\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        return fun(arr,mat);\\n    }\\n}\\n\\n// Optimized Code \\n// Time Complexity : O(Row*Col + Row*Col + len)\\n// Space Complexity : O(Row*Col + Row + Col)\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\n    private static boolean isDone(int row, int col, int[][] mat){\\n        int Row = mat.length, Col = mat[0].length;\\n        boolean isColDone = true, isRowDone = true;\\n        for(int c=0;c<Col;c++){\\n            if(mat[row][c]!=-1){\\n                isColDone = false;\\n                break;\\n            }\\n        }\\n        for(int r=0;r<Row;r++){\\n            if(mat[r][col]!=-1){\\n                isRowDone = false;\\n                break;\\n            }\\n        }\\n        return isColDone || isRowDone;\\n    }\\n\\n    private static boolean paint(int value, int[][] mat){\\n        for(int row=0;row<mat.length;row++){\\n            for(int col=0;col<mat[0].length;col++){\\n                if(mat[row][col]==value){\\n                    mat[row][col] = -1;\\n                    if(isDone(row,col,mat)) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private static int fun(int[] arr, int[][] mat){\\n        int len = arr.length, Row = mat.length, Col = mat[0].length, limit = Row*Col;\\n        for(int index=0;index<len;index++){\\n            int value = arr[index];\\n            boolean isDone = paint(value,mat);\\n            if(isDone) return index;\\n            else continue;\\n        }\\n        return len-1;\\n    }\\n\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        return fun(arr,mat);\\n    }\\n}\\n\\n// Brute Force Code \\n// Time Complexity : O(len * (Row*Col + Row + Col))\\n// Space Complexity : O(1)\\n```\n```\\nclass Pair{\\n    int row, col;\\n    Pair(int row, int col){\\n        this.row = row;\\n        this.col = col;\\n    }\\n}\\nclass Solution {\\n\\n    private static int paint(int[] arr, int[][] mat, Map<Integer,Pair> map,int[] rowFill,int[] colFill){\\n        int len = arr.length, Row = mat.length, Col = mat[0].length;\\n        for(int index=0;index<len;index++){\\n            int value = arr[index];\\n            Pair curPair = map.get(value);\\n            int row = curPair.row, col = curPair.col;\\n            rowFill[row]--;\\n            colFill[col]--;\\n            mat[row][col] = -1;\\n            if(rowFill[row]==0 || colFill[col]==0) return index;\\n        }\\n        return len-1;\\n    }\\n\\n    private static int fun(int[] arr, int[][] mat){\\n        int len = arr.length, Row = mat.length, Col = mat[0].length;\\n        Map<Integer,Pair> map = new HashMap<>();\\n        for(int row=0;row<Row;row++){\\n            for(int col=0;col<Col;col++){\\n                map.put(mat[row][col], new Pair(row,col));\\n            }\\n        }\\n        int[] rowFill = new int[Row], colFill = new int[Col];\\n        Arrays.fill(rowFill,Col);\\n        Arrays.fill(colFill,Row);\\n        return paint(arr,mat,map,rowFill,colFill);\\n    }\\n\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        return fun(arr,mat);\\n    }\\n}\\n\\n// Optimized Code \\n// Time Complexity : O(Row*Col + Row*Col + len)\\n// Space Complexity : O(Row*Col + Row + Col)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623170,
                "title": "java-solution-easy-to-understand-o-n-m",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhashing the arr array via its index\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nget max index of painting each row and col and getting min of all of them\\n\\n# Complexity\\n- Time complexity: O(n * m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int ans = mat.length * mat[0].length ;\\n        for(int i = 0; i < arr.length; i++){\\n            map.put(arr[i], i);\\n        }\\n        \\n        for(int i = 0; i < mat.length ; i++){\\n            int maxV = 0;\\n            for(int j = 0; j < mat[0].length; j++){\\n                maxV = Math.max(maxV, map.get(mat[i][j]));\\n            }\\n            ans = Math.min(ans, maxV);\\n        }\\n        for(int i = 0; i < mat[0].length ; i++){\\n            int maxV = 0;\\n            for(int j = 0; j < mat.length; j++){\\n                maxV = Math.max(maxV, map.get(mat[j][i]));\\n            }\\n            ans = Math.min(ans, maxV);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int ans = mat.length * mat[0].length ;\\n        for(int i = 0; i < arr.length; i++){\\n            map.put(arr[i], i);\\n        }\\n        \\n        for(int i = 0; i < mat.length ; i++){\\n            int maxV = 0;\\n            for(int j = 0; j < mat[0].length; j++){\\n                maxV = Math.max(maxV, map.get(mat[i][j]));\\n            }\\n            ans = Math.min(ans, maxV);\\n        }\\n        for(int i = 0; i < mat[0].length ; i++){\\n            int maxV = 0;\\n            for(int j = 0; j < mat.length; j++){\\n                maxV = Math.max(maxV, map.get(mat[j][i]));\\n            }\\n            ans = Math.min(ans, maxV);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618000,
                "title": "java-map-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution { \\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int m = mat.length; int n = mat[0].length;\\n        Map<Integer,int[]> map = new HashMap<>();\\n \\n // these arrays values means how many grids are painted at particular row or col \\n        int[]rows = new int[m];\\n        int[]cols = new int[n];\\n\\n        for(int i = 0;i<m;i++){//map will store r,c of every value \\n            for(int j = 0;j<n;j++){\\n                map.put(mat[i][j],new int[]{i,j});\\n            }            \\n        }\\n\\n        for(int i = 0;i<m*n;i++){\\n           int[]curr =  map.get(arr[i]);// get curr num\\'s (r,c) from map\\n//when ever value is painted, just increment row and col at r and c index resp.\\n\\n           rows[curr[0]]++;   \\n           cols[curr[1]]++;\\n\\n// at last check is particular row or col fully painted?\\n// conditions are as follwing to check full painted row and col\\n           if(rows[curr[0]] == n){\\n               return i;\\n           }\\n           if(cols[curr[1]] == m){\\n               return i;\\n           } \\n            \\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution { \\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int m = mat.length; int n = mat[0].length;\\n        Map<Integer,int[]> map = new HashMap<>();\\n \\n // these arrays values means how many grids are painted at particular row or col \\n        int[]rows = new int[m];\\n        int[]cols = new int[n];\\n\\n        for(int i = 0;i<m;i++){//map will store r,c of every value \\n            for(int j = 0;j<n;j++){\\n                map.put(mat[i][j],new int[]{i,j});\\n            }            \\n        }\\n\\n        for(int i = 0;i<m*n;i++){\\n           int[]curr =  map.get(arr[i]);// get curr num\\'s (r,c) from map\\n//when ever value is painted, just increment row and col at r and c index resp.\\n\\n           rows[curr[0]]++;   \\n           cols[curr[1]]++;\\n\\n// at last check is particular row or col fully painted?\\n// conditions are as follwing to check full painted row and col\\n           if(rows[curr[0]] == n){\\n               return i;\\n           }\\n           if(cols[curr[1]] == m){\\n               return i;\\n           } \\n            \\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617816,
                "title": "first-completely-painted-row-or-column-easy-approach-one-map",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) \\n    {\\n        unordered_map<int,int>m;\\n        int a = mat.size();\\n        int b = mat[0].size();\\n\\n        for(int i = 0; i<arr.size(); i++)\\n        {\\n            m[arr[i]] = i;\\n        }\\n\\n        int res = a*b;\\n\\n        for(int i = 0; i<a; i++)\\n        {\\n            int maxi = 0;\\n            for(int j = 0; j<b; j++)\\n            {\\n                maxi = max(maxi,m[mat[i][j]]);\\n            }\\n            res = min(res,maxi);\\n        }\\n\\n        for(int i = 0; i<b; i++)\\n        {\\n            int maxi = 0;\\n            for(int j = 0; j<a; j++)\\n            {\\n                maxi = max(maxi,m[mat[j][i]]);\\n            }\\n            res = min(res,maxi);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) \\n    {\\n        unordered_map<int,int>m;\\n        int a = mat.size();\\n        int b = mat[0].size();\\n\\n        for(int i = 0; i<arr.size(); i++)\\n        {\\n            m[arr[i]] = i;\\n        }\\n\\n        int res = a*b;\\n\\n        for(int i = 0; i<a; i++)\\n        {\\n            int maxi = 0;\\n            for(int j = 0; j<b; j++)\\n            {\\n                maxi = max(maxi,m[mat[i][j]]);\\n            }\\n            res = min(res,maxi);\\n        }\\n\\n        for(int i = 0; i<b; i++)\\n        {\\n            int maxi = 0;\\n            for(int j = 0; j<a; j++)\\n            {\\n                maxi = max(maxi,m[mat[j][i]]);\\n            }\\n            res = min(res,maxi);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617166,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        Map<Integer,Integer> map = new HashMap();\\n        for(int i=0; i<arr.length; i++) map.put(arr[i],i);\\n        int min = arr.length;\\n        for(int i=0; i<mat.length; i++){\\n            int max = 0;\\n            for(int j=0; j<mat[0].length; j++){\\n                max = Math.max(max, map.get(mat[i][j]));\\n            }\\n            min = Math.min(min,max);\\n        }\\n        for(int i=0; i<mat[0].length; i++){\\n            int max = 0;\\n            for(int j=0; j<mat.length; j++){\\n                max = Math.max(max, map.get(mat[j][i]));\\n            }\\n            min = Math.min(min,max);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        Map<Integer,Integer> map = new HashMap();\\n        for(int i=0; i<arr.length; i++) map.put(arr[i],i);\\n        int min = arr.length;\\n        for(int i=0; i<mat.length; i++){\\n            int max = 0;\\n            for(int j=0; j<mat[0].length; j++){\\n                max = Math.max(max, map.get(mat[i][j]));\\n            }\\n            min = Math.min(min,max);\\n        }\\n        for(int i=0; i<mat[0].length; i++){\\n            int max = 0;\\n            for(int j=0; j<mat.length; j++){\\n                max = Math.max(max, map.get(mat[j][i]));\\n            }\\n            min = Math.min(min,max);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3605986,
                "title": "javascript-logic-w-map",
                "content": "# Code\\n```\\n// Time: O(m*n) | Space: O(m*n)\\nvar firstCompleteIndex = function(arr, mat) {\\n    const m = mat.length;\\n    const n = mat[0].length;\\n    const map = {};\\n    const cols = Array(n).fill(m);\\n    const rows = Array(m).fill(n);\\n    for (let i = 0; i < m; i++) {\\n        for (let j = 0; j < n; j++) {\\n            map[mat[i][j]] = [i, j];\\n        }\\n    }\\n    for (let k = 0; k < arr.length; k++) {\\n        let [i, j] = map[arr[k]];\\n        rows[i]--;\\n        if (rows[i] === 0) return k;\\n        cols[j]--;\\n        if (cols[j] === 0) return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// Time: O(m*n) | Space: O(m*n)\\nvar firstCompleteIndex = function(arr, mat) {\\n    const m = mat.length;\\n    const n = mat[0].length;\\n    const map = {};\\n    const cols = Array(n).fill(m);\\n    const rows = Array(m).fill(n);\\n    for (let i = 0; i < m; i++) {\\n        for (let j = 0; j < n; j++) {\\n            map[mat[i][j]] = [i, j];\\n        }\\n    }\\n    for (let k = 0; k < arr.length; k++) {\\n        let [i, j] = map[arr[k]];\\n        rows[i]--;\\n        if (rows[i] === 0) return k;\\n        cols[j]--;\\n        if (cols[j] === 0) return k;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3600542,
                "title": "java-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n```\\n        num in paint[] is also contained in matrix[r][c] \\n        so paint[i] = matrix[r][c] = num and all the num value in both paint[]\\n        and matrix[][] are unique as num is one of these values [1 to ROW * COL]\\n        \\n        This question requires that we should return an index \\'i\\' from paint[]\\n        where uptil this i-th index either a row or col in matrix must have been\\n        completely painted.\\n        \\n        we know that we have rows = ROW and each contains cells that counts to COL\\n        similarly we have cols = COL and each contains cells that counts to ROW\\n        \\n        //hence each unpaintedCellsInEachRow has cell equals to COL\\n        row1 = [COL]\\n        row2 = [COL]\\n        row3 = [COL]\\n        \\n        //hence each unpaintedCellsInEachCol has cell equals to ROW\\n        col1    col2    col3\\n        [ROW]   [ROW]   [ROW]\\n        \\n        each time we get a num from paint[i] then num in matrix must be painted\\n        that num in matrix[][] is store in numCellsMap as int[]{row, col}\\n        \\n        then this num = matrix[][] = cells(row, col) should be painted in\\n        unpaintedCellsInEachRow on row\\n        and \\n        unpaintedCellsInEachCol on col\\n        \\n        if at any time\\n        unpaintedCellsInEachRow[row] == 0\\n        or unpaintedCellsInEachCol[col] == 0\\n        means we have painted either a row or col in matrix[][]\\n        return that \\'i\\'\\n```\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(ROW + COL + (ROW * COL) + Len) \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n\\n        int len = arr.length;\\n\\n        int ROW = mat.length;\\n        int COL = mat[0].length;\\n        \\n        //each row have COL amount of cells to be painted\\n        /*\\n        row1 [COL]\\n        row2 [COL]\\n        */\\n        int[] unpaintedCellsInRows = new int[ROW];\\n        Arrays.fill(unpaintedCellsInRows, COL);\\n\\n        //each col have ROW amount of cells to be painted\\n        /*\\n        col1    col2\\n        [ROW]   [ROW]\\n        */\\n        int[] unpaintedCellsInCols = new int[COL];\\n        Arrays.fill(unpaintedCellsInCols, ROW);\\n\\n        Map<Integer, int[]> numCellMap = new HashMap<>();\\n\\n        for(int r = 0; r < ROW; r++){\\n            for(int c = 0; c < COL; c++){\\n                numCellMap.put(mat[r][c], new int[]{r, c});\\n            }\\n        }\\n\\n        for(int i = 0; i < len; i++){\\n\\n            int num = arr[i];\\n\\n            int[] currCell = numCellMap.get(num);\\n\\n            int row = currCell[0];\\n            int col = currCell[1];\\n\\n            unpaintedCellsInRows[row]--;\\n            if(unpaintedCellsInRows[row] == 0) return i;\\n\\n            unpaintedCellsInCols[col]--;\\n            if(unpaintedCellsInCols[col] == 0) return i;\\n        }\\n        return len - 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n        num in paint[] is also contained in matrix[r][c] \\n        so paint[i] = matrix[r][c] = num and all the num value in both paint[]\\n        and matrix[][] are unique as num is one of these values [1 to ROW * COL]\\n        \\n        This question requires that we should return an index \\'i\\' from paint[]\\n        where uptil this i-th index either a row or col in matrix must have been\\n        completely painted.\\n        \\n        we know that we have rows = ROW and each contains cells that counts to COL\\n        similarly we have cols = COL and each contains cells that counts to ROW\\n        \\n        //hence each unpaintedCellsInEachRow has cell equals to COL\\n        row1 = [COL]\\n        row2 = [COL]\\n        row3 = [COL]\\n        \\n        //hence each unpaintedCellsInEachCol has cell equals to ROW\\n        col1    col2    col3\\n        [ROW]   [ROW]   [ROW]\\n        \\n        each time we get a num from paint[i] then num in matrix must be painted\\n        that num in matrix[][] is store in numCellsMap as int[]{row, col}\\n        \\n        then this num = matrix[][] = cells(row, col) should be painted in\\n        unpaintedCellsInEachRow on row\\n        and \\n        unpaintedCellsInEachCol on col\\n        \\n        if at any time\\n        unpaintedCellsInEachRow[row] == 0\\n        or unpaintedCellsInEachCol[col] == 0\\n        means we have painted either a row or col in matrix[][]\\n        return that \\'i\\'\\n```\n```\\nclass Solution {\\n\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n\\n        int len = arr.length;\\n\\n        int ROW = mat.length;\\n        int COL = mat[0].length;\\n        \\n        //each row have COL amount of cells to be painted\\n        /*\\n        row1 [COL]\\n        row2 [COL]\\n        */\\n        int[] unpaintedCellsInRows = new int[ROW];\\n        Arrays.fill(unpaintedCellsInRows, COL);\\n\\n        //each col have ROW amount of cells to be painted\\n        /*\\n        col1    col2\\n        [ROW]   [ROW]\\n        */\\n        int[] unpaintedCellsInCols = new int[COL];\\n        Arrays.fill(unpaintedCellsInCols, ROW);\\n\\n        Map<Integer, int[]> numCellMap = new HashMap<>();\\n\\n        for(int r = 0; r < ROW; r++){\\n            for(int c = 0; c < COL; c++){\\n                numCellMap.put(mat[r][c], new int[]{r, c});\\n            }\\n        }\\n\\n        for(int i = 0; i < len; i++){\\n\\n            int num = arr[i];\\n\\n            int[] currCell = numCellMap.get(num);\\n\\n            int row = currCell[0];\\n            int col = currCell[1];\\n\\n            unpaintedCellsInRows[row]--;\\n            if(unpaintedCellsInRows[row] == 0) return i;\\n\\n            unpaintedCellsInCols[col]--;\\n            if(unpaintedCellsInCols[col] == 0) return i;\\n        }\\n        return len - 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598464,
                "title": "solution-using-java-and-hashmaps-with-intuition-and-approach-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to know when a row/column is painted.\\nHow do we know if a cell is painted?\\n\\nWe can create a row and column identifiers and keep incrementing them by 1 when a cell gets painted in them.\\nWhenever the total for a row reaches \"m\" then we know that the row has been painted.\\nWhenever the total for a column reaches \"n\" then we know that the column has been painted.\\n\\nAt this moment we stop painting and return the index at which the column or row were painted.\\n\\nHow do we store the row and column identifiers? We could use a hashmap.\\n\\nHow do we name the identifiers? We could use the rx and cx where x would be the index/number of the row/column.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe start by iterating over the input array.\\nIn every iteration, we find the cell and paint it.\\nWhat do we mean paint it? We simply find its (row, column) identifier and increment the total of that column/row.\\n\\nHow do we find the cell location aka (row, column) identifier?\\nIterate over the 2-dimensional array and store the row, column identifier for each number in hashmap. The insertion and lookup will be O(1).\\n\\n# Complexity\\n## Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m * n) - this is the time complexity for pre-processing the matrix and storing the cell locations in the hashmap.\\nO(m * n) - this is the time complexity for traversing through the final array of numbers.\\nSince, insertion and lookup in hashmap is of complexity O(1), it can be ignored.\\n\\nTotal time complexity = O (m * n)\\n\\n## Space complexity:\\nO(m + n) - for storing the painted cells in rows and columns\\nO(m * n) - for storing the cell locations since there would be (m * n) cells.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        // A map that store the key as the number and value as its cell location in form (row, col).\\n        Map<Integer, String> cellLocations = new HashMap<>();\\n        // A map that will store the key as each individual row and column,\\n        // the value will be total cells in that row/column that have been painted.\\n        Map<String, Integer> totalCellsPaintedInRowCol = new HashMap<>();\\n        int totalRows = mat.length;\\n        int totalColumns = mat[0].length;\\n        int answer = 0;\\n\\n        for (int row = 0; row < mat.length; row++) {\\n            for (int col = 0; col < mat[row].length; col++) {\\n                cellLocations.put(mat[row][col], row + \",\" + col);\\n            }\\n        }\\n\\n        for (int i = 0; i < arr.length; i++) {\\n            String currentCellLocation = cellLocations.get(arr[i]);\\n            String row = \"r\" + currentCellLocation.split(\",\")[0];\\n            String col = \"c\" + currentCellLocation.split(\",\")[1];\\n\\n            // Update the total for the number\\'s row\\n            if (totalCellsPaintedInRowCol.containsKey(row)) {\\n                totalCellsPaintedInRowCol.put(row, totalCellsPaintedInRowCol.get(row) + 1);\\n            } else {\\n                totalCellsPaintedInRowCol.put(row, 1);\\n            }\\n            // Update the total for the number\\'s column\\n            if (totalCellsPaintedInRowCol.containsKey(col)) {\\n                totalCellsPaintedInRowCol.put(col, totalCellsPaintedInRowCol.get(col) + 1);\\n            } else {\\n                totalCellsPaintedInRowCol.put(col, 1);\\n            }\\n            // By updating the row and column total, we have completed painting the cell.\\n            // Now, we will check if that current row or column have been completely painted or not?\\n            // If they have then we simply return the current index as the answer or else we iterate to the next number is arr.\\n            if (totalCellsPaintedInRowCol.get(row) == totalColumns || totalCellsPaintedInRowCol.get(col) == totalRows) {\\n                answer = i;\\n                break;\\n            }\\n\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        // A map that store the key as the number and value as its cell location in form (row, col).\\n        Map<Integer, String> cellLocations = new HashMap<>();\\n        // A map that will store the key as each individual row and column,\\n        // the value will be total cells in that row/column that have been painted.\\n        Map<String, Integer> totalCellsPaintedInRowCol = new HashMap<>();\\n        int totalRows = mat.length;\\n        int totalColumns = mat[0].length;\\n        int answer = 0;\\n\\n        for (int row = 0; row < mat.length; row++) {\\n            for (int col = 0; col < mat[row].length; col++) {\\n                cellLocations.put(mat[row][col], row + \",\" + col);\\n            }\\n        }\\n\\n        for (int i = 0; i < arr.length; i++) {\\n            String currentCellLocation = cellLocations.get(arr[i]);\\n            String row = \"r\" + currentCellLocation.split(\",\")[0];\\n            String col = \"c\" + currentCellLocation.split(\",\")[1];\\n\\n            // Update the total for the number\\'s row\\n            if (totalCellsPaintedInRowCol.containsKey(row)) {\\n                totalCellsPaintedInRowCol.put(row, totalCellsPaintedInRowCol.get(row) + 1);\\n            } else {\\n                totalCellsPaintedInRowCol.put(row, 1);\\n            }\\n            // Update the total for the number\\'s column\\n            if (totalCellsPaintedInRowCol.containsKey(col)) {\\n                totalCellsPaintedInRowCol.put(col, totalCellsPaintedInRowCol.get(col) + 1);\\n            } else {\\n                totalCellsPaintedInRowCol.put(col, 1);\\n            }\\n            // By updating the row and column total, we have completed painting the cell.\\n            // Now, we will check if that current row or column have been completely painted or not?\\n            // If they have then we simply return the current index as the answer or else we iterate to the next number is arr.\\n            if (totalCellsPaintedInRowCol.get(row) == totalColumns || totalCellsPaintedInRowCol.get(col) == totalRows) {\\n                answer = i;\\n                break;\\n            }\\n\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598179,
                "title": "problem-2661-first-completely-painted-row-or-column-easy-solution-using-unordered-map-in-c",
                "content": "# Intuition\\nAn unordered map with three elements each can be used to tackle the problem here.\\n\\n# Approach\\nAt first, an unordered map is declared having values *int*, and *pair* of *ints*. Here, the first *int* represents the value of an element in the matrix and the *pair* represents the address of the element in the matrix.\\n\\nAlong with that, two arrays of sizes *m* and *n* are created to store the number of elements painted in each row and column of the matrix.\\n\\nThe unordered map is initialised with the address of all the elements in the matrix using the *for* loop.\\n\\nAfter that, the given array is traversed one by one, and corresponding to the address of the element in the unordered map, the values in *rows* and *columns* are incremented, marking the fact that one more element in that row/column has been painted.\\n\\nIf the number of rows or columns painted at any point matches the total number of rows/columns, the index of array at which this is achieved is simply returned.\\n\\n# Complexity\\n- Time complexity:\\nSince there are two *for* loops corresponding to the rows *m* and columns *n* of the matrix intertwined, the time complexity for this solution is **O(mn)**.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n    int i=mat.size(), j=mat[0].size(), k=arr.size();\\n    vector<int> rows(i);\\n    vector<int> columns(j); \\n    unordered_map<int,pair<int,int>> map;\\n\\n    for(int n=0;n<i;n++)\\n        for(int p=0;p<j;p++)\\n        {\\n            map[mat[n][p]].first=n;\\n            map[mat[n][p]].second=p;\\n            \\n        }\\n\\n    for(int n=0;n<k;n++)\\n    {\\n        int x=arr[n];\\n        rows[map[x].first]++;\\n        columns[map[x].second]++;\\n\\n        if(rows[map[x].first]==j || columns[map[x].second]==i)\\n            return n;\\n    }\\n\\n    return 0;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n    int i=mat.size(), j=mat[0].size(), k=arr.size();\\n    vector<int> rows(i);\\n    vector<int> columns(j); \\n    unordered_map<int,pair<int,int>> map;\\n\\n    for(int n=0;n<i;n++)\\n        for(int p=0;p<j;p++)\\n        {\\n            map[mat[n][p]].first=n;\\n            map[mat[n][p]].second=p;\\n            \\n        }\\n\\n    for(int n=0;n<k;n++)\\n    {\\n        int x=arr[n];\\n        rows[map[x].first]++;\\n        columns[map[x].second]++;\\n\\n        if(rows[map[x].first]==j || columns[map[x].second]==i)\\n            return n;\\n    }\\n\\n    return 0;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592586,
                "title": "hash-o-m-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nusing hash, tracking paint count each rows and cols (aux space is M, N)\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- 1 Make (key, value) hash to find (r,c) at each paint\\n- 2 feed-forward array query, and tracking rows and cols status\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        m, n = len(mat), len(mat[0])\\n        rows = [0] * m\\n        cols = [0] * n\\n\\n        paint = defaultdict(lambda :(-1,-1))\\n        \\n        for r in range(m):\\n            for c in range(n):\\n                paint[mat[r][c]] = (r,c)\\n\\n        for i in range(len(arr)):\\n            r,c = paint[arr[i]]\\n\\n            rows[r] +=1\\n            cols[c] +=1\\n            \\n\\n            if rows[r] == n or cols[c] == m:\\n                return i\\n\\n        return m*n -1\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        m, n = len(mat), len(mat[0])\\n        rows = [0] * m\\n        cols = [0] * n\\n\\n        paint = defaultdict(lambda :(-1,-1))\\n        \\n        for r in range(m):\\n            for c in range(n):\\n                paint[mat[r][c]] = (r,c)\\n\\n        for i in range(len(arr)):\\n            r,c = paint[arr[i]]\\n\\n            rows[r] +=1\\n            cols[c] +=1\\n            \\n\\n            if rows[r] == n or cols[c] == m:\\n                return i\\n\\n        return m*n -1\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3589982,
                "title": "swift-tle-optimised-88-faster",
                "content": "# Intitial approach (TLE)\\n##### Complexity\\n- Time complexity: $$O(m^2*n^2)$$\\n- Space complexity: $$O(m + n)$$\\n```\\nclass Solution {\\n    func firstCompleteIndex(_ arr: [Int], _ mat: [[Int]]) -> Int {\\n        let (m, n) = (mat.count, mat[0].count)\\n        var row = Array(repeating: 0, count: m)\\n        var col = Array(repeating: 0, count: n)\\n        for (k, target) in arr.enumerated() {\\n            for x in 0..<m {\\n                for y in 0..<n {\\n                    if mat[x][y] == target {\\n                        row[x] += 1\\n                        col[y] += 1\\n                        if row[x] == n || col[y] == m {\\n                            return k\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return arr.count\\n    }\\n}\\n```\\n\\n# Optimized approach \\n##### Complexity\\n- Time complexity: $$O(m*n)$$\\n- Space complexity: $$O(m + n + m*n)$$\\n```\\nclass Solution {\\n    func firstCompleteIndex(_ arr: [Int], _ mat: [[Int]]) -> Int {\\n        let (m, n) = (mat.count, mat[0].count)\\n        var row = Array(repeating: 0, count: m)\\n        var col = Array(repeating: 0, count: n)\\n        var coord: [Int: (Int, Int)] = [:]\\n        for i in 0..<m {\\n            for j in 0..<n {\\n                coord[mat[i][j]] = (i, j)\\n            }\\n        }\\n        for (k, target) in arr.enumerated() {\\n            let (x, y) = coord[target]!\\n            row[x] += 1\\n            col[y] += 1\\n            if row[x] == n || col[y] == m {\\n                return k\\n            }\\n        }\\n        return arr.count\\n    }\\n}",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func firstCompleteIndex(_ arr: [Int], _ mat: [[Int]]) -> Int {\\n        let (m, n) = (mat.count, mat[0].count)\\n        var row = Array(repeating: 0, count: m)\\n        var col = Array(repeating: 0, count: n)\\n        for (k, target) in arr.enumerated() {\\n            for x in 0..<m {\\n                for y in 0..<n {\\n                    if mat[x][y] == target {\\n                        row[x] += 1\\n                        col[y] += 1\\n                        if row[x] == n || col[y] == m {\\n                            return k\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return arr.count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3589208,
                "title": "inefficient-but-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n\\n        set<int> rows[m];\\n        set<int> cols[n];\\n\\n        unordered_map<int, pair<int,int>> umap;\\n\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                umap[mat[i][j]] = {i,j};\\n            }\\n        }\\n\\n        for(int i=0;i<arr.size();i++){\\n            rows[umap[arr[i]].first].insert(umap[arr[i]].second);\\n            cols[umap[arr[i]].second].insert(umap[arr[i]].first);\\n\\n            if(rows[umap[arr[i]].first].size()==n){\\n                return i;\\n            }\\n\\n            if(cols[umap[arr[i]].second].size()==m){\\n                return i;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n\\n        set<int> rows[m];\\n        set<int> cols[n];\\n\\n        unordered_map<int, pair<int,int>> umap;\\n\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                umap[mat[i][j]] = {i,j};\\n            }\\n        }\\n\\n        for(int i=0;i<arr.size();i++){\\n            rows[umap[arr[i]].first].insert(umap[arr[i]].second);\\n            cols[umap[arr[i]].second].insert(umap[arr[i]].first);\\n\\n            if(rows[umap[arr[i]].first].size()==n){\\n                return i;\\n            }\\n\\n            if(cols[umap[arr[i]].second].size()==m){\\n                return i;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586420,
                "title": "fast-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        // const int size = arr.size();\\n        const int M = mat.size();\\n        if (M==0) return 0;\\n        const int N = mat[0].size();\\n\\n        vector<int> rows(M,0);\\n        vector<int> cols(N,0);\\n\\n        vector<tuple<int, int>> mat_proj(M*N, {0,0});\\n\\n        for (int m=0; m<M; m++) {\\n            for (int n=0; n<N; n++) {\\n                int el = mat[m][n];\\n                mat_proj[el-1] = {m,n};\\n            }\\n        }\\n\\n        int idx=0;\\n        for (const int a : arr) {\\n            tuple<int,int> tup = mat_proj[a-1];\\n            if (++rows[get<0>(tup)] == N || ++cols[get<1>(tup)] == M) return idx;\\n            idx++;\\n        }\\n        return idx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        // const int size = arr.size();\\n        const int M = mat.size();\\n        if (M==0) return 0;\\n        const int N = mat[0].size();\\n\\n        vector<int> rows(M,0);\\n        vector<int> cols(N,0);\\n\\n        vector<tuple<int, int>> mat_proj(M*N, {0,0});\\n\\n        for (int m=0; m<M; m++) {\\n            for (int n=0; n<N; n++) {\\n                int el = mat[m][n];\\n                mat_proj[el-1] = {m,n};\\n            }\\n        }\\n\\n        int idx=0;\\n        for (const int a : arr) {\\n            tuple<int,int> tup = mat_proj[a-1];\\n            if (++rows[get<0>(tup)] == N || ++cols[get<1>(tup)] == M) return idx;\\n            idx++;\\n        }\\n        return idx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580093,
                "title": "solution",
                "content": "# Code\\n```\\nobject Solution {\\n  def firstCompleteIndex(arr: Array[Int], mat: Array[Array[Int]]): Int = {\\n    val (m, n) = (mat.size, mat.head.size)\\n    val (rows, cols) = (Array.fill(m)(n), Array.fill(n)(m))\\n    val ijs = mat.indices.flatMap(i => mat.head.indices.map(j => mat(i)(j) -> (i, j))).toMap\\n    arr.map(ijs).indexWhere { case (i, j) =>\\n      rows(i) = rows(i) - 1\\n      cols(j) = cols(j) - 1\\n      rows(i) == 0 || cols(j) == 0\\n    }\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def firstCompleteIndex(arr: Array[Int], mat: Array[Array[Int]]): Int = {\\n    val (m, n) = (mat.size, mat.head.size)\\n    val (rows, cols) = (Array.fill(m)(n), Array.fill(n)(m))\\n    val ijs = mat.indices.flatMap(i => mat.head.indices.map(j => mat(i)(j) -> (i, j))).toMap\\n    arr.map(ijs).indexWhere { case (i, j) =>\\n      rows(i) = rows(i) - 1\\n      cols(j) = cols(j) - 1\\n      rows(i) == 0 || cols(j) == 0\\n    }\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3576162,
                "title": "first-completely-painted-row-or-column",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        Map<Integer,Integer> hmap = new HashMap<>();\\n\\n        int l = mat.length;\\n        int csize = mat[0].length;\\n        int ans = Integer.MAX_VALUE;\\n\\n        for(int i =0;i<arr.length;i++){\\n            hmap.put(arr[i],i);\\n        }\\n        for(int i=0;i<l;i++){\\n            int value =0;\\n            for(int j =0;j<csize;j++){\\n                value = Math.max(value,hmap.get(mat[i][j]));\\n            }\\n            ans = Math.min(ans,value);\\n        }\\n        for(int i=0;i<csize;i++){\\n            int value =0;\\n            for(int j=0;j<l;j++){\\n                value = Math.max(value,hmap.get(mat[j][i]));\\n            }\\n            ans = Math.min(ans,value);\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        Map<Integer,Integer> hmap = new HashMap<>();\\n\\n        int l = mat.length;\\n        int csize = mat[0].length;\\n        int ans = Integer.MAX_VALUE;\\n\\n        for(int i =0;i<arr.length;i++){\\n            hmap.put(arr[i],i);\\n        }\\n        for(int i=0;i<l;i++){\\n            int value =0;\\n            for(int j =0;j<csize;j++){\\n                value = Math.max(value,hmap.get(mat[i][j]));\\n            }\\n            ans = Math.min(ans,value);\\n        }\\n        for(int i=0;i<csize;i++){\\n            int value =0;\\n            for(int j=0;j<l;j++){\\n                value = Math.max(value,hmap.get(mat[j][i]));\\n            }\\n            ans = Math.min(ans,value);\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568159,
                "title": "mapping",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        vector<int> row(mat.size(), 0);\\n        vector<int> col(mat[0].size(), 0);\\n        map<int, vector<int>> mp;\\n        for(int i=0; i<mat.size(); i++){\\n            for(int j=0; j<mat[0].size(); j++){\\n                mp[mat[i][j]].push_back(i);\\n                mp[mat[i][j]].push_back(j);\\n            }\\n        }\\n        for(int i=0; i<arr.size(); i++){\\n            row[mp[arr[i]][0]]++;\\n            col[mp[arr[i]][1]]++;\\n            if(row[mp[arr[i]][0]]==mat[0].size() || col[mp[arr[i]][1]]==mat.size()) return i;\\n        }\\n        return arr.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        vector<int> row(mat.size(), 0);\\n        vector<int> col(mat[0].size(), 0);\\n        map<int, vector<int>> mp;\\n        for(int i=0; i<mat.size(); i++){\\n            for(int j=0; j<mat[0].size(); j++){\\n                mp[mat[i][j]].push_back(i);\\n                mp[mat[i][j]].push_back(j);\\n            }\\n        }\\n        for(int i=0; i<arr.size(); i++){\\n            row[mp[arr[i]][0]]++;\\n            col[mp[arr[i]][1]]++;\\n            if(row[mp[arr[i]][0]]==mat[0].size() || col[mp[arr[i]][1]]==mat.size()) return i;\\n        }\\n        return arr.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565653,
                "title": "python-o-m-n-by-score-board-w-comment",
                "content": "# Intuition and approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nMaintain a dictionary (i.e., hash table, or mapping table) to save **(x, y) location pair** for each number on the matrix.\\n\\nMaintain other two dictionaries as score board for each column as well as row.\\n\\nPaint matrix cell with given element value, given in input array.\\n\\nUpdate score board for corresponding row y and column x, from location pair(x, y) of current element value.\\n\\nOnce one of them, eitehr column #x or row #y, hits full score, then return current step count as index.\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m*n) : dictionary building of \"location\"\\nO(m*n) : time cost of for loop\\n\\nTo sum up, it is O(m*n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m*n) : space cost of dictionary \"location\"\\n\\nO(m) : space cost of dictionary \"row_score\"\\n\\nO(n) : space cost of dictionary \"col_score\"\\n\\nTo sum up, it is O(m*n)\\n\\n# Code\\n```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n\\n        # h: height of matrix\\n        # w: width of matrix\\n        h, w = len(mat), len(mat[0])\\n\\n        # Mapping table\\n        # key: element value\\n        # value: (x, y) pair of that element\\n        location = { mat[y][x]: (x, y) for y in range(h) for x in range(w)}\\n\\n        # key: row index\\n        # value: score of of corresponding row\\n        row_score = defaultdict(int)\\n\\n        # key: column index\\n        # value: score of of corresponding column\\n        col_score = defaultdict(int)\\n\\n        # Paint with given number, with idx updaing on iteration\\n        for idx, number in enumerate(arr):\\n\\n            # Get location (x, y) of current number\\n            x, y = location[number]\\n\\n            # Update score of (x, y)\\n            row_score[y] += 1\\n            col_score[x] += 1\\n\\n            # Check if we\\'ve painted full row #y, or full column #x\\n            if (row_score[y] == w) or (col_score[x] == h):\\n                return idx\\n\\n        return -1\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n\\n        # h: height of matrix\\n        # w: width of matrix\\n        h, w = len(mat), len(mat[0])\\n\\n        # Mapping table\\n        # key: element value\\n        # value: (x, y) pair of that element\\n        location = { mat[y][x]: (x, y) for y in range(h) for x in range(w)}\\n\\n        # key: row index\\n        # value: score of of corresponding row\\n        row_score = defaultdict(int)\\n\\n        # key: column index\\n        # value: score of of corresponding column\\n        col_score = defaultdict(int)\\n\\n        # Paint with given number, with idx updaing on iteration\\n        for idx, number in enumerate(arr):\\n\\n            # Get location (x, y) of current number\\n            x, y = location[number]\\n\\n            # Update score of (x, y)\\n            row_score[y] += 1\\n            col_score[x] += 1\\n\\n            # Check if we\\'ve painted full row #y, or full column #x\\n            if (row_score[y] == w) or (col_score[x] == h):\\n                return idx\\n\\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3554806,
                "title": "c-solution-simple-beginner-friendly",
                "content": "# Intuition\\nMaintain a map to store indexes according to value and maintain 2 vectors to track count of unmarked cells in each row and each col\\n\\n# Complexity\\n- Time complexity: O(M*N)\\n\\n- Space complexity: O(M*N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        map<int,pair<int,int>> index;\\n        vector<int> cols(mat[0].size()+1,mat.size());\\n        vector<int> rows(mat.size()+1,mat[0].size());\\n        for(int i = 0;i<mat.size();i++){\\n            for(int j = 0;j<mat[0].size();j++){\\n                index[mat[i][j]] = {i,j};\\n            }\\n        }\\n        for(int i = 0;i<arr.size();i++){\\n            int row = index[arr[i]].first;\\n            int col = index[arr[i]].second;\\n            rows[row]--;\\n            cols[col]--;\\n            if(rows[row]==0||cols[col]==0) return i;\\n        }\\n        return 0;\\n    }\\n};\\n```\\nupvote if it helps :)",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        map<int,pair<int,int>> index;\\n        vector<int> cols(mat[0].size()+1,mat.size());\\n        vector<int> rows(mat.size()+1,mat[0].size());\\n        for(int i = 0;i<mat.size();i++){\\n            for(int j = 0;j<mat[0].size();j++){\\n                index[mat[i][j]] = {i,j};\\n            }\\n        }\\n        for(int i = 0;i<arr.size();i++){\\n            int row = index[arr[i]].first;\\n            int col = index[arr[i]].second;\\n            rows[row]--;\\n            cols[col]--;\\n            if(rows[row]==0||cols[col]==0) return i;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544183,
                "title": "java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int m = mat.length, n= mat[0].length;\\n        int[] rowsBingo = new int[n], colsBingo = new int [m];\\n        Map<Integer,Pair<Integer,Integer>> map = new HashMap();\\n        for (int i=0;i<m;i++){\\n            for (int j=0;j<n;j++){\\n                map.put(mat[i][j],new Pair<Integer,Integer>(i,j));\\n            }\\n        }\\n        for (int i=0;i<n*m;i++){\\n            Pair<Integer,Integer> cur = map.get(arr[i]);\\n            rowsBingo[cur.getValue()]++;\\n            colsBingo[cur.getKey()]++;\\n            if (rowsBingo[cur.getValue()]==m ||colsBingo[cur.getKey()]==n) return i;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int m = mat.length, n= mat[0].length;\\n        int[] rowsBingo = new int[n], colsBingo = new int [m];\\n        Map<Integer,Pair<Integer,Integer>> map = new HashMap();\\n        for (int i=0;i<m;i++){\\n            for (int j=0;j<n;j++){\\n                map.put(mat[i][j],new Pair<Integer,Integer>(i,j));\\n            }\\n        }\\n        for (int i=0;i<n*m;i++){\\n            Pair<Integer,Integer> cur = map.get(arr[i]);\\n            rowsBingo[cur.getValue()]++;\\n            colsBingo[cur.getKey()]++;\\n            if (rowsBingo[cur.getValue()]==m ||colsBingo[cur.getKey()]==n) return i;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3543869,
                "title": "easy-to-understand-javascript-hash-beats-100-runtime-beats-90-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction firstCompleteIndex(arr: number[], mat: number[][]): number {\\n    const hash = [];\\n    let smallest = 0;\\n    const n = mat[0].length;\\n    const m = mat.length;\\n    const rows = new Array(m).fill(0);\\n    const columns = new Array(n).fill(0);\\n\\n    for (let i = 0; i < mat.length; i++) {\\n        for (let j = 0; j < mat[i].length; j++) {\\n            hash[mat[i][j]] = { row: i, col: j};\\n        }\\n    }\\n    \\n    for (let i = 0; i < arr.length; i++) {\\n        const { row, col } = hash[arr[i]];\\n\\n        rows[row] += 1;\\n        columns[col] += 1;\\n\\n        if (rows[row] === n || columns[col] === m) {\\n            smallest = i;\\n            break;\\n        }\\n    }\\n\\n    return smallest;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction firstCompleteIndex(arr: number[], mat: number[][]): number {\\n    const hash = [];\\n    let smallest = 0;\\n    const n = mat[0].length;\\n    const m = mat.length;\\n    const rows = new Array(m).fill(0);\\n    const columns = new Array(n).fill(0);\\n\\n    for (let i = 0; i < mat.length; i++) {\\n        for (let j = 0; j < mat[i].length; j++) {\\n            hash[mat[i][j]] = { row: i, col: j};\\n        }\\n    }\\n    \\n    for (let i = 0; i < arr.length; i++) {\\n        const { row, col } = hash[arr[i]];\\n\\n        rows[row] += 1;\\n        columns[col] += 1;\\n\\n        if (rows[row] === n || columns[col] === m) {\\n            smallest = i;\\n            break;\\n        }\\n    }\\n\\n    return smallest;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3541912,
                "title": "simple-clean-math",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int n=mat.size(),m=mat[0].size();\\n\\n        vector<pair<int,int>> pos(m*n+1);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                pos[mat[i][j]]={i,j};\\n            }\\n        }\\n\\n        for(int i=0;i<arr.size();i++){\\n            int x=pos[arr[i]].first,y=pos[arr[i]].second;\\n            mat[x][y]=-i;\\n        }\\n\\n        vector<int> v;\\n        for(int i=0;i<n;i++){\\n            int mini=INT_MAX;\\n            for(int j=0;j<m;j++){\\n                mini=min(mini,mat[i][j]);\\n            }\\n            v.push_back(mini);\\n        }\\n\\n        for(int i=0;i<m;i++){\\n            int mini=INT_MAX;\\n            for(int j=0;j<n;j++){\\n                mini=min(mini,mat[j][i]);\\n            }\\n            v.push_back(mini);\\n        }\\n\\n        sort(v.rbegin(),v.rend());\\n\\n        return -v[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int n=mat.size(),m=mat[0].size();\\n\\n        vector<pair<int,int>> pos(m*n+1);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                pos[mat[i][j]]={i,j};\\n            }\\n        }\\n\\n        for(int i=0;i<arr.size();i++){\\n            int x=pos[arr[i]].first,y=pos[arr[i]].second;\\n            mat[x][y]=-i;\\n        }\\n\\n        vector<int> v;\\n        for(int i=0;i<n;i++){\\n            int mini=INT_MAX;\\n            for(int j=0;j<m;j++){\\n                mini=min(mini,mat[i][j]);\\n            }\\n            v.push_back(mini);\\n        }\\n\\n        for(int i=0;i<m;i++){\\n            int mini=INT_MAX;\\n            for(int j=0;j<n;j++){\\n                mini=min(mini,mat[j][i]);\\n            }\\n            v.push_back(mini);\\n        }\\n\\n        sort(v.rbegin(),v.rend());\\n\\n        return -v[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3537970,
                "title": "simple-code-to-understand",
                "content": "In this question, just have a count of element appeared in particular row and column. When it reaches its row length or column length, that index would be the answer\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        HashMap<Integer,int[]> data = new HashMap<>();\\n        for(int i=0;i<mat.length;i++)\\n            for(int j=0;j<mat[0].length;j++){\\n                int temp[] = {i,j};\\n                data.put(mat[i][j],temp);\\n            }\\n        int row[] = new int[mat[0].length],col[] = new int[mat.length];\\n        for(int j=0;j<arr.length;j++){\\n            int i = arr[j],temp[] = data.get(i);\\n            row[temp[1]]++; col[temp[0]]++;\\n            if(row[temp[1]]==mat.length||col[temp[0]]==mat[0].length) return j;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        HashMap<Integer,int[]> data = new HashMap<>();\\n        for(int i=0;i<mat.length;i++)\\n            for(int j=0;j<mat[0].length;j++){\\n                int temp[] = {i,j};\\n                data.put(mat[i][j],temp);\\n            }\\n        int row[] = new int[mat[0].length],col[] = new int[mat.length];\\n        for(int j=0;j<arr.length;j++){\\n            int i = arr[j],temp[] = data.get(i);\\n            row[temp[1]]++; col[temp[0]]++;\\n            if(row[temp[1]]==mat.length||col[temp[0]]==mat[0].length) return j;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3536408,
                "title": "c-mark-element-then-count-by-row-and-col",
                "content": "\\n```\\nclass Solution \\n{\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) \\n    {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n\\n        unordered_map<int, pair<int, int>> mp;\\n        for (int i = 0; i < m; ++i)\\n        {\\n            for (int j = 0; j < n; ++j)\\n            {\\n                mp[mat[i][j]] = make_pair(i, j);\\n            }\\n        }\\n\\n        vector<int> rows(m), cols(n);\\n        for (int k = 0; k < arr.size(); ++k)\\n        {\\n            auto& [i, j] = mp[arr[k]];\\n            ++rows[i], ++cols[j];\\n\\n            if (rows[i] == n || cols[j] == m)\\n            {\\n                return k;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) \\n    {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n\\n        unordered_map<int, pair<int, int>> mp;\\n        for (int i = 0; i < m; ++i)\\n        {\\n            for (int j = 0; j < n; ++j)\\n            {\\n                mp[mat[i][j]] = make_pair(i, j);\\n            }\\n        }\\n\\n        vector<int> rows(m), cols(n);\\n        for (int k = 0; k < arr.size(); ++k)\\n        {\\n            auto& [i, j] = mp[arr[k]];\\n            ++rows[i], ++cols[j];\\n\\n            if (rows[i] == n || cols[j] == m)\\n            {\\n                return k;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3533736,
                "title": "beats-100-java-c-python-2-approaches",
                "content": "# TL;DR\\n1. Beats 100% (3ms) solution:\\n``` java []\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int n = mat.length, m = mat[0].length;\\n        var ids = new int[arr.length + 1];\\n\\n        for (int i = 0; i < arr.length; i++) {\\n            ids[arr[i]] = i;\\n        }\\n\\n        int minOpId = Integer.MAX_VALUE;\\n        for (int r = 0; r < n; r++) {\\n            int fullRowPaintOpId = -1;\\n            for (int c = 0; c < m; c++) {\\n                fullRowPaintOpId = Math.max(fullRowPaintOpId, ids[mat[r][c]]);\\n            }\\n            minOpId = Math.min(minOpId, fullRowPaintOpId);\\n        }\\n        \\n        for (int c = 0; c < m; c++) {\\n            int fullColPaintOpId = -1;\\n            for (int r = 0; r < n; r++) {\\n                fullColPaintOpId = Math.max(fullColPaintOpId, ids[mat[r][c]]);\\n            }\\n            minOpId = Math.min(minOpId, fullColPaintOpId);\\n        }\\n\\n        return minOpId;\\n    }\\n}\\n```\\n``` cpp []\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int n = mat.size(), m = mat[0].size();\\n        std::vector<int> ids(arr.size() + 1);\\n\\n        for (int i = 0; i < arr.size(); i++) {\\n            ids[arr[i]] = i;\\n        }\\n\\n        int minOpId = INT_MAX;\\n        for (int r = 0; r < n; r++) {\\n            int fullRowPaintOpId = -1;\\n            for (int c = 0; c < m; c++) {\\n                fullRowPaintOpId = std::max(fullRowPaintOpId, ids[mat[r][c]]);\\n            }\\n            minOpId = std::min(minOpId, fullRowPaintOpId);\\n        }\\n\\n        for (int c = 0; c < m; c++) {\\n            int fullColPaintOpId = -1;\\n            for (int r = 0; r < n; r++) {\\n                fullColPaintOpId = std::max(fullColPaintOpId, ids[mat[r][c]]);\\n            }\\n            minOpId = std::min(minOpId, fullColPaintOpId);\\n        }\\n\\n        return minOpId;\\n    }\\n};\\n```\\n``` python []\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        n = len(mat)\\n        m = len(mat[0])\\n        ids = [0]*(len(arr) + 1)\\n\\n        for i in range(len(arr)):\\n            ids[arr[i]] = i\\n\\n        minOpId = float(\\'inf\\')\\n        for r in range(n):\\n            fullRowPaintOpId = -1\\n            for c in range(m):\\n                fullRowPaintOpId = max(fullRowPaintOpId, ids[mat[r][c]])\\n            minOpId = min(minOpId, fullRowPaintOpId)\\n\\n        for c in range(m):\\n            fullColPaintOpId = -1\\n            for r in range(n):\\n                fullColPaintOpId = max(fullColPaintOpId, ids[mat[r][c]])\\n            minOpId = min(minOpId, fullColPaintOpId)\\n\\n        return minOpId\\n```\\n2. Beats 88% (18ms) solution:\\n``` java []\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int n = mat.length, m = mat[0].length;\\n        var coordinates = new int[n * m + 1][2];\\n\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < m; c++) {\\n                coordinates[mat[r][c]] = new int[]{r, c};\\n            }\\n        }\\n\\n        var rows = new int[n];\\n        var columns = new int[m];\\n        for (int i = 0; i < arr.length; i++) {\\n            var cell = coordinates[arr[i]];\\n            if (++rows[cell[0]] == m | ++columns[cell[1]] == n) {\\n                return i;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```\\n``` cpp []\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int n = mat.size(), m = mat[0].size();\\n        std::vector<std::vector<int>> coordinates(n * m + 1, std::vector<int>(2));\\n\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < m; c++) {\\n                coordinates[mat[r][c]][0] = r;\\n                coordinates[mat[r][c]][1] = c;\\n            }\\n        }\\n\\n        std::vector<int> rows(n), columns(m);\\n        for (int i = 0; i < arr.size(); i++) {\\n            auto cell = coordinates[arr[i]];\\n            if (++rows[cell[0]] == m || ++columns[cell[1]] == n) {\\n                return i;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```\\n``` python []\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        n = len(mat)\\n        m = len(mat[0])\\n        coordinates = [[0, 0] for _ in range(n * m + 1)]\\n\\n        for r in range(n):\\n            for c in range(m):\\n                coordinates[mat[r][c]][0] = r\\n                coordinates[mat[r][c]][1] = c\\n\\n        rows = [0]*n\\n        columns = [0]*m\\n        for i in range(len(arr)):\\n            cell = coordinates[arr[i]]\\n            rows[cell[0]] += 1\\n            columns[cell[1]] += 1\\n            if rows[cell[0]] == m or columns[cell[1]] == n:\\n                return i\\n\\n        return -1\\n```\\n\\n---\\n#### \\u26A0\\uFE0F Thank you for your upvote! \\uD83D\\uDE43\\n---\\n\\n# Intuition\\n\\nThe two provided solutions tackle the problem from different perspectives:\\n\\n### Tricky one\\nIn the first approach, we essentially map each value from the matrix to its corresponding index in the array. This mapping allows us to know at what point in the process each cell gets painted.\\n\\nThe for-loops over the rows and columns aim to determine the latest point at which a cell in a particular row or column gets painted. This is achieved by finding the maximum index among the cells in a row or column (which corresponds to the latest point in the painting process). This value is stored in `fullRowPaintOpId` and `fullColPaintOpId` respectively. \\n\\nThe rationale behind this is that for a row or column to be fully painted, even the cell that gets painted last (i.e., the cell with the maximum corresponding index in the array) must be painted. So the maximum index in a row or column represents the earliest point at which that row or column could be fully painted.\\n\\nFinally, we are interested in the earliest point at which ANY row or column gets fully painted. This is determined by finding the minimum value among all the `fullRowPaintOpId`s and `fullColPaintOpId`s.\\n\\n### Simulation\\nThe second approach takes a more direct route. It maps the cell values to their respective coordinates in the matrix. Then it simulates the painting process as described in the array. During the simulation, it keeps track of the number of cells painted in each row and column. As soon as a row or column gets completely painted, it returns the current index.\\n\\n\\n# Complexity Analysis\\n\\n- Time complexity: For both versions the time complexity is $$O(m*n)$$, where $$m$$ is the number of rows and $$n$$ is the number of columns in the matrix. \\n\\n- Space complexity: For both versions the space complexity is $$O(m*n)$$.\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Simulation"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int n = mat.length, m = mat[0].length;\\n        var ids = new int[arr.length + 1];\\n\\n        for (int i = 0; i < arr.length; i++) {\\n            ids[arr[i]] = i;\\n        }\\n\\n        int minOpId = Integer.MAX_VALUE;\\n        for (int r = 0; r < n; r++) {\\n            int fullRowPaintOpId = -1;\\n            for (int c = 0; c < m; c++) {\\n                fullRowPaintOpId = Math.max(fullRowPaintOpId, ids[mat[r][c]]);\\n            }\\n            minOpId = Math.min(minOpId, fullRowPaintOpId);\\n        }\\n        \\n        for (int c = 0; c < m; c++) {\\n            int fullColPaintOpId = -1;\\n            for (int r = 0; r < n; r++) {\\n                fullColPaintOpId = Math.max(fullColPaintOpId, ids[mat[r][c]]);\\n            }\\n            minOpId = Math.min(minOpId, fullColPaintOpId);\\n        }\\n\\n        return minOpId;\\n    }\\n}\\n```\n``` cpp []\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int n = mat.size(), m = mat[0].size();\\n        std::vector<int> ids(arr.size() + 1);\\n\\n        for (int i = 0; i < arr.size(); i++) {\\n            ids[arr[i]] = i;\\n        }\\n\\n        int minOpId = INT_MAX;\\n        for (int r = 0; r < n; r++) {\\n            int fullRowPaintOpId = -1;\\n            for (int c = 0; c < m; c++) {\\n                fullRowPaintOpId = std::max(fullRowPaintOpId, ids[mat[r][c]]);\\n            }\\n            minOpId = std::min(minOpId, fullRowPaintOpId);\\n        }\\n\\n        for (int c = 0; c < m; c++) {\\n            int fullColPaintOpId = -1;\\n            for (int r = 0; r < n; r++) {\\n                fullColPaintOpId = std::max(fullColPaintOpId, ids[mat[r][c]]);\\n            }\\n            minOpId = std::min(minOpId, fullColPaintOpId);\\n        }\\n\\n        return minOpId;\\n    }\\n};\\n```\n``` python []\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        n = len(mat)\\n        m = len(mat[0])\\n        ids = [0]*(len(arr) + 1)\\n\\n        for i in range(len(arr)):\\n            ids[arr[i]] = i\\n\\n        minOpId = float(\\'inf\\')\\n        for r in range(n):\\n            fullRowPaintOpId = -1\\n            for c in range(m):\\n                fullRowPaintOpId = max(fullRowPaintOpId, ids[mat[r][c]])\\n            minOpId = min(minOpId, fullRowPaintOpId)\\n\\n        for c in range(m):\\n            fullColPaintOpId = -1\\n            for r in range(n):\\n                fullColPaintOpId = max(fullColPaintOpId, ids[mat[r][c]])\\n            minOpId = min(minOpId, fullColPaintOpId)\\n\\n        return minOpId\\n```\n``` java []\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int n = mat.length, m = mat[0].length;\\n        var coordinates = new int[n * m + 1][2];\\n\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < m; c++) {\\n                coordinates[mat[r][c]] = new int[]{r, c};\\n            }\\n        }\\n\\n        var rows = new int[n];\\n        var columns = new int[m];\\n        for (int i = 0; i < arr.length; i++) {\\n            var cell = coordinates[arr[i]];\\n            if (++rows[cell[0]] == m | ++columns[cell[1]] == n) {\\n                return i;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```\n``` cpp []\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int n = mat.size(), m = mat[0].size();\\n        std::vector<std::vector<int>> coordinates(n * m + 1, std::vector<int>(2));\\n\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < m; c++) {\\n                coordinates[mat[r][c]][0] = r;\\n                coordinates[mat[r][c]][1] = c;\\n            }\\n        }\\n\\n        std::vector<int> rows(n), columns(m);\\n        for (int i = 0; i < arr.size(); i++) {\\n            auto cell = coordinates[arr[i]];\\n            if (++rows[cell[0]] == m || ++columns[cell[1]] == n) {\\n                return i;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```\n``` python []\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        n = len(mat)\\n        m = len(mat[0])\\n        coordinates = [[0, 0] for _ in range(n * m + 1)]\\n\\n        for r in range(n):\\n            for c in range(m):\\n                coordinates[mat[r][c]][0] = r\\n                coordinates[mat[r][c]][1] = c\\n\\n        rows = [0]*n\\n        columns = [0]*m\\n        for i in range(len(arr)):\\n            cell = coordinates[arr[i]]\\n            rows[cell[0]] += 1\\n            columns[cell[1]] += 1\\n            if rows[cell[0]] == m or columns[cell[1]] == n:\\n                return i\\n\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3528451,
                "title": "js-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} arr\\n * @param {number[][]} mat\\n * @return {number}\\n */\\nvar firstCompleteIndex = function(arr, mat) {\\n  const m = mat.length;\\n  const n = mat[0].length;\\n\\n  const hash = {}\\n\\n  for (let i = 0; i < m; i++) {\\n    for (let j = 0; j < n; j++) {\\n      hash[mat[i][j]] = { i, j }\\n    }\\n  }\\n\\n  const rows = new Array(m).fill(0)\\n  const cols = new Array(n).fill(0)\\n\\n  let buff;\\n\\n  const last = m * n;\\n  for (let i = 0; i < last; i++) {\\n    buff = hash[arr[i]];\\n    rows[+buff.i]++\\n    cols[+buff.j]++\\n\\n    if (rows[+buff.i] === n || cols[+buff.j] === m) return i\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @param {number[][]} mat\\n * @return {number}\\n */\\nvar firstCompleteIndex = function(arr, mat) {\\n  const m = mat.length;\\n  const n = mat[0].length;\\n\\n  const hash = {}\\n\\n  for (let i = 0; i < m; i++) {\\n    for (let j = 0; j < n; j++) {\\n      hash[mat[i][j]] = { i, j }\\n    }\\n  }\\n\\n  const rows = new Array(m).fill(0)\\n  const cols = new Array(n).fill(0)\\n\\n  let buff;\\n\\n  const last = m * n;\\n  for (let i = 0; i < last; i++) {\\n    buff = hash[arr[i]];\\n    rows[+buff.i]++\\n    cols[+buff.j]++\\n\\n    if (rows[+buff.i] === n || cols[+buff.j] === m) return i\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3519057,
                "title": "python-dictionary-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        dict_matrix = {}\\n\\n        row = len(mat)\\n        col = len(mat[0])\\n\\n        for r in range(row):\\n            for c in range(col):\\n                dict_matrix[mat[r][c]] = (r, c)\\n        \\n        r_ans = [0 for i in range(row)]\\n        c_ans = [0 for i in range(col)]\\n        \\n        for i in range(len(arr)):\\n            r, c = dict_matrix[arr[i]]\\n            r_ans[r] += 1\\n            c_ans[c] += 1\\n            if r_ans[r] == col or c_ans[c] == row:\\n                return i\\n        \\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        dict_matrix = {}\\n\\n        row = len(mat)\\n        col = len(mat[0])\\n\\n        for r in range(row):\\n            for c in range(col):\\n                dict_matrix[mat[r][c]] = (r, c)\\n        \\n        r_ans = [0 for i in range(row)]\\n        c_ans = [0 for i in range(col)]\\n        \\n        for i in range(len(arr)):\\n            r, c = dict_matrix[arr[i]]\\n            r_ans[r] += 1\\n            c_ans[c] += 1\\n            if r_ans[r] == col or c_ans[c] == row:\\n                return i\\n        \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3515076,
                "title": "hashing-preprocessing-everything-commented-easy-to-understand-c-o-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n/*This private section has 2 functions that checks the matrix\\'s specified row and column for colouring (zero) in other words. But it runs for 1021/1057 testcases and gives TLE right-after so we tackle this problem in a different way using hash-table for individual row and column after pre-processing the co-ordinates in another map.*/\\n\\n/*private: \\n    bool checkRow(vector<vector<int>> mat, int row)\\n    {\\n        int f=0, l=mat[0].size()-1;\\n        while(f<=l)  \\n        {\\n            if(mat[row][f++]!=0 || mat[row][l--]!=0 ){return false;}\\n        }\\n        return true;\\n    }\\n    bool checkColumn(vector<vector<int>> mat, int column)\\n    {\\n        int f=0, l=mat.size()-1;\\n        while(f<=l) \\n        {\\n            if(mat[f++][column]!=0 || mat[l--][column]!=0){return false;}\\n        }\\n        return true;\\n    }*/\\n\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n      int m = mat.size();\\n      int n = mat[0].size();\\n      //preprocessing co-ordinates using 2 maps\\n       map<pair<int,int>,int> m1; // pre-processing usage\\n       unordered_map<int,pair<int,int>> m2; // pre-processing usage\\n       unordered_map<int,int>row,column; //row & column map for x-axis & y-axis of the arr[i] respectively.\\n       //vector<vector<int>> x=mat; // we pass this 2D vector to that private function (TLE)\\n       for(int i=0;i<m;i++)\\n       {\\n           for(int j=0;j<n;j++)\\n           {\\n               m1[{i,j}]=mat[i][j]; //map of pair of co-ordinates pre-processing\\n           }\\n       }\\n       for(auto it:m1)\\n    {\\n        m2.insert({it.second,{it.first.first,it.first.second}}); //same map but reversed for easier traversal\\n    }\\n    m1.clear();\\n    int a=0,b=0;\\n    for(int i=0;i<arr.size();i++)\\n    {\\n\\n        if(m2.find(arr[i])!=m2.end())\\n        {\\n             a = m2[arr[i]].first; //abscissa\\n             b = m2[arr[i]].second; //ordinate\\n            if(row[a]==n-1||column[b]==m-1){return i;}\\n            //x[a][b]=0; //TLE condition. This line colours the co-ordinates replacing the actual value with 0.\\n            row[a]++;column[b]++;\\n            //if(i>=m-1||i>=n-1){\\n            //if(checkRow(x,a)||checkColumn(x,b)){return i;}}//TLE CASE\\n        }\\n    }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n/*This private section has 2 functions that checks the matrix\\'s specified row and column for colouring (zero) in other words. But it runs for 1021/1057 testcases and gives TLE right-after so we tackle this problem in a different way using hash-table for individual row and column after pre-processing the co-ordinates in another map.*/\\n\\n/*private: \\n    bool checkRow(vector<vector<int>> mat, int row)\\n    {\\n        int f=0, l=mat[0].size()-1;\\n        while(f<=l)  \\n        {\\n            if(mat[row][f++]!=0 || mat[row][l--]!=0 ){return false;}\\n        }\\n        return true;\\n    }\\n    bool checkColumn(vector<vector<int>> mat, int column)\\n    {\\n        int f=0, l=mat.size()-1;\\n        while(f<=l) \\n        {\\n            if(mat[f++][column]!=0 || mat[l--][column]!=0){return false;}\\n        }\\n        return true;\\n    }*/\\n\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n      int m = mat.size();\\n      int n = mat[0].size();\\n      //preprocessing co-ordinates using 2 maps\\n       map<pair<int,int>,int> m1; // pre-processing usage\\n       unordered_map<int,pair<int,int>> m2; // pre-processing usage\\n       unordered_map<int,int>row,column; //row & column map for x-axis & y-axis of the arr[i] respectively.\\n       //vector<vector<int>> x=mat; // we pass this 2D vector to that private function (TLE)\\n       for(int i=0;i<m;i++)\\n       {\\n           for(int j=0;j<n;j++)\\n           {\\n               m1[{i,j}]=mat[i][j]; //map of pair of co-ordinates pre-processing\\n           }\\n       }\\n       for(auto it:m1)\\n    {\\n        m2.insert({it.second,{it.first.first,it.first.second}}); //same map but reversed for easier traversal\\n    }\\n    m1.clear();\\n    int a=0,b=0;\\n    for(int i=0;i<arr.size();i++)\\n    {\\n\\n        if(m2.find(arr[i])!=m2.end())\\n        {\\n             a = m2[arr[i]].first; //abscissa\\n             b = m2[arr[i]].second; //ordinate\\n            if(row[a]==n-1||column[b]==m-1){return i;}\\n            //x[a][b]=0; //TLE condition. This line colours the co-ordinates replacing the actual value with 0.\\n            row[a]++;column[b]++;\\n            //if(i>=m-1||i>=n-1){\\n            //if(checkRow(x,a)||checkColumn(x,b)){return i;}}//TLE CASE\\n        }\\n    }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3512181,
                "title": "javascript-easy-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} arr\\n * @param {number[][]} mat\\n * @return {number}\\n */\\nconst firstCompleteIndex = function(arr, mat) {\\n  const m = mat.length;\\n  const n = mat[0].length;\\n\\n  // create an array to store the coordinates of all elements in the matrix\\n  const coordinates = Array(m * n + 1);\\n  for (let i = 0; i < m; i++) {\\n    for (let j = 0; j < n; j++) {\\n      coordinates[mat[i][j]] = [i, j];\\n    }\\n  }\\n\\n  // create two arrays to store the remaining count of elements in each row and column\\n  const rowCount = Array(m).fill(n);\\n  const colCount = Array(n).fill(m);\\n\\n  // iterate through the array of numbers and update the row and column counts\\n  for (let i = 0; i < m * n; i++) {\\n    const [row, col] = coordinates[arr[i]];\\n    if (--rowCount[row] === 0 || --colCount[col] === 0) {\\n      // if any row or column has no remaining elements, return the current index\\n      return i;\\n    }\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @param {number[][]} mat\\n * @return {number}\\n */\\nconst firstCompleteIndex = function(arr, mat) {\\n  const m = mat.length;\\n  const n = mat[0].length;\\n\\n  // create an array to store the coordinates of all elements in the matrix\\n  const coordinates = Array(m * n + 1);\\n  for (let i = 0; i < m; i++) {\\n    for (let j = 0; j < n; j++) {\\n      coordinates[mat[i][j]] = [i, j];\\n    }\\n  }\\n\\n  // create two arrays to store the remaining count of elements in each row and column\\n  const rowCount = Array(m).fill(n);\\n  const colCount = Array(n).fill(m);\\n\\n  // iterate through the array of numbers and update the row and column counts\\n  for (let i = 0; i < m * n; i++) {\\n    const [row, col] = coordinates[arr[i]];\\n    if (--rowCount[row] === 0 || --colCount[col] === 0) {\\n      // if any row or column has no remaining elements, return the current index\\n      return i;\\n    }\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3511840,
                "title": "brute-force-method",
                "content": "### STORE EVERY MATRIX ELEMENT WITH ITS ROW AND COL AS A HEY VALUE PAIR ITERATE THROUGH THE GIVEN ARR AND KEEP A ROW_ARR AND COL_ARR TO VALUATE THE MAX_VAL IN THEM ,IF THE MAX VALUE IS ACHIEVED THEN THE ARR[I] IS THE ANSWER.\\n\\n#### DONT ASK ME WHY I USED DEFAULTDICT(LIST) , BECAUSE I WAS LEARING GRAPH PROBLEMS FOR ADJ_LIST ,IT BECAME HANDY\\n```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        \\n        m=len(mat)\\n        n=len(mat[0])\\n        \\n        hash_map=defaultdict(list)\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                hash_map[mat[i][j]].append([i,j])\\n        \\n        row_mat=[0 for i in range(m)]\\n        \\n        col_mat=[0 for i in range(n)]\\n        \\n        for i in range(len(arr)):\\n            k=hash_map[arr[i]]\\n            \\n            row_mat[k[0][0]]+=1\\n            col_mat[k[0][1]]+=1\\n            \\n            if row_mat[k[0][0]]==n or col_mat[k[0][1]]==m:\\n                return i\\n```\\n\\n# HAPPY  LEETCODING!",
                "solutionTags": [
                    "Python3",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        \\n        m=len(mat)\\n        n=len(mat[0])\\n        \\n        hash_map=defaultdict(list)\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                hash_map[mat[i][j]].append([i,j])\\n        \\n        row_mat=[0 for i in range(m)]\\n        \\n        col_mat=[0 for i in range(n)]\\n        \\n        for i in range(len(arr)):\\n            k=hash_map[arr[i]]\\n            \\n            row_mat[k[0][0]]+=1\\n            col_mat[k[0][1]]+=1\\n            \\n            if row_mat[k[0][0]]==n or col_mat[k[0][1]]==m:\\n                return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507625,
                "title": "java-solution-that-keeps-track-of-the-number-of-elements-colored-in-any-row-or-any-column",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInitially create a 2Darray that keeps record of row number and column number of a particular value that lies in the range 1 to m*n present in mat[][].\\nCreate two arrays that will keep track of the number of elements colored in ith row and ith column.\\nif ith row or ith column becomes fully colored, we stop our traversal.\\n\\n# Complexity\\n- Time complexity:$$O(n*m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n+m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int[][] array = new int[arr.length+1][2];\\n        for(int i = 0 ; i<mat.length ; i++){\\n            for(int j = 0 ; j<mat[0].length ; j++){\\n                array[mat[i][j]][0] = i; \\n                array[mat[i][j]][1] = j; \\n            }\\n        }\\n        int[] rows = new int[mat.length];\\n        int[] cols = new int[mat[0].length];\\n\\n        for(int i = 0 ; i<arr.length ; i++){\\n            int r = array[arr[i]][0];\\n            int c = array[arr[i]][1];\\n            rows[r]++;\\n            cols[c]++;\\n            if(rows[r] == mat[0].length || cols[c] == mat.length){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int[][] array = new int[arr.length+1][2];\\n        for(int i = 0 ; i<mat.length ; i++){\\n            for(int j = 0 ; j<mat[0].length ; j++){\\n                array[mat[i][j]][0] = i; \\n                array[mat[i][j]][1] = j; \\n            }\\n        }\\n        int[] rows = new int[mat.length];\\n        int[] cols = new int[mat[0].length];\\n\\n        for(int i = 0 ; i<arr.length ; i++){\\n            int r = array[arr[i]][0];\\n            int c = array[arr[i]][1];\\n            rows[r]++;\\n            cols[c]++;\\n            if(rows[r] == mat[0].length || cols[c] == mat.length){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503655,
                "title": "easy-hash-table-implementation-cpp-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->The solution starts by creating two vectors, rowsum and columnsum, that will store the sum of each row and column in the matrix, respectively.\\n\\nThe first for loop iterates through each row of the matrix, calculates the sum of the row elements and pushes the result into the rowsum vector.\\n\\nThe second for loop iterates through each column of the matrix, calculates the sum of the column elements and pushes the result into the columnsum vector.\\n\\nNext, the solution creates a vector of pairs v that stores the coordinates of each element in the matrix with respect to the original vector arr. The index of each element in arr is used as the key to store its coordinates in the matrix in the form of a pair of integers representing the row and column indices.\\n\\nFinally, the solution iterates through each element of arr. For each element, it subtracts its value from the corresponding row and column sums using the coordinates stored in the v vector. If the resulting row or column sum is zero, it means that the row or column is complete, and the index of the element in arr is returned. If no complete row or column is found, the function returns zero.\\n\\nOverall, the solution works by using the rowsum and columnsum vectors to efficiently check for complete rows and columns in the matrix and by using the v vector to quickly look up the coordinates of each element in arr in the matrix.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->The time complexity of the given solution is O(n^2), where n is the length of the input vector arr. This is because the solution involves iterating over all the elements in the matrix twice to calculate the row and column sums, and then iterating over all the elements in arr once to check for complete rows and columns.\\n\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->The space complexity of the solution is O(n+m), where m is the size of the matrix. This is because the solution creates two vectors, rowsum and columnsum, of size m to store the row and column sums, respectively. It also creates a vector of pairs v of size n+1 to store the coordinates of each element in arr. The overall space complexity is dominated by the v vector, which grows with the size of the input vector arr.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        vector<long long>rowsum;\\n        for(int i=0;i<mat.size();i++){\\n            long long temp=0;\\n              for(int j=0;j<mat[i].size();j++){\\n                 temp+=mat[i][j];\\n            }\\n            rowsum.push_back(temp);\\n        }\\n          vector<long long>columnsum;\\n        for(int i=0;i<mat[0].size();i++){\\n            long long temp=0;\\n              for(int j=0;j<mat.size();j++){\\n                 temp+=mat[j][i];\\n            }\\n            columnsum.push_back(temp);\\n        }\\n        vector<pair<int,int>>v(arr.size()+1);\\n        for(int i=0;i<mat.size();i++){\\n              for(int j=0;j<mat[i].size();j++){\\n                 v[mat[i][j]]={i,j};\\n            }\\n        }\\n        for(int i=0;i<arr.size();i++){\\n            rowsum[v[arr[i]].first]-=arr[i];\\n            columnsum[v[arr[i]].second]-=arr[i];\\n           if(rowsum[v[arr[i]].first]==0 ||  columnsum[v[arr[i]].second]==0 ) return i;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        vector<long long>rowsum;\\n        for(int i=0;i<mat.size();i++){\\n            long long temp=0;\\n              for(int j=0;j<mat[i].size();j++){\\n                 temp+=mat[i][j];\\n            }\\n            rowsum.push_back(temp);\\n        }\\n          vector<long long>columnsum;\\n        for(int i=0;i<mat[0].size();i++){\\n            long long temp=0;\\n              for(int j=0;j<mat.size();j++){\\n                 temp+=mat[j][i];\\n            }\\n            columnsum.push_back(temp);\\n        }\\n        vector<pair<int,int>>v(arr.size()+1);\\n        for(int i=0;i<mat.size();i++){\\n              for(int j=0;j<mat[i].size();j++){\\n                 v[mat[i][j]]={i,j};\\n            }\\n        }\\n        for(int i=0;i<arr.size();i++){\\n            rowsum[v[arr[i]].first]-=arr[i];\\n            columnsum[v[arr[i]].second]-=arr[i];\\n           if(rowsum[v[arr[i]].first]==0 ||  columnsum[v[arr[i]].second]==0 ) return i;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3501710,
                "title": "very-solution-c",
                "content": "# Complexity\\n- Time complexity: O(N*M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N*M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        vector<int> row(mat.size(),0) , col(mat[0].size(),0);\\n        vector<pair<int,int>> ind(mat.size()*mat[0].size()+1);\\n        for(int i=0;i<mat.size();i++)\\n            for(int j=0;j<mat[0].size();j++) ind[mat[i][j]] = {i,j};\\n        // Now choose elements from arr and then update row and col\\n        for(int i=0;i<arr.size();i++){\\n            // we get elements\\n            row[ind[arr[i]].first]++;\\n            col[ind[arr[i]].second]++;\\n            if(row[ind[arr[i]].first] == mat[0].size() || col[ind[arr[i]].second] == mat.size()) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        vector<int> row(mat.size(),0) , col(mat[0].size(),0);\\n        vector<pair<int,int>> ind(mat.size()*mat[0].size()+1);\\n        for(int i=0;i<mat.size();i++)\\n            for(int j=0;j<mat[0].size();j++) ind[mat[i][j]] = {i,j};\\n        // Now choose elements from arr and then update row and col\\n        for(int i=0;i<arr.size();i++){\\n            // we get elements\\n            row[ind[arr[i]].first]++;\\n            col[ind[arr[i]].second]++;\\n            if(row[ind[arr[i]].first] == mat[0].size() || col[ind[arr[i]].second] == mat.size()) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3500821,
                "title": "hashmap-solution",
                "content": "```\\nclass Solution {\\n    func firstCompleteIndex(_ arr: [Int], _ mat: [[Int]]) -> Int {\\n        let m = mat.count\\n        let n = mat[0].count\\n        \\n        var rows = Array(repeating: n, count: m)\\n        var cols = Array(repeating: m, count: n)\\n        \\n        var map = [Int: [Int]]()\\n        for r in 0..<m {\\n            for c in 0..<n {\\n                map[mat[r][c]] = [r,c]\\n            }\\n        }\\n        \\n        for i in 0..<m*n {\\n            if let pairs = map[arr[i]] {\\n                let r = pairs[0]\\n                let c = pairs[1]\\n                rows[r] -= 1\\n                if rows[r] == 0 { return i }\\n                cols[c] -= 1\\n                if cols[c] == 0 { return i }\\n            }\\n        }\\n        return m*n-1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func firstCompleteIndex(_ arr: [Int], _ mat: [[Int]]) -> Int {\\n        let m = mat.count\\n        let n = mat[0].count\\n        \\n        var rows = Array(repeating: n, count: m)\\n        var cols = Array(repeating: m, count: n)\\n        \\n        var map = [Int: [Int]]()\\n        for r in 0..<m {\\n            for c in 0..<n {\\n                map[mat[r][c]] = [r,c]\\n            }\\n        }\\n        \\n        for i in 0..<m*n {\\n            if let pairs = map[arr[i]] {\\n                let r = pairs[0]\\n                let c = pairs[1]\\n                rows[r] -= 1\\n                if rows[r] == 0 { return i }\\n                cols[c] -= 1\\n                if cols[c] == 0 { return i }\\n            }\\n        }\\n        return m*n-1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3500387,
                "title": "c-clean-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->        \\n    O(M*N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->                  \\nO(M*N)+O(M*N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        map<string,int> mp;\\n        map<int,pair<string,string>>f;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                f[mat[i][j]]={to_string(i)+\\'R\\',to_string(j)+\\'C\\'};\\n            }\\n        }\\n        for(int i=0;i<arr.size();i++){\\n            mp[f[arr[i]].first]++;\\n            mp[f[arr[i]].second]++;\\n            if(mp[f[arr[i]].first]==n || mp[f[arr[i]].second]==m){\\n                return i;\\n            }\\n            \\n        }\\n        return arr.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        map<string,int> mp;\\n        map<int,pair<string,string>>f;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                f[mat[i][j]]={to_string(i)+\\'R\\',to_string(j)+\\'C\\'};\\n            }\\n        }\\n        for(int i=0;i<arr.size();i++){\\n            mp[f[arr[i]].first]++;\\n            mp[f[arr[i]].second]++;\\n            if(mp[f[arr[i]].first]==n || mp[f[arr[i]].second]==m){\\n                return i;\\n            }\\n            \\n        }\\n        return arr.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3498981,
                "title": "simple-java-solution-by-creating-a-map-for-each-number-with-o-n2-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    Simple Java Solution\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Map the cordinates of each number in the mat array,\\n    Create a row and column array which will keep track of the number of element elements colored in that row or column.\\n    Traverse the array arr and keep increment the row and column values of the repective arrays and whenever any of them becomes equal to max return the index.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int n = mat.length;\\n        int m = mat[0].length;\\n        int len = n * m;\\n        final int RSUM = m;\\n        final int CSUM = n;\\n        int[][] cor = new int[len+1][2];\\n        \\n        int[] rowSum = new int[n];\\n        int[] colSum = new int[m];\\n\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int val = mat[i][j];\\n                cor[val] = new int[]{i,j};\\n            }\\n        }\\n        \\n        for(int i=0;i<len;i++){\\n            int val = arr[i];\\n            int r = cor[val][0];\\n            int c = cor[val][1];\\n            \\n            rowSum[r]++;\\n            colSum[c]++;\\n            \\n            if(rowSum[r] >= RSUM || colSum[c] >= CSUM)\\n                return i;\\n        }\\n        return len-1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int n = mat.length;\\n        int m = mat[0].length;\\n        int len = n * m;\\n        final int RSUM = m;\\n        final int CSUM = n;\\n        int[][] cor = new int[len+1][2];\\n        \\n        int[] rowSum = new int[n];\\n        int[] colSum = new int[m];\\n\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int val = mat[i][j];\\n                cor[val] = new int[]{i,j};\\n            }\\n        }\\n        \\n        for(int i=0;i<len;i++){\\n            int val = arr[i];\\n            int r = cor[val][0];\\n            int c = cor[val][1];\\n            \\n            rowSum[r]++;\\n            colSum[c]++;\\n            \\n            if(rowSum[r] >= RSUM || colSum[c] >= CSUM)\\n                return i;\\n        }\\n        return len-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497147,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        unordered_map<int,int>row;\\n        unordered_map<int,int>col;\\n\\n        unordered_map<int,pair<int,int>>mp;\\n\\n        for(int i = 0;i<mat.size();i++){\\n\\n            for(int j = 0;j<mat[i].size();j++){\\n\\n                mp[mat[i][j]] = {i,j};\\n            }\\n        }\\n        int res = 1e9;\\n\\n        for(int i = 0;i<arr.size();i++){\\n\\n            pair<int,int>p  = mp[arr[i]];\\n            \\n            row[p.first]++;\\n            col[p.second]++;\\n            if(row[p.first]==n || col[p.second]==m){\\n\\n                res = min(res,i);\\n            }\\n            \\n        }\\n\\n        return res;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        unordered_map<int,int>row;\\n        unordered_map<int,int>col;\\n\\n        unordered_map<int,pair<int,int>>mp;\\n\\n        for(int i = 0;i<mat.size();i++){\\n\\n            for(int j = 0;j<mat[i].size();j++){\\n\\n                mp[mat[i][j]] = {i,j};\\n            }\\n        }\\n        int res = 1e9;\\n\\n        for(int i = 0;i<arr.size();i++){\\n\\n            pair<int,int>p  = mp[arr[i]];\\n            \\n            row[p.first]++;\\n            col[p.second]++;\\n            if(row[p.first]==n || col[p.second]==m){\\n\\n                res = min(res,i);\\n            }\\n            \\n        }\\n\\n        return res;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496407,
                "title": "java-4ms-beats-98-and-clean-code",
                "content": "# Approach\\n1. A brute force attempt would mean you traverse arr, find element i in matrix O (n*m), color it then check if whole row or column is painted O (n+m).\\n2. You can optimize it by knowing WHERE exactly where each element is in the matrix.\\n    - Declare an int[n*m + 1] and store the prefixed order of each element:\\n    The last element in a n*m matrix would be mapped against the position n*m in the position array.\\n    EG: mat [[4,3],[1,2]] => int[] pos of size 5\\n    - 4 will be mapped as pos 0: pos[4] = 0;\\n    - 3 -> pos 1:  pos[3] = 1\\n    - 1 -> pos 2: pos[1] = 2\\n    - 2 -> pos 3: pos[2] = 3\\n3. This way, if we want to color element 1, we look at pos[1] = 2.\\n    - 2 / 2 = 1 => row 1 (i) - see point #5 & 6\\n    - 2 % 2 = 0 => col 0. (j) - see point #5 & 6\\n4. Furthermore, we don\\'t really need to \"paint\" the matrix and traverse whole row/col and count the number of painted cells. We can keep track of how many painted cells are in each row/ column\\n5. Declare an int[mat.length] coloredRows and int[mat[0].length] coloredColumns.\\n6. Using the info from #3, increment coloredRows[1]++ and coloredColumns[0]++.\\n    If coloredRows[i] == numberOfColumns (all columns are painted on that row) OR coloredColumns[j] == numberOfRows (all rows are colored for that column) return index of arr. \\n\\n# Complexity\\n- Time complexity:$$O(n*m + a)$$ a - size of arr\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n*m + n + m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int rows = mat.length, cols = mat[0].length;\\n        int[] coloredRows = new int[rows];\\n        int[] coloredColumns = new int[cols];\\n        int[] matPositions = getMatPositions(mat);\\n        int rowToPaint, colToPaint;\\n        for (int i = 0; i < arr.length; i++) {\\n            rowToPaint = matPositions[arr[i]] / cols;\\n            colToPaint = matPositions[arr[i]] % cols;\\n            if (++coloredRows[rowToPaint] == cols || ++coloredColumns[colToPaint] == rows) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    private int[] getMatPositions(int[][] mat) {\\n        int[] positions = new int[mat.length * mat[0].length + 1];\\n        int pos = 0;\\n        for (int[] row : mat) {\\n            for (int num : row) {\\n                positions[num] = pos++;      \\n            }\\n        }\\n        return positions;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int rows = mat.length, cols = mat[0].length;\\n        int[] coloredRows = new int[rows];\\n        int[] coloredColumns = new int[cols];\\n        int[] matPositions = getMatPositions(mat);\\n        int rowToPaint, colToPaint;\\n        for (int i = 0; i < arr.length; i++) {\\n            rowToPaint = matPositions[arr[i]] / cols;\\n            colToPaint = matPositions[arr[i]] % cols;\\n            if (++coloredRows[rowToPaint] == cols || ++coloredColumns[colToPaint] == rows) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    private int[] getMatPositions(int[][] mat) {\\n        int[] positions = new int[mat.length * mat[0].length + 1];\\n        int pos = 0;\\n        for (int[] row : mat) {\\n            for (int num : row) {\\n                positions[num] = pos++;      \\n            }\\n        }\\n        return positions;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494464,
                "title": "java-solution-with-integer-array-as-map",
                "content": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int numRows = mat.length, numCols = mat[0].length;\\n        int[] sumRows = new int[numRows];\\n        int[] sumCols = new int[numCols];\\n\\n        List<Integer>[] map = new ArrayList[(numRows * numCols) + 1];\\n        for (int i = 0; i < map.length; i++) {\\n            map[i] = new ArrayList<>();\\n        }\\n\\n        for (int i = 0; i < mat.length; i++) {\\n            for (int j = 0; j < mat[0].length; j++) {\\n                int value = mat[i][j];\\n                map[value] = new ArrayList<>();\\n                map[value].add(i);\\n                map[value].add(j);\\n            }\\n        }\\n\\n        for (int i = 0; i < arr.length; i++) {\\n            int arrVal = arr[i];\\n            int rowOfArrVal = map[arrVal].get(0);\\n            int colOfArrVal = map[arrVal].get(1);\\n            sumRows[rowOfArrVal]++;\\n            sumCols[colOfArrVal]++;\\n            if (sumRows[rowOfArrVal] == numCols || sumCols[colOfArrVal] == numRows) {\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int numRows = mat.length, numCols = mat[0].length;\\n        int[] sumRows = new int[numRows];\\n        int[] sumCols = new int[numCols];\\n\\n        List<Integer>[] map = new ArrayList[(numRows * numCols) + 1];\\n        for (int i = 0; i < map.length; i++) {\\n            map[i] = new ArrayList<>();\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3494130,
                "title": "ruby-solution-beats-100-100",
                "content": "```\\n# @param {Integer[]} arr\\n# @param {Integer[][]} mat\\n# @return {Integer}\\ndef first_complete_index(arr, mat)\\n  n = mat.size\\n  m = mat[0].size\\n  h = Array.new(n * m + 1)\\n\\n  mat.each_with_index do |r, i|\\n    r.each_with_index do |x, j|\\n      h[x] = i * m + j\\n    end\\n  end\\n\\n  rc = Array.new(m, n)\\n  cc = Array.new(n, m)\\n\\n  arr.find_index do |x|\\n    i, j = h[x].divmod(m)\\n    (rc[j] -= 1) == 0 || (cc[i] -= 1) == 0\\n  end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} arr\\n# @param {Integer[][]} mat\\n# @return {Integer}\\ndef first_complete_index(arr, mat)\\n  n = mat.size\\n  m = mat[0].size\\n  h = Array.new(n * m + 1)\\n\\n  mat.each_with_index do |r, i|\\n    r.each_with_index do |x, j|\\n      h[x] = i * m + j\\n    end\\n  end\\n\\n  rc = Array.new(m, n)\\n  cc = Array.new(n, m)\\n\\n  arr.find_index do |x|\\n    i, j = h[x].divmod(m)\\n    (rc[j] -= 1) == 0 || (cc[i] -= 1) == 0\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3494107,
                "title": "c-solution-using-hashmaps-faster-and-very-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        unordered_map<int,pair<int,int>> index;\\n        int m = mat.size(),n = mat[0].size();\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                index[mat[i][j]] = {i,j};\\n            }\\n        }\\n        \\n        unordered_map<int,int> rowFilledCnt,colFilledCnt;\\n        int ans = -1;\\n        for(int i=0;i<arr.size();i++){\\n            int x = index[arr[i]].first, y = index[arr[i]].second;\\n            rowFilledCnt[x]++;\\n            colFilledCnt[y]++;\\n            \\n            if(rowFilledCnt[x] == n || colFilledCnt[y] == m){\\n                ans = i;\\n                break;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        unordered_map<int,pair<int,int>> index;\\n        int m = mat.size(),n = mat[0].size();\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                index[mat[i][j]] = {i,j};\\n            }\\n        }\\n        \\n        unordered_map<int,int> rowFilledCnt,colFilledCnt;\\n        int ans = -1;\\n        for(int i=0;i<arr.size();i++){\\n            int x = index[arr[i]].first, y = index[arr[i]].second;\\n            rowFilledCnt[x]++;\\n            colFilledCnt[y]++;\\n            \\n            if(rowFilledCnt[x] == n || colFilledCnt[y] == m){\\n                ans = i;\\n                break;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494052,
                "title": "simple-c-map-solution-easily-understandable",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int m = mat.size() , n = mat[0].size() ;\\n        unordered_map<int , pair<int , int>> mp ;\\n        unordered_map<int , int> mp1 , mp2 ;\\n        for(int i = 0 ; i < m ; i++){\\n            for(int j = 0 ; j < n ; j++)\\n            mp[mat[i][j]] = {i , j} ;\\n        }\\n\\n        for(int i = 0 ; i < arr.size() ; i++){\\n           int row = mp[arr[i]].first , col = mp[arr[i]].second ;\\n           mp1[row]++ ;\\n           mp2[col]++ ;\\n           if(mp1[row] == n || mp2[col] == m) return i ;\\n        }\\n        return arr.size() - 1 ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int m = mat.size() , n = mat[0].size() ;\\n        unordered_map<int , pair<int , int>> mp ;\\n        unordered_map<int , int> mp1 , mp2 ;\\n        for(int i = 0 ; i < m ; i++){\\n            for(int j = 0 ; j < n ; j++)\\n            mp[mat[i][j]] = {i , j} ;\\n        }\\n\\n        for(int i = 0 ; i < arr.size() ; i++){\\n           int row = mp[arr[i]].first , col = mp[arr[i]].second ;\\n           mp1[row]++ ;\\n           mp2[col]++ ;\\n           if(mp1[row] == n || mp2[col] == m) return i ;\\n        }\\n        return arr.size() - 1 ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3493472,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n       HashMap<Integer,Integer> hmc = new HashMap<>();\\n       HashMap<Integer,Integer> hmr = new HashMap<>();\\n       HashMap<Integer,int[]> hmElement = new HashMap<>();\\n       int sum=0;\\n\\n       //row\\n       for(int i=0;i<mat.length;i++)\\n       {\\n           for(int j=0;j<mat[0].length;j++)\\n           {\\n               sum=sum+mat[i][j];\\n               hmElement.put(mat[i][j],new int[]{i,j});\\n           }\\n           hmr.put(i,sum);\\n           sum=0;\\n       }\\n\\n        //col\\n        sum=0;\\n       for(int i=0;i<mat[0].length;i++)\\n       {\\n           for(int j=0;j<mat.length;j++)\\n           {\\n               sum=sum+mat[j][i];           }\\n           hmc.put(i,sum);\\n           sum=0;\\n       }\\n\\n       for(int i=0;i<arr.length;i++)\\n       {\\n           int[] temp = hmElement.get(arr[i]);\\n           int r = temp[0];\\n           int c = temp[1];\\n           int sumr = hmr.get(r);\\n           int sumc = hmc.get(c);\\n           sumr=sumr-arr[i];\\n           if(sumr==0)\\n           return i;\\n           sumc=sumc-arr[i];\\n           if(sumc==0)\\n           return i;\\n           hmr.put(r,sumr);\\n           hmc.put(c,sumc);\\n       }\\n       return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n       HashMap<Integer,Integer> hmc = new HashMap<>();\\n       HashMap<Integer,Integer> hmr = new HashMap<>();\\n       HashMap<Integer,int[]> hmElement = new HashMap<>();\\n       int sum=0;\\n\\n       //row\\n       for(int i=0;i<mat.length;i++)\\n       {\\n           for(int j=0;j<mat[0].length;j++)\\n           {\\n               sum=sum+mat[i][j];\\n               hmElement.put(mat[i][j],new int[]{i,j});\\n           }\\n           hmr.put(i,sum);\\n           sum=0;\\n       }\\n\\n        //col\\n        sum=0;\\n       for(int i=0;i<mat[0].length;i++)\\n       {\\n           for(int j=0;j<mat.length;j++)\\n           {\\n               sum=sum+mat[j][i];           }\\n           hmc.put(i,sum);\\n           sum=0;\\n       }\\n\\n       for(int i=0;i<arr.length;i++)\\n       {\\n           int[] temp = hmElement.get(arr[i]);\\n           int r = temp[0];\\n           int c = temp[1];\\n           int sumr = hmr.get(r);\\n           int sumc = hmc.get(c);\\n           sumr=sumr-arr[i];\\n           if(sumr==0)\\n           return i;\\n           sumc=sumc-arr[i];\\n           if(sumc==0)\\n           return i;\\n           hmr.put(r,sumr);\\n           hmc.put(c,sumc);\\n       }\\n       return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3493362,
                "title": "c-simple-map-solution-with-explanation",
                "content": "# Intuition\\nThe given solution uses an unordered map mp to store the positions of all the elements of mat.\\n\\nThen, two vectors row and col are created to keep track of the count of painted cells in each row and column of mat.\\n\\nWe iterate through each element of arr, retrieves its position from mp, and increments the corresponding rows and columns in row and col. Then, we checks if any row or column is completely painted. If a row or column is completely painted, it returns the index of the current element of arr. Otherwise, it continues to the next element of arr.\\n\\n# Approach\\n1. Create an unordered map mp to store the positions of all the elements of mat as a pair of row and column indices.\\n2. Create two vectors row and col of size n and m respectively, initialized to 0.\\n3. Iterate through all the elements of mat and store their positions in mp.\\n4. Iterate through each element of arr.\\n5. Retrieve the position of the current element of arr from mp.\\n6. Increment the corresponding rows and columns in row and col.\\n7. Check if any row or column is completely painted. If a row or column is completely painted, return the index of the current element of arr.\\n8. If no row or column is completely painted after processing all the elements of arr, return -1.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n\\n- Space complexity: $$O(n^2)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        unordered_map<int, pair<int, int>> mp;\\n        int n = mat.size(), m = mat[0].size();\\n        vector<int> row(n), col(m);\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                mp[mat[i][j]] = {i, j};\\n            }\\n        }\\n        for(int i = 0, sz = arr.size(); i < sz; i++){\\n            auto [f, s] = mp[arr[i]];\\n            row[f]++;\\n            col[s]++;\\n            if(row[f] == m or col[s] == n) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        unordered_map<int, pair<int, int>> mp;\\n        int n = mat.size(), m = mat[0].size();\\n        vector<int> row(n), col(m);\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                mp[mat[i][j]] = {i, j};\\n            }\\n        }\\n        for(int i = 0, sz = arr.size(); i < sz; i++){\\n            auto [f, s] = mp[arr[i]];\\n            row[f]++;\\n            col[s]++;\\n            if(row[f] == m or col[s] == n) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3493009,
                "title": "java-using-hashmap",
                "content": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        Map<Integer, int[]> map = new HashMap<>();\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) map.put(mat[i][j], new int[]{i, j});\\n        }\\n        int row[] = new int[m];\\n        int col[] = new int[n];\\n        for (int i = 0; i < arr.length; i++) {\\n            int position[] = map.get(arr[i]);\\n            int x = position[0];\\n            int y = position[1];\\n            row[x]++;\\n            col[y]++;\\n            if (row[x] == n || col[y] == m) return i;\\n        }\\n        return arr.length-1;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        Map<Integer, int[]> map = new HashMap<>();\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) map.put(mat[i][j], new int[]{i, j});\\n        }\\n        int row[] = new int[m];\\n        int col[] = new int[n];\\n        for (int i = 0; i < arr.length; i++) {\\n            int position[] = map.get(arr[i]);\\n            int x = position[0];\\n            int y = position[1];\\n            row[x]++;\\n            col[y]++;\\n            if (row[x] == n || col[y] == m) return i;\\n        }\\n        return arr.length-1;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3492574,
                "title": "javascrip-map-solution",
                "content": "# Intuition\\nSimple iteration with optionmization\\n\\n# Approach\\nSotre indexes [i,j] for every element from matrix. For every element from array, get it\\'s position in matrix. Increase number of elements visited from ith row and jth column, check if row or column fully visited.\\n\\n# Complexity\\n- Time complexity:\\nO(N*M)\\n\\n- Space complexity:\\nO(N*M)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} arr\\n * @param {number[][]} mat\\n * @return {number}\\n */\\nvar firstCompleteIndex = function(arr, mat) {\\n    const n = mat.length;\\n    const m = mat[0].length;\\n    let map = new Map();\\n    for(let i = 0; i < n; i++){\\n        for(let j = 0; j < m; j++){\\n            map.set(mat[i][j], [i, j])\\n        }\\n    }\\n    \\n    let rows = (new Array(n)).fill(0);\\n    let cols = (new Array(m)).fill(0);\\n    \\n    for(let k = 0; k < arr.length; k++){\\n        let num = arr[k]\\n        let [i, j] = map.get(num);\\n        rows[i]++;\\n        if(rows[i] === m){\\n            return k\\n        }\\n        cols[j]++\\n        if(cols[j] === n){\\n            return k\\n        }\\n    }\\n    \\n    return -1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @param {number[][]} mat\\n * @return {number}\\n */\\nvar firstCompleteIndex = function(arr, mat) {\\n    const n = mat.length;\\n    const m = mat[0].length;\\n    let map = new Map();\\n    for(let i = 0; i < n; i++){\\n        for(let j = 0; j < m; j++){\\n            map.set(mat[i][j], [i, j])\\n        }\\n    }\\n    \\n    let rows = (new Array(n)).fill(0);\\n    let cols = (new Array(m)).fill(0);\\n    \\n    for(let k = 0; k < arr.length; k++){\\n        let num = arr[k]\\n        let [i, j] = map.get(num);\\n        rows[i]++;\\n        if(rows[i] === m){\\n            return k\\n        }\\n        cols[j]++\\n        if(cols[j] === n){\\n            return k\\n        }\\n    }\\n    \\n    return -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3492526,
                "title": "o-n-easy-approach",
                "content": "\\n# Complexity\\n- Time complexity: O(N) where N is len of arr\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        __map_rc = defaultdict(int)\\n        __map = {}\\n        n = len(mat)\\n        m = len(mat[0])\\n        for i in range(len(mat)):\\n            for j in range(len(mat[0])):\\n                __map[mat[i][j]] = (i,j)\\n        \\n        for i in range(len(arr)):\\n            num = arr[i]\\n            r, c = __map[num][0], __map[num][1]\\n\\n            __map_rc[\"r\" + str(r)] +=1\\n            __map_rc[\"c\" + str(c)] +=1\\n\\n            if  __map_rc[\"r\" + str(r)] == m or __map_rc[\"c\" + str(c)]== n:\\n                return i\\n        \\n        return -1\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        __map_rc = defaultdict(int)\\n        __map = {}\\n        n = len(mat)\\n        m = len(mat[0])\\n        for i in range(len(mat)):\\n            for j in range(len(mat[0])):\\n                __map[mat[i][j]] = (i,j)\\n        \\n        for i in range(len(arr)):\\n            num = arr[i]\\n            r, c = __map[num][0], __map[num][1]\\n\\n            __map_rc[\"r\" + str(r)] +=1\\n            __map_rc[\"c\" + str(c)] +=1\\n\\n            if  __map_rc[\"r\" + str(r)] == m or __map_rc[\"c\" + str(c)]== n:\\n                return i\\n        \\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3492067,
                "title": "hashmap-intuition-explained-java-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOne way to approach this problem is to keep track of the number of painted cells in each row and column of the matrix `mat` as we iterate through the elements in `arr`. However, to determine the row and column of a given element in `mat`, we would need to search through the entire matrix each time, which would result in a time complexity of `O(k * m * n)`, where `k` is the length of `arr`.\\n\\nTo avoid this, we can use a `HashMap` to map each element in the matrix to its corresponding (row, column) pair. This way, we can quickly retrieve the (row, column) pair for a given element in `arr` by doing a constant-time lookup in the `HashMap`. Then, we can update the number of painted cells in the corresponding row and column of the matrix, and check if any row or column has been completely painted after each iteration through `arr`. If a row or column has been completely painted, we can return the index of the current iteration.\\n\\nOverall, this approach reduces the time complexity to `O(k + m * n)` by using a `HashMap` to avoid searching through the entire matrix for each element in `arr`.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize integer variables `m` and `n` to the number of rows and columns in `mat`, respectively.\\n2. Initialize two integer arrays `rows` and `cols` of size `m` and `n`, respectively, to keep track of the number of painted cells in each row and column of `mat`.\\n3. Initialize a HashMap to map each element in `mat` to its corresponding (row, column) pair.\\n4. Iterate through the elements in `arr` using a for loop:\\n    1. Retrieve the corresponding (row, column) pair for the current element from the `HashMap`.\\n    2. Increment the count of the current row and column in the `rows` and `cols` arrays, respectively.\\n    3. Check if the count of the current row or column in the `rows` or `cols` arrays, respectively, is equal to the number of columns or rows in mat. If so, return the index of the current iteration.\\n5. If no row or column has been completely painted, return `-1`.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(k + mn)$$, where `k` is the length of the `arr` array and `m` and `n` are the dimensions of the `mat` matrix. The time complexity is dominated by the for loop iterating through `arr`, which has a time complexity of $$O(k)$$. The `HashMap` lookup and array updates have a time complexity of $$O(1)$$ each, and iterating through the `mat` matrix to create the `HashMap` has a time complexity of $$O(mn)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(mn)$$, for the `HashMap` to store the (row, column) pairs for each element in `mat`, and the `rows` and `cols` arrays to keep track of the number of painted cells in each row and column of `mat`.\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int m =mat.length;\\n        int n= mat[0].length;\\n        int[] rows = new int[m];\\n        int[] cols = new int[n];\\n\\n        HashMap<Integer, Pair> map =new HashMap<>();\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                map.put(mat[i][j], new Pair(i,j));\\n            }\\n        }\\n\\n        for(int i =0;i<arr.length;i++){\\n            Pair p=map.get(arr[i]);\\n            int r = p.i;\\n            int c = p.j;\\n            rows[r]++;\\n            cols[c]++; \\n            if(rows[r]==n || cols[c]==m)\\n                return i;\\n        }\\n\\n        return -1;        \\n    }\\n}\\n\\nclass Pair {\\n    int i,j;\\n    Pair(){}\\n\\n    Pair(int i, int j){\\n        this.i = i;\\n        this.j = j;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int m =mat.length;\\n        int n= mat[0].length;\\n        int[] rows = new int[m];\\n        int[] cols = new int[n];\\n\\n        HashMap<Integer, Pair> map =new HashMap<>();\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                map.put(mat[i][j], new Pair(i,j));\\n            }\\n        }\\n\\n        for(int i =0;i<arr.length;i++){\\n            Pair p=map.get(arr[i]);\\n            int r = p.i;\\n            int c = p.j;\\n            rows[r]++;\\n            cols[c]++; \\n            if(rows[r]==n || cols[c]==m)\\n                return i;\\n        }\\n\\n        return -1;        \\n    }\\n}\\n\\nclass Pair {\\n    int i,j;\\n    Pair(){}\\n\\n    Pair(int i, int j){\\n        this.i = i;\\n        this.j = j;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490791,
                "title": "easy-java-sol-easy-to-understand-code-hashtable",
                "content": "\\n# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n*m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        HashMap<Integer, int[]> map = new HashMap<>();\\n        int m = mat.length; int n = mat[0].length;\\n        for(int i = 1; i <= m*n; i++){\\n            map.put(i,new int[2]);\\n        }\\n\\n        for(int r = 0; r < mat.length; r++){\\n            for(int c = 0; c < mat[0].length; c++){\\n                map.get(mat[r][c])[0] = r;\\n                map.get(mat[r][c])[1] = c;\\n            }\\n        }\\n        \\n        int[] rows = new int[mat.length];\\n        int[] cols = new int[mat[0].length];\\n        for(int i = 0; i < arr.length; i++){\\n            rows[map.get(arr[i])[0]]++;\\n            cols[map.get(arr[i])[1]]++;\\n            if(rows[map.get(arr[i])[0]] == n || cols[map.get(arr[i])[1]] == m){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        HashMap<Integer, int[]> map = new HashMap<>();\\n        int m = mat.length; int n = mat[0].length;\\n        for(int i = 1; i <= m*n; i++){\\n            map.put(i,new int[2]);\\n        }\\n\\n        for(int r = 0; r < mat.length; r++){\\n            for(int c = 0; c < mat[0].length; c++){\\n                map.get(mat[r][c])[0] = r;\\n                map.get(mat[r][c])[1] = c;\\n            }\\n        }\\n        \\n        int[] rows = new int[mat.length];\\n        int[] cols = new int[mat[0].length];\\n        for(int i = 0; i < arr.length; i++){\\n            rows[map.get(arr[i])[0]]++;\\n            cols[map.get(arr[i])[1]]++;\\n            if(rows[map.get(arr[i])[0]] == n || cols[map.get(arr[i])[1]] == m){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490027,
                "title": "simple-c-solution-using-map",
                "content": "# Intuition\\n###### In this problem we need to find the first row or column to be fully painted, so we can think of iterating over the array checking each time whether any row or column is fully painted or not.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. First we declare 2 frequency vectors for checking whether the row or column is fully painted or not and a map.\\n\\n2. Now in order to check for every row or column for fully painted we can use a map to store the index of row and column simultaneouly corresponding to the element value. \\n\\nFor Eg.   m[1] = {0, 0} meaning for the value of element 1 we store the index of row and column i.e. 0.\\n\\n3. When iterating the array we keep updating the index of the row and the column in their corresponding frequency vectors.\\n\\n4. After each updation we check whether the frequency of any row vector element equals to column size or vice versa. \\n\\n5. After it becomes equal we just simply return the index of that particular iteration.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(m*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n) + O(n) + O(m*n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int n = mat.size(), m = mat[0].size();\\n        map<int, pair<int, int>> mp;\\n        vector<int> r(n, 0), c(m, 0); //Frequency Array for checking completely painted row or column\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                mp[mat[i][j]] = {i, j}; //Mapping row and column value to the element\\n            }\\n        }\\n\\n        int ans = 0;\\n        for(int i=0; i<arr.size();i++){\\n            r[mp[arr[i]].first]++;\\n            c[mp[arr[i]].second]++;\\n\\n            if(r[mp[arr[i]].first] == m || c[mp[arr[i]].second] == n){\\n                ans = i;\\n                break;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int n = mat.size(), m = mat[0].size();\\n        map<int, pair<int, int>> mp;\\n        vector<int> r(n, 0), c(m, 0); //Frequency Array for checking completely painted row or column\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                mp[mat[i][j]] = {i, j}; //Mapping row and column value to the element\\n            }\\n        }\\n\\n        int ans = 0;\\n        for(int i=0; i<arr.size();i++){\\n            r[mp[arr[i]].first]++;\\n            c[mp[arr[i]].second]++;\\n\\n            if(r[mp[arr[i]].first] == m || c[mp[arr[i]].second] == n){\\n                ans = i;\\n                break;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3488887,
                "title": "c-simple",
                "content": "```\\nclass Solution {\\n    struct helper{\\n        int row;\\n        int col;\\n    };\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        const int M = mat.size();\\n        const int N = mat[0].size();\\n        \\n        vector<int> rows(M, N);\\n        vector<int> columns(N, M);\\n                \\n        unordered_map<int, helper> lookup;\\n        for(int r = 0; r < M; ++r) {\\n            for(int c = 0; c < N; ++c) {\\n                lookup[mat[r][c]] = {r,c};\\n            }\\n        }\\n        \\n        for(int i = 0; i < M * N; ++i) {\\n            const auto &coord = lookup[arr[i]];\\n            if(--rows[coord.row] == 0 || --columns[coord.col] == 0) {\\n                return i;\\n            }\\n        }\\n        return M * N;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    struct helper{\\n        int row;\\n        int col;\\n    };\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        const int M = mat.size();\\n        const int N = mat[0].size();\\n        \\n        vector<int> rows(M, N);\\n        vector<int> columns(N, M);\\n                \\n        unordered_map<int, helper> lookup;\\n        for(int r = 0; r < M; ++r) {\\n            for(int c = 0; c < N; ++c) {\\n                lookup[mat[r][c]] = {r,c};\\n            }\\n        }\\n        \\n        for(int i = 0; i < M * N; ++i) {\\n            const auto &coord = lookup[arr[i]];\\n            if(--rows[coord.row] == 0 || --columns[coord.col] == 0) {\\n                return i;\\n            }\\n        }\\n        return M * N;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3487440,
                "title": "simple-code-with-approach-and-step-by-step-explaination",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int m = mat.length, n = mat[0].length;\\n        int[] rowCount = new int[m];\\n        int[] colCount = new int[n];\\n        var matLookup = new HashMap<Integer, int[]>();//number vs (mat -> row,col)\\n\\n        //let\\'s fill the map\\n        for(int row = 0; row < m; row++){\\n            for(int col = 0; col < n; col++){\\n                matLookup.put(mat[row][col], new int[]{row, col});\\n            }\\n        }\\n\\n        //let\\'s iterate over the num array and find out its occurance in the mat \\n        for(int i = 0; i < arr.length; i++){\\n            //fetch the position .i.e row and col pos in the mat for the curr num\\n            int currNum = arr[i];\\n            int rowIdx = matLookup.get(currNum)[0];\\n            int colIdx = matLookup.get(currNum)[1];\\n            //since we know we have to paint the cell\\n            //we also upadate the number of painted rows and cols at that specific row and col \\n            rowCount[rowIdx]++;\\n            colCount[colIdx]++;\\n            //now let\\'s try to see if at this time we have a fully painted row or a col\\n            if(rowCount[rowIdx] == n || colCount[colIdx] == m)\\n                return i;\\n        }\\n\\n        return -1;\\n\\n    }\\n}\\n\\n/**\\n\\nrow = [1,1,2]\\n       0,1,2\\ncol = [1,3,0]\\n       0,1,2\\n\\nif(col[i] == m(rowcount) || row[i] == n(col count))\\n    return the curr Idx\\n\\n\\nApproach: \\n* Since all the nums in mat is unique we fill a map of num vs tuple(row,col)\\n* we iterate over the arr\\n* we fetch the occurance of arr[i] from the map and update it row and col count by 1\\n* each time at the end of the loop we check if there is some col or row which are all painted\\n* if yes we return the i;\\n\\nTC: O(N) + O(Mat)\\nSC: O(Mat or m*n)\\n\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int m = mat.length, n = mat[0].length;\\n        int[] rowCount = new int[m];\\n        int[] colCount = new int[n];\\n        var matLookup = new HashMap<Integer, int[]>();//number vs (mat -> row,col)\\n\\n        //let\\'s fill the map\\n        for(int row = 0; row < m; row++){\\n            for(int col = 0; col < n; col++){\\n                matLookup.put(mat[row][col], new int[]{row, col});\\n            }\\n        }\\n\\n        //let\\'s iterate over the num array and find out its occurance in the mat \\n        for(int i = 0; i < arr.length; i++){\\n            //fetch the position .i.e row and col pos in the mat for the curr num\\n            int currNum = arr[i];\\n            int rowIdx = matLookup.get(currNum)[0];\\n            int colIdx = matLookup.get(currNum)[1];\\n            //since we know we have to paint the cell\\n            //we also upadate the number of painted rows and cols at that specific row and col \\n            rowCount[rowIdx]++;\\n            colCount[colIdx]++;\\n            //now let\\'s try to see if at this time we have a fully painted row or a col\\n            if(rowCount[rowIdx] == n || colCount[colIdx] == m)\\n                return i;\\n        }\\n\\n        return -1;\\n\\n    }\\n}\\n\\n/**\\n\\nrow = [1,1,2]\\n       0,1,2\\ncol = [1,3,0]\\n       0,1,2\\n\\nif(col[i] == m(rowcount) || row[i] == n(col count))\\n    return the curr Idx\\n\\n\\nApproach: \\n* Since all the nums in mat is unique we fill a map of num vs tuple(row,col)\\n* we iterate over the arr\\n* we fetch the occurance of arr[i] from the map and update it row and col count by 1\\n* each time at the end of the loop we check if there is some col or row which are all painted\\n* if yes we return the i;\\n\\nTC: O(N) + O(Mat)\\nSC: O(Mat or m*n)\\n\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3486124,
                "title": "java-simple-solution-hashmap-array-technique-o-n",
                "content": "\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N * M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        Map<Integer,List<int[]>> map = new HashMap<>();\\n        int n = mat.length;\\n        int m = mat[0].length;\\n        for(int i = 0;i < n;i++){\\n            for(int j = 0;j < m;j++){\\n                map.putIfAbsent(mat[i][j],new ArrayList<>());\\n                map.get(mat[i][j]).add(new int[]{i,j});\\n            }\\n        }\\n        int[] rows = new int[n];\\n        int[] cols = new int[m];\\n        for(int i = 0;i < arr.length;i++){\\n            for(int[] loc : map.get(arr[i])){\\n                int r = loc[0];\\n                int c = loc[1];\\n                rows[r]++;\\n                cols[c]++;\\n\\n                if(rows[r] == m || cols[c] == n){\\n                    return i;\\n                }\\n            }\\n        }\\n\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        Map<Integer,List<int[]>> map = new HashMap<>();\\n        int n = mat.length;\\n        int m = mat[0].length;\\n        for(int i = 0;i < n;i++){\\n            for(int j = 0;j < m;j++){\\n                map.putIfAbsent(mat[i][j],new ArrayList<>());\\n                map.get(mat[i][j]).add(new int[]{i,j});\\n            }\\n        }\\n        int[] rows = new int[n];\\n        int[] cols = new int[m];\\n        for(int i = 0;i < arr.length;i++){\\n            for(int[] loc : map.get(arr[i])){\\n                int r = loc[0];\\n                int c = loc[1];\\n                rows[r]++;\\n                cols[c]++;\\n\\n                if(rows[r] == m || cols[c] == n){\\n                    return i;\\n                }\\n            }\\n        }\\n\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485972,
                "title": "first-completely-painted-row-or-column-hashmap-java-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int m=mat.length;\\n        int n=mat[0].length;\\n\\n        int []row=new int[m];\\n        int []col=new int[n];\\n\\n        HashMap<Integer,Pos> hm=new HashMap<>();\\n\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                hm.put(mat[i][j],new Pos(i,j));\\n            }\\n        }\\n\\n        for(int i=0;i<arr.length;i++){\\n            Pos p=hm.get(arr[i]);\\n            row[p.r]++;\\n            col[p.c]++;\\n\\n            if(row[p.r]==n || col[p.c]==m){\\n                return i;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n\\nclass Pos{\\n    int r;\\n    int c;\\n\\n    public Pos(int r, int c){\\n        this.r=r;\\n        this.c=c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int m=mat.length;\\n        int n=mat[0].length;\\n\\n        int []row=new int[m];\\n        int []col=new int[n];\\n\\n        HashMap<Integer,Pos> hm=new HashMap<>();\\n\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                hm.put(mat[i][j],new Pos(i,j));\\n            }\\n        }\\n\\n        for(int i=0;i<arr.length;i++){\\n            Pos p=hm.get(arr[i]);\\n            row[p.r]++;\\n            col[p.c]++;\\n\\n            if(row[p.r]==n || col[p.c]==m){\\n                return i;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n\\nclass Pos{\\n    int r;\\n    int c;\\n\\n    public Pos(int r, int c){\\n        this.r=r;\\n        this.c=c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485268,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        Map<Integer,int[]> map = new HashMap<>();\\n        Map<Integer,Integer> row_map = new HashMap<>();\\n        Map<Integer,Integer> col_map = new HashMap<>();\\n        for(int i = 0; i < mat.length; i++)\\n        {\\n            for(int j = 0; j < mat[0].length; j++)\\n            {\\n                map.put(mat[i][j], new int[]{i, j});\\n            }\\n        }\\n        for(int i = 0; i < arr.length; i++)\\n        {\\n            int i_idx = map.get(arr[i])[0];\\n            int j_idx = map.get(arr[i])[1];\\n            int ct_i = row_map.getOrDefault(i_idx, 0) + 1;\\n            if(ct_i == mat[0].length)\\n            {\\n                return i;\\n            }\\n            int ct_j = col_map.getOrDefault(j_idx, 0) + 1;\\n            if(ct_j == mat.length)\\n            {\\n                return i;\\n            }\\n            row_map.put(i_idx, ct_i);\\n            col_map.put(j_idx, ct_j);\\n        }\\n        return arr.length - 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        Map<Integer,int[]> map = new HashMap<>();\\n        Map<Integer,Integer> row_map = new HashMap<>();\\n        Map<Integer,Integer> col_map = new HashMap<>();\\n        for(int i = 0; i < mat.length; i++)\\n        {\\n            for(int j = 0; j < mat[0].length; j++)\\n            {\\n                map.put(mat[i][j], new int[]{i, j});\\n            }\\n        }\\n        for(int i = 0; i < arr.length; i++)\\n        {\\n            int i_idx = map.get(arr[i])[0];\\n            int j_idx = map.get(arr[i])[1];\\n            int ct_i = row_map.getOrDefault(i_idx, 0) + 1;\\n            if(ct_i == mat[0].length)\\n            {\\n                return i;\\n            }\\n            int ct_j = col_map.getOrDefault(j_idx, 0) + 1;\\n            if(ct_j == mat.length)\\n            {\\n                return i;\\n            }\\n            row_map.put(i_idx, ct_i);\\n            col_map.put(j_idx, ct_j);\\n        }\\n        return arr.length - 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484352,
                "title": "python3-o-mn-row-or-col-max-index",
                "content": "```\\nfrom itertools import product\\n\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        ans = len(arr) - 1\\n        idxs = {v : i for i, v in enumerate(arr)}\\n        for r, c in product(range(len(mat)), range(len(mat[0]))): mat[r][c] = idxs[mat[r][c]]\\n        for r in range(len(mat)): ans = min(ans, max(mat[r][c] for c in range(len(mat[0]))))\\n        for c in range(len(mat[0])): ans = min(ans, max(mat[r][c] for r in range(len(mat))))\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom itertools import product\\n\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        ans = len(arr) - 1\\n        idxs = {v : i for i, v in enumerate(arr)}\\n        for r, c in product(range(len(mat)), range(len(mat[0]))): mat[r][c] = idxs[mat[r][c]]\\n        for r in range(len(mat)): ans = min(ans, max(mat[r][c] for c in range(len(mat[0]))))\\n        for c in range(len(mat[0])): ans = min(ans, max(mat[r][c] for r in range(len(mat))))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484294,
                "title": "python3-easy-to-read-needs-improvement-in-time-consumption-though",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy original solution was TLE. this is inspired by this solution.\\nhttps://leetcode.com/problems/first-completely-painted-row-or-column/solutions/3468410/just-use-a-simple-map/?languageTags=java\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Initialize `row` and `col` dictionaries. They will hold the number of house painted againt the index of row and column.\\n- Iterate through `mat` and store the ith and jth index (the x and y index) for each house number in a dictionary. The two indexes represent the index of the row and column.\\n- Iterate through `arr` and get the x,y index from the `position` dict (from above) and increment the integer value againt the index of `row` and `col` by 1.\\n- Check if value of integer against the row index `x` == n (length of column) or value of integer against the column index `y` == m (length of row). If yes, then that means that either the row at index `x` or the column at index `y` are completely painted. Return index ith count of iteration from here\\n\\n# Complexity\\n- Time complexity: O(N) N is total number of houses to paint\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N^2), a tuple is stored against each position.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        # Create a dictionary\\n        rows = {}\\n        cols = {}\\n\\n        positions = {}\\n        m = len(mat)\\n        n = len(mat[0])\\n\\n        for i in range(m):\\n            for j in range(n):\\n                positions[mat[i][j]] = (i,j)\\n                print(positions[mat[i][j]])\\n        \\n        for i,index in enumerate(arr):\\n            x,y = positions[index]\\n            rows[x] = (rows[x] + 1) if x in rows else 1\\n            cols[y] = (cols[y] + 1) if y in cols else 1\\n\\n            if rows[x] == n or cols[y] == m:\\n                return i\\n\\n        return len(arr) - 1\\n\\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        # Create a dictionary\\n        rows = {}\\n        cols = {}\\n\\n        positions = {}\\n        m = len(mat)\\n        n = len(mat[0])\\n\\n        for i in range(m):\\n            for j in range(n):\\n                positions[mat[i][j]] = (i,j)\\n                print(positions[mat[i][j]])\\n        \\n        for i,index in enumerate(arr):\\n            x,y = positions[index]\\n            rows[x] = (rows[x] + 1) if x in rows else 1\\n            cols[y] = (cols[y] + 1) if y in cols else 1\\n\\n            if rows[x] == n or cols[y] == m:\\n                return i\\n\\n        return len(arr) - 1\\n\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484293,
                "title": "python3-easy-to-read-needs-improvement-in-time-consumption-though",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy original solution was TLE. this is inspired by this solution.\\nhttps://leetcode.com/problems/first-completely-painted-row-or-column/solutions/3468410/just-use-a-simple-map/?languageTags=java\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Initialize `row` and `col` dictionaries. They will hold the number of house painted againt the index of row and column.\\n- Iterate through `mat` and store the ith and jth index (the x and y index) for each house number in a dictionary. The two indexes represent the index of the row and column.\\n- Iterate through `arr` and get the x,y index from the `position` dict (from above) and increment the integer value againt the index of `row` and `col` by 1.\\n- Check if value of integer against the row index `x` == n (length of column) or value of integer against the column index `y` == m (length of row). If yes, then that means that either the row at index `x` or the column at index `y` are completely painted. Return index ith count of iteration from here\\n\\n# Complexity\\n- Time complexity: O(N) N is total number of houses to paint\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N^2), a tuple is stored against each position.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        # Create a dictionary\\n        rows = {}\\n        cols = {}\\n\\n        positions = {}\\n        m = len(mat)\\n        n = len(mat[0])\\n\\n        for i in range(m):\\n            for j in range(n):\\n                positions[mat[i][j]] = (i,j)\\n                print(positions[mat[i][j]])\\n        \\n        for i,index in enumerate(arr):\\n            x,y = positions[index]\\n            rows[x] = (rows[x] + 1) if x in rows else 1\\n            cols[y] = (cols[y] + 1) if y in cols else 1\\n\\n            if rows[x] == n or cols[y] == m:\\n                return i\\n\\n        return len(arr) - 1\\n\\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        # Create a dictionary\\n        rows = {}\\n        cols = {}\\n\\n        positions = {}\\n        m = len(mat)\\n        n = len(mat[0])\\n\\n        for i in range(m):\\n            for j in range(n):\\n                positions[mat[i][j]] = (i,j)\\n                print(positions[mat[i][j]])\\n        \\n        for i,index in enumerate(arr):\\n            x,y = positions[index]\\n            rows[x] = (rows[x] + 1) if x in rows else 1\\n            cols[y] = (cols[y] + 1) if y in cols else 1\\n\\n            if rows[x] == n or cols[y] == m:\\n                return i\\n\\n        return len(arr) - 1\\n\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484028,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i = 0; i < arr.length; i++)\\n          map.put(arr[i], i);\\n        int ans = Integer.MAX_VALUE;\\n        \\n        for(int i = 0; i < mat.length; i++){\\n            int currMaxIndex = Integer.MIN_VALUE;\\n\\n            for(int j = 0; j < mat[0].length; j++)\\n              currMaxIndex = Math.max(currMaxIndex, map.get(mat[i][j]));\\n            \\n            ans = Math.min(ans, currMaxIndex);\\n        }\\n\\n        for(int j = 0; j < mat[0].length; j++){\\n            int currMaxIndex = Integer.MIN_VALUE;\\n\\n            for(int i = 0; i < mat.length; i++)\\n              currMaxIndex = Math.max(currMaxIndex, map.get(mat[i][j]));\\n\\n            ans = Math.min(ans, currMaxIndex);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i = 0; i < arr.length; i++)\\n          map.put(arr[i], i);\\n        int ans = Integer.MAX_VALUE;\\n        \\n        for(int i = 0; i < mat.length; i++){\\n            int currMaxIndex = Integer.MIN_VALUE;\\n\\n            for(int j = 0; j < mat[0].length; j++)\\n              currMaxIndex = Math.max(currMaxIndex, map.get(mat[i][j]));\\n            \\n            ans = Math.min(ans, currMaxIndex);\\n        }\\n\\n        for(int j = 0; j < mat[0].length; j++){\\n            int currMaxIndex = Integer.MIN_VALUE;\\n\\n            for(int i = 0; i < mat.length; i++)\\n              currMaxIndex = Math.max(currMaxIndex, map.get(mat[i][j]));\\n\\n            ans = Math.min(ans, currMaxIndex);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483164,
                "title": "python-memory-44-9-mb-beats-93-52",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n\\n- Space complexity: $$O(n^2)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        indices=[None for i in range(len(mat)*len(mat[0])+2)]\\n        for i in range(len(mat)):\\n            for j in range(len(mat[0])):\\n                indices[mat[i][j]]=(i, j)\\n        \\n        row=[0 for i in range(len(mat))]\\n        col=[0 for j in range(len(mat[0]))]\\n        for x in range(len(arr)):\\n            i, j=indices[arr[x]]\\n            row[i]+=1\\n            col[j]+=1\\n            # print(arr[x], \"--\")\\n            # print(i, row[i], len(mat))\\n            # print(j, col[j], len(mat[0]))\\n            # print(\"--\")\\n            if row[i]==len(mat[0]) or col[j]==len(mat):\\n                return x\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        indices=[None for i in range(len(mat)*len(mat[0])+2)]\\n        for i in range(len(mat)):\\n            for j in range(len(mat[0])):\\n                indices[mat[i][j]]=(i, j)\\n        \\n        row=[0 for i in range(len(mat))]\\n        col=[0 for j in range(len(mat[0]))]\\n        for x in range(len(arr)):\\n            i, j=indices[arr[x]]\\n            row[i]+=1\\n            col[j]+=1\\n            # print(arr[x], \"--\")\\n            # print(i, row[i], len(mat))\\n            # print(j, col[j], len(mat[0]))\\n            # print(\"--\")\\n            if row[i]==len(mat[0]) or col[j]==len(mat):\\n                return x\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483074,
                "title": "only-1-iteration-over-both-the-arrays-using-java-easy-solution-bats-98",
                "content": "\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        \\n        var r=mat.length;\\n        var c=mat[0].length;\\n        var posr=new int[r*c];\\n        var posc=new int[c*r];\\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n                var curr=mat[i][j];\\n                posr[curr-1]=i;\\n                posc[curr-1]=j;\\n            }\\n        }\\n        \\n        var row=new int[r];\\n        var col=new int[c];\\n        int i=0;\\n        for(i=0;i<arr.length;i++){\\n            var curr=arr[i];\\n            var cr=posr[curr-1];\\n            var cc=posc[curr-1];\\n            row[cr]++;\\n            col[cc]++;\\n            if(row[cr]>=c || col[cc]>=r)return i;\\n        }\\n        return i-1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        \\n        var r=mat.length;\\n        var c=mat[0].length;\\n        var posr=new int[r*c];\\n        var posc=new int[c*r];\\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n                var curr=mat[i][j];\\n                posr[curr-1]=i;\\n                posc[curr-1]=j;\\n            }\\n        }\\n        \\n        var row=new int[r];\\n        var col=new int[c];\\n        int i=0;\\n        for(i=0;i<arr.length;i++){\\n            var curr=arr[i];\\n            var cr=posr[curr-1];\\n            var cc=posc[curr-1];\\n            row[cr]++;\\n            col[cc]++;\\n            if(row[cr]>=c || col[cc]>=r)return i;\\n        }\\n        return i-1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3482925,
                "title": "java-time-o-m-n-space-o-m-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStore row and col index to map and return index once it hits row or col length return the current index.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m * n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m * n)\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        if(mat.length == 1 || mat[0].length == 1)\\n            return 0;\\n        Map<Integer, int[]> map = new HashMap<>();\\n        int[] rows = new int[mat.length];\\n        int[] cols = new int[mat[0].length];\\n        for(int i = 0; i < mat.length; ++i){\\n            for(int j = 0; j < mat[0].length; ++j){\\n                map.put(mat[i][j], new int[]{i, j});\\n            }\\n        }\\n        for(int i = 0; i < arr.length; ++i){\\n            int[] idx = map.get(arr[i]);\\n            rows[idx[0]]++;\\n            cols[idx[1]]++;\\n            if(rows[idx[0]] == mat[0].length || cols[idx[1]] == mat.length)\\n                return i;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        if(mat.length == 1 || mat[0].length == 1)\\n            return 0;\\n        Map<Integer, int[]> map = new HashMap<>();\\n        int[] rows = new int[mat.length];\\n        int[] cols = new int[mat[0].length];\\n        for(int i = 0; i < mat.length; ++i){\\n            for(int j = 0; j < mat[0].length; ++j){\\n                map.put(mat[i][j], new int[]{i, j});\\n            }\\n        }\\n        for(int i = 0; i < arr.length; ++i){\\n            int[] idx = map.get(arr[i]);\\n            rows[idx[0]]++;\\n            cols[idx[1]]++;\\n            if(rows[idx[0]] == mat[0].length || cols[idx[1]] == mat.length)\\n                return i;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481464,
                "title": "java-map-solution-o-n-m-time-space",
                "content": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int m=mat.length;\\n        int n=mat[0].length;\\n        Map<Integer, Integer>matrixPositions = new HashMap<>();\\n        for (int i=0;i<m;i++){\\n            for (int j=0;j<n;j++){\\n                matrixPositions.put(mat[i][j], i*n+j);\\n            }\\n        }\\n        \\n        int[]columns = new int[n];\\n        int[]rows=new int[m];\\n        \\n        for (int i=0;i< arr.length;i++){\\n           int row= matrixPositions.get(arr[i])/n;\\n           int column = matrixPositions.get(arr[i])%n;\\n            columns[column]++;\\n            rows[row]++;\\n            if (columns[column]==m || rows[row]==n)return i;\\n        }\\n        return arr.length-1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int m=mat.length;\\n        int n=mat[0].length;\\n        Map<Integer, Integer>matrixPositions = new HashMap<>();\\n        for (int i=0;i<m;i++){\\n            for (int j=0;j<n;j++){\\n                matrixPositions.put(mat[i][j], i*n+j);\\n            }\\n        }\\n        \\n        int[]columns = new int[n];\\n        int[]rows=new int[m];\\n        \\n        for (int i=0;i< arr.length;i++){\\n           int row= matrixPositions.get(arr[i])/n;\\n           int column = matrixPositions.get(arr[i])%n;\\n            columns[column]++;\\n            rows[row]++;\\n            if (columns[column]==m || rows[row]==n)return i;\\n        }\\n        return arr.length-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481292,
                "title": "c-single-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int n = mat.size(), m = mat[0].size();\\n        vector<int> row(n, m);\\n        vector<int> col(m, n);\\n        unordered_map<int, pair<int, int>> hash;\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++){\\n                hash[mat[i][j]] = {i, j};\\n            }\\n        int res;\\n        for(int i = 0; i < arr.size(); i++){\\n            int p = hash[arr[i]].first;\\n            int q = hash[arr[i]].second;\\n            if(--row[p] == 0){\\n                res = i;\\n                break;\\n            }\\n            if(--col[q] == 0){\\n                res = i;\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int n = mat.size(), m = mat[0].size();\\n        vector<int> row(n, m);\\n        vector<int> col(m, n);\\n        unordered_map<int, pair<int, int>> hash;\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++){\\n                hash[mat[i][j]] = {i, j};\\n            }\\n        int res;\\n        for(int i = 0; i < arr.size(); i++){\\n            int p = hash[arr[i]].first;\\n            int q = hash[arr[i]].second;\\n            if(--row[p] == 0){\\n                res = i;\\n                break;\\n            }\\n            if(--col[q] == 0){\\n                res = i;\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3480857,
                "title": "c-counting-rows-and-columns",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs every array value will be unique and exist in `mat` matrix, we can use **Counter** arrray(rows, cols) to count the **value positions**. And if we reach: \\n- rows `count size == (matrix column).size` (C variable) OR\\n- cols `count size == (matrix rows).size` (R variable)\\n\\nReturn the arr `ith` index\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- **int[] rows = new int[R];** - Count of arr item position in rows\\n- **int[] cols = new int[C];** - Count of arr item position in columns\\n- **(int r, int c)[] positions = new (int r, int c)[R * C + 1];** - Store the value position as **Value tuple** `(int r, int c)`\\n\\n\\n# Complexity\\n- Time complexity:$$O(R * C )$$, where R, C = total Rows and Columns size\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(R * C)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int FirstCompleteIndex(int[] arr, int[][] mat) {\\n        int R = mat.Length;\\n        int C = mat[0].Length;\\n\\n        int[] rows = new int[R];\\n        int[] cols = new int[C];\\n        (int r, int c)[] positions = new (int r, int c)[R * C + 1];\\n\\n        for (int i = 0; i < R; i++) {\\n            for (int j = 0; j < C; j++) {\\n                positions[mat[i][j]] = (i, j);\\n            }\\n        }\\n\\n        for (int i = 0; i < arr.Length; i++) {\\n            (int r, int c) = positions[arr[i]];\\n            rows[r]++;\\n            cols[c]++;\\n\\n            if (rows[r] == C || cols[c] == R) {\\n                return i;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Counting"
                ],
                "code": "```\\npublic class Solution {\\n    public int FirstCompleteIndex(int[] arr, int[][] mat) {\\n        int R = mat.Length;\\n        int C = mat[0].Length;\\n\\n        int[] rows = new int[R];\\n        int[] cols = new int[C];\\n        (int r, int c)[] positions = new (int r, int c)[R * C + 1];\\n\\n        for (int i = 0; i < R; i++) {\\n            for (int j = 0; j < C; j++) {\\n                positions[mat[i][j]] = (i, j);\\n            }\\n        }\\n\\n        for (int i = 0; i < arr.Length; i++) {\\n            (int r, int c) = positions[arr[i]];\\n            rows[r]++;\\n            cols[c]++;\\n\\n            if (rows[r] == C || cols[c] == R) {\\n                return i;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3480660,
                "title": "first-completely-painted-row-or-column-o-n-m-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n+m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        n=len(mat)\\n        m=len(mat[0])\\n        d={}\\n        for i in range(n*m):\\n            d[arr[i]]=i\\n        row=[-1]*n\\n        col=[-1]*m\\n        for i in range(n):\\n            for j in range(m):\\n                row[i]=max(d[mat[i][j]],row[i])\\n                col[j]=max(d[mat[i][j]],col[j])\\n        return min(min(row),min(col))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        n=len(mat)\\n        m=len(mat[0])\\n        d={}\\n        for i in range(n*m):\\n            d[arr[i]]=i\\n        row=[-1]*n\\n        col=[-1]*m\\n        for i in range(n):\\n            for j in range(m):\\n                row[i]=max(d[mat[i][j]],row[i])\\n                col[j]=max(d[mat[i][j]],col[j])\\n        return min(min(row),min(col))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3480410,
                "title": "easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check_row(pair<int, int> loc, vector<vector<int>>& mat){\\n        int flag = 1;\\n        for(int j=0; j < mat[0].size(); j++){\\n            if(mat[loc.first][j]!=-1){\\n                flag = 0;\\n                break;\\n            } \\n        } \\n        return flag;\\n    }\\n\\n    bool check_column(pair<int, int> loc, vector<vector<int>>& mat){\\n        int flag = 1;\\n        for(int i=0; i < mat.size(); i++){\\n            if(mat[i][loc.second]!=-1){\\n                flag = 0;\\n                break;\\n            }\\n        }\\n        return flag;\\n    }\\n\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        unordered_map<int, pair<int, int>> mp;\\n        pair<int, int> loc;\\n        for(int i=0; i < mat.size(); i++){\\n            for(int j=0; j < mat[i].size(); j++){\\n                mp[mat[i][j]] = {i,j};\\n            }\\n        }\\n        int count =0;\\n        for(int i=0; i < arr.size(); i++){\\n            loc = mp[arr[i]];\\n            mat[loc.first][loc.second] = -1;\\n            count++;\\n            if(count >= mat[0].size()){\\n                if(check_row(loc, mat)) return i;\\n            }\\n            if(count >= mat.size()){\\n                if(check_column(loc, mat)) return i;\\n            }\\n            \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check_row(pair<int, int> loc, vector<vector<int>>& mat){\\n        int flag = 1;\\n        for(int j=0; j < mat[0].size(); j++){\\n            if(mat[loc.first][j]!=-1){\\n                flag = 0;\\n                break;\\n            } \\n        } \\n        return flag;\\n    }\\n\\n    bool check_column(pair<int, int> loc, vector<vector<int>>& mat){\\n        int flag = 1;\\n        for(int i=0; i < mat.size(); i++){\\n            if(mat[i][loc.second]!=-1){\\n                flag = 0;\\n                break;\\n            }\\n        }\\n        return flag;\\n    }\\n\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        unordered_map<int, pair<int, int>> mp;\\n        pair<int, int> loc;\\n        for(int i=0; i < mat.size(); i++){\\n            for(int j=0; j < mat[i].size(); j++){\\n                mp[mat[i][j]] = {i,j};\\n            }\\n        }\\n        int count =0;\\n        for(int i=0; i < arr.size(); i++){\\n            loc = mp[arr[i]];\\n            mat[loc.first][loc.second] = -1;\\n            count++;\\n            if(count >= mat[0].size()){\\n                if(check_row(loc, mat)) return i;\\n            }\\n            if(count >= mat.size()){\\n                if(check_column(loc, mat)) return i;\\n            }\\n            \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3479777,
                "title": "javascript-6-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} arr\\n * @param {number[][]} mat\\n * @return {number}\\n */\\nvar firstCompleteIndex = function(arr, mat) {\\n    let n = mat.length, m = mat[0].length, mp = new Map();\\n    let cntRow = new Array(n).fill(m), cntCol = new Array(m).fill(n);\\n    for(let i=0;i<n;i++) for(let j=0; j<m; j++) mp.set(mat[i][j], [i, j]);\\n    for(let k = 0; k<arr.length; k++){\\n        let [i, j] = mp.get(arr[k]);\\n        if(--cntRow[i] == 0 || --cntCol[j] == 0) return k; \\n    } \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @param {number[][]} mat\\n * @return {number}\\n */\\nvar firstCompleteIndex = function(arr, mat) {\\n    let n = mat.length, m = mat[0].length, mp = new Map();\\n    let cntRow = new Array(n).fill(m), cntCol = new Array(m).fill(n);\\n    for(let i=0;i<n;i++) for(let j=0; j<m; j++) mp.set(mat[i][j], [i, j]);\\n    for(let k = 0; k<arr.length; k++){\\n        let [i, j] = mp.get(arr[k]);\\n        if(--cntRow[i] == 0 || --cntCol[j] == 0) return k; \\n    } \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3478663,
                "title": "c-using-hashmap-easy-to-understand-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int row = mat.size(), col = mat[0].size();\\n        unordered_map<int, pair<int, int>> ump;\\n        vector<int> rowArr(row, col), colArr(col, row);\\n        \\n\\t\\t//Create Hash map with element as key and row & col as a value(pair)\\n        for(int i=0;i<row;i++)\\n        {\\n            for(int j=0;j<col;j++)\\n            {\\n                ump[mat[i][j]] = {i, j};\\n            }\\n        }\\n        \\n\\t\\t//Pass through the array, fetch corresponding row & col and decrement the perticular row/col value from rowArr and colArr and when hit 0 return i \\n        for(int i=0;i<arr.size();i++)\\n        {\\n            pair<int, int> pr = ump[arr[i]];\\n            int r = pr.first;\\n            int c = pr.second;\\n            \\n            rowArr[r]--;\\n            colArr[c]--;\\n            if(rowArr[r]==0 || colArr[c]==0)\\n                return i;\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int row = mat.size(), col = mat[0].size();\\n        unordered_map<int, pair<int, int>> ump;\\n        vector<int> rowArr(row, col), colArr(col, row);\\n        \\n\\t\\t//Create Hash map with element as key and row & col as a value(pair)\\n        for(int i=0;i<row;i++)\\n        {\\n            for(int j=0;j<col;j++)\\n            {\\n                ump[mat[i][j]] = {i, j};\\n            }\\n        }\\n        \\n\\t\\t//Pass through the array, fetch corresponding row & col and decrement the perticular row/col value from rowArr and colArr and when hit 0 return i \\n        for(int i=0;i<arr.size();i++)\\n        {\\n            pair<int, int> pr = ump[arr[i]];\\n            int r = pr.first;\\n            int c = pr.second;\\n            \\n            rowArr[r]--;\\n            colArr[c]--;\\n            if(rowArr[r]==0 || colArr[c]==0)\\n                return i;\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478615,
                "title": "java-solution-using-hashmap",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int[] row = new int[m];\\n        int[] col = new int[n];\\n\\n        Map<Integer, Pair> map = new HashMap<>();\\n\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                map.put(mat[i][j], new Pair(i, j));\\n            }\\n        }   \\n        for(int i = 0; i < arr.length; i++){\\n            Pair p = map.get(arr[i]);\\n            row[p.i]++;\\n            col[p.j]++;\\n            if(row[p.i] == n || col[p.j] == m) return i;\\n        }\\n        return -1;\\n    }\\n}\\nclass Pair {\\n    int i;\\n    int j;\\n    Pair (int i, int j){\\n        this.i = i;\\n        this.j = j;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int[] row = new int[m];\\n        int[] col = new int[n];\\n\\n        Map<Integer, Pair> map = new HashMap<>();\\n\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                map.put(mat[i][j], new Pair(i, j));\\n            }\\n        }   \\n        for(int i = 0; i < arr.length; i++){\\n            Pair p = map.get(arr[i]);\\n            row[p.i]++;\\n            col[p.j]++;\\n            if(row[p.i] == n || col[p.j] == m) return i;\\n        }\\n        return -1;\\n    }\\n}\\nclass Pair {\\n    int i;\\n    int j;\\n    Pair (int i, int j){\\n        this.i = i;\\n        this.j = j;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478012,
                "title": "java-time-complexity-o-n-2-space-complexity-o-n-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGet the index of element and sum of row wise and column wise sum and subtarct element from both and when ever the row sum or and column sum will zero return that index....\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst inserting all element with their index and then after also get the sum every row and column in seprate 2d vector and then when ever we subtract the from the sum of row and column and when erver the sum of the sum of either row of column become zero then just return that index.......\\n\\n# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n*m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        unordered_map<int,pair<int,int>>m;\\n        int l=0;\\n        int n=mat.size(),k=mat[0].size();\\n        vector<vector<long long>>a(n+1,vector<long long>(k+1));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<k;j++)\\n            {\\n                a[i][j]=mat[i][j];\\n                pair<int,int>p;\\n                p.first=i;\\n                p.second=j;\\n                m[mat[i][j]]=p;\\n            }\\n        }\\n        for(int i=0;i<k;i++)\\n        {\\n            long long  sum=0;\\n            for(int j=0;j<n;j++)\\n                sum+=mat[j][i];\\n            a[n][l]=sum;\\n            l++;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            long long sum=0;\\n            for(int j=0;j<k;j++)\\n                sum+=mat[i][j];\\n            a[i][k]=sum;\\n        }\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            pair<int,int>p=m[arr[i]];\\n            a[n][p.second]-=mat[p.first][p.second];\\n            a[p.first][k]-=mat[p.first][p.second];\\n            if(a[n][p.second]==0 or a[p.first][k]==0)\\n                return i;\\n        }\\n        return -1;\\n    }\\n};\\nfeel free to ask your doubt happy to help......\\nIf it help you than plz upvote it......Thanks!!!!\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Greedy",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        unordered_map<int,pair<int,int>>m;\\n        int l=0;\\n        int n=mat.size(),k=mat[0].size();\\n        vector<vector<long long>>a(n+1,vector<long long>(k+1));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<k;j++)\\n            {\\n                a[i][j]=mat[i][j];\\n                pair<int,int>p;\\n                p.first=i;\\n                p.second=j;\\n                m[mat[i][j]]=p;\\n            }\\n        }\\n        for(int i=0;i<k;i++)\\n        {\\n            long long  sum=0;\\n            for(int j=0;j<n;j++)\\n                sum+=mat[j][i];\\n            a[n][l]=sum;\\n            l++;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            long long sum=0;\\n            for(int j=0;j<k;j++)\\n                sum+=mat[i][j];\\n            a[i][k]=sum;\\n        }\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            pair<int,int>p=m[arr[i]];\\n            a[n][p.second]-=mat[p.first][p.second];\\n            a[p.first][k]-=mat[p.first][p.second];\\n            if(a[n][p.second]==0 or a[p.first][k]==0)\\n                return i;\\n        }\\n        return -1;\\n    }\\n};\\nfeel free to ask your doubt happy to help......\\nIf it help you than plz upvote it......Thanks!!!!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477531,
                "title": "c-faster-than-100",
                "content": "Simply maintain how many uncoloured cells there are in rows and columns. When it reaches zero return the number of nums seen.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    Solution()\\n    {\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);\\n        cout.tie(0);\\n    }\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat)\\n    {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        vector<int> rowRemain(m, n);\\n        vector<int> colRemain(n, m);\\n        vector<pair<int,int>> num2coords(m*n+1);\\n        for(int row = 0; row<m; row++)\\n            for(int col = 0; col<n; col++)\\n                num2coords[mat[row][col]] = make_pair(row, col);\\n        int ret = 0;\\n        for(int num : arr)\\n        {\\n            rowRemain[num2coords[num].first] --;\\n            if(rowRemain[num2coords[num].first] == 0)\\n                return ret;\\n            colRemain[num2coords[num].second] --;\\n            if(colRemain[num2coords[num].second] == 0)\\n                return ret;\\n            ret ++;\\n        }\\n        return 0; // never happens\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Solution()\\n    {\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);\\n        cout.tie(0);\\n    }\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat)\\n    {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        vector<int> rowRemain(m, n);\\n        vector<int> colRemain(n, m);\\n        vector<pair<int,int>> num2coords(m*n+1);\\n        for(int row = 0; row<m; row++)\\n            for(int col = 0; col<n; col++)\\n                num2coords[mat[row][col]] = make_pair(row, col);\\n        int ret = 0;\\n        for(int num : arr)\\n        {\\n            rowRemain[num2coords[num].first] --;\\n            if(rowRemain[num2coords[num].first] == 0)\\n                return ret;\\n            colRemain[num2coords[num].second] --;\\n            if(colRemain[num2coords[num].second] == 0)\\n                return ret;\\n            ret ++;\\n        }\\n        return 0; // never happens\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3476474,
                "title": "simple-python-solution-w-comments",
                "content": "\\n\\n# Code\\n```\\n# the problem comes down to how do we know when a row or a column is filled\\n# record each number\\'s position in the matrix \\n# for each number in arr, that number row++ and col++\\n# return if row == m or col == n\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        mapRow, mapCol = {}, {}\\n        m, n = len(mat), len(mat[0])\\n        row, col = [0]*len(mat), [0]*len(mat[0])\\n        for i in range(len(mat)): \\n            for j in range(len(mat[0])): \\n                mapRow[mat[i][j]] = i\\n                mapCol[mat[i][j]] = j\\n        for index, num in enumerate(arr): \\n            row[mapRow[num]]+=1\\n            col[mapCol[num]]+=1\\n            if row[mapRow[num]]==n or col[mapCol[num]] == m:\\n                return index\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# the problem comes down to how do we know when a row or a column is filled\\n# record each number\\'s position in the matrix \\n# for each number in arr, that number row++ and col++\\n# return if row == m or col == n\\nclass Solution:\\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\\n        mapRow, mapCol = {}, {}\\n        m, n = len(mat), len(mat[0])\\n        row, col = [0]*len(mat), [0]*len(mat[0])\\n        for i in range(len(mat)): \\n            for j in range(len(mat[0])): \\n                mapRow[mat[i][j]] = i\\n                mapCol[mat[i][j]] = j\\n        for index, num in enumerate(arr): \\n            row[mapRow[num]]+=1\\n            col[mapCol[num]]+=1\\n            if row[mapRow[num]]==n or col[mapCol[num]] == m:\\n                return index\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475677,
                "title": "c-dictionary",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int FirstCompleteIndex(int[] arr, int[][] mat) {\\n        var dic = new Dictionary<int, (int, int)>();\\n        for (var i = 0; i < mat.Length; i++) {\\n            for (var j = 0; j < mat[i].Length; j++) {\\n                dic.Add(mat[i][j], (i, j));\\n            }\\n        }\\n\\n        var row = new int[mat.Length];\\n        var col = new int[mat[0].Length];\\n        var rowIndex = 0;\\n        var colIndex = 0;\\n        for (var k = 0; k < arr.Length; k++) {\\n            rowIndex = dic[arr[k]].Item1;\\n            colIndex = dic[arr[k]].Item2;\\n            row[rowIndex]++;\\n            col[colIndex]++;\\n            if (row[rowIndex] == mat[0].Length || col[colIndex] == mat.Length)\\n                return k;\\n        }\\n\\n        return 0;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int FirstCompleteIndex(int[] arr, int[][] mat) {\\n        var dic = new Dictionary<int, (int, int)>();\\n        for (var i = 0; i < mat.Length; i++) {\\n            for (var j = 0; j < mat[i].Length; j++) {\\n                dic.Add(mat[i][j], (i, j));\\n            }\\n        }\\n\\n        var row = new int[mat.Length];\\n        var col = new int[mat[0].Length];\\n        var rowIndex = 0;\\n        var colIndex = 0;\\n        for (var k = 0; k < arr.Length; k++) {\\n            rowIndex = dic[arr[k]].Item1;\\n            colIndex = dic[arr[k]].Item2;\\n            row[rowIndex]++;\\n            col[colIndex]++;\\n            if (row[rowIndex] == mat[0].Length || col[colIndex] == mat.Length)\\n                return k;\\n        }\\n\\n        return 0;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475551,
                "title": "tracking-the-reamaining-cells-hashmap-for-lookups-o-m-n",
                "content": "# Intuition\\nSince the matrix contains all integers in the range from `1` to `m * n` the values are unique in each cell we just need to keep track of the number of remaining cells in each row and in each column \\n\\n# Approach\\n- keep track of the location of each integer in a map for constant lookups \\n- loop over the arr and reduce the corresponding row and column by 1 then check if either is `0` then return the integer \\n\\n# Complexity\\n- Time complexity: `O(m * n)`\\n\\n- Space complexity: `O(m * n)`\\n\\n\\n# Code\\n```\\n/**\\n * @param {number[]} arr\\n * @param {number[][]} mat\\n * @return {number}\\n */\\nvar firstCompleteIndex = function (arr, mat) {\\n    const locations = {};\\n    const M = mat.length\\n    const N = mat[0].length\\n    const cols = new Array(N).fill(M);\\n    const rows = new Array(M).fill(N);\\n    for (let i = 0; i < M; i++) {\\n        for (let j = 0; j < N; j++) {\\n            locations[mat[i][j]] = [i, j]\\n        }\\n    }\\n    for (let x = 0; x < arr.length; x++) {\\n        const [i, j] = locations[arr[x]];\\n        rows[i]--;\\n        cols[j]--;\\n        if (!rows[i] || !cols[j])\\n            return x;\\n    }\\n    return -1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @param {number[][]} mat\\n * @return {number}\\n */\\nvar firstCompleteIndex = function (arr, mat) {\\n    const locations = {};\\n    const M = mat.length\\n    const N = mat[0].length\\n    const cols = new Array(N).fill(M);\\n    const rows = new Array(M).fill(N);\\n    for (let i = 0; i < M; i++) {\\n        for (let j = 0; j < N; j++) {\\n            locations[mat[i][j]] = [i, j]\\n        }\\n    }\\n    for (let x = 0; x < arr.length; x++) {\\n        const [i, j] = locations[arr[x]];\\n        rows[i]--;\\n        cols[j]--;\\n        if (!rows[i] || !cols[j])\\n            return x;\\n    }\\n    return -1\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1877980,
                "content": [
                    {
                        "username": "namandt",
                        "content": "Nice Question!."
                    },
                    {
                        "username": "cionx",
                        "content": "For those searching for test cases:\\n```text\\n[8,2,4,9,3,5,7,10,1,6]\\n[[8,2,9,10,4],[1,7,6,3,5]]\\n```\\nfound an error in my submission that the previous cases missed."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "That\\'s Mahh Boii, By the way... I got TLE"
                    },
                    {
                        "username": "2uringTested",
                        "content": "This binary search code passes all the test cases, 1058 of them, yet still gets a TLE :( how to fix the issue?\\n `\\nclass Solution {\\npublic:\\n    using vvi = vector<vector<int>>;\\n    \\n    bool color(vvi mat,set<int>& nums){\\n        for(int i=0;i<mat.size();i++){\\n            bool isColor = true;\\n            for(int j=0;j<mat[0].size();j++){\\n                if(nums.find(mat[i][j])!=nums.end()){\\n                    mat[i][j]=-1;\\n                }else{\\n                    isColor = false;\\n                }\\n            }\\n            if(isColor == true) return true;\\n        }\\n        for(int j=0;j<mat[0].size();j++){\\n            bool isColor = true;\\n            for(int i=0;i<mat.size();i++){\\n                if(mat[i][j]!=-1){\\n                    isColor = false;\\n                    break;\\n                }\\n            }\\n            if(isColor) return true;\\n        }\\n        return false;\\n\\n    }\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        \\n        int left = 0;\\n        int right = arr.size()-1;\\n        int mid = left+(right-left)/2;\\n        int ans = INT_MAX;\\n\\n        while(left<=right){\\n\\n            set<int> nums;\\n            for(int j=0;j<=mid;j++){\\n                nums.insert(arr[j]);\\n            }\\n            if(color(mat,nums)){\\n                ans = min(ans,mid);\\n                right = mid-1;\\n            }else{\\n                left = mid+1;\\n            }\\n\\n            mid = left+(right-left)/2;\\n            \\n        }\\n        return ans;\\n    }};`"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of your code is quite high due to multiple reasons. Let\\'s consider n = arr.size(), m = mat.size(), and p = mat[0].size():\\n\\n1. The main binary search loop runs log(n) times.\\n2. In each iteration of the binary search, you\\'re inserting up to n elements into a set. This costs O(n log(n)).\\n3. After that, you\\'re iterating over all the elements in the matrix, which is O(m*p), and for each matrix element, you\\'re performing a set find operation, which costs O(log(n)).\\n\\nMultiplying all these together, your total time complexity is O(n * m * p * log(n) * log(n)).\\n\\nNow, to optimize the code, there are a few strategies we can take:\\n\\n1. **Avoid re-computing the set in every iteration**: Instead of creating the set from scratch for every mid, you can maintain a set outside the loop and just add or remove elements as necessary when you update mid.\\n\\n2. **Utilize matrix properties for faster check**: Instead of going through all the elements in the matrix in each iteration, you can maintain a count of the number of painted cells in each row and column. Then, in each iteration, you only need to update the counts for the cells that are newly painted, and check if any row or column count equals the matrix\\'s width or height, respectively. This reduces the matrix checking cost to O(m + p) in each iteration.\\n\\nWith these optimizations, the total time complexity can be reduced to O(n * log(n) + n * (m + p)). However, it might still be considered high for large inputs. Depending on the exact constraints of your problem, further optimizations might be necessary. For instance, if the matrix is guaranteed to be a square matrix (m = p), and m, p << n, then this time complexity should be efficient enough."
                    },
                    {
                        "username": "2uringTested",
                        "content": "never mind, got it, changing from set to unordered_set improved the solution"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it was really a very good question took 2-3 hours to actually code it correctly and the feeling is really good "
                    },
                    {
                        "username": "namansingh100",
                        "content": "this code is giving TLE\\neven after passing all the test cases;  sad$face$emoji\\n\\n\\nclass Solution {\\npublic:\\n    \\n    bool check(int mid,vector<int>& arr,vector<vector<int>>& mat)\\n    {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        unordered_set<int> st;\\n        unordered_map<int,pair<int,int>> mp;\\n//         for(int i = 0; i<n; i++)\\n//         {\\n//             for(int j = 0; j<m; j++)\\n//             {\\n//                 mp[mat[i][j]] = make_pair(i,j);\\n//             }\\n//         }\\n//         for(int i = 0; i<=mid; i++)\\n            \\n//         {\\n//             auto pr = mp[arr[i]];\\n//             int x = pr.first;\\n//             int y = pr.second;\\n//             vis[x][y] = 1;\\n//         }\\n        for(int i = 0; i<=mid; i++)\\n        {\\n            st.insert(arr[i]);\\n        }\\n        //int idUpTo = mid-1;\\n        for(int i = 0; i<n; i++)\\n        {\\n            for(int j = 0; j<m; j++)\\n            {\\n                if(st.find(mat[i][j]) != st.end())\\n                {\\n                    vis[i][j] = 1;\\n                    st.erase(mat[i][j]);\\n                }\\n            }\\n        }  \\n        bool flag1;\\n        bool flag2;\\n        for(auto row : vis)\\n        {\\n            flag1 = true;\\n            for(int i = 0; i<m; i++)\\n            {\\n                if(row[i] != 1)\\n                {\\n                    flag1 = false;\\n                    break;\\n                }\\n            }\\n            if(flag1)\\n            {\\n                break;\\n            }\\n        }\\n        vector<vector<int>> vis2(m,vector<int>(n,0));\\n        for(int i = 0; i<n; i++)\\n        {\\n            for(int j = 0; j<m; j++)\\n                \\n            {\\n                vis2[j][i] = vis[i][j];\\n            }\\n        }\\n        // reverse(vis.begin(),vis.end());\\n        // for(auto )\\n        for(auto row : vis2)\\n        {\\n            flag2 = true;\\n            for(int i = 0; i<n; i++)\\n            {\\n                if(row[i] != 1)\\n                {\\n                    flag2 = false;\\n                    break;\\n                }\\n            }\\n            if(flag2)\\n            {\\n                break;\\n            }\\n        }\\n        //return flag2;\\n        if(flag1 || flag2) return 1;\\n        return 0;\\n    }\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int sz = arr.size();\\n        int hi = sz-1;\\n        int lo = 0;\\n        int ans = INT_MAX;\\n        // int mid = lo + (hi - lo)/2;\\n        // return check(mid,arr,mat);\\n        while(lo <= hi)\\n        {\\n            int mid = lo + (hi - lo)/2;\\n            //return mid;\\n            if(check(mid,arr,mat))\\n            {\\n                //return mid;\\n                ans = mid;\\n                hi = mid-1;\\n                //return ans;\\n            }\\n            else\\n            {\\n                //return mid;\\n                lo = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The function check() is called for each mid in the binary search which operates in O(log(n)) time complexity, where n is the size of arr. Inside the check() function, you\\'re iterating over the entire matrix, which is of size m*n. Also, in the worst-case scenario, you\\'re doing an erase operation on an unordered_set for each element in the matrix, which is an O(1) operation.\\n\\nHowever, the major contributing factor to the high time complexity is the nested loop over the matrix inside check() function, making the overall time complexity O(n*m*log(n)).\\n\\nNow to optimize, we could modify the code as follows:\\n\\n1. Instead of iterating over the entire matrix to fill vis[][] in check() function, maintain a map of each element\\'s position in the matrix. Then, just update vis[][] for the elements up to arr[mid].\\n\\n2. Instead of erasing each found element from the unordered_set st, you can check if all elements up to arr[mid] have been found in the matrix by comparing the size of st to the index mid. If the size of st equals (mid+1), then all elements have been found.\\n\\n3. Instead of iterating over all rows and columns to check if any of them is completely painted, maintain a count array for each row and column. In each update of vis[][], increment the corresponding row\\'s and column\\'s count. Then, you only need to check if any count equals the width or height of the matrix, respectively.\\n\\nThese modifications should significantly improve the time complexity of your code. Please note that the overall complexity still remains O(n*log(n)), which might be still high for large inputs depending on the exact constraints of your problem. Further optimizations might be necessary based on those constraints."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "sad facefaceface emoji"
                    },
                    {
                        "username": "SilentStorm2k",
                        "content": "Is this a wrong test case? How could expected answer be smaller than number of rows or columns? Unable to submit because of this. Anyone else having this issue?\\narr =\\n[1,4,5,2,6,3]\\nmat =\\n[[4,3,5],[1,2,6]]\\n\\nOutput\\n2\\nExpected\\n1"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The indexing is `0-based` . So 1 here means `arr[1]` i.e. 4. Thats paints the first column completely. Hope that helps."
                    },
                    {
                        "username": "bparanj",
                        "content": "The expected output seems correct. Here\\'s why:\\n\\nYou go through each index `i` in `arr` starting from index `0` and paint the cell in `mat` containing the integer `arr[i]`. The output is the smallest index `i` at which either a row or a column will be completely painted in `mat`.\\n\\nIn this case:\\n\\nAt index `0` in `arr`, you paint `1` which is at position `[1,0]` in `mat`.\\nAt index `1` in `arr`, you paint `4` which is at position `[0,0]` in `mat`.\\n\\nAfter these steps, the first column of `mat` (index `0`) is completely painted. Hence, the smallest index at which a row or column is completely painted is `1` (the index of `4` in `arr`), which is the expected output. \\n\\nRemember, the task is to find the smallest index `i` in `arr`, not the number of painted cells or the size of a row/column in `mat`.\\n\\nSo, the test case is correct and the expected output of `1` is valid."
                    },
                    {
                        "username": "avissant",
                        "content": "The expected answer is the index of the array `arr` 0-indexed. So in the test case you have that means the index of the number 4, so 1."
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "the first item in array is the start point , you need to print how many more passes you need until its row/col is fully painted"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we have to return the index in arr so that any row or column is completely painted\ni guess you are missing on\n rowcount should be equal to number of columns \nor columncount should be equal to number of rows"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Wants to know the intuition and approach on how to solve this problem?\\nCheck out my solution post which is very well explained including about constraints as well as time and space complexities.\\uD83D\\uDC47\\uD83C\\uDFFB\\uD83D\\uDD25\\n\\n[leetcode](https://leetcode.com)https://leetcode.com/problems/first-completely-painted-row-or-column/solutions/3468364/hashmap-well-explained-java-clean-code/"
                    }
                ]
            },
            {
                "id": 1917849,
                "content": [
                    {
                        "username": "namandt",
                        "content": "Nice Question!."
                    },
                    {
                        "username": "cionx",
                        "content": "For those searching for test cases:\\n```text\\n[8,2,4,9,3,5,7,10,1,6]\\n[[8,2,9,10,4],[1,7,6,3,5]]\\n```\\nfound an error in my submission that the previous cases missed."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "That\\'s Mahh Boii, By the way... I got TLE"
                    },
                    {
                        "username": "2uringTested",
                        "content": "This binary search code passes all the test cases, 1058 of them, yet still gets a TLE :( how to fix the issue?\\n `\\nclass Solution {\\npublic:\\n    using vvi = vector<vector<int>>;\\n    \\n    bool color(vvi mat,set<int>& nums){\\n        for(int i=0;i<mat.size();i++){\\n            bool isColor = true;\\n            for(int j=0;j<mat[0].size();j++){\\n                if(nums.find(mat[i][j])!=nums.end()){\\n                    mat[i][j]=-1;\\n                }else{\\n                    isColor = false;\\n                }\\n            }\\n            if(isColor == true) return true;\\n        }\\n        for(int j=0;j<mat[0].size();j++){\\n            bool isColor = true;\\n            for(int i=0;i<mat.size();i++){\\n                if(mat[i][j]!=-1){\\n                    isColor = false;\\n                    break;\\n                }\\n            }\\n            if(isColor) return true;\\n        }\\n        return false;\\n\\n    }\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        \\n        int left = 0;\\n        int right = arr.size()-1;\\n        int mid = left+(right-left)/2;\\n        int ans = INT_MAX;\\n\\n        while(left<=right){\\n\\n            set<int> nums;\\n            for(int j=0;j<=mid;j++){\\n                nums.insert(arr[j]);\\n            }\\n            if(color(mat,nums)){\\n                ans = min(ans,mid);\\n                right = mid-1;\\n            }else{\\n                left = mid+1;\\n            }\\n\\n            mid = left+(right-left)/2;\\n            \\n        }\\n        return ans;\\n    }};`"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of your code is quite high due to multiple reasons. Let\\'s consider n = arr.size(), m = mat.size(), and p = mat[0].size():\\n\\n1. The main binary search loop runs log(n) times.\\n2. In each iteration of the binary search, you\\'re inserting up to n elements into a set. This costs O(n log(n)).\\n3. After that, you\\'re iterating over all the elements in the matrix, which is O(m*p), and for each matrix element, you\\'re performing a set find operation, which costs O(log(n)).\\n\\nMultiplying all these together, your total time complexity is O(n * m * p * log(n) * log(n)).\\n\\nNow, to optimize the code, there are a few strategies we can take:\\n\\n1. **Avoid re-computing the set in every iteration**: Instead of creating the set from scratch for every mid, you can maintain a set outside the loop and just add or remove elements as necessary when you update mid.\\n\\n2. **Utilize matrix properties for faster check**: Instead of going through all the elements in the matrix in each iteration, you can maintain a count of the number of painted cells in each row and column. Then, in each iteration, you only need to update the counts for the cells that are newly painted, and check if any row or column count equals the matrix\\'s width or height, respectively. This reduces the matrix checking cost to O(m + p) in each iteration.\\n\\nWith these optimizations, the total time complexity can be reduced to O(n * log(n) + n * (m + p)). However, it might still be considered high for large inputs. Depending on the exact constraints of your problem, further optimizations might be necessary. For instance, if the matrix is guaranteed to be a square matrix (m = p), and m, p << n, then this time complexity should be efficient enough."
                    },
                    {
                        "username": "2uringTested",
                        "content": "never mind, got it, changing from set to unordered_set improved the solution"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it was really a very good question took 2-3 hours to actually code it correctly and the feeling is really good "
                    },
                    {
                        "username": "namansingh100",
                        "content": "this code is giving TLE\\neven after passing all the test cases;  sad$face$emoji\\n\\n\\nclass Solution {\\npublic:\\n    \\n    bool check(int mid,vector<int>& arr,vector<vector<int>>& mat)\\n    {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        unordered_set<int> st;\\n        unordered_map<int,pair<int,int>> mp;\\n//         for(int i = 0; i<n; i++)\\n//         {\\n//             for(int j = 0; j<m; j++)\\n//             {\\n//                 mp[mat[i][j]] = make_pair(i,j);\\n//             }\\n//         }\\n//         for(int i = 0; i<=mid; i++)\\n            \\n//         {\\n//             auto pr = mp[arr[i]];\\n//             int x = pr.first;\\n//             int y = pr.second;\\n//             vis[x][y] = 1;\\n//         }\\n        for(int i = 0; i<=mid; i++)\\n        {\\n            st.insert(arr[i]);\\n        }\\n        //int idUpTo = mid-1;\\n        for(int i = 0; i<n; i++)\\n        {\\n            for(int j = 0; j<m; j++)\\n            {\\n                if(st.find(mat[i][j]) != st.end())\\n                {\\n                    vis[i][j] = 1;\\n                    st.erase(mat[i][j]);\\n                }\\n            }\\n        }  \\n        bool flag1;\\n        bool flag2;\\n        for(auto row : vis)\\n        {\\n            flag1 = true;\\n            for(int i = 0; i<m; i++)\\n            {\\n                if(row[i] != 1)\\n                {\\n                    flag1 = false;\\n                    break;\\n                }\\n            }\\n            if(flag1)\\n            {\\n                break;\\n            }\\n        }\\n        vector<vector<int>> vis2(m,vector<int>(n,0));\\n        for(int i = 0; i<n; i++)\\n        {\\n            for(int j = 0; j<m; j++)\\n                \\n            {\\n                vis2[j][i] = vis[i][j];\\n            }\\n        }\\n        // reverse(vis.begin(),vis.end());\\n        // for(auto )\\n        for(auto row : vis2)\\n        {\\n            flag2 = true;\\n            for(int i = 0; i<n; i++)\\n            {\\n                if(row[i] != 1)\\n                {\\n                    flag2 = false;\\n                    break;\\n                }\\n            }\\n            if(flag2)\\n            {\\n                break;\\n            }\\n        }\\n        //return flag2;\\n        if(flag1 || flag2) return 1;\\n        return 0;\\n    }\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int sz = arr.size();\\n        int hi = sz-1;\\n        int lo = 0;\\n        int ans = INT_MAX;\\n        // int mid = lo + (hi - lo)/2;\\n        // return check(mid,arr,mat);\\n        while(lo <= hi)\\n        {\\n            int mid = lo + (hi - lo)/2;\\n            //return mid;\\n            if(check(mid,arr,mat))\\n            {\\n                //return mid;\\n                ans = mid;\\n                hi = mid-1;\\n                //return ans;\\n            }\\n            else\\n            {\\n                //return mid;\\n                lo = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The function check() is called for each mid in the binary search which operates in O(log(n)) time complexity, where n is the size of arr. Inside the check() function, you\\'re iterating over the entire matrix, which is of size m*n. Also, in the worst-case scenario, you\\'re doing an erase operation on an unordered_set for each element in the matrix, which is an O(1) operation.\\n\\nHowever, the major contributing factor to the high time complexity is the nested loop over the matrix inside check() function, making the overall time complexity O(n*m*log(n)).\\n\\nNow to optimize, we could modify the code as follows:\\n\\n1. Instead of iterating over the entire matrix to fill vis[][] in check() function, maintain a map of each element\\'s position in the matrix. Then, just update vis[][] for the elements up to arr[mid].\\n\\n2. Instead of erasing each found element from the unordered_set st, you can check if all elements up to arr[mid] have been found in the matrix by comparing the size of st to the index mid. If the size of st equals (mid+1), then all elements have been found.\\n\\n3. Instead of iterating over all rows and columns to check if any of them is completely painted, maintain a count array for each row and column. In each update of vis[][], increment the corresponding row\\'s and column\\'s count. Then, you only need to check if any count equals the width or height of the matrix, respectively.\\n\\nThese modifications should significantly improve the time complexity of your code. Please note that the overall complexity still remains O(n*log(n)), which might be still high for large inputs depending on the exact constraints of your problem. Further optimizations might be necessary based on those constraints."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "sad facefaceface emoji"
                    },
                    {
                        "username": "SilentStorm2k",
                        "content": "Is this a wrong test case? How could expected answer be smaller than number of rows or columns? Unable to submit because of this. Anyone else having this issue?\\narr =\\n[1,4,5,2,6,3]\\nmat =\\n[[4,3,5],[1,2,6]]\\n\\nOutput\\n2\\nExpected\\n1"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The indexing is `0-based` . So 1 here means `arr[1]` i.e. 4. Thats paints the first column completely. Hope that helps."
                    },
                    {
                        "username": "bparanj",
                        "content": "The expected output seems correct. Here\\'s why:\\n\\nYou go through each index `i` in `arr` starting from index `0` and paint the cell in `mat` containing the integer `arr[i]`. The output is the smallest index `i` at which either a row or a column will be completely painted in `mat`.\\n\\nIn this case:\\n\\nAt index `0` in `arr`, you paint `1` which is at position `[1,0]` in `mat`.\\nAt index `1` in `arr`, you paint `4` which is at position `[0,0]` in `mat`.\\n\\nAfter these steps, the first column of `mat` (index `0`) is completely painted. Hence, the smallest index at which a row or column is completely painted is `1` (the index of `4` in `arr`), which is the expected output. \\n\\nRemember, the task is to find the smallest index `i` in `arr`, not the number of painted cells or the size of a row/column in `mat`.\\n\\nSo, the test case is correct and the expected output of `1` is valid."
                    },
                    {
                        "username": "avissant",
                        "content": "The expected answer is the index of the array `arr` 0-indexed. So in the test case you have that means the index of the number 4, so 1."
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "the first item in array is the start point , you need to print how many more passes you need until its row/col is fully painted"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we have to return the index in arr so that any row or column is completely painted\ni guess you are missing on\n rowcount should be equal to number of columns \nor columncount should be equal to number of rows"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Wants to know the intuition and approach on how to solve this problem?\\nCheck out my solution post which is very well explained including about constraints as well as time and space complexities.\\uD83D\\uDC47\\uD83C\\uDFFB\\uD83D\\uDD25\\n\\n[leetcode](https://leetcode.com)https://leetcode.com/problems/first-completely-painted-row-or-column/solutions/3468364/hashmap-well-explained-java-clean-code/"
                    }
                ]
            },
            {
                "id": 1890968,
                "content": [
                    {
                        "username": "namandt",
                        "content": "Nice Question!."
                    },
                    {
                        "username": "cionx",
                        "content": "For those searching for test cases:\\n```text\\n[8,2,4,9,3,5,7,10,1,6]\\n[[8,2,9,10,4],[1,7,6,3,5]]\\n```\\nfound an error in my submission that the previous cases missed."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "That\\'s Mahh Boii, By the way... I got TLE"
                    },
                    {
                        "username": "2uringTested",
                        "content": "This binary search code passes all the test cases, 1058 of them, yet still gets a TLE :( how to fix the issue?\\n `\\nclass Solution {\\npublic:\\n    using vvi = vector<vector<int>>;\\n    \\n    bool color(vvi mat,set<int>& nums){\\n        for(int i=0;i<mat.size();i++){\\n            bool isColor = true;\\n            for(int j=0;j<mat[0].size();j++){\\n                if(nums.find(mat[i][j])!=nums.end()){\\n                    mat[i][j]=-1;\\n                }else{\\n                    isColor = false;\\n                }\\n            }\\n            if(isColor == true) return true;\\n        }\\n        for(int j=0;j<mat[0].size();j++){\\n            bool isColor = true;\\n            for(int i=0;i<mat.size();i++){\\n                if(mat[i][j]!=-1){\\n                    isColor = false;\\n                    break;\\n                }\\n            }\\n            if(isColor) return true;\\n        }\\n        return false;\\n\\n    }\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        \\n        int left = 0;\\n        int right = arr.size()-1;\\n        int mid = left+(right-left)/2;\\n        int ans = INT_MAX;\\n\\n        while(left<=right){\\n\\n            set<int> nums;\\n            for(int j=0;j<=mid;j++){\\n                nums.insert(arr[j]);\\n            }\\n            if(color(mat,nums)){\\n                ans = min(ans,mid);\\n                right = mid-1;\\n            }else{\\n                left = mid+1;\\n            }\\n\\n            mid = left+(right-left)/2;\\n            \\n        }\\n        return ans;\\n    }};`"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of your code is quite high due to multiple reasons. Let\\'s consider n = arr.size(), m = mat.size(), and p = mat[0].size():\\n\\n1. The main binary search loop runs log(n) times.\\n2. In each iteration of the binary search, you\\'re inserting up to n elements into a set. This costs O(n log(n)).\\n3. After that, you\\'re iterating over all the elements in the matrix, which is O(m*p), and for each matrix element, you\\'re performing a set find operation, which costs O(log(n)).\\n\\nMultiplying all these together, your total time complexity is O(n * m * p * log(n) * log(n)).\\n\\nNow, to optimize the code, there are a few strategies we can take:\\n\\n1. **Avoid re-computing the set in every iteration**: Instead of creating the set from scratch for every mid, you can maintain a set outside the loop and just add or remove elements as necessary when you update mid.\\n\\n2. **Utilize matrix properties for faster check**: Instead of going through all the elements in the matrix in each iteration, you can maintain a count of the number of painted cells in each row and column. Then, in each iteration, you only need to update the counts for the cells that are newly painted, and check if any row or column count equals the matrix\\'s width or height, respectively. This reduces the matrix checking cost to O(m + p) in each iteration.\\n\\nWith these optimizations, the total time complexity can be reduced to O(n * log(n) + n * (m + p)). However, it might still be considered high for large inputs. Depending on the exact constraints of your problem, further optimizations might be necessary. For instance, if the matrix is guaranteed to be a square matrix (m = p), and m, p << n, then this time complexity should be efficient enough."
                    },
                    {
                        "username": "2uringTested",
                        "content": "never mind, got it, changing from set to unordered_set improved the solution"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it was really a very good question took 2-3 hours to actually code it correctly and the feeling is really good "
                    },
                    {
                        "username": "namansingh100",
                        "content": "this code is giving TLE\\neven after passing all the test cases;  sad$face$emoji\\n\\n\\nclass Solution {\\npublic:\\n    \\n    bool check(int mid,vector<int>& arr,vector<vector<int>>& mat)\\n    {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        unordered_set<int> st;\\n        unordered_map<int,pair<int,int>> mp;\\n//         for(int i = 0; i<n; i++)\\n//         {\\n//             for(int j = 0; j<m; j++)\\n//             {\\n//                 mp[mat[i][j]] = make_pair(i,j);\\n//             }\\n//         }\\n//         for(int i = 0; i<=mid; i++)\\n            \\n//         {\\n//             auto pr = mp[arr[i]];\\n//             int x = pr.first;\\n//             int y = pr.second;\\n//             vis[x][y] = 1;\\n//         }\\n        for(int i = 0; i<=mid; i++)\\n        {\\n            st.insert(arr[i]);\\n        }\\n        //int idUpTo = mid-1;\\n        for(int i = 0; i<n; i++)\\n        {\\n            for(int j = 0; j<m; j++)\\n            {\\n                if(st.find(mat[i][j]) != st.end())\\n                {\\n                    vis[i][j] = 1;\\n                    st.erase(mat[i][j]);\\n                }\\n            }\\n        }  \\n        bool flag1;\\n        bool flag2;\\n        for(auto row : vis)\\n        {\\n            flag1 = true;\\n            for(int i = 0; i<m; i++)\\n            {\\n                if(row[i] != 1)\\n                {\\n                    flag1 = false;\\n                    break;\\n                }\\n            }\\n            if(flag1)\\n            {\\n                break;\\n            }\\n        }\\n        vector<vector<int>> vis2(m,vector<int>(n,0));\\n        for(int i = 0; i<n; i++)\\n        {\\n            for(int j = 0; j<m; j++)\\n                \\n            {\\n                vis2[j][i] = vis[i][j];\\n            }\\n        }\\n        // reverse(vis.begin(),vis.end());\\n        // for(auto )\\n        for(auto row : vis2)\\n        {\\n            flag2 = true;\\n            for(int i = 0; i<n; i++)\\n            {\\n                if(row[i] != 1)\\n                {\\n                    flag2 = false;\\n                    break;\\n                }\\n            }\\n            if(flag2)\\n            {\\n                break;\\n            }\\n        }\\n        //return flag2;\\n        if(flag1 || flag2) return 1;\\n        return 0;\\n    }\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int sz = arr.size();\\n        int hi = sz-1;\\n        int lo = 0;\\n        int ans = INT_MAX;\\n        // int mid = lo + (hi - lo)/2;\\n        // return check(mid,arr,mat);\\n        while(lo <= hi)\\n        {\\n            int mid = lo + (hi - lo)/2;\\n            //return mid;\\n            if(check(mid,arr,mat))\\n            {\\n                //return mid;\\n                ans = mid;\\n                hi = mid-1;\\n                //return ans;\\n            }\\n            else\\n            {\\n                //return mid;\\n                lo = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The function check() is called for each mid in the binary search which operates in O(log(n)) time complexity, where n is the size of arr. Inside the check() function, you\\'re iterating over the entire matrix, which is of size m*n. Also, in the worst-case scenario, you\\'re doing an erase operation on an unordered_set for each element in the matrix, which is an O(1) operation.\\n\\nHowever, the major contributing factor to the high time complexity is the nested loop over the matrix inside check() function, making the overall time complexity O(n*m*log(n)).\\n\\nNow to optimize, we could modify the code as follows:\\n\\n1. Instead of iterating over the entire matrix to fill vis[][] in check() function, maintain a map of each element\\'s position in the matrix. Then, just update vis[][] for the elements up to arr[mid].\\n\\n2. Instead of erasing each found element from the unordered_set st, you can check if all elements up to arr[mid] have been found in the matrix by comparing the size of st to the index mid. If the size of st equals (mid+1), then all elements have been found.\\n\\n3. Instead of iterating over all rows and columns to check if any of them is completely painted, maintain a count array for each row and column. In each update of vis[][], increment the corresponding row\\'s and column\\'s count. Then, you only need to check if any count equals the width or height of the matrix, respectively.\\n\\nThese modifications should significantly improve the time complexity of your code. Please note that the overall complexity still remains O(n*log(n)), which might be still high for large inputs depending on the exact constraints of your problem. Further optimizations might be necessary based on those constraints."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "sad facefaceface emoji"
                    },
                    {
                        "username": "SilentStorm2k",
                        "content": "Is this a wrong test case? How could expected answer be smaller than number of rows or columns? Unable to submit because of this. Anyone else having this issue?\\narr =\\n[1,4,5,2,6,3]\\nmat =\\n[[4,3,5],[1,2,6]]\\n\\nOutput\\n2\\nExpected\\n1"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The indexing is `0-based` . So 1 here means `arr[1]` i.e. 4. Thats paints the first column completely. Hope that helps."
                    },
                    {
                        "username": "bparanj",
                        "content": "The expected output seems correct. Here\\'s why:\\n\\nYou go through each index `i` in `arr` starting from index `0` and paint the cell in `mat` containing the integer `arr[i]`. The output is the smallest index `i` at which either a row or a column will be completely painted in `mat`.\\n\\nIn this case:\\n\\nAt index `0` in `arr`, you paint `1` which is at position `[1,0]` in `mat`.\\nAt index `1` in `arr`, you paint `4` which is at position `[0,0]` in `mat`.\\n\\nAfter these steps, the first column of `mat` (index `0`) is completely painted. Hence, the smallest index at which a row or column is completely painted is `1` (the index of `4` in `arr`), which is the expected output. \\n\\nRemember, the task is to find the smallest index `i` in `arr`, not the number of painted cells or the size of a row/column in `mat`.\\n\\nSo, the test case is correct and the expected output of `1` is valid."
                    },
                    {
                        "username": "avissant",
                        "content": "The expected answer is the index of the array `arr` 0-indexed. So in the test case you have that means the index of the number 4, so 1."
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "the first item in array is the start point , you need to print how many more passes you need until its row/col is fully painted"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we have to return the index in arr so that any row or column is completely painted\ni guess you are missing on\n rowcount should be equal to number of columns \nor columncount should be equal to number of rows"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Wants to know the intuition and approach on how to solve this problem?\\nCheck out my solution post which is very well explained including about constraints as well as time and space complexities.\\uD83D\\uDC47\\uD83C\\uDFFB\\uD83D\\uDD25\\n\\n[leetcode](https://leetcode.com)https://leetcode.com/problems/first-completely-painted-row-or-column/solutions/3468364/hashmap-well-explained-java-clean-code/"
                    }
                ]
            },
            {
                "id": 1889295,
                "content": [
                    {
                        "username": "namandt",
                        "content": "Nice Question!."
                    },
                    {
                        "username": "cionx",
                        "content": "For those searching for test cases:\\n```text\\n[8,2,4,9,3,5,7,10,1,6]\\n[[8,2,9,10,4],[1,7,6,3,5]]\\n```\\nfound an error in my submission that the previous cases missed."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "That\\'s Mahh Boii, By the way... I got TLE"
                    },
                    {
                        "username": "2uringTested",
                        "content": "This binary search code passes all the test cases, 1058 of them, yet still gets a TLE :( how to fix the issue?\\n `\\nclass Solution {\\npublic:\\n    using vvi = vector<vector<int>>;\\n    \\n    bool color(vvi mat,set<int>& nums){\\n        for(int i=0;i<mat.size();i++){\\n            bool isColor = true;\\n            for(int j=0;j<mat[0].size();j++){\\n                if(nums.find(mat[i][j])!=nums.end()){\\n                    mat[i][j]=-1;\\n                }else{\\n                    isColor = false;\\n                }\\n            }\\n            if(isColor == true) return true;\\n        }\\n        for(int j=0;j<mat[0].size();j++){\\n            bool isColor = true;\\n            for(int i=0;i<mat.size();i++){\\n                if(mat[i][j]!=-1){\\n                    isColor = false;\\n                    break;\\n                }\\n            }\\n            if(isColor) return true;\\n        }\\n        return false;\\n\\n    }\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        \\n        int left = 0;\\n        int right = arr.size()-1;\\n        int mid = left+(right-left)/2;\\n        int ans = INT_MAX;\\n\\n        while(left<=right){\\n\\n            set<int> nums;\\n            for(int j=0;j<=mid;j++){\\n                nums.insert(arr[j]);\\n            }\\n            if(color(mat,nums)){\\n                ans = min(ans,mid);\\n                right = mid-1;\\n            }else{\\n                left = mid+1;\\n            }\\n\\n            mid = left+(right-left)/2;\\n            \\n        }\\n        return ans;\\n    }};`"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of your code is quite high due to multiple reasons. Let\\'s consider n = arr.size(), m = mat.size(), and p = mat[0].size():\\n\\n1. The main binary search loop runs log(n) times.\\n2. In each iteration of the binary search, you\\'re inserting up to n elements into a set. This costs O(n log(n)).\\n3. After that, you\\'re iterating over all the elements in the matrix, which is O(m*p), and for each matrix element, you\\'re performing a set find operation, which costs O(log(n)).\\n\\nMultiplying all these together, your total time complexity is O(n * m * p * log(n) * log(n)).\\n\\nNow, to optimize the code, there are a few strategies we can take:\\n\\n1. **Avoid re-computing the set in every iteration**: Instead of creating the set from scratch for every mid, you can maintain a set outside the loop and just add or remove elements as necessary when you update mid.\\n\\n2. **Utilize matrix properties for faster check**: Instead of going through all the elements in the matrix in each iteration, you can maintain a count of the number of painted cells in each row and column. Then, in each iteration, you only need to update the counts for the cells that are newly painted, and check if any row or column count equals the matrix\\'s width or height, respectively. This reduces the matrix checking cost to O(m + p) in each iteration.\\n\\nWith these optimizations, the total time complexity can be reduced to O(n * log(n) + n * (m + p)). However, it might still be considered high for large inputs. Depending on the exact constraints of your problem, further optimizations might be necessary. For instance, if the matrix is guaranteed to be a square matrix (m = p), and m, p << n, then this time complexity should be efficient enough."
                    },
                    {
                        "username": "2uringTested",
                        "content": "never mind, got it, changing from set to unordered_set improved the solution"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it was really a very good question took 2-3 hours to actually code it correctly and the feeling is really good "
                    },
                    {
                        "username": "namansingh100",
                        "content": "this code is giving TLE\\neven after passing all the test cases;  sad$face$emoji\\n\\n\\nclass Solution {\\npublic:\\n    \\n    bool check(int mid,vector<int>& arr,vector<vector<int>>& mat)\\n    {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        unordered_set<int> st;\\n        unordered_map<int,pair<int,int>> mp;\\n//         for(int i = 0; i<n; i++)\\n//         {\\n//             for(int j = 0; j<m; j++)\\n//             {\\n//                 mp[mat[i][j]] = make_pair(i,j);\\n//             }\\n//         }\\n//         for(int i = 0; i<=mid; i++)\\n            \\n//         {\\n//             auto pr = mp[arr[i]];\\n//             int x = pr.first;\\n//             int y = pr.second;\\n//             vis[x][y] = 1;\\n//         }\\n        for(int i = 0; i<=mid; i++)\\n        {\\n            st.insert(arr[i]);\\n        }\\n        //int idUpTo = mid-1;\\n        for(int i = 0; i<n; i++)\\n        {\\n            for(int j = 0; j<m; j++)\\n            {\\n                if(st.find(mat[i][j]) != st.end())\\n                {\\n                    vis[i][j] = 1;\\n                    st.erase(mat[i][j]);\\n                }\\n            }\\n        }  \\n        bool flag1;\\n        bool flag2;\\n        for(auto row : vis)\\n        {\\n            flag1 = true;\\n            for(int i = 0; i<m; i++)\\n            {\\n                if(row[i] != 1)\\n                {\\n                    flag1 = false;\\n                    break;\\n                }\\n            }\\n            if(flag1)\\n            {\\n                break;\\n            }\\n        }\\n        vector<vector<int>> vis2(m,vector<int>(n,0));\\n        for(int i = 0; i<n; i++)\\n        {\\n            for(int j = 0; j<m; j++)\\n                \\n            {\\n                vis2[j][i] = vis[i][j];\\n            }\\n        }\\n        // reverse(vis.begin(),vis.end());\\n        // for(auto )\\n        for(auto row : vis2)\\n        {\\n            flag2 = true;\\n            for(int i = 0; i<n; i++)\\n            {\\n                if(row[i] != 1)\\n                {\\n                    flag2 = false;\\n                    break;\\n                }\\n            }\\n            if(flag2)\\n            {\\n                break;\\n            }\\n        }\\n        //return flag2;\\n        if(flag1 || flag2) return 1;\\n        return 0;\\n    }\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int sz = arr.size();\\n        int hi = sz-1;\\n        int lo = 0;\\n        int ans = INT_MAX;\\n        // int mid = lo + (hi - lo)/2;\\n        // return check(mid,arr,mat);\\n        while(lo <= hi)\\n        {\\n            int mid = lo + (hi - lo)/2;\\n            //return mid;\\n            if(check(mid,arr,mat))\\n            {\\n                //return mid;\\n                ans = mid;\\n                hi = mid-1;\\n                //return ans;\\n            }\\n            else\\n            {\\n                //return mid;\\n                lo = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The function check() is called for each mid in the binary search which operates in O(log(n)) time complexity, where n is the size of arr. Inside the check() function, you\\'re iterating over the entire matrix, which is of size m*n. Also, in the worst-case scenario, you\\'re doing an erase operation on an unordered_set for each element in the matrix, which is an O(1) operation.\\n\\nHowever, the major contributing factor to the high time complexity is the nested loop over the matrix inside check() function, making the overall time complexity O(n*m*log(n)).\\n\\nNow to optimize, we could modify the code as follows:\\n\\n1. Instead of iterating over the entire matrix to fill vis[][] in check() function, maintain a map of each element\\'s position in the matrix. Then, just update vis[][] for the elements up to arr[mid].\\n\\n2. Instead of erasing each found element from the unordered_set st, you can check if all elements up to arr[mid] have been found in the matrix by comparing the size of st to the index mid. If the size of st equals (mid+1), then all elements have been found.\\n\\n3. Instead of iterating over all rows and columns to check if any of them is completely painted, maintain a count array for each row and column. In each update of vis[][], increment the corresponding row\\'s and column\\'s count. Then, you only need to check if any count equals the width or height of the matrix, respectively.\\n\\nThese modifications should significantly improve the time complexity of your code. Please note that the overall complexity still remains O(n*log(n)), which might be still high for large inputs depending on the exact constraints of your problem. Further optimizations might be necessary based on those constraints."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "sad facefaceface emoji"
                    },
                    {
                        "username": "SilentStorm2k",
                        "content": "Is this a wrong test case? How could expected answer be smaller than number of rows or columns? Unable to submit because of this. Anyone else having this issue?\\narr =\\n[1,4,5,2,6,3]\\nmat =\\n[[4,3,5],[1,2,6]]\\n\\nOutput\\n2\\nExpected\\n1"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The indexing is `0-based` . So 1 here means `arr[1]` i.e. 4. Thats paints the first column completely. Hope that helps."
                    },
                    {
                        "username": "bparanj",
                        "content": "The expected output seems correct. Here\\'s why:\\n\\nYou go through each index `i` in `arr` starting from index `0` and paint the cell in `mat` containing the integer `arr[i]`. The output is the smallest index `i` at which either a row or a column will be completely painted in `mat`.\\n\\nIn this case:\\n\\nAt index `0` in `arr`, you paint `1` which is at position `[1,0]` in `mat`.\\nAt index `1` in `arr`, you paint `4` which is at position `[0,0]` in `mat`.\\n\\nAfter these steps, the first column of `mat` (index `0`) is completely painted. Hence, the smallest index at which a row or column is completely painted is `1` (the index of `4` in `arr`), which is the expected output. \\n\\nRemember, the task is to find the smallest index `i` in `arr`, not the number of painted cells or the size of a row/column in `mat`.\\n\\nSo, the test case is correct and the expected output of `1` is valid."
                    },
                    {
                        "username": "avissant",
                        "content": "The expected answer is the index of the array `arr` 0-indexed. So in the test case you have that means the index of the number 4, so 1."
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "the first item in array is the start point , you need to print how many more passes you need until its row/col is fully painted"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we have to return the index in arr so that any row or column is completely painted\ni guess you are missing on\n rowcount should be equal to number of columns \nor columncount should be equal to number of rows"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Wants to know the intuition and approach on how to solve this problem?\\nCheck out my solution post which is very well explained including about constraints as well as time and space complexities.\\uD83D\\uDC47\\uD83C\\uDFFB\\uD83D\\uDD25\\n\\n[leetcode](https://leetcode.com)https://leetcode.com/problems/first-completely-painted-row-or-column/solutions/3468364/hashmap-well-explained-java-clean-code/"
                    }
                ]
            },
            {
                "id": 1879192,
                "content": [
                    {
                        "username": "namandt",
                        "content": "Nice Question!."
                    },
                    {
                        "username": "cionx",
                        "content": "For those searching for test cases:\\n```text\\n[8,2,4,9,3,5,7,10,1,6]\\n[[8,2,9,10,4],[1,7,6,3,5]]\\n```\\nfound an error in my submission that the previous cases missed."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "That\\'s Mahh Boii, By the way... I got TLE"
                    },
                    {
                        "username": "2uringTested",
                        "content": "This binary search code passes all the test cases, 1058 of them, yet still gets a TLE :( how to fix the issue?\\n `\\nclass Solution {\\npublic:\\n    using vvi = vector<vector<int>>;\\n    \\n    bool color(vvi mat,set<int>& nums){\\n        for(int i=0;i<mat.size();i++){\\n            bool isColor = true;\\n            for(int j=0;j<mat[0].size();j++){\\n                if(nums.find(mat[i][j])!=nums.end()){\\n                    mat[i][j]=-1;\\n                }else{\\n                    isColor = false;\\n                }\\n            }\\n            if(isColor == true) return true;\\n        }\\n        for(int j=0;j<mat[0].size();j++){\\n            bool isColor = true;\\n            for(int i=0;i<mat.size();i++){\\n                if(mat[i][j]!=-1){\\n                    isColor = false;\\n                    break;\\n                }\\n            }\\n            if(isColor) return true;\\n        }\\n        return false;\\n\\n    }\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        \\n        int left = 0;\\n        int right = arr.size()-1;\\n        int mid = left+(right-left)/2;\\n        int ans = INT_MAX;\\n\\n        while(left<=right){\\n\\n            set<int> nums;\\n            for(int j=0;j<=mid;j++){\\n                nums.insert(arr[j]);\\n            }\\n            if(color(mat,nums)){\\n                ans = min(ans,mid);\\n                right = mid-1;\\n            }else{\\n                left = mid+1;\\n            }\\n\\n            mid = left+(right-left)/2;\\n            \\n        }\\n        return ans;\\n    }};`"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of your code is quite high due to multiple reasons. Let\\'s consider n = arr.size(), m = mat.size(), and p = mat[0].size():\\n\\n1. The main binary search loop runs log(n) times.\\n2. In each iteration of the binary search, you\\'re inserting up to n elements into a set. This costs O(n log(n)).\\n3. After that, you\\'re iterating over all the elements in the matrix, which is O(m*p), and for each matrix element, you\\'re performing a set find operation, which costs O(log(n)).\\n\\nMultiplying all these together, your total time complexity is O(n * m * p * log(n) * log(n)).\\n\\nNow, to optimize the code, there are a few strategies we can take:\\n\\n1. **Avoid re-computing the set in every iteration**: Instead of creating the set from scratch for every mid, you can maintain a set outside the loop and just add or remove elements as necessary when you update mid.\\n\\n2. **Utilize matrix properties for faster check**: Instead of going through all the elements in the matrix in each iteration, you can maintain a count of the number of painted cells in each row and column. Then, in each iteration, you only need to update the counts for the cells that are newly painted, and check if any row or column count equals the matrix\\'s width or height, respectively. This reduces the matrix checking cost to O(m + p) in each iteration.\\n\\nWith these optimizations, the total time complexity can be reduced to O(n * log(n) + n * (m + p)). However, it might still be considered high for large inputs. Depending on the exact constraints of your problem, further optimizations might be necessary. For instance, if the matrix is guaranteed to be a square matrix (m = p), and m, p << n, then this time complexity should be efficient enough."
                    },
                    {
                        "username": "2uringTested",
                        "content": "never mind, got it, changing from set to unordered_set improved the solution"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it was really a very good question took 2-3 hours to actually code it correctly and the feeling is really good "
                    },
                    {
                        "username": "namansingh100",
                        "content": "this code is giving TLE\\neven after passing all the test cases;  sad$face$emoji\\n\\n\\nclass Solution {\\npublic:\\n    \\n    bool check(int mid,vector<int>& arr,vector<vector<int>>& mat)\\n    {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        unordered_set<int> st;\\n        unordered_map<int,pair<int,int>> mp;\\n//         for(int i = 0; i<n; i++)\\n//         {\\n//             for(int j = 0; j<m; j++)\\n//             {\\n//                 mp[mat[i][j]] = make_pair(i,j);\\n//             }\\n//         }\\n//         for(int i = 0; i<=mid; i++)\\n            \\n//         {\\n//             auto pr = mp[arr[i]];\\n//             int x = pr.first;\\n//             int y = pr.second;\\n//             vis[x][y] = 1;\\n//         }\\n        for(int i = 0; i<=mid; i++)\\n        {\\n            st.insert(arr[i]);\\n        }\\n        //int idUpTo = mid-1;\\n        for(int i = 0; i<n; i++)\\n        {\\n            for(int j = 0; j<m; j++)\\n            {\\n                if(st.find(mat[i][j]) != st.end())\\n                {\\n                    vis[i][j] = 1;\\n                    st.erase(mat[i][j]);\\n                }\\n            }\\n        }  \\n        bool flag1;\\n        bool flag2;\\n        for(auto row : vis)\\n        {\\n            flag1 = true;\\n            for(int i = 0; i<m; i++)\\n            {\\n                if(row[i] != 1)\\n                {\\n                    flag1 = false;\\n                    break;\\n                }\\n            }\\n            if(flag1)\\n            {\\n                break;\\n            }\\n        }\\n        vector<vector<int>> vis2(m,vector<int>(n,0));\\n        for(int i = 0; i<n; i++)\\n        {\\n            for(int j = 0; j<m; j++)\\n                \\n            {\\n                vis2[j][i] = vis[i][j];\\n            }\\n        }\\n        // reverse(vis.begin(),vis.end());\\n        // for(auto )\\n        for(auto row : vis2)\\n        {\\n            flag2 = true;\\n            for(int i = 0; i<n; i++)\\n            {\\n                if(row[i] != 1)\\n                {\\n                    flag2 = false;\\n                    break;\\n                }\\n            }\\n            if(flag2)\\n            {\\n                break;\\n            }\\n        }\\n        //return flag2;\\n        if(flag1 || flag2) return 1;\\n        return 0;\\n    }\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int sz = arr.size();\\n        int hi = sz-1;\\n        int lo = 0;\\n        int ans = INT_MAX;\\n        // int mid = lo + (hi - lo)/2;\\n        // return check(mid,arr,mat);\\n        while(lo <= hi)\\n        {\\n            int mid = lo + (hi - lo)/2;\\n            //return mid;\\n            if(check(mid,arr,mat))\\n            {\\n                //return mid;\\n                ans = mid;\\n                hi = mid-1;\\n                //return ans;\\n            }\\n            else\\n            {\\n                //return mid;\\n                lo = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The function check() is called for each mid in the binary search which operates in O(log(n)) time complexity, where n is the size of arr. Inside the check() function, you\\'re iterating over the entire matrix, which is of size m*n. Also, in the worst-case scenario, you\\'re doing an erase operation on an unordered_set for each element in the matrix, which is an O(1) operation.\\n\\nHowever, the major contributing factor to the high time complexity is the nested loop over the matrix inside check() function, making the overall time complexity O(n*m*log(n)).\\n\\nNow to optimize, we could modify the code as follows:\\n\\n1. Instead of iterating over the entire matrix to fill vis[][] in check() function, maintain a map of each element\\'s position in the matrix. Then, just update vis[][] for the elements up to arr[mid].\\n\\n2. Instead of erasing each found element from the unordered_set st, you can check if all elements up to arr[mid] have been found in the matrix by comparing the size of st to the index mid. If the size of st equals (mid+1), then all elements have been found.\\n\\n3. Instead of iterating over all rows and columns to check if any of them is completely painted, maintain a count array for each row and column. In each update of vis[][], increment the corresponding row\\'s and column\\'s count. Then, you only need to check if any count equals the width or height of the matrix, respectively.\\n\\nThese modifications should significantly improve the time complexity of your code. Please note that the overall complexity still remains O(n*log(n)), which might be still high for large inputs depending on the exact constraints of your problem. Further optimizations might be necessary based on those constraints."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "sad facefaceface emoji"
                    },
                    {
                        "username": "SilentStorm2k",
                        "content": "Is this a wrong test case? How could expected answer be smaller than number of rows or columns? Unable to submit because of this. Anyone else having this issue?\\narr =\\n[1,4,5,2,6,3]\\nmat =\\n[[4,3,5],[1,2,6]]\\n\\nOutput\\n2\\nExpected\\n1"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The indexing is `0-based` . So 1 here means `arr[1]` i.e. 4. Thats paints the first column completely. Hope that helps."
                    },
                    {
                        "username": "bparanj",
                        "content": "The expected output seems correct. Here\\'s why:\\n\\nYou go through each index `i` in `arr` starting from index `0` and paint the cell in `mat` containing the integer `arr[i]`. The output is the smallest index `i` at which either a row or a column will be completely painted in `mat`.\\n\\nIn this case:\\n\\nAt index `0` in `arr`, you paint `1` which is at position `[1,0]` in `mat`.\\nAt index `1` in `arr`, you paint `4` which is at position `[0,0]` in `mat`.\\n\\nAfter these steps, the first column of `mat` (index `0`) is completely painted. Hence, the smallest index at which a row or column is completely painted is `1` (the index of `4` in `arr`), which is the expected output. \\n\\nRemember, the task is to find the smallest index `i` in `arr`, not the number of painted cells or the size of a row/column in `mat`.\\n\\nSo, the test case is correct and the expected output of `1` is valid."
                    },
                    {
                        "username": "avissant",
                        "content": "The expected answer is the index of the array `arr` 0-indexed. So in the test case you have that means the index of the number 4, so 1."
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "the first item in array is the start point , you need to print how many more passes you need until its row/col is fully painted"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we have to return the index in arr so that any row or column is completely painted\ni guess you are missing on\n rowcount should be equal to number of columns \nor columncount should be equal to number of rows"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Wants to know the intuition and approach on how to solve this problem?\\nCheck out my solution post which is very well explained including about constraints as well as time and space complexities.\\uD83D\\uDC47\\uD83C\\uDFFB\\uD83D\\uDD25\\n\\n[leetcode](https://leetcode.com)https://leetcode.com/problems/first-completely-painted-row-or-column/solutions/3468364/hashmap-well-explained-java-clean-code/"
                    }
                ]
            },
            {
                "id": 1878032,
                "content": [
                    {
                        "username": "namandt",
                        "content": "Nice Question!."
                    },
                    {
                        "username": "cionx",
                        "content": "For those searching for test cases:\\n```text\\n[8,2,4,9,3,5,7,10,1,6]\\n[[8,2,9,10,4],[1,7,6,3,5]]\\n```\\nfound an error in my submission that the previous cases missed."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "That\\'s Mahh Boii, By the way... I got TLE"
                    },
                    {
                        "username": "2uringTested",
                        "content": "This binary search code passes all the test cases, 1058 of them, yet still gets a TLE :( how to fix the issue?\\n `\\nclass Solution {\\npublic:\\n    using vvi = vector<vector<int>>;\\n    \\n    bool color(vvi mat,set<int>& nums){\\n        for(int i=0;i<mat.size();i++){\\n            bool isColor = true;\\n            for(int j=0;j<mat[0].size();j++){\\n                if(nums.find(mat[i][j])!=nums.end()){\\n                    mat[i][j]=-1;\\n                }else{\\n                    isColor = false;\\n                }\\n            }\\n            if(isColor == true) return true;\\n        }\\n        for(int j=0;j<mat[0].size();j++){\\n            bool isColor = true;\\n            for(int i=0;i<mat.size();i++){\\n                if(mat[i][j]!=-1){\\n                    isColor = false;\\n                    break;\\n                }\\n            }\\n            if(isColor) return true;\\n        }\\n        return false;\\n\\n    }\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        \\n        int left = 0;\\n        int right = arr.size()-1;\\n        int mid = left+(right-left)/2;\\n        int ans = INT_MAX;\\n\\n        while(left<=right){\\n\\n            set<int> nums;\\n            for(int j=0;j<=mid;j++){\\n                nums.insert(arr[j]);\\n            }\\n            if(color(mat,nums)){\\n                ans = min(ans,mid);\\n                right = mid-1;\\n            }else{\\n                left = mid+1;\\n            }\\n\\n            mid = left+(right-left)/2;\\n            \\n        }\\n        return ans;\\n    }};`"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of your code is quite high due to multiple reasons. Let\\'s consider n = arr.size(), m = mat.size(), and p = mat[0].size():\\n\\n1. The main binary search loop runs log(n) times.\\n2. In each iteration of the binary search, you\\'re inserting up to n elements into a set. This costs O(n log(n)).\\n3. After that, you\\'re iterating over all the elements in the matrix, which is O(m*p), and for each matrix element, you\\'re performing a set find operation, which costs O(log(n)).\\n\\nMultiplying all these together, your total time complexity is O(n * m * p * log(n) * log(n)).\\n\\nNow, to optimize the code, there are a few strategies we can take:\\n\\n1. **Avoid re-computing the set in every iteration**: Instead of creating the set from scratch for every mid, you can maintain a set outside the loop and just add or remove elements as necessary when you update mid.\\n\\n2. **Utilize matrix properties for faster check**: Instead of going through all the elements in the matrix in each iteration, you can maintain a count of the number of painted cells in each row and column. Then, in each iteration, you only need to update the counts for the cells that are newly painted, and check if any row or column count equals the matrix\\'s width or height, respectively. This reduces the matrix checking cost to O(m + p) in each iteration.\\n\\nWith these optimizations, the total time complexity can be reduced to O(n * log(n) + n * (m + p)). However, it might still be considered high for large inputs. Depending on the exact constraints of your problem, further optimizations might be necessary. For instance, if the matrix is guaranteed to be a square matrix (m = p), and m, p << n, then this time complexity should be efficient enough."
                    },
                    {
                        "username": "2uringTested",
                        "content": "never mind, got it, changing from set to unordered_set improved the solution"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it was really a very good question took 2-3 hours to actually code it correctly and the feeling is really good "
                    },
                    {
                        "username": "namansingh100",
                        "content": "this code is giving TLE\\neven after passing all the test cases;  sad$face$emoji\\n\\n\\nclass Solution {\\npublic:\\n    \\n    bool check(int mid,vector<int>& arr,vector<vector<int>>& mat)\\n    {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        unordered_set<int> st;\\n        unordered_map<int,pair<int,int>> mp;\\n//         for(int i = 0; i<n; i++)\\n//         {\\n//             for(int j = 0; j<m; j++)\\n//             {\\n//                 mp[mat[i][j]] = make_pair(i,j);\\n//             }\\n//         }\\n//         for(int i = 0; i<=mid; i++)\\n            \\n//         {\\n//             auto pr = mp[arr[i]];\\n//             int x = pr.first;\\n//             int y = pr.second;\\n//             vis[x][y] = 1;\\n//         }\\n        for(int i = 0; i<=mid; i++)\\n        {\\n            st.insert(arr[i]);\\n        }\\n        //int idUpTo = mid-1;\\n        for(int i = 0; i<n; i++)\\n        {\\n            for(int j = 0; j<m; j++)\\n            {\\n                if(st.find(mat[i][j]) != st.end())\\n                {\\n                    vis[i][j] = 1;\\n                    st.erase(mat[i][j]);\\n                }\\n            }\\n        }  \\n        bool flag1;\\n        bool flag2;\\n        for(auto row : vis)\\n        {\\n            flag1 = true;\\n            for(int i = 0; i<m; i++)\\n            {\\n                if(row[i] != 1)\\n                {\\n                    flag1 = false;\\n                    break;\\n                }\\n            }\\n            if(flag1)\\n            {\\n                break;\\n            }\\n        }\\n        vector<vector<int>> vis2(m,vector<int>(n,0));\\n        for(int i = 0; i<n; i++)\\n        {\\n            for(int j = 0; j<m; j++)\\n                \\n            {\\n                vis2[j][i] = vis[i][j];\\n            }\\n        }\\n        // reverse(vis.begin(),vis.end());\\n        // for(auto )\\n        for(auto row : vis2)\\n        {\\n            flag2 = true;\\n            for(int i = 0; i<n; i++)\\n            {\\n                if(row[i] != 1)\\n                {\\n                    flag2 = false;\\n                    break;\\n                }\\n            }\\n            if(flag2)\\n            {\\n                break;\\n            }\\n        }\\n        //return flag2;\\n        if(flag1 || flag2) return 1;\\n        return 0;\\n    }\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int sz = arr.size();\\n        int hi = sz-1;\\n        int lo = 0;\\n        int ans = INT_MAX;\\n        // int mid = lo + (hi - lo)/2;\\n        // return check(mid,arr,mat);\\n        while(lo <= hi)\\n        {\\n            int mid = lo + (hi - lo)/2;\\n            //return mid;\\n            if(check(mid,arr,mat))\\n            {\\n                //return mid;\\n                ans = mid;\\n                hi = mid-1;\\n                //return ans;\\n            }\\n            else\\n            {\\n                //return mid;\\n                lo = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The function check() is called for each mid in the binary search which operates in O(log(n)) time complexity, where n is the size of arr. Inside the check() function, you\\'re iterating over the entire matrix, which is of size m*n. Also, in the worst-case scenario, you\\'re doing an erase operation on an unordered_set for each element in the matrix, which is an O(1) operation.\\n\\nHowever, the major contributing factor to the high time complexity is the nested loop over the matrix inside check() function, making the overall time complexity O(n*m*log(n)).\\n\\nNow to optimize, we could modify the code as follows:\\n\\n1. Instead of iterating over the entire matrix to fill vis[][] in check() function, maintain a map of each element\\'s position in the matrix. Then, just update vis[][] for the elements up to arr[mid].\\n\\n2. Instead of erasing each found element from the unordered_set st, you can check if all elements up to arr[mid] have been found in the matrix by comparing the size of st to the index mid. If the size of st equals (mid+1), then all elements have been found.\\n\\n3. Instead of iterating over all rows and columns to check if any of them is completely painted, maintain a count array for each row and column. In each update of vis[][], increment the corresponding row\\'s and column\\'s count. Then, you only need to check if any count equals the width or height of the matrix, respectively.\\n\\nThese modifications should significantly improve the time complexity of your code. Please note that the overall complexity still remains O(n*log(n)), which might be still high for large inputs depending on the exact constraints of your problem. Further optimizations might be necessary based on those constraints."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "sad facefaceface emoji"
                    },
                    {
                        "username": "SilentStorm2k",
                        "content": "Is this a wrong test case? How could expected answer be smaller than number of rows or columns? Unable to submit because of this. Anyone else having this issue?\\narr =\\n[1,4,5,2,6,3]\\nmat =\\n[[4,3,5],[1,2,6]]\\n\\nOutput\\n2\\nExpected\\n1"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The indexing is `0-based` . So 1 here means `arr[1]` i.e. 4. Thats paints the first column completely. Hope that helps."
                    },
                    {
                        "username": "bparanj",
                        "content": "The expected output seems correct. Here\\'s why:\\n\\nYou go through each index `i` in `arr` starting from index `0` and paint the cell in `mat` containing the integer `arr[i]`. The output is the smallest index `i` at which either a row or a column will be completely painted in `mat`.\\n\\nIn this case:\\n\\nAt index `0` in `arr`, you paint `1` which is at position `[1,0]` in `mat`.\\nAt index `1` in `arr`, you paint `4` which is at position `[0,0]` in `mat`.\\n\\nAfter these steps, the first column of `mat` (index `0`) is completely painted. Hence, the smallest index at which a row or column is completely painted is `1` (the index of `4` in `arr`), which is the expected output. \\n\\nRemember, the task is to find the smallest index `i` in `arr`, not the number of painted cells or the size of a row/column in `mat`.\\n\\nSo, the test case is correct and the expected output of `1` is valid."
                    },
                    {
                        "username": "avissant",
                        "content": "The expected answer is the index of the array `arr` 0-indexed. So in the test case you have that means the index of the number 4, so 1."
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "the first item in array is the start point , you need to print how many more passes you need until its row/col is fully painted"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we have to return the index in arr so that any row or column is completely painted\ni guess you are missing on\n rowcount should be equal to number of columns \nor columncount should be equal to number of rows"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Wants to know the intuition and approach on how to solve this problem?\\nCheck out my solution post which is very well explained including about constraints as well as time and space complexities.\\uD83D\\uDC47\\uD83C\\uDFFB\\uD83D\\uDD25\\n\\n[leetcode](https://leetcode.com)https://leetcode.com/problems/first-completely-painted-row-or-column/solutions/3468364/hashmap-well-explained-java-clean-code/"
                    }
                ]
            },
            {
                "id": 1877688,
                "content": [
                    {
                        "username": "namandt",
                        "content": "Nice Question!."
                    },
                    {
                        "username": "cionx",
                        "content": "For those searching for test cases:\\n```text\\n[8,2,4,9,3,5,7,10,1,6]\\n[[8,2,9,10,4],[1,7,6,3,5]]\\n```\\nfound an error in my submission that the previous cases missed."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "That\\'s Mahh Boii, By the way... I got TLE"
                    },
                    {
                        "username": "2uringTested",
                        "content": "This binary search code passes all the test cases, 1058 of them, yet still gets a TLE :( how to fix the issue?\\n `\\nclass Solution {\\npublic:\\n    using vvi = vector<vector<int>>;\\n    \\n    bool color(vvi mat,set<int>& nums){\\n        for(int i=0;i<mat.size();i++){\\n            bool isColor = true;\\n            for(int j=0;j<mat[0].size();j++){\\n                if(nums.find(mat[i][j])!=nums.end()){\\n                    mat[i][j]=-1;\\n                }else{\\n                    isColor = false;\\n                }\\n            }\\n            if(isColor == true) return true;\\n        }\\n        for(int j=0;j<mat[0].size();j++){\\n            bool isColor = true;\\n            for(int i=0;i<mat.size();i++){\\n                if(mat[i][j]!=-1){\\n                    isColor = false;\\n                    break;\\n                }\\n            }\\n            if(isColor) return true;\\n        }\\n        return false;\\n\\n    }\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        \\n        int left = 0;\\n        int right = arr.size()-1;\\n        int mid = left+(right-left)/2;\\n        int ans = INT_MAX;\\n\\n        while(left<=right){\\n\\n            set<int> nums;\\n            for(int j=0;j<=mid;j++){\\n                nums.insert(arr[j]);\\n            }\\n            if(color(mat,nums)){\\n                ans = min(ans,mid);\\n                right = mid-1;\\n            }else{\\n                left = mid+1;\\n            }\\n\\n            mid = left+(right-left)/2;\\n            \\n        }\\n        return ans;\\n    }};`"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of your code is quite high due to multiple reasons. Let\\'s consider n = arr.size(), m = mat.size(), and p = mat[0].size():\\n\\n1. The main binary search loop runs log(n) times.\\n2. In each iteration of the binary search, you\\'re inserting up to n elements into a set. This costs O(n log(n)).\\n3. After that, you\\'re iterating over all the elements in the matrix, which is O(m*p), and for each matrix element, you\\'re performing a set find operation, which costs O(log(n)).\\n\\nMultiplying all these together, your total time complexity is O(n * m * p * log(n) * log(n)).\\n\\nNow, to optimize the code, there are a few strategies we can take:\\n\\n1. **Avoid re-computing the set in every iteration**: Instead of creating the set from scratch for every mid, you can maintain a set outside the loop and just add or remove elements as necessary when you update mid.\\n\\n2. **Utilize matrix properties for faster check**: Instead of going through all the elements in the matrix in each iteration, you can maintain a count of the number of painted cells in each row and column. Then, in each iteration, you only need to update the counts for the cells that are newly painted, and check if any row or column count equals the matrix\\'s width or height, respectively. This reduces the matrix checking cost to O(m + p) in each iteration.\\n\\nWith these optimizations, the total time complexity can be reduced to O(n * log(n) + n * (m + p)). However, it might still be considered high for large inputs. Depending on the exact constraints of your problem, further optimizations might be necessary. For instance, if the matrix is guaranteed to be a square matrix (m = p), and m, p << n, then this time complexity should be efficient enough."
                    },
                    {
                        "username": "2uringTested",
                        "content": "never mind, got it, changing from set to unordered_set improved the solution"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "it was really a very good question took 2-3 hours to actually code it correctly and the feeling is really good "
                    },
                    {
                        "username": "namansingh100",
                        "content": "this code is giving TLE\\neven after passing all the test cases;  sad$face$emoji\\n\\n\\nclass Solution {\\npublic:\\n    \\n    bool check(int mid,vector<int>& arr,vector<vector<int>>& mat)\\n    {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        unordered_set<int> st;\\n        unordered_map<int,pair<int,int>> mp;\\n//         for(int i = 0; i<n; i++)\\n//         {\\n//             for(int j = 0; j<m; j++)\\n//             {\\n//                 mp[mat[i][j]] = make_pair(i,j);\\n//             }\\n//         }\\n//         for(int i = 0; i<=mid; i++)\\n            \\n//         {\\n//             auto pr = mp[arr[i]];\\n//             int x = pr.first;\\n//             int y = pr.second;\\n//             vis[x][y] = 1;\\n//         }\\n        for(int i = 0; i<=mid; i++)\\n        {\\n            st.insert(arr[i]);\\n        }\\n        //int idUpTo = mid-1;\\n        for(int i = 0; i<n; i++)\\n        {\\n            for(int j = 0; j<m; j++)\\n            {\\n                if(st.find(mat[i][j]) != st.end())\\n                {\\n                    vis[i][j] = 1;\\n                    st.erase(mat[i][j]);\\n                }\\n            }\\n        }  \\n        bool flag1;\\n        bool flag2;\\n        for(auto row : vis)\\n        {\\n            flag1 = true;\\n            for(int i = 0; i<m; i++)\\n            {\\n                if(row[i] != 1)\\n                {\\n                    flag1 = false;\\n                    break;\\n                }\\n            }\\n            if(flag1)\\n            {\\n                break;\\n            }\\n        }\\n        vector<vector<int>> vis2(m,vector<int>(n,0));\\n        for(int i = 0; i<n; i++)\\n        {\\n            for(int j = 0; j<m; j++)\\n                \\n            {\\n                vis2[j][i] = vis[i][j];\\n            }\\n        }\\n        // reverse(vis.begin(),vis.end());\\n        // for(auto )\\n        for(auto row : vis2)\\n        {\\n            flag2 = true;\\n            for(int i = 0; i<n; i++)\\n            {\\n                if(row[i] != 1)\\n                {\\n                    flag2 = false;\\n                    break;\\n                }\\n            }\\n            if(flag2)\\n            {\\n                break;\\n            }\\n        }\\n        //return flag2;\\n        if(flag1 || flag2) return 1;\\n        return 0;\\n    }\\n    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {\\n        int sz = arr.size();\\n        int hi = sz-1;\\n        int lo = 0;\\n        int ans = INT_MAX;\\n        // int mid = lo + (hi - lo)/2;\\n        // return check(mid,arr,mat);\\n        while(lo <= hi)\\n        {\\n            int mid = lo + (hi - lo)/2;\\n            //return mid;\\n            if(check(mid,arr,mat))\\n            {\\n                //return mid;\\n                ans = mid;\\n                hi = mid-1;\\n                //return ans;\\n            }\\n            else\\n            {\\n                //return mid;\\n                lo = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The function check() is called for each mid in the binary search which operates in O(log(n)) time complexity, where n is the size of arr. Inside the check() function, you\\'re iterating over the entire matrix, which is of size m*n. Also, in the worst-case scenario, you\\'re doing an erase operation on an unordered_set for each element in the matrix, which is an O(1) operation.\\n\\nHowever, the major contributing factor to the high time complexity is the nested loop over the matrix inside check() function, making the overall time complexity O(n*m*log(n)).\\n\\nNow to optimize, we could modify the code as follows:\\n\\n1. Instead of iterating over the entire matrix to fill vis[][] in check() function, maintain a map of each element\\'s position in the matrix. Then, just update vis[][] for the elements up to arr[mid].\\n\\n2. Instead of erasing each found element from the unordered_set st, you can check if all elements up to arr[mid] have been found in the matrix by comparing the size of st to the index mid. If the size of st equals (mid+1), then all elements have been found.\\n\\n3. Instead of iterating over all rows and columns to check if any of them is completely painted, maintain a count array for each row and column. In each update of vis[][], increment the corresponding row\\'s and column\\'s count. Then, you only need to check if any count equals the width or height of the matrix, respectively.\\n\\nThese modifications should significantly improve the time complexity of your code. Please note that the overall complexity still remains O(n*log(n)), which might be still high for large inputs depending on the exact constraints of your problem. Further optimizations might be necessary based on those constraints."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "sad facefaceface emoji"
                    },
                    {
                        "username": "SilentStorm2k",
                        "content": "Is this a wrong test case? How could expected answer be smaller than number of rows or columns? Unable to submit because of this. Anyone else having this issue?\\narr =\\n[1,4,5,2,6,3]\\nmat =\\n[[4,3,5],[1,2,6]]\\n\\nOutput\\n2\\nExpected\\n1"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The indexing is `0-based` . So 1 here means `arr[1]` i.e. 4. Thats paints the first column completely. Hope that helps."
                    },
                    {
                        "username": "bparanj",
                        "content": "The expected output seems correct. Here\\'s why:\\n\\nYou go through each index `i` in `arr` starting from index `0` and paint the cell in `mat` containing the integer `arr[i]`. The output is the smallest index `i` at which either a row or a column will be completely painted in `mat`.\\n\\nIn this case:\\n\\nAt index `0` in `arr`, you paint `1` which is at position `[1,0]` in `mat`.\\nAt index `1` in `arr`, you paint `4` which is at position `[0,0]` in `mat`.\\n\\nAfter these steps, the first column of `mat` (index `0`) is completely painted. Hence, the smallest index at which a row or column is completely painted is `1` (the index of `4` in `arr`), which is the expected output. \\n\\nRemember, the task is to find the smallest index `i` in `arr`, not the number of painted cells or the size of a row/column in `mat`.\\n\\nSo, the test case is correct and the expected output of `1` is valid."
                    },
                    {
                        "username": "avissant",
                        "content": "The expected answer is the index of the array `arr` 0-indexed. So in the test case you have that means the index of the number 4, so 1."
                    },
                    {
                        "username": "Flame_BlitZ",
                        "content": "the first item in array is the start point , you need to print how many more passes you need until its row/col is fully painted"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we have to return the index in arr so that any row or column is completely painted\ni guess you are missing on\n rowcount should be equal to number of columns \nor columncount should be equal to number of rows"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Wants to know the intuition and approach on how to solve this problem?\\nCheck out my solution post which is very well explained including about constraints as well as time and space complexities.\\uD83D\\uDC47\\uD83C\\uDFFB\\uD83D\\uDD25\\n\\n[leetcode](https://leetcode.com)https://leetcode.com/problems/first-completely-painted-row-or-column/solutions/3468364/hashmap-well-explained-java-clean-code/"
                    }
                ]
            }
        ]
    }
]