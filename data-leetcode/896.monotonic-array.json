[
    {
        "title": "Monotonic Array",
        "question_content": "An array is monotonic if it is either monotone increasing or monotone decreasing.\nAn array nums is monotone increasing if for all i <= j, nums[i] <= nums[j]. An array nums is monotone decreasing if for all i <= j, nums[i] >= nums[j].\nGiven an integer array nums, return true if the given array is monotonic, or false otherwise.\n&nbsp;\nExample 1:\n\nInput: nums = [1,2,2,3]\nOutput: true\n\nExample 2:\n\nInput: nums = [6,5,4,4]\nOutput: true\n\nExample 3:\n\nInput: nums = [1,3,2]\nOutput: false\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 105\n\t-105 <= nums[i] <= 105",
        "solutions": [
            {
                "id": 165889,
                "title": "c-java-python-one-pass-o-n",
                "content": "We check if `A` is increasing and decreasing.\\n\\n**C++:**\\n```\\n    bool isMonotonic(vector<int> A) {\\n        bool inc = true, dec = true;\\n        for (int i = 1; i < A.size(); ++i)\\n            inc &= A[i - 1] <= A[i], dec &= A[i - 1] >= A[i];\\n        return inc || dec;\\n    }\\n```\\n\\n**Java:**\\n```\\n    public boolean isMonotonic(int[] A) {\\n        boolean inc = true, dec = true;\\n        for (int i = 1; i < A.length; ++i) {\\n            inc &= A[i - 1] <= A[i];\\n            dec &= A[i - 1] >= A[i];\\n        }\\n        return inc || dec;\\n    }\\n```\\n\\n**Python:**\\n```\\n    def isMonotonic(self, A):\\n        return not {cmp(i, j) for i, j in zip(A, A[1:])} >= {1, -1}\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    bool isMonotonic(vector<int> A) {\\n        bool inc = true, dec = true;\\n        for (int i = 1; i < A.size(); ++i)\\n            inc &= A[i - 1] <= A[i], dec &= A[i - 1] >= A[i];\\n        return inc || dec;\\n    }\\n```\n```\\n    public boolean isMonotonic(int[] A) {\\n        boolean inc = true, dec = true;\\n        for (int i = 1; i < A.length; ++i) {\\n            inc &= A[i - 1] <= A[i];\\n            dec &= A[i - 1] >= A[i];\\n        }\\n        return inc || dec;\\n    }\\n```\n```\\n    def isMonotonic(self, A):\\n        return not {cmp(i, j) for i, j in zip(A, A[1:])} >= {1, -1}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4102869,
                "title": "95-15-single-pass-check",
                "content": "# Interview Guide: \"Check Monotonic Array\" Problem\\n\\n## Problem Understanding\\n\\nThe \"Check Monotonic Array\" problem requires evaluating whether a given array is either entirely non-decreasing (monotonically increasing) or non-increasing (monotonically decreasing). The objective is to return a boolean value indicating the array\\'s monotonicity.\\n\\n## Key Points to Consider\\n\\n### 1. Understand the Constraints\\n\\nBefore diving into the solution, it\\'s crucial to recognize the problem\\'s constraints. The length of the array `nums` is between 1 and $$10^5$$, and the integers in `nums` range between $$-10^5$$ and $$10^5$$. These constraints offer insights into potential solutions in terms of time and space complexity.\\n\\n### 2. Single Pass Check\\n\\nOne efficient way to solve this problem is to use a single pass through the array to determine if it\\'s increasing, decreasing, or neither. This approach reduces the number of checks and can potentially exit early if the array is neither increasing nor decreasing.\\n\\n### 3. Understand Array Characteristics\\n\\nA key observation is that if an array starts by increasing, it should not switch to decreasing later and vice versa. This observation forms the basis of the solution.\\n\\n### 4. Explain Your Thought Process\\n\\nAlways articulate the rationale behind your approach. Describe the importance of determining the direction of monotonicity early on and how it can help in making the solution more efficient.\\n\\n## Conclusion\\n\\nThe \"Check Monotonic Array\" problem emphasizes the significance of understanding array traversal and condition checks. By performing a single pass through the array, you can efficiently determine its monotonicity.\\n\\n---\\n\\n## Live Coding & Explain\\nhttps://youtu.be/INyEvNkNRcg?si=R2VWH4FxIb_nHWoH\\n\\n# Approach: Single Pass Check\\n\\nTo solve the \"Check Monotonic Array\" problem using the single pass check:\\n\\n## Key Data Structures:\\n\\n- **direction**: A variable to keep track of the array\\'s direction (increasing, decreasing, or unknown).\\n\\n## Enhanced Breakdown:\\n\\n1. **Initialization**:\\n   - If the array\\'s length is less than 2, return `True` (arrays with 0 or 1 elements are always monotonic).\\n   - Initialize the `direction` as 0 (unknown).\\n   \\n2. **Traverse the Array**:\\n   - For every pair of adjacent elements, determine if the array is increasing, decreasing, or neither.\\n   - If the direction is set to increasing and a decreasing pattern is found, return `False`, and vice versa.\\n   \\n3. **Return the Result**:\\n   - If no violation of monotonicity is found during traversal, return `True`.\\n\\n# Complexity:\\n\\n**Time Complexity:** \\n- The solution involves traversing the array once, leading to a time complexity of $$O(n)$$, where `n` is the length of the array `nums`.\\n\\n**Space Complexity:** \\n- The space complexity is $$O(1)$$ since the solution doesn\\'t use any additional data structures that scale with the input size.\\n\\n# Code Single Pass Check\\n``` Python []\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        if len(nums) < 2:\\n            return True\\n        \\n        direction = 0  # 0 means unknown, 1 means increasing, -1 means decreasing\\n        \\n        for i in range(1, len(nums)):\\n            if nums[i] > nums[i-1]:  # increasing\\n                if direction == 0:\\n                    direction = 1\\n                elif direction == -1:\\n                    return False\\n            elif nums[i] < nums[i-1]:  # decreasing\\n                if direction == 0:\\n                    direction = -1\\n                elif direction == 1:\\n                    return False\\n        \\n        return True\\n```\\n``` Go []\\nfunc isMonotonic(nums []int) bool {\\n    if len(nums) < 2 {\\n        return true\\n    }\\n\\n    direction := 0  // 0 means unknown, 1 means increasing, -1 means decreasing\\n\\n    for i := 1; i < len(nums); i++ {\\n        if nums[i] > nums[i-1] {  // increasing\\n            if direction == 0 {\\n                direction = 1\\n            } else if direction == -1 {\\n                return false\\n            }\\n        } else if nums[i] < nums[i-1] {  // decreasing\\n            if direction == 0 {\\n                direction = -1\\n            } else if direction == 1 {\\n                return false\\n            }\\n        }\\n    }\\n\\n    return true\\n}\\n```\\n``` Rust []\\nimpl Solution {\\n    pub fn is_monotonic(nums: Vec<i32>) -> bool {\\n        if nums.len() < 2 {\\n            return true;\\n        }\\n\\n        let mut direction = 0;  // 0 means unknown, 1 means increasing, -1 means decreasing\\n\\n        for i in 1..nums.len() {\\n            if nums[i] > nums[i-1] {  // increasing\\n                if direction == 0 {\\n                    direction = 1;\\n                } else if direction == -1 {\\n                    return false;\\n                }\\n            } else if nums[i] < nums[i-1] {  // decreasing\\n                if direction == 0 {\\n                    direction = -1;\\n                } else if direction == 1 {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        true\\n    }\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    bool isMonotonic(std::vector<int>& nums) {\\n        if (nums.size() < 2) return true;\\n\\n        int direction = 0;  // 0 means unknown, 1 means increasing, -1 means decreasing\\n\\n        for (size_t i = 1; i < nums.size(); i++) {\\n            if (nums[i] > nums[i-1]) {  // increasing\\n                if (direction == 0) direction = 1;\\n                else if (direction == -1) return false;\\n            } else if (nums[i] < nums[i-1]) {  // decreasing\\n                if (direction == 0) direction = -1;\\n                else if (direction == 1) return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n```\\n``` Java []\\npublic class Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        if (nums.length < 2) return true;\\n\\n        int direction = 0;  // 0 means unknown, 1 means increasing, -1 means decreasing\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] > nums[i-1]) {  // increasing\\n                if (direction == 0) direction = 1;\\n                else if (direction == -1) return false;\\n            } else if (nums[i] < nums[i-1]) {  // decreasing\\n                if (direction == 0) direction = -1;\\n                else if (direction == 1) return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\\n``` JavaScript []\\nvar isMonotonic = function(nums) {\\n    if (nums.length < 2) return true;\\n\\n    let direction = 0;  // 0 means unknown, 1 means increasing, -1 means decreasing\\n\\n    for (let i = 1; i < nums.length; i++) {\\n        if (nums[i] > nums[i-1]) {  // increasing\\n            if (direction === 0) direction = 1;\\n            else if (direction === -1) return false;\\n        } else if (nums[i] < nums[i-1]) {  // decreasing\\n            if (direction === 0) direction = -1;\\n            else if (direction === 1) return false;\\n        }\\n    }\\n\\n    return true;\\n};\\n```\\n``` PHP []\\nclass Solution {\\n    function isMonotonic($nums) {\\n        if (count($nums) < 2) return true;\\n\\n        $direction = 0;  // 0 means unknown, 1 means increasing, -1 means decreasing\\n\\n        for ($i = 1; $i < count($nums); $i++) {\\n            if ($nums[$i] > $nums[$i-1]) {  // increasing\\n                if ($direction == 0) $direction = 1;\\n                else if ($direction == -1) return false;\\n            } else if ($nums[$i] < $nums[$i-1]) {  // decreasing\\n                if ($direction == 0) $direction = -1;\\n                else if ($direction == 1) return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\\n``` C# []\\npublic class Solution {\\n    public bool IsMonotonic(int[] nums) {\\n        if (nums.Length < 2) return true;\\n\\n        int direction = 0;  // 0 means unknown, 1 means increasing, -1 means decreasing\\n\\n        for (int i = 1; i < nums.Length; i++) {\\n            if (nums[i] > nums[i-1]) {  // increasing\\n                if (direction == 0) direction = 1;\\n                else if (direction == -1) return false;\\n            } else if (nums[i] < nums[i-1]) {  // decreasing\\n                if (direction == 0) direction = -1;\\n                else if (direction == 1) return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\\n\\n## Performance\\n\\n| Language   | Time (ms) | Memory    |\\n|------------|-----------|-----------|\\n| Java       | 1 ms      | 55.4 MB   |\\n| Rust       | 12 ms     | 3.3 MB    |\\n| JavaScript | 80 ms     | 52.4 MB   |\\n| C++        | 131 ms    | 96.8 MB   |\\n| Go         | 135 ms    | 9.8 MB    |\\n| C#         | 241 ms    | 61.4 MB   |\\n| PHP        | 277 ms    | 31.7 MB   |\\n| Python3    | 812 ms    | 30.4 MB   |\\n\\n![v4.png](https://assets.leetcode.com/users/images/f7e8cef7-b85d-4335-82e6-2f3f0fc83197_1695948899.0787735.png)\\n\\nThe \"Check Monotonic Array\" problem is an interesting array traversal problem that tests the ability to keep track of a property (monotonicity) while traversing an array. It showcases the importance of efficient array traversal and conditional checks. \\uD83D\\uDE80\\uD83E\\uDDE0\\uD83D\\uDC69\\u200D\\uD83D\\uDCBB\\uD83D\\uDC68\\u200D\\uD83D\\uDCBB.",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript",
                    "Go",
                    "Rust",
                    "PHP"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        if len(nums) < 2:\\n            return True\\n        \\n        direction = 0  # 0 means unknown, 1 means increasing, -1 means decreasing\\n        \\n        for i in range(1, len(nums)):\\n            if nums[i] > nums[i-1]:  # increasing\\n                if direction == 0:\\n                    direction = 1\\n                elif direction == -1:\\n                    return False\\n            elif nums[i] < nums[i-1]:  # decreasing\\n                if direction == 0:\\n                    direction = -1\\n                elif direction == 1:\\n                    return False\\n        \\n        return True\\n```\n``` Go []\\nfunc isMonotonic(nums []int) bool {\\n    if len(nums) < 2 {\\n        return true\\n    }\\n\\n    direction := 0  // 0 means unknown, 1 means increasing, -1 means decreasing\\n\\n    for i := 1; i < len(nums); i++ {\\n        if nums[i] > nums[i-1] {  // increasing\\n            if direction == 0 {\\n                direction = 1\\n            } else if direction == -1 {\\n                return false\\n            }\\n        } else if nums[i] < nums[i-1] {  // decreasing\\n            if direction == 0 {\\n                direction = -1\\n            } else if direction == 1 {\\n                return false\\n            }\\n        }\\n    }\\n\\n    return true\\n}\\n```\n``` Rust []\\nimpl Solution {\\n    pub fn is_monotonic(nums: Vec<i32>) -> bool {\\n        if nums.len() < 2 {\\n            return true;\\n        }\\n\\n        let mut direction = 0;  // 0 means unknown, 1 means increasing, -1 means decreasing\\n\\n        for i in 1..nums.len() {\\n            if nums[i] > nums[i-1] {  // increasing\\n                if direction == 0 {\\n                    direction = 1;\\n                } else if direction == -1 {\\n                    return false;\\n                }\\n            } else if nums[i] < nums[i-1] {  // decreasing\\n                if direction == 0 {\\n                    direction = -1;\\n                } else if direction == 1 {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        true\\n    }\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    bool isMonotonic(std::vector<int>& nums) {\\n        if (nums.size() < 2) return true;\\n\\n        int direction = 0;  // 0 means unknown, 1 means increasing, -1 means decreasing\\n\\n        for (size_t i = 1; i < nums.size(); i++) {\\n            if (nums[i] > nums[i-1]) {  // increasing\\n                if (direction == 0) direction = 1;\\n                else if (direction == -1) return false;\\n            } else if (nums[i] < nums[i-1]) {  // decreasing\\n                if (direction == 0) direction = -1;\\n                else if (direction == 1) return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n```\n``` Java []\\npublic class Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        if (nums.length < 2) return true;\\n\\n        int direction = 0;  // 0 means unknown, 1 means increasing, -1 means decreasing\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] > nums[i-1]) {  // increasing\\n                if (direction == 0) direction = 1;\\n                else if (direction == -1) return false;\\n            } else if (nums[i] < nums[i-1]) {  // decreasing\\n                if (direction == 0) direction = -1;\\n                else if (direction == 1) return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\n``` JavaScript []\\nvar isMonotonic = function(nums) {\\n    if (nums.length < 2) return true;\\n\\n    let direction = 0;  // 0 means unknown, 1 means increasing, -1 means decreasing\\n\\n    for (let i = 1; i < nums.length; i++) {\\n        if (nums[i] > nums[i-1]) {  // increasing\\n            if (direction === 0) direction = 1;\\n            else if (direction === -1) return false;\\n        } else if (nums[i] < nums[i-1]) {  // decreasing\\n            if (direction === 0) direction = -1;\\n            else if (direction === 1) return false;\\n        }\\n    }\\n\\n    return true;\\n};\\n```\n``` PHP []\\nclass Solution {\\n    function isMonotonic($nums) {\\n        if (count($nums) < 2) return true;\\n\\n        $direction = 0;  // 0 means unknown, 1 means increasing, -1 means decreasing\\n\\n        for ($i = 1; $i < count($nums); $i++) {\\n            if ($nums[$i] > $nums[$i-1]) {  // increasing\\n                if ($direction == 0) $direction = 1;\\n                else if ($direction == -1) return false;\\n            } else if ($nums[$i] < $nums[$i-1]) {  // decreasing\\n                if ($direction == 0) $direction = -1;\\n                else if ($direction == 1) return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\n``` C# []\\npublic class Solution {\\n    public bool IsMonotonic(int[] nums) {\\n        if (nums.Length < 2) return true;\\n\\n        int direction = 0;  // 0 means unknown, 1 means increasing, -1 means decreasing\\n\\n        for (int i = 1; i < nums.Length; i++) {\\n            if (nums[i] > nums[i-1]) {  // increasing\\n                if (direction == 0) direction = 1;\\n                else if (direction == -1) return false;\\n            } else if (nums[i] < nums[i-1]) {  // decreasing\\n                if (direction == 0) direction = -1;\\n                else if (direction == 1) return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4102847,
                "title": "97-44-increasing-decreasing-1-line-code",
                "content": "# Problem\\n#### The problem statement asks you to determine whether a given array nums is monotonic. An array is considered monotonic if it is either monotone increasing or monotone decreasing.\\n\\n **1.** **Monotone Increasing :**   An array is considered monotone increasing if for all indices i and j where i <= j, the element at index i is less than or equal to the element at index j. In other words, the values in the array are non-decreasing as you move from left to right.\\n\\n**2.** **Monotone Decreasing :** An array is considered monotone decreasing if for all indices i and j where i <= j, the element at index i is greater than or equal to the element at index j. In other words, the values in the array are non-increasing as you move from left to right.\\n\\n#### The task is to check if the given nums array satisfies either of these conditions. If it does, the function should return true, indicating that the array is monotonic. Otherwise, it should return false.\\n---\\n# Solution\\n#### 1. Initialize two boolean variables, increasing and decreasing, to true. These variables will be used to track whether the array is monotone increasing or monotone decreasing.\\n\\n#### 2.Iterate through the array from the second element (i = 1) to the last element (i = nums.length - 1).\\n\\n#### 3.For each pair of adjacent elements at indices i and i - 1, compare them:\\n\\n- ***If nums[i] is greater than nums[i - 1], set decreasing to false. This means the array is not monotone decreasing.***\\n\\n- ***If nums[i] is less than nums[i - 1], set increasing to false. This means the array is not monotone increasing.***\\n\\n#### 4. During the iteration, if at any point both increasing and decreasing become false, you can immediately return false because the array is neither monotone increasing nor monotone decreasing.\\n\\n#### 5.After the loop, if either increasing or decreasing is still true, it means the array is either monotone increasing or monotone decreasing, so you return true. Otherwise, you return false because the array is not monotonic.\\n---\\n\\n```python []\\nclass Solution:\\n    def isMonotonic(self, A: List[int]) -> bool:\\n        return all(A[i] <= A[i + 1] for i in range(len(A) - 1)) or all(A[i] >= A[i + 1] for i in range(len(A) - 1))\\n\\n```\\n```C# []\\npublic class Solution {\\n    public bool IsMonotonic(int[] nums) {\\n        bool increasing = true;\\n        bool decreasing = true;\\n\\n        for (int i = 1; i < nums.Length; i++) {\\n            if (nums[i] > nums[i - 1]) {\\n                decreasing = false;\\n            } else if (nums[i] < nums[i - 1]) {\\n                increasing = false;\\n            }\\n\\n            if (!increasing && !decreasing) {\\n                return false;\\n            }\\n        }\\n\\n        return true; \\n    }\\n}\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        bool increasing = true;\\n        bool decreasing = true;\\n\\n        for (int i = 1; i < nums.size(); ++i) {\\n            if (nums[i] > nums[i - 1]) {\\n                decreasing = false;\\n            } else if (nums[i] < nums[i - 1]) {\\n                increasing = false;\\n            }\\n\\n            if (!increasing && !decreasing) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n```\\n```C []\\nbool isMonotonic(int* nums, int numsSize) {\\n    bool increasing = true;\\n    bool decreasing = true;\\n\\n    for (int i = 1; i < numsSize; i++) {\\n        if (nums[i] > nums[i - 1]) {\\n            decreasing = false;\\n        } else if (nums[i] < nums[i - 1]) {\\n            increasing = false;\\n        }\\n\\n        if (!increasing && !decreasing) {\\n            return false;\\n        }\\n    }\\n\\n    return true; \\n}\\n\\n```\\n```Java []\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        boolean increasing = true;\\n        boolean decreasing = true;\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] > nums[i - 1]) {\\n                decreasing = false;\\n            } else if (nums[i] < nums[i - 1]) {\\n                increasing = false;\\n            }\\n\\n            if (!increasing && !decreasing) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n```\\n```javascript []\\nvar isMonotonic = function(nums) {\\n    let increasing = true;\\n    let decreasing = true;\\n\\n    for (let i = 1; i < nums.length; i++) {\\n        if (nums[i] > nums[i - 1]) {\\n            decreasing = false;\\n        } else if (nums[i] < nums[i - 1]) {\\n            increasing = false;\\n        }\\n\\n        if (!increasing && !decreasing) {\\n            return false;\\n        }\\n    }\\n\\n    return true; \\n};\\n\\n```\\n```typescript []\\nfunction isMonotonic(nums: number[]): boolean {\\n    let increasing = true;\\n    let decreasing = true;\\n\\n    for (let i = 1; i < nums.length; i++) {\\n        if (nums[i] > nums[i - 1]) {\\n            decreasing = false;\\n        } else if (nums[i] < nums[i - 1]) {\\n            increasing = false;\\n        }\\n\\n        if (!increasing && !decreasing) {\\n            return false;\\n        }\\n    }\\n\\n    return true;\\n}\\n\\n```\\n```Go []\\nfunc isMonotonic(nums []int) bool {\\n    increasing := true\\n    decreasing := true\\n    for i := 1; i < len(nums); i++ {\\n        if nums[i] > nums[i-1] {\\n            decreasing = false\\n        } else if nums[i] < nums[i-1] {\\n            increasing = false\\n        }\\n        if !increasing && !decreasing {\\n            return false\\n        }\\n    }\\n    return true \\n}\\n```\\n```rust []\\nimpl Solution {\\n    pub fn is_monotonic(nums: Vec<i32>) -> bool {\\n        let mut increasing = true;\\n        let mut decreasing = true;\\n\\n        for i in 1..nums.len() {\\n            if nums[i] > nums[i - 1] {\\n                decreasing = false;\\n            } else if nums[i] < nums[i - 1] {\\n                increasing = false;\\n            }\\n\\n            // If both increasing and decreasing become false, return false immediately.\\n            if !increasing && !decreasing {\\n                return false;\\n            }\\n        }\\n\\n        true // Either increasing or decreasing remains true, or both are true (monotonic).\\n    }\\n}\\n```\\n\\n![9c6f9412-c860-47d6-9a2e-7fcf37ff3321_1686334926.180891.png](https://assets.leetcode.com/users/images/372c6f32-ec84-4a05-9050-846fe3cc231a_1695946977.0907705.png)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "C#",
                    "JavaScript",
                    "Go",
                    "Rust",
                    "TypeScript"
                ],
                "code": "```python []\\nclass Solution:\\n    def isMonotonic(self, A: List[int]) -> bool:\\n        return all(A[i] <= A[i + 1] for i in range(len(A) - 1)) or all(A[i] >= A[i + 1] for i in range(len(A) - 1))\\n\\n```\n```C# []\\npublic class Solution {\\n    public bool IsMonotonic(int[] nums) {\\n        bool increasing = true;\\n        bool decreasing = true;\\n\\n        for (int i = 1; i < nums.Length; i++) {\\n            if (nums[i] > nums[i - 1]) {\\n                decreasing = false;\\n            } else if (nums[i] < nums[i - 1]) {\\n                increasing = false;\\n            }\\n\\n            if (!increasing && !decreasing) {\\n                return false;\\n            }\\n        }\\n\\n        return true; \\n    }\\n}\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        bool increasing = true;\\n        bool decreasing = true;\\n\\n        for (int i = 1; i < nums.size(); ++i) {\\n            if (nums[i] > nums[i - 1]) {\\n                decreasing = false;\\n            } else if (nums[i] < nums[i - 1]) {\\n                increasing = false;\\n            }\\n\\n            if (!increasing && !decreasing) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n```\n```C []\\nbool isMonotonic(int* nums, int numsSize) {\\n    bool increasing = true;\\n    bool decreasing = true;\\n\\n    for (int i = 1; i < numsSize; i++) {\\n        if (nums[i] > nums[i - 1]) {\\n            decreasing = false;\\n        } else if (nums[i] < nums[i - 1]) {\\n            increasing = false;\\n        }\\n\\n        if (!increasing && !decreasing) {\\n            return false;\\n        }\\n    }\\n\\n    return true; \\n}\\n\\n```\n```Java []\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        boolean increasing = true;\\n        boolean decreasing = true;\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] > nums[i - 1]) {\\n                decreasing = false;\\n            } else if (nums[i] < nums[i - 1]) {\\n                increasing = false;\\n            }\\n\\n            if (!increasing && !decreasing) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n```\n```javascript []\\nvar isMonotonic = function(nums) {\\n    let increasing = true;\\n    let decreasing = true;\\n\\n    for (let i = 1; i < nums.length; i++) {\\n        if (nums[i] > nums[i - 1]) {\\n            decreasing = false;\\n        } else if (nums[i] < nums[i - 1]) {\\n            increasing = false;\\n        }\\n\\n        if (!increasing && !decreasing) {\\n            return false;\\n        }\\n    }\\n\\n    return true; \\n};\\n\\n```\n```typescript []\\nfunction isMonotonic(nums: number[]): boolean {\\n    let increasing = true;\\n    let decreasing = true;\\n\\n    for (let i = 1; i < nums.length; i++) {\\n        if (nums[i] > nums[i - 1]) {\\n            decreasing = false;\\n        } else if (nums[i] < nums[i - 1]) {\\n            increasing = false;\\n        }\\n\\n        if (!increasing && !decreasing) {\\n            return false;\\n        }\\n    }\\n\\n    return true;\\n}\\n\\n```\n```Go []\\nfunc isMonotonic(nums []int) bool {\\n    increasing := true\\n    decreasing := true\\n    for i := 1; i < len(nums); i++ {\\n        if nums[i] > nums[i-1] {\\n            decreasing = false\\n        } else if nums[i] < nums[i-1] {\\n            increasing = false\\n        }\\n        if !increasing && !decreasing {\\n            return false\\n        }\\n    }\\n    return true \\n}\\n```\n```rust []\\nimpl Solution {\\n    pub fn is_monotonic(nums: Vec<i32>) -> bool {\\n        let mut increasing = true;\\n        let mut decreasing = true;\\n\\n        for i in 1..nums.len() {\\n            if nums[i] > nums[i - 1] {\\n                decreasing = false;\\n            } else if nums[i] < nums[i - 1] {\\n                increasing = false;\\n            }\\n\\n            // If both increasing and decreasing become false, return false immediately.\\n            if !increasing && !decreasing {\\n                return false;\\n            }\\n        }\\n\\n        true // Either increasing or decreasing remains true, or both are true (monotonic).\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 165960,
                "title": "python-solution-easy-to-understand",
                "content": "```\\nclass Solution(object):\\n    def isMonotonic(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: bool\\n        \"\"\"\\n\\n        n = len(A)\\n        if n <= 2: return True\\n\\t\\t\\t\\t\\n        isGreat = False\\n        isLess = False\\n        for i in range(1, n):\\n            if A[i - 1] > A[i]:\\n                isGreat = True\\n            if A[i - 1] < A[i]:\\n                isLess = True\\n\\n            if isGreat and isLess:\\n                return False\\n\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isMonotonic(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: bool\\n        \"\"\"\\n\\n        n = len(A)\\n        if n <= 2: return True\\n\\t\\t\\t\\t\\n        isGreat = False\\n        isLess = False\\n        for i in range(1, n):\\n            if A[i - 1] > A[i]:\\n                isGreat = True\\n            if A[i - 1] < A[i]:\\n                isLess = True\\n\\n            if isGreat and isLess:\\n                return False\\n\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 518215,
                "title": "c-easy-one-pass-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& A) {\\n        bool increase = true;\\n        bool decrease = true;\\n        for(int i = 0; i < A.size() - 1; i++) {\\n            if(A[i] > A[i+1]) increase = false;\\n            if(A[i] < A[i+1]) decrease = false;\\n            if(increase == false && decrease == false) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& A) {\\n        bool increase = true;\\n        bool decrease = true;\\n        for(int i = 0; i < A.size() - 1; i++) {\\n            if(A[i] > A[i+1]) increase = false;\\n            if(A[i] < A[i+1]) decrease = false;\\n            if(increase == false && decrease == false) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 165917,
                "title": "java-tricky-solution",
                "content": "1. Find the trend based on A[0] and A[n-1]\\n2. Check if the consecutive neighbors are consistent with the trend.\\n```\\nclass Solution {\\n    public boolean isMonotonic(int[] A) {\\n        if (A.length==1) return true;\\n        int n=A.length;\\n        boolean up= (A[n-1]-A[0])>0;\\n        for (int i=0; i<n-1; i++)\\n            if (A[i+1]!=A[i] && (A[i+1]-A[i]>0)!=up) \\n                return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] A) {\\n        if (A.length==1) return true;\\n        int n=A.length;\\n        boolean up= (A[n-1]-A[0])>0;\\n        for (int i=0; i<n-1; i++)\\n            if (A[i+1]!=A[i] && (A[i+1]-A[i]>0)!=up) \\n                return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 172578,
                "title": "java-o-n-simple-solution",
                "content": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] A) {\\n        int inc=1;\\n        int dec=1;\\n        for(int i=1; i<A.length; i++){\\n            if(A[i] - A[i-1] > 0)\\n                inc++;\\n            else if(A[i] - A[i-1] < 0)\\n                dec++;\\n            else {\\n                inc++; dec++;\\n            }\\n                \\n        }\\n        return inc == A.length || dec == A.length;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] A) {\\n        int inc=1;\\n        int dec=1;\\n        for(int i=1; i<A.length; i++){\\n            if(A[i] - A[i-1] > 0)\\n                inc++;\\n            else if(A[i] - A[i-1] < 0)\\n                dec++;\\n            else {\\n                inc++; dec++;\\n            }\\n                \\n        }\\n        return inc == A.length || dec == A.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1680607,
                "title": "python-simple-one-line-solution",
                "content": "**Python :**\\n\\n```\\ndef isMonotonic(self, nums: List[int]) -> bool:\\n\\treturn nums == sorted(nums) or nums == sorted(nums, reverse=True)\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef isMonotonic(self, nums: List[int]) -> bool:\\n\\treturn nums == sorted(nums) or nums == sorted(nums, reverse=True)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4103078,
                "title": "video-how-we-think-about-a-solution-two-flags-python-javascript-java-c",
                "content": "Welcome to my article! This artcle starts with \"How we think about a solution\". In other words, that is my thought process to solve the question. This article explains how I get to my solution instead of just posting solution codes or out of blue algorithms. I hope this aricle is helpful for someone.\\n\\n# Intuition\\nUse two flags to check this is increasing or decreasing.\\n\\n---\\n\\n# Solution Video\\n\\nhttps://youtu.be/UVEDSDDSP-U\\n\\n### \\u2B50\\uFE0F\\u2B50\\uFE0F Don\\'t forget to subscribe to my channel! \\u2B50\\uFE0F\\u2B50\\uFE0F\\n\\n**\\u25A0 Subscribe URL**\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\nSubscribers: 2,533\\nMy initial goal is 10,000\\nThank you for your support!\\n\\n---\\n\\n# Approach\\n\\n## How we think about a solution.\\n\\nAt first, I solved this question with two loops simply like this.\\n\\n```\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        if n == 1: return True\\n        \\n        # check if this is increasing        \\n        for i in range(1, n):\\n            if nums[i] < nums[i-1]:\\n                break\\n            \\n            if i == n - 1:\\n                return True\\n\\n        # check if this is decreasing\\n        for i in range(1, n):\\n            if nums[i] > nums[i-1]:\\n                break\\n            \\n            if i == n - 1:\\n                return True\\n\\n        return False\\n```\\nThis solution passed all test cases and beated about 60%... not bad. but I realized that we can check both simultaneously if we have `two flags`.\\n\\n---\\n\\n\\n**The `two flags` indicates that input is increasing or decreasing.**\\n\\n---\\n\\nThe both flags start with `True`\\n```\\nInput: nums = [1,2,2,3]\\n\\nis_inc = True\\nis_dec = True\\n```\\nFirst of all, check length of input and if length of input is `1` return `true`.\\n\\nNext, we start from `index 1`. Compare two numbers at `index 1` and `index 0`\\n\\n```\\nindex 0: 1\\nindex 1: 2\\n\\nis_inc = True\\nis_dec = False\\n```\\nThis is increasing case, so in the end the `two flags` should be above.\\n```\\nindex 1: 2\\nindex 2: 2\\n\\nis_inc = True\\nis_dec = False\\n```\\nWe can consider the same numbers as both cases, so this is increasing case because `is_dec` was already `false`, so in the end the `two flags` should be the same.\\n\\n```\\nindex 2: 2\\nindex 3: 3\\n\\nis_inc = True\\nis_dec = False\\n```\\nThis is increasing case, the `both flag` should be the same. Then finish looping.\\n\\nAfter that, check both flags and if one of them is still `true`, that means we have `Monotonic Array`, so return `true`.\\n\\nOf course, during looping, if both flags are `false`, we can immediately return `false`.\\n\\nAnd one more thing\\n\\nI use `or` at the last step in the codes. It covers cases like `[1,3,2]`. In this case, loop 2 times and `is_dec` turn into `false` in the first loop and `is_inc` turn into `false` in the second loop.\\n\\nSo now both flags are `false` and finish looping. \\n\\nWhat I\\'m trying to say is that \\n\\n---\\n\\nFinishing loop is not always true case. \\n\\n---\\n\\n\\nThat\\'s why I check `both flags` with `or`.\\n\\nBe careful.\\n\\nLet\\'s see a real algorithm!\\n\\nAlgorithm Overview:\\n1. Initialize variables `is_inc` and `is_dec` to `True` to track whether the sequence is increasing or decreasing.\\n2. Iterate through the input list `nums` starting from the second element.\\n3. Update `is_inc` to `False` if the current element is less than the previous element.\\n4. Update `is_dec` to `False` if the current element is greater than the previous element.\\n5. If both `is_inc` and `is_dec` are `False`, return `False` as the sequence is neither strictly increasing nor strictly decreasing.\\n6. Return `True` if either `is_inc` or `is_dec` is `True`, indicating that the sequence is either strictly increasing or strictly decreasing.\\n\\nDetailed Explanation:\\n1. Initialize variables `is_inc` and `is_dec` to `True` to indicate that the sequence is initially assumed to be both increasing and decreasing.\\n2. Iterate through the input list `nums` starting from the second element (index 1).\\n3. Check if the sequence is not both increasing and decreasing (i.e., both `is_inc` and `is_dec` are `False`). If so, return `False` since the sequence is neither strictly increasing nor strictly decreasing.\\n4. Check if the current element (`nums[i]`) is less than the previous element (`nums[i-1]`). If true, update `is_inc` to `False` since the sequence is no longer strictly increasing.\\n5. Check if the current element (`nums[i]`) is greater than the previous element (`nums[i-1]`). If true, update `is_dec` to `False` since the sequence is no longer strictly decreasing.\\n6. After iterating through the entire list, if either `is_inc` or `is_dec` is `True`, return `True` indicating that the sequence is either strictly increasing or strictly decreasing. If both are `False`, return `False`.\\n\\n---\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n```python []\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        if n == 1: return True\\n\\n        is_inc = True\\n        is_dec = True\\n\\n        for i in range(1, n):\\n            if not is_inc and not is_dec:\\n                return False\\n\\n            if nums[i] < nums[i-1]:\\n                is_inc = False\\n            if nums[i] > nums[i-1]:\\n                is_dec = False\\n\\n        return is_inc or is_dec\\n```\\n```javascript []\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar isMonotonic = function(nums) {\\n    const n = nums.length;\\n    if (n === 1) return true;\\n\\n    let isInc = true;\\n    let isDec = true;\\n\\n    for (let i = 1; i < n; i++) {\\n        if (!isInc && !isDec) {\\n            return false;\\n        }\\n\\n        if (nums[i] < nums[i - 1]) {\\n            isInc = false;\\n        }\\n        if (nums[i] > nums[i - 1]) {\\n            isDec = false;\\n        }\\n    }\\n\\n    return isInc || isDec;    \\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        int n = nums.length;\\n        if (n == 1) return true;\\n\\n        boolean isInc = true;\\n        boolean isDec = true;\\n\\n        for (int i = 1; i < n; i++) {\\n            if (!isInc && !isDec) {\\n                return false;\\n            }\\n\\n            if (nums[i] < nums[i - 1]) {\\n                isInc = false;\\n            }\\n            if (nums[i] > nums[i - 1]) {\\n                isDec = false;\\n            }\\n        }\\n\\n        return isInc || isDec;        \\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1) return true;\\n\\n        bool isInc = true;\\n        bool isDec = true;\\n\\n        for (int i = 1; i < n; i++) {\\n            if (!isInc && !isDec) {\\n                return false;\\n            }\\n\\n            if (nums[i] < nums[i - 1]) {\\n                isInc = false;\\n            }\\n            if (nums[i] > nums[i - 1]) {\\n                isDec = false;\\n            }\\n        }\\n\\n        return isInc || isDec;        \\n    }\\n};\\n```\\n\\n\\n---\\n\\nThank you for reading my post.\\n\\u2B50\\uFE0F Please upvote it and don\\'t forget to subscribe to my channel!\\n\\nMy previous post for daily coding challenge\\nhttps://leetcode.com/problems/sort-array-by-parity/solutions/4098282/video-how-we-think-about-a-solution-one-pointer-python-javascript-java-c/",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        if n == 1: return True\\n        \\n        # check if this is increasing        \\n        for i in range(1, n):\\n            if nums[i] < nums[i-1]:\\n                break\\n            \\n            if i == n - 1:\\n                return True\\n\\n        # check if this is decreasing\\n        for i in range(1, n):\\n            if nums[i] > nums[i-1]:\\n                break\\n            \\n            if i == n - 1:\\n                return True\\n\\n        return False\\n```\n```\\nInput: nums = [1,2,2,3]\\n\\nis_inc = True\\nis_dec = True\\n```\n```\\nindex 0: 1\\nindex 1: 2\\n\\nis_inc = True\\nis_dec = False\\n```\n```\\nindex 1: 2\\nindex 2: 2\\n\\nis_inc = True\\nis_dec = False\\n```\n```\\nindex 2: 2\\nindex 3: 3\\n\\nis_inc = True\\nis_dec = False\\n```\n```python []\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        if n == 1: return True\\n\\n        is_inc = True\\n        is_dec = True\\n\\n        for i in range(1, n):\\n            if not is_inc and not is_dec:\\n                return False\\n\\n            if nums[i] < nums[i-1]:\\n                is_inc = False\\n            if nums[i] > nums[i-1]:\\n                is_dec = False\\n\\n        return is_inc or is_dec\\n```\n```javascript []\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar isMonotonic = function(nums) {\\n    const n = nums.length;\\n    if (n === 1) return true;\\n\\n    let isInc = true;\\n    let isDec = true;\\n\\n    for (let i = 1; i < n; i++) {\\n        if (!isInc && !isDec) {\\n            return false;\\n        }\\n\\n        if (nums[i] < nums[i - 1]) {\\n            isInc = false;\\n        }\\n        if (nums[i] > nums[i - 1]) {\\n            isDec = false;\\n        }\\n    }\\n\\n    return isInc || isDec;    \\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        int n = nums.length;\\n        if (n == 1) return true;\\n\\n        boolean isInc = true;\\n        boolean isDec = true;\\n\\n        for (int i = 1; i < n; i++) {\\n            if (!isInc && !isDec) {\\n                return false;\\n            }\\n\\n            if (nums[i] < nums[i - 1]) {\\n                isInc = false;\\n            }\\n            if (nums[i] > nums[i - 1]) {\\n                isDec = false;\\n            }\\n        }\\n\\n        return isInc || isDec;        \\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1) return true;\\n\\n        bool isInc = true;\\n        bool isDec = true;\\n\\n        for (int i = 1; i < n; i++) {\\n            if (!isInc && !isDec) {\\n                return false;\\n            }\\n\\n            if (nums[i] < nums[i - 1]) {\\n                isInc = false;\\n            }\\n            if (nums[i] > nums[i - 1]) {\\n                isDec = false;\\n            }\\n        }\\n\\n        return isInc || isDec;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4102860,
                "title": "93-24-one-pass-solution-commented-code",
                "content": "# Problem Description\\n\\nThe problem involves determining whether a given integer array, nums, is **monotonic**, meaning it is either non-decreasing or non-increasing.\\n\\nThe task is to **return** `true` if the array is monotonic, and `false` otherwise.\\n\\n**Monotonic array** is an array in which the elements are either entirely **non-increasing** (monotone decreasing) or entirely **non-decreasing** (monotone increasing). In other words, the elements in a monotonic array are in a consistently **increasing** or consistently **decreasing** order.\\n- **Monotone increasing**: `nums[i] <= nums[j]` for all `i <= j`.\\n- **Monotone decreasing**: `nums[i] >= nums[j]` for all `i <= j`.\\n\\n![image.png](https://assets.leetcode.com/users/images/3c360608-d0cb-4740-99f0-b8ffe7f99f46_1695946655.0437603.png)\\n\\n\\n---\\n\\n# Approach\\n1. Initialize two boolean variables: `isIncreasing` and `isDecreasing` to **true**.\\n2. Loop through the array:\\n    - Starting from the **second** element, compare each **element** with its **previous** element.\\n    - If an element is **less** than its previous element, set `isIncreasing` to **false** (indicating the array is **not increasing**).\\n    - If an element is **greater** than its previous element, set `isDecreasing` to **false** (indicating the array is **not decreasing**).\\n    - If both `isIncreasing` and `isDecreasing` are **false**, **break** the loop as the array is neither increasing nor decreasing and we don\\'t have to **continue** the loop.\\n3. Return if either `isIncreasing` or `isDecreasing` is **true** since the array is considered monotonic if **one** of them is **true** and non monotonic if both are **false**.\\n\\n\\n# Complexity\\n- **Time complexity:** $$O(N)$$\\nSince we are using one for loop then it is linear time which is `O(N)`.\\n- **Space complexity:** $$O(1)$$\\nSince we are using couple of constant variables then it is `O(1)`.\\n\\n---\\n\\n\\n\\n# Code\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        bool isIncreasing = true;  // Indicates if the array is increasing.\\n        bool isDecreasing = true;  // Indicates if the array is decreasing.\\n\\n        // Check if the array is either increasing or non-increasing.\\n        for (int i = 1; i < nums.size(); i++) {\\n            // Check increasing condition.\\n            if (nums[i] < nums[i - 1])\\n                isIncreasing = false;\\n                \\n            // Check decreasing condition.\\n            else if (nums[i] > nums[i - 1])\\n                isDecreasing = false;\\n\\n            // If it is neither increasing nor decreasing then don\\'t continue the loop\\n            if (!isIncreasing && !isDecreasing)\\n                break;\\n        }\\n\\n        return isIncreasing || isDecreasing;  // Return true if either condition is met.\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        boolean isIncreasing = true;  // Indicates if the array is increasing\\n        boolean isDecreasing = true;  // Indicates if the array is decreasing\\n\\n        // Check if the array is either increasing or non-increasing\\n        for (int i = 1; i < nums.length; i++) {\\n            // Check increasing condition.\\n            if (nums[i] < nums[i - 1])\\n                isIncreasing = false;\\n\\n            // Check decreasing condition.\\n            else if (nums[i] > nums[i - 1])\\n                isDecreasing = false;\\n\\n            // If it is neither increasing nor decreasing then don\\'t continue the loop\\n            if (!isIncreasing && !isDecreasing)\\n                break;\\n        }\\n\\n        return isIncreasing || isDecreasing;  // Return true if either condition is met\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def isMonotonic(self, nums: list[int]) -> bool:\\n        is_increasing = True  # Indicates if the array is increasing.\\n        is_decreasing = True  # Indicates if the array is decreasing.\\n\\n        # Check if the array is either increasing or non-increasing.\\n        for i in range(1, len(nums)):\\n            # Check increasing condition.\\n            if nums[i] < nums[i - 1]:\\n                is_increasing = False\\n\\n            # Check decreasing condition.\\n            elif nums[i] > nums[i - 1]:\\n                is_decreasing = False\\n\\n            # If it is neither increasing nor decreasing then don\\'t continue the loop.\\n            if not is_increasing and not is_decreasing:\\n                break\\n\\n        return is_increasing or is_decreasing  # Return true if either condition is met.\\n```\\n\\n![leet_sol.jpg](https://assets.leetcode.com/users/images/ee804bfd-acfc-41bb-bc77-ec864144fe24_1695947355.9566755.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        bool isIncreasing = true;  // Indicates if the array is increasing.\\n        bool isDecreasing = true;  // Indicates if the array is decreasing.\\n\\n        // Check if the array is either increasing or non-increasing.\\n        for (int i = 1; i < nums.size(); i++) {\\n            // Check increasing condition.\\n            if (nums[i] < nums[i - 1])\\n                isIncreasing = false;\\n                \\n            // Check decreasing condition.\\n            else if (nums[i] > nums[i - 1])\\n                isDecreasing = false;\\n\\n            // If it is neither increasing nor decreasing then don\\'t continue the loop\\n            if (!isIncreasing && !isDecreasing)\\n                break;\\n        }\\n\\n        return isIncreasing || isDecreasing;  // Return true if either condition is met.\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        boolean isIncreasing = true;  // Indicates if the array is increasing\\n        boolean isDecreasing = true;  // Indicates if the array is decreasing\\n\\n        // Check if the array is either increasing or non-increasing\\n        for (int i = 1; i < nums.length; i++) {\\n            // Check increasing condition.\\n            if (nums[i] < nums[i - 1])\\n                isIncreasing = false;\\n\\n            // Check decreasing condition.\\n            else if (nums[i] > nums[i - 1])\\n                isDecreasing = false;\\n\\n            // If it is neither increasing nor decreasing then don\\'t continue the loop\\n            if (!isIncreasing && !isDecreasing)\\n                break;\\n        }\\n\\n        return isIncreasing || isDecreasing;  // Return true if either condition is met\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def isMonotonic(self, nums: list[int]) -> bool:\\n        is_increasing = True  # Indicates if the array is increasing.\\n        is_decreasing = True  # Indicates if the array is decreasing.\\n\\n        # Check if the array is either increasing or non-increasing.\\n        for i in range(1, len(nums)):\\n            # Check increasing condition.\\n            if nums[i] < nums[i - 1]:\\n                is_increasing = False\\n\\n            # Check decreasing condition.\\n            elif nums[i] > nums[i - 1]:\\n                is_decreasing = False\\n\\n            # If it is neither increasing nor decreasing then don\\'t continue the loop.\\n            if not is_increasing and not is_decreasing:\\n                break\\n\\n        return is_increasing or is_decreasing  # Return true if either condition is met.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 501946,
                "title": "python-and-java-solution-beat-96-and-100",
                "content": "Since we only need to check if the array is either ascending or descending, we compare the first and last element value and reverse the list. As the result, we only need to do ascending check.\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n\\nPython\\n```python\\nclass Solution:\\n    def isMonotonic(self, A: List[int]) -> bool:\\n        if A[-1] < A[0]: \\n            A = A[::-1]\\n        \\n        for i in range(1, len(A)):\\n            if A[i] < A[i-1]:\\n                return False\\n        return True\\n```\\n\\nJava\\n```java\\nclass Solution {\\n    public boolean isMonotonic(int[] arr) {\\n        if (arr[arr.length-1] < arr[0])\\n            reverse(arr);\\n        \\n        for (int i = 1; i < arr.length; i++) {\\n            if (arr[i] < arr[i-1]) \\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    private void reverse(int[] arr) {\\n        for (int i = 0; i < arr.length/2; i++) {\\n            int temp = arr[i];\\n            arr[i] = arr[arr.length - 1 - i];\\n            arr[arr.length - 1 - i] = temp;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def isMonotonic(self, A: List[int]) -> bool:\\n        if A[-1] < A[0]: \\n            A = A[::-1]\\n        \\n        for i in range(1, len(A)):\\n            if A[i] < A[i-1]:\\n                return False\\n        return True\\n```\n```java\\nclass Solution {\\n    public boolean isMonotonic(int[] arr) {\\n        if (arr[arr.length-1] < arr[0])\\n            reverse(arr);\\n        \\n        for (int i = 1; i < arr.length; i++) {\\n            if (arr[i] < arr[i-1]) \\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    private void reverse(int[] arr) {\\n        for (int i = 0; i < arr.length/2; i++) {\\n            int temp = arr[i];\\n            arr[i] = arr[arr.length - 1 - i];\\n            arr[arr.length - 1 - i] = temp;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2133433,
                "title": "c-one-liner-100-optimised-one-pass",
                "content": "```\\nbool isMonotonic(vector<int>& nums) {\\n       return is_sorted(nums.begin(),nums.end()) || is_sorted(nums.begin(),nums.end(),greater<int>());\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool isMonotonic(vector<int>& nums) {\\n       return is_sorted(nums.begin(),nums.end()) || is_sorted(nums.begin(),nums.end(),greater<int>());\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 512313,
                "title": "javascript-one-liner-solution",
                "content": "```javascript\\n/**\\n * @param {number[]} A\\n * @return {boolean}\\n */\\nvar isMonotonic = function(A) {\\n  return (\\n    A.every((v, i) => i === 0 || v <= A[i - 1]) ||\\n    A.every((v, i) => i === 0 || v >= A[i - 1])\\n  );\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {number[]} A\\n * @return {boolean}\\n */\\nvar isMonotonic = function(A) {\\n  return (\\n    A.every((v, i) => i === 0 || v <= A[i - 1]) ||\\n    A.every((v, i) => i === 0 || v >= A[i - 1])\\n  );\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4102978,
                "title": "easy-to-understand-beginner",
                "content": "# Intuition\\n- The problem asks whether a given array` nums` is monotonic. \\n- A monotonic array is one that is either entirely non-increasing or non-decreasing. \\n- In simpler terms, it means that the elements in the array are in a sorted order, either in ascending or descending order.\\n\\n# Approach\\n1. Initialize two boolean flags, `increasing` and `decreasing`, to true. These flags will help us track whether the array is `non-increasing` or `non-decreasing`, respectively.\\n\\n1. Iterate through the array `nums` starting from index 1 (comparing each element with the previous one).\\n\\n1. For each pair of adjacent elements, check whether `nums[i] `is greater than `nums[i - 1]`. If it is, set the `decreasing` flag to false because this indicates that the array is not `decreasing`.\\n\\n1. If `nums[i] `is less than `nums[i - 1]`, set the `increasing` flag to false because this indicates that the array is not `increasing`.\\n\\n1. Continue this process for the entire array.\\n\\n1. After the loop, check whether either increasing or decreasing is true. If either of them is true, it means that the array is monotonic (either non-increasing or non-decreasing), so return true. Otherwise, return false.\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nThe `time complexity of this approach is O(n)`, where n is the number of elements in the nums array. This is because we iterate through the array once, comparing each element with its previous element.\\n\\n- Space complexity:\\n- The `space complexity is O(1) `because we use a constant amount of extra space to store the boolean flags `increasing` and `decreasing`, regardless of the size of the input array.\\n\\n# PLEASE UPVOTE\\u2764\\uD83D\\uDE0D\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        bool increasing = true;\\n        bool decreasing = true;\\n\\n        for (int i = 1; i < nums.size(); i++) {\\n            if (nums[i] > nums[i - 1]) {\\n                decreasing = false;\\n            } else if (nums[i] < nums[i - 1]) {\\n                increasing = false;\\n            }\\n        }\\n\\n        return increasing || decreasing;\\n    }\\n};\\n```\\n# JAVA\\n```\\npublic class Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        boolean increasing = true;\\n        boolean decreasing = true;\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] > nums[i - 1]) {\\n                decreasing = false;\\n            } else if (nums[i] < nums[i - 1]) {\\n                increasing = false;\\n            }\\n        }\\n\\n        return increasing || decreasing;\\n    }\\n}\\n\\n```\\n# PYTHON\\n```\\nclass Solution:\\n    def isMonotonic(self, nums):\\n        increasing = True\\n        decreasing = True\\n\\n        for i in range(1, len(nums)):\\n            if nums[i] > nums[i - 1]:\\n                decreasing = False\\n            elif nums[i] < nums[i - 1]:\\n                increasing = False\\n\\n        return increasing or decreasing\\n\\n```\\n# JAVASCRIPT\\n```\\nvar isMonotonic = function(nums) {\\n    let increasing = true;\\n    let decreasing = true;\\n\\n    for (let i = 1; i < nums.length; i++) {\\n        if (nums[i] > nums[i - 1]) {\\n            decreasing = false;\\n        } else if (nums[i] < nums[i - 1]) {\\n            increasing = false;\\n        }\\n    }\\n\\n    return increasing || decreasing;\\n};\\n\\n```\\n# PLEASE UPVOTE\\u2764\\uD83D\\uDE0D",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        bool increasing = true;\\n        bool decreasing = true;\\n\\n        for (int i = 1; i < nums.size(); i++) {\\n            if (nums[i] > nums[i - 1]) {\\n                decreasing = false;\\n            } else if (nums[i] < nums[i - 1]) {\\n                increasing = false;\\n            }\\n        }\\n\\n        return increasing || decreasing;\\n    }\\n};\\n```\n```\\npublic class Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        boolean increasing = true;\\n        boolean decreasing = true;\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] > nums[i - 1]) {\\n                decreasing = false;\\n            } else if (nums[i] < nums[i - 1]) {\\n                increasing = false;\\n            }\\n        }\\n\\n        return increasing || decreasing;\\n    }\\n}\\n\\n```\n```\\nclass Solution:\\n    def isMonotonic(self, nums):\\n        increasing = True\\n        decreasing = True\\n\\n        for i in range(1, len(nums)):\\n            if nums[i] > nums[i - 1]:\\n                decreasing = False\\n            elif nums[i] < nums[i - 1]:\\n                increasing = False\\n\\n        return increasing or decreasing\\n\\n```\n```\\nvar isMonotonic = function(nums) {\\n    let increasing = true;\\n    let decreasing = true;\\n\\n    for (let i = 1; i < nums.length; i++) {\\n        if (nums[i] > nums[i - 1]) {\\n            decreasing = false;\\n        } else if (nums[i] < nums[i - 1]) {\\n            increasing = false;\\n        }\\n    }\\n\\n    return increasing || decreasing;\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1153557,
                "title": "java-6-lines-easy-solution",
                "content": "```\\n    public boolean isMonotonic(int[] A) {\\n     boolean increasing = false, decreasing = false;\\n     for(int i = 1; i< A.length; i++){\\n         if(A[i] < A[i-1]) decreasing = true;\\n         if(A[i] > A[i-1]) increasing = true;\\n     }\\n     return increasing && decreasing ? false: true;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public boolean isMonotonic(int[] A) {\\n     boolean increasing = false, decreasing = false;\\n     for(int i = 1; i< A.length; i++){\\n         if(A[i] < A[i-1]) decreasing = true;\\n         if(A[i] > A[i-1]) increasing = true;\\n     }\\n     return increasing && decreasing ? false: true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4103805,
                "title": "99-82-simple-solution-c-java-python-javascript",
                "content": "\\u270599.82% Simple Solution  || C++ | Java || Python || JavaScript \\uD83D\\uDCAF\\uD83D\\uDD25\\n\\n# Read Article for Explaination and code :https://www.nileshblog.tech/leetcode-896-monotonic-array/\\n\\n\\n[c++ \\n](https://www.nileshblog.tech/leetcode-896-monotonic-array/#C_Leetcode_898_Monotonic_Array)\\n[Python](https://www.nileshblog.tech/leetcode-896-monotonic-array/#Python_Leetcode_898_Monotonic_Array )\\n\\n[Javascript \\n](https://www.nileshblog.tech/leetcode-896-monotonic-array/#JavaScript_Leetcode_898_Monotonic_Array)\\n[Java](https://www.nileshblog.tech/leetcode-896-monotonic-array/#C_Leetcode_898_Monotonic_Array)\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/6381729e-7a65-4020-a498-3079f6ed1095_1695966928.5496523.png)\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/22236aff-2a54-4df6-9c91-8dd14a3da698_1695967237.2066336.png)\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "\\u270599.82% Simple Solution  || C++ | Java || Python || JavaScript \\uD83D\\uDCAF\\uD83D\\uDD25\\n\\n# Read Article for Explaination and code :https://www.nileshblog.tech/leetcode-896-monotonic-array/\\n\\n\\n[c++ \\n](https://www.nileshblog.tech/leetcode-896-monotonic-array/#C_Leetcode_898_Monotonic_Array)\\n[Python](https://www.nileshblog.tech/leetcode-896-monotonic-array/#Python_Leetcode_898_Monotonic_Array )\\n\\n[Javascript \\n](https://www.nileshblog.tech/leetcode-896-monotonic-array/#JavaScript_Leetcode_898_Monotonic_Array)\\n[Java](https://www.nileshblog.tech/leetcode-896-monotonic-array/#C_Leetcode_898_Monotonic_Array)\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/6381729e-7a65-4020-a498-3079f6ed1095_1695966928.5496523.png)\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/22236aff-2a54-4df6-9c91-8dd14a3da698_1695967237.2066336.png)\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1860864,
                "title": "beginner-friendly-solution-cpp-easy-to-understand",
                "content": "```\\nPls upvote if it  is helpful\\n\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        \\n        int n = nums.size() ;\\n        int count = 1 ,flag = 1;\\n        \\n        for (int i=1; i<n; i++)\\n        {\\n            if (nums[i-1]<=nums[i])\\n            {\\n                count++ ;\\n            }\\n        }\\n        \\n        for (int i=1; i<n; i++)\\n        {\\n            if (nums[i-1]>=nums[i])\\n            {\\n                flag++ ;\\n            }\\n        }\\n        \\n        \\n        if (count==n || flag==n)\\n            return true ;\\n        else \\n            return false ;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nPls upvote if it  is helpful\\n\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        \\n        int n = nums.size() ;\\n        int count = 1 ,flag = 1;\\n        \\n        for (int i=1; i<n; i++)\\n        {\\n            if (nums[i-1]<=nums[i])\\n            {\\n                count++ ;\\n            }\\n        }\\n        \\n        for (int i=1; i<n; i++)\\n        {\\n            if (nums[i-1]>=nums[i])\\n            {\\n                flag++ ;\\n            }\\n        }\\n        \\n        \\n        if (count==n || flag==n)\\n            return true ;\\n        else \\n            return false ;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618159,
                "title": "python-3-2-lines-using-generator",
                "content": "```python3 []\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        pattern = nums[len(nums) - 1] > nums[0]\\n        return all((nums[i] > nums[i-1]) == pattern or nums[i] == nums[i-1] for i in range(1, len(nums)))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        pattern = nums[len(nums) - 1] > nums[0]\\n        return all((nums[i] > nums[i-1]) == pattern or nums[i] == nums[i-1] for i in range(1, len(nums)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 730460,
                "title": "simple-python3",
                "content": "```\\nclass Solution:\\n    def isMonotonic(self, A: List[int]) -> bool:\\n        \\n        increase = True\\n        decrease = True\\n        \\n        for i in range(len(A)-1):\\n            \\n            if A[i] > A[i+1]:\\n                increase = False\\n                \\n            if A[i] < A[i+1]:\\n                decrease = False\\n                \\n        return increase or decrease\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isMonotonic(self, A: List[int]) -> bool:\\n        \\n        increase = True\\n        decrease = True\\n        \\n        for i in range(len(A)-1):\\n            \\n            if A[i] > A[i+1]:\\n                increase = False\\n                \\n            if A[i] < A[i+1]:\\n                decrease = False\\n                \\n        return increase or decrease\\n```",
                "codeTag": "Java"
            },
            {
                "id": 168322,
                "title": "simple-javascript-100-solution",
                "content": "```\\nvar isMonotonic = function(A) {\\n    let arrLength = A.length;\\n    \\n    let isIncreasing = false;\\n    let isDecreasing = false;\\n    \\n    for(let i = 1; i <arrLength; i++){\\n        if(isIncreasing && isDecreasing){\\n            return false;\\n        }\\n        \\n        if(A[i] > A[i-1]){\\n            isIncreasing = true;\\n        } else if(A[i] < A[i-1]){\\n            isDecreasing = true;\\n        }\\n    }\\n    \\n    return !(isIncreasing && isDecreasing);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar isMonotonic = function(A) {\\n    let arrLength = A.length;\\n    \\n    let isIncreasing = false;\\n    let isDecreasing = false;\\n    \\n    for(let i = 1; i <arrLength; i++){\\n        if(isIncreasing && isDecreasing){\\n            return false;\\n        }\\n        \\n        if(A[i] > A[i-1]){\\n            isIncreasing = true;\\n        } else if(A[i] < A[i-1]){\\n            isDecreasing = true;\\n        }\\n    }\\n    \\n    return !(isIncreasing && isDecreasing);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 207057,
                "title": "4-lines-beats-99",
                "content": "```\\n    public boolean isMonotonic(int[] A) {\\n        int direction = (A[0] <= A[A.length - 1]) ? -1 : 1;\\n        for(int i = 0 ; i < A.length-1 ; i++)\\n            if ((A[i] - A[i + 1]) * direction < 0) return false;\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean isMonotonic(int[] A) {\\n        int direction = (A[0] <= A[A.length - 1]) ? -1 : 1;\\n        for(int i = 0 ; i < A.length-1 ; i++)\\n            if ((A[i] - A[i + 1]) * direction < 0) return false;\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 165899,
                "title": "a-few-solutions",
                "content": "Return `true` if-and-only-if the input array `A` is *sorted* in **non-increasing** *inclusive-or* **non-decreasing** order.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    var isSorted = { A: IntArray -> A.withIndex().all{ (i, _) -> (0 < i && A[i - 1] <= A[i]) || (i == 0) } }\\n    var isMonotonic = { A: IntArray -> isSorted(A) || isSorted(A.reversed().toIntArray()) }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet isMonotonic = (A, isSorted = A => A.every((_, i) => 0 < i && A[i - 1] <= A[i] || !i)) => isSorted(A) || isSorted(A.reverse());\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    isSorted = lambda self, A: all(A[i - 1] <= A[i] for i in range(1, len(A)))\\n    isMonotonic = lambda self, A: self.isSorted(A) or self.isSorted(A[::-1])\\n```\\n\\n*Rust*\\n```\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn is_monotonic(A: VI) -> bool {\\n        let is_sorted = (|A: &VI| A.iter().enumerate().all(|(i, _)| (0 < i && A[i - 1] <= A[i]) || (i == 0)));\\n        is_sorted(&A) || is_sorted(&A.into_iter().rev().collect::<VI>())\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    bool isMonotonic(VI& A) { return is_sorted(A.begin(), A.end()) || is_sorted(A.rbegin(), A.rend()); }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    var isSorted = { A: IntArray -> A.withIndex().all{ (i, _) -> (0 < i && A[i - 1] <= A[i]) || (i == 0) } }\\n    var isMonotonic = { A: IntArray -> isSorted(A) || isSorted(A.reversed().toIntArray()) }\\n}\\n```\n```\\nlet isMonotonic = (A, isSorted = A => A.every((_, i) => 0 < i && A[i - 1] <= A[i] || !i)) => isSorted(A) || isSorted(A.reverse());\\n```\n```\\nclass Solution:\\n    isSorted = lambda self, A: all(A[i - 1] <= A[i] for i in range(1, len(A)))\\n    isMonotonic = lambda self, A: self.isSorted(A) or self.isSorted(A[::-1])\\n```\n```\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn is_monotonic(A: VI) -> bool {\\n        let is_sorted = (|A: &VI| A.iter().enumerate().all(|(i, _)| (0 < i && A[i - 1] <= A[i]) || (i == 0)));\\n        is_sorted(&A) || is_sorted(&A.into_iter().rev().collect::<VI>())\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    bool isMonotonic(VI& A) { return is_sorted(A.begin(), A.end()) || is_sorted(A.rbegin(), A.rend()); }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4103376,
                "title": "c-one-loop-one-direction-indicator-approach-animation",
                "content": "# Intuition\\n![ezgif.com-video-to-gif (9).gif](https://assets.leetcode.com/users/images/ba3049dd-5d24-4e5e-8177-e6bb8ff93da7_1695965252.3622503.gif)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initializes a variable named **direction** to 0, which represents the direction of monotonicity. A positive value indicates non-decreasing order, a negative value indicates non-increasing order, and 0 indicates that the direction has not been determined yet.\\n\\n1. Enters a loop that iterates over the elements of the vector starting from the second element (i = 1).\\n\\n    Inside the loop, the function checks for violations of monotonicity based on the current direction.\\n\\n    1. If the direction is greater than 0 (indicating non-decreasing order) and the current element nums[i] is less than the previous element nums[i-1], it means the vector is not monotonic. In this case, the function immediately returns **false**.\\n\\n    1. If the direction is less than 0 (indicating non-increasing order) and the current element nums[i] is greater than the previous element nums[i-1], it means the vector is not monotonic. In this case, the function immediately returns **false**.\\n\\n    1. If neither of the above conditions is met, it means the vector is still potentially monotonic. The function then checks if the direction is still 0 (indicating that the direction has not been determined yet). The direction of monotonicity is determine by calculating the difference between the current element nums[i] and the previous element nums[i-1]. This difference is then assigned to direction.\\n\\n    The loop continues until all elements of the vector have been checked.\\n\\n1. After the loop, if no violations of monotonicity have been found, the function returns **true**, indicating that the vector is monotonic.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        int direction = 0;\\n        for(int i = 1; i < nums.size(); i++){\\n            if(direction > 0 && nums[i] < nums[i-1]) return false;\\n            if(direction < 0 && nums[i] > nums[i-1]) return false;\\n            if(direction == 0) direction = nums[i] - nums[i-1];\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\nhttps://youtu.be/P44t-myQXtM",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        int direction = 0;\\n        for(int i = 1; i < nums.size(); i++){\\n            if(direction > 0 && nums[i] < nums[i-1]) return false;\\n            if(direction < 0 && nums[i] > nums[i-1]) return false;\\n            if(direction == 0) direction = nums[i] - nums[i-1];\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2973744,
                "title": "clean-python-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n       inc = True\\n       dec = True\\n       for i in range(1,len(nums)):\\n           inc = inc and nums[i-1] >= nums[i]\\n           dec = dec and nums[i-1] <= nums[i]\\n       return inc or dec\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n       inc = True\\n       dec = True\\n       for i in range(1,len(nums)):\\n           inc = inc and nums[i-1] >= nums[i]\\n           dec = dec and nums[i-1] <= nums[i]\\n       return inc or dec\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 165865,
                "title": "java-straightforward-o-n-solution",
                "content": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] A) {\\n        if(A == null || A.length <= 1) return true;\\n        int[] dir = new int[2]; // inc, dec\\n        for(int i=1;i<A.length;i++){\\n            if(A[i] == A[i-1]) continue;\\n            if(A[i] > A[i-1]) dir[0] = 1;\\n            if(A[i] < A[i-1]) dir[1] = 1;\\n            if(dir[0] == 1 && dir[1] == 1) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] A) {\\n        if(A == null || A.length <= 1) return true;\\n        int[] dir = new int[2]; // inc, dec\\n        for(int i=1;i<A.length;i++){\\n            if(A[i] == A[i-1]) continue;\\n            if(A[i] > A[i-1]) dir[0] = 1;\\n            if(A[i] < A[i-1]) dir[1] = 1;\\n            if(dir[0] == 1 && dir[1] == 1) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4103581,
                "title": "how-to-check-if-an-array-is-monotonic-a-simple-and-efficient-approach-in-c",
                "content": "# Intuition\\nBasically The goal is to determine whether the given array is monotonic,which means it is either entirely non-decreasing or non-increasing. A key observation is that if the array is both increasing and decreasing at any point, it cannot be monotonic.\\n\\n# Approach\\nI\\'ll iterate through the array once, comparing each element with its previous one. While iterating, I\\'ll maintain two boolean variables, increasing and decreasing, to track whether the array is currently considered non-decreasing or non-increasing.\\n\\n1.If nums[i] > nums[i - 1], I\\'ll set decreasing to false because it\\'s not decreasing.\\n2.If nums[i] < nums[i - 1], I\\'ll set increasing to false because it\\'s not increasing.\\n3.If at any point both increasing and decreasing are false, I\\'ll return false since the array is not monotonic.\\n4.After the loop, if either increasing or decreasing (or both) is still true, it means the array is monotonic.\\n\\n# Complexity\\n- Time complexity: O(n), where n is the size of the array, as we iterate through the array once.\\n\\n- Space complexity: O(1), as we use only a constant amount of extra space(two boolean variables).\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        bool increasing = true;\\n        bool decreasing = true;\\n\\n        for (int i = 1; i < nums.size(); i++) {\\n            if (nums[i] > nums[i - 1]) {\\n                decreasing = false;\\n            } else if (nums[i] < nums[i - 1]) {\\n                increasing = false;\\n            }\\n\\n            // If neither increasing not decreasing, array is not monotonic.\\n            if (!increasing && !decreasing) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        bool increasing = true;\\n        bool decreasing = true;\\n\\n        for (int i = 1; i < nums.size(); i++) {\\n            if (nums[i] > nums[i - 1]) {\\n                decreasing = false;\\n            } else if (nums[i] < nums[i - 1]) {\\n                increasing = false;\\n            }\\n\\n            // If neither increasing not decreasing, array is not monotonic.\\n            if (!increasing && !decreasing) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4103134,
                "title": "java-easy-to-understand-two-approaches-single-pass-time-o-n-space-o-1-beats-100",
                "content": "# Approach 1 (Fastest)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can follow a straightforward approach: starting from the first element, we compare adjacent elements to check if they satisfy the required monotonic condition. If the array starts with a smaller element than the last one, we traverse the array to ensure it\\'s monotonically increasing. Otherwise, if it starts with a larger element, we traverse to check for a monotonically decreasing condition.\\n```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        if (nums[0] < nums[nums.length-1]) {\\n            for (int i = 1; i < nums.length; i++) {\\n                if (nums[i] < nums[i-1]) {\\n                    return false;\\n                }\\n            }\\n        } else {\\n            for (int i = 1; i < nums.length; i++) {\\n                if (nums[i] > nums[i-1]) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n# Approach 2 (Beats 60%)\\n<!-- Describe your approach to solving the problem. -->\\nTo check if an array is monotonic, we can use bitwise operations to compare adjacent elements. We maintain two boolean flags, increase and decrease, initially set to true. As we iterate through the array, we update these flags based on the monotonic conditions. If both flags remain true after traversing the entire array, it\\'s monotonic.\\n```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        boolean increase = true, decrease = true;\\n        for (int i = 1; i < nums.length; ++i) {\\n            increase = increase &&(nums[i - 1] <= nums[i]);\\n            decrease = decrease &&(nums[i - 1] >= nums[i]);\\n        }\\n        return increase || decrease;\\n    }\\n}\\n```\\n\\n# Complexity\\nFor both approaches:\\n- Time complexity: `O(n)`, where `n` is the length of the input array nums. In both approaches, we perform a single pass through the array, comparing adjacent elements or using bitwise operations.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(1)`, as we use only a constant amount of extra space for storing boolean flags.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n## Remember to subscribe to my YouTube Channel:\\n\\n[https://youtu.be/iJSd5_WS24E]()\\n# Note \\n- In an interview setting, where code clarity, efficiency, and simplicity are crucial, Approach 2 has an advantage in terms of efficiency and simplicity. It avoids multiple conditional checks and reduces the code complexity, making it a more elegant solution.\\n- It  employs bitwise operations for checking monotonicity, is the preferred choice for interviews, as it not only provides a correct solution but also highlights the candidate\\'s coding skills and optimization techniques.",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        if (nums[0] < nums[nums.length-1]) {\\n            for (int i = 1; i < nums.length; i++) {\\n                if (nums[i] < nums[i-1]) {\\n                    return false;\\n                }\\n            }\\n        } else {\\n            for (int i = 1; i < nums.length; i++) {\\n                if (nums[i] > nums[i-1]) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        boolean increase = true, decrease = true;\\n        for (int i = 1; i < nums.length; ++i) {\\n            increase = increase &&(nums[i - 1] <= nums[i]);\\n            decrease = decrease &&(nums[i - 1] >= nums[i]);\\n        }\\n        return increase || decrease;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960328,
                "title": "java-simple-solution-runtime-1ms-beats100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) \\n    {\\n\\n         int i = 0;\\n\\n        while (i < nums.length - 2  && nums[i] == nums[i+1])\\n            i++;\\n\\n        Boolean cond = (i <= nums.length - 2 && nums[i] <= nums[i + 1] ) ? true : false;\\n\\n        for ( i = 0; i < nums.length - 1 ; i++)\\n        {\\n            if (cond)\\n            {\\n                if ( !(nums[i] <= nums[i+1] ) )\\n                    return false;\\n\\n            }else {\\n                if (!(nums[i] >= nums[i+1]))\\n                    return false;\\n            }\\n        }\\n        return true;\\n        \\n    }\\n}\\n```\\n\\n\\n![e78315ef-8a9d-492b-9908-e3917f23eb31_1674946036.087042.jpeg](https://assets.leetcode.com/users/images/7dc2a05e-73f1-45bf-aaa4-32253a407be2_1693000930.543635.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) \\n    {\\n\\n         int i = 0;\\n\\n        while (i < nums.length - 2  && nums[i] == nums[i+1])\\n            i++;\\n\\n        Boolean cond = (i <= nums.length - 2 && nums[i] <= nums[i + 1] ) ? true : false;\\n\\n        for ( i = 0; i < nums.length - 1 ; i++)\\n        {\\n            if (cond)\\n            {\\n                if ( !(nums[i] <= nums[i+1] ) )\\n                    return false;\\n\\n            }else {\\n                if (!(nums[i] >= nums[i+1]))\\n                    return false;\\n            }\\n        }\\n        return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549682,
                "title": "easy-java-solution-step-by-step-explanation",
                "content": "# Approach\\nThis code is for a method called `isMonotonic` that checks whether an array of integers `nums` is monotonic. A monotonic array is one that is either entirely non-increasing or non-decreasing. Let\\'s break down the code step by step:\\n\\n1. Initialize two boolean variables `increasing` and `decreasing` to false. These variables will be used to track whether the array is increasing or decreasing.\\n\\n2. Start a loop that iterates over the elements of the array `nums`, starting from the second element (`i = 1`) and comparing it with the previous element.\\n\\n3. Inside the loop, check if the current element `nums[i]` is greater than the previous element `nums[i-1]`. If it is, it means the array is increasing at this point.\\n\\n4. If the current element is not greater than the previous element, check if it is less than the previous element. If it is, it means the array is decreasing at this point.\\n\\n5. After examining all the elements in the array, the boolean variables `increasing` and `decreasing` will indicate whether the array is increasing, decreasing, or neither.\\n\\n6. Calculate the final result by checking if both `increasing` and `decreasing` are true. If they are, it means the array has both increasing and decreasing elements, which makes it not monotonic. In this case, assign `false` to the `result` variable. Otherwise, assign `true` to `result`.\\n\\n7. Return the `result` variable, which indicates whether the array `nums` is monotonic or not.\\n\\nIn summary, the code checks each pair of adjacent elements in the array to determine whether the array is increasing or decreasing at any point. If there are elements that cause the array to both increase and decrease, the array is not monotonic. Otherwise, the array is monotonic.\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        boolean increasing = false, decreasing = false;\\n        for (int i=1; i< nums.length; i++){\\n            if (nums[i]>nums[i-1]){\\n                increasing=true;\\n            } else if (nums[i]<nums[i-1]) {\\n                decreasing=true;\\n            }\\n        }\\n        boolean result = (increasing && decreasing) ? false:true;\\n        return result;\\n    }\\n}\\n```\\n**Please upvote if you like the solution.\\nHappy Coding!** \\uD83D\\uDE0A\\n",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        boolean increasing = false, decreasing = false;\\n        for (int i=1; i< nums.length; i++){\\n            if (nums[i]>nums[i-1]){\\n                increasing=true;\\n            } else if (nums[i]<nums[i-1]) {\\n                decreasing=true;\\n            }\\n        }\\n        boolean result = (increasing && decreasing) ? false:true;\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3135435,
                "title": "simple-c-o-n-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUSED VERY SIMPLE APPROACH .\\ncount1 stores if all elements are in increasing order whereas count2 stores all elemnet in decreasing order.\\nif either count1 or count2 equals to size of vector -1 then it is monotonically increasing.\\n\\nHope You Understood.\\n\\nDo{\\n   Please Upvote !!\\n}\\nwhile(you Like the solution);\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTIME COMPLEXITY O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        int count1=0,count2=0;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]<=nums[i+1])count1++;\\n            if(nums[i]>=nums[i+1])count2++;}\\n        if(count1==nums.size()-1 || count2==nums.size()-1)return true;\\n        else return false;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        int count1=0,count2=0;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]<=nums[i+1])count1++;\\n            if(nums[i]>=nums[i+1])count2++;}\\n        if(count1==nums.size()-1 || count2==nums.size()-1)return true;\\n        else return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3095918,
                "title": "1ms-100-java-enough-fast-solution-2023",
                "content": "\\t* class Solution {\\n\\t\\t public boolean isMonotonic(int[] nums) {\\n\\t\\t\\tif (nums.length > 2) {\\n\\t\\t\\t\\tif (nums[0] > nums[nums.length - 1]) {\\n\\t\\t\\t\\t\\treturn decreasing(nums);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\treturn increasing(nums);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tboolean increasing(int[] nums) {\\n\\t\\t\\tint i = 1;\\n\\t\\t\\twhile (nums.length > i) {\\n\\t\\t\\t\\tif (nums[i] < nums[i - 1]) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\tboolean decreasing(int[] nums) {\\n\\t\\t\\tint i = 1;\\n\\t\\t\\twhile (nums.length > i) {\\n\\t\\t\\t\\tif (nums[i] > nums[i -1]) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n\\t\\t public boolean isMonotonic(int[] nums) {\\n\\t\\t\\tif (nums.length > 2) {\\n\\t\\t\\t\\tif (nums[0] > nums[nums.length - 1]) {\\n\\t\\t\\t\\t\\treturn decreasing(nums);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3530343,
                "title": "java-xor-monotonic-array",
                "content": "\\n```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        int i = 1;\\n        int diff = 0;\\n        while (i < nums.length && nums[0] == nums[i])\\n            i++;\\n        if (i < nums.length) diff = nums[0] - nums[i];\\n        while (i < nums.length) {\\n            if (nums[i - 1] != nums[i] && ((nums[i - 1] - nums[i]) <= 0 ^ diff < 0))\\n                return false;\\n            i++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        int i = 1;\\n        int diff = 0;\\n        while (i < nums.length && nums[0] == nums[i])\\n            i++;\\n        if (i < nums.length) diff = nums[0] - nums[i];\\n        while (i < nums.length) {\\n            if (nums[i - 1] != nums[i] && ((nums[i - 1] - nums[i]) <= 0 ^ diff < 0))\\n                return false;\\n            i++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2465941,
                "title": "python-c-java-beginner-level-as-simple-as-u-think-simple-short-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome*.**\\n___________________\\n_________________\\n***Q896. Monotonic Array***\\nAn array is monotonic if it is either monotone increasing or monotone decreasing.\\n\\nAn array `nums` is monotone increasing if for all` i <= j, nums[i] <= nums[j]`. An array nums is monotone decreasing if for all `i <= j, nums[i] >= nums[j]`.\\n\\nGiven an integer array `nums`, return `true` if the given array is monotonic, or `false` otherwise.\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Python  Code** :\\n```\\nclass Solution:\\n    def isMonotonic(self, A: List[int]) -> bool:\\n        inc = True\\n        dec = True\\n        for i in range(len(A)-1):\\n            if A[i] > A[i+1]:\\n                inc = False\\n                \\n            if A[i] < A[i+1]:\\n                dec = False\\n                \\n        return inc or dec\\n        \\n```\\n**Runtime:**  1099 ms\\t\\n**Memory Usage:**  23.9 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\n\\u2705 **Java Code** :\\n```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n       boolean inc=true,dec=true;\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            if (nums[i]>nums[i+1])\\n                inc=false;\\n            \\n            if(nums[i]<nums[i+1])\\n                dec =false;\\n            if(inc==false && dec==false) return false;   \\n        }\\n        return true;  \\n    }\\n}\\n```\\n**Runtime:**  3 ms\\t\\t\\n**Memory Usage:**  92.8 MB\\t\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **C++  Code** :\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n     bool inc=true,dec=true;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if (nums[i]>nums[i+1])\\n                inc=false;\\n            \\n            if(nums[i]<nums[i+1])\\n                dec =false;\\n            if(inc==false && dec==false) return false;   \\n        }\\n        return true;\\n        \\n    }\\n};\\n```\\n**Runtime:** 156 ms\\t\\n**Memory Usage:**  96.5 MB\\t\\t\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def isMonotonic(self, A: List[int]) -> bool:\\n        inc = True\\n        dec = True\\n        for i in range(len(A)-1):\\n            if A[i] > A[i+1]:\\n                inc = False\\n                \\n            if A[i] < A[i+1]:\\n                dec = False\\n                \\n        return inc or dec\\n        \\n```\n```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n       boolean inc=true,dec=true;\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            if (nums[i]>nums[i+1])\\n                inc=false;\\n            \\n            if(nums[i]<nums[i+1])\\n                dec =false;\\n            if(inc==false && dec==false) return false;   \\n        }\\n        return true;  \\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n     bool inc=true,dec=true;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if (nums[i]>nums[i+1])\\n                inc=false;\\n            \\n            if(nums[i]<nums[i+1])\\n                dec =false;\\n            if(inc==false && dec==false) return false;   \\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 165866,
                "title": "java-1-pass-7-lines-straight-forward-code",
                "content": "1. Loop through A, only consider those non-equal neighbors (strictly bigger or smaller relations), and count them. \\n2. When count >= 2, check if the bigger (smaller) relation changes; if yes, return false; otherwise, continue.\\n3. return true if no false encounterd.\\n\\n```\\n    public boolean isMonotonic(int[] A) {\\n        boolean smaller = false;\\n        for (int i = 0, count = 0; i < A.length - 1; ++i) {\\n            if (A[i] == A[i + 1]) { continue; } // ignore those equal ones.\\n            if (++count >= 2 && smaller != (A[i] < A[i + 1])) { return false; }\\n            smaller = (A[i] < A[i + 1]); \\n        }\\n        return true;\\n    }\\n``",
                "solutionTags": [],
                "code": "1. Loop through A, only consider those non-equal neighbors (strictly bigger or smaller relations), and count them. \\n2. When count >= 2, check if the bigger (smaller) relation changes; if yes, return false; otherwise, continue.\\n3. return true if no false encounterd.\\n\\n```\\n    public boolean isMonotonic(int[] A) {\\n        boolean smaller = false;\\n        for (int i = 0, count = 0; i < A.length - 1; ++i) {\\n            if (A[i] == A[i + 1]) { continue; } // ignore those equal ones.\\n            if (++count >= 2 && smaller != (A[i] < A[i + 1])) { return false; }\\n            smaller = (A[i] < A[i + 1]); \\n        }\\n        return true;\\n    }\\n``",
                "codeTag": "Unknown"
            },
            {
                "id": 4103731,
                "title": "easisiet-c-solution-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        bool isMonotonic=0;\\n        int f=0;\\n\\n        for(int i=1;i<nums.size();i++){    //for monotonic increasing\\n            if(nums[i]<nums[i-1]){        //if curr value is less than previous value\\n                f=1;\\n                break;\\n            }\\n        }\\n\\n        if(f==0)\\n        return 1;\\n\\n        f=0;\\n\\n        for(int i=1;i<nums.size();i++){   //for monotonic decreasing\\n            if(nums[i]>nums[i-1]){        //if curr value is greater than previous value\\n                f=1;\\n                return 0;\\n            }\\n        }\\n\\n        return 1;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        bool isMonotonic=0;\\n        int f=0;\\n\\n        for(int i=1;i<nums.size();i++){    //for monotonic increasing\\n            if(nums[i]<nums[i-1]){        //if curr value is less than previous value\\n                f=1;\\n                break;\\n            }\\n        }\\n\\n        if(f==0)\\n        return 1;\\n\\n        f=0;\\n\\n        for(int i=1;i<nums.size();i++){   //for monotonic decreasing\\n            if(nums[i]>nums[i-1]){        //if curr value is greater than previous value\\n                f=1;\\n                return 0;\\n            }\\n        }\\n\\n        return 1;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4102839,
                "title": "easy-loop-vs-c-adjacent-difference-count-if-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTraverse once and compute `d=nums[i+1]-nums[i]`. Initialize boolean variables `greate=false, less=false`.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nif `d>0` set `greater=true` else if `d<0` set `less=true`.\\nif both of `greater` & `less` are set, return false, because there are some i, j such that `nums[i+1]-nums[i]` & `nums[j+1]-nums[j]` have the different signs.\\n\\nWhen the loop is through, return true.\\n\\n2nd approach uses C++ adjacent_difference. So it is a 2 pass solution!\\n\\n3rd aproach uses C++ adjacent_difference & count_if which might overkill!\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```python []\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        greater, less=False, False\\n        n=len(nums)\\n        for i in range(n-1):\\n            d=nums[i+1]-nums[i]\\n            if d>0: greater=True\\n            elif d<0: less=True\\n            if greater and less: return False\\n        return True\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        bool greater=0, less=0;\\n        int n=nums.size();\\n        for(int i=0; i<n-1; i++){\\n            int d=nums[i+1]-nums[i];\\n            if (d>0) greater=1;\\n            else if (d<0) less=1;\\n            if (greater && less) return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```\\n```C []\\nbool isMonotonic(int* nums, int numsSize){\\n    bool greater=0, less=0;\\n    for(register int i=0; i<numsSize-1; i++){\\n        int d=nums[i+1]-nums[i];\\n        if (d>0) greater=1;\\n        else if (d<0) less=1;\\n        if (greater && less) return 0;\\n    }\\n    return 1;\\n}\\n```\\n```Java []\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        boolean greater=false, less=false;\\n        int n=nums.length;\\n        for(int i=0; i<n-1; i++){\\n            int d=nums[i+1]-nums[i];\\n            if (d>0) greater=true;\\n            else if (d<0) less=true;\\n            if (greater && less) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\n```C# []\\npublic class Solution {\\n    public bool IsMonotonic(int[] nums) {\\n        bool greater=false, less=false;\\n        int n=nums.Length;\\n        for(int i=0; i<n-1; i++){\\n            int d=nums[i+1]-nums[i];\\n            if (d>0) greater=true;\\n            else if (d<0) less=true;\\n            if (greater && less) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\n# Code using C++ adjacent_difference Runtime 61 ms Beats 100%\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        //C++ adjacent_difference\\n        //nums[i]=nums[i]-nums[i-1] for i>0 nums[0]=nums[0]\\n        adjacent_difference(nums.begin(), nums.end(), nums.begin());\\n        nums[0]=0;//Modify nums[0]=0\\n\\n        bool greater=0, less=0;\\n        #pragma unroll\\n        for(int d: nums){\\n            if (d>0) greater=1;\\n            else if (d<0) less=1;\\n            if (greater && less) return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```\\n# Code using adjacent_difference & count_if Runtime 88 ms Beats 99.18%\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        //C++ adjacent_difference\\n        //nums[i]=nums[i]-nums[i-1] for i>0 nums[0]=nums[0]\\n        adjacent_difference(nums.begin(), nums.end(), nums.begin());\\n        nums[0]=0;//Modify nums[0]=0\\n\\n        int greater0=count_if(nums.begin(), nums.end(), [](int x){return x>0;});\\n        int less0=count_if(nums.begin(), nums.end(), [](int x){return x<0;});\\n\\n        return (greater0>0&& less0>0)?0:1;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C",
                    "C#",
                    "Array"
                ],
                "code": "```python []\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        greater, less=False, False\\n        n=len(nums)\\n        for i in range(n-1):\\n            d=nums[i+1]-nums[i]\\n            if d>0: greater=True\\n            elif d<0: less=True\\n            if greater and less: return False\\n        return True\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        bool greater=0, less=0;\\n        int n=nums.size();\\n        for(int i=0; i<n-1; i++){\\n            int d=nums[i+1]-nums[i];\\n            if (d>0) greater=1;\\n            else if (d<0) less=1;\\n            if (greater && less) return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```\n```C []\\nbool isMonotonic(int* nums, int numsSize){\\n    bool greater=0, less=0;\\n    for(register int i=0; i<numsSize-1; i++){\\n        int d=nums[i+1]-nums[i];\\n        if (d>0) greater=1;\\n        else if (d<0) less=1;\\n        if (greater && less) return 0;\\n    }\\n    return 1;\\n}\\n```\n```Java []\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        boolean greater=false, less=false;\\n        int n=nums.length;\\n        for(int i=0; i<n-1; i++){\\n            int d=nums[i+1]-nums[i];\\n            if (d>0) greater=true;\\n            else if (d<0) less=true;\\n            if (greater && less) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\n```C# []\\npublic class Solution {\\n    public bool IsMonotonic(int[] nums) {\\n        bool greater=false, less=false;\\n        int n=nums.Length;\\n        for(int i=0; i<n-1; i++){\\n            int d=nums[i+1]-nums[i];\\n            if (d>0) greater=true;\\n            else if (d<0) less=true;\\n            if (greater && less) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        //C++ adjacent_difference\\n        //nums[i]=nums[i]-nums[i-1] for i>0 nums[0]=nums[0]\\n        adjacent_difference(nums.begin(), nums.end(), nums.begin());\\n        nums[0]=0;//Modify nums[0]=0\\n\\n        bool greater=0, less=0;\\n        #pragma unroll\\n        for(int d: nums){\\n            if (d>0) greater=1;\\n            else if (d<0) less=1;\\n            if (greater && less) return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        //C++ adjacent_difference\\n        //nums[i]=nums[i]-nums[i-1] for i>0 nums[0]=nums[0]\\n        adjacent_difference(nums.begin(), nums.end(), nums.begin());\\n        nums[0]=0;//Modify nums[0]=0\\n\\n        int greater0=count_if(nums.begin(), nums.end(), [](int x){return x>0;});\\n        int less0=count_if(nums.begin(), nums.end(), [](int x){return x<0;});\\n\\n        return (greater0>0&& less0>0)?0:1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2355132,
                "title": "python-easy-solution-beats-97-24",
                "content": "```\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        a = sorted(nums)\\n        b = sorted(nums,reverse=True)\\n        if nums == a or nums == b:\\n            return True\\n        return False\\n```\\n**.\\n.\\n.\\n.\\n<<< Please Up-vote if you find it useful >>>**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        a = sorted(nums)\\n        b = sorted(nums,reverse=True)\\n        if nums == a or nums == b:\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1681208,
                "title": "python-one-pass",
                "content": "```\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        inc = dec = True\\n        for i in range(len(nums)-1):\\n            if nums[i] > nums[i+1]:\\n                inc = False\\n                if dec == False: return False\\n            if nums[i] < nums[i+1]:\\n                dec = False\\n                if inc == False: return False\\n\\n        return True if dec or inc else False\\n       \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        inc = dec = True\\n        for i in range(len(nums)-1):\\n            if nums[i] > nums[i+1]:\\n                inc = False\\n                if dec == False: return False\\n            if nums[i] < nums[i+1]:\\n                dec = False\\n                if inc == False: return False\\n\\n        return True if dec or inc else False\\n       \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 811494,
                "title": "javascript-one-pass-o-n-time-o-1-space",
                "content": "```\\nvar isMonotonic = function(A) {\\n    \\n    let increasing = true \\n    let decreasing = true \\n    \\n    for(let i=0; i<A.length -1; i++){\\n        if(A[i] > A[i+1]){\\n            increasing = false\\n        }\\n        if(A[i] < A[i+1]){\\n            decreasing = false\\n        }\\n        \\n    }\\n    \\n    return increasing || decreasing \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isMonotonic = function(A) {\\n    \\n    let increasing = true \\n    let decreasing = true \\n    \\n    for(let i=0; i<A.length -1; i++){\\n        if(A[i] > A[i+1]){\\n            increasing = false\\n        }\\n        if(A[i] < A[i+1]){\\n            decreasing = false\\n        }\\n        \\n    }\\n    \\n    return increasing || decreasing \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 206729,
                "title": "python-solution-beats-95",
                "content": "```\\nclass Solution:\\n    def isMonotonic(self, A):\\n        if len(A) == 1:\\n            return True\\n        increasing = True if A[-1] > A[0] else False\\n        prev = A[0]\\n        if increasing:\\n            for i in range(1, len(A)):\\n                if A[i] < prev:\\n                    return False\\n                prev = A[i]\\n        else:\\n            for i in range(1, len(A)):\\n                if A[i] > prev:\\n                    return False\\n                prev = A[i]\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isMonotonic(self, A):\\n        if len(A) == 1:\\n            return True\\n        increasing = True if A[-1] > A[0] else False\\n        prev = A[0]\\n        if increasing:\\n            for i in range(1, len(A)):\\n                if A[i] < prev:\\n                    return False\\n                prev = A[i]\\n        else:\\n            for i in range(1, len(A)):\\n                if A[i] > prev:\\n                    return False\\n                prev = A[i]\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 165861,
                "title": "clean-code",
                "content": "```\\npublic boolean isMonotonic(int[] array) {\\n    return isNotDecreasing(array) || isNotIncreasing(array);\\n}\\n\\nprivate boolean isNotIncreasing(int[] array) {\\n    for (int i = 0; i < array.length - 1; i++) {\\n        if (array[i] < array[i + 1])\\n            return false;\\n    }\\n    return true;\\n}\\n\\nprivate boolean isNotDecreasing(int[] array) {\\n    for (int i = 0; i < array.length - 1; i++) {\\n        if (array[i] > array[i + 1])\\n            return false;\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean isMonotonic(int[] array) {\\n    return isNotDecreasing(array) || isNotIncreasing(array);\\n}\\n\\nprivate boolean isNotIncreasing(int[] array) {\\n    for (int i = 0; i < array.length - 1; i++) {\\n        if (array[i] < array[i + 1])\\n            return false;\\n    }\\n    return true;\\n}\\n\\nprivate boolean isNotDecreasing(int[] array) {\\n    for (int i = 0; i < array.length - 1; i++) {\\n        if (array[i] > array[i + 1])\\n            return false;\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4103042,
                "title": "detailed-explanation-with-100-acceptance-rate-c-optimised-approach-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this code is to determine whether the given array is monotonic, i.e., either monotone increasing or monotone decreasing. To do this efficiently, the code iterates through the array while tracking the direction of monotonicity. It returns true if the array is monotonic and false if it is not.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize a variable direction to 0, which will be used to track the direction of monotonicity. A value of 0 indicates that the direction is undetermined, 1 indicates increasing, and -1 indicates decreasing.\\n\\n2. Check if the size of the input array nums is less than or equal to 1. If it is, return true because a single-element array is considered monotonic.\\n\\n3. Iterate through the array nums starting from the second element (index 1) to the end.\\n\\n4. In each iteration, calculate the difference diff between the current element and the previous element (i.e., nums[i] - nums[i - 1]).\\n\\n5. Based on the value of diff, update the direction variable:\\n\\n- If diff is greater than 0, it means the array is increasing. Check if the direction was previously set to -1 (decreasing). If it was, return false because the array is not monotonic. Otherwise, update direction to 1 (increasing).\\n\\n- If diff is less than 0, it means the array is decreasing. Check if the direction was previously set to 1 (increasing). If it was, return false because the array is not monotonic. Otherwise, update direction to -1 (decreasing).\\n\\n6. If diff is equal to 0, it means the current and previous elements are equal. In this case, we continue to the next element without changing the direction.\\n\\n7. After the loop, if we have not encountered a situation where direction changed from the initial undetermined state (0), it means the array is either entirely increasing or entirely decreasing, and we return true. Otherwise, we return false.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe code iterates through the input array nums once, comparing each element with the previous one. The time complexity is O(n), where n is the number of elements in the array.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe code uses a constant amount of extra space for variables (direction, n). Therefore, the space complexity is O(1), indicating constant space usage regardless of the input array\\'s size.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        if (n <= 1) {\\n            return true; // A single element array is considered monotonic.\\n        }\\n        \\n        int direction = 0; // 0: undetermined, 1: increasing, -1: decreasing\\n        \\n        for (int i = 1; i < n; i++) {\\n            int diff = nums[i] - nums[i - 1];\\n            \\n            if (diff > 0) {\\n                if (direction == -1) {\\n                    return false; // Not monotonic if it was decreasing before.\\n                }\\n                direction = 1;\\n            } else if (diff < 0) {\\n                if (direction == 1) {\\n                    return false; // Not monotonic if it was increasing before.\\n                }\\n                direction = -1;\\n            }\\n            // If diff == 0, continue to the next element.\\n        }\\n        \\n        return true;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "Array",
                    "Two Pointers",
                    "Tree",
                    "Sliding Window",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        if (n <= 1) {\\n            return true; // A single element array is considered monotonic.\\n        }\\n        \\n        int direction = 0; // 0: undetermined, 1: increasing, -1: decreasing\\n        \\n        for (int i = 1; i < n; i++) {\\n            int diff = nums[i] - nums[i - 1];\\n            \\n            if (diff > 0) {\\n                if (direction == -1) {\\n                    return false; // Not monotonic if it was decreasing before.\\n                }\\n                direction = 1;\\n            } else if (diff < 0) {\\n                if (direction == 1) {\\n                    return false; // Not monotonic if it was increasing before.\\n                }\\n                direction = -1;\\n            }\\n            // If diff == 0, continue to the next element.\\n        }\\n        \\n        return true;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4102998,
                "title": "easy-c-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        bool flag=true,flag1=true;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(nums[i]>nums[i+1])\\n            flag=false; \\n        }\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(nums[i]<nums[i+1])\\n            flag1=false; \\n        }\\n        if(flag==true)\\n            return flag;\\n        else if(flag1==true)\\n            return flag1;\\n        else\\n            return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        bool flag=true,flag1=true;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(nums[i]>nums[i+1])\\n            flag=false; \\n        }\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(nums[i]<nums[i+1])\\n            flag1=false; \\n        }\\n        if(flag==true)\\n            return flag;\\n        else if(flag1==true)\\n            return flag1;\\n        else\\n            return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4102818,
                "title": "daily-leetcoding-challenge-september-day-29",
                "content": "This problem is the Daily LeetCoding Challenge for September, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/monotonic-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Pass\n\n  \n**Approach 2:** One Pass\n\n  \n**Approach 3:** One Pass (Simple Variant)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/monotonic-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n**Approach 3:** One Pass (Simple Variant)\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3741853,
                "title": "simplest-o-n-6-line-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nTime Complexity is O(N)\\n\\n- Space complexity:\\nSpace Complexity is O(N) since we are not using any extra space\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        int n = nums.size();\\n        int cntp=0,cntn=0;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(nums[i]<=nums[i+1])cntp++;\\n            if(nums[i]>=nums[i+1])cntn++;\\n        }\\n        return cntn==n-1 || cntp==n-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        int n = nums.size();\\n        int cntp=0,cntn=0;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(nums[i]<=nums[i+1])cntp++;\\n            if(nums[i]>=nums[i+1])cntn++;\\n        }\\n        return cntn==n-1 || cntp==n-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3666524,
                "title": "java-simple-and-easy-to-understand-solution",
                "content": "class Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        int c=0;int k=0;\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            if(nums[i+1]>=nums[i])\\n                c++;\\n             if(nums[i]>=nums[i+1])\\n                k++;\\n        }\\n        if(c==nums.length-1||k==nums.length-1)\\n            return true;\\n        else\\n            return false;\\n       \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        int c=0;int k=0;\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            if(nums[i+1]>=nums[i])\\n                c++;\\n             if(nums[i]>=nums[i+1])\\n                k++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3638306,
                "title": "c-using-bitwise-operator-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        int n = nums.size();\\n        bool isIncreasing = false, isDecreasing = false;\\n        for(int i = 0; i < n-1; i++) {\\n            if(nums[i] < nums[i+1])\\n                isIncreasing = true;\\n            else if(nums[i] > nums[i+1])\\n                isDecreasing = true;\\n            if(isIncreasing & isDecreasing) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        int n = nums.size();\\n        bool isIncreasing = false, isDecreasing = false;\\n        for(int i = 0; i < n-1; i++) {\\n            if(nums[i] < nums[i+1])\\n                isIncreasing = true;\\n            else if(nums[i] > nums[i+1])\\n                isDecreasing = true;\\n            if(isIncreasing & isDecreasing) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2343378,
                "title": "beginner-friendly-java-javascript-python-soluton",
                "content": "**Time Complexity : O(n)**\\n**Java**\\n```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        boolean monotone_increasing = true, monotone_decreasing = true;\\n        for(int i=1; i<nums.length; i++){\\n            if(nums[i] > nums[i-1]) monotone_decreasing = false;\\n            if(nums[i] < nums[i-1]) monotone_increasing = false;\\n        }\\n        return monotone_increasing || monotone_decreasing;\\n    }\\n}\\n```\\n**JavaScrpit**\\n```\\nvar isMonotonic = function(nums) {\\n    let monotone_increasing = true, monotone_decreasing = true\\n    for(let i=1; i<nums.length; i++){\\n        if(nums[i] > nums[i-1]) monotone_decreasing = false\\n        if(nums[i] < nums[i-1]) monotone_increasing = false\\n    }\\n    return monotone_increasing || monotone_decreasing\\n};\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def isMonotonic(self, nums):\\n        monotone_increasing = monotone_decreasing = True\\n        for i in range(1, len(nums)):\\n            if nums[i] > nums[i-1]:\\n                monotone_decreasing = False\\n            if nums[i] < nums[i-1] :\\n                monotone_increasing = False\\n        return monotone_increasing or monotone_decreasing\\n```",
                "solutionTags": [
                    "Java",
                    "Python"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        boolean monotone_increasing = true, monotone_decreasing = true;\\n        for(int i=1; i<nums.length; i++){\\n            if(nums[i] > nums[i-1]) monotone_decreasing = false;\\n            if(nums[i] < nums[i-1]) monotone_increasing = false;\\n        }\\n        return monotone_increasing || monotone_decreasing;\\n    }\\n}\\n```\n```\\nvar isMonotonic = function(nums) {\\n    let monotone_increasing = true, monotone_decreasing = true\\n    for(let i=1; i<nums.length; i++){\\n        if(nums[i] > nums[i-1]) monotone_decreasing = false\\n        if(nums[i] < nums[i-1]) monotone_increasing = false\\n    }\\n    return monotone_increasing || monotone_decreasing\\n};\\n```\n```\\nclass Solution(object):\\n    def isMonotonic(self, nums):\\n        monotone_increasing = monotone_decreasing = True\\n        for i in range(1, len(nums)):\\n            if nums[i] > nums[i-1]:\\n                monotone_decreasing = False\\n            if nums[i] < nums[i-1] :\\n                monotone_increasing = False\\n        return monotone_increasing or monotone_decreasing\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2234155,
                "title": "python-simple-one-pass-solution",
                "content": "This solution in a **single** **pass** is able to compare the current element and the previous element and just sets the boolean values of our flags as we go ahead. \\n\\n**Time Complexity = O(n)** as we traverse through each element of the array **nums** only once.\\n**Space Complexity = O(1)** as we don\\'t use extra memory.\\n\\n```\\n\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        # Time Complexity = O(n) and Space Complexity = O(1)\\n        isNonDecreasing = True\\n        isNonIncreasing = True\\n        \\n        for i in range(1, len(nums)):\\n            if nums[i] > nums[i-1]:\\n                isNonDecreasing = False\\n            if nums[i] < nums[i-1]:\\n                isNonIncreasing = False\\n                \\n        return isNonDecreasing or isNonIncreasing\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        # Time Complexity = O(n) and Space Complexity = O(1)\\n        isNonDecreasing = True\\n        isNonIncreasing = True\\n        \\n        for i in range(1, len(nums)):\\n            if nums[i] > nums[i-1]:\\n                isNonDecreasing = False\\n            if nums[i] < nums[i-1]:\\n                isNonIncreasing = False\\n                \\n        return isNonDecreasing or isNonIncreasing\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2145287,
                "title": "java-simple-and-easy-to-understand-solution",
                "content": "```\\npublic boolean isMonotonic(int[] nums) {\\n    if (nums.length <= 1) return true;\\n    int m = 0, n = 0;\\n    for (int i = 1; i < nums.length; i++) {\\n        if (nums[i] >= nums[i-1]) m++;\\n        if (nums[i] <= nums[i-1]) n++;\\n    }\\n    if (m == nums.length - 1) return true;\\n    else if (n == nums.length - 1) return true;\\n    else return false;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean isMonotonic(int[] nums) {\\n    if (nums.length <= 1) return true;\\n    int m = 0, n = 0;\\n    for (int i = 1; i < nums.length; i++) {\\n        if (nums[i] >= nums[i-1]) m++;\\n        if (nums[i] <= nums[i-1]) n++;\\n    }\\n    if (m == nums.length - 1) return true;\\n    else if (n == nums.length - 1) return true;\\n    else return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2070573,
                "title": "java-easy-o-n-faster-solution",
                "content": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        int n = nums.length;\\n        boolean ans1 = true;\\n        boolean ans2 = true;\\n        \\n        for(int i=0;i<n-1;i++){\\n            if(nums[i]<nums[i+1]) ans1 = false;\\n            if(nums[i]>nums[i+1]) ans2 = false;\\n        }\\n        \\n        return ans1 || ans2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        int n = nums.length;\\n        boolean ans1 = true;\\n        boolean ans2 = true;\\n        \\n        for(int i=0;i<n-1;i++){\\n            if(nums[i]<nums[i+1]) ans1 = false;\\n            if(nums[i]>nums[i+1]) ans2 = false;\\n        }\\n        \\n        return ans1 || ans2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 820839,
                "title": "c-super-simple-solution",
                "content": "**Like it? please upvote...**\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& A) {\\n        if (A.size() <= 2) return true; // two numbers are always monotonous\\n        int i=0;\\n        while ((i < A.size()-1) && (A[i] == A[i+1]))\\n            i++;\\n        if (i == A.size()-1) return true; // reached end of array with only equal numbers\\n        bool is_increase = A[i] < A[i+1] ? true : false; // is array increasing or decreasing?\\n        while (i < A.size()-1)\\n        {\\n            if ((is_increase == false) && (A[i] < A[i+1])) return false;\\n            if ((is_increase == true) && (A[i] > A[i+1])) return false;\\n            i++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& A) {\\n        if (A.size() <= 2) return true; // two numbers are always monotonous\\n        int i=0;\\n        while ((i < A.size()-1) && (A[i] == A[i+1]))\\n            i++;\\n        if (i == A.size()-1) return true; // reached end of array with only equal numbers\\n        bool is_increase = A[i] < A[i+1] ? true : false; // is array increasing or decreasing?\\n        while (i < A.size()-1)\\n        {\\n            if ((is_increase == false) && (A[i] < A[i+1])) return false;\\n            if ((is_increase == true) && (A[i] > A[i+1])) return false;\\n            i++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4103623,
                "title": "c-easy-solution",
                "content": "# Intuition\\nWe will tarverse through array and will store the value if it is increasing or decreasing.\\n\\n# Approach\\nWe will declare two variable inc and dec and intialise them with false ...if array is increasing we will set inc to true and if decreasing we will set dec to true..Then after full iteration if both are true this mean that array is not monotonic else array is monotonic.\\n\\n# Complexity\\n- Time complexity:\\n0(n) , where n is size of array\\n\\n- Space complexity:\\n0(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        bool inc = false;\\n        bool dec = false;\\n        int n = nums.size();\\n        for(int i=0;i<n-1;i++){\\n            if(nums[i]>nums[i+1]){\\n                dec=true;  // array decreasing\\n            } else if(nums[i]<nums[i+1]){\\n                inc = true;   // array increasing\\n            }\\n        }\\n\\n        if(dec && inc) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        bool inc = false;\\n        bool dec = false;\\n        int n = nums.size();\\n        for(int i=0;i<n-1;i++){\\n            if(nums[i]>nums[i+1]){\\n                dec=true;  // array decreasing\\n            } else if(nums[i]<nums[i+1]){\\n                inc = true;   // array increasing\\n            }\\n        }\\n\\n        if(dec && inc) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4103381,
                "title": "noob-code-easy-to-understand",
                "content": "\\n# Approach\\n1. `o` is initialized to `False`. This variable will be used to store the result indicating whether the list is monotonic.\\n\\n2. An empty list `k` is initialized.\\n\\n3. A loop is used to iterate through each element `i` in the input list `nums`. Inside the loop, each element `i` is appended to the list `k`.\\n\\n4. The list `k` is sorted in ascending order using `k.sort()`. This sorting operation doesn\\'t modify the original `nums` list.\\n\\n5. The code checks if the first element of the sorted list `k` is equal to the last element of the input `nums`. This comparison is used to determine whether the list is non-increasing or non-decreasing. If they are equal, it suggests that the list is non-increasing, and if they are not equal, it suggests that the list is non-decreasing.\\n\\n6. Two separate loops are used based on the comparison result:\\n   - If `k[0] == nums[-1]`, it means the list is non-increasing. In this case, a loop iterates through the `nums` list from the first element to the second-to-last element. If it finds any element that is greater than or equal to the next element, it sets `o` to `True`, indicating that the list is non-increasing. If any element is less than the next element, it sets `o` to `False` and breaks the loop.\\n   - If `k[0] != nums[-1]`, it means the list is non-decreasing. In this case, a loop iterates through the `nums` list from the first element to the second-to-last element. If it finds any element that is less than or equal to the next element, it sets `o` to `True`, indicating that the list is non-decreasing. If any element is greater than the next element, it sets `o` to `False` and breaks the loop.\\n\\n7. There\\'s a special case check for lists with only one element (`len(nums) == 1`). In this case, the list is considered monotonic by default, so `o` is set to `True`.\\n\\n8. Finally, the function returns the value of `o`, which indicates whether the input list `nums` is monotonic or not.\\n\\n\\n# Complexity\\n- Time complexity: ***O(n x log(n))*** \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: ***o(n)***\\n\\n# Code\\n```\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        o=False\\n        k=[]\\n        for i in nums:\\n            k.append(i)\\n        k.sort()\\n        if(k[0]==nums[-1]):\\n            for i in range(len(nums)-1):\\n                print(1)\\n                if nums[i]>=nums[i+1]:\\n                    o=True\\n                else:\\n                    o=False\\n                    break\\n        else:\\n            for i in range(len(nums)-1):\\n                print(nums[i])\\n                if nums[i]<=nums[i+1]:\\n                    o=True\\n                else:\\n                    o=False\\n                    break\\n        if(len(nums)==1):\\n            o=True\\n        return(o)\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        o=False\\n        k=[]\\n        for i in nums:\\n            k.append(i)\\n        k.sort()\\n        if(k[0]==nums[-1]):\\n            for i in range(len(nums)-1):\\n                print(1)\\n                if nums[i]>=nums[i+1]:\\n                    o=True\\n                else:\\n                    o=False\\n                    break\\n        else:\\n            for i in range(len(nums)-1):\\n                print(nums[i])\\n                if nums[i]<=nums[i+1]:\\n                    o=True\\n                else:\\n                    o=False\\n                    break\\n        if(len(nums)==1):\\n            o=True\\n        return(o)\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4103044,
                "title": "detailed-explanation-with-solution-using-two-pointer-approach-o-n-with-100-acceptance-rate",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this code is to determine whether the given array is monotonic, i.e., either monotone increasing or monotone decreasing. It uses a two-pointer approach to skip identical elements at the beginning and end of the array and then checks if the remaining elements are consistent with either a monotone increasing or decreasing pattern.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Check if the size of the input array nums is less than or equal to 1. If it is, return true because a single-element array is considered monotonic.\\n\\n2. Initialize two pointers, left and right, initially pointing to the first and last elements of the array, respectively.\\n\\n3. Use the left pointer to skip identical elements at the beginning of the array. Increment left while the current element is equal to the next element.\\n\\n4. Use the right pointer to skip identical elements at the end of the array. Decrement right while the current element is equal to the previous element.\\n\\n5. Check if left is greater than or equal to right. If it is, it means all elements in the array are identical, and the array is considered monotonic. Return true.\\n\\n6. Determine whether the array is increasing or decreasing based on the values at left and left + 1.\\n\\n7. Iterate from left to right - 1 and compare each element with its next element:\\n\\n- If the array is increasing and the current element is greater than the next element, return false (not monotonic).\\n\\n- If the array is decreasing and the current element is less than the next element, return false (not monotonic).\\n8. If the loop completes without returning false, return true because the array is monotonic.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe code iterates through the input array nums once, either from left to right or from right to left, depending on the direction of monotonicity. The time complexity is O(n), where n is the number of elements in the array.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe code uses a constant amount of extra space for variables (left, right, n). Therefore, the space complexity is O(1), indicating constant space usage regardless of the input array\\'s size.\\n\\n# Do Upvote if you liked the explanation \\uD83E\\uDD1E\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        if (n <= 1) {\\n            return true; // A single element array is considered monotonic.\\n        }\\n        \\n        int left = 0;\\n        int right = n - 1;\\n        \\n        while (left < n - 1 && nums[left] == nums[left + 1]) {\\n            left++; // Skip identical elements at the beginning.\\n        }\\n        \\n        while (right > 0 && nums[right] == nums[right - 1]) {\\n            right--; // Skip identical elements at the end.\\n        }\\n        \\n        if (left >= right) {\\n            return true; // All elements are identical; the array is monotonic.\\n        }\\n        \\n        bool increasing = nums[left] < nums[left + 1];\\n        \\n        for (int i = left; i < right; i++) {\\n            if (increasing && nums[i] > nums[i + 1]) {\\n                return false; // Not monotonic if it decreases.\\n            } else if (!increasing && nums[i] < nums[i + 1]) {\\n                return false; // Not monotonic if it increases.\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "Array",
                    "Math",
                    "Two Pointers",
                    "String",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        if (n <= 1) {\\n            return true; // A single element array is considered monotonic.\\n        }\\n        \\n        int left = 0;\\n        int right = n - 1;\\n        \\n        while (left < n - 1 && nums[left] == nums[left + 1]) {\\n            left++; // Skip identical elements at the beginning.\\n        }\\n        \\n        while (right > 0 && nums[right] == nums[right - 1]) {\\n            right--; // Skip identical elements at the end.\\n        }\\n        \\n        if (left >= right) {\\n            return true; // All elements are identical; the array is monotonic.\\n        }\\n        \\n        bool increasing = nums[left] < nums[left + 1];\\n        \\n        for (int i = left; i < right; i++) {\\n            if (increasing && nums[i] > nums[i + 1]) {\\n                return false; // Not monotonic if it decreases.\\n            } else if (!increasing && nums[i] < nums[i + 1]) {\\n                return false; // Not monotonic if it increases.\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4102922,
                "title": "straightforward-algorithm-easy-approach-o-n-time-complexity",
                "content": "# Intuition\\n<--The intuition behind this code is to check whether the given array is monotonic, which means it is either strictly increasing or strictly decreasing. \\n# Approach\\n<-- The approach iterates through the array while maintaining two flags, one for increasing and one for decreasing trends.\\nIf both flags are set to true at any point, it returns false, indicating a violation of monotonicity(i.e the array is not strictly increasing nor strictly decreasing). \\nIf neither flag is set to true throughout the iteration, it returns true, indicating that the array is monotonic.\\n\\n# Complexity\\n- Time complexity:\\n<-- O(n)\\n\\n- Space complexity:\\n<-- o(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n    bool flag=false;\\n    bool flag1=false;\\n    for (int i = 1; i < nums.size(); ++i) {\\n            if (nums[i] > nums[i - 1]) {\\n                flag = true;\\n            } else if (nums[i] < nums[i - 1]) {\\n                flag1 = true;\\n            }\\n            if (flag && flag1) {\\n                return false; \\n            }\\n        }\\n        return true; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n    bool flag=false;\\n    bool flag1=false;\\n    for (int i = 1; i < nums.size(); ++i) {\\n            if (nums[i] > nums[i - 1]) {\\n                flag = true;\\n            } else if (nums[i] < nums[i - 1]) {\\n                flag1 = true;\\n            }\\n            if (flag && flag1) {\\n                return false; \\n            }\\n        }\\n        return true; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779578,
                "title": "100-beats-fastest-solution-java",
                "content": "# Intuition \\nJust check both type of monotonicity.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution{\\n    public boolean isMonotonic(int[] nums){\\n        return isInc(nums) || isDec(nums);\\n    }\\n\\n    public boolean isInc(int[] nums){\\n        for(int i=1; i<nums.length; i++){\\n            if(nums[i]>nums[i-1]) return false;\\n        }\\n        return true;\\n    }\\n\\n    public boolean isDec(int[] nums){\\n        for(int i=1; i<nums.length; i++){\\n            if(nums[i]<nums[i-1]) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution{\\n    public boolean isMonotonic(int[] nums){\\n        return isInc(nums) || isDec(nums);\\n    }\\n\\n    public boolean isInc(int[] nums){\\n        for(int i=1; i<nums.length; i++){\\n            if(nums[i]>nums[i-1]) return false;\\n        }\\n        return true;\\n    }\\n\\n    public boolean isDec(int[] nums){\\n        for(int i=1; i<nums.length; i++){\\n            if(nums[i]<nums[i-1]) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3763009,
                "title": "monotonic-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar isMonotonic = function(nums) {\\n    let increasing =  true;\\n    let decreasing = true;\\n\\n    for(let i = 1; i < nums.length; i++){\\n        if(nums[i-1] < nums[i]){\\n            decreasing = false;\\n        }\\n        else if(nums[i - 1] > nums[i]){\\n            increasing = false;\\n        }\\n    }\\n    return increasing || decreasing\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar isMonotonic = function(nums) {\\n    let increasing =  true;\\n    let decreasing = true;\\n\\n    for(let i = 1; i < nums.length; i++){\\n        if(nums[i-1] < nums[i]){\\n            decreasing = false;\\n        }\\n        else if(nums[i - 1] > nums[i]){\\n            increasing = false;\\n        }\\n    }\\n    return increasing || decreasing\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3669154,
                "title": "easy-c-solution-beats-84-in-run-time",
                "content": "class Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n       int c=0,k=0;\\n        int n = nums.size()-1;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]<=nums[i+1]){\\n                c=c+1;\\n            }\\n           if(nums[i]>=nums[i+1]) \\n            {\\n                k=k+1;\\n            }\\n        }\\n      \\n        if(c==nums.size()-1 || k==nums.size()-1)\\n            return true;\\n        else{\\n            return false;\\n        }\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n       int c=0,k=0;\\n        int n = nums.size()-1;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]<=nums[i+1]){\\n                c=c+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3607947,
                "title": "absolute-beginner-friendly-one-pass-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        vector<int>tmp;\\n        copy(nums.begin(), nums.end(), back_inserter(tmp));\\n        sort(tmp.begin(),tmp.end());\\n        if(tmp==nums) return 1;\\n        reverse(tmp.begin(),tmp.end());\\n        if(tmp==nums) return 1;\\n        return 0;\\n     }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        vector<int>tmp;\\n        copy(nums.begin(), nums.end(), back_inserter(tmp));\\n        sort(tmp.begin(),tmp.end());\\n        if(tmp==nums) return 1;\\n        reverse(tmp.begin(),tmp.end());\\n        if(tmp==nums) return 1;\\n        return 0;\\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453068,
                "title": "python-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        if nums[-1]> nums[0]:\\n            for i in range(len(nums)-1):\\n                if nums[i+1] < nums[i]:\\n                    return False\\n            return True\\n        elif nums[-1]<nums[0]:\\n            for i in range(len(nums)-1):\\n                if nums[i+1] > nums[i]:\\n                    return False\\n            return True\\n        else:\\n            for i in range(len(nums)-1):\\n                if nums[i+1] != nums[i]:\\n                    return False\\n            return True\\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        if nums[-1]> nums[0]:\\n            for i in range(len(nums)-1):\\n                if nums[i+1] < nums[i]:\\n                    return False\\n            return True\\n        elif nums[-1]<nums[0]:\\n            for i in range(len(nums)-1):\\n                if nums[i+1] > nums[i]:\\n                    return False\\n            return True\\n        else:\\n            for i in range(len(nums)-1):\\n                if nums[i+1] != nums[i]:\\n                    return False\\n            return True\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3412778,
                "title": "monotonic-array-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        int i, flag=0;\\n        for(i=1 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i]-nums[i-1]>0 && flag==0)\\n            {\\n                flag = 1;\\n            }\\n            else if(nums[i]-nums[i-1]<0 && flag==0)\\n            {\\n                flag = 2;\\n            }\\n            else if(nums[i]-nums[i-1]>0 && flag==2 || nums[i]-nums[i-1]<0 && flag==1)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/792a2ee3-fa92-4936-9a87-216cd9a9ac02_1682613207.1269994.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        int i, flag=0;\\n        for(i=1 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i]-nums[i-1]>0 && flag==0)\\n            {\\n                flag = 1;\\n            }\\n            else if(nums[i]-nums[i-1]<0 && flag==0)\\n            {\\n                flag = 2;\\n            }\\n            else if(nums[i]-nums[i-1]>0 && flag==2 || nums[i]-nums[i-1]<0 && flag==1)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3120025,
                "title": "java-896-monotonic-array",
                "content": "\\n# Java Code.  \\n```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n         int n = nums.length;\\n            boolean up=true, down=true;\\n\\n            for (int i = 0; i < n-1; i++) {\\n                if (nums[i] > nums[i + 1]) {\\n                    up = false;\\n                    break;\\n                }\\n            }\\n\\n            for (int i = 0; i < n-1; i++) {\\n                if (nums[i] < nums[i + 1]) {\\n                    down = false;\\n                    break;\\n                }\\n            }\\n            return up || down;\\n    }\\n}\\n```\\n# Good Luck\\uD83D\\uDE09",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n         int n = nums.length;\\n            boolean up=true, down=true;\\n\\n            for (int i = 0; i < n-1; i++) {\\n                if (nums[i] > nums[i + 1]) {\\n                    up = false;\\n                    break;\\n                }\\n            }\\n\\n            for (int i = 0; i < n-1; i++) {\\n                if (nums[i] < nums[i + 1]) {\\n                    down = false;\\n                    break;\\n                }\\n            }\\n            return up || down;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3054468,
                "title": "easy-c-solution-two-line-code-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst click i get that order is manipulated by sorting. See the APPROACH.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach is so simple, the question said that this must be in increasing or in decreasing order (monotone). We can change the order by doing sorting.\\n1. Create two copies of input vector.\\n2. Sort first copy vector (in increasing order) using simple sort method.\\n3. Sort second copy vector (in decreasing order) using the function (written in code).\\n4. Now use if else condition to check whether any of these two vector is equal or not to the input vector (original vector).\\n5. So use or operator if any of them is equal, it return true else false.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this code is O(nlogn) due to the use of the sort function, which has a time complexity of O(nlogn) for the average and worst case.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) as it creates two copies of the input vector, v1 and v2, each of which takes up n space.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        vector <int> v1 = nums,v2 = nums;\\n        sort(v1.begin(),v1.end()); //sort in increasing order\\n        sort(v2.begin(), v2.end(), greater<int>()); //sort in decreasing order\\n        if(v1==nums || v2==nums) return 1;\\n        else return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        vector <int> v1 = nums,v2 = nums;\\n        sort(v1.begin(),v1.end()); //sort in increasing order\\n        sort(v2.begin(), v2.end(), greater<int>()); //sort in decreasing order\\n        if(v1==nums || v2==nums) return 1;\\n        else return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016062,
                "title": "c-brute-force-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        if(nums[0]>nums[nums.size()-1]){\\n            for(int i=0; i<nums.size()-1; i++){\\n                if(nums[i]<nums[i+1]){\\n                    return false;\\n                }\\n            }\\n        }\\n        else if(nums[0]<nums[nums.size()-1]){\\n            for(int i=0; i<nums.size()-1; i++){\\n                if(nums[i]>nums[i+1]){\\n                    return false;\\n                }\\n            }\\n        }\\n        else{\\n            for(int i=0; i<nums.size()-1; i++){\\n                if(nums[i]!=nums[i+1]){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        if(nums[0]>nums[nums.size()-1]){\\n            for(int i=0; i<nums.size()-1; i++){\\n                if(nums[i]<nums[i+1]){\\n                    return false;\\n                }\\n            }\\n        }\\n        else if(nums[0]<nums[nums.size()-1]){\\n            for(int i=0; i<nums.size()-1; i++){\\n                if(nums[i]>nums[i+1]){\\n                    return false;\\n                }\\n            }\\n        }\\n        else{\\n            for(int i=0; i<nums.size()-1; i++){\\n                if(nums[i]!=nums[i+1]){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944650,
                "title": "java-1ms-o-n-time-complexity",
                "content": "\\n# Complexity\\n- Time complexity:\\nO ( N )\\n\\n- Space complexity:\\nO ( 1 )\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        int count=0;\\n        int count1=0;\\n        for(int i=0; i<nums.length-1; i++){\\n            if(nums[i]<=nums[i+1]){\\n                count++;\\n            }\\n        }\\n        for(int i=0; i<nums.length-1; i++){\\n            if(nums[i]>=nums[i+1]) {\\n                count1++;\\n            }\\n        }\\n        return count==nums.length-1 || count1==nums.length-1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        int count=0;\\n        int count1=0;\\n        for(int i=0; i<nums.length-1; i++){\\n            if(nums[i]<=nums[i+1]){\\n                count++;\\n            }\\n        }\\n        for(int i=0; i<nums.length-1; i++){\\n            if(nums[i]>=nums[i+1]) {\\n                count1++;\\n            }\\n        }\\n        return count==nums.length-1 || count1==nums.length-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2919469,
                "title": "java-1ms-100-easy",
                "content": "# Please Upvote :D\\n---\\n![image.png](https://assets.leetcode.com/users/images/5aea1073-69b3-4182-92f9-1d25fb2e2605_1671227782.435388.png)\\n\\n``` java []\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        int n = nums.length;\\n        if (n < 3) {\\n            return true;\\n        }\\n\\n        boolean isIncreasing = nums[n - 1] > nums[0];\\n        for (int i = 1; i < n; i++) {\\n            if (isIncreasing) {\\n                if (nums[i - 1] > nums[i]) {\\n                    return false;\\n                }\\n            }\\n            else {\\n                if (nums[i - 1] < nums[i]) {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\\nTime complexity: `O(n)`\\nSpace complexity: `O(1)`",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "``` java []\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        int n = nums.length;\\n        if (n < 3) {\\n            return true;\\n        }\\n\\n        boolean isIncreasing = nums[n - 1] > nums[0];\\n        for (int i = 1; i < n; i++) {\\n            if (isIncreasing) {\\n                if (nums[i - 1] > nums[i]) {\\n                    return false;\\n                }\\n            }\\n            else {\\n                if (nums[i - 1] < nums[i]) {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2611352,
                "title": "java-fast-solution",
                "content": "class Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        int c=1,d=1;\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            if(nums[i]<=nums[i+1])\\n            {\\n            c++;\\n            }\\n            if(nums[i+1]<=nums[i])\\n            {\\n             d++;\\n            }\\n        }\\n        System.out.println(c+\" \"+d);\\n        if(c==nums.length || d==nums.length)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        int c=1,d=1;\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            if(nums[i]<=nums[i+1])\\n            {\\n            c++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2209802,
                "title": "easy-code-with-line-by-line-explanation",
                "content": "class Solution {\\npublic:\\n\\n    bool isMonotonic(vector<int>& v) {\\n        int flag;\\n        //if flag=1 then increaseing, if flag==-1 the decreasing\\n\\t\\t\\n        int n=v.size();\\n\\t\\t\\n\\t\\t//if number of element is 1 or 2 the array is always monotonic\\n        if(n<=2)\\n            return true;\\n\\t\\t\\t\\n\\t\\t//steps to remove duplicate elements\\n        vector<int>::iterator ip;\\n        ip = std::unique(v.begin(), v.begin() + n);\\n        v.resize(std::distance(v.begin(), ip));\\n\\t\\t\\n\\t\\t//setting the flag value wrt the first 2 elements\\n        if(v[0]<v[1])\\n            flag=1;\\n        else\\n            flag=-1;\\n        int p;\\n        for(int i=1;i<v.size()-1;i++){\\n            if(v[i]<v[i+1])\\n                p=1;\\n            else\\n                p=-1;\\n            if(p!=flag)\\n                return false;       \\n        }\\n        return true;\\n    }\\n};\\n\\nHope the solution was pretty easy. If you like the solution then kindly do upvote it!!",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    bool isMonotonic(vector<int>& v) {\\n        int flag;\\n        //if flag=1 then increaseing, if flag==-1 the decreasing\\n\\t\\t\\n        int n=v.size();\\n\\t\\t\\n\\t\\t//if number of element is 1 or 2 the array is always monotonic\\n        if(n<=2)\\n            return true;\\n\\t\\t\\t\\n\\t\\t//steps to remove duplicate elements\\n        vector<int>::iterator ip;\\n        ip = std::unique(v.begin(), v.begin() + n);\\n        v.resize(std::distance(v.begin(), ip));\\n\\t\\t\\n\\t\\t//setting the flag value wrt the first 2 elements\\n        if(v[0]<v[1])\\n            flag=1;\\n        else\\n            flag=-1;\\n        int p;\\n        for(int i=1;i<v.size()-1;i++){\\n            if(v[i]<v[i+1])\\n                p=1;\\n            else\\n                p=-1;\\n            if(p!=flag)\\n                return false;       \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1572649,
                "title": "rust-solution-16-ms",
                "content": "```\\nimpl Solution {\\n    pub fn is_monotonic(nums: Vec<i32>) -> bool {\\n        use std::cmp::Ordering;\\n        let mut dir = 0;\\n        for (a, b) in nums.iter().zip(nums[1..].iter()) {\\n            dir |= match a.cmp(b) {\\n                Ordering::Equal => 0,\\n                Ordering::Less => 1,\\n                Ordering::Greater => 2,\\n            };\\n            if dir == 3 {\\n                return false;\\n            }\\n        }\\n        true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn is_monotonic(nums: Vec<i32>) -> bool {\\n        use std::cmp::Ordering;\\n        let mut dir = 0;\\n        for (a, b) in nums.iter().zip(nums[1..].iter()) {\\n            dir |= match a.cmp(b) {\\n                Ordering::Equal => 0,\\n                Ordering::Less => 1,\\n                Ordering::Greater => 2,\\n            };\\n            if dir == 3 {\\n                return false;\\n            }\\n        }\\n        true\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1569739,
                "title": "my-simple-understandable-solution-java-c-c",
                "content": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        boolean increasing=true;\\n        boolean decreasing=true;\\n        for(int i=0; i<nums.length-1; i++){\\n            if(nums[i]>nums[i+1]){\\n                increasing=false;\\n            }\\n            if(nums[i]<nums[i+1]){\\n                decreasing=false;\\n            }\\n        }\\n        return increasing || decreasing;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        boolean increasing=true;\\n        boolean decreasing=true;\\n        for(int i=0; i<nums.length-1; i++){\\n            if(nums[i]>nums[i+1]){\\n                increasing=false;\\n            }\\n            if(nums[i]<nums[i+1]){\\n                decreasing=false;\\n            }\\n        }\\n        return increasing || decreasing;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1541605,
                "title": "java-easy-solution-100-fast-with-one-loop",
                "content": "```\\n\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n\\tint i=0; \\n        int  j= nums.length-1;\\n        if(nums.length==1) return true;\\n        while(i<j){\\n          // checking if order is increasing or decreasing //\\n\\t\\t  if(nums[0]<nums[nums.length-1]){\\n                if(nums[i]<=nums[i+1]){\\n                    i++;\\n                }else break;\\n            } else if(nums[0]>nums[nums.length-1] ){\\n                if(nums[j]<=nums[j-1] ) j--;\\n                else break;\\n            }\\n\\t\\t\\telse{\\n                if(nums[i]==nums[j]) {\\n                    i++;\\n                    \\n                }else break;\\n            }\\n        }\\n        if(i==nums.length-1|| j<=0) return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n\\tint i=0; \\n        int  j= nums.length-1;\\n        if(nums.length==1) return true;\\n        while(i<j){\\n          // checking if order is increasing or decreasing //\\n\\t\\t  if(nums[0]<nums[nums.length-1]){\\n                if(nums[i]<=nums[i+1]){\\n                    i++;\\n                }else break;\\n            } else if(nums[0]>nums[nums.length-1] ){\\n                if(nums[j]<=nums[j-1] ) j--;\\n                else break;\\n            }\\n\\t\\t\\telse{\\n                if(nums[i]==nums[j]) {\\n                    i++;\\n                    \\n                }else break;\\n            }\\n        }\\n        if(i==nums.length-1|| j<=0) return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1536608,
                "title": "c-simplest-solution",
                "content": "class Solution {\\npublic:\\n\\n    bool isMonotonic(vector<int>& nums) {\\n        int n = nums.size();\\n        int inc=1,dec=1;\\n        \\n        for(int i=0 ; i<n-1 ; ++i)\\n        {\\n            if(nums[i]<=nums[i+1])\\n                inc++;\\n            if(nums[i]>=nums[i+1])\\n                dec++;\\n        }\\n        if(inc==n || dec==n)\\n            return true;\\n        return false;\\n    }\\n};\\n**leave a like.**",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    bool isMonotonic(vector<int>& nums) {\\n        int n = nums.size();\\n        int inc=1,dec=1;\\n        \\n        for(int i=0 ; i<n-1 ; ++i)\\n        {\\n            if(nums[i]<=nums[i+1])\\n                inc++;\\n            if(nums[i]>=nums[i+1])\\n                dec++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1358055,
                "title": "c-easy-to-understand-stl-99-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n         ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\\n        if(is_sorted(nums.begin(),nums.end()))\\n            return true;\\n        if(is_sorted(nums.begin(),nums.end(),greater<int>()))\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n         ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\\n        if(is_sorted(nums.begin(),nums.end()))\\n            return true;\\n        if(is_sorted(nums.begin(),nums.end(),greater<int>()))\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1199418,
                "title": "rust-one-pass-4ms-beats-100",
                "content": "```rust\\nimpl Solution {\\n    pub fn is_monotonic(a: Vec<i32>) -> bool {\\n        let mut direction = 0;\\n\\n        for i in 1..a.len() {\\n            let s = (a[i] - a[i-1]).signum();\\n            if s == 0 {\\n                continue;\\n            } else if direction == 0 {\\n                direction = s;\\n            } else if s != direction {\\n                return false;\\n            }\\n        }\\n\\n        true\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn is_monotonic(a: Vec<i32>) -> bool {\\n        let mut direction = 0;\\n\\n        for i in 1..a.len() {\\n            let s = (a[i] - a[i-1]).signum();\\n            if s == 0 {\\n                continue;\\n            } else if direction == 0 {\\n                direction = s;\\n            } else if s != direction {\\n                return false;\\n            }\\n        }\\n\\n        true\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1018290,
                "title": "simple-solution-in-c",
                "content": "class Solution {\\npublic:\\n    bool isMonotonic(vector<int>& A) {\\n        int c=0,d=0;\\n        for(int i=1;i<A.size();i++){\\n            if(A[i]<A[i-1]){\\n                c++;\\n                break;\\n            }\\n        }\\n        for(int i=1;i<A.size();i++){\\n            if(A[i]>A[i-1]){\\n                d++;\\n                break;\\n            }\\n        }\\n        if(d>0&&c>0){\\n            return false;\\n            \\n        }\\n        \\n        else{\\n            return true;\\n        }\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool isMonotonic(vector<int>& A) {\\n        int c=0,d=0;\\n        for(int i=1;i<A.size();i++){\\n            if(A[i]<A[i-1]){\\n                c++;\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 659378,
                "title": "java-one-pass-o-n",
                "content": "It is first time for me to post my answer. If you have any suggestion, I am willing to learn and improve my code. \\u266A(\\uFF3E\\u2200\\uFF3E\\u25CF)\\uFF89\\n```\\npublic boolean isMonotonic(int[] A) {\\n        int n = A.length;\\n        if (n == 1) {\\n            return true;\\n        }\\n        \\n        int direction = Integer.compare(A[0], A[n - 1]);\\n        \\n        for (int i = 1; i < n; i++) {\\n            int compare = Integer.compare(A[i - 1], A[i]);\\n            if (compare != 0 && compare != direction) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean isMonotonic(int[] A) {\\n        int n = A.length;\\n        if (n == 1) {\\n            return true;\\n        }\\n        \\n        int direction = Integer.compare(A[0], A[n - 1]);\\n        \\n        for (int i = 1; i < n; i++) {\\n            int compare = Integer.compare(A[i - 1], A[i]);\\n            if (compare != 0 && compare != direction) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 632571,
                "title": "java-one-pass-o-n-100-w-r-t-time",
                "content": "class Solution {\\n\\n    public boolean isMonotonic(int[] A) {\\n        \\n        boolean increasing = true;\\n        boolean decreasing = true;\\n        \\n        for (int i = 0; i < A.length - 1; i ++) {\\n            if (A[i] < A[i + 1]) {\\n                decreasing = false;\\n            } \\n            \\n            if (A[i + 1] < A[i]) {\\n                increasing = false;\\n            }\\n        }\\n        \\n        return increasing || decreasing;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public boolean isMonotonic(int[] A) {\\n        \\n        boolean increasing = true;\\n        boolean decreasing = true;\\n        \\n        for (int i = 0; i < A.length - 1; i ++) {\\n            if (A[i] < A[i + 1]) {\\n                decreasing = false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 490963,
                "title": "straightforward-solution",
                "content": "```\\nbool isMonotonic(vector<int>& a)\\n{\\n\\tauto inc{a.front()<=a.back()};\\n\\tfor(auto i{1}; i<size(a); ++i)\\n\\t\\tif(a[i]<a[i-1] and inc or a[i]>a[i-1] and !inc)\\treturn false;    \\n\\treturn true;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool isMonotonic(vector<int>& a)\\n{\\n\\tauto inc{a.front()<=a.back()};\\n\\tfor(auto i{1}; i<size(a); ++i)\\n\\t\\tif(a[i]<a[i-1] and inc or a[i]>a[i-1] and !inc)\\treturn false;    \\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 378503,
                "title": "java-solution-100-runtime-and-memory",
                "content": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] A) {\\n        if (A.length == 1) return true;\\n        if (A[0] < A[1]) return isIncreasing(A);\\n        else if (A[0] > A[1]) return isDecreasing(A);\\n        else {\\n            if (isIncreasing(A)) return true;\\n            return isDecreasing(A);\\n        }\\n    }\\n    \\n    public boolean isIncreasing(int[] A){\\n        for (int i = 0; i < A.length-1; i++){\\n            if (!(A[i] <= A[i+1])) return false;\\n        }\\n        return true;\\n    }\\n    \\n    public boolean isDecreasing(int[] A){\\n        for (int i = 0; i < A.length-1; i++){\\n            if (!(A[i] >= A[i+1])) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] A) {\\n        if (A.length == 1) return true;\\n        if (A[0] < A[1]) return isIncreasing(A);\\n        else if (A[0] > A[1]) return isDecreasing(A);\\n        else {\\n            if (isIncreasing(A)) return true;\\n            return isDecreasing(A);\\n        }\\n    }\\n    \\n    public boolean isIncreasing(int[] A){\\n        for (int i = 0; i < A.length-1; i++){\\n            if (!(A[i] <= A[i+1])) return false;\\n        }\\n        return true;\\n    }\\n    \\n    public boolean isDecreasing(int[] A){\\n        for (int i = 0; i < A.length-1; i++){\\n            if (!(A[i] >= A[i+1])) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 295733,
                "title": "java-one-pass-solution-with-two-boolean-variables",
                "content": "* Create two boolean variables to keep track of whether the array is increasing or decreasing.\\n* If the array is increasing, mark decreasing as false and if the array is decreasing, mark increasing as false.\\n* If both variables are false, then the array is neither increasing nor decreasing.\\n* At the end return whichever is true, increasing or decreasing.\\n```\\npublic boolean isMonotonic(int[] A) {\\n        boolean increasing = true, decreasing = true;\\n        for(int i = 1; i < A.length; i++) {\\n            if(A[i] > A[i - 1]) {\\n                decreasing = false;\\n            }\\n            else if(A[i] < A[i - 1]) {\\n                increasing = false;\\n            }\\n            if(!increasing && !decreasing)\\n                return false;\\n        }\\n        return increasing || decreasing;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic boolean isMonotonic(int[] A) {\\n        boolean increasing = true, decreasing = true;\\n        for(int i = 1; i < A.length; i++) {\\n            if(A[i] > A[i - 1]) {\\n                decreasing = false;\\n            }\\n            else if(A[i] < A[i - 1]) {\\n                increasing = false;\\n            }\\n            if(!increasing && !decreasing)\\n                return false;\\n        }\\n        return increasing || decreasing;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 245101,
                "title": "python3-self-explanatory",
                "content": "```\\nclass Solution:\\n    def isMonotonic(self, A: List[int]) -> bool:\\n        if len(A) <= 1:\\n            return True\\n        absdiff = abs(A[-1] - A[0])\\n        \\n        diffsum = 0\\n        for i in range(len(A) - 1):\\n            diffsum += abs(A[i + 1] - A[i])\\n        \\n        return diffsum == absdiff\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isMonotonic(self, A: List[int]) -> bool:\\n        if len(A) <= 1:\\n            return True\\n        absdiff = abs(A[-1] - A[0])\\n        \\n        diffsum = 0\\n        for i in range(len(A) - 1):\\n            diffsum += abs(A[i + 1] - A[i])\\n        \\n        return diffsum == absdiff\\n```",
                "codeTag": "Java"
            },
            {
                "id": 191397,
                "title": "javascript",
                "content": "```\nvar isMonotonic = function(A) {\n    let increase = true, decrease = true;\n    for(let i = 0; i < A.length - 1; i++) {\n        if(A[i] > A[i + 1]) increase = false;\n        if(A[i] < A[i + 1]) decrease = false;\n    }\n    return increase || decrease;\n};\n```",
                "solutionTags": [],
                "code": "```\nvar isMonotonic = function(A) {\n    let increase = true, decrease = true;\n    for(let i = 0; i < A.length - 1; i++) {\n        if(A[i] > A[i + 1]) increase = false;\n        if(A[i] < A[i + 1]) decrease = false;\n    }\n    return increase || decrease;\n};\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 172879,
                "title": "world-needs-a-better-solution-here-it-is-java-o-n-single-pass",
                "content": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] A) {\\n        //use inc flag and dec flags.\\n        int inc=0, dec=0;\\n        for(int i=1;i<A.length;i++){\\n            if(A[i]-A[i-1] < 0){\\n                dec = 1;\\n            }else if(A[i]-A[i-1] > 0){\\n                inc = 1;\\n            }\\n        }\\n        if(inc==1 && dec==1 ) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] A) {\\n        //use inc flag and dec flags.\\n        int inc=0, dec=0;\\n        for(int i=1;i<A.length;i++){\\n            if(A[i]-A[i-1] < 0){\\n                dec = 1;\\n            }else if(A[i]-A[i-1] > 0){\\n                inc = 1;\\n            }\\n        }\\n        if(inc==1 && dec==1 ) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 165942,
                "title": "java-straightforward",
                "content": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] A) {\\n        boolean inc = true, dec = true;\\n        for (int i = 0; i < A.length - 1; i++) {\\n            if (A[i] > A[i + 1]) {\\n                inc = false;\\n            }\\n            if (A[i] < A[i + 1]) {\\n                dec = false;\\n            }\\n            if (!inc && !dec) {\\n                return false;\\n            }\\n        }\\n        return inc || dec;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] A) {\\n        boolean inc = true, dec = true;\\n        for (int i = 0; i < A.length - 1; i++) {\\n            if (A[i] > A[i + 1]) {\\n                inc = false;\\n            }\\n            if (A[i] < A[i + 1]) {\\n                dec = false;\\n            }\\n            if (!inc && !dec) {\\n                return false;\\n            }\\n        }\\n        return inc || dec;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4106358,
                "title": "one-pass-most-concise-and-clean",
                "content": "```c++\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        bool i = true;\\n        bool d = true;\\n        \\n        int index = 0;\\n        \\n        while ((i || d) && index < nums.size() - 1) {\\n            if (d && nums[index] < nums[index + 1]) {\\n                d = false;\\n            }\\n            \\n            if (i && nums[index] > nums[index + 1]) {\\n                i = false;\\n            }\\n            \\n            index++;\\n        }\\n        \\n        return i || d || false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        bool i = true;\\n        bool d = true;\\n        \\n        int index = 0;\\n        \\n        while ((i || d) && index < nums.size() - 1) {\\n            if (d && nums[index] < nums[index + 1]) {\\n                d = false;\\n            }\\n            \\n            if (i && nums[index] > nums[index + 1]) {\\n                i = false;\\n            }\\n            \\n            index++;\\n        }\\n        \\n        return i || d || false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4105770,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        bool inc=false,dec=false;\\n        int len=nums.size();\\n\\n        if(len==1)\\n            return true;\\n        for(int i=1;i<len;i++){\\n            if(inc &&dec){\\n                return false;\\n            }\\n            if(nums[i]>nums[i-1]){\\n                inc=true;\\n            }\\n            else if(nums[i]<nums[i-1]){\\n                dec=true;\\n            }\\n            \\n        }\\n        if(inc &&dec)\\n            return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        bool inc=false,dec=false;\\n        int len=nums.size();\\n\\n        if(len==1)\\n            return true;\\n        for(int i=1;i<len;i++){\\n            if(inc &&dec){\\n                return false;\\n            }\\n            if(nums[i]>nums[i-1]){\\n                inc=true;\\n            }\\n            else if(nums[i]<nums[i-1]){\\n                dec=true;\\n            }\\n            \\n        }\\n        if(inc &&dec)\\n            return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4105064,
                "title": "python-3-o-n-time-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n\\n        # If last elemnt is greater than first\\n        # Conisdeirng it as monotonically increasing\\n        if nums[-1]>nums[0]:\\n            for i in range(len(nums)-1):\\n                if nums[i+1]<nums[i]:\\n                    return False\\n            return True\\n        # Else monotonically decreasing\\n        else:\\n            for i in range(len(nums)-1):\\n                if nums[i+1]>nums[i]:\\n                    return False\\n            return True\\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n\\n        # If last elemnt is greater than first\\n        # Conisdeirng it as monotonically increasing\\n        if nums[-1]>nums[0]:\\n            for i in range(len(nums)-1):\\n                if nums[i+1]<nums[i]:\\n                    return False\\n            return True\\n        # Else monotonically decreasing\\n        else:\\n            for i in range(len(nums)-1):\\n                if nums[i+1]>nums[i]:\\n                    return False\\n            return True\\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4105032,
                "title": "python-3-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        rev=sorted(nums,reverse=True)\\n        so=sorted(nums)\\n\\n        return nums==so or nums==rev\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        rev=sorted(nums,reverse=True)\\n        so=sorted(nums)\\n\\n        return nums==so or nums==rev\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4104922,
                "title": "swift-easy-to-understand-and-simple-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    func isMonotonic(_ nums: [Int]) -> Bool {\\n        var increasing = true\\n        var decreasing = true\\n        for i in 1..<nums.count {\\n            increasing = increasing && nums[i - 1] <= nums[i]\\n            decreasing = decreasing && nums[i - 1] >= nums[i]\\n        }\\n        return increasing || decreasing\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func isMonotonic(_ nums: [Int]) -> Bool {\\n        var increasing = true\\n        var decreasing = true\\n        for i in 1..<nums.count {\\n            increasing = increasing && nums[i - 1] <= nums[i]\\n            decreasing = decreasing && nums[i - 1] >= nums[i]\\n        }\\n        return increasing || decreasing\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4104338,
                "title": "c-2-approaches-explained",
                "content": "# *PLEASE UPVOTE IF IT HELPED*\\n\\n---\\n\\n\\n# Approach\\n***(Also explained in the code)***\\n\\n\\n***Approach 1:***\\n\\n1. It first checks if the first element is greater than the last element.\\n    - If it is, it loops through the array to ensure each element is greater than or equal to the previous one.\\n    - If any element violates this condition, it returns **false**.\\n1. If the first element is not greater than the last (or they are equal), it checks if the array is non-decreasing.\\n    - It does this by looping through the array and ensuring each element is less than or equal to the previous one.\\n    - If any element violates this condition, it returns **false**.\\n1. If neither of the above conditions is met, the array is monotonic, and it returns **true**.\\n\\n***Approach 2:***\\n\\n1. If the input vector has less than 2 elements, it\\'s trivially monotonic, and the function returns **true**.\\n1. It uses a direction variable to keep track of the monotonic trend: 0 for undefined, -1 for decreasing, and 1 for increasing.\\n1. It iterates through the vector, comparing each element with the previous one.\\n1. If the direction is inconsistent with the established monotonicity, the function returns **false**.\\n1. If the loop completes without returning **false**, the vector is monotonic, and the function returns **true**.\\n\\n# Complexity\\n- Time complexity:\\n1.$$O(2n)$$\\n2.$$O(n)$$\\n\\n- Space complexity:\\n1.$$O(1)$$\\n2.$$O(1)$$\\n\\n# Code\\n```\\n                --------Approach 1---------\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        // Check if the first element is greater than the last element\\n        if (nums[0] > nums[nums.size() - 1]) {\\n            // If it is, loop through the array from the second element\\n            for (int i = 1; i < nums.size(); i++) {\\n                // Check if the current element is greater than or equal to the previous element\\n                if (nums[i - 1] >= nums[i]) {\\n                    continue; // Continue the loop if it\\'s greater or equal\\n                } else {\\n                    return false; // Return false if it\\'s not monotonic\\n                }\\n            }\\n        } else {\\n            // If the first element is not greater than the last element (or they are equal)\\n            for (int i = 1; i < nums.size(); i++) {\\n                // Check if the current element is less than or equal to the previous element\\n                if (nums[i - 1] <= nums[i]) {\\n                    continue; // Continue the loop if it\\'s less or equal\\n                } else {\\n                    return false; // Return false if it\\'s not monotonic\\n                }\\n            }\\n        }\\n        return true; // If the loop completes without returning false, the array is monotonic\\n    }\\n};\\n\\n                --------Approach 2---------\\n\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        // Check if the input vector has less than 2 elements (trivially monotonic)\\n        if (nums.size() < 2) {\\n            return true;\\n        }\\n\\n        // Initialize a direction variable to track the monotonicity\\n        int direction = 0;  // 0 represents undefined direction, -1 represents decreasing, 1 represents increasing\\n\\n        // Loop through the vector starting from the second element\\n        for (int i = 1; i < nums.size(); i++) {\\n\\n            // Compare the current element with the previous one\\n            if (nums[i - 1] < nums[i]) {\\n                // If it\\'s increasing and direction was previously undefined or also increasing, set direction to increasing\\n                if (direction == 0 || direction == 1) {\\n                    direction = 1;\\n                } else {\\n                    return false; // If direction was decreasing, it\\'s not monotonic\\n                }\\n            } else if (nums[i - 1] > nums[i]) {\\n                // If it\\'s decreasing and direction was previously undefined or also decreasing, set direction to decreasing\\n                if (direction == 0 || direction == -1) {\\n                    direction = -1;\\n                } else {\\n                    return false; // If direction was increasing, it\\'s not monotonic\\n                }\\n            }\\n            // If elements are equal, no change in direction\\n        }\\n        return true; // If the loop completes without returning false, the array is monotonic\\n    }\\n};\\n\\n\\n\\n```\\n\\n# *PLEASE UPVOTE IF IT HELPED*\\n\\n---\\n---\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\n                --------Approach 1---------\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        // Check if the first element is greater than the last element\\n        if (nums[0] > nums[nums.size() - 1]) {\\n            // If it is, loop through the array from the second element\\n            for (int i = 1; i < nums.size(); i++) {\\n                // Check if the current element is greater than or equal to the previous element\\n                if (nums[i - 1] >= nums[i]) {\\n                    continue; // Continue the loop if it\\'s greater or equal\\n                } else {\\n                    return false; // Return false if it\\'s not monotonic\\n                }\\n            }\\n        } else {\\n            // If the first element is not greater than the last element (or they are equal)\\n            for (int i = 1; i < nums.size(); i++) {\\n                // Check if the current element is less than or equal to the previous element\\n                if (nums[i - 1] <= nums[i]) {\\n                    continue; // Continue the loop if it\\'s less or equal\\n                } else {\\n                    return false; // Return false if it\\'s not monotonic\\n                }\\n            }\\n        }\\n        return true; // If the loop completes without returning false, the array is monotonic\\n    }\\n};\\n\\n                --------Approach 2---------\\n\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        // Check if the input vector has less than 2 elements (trivially monotonic)\\n        if (nums.size() < 2) {\\n            return true;\\n        }\\n\\n        // Initialize a direction variable to track the monotonicity\\n        int direction = 0;  // 0 represents undefined direction, -1 represents decreasing, 1 represents increasing\\n\\n        // Loop through the vector starting from the second element\\n        for (int i = 1; i < nums.size(); i++) {\\n\\n            // Compare the current element with the previous one\\n            if (nums[i - 1] < nums[i]) {\\n                // If it\\'s increasing and direction was previously undefined or also increasing, set direction to increasing\\n                if (direction == 0 || direction == 1) {\\n                    direction = 1;\\n                } else {\\n                    return false; // If direction was decreasing, it\\'s not monotonic\\n                }\\n            } else if (nums[i - 1] > nums[i]) {\\n                // If it\\'s decreasing and direction was previously undefined or also decreasing, set direction to decreasing\\n                if (direction == 0 || direction == -1) {\\n                    direction = -1;\\n                } else {\\n                    return false; // If direction was increasing, it\\'s not monotonic\\n                }\\n            }\\n            // If elements are equal, no change in direction\\n        }\\n        return true; // If the loop completes without returning false, the array is monotonic\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4104068,
                "title": "monotonic-array-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        int n= nums.length;\\n        if(n<2){\\n            return true;\\n        }\\n        boolean incrDir=true;\\n        boolean decrDir=true;\\n        for(int i=1;i<n;i++){\\n            if(nums[i]>nums[i-1]){\\n               decrDir= false;\\n            }else if(nums[i]<nums[i-1]){\\n               incrDir = false;\\n            }\\n            if(!decrDir && !incrDir){\\n                return false;\\n            }\\n           \\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        int n= nums.length;\\n        if(n<2){\\n            return true;\\n        }\\n        boolean incrDir=true;\\n        boolean decrDir=true;\\n        for(int i=1;i<n;i++){\\n            if(nums[i]>nums[i-1]){\\n               decrDir= false;\\n            }else if(nums[i]<nums[i-1]){\\n               incrDir = false;\\n            }\\n            if(!decrDir && !incrDir){\\n                return false;\\n            }\\n           \\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4103950,
                "title": "accepted-5-line-java-code-beats-100",
                "content": "# Complexity\\n- Time complexity : $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```JAVA []\\nclass Solution {\\npublic boolean isMonotonic(int[] A) {\\n    int i = 1;\\n    for(; i < A.length; i++)\\n        if(A[i - 1] > A[i]) break;\\n    if(i != A.length)\\n        for(i = A.length-2; i > -1; i--)\\n            if(A[i + 1] > A[i]) return false;\\n    return true;\\n}\\n}\\n```\\n>>> ## Upvote\\uD83D\\uDC4D if you find helpful\\n",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```JAVA []\\nclass Solution {\\npublic boolean isMonotonic(int[] A) {\\n    int i = 1;\\n    for(; i < A.length; i++)\\n        if(A[i - 1] > A[i]) break;\\n    if(i != A.length)\\n        for(i = A.length-2; i > -1; i--)\\n            if(A[i + 1] > A[i]) return false;\\n    return true;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4103660,
                "title": "short-and-crisp-code-trick-to-solve-these-problems-which-can-be-utilized-in-many-hard-problems",
                "content": "# Intuition\\nMost basic intuition is - **in an increasing or decreasing array, the product of current difference and previous difference will never be negative.**\\n\\n`(Ai - Ai-1) * (Ai+1 - Ai) >= 0; Where 0 < i < n`\\n\\n**It can be utilized in mountain array questions or where we have to find the break points (the points where the array changes from increasing to decreasing or vice-versa)**\\n\\n# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        if(nums.size() <= 2)return true;\\n        int prev = nums[1] - nums[0];\\n        for(int i=2; i<nums.size(); ++i){\\n            int diff = nums[i] - nums[i-1];\\n            if(1LL * prev * diff < 0)return false;\\n            if(diff != 0)prev = diff;\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        if(nums.size() <= 2)return true;\\n        int prev = nums[1] - nums[0];\\n        for(int i=2; i<nums.size(); ++i){\\n            int diff = nums[i] - nums[i-1];\\n            if(1LL * prev * diff < 0)return false;\\n            if(diff != 0)prev = diff;\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4103414,
                "title": "find-monotonic-array-using-count-variable",
                "content": "# Intuition\\nIf array is strictly increasing or its strictly decreasing then return true otherwise return false.\\n\\n# Approach\\nTo solve this problem two count variables are maintained if array is increasing then increasing_count is incremented if array is decreasing then decreasing_count is decremented and in the last part we are checking if count variable is matching with number of iterations then we are returning true else it will return false.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Codea\\n```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        int increasing_count =0;\\n        int decreasing_count =0;\\n\\n        if(nums.length == 1){\\n            return true;\\n        }\\n        else{\\n            for(int i=0 ; i<nums.length-1 ; i++){\\n                if(nums[i] < nums[i+1]){\\n                    increasing_count++;\\n                }\\n                else if(nums[i] > nums[i+1]){\\n                    decreasing_count++;\\n                }\\n                else if(nums[i] == nums[i+1]){\\n                    decreasing_count++;\\n                    increasing_count++;\\n                }\\n\\n            }\\n\\n        }\\n        if(decreasing_count == nums.length - 1 || increasing_count == nums.length - 1){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        int increasing_count =0;\\n        int decreasing_count =0;\\n\\n        if(nums.length == 1){\\n            return true;\\n        }\\n        else{\\n            for(int i=0 ; i<nums.length-1 ; i++){\\n                if(nums[i] < nums[i+1]){\\n                    increasing_count++;\\n                }\\n                else if(nums[i] > nums[i+1]){\\n                    decreasing_count++;\\n                }\\n                else if(nums[i] == nums[i+1]){\\n                    decreasing_count++;\\n                    increasing_count++;\\n                }\\n\\n            }\\n\\n        }\\n        if(decreasing_count == nums.length - 1 || increasing_count == nums.length - 1){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4103321,
                "title": "oops-concept-easy-code-in-c",
                "content": "# Intuition\\nThe idea to solve this problem is simple, if the first 2 element is increasing then check for increasing in the array, if they are decreasing then check for decreasing in the array otherwise check for both and return the result appropriately.\\n\\n# Approach\\nIn the approach, I have used the cocept of OOPs to write the comparator for increasing and decreasing check using the concept of virtual function in C++. Now, thic code is also extensible if we want to check the array with respect to increasing or decreasing absolute values.\\n\\n# Complexity\\n- Time Complexity: O(N)\\n\\n- Space Complexity: O(1)\\n\\n# Code\\n```\\nclass Comparator {\\n    public:\\n    virtual bool compare(int a, int b) = 0;\\n};\\n\\nclass IncreasingComparator : public Comparator {\\n    public:\\n    bool compare(int a, int b) {\\n        return a <= b;\\n    }\\n};\\n\\nclass DecreasingComparator : public Comparator {\\n    public:\\n    bool compare(int a, int b) {\\n        return a >= b;\\n    }\\n};\\n\\nclass Solution {\\n\\n    bool isMonotonic(vector<int> nums, Comparator *comparator) {\\n        int N = nums.size();\\n        for(int i = 0; i < N - 1; i++) {\\n            if(!(comparator->compare(nums[i], nums[i + 1]))) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\npublic:\\n    bool isMonotonic(vector<int> &nums) {\\n        if(nums.size() == 1) return true;\\n        if(nums[0] < nums[1]) {\\n            return isMonotonic(nums, new IncreasingComparator());\\n        } else if(nums[0] < nums[1]) {\\n            return isMonotonic(nums, new DecreasingComparator());\\n        } else {\\n            return isMonotonic(nums, new IncreasingComparator()) or isMonotonic(nums, new DecreasingComparator());\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Comparator {\\n    public:\\n    virtual bool compare(int a, int b) = 0;\\n};\\n\\nclass IncreasingComparator : public Comparator {\\n    public:\\n    bool compare(int a, int b) {\\n        return a <= b;\\n    }\\n};\\n\\nclass DecreasingComparator : public Comparator {\\n    public:\\n    bool compare(int a, int b) {\\n        return a >= b;\\n    }\\n};\\n\\nclass Solution {\\n\\n    bool isMonotonic(vector<int> nums, Comparator *comparator) {\\n        int N = nums.size();\\n        for(int i = 0; i < N - 1; i++) {\\n            if(!(comparator->compare(nums[i], nums[i + 1]))) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\npublic:\\n    bool isMonotonic(vector<int> &nums) {\\n        if(nums.size() == 1) return true;\\n        if(nums[0] < nums[1]) {\\n            return isMonotonic(nums, new IncreasingComparator());\\n        } else if(nums[0] < nums[1]) {\\n            return isMonotonic(nums, new DecreasingComparator());\\n        } else {\\n            return isMonotonic(nums, new IncreasingComparator()) or isMonotonic(nums, new DecreasingComparator());\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4103096,
                "title": "simple-c-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem asks us to determine whether the given array nums is monotonic, meaning it is entirely non-increasing or non-decreasing. To solve this, we can iterate through the array, keeping track of whether the array is increasing or decreasing. If at any point we encounter a violation of the chosen order, the array is not monotonic.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize Variables: We start by initializing a variable `res` to 0, which will keep track of the ordering (`0 for not determined`, `1 for increasing`, and `-1 for decreasing`). Also, we get the size of the input array nums.\\n\\n2. Iterate Through the Array: We traverse the array from index 0 to n-2 (where n is the size of the array) to compare each element with the next one.\\n\\n3. Compare Elements:\\n\\n    - If the current element is greater than the next element (`nums[i] > nums[i+1]`), it means we have a `decreasing` order. We update `res to -1` accordingly.\\n    - If the current element is less than the next element (`nums[i] < nums[i+1]`), it means we have an `increasing` order. We update `res to 1` accordingly.\\nCheck for Conflicting Orders:\\n\\nIf we encounter a conflicting order (e.g., increasing followed by decreasing or vice versa), we return false since the array is not monotonic.\\nReturn Result:\\n\\nIf we traverse the entire array without encountering any conflicts, we return true, indicating that the array is monotonic.\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        int res = 0;\\n        int n = nums.size();\\n        for(int i =0;i<n-1; i++){\\n            if(nums[i] > nums[i+1]){\\n                if(res == 0) res = -1;\\n                else if(res == 1) return false;\\n            }\\n            else if(nums[i] < nums[i+1]){\\n                if(res == 0) res = 1;\\n                else if(res == -1) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        int res = 0;\\n        int n = nums.size();\\n        for(int i =0;i<n-1; i++){\\n            if(nums[i] > nums[i+1]){\\n                if(res == 0) res = -1;\\n                else if(res == 1) return false;\\n            }\\n            else if(nums[i] < nums[i+1]){\\n                if(res == 0) res = 1;\\n                else if(res == -1) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744092,
                "title": "monotonic-array-i",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        boolean increasing = true;\\n        boolean decreasing = true;\\n\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            if (nums[i] > nums[i + 1]) {\\n                increasing = false;\\n            }\\n            if (nums[i] < nums[i + 1]) {\\n                decreasing = false;\\n            }\\n        }\\n\\n        return increasing || decreasing;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        boolean increasing = true;\\n        boolean decreasing = true;\\n\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            if (nums[i] > nums[i + 1]) {\\n                increasing = false;\\n            }\\n            if (nums[i] < nums[i + 1]) {\\n                decreasing = false;\\n            }\\n        }\\n\\n        return increasing || decreasing;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668199,
                "title": "100-beats-java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n\\n        for(int i = 0; i < nums.length - 1; i++){\\n            if(nums[i] < nums[i + 1]) {\\n                \\n                for(int j = i + 1; j < nums.length - 1; j++){\\n                    if(nums[j] > nums[j + 1]) return false;\\n                }\\n\\n                return true;\\n            }\\n            else if(nums[i] > nums[i + 1]) {\\n                \\n                for(int j = i + 1; j < nums.length - 1; j++){\\n                    if(nums[j] < nums[j + 1]) return false;\\n                }\\n\\n                return true;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n\\n        for(int i = 0; i < nums.length - 1; i++){\\n            if(nums[i] < nums[i + 1]) {\\n                \\n                for(int j = i + 1; j < nums.length - 1; j++){\\n                    if(nums[j] > nums[j + 1]) return false;\\n                }\\n\\n                return true;\\n            }\\n            else if(nums[i] > nums[i + 1]) {\\n                \\n                for(int j = i + 1; j < nums.length - 1; j++){\\n                    if(nums[j] < nums[j + 1]) return false;\\n                }\\n\\n                return true;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538757,
                "title": "might-be-an-overkill",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        vector<int> a,b;\\n        a=b=nums;\\n        sort(a.begin(),a.end());\\n        sort(b.begin(),b.end(),greater<int>());\\n        \\n        if(a==nums || b==nums)\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        vector<int> a,b;\\n        a=b=nums;\\n        sort(a.begin(),a.end());\\n        sort(b.begin(),b.end(),greater<int>());\\n        \\n        if(a==nums || b==nums)\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531698,
                "title": "easy-c-solution",
                "content": "# Intuition\\nCheck if the array is moving in backward direction or foward direction \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1)If size=0 then return true\\n2)Use a for loop to check foward direction if yes then continue till loop end and after thaty check if i =n-1 if yes then return true\\n3)Use a for loop to check backward direction if yes then continue till loop end and after thaty check if i =n-1 if yes then return true\\n4)If none of them work return false\\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) \\n    {\\n      int n=nums.size();\\n      if(n==0){return true;}\\n      int i;\\n        for(i =0;i<n-1;i++)\\n            {\\n                if(nums[i]>=nums[i+1])\\n                continue;\\n                else\\n                break; \\n            }\\n            if(i==n-1)return true;\\n             for(i =0;i<n-1;i++)\\n            {\\n                if(nums[i]<=nums[i+1])\\n                continue;\\n                else\\n                break;\\n            }     if(i==n-1)return true;       \\n    return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) \\n    {\\n      int n=nums.size();\\n      if(n==0){return true;}\\n      int i;\\n        for(i =0;i<n-1;i++)\\n            {\\n                if(nums[i]>=nums[i+1])\\n                continue;\\n                else\\n                break; \\n            }\\n            if(i==n-1)return true;\\n             for(i =0;i<n-1;i++)\\n            {\\n                if(nums[i]<=nums[i+1])\\n                continue;\\n                else\\n                break;\\n            }     if(i==n-1)return true;       \\n    return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519628,
                "title": "100-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n\\n        for(int i = 0; i < nums.length - 1; i++){\\n            if(nums[i] < nums[i + 1]) {\\n                \\n                for(int j = i + 1; j < nums.length - 1; j++){\\n                    if(nums[j] > nums[j + 1]) return false;\\n                }\\n\\n                return true;\\n            }else if(nums[i] > nums[i + 1]) {\\n                \\n                for(int j = i + 1; j < nums.length - 1; j++){\\n                    if(nums[j] < nums[j + 1]) return false;\\n                }\\n\\n                return true;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n\\n        for(int i = 0; i < nums.length - 1; i++){\\n            if(nums[i] < nums[i + 1]) {\\n                \\n                for(int j = i + 1; j < nums.length - 1; j++){\\n                    if(nums[j] > nums[j + 1]) return false;\\n                }\\n\\n                return true;\\n            }else if(nums[i] > nums[i + 1]) {\\n                \\n                for(int j = i + 1; j < nums.length - 1; j++){\\n                    if(nums[j] < nums[j + 1]) return false;\\n                }\\n\\n                return true;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396758,
                "title": "fastest-solution-with-java-as-unique-way",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        \\n        for(int a = 0; a < nums.length-1; a++){\\n            int diff1 = nums[a+1]-nums[a];// First value that representing difference\\n            \\n            while(diff1 == 0){// Control for difference without 0\\n                a++;\\n                if(a+1==nums.length){\\n                    return true;\\n                }\\n                diff1 = nums[a+1]-nums[a];\\n            }\\n            if(diff1>0){// Control for other differences\\n                for(int b = a+1; b < nums.length-1; b++){// If difference is different we will return false;\\n                    int diff2 =  nums[b+1]-nums[b];\\n                    if(diff2<0){\\n                        return false;\\n                    }\\n                }\\n                return true;\\n            }else if(diff1<0){\\n                for(int b = a+1; b < nums.length-1; b++){\\n                    int diff2 =  nums[b+1]-nums[b];\\n                    if(diff2>0){\\n                        return false;\\n                    }\\n                }\\n                return true;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        \\n        for(int a = 0; a < nums.length-1; a++){\\n            int diff1 = nums[a+1]-nums[a];// First value that representing difference\\n            \\n            while(diff1 == 0){// Control for difference without 0\\n                a++;\\n                if(a+1==nums.length){\\n                    return true;\\n                }\\n                diff1 = nums[a+1]-nums[a];\\n            }\\n            if(diff1>0){// Control for other differences\\n                for(int b = a+1; b < nums.length-1; b++){// If difference is different we will return false;\\n                    int diff2 =  nums[b+1]-nums[b];\\n                    if(diff2<0){\\n                        return false;\\n                    }\\n                }\\n                return true;\\n            }else if(diff1<0){\\n                for(int b = a+1; b < nums.length-1; b++){\\n                    int diff2 =  nums[b+1]-nums[b];\\n                    if(diff2>0){\\n                        return false;\\n                    }\\n                }\\n                return true;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3277276,
                "title": "simple-process-o-n-runtime-easy-solution-java",
                "content": "- 371/371 cases passed (2 ms)\\n- Your runtime beats 68.66 % of java submissions\\n- Your memory usage beats 68.13 % of java submissions (52.5 MB)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        int len=nums.length;\\n        \\n        if(len<2)\\n            return true;\\n        boolean asc=nums[0]<nums[len-1];\\n\\n        for(int i=0;i<len-1;i++)\\n            if(nums[i]==nums[i+1]) continue;\\n            else if(asc!=(nums[i]<nums[i+1]))\\n                return false;\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        int len=nums.length;\\n        \\n        if(len<2)\\n            return true;\\n        boolean asc=nums[0]<nums[len-1];\\n\\n        for(int i=0;i<len-1;i++)\\n            if(nums[i]==nums[i+1]) continue;\\n            else if(asc!=(nums[i]<nums[i+1]))\\n                return false;\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3240300,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n\\n    bool inc=true;\\n    bool dec=true;\\n\\n    if (nums.size() == 1)\\n        return true;\\n    else\\n    {\\n            for (int i = 0; i < nums.size() - 1; i++)\\n            {\\n                if (nums[i] > nums[i + 1])\\n                    inc=false;\\n            }\\n            for (int i = 0; i < nums.size() - 1; i++)\\n            {\\n                if (nums[i] < nums[i + 1])\\n                    dec=false;\\n            }\\n    }\\n    return (inc || dec);\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n\\n    bool inc=true;\\n    bool dec=true;\\n\\n    if (nums.size() == 1)\\n        return true;\\n    else\\n    {\\n            for (int i = 0; i < nums.size() - 1; i++)\\n            {\\n                if (nums[i] > nums[i + 1])\\n                    inc=false;\\n            }\\n            for (int i = 0; i < nums.size() - 1; i++)\\n            {\\n                if (nums[i] < nums[i + 1])\\n                    dec=false;\\n            }\\n    }\\n    return (inc || dec);\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038523,
                "title": "easy-to-understand-c-sollution-beats-99-95",
                "content": "```\\nUpvote if it was useful :)\\n```\\n# Approach\\nFirst Search for the increment and decrement point in the array and then from that check the remaining array if it\\'s monotone increasing or monotone decreasing.\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public:\\n    Solution()//Fast IO\\n    {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n    }\\n\\n    bool isMonotonic(vector<int>& nums) \\n    {\\n        if(nums.size()==1)\\n        {\\n            return true;\\n        }\\n\\n        int i=0,j=1;\\n        while( j<nums.size() && nums[i]==nums[j])// break point is searched\\n        {\\n            // getting indexes\\n            i++;\\n            j++;\\n        }\\n\\n\\n        if(j<nums.size() && nums[i]>nums[j])//determining whether increasing or decreasing\\n        {\\n            while(j<nums.size())\\n            {\\n                if(nums[i]<nums[j])\\n                {\\n                    return false;\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        else if(j<nums.size())\\n        {\\n            while(j<nums.size())\\n            {\\n                if(nums[i]>nums[j])\\n                {\\n                    return false;\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nUpvote if it was useful :)\\n```\n```\\nclass Solution \\n{\\n    public:\\n    Solution()//Fast IO\\n    {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n    }\\n\\n    bool isMonotonic(vector<int>& nums) \\n    {\\n        if(nums.size()==1)\\n        {\\n            return true;\\n        }\\n\\n        int i=0,j=1;\\n        while( j<nums.size() && nums[i]==nums[j])// break point is searched\\n        {\\n            // getting indexes\\n            i++;\\n            j++;\\n        }\\n\\n\\n        if(j<nums.size() && nums[i]>nums[j])//determining whether increasing or decreasing\\n        {\\n            while(j<nums.size())\\n            {\\n                if(nums[i]<nums[j])\\n                {\\n                    return false;\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        else if(j<nums.size())\\n        {\\n            while(j<nums.size())\\n            {\\n                if(nums[i]>nums[j])\\n                {\\n                    return false;\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925225,
                "title": "easy-c-solution",
                "content": "\\n## Code 1\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        if (nums.size()<=2) return true;\\n        bool inc= 1;\\n        int i=0;\\n        while (i+1<nums.size() && nums[i]==nums[i+1])++i;\\n        if (i== nums.size()-1)return true;\\n        if (nums[i]>nums[i+1])inc=0;\\n        for (;i+1<nums.size(); i++){\\n            if (inc==1){\\n                if (nums[i]>nums[i+1])return false;\\n            }\\n            else{\\n                if (nums[i]<nums[i+1])return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n## Code 2\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        if (nums.size()<=2) return true;\\n        bool is_increasing= 1;\\n        if (nums[0] > nums.back())is_increasing=0;\\n        for (int i=0; i<nums.size()-1; i++){\\n            if (is_increasing){\\n                if (nums[i]>nums[i+1])return false;\\n            }\\n            else{\\n                if (nums[i]<nums[i+1])return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n### Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        if (nums.size()<=2) return true;\\n        bool inc= 1;\\n        int i=0;\\n        while (i+1<nums.size() && nums[i]==nums[i+1])++i;\\n        if (i== nums.size()-1)return true;\\n        if (nums[i]>nums[i+1])inc=0;\\n        for (;i+1<nums.size(); i++){\\n            if (inc==1){\\n                if (nums[i]>nums[i+1])return false;\\n            }\\n            else{\\n                if (nums[i]<nums[i+1])return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        if (nums.size()<=2) return true;\\n        bool is_increasing= 1;\\n        if (nums[0] > nums.back())is_increasing=0;\\n        for (int i=0; i<nums.size()-1; i++){\\n            if (is_increasing){\\n                if (nums[i]>nums[i+1])return false;\\n            }\\n            else{\\n                if (nums[i]<nums[i+1])return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2704501,
                "title": "solution-in-python-fastest-solution",
                "content": "```\\nclass Solution(object):\\n    def isMonotonic(self, nums):\\n        n=len(nums)\\n        p=0\\n        g=0\\n        for i in range(n-1):\\n            if(p==0): #checking for if it is in ascending or descending order\\n                if nums[i]==nums[i+1]:\\n                    continue\\n                elif nums[i]<nums[i+1]:\\n                    g=1\\n                    p=1\\n                else:\\n                    g=0\\n                    p=1\\n            else:\\n                if nums[i]<nums[i+1] and g==0:\\n                    return False\\n                if nums[i]>nums[i+1] and g==1:\\n                    return False\\n        return True        \\n                    z\\n        \\n\\t\\t```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def isMonotonic(self, nums):\\n        n=len(nums)\\n        p=0\\n        g=0\\n        for i in range(n-1):\\n            if(p==0): #checking for if it is in ascending or descending order\\n                if nums[i]==nums[i+1]:\\n                    continue\\n                elif nums[i]<nums[i+1]:\\n                    g=1\\n                    p=1\\n                else:\\n                    g=0\\n                    p=1\\n            else:\\n                if nums[i]<nums[i+1] and g==0:\\n                    return False\\n                if nums[i]>nums[i+1] and g==1:\\n                    return False\\n        return True        \\n                    z\\n        \\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2677841,
                "title": "easy-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n       bool inc=true;\\n        bool dec=true;\\n        int i;\\n       for(i=0;i<nums.size()-1;i++)   \\n        {\\n            if(nums[i]>nums[i+1])\\n            \\n                inc=false;\\n            \\n            else if(nums[i]<nums[i+1])\\n            \\n                dec=false;\\n            \\n             if(inc==false && dec==false)\\n                 return false;\\n        }\\n        return true;\\n    }\\n};\\n\\n\\n \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n       bool inc=true;\\n        bool dec=true;\\n        int i;\\n       for(i=0;i<nums.size()-1;i++)   \\n        {\\n            if(nums[i]>nums[i+1])\\n            \\n                inc=false;\\n            \\n            else if(nums[i]<nums[i+1])\\n            \\n                dec=false;\\n            \\n             if(inc==false && dec==false)\\n                 return false;\\n        }\\n        return true;\\n    }\\n};\\n\\n\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2570142,
                "title": "js-simple-solution-with-o-n",
                "content": "```\\nconst CONST = {\\n    EQUAL: \\'EQUAL\\',\\n    DECREASING: \\'DECREASING\\',\\n    INCREASING: \\'INCREASING\\',\\n}\\n\\nvar isMonotonic = function(nums) {\\n    let status = CONST.EQUAL;\\n\\n    for (let i = 0; i < nums.length - 1; i++) {\\n        if (nums[i] < nums[i + 1] && [CONST.EQUAL,CONST.INCREASING].includes(status)) {\\n            status = CONST.INCREASING;\\n        } else if (nums[i] > nums[i + 1] && [CONST.EQUAL, CONST.DECREASING].includes(status)) {\\n            status = CONST.DECREASING;\\n        } else if (nums[i] !== nums[i + 1]) {\\n            return false;\\n        }\\n    }\\n\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst CONST = {\\n    EQUAL: \\'EQUAL\\',\\n    DECREASING: \\'DECREASING\\',\\n    INCREASING: \\'INCREASING\\',\\n}\\n\\nvar isMonotonic = function(nums) {\\n    let status = CONST.EQUAL;\\n\\n    for (let i = 0; i < nums.length - 1; i++) {\\n        if (nums[i] < nums[i + 1] && [CONST.EQUAL,CONST.INCREASING].includes(status)) {\\n            status = CONST.INCREASING;\\n        } else if (nums[i] > nums[i + 1] && [CONST.EQUAL, CONST.DECREASING].includes(status)) {\\n            status = CONST.DECREASING;\\n        } else if (nums[i] !== nums[i + 1]) {\\n            return false;\\n        }\\n    }\\n\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2565016,
                "title": "with-explanation-comments-time-247-ms-60-49-space-96-4-mb-65-83",
                "content": "**Like it? ->Upvote please!** \\u30C4\\n\\n**Solution 1: Two passes**\\n\\n\\nTime: 380 ms (10.93%), Space: 104.4 MB (6.47%) \\nTC: O(n)   //iterate the array\\nSC: O(1)\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    \\n    bool decreasing(vector<int> nums){\\n        \\n        //loop over the whole array elements\\n        for(int i=0;i<nums.size()-1;i++)\\n            //check if the array elements is decresing or not\\n            if(nums[i]>nums[i+1])\\n                //if not-> false\\n                return false;\\n        \\n        //if yes-> true\\n        return true;\\n    }\\n    \\n    bool increasing(vector<int> nums){\\n        \\n        //loop over the whole array elements\\n        for(int i=0;i<nums.size()-1;i++)\\n            //check if the array elements is incresing or not\\n            if(nums[i]<nums[i+1])\\n                //if not-> false\\n                return false;\\n        \\n        //if yes-> true\\n        return true;\\n    }\\n    \\n    bool isMonotonic(vector<int>& nums) {\\n        \\n        //check if the array elements are either ALL increasing or ALL decreasing\\n        return increasing(nums) || decreasing(nums);\\n   \\n    }\\n};\\n\\'\\'\\'\\n\\n**Solution 2: One pass**\\n\\n\\nTime: 247 ms (60.49%), Space: 96.4 MB (65.83%)\\nTC: O(n)   //iterate the array\\nSC: O(1)\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        \\n        //initialize two boolean flags with initial values of true\\n        bool inc=true, dec=true;\\n        \\n        //loop over the whole array elements\\n        for(int i=0;i<nums.size()-1;i++){\\n            \\n            //check if the array elements aren\\'t in increasing order\\n            if(nums[i]>nums[i+1])\\n                inc=false;\\n            //check if the array elements aren\\'t in increasing order\\n            if(nums[i]<nums[i+1])\\n                //dec flag is off\\n                dec=false;\\n        }\\n        \\n        //retrun if there\\'s a true value of either ALL increasing or ALL decreasing\\n        return inc || dec;\\n    }\\n};\\n\\'\\'\\'\\n\\n\\n**Like it? ->Upvote please!** \\u30C4\\n**If still not understood, feel free to comment. I will help you out**\\n**Happy Coding :)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    bool decreasing(vector<int> nums){\\n        \\n        //loop over the whole array elements\\n        for(int i=0;i<nums.size()-1;i++)\\n            //check if the array elements is decresing or not\\n            if(nums[i]>nums[i+1])\\n                //if not-> false\\n                return false;\\n        \\n        //if yes-> true\\n        return true;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2521034,
                "title": "c-simple-solution-using-is-sorted-function",
                "content": "# Simple use of is_sorted() function\\n```\\n#include <vector>  \\n#include <algorithm>  \\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        if(is_sorted(nums.begin(), nums.end()))  // check for ascending order\\n            return true;\\n        else if(is_sorted(nums.begin(),nums.end(),greater<int>()))  //check for descending\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#include <vector>  \\n#include <algorithm>  \\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        if(is_sorted(nums.begin(), nums.end()))  // check for ascending order\\n            return true;\\n        else if(is_sorted(nums.begin(),nums.end(),greater<int>()))  //check for descending\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2497338,
                "title": "java-1-ms-beats-100-easy-lol",
                "content": "```\\nint count = 0 ;\\n        //we take count variable ;\\n        \\n        //first we iterate and check for monotonically increasing array ;\\n        for(int i = 0 ; i < nums.length -1 ; i++){\\n            if(nums[i]<=nums[i+1]){\\n                continue ;\\n            }else{\\n                count ++;\\n                break ;\\n            }\\n        }\\n        //then we iterate and check for monotonically decreasing array ;\\n        for(int i = 0 ; i < nums.length -1 ; i++){\\n            if(nums[i]>=nums[i+1]){\\n                continue; \\n            }else{\\n                count ++;\\n                break ;\\n            }\\n        }\\n        //if count == 2 then that means it broke out of both the loops so its not monotonic array ;else we return true ;\\n        if(count == 2){\\n           return false;\\n        }else{\\n            return true;\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nint count = 0 ;\\n        //we take count variable ;\\n        \\n        //first we iterate and check for monotonically increasing array ;\\n        for(int i = 0 ; i < nums.length -1 ; i++){\\n            if(nums[i]<=nums[i+1]){\\n                continue ;\\n            }else{\\n                count ++;\\n                break ;\\n            }\\n        }\\n        //then we iterate and check for monotonically decreasing array ;\\n        for(int i = 0 ; i < nums.length -1 ; i++){\\n            if(nums[i]>=nums[i+1]){\\n                continue; \\n            }else{\\n                count ++;\\n                break ;\\n            }\\n        }\\n        //if count == 2 then that means it broke out of both the loops so its not monotonic array ;else we return true ;\\n        if(count == 2){\\n           return false;\\n        }else{\\n            return true;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 2495159,
                "title": "two-naughty-solutions-in-java-concise-and-easy",
                "content": "Solution 1:\\n```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        int n=nums.length,i,incr=0,decr=0,eq=0;\\n        for(i=1;i<n;i++){\\n            if(nums[i-1]<nums[i]) incr++;\\n            else if(nums[i-1]>nums[i]) decr++;\\n            if(incr > 0 && decr > 0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\nSolution 2:\\n```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        Integer num[] = new Integer[nums.length], numm[] = new Integer[nums.length];\\n        for(int i=0;i<nums.length;num[i]=numm[i]=nums[i],i++);\\n        Arrays.sort(numm); Arrays.sort(num,(a,b)->b-a);\\n        return Arrays.toString(numm).equals(Arrays.toString(nums)) || Arrays.toString(num).equals(Arrays.toString(nums));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        int n=nums.length,i,incr=0,decr=0,eq=0;\\n        for(i=1;i<n;i++){\\n            if(nums[i-1]<nums[i]) incr++;\\n            else if(nums[i-1]>nums[i]) decr++;\\n            if(incr > 0 && decr > 0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        Integer num[] = new Integer[nums.length], numm[] = new Integer[nums.length];\\n        for(int i=0;i<nums.length;num[i]=numm[i]=nums[i],i++);\\n        Arrays.sort(numm); Arrays.sort(num,(a,b)->b-a);\\n        return Arrays.toString(numm).equals(Arrays.toString(nums)) || Arrays.toString(num).equals(Arrays.toString(nums));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2435863,
                "title": "c-5-line-code-without-loop-or-anything-super-easy-documented",
                "content": "There is only 2 condition: \\n1. All previous elements are less or equal than current element.\\n2. Or all previous elements are greater or equal than current element.\\n\\nThat mean the **array shoud be sorted in accending order or in decending order**.........That\\'s it.\\n\\n```\\nbool isMonotonic(vector<int>& nums) {\\n        \\n        vector<int> temp = nums;\\n        sort(temp.begin(), temp.end());\\n        \\n        if(nums == temp) return 1;\\n        reverse(temp.begin(), temp.end());\\n        if(nums == temp) return 1;\\n        \\n        return 0;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool isMonotonic(vector<int>& nums) {\\n        \\n        vector<int> temp = nums;\\n        sort(temp.begin(), temp.end());\\n        \\n        if(nums == temp) return 1;\\n        reverse(temp.begin(), temp.end());\\n        if(nums == temp) return 1;\\n        \\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2151355,
                "title": "monotonic-array",
                "content": "This is done in the following way:\\n* Check for any disruption of the given condition in the first case that is for the increasing order of array. Take pointer pointing to the 1st index element and check if the condition doesn\\'t satisfy (i.e. arr[i-1]<=arr[i]) considering the previous adjacent element using a bool variable.\\n* Now take the second case i.e. for the decreasing order of the array. Follow the same method as of the increasing case. Take another bool variable that takes account of this condition (i.e. arr[i-1] > arr[i]).\\n* Now we can see that an array can\\'t be monotonically increasing or decreasing at the same time so we need to use the \\'or\\' operator to get the desired result.\\n\\nImplementation is as follows:\\n```\\nbool isMonotonic(vector<int>& nums) {\\n        bool monoInc=true, monoDec=true;\\n\\t\\t\\n\\t\\t//checking for monotonically increasing\\n        for(int i=1; i<nums.size(); i++){\\n            if(nums[i-1]> nums[i]){\\n                monoInc=false;\\n            }\\n        }\\n\\t\\t\\n\\t\\t//check for monotonically decreasing\\n        for(int i=1; i<nums.size();i++){\\n            if(nums[i-1]<nums[i]){\\n                monoDec=false;\\n            }\\n        }\\n        return monoInc or monoDec;\\n    }\\n\\t```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool isMonotonic(vector<int>& nums) {\\n        bool monoInc=true, monoDec=true;\\n\\t\\t\\n\\t\\t//checking for monotonically increasing\\n        for(int i=1; i<nums.size(); i++){\\n            if(nums[i-1]> nums[i]){\\n                monoInc=false;\\n            }\\n        }\\n\\t\\t\\n\\t\\t//check for monotonically decreasing\\n        for(int i=1; i<nums.size();i++){\\n            if(nums[i-1]<nums[i]){\\n                monoDec=false;\\n            }\\n        }\\n        return monoInc or monoDec;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2150286,
                "title": "c-easy-to-understand-one-pass",
                "content": "First check if it should be increasing or decreasing by looking at the two ends.\\nChecking the first two elements is also possible, but be aware of the special case where only one element exists.\\nIf it should be increasing but you found nums[i] > nums[i + 1], it\\'s not monotonic.\\nSame goes with the decreasing case.\\n\\n**Code:**\\n```\\nclass Solution {\\n public:\\n  bool IsMonotonic(const vector<int> &nums) {\\n    const int n = nums.size();\\n    if (nums.front() <= nums.back()) {\\n      for (int i = 0; i < n - 1; i++)\\n        if (nums[i] > nums[i + 1]) return false;\\n    } else {\\n      for (int i = 0; i < n - 1; i++)\\n        if (nums[i] < nums[i + 1]) return false;\\n    }\\n    return true;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  bool IsMonotonic(const vector<int> &nums) {\\n    const int n = nums.size();\\n    if (nums.front() <= nums.back()) {\\n      for (int i = 0; i < n - 1; i++)\\n        if (nums[i] > nums[i + 1]) return false;\\n    } else {\\n      for (int i = 0; i < n - 1; i++)\\n        if (nums[i] < nums[i + 1]) return false;\\n    }\\n    return true;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2130646,
                "title": "easy-java-solution-beginner-friendly",
                "content": "* class Solution {\\n*     public boolean isMonotonic(int[] nums) {\\n*         boolean inc = false;\\n*         boolean dec = false;\\n*         \\n*         for (int i = 0; i < nums.length - 1; i++) {\\n*             if (nums[i+1] > nums[i]) inc = true;\\n*             if (nums[i+1] < nums[i]) dec = true;\\n*             if (inc && dec) return false;\\n*         }\\n*         \\n*         return true;\\n*     }\\n* }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n*     public boolean isMonotonic(int[] nums) {\\n*         boolean inc = false;\\n*         boolean dec = false;\\n*         \\n*         for (int i = 0; i < nums.length - 1; i++) {\\n*             if (nums[i+1] > nums[i]) inc = true;\\n*             if (nums[i+1] < nums[i]) dec = true;\\n*             if (inc && dec) return false;\\n*         }",
                "codeTag": "Java"
            },
            {
                "id": 2067734,
                "title": "monotonic-array-t-o-n-s-o-1",
                "content": "```\\nclass Solution:\\n    #T=O(n), S=O(1)\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        #we don\\'t know if the array is monotonic increasing or decreasing\\n        #check both scenarios\\n        increasing, decreasing = True, True\\n        #iterate from index 0 to len-2 (range() excludes the last position)\\n        for i in range(len(nums)-1):\\n            #monotonic increasing should have next item greater than or equal to current item\\n            if nums[i+1] < nums[i]:\\n                increasing = False\\n            #monotonic decreasing should have next item lesser than or equal to current item\\n            if nums[i+1] > nums[i]:\\n                decreasing = False\\n        #either of condition should be Truthy for monotonicity\\n        return increasing or decreasing\\n```\\n\\n```\\nclass Solution:\\n    #T=O(n),S=O(n)\\n    #monostack\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        i_stack = []\\n        d_stack = []\\n        increasing = decreasing = True\\n        \\n        #mono increasing\\n        for n in nums:\\n            while i_stack and i_stack[-1] > n:\\n                increasing = False\\n                break\\n            if not increasing: \\n                break\\n            i_stack.append(n)\\n            \\n\\n        #mono decreasing\\n        for n in nums:\\n            while d_stack and d_stack[-1] < n:\\n                decreasing = False\\n                break\\n            if not decreasing: \\n                break\\n            d_stack.append(n)\\n        \\n        return increasing or decreasing\\n```",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    #T=O(n), S=O(1)\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        #we don\\'t know if the array is monotonic increasing or decreasing\\n        #check both scenarios\\n        increasing, decreasing = True, True\\n        #iterate from index 0 to len-2 (range() excludes the last position)\\n        for i in range(len(nums)-1):\\n            #monotonic increasing should have next item greater than or equal to current item\\n            if nums[i+1] < nums[i]:\\n                increasing = False\\n            #monotonic decreasing should have next item lesser than or equal to current item\\n            if nums[i+1] > nums[i]:\\n                decreasing = False\\n        #either of condition should be Truthy for monotonicity\\n        return increasing or decreasing\\n```\n```\\nclass Solution:\\n    #T=O(n),S=O(n)\\n    #monostack\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        i_stack = []\\n        d_stack = []\\n        increasing = decreasing = True\\n        \\n        #mono increasing\\n        for n in nums:\\n            while i_stack and i_stack[-1] > n:\\n                increasing = False\\n                break\\n            if not increasing: \\n                break\\n            i_stack.append(n)\\n            \\n\\n        #mono decreasing\\n        for n in nums:\\n            while d_stack and d_stack[-1] < n:\\n                decreasing = False\\n                break\\n            if not decreasing: \\n                break\\n            d_stack.append(n)\\n        \\n        return increasing or decreasing\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024441,
                "title": "c-easy-solution",
                "content": "\\tbool isMonotonic(vector<int>& nums) {\\n        bool isInc = false;\\n        bool isDec = false;\\n        for (int i = 0; i < nums.size()-1; i++) {\\n            if (nums[i] > nums[i+1]) isDec = true;\\n            else if (nums[i] < nums[i+1]) isInc = true;\\n        }\\n        return !(isInc && isDec);\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "\\tbool isMonotonic(vector<int>& nums) {\\n        bool isInc = false;\\n        bool isDec = false;\\n        for (int i = 0; i < nums.size()-1; i++) {\\n            if (nums[i] > nums[i+1]) isDec = true;\\n            else if (nums[i] < nums[i+1]) isInc = true;\\n        }\\n        return !(isInc && isDec);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1970573,
                "title": "java-beats-100-00-memory-speed-0ms-april-2022",
                "content": "\\n\\tclass Solution {\\n\\n    public boolean isMonotonic(int[] A) {\\n     boolean increasing = false, decreasing = false;\\n     for(int i = 1; i< A.length; i++){\\n         if(A[i] < A[i-1]) decreasing = true;\\n         if(A[i] > A[i-1]) increasing = true;\\n     }\\n     return increasing && decreasing ? false: true;\\n    }\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public boolean isMonotonic(int[] A) {\\n     boolean increasing = false, decreasing = false;\\n     for(int i = 1; i< A.length; i++){\\n         if(A[i] < A[i-1]) decreasing = true;\\n         if(A[i] > A[i-1]) increasing = true;\\n     }",
                "codeTag": "Java"
            },
            {
                "id": 1844612,
                "title": "python-o-n-easy",
                "content": "**1.** **We just need to check if there is both increasing and decreasing sequence in `nums`.**\\n**2.** **The answer is `False` iff there is both the sequence in `nums` else it is `True`.**\\n##### Code in Python:\\n```\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        inc = dec = False\\n        for i in range(1, len(nums)):\\n            if nums[i] > nums[i-1]:\\n                inc = True\\n            if nums[i] < nums[i-1]:\\n                dec = True\\n        return False if inc and dec else True\\n    \\n    # TC: O(N)\\n    # SC: O(1)\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        inc = dec = False\\n        for i in range(1, len(nums)):\\n            if nums[i] > nums[i-1]:\\n                inc = True\\n            if nums[i] < nums[i-1]:\\n                dec = True\\n        return False if inc and dec else True\\n    \\n    # TC: O(N)\\n    # SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1801447,
                "title": "problem-no-896-easy-solution-for-beginners-c",
                "content": "```\\nclass Solution{\\npublic:\\n    bool isMonotonic(vector<int> &nums){\\n        int len = nums.size();\\n        int increasing = 1, decreasing = 1;\\n        for(int i = 0; i < len-1; i++){\\n            if (nums[i] <= nums[i+1]){\\n                increasing++;\\n            } \\n            if (nums[i] >= nums[i+1]){\\n                decreasing++;\\n            }\\n        }\\n        if(increasing == len || decreasing == len){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n***Please upvote if it was helpful for you, thank you!***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution{\\npublic:\\n    bool isMonotonic(vector<int> &nums){\\n        int len = nums.size();\\n        int increasing = 1, decreasing = 1;\\n        for(int i = 0; i < len-1; i++){\\n            if (nums[i] <= nums[i+1]){\\n                increasing++;\\n            } \\n            if (nums[i] >= nums[i+1]){\\n                decreasing++;\\n            }\\n        }\\n        if(increasing == len || decreasing == len){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785987,
                "title": "python-one-pass-solution",
                "content": "```\\nclass Solution:\\n    def isMonotonic(self, a: List[int]) -> bool:\\n        \\n        if len(a) < 3:\\n            return True\\n        \\n        is_monotonically_increasing = True\\n        is_monotonically_decreasing = True\\n        \\n        for i in range(1, len(a)):\\n            \\n            if a[i-1] > a[i]:\\n                is_monotonically_increasing = False\\n            \\n            if a[i-1] < a[i]:\\n                is_monotonically_decreasing = False\\n                \\n               \\n        return is_monotonically_increasing or is_monotonically_decreasing  \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isMonotonic(self, a: List[int]) -> bool:\\n        \\n        if len(a) < 3:\\n            return True\\n        \\n        is_monotonically_increasing = True\\n        is_monotonically_decreasing = True\\n        \\n        for i in range(1, len(a)):\\n            \\n            if a[i-1] > a[i]:\\n                is_monotonically_increasing = False\\n            \\n            if a[i-1] < a[i]:\\n                is_monotonically_decreasing = False\\n                \\n               \\n        return is_monotonically_increasing or is_monotonically_decreasing  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1640054,
                "title": "golang-one-pass-solution",
                "content": "```\\nfunc isMonotonic(nums []int) bool {\\n    isIncreasing := true\\n    isDecreasing := true\\n    \\n    for i := 0; i < len(nums) - 1; i++ {\\n        isIncreasing = isIncreasing && nums[i] <= nums[i + 1]\\n        isDecreasing = isDecreasing && nums[i] >= nums[i + 1]\\n    }\\n    \\n    return isIncreasing || isDecreasing\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc isMonotonic(nums []int) bool {\\n    isIncreasing := true\\n    isDecreasing := true\\n    \\n    for i := 0; i < len(nums) - 1; i++ {\\n        isIncreasing = isIncreasing && nums[i] <= nums[i + 1]\\n        isDecreasing = isDecreasing && nums[i] >= nums[i + 1]\\n    }\\n    \\n    return isIncreasing || isDecreasing\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1549134,
                "title": "javascript-solution-one-pass-o-n",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar isMonotonic = function(nums) {\\n    let isMonotonicallyIncreasing = null\\n    for(let i=1;i<nums.length;i++) {\\n        if(nums[i] > nums[i-1]) {\\n            if(isMonotonicallyIncreasing === false) {\\n                return false\\n            }\\n            isMonotonicallyIncreasing = true\\n        } else if (nums[i] < nums[i-1]) {\\n            if(isMonotonicallyIncreasing === true) {\\n                return false\\n            }\\n            isMonotonicallyIncreasing = false\\n        }\\n    }\\n    return true\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar isMonotonic = function(nums) {\\n    let isMonotonicallyIncreasing = null\\n    for(let i=1;i<nums.length;i++) {\\n        if(nums[i] > nums[i-1]) {\\n            if(isMonotonicallyIncreasing === false) {\\n                return false\\n            }\\n            isMonotonicallyIncreasing = true\\n        } else if (nums[i] < nums[i-1]) {\\n            if(isMonotonicallyIncreasing === true) {\\n                return false\\n            }\\n            isMonotonicallyIncreasing = false\\n        }\\n    }\\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1488559,
                "title": "java-100-faster-easy",
                "content": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n\\t    //Edge case\\n        if(nums.length == 1) return true;\\n        boolean increasing = true;\\n        boolean decreasing = true;\\n        for(int i = 0; i < nums.length - 1; i++) {\\n            if(increasing && nums[i+1] < nums[i]) {\\n                increasing = false;\\n            } else if(decreasing && nums[i+1] > nums[i]) {\\n                decreasing = false;\\n            } \\n        }\\n        return increasing || decreasing;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n\\t    //Edge case\\n        if(nums.length == 1) return true;\\n        boolean increasing = true;\\n        boolean decreasing = true;\\n        for(int i = 0; i < nums.length - 1; i++) {\\n            if(increasing && nums[i+1] < nums[i]) {\\n                increasing = false;\\n            } else if(decreasing && nums[i+1] > nums[i]) {\\n                decreasing = false;\\n            } \\n        }\\n        return increasing || decreasing;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1450395,
                "title": "easy-faster-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        int flag1=true,flag2=true;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i-1]>nums[i])flag1=false;//decreasing\\n            if(nums[i-1]<nums[i])flag2=false;//increasing\\n        }\\n        return flag1|| flag2;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        int flag1=true,flag2=true;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i-1]>nums[i])flag1=false;//decreasing\\n            if(nums[i-1]<nums[i])flag2=false;//increasing\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1285678,
                "title": "python-3-line-solution",
                "content": "```\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        copy = nums.copy()\\n        copy.sort()\\n        return (nums == copy or nums == copy[::-1])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        copy = nums.copy()\\n        copy.sort()\\n        return (nums == copy or nums == copy[::-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1213841,
                "title": "c-simple-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool isMonotonic(vector<int>& nums) {\\n\\t\\t\\tbool incr = true;\\n\\t\\t\\tbool decr = true;\\n\\t\\t\\tfor(int i = 0; i < nums.size() - 1; i++){\\n\\t\\t\\t\\tif(nums[i] > nums[i + 1]){\\\\\\n\\t\\t\\t\\t\\tincr = false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(nums[i] < nums[i + 1]){\\n\\t\\t\\t\\t\\tdecr = false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(incr == false && decr == false){\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool isMonotonic(vector<int>& nums) {\\n\\t\\t\\tbool incr = true;\\n\\t\\t\\tbool decr = true;\\n\\t\\t\\tfor(int i = 0; i < nums.size() - 1; i++){\\n\\t\\t\\t\\tif(nums[i] > nums[i + 1]){\\\\\\n\\t\\t\\t\\t\\tincr = false;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1200898,
                "title": "so-much-simple-solution",
                "content": "```\\nclass Solution:\\n    def isMonotonic(self, A: List[int]) -> bool:\\n        if sorted(A)==A or sorted(A,reverse=True)==A:\\n            return True\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def isMonotonic(self, A: List[int]) -> bool:\\n        if sorted(A)==A or sorted(A,reverse=True)==A:\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1116137,
                "title": "python-one-liner",
                "content": "```\\ndef isMonotonic(self, A: List[int]) -> bool:\\n        return True if A == sorted(A, reverse=True) or A == sorted(A) else False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef isMonotonic(self, A: List[int]) -> bool:\\n        return True if A == sorted(A, reverse=True) or A == sorted(A) else False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 981237,
                "title": "easiest-python-solution",
                "content": "```\\nclass Solution:\\n    def isMonotonic(self, A: List[int]) -> bool:\\n        if A == sorted(A) or A == sorted(A,reverse=True):\\n            return True\\n        else:\\n            return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isMonotonic(self, A: List[int]) -> bool:\\n        if A == sorted(A) or A == sorted(A,reverse=True):\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 783272,
                "title": "c-1-line-answer",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& A) {\\n        return is_sorted(A.begin(),A.end()) || is_sorted(A.rbegin(),A.rend());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& A) {\\n        return is_sorted(A.begin(),A.end()) || is_sorted(A.rbegin(),A.rend());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 754271,
                "title": "javascript-solution",
                "content": "```\\nvar isMonotonic = function(A) {\\n    let increasing = true, decreasing = true;\\n    for (i = 0; i < A.length; i++) {\\n        if (A[i] < A[i+1]){\\n             decreasing = false;\\n        }\\n        else if (A[i] > A[i+1]) {\\n            increasing = false;\\n        }\\n        else if (A[i] === A[i+1]){\\n             continue;\\n        }\\n    }\\n    return increasing || decreasing;\\n};\\n```\\n\\n**Runtime: 92 ms, faster than 51.76% of JavaScript online submissions for Monotonic Array.\\nMemory Usage: 43 MB, less than 20.34% of JavaScript online submissions for Monotonic Array.**",
                "solutionTags": [],
                "code": "```\\nvar isMonotonic = function(A) {\\n    let increasing = true, decreasing = true;\\n    for (i = 0; i < A.length; i++) {\\n        if (A[i] < A[i+1]){\\n             decreasing = false;\\n        }\\n        else if (A[i] > A[i+1]) {\\n            increasing = false;\\n        }\\n        else if (A[i] === A[i+1]){\\n             continue;\\n        }\\n    }\\n    return increasing || decreasing;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 739246,
                "title": "python-easy-solution",
                "content": "Python O(n) Solution :\\n```\\ndef isMonotonic(self, A: List[int]) -> bool:\\n        \\n        increasing = decreasing = True\\n        \\n        for i in range(len(A)-1):\\n            \\n            if A[i] > A[i+1]:\\n                increasing = False\\n            if A[i] < A[i+1]:\\n                decreasing = False\\n            \\n        return increasing or decreasing\\n```\\n\\nPython O(n2) Solution:\\n```\\ndef isMonotonic(self, A: List[int]) -> bool:\\n\\t\\t\\tc = 0\\n\\t\\t\\tfor i in range(1,len(A)):\\n\\t\\t\\t\\tif A[i-1] <= A[i] :\\n\\t\\t\\t\\t\\tc += 1\\n\\n\\t\\t\\tif len(A) - 1 == c:\\n\\t\\t\\t\\treturn True\\n\\n\\t\\t\\tc = 0\\n\\t\\t\\tfor i in range(1,len(A)):\\n\\t\\t\\t\\tif A[i-1] >= A[i] :\\n\\t\\t\\t\\t\\tc += 1\\n\\n\\t\\t\\tif len(A) - 1 == c:\\n\\t\\t\\t\\treturn True\\n\\n\\t\\t\\treturn False\\n```",
                "solutionTags": [],
                "code": "```\\ndef isMonotonic(self, A: List[int]) -> bool:\\n        \\n        increasing = decreasing = True\\n        \\n        for i in range(len(A)-1):\\n            \\n            if A[i] > A[i+1]:\\n                increasing = False\\n            if A[i] < A[i+1]:\\n                decreasing = False\\n            \\n        return increasing or decreasing\\n```\n```\\ndef isMonotonic(self, A: List[int]) -> bool:\\n\\t\\t\\tc = 0\\n\\t\\t\\tfor i in range(1,len(A)):\\n\\t\\t\\t\\tif A[i-1] <= A[i] :\\n\\t\\t\\t\\t\\tc += 1\\n\\n\\t\\t\\tif len(A) - 1 == c:\\n\\t\\t\\t\\treturn True\\n\\n\\t\\t\\tc = 0\\n\\t\\t\\tfor i in range(1,len(A)):\\n\\t\\t\\t\\tif A[i-1] >= A[i] :\\n\\t\\t\\t\\t\\tc += 1\\n\\n\\t\\t\\tif len(A) - 1 == c:\\n\\t\\t\\t\\treturn True\\n\\n\\t\\t\\treturn False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 722989,
                "title": "simple-java",
                "content": "```\\npublic boolean isMonotonic(int[] A) {\\n        boolean increase=A[0]<=A[A.length-1];\\n        \\n        for(int i =1;i<A.length;i++){\\n            if(A[i-1]==A[i]){\\n                continue;\\n            }else if(increase && A[i-1]>A[i]){\\n                return false;\\n            }else if(!increase && A[i-1]<A[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\t\\n\\t```",
                "solutionTags": [],
                "code": "```\\npublic boolean isMonotonic(int[] A) {\\n        boolean increase=A[0]<=A[A.length-1];\\n        \\n        for(int i =1;i<A.length;i++){\\n            if(A[i-1]==A[i]){\\n                continue;\\n            }else if(increase && A[i-1]>A[i]){\\n                return false;\\n            }else if(!increase && A[i-1]<A[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\t\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 712322,
                "title": "easy-js-solution",
                "content": "```\\n/**\\n * @param {number[]} A\\n * @return {boolean}\\n */\\nvar isMonotonic = function(A) {\\n    let increasing = true, decreasing = true;\\n    for (i = 0; i < A.length; i++) {\\n        if (A[i] < A[i+1]) decreasing = false;\\n        else if (A[i] > A[i+1]) increasing = false;\\n        else if (A[i] === A[i+1]) continue;\\n    }\\n    return increasing || decreasing;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} A\\n * @return {boolean}\\n */\\nvar isMonotonic = function(A) {\\n    let increasing = true, decreasing = true;\\n    for (i = 0; i < A.length; i++) {\\n        if (A[i] < A[i+1]) decreasing = false;\\n        else if (A[i] > A[i+1]) increasing = false;\\n        else if (A[i] === A[i+1]) continue;\\n    }\\n    return increasing || decreasing;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 492848,
                "title": "c-one-liner-3-more-modern-c-solutions",
                "content": "```\\nclass Solution {\\n    public:\\n        bool isMonotonic(vector<int>& A) \\n        {\\n            return is_sorted(A.begin(), A.end(), greater<int>()) || is_sorted(A.begin(), A.end(), less<int>());\\n        }\\n};\\n```\\n\\nOr, if you prefer not to use std::is_sorted():\\n```\\nclass Solution {\\n    public:\\n        bool isMonotonic(vector<int>& A) \\n        {\\n            return isMonotonic(A, greater_equal<int>()) || isMonotonic(A, less_equal<int>());\\n        }\\n\\n    protected:\\n        bool isMonotonic(vector<int>& v, function<bool(int, int)> func)\\n        {\\n            for(int i = 1; i < v.size(); ++i)\\n                if(! func(v[i], v[i-1])) return false;\\n            return true;\\n        }\\n};\\n```\\n\\nOr, no build-in functions at all:\\n```\\nclass Solution {\\n    public:\\n        bool isMonotonic(vector<int>& A) \\n        {\\n            return isMonotonic(A, [](int a, int b){return a <= b;}) || isMonotonic(A, [](int a, int b){return a >= b;});\\n        }\\n\\n    protected:\\n        bool isMonotonic(vector<int>& v, function<bool(int, int)> func)\\n        {\\n            for(int i = 1; i < v.size(); ++i)\\n                if(! func(v[i], v[i-1])) return false;\\n            return true;\\n        }\\n};\\n```\\n\\nOr, another way without \"raw loop\":\\n```\\nclass Solution {\\n    public:\\n        bool isMonotonic(vector<int>& A) \\n        {\\n            return isMonotonic(A, greater_equal<int>()) || isMonotonic(A, less_equal<int>());\\n        }\\n\\n    protected:\\n        bool isMonotonic(vector<int>& v, function<bool(int, int)> func)\\n        {\\n            int a = *v.begin();\\n            auto it = find_if(v.begin()+1, v.end(), [&](int b){if(! func(a, b)) return true; a = b; return false;});\\n            return it == v.end();\\n        }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public:\\n        bool isMonotonic(vector<int>& A) \\n        {\\n            return is_sorted(A.begin(), A.end(), greater<int>()) || is_sorted(A.begin(), A.end(), less<int>());\\n        }\\n};\\n```\n```\\nclass Solution {\\n    public:\\n        bool isMonotonic(vector<int>& A) \\n        {\\n            return isMonotonic(A, greater_equal<int>()) || isMonotonic(A, less_equal<int>());\\n        }\\n\\n    protected:\\n        bool isMonotonic(vector<int>& v, function<bool(int, int)> func)\\n        {\\n            for(int i = 1; i < v.size(); ++i)\\n                if(! func(v[i], v[i-1])) return false;\\n            return true;\\n        }\\n};\\n```\n```\\nclass Solution {\\n    public:\\n        bool isMonotonic(vector<int>& A) \\n        {\\n            return isMonotonic(A, [](int a, int b){return a <= b;}) || isMonotonic(A, [](int a, int b){return a >= b;});\\n        }\\n\\n    protected:\\n        bool isMonotonic(vector<int>& v, function<bool(int, int)> func)\\n        {\\n            for(int i = 1; i < v.size(); ++i)\\n                if(! func(v[i], v[i-1])) return false;\\n            return true;\\n        }\\n};\\n```\n```\\nclass Solution {\\n    public:\\n        bool isMonotonic(vector<int>& A) \\n        {\\n            return isMonotonic(A, greater_equal<int>()) || isMonotonic(A, less_equal<int>());\\n        }\\n\\n    protected:\\n        bool isMonotonic(vector<int>& v, function<bool(int, int)> func)\\n        {\\n            int a = *v.begin();\\n            auto it = find_if(v.begin()+1, v.end(), [&](int b){if(! func(a, b)) return true; a = b; return false;});\\n            return it == v.end();\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 439363,
                "title": "java-simplest-1-pass-solution",
                "content": "```\\npublic boolean isMonotonic(int[] A) {\\n\\tboolean isIncreasing = true, isDecreasing = true;\\n\\tfor(int i=1; i<A.length; i++) {\\n\\t\\tif(!isIncreasing && !isDecreasing) return false; //No need to see other numbers anymore\\n\\t\\tif(isIncreasing && A[i-1]>A[i]) isIncreasing = false;\\n\\t\\tif(isDecreasing && A[i-1]<A[i]) isDecreasing = false;\\n\\t}\\n\\treturn isIncreasing || isDecreasing;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean isMonotonic(int[] A) {\\n\\tboolean isIncreasing = true, isDecreasing = true;\\n\\tfor(int i=1; i<A.length; i++) {\\n\\t\\tif(!isIncreasing && !isDecreasing) return false; //No need to see other numbers anymore\\n\\t\\tif(isIncreasing && A[i-1]>A[i]) isIncreasing = false;\\n\\t\\tif(isDecreasing && A[i-1]<A[i]) isDecreasing = false;\\n\\t}\\n\\treturn isIncreasing || isDecreasing;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 401155,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def isMonotonic(self, A: List[int]) -> bool:\\n        inc = True\\n        for i in range(1, len(A)):\\n            if A[i]>=A[i-1]:\\n                pass\\n            else:\\n                inc = False\\n        dec = True\\n        for i in range(1, len(A)):\\n            if A[i]<=A[i-1]:\\n                pass\\n            else:\\n                dec = False\\n        return inc or dec\\n```\\n\\n```\\nclass Solution:\\n    def isMonotonic(self, A: List[int]) -> bool:\\n        inc = True\\n        dec = True\\n        for i in range(1, len(A)):\\n            if A[i] >= A[i-1]:\\n                pass\\n            else:\\n                inc = False\\n                \\n            if A[i] <= A[i-1]:\\n                pass\\n            else:\\n                dec = False\\n                \\n        return inc or dec\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isMonotonic(self, A: List[int]) -> bool:\\n        inc = True\\n        for i in range(1, len(A)):\\n            if A[i]>=A[i-1]:\\n                pass\\n            else:\\n                inc = False\\n        dec = True\\n        for i in range(1, len(A)):\\n            if A[i]<=A[i-1]:\\n                pass\\n            else:\\n                dec = False\\n        return inc or dec\\n```\n```\\nclass Solution:\\n    def isMonotonic(self, A: List[int]) -> bool:\\n        inc = True\\n        dec = True\\n        for i in range(1, len(A)):\\n            if A[i] >= A[i-1]:\\n                pass\\n            else:\\n                inc = False\\n                \\n            if A[i] <= A[i-1]:\\n                pass\\n            else:\\n                dec = False\\n                \\n        return inc or dec\\n```",
                "codeTag": "Java"
            },
            {
                "id": 342431,
                "title": "my-swift-solution",
                "content": "```\\n\\nfunc isMonotonic(_ A: [Int]) -> Bool {\\n    var increasing = true\\n    var decreasing = true\\n    for i in 0..<(A.count - 1) {\\n        if A[i] < A[i + 1] {\\n            decreasing = false\\n        }\\n        if A[i] > A[i + 1] {\\n            increasing = false\\n        }\\n    }\\n    return increasing || decreasing\\n}\\n\\nassert(isMonotonic([1,2,2,3]) == true, \"Failed\")\\nassert(isMonotonic( [6,5,4,4]) == true, \"Failed\")\\nassert(isMonotonic( [1,3,2]) == false, \"Failed\")\\nassert(isMonotonic([1,2,4,5]) == true, \"Failed\")\\nassert(isMonotonic([1,1,1]) == true, \"Failed\")\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nfunc isMonotonic(_ A: [Int]) -> Bool {\\n    var increasing = true\\n    var decreasing = true\\n    for i in 0..<(A.count - 1) {\\n        if A[i] < A[i + 1] {\\n            decreasing = false\\n        }\\n        if A[i] > A[i + 1] {\\n            increasing = false\\n        }\\n    }\\n    return increasing || decreasing\\n}\\n\\nassert(isMonotonic([1,2,2,3]) == true, \"Failed\")\\nassert(isMonotonic( [6,5,4,4]) == true, \"Failed\")\\nassert(isMonotonic( [1,3,2]) == false, \"Failed\")\\nassert(isMonotonic([1,2,4,5]) == true, \"Failed\")\\nassert(isMonotonic([1,1,1]) == true, \"Failed\")\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 290366,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def isMonotonic(self, A: List[int]) -> bool:\\n        inc = A[0] > A[len(A)-1]\\n        \\n        for i in range(0, len(A)-1):\\n            if A[i] < A[i+1]:\\n                if inc == True:\\n                    return False\\n            if A[i] > A[i+1]:\\n                if inc == False:\\n                    return False\\n        return True",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isMonotonic(self, A: List[int]) -> bool:\\n        inc = A[0] > A[len(A)-1]\\n        \\n        for i in range(0, len(A)-1):\\n            if A[i] < A[i+1]:\\n                if inc == True:\\n                    return False\\n            if A[i] > A[i+1]:\\n                if inc == False:\\n                    return False\\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 242133,
                "title": "c-95",
                "content": "Easy to understand C# code that scored faster than 95% on Feb22, 2019.\\n\\n```\\npublic class Solution\\n{\\n    public bool IsMonotonic(int[] A)\\n    {\\n        var length = A.Length;\\n        if (length < 3)\\n        {\\n            return true;\\n        }\\n\\n        if (A[0] < A[length-1])\\n        {\\n            for (int i = 1; i < length; i++)\\n            {\\n                if (A[i-1] > A[i])\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for (int i = 1; i < length; i++)\\n            {\\n                if (A[i-1] < A[i])\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public bool IsMonotonic(int[] A)\\n    {\\n        var length = A.Length;\\n        if (length < 3)\\n        {\\n            return true;\\n        }\\n\\n        if (A[0] < A[length-1])\\n        {\\n            for (int i = 1; i < length; i++)\\n            {\\n                if (A[i-1] > A[i])\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for (int i = 1; i < length; i++)\\n            {\\n                if (A[i-1] < A[i])\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 220592,
                "title": "rust-solution",
                "content": "```Rust\\nimpl Solution {\\n    pub fn is_monotonic(a: Vec<i32>) -> bool {\\n        let mut inc = true;\\n        let mut dec = true;\\n        \\n        for idx in (1..a.len()) {\\n            inc &= a[idx - 1] <= a[idx];\\n            dec &= a[idx - 1] >= a[idx];\\n        }\\n        return inc || dec;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Rust\\nimpl Solution {\\n    pub fn is_monotonic(a: Vec<i32>) -> bool {\\n        let mut inc = true;\\n        let mut dec = true;\\n        \\n        for idx in (1..a.len()) {\\n            inc &= a[idx - 1] <= a[idx];\\n            dec &= a[idx - 1] >= a[idx];\\n        }\\n        return inc || dec;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 169253,
                "title": "c-o-n-using-the-idea-of-derivative-easy-to-understand",
                "content": "```\\n bool isMonotonic(vector<int>& A) {\\n        if(A.size()<=2) return true;\\n        int trend = 0,pre = trend;\\n        for(int i = 1; i < A.size(); i++){\\n            trend = A[i]-A[i-1];\\n            if(trend == 0) continue;\\n            if(pre*trend < 0) return false; // Check the sign\\n            pre = trend;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n bool isMonotonic(vector<int>& A) {\\n        if(A.size()<=2) return true;\\n        int trend = 0,pre = trend;\\n        for(int i = 1; i < A.size(); i++){\\n            trend = A[i]-A[i-1];\\n            if(trend == 0) continue;\\n            if(pre*trend < 0) return false; // Check the sign\\n            pre = trend;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 166290,
                "title": "java-single-loop-solution",
                "content": "```\\npublic boolean isMonotonic(int[] A) {\\n\\t\\tboolean asc = true, desc = true;\\n\\t\\tfor(int i = 1; i < A.length; i++) {\\n\\t\\t\\tif(asc && A[i-1] > A[i]) asc = false;\\n\\t\\t\\tif(desc && A[i-1] < A[i]) desc = false;\\n\\t\\t}\\n\\t\\treturn asc || desc;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean isMonotonic(int[] A) {\\n\\t\\tboolean asc = true, desc = true;\\n\\t\\tfor(int i = 1; i < A.length; i++) {\\n\\t\\t\\tif(asc && A[i-1] > A[i]) asc = false;\\n\\t\\t\\tif(desc && A[i-1] < A[i]) desc = false;\\n\\t\\t}\\n\\t\\treturn asc || desc;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 165884,
                "title": "c-1-liner",
                "content": "1-liner with STL:\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& A) {\\n        return is_sorted(A.begin(), A.end(), less<int>()) || is_sorted(A.begin(), A.end(), greater<int>());\\n    }\\n};\\n```\\n\\nwithout STL:\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& A) {\\n        if (A.size() == 1) return true;\\n        bool increase = false, decrease = false;\\n        for (int i = 1; i < A.size(); ++i) {\\n            if (A[i] > A[i - 1]) {\\n                increase = true;\\n            } else if (A[i] < A[i - 1]) {\\n                decrease = true;\\n            }\\n        }\\n        return !(increase & decrease);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& A) {\\n        return is_sorted(A.begin(), A.end(), less<int>()) || is_sorted(A.begin(), A.end(), greater<int>());\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& A) {\\n        if (A.size() == 1) return true;\\n        bool increase = false, decrease = false;\\n        for (int i = 1; i < A.size(); ++i) {\\n            if (A[i] > A[i - 1]) {\\n                increase = true;\\n            } else if (A[i] < A[i - 1]) {\\n                decrease = true;\\n            }\\n        }\\n        return !(increase & decrease);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4107225,
                "title": "simple-map-reduce",
                "content": "# Intuition\\nCould check `nums[0]` and `nums[len(nums)-1]` to determine increasing / decreasing / constant upfront, but there is no meaningful difference.\\n\\n# Approach\\n- Create an iterator for `is_increasing` and `is_decreasing`.\\n- Use `all()` to reduce them.\\n- Return `True` if either of them reduces to `True`.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n    > worst case two passes (`nums[len(nums)-2]` > `nums[len(nums)-1]`)\\n\\n- Space complexity: $$O(1)$$\\n    > iterators are nice\\n\\n# Code\\n- Using `map` and `lambda`:\\n```\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        is_increasing = map(lambda a, b: a <= b, nums[:len(nums)], nums[1:])\\n        is_decreasing = map(lambda a, b: a >= b, nums[:len(nums)], nums[1:])\\n        return all(is_increasing) or all(is_decreasing)\\n```\\n- Using `generator expression`:\\n```\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        is_increasing = (a <= b for (a, b) in zip(nums[:len(nums)], nums[1:]))\\n        is_decreasing = (a >= b for (a, b) in zip(nums[:len(nums)], nums[1:]))\\n        return all(is_increasing) or all(is_decreasing)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        is_increasing = map(lambda a, b: a <= b, nums[:len(nums)], nums[1:])\\n        is_decreasing = map(lambda a, b: a >= b, nums[:len(nums)], nums[1:])\\n        return all(is_increasing) or all(is_decreasing)\\n```\n```\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        is_increasing = (a <= b for (a, b) in zip(nums[:len(nums)], nums[1:]))\\n        is_decreasing = (a >= b for (a, b) in zip(nums[:len(nums)], nums[1:]))\\n        return all(is_increasing) or all(is_decreasing)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4106989,
                "title": "very-simple-technique-only-6-7-lines-fast-100",
                "content": "# Please Upvote if you liked my Solution \\uD83E\\uDD17\\uD83E\\uDD17\\n> **Please do UpVote** it took lot of time to figure out these solutions\\n\\n# Complexity \\n- Time complexity: $$O(N)$$ where `N = nums.length`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        if( nums.size() <= 2 ) return 1;\\n        int n = nums.size(), d = 0;\\n\\n        // set value of d ( 1 or -1 ) when change occur first time \\n        for(int i=1; i<n; i++){\\n            int dt = nums[i] - nums[i-1];\\n            if( d == 0 && dt != 0 ) d = dt > 0 ? 1 : -1;\\n            else if( dt*d < 0 ) return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```\\n\\n---\\n\\n# Java Code\\n```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        if( nums.length <= 2 ) return true;\\n        int n = nums.length, d = 0;\\n\\n        // set value of d ( 1 or -1 ) when change occur first time \\n        for(int i=1; i<n; i++){\\n            int dt = nums[i] - nums[i-1];\\n            if( d == 0 && dt != 0 ) d = dt > 0 ? 1 : -1;\\n            else if( dt*d < 0 ) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n![upvote-4.png](https://assets.leetcode.com/users/images/5af4e2a5-e8b2-4f46-be00-75247cfdf9ff_1689947516.7818904.png)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        if( nums.size() <= 2 ) return 1;\\n        int n = nums.size(), d = 0;\\n\\n        // set value of d ( 1 or -1 ) when change occur first time \\n        for(int i=1; i<n; i++){\\n            int dt = nums[i] - nums[i-1];\\n            if( d == 0 && dt != 0 ) d = dt > 0 ? 1 : -1;\\n            else if( dt*d < 0 ) return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        if( nums.length <= 2 ) return true;\\n        int n = nums.length, d = 0;\\n\\n        // set value of d ( 1 or -1 ) when change occur first time \\n        for(int i=1; i<n; i++){\\n            int dt = nums[i] - nums[i-1];\\n            if( d == 0 && dt != 0 ) d = dt > 0 ? 1 : -1;\\n            else if( dt*d < 0 ) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 2076399,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Tomorrow is both a weekend and a month-end. Brace yourselves."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s the problem for reference: [132 Pattern](https://leetcode.com/problems/132-pattern/)"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Oh no... Past 2 questions have been too easy, I\\'m afraid tomorrow is going to be a big bad HARD smacked on our face..."
                    },
                    {
                        "username": "user5400vw",
                        "content": "our lives are at stake "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Initialize two boolean variables: isIncreasing and isDecreasing to true\\nStarting from the second element, compare each element with its previous element.\\nIf an element is less than its previous element, set isIncreasing to false (indicating the array is not increasing).\\nIf an element is greater than its previous element, set isDecreasing to false (indicating the array is not decreasing).\\nIf both isIncreasing and isDecreasing are false, break the loop as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nReturn if either isIncreasing or isDecreasing is true since the array is considered monotonic if one of them is true and non monotonic if both are false.\\n\\nwas it helpful ... support by upvote."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Have a nice day!  It\\'s again an easy question.  O(n) solution is expected, but is it possible to create a sublinear solution?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Given the variance of leetCode run times, I suspect that a sample size of 10 is inadequate (especially if all samples are taken on the same day). I\\'m not sure that picking an outlier is the best idea."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@mshoosterman](/mshoosterman) the point is, LC test case developers are well aware of this and normally would give you the worst possible scenarios for all typical implementations."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Why not? Submit 10 times at different time of the day, pick best. The usual statistic gathering routine. How to people measure non-deterministic real life processes?"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) perfect!"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Worstcase sublinear is certainly impossible. Since the list can be sorted except for a single element, which means you necessarily have to check all elements. \\n\\nAverage case is a harder question because you need to ask what is the distribution? if we take our input to be a random list, then consider the average runtime, any failfast solution, which returns false as soon as it sees a contradiction, should actually be pretty close to O(1) average runtime, since most lists will have a contradiction in the first few elements. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Are you relying on the leetCode timer to judge your submission times?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@anwendeng](/anwendeng) well, perhaps it does not beat 100% anymore: https://leetcode.com/submissions/detail/1062141454/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) One of my C++ code using  adjacent_difference has runtime 61 ms & beats 100%, that is a 2 pass code!"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "If we were checking whether the array is *strictly* in/decreasing, we could have taken a binary search approach which we all know has a TC of $O(\\\\log n)$. But alas...  \\nMight be worth mentioning this fact if this problem ever gets asked in an actual interview though!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Managed to get 55 ms and a top execution time for C++ with a simple trick.\nWhen LC gives you test cases, they usually intend to catch improper handling of edge cases.\nConsidering that, for sequences beyond certain length I first check linear ordering of elements at 1/4, 2/4, 3/4-th indexes and the last element. If it holds, then run the usual loop with early exit checking each consecutive pair.\nAlso I always start with comparing the first element with the last element regardless of the length.\nIt still has linear time of course, but in some cases it becomes constant.\nThe previous record was 61 ms with a linear loop containing excessive branch points (which CPUs don't like), but I couldn't get less than 68 ms even for better implementation - tried a dozen of submissions.\n\nP.S. Tried an exponential search (check 1-st, 2-nd, 4-th, 8-th, etc. elements) and got 53 ms after a few tries. That's about it. No ideas how to push it further, except may be tuning the degree base."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@rajan_jasani9](/rajan_jasani9) That\\'s what I did.\\nhttps://leetcode.com/submissions/detail/1061885493/"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) what if we just return False when the 1st violation occurs? "
                    },
                    {
                        "username": "sergei99",
                        "content": "May be if you look at Timsort merge algorithm, that would help. It detects long subsequences with natural ordering and skips entire ranges based on that. It defaults to element by element handling if the natural ordering guess turned out to be wrong - so it has to detect such cases somehow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Aadil42](/Aadil42) Yes. I tried but not successful, 305/371 are pass! A binary search solution can solve some patterns but not all. For example if there is just 1 exception, BS works."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@anwendeng](/anwendeng) When you say sublinear, do you mean O(log(n)) time?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@hero080](/hero080) Yes, sublinear is not possible but you can code your solution for an early exit if the first violation occurs early in the array. (Many solutions keep going to the end of the array regardless of where the first violation occurs)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hero080](/hero080) Yes. A sublinear solution is not possible."
                    },
                    {
                        "username": "hero080",
                        "content": "The solution has to be $\\\\Omega(n)$ because there might be only a single element in `nums` that violates the monotonic condition and we have to check every index to find it."
                    },
                    {
                        "username": "freezeen3",
                        "content": "So guys today is the Chinese Mid-Autumn Festival, it\\'s good to have a relaxing day with Leetcode\\'s support!"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Everyone have a nice Friday! You have more time today for other stuff to do ;)"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I wish I could know what tomorrows hard problem will be, so I can get a head start! "
                    },
                    {
                        "username": "IAmBadAtLeetcode",
                        "content": "no.. need to leetcode more. it was too easy today, need to keep going lol"
                    },
                    {
                        "username": "demaw",
                        "content": "any valid solution must run in (at least) O(n) time. consider the case [3,3,3,3, ... ,7, ... 3,3,3]. because a number like 7 could exist anywhere in a potentially monotonic array full of 3s, we must check every index of the array to be sure that it is monotonic"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "Good Friday easy task. We almost made it in September, keep it up guys!"
                    },
                    {
                        "username": "shakibaenur",
                        "content": "* Initialize two boolean variables: isIncreasing and isDecreasing to false\\n* Start the loop from index 1 compare with its previous element.\\n* If an element is greater than its previous element then set isIncreasing=true(means the array is increasing)\\n* If an element is smaller than its previous element then set isDecreasing=true(means the array is decreasing)\\n* if both isIncreasing and isDecreasing are true then return false and break as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nWas it helpful ... support by upvote."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Month End should be peace like this :)"
                    },
                    {
                        "username": "singlamuskan1208",
                        "content": "Do we have any solution with less than O(n) time complx?"
                    },
                    {
                        "username": "sergei99",
                        "content": "To an extent. We can use some heuristics exploiting the data structure and failing fast for non-ordered sequences (not just trivial early exit from the loop, but there are other techniques).\\nBut proving that sequence is ordered cannot be less than $$O(n)$$."
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I dont think so, because to compare the elements, we must iterate through the array. So to iterate through the array, we must use for loop.\\n"
                    }
                ]
            },
            {
                "id": 2076699,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Tomorrow is both a weekend and a month-end. Brace yourselves."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s the problem for reference: [132 Pattern](https://leetcode.com/problems/132-pattern/)"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Oh no... Past 2 questions have been too easy, I\\'m afraid tomorrow is going to be a big bad HARD smacked on our face..."
                    },
                    {
                        "username": "user5400vw",
                        "content": "our lives are at stake "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Initialize two boolean variables: isIncreasing and isDecreasing to true\\nStarting from the second element, compare each element with its previous element.\\nIf an element is less than its previous element, set isIncreasing to false (indicating the array is not increasing).\\nIf an element is greater than its previous element, set isDecreasing to false (indicating the array is not decreasing).\\nIf both isIncreasing and isDecreasing are false, break the loop as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nReturn if either isIncreasing or isDecreasing is true since the array is considered monotonic if one of them is true and non monotonic if both are false.\\n\\nwas it helpful ... support by upvote."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Have a nice day!  It\\'s again an easy question.  O(n) solution is expected, but is it possible to create a sublinear solution?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Given the variance of leetCode run times, I suspect that a sample size of 10 is inadequate (especially if all samples are taken on the same day). I\\'m not sure that picking an outlier is the best idea."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@mshoosterman](/mshoosterman) the point is, LC test case developers are well aware of this and normally would give you the worst possible scenarios for all typical implementations."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Why not? Submit 10 times at different time of the day, pick best. The usual statistic gathering routine. How to people measure non-deterministic real life processes?"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) perfect!"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Worstcase sublinear is certainly impossible. Since the list can be sorted except for a single element, which means you necessarily have to check all elements. \\n\\nAverage case is a harder question because you need to ask what is the distribution? if we take our input to be a random list, then consider the average runtime, any failfast solution, which returns false as soon as it sees a contradiction, should actually be pretty close to O(1) average runtime, since most lists will have a contradiction in the first few elements. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Are you relying on the leetCode timer to judge your submission times?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@anwendeng](/anwendeng) well, perhaps it does not beat 100% anymore: https://leetcode.com/submissions/detail/1062141454/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) One of my C++ code using  adjacent_difference has runtime 61 ms & beats 100%, that is a 2 pass code!"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "If we were checking whether the array is *strictly* in/decreasing, we could have taken a binary search approach which we all know has a TC of $O(\\\\log n)$. But alas...  \\nMight be worth mentioning this fact if this problem ever gets asked in an actual interview though!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Managed to get 55 ms and a top execution time for C++ with a simple trick.\nWhen LC gives you test cases, they usually intend to catch improper handling of edge cases.\nConsidering that, for sequences beyond certain length I first check linear ordering of elements at 1/4, 2/4, 3/4-th indexes and the last element. If it holds, then run the usual loop with early exit checking each consecutive pair.\nAlso I always start with comparing the first element with the last element regardless of the length.\nIt still has linear time of course, but in some cases it becomes constant.\nThe previous record was 61 ms with a linear loop containing excessive branch points (which CPUs don't like), but I couldn't get less than 68 ms even for better implementation - tried a dozen of submissions.\n\nP.S. Tried an exponential search (check 1-st, 2-nd, 4-th, 8-th, etc. elements) and got 53 ms after a few tries. That's about it. No ideas how to push it further, except may be tuning the degree base."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@rajan_jasani9](/rajan_jasani9) That\\'s what I did.\\nhttps://leetcode.com/submissions/detail/1061885493/"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) what if we just return False when the 1st violation occurs? "
                    },
                    {
                        "username": "sergei99",
                        "content": "May be if you look at Timsort merge algorithm, that would help. It detects long subsequences with natural ordering and skips entire ranges based on that. It defaults to element by element handling if the natural ordering guess turned out to be wrong - so it has to detect such cases somehow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Aadil42](/Aadil42) Yes. I tried but not successful, 305/371 are pass! A binary search solution can solve some patterns but not all. For example if there is just 1 exception, BS works."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@anwendeng](/anwendeng) When you say sublinear, do you mean O(log(n)) time?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@hero080](/hero080) Yes, sublinear is not possible but you can code your solution for an early exit if the first violation occurs early in the array. (Many solutions keep going to the end of the array regardless of where the first violation occurs)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hero080](/hero080) Yes. A sublinear solution is not possible."
                    },
                    {
                        "username": "hero080",
                        "content": "The solution has to be $\\\\Omega(n)$ because there might be only a single element in `nums` that violates the monotonic condition and we have to check every index to find it."
                    },
                    {
                        "username": "freezeen3",
                        "content": "So guys today is the Chinese Mid-Autumn Festival, it\\'s good to have a relaxing day with Leetcode\\'s support!"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Everyone have a nice Friday! You have more time today for other stuff to do ;)"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I wish I could know what tomorrows hard problem will be, so I can get a head start! "
                    },
                    {
                        "username": "IAmBadAtLeetcode",
                        "content": "no.. need to leetcode more. it was too easy today, need to keep going lol"
                    },
                    {
                        "username": "demaw",
                        "content": "any valid solution must run in (at least) O(n) time. consider the case [3,3,3,3, ... ,7, ... 3,3,3]. because a number like 7 could exist anywhere in a potentially monotonic array full of 3s, we must check every index of the array to be sure that it is monotonic"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "Good Friday easy task. We almost made it in September, keep it up guys!"
                    },
                    {
                        "username": "shakibaenur",
                        "content": "* Initialize two boolean variables: isIncreasing and isDecreasing to false\\n* Start the loop from index 1 compare with its previous element.\\n* If an element is greater than its previous element then set isIncreasing=true(means the array is increasing)\\n* If an element is smaller than its previous element then set isDecreasing=true(means the array is decreasing)\\n* if both isIncreasing and isDecreasing are true then return false and break as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nWas it helpful ... support by upvote."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Month End should be peace like this :)"
                    },
                    {
                        "username": "singlamuskan1208",
                        "content": "Do we have any solution with less than O(n) time complx?"
                    },
                    {
                        "username": "sergei99",
                        "content": "To an extent. We can use some heuristics exploiting the data structure and failing fast for non-ordered sequences (not just trivial early exit from the loop, but there are other techniques).\\nBut proving that sequence is ordered cannot be less than $$O(n)$$."
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I dont think so, because to compare the elements, we must iterate through the array. So to iterate through the array, we must use for loop.\\n"
                    }
                ]
            },
            {
                "id": 2076326,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Tomorrow is both a weekend and a month-end. Brace yourselves."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s the problem for reference: [132 Pattern](https://leetcode.com/problems/132-pattern/)"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Oh no... Past 2 questions have been too easy, I\\'m afraid tomorrow is going to be a big bad HARD smacked on our face..."
                    },
                    {
                        "username": "user5400vw",
                        "content": "our lives are at stake "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Initialize two boolean variables: isIncreasing and isDecreasing to true\\nStarting from the second element, compare each element with its previous element.\\nIf an element is less than its previous element, set isIncreasing to false (indicating the array is not increasing).\\nIf an element is greater than its previous element, set isDecreasing to false (indicating the array is not decreasing).\\nIf both isIncreasing and isDecreasing are false, break the loop as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nReturn if either isIncreasing or isDecreasing is true since the array is considered monotonic if one of them is true and non monotonic if both are false.\\n\\nwas it helpful ... support by upvote."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Have a nice day!  It\\'s again an easy question.  O(n) solution is expected, but is it possible to create a sublinear solution?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Given the variance of leetCode run times, I suspect that a sample size of 10 is inadequate (especially if all samples are taken on the same day). I\\'m not sure that picking an outlier is the best idea."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@mshoosterman](/mshoosterman) the point is, LC test case developers are well aware of this and normally would give you the worst possible scenarios for all typical implementations."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Why not? Submit 10 times at different time of the day, pick best. The usual statistic gathering routine. How to people measure non-deterministic real life processes?"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) perfect!"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Worstcase sublinear is certainly impossible. Since the list can be sorted except for a single element, which means you necessarily have to check all elements. \\n\\nAverage case is a harder question because you need to ask what is the distribution? if we take our input to be a random list, then consider the average runtime, any failfast solution, which returns false as soon as it sees a contradiction, should actually be pretty close to O(1) average runtime, since most lists will have a contradiction in the first few elements. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Are you relying on the leetCode timer to judge your submission times?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@anwendeng](/anwendeng) well, perhaps it does not beat 100% anymore: https://leetcode.com/submissions/detail/1062141454/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) One of my C++ code using  adjacent_difference has runtime 61 ms & beats 100%, that is a 2 pass code!"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "If we were checking whether the array is *strictly* in/decreasing, we could have taken a binary search approach which we all know has a TC of $O(\\\\log n)$. But alas...  \\nMight be worth mentioning this fact if this problem ever gets asked in an actual interview though!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Managed to get 55 ms and a top execution time for C++ with a simple trick.\nWhen LC gives you test cases, they usually intend to catch improper handling of edge cases.\nConsidering that, for sequences beyond certain length I first check linear ordering of elements at 1/4, 2/4, 3/4-th indexes and the last element. If it holds, then run the usual loop with early exit checking each consecutive pair.\nAlso I always start with comparing the first element with the last element regardless of the length.\nIt still has linear time of course, but in some cases it becomes constant.\nThe previous record was 61 ms with a linear loop containing excessive branch points (which CPUs don't like), but I couldn't get less than 68 ms even for better implementation - tried a dozen of submissions.\n\nP.S. Tried an exponential search (check 1-st, 2-nd, 4-th, 8-th, etc. elements) and got 53 ms after a few tries. That's about it. No ideas how to push it further, except may be tuning the degree base."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@rajan_jasani9](/rajan_jasani9) That\\'s what I did.\\nhttps://leetcode.com/submissions/detail/1061885493/"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) what if we just return False when the 1st violation occurs? "
                    },
                    {
                        "username": "sergei99",
                        "content": "May be if you look at Timsort merge algorithm, that would help. It detects long subsequences with natural ordering and skips entire ranges based on that. It defaults to element by element handling if the natural ordering guess turned out to be wrong - so it has to detect such cases somehow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Aadil42](/Aadil42) Yes. I tried but not successful, 305/371 are pass! A binary search solution can solve some patterns but not all. For example if there is just 1 exception, BS works."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@anwendeng](/anwendeng) When you say sublinear, do you mean O(log(n)) time?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@hero080](/hero080) Yes, sublinear is not possible but you can code your solution for an early exit if the first violation occurs early in the array. (Many solutions keep going to the end of the array regardless of where the first violation occurs)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hero080](/hero080) Yes. A sublinear solution is not possible."
                    },
                    {
                        "username": "hero080",
                        "content": "The solution has to be $\\\\Omega(n)$ because there might be only a single element in `nums` that violates the monotonic condition and we have to check every index to find it."
                    },
                    {
                        "username": "freezeen3",
                        "content": "So guys today is the Chinese Mid-Autumn Festival, it\\'s good to have a relaxing day with Leetcode\\'s support!"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Everyone have a nice Friday! You have more time today for other stuff to do ;)"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I wish I could know what tomorrows hard problem will be, so I can get a head start! "
                    },
                    {
                        "username": "IAmBadAtLeetcode",
                        "content": "no.. need to leetcode more. it was too easy today, need to keep going lol"
                    },
                    {
                        "username": "demaw",
                        "content": "any valid solution must run in (at least) O(n) time. consider the case [3,3,3,3, ... ,7, ... 3,3,3]. because a number like 7 could exist anywhere in a potentially monotonic array full of 3s, we must check every index of the array to be sure that it is monotonic"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "Good Friday easy task. We almost made it in September, keep it up guys!"
                    },
                    {
                        "username": "shakibaenur",
                        "content": "* Initialize two boolean variables: isIncreasing and isDecreasing to false\\n* Start the loop from index 1 compare with its previous element.\\n* If an element is greater than its previous element then set isIncreasing=true(means the array is increasing)\\n* If an element is smaller than its previous element then set isDecreasing=true(means the array is decreasing)\\n* if both isIncreasing and isDecreasing are true then return false and break as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nWas it helpful ... support by upvote."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Month End should be peace like this :)"
                    },
                    {
                        "username": "singlamuskan1208",
                        "content": "Do we have any solution with less than O(n) time complx?"
                    },
                    {
                        "username": "sergei99",
                        "content": "To an extent. We can use some heuristics exploiting the data structure and failing fast for non-ordered sequences (not just trivial early exit from the loop, but there are other techniques).\\nBut proving that sequence is ordered cannot be less than $$O(n)$$."
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I dont think so, because to compare the elements, we must iterate through the array. So to iterate through the array, we must use for loop.\\n"
                    }
                ]
            },
            {
                "id": 2076367,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Tomorrow is both a weekend and a month-end. Brace yourselves."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s the problem for reference: [132 Pattern](https://leetcode.com/problems/132-pattern/)"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Oh no... Past 2 questions have been too easy, I\\'m afraid tomorrow is going to be a big bad HARD smacked on our face..."
                    },
                    {
                        "username": "user5400vw",
                        "content": "our lives are at stake "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Initialize two boolean variables: isIncreasing and isDecreasing to true\\nStarting from the second element, compare each element with its previous element.\\nIf an element is less than its previous element, set isIncreasing to false (indicating the array is not increasing).\\nIf an element is greater than its previous element, set isDecreasing to false (indicating the array is not decreasing).\\nIf both isIncreasing and isDecreasing are false, break the loop as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nReturn if either isIncreasing or isDecreasing is true since the array is considered monotonic if one of them is true and non monotonic if both are false.\\n\\nwas it helpful ... support by upvote."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Have a nice day!  It\\'s again an easy question.  O(n) solution is expected, but is it possible to create a sublinear solution?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Given the variance of leetCode run times, I suspect that a sample size of 10 is inadequate (especially if all samples are taken on the same day). I\\'m not sure that picking an outlier is the best idea."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@mshoosterman](/mshoosterman) the point is, LC test case developers are well aware of this and normally would give you the worst possible scenarios for all typical implementations."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Why not? Submit 10 times at different time of the day, pick best. The usual statistic gathering routine. How to people measure non-deterministic real life processes?"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) perfect!"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Worstcase sublinear is certainly impossible. Since the list can be sorted except for a single element, which means you necessarily have to check all elements. \\n\\nAverage case is a harder question because you need to ask what is the distribution? if we take our input to be a random list, then consider the average runtime, any failfast solution, which returns false as soon as it sees a contradiction, should actually be pretty close to O(1) average runtime, since most lists will have a contradiction in the first few elements. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Are you relying on the leetCode timer to judge your submission times?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@anwendeng](/anwendeng) well, perhaps it does not beat 100% anymore: https://leetcode.com/submissions/detail/1062141454/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) One of my C++ code using  adjacent_difference has runtime 61 ms & beats 100%, that is a 2 pass code!"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "If we were checking whether the array is *strictly* in/decreasing, we could have taken a binary search approach which we all know has a TC of $O(\\\\log n)$. But alas...  \\nMight be worth mentioning this fact if this problem ever gets asked in an actual interview though!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Managed to get 55 ms and a top execution time for C++ with a simple trick.\nWhen LC gives you test cases, they usually intend to catch improper handling of edge cases.\nConsidering that, for sequences beyond certain length I first check linear ordering of elements at 1/4, 2/4, 3/4-th indexes and the last element. If it holds, then run the usual loop with early exit checking each consecutive pair.\nAlso I always start with comparing the first element with the last element regardless of the length.\nIt still has linear time of course, but in some cases it becomes constant.\nThe previous record was 61 ms with a linear loop containing excessive branch points (which CPUs don't like), but I couldn't get less than 68 ms even for better implementation - tried a dozen of submissions.\n\nP.S. Tried an exponential search (check 1-st, 2-nd, 4-th, 8-th, etc. elements) and got 53 ms after a few tries. That's about it. No ideas how to push it further, except may be tuning the degree base."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@rajan_jasani9](/rajan_jasani9) That\\'s what I did.\\nhttps://leetcode.com/submissions/detail/1061885493/"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) what if we just return False when the 1st violation occurs? "
                    },
                    {
                        "username": "sergei99",
                        "content": "May be if you look at Timsort merge algorithm, that would help. It detects long subsequences with natural ordering and skips entire ranges based on that. It defaults to element by element handling if the natural ordering guess turned out to be wrong - so it has to detect such cases somehow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Aadil42](/Aadil42) Yes. I tried but not successful, 305/371 are pass! A binary search solution can solve some patterns but not all. For example if there is just 1 exception, BS works."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@anwendeng](/anwendeng) When you say sublinear, do you mean O(log(n)) time?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@hero080](/hero080) Yes, sublinear is not possible but you can code your solution for an early exit if the first violation occurs early in the array. (Many solutions keep going to the end of the array regardless of where the first violation occurs)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hero080](/hero080) Yes. A sublinear solution is not possible."
                    },
                    {
                        "username": "hero080",
                        "content": "The solution has to be $\\\\Omega(n)$ because there might be only a single element in `nums` that violates the monotonic condition and we have to check every index to find it."
                    },
                    {
                        "username": "freezeen3",
                        "content": "So guys today is the Chinese Mid-Autumn Festival, it\\'s good to have a relaxing day with Leetcode\\'s support!"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Everyone have a nice Friday! You have more time today for other stuff to do ;)"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I wish I could know what tomorrows hard problem will be, so I can get a head start! "
                    },
                    {
                        "username": "IAmBadAtLeetcode",
                        "content": "no.. need to leetcode more. it was too easy today, need to keep going lol"
                    },
                    {
                        "username": "demaw",
                        "content": "any valid solution must run in (at least) O(n) time. consider the case [3,3,3,3, ... ,7, ... 3,3,3]. because a number like 7 could exist anywhere in a potentially monotonic array full of 3s, we must check every index of the array to be sure that it is monotonic"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "Good Friday easy task. We almost made it in September, keep it up guys!"
                    },
                    {
                        "username": "shakibaenur",
                        "content": "* Initialize two boolean variables: isIncreasing and isDecreasing to false\\n* Start the loop from index 1 compare with its previous element.\\n* If an element is greater than its previous element then set isIncreasing=true(means the array is increasing)\\n* If an element is smaller than its previous element then set isDecreasing=true(means the array is decreasing)\\n* if both isIncreasing and isDecreasing are true then return false and break as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nWas it helpful ... support by upvote."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Month End should be peace like this :)"
                    },
                    {
                        "username": "singlamuskan1208",
                        "content": "Do we have any solution with less than O(n) time complx?"
                    },
                    {
                        "username": "sergei99",
                        "content": "To an extent. We can use some heuristics exploiting the data structure and failing fast for non-ordered sequences (not just trivial early exit from the loop, but there are other techniques).\\nBut proving that sequence is ordered cannot be less than $$O(n)$$."
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I dont think so, because to compare the elements, we must iterate through the array. So to iterate through the array, we must use for loop.\\n"
                    }
                ]
            },
            {
                "id": 2076411,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Tomorrow is both a weekend and a month-end. Brace yourselves."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s the problem for reference: [132 Pattern](https://leetcode.com/problems/132-pattern/)"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Oh no... Past 2 questions have been too easy, I\\'m afraid tomorrow is going to be a big bad HARD smacked on our face..."
                    },
                    {
                        "username": "user5400vw",
                        "content": "our lives are at stake "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Initialize two boolean variables: isIncreasing and isDecreasing to true\\nStarting from the second element, compare each element with its previous element.\\nIf an element is less than its previous element, set isIncreasing to false (indicating the array is not increasing).\\nIf an element is greater than its previous element, set isDecreasing to false (indicating the array is not decreasing).\\nIf both isIncreasing and isDecreasing are false, break the loop as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nReturn if either isIncreasing or isDecreasing is true since the array is considered monotonic if one of them is true and non monotonic if both are false.\\n\\nwas it helpful ... support by upvote."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Have a nice day!  It\\'s again an easy question.  O(n) solution is expected, but is it possible to create a sublinear solution?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Given the variance of leetCode run times, I suspect that a sample size of 10 is inadequate (especially if all samples are taken on the same day). I\\'m not sure that picking an outlier is the best idea."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@mshoosterman](/mshoosterman) the point is, LC test case developers are well aware of this and normally would give you the worst possible scenarios for all typical implementations."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Why not? Submit 10 times at different time of the day, pick best. The usual statistic gathering routine. How to people measure non-deterministic real life processes?"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) perfect!"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Worstcase sublinear is certainly impossible. Since the list can be sorted except for a single element, which means you necessarily have to check all elements. \\n\\nAverage case is a harder question because you need to ask what is the distribution? if we take our input to be a random list, then consider the average runtime, any failfast solution, which returns false as soon as it sees a contradiction, should actually be pretty close to O(1) average runtime, since most lists will have a contradiction in the first few elements. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Are you relying on the leetCode timer to judge your submission times?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@anwendeng](/anwendeng) well, perhaps it does not beat 100% anymore: https://leetcode.com/submissions/detail/1062141454/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) One of my C++ code using  adjacent_difference has runtime 61 ms & beats 100%, that is a 2 pass code!"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "If we were checking whether the array is *strictly* in/decreasing, we could have taken a binary search approach which we all know has a TC of $O(\\\\log n)$. But alas...  \\nMight be worth mentioning this fact if this problem ever gets asked in an actual interview though!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Managed to get 55 ms and a top execution time for C++ with a simple trick.\nWhen LC gives you test cases, they usually intend to catch improper handling of edge cases.\nConsidering that, for sequences beyond certain length I first check linear ordering of elements at 1/4, 2/4, 3/4-th indexes and the last element. If it holds, then run the usual loop with early exit checking each consecutive pair.\nAlso I always start with comparing the first element with the last element regardless of the length.\nIt still has linear time of course, but in some cases it becomes constant.\nThe previous record was 61 ms with a linear loop containing excessive branch points (which CPUs don't like), but I couldn't get less than 68 ms even for better implementation - tried a dozen of submissions.\n\nP.S. Tried an exponential search (check 1-st, 2-nd, 4-th, 8-th, etc. elements) and got 53 ms after a few tries. That's about it. No ideas how to push it further, except may be tuning the degree base."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@rajan_jasani9](/rajan_jasani9) That\\'s what I did.\\nhttps://leetcode.com/submissions/detail/1061885493/"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) what if we just return False when the 1st violation occurs? "
                    },
                    {
                        "username": "sergei99",
                        "content": "May be if you look at Timsort merge algorithm, that would help. It detects long subsequences with natural ordering and skips entire ranges based on that. It defaults to element by element handling if the natural ordering guess turned out to be wrong - so it has to detect such cases somehow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Aadil42](/Aadil42) Yes. I tried but not successful, 305/371 are pass! A binary search solution can solve some patterns but not all. For example if there is just 1 exception, BS works."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@anwendeng](/anwendeng) When you say sublinear, do you mean O(log(n)) time?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@hero080](/hero080) Yes, sublinear is not possible but you can code your solution for an early exit if the first violation occurs early in the array. (Many solutions keep going to the end of the array regardless of where the first violation occurs)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hero080](/hero080) Yes. A sublinear solution is not possible."
                    },
                    {
                        "username": "hero080",
                        "content": "The solution has to be $\\\\Omega(n)$ because there might be only a single element in `nums` that violates the monotonic condition and we have to check every index to find it."
                    },
                    {
                        "username": "freezeen3",
                        "content": "So guys today is the Chinese Mid-Autumn Festival, it\\'s good to have a relaxing day with Leetcode\\'s support!"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Everyone have a nice Friday! You have more time today for other stuff to do ;)"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I wish I could know what tomorrows hard problem will be, so I can get a head start! "
                    },
                    {
                        "username": "IAmBadAtLeetcode",
                        "content": "no.. need to leetcode more. it was too easy today, need to keep going lol"
                    },
                    {
                        "username": "demaw",
                        "content": "any valid solution must run in (at least) O(n) time. consider the case [3,3,3,3, ... ,7, ... 3,3,3]. because a number like 7 could exist anywhere in a potentially monotonic array full of 3s, we must check every index of the array to be sure that it is monotonic"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "Good Friday easy task. We almost made it in September, keep it up guys!"
                    },
                    {
                        "username": "shakibaenur",
                        "content": "* Initialize two boolean variables: isIncreasing and isDecreasing to false\\n* Start the loop from index 1 compare with its previous element.\\n* If an element is greater than its previous element then set isIncreasing=true(means the array is increasing)\\n* If an element is smaller than its previous element then set isDecreasing=true(means the array is decreasing)\\n* if both isIncreasing and isDecreasing are true then return false and break as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nWas it helpful ... support by upvote."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Month End should be peace like this :)"
                    },
                    {
                        "username": "singlamuskan1208",
                        "content": "Do we have any solution with less than O(n) time complx?"
                    },
                    {
                        "username": "sergei99",
                        "content": "To an extent. We can use some heuristics exploiting the data structure and failing fast for non-ordered sequences (not just trivial early exit from the loop, but there are other techniques).\\nBut proving that sequence is ordered cannot be less than $$O(n)$$."
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I dont think so, because to compare the elements, we must iterate through the array. So to iterate through the array, we must use for loop.\\n"
                    }
                ]
            },
            {
                "id": 2076339,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Tomorrow is both a weekend and a month-end. Brace yourselves."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s the problem for reference: [132 Pattern](https://leetcode.com/problems/132-pattern/)"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Oh no... Past 2 questions have been too easy, I\\'m afraid tomorrow is going to be a big bad HARD smacked on our face..."
                    },
                    {
                        "username": "user5400vw",
                        "content": "our lives are at stake "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Initialize two boolean variables: isIncreasing and isDecreasing to true\\nStarting from the second element, compare each element with its previous element.\\nIf an element is less than its previous element, set isIncreasing to false (indicating the array is not increasing).\\nIf an element is greater than its previous element, set isDecreasing to false (indicating the array is not decreasing).\\nIf both isIncreasing and isDecreasing are false, break the loop as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nReturn if either isIncreasing or isDecreasing is true since the array is considered monotonic if one of them is true and non monotonic if both are false.\\n\\nwas it helpful ... support by upvote."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Have a nice day!  It\\'s again an easy question.  O(n) solution is expected, but is it possible to create a sublinear solution?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Given the variance of leetCode run times, I suspect that a sample size of 10 is inadequate (especially if all samples are taken on the same day). I\\'m not sure that picking an outlier is the best idea."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@mshoosterman](/mshoosterman) the point is, LC test case developers are well aware of this and normally would give you the worst possible scenarios for all typical implementations."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Why not? Submit 10 times at different time of the day, pick best. The usual statistic gathering routine. How to people measure non-deterministic real life processes?"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) perfect!"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Worstcase sublinear is certainly impossible. Since the list can be sorted except for a single element, which means you necessarily have to check all elements. \\n\\nAverage case is a harder question because you need to ask what is the distribution? if we take our input to be a random list, then consider the average runtime, any failfast solution, which returns false as soon as it sees a contradiction, should actually be pretty close to O(1) average runtime, since most lists will have a contradiction in the first few elements. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Are you relying on the leetCode timer to judge your submission times?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@anwendeng](/anwendeng) well, perhaps it does not beat 100% anymore: https://leetcode.com/submissions/detail/1062141454/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) One of my C++ code using  adjacent_difference has runtime 61 ms & beats 100%, that is a 2 pass code!"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "If we were checking whether the array is *strictly* in/decreasing, we could have taken a binary search approach which we all know has a TC of $O(\\\\log n)$. But alas...  \\nMight be worth mentioning this fact if this problem ever gets asked in an actual interview though!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Managed to get 55 ms and a top execution time for C++ with a simple trick.\nWhen LC gives you test cases, they usually intend to catch improper handling of edge cases.\nConsidering that, for sequences beyond certain length I first check linear ordering of elements at 1/4, 2/4, 3/4-th indexes and the last element. If it holds, then run the usual loop with early exit checking each consecutive pair.\nAlso I always start with comparing the first element with the last element regardless of the length.\nIt still has linear time of course, but in some cases it becomes constant.\nThe previous record was 61 ms with a linear loop containing excessive branch points (which CPUs don't like), but I couldn't get less than 68 ms even for better implementation - tried a dozen of submissions.\n\nP.S. Tried an exponential search (check 1-st, 2-nd, 4-th, 8-th, etc. elements) and got 53 ms after a few tries. That's about it. No ideas how to push it further, except may be tuning the degree base."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@rajan_jasani9](/rajan_jasani9) That\\'s what I did.\\nhttps://leetcode.com/submissions/detail/1061885493/"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) what if we just return False when the 1st violation occurs? "
                    },
                    {
                        "username": "sergei99",
                        "content": "May be if you look at Timsort merge algorithm, that would help. It detects long subsequences with natural ordering and skips entire ranges based on that. It defaults to element by element handling if the natural ordering guess turned out to be wrong - so it has to detect such cases somehow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Aadil42](/Aadil42) Yes. I tried but not successful, 305/371 are pass! A binary search solution can solve some patterns but not all. For example if there is just 1 exception, BS works."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@anwendeng](/anwendeng) When you say sublinear, do you mean O(log(n)) time?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@hero080](/hero080) Yes, sublinear is not possible but you can code your solution for an early exit if the first violation occurs early in the array. (Many solutions keep going to the end of the array regardless of where the first violation occurs)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hero080](/hero080) Yes. A sublinear solution is not possible."
                    },
                    {
                        "username": "hero080",
                        "content": "The solution has to be $\\\\Omega(n)$ because there might be only a single element in `nums` that violates the monotonic condition and we have to check every index to find it."
                    },
                    {
                        "username": "freezeen3",
                        "content": "So guys today is the Chinese Mid-Autumn Festival, it\\'s good to have a relaxing day with Leetcode\\'s support!"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Everyone have a nice Friday! You have more time today for other stuff to do ;)"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I wish I could know what tomorrows hard problem will be, so I can get a head start! "
                    },
                    {
                        "username": "IAmBadAtLeetcode",
                        "content": "no.. need to leetcode more. it was too easy today, need to keep going lol"
                    },
                    {
                        "username": "demaw",
                        "content": "any valid solution must run in (at least) O(n) time. consider the case [3,3,3,3, ... ,7, ... 3,3,3]. because a number like 7 could exist anywhere in a potentially monotonic array full of 3s, we must check every index of the array to be sure that it is monotonic"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "Good Friday easy task. We almost made it in September, keep it up guys!"
                    },
                    {
                        "username": "shakibaenur",
                        "content": "* Initialize two boolean variables: isIncreasing and isDecreasing to false\\n* Start the loop from index 1 compare with its previous element.\\n* If an element is greater than its previous element then set isIncreasing=true(means the array is increasing)\\n* If an element is smaller than its previous element then set isDecreasing=true(means the array is decreasing)\\n* if both isIncreasing and isDecreasing are true then return false and break as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nWas it helpful ... support by upvote."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Month End should be peace like this :)"
                    },
                    {
                        "username": "singlamuskan1208",
                        "content": "Do we have any solution with less than O(n) time complx?"
                    },
                    {
                        "username": "sergei99",
                        "content": "To an extent. We can use some heuristics exploiting the data structure and failing fast for non-ordered sequences (not just trivial early exit from the loop, but there are other techniques).\\nBut proving that sequence is ordered cannot be less than $$O(n)$$."
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I dont think so, because to compare the elements, we must iterate through the array. So to iterate through the array, we must use for loop.\\n"
                    }
                ]
            },
            {
                "id": 2076323,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Tomorrow is both a weekend and a month-end. Brace yourselves."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s the problem for reference: [132 Pattern](https://leetcode.com/problems/132-pattern/)"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Oh no... Past 2 questions have been too easy, I\\'m afraid tomorrow is going to be a big bad HARD smacked on our face..."
                    },
                    {
                        "username": "user5400vw",
                        "content": "our lives are at stake "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Initialize two boolean variables: isIncreasing and isDecreasing to true\\nStarting from the second element, compare each element with its previous element.\\nIf an element is less than its previous element, set isIncreasing to false (indicating the array is not increasing).\\nIf an element is greater than its previous element, set isDecreasing to false (indicating the array is not decreasing).\\nIf both isIncreasing and isDecreasing are false, break the loop as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nReturn if either isIncreasing or isDecreasing is true since the array is considered monotonic if one of them is true and non monotonic if both are false.\\n\\nwas it helpful ... support by upvote."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Have a nice day!  It\\'s again an easy question.  O(n) solution is expected, but is it possible to create a sublinear solution?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Given the variance of leetCode run times, I suspect that a sample size of 10 is inadequate (especially if all samples are taken on the same day). I\\'m not sure that picking an outlier is the best idea."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@mshoosterman](/mshoosterman) the point is, LC test case developers are well aware of this and normally would give you the worst possible scenarios for all typical implementations."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Why not? Submit 10 times at different time of the day, pick best. The usual statistic gathering routine. How to people measure non-deterministic real life processes?"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) perfect!"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Worstcase sublinear is certainly impossible. Since the list can be sorted except for a single element, which means you necessarily have to check all elements. \\n\\nAverage case is a harder question because you need to ask what is the distribution? if we take our input to be a random list, then consider the average runtime, any failfast solution, which returns false as soon as it sees a contradiction, should actually be pretty close to O(1) average runtime, since most lists will have a contradiction in the first few elements. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Are you relying on the leetCode timer to judge your submission times?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@anwendeng](/anwendeng) well, perhaps it does not beat 100% anymore: https://leetcode.com/submissions/detail/1062141454/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) One of my C++ code using  adjacent_difference has runtime 61 ms & beats 100%, that is a 2 pass code!"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "If we were checking whether the array is *strictly* in/decreasing, we could have taken a binary search approach which we all know has a TC of $O(\\\\log n)$. But alas...  \\nMight be worth mentioning this fact if this problem ever gets asked in an actual interview though!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Managed to get 55 ms and a top execution time for C++ with a simple trick.\nWhen LC gives you test cases, they usually intend to catch improper handling of edge cases.\nConsidering that, for sequences beyond certain length I first check linear ordering of elements at 1/4, 2/4, 3/4-th indexes and the last element. If it holds, then run the usual loop with early exit checking each consecutive pair.\nAlso I always start with comparing the first element with the last element regardless of the length.\nIt still has linear time of course, but in some cases it becomes constant.\nThe previous record was 61 ms with a linear loop containing excessive branch points (which CPUs don't like), but I couldn't get less than 68 ms even for better implementation - tried a dozen of submissions.\n\nP.S. Tried an exponential search (check 1-st, 2-nd, 4-th, 8-th, etc. elements) and got 53 ms after a few tries. That's about it. No ideas how to push it further, except may be tuning the degree base."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@rajan_jasani9](/rajan_jasani9) That\\'s what I did.\\nhttps://leetcode.com/submissions/detail/1061885493/"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) what if we just return False when the 1st violation occurs? "
                    },
                    {
                        "username": "sergei99",
                        "content": "May be if you look at Timsort merge algorithm, that would help. It detects long subsequences with natural ordering and skips entire ranges based on that. It defaults to element by element handling if the natural ordering guess turned out to be wrong - so it has to detect such cases somehow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Aadil42](/Aadil42) Yes. I tried but not successful, 305/371 are pass! A binary search solution can solve some patterns but not all. For example if there is just 1 exception, BS works."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@anwendeng](/anwendeng) When you say sublinear, do you mean O(log(n)) time?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@hero080](/hero080) Yes, sublinear is not possible but you can code your solution for an early exit if the first violation occurs early in the array. (Many solutions keep going to the end of the array regardless of where the first violation occurs)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hero080](/hero080) Yes. A sublinear solution is not possible."
                    },
                    {
                        "username": "hero080",
                        "content": "The solution has to be $\\\\Omega(n)$ because there might be only a single element in `nums` that violates the monotonic condition and we have to check every index to find it."
                    },
                    {
                        "username": "freezeen3",
                        "content": "So guys today is the Chinese Mid-Autumn Festival, it\\'s good to have a relaxing day with Leetcode\\'s support!"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Everyone have a nice Friday! You have more time today for other stuff to do ;)"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I wish I could know what tomorrows hard problem will be, so I can get a head start! "
                    },
                    {
                        "username": "IAmBadAtLeetcode",
                        "content": "no.. need to leetcode more. it was too easy today, need to keep going lol"
                    },
                    {
                        "username": "demaw",
                        "content": "any valid solution must run in (at least) O(n) time. consider the case [3,3,3,3, ... ,7, ... 3,3,3]. because a number like 7 could exist anywhere in a potentially monotonic array full of 3s, we must check every index of the array to be sure that it is monotonic"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "Good Friday easy task. We almost made it in September, keep it up guys!"
                    },
                    {
                        "username": "shakibaenur",
                        "content": "* Initialize two boolean variables: isIncreasing and isDecreasing to false\\n* Start the loop from index 1 compare with its previous element.\\n* If an element is greater than its previous element then set isIncreasing=true(means the array is increasing)\\n* If an element is smaller than its previous element then set isDecreasing=true(means the array is decreasing)\\n* if both isIncreasing and isDecreasing are true then return false and break as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nWas it helpful ... support by upvote."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Month End should be peace like this :)"
                    },
                    {
                        "username": "singlamuskan1208",
                        "content": "Do we have any solution with less than O(n) time complx?"
                    },
                    {
                        "username": "sergei99",
                        "content": "To an extent. We can use some heuristics exploiting the data structure and failing fast for non-ordered sequences (not just trivial early exit from the loop, but there are other techniques).\\nBut proving that sequence is ordered cannot be less than $$O(n)$$."
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I dont think so, because to compare the elements, we must iterate through the array. So to iterate through the array, we must use for loop.\\n"
                    }
                ]
            },
            {
                "id": 2077034,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Tomorrow is both a weekend and a month-end. Brace yourselves."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s the problem for reference: [132 Pattern](https://leetcode.com/problems/132-pattern/)"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Oh no... Past 2 questions have been too easy, I\\'m afraid tomorrow is going to be a big bad HARD smacked on our face..."
                    },
                    {
                        "username": "user5400vw",
                        "content": "our lives are at stake "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Initialize two boolean variables: isIncreasing and isDecreasing to true\\nStarting from the second element, compare each element with its previous element.\\nIf an element is less than its previous element, set isIncreasing to false (indicating the array is not increasing).\\nIf an element is greater than its previous element, set isDecreasing to false (indicating the array is not decreasing).\\nIf both isIncreasing and isDecreasing are false, break the loop as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nReturn if either isIncreasing or isDecreasing is true since the array is considered monotonic if one of them is true and non monotonic if both are false.\\n\\nwas it helpful ... support by upvote."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Have a nice day!  It\\'s again an easy question.  O(n) solution is expected, but is it possible to create a sublinear solution?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Given the variance of leetCode run times, I suspect that a sample size of 10 is inadequate (especially if all samples are taken on the same day). I\\'m not sure that picking an outlier is the best idea."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@mshoosterman](/mshoosterman) the point is, LC test case developers are well aware of this and normally would give you the worst possible scenarios for all typical implementations."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Why not? Submit 10 times at different time of the day, pick best. The usual statistic gathering routine. How to people measure non-deterministic real life processes?"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) perfect!"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Worstcase sublinear is certainly impossible. Since the list can be sorted except for a single element, which means you necessarily have to check all elements. \\n\\nAverage case is a harder question because you need to ask what is the distribution? if we take our input to be a random list, then consider the average runtime, any failfast solution, which returns false as soon as it sees a contradiction, should actually be pretty close to O(1) average runtime, since most lists will have a contradiction in the first few elements. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Are you relying on the leetCode timer to judge your submission times?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@anwendeng](/anwendeng) well, perhaps it does not beat 100% anymore: https://leetcode.com/submissions/detail/1062141454/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) One of my C++ code using  adjacent_difference has runtime 61 ms & beats 100%, that is a 2 pass code!"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "If we were checking whether the array is *strictly* in/decreasing, we could have taken a binary search approach which we all know has a TC of $O(\\\\log n)$. But alas...  \\nMight be worth mentioning this fact if this problem ever gets asked in an actual interview though!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Managed to get 55 ms and a top execution time for C++ with a simple trick.\nWhen LC gives you test cases, they usually intend to catch improper handling of edge cases.\nConsidering that, for sequences beyond certain length I first check linear ordering of elements at 1/4, 2/4, 3/4-th indexes and the last element. If it holds, then run the usual loop with early exit checking each consecutive pair.\nAlso I always start with comparing the first element with the last element regardless of the length.\nIt still has linear time of course, but in some cases it becomes constant.\nThe previous record was 61 ms with a linear loop containing excessive branch points (which CPUs don't like), but I couldn't get less than 68 ms even for better implementation - tried a dozen of submissions.\n\nP.S. Tried an exponential search (check 1-st, 2-nd, 4-th, 8-th, etc. elements) and got 53 ms after a few tries. That's about it. No ideas how to push it further, except may be tuning the degree base."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@rajan_jasani9](/rajan_jasani9) That\\'s what I did.\\nhttps://leetcode.com/submissions/detail/1061885493/"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) what if we just return False when the 1st violation occurs? "
                    },
                    {
                        "username": "sergei99",
                        "content": "May be if you look at Timsort merge algorithm, that would help. It detects long subsequences with natural ordering and skips entire ranges based on that. It defaults to element by element handling if the natural ordering guess turned out to be wrong - so it has to detect such cases somehow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Aadil42](/Aadil42) Yes. I tried but not successful, 305/371 are pass! A binary search solution can solve some patterns but not all. For example if there is just 1 exception, BS works."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@anwendeng](/anwendeng) When you say sublinear, do you mean O(log(n)) time?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@hero080](/hero080) Yes, sublinear is not possible but you can code your solution for an early exit if the first violation occurs early in the array. (Many solutions keep going to the end of the array regardless of where the first violation occurs)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hero080](/hero080) Yes. A sublinear solution is not possible."
                    },
                    {
                        "username": "hero080",
                        "content": "The solution has to be $\\\\Omega(n)$ because there might be only a single element in `nums` that violates the monotonic condition and we have to check every index to find it."
                    },
                    {
                        "username": "freezeen3",
                        "content": "So guys today is the Chinese Mid-Autumn Festival, it\\'s good to have a relaxing day with Leetcode\\'s support!"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Everyone have a nice Friday! You have more time today for other stuff to do ;)"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I wish I could know what tomorrows hard problem will be, so I can get a head start! "
                    },
                    {
                        "username": "IAmBadAtLeetcode",
                        "content": "no.. need to leetcode more. it was too easy today, need to keep going lol"
                    },
                    {
                        "username": "demaw",
                        "content": "any valid solution must run in (at least) O(n) time. consider the case [3,3,3,3, ... ,7, ... 3,3,3]. because a number like 7 could exist anywhere in a potentially monotonic array full of 3s, we must check every index of the array to be sure that it is monotonic"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "Good Friday easy task. We almost made it in September, keep it up guys!"
                    },
                    {
                        "username": "shakibaenur",
                        "content": "* Initialize two boolean variables: isIncreasing and isDecreasing to false\\n* Start the loop from index 1 compare with its previous element.\\n* If an element is greater than its previous element then set isIncreasing=true(means the array is increasing)\\n* If an element is smaller than its previous element then set isDecreasing=true(means the array is decreasing)\\n* if both isIncreasing and isDecreasing are true then return false and break as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nWas it helpful ... support by upvote."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Month End should be peace like this :)"
                    },
                    {
                        "username": "singlamuskan1208",
                        "content": "Do we have any solution with less than O(n) time complx?"
                    },
                    {
                        "username": "sergei99",
                        "content": "To an extent. We can use some heuristics exploiting the data structure and failing fast for non-ordered sequences (not just trivial early exit from the loop, but there are other techniques).\\nBut proving that sequence is ordered cannot be less than $$O(n)$$."
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I dont think so, because to compare the elements, we must iterate through the array. So to iterate through the array, we must use for loop.\\n"
                    }
                ]
            },
            {
                "id": 2076490,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Tomorrow is both a weekend and a month-end. Brace yourselves."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s the problem for reference: [132 Pattern](https://leetcode.com/problems/132-pattern/)"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Oh no... Past 2 questions have been too easy, I\\'m afraid tomorrow is going to be a big bad HARD smacked on our face..."
                    },
                    {
                        "username": "user5400vw",
                        "content": "our lives are at stake "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Initialize two boolean variables: isIncreasing and isDecreasing to true\\nStarting from the second element, compare each element with its previous element.\\nIf an element is less than its previous element, set isIncreasing to false (indicating the array is not increasing).\\nIf an element is greater than its previous element, set isDecreasing to false (indicating the array is not decreasing).\\nIf both isIncreasing and isDecreasing are false, break the loop as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nReturn if either isIncreasing or isDecreasing is true since the array is considered monotonic if one of them is true and non monotonic if both are false.\\n\\nwas it helpful ... support by upvote."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Have a nice day!  It\\'s again an easy question.  O(n) solution is expected, but is it possible to create a sublinear solution?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Given the variance of leetCode run times, I suspect that a sample size of 10 is inadequate (especially if all samples are taken on the same day). I\\'m not sure that picking an outlier is the best idea."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@mshoosterman](/mshoosterman) the point is, LC test case developers are well aware of this and normally would give you the worst possible scenarios for all typical implementations."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Why not? Submit 10 times at different time of the day, pick best. The usual statistic gathering routine. How to people measure non-deterministic real life processes?"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) perfect!"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Worstcase sublinear is certainly impossible. Since the list can be sorted except for a single element, which means you necessarily have to check all elements. \\n\\nAverage case is a harder question because you need to ask what is the distribution? if we take our input to be a random list, then consider the average runtime, any failfast solution, which returns false as soon as it sees a contradiction, should actually be pretty close to O(1) average runtime, since most lists will have a contradiction in the first few elements. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Are you relying on the leetCode timer to judge your submission times?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@anwendeng](/anwendeng) well, perhaps it does not beat 100% anymore: https://leetcode.com/submissions/detail/1062141454/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) One of my C++ code using  adjacent_difference has runtime 61 ms & beats 100%, that is a 2 pass code!"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "If we were checking whether the array is *strictly* in/decreasing, we could have taken a binary search approach which we all know has a TC of $O(\\\\log n)$. But alas...  \\nMight be worth mentioning this fact if this problem ever gets asked in an actual interview though!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Managed to get 55 ms and a top execution time for C++ with a simple trick.\nWhen LC gives you test cases, they usually intend to catch improper handling of edge cases.\nConsidering that, for sequences beyond certain length I first check linear ordering of elements at 1/4, 2/4, 3/4-th indexes and the last element. If it holds, then run the usual loop with early exit checking each consecutive pair.\nAlso I always start with comparing the first element with the last element regardless of the length.\nIt still has linear time of course, but in some cases it becomes constant.\nThe previous record was 61 ms with a linear loop containing excessive branch points (which CPUs don't like), but I couldn't get less than 68 ms even for better implementation - tried a dozen of submissions.\n\nP.S. Tried an exponential search (check 1-st, 2-nd, 4-th, 8-th, etc. elements) and got 53 ms after a few tries. That's about it. No ideas how to push it further, except may be tuning the degree base."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@rajan_jasani9](/rajan_jasani9) That\\'s what I did.\\nhttps://leetcode.com/submissions/detail/1061885493/"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) what if we just return False when the 1st violation occurs? "
                    },
                    {
                        "username": "sergei99",
                        "content": "May be if you look at Timsort merge algorithm, that would help. It detects long subsequences with natural ordering and skips entire ranges based on that. It defaults to element by element handling if the natural ordering guess turned out to be wrong - so it has to detect such cases somehow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Aadil42](/Aadil42) Yes. I tried but not successful, 305/371 are pass! A binary search solution can solve some patterns but not all. For example if there is just 1 exception, BS works."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@anwendeng](/anwendeng) When you say sublinear, do you mean O(log(n)) time?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@hero080](/hero080) Yes, sublinear is not possible but you can code your solution for an early exit if the first violation occurs early in the array. (Many solutions keep going to the end of the array regardless of where the first violation occurs)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hero080](/hero080) Yes. A sublinear solution is not possible."
                    },
                    {
                        "username": "hero080",
                        "content": "The solution has to be $\\\\Omega(n)$ because there might be only a single element in `nums` that violates the monotonic condition and we have to check every index to find it."
                    },
                    {
                        "username": "freezeen3",
                        "content": "So guys today is the Chinese Mid-Autumn Festival, it\\'s good to have a relaxing day with Leetcode\\'s support!"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Everyone have a nice Friday! You have more time today for other stuff to do ;)"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I wish I could know what tomorrows hard problem will be, so I can get a head start! "
                    },
                    {
                        "username": "IAmBadAtLeetcode",
                        "content": "no.. need to leetcode more. it was too easy today, need to keep going lol"
                    },
                    {
                        "username": "demaw",
                        "content": "any valid solution must run in (at least) O(n) time. consider the case [3,3,3,3, ... ,7, ... 3,3,3]. because a number like 7 could exist anywhere in a potentially monotonic array full of 3s, we must check every index of the array to be sure that it is monotonic"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "Good Friday easy task. We almost made it in September, keep it up guys!"
                    },
                    {
                        "username": "shakibaenur",
                        "content": "* Initialize two boolean variables: isIncreasing and isDecreasing to false\\n* Start the loop from index 1 compare with its previous element.\\n* If an element is greater than its previous element then set isIncreasing=true(means the array is increasing)\\n* If an element is smaller than its previous element then set isDecreasing=true(means the array is decreasing)\\n* if both isIncreasing and isDecreasing are true then return false and break as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nWas it helpful ... support by upvote."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Month End should be peace like this :)"
                    },
                    {
                        "username": "singlamuskan1208",
                        "content": "Do we have any solution with less than O(n) time complx?"
                    },
                    {
                        "username": "sergei99",
                        "content": "To an extent. We can use some heuristics exploiting the data structure and failing fast for non-ordered sequences (not just trivial early exit from the loop, but there are other techniques).\\nBut proving that sequence is ordered cannot be less than $$O(n)$$."
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I dont think so, because to compare the elements, we must iterate through the array. So to iterate through the array, we must use for loop.\\n"
                    }
                ]
            },
            {
                "id": 1672119,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Tomorrow is both a weekend and a month-end. Brace yourselves."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s the problem for reference: [132 Pattern](https://leetcode.com/problems/132-pattern/)"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Oh no... Past 2 questions have been too easy, I\\'m afraid tomorrow is going to be a big bad HARD smacked on our face..."
                    },
                    {
                        "username": "user5400vw",
                        "content": "our lives are at stake "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Initialize two boolean variables: isIncreasing and isDecreasing to true\\nStarting from the second element, compare each element with its previous element.\\nIf an element is less than its previous element, set isIncreasing to false (indicating the array is not increasing).\\nIf an element is greater than its previous element, set isDecreasing to false (indicating the array is not decreasing).\\nIf both isIncreasing and isDecreasing are false, break the loop as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nReturn if either isIncreasing or isDecreasing is true since the array is considered monotonic if one of them is true and non monotonic if both are false.\\n\\nwas it helpful ... support by upvote."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Have a nice day!  It\\'s again an easy question.  O(n) solution is expected, but is it possible to create a sublinear solution?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Given the variance of leetCode run times, I suspect that a sample size of 10 is inadequate (especially if all samples are taken on the same day). I\\'m not sure that picking an outlier is the best idea."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@mshoosterman](/mshoosterman) the point is, LC test case developers are well aware of this and normally would give you the worst possible scenarios for all typical implementations."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Why not? Submit 10 times at different time of the day, pick best. The usual statistic gathering routine. How to people measure non-deterministic real life processes?"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) perfect!"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Worstcase sublinear is certainly impossible. Since the list can be sorted except for a single element, which means you necessarily have to check all elements. \\n\\nAverage case is a harder question because you need to ask what is the distribution? if we take our input to be a random list, then consider the average runtime, any failfast solution, which returns false as soon as it sees a contradiction, should actually be pretty close to O(1) average runtime, since most lists will have a contradiction in the first few elements. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Are you relying on the leetCode timer to judge your submission times?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@anwendeng](/anwendeng) well, perhaps it does not beat 100% anymore: https://leetcode.com/submissions/detail/1062141454/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) One of my C++ code using  adjacent_difference has runtime 61 ms & beats 100%, that is a 2 pass code!"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "If we were checking whether the array is *strictly* in/decreasing, we could have taken a binary search approach which we all know has a TC of $O(\\\\log n)$. But alas...  \\nMight be worth mentioning this fact if this problem ever gets asked in an actual interview though!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Managed to get 55 ms and a top execution time for C++ with a simple trick.\nWhen LC gives you test cases, they usually intend to catch improper handling of edge cases.\nConsidering that, for sequences beyond certain length I first check linear ordering of elements at 1/4, 2/4, 3/4-th indexes and the last element. If it holds, then run the usual loop with early exit checking each consecutive pair.\nAlso I always start with comparing the first element with the last element regardless of the length.\nIt still has linear time of course, but in some cases it becomes constant.\nThe previous record was 61 ms with a linear loop containing excessive branch points (which CPUs don't like), but I couldn't get less than 68 ms even for better implementation - tried a dozen of submissions.\n\nP.S. Tried an exponential search (check 1-st, 2-nd, 4-th, 8-th, etc. elements) and got 53 ms after a few tries. That's about it. No ideas how to push it further, except may be tuning the degree base."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@rajan_jasani9](/rajan_jasani9) That\\'s what I did.\\nhttps://leetcode.com/submissions/detail/1061885493/"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) what if we just return False when the 1st violation occurs? "
                    },
                    {
                        "username": "sergei99",
                        "content": "May be if you look at Timsort merge algorithm, that would help. It detects long subsequences with natural ordering and skips entire ranges based on that. It defaults to element by element handling if the natural ordering guess turned out to be wrong - so it has to detect such cases somehow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Aadil42](/Aadil42) Yes. I tried but not successful, 305/371 are pass! A binary search solution can solve some patterns but not all. For example if there is just 1 exception, BS works."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@anwendeng](/anwendeng) When you say sublinear, do you mean O(log(n)) time?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@hero080](/hero080) Yes, sublinear is not possible but you can code your solution for an early exit if the first violation occurs early in the array. (Many solutions keep going to the end of the array regardless of where the first violation occurs)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hero080](/hero080) Yes. A sublinear solution is not possible."
                    },
                    {
                        "username": "hero080",
                        "content": "The solution has to be $\\\\Omega(n)$ because there might be only a single element in `nums` that violates the monotonic condition and we have to check every index to find it."
                    },
                    {
                        "username": "freezeen3",
                        "content": "So guys today is the Chinese Mid-Autumn Festival, it\\'s good to have a relaxing day with Leetcode\\'s support!"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Everyone have a nice Friday! You have more time today for other stuff to do ;)"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I wish I could know what tomorrows hard problem will be, so I can get a head start! "
                    },
                    {
                        "username": "IAmBadAtLeetcode",
                        "content": "no.. need to leetcode more. it was too easy today, need to keep going lol"
                    },
                    {
                        "username": "demaw",
                        "content": "any valid solution must run in (at least) O(n) time. consider the case [3,3,3,3, ... ,7, ... 3,3,3]. because a number like 7 could exist anywhere in a potentially monotonic array full of 3s, we must check every index of the array to be sure that it is monotonic"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "Good Friday easy task. We almost made it in September, keep it up guys!"
                    },
                    {
                        "username": "shakibaenur",
                        "content": "* Initialize two boolean variables: isIncreasing and isDecreasing to false\\n* Start the loop from index 1 compare with its previous element.\\n* If an element is greater than its previous element then set isIncreasing=true(means the array is increasing)\\n* If an element is smaller than its previous element then set isDecreasing=true(means the array is decreasing)\\n* if both isIncreasing and isDecreasing are true then return false and break as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nWas it helpful ... support by upvote."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Month End should be peace like this :)"
                    },
                    {
                        "username": "singlamuskan1208",
                        "content": "Do we have any solution with less than O(n) time complx?"
                    },
                    {
                        "username": "sergei99",
                        "content": "To an extent. We can use some heuristics exploiting the data structure and failing fast for non-ordered sequences (not just trivial early exit from the loop, but there are other techniques).\\nBut proving that sequence is ordered cannot be less than $$O(n)$$."
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I dont think so, because to compare the elements, we must iterate through the array. So to iterate through the array, we must use for loop.\\n"
                    }
                ]
            },
            {
                "id": 2076399,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Tomorrow is both a weekend and a month-end. Brace yourselves."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s the problem for reference: [132 Pattern](https://leetcode.com/problems/132-pattern/)"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Oh no... Past 2 questions have been too easy, I\\'m afraid tomorrow is going to be a big bad HARD smacked on our face..."
                    },
                    {
                        "username": "user5400vw",
                        "content": "our lives are at stake "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Initialize two boolean variables: isIncreasing and isDecreasing to true\\nStarting from the second element, compare each element with its previous element.\\nIf an element is less than its previous element, set isIncreasing to false (indicating the array is not increasing).\\nIf an element is greater than its previous element, set isDecreasing to false (indicating the array is not decreasing).\\nIf both isIncreasing and isDecreasing are false, break the loop as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nReturn if either isIncreasing or isDecreasing is true since the array is considered monotonic if one of them is true and non monotonic if both are false.\\n\\nwas it helpful ... support by upvote."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Have a nice day!  It\\'s again an easy question.  O(n) solution is expected, but is it possible to create a sublinear solution?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Given the variance of leetCode run times, I suspect that a sample size of 10 is inadequate (especially if all samples are taken on the same day). I\\'m not sure that picking an outlier is the best idea."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@mshoosterman](/mshoosterman) the point is, LC test case developers are well aware of this and normally would give you the worst possible scenarios for all typical implementations."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Why not? Submit 10 times at different time of the day, pick best. The usual statistic gathering routine. How to people measure non-deterministic real life processes?"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) perfect!"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Worstcase sublinear is certainly impossible. Since the list can be sorted except for a single element, which means you necessarily have to check all elements. \\n\\nAverage case is a harder question because you need to ask what is the distribution? if we take our input to be a random list, then consider the average runtime, any failfast solution, which returns false as soon as it sees a contradiction, should actually be pretty close to O(1) average runtime, since most lists will have a contradiction in the first few elements. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Are you relying on the leetCode timer to judge your submission times?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@anwendeng](/anwendeng) well, perhaps it does not beat 100% anymore: https://leetcode.com/submissions/detail/1062141454/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) One of my C++ code using  adjacent_difference has runtime 61 ms & beats 100%, that is a 2 pass code!"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "If we were checking whether the array is *strictly* in/decreasing, we could have taken a binary search approach which we all know has a TC of $O(\\\\log n)$. But alas...  \\nMight be worth mentioning this fact if this problem ever gets asked in an actual interview though!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Managed to get 55 ms and a top execution time for C++ with a simple trick.\nWhen LC gives you test cases, they usually intend to catch improper handling of edge cases.\nConsidering that, for sequences beyond certain length I first check linear ordering of elements at 1/4, 2/4, 3/4-th indexes and the last element. If it holds, then run the usual loop with early exit checking each consecutive pair.\nAlso I always start with comparing the first element with the last element regardless of the length.\nIt still has linear time of course, but in some cases it becomes constant.\nThe previous record was 61 ms with a linear loop containing excessive branch points (which CPUs don't like), but I couldn't get less than 68 ms even for better implementation - tried a dozen of submissions.\n\nP.S. Tried an exponential search (check 1-st, 2-nd, 4-th, 8-th, etc. elements) and got 53 ms after a few tries. That's about it. No ideas how to push it further, except may be tuning the degree base."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@rajan_jasani9](/rajan_jasani9) That\\'s what I did.\\nhttps://leetcode.com/submissions/detail/1061885493/"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) what if we just return False when the 1st violation occurs? "
                    },
                    {
                        "username": "sergei99",
                        "content": "May be if you look at Timsort merge algorithm, that would help. It detects long subsequences with natural ordering and skips entire ranges based on that. It defaults to element by element handling if the natural ordering guess turned out to be wrong - so it has to detect such cases somehow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Aadil42](/Aadil42) Yes. I tried but not successful, 305/371 are pass! A binary search solution can solve some patterns but not all. For example if there is just 1 exception, BS works."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@anwendeng](/anwendeng) When you say sublinear, do you mean O(log(n)) time?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@hero080](/hero080) Yes, sublinear is not possible but you can code your solution for an early exit if the first violation occurs early in the array. (Many solutions keep going to the end of the array regardless of where the first violation occurs)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hero080](/hero080) Yes. A sublinear solution is not possible."
                    },
                    {
                        "username": "hero080",
                        "content": "The solution has to be $\\\\Omega(n)$ because there might be only a single element in `nums` that violates the monotonic condition and we have to check every index to find it."
                    },
                    {
                        "username": "freezeen3",
                        "content": "So guys today is the Chinese Mid-Autumn Festival, it\\'s good to have a relaxing day with Leetcode\\'s support!"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Everyone have a nice Friday! You have more time today for other stuff to do ;)"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I wish I could know what tomorrows hard problem will be, so I can get a head start! "
                    },
                    {
                        "username": "IAmBadAtLeetcode",
                        "content": "no.. need to leetcode more. it was too easy today, need to keep going lol"
                    },
                    {
                        "username": "demaw",
                        "content": "any valid solution must run in (at least) O(n) time. consider the case [3,3,3,3, ... ,7, ... 3,3,3]. because a number like 7 could exist anywhere in a potentially monotonic array full of 3s, we must check every index of the array to be sure that it is monotonic"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "Good Friday easy task. We almost made it in September, keep it up guys!"
                    },
                    {
                        "username": "shakibaenur",
                        "content": "* Initialize two boolean variables: isIncreasing and isDecreasing to false\\n* Start the loop from index 1 compare with its previous element.\\n* If an element is greater than its previous element then set isIncreasing=true(means the array is increasing)\\n* If an element is smaller than its previous element then set isDecreasing=true(means the array is decreasing)\\n* if both isIncreasing and isDecreasing are true then return false and break as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nWas it helpful ... support by upvote."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Month End should be peace like this :)"
                    },
                    {
                        "username": "singlamuskan1208",
                        "content": "Do we have any solution with less than O(n) time complx?"
                    },
                    {
                        "username": "sergei99",
                        "content": "To an extent. We can use some heuristics exploiting the data structure and failing fast for non-ordered sequences (not just trivial early exit from the loop, but there are other techniques).\\nBut proving that sequence is ordered cannot be less than $$O(n)$$."
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I dont think so, because to compare the elements, we must iterate through the array. So to iterate through the array, we must use for loop.\\n"
                    }
                ]
            },
            {
                "id": 2076699,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Tomorrow is both a weekend and a month-end. Brace yourselves."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s the problem for reference: [132 Pattern](https://leetcode.com/problems/132-pattern/)"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Oh no... Past 2 questions have been too easy, I\\'m afraid tomorrow is going to be a big bad HARD smacked on our face..."
                    },
                    {
                        "username": "user5400vw",
                        "content": "our lives are at stake "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Initialize two boolean variables: isIncreasing and isDecreasing to true\\nStarting from the second element, compare each element with its previous element.\\nIf an element is less than its previous element, set isIncreasing to false (indicating the array is not increasing).\\nIf an element is greater than its previous element, set isDecreasing to false (indicating the array is not decreasing).\\nIf both isIncreasing and isDecreasing are false, break the loop as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nReturn if either isIncreasing or isDecreasing is true since the array is considered monotonic if one of them is true and non monotonic if both are false.\\n\\nwas it helpful ... support by upvote."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Have a nice day!  It\\'s again an easy question.  O(n) solution is expected, but is it possible to create a sublinear solution?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Given the variance of leetCode run times, I suspect that a sample size of 10 is inadequate (especially if all samples are taken on the same day). I\\'m not sure that picking an outlier is the best idea."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@mshoosterman](/mshoosterman) the point is, LC test case developers are well aware of this and normally would give you the worst possible scenarios for all typical implementations."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Why not? Submit 10 times at different time of the day, pick best. The usual statistic gathering routine. How to people measure non-deterministic real life processes?"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) perfect!"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Worstcase sublinear is certainly impossible. Since the list can be sorted except for a single element, which means you necessarily have to check all elements. \\n\\nAverage case is a harder question because you need to ask what is the distribution? if we take our input to be a random list, then consider the average runtime, any failfast solution, which returns false as soon as it sees a contradiction, should actually be pretty close to O(1) average runtime, since most lists will have a contradiction in the first few elements. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Are you relying on the leetCode timer to judge your submission times?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@anwendeng](/anwendeng) well, perhaps it does not beat 100% anymore: https://leetcode.com/submissions/detail/1062141454/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) One of my C++ code using  adjacent_difference has runtime 61 ms & beats 100%, that is a 2 pass code!"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "If we were checking whether the array is *strictly* in/decreasing, we could have taken a binary search approach which we all know has a TC of $O(\\\\log n)$. But alas...  \\nMight be worth mentioning this fact if this problem ever gets asked in an actual interview though!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Managed to get 55 ms and a top execution time for C++ with a simple trick.\nWhen LC gives you test cases, they usually intend to catch improper handling of edge cases.\nConsidering that, for sequences beyond certain length I first check linear ordering of elements at 1/4, 2/4, 3/4-th indexes and the last element. If it holds, then run the usual loop with early exit checking each consecutive pair.\nAlso I always start with comparing the first element with the last element regardless of the length.\nIt still has linear time of course, but in some cases it becomes constant.\nThe previous record was 61 ms with a linear loop containing excessive branch points (which CPUs don't like), but I couldn't get less than 68 ms even for better implementation - tried a dozen of submissions.\n\nP.S. Tried an exponential search (check 1-st, 2-nd, 4-th, 8-th, etc. elements) and got 53 ms after a few tries. That's about it. No ideas how to push it further, except may be tuning the degree base."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@rajan_jasani9](/rajan_jasani9) That\\'s what I did.\\nhttps://leetcode.com/submissions/detail/1061885493/"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) what if we just return False when the 1st violation occurs? "
                    },
                    {
                        "username": "sergei99",
                        "content": "May be if you look at Timsort merge algorithm, that would help. It detects long subsequences with natural ordering and skips entire ranges based on that. It defaults to element by element handling if the natural ordering guess turned out to be wrong - so it has to detect such cases somehow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Aadil42](/Aadil42) Yes. I tried but not successful, 305/371 are pass! A binary search solution can solve some patterns but not all. For example if there is just 1 exception, BS works."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@anwendeng](/anwendeng) When you say sublinear, do you mean O(log(n)) time?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@hero080](/hero080) Yes, sublinear is not possible but you can code your solution for an early exit if the first violation occurs early in the array. (Many solutions keep going to the end of the array regardless of where the first violation occurs)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hero080](/hero080) Yes. A sublinear solution is not possible."
                    },
                    {
                        "username": "hero080",
                        "content": "The solution has to be $\\\\Omega(n)$ because there might be only a single element in `nums` that violates the monotonic condition and we have to check every index to find it."
                    },
                    {
                        "username": "freezeen3",
                        "content": "So guys today is the Chinese Mid-Autumn Festival, it\\'s good to have a relaxing day with Leetcode\\'s support!"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Everyone have a nice Friday! You have more time today for other stuff to do ;)"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I wish I could know what tomorrows hard problem will be, so I can get a head start! "
                    },
                    {
                        "username": "IAmBadAtLeetcode",
                        "content": "no.. need to leetcode more. it was too easy today, need to keep going lol"
                    },
                    {
                        "username": "demaw",
                        "content": "any valid solution must run in (at least) O(n) time. consider the case [3,3,3,3, ... ,7, ... 3,3,3]. because a number like 7 could exist anywhere in a potentially monotonic array full of 3s, we must check every index of the array to be sure that it is monotonic"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "Good Friday easy task. We almost made it in September, keep it up guys!"
                    },
                    {
                        "username": "shakibaenur",
                        "content": "* Initialize two boolean variables: isIncreasing and isDecreasing to false\\n* Start the loop from index 1 compare with its previous element.\\n* If an element is greater than its previous element then set isIncreasing=true(means the array is increasing)\\n* If an element is smaller than its previous element then set isDecreasing=true(means the array is decreasing)\\n* if both isIncreasing and isDecreasing are true then return false and break as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nWas it helpful ... support by upvote."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Month End should be peace like this :)"
                    },
                    {
                        "username": "singlamuskan1208",
                        "content": "Do we have any solution with less than O(n) time complx?"
                    },
                    {
                        "username": "sergei99",
                        "content": "To an extent. We can use some heuristics exploiting the data structure and failing fast for non-ordered sequences (not just trivial early exit from the loop, but there are other techniques).\\nBut proving that sequence is ordered cannot be less than $$O(n)$$."
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I dont think so, because to compare the elements, we must iterate through the array. So to iterate through the array, we must use for loop.\\n"
                    }
                ]
            },
            {
                "id": 2076326,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Tomorrow is both a weekend and a month-end. Brace yourselves."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s the problem for reference: [132 Pattern](https://leetcode.com/problems/132-pattern/)"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Oh no... Past 2 questions have been too easy, I\\'m afraid tomorrow is going to be a big bad HARD smacked on our face..."
                    },
                    {
                        "username": "user5400vw",
                        "content": "our lives are at stake "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Initialize two boolean variables: isIncreasing and isDecreasing to true\\nStarting from the second element, compare each element with its previous element.\\nIf an element is less than its previous element, set isIncreasing to false (indicating the array is not increasing).\\nIf an element is greater than its previous element, set isDecreasing to false (indicating the array is not decreasing).\\nIf both isIncreasing and isDecreasing are false, break the loop as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nReturn if either isIncreasing or isDecreasing is true since the array is considered monotonic if one of them is true and non monotonic if both are false.\\n\\nwas it helpful ... support by upvote."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Have a nice day!  It\\'s again an easy question.  O(n) solution is expected, but is it possible to create a sublinear solution?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Given the variance of leetCode run times, I suspect that a sample size of 10 is inadequate (especially if all samples are taken on the same day). I\\'m not sure that picking an outlier is the best idea."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@mshoosterman](/mshoosterman) the point is, LC test case developers are well aware of this and normally would give you the worst possible scenarios for all typical implementations."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Why not? Submit 10 times at different time of the day, pick best. The usual statistic gathering routine. How to people measure non-deterministic real life processes?"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) perfect!"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Worstcase sublinear is certainly impossible. Since the list can be sorted except for a single element, which means you necessarily have to check all elements. \\n\\nAverage case is a harder question because you need to ask what is the distribution? if we take our input to be a random list, then consider the average runtime, any failfast solution, which returns false as soon as it sees a contradiction, should actually be pretty close to O(1) average runtime, since most lists will have a contradiction in the first few elements. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Are you relying on the leetCode timer to judge your submission times?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@anwendeng](/anwendeng) well, perhaps it does not beat 100% anymore: https://leetcode.com/submissions/detail/1062141454/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) One of my C++ code using  adjacent_difference has runtime 61 ms & beats 100%, that is a 2 pass code!"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "If we were checking whether the array is *strictly* in/decreasing, we could have taken a binary search approach which we all know has a TC of $O(\\\\log n)$. But alas...  \\nMight be worth mentioning this fact if this problem ever gets asked in an actual interview though!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Managed to get 55 ms and a top execution time for C++ with a simple trick.\nWhen LC gives you test cases, they usually intend to catch improper handling of edge cases.\nConsidering that, for sequences beyond certain length I first check linear ordering of elements at 1/4, 2/4, 3/4-th indexes and the last element. If it holds, then run the usual loop with early exit checking each consecutive pair.\nAlso I always start with comparing the first element with the last element regardless of the length.\nIt still has linear time of course, but in some cases it becomes constant.\nThe previous record was 61 ms with a linear loop containing excessive branch points (which CPUs don't like), but I couldn't get less than 68 ms even for better implementation - tried a dozen of submissions.\n\nP.S. Tried an exponential search (check 1-st, 2-nd, 4-th, 8-th, etc. elements) and got 53 ms after a few tries. That's about it. No ideas how to push it further, except may be tuning the degree base."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@rajan_jasani9](/rajan_jasani9) That\\'s what I did.\\nhttps://leetcode.com/submissions/detail/1061885493/"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) what if we just return False when the 1st violation occurs? "
                    },
                    {
                        "username": "sergei99",
                        "content": "May be if you look at Timsort merge algorithm, that would help. It detects long subsequences with natural ordering and skips entire ranges based on that. It defaults to element by element handling if the natural ordering guess turned out to be wrong - so it has to detect such cases somehow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Aadil42](/Aadil42) Yes. I tried but not successful, 305/371 are pass! A binary search solution can solve some patterns but not all. For example if there is just 1 exception, BS works."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@anwendeng](/anwendeng) When you say sublinear, do you mean O(log(n)) time?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@hero080](/hero080) Yes, sublinear is not possible but you can code your solution for an early exit if the first violation occurs early in the array. (Many solutions keep going to the end of the array regardless of where the first violation occurs)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hero080](/hero080) Yes. A sublinear solution is not possible."
                    },
                    {
                        "username": "hero080",
                        "content": "The solution has to be $\\\\Omega(n)$ because there might be only a single element in `nums` that violates the monotonic condition and we have to check every index to find it."
                    },
                    {
                        "username": "freezeen3",
                        "content": "So guys today is the Chinese Mid-Autumn Festival, it\\'s good to have a relaxing day with Leetcode\\'s support!"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Everyone have a nice Friday! You have more time today for other stuff to do ;)"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I wish I could know what tomorrows hard problem will be, so I can get a head start! "
                    },
                    {
                        "username": "IAmBadAtLeetcode",
                        "content": "no.. need to leetcode more. it was too easy today, need to keep going lol"
                    },
                    {
                        "username": "demaw",
                        "content": "any valid solution must run in (at least) O(n) time. consider the case [3,3,3,3, ... ,7, ... 3,3,3]. because a number like 7 could exist anywhere in a potentially monotonic array full of 3s, we must check every index of the array to be sure that it is monotonic"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "Good Friday easy task. We almost made it in September, keep it up guys!"
                    },
                    {
                        "username": "shakibaenur",
                        "content": "* Initialize two boolean variables: isIncreasing and isDecreasing to false\\n* Start the loop from index 1 compare with its previous element.\\n* If an element is greater than its previous element then set isIncreasing=true(means the array is increasing)\\n* If an element is smaller than its previous element then set isDecreasing=true(means the array is decreasing)\\n* if both isIncreasing and isDecreasing are true then return false and break as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nWas it helpful ... support by upvote."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Month End should be peace like this :)"
                    },
                    {
                        "username": "singlamuskan1208",
                        "content": "Do we have any solution with less than O(n) time complx?"
                    },
                    {
                        "username": "sergei99",
                        "content": "To an extent. We can use some heuristics exploiting the data structure and failing fast for non-ordered sequences (not just trivial early exit from the loop, but there are other techniques).\\nBut proving that sequence is ordered cannot be less than $$O(n)$$."
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I dont think so, because to compare the elements, we must iterate through the array. So to iterate through the array, we must use for loop.\\n"
                    }
                ]
            },
            {
                "id": 2076367,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Tomorrow is both a weekend and a month-end. Brace yourselves."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s the problem for reference: [132 Pattern](https://leetcode.com/problems/132-pattern/)"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Oh no... Past 2 questions have been too easy, I\\'m afraid tomorrow is going to be a big bad HARD smacked on our face..."
                    },
                    {
                        "username": "user5400vw",
                        "content": "our lives are at stake "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Initialize two boolean variables: isIncreasing and isDecreasing to true\\nStarting from the second element, compare each element with its previous element.\\nIf an element is less than its previous element, set isIncreasing to false (indicating the array is not increasing).\\nIf an element is greater than its previous element, set isDecreasing to false (indicating the array is not decreasing).\\nIf both isIncreasing and isDecreasing are false, break the loop as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nReturn if either isIncreasing or isDecreasing is true since the array is considered monotonic if one of them is true and non monotonic if both are false.\\n\\nwas it helpful ... support by upvote."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Have a nice day!  It\\'s again an easy question.  O(n) solution is expected, but is it possible to create a sublinear solution?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Given the variance of leetCode run times, I suspect that a sample size of 10 is inadequate (especially if all samples are taken on the same day). I\\'m not sure that picking an outlier is the best idea."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@mshoosterman](/mshoosterman) the point is, LC test case developers are well aware of this and normally would give you the worst possible scenarios for all typical implementations."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Why not? Submit 10 times at different time of the day, pick best. The usual statistic gathering routine. How to people measure non-deterministic real life processes?"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) perfect!"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Worstcase sublinear is certainly impossible. Since the list can be sorted except for a single element, which means you necessarily have to check all elements. \\n\\nAverage case is a harder question because you need to ask what is the distribution? if we take our input to be a random list, then consider the average runtime, any failfast solution, which returns false as soon as it sees a contradiction, should actually be pretty close to O(1) average runtime, since most lists will have a contradiction in the first few elements. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Are you relying on the leetCode timer to judge your submission times?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@anwendeng](/anwendeng) well, perhaps it does not beat 100% anymore: https://leetcode.com/submissions/detail/1062141454/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) One of my C++ code using  adjacent_difference has runtime 61 ms & beats 100%, that is a 2 pass code!"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "If we were checking whether the array is *strictly* in/decreasing, we could have taken a binary search approach which we all know has a TC of $O(\\\\log n)$. But alas...  \\nMight be worth mentioning this fact if this problem ever gets asked in an actual interview though!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Managed to get 55 ms and a top execution time for C++ with a simple trick.\nWhen LC gives you test cases, they usually intend to catch improper handling of edge cases.\nConsidering that, for sequences beyond certain length I first check linear ordering of elements at 1/4, 2/4, 3/4-th indexes and the last element. If it holds, then run the usual loop with early exit checking each consecutive pair.\nAlso I always start with comparing the first element with the last element regardless of the length.\nIt still has linear time of course, but in some cases it becomes constant.\nThe previous record was 61 ms with a linear loop containing excessive branch points (which CPUs don't like), but I couldn't get less than 68 ms even for better implementation - tried a dozen of submissions.\n\nP.S. Tried an exponential search (check 1-st, 2-nd, 4-th, 8-th, etc. elements) and got 53 ms after a few tries. That's about it. No ideas how to push it further, except may be tuning the degree base."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@rajan_jasani9](/rajan_jasani9) That\\'s what I did.\\nhttps://leetcode.com/submissions/detail/1061885493/"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) what if we just return False when the 1st violation occurs? "
                    },
                    {
                        "username": "sergei99",
                        "content": "May be if you look at Timsort merge algorithm, that would help. It detects long subsequences with natural ordering and skips entire ranges based on that. It defaults to element by element handling if the natural ordering guess turned out to be wrong - so it has to detect such cases somehow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Aadil42](/Aadil42) Yes. I tried but not successful, 305/371 are pass! A binary search solution can solve some patterns but not all. For example if there is just 1 exception, BS works."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@anwendeng](/anwendeng) When you say sublinear, do you mean O(log(n)) time?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@hero080](/hero080) Yes, sublinear is not possible but you can code your solution for an early exit if the first violation occurs early in the array. (Many solutions keep going to the end of the array regardless of where the first violation occurs)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hero080](/hero080) Yes. A sublinear solution is not possible."
                    },
                    {
                        "username": "hero080",
                        "content": "The solution has to be $\\\\Omega(n)$ because there might be only a single element in `nums` that violates the monotonic condition and we have to check every index to find it."
                    },
                    {
                        "username": "freezeen3",
                        "content": "So guys today is the Chinese Mid-Autumn Festival, it\\'s good to have a relaxing day with Leetcode\\'s support!"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Everyone have a nice Friday! You have more time today for other stuff to do ;)"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I wish I could know what tomorrows hard problem will be, so I can get a head start! "
                    },
                    {
                        "username": "IAmBadAtLeetcode",
                        "content": "no.. need to leetcode more. it was too easy today, need to keep going lol"
                    },
                    {
                        "username": "demaw",
                        "content": "any valid solution must run in (at least) O(n) time. consider the case [3,3,3,3, ... ,7, ... 3,3,3]. because a number like 7 could exist anywhere in a potentially monotonic array full of 3s, we must check every index of the array to be sure that it is monotonic"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "Good Friday easy task. We almost made it in September, keep it up guys!"
                    },
                    {
                        "username": "shakibaenur",
                        "content": "* Initialize two boolean variables: isIncreasing and isDecreasing to false\\n* Start the loop from index 1 compare with its previous element.\\n* If an element is greater than its previous element then set isIncreasing=true(means the array is increasing)\\n* If an element is smaller than its previous element then set isDecreasing=true(means the array is decreasing)\\n* if both isIncreasing and isDecreasing are true then return false and break as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nWas it helpful ... support by upvote."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Month End should be peace like this :)"
                    },
                    {
                        "username": "singlamuskan1208",
                        "content": "Do we have any solution with less than O(n) time complx?"
                    },
                    {
                        "username": "sergei99",
                        "content": "To an extent. We can use some heuristics exploiting the data structure and failing fast for non-ordered sequences (not just trivial early exit from the loop, but there are other techniques).\\nBut proving that sequence is ordered cannot be less than $$O(n)$$."
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I dont think so, because to compare the elements, we must iterate through the array. So to iterate through the array, we must use for loop.\\n"
                    }
                ]
            },
            {
                "id": 2076411,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Tomorrow is both a weekend and a month-end. Brace yourselves."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s the problem for reference: [132 Pattern](https://leetcode.com/problems/132-pattern/)"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Oh no... Past 2 questions have been too easy, I\\'m afraid tomorrow is going to be a big bad HARD smacked on our face..."
                    },
                    {
                        "username": "user5400vw",
                        "content": "our lives are at stake "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Initialize two boolean variables: isIncreasing and isDecreasing to true\\nStarting from the second element, compare each element with its previous element.\\nIf an element is less than its previous element, set isIncreasing to false (indicating the array is not increasing).\\nIf an element is greater than its previous element, set isDecreasing to false (indicating the array is not decreasing).\\nIf both isIncreasing and isDecreasing are false, break the loop as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nReturn if either isIncreasing or isDecreasing is true since the array is considered monotonic if one of them is true and non monotonic if both are false.\\n\\nwas it helpful ... support by upvote."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Have a nice day!  It\\'s again an easy question.  O(n) solution is expected, but is it possible to create a sublinear solution?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Given the variance of leetCode run times, I suspect that a sample size of 10 is inadequate (especially if all samples are taken on the same day). I\\'m not sure that picking an outlier is the best idea."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@mshoosterman](/mshoosterman) the point is, LC test case developers are well aware of this and normally would give you the worst possible scenarios for all typical implementations."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Why not? Submit 10 times at different time of the day, pick best. The usual statistic gathering routine. How to people measure non-deterministic real life processes?"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) perfect!"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Worstcase sublinear is certainly impossible. Since the list can be sorted except for a single element, which means you necessarily have to check all elements. \\n\\nAverage case is a harder question because you need to ask what is the distribution? if we take our input to be a random list, then consider the average runtime, any failfast solution, which returns false as soon as it sees a contradiction, should actually be pretty close to O(1) average runtime, since most lists will have a contradiction in the first few elements. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Are you relying on the leetCode timer to judge your submission times?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@anwendeng](/anwendeng) well, perhaps it does not beat 100% anymore: https://leetcode.com/submissions/detail/1062141454/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) One of my C++ code using  adjacent_difference has runtime 61 ms & beats 100%, that is a 2 pass code!"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "If we were checking whether the array is *strictly* in/decreasing, we could have taken a binary search approach which we all know has a TC of $O(\\\\log n)$. But alas...  \\nMight be worth mentioning this fact if this problem ever gets asked in an actual interview though!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Managed to get 55 ms and a top execution time for C++ with a simple trick.\nWhen LC gives you test cases, they usually intend to catch improper handling of edge cases.\nConsidering that, for sequences beyond certain length I first check linear ordering of elements at 1/4, 2/4, 3/4-th indexes and the last element. If it holds, then run the usual loop with early exit checking each consecutive pair.\nAlso I always start with comparing the first element with the last element regardless of the length.\nIt still has linear time of course, but in some cases it becomes constant.\nThe previous record was 61 ms with a linear loop containing excessive branch points (which CPUs don't like), but I couldn't get less than 68 ms even for better implementation - tried a dozen of submissions.\n\nP.S. Tried an exponential search (check 1-st, 2-nd, 4-th, 8-th, etc. elements) and got 53 ms after a few tries. That's about it. No ideas how to push it further, except may be tuning the degree base."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@rajan_jasani9](/rajan_jasani9) That\\'s what I did.\\nhttps://leetcode.com/submissions/detail/1061885493/"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) what if we just return False when the 1st violation occurs? "
                    },
                    {
                        "username": "sergei99",
                        "content": "May be if you look at Timsort merge algorithm, that would help. It detects long subsequences with natural ordering and skips entire ranges based on that. It defaults to element by element handling if the natural ordering guess turned out to be wrong - so it has to detect such cases somehow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Aadil42](/Aadil42) Yes. I tried but not successful, 305/371 are pass! A binary search solution can solve some patterns but not all. For example if there is just 1 exception, BS works."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@anwendeng](/anwendeng) When you say sublinear, do you mean O(log(n)) time?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@hero080](/hero080) Yes, sublinear is not possible but you can code your solution for an early exit if the first violation occurs early in the array. (Many solutions keep going to the end of the array regardless of where the first violation occurs)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hero080](/hero080) Yes. A sublinear solution is not possible."
                    },
                    {
                        "username": "hero080",
                        "content": "The solution has to be $\\\\Omega(n)$ because there might be only a single element in `nums` that violates the monotonic condition and we have to check every index to find it."
                    },
                    {
                        "username": "freezeen3",
                        "content": "So guys today is the Chinese Mid-Autumn Festival, it\\'s good to have a relaxing day with Leetcode\\'s support!"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Everyone have a nice Friday! You have more time today for other stuff to do ;)"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I wish I could know what tomorrows hard problem will be, so I can get a head start! "
                    },
                    {
                        "username": "IAmBadAtLeetcode",
                        "content": "no.. need to leetcode more. it was too easy today, need to keep going lol"
                    },
                    {
                        "username": "demaw",
                        "content": "any valid solution must run in (at least) O(n) time. consider the case [3,3,3,3, ... ,7, ... 3,3,3]. because a number like 7 could exist anywhere in a potentially monotonic array full of 3s, we must check every index of the array to be sure that it is monotonic"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "Good Friday easy task. We almost made it in September, keep it up guys!"
                    },
                    {
                        "username": "shakibaenur",
                        "content": "* Initialize two boolean variables: isIncreasing and isDecreasing to false\\n* Start the loop from index 1 compare with its previous element.\\n* If an element is greater than its previous element then set isIncreasing=true(means the array is increasing)\\n* If an element is smaller than its previous element then set isDecreasing=true(means the array is decreasing)\\n* if both isIncreasing and isDecreasing are true then return false and break as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nWas it helpful ... support by upvote."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Month End should be peace like this :)"
                    },
                    {
                        "username": "singlamuskan1208",
                        "content": "Do we have any solution with less than O(n) time complx?"
                    },
                    {
                        "username": "sergei99",
                        "content": "To an extent. We can use some heuristics exploiting the data structure and failing fast for non-ordered sequences (not just trivial early exit from the loop, but there are other techniques).\\nBut proving that sequence is ordered cannot be less than $$O(n)$$."
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I dont think so, because to compare the elements, we must iterate through the array. So to iterate through the array, we must use for loop.\\n"
                    }
                ]
            },
            {
                "id": 2076339,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Tomorrow is both a weekend and a month-end. Brace yourselves."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s the problem for reference: [132 Pattern](https://leetcode.com/problems/132-pattern/)"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Oh no... Past 2 questions have been too easy, I\\'m afraid tomorrow is going to be a big bad HARD smacked on our face..."
                    },
                    {
                        "username": "user5400vw",
                        "content": "our lives are at stake "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Initialize two boolean variables: isIncreasing and isDecreasing to true\\nStarting from the second element, compare each element with its previous element.\\nIf an element is less than its previous element, set isIncreasing to false (indicating the array is not increasing).\\nIf an element is greater than its previous element, set isDecreasing to false (indicating the array is not decreasing).\\nIf both isIncreasing and isDecreasing are false, break the loop as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nReturn if either isIncreasing or isDecreasing is true since the array is considered monotonic if one of them is true and non monotonic if both are false.\\n\\nwas it helpful ... support by upvote."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Have a nice day!  It\\'s again an easy question.  O(n) solution is expected, but is it possible to create a sublinear solution?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Given the variance of leetCode run times, I suspect that a sample size of 10 is inadequate (especially if all samples are taken on the same day). I\\'m not sure that picking an outlier is the best idea."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@mshoosterman](/mshoosterman) the point is, LC test case developers are well aware of this and normally would give you the worst possible scenarios for all typical implementations."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Why not? Submit 10 times at different time of the day, pick best. The usual statistic gathering routine. How to people measure non-deterministic real life processes?"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) perfect!"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Worstcase sublinear is certainly impossible. Since the list can be sorted except for a single element, which means you necessarily have to check all elements. \\n\\nAverage case is a harder question because you need to ask what is the distribution? if we take our input to be a random list, then consider the average runtime, any failfast solution, which returns false as soon as it sees a contradiction, should actually be pretty close to O(1) average runtime, since most lists will have a contradiction in the first few elements. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Are you relying on the leetCode timer to judge your submission times?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@anwendeng](/anwendeng) well, perhaps it does not beat 100% anymore: https://leetcode.com/submissions/detail/1062141454/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) One of my C++ code using  adjacent_difference has runtime 61 ms & beats 100%, that is a 2 pass code!"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "If we were checking whether the array is *strictly* in/decreasing, we could have taken a binary search approach which we all know has a TC of $O(\\\\log n)$. But alas...  \\nMight be worth mentioning this fact if this problem ever gets asked in an actual interview though!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Managed to get 55 ms and a top execution time for C++ with a simple trick.\nWhen LC gives you test cases, they usually intend to catch improper handling of edge cases.\nConsidering that, for sequences beyond certain length I first check linear ordering of elements at 1/4, 2/4, 3/4-th indexes and the last element. If it holds, then run the usual loop with early exit checking each consecutive pair.\nAlso I always start with comparing the first element with the last element regardless of the length.\nIt still has linear time of course, but in some cases it becomes constant.\nThe previous record was 61 ms with a linear loop containing excessive branch points (which CPUs don't like), but I couldn't get less than 68 ms even for better implementation - tried a dozen of submissions.\n\nP.S. Tried an exponential search (check 1-st, 2-nd, 4-th, 8-th, etc. elements) and got 53 ms after a few tries. That's about it. No ideas how to push it further, except may be tuning the degree base."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@rajan_jasani9](/rajan_jasani9) That\\'s what I did.\\nhttps://leetcode.com/submissions/detail/1061885493/"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) what if we just return False when the 1st violation occurs? "
                    },
                    {
                        "username": "sergei99",
                        "content": "May be if you look at Timsort merge algorithm, that would help. It detects long subsequences with natural ordering and skips entire ranges based on that. It defaults to element by element handling if the natural ordering guess turned out to be wrong - so it has to detect such cases somehow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Aadil42](/Aadil42) Yes. I tried but not successful, 305/371 are pass! A binary search solution can solve some patterns but not all. For example if there is just 1 exception, BS works."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@anwendeng](/anwendeng) When you say sublinear, do you mean O(log(n)) time?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@hero080](/hero080) Yes, sublinear is not possible but you can code your solution for an early exit if the first violation occurs early in the array. (Many solutions keep going to the end of the array regardless of where the first violation occurs)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hero080](/hero080) Yes. A sublinear solution is not possible."
                    },
                    {
                        "username": "hero080",
                        "content": "The solution has to be $\\\\Omega(n)$ because there might be only a single element in `nums` that violates the monotonic condition and we have to check every index to find it."
                    },
                    {
                        "username": "freezeen3",
                        "content": "So guys today is the Chinese Mid-Autumn Festival, it\\'s good to have a relaxing day with Leetcode\\'s support!"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Everyone have a nice Friday! You have more time today for other stuff to do ;)"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I wish I could know what tomorrows hard problem will be, so I can get a head start! "
                    },
                    {
                        "username": "IAmBadAtLeetcode",
                        "content": "no.. need to leetcode more. it was too easy today, need to keep going lol"
                    },
                    {
                        "username": "demaw",
                        "content": "any valid solution must run in (at least) O(n) time. consider the case [3,3,3,3, ... ,7, ... 3,3,3]. because a number like 7 could exist anywhere in a potentially monotonic array full of 3s, we must check every index of the array to be sure that it is monotonic"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "Good Friday easy task. We almost made it in September, keep it up guys!"
                    },
                    {
                        "username": "shakibaenur",
                        "content": "* Initialize two boolean variables: isIncreasing and isDecreasing to false\\n* Start the loop from index 1 compare with its previous element.\\n* If an element is greater than its previous element then set isIncreasing=true(means the array is increasing)\\n* If an element is smaller than its previous element then set isDecreasing=true(means the array is decreasing)\\n* if both isIncreasing and isDecreasing are true then return false and break as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nWas it helpful ... support by upvote."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Month End should be peace like this :)"
                    },
                    {
                        "username": "singlamuskan1208",
                        "content": "Do we have any solution with less than O(n) time complx?"
                    },
                    {
                        "username": "sergei99",
                        "content": "To an extent. We can use some heuristics exploiting the data structure and failing fast for non-ordered sequences (not just trivial early exit from the loop, but there are other techniques).\\nBut proving that sequence is ordered cannot be less than $$O(n)$$."
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I dont think so, because to compare the elements, we must iterate through the array. So to iterate through the array, we must use for loop.\\n"
                    }
                ]
            },
            {
                "id": 2076323,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Tomorrow is both a weekend and a month-end. Brace yourselves."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s the problem for reference: [132 Pattern](https://leetcode.com/problems/132-pattern/)"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Oh no... Past 2 questions have been too easy, I\\'m afraid tomorrow is going to be a big bad HARD smacked on our face..."
                    },
                    {
                        "username": "user5400vw",
                        "content": "our lives are at stake "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Initialize two boolean variables: isIncreasing and isDecreasing to true\\nStarting from the second element, compare each element with its previous element.\\nIf an element is less than its previous element, set isIncreasing to false (indicating the array is not increasing).\\nIf an element is greater than its previous element, set isDecreasing to false (indicating the array is not decreasing).\\nIf both isIncreasing and isDecreasing are false, break the loop as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nReturn if either isIncreasing or isDecreasing is true since the array is considered monotonic if one of them is true and non monotonic if both are false.\\n\\nwas it helpful ... support by upvote."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Have a nice day!  It\\'s again an easy question.  O(n) solution is expected, but is it possible to create a sublinear solution?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Given the variance of leetCode run times, I suspect that a sample size of 10 is inadequate (especially if all samples are taken on the same day). I\\'m not sure that picking an outlier is the best idea."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@mshoosterman](/mshoosterman) the point is, LC test case developers are well aware of this and normally would give you the worst possible scenarios for all typical implementations."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Why not? Submit 10 times at different time of the day, pick best. The usual statistic gathering routine. How to people measure non-deterministic real life processes?"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) perfect!"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Worstcase sublinear is certainly impossible. Since the list can be sorted except for a single element, which means you necessarily have to check all elements. \\n\\nAverage case is a harder question because you need to ask what is the distribution? if we take our input to be a random list, then consider the average runtime, any failfast solution, which returns false as soon as it sees a contradiction, should actually be pretty close to O(1) average runtime, since most lists will have a contradiction in the first few elements. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Are you relying on the leetCode timer to judge your submission times?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@anwendeng](/anwendeng) well, perhaps it does not beat 100% anymore: https://leetcode.com/submissions/detail/1062141454/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) One of my C++ code using  adjacent_difference has runtime 61 ms & beats 100%, that is a 2 pass code!"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "If we were checking whether the array is *strictly* in/decreasing, we could have taken a binary search approach which we all know has a TC of $O(\\\\log n)$. But alas...  \\nMight be worth mentioning this fact if this problem ever gets asked in an actual interview though!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Managed to get 55 ms and a top execution time for C++ with a simple trick.\nWhen LC gives you test cases, they usually intend to catch improper handling of edge cases.\nConsidering that, for sequences beyond certain length I first check linear ordering of elements at 1/4, 2/4, 3/4-th indexes and the last element. If it holds, then run the usual loop with early exit checking each consecutive pair.\nAlso I always start with comparing the first element with the last element regardless of the length.\nIt still has linear time of course, but in some cases it becomes constant.\nThe previous record was 61 ms with a linear loop containing excessive branch points (which CPUs don't like), but I couldn't get less than 68 ms even for better implementation - tried a dozen of submissions.\n\nP.S. Tried an exponential search (check 1-st, 2-nd, 4-th, 8-th, etc. elements) and got 53 ms after a few tries. That's about it. No ideas how to push it further, except may be tuning the degree base."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@rajan_jasani9](/rajan_jasani9) That\\'s what I did.\\nhttps://leetcode.com/submissions/detail/1061885493/"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) what if we just return False when the 1st violation occurs? "
                    },
                    {
                        "username": "sergei99",
                        "content": "May be if you look at Timsort merge algorithm, that would help. It detects long subsequences with natural ordering and skips entire ranges based on that. It defaults to element by element handling if the natural ordering guess turned out to be wrong - so it has to detect such cases somehow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Aadil42](/Aadil42) Yes. I tried but not successful, 305/371 are pass! A binary search solution can solve some patterns but not all. For example if there is just 1 exception, BS works."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@anwendeng](/anwendeng) When you say sublinear, do you mean O(log(n)) time?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@hero080](/hero080) Yes, sublinear is not possible but you can code your solution for an early exit if the first violation occurs early in the array. (Many solutions keep going to the end of the array regardless of where the first violation occurs)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hero080](/hero080) Yes. A sublinear solution is not possible."
                    },
                    {
                        "username": "hero080",
                        "content": "The solution has to be $\\\\Omega(n)$ because there might be only a single element in `nums` that violates the monotonic condition and we have to check every index to find it."
                    },
                    {
                        "username": "freezeen3",
                        "content": "So guys today is the Chinese Mid-Autumn Festival, it\\'s good to have a relaxing day with Leetcode\\'s support!"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Everyone have a nice Friday! You have more time today for other stuff to do ;)"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I wish I could know what tomorrows hard problem will be, so I can get a head start! "
                    },
                    {
                        "username": "IAmBadAtLeetcode",
                        "content": "no.. need to leetcode more. it was too easy today, need to keep going lol"
                    },
                    {
                        "username": "demaw",
                        "content": "any valid solution must run in (at least) O(n) time. consider the case [3,3,3,3, ... ,7, ... 3,3,3]. because a number like 7 could exist anywhere in a potentially monotonic array full of 3s, we must check every index of the array to be sure that it is monotonic"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "Good Friday easy task. We almost made it in September, keep it up guys!"
                    },
                    {
                        "username": "shakibaenur",
                        "content": "* Initialize two boolean variables: isIncreasing and isDecreasing to false\\n* Start the loop from index 1 compare with its previous element.\\n* If an element is greater than its previous element then set isIncreasing=true(means the array is increasing)\\n* If an element is smaller than its previous element then set isDecreasing=true(means the array is decreasing)\\n* if both isIncreasing and isDecreasing are true then return false and break as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nWas it helpful ... support by upvote."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Month End should be peace like this :)"
                    },
                    {
                        "username": "singlamuskan1208",
                        "content": "Do we have any solution with less than O(n) time complx?"
                    },
                    {
                        "username": "sergei99",
                        "content": "To an extent. We can use some heuristics exploiting the data structure and failing fast for non-ordered sequences (not just trivial early exit from the loop, but there are other techniques).\\nBut proving that sequence is ordered cannot be less than $$O(n)$$."
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I dont think so, because to compare the elements, we must iterate through the array. So to iterate through the array, we must use for loop.\\n"
                    }
                ]
            },
            {
                "id": 2077034,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Tomorrow is both a weekend and a month-end. Brace yourselves."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s the problem for reference: [132 Pattern](https://leetcode.com/problems/132-pattern/)"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Oh no... Past 2 questions have been too easy, I\\'m afraid tomorrow is going to be a big bad HARD smacked on our face..."
                    },
                    {
                        "username": "user5400vw",
                        "content": "our lives are at stake "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Initialize two boolean variables: isIncreasing and isDecreasing to true\\nStarting from the second element, compare each element with its previous element.\\nIf an element is less than its previous element, set isIncreasing to false (indicating the array is not increasing).\\nIf an element is greater than its previous element, set isDecreasing to false (indicating the array is not decreasing).\\nIf both isIncreasing and isDecreasing are false, break the loop as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nReturn if either isIncreasing or isDecreasing is true since the array is considered monotonic if one of them is true and non monotonic if both are false.\\n\\nwas it helpful ... support by upvote."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Have a nice day!  It\\'s again an easy question.  O(n) solution is expected, but is it possible to create a sublinear solution?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Given the variance of leetCode run times, I suspect that a sample size of 10 is inadequate (especially if all samples are taken on the same day). I\\'m not sure that picking an outlier is the best idea."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@mshoosterman](/mshoosterman) the point is, LC test case developers are well aware of this and normally would give you the worst possible scenarios for all typical implementations."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Why not? Submit 10 times at different time of the day, pick best. The usual statistic gathering routine. How to people measure non-deterministic real life processes?"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) perfect!"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Worstcase sublinear is certainly impossible. Since the list can be sorted except for a single element, which means you necessarily have to check all elements. \\n\\nAverage case is a harder question because you need to ask what is the distribution? if we take our input to be a random list, then consider the average runtime, any failfast solution, which returns false as soon as it sees a contradiction, should actually be pretty close to O(1) average runtime, since most lists will have a contradiction in the first few elements. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Are you relying on the leetCode timer to judge your submission times?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@anwendeng](/anwendeng) well, perhaps it does not beat 100% anymore: https://leetcode.com/submissions/detail/1062141454/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) One of my C++ code using  adjacent_difference has runtime 61 ms & beats 100%, that is a 2 pass code!"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "If we were checking whether the array is *strictly* in/decreasing, we could have taken a binary search approach which we all know has a TC of $O(\\\\log n)$. But alas...  \\nMight be worth mentioning this fact if this problem ever gets asked in an actual interview though!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Managed to get 55 ms and a top execution time for C++ with a simple trick.\nWhen LC gives you test cases, they usually intend to catch improper handling of edge cases.\nConsidering that, for sequences beyond certain length I first check linear ordering of elements at 1/4, 2/4, 3/4-th indexes and the last element. If it holds, then run the usual loop with early exit checking each consecutive pair.\nAlso I always start with comparing the first element with the last element regardless of the length.\nIt still has linear time of course, but in some cases it becomes constant.\nThe previous record was 61 ms with a linear loop containing excessive branch points (which CPUs don't like), but I couldn't get less than 68 ms even for better implementation - tried a dozen of submissions.\n\nP.S. Tried an exponential search (check 1-st, 2-nd, 4-th, 8-th, etc. elements) and got 53 ms after a few tries. That's about it. No ideas how to push it further, except may be tuning the degree base."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@rajan_jasani9](/rajan_jasani9) That\\'s what I did.\\nhttps://leetcode.com/submissions/detail/1061885493/"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) what if we just return False when the 1st violation occurs? "
                    },
                    {
                        "username": "sergei99",
                        "content": "May be if you look at Timsort merge algorithm, that would help. It detects long subsequences with natural ordering and skips entire ranges based on that. It defaults to element by element handling if the natural ordering guess turned out to be wrong - so it has to detect such cases somehow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Aadil42](/Aadil42) Yes. I tried but not successful, 305/371 are pass! A binary search solution can solve some patterns but not all. For example if there is just 1 exception, BS works."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@anwendeng](/anwendeng) When you say sublinear, do you mean O(log(n)) time?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@hero080](/hero080) Yes, sublinear is not possible but you can code your solution for an early exit if the first violation occurs early in the array. (Many solutions keep going to the end of the array regardless of where the first violation occurs)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hero080](/hero080) Yes. A sublinear solution is not possible."
                    },
                    {
                        "username": "hero080",
                        "content": "The solution has to be $\\\\Omega(n)$ because there might be only a single element in `nums` that violates the monotonic condition and we have to check every index to find it."
                    },
                    {
                        "username": "freezeen3",
                        "content": "So guys today is the Chinese Mid-Autumn Festival, it\\'s good to have a relaxing day with Leetcode\\'s support!"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Everyone have a nice Friday! You have more time today for other stuff to do ;)"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I wish I could know what tomorrows hard problem will be, so I can get a head start! "
                    },
                    {
                        "username": "IAmBadAtLeetcode",
                        "content": "no.. need to leetcode more. it was too easy today, need to keep going lol"
                    },
                    {
                        "username": "demaw",
                        "content": "any valid solution must run in (at least) O(n) time. consider the case [3,3,3,3, ... ,7, ... 3,3,3]. because a number like 7 could exist anywhere in a potentially monotonic array full of 3s, we must check every index of the array to be sure that it is monotonic"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "Good Friday easy task. We almost made it in September, keep it up guys!"
                    },
                    {
                        "username": "shakibaenur",
                        "content": "* Initialize two boolean variables: isIncreasing and isDecreasing to false\\n* Start the loop from index 1 compare with its previous element.\\n* If an element is greater than its previous element then set isIncreasing=true(means the array is increasing)\\n* If an element is smaller than its previous element then set isDecreasing=true(means the array is decreasing)\\n* if both isIncreasing and isDecreasing are true then return false and break as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nWas it helpful ... support by upvote."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Month End should be peace like this :)"
                    },
                    {
                        "username": "singlamuskan1208",
                        "content": "Do we have any solution with less than O(n) time complx?"
                    },
                    {
                        "username": "sergei99",
                        "content": "To an extent. We can use some heuristics exploiting the data structure and failing fast for non-ordered sequences (not just trivial early exit from the loop, but there are other techniques).\\nBut proving that sequence is ordered cannot be less than $$O(n)$$."
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I dont think so, because to compare the elements, we must iterate through the array. So to iterate through the array, we must use for loop.\\n"
                    }
                ]
            },
            {
                "id": 2076490,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Tomorrow is both a weekend and a month-end. Brace yourselves."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s the problem for reference: [132 Pattern](https://leetcode.com/problems/132-pattern/)"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Oh no... Past 2 questions have been too easy, I\\'m afraid tomorrow is going to be a big bad HARD smacked on our face..."
                    },
                    {
                        "username": "user5400vw",
                        "content": "our lives are at stake "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Initialize two boolean variables: isIncreasing and isDecreasing to true\\nStarting from the second element, compare each element with its previous element.\\nIf an element is less than its previous element, set isIncreasing to false (indicating the array is not increasing).\\nIf an element is greater than its previous element, set isDecreasing to false (indicating the array is not decreasing).\\nIf both isIncreasing and isDecreasing are false, break the loop as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nReturn if either isIncreasing or isDecreasing is true since the array is considered monotonic if one of them is true and non monotonic if both are false.\\n\\nwas it helpful ... support by upvote."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Have a nice day!  It\\'s again an easy question.  O(n) solution is expected, but is it possible to create a sublinear solution?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Given the variance of leetCode run times, I suspect that a sample size of 10 is inadequate (especially if all samples are taken on the same day). I\\'m not sure that picking an outlier is the best idea."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@mshoosterman](/mshoosterman) the point is, LC test case developers are well aware of this and normally would give you the worst possible scenarios for all typical implementations."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Why not? Submit 10 times at different time of the day, pick best. The usual statistic gathering routine. How to people measure non-deterministic real life processes?"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) perfect!"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Worstcase sublinear is certainly impossible. Since the list can be sorted except for a single element, which means you necessarily have to check all elements. \\n\\nAverage case is a harder question because you need to ask what is the distribution? if we take our input to be a random list, then consider the average runtime, any failfast solution, which returns false as soon as it sees a contradiction, should actually be pretty close to O(1) average runtime, since most lists will have a contradiction in the first few elements. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Are you relying on the leetCode timer to judge your submission times?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@anwendeng](/anwendeng) well, perhaps it does not beat 100% anymore: https://leetcode.com/submissions/detail/1062141454/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) One of my C++ code using  adjacent_difference has runtime 61 ms & beats 100%, that is a 2 pass code!"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "If we were checking whether the array is *strictly* in/decreasing, we could have taken a binary search approach which we all know has a TC of $O(\\\\log n)$. But alas...  \\nMight be worth mentioning this fact if this problem ever gets asked in an actual interview though!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Managed to get 55 ms and a top execution time for C++ with a simple trick.\nWhen LC gives you test cases, they usually intend to catch improper handling of edge cases.\nConsidering that, for sequences beyond certain length I first check linear ordering of elements at 1/4, 2/4, 3/4-th indexes and the last element. If it holds, then run the usual loop with early exit checking each consecutive pair.\nAlso I always start with comparing the first element with the last element regardless of the length.\nIt still has linear time of course, but in some cases it becomes constant.\nThe previous record was 61 ms with a linear loop containing excessive branch points (which CPUs don't like), but I couldn't get less than 68 ms even for better implementation - tried a dozen of submissions.\n\nP.S. Tried an exponential search (check 1-st, 2-nd, 4-th, 8-th, etc. elements) and got 53 ms after a few tries. That's about it. No ideas how to push it further, except may be tuning the degree base."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@rajan_jasani9](/rajan_jasani9) That\\'s what I did.\\nhttps://leetcode.com/submissions/detail/1061885493/"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) what if we just return False when the 1st violation occurs? "
                    },
                    {
                        "username": "sergei99",
                        "content": "May be if you look at Timsort merge algorithm, that would help. It detects long subsequences with natural ordering and skips entire ranges based on that. It defaults to element by element handling if the natural ordering guess turned out to be wrong - so it has to detect such cases somehow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Aadil42](/Aadil42) Yes. I tried but not successful, 305/371 are pass! A binary search solution can solve some patterns but not all. For example if there is just 1 exception, BS works."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@anwendeng](/anwendeng) When you say sublinear, do you mean O(log(n)) time?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@hero080](/hero080) Yes, sublinear is not possible but you can code your solution for an early exit if the first violation occurs early in the array. (Many solutions keep going to the end of the array regardless of where the first violation occurs)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hero080](/hero080) Yes. A sublinear solution is not possible."
                    },
                    {
                        "username": "hero080",
                        "content": "The solution has to be $\\\\Omega(n)$ because there might be only a single element in `nums` that violates the monotonic condition and we have to check every index to find it."
                    },
                    {
                        "username": "freezeen3",
                        "content": "So guys today is the Chinese Mid-Autumn Festival, it\\'s good to have a relaxing day with Leetcode\\'s support!"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Everyone have a nice Friday! You have more time today for other stuff to do ;)"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I wish I could know what tomorrows hard problem will be, so I can get a head start! "
                    },
                    {
                        "username": "IAmBadAtLeetcode",
                        "content": "no.. need to leetcode more. it was too easy today, need to keep going lol"
                    },
                    {
                        "username": "demaw",
                        "content": "any valid solution must run in (at least) O(n) time. consider the case [3,3,3,3, ... ,7, ... 3,3,3]. because a number like 7 could exist anywhere in a potentially monotonic array full of 3s, we must check every index of the array to be sure that it is monotonic"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "Good Friday easy task. We almost made it in September, keep it up guys!"
                    },
                    {
                        "username": "shakibaenur",
                        "content": "* Initialize two boolean variables: isIncreasing and isDecreasing to false\\n* Start the loop from index 1 compare with its previous element.\\n* If an element is greater than its previous element then set isIncreasing=true(means the array is increasing)\\n* If an element is smaller than its previous element then set isDecreasing=true(means the array is decreasing)\\n* if both isIncreasing and isDecreasing are true then return false and break as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nWas it helpful ... support by upvote."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Month End should be peace like this :)"
                    },
                    {
                        "username": "singlamuskan1208",
                        "content": "Do we have any solution with less than O(n) time complx?"
                    },
                    {
                        "username": "sergei99",
                        "content": "To an extent. We can use some heuristics exploiting the data structure and failing fast for non-ordered sequences (not just trivial early exit from the loop, but there are other techniques).\\nBut proving that sequence is ordered cannot be less than $$O(n)$$."
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I dont think so, because to compare the elements, we must iterate through the array. So to iterate through the array, we must use for loop.\\n"
                    }
                ]
            },
            {
                "id": 1672119,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Tomorrow is both a weekend and a month-end. Brace yourselves."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s the problem for reference: [132 Pattern](https://leetcode.com/problems/132-pattern/)"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Oh no... Past 2 questions have been too easy, I\\'m afraid tomorrow is going to be a big bad HARD smacked on our face..."
                    },
                    {
                        "username": "user5400vw",
                        "content": "our lives are at stake "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Initialize two boolean variables: isIncreasing and isDecreasing to true\\nStarting from the second element, compare each element with its previous element.\\nIf an element is less than its previous element, set isIncreasing to false (indicating the array is not increasing).\\nIf an element is greater than its previous element, set isDecreasing to false (indicating the array is not decreasing).\\nIf both isIncreasing and isDecreasing are false, break the loop as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nReturn if either isIncreasing or isDecreasing is true since the array is considered monotonic if one of them is true and non monotonic if both are false.\\n\\nwas it helpful ... support by upvote."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Have a nice day!  It\\'s again an easy question.  O(n) solution is expected, but is it possible to create a sublinear solution?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Given the variance of leetCode run times, I suspect that a sample size of 10 is inadequate (especially if all samples are taken on the same day). I\\'m not sure that picking an outlier is the best idea."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@mshoosterman](/mshoosterman) the point is, LC test case developers are well aware of this and normally would give you the worst possible scenarios for all typical implementations."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Why not? Submit 10 times at different time of the day, pick best. The usual statistic gathering routine. How to people measure non-deterministic real life processes?"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) perfect!"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Worstcase sublinear is certainly impossible. Since the list can be sorted except for a single element, which means you necessarily have to check all elements. \\n\\nAverage case is a harder question because you need to ask what is the distribution? if we take our input to be a random list, then consider the average runtime, any failfast solution, which returns false as soon as it sees a contradiction, should actually be pretty close to O(1) average runtime, since most lists will have a contradiction in the first few elements. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Are you relying on the leetCode timer to judge your submission times?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@anwendeng](/anwendeng) well, perhaps it does not beat 100% anymore: https://leetcode.com/submissions/detail/1062141454/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) One of my C++ code using  adjacent_difference has runtime 61 ms & beats 100%, that is a 2 pass code!"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "If we were checking whether the array is *strictly* in/decreasing, we could have taken a binary search approach which we all know has a TC of $O(\\\\log n)$. But alas...  \\nMight be worth mentioning this fact if this problem ever gets asked in an actual interview though!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Managed to get 55 ms and a top execution time for C++ with a simple trick.\nWhen LC gives you test cases, they usually intend to catch improper handling of edge cases.\nConsidering that, for sequences beyond certain length I first check linear ordering of elements at 1/4, 2/4, 3/4-th indexes and the last element. If it holds, then run the usual loop with early exit checking each consecutive pair.\nAlso I always start with comparing the first element with the last element regardless of the length.\nIt still has linear time of course, but in some cases it becomes constant.\nThe previous record was 61 ms with a linear loop containing excessive branch points (which CPUs don't like), but I couldn't get less than 68 ms even for better implementation - tried a dozen of submissions.\n\nP.S. Tried an exponential search (check 1-st, 2-nd, 4-th, 8-th, etc. elements) and got 53 ms after a few tries. That's about it. No ideas how to push it further, except may be tuning the degree base."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@rajan_jasani9](/rajan_jasani9) That\\'s what I did.\\nhttps://leetcode.com/submissions/detail/1061885493/"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) what if we just return False when the 1st violation occurs? "
                    },
                    {
                        "username": "sergei99",
                        "content": "May be if you look at Timsort merge algorithm, that would help. It detects long subsequences with natural ordering and skips entire ranges based on that. It defaults to element by element handling if the natural ordering guess turned out to be wrong - so it has to detect such cases somehow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Aadil42](/Aadil42) Yes. I tried but not successful, 305/371 are pass! A binary search solution can solve some patterns but not all. For example if there is just 1 exception, BS works."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@anwendeng](/anwendeng) When you say sublinear, do you mean O(log(n)) time?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@hero080](/hero080) Yes, sublinear is not possible but you can code your solution for an early exit if the first violation occurs early in the array. (Many solutions keep going to the end of the array regardless of where the first violation occurs)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hero080](/hero080) Yes. A sublinear solution is not possible."
                    },
                    {
                        "username": "hero080",
                        "content": "The solution has to be $\\\\Omega(n)$ because there might be only a single element in `nums` that violates the monotonic condition and we have to check every index to find it."
                    },
                    {
                        "username": "freezeen3",
                        "content": "So guys today is the Chinese Mid-Autumn Festival, it\\'s good to have a relaxing day with Leetcode\\'s support!"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Everyone have a nice Friday! You have more time today for other stuff to do ;)"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I wish I could know what tomorrows hard problem will be, so I can get a head start! "
                    },
                    {
                        "username": "IAmBadAtLeetcode",
                        "content": "no.. need to leetcode more. it was too easy today, need to keep going lol"
                    },
                    {
                        "username": "demaw",
                        "content": "any valid solution must run in (at least) O(n) time. consider the case [3,3,3,3, ... ,7, ... 3,3,3]. because a number like 7 could exist anywhere in a potentially monotonic array full of 3s, we must check every index of the array to be sure that it is monotonic"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "Good Friday easy task. We almost made it in September, keep it up guys!"
                    },
                    {
                        "username": "shakibaenur",
                        "content": "* Initialize two boolean variables: isIncreasing and isDecreasing to false\\n* Start the loop from index 1 compare with its previous element.\\n* If an element is greater than its previous element then set isIncreasing=true(means the array is increasing)\\n* If an element is smaller than its previous element then set isDecreasing=true(means the array is decreasing)\\n* if both isIncreasing and isDecreasing are true then return false and break as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nWas it helpful ... support by upvote."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Month End should be peace like this :)"
                    },
                    {
                        "username": "singlamuskan1208",
                        "content": "Do we have any solution with less than O(n) time complx?"
                    },
                    {
                        "username": "sergei99",
                        "content": "To an extent. We can use some heuristics exploiting the data structure and failing fast for non-ordered sequences (not just trivial early exit from the loop, but there are other techniques).\\nBut proving that sequence is ordered cannot be less than $$O(n)$$."
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I dont think so, because to compare the elements, we must iterate through the array. So to iterate through the array, we must use for loop.\\n"
                    }
                ]
            },
            {
                "id": 1572137,
                "content": [
                    {
                        "username": "knownfemme",
                        "content": "So, both the one pass solution and the double pass solution run in O(n) time. Therefore, for large inputs of data, we can expect both solutions to perform similarly. I want to argue the double pass solution is actually the better option because it should be easier to maintain in the long run. For example, it should be easier for someone unfamiliar with the code who might be tasked with updating it to look at it and determine how the code works.\\n\\nOf course, there the single pass solution is faster and arguably more clever. What are your opinions? If you had to defend a solution, which one would you defend and why? "
                    },
                    {
                        "username": "anshu22sri",
                        "content": "Can you help me with a problem??"
                    },
                    {
                        "username": "jenkunsen",
                        "content": "You can instantly check whether or not an array is potentially monotone increasing or monotone decreasing by comparing the first and last element of said array."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@deCodeIt](/deCodeIt) It\\'s still not a great help. You are just adding a third case to the list: all elements are equal and we don\\'t have to check for this otherwise."
                    },
                    {
                        "username": "moris_7",
                        "content": "But if elements that are in the middle of 1st and last element, are greater than or less than 1st and last element then this method won\\'t work.\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "[@psionl0](/psionl0) well in that case all the elements in the array should be equal to it to be a monotone so it  still helps :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "That doesn\\'t help much if the first and last elements are the same."
                    },
                    {
                        "username": "phat_dang",
                        "content": "First we can detect the array is increasing or decreasing by comparing first and last elements\\nThen any 2 adjacent elements break that flag, considering as a false case"
                    },
                    {
                        "username": "s3stan",
                        "content": "Apparently tomorrow I\\'ll have to think carefully"
                    },
                    {
                        "username": "sk4142",
                        "content": "the calm before the storm"
                    },
                    {
                        "username": "Daksh_Makhija",
                        "content": "In constraints, it is given -10^5 <= nums[i] <= 10^5 . It should be 10^(-5) <= nums[i] <= 10^5. Pls reply if you agree on this everyone."
                    },
                    {
                        "username": "psionl0",
                        "content": "The lack of other replies suggests that nobody agrees with you. This is an array of integers and 10^(-5) is not an integer."
                    },
                    {
                        "username": "buithanh2342002",
                        "content": "An array is monotonic if it is either monotone increasing or monotone decreasing. So, it\\'s supposed to be false if an array is not increasing or decreasing. [1,1,1,1] -> false"
                    },
                    {
                        "username": "psionl0",
                        "content": "LeetCode is not defining \"monotonic\" correctly. Mathematically speaking, a function is monotonic if no two elements from the domain map to the same element in the range. This means that the array should be strictly increasing or strictly decreasing and not merely non-decreasing or non-increasing."
                    },
                    {
                        "username": "m-shazaib",
                        "content": "Exactly"
                    },
                    {
                        "username": "m-shazaib",
                        "content": "basically break down the problem.\n1. for an array to be monotonic they can't have both tendencies. \n2. keeping the above in mind, check for previous and next elements in your array. \n3. now for comparing, you might use two variables of type bool, i.e isIncreasing and isDecreasing.\n4. Assign values to them.\n5. At the end check if your variables complies with point  1 above. (isIncreasing==isDecreasing)\n\nThis is a pseudocode. You still have some work to do mate.\n"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "pretty quiet before the storm comes....."
                    },
                    {
                        "username": "realitant",
                        "content": "Obviously python is a comparatively slow language, but does anyone have insight as to why it\\'s so slow on this problem in particular?\\nMy python and java solutions were both about 65%. Java ran in 2ms; Python was around 850ms.\\nI\\'m used to seeing about a 10x runtime differential. 425x is unexpected."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@Harsh-br0](/Harsh-br0) it does, but java measurements here are nevertheless very stable.\\nMay be they commit a System.gc() after every call, excluding its time from summary, I don\\'t know."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@sergei99](/sergei99) java also have a GC , no?\\n"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess they measure pure execution time for Java, while Python, Scala, etc. measurements include GC and other overhead. Even C++ execution s typically slower than Java."
                    }
                ]
            },
            {
                "id": 2028130,
                "content": [
                    {
                        "username": "knownfemme",
                        "content": "So, both the one pass solution and the double pass solution run in O(n) time. Therefore, for large inputs of data, we can expect both solutions to perform similarly. I want to argue the double pass solution is actually the better option because it should be easier to maintain in the long run. For example, it should be easier for someone unfamiliar with the code who might be tasked with updating it to look at it and determine how the code works.\\n\\nOf course, there the single pass solution is faster and arguably more clever. What are your opinions? If you had to defend a solution, which one would you defend and why? "
                    },
                    {
                        "username": "anshu22sri",
                        "content": "Can you help me with a problem??"
                    },
                    {
                        "username": "jenkunsen",
                        "content": "You can instantly check whether or not an array is potentially monotone increasing or monotone decreasing by comparing the first and last element of said array."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@deCodeIt](/deCodeIt) It\\'s still not a great help. You are just adding a third case to the list: all elements are equal and we don\\'t have to check for this otherwise."
                    },
                    {
                        "username": "moris_7",
                        "content": "But if elements that are in the middle of 1st and last element, are greater than or less than 1st and last element then this method won\\'t work.\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "[@psionl0](/psionl0) well in that case all the elements in the array should be equal to it to be a monotone so it  still helps :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "That doesn\\'t help much if the first and last elements are the same."
                    },
                    {
                        "username": "phat_dang",
                        "content": "First we can detect the array is increasing or decreasing by comparing first and last elements\\nThen any 2 adjacent elements break that flag, considering as a false case"
                    },
                    {
                        "username": "s3stan",
                        "content": "Apparently tomorrow I\\'ll have to think carefully"
                    },
                    {
                        "username": "sk4142",
                        "content": "the calm before the storm"
                    },
                    {
                        "username": "Daksh_Makhija",
                        "content": "In constraints, it is given -10^5 <= nums[i] <= 10^5 . It should be 10^(-5) <= nums[i] <= 10^5. Pls reply if you agree on this everyone."
                    },
                    {
                        "username": "psionl0",
                        "content": "The lack of other replies suggests that nobody agrees with you. This is an array of integers and 10^(-5) is not an integer."
                    },
                    {
                        "username": "buithanh2342002",
                        "content": "An array is monotonic if it is either monotone increasing or monotone decreasing. So, it\\'s supposed to be false if an array is not increasing or decreasing. [1,1,1,1] -> false"
                    },
                    {
                        "username": "psionl0",
                        "content": "LeetCode is not defining \"monotonic\" correctly. Mathematically speaking, a function is monotonic if no two elements from the domain map to the same element in the range. This means that the array should be strictly increasing or strictly decreasing and not merely non-decreasing or non-increasing."
                    },
                    {
                        "username": "m-shazaib",
                        "content": "Exactly"
                    },
                    {
                        "username": "m-shazaib",
                        "content": "basically break down the problem.\n1. for an array to be monotonic they can't have both tendencies. \n2. keeping the above in mind, check for previous and next elements in your array. \n3. now for comparing, you might use two variables of type bool, i.e isIncreasing and isDecreasing.\n4. Assign values to them.\n5. At the end check if your variables complies with point  1 above. (isIncreasing==isDecreasing)\n\nThis is a pseudocode. You still have some work to do mate.\n"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "pretty quiet before the storm comes....."
                    },
                    {
                        "username": "realitant",
                        "content": "Obviously python is a comparatively slow language, but does anyone have insight as to why it\\'s so slow on this problem in particular?\\nMy python and java solutions were both about 65%. Java ran in 2ms; Python was around 850ms.\\nI\\'m used to seeing about a 10x runtime differential. 425x is unexpected."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@Harsh-br0](/Harsh-br0) it does, but java measurements here are nevertheless very stable.\\nMay be they commit a System.gc() after every call, excluding its time from summary, I don\\'t know."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@sergei99](/sergei99) java also have a GC , no?\\n"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess they measure pure execution time for Java, while Python, Scala, etc. measurements include GC and other overhead. Even C++ execution s typically slower than Java."
                    }
                ]
            },
            {
                "id": 2077480,
                "content": [
                    {
                        "username": "knownfemme",
                        "content": "So, both the one pass solution and the double pass solution run in O(n) time. Therefore, for large inputs of data, we can expect both solutions to perform similarly. I want to argue the double pass solution is actually the better option because it should be easier to maintain in the long run. For example, it should be easier for someone unfamiliar with the code who might be tasked with updating it to look at it and determine how the code works.\\n\\nOf course, there the single pass solution is faster and arguably more clever. What are your opinions? If you had to defend a solution, which one would you defend and why? "
                    },
                    {
                        "username": "anshu22sri",
                        "content": "Can you help me with a problem??"
                    },
                    {
                        "username": "jenkunsen",
                        "content": "You can instantly check whether or not an array is potentially monotone increasing or monotone decreasing by comparing the first and last element of said array."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@deCodeIt](/deCodeIt) It\\'s still not a great help. You are just adding a third case to the list: all elements are equal and we don\\'t have to check for this otherwise."
                    },
                    {
                        "username": "moris_7",
                        "content": "But if elements that are in the middle of 1st and last element, are greater than or less than 1st and last element then this method won\\'t work.\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "[@psionl0](/psionl0) well in that case all the elements in the array should be equal to it to be a monotone so it  still helps :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "That doesn\\'t help much if the first and last elements are the same."
                    },
                    {
                        "username": "phat_dang",
                        "content": "First we can detect the array is increasing or decreasing by comparing first and last elements\\nThen any 2 adjacent elements break that flag, considering as a false case"
                    },
                    {
                        "username": "s3stan",
                        "content": "Apparently tomorrow I\\'ll have to think carefully"
                    },
                    {
                        "username": "sk4142",
                        "content": "the calm before the storm"
                    },
                    {
                        "username": "Daksh_Makhija",
                        "content": "In constraints, it is given -10^5 <= nums[i] <= 10^5 . It should be 10^(-5) <= nums[i] <= 10^5. Pls reply if you agree on this everyone."
                    },
                    {
                        "username": "psionl0",
                        "content": "The lack of other replies suggests that nobody agrees with you. This is an array of integers and 10^(-5) is not an integer."
                    },
                    {
                        "username": "buithanh2342002",
                        "content": "An array is monotonic if it is either monotone increasing or monotone decreasing. So, it\\'s supposed to be false if an array is not increasing or decreasing. [1,1,1,1] -> false"
                    },
                    {
                        "username": "psionl0",
                        "content": "LeetCode is not defining \"monotonic\" correctly. Mathematically speaking, a function is monotonic if no two elements from the domain map to the same element in the range. This means that the array should be strictly increasing or strictly decreasing and not merely non-decreasing or non-increasing."
                    },
                    {
                        "username": "m-shazaib",
                        "content": "Exactly"
                    },
                    {
                        "username": "m-shazaib",
                        "content": "basically break down the problem.\n1. for an array to be monotonic they can't have both tendencies. \n2. keeping the above in mind, check for previous and next elements in your array. \n3. now for comparing, you might use two variables of type bool, i.e isIncreasing and isDecreasing.\n4. Assign values to them.\n5. At the end check if your variables complies with point  1 above. (isIncreasing==isDecreasing)\n\nThis is a pseudocode. You still have some work to do mate.\n"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "pretty quiet before the storm comes....."
                    },
                    {
                        "username": "realitant",
                        "content": "Obviously python is a comparatively slow language, but does anyone have insight as to why it\\'s so slow on this problem in particular?\\nMy python and java solutions were both about 65%. Java ran in 2ms; Python was around 850ms.\\nI\\'m used to seeing about a 10x runtime differential. 425x is unexpected."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@Harsh-br0](/Harsh-br0) it does, but java measurements here are nevertheless very stable.\\nMay be they commit a System.gc() after every call, excluding its time from summary, I don\\'t know."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@sergei99](/sergei99) java also have a GC , no?\\n"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess they measure pure execution time for Java, while Python, Scala, etc. measurements include GC and other overhead. Even C++ execution s typically slower than Java."
                    }
                ]
            },
            {
                "id": 2077471,
                "content": [
                    {
                        "username": "knownfemme",
                        "content": "So, both the one pass solution and the double pass solution run in O(n) time. Therefore, for large inputs of data, we can expect both solutions to perform similarly. I want to argue the double pass solution is actually the better option because it should be easier to maintain in the long run. For example, it should be easier for someone unfamiliar with the code who might be tasked with updating it to look at it and determine how the code works.\\n\\nOf course, there the single pass solution is faster and arguably more clever. What are your opinions? If you had to defend a solution, which one would you defend and why? "
                    },
                    {
                        "username": "anshu22sri",
                        "content": "Can you help me with a problem??"
                    },
                    {
                        "username": "jenkunsen",
                        "content": "You can instantly check whether or not an array is potentially monotone increasing or monotone decreasing by comparing the first and last element of said array."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@deCodeIt](/deCodeIt) It\\'s still not a great help. You are just adding a third case to the list: all elements are equal and we don\\'t have to check for this otherwise."
                    },
                    {
                        "username": "moris_7",
                        "content": "But if elements that are in the middle of 1st and last element, are greater than or less than 1st and last element then this method won\\'t work.\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "[@psionl0](/psionl0) well in that case all the elements in the array should be equal to it to be a monotone so it  still helps :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "That doesn\\'t help much if the first and last elements are the same."
                    },
                    {
                        "username": "phat_dang",
                        "content": "First we can detect the array is increasing or decreasing by comparing first and last elements\\nThen any 2 adjacent elements break that flag, considering as a false case"
                    },
                    {
                        "username": "s3stan",
                        "content": "Apparently tomorrow I\\'ll have to think carefully"
                    },
                    {
                        "username": "sk4142",
                        "content": "the calm before the storm"
                    },
                    {
                        "username": "Daksh_Makhija",
                        "content": "In constraints, it is given -10^5 <= nums[i] <= 10^5 . It should be 10^(-5) <= nums[i] <= 10^5. Pls reply if you agree on this everyone."
                    },
                    {
                        "username": "psionl0",
                        "content": "The lack of other replies suggests that nobody agrees with you. This is an array of integers and 10^(-5) is not an integer."
                    },
                    {
                        "username": "buithanh2342002",
                        "content": "An array is monotonic if it is either monotone increasing or monotone decreasing. So, it\\'s supposed to be false if an array is not increasing or decreasing. [1,1,1,1] -> false"
                    },
                    {
                        "username": "psionl0",
                        "content": "LeetCode is not defining \"monotonic\" correctly. Mathematically speaking, a function is monotonic if no two elements from the domain map to the same element in the range. This means that the array should be strictly increasing or strictly decreasing and not merely non-decreasing or non-increasing."
                    },
                    {
                        "username": "m-shazaib",
                        "content": "Exactly"
                    },
                    {
                        "username": "m-shazaib",
                        "content": "basically break down the problem.\n1. for an array to be monotonic they can't have both tendencies. \n2. keeping the above in mind, check for previous and next elements in your array. \n3. now for comparing, you might use two variables of type bool, i.e isIncreasing and isDecreasing.\n4. Assign values to them.\n5. At the end check if your variables complies with point  1 above. (isIncreasing==isDecreasing)\n\nThis is a pseudocode. You still have some work to do mate.\n"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "pretty quiet before the storm comes....."
                    },
                    {
                        "username": "realitant",
                        "content": "Obviously python is a comparatively slow language, but does anyone have insight as to why it\\'s so slow on this problem in particular?\\nMy python and java solutions were both about 65%. Java ran in 2ms; Python was around 850ms.\\nI\\'m used to seeing about a 10x runtime differential. 425x is unexpected."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@Harsh-br0](/Harsh-br0) it does, but java measurements here are nevertheless very stable.\\nMay be they commit a System.gc() after every call, excluding its time from summary, I don\\'t know."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@sergei99](/sergei99) java also have a GC , no?\\n"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess they measure pure execution time for Java, while Python, Scala, etc. measurements include GC and other overhead. Even C++ execution s typically slower than Java."
                    }
                ]
            },
            {
                "id": 2077467,
                "content": [
                    {
                        "username": "knownfemme",
                        "content": "So, both the one pass solution and the double pass solution run in O(n) time. Therefore, for large inputs of data, we can expect both solutions to perform similarly. I want to argue the double pass solution is actually the better option because it should be easier to maintain in the long run. For example, it should be easier for someone unfamiliar with the code who might be tasked with updating it to look at it and determine how the code works.\\n\\nOf course, there the single pass solution is faster and arguably more clever. What are your opinions? If you had to defend a solution, which one would you defend and why? "
                    },
                    {
                        "username": "anshu22sri",
                        "content": "Can you help me with a problem??"
                    },
                    {
                        "username": "jenkunsen",
                        "content": "You can instantly check whether or not an array is potentially monotone increasing or monotone decreasing by comparing the first and last element of said array."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@deCodeIt](/deCodeIt) It\\'s still not a great help. You are just adding a third case to the list: all elements are equal and we don\\'t have to check for this otherwise."
                    },
                    {
                        "username": "moris_7",
                        "content": "But if elements that are in the middle of 1st and last element, are greater than or less than 1st and last element then this method won\\'t work.\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "[@psionl0](/psionl0) well in that case all the elements in the array should be equal to it to be a monotone so it  still helps :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "That doesn\\'t help much if the first and last elements are the same."
                    },
                    {
                        "username": "phat_dang",
                        "content": "First we can detect the array is increasing or decreasing by comparing first and last elements\\nThen any 2 adjacent elements break that flag, considering as a false case"
                    },
                    {
                        "username": "s3stan",
                        "content": "Apparently tomorrow I\\'ll have to think carefully"
                    },
                    {
                        "username": "sk4142",
                        "content": "the calm before the storm"
                    },
                    {
                        "username": "Daksh_Makhija",
                        "content": "In constraints, it is given -10^5 <= nums[i] <= 10^5 . It should be 10^(-5) <= nums[i] <= 10^5. Pls reply if you agree on this everyone."
                    },
                    {
                        "username": "psionl0",
                        "content": "The lack of other replies suggests that nobody agrees with you. This is an array of integers and 10^(-5) is not an integer."
                    },
                    {
                        "username": "buithanh2342002",
                        "content": "An array is monotonic if it is either monotone increasing or monotone decreasing. So, it\\'s supposed to be false if an array is not increasing or decreasing. [1,1,1,1] -> false"
                    },
                    {
                        "username": "psionl0",
                        "content": "LeetCode is not defining \"monotonic\" correctly. Mathematically speaking, a function is monotonic if no two elements from the domain map to the same element in the range. This means that the array should be strictly increasing or strictly decreasing and not merely non-decreasing or non-increasing."
                    },
                    {
                        "username": "m-shazaib",
                        "content": "Exactly"
                    },
                    {
                        "username": "m-shazaib",
                        "content": "basically break down the problem.\n1. for an array to be monotonic they can't have both tendencies. \n2. keeping the above in mind, check for previous and next elements in your array. \n3. now for comparing, you might use two variables of type bool, i.e isIncreasing and isDecreasing.\n4. Assign values to them.\n5. At the end check if your variables complies with point  1 above. (isIncreasing==isDecreasing)\n\nThis is a pseudocode. You still have some work to do mate.\n"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "pretty quiet before the storm comes....."
                    },
                    {
                        "username": "realitant",
                        "content": "Obviously python is a comparatively slow language, but does anyone have insight as to why it\\'s so slow on this problem in particular?\\nMy python and java solutions were both about 65%. Java ran in 2ms; Python was around 850ms.\\nI\\'m used to seeing about a 10x runtime differential. 425x is unexpected."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@Harsh-br0](/Harsh-br0) it does, but java measurements here are nevertheless very stable.\\nMay be they commit a System.gc() after every call, excluding its time from summary, I don\\'t know."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@sergei99](/sergei99) java also have a GC , no?\\n"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess they measure pure execution time for Java, while Python, Scala, etc. measurements include GC and other overhead. Even C++ execution s typically slower than Java."
                    }
                ]
            },
            {
                "id": 2077457,
                "content": [
                    {
                        "username": "knownfemme",
                        "content": "So, both the one pass solution and the double pass solution run in O(n) time. Therefore, for large inputs of data, we can expect both solutions to perform similarly. I want to argue the double pass solution is actually the better option because it should be easier to maintain in the long run. For example, it should be easier for someone unfamiliar with the code who might be tasked with updating it to look at it and determine how the code works.\\n\\nOf course, there the single pass solution is faster and arguably more clever. What are your opinions? If you had to defend a solution, which one would you defend and why? "
                    },
                    {
                        "username": "anshu22sri",
                        "content": "Can you help me with a problem??"
                    },
                    {
                        "username": "jenkunsen",
                        "content": "You can instantly check whether or not an array is potentially monotone increasing or monotone decreasing by comparing the first and last element of said array."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@deCodeIt](/deCodeIt) It\\'s still not a great help. You are just adding a third case to the list: all elements are equal and we don\\'t have to check for this otherwise."
                    },
                    {
                        "username": "moris_7",
                        "content": "But if elements that are in the middle of 1st and last element, are greater than or less than 1st and last element then this method won\\'t work.\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "[@psionl0](/psionl0) well in that case all the elements in the array should be equal to it to be a monotone so it  still helps :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "That doesn\\'t help much if the first and last elements are the same."
                    },
                    {
                        "username": "phat_dang",
                        "content": "First we can detect the array is increasing or decreasing by comparing first and last elements\\nThen any 2 adjacent elements break that flag, considering as a false case"
                    },
                    {
                        "username": "s3stan",
                        "content": "Apparently tomorrow I\\'ll have to think carefully"
                    },
                    {
                        "username": "sk4142",
                        "content": "the calm before the storm"
                    },
                    {
                        "username": "Daksh_Makhija",
                        "content": "In constraints, it is given -10^5 <= nums[i] <= 10^5 . It should be 10^(-5) <= nums[i] <= 10^5. Pls reply if you agree on this everyone."
                    },
                    {
                        "username": "psionl0",
                        "content": "The lack of other replies suggests that nobody agrees with you. This is an array of integers and 10^(-5) is not an integer."
                    },
                    {
                        "username": "buithanh2342002",
                        "content": "An array is monotonic if it is either monotone increasing or monotone decreasing. So, it\\'s supposed to be false if an array is not increasing or decreasing. [1,1,1,1] -> false"
                    },
                    {
                        "username": "psionl0",
                        "content": "LeetCode is not defining \"monotonic\" correctly. Mathematically speaking, a function is monotonic if no two elements from the domain map to the same element in the range. This means that the array should be strictly increasing or strictly decreasing and not merely non-decreasing or non-increasing."
                    },
                    {
                        "username": "m-shazaib",
                        "content": "Exactly"
                    },
                    {
                        "username": "m-shazaib",
                        "content": "basically break down the problem.\n1. for an array to be monotonic they can't have both tendencies. \n2. keeping the above in mind, check for previous and next elements in your array. \n3. now for comparing, you might use two variables of type bool, i.e isIncreasing and isDecreasing.\n4. Assign values to them.\n5. At the end check if your variables complies with point  1 above. (isIncreasing==isDecreasing)\n\nThis is a pseudocode. You still have some work to do mate.\n"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "pretty quiet before the storm comes....."
                    },
                    {
                        "username": "realitant",
                        "content": "Obviously python is a comparatively slow language, but does anyone have insight as to why it\\'s so slow on this problem in particular?\\nMy python and java solutions were both about 65%. Java ran in 2ms; Python was around 850ms.\\nI\\'m used to seeing about a 10x runtime differential. 425x is unexpected."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@Harsh-br0](/Harsh-br0) it does, but java measurements here are nevertheless very stable.\\nMay be they commit a System.gc() after every call, excluding its time from summary, I don\\'t know."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@sergei99](/sergei99) java also have a GC , no?\\n"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess they measure pure execution time for Java, while Python, Scala, etc. measurements include GC and other overhead. Even C++ execution s typically slower than Java."
                    }
                ]
            },
            {
                "id": 2077416,
                "content": [
                    {
                        "username": "knownfemme",
                        "content": "So, both the one pass solution and the double pass solution run in O(n) time. Therefore, for large inputs of data, we can expect both solutions to perform similarly. I want to argue the double pass solution is actually the better option because it should be easier to maintain in the long run. For example, it should be easier for someone unfamiliar with the code who might be tasked with updating it to look at it and determine how the code works.\\n\\nOf course, there the single pass solution is faster and arguably more clever. What are your opinions? If you had to defend a solution, which one would you defend and why? "
                    },
                    {
                        "username": "anshu22sri",
                        "content": "Can you help me with a problem??"
                    },
                    {
                        "username": "jenkunsen",
                        "content": "You can instantly check whether or not an array is potentially monotone increasing or monotone decreasing by comparing the first and last element of said array."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@deCodeIt](/deCodeIt) It\\'s still not a great help. You are just adding a third case to the list: all elements are equal and we don\\'t have to check for this otherwise."
                    },
                    {
                        "username": "moris_7",
                        "content": "But if elements that are in the middle of 1st and last element, are greater than or less than 1st and last element then this method won\\'t work.\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "[@psionl0](/psionl0) well in that case all the elements in the array should be equal to it to be a monotone so it  still helps :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "That doesn\\'t help much if the first and last elements are the same."
                    },
                    {
                        "username": "phat_dang",
                        "content": "First we can detect the array is increasing or decreasing by comparing first and last elements\\nThen any 2 adjacent elements break that flag, considering as a false case"
                    },
                    {
                        "username": "s3stan",
                        "content": "Apparently tomorrow I\\'ll have to think carefully"
                    },
                    {
                        "username": "sk4142",
                        "content": "the calm before the storm"
                    },
                    {
                        "username": "Daksh_Makhija",
                        "content": "In constraints, it is given -10^5 <= nums[i] <= 10^5 . It should be 10^(-5) <= nums[i] <= 10^5. Pls reply if you agree on this everyone."
                    },
                    {
                        "username": "psionl0",
                        "content": "The lack of other replies suggests that nobody agrees with you. This is an array of integers and 10^(-5) is not an integer."
                    },
                    {
                        "username": "buithanh2342002",
                        "content": "An array is monotonic if it is either monotone increasing or monotone decreasing. So, it\\'s supposed to be false if an array is not increasing or decreasing. [1,1,1,1] -> false"
                    },
                    {
                        "username": "psionl0",
                        "content": "LeetCode is not defining \"monotonic\" correctly. Mathematically speaking, a function is monotonic if no two elements from the domain map to the same element in the range. This means that the array should be strictly increasing or strictly decreasing and not merely non-decreasing or non-increasing."
                    },
                    {
                        "username": "m-shazaib",
                        "content": "Exactly"
                    },
                    {
                        "username": "m-shazaib",
                        "content": "basically break down the problem.\n1. for an array to be monotonic they can't have both tendencies. \n2. keeping the above in mind, check for previous and next elements in your array. \n3. now for comparing, you might use two variables of type bool, i.e isIncreasing and isDecreasing.\n4. Assign values to them.\n5. At the end check if your variables complies with point  1 above. (isIncreasing==isDecreasing)\n\nThis is a pseudocode. You still have some work to do mate.\n"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "pretty quiet before the storm comes....."
                    },
                    {
                        "username": "realitant",
                        "content": "Obviously python is a comparatively slow language, but does anyone have insight as to why it\\'s so slow on this problem in particular?\\nMy python and java solutions were both about 65%. Java ran in 2ms; Python was around 850ms.\\nI\\'m used to seeing about a 10x runtime differential. 425x is unexpected."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@Harsh-br0](/Harsh-br0) it does, but java measurements here are nevertheless very stable.\\nMay be they commit a System.gc() after every call, excluding its time from summary, I don\\'t know."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@sergei99](/sergei99) java also have a GC , no?\\n"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess they measure pure execution time for Java, while Python, Scala, etc. measurements include GC and other overhead. Even C++ execution s typically slower than Java."
                    }
                ]
            },
            {
                "id": 2077411,
                "content": [
                    {
                        "username": "knownfemme",
                        "content": "So, both the one pass solution and the double pass solution run in O(n) time. Therefore, for large inputs of data, we can expect both solutions to perform similarly. I want to argue the double pass solution is actually the better option because it should be easier to maintain in the long run. For example, it should be easier for someone unfamiliar with the code who might be tasked with updating it to look at it and determine how the code works.\\n\\nOf course, there the single pass solution is faster and arguably more clever. What are your opinions? If you had to defend a solution, which one would you defend and why? "
                    },
                    {
                        "username": "anshu22sri",
                        "content": "Can you help me with a problem??"
                    },
                    {
                        "username": "jenkunsen",
                        "content": "You can instantly check whether or not an array is potentially monotone increasing or monotone decreasing by comparing the first and last element of said array."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@deCodeIt](/deCodeIt) It\\'s still not a great help. You are just adding a third case to the list: all elements are equal and we don\\'t have to check for this otherwise."
                    },
                    {
                        "username": "moris_7",
                        "content": "But if elements that are in the middle of 1st and last element, are greater than or less than 1st and last element then this method won\\'t work.\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "[@psionl0](/psionl0) well in that case all the elements in the array should be equal to it to be a monotone so it  still helps :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "That doesn\\'t help much if the first and last elements are the same."
                    },
                    {
                        "username": "phat_dang",
                        "content": "First we can detect the array is increasing or decreasing by comparing first and last elements\\nThen any 2 adjacent elements break that flag, considering as a false case"
                    },
                    {
                        "username": "s3stan",
                        "content": "Apparently tomorrow I\\'ll have to think carefully"
                    },
                    {
                        "username": "sk4142",
                        "content": "the calm before the storm"
                    },
                    {
                        "username": "Daksh_Makhija",
                        "content": "In constraints, it is given -10^5 <= nums[i] <= 10^5 . It should be 10^(-5) <= nums[i] <= 10^5. Pls reply if you agree on this everyone."
                    },
                    {
                        "username": "psionl0",
                        "content": "The lack of other replies suggests that nobody agrees with you. This is an array of integers and 10^(-5) is not an integer."
                    },
                    {
                        "username": "buithanh2342002",
                        "content": "An array is monotonic if it is either monotone increasing or monotone decreasing. So, it\\'s supposed to be false if an array is not increasing or decreasing. [1,1,1,1] -> false"
                    },
                    {
                        "username": "psionl0",
                        "content": "LeetCode is not defining \"monotonic\" correctly. Mathematically speaking, a function is monotonic if no two elements from the domain map to the same element in the range. This means that the array should be strictly increasing or strictly decreasing and not merely non-decreasing or non-increasing."
                    },
                    {
                        "username": "m-shazaib",
                        "content": "Exactly"
                    },
                    {
                        "username": "m-shazaib",
                        "content": "basically break down the problem.\n1. for an array to be monotonic they can't have both tendencies. \n2. keeping the above in mind, check for previous and next elements in your array. \n3. now for comparing, you might use two variables of type bool, i.e isIncreasing and isDecreasing.\n4. Assign values to them.\n5. At the end check if your variables complies with point  1 above. (isIncreasing==isDecreasing)\n\nThis is a pseudocode. You still have some work to do mate.\n"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "pretty quiet before the storm comes....."
                    },
                    {
                        "username": "realitant",
                        "content": "Obviously python is a comparatively slow language, but does anyone have insight as to why it\\'s so slow on this problem in particular?\\nMy python and java solutions were both about 65%. Java ran in 2ms; Python was around 850ms.\\nI\\'m used to seeing about a 10x runtime differential. 425x is unexpected."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@Harsh-br0](/Harsh-br0) it does, but java measurements here are nevertheless very stable.\\nMay be they commit a System.gc() after every call, excluding its time from summary, I don\\'t know."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@sergei99](/sergei99) java also have a GC , no?\\n"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess they measure pure execution time for Java, while Python, Scala, etc. measurements include GC and other overhead. Even C++ execution s typically slower than Java."
                    }
                ]
            },
            {
                "id": 2077095,
                "content": [
                    {
                        "username": "knownfemme",
                        "content": "So, both the one pass solution and the double pass solution run in O(n) time. Therefore, for large inputs of data, we can expect both solutions to perform similarly. I want to argue the double pass solution is actually the better option because it should be easier to maintain in the long run. For example, it should be easier for someone unfamiliar with the code who might be tasked with updating it to look at it and determine how the code works.\\n\\nOf course, there the single pass solution is faster and arguably more clever. What are your opinions? If you had to defend a solution, which one would you defend and why? "
                    },
                    {
                        "username": "anshu22sri",
                        "content": "Can you help me with a problem??"
                    },
                    {
                        "username": "jenkunsen",
                        "content": "You can instantly check whether or not an array is potentially monotone increasing or monotone decreasing by comparing the first and last element of said array."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@deCodeIt](/deCodeIt) It\\'s still not a great help. You are just adding a third case to the list: all elements are equal and we don\\'t have to check for this otherwise."
                    },
                    {
                        "username": "moris_7",
                        "content": "But if elements that are in the middle of 1st and last element, are greater than or less than 1st and last element then this method won\\'t work.\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "[@psionl0](/psionl0) well in that case all the elements in the array should be equal to it to be a monotone so it  still helps :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "That doesn\\'t help much if the first and last elements are the same."
                    },
                    {
                        "username": "phat_dang",
                        "content": "First we can detect the array is increasing or decreasing by comparing first and last elements\\nThen any 2 adjacent elements break that flag, considering as a false case"
                    },
                    {
                        "username": "s3stan",
                        "content": "Apparently tomorrow I\\'ll have to think carefully"
                    },
                    {
                        "username": "sk4142",
                        "content": "the calm before the storm"
                    },
                    {
                        "username": "Daksh_Makhija",
                        "content": "In constraints, it is given -10^5 <= nums[i] <= 10^5 . It should be 10^(-5) <= nums[i] <= 10^5. Pls reply if you agree on this everyone."
                    },
                    {
                        "username": "psionl0",
                        "content": "The lack of other replies suggests that nobody agrees with you. This is an array of integers and 10^(-5) is not an integer."
                    },
                    {
                        "username": "buithanh2342002",
                        "content": "An array is monotonic if it is either monotone increasing or monotone decreasing. So, it\\'s supposed to be false if an array is not increasing or decreasing. [1,1,1,1] -> false"
                    },
                    {
                        "username": "psionl0",
                        "content": "LeetCode is not defining \"monotonic\" correctly. Mathematically speaking, a function is monotonic if no two elements from the domain map to the same element in the range. This means that the array should be strictly increasing or strictly decreasing and not merely non-decreasing or non-increasing."
                    },
                    {
                        "username": "m-shazaib",
                        "content": "Exactly"
                    },
                    {
                        "username": "m-shazaib",
                        "content": "basically break down the problem.\n1. for an array to be monotonic they can't have both tendencies. \n2. keeping the above in mind, check for previous and next elements in your array. \n3. now for comparing, you might use two variables of type bool, i.e isIncreasing and isDecreasing.\n4. Assign values to them.\n5. At the end check if your variables complies with point  1 above. (isIncreasing==isDecreasing)\n\nThis is a pseudocode. You still have some work to do mate.\n"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "pretty quiet before the storm comes....."
                    },
                    {
                        "username": "realitant",
                        "content": "Obviously python is a comparatively slow language, but does anyone have insight as to why it\\'s so slow on this problem in particular?\\nMy python and java solutions were both about 65%. Java ran in 2ms; Python was around 850ms.\\nI\\'m used to seeing about a 10x runtime differential. 425x is unexpected."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@Harsh-br0](/Harsh-br0) it does, but java measurements here are nevertheless very stable.\\nMay be they commit a System.gc() after every call, excluding its time from summary, I don\\'t know."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@sergei99](/sergei99) java also have a GC , no?\\n"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess they measure pure execution time for Java, while Python, Scala, etc. measurements include GC and other overhead. Even C++ execution s typically slower than Java."
                    }
                ]
            },
            {
                "id": 2077058,
                "content": [
                    {
                        "username": "knownfemme",
                        "content": "So, both the one pass solution and the double pass solution run in O(n) time. Therefore, for large inputs of data, we can expect both solutions to perform similarly. I want to argue the double pass solution is actually the better option because it should be easier to maintain in the long run. For example, it should be easier for someone unfamiliar with the code who might be tasked with updating it to look at it and determine how the code works.\\n\\nOf course, there the single pass solution is faster and arguably more clever. What are your opinions? If you had to defend a solution, which one would you defend and why? "
                    },
                    {
                        "username": "anshu22sri",
                        "content": "Can you help me with a problem??"
                    },
                    {
                        "username": "jenkunsen",
                        "content": "You can instantly check whether or not an array is potentially monotone increasing or monotone decreasing by comparing the first and last element of said array."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@deCodeIt](/deCodeIt) It\\'s still not a great help. You are just adding a third case to the list: all elements are equal and we don\\'t have to check for this otherwise."
                    },
                    {
                        "username": "moris_7",
                        "content": "But if elements that are in the middle of 1st and last element, are greater than or less than 1st and last element then this method won\\'t work.\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "[@psionl0](/psionl0) well in that case all the elements in the array should be equal to it to be a monotone so it  still helps :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "That doesn\\'t help much if the first and last elements are the same."
                    },
                    {
                        "username": "phat_dang",
                        "content": "First we can detect the array is increasing or decreasing by comparing first and last elements\\nThen any 2 adjacent elements break that flag, considering as a false case"
                    },
                    {
                        "username": "s3stan",
                        "content": "Apparently tomorrow I\\'ll have to think carefully"
                    },
                    {
                        "username": "sk4142",
                        "content": "the calm before the storm"
                    },
                    {
                        "username": "Daksh_Makhija",
                        "content": "In constraints, it is given -10^5 <= nums[i] <= 10^5 . It should be 10^(-5) <= nums[i] <= 10^5. Pls reply if you agree on this everyone."
                    },
                    {
                        "username": "psionl0",
                        "content": "The lack of other replies suggests that nobody agrees with you. This is an array of integers and 10^(-5) is not an integer."
                    },
                    {
                        "username": "buithanh2342002",
                        "content": "An array is monotonic if it is either monotone increasing or monotone decreasing. So, it\\'s supposed to be false if an array is not increasing or decreasing. [1,1,1,1] -> false"
                    },
                    {
                        "username": "psionl0",
                        "content": "LeetCode is not defining \"monotonic\" correctly. Mathematically speaking, a function is monotonic if no two elements from the domain map to the same element in the range. This means that the array should be strictly increasing or strictly decreasing and not merely non-decreasing or non-increasing."
                    },
                    {
                        "username": "m-shazaib",
                        "content": "Exactly"
                    },
                    {
                        "username": "m-shazaib",
                        "content": "basically break down the problem.\n1. for an array to be monotonic they can't have both tendencies. \n2. keeping the above in mind, check for previous and next elements in your array. \n3. now for comparing, you might use two variables of type bool, i.e isIncreasing and isDecreasing.\n4. Assign values to them.\n5. At the end check if your variables complies with point  1 above. (isIncreasing==isDecreasing)\n\nThis is a pseudocode. You still have some work to do mate.\n"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "pretty quiet before the storm comes....."
                    },
                    {
                        "username": "realitant",
                        "content": "Obviously python is a comparatively slow language, but does anyone have insight as to why it\\'s so slow on this problem in particular?\\nMy python and java solutions were both about 65%. Java ran in 2ms; Python was around 850ms.\\nI\\'m used to seeing about a 10x runtime differential. 425x is unexpected."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@Harsh-br0](/Harsh-br0) it does, but java measurements here are nevertheless very stable.\\nMay be they commit a System.gc() after every call, excluding its time from summary, I don\\'t know."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@sergei99](/sergei99) java also have a GC , no?\\n"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess they measure pure execution time for Java, while Python, Scala, etc. measurements include GC and other overhead. Even C++ execution s typically slower than Java."
                    }
                ]
            },
            {
                "id": 2077057,
                "content": [
                    {
                        "username": "ajaystealths",
                        "content": "check for increasing and decreasing of array in single loop and return false if it\\'s follow both the conditions, else return true.\\nAgain an easy question on the LC.\\nHave a nice day ahead!!!"
                    },
                    {
                        "username": "rhugvedbhojane10",
                        "content": "This is the calm before the storm. "
                    },
                    {
                        "username": "SG-C",
                        "content": "LeetCode end of month surprise \\uD83D\\uDE00 .\\nHappy LeetCoding !"
                    },
                    {
                        "username": "mannchandarana",
                        "content": "Good Friday , enjoy your friday\\n"
                    },
                    {
                        "username": "bughunter1712",
                        "content": "Today i got to know y spacing is important . The problem was pretty easy.:)"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Lucky Friday**"
                    },
                    {
                        "username": "user0463au",
                        "content": "Happy Mid-Autumn Festival!\\n1 day left in Sep., almost there!"
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "questions are easy in month last."
                    },
                    {
                        "username": "pankajkr_110",
                        "content": "leetcode hard is coming tommorow :)"
                    },
                    {
                        "username": "RuslanVdovychenko",
                        "content": "Java / Python3 / C++ solution (One-Pass, Summation)\\nhttps://leetcode.com/problems/monotonic-array/solutions/4104450/java-python3-c-solution-one-pass-summation/"
                    }
                ]
            },
            {
                "id": 2077046,
                "content": [
                    {
                        "username": "ajaystealths",
                        "content": "check for increasing and decreasing of array in single loop and return false if it\\'s follow both the conditions, else return true.\\nAgain an easy question on the LC.\\nHave a nice day ahead!!!"
                    },
                    {
                        "username": "rhugvedbhojane10",
                        "content": "This is the calm before the storm. "
                    },
                    {
                        "username": "SG-C",
                        "content": "LeetCode end of month surprise \\uD83D\\uDE00 .\\nHappy LeetCoding !"
                    },
                    {
                        "username": "mannchandarana",
                        "content": "Good Friday , enjoy your friday\\n"
                    },
                    {
                        "username": "bughunter1712",
                        "content": "Today i got to know y spacing is important . The problem was pretty easy.:)"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Lucky Friday**"
                    },
                    {
                        "username": "user0463au",
                        "content": "Happy Mid-Autumn Festival!\\n1 day left in Sep., almost there!"
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "questions are easy in month last."
                    },
                    {
                        "username": "pankajkr_110",
                        "content": "leetcode hard is coming tommorow :)"
                    },
                    {
                        "username": "RuslanVdovychenko",
                        "content": "Java / Python3 / C++ solution (One-Pass, Summation)\\nhttps://leetcode.com/problems/monotonic-array/solutions/4104450/java-python3-c-solution-one-pass-summation/"
                    }
                ]
            },
            {
                "id": 2076996,
                "content": [
                    {
                        "username": "ajaystealths",
                        "content": "check for increasing and decreasing of array in single loop and return false if it\\'s follow both the conditions, else return true.\\nAgain an easy question on the LC.\\nHave a nice day ahead!!!"
                    },
                    {
                        "username": "rhugvedbhojane10",
                        "content": "This is the calm before the storm. "
                    },
                    {
                        "username": "SG-C",
                        "content": "LeetCode end of month surprise \\uD83D\\uDE00 .\\nHappy LeetCoding !"
                    },
                    {
                        "username": "mannchandarana",
                        "content": "Good Friday , enjoy your friday\\n"
                    },
                    {
                        "username": "bughunter1712",
                        "content": "Today i got to know y spacing is important . The problem was pretty easy.:)"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Lucky Friday**"
                    },
                    {
                        "username": "user0463au",
                        "content": "Happy Mid-Autumn Festival!\\n1 day left in Sep., almost there!"
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "questions are easy in month last."
                    },
                    {
                        "username": "pankajkr_110",
                        "content": "leetcode hard is coming tommorow :)"
                    },
                    {
                        "username": "RuslanVdovychenko",
                        "content": "Java / Python3 / C++ solution (One-Pass, Summation)\\nhttps://leetcode.com/problems/monotonic-array/solutions/4104450/java-python3-c-solution-one-pass-summation/"
                    }
                ]
            },
            {
                "id": 2076986,
                "content": [
                    {
                        "username": "ajaystealths",
                        "content": "check for increasing and decreasing of array in single loop and return false if it\\'s follow both the conditions, else return true.\\nAgain an easy question on the LC.\\nHave a nice day ahead!!!"
                    },
                    {
                        "username": "rhugvedbhojane10",
                        "content": "This is the calm before the storm. "
                    },
                    {
                        "username": "SG-C",
                        "content": "LeetCode end of month surprise \\uD83D\\uDE00 .\\nHappy LeetCoding !"
                    },
                    {
                        "username": "mannchandarana",
                        "content": "Good Friday , enjoy your friday\\n"
                    },
                    {
                        "username": "bughunter1712",
                        "content": "Today i got to know y spacing is important . The problem was pretty easy.:)"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Lucky Friday**"
                    },
                    {
                        "username": "user0463au",
                        "content": "Happy Mid-Autumn Festival!\\n1 day left in Sep., almost there!"
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "questions are easy in month last."
                    },
                    {
                        "username": "pankajkr_110",
                        "content": "leetcode hard is coming tommorow :)"
                    },
                    {
                        "username": "RuslanVdovychenko",
                        "content": "Java / Python3 / C++ solution (One-Pass, Summation)\\nhttps://leetcode.com/problems/monotonic-array/solutions/4104450/java-python3-c-solution-one-pass-summation/"
                    }
                ]
            },
            {
                "id": 2076898,
                "content": [
                    {
                        "username": "ajaystealths",
                        "content": "check for increasing and decreasing of array in single loop and return false if it\\'s follow both the conditions, else return true.\\nAgain an easy question on the LC.\\nHave a nice day ahead!!!"
                    },
                    {
                        "username": "rhugvedbhojane10",
                        "content": "This is the calm before the storm. "
                    },
                    {
                        "username": "SG-C",
                        "content": "LeetCode end of month surprise \\uD83D\\uDE00 .\\nHappy LeetCoding !"
                    },
                    {
                        "username": "mannchandarana",
                        "content": "Good Friday , enjoy your friday\\n"
                    },
                    {
                        "username": "bughunter1712",
                        "content": "Today i got to know y spacing is important . The problem was pretty easy.:)"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Lucky Friday**"
                    },
                    {
                        "username": "user0463au",
                        "content": "Happy Mid-Autumn Festival!\\n1 day left in Sep., almost there!"
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "questions are easy in month last."
                    },
                    {
                        "username": "pankajkr_110",
                        "content": "leetcode hard is coming tommorow :)"
                    },
                    {
                        "username": "RuslanVdovychenko",
                        "content": "Java / Python3 / C++ solution (One-Pass, Summation)\\nhttps://leetcode.com/problems/monotonic-array/solutions/4104450/java-python3-c-solution-one-pass-summation/"
                    }
                ]
            },
            {
                "id": 2076860,
                "content": [
                    {
                        "username": "ajaystealths",
                        "content": "check for increasing and decreasing of array in single loop and return false if it\\'s follow both the conditions, else return true.\\nAgain an easy question on the LC.\\nHave a nice day ahead!!!"
                    },
                    {
                        "username": "rhugvedbhojane10",
                        "content": "This is the calm before the storm. "
                    },
                    {
                        "username": "SG-C",
                        "content": "LeetCode end of month surprise \\uD83D\\uDE00 .\\nHappy LeetCoding !"
                    },
                    {
                        "username": "mannchandarana",
                        "content": "Good Friday , enjoy your friday\\n"
                    },
                    {
                        "username": "bughunter1712",
                        "content": "Today i got to know y spacing is important . The problem was pretty easy.:)"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Lucky Friday**"
                    },
                    {
                        "username": "user0463au",
                        "content": "Happy Mid-Autumn Festival!\\n1 day left in Sep., almost there!"
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "questions are easy in month last."
                    },
                    {
                        "username": "pankajkr_110",
                        "content": "leetcode hard is coming tommorow :)"
                    },
                    {
                        "username": "RuslanVdovychenko",
                        "content": "Java / Python3 / C++ solution (One-Pass, Summation)\\nhttps://leetcode.com/problems/monotonic-array/solutions/4104450/java-python3-c-solution-one-pass-summation/"
                    }
                ]
            },
            {
                "id": 2076828,
                "content": [
                    {
                        "username": "ajaystealths",
                        "content": "check for increasing and decreasing of array in single loop and return false if it\\'s follow both the conditions, else return true.\\nAgain an easy question on the LC.\\nHave a nice day ahead!!!"
                    },
                    {
                        "username": "rhugvedbhojane10",
                        "content": "This is the calm before the storm. "
                    },
                    {
                        "username": "SG-C",
                        "content": "LeetCode end of month surprise \\uD83D\\uDE00 .\\nHappy LeetCoding !"
                    },
                    {
                        "username": "mannchandarana",
                        "content": "Good Friday , enjoy your friday\\n"
                    },
                    {
                        "username": "bughunter1712",
                        "content": "Today i got to know y spacing is important . The problem was pretty easy.:)"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Lucky Friday**"
                    },
                    {
                        "username": "user0463au",
                        "content": "Happy Mid-Autumn Festival!\\n1 day left in Sep., almost there!"
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "questions are easy in month last."
                    },
                    {
                        "username": "pankajkr_110",
                        "content": "leetcode hard is coming tommorow :)"
                    },
                    {
                        "username": "RuslanVdovychenko",
                        "content": "Java / Python3 / C++ solution (One-Pass, Summation)\\nhttps://leetcode.com/problems/monotonic-array/solutions/4104450/java-python3-c-solution-one-pass-summation/"
                    }
                ]
            },
            {
                "id": 2076794,
                "content": [
                    {
                        "username": "ajaystealths",
                        "content": "check for increasing and decreasing of array in single loop and return false if it\\'s follow both the conditions, else return true.\\nAgain an easy question on the LC.\\nHave a nice day ahead!!!"
                    },
                    {
                        "username": "rhugvedbhojane10",
                        "content": "This is the calm before the storm. "
                    },
                    {
                        "username": "SG-C",
                        "content": "LeetCode end of month surprise \\uD83D\\uDE00 .\\nHappy LeetCoding !"
                    },
                    {
                        "username": "mannchandarana",
                        "content": "Good Friday , enjoy your friday\\n"
                    },
                    {
                        "username": "bughunter1712",
                        "content": "Today i got to know y spacing is important . The problem was pretty easy.:)"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Lucky Friday**"
                    },
                    {
                        "username": "user0463au",
                        "content": "Happy Mid-Autumn Festival!\\n1 day left in Sep., almost there!"
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "questions are easy in month last."
                    },
                    {
                        "username": "pankajkr_110",
                        "content": "leetcode hard is coming tommorow :)"
                    },
                    {
                        "username": "RuslanVdovychenko",
                        "content": "Java / Python3 / C++ solution (One-Pass, Summation)\\nhttps://leetcode.com/problems/monotonic-array/solutions/4104450/java-python3-c-solution-one-pass-summation/"
                    }
                ]
            },
            {
                "id": 2076787,
                "content": [
                    {
                        "username": "ajaystealths",
                        "content": "check for increasing and decreasing of array in single loop and return false if it\\'s follow both the conditions, else return true.\\nAgain an easy question on the LC.\\nHave a nice day ahead!!!"
                    },
                    {
                        "username": "rhugvedbhojane10",
                        "content": "This is the calm before the storm. "
                    },
                    {
                        "username": "SG-C",
                        "content": "LeetCode end of month surprise \\uD83D\\uDE00 .\\nHappy LeetCoding !"
                    },
                    {
                        "username": "mannchandarana",
                        "content": "Good Friday , enjoy your friday\\n"
                    },
                    {
                        "username": "bughunter1712",
                        "content": "Today i got to know y spacing is important . The problem was pretty easy.:)"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Lucky Friday**"
                    },
                    {
                        "username": "user0463au",
                        "content": "Happy Mid-Autumn Festival!\\n1 day left in Sep., almost there!"
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "questions are easy in month last."
                    },
                    {
                        "username": "pankajkr_110",
                        "content": "leetcode hard is coming tommorow :)"
                    },
                    {
                        "username": "RuslanVdovychenko",
                        "content": "Java / Python3 / C++ solution (One-Pass, Summation)\\nhttps://leetcode.com/problems/monotonic-array/solutions/4104450/java-python3-c-solution-one-pass-summation/"
                    }
                ]
            },
            {
                "id": 2076770,
                "content": [
                    {
                        "username": "ajaystealths",
                        "content": "check for increasing and decreasing of array in single loop and return false if it\\'s follow both the conditions, else return true.\\nAgain an easy question on the LC.\\nHave a nice day ahead!!!"
                    },
                    {
                        "username": "rhugvedbhojane10",
                        "content": "This is the calm before the storm. "
                    },
                    {
                        "username": "SG-C",
                        "content": "LeetCode end of month surprise \\uD83D\\uDE00 .\\nHappy LeetCoding !"
                    },
                    {
                        "username": "mannchandarana",
                        "content": "Good Friday , enjoy your friday\\n"
                    },
                    {
                        "username": "bughunter1712",
                        "content": "Today i got to know y spacing is important . The problem was pretty easy.:)"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Lucky Friday**"
                    },
                    {
                        "username": "user0463au",
                        "content": "Happy Mid-Autumn Festival!\\n1 day left in Sep., almost there!"
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "questions are easy in month last."
                    },
                    {
                        "username": "pankajkr_110",
                        "content": "leetcode hard is coming tommorow :)"
                    },
                    {
                        "username": "RuslanVdovychenko",
                        "content": "Java / Python3 / C++ solution (One-Pass, Summation)\\nhttps://leetcode.com/problems/monotonic-array/solutions/4104450/java-python3-c-solution-one-pass-summation/"
                    }
                ]
            },
            {
                "id": 2076747,
                "content": [
                    {
                        "username": "swnsma",
                        "content": "Thank you Leet Code for nice Friday!\\nThat\\'s what we all need after last few exhausting weeks of not-ordinary Medium questions.\\nStay tuned for weekend + End of the Month challenge!"
                    },
                    {
                        "username": "reassurance",
                        "content": "Wish our life would be this monotonically easy"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "Have a good day!"
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Again easy-peasy."
                    },
                    {
                        "username": "Musfik41",
                        "content": "is monotonic means we have to check duplicate elements?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Duplicate elements will be together if the array is monotonic. No need to check for that - just move on."
                    },
                    {
                        "username": "adish_ct",
                        "content": "Monotonic means the elements in the array are either consistently increasing or consistently decreasing. \n\n[1,1,1,2,2,2,3,3,34,4,4,4,4] at this time you have to consider dupicates also."
                    },
                    {
                        "username": "adish_ct",
                        "content": "Sort method is enough to solve the problem but time comlexity will be high. \\nThe array contains either increasing or decreasing order ."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "Easy \\uD83D\\uDE0C"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Sort the array, reverse sort it then enjoy the weekend !"
                    },
                    {
                        "username": "Rahul_108",
                        "content": "No need to sort just iterate!"
                    },
                    {
                        "username": "verma1vedansh1",
                        "content": "Didn\\'t have anything to enjoy weekend hell for me doing House hold work of mom"
                    },
                    {
                        "username": "halfengineer",
                        "content": "That\\'s Suspicious\\uD83D\\uDE12\\uD83D\\uDE12,Something coming on weekend."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "good easy days, enjoy as they last"
                    }
                ]
            },
            {
                "id": 2076676,
                "content": [
                    {
                        "username": "swnsma",
                        "content": "Thank you Leet Code for nice Friday!\\nThat\\'s what we all need after last few exhausting weeks of not-ordinary Medium questions.\\nStay tuned for weekend + End of the Month challenge!"
                    },
                    {
                        "username": "reassurance",
                        "content": "Wish our life would be this monotonically easy"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "Have a good day!"
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Again easy-peasy."
                    },
                    {
                        "username": "Musfik41",
                        "content": "is monotonic means we have to check duplicate elements?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Duplicate elements will be together if the array is monotonic. No need to check for that - just move on."
                    },
                    {
                        "username": "adish_ct",
                        "content": "Monotonic means the elements in the array are either consistently increasing or consistently decreasing. \n\n[1,1,1,2,2,2,3,3,34,4,4,4,4] at this time you have to consider dupicates also."
                    },
                    {
                        "username": "adish_ct",
                        "content": "Sort method is enough to solve the problem but time comlexity will be high. \\nThe array contains either increasing or decreasing order ."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "Easy \\uD83D\\uDE0C"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Sort the array, reverse sort it then enjoy the weekend !"
                    },
                    {
                        "username": "Rahul_108",
                        "content": "No need to sort just iterate!"
                    },
                    {
                        "username": "verma1vedansh1",
                        "content": "Didn\\'t have anything to enjoy weekend hell for me doing House hold work of mom"
                    },
                    {
                        "username": "halfengineer",
                        "content": "That\\'s Suspicious\\uD83D\\uDE12\\uD83D\\uDE12,Something coming on weekend."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "good easy days, enjoy as they last"
                    }
                ]
            },
            {
                "id": 2076657,
                "content": [
                    {
                        "username": "swnsma",
                        "content": "Thank you Leet Code for nice Friday!\\nThat\\'s what we all need after last few exhausting weeks of not-ordinary Medium questions.\\nStay tuned for weekend + End of the Month challenge!"
                    },
                    {
                        "username": "reassurance",
                        "content": "Wish our life would be this monotonically easy"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "Have a good day!"
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Again easy-peasy."
                    },
                    {
                        "username": "Musfik41",
                        "content": "is monotonic means we have to check duplicate elements?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Duplicate elements will be together if the array is monotonic. No need to check for that - just move on."
                    },
                    {
                        "username": "adish_ct",
                        "content": "Monotonic means the elements in the array are either consistently increasing or consistently decreasing. \n\n[1,1,1,2,2,2,3,3,34,4,4,4,4] at this time you have to consider dupicates also."
                    },
                    {
                        "username": "adish_ct",
                        "content": "Sort method is enough to solve the problem but time comlexity will be high. \\nThe array contains either increasing or decreasing order ."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "Easy \\uD83D\\uDE0C"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Sort the array, reverse sort it then enjoy the weekend !"
                    },
                    {
                        "username": "Rahul_108",
                        "content": "No need to sort just iterate!"
                    },
                    {
                        "username": "verma1vedansh1",
                        "content": "Didn\\'t have anything to enjoy weekend hell for me doing House hold work of mom"
                    },
                    {
                        "username": "halfengineer",
                        "content": "That\\'s Suspicious\\uD83D\\uDE12\\uD83D\\uDE12,Something coming on weekend."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "good easy days, enjoy as they last"
                    }
                ]
            },
            {
                "id": 2076640,
                "content": [
                    {
                        "username": "swnsma",
                        "content": "Thank you Leet Code for nice Friday!\\nThat\\'s what we all need after last few exhausting weeks of not-ordinary Medium questions.\\nStay tuned for weekend + End of the Month challenge!"
                    },
                    {
                        "username": "reassurance",
                        "content": "Wish our life would be this monotonically easy"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "Have a good day!"
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Again easy-peasy."
                    },
                    {
                        "username": "Musfik41",
                        "content": "is monotonic means we have to check duplicate elements?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Duplicate elements will be together if the array is monotonic. No need to check for that - just move on."
                    },
                    {
                        "username": "adish_ct",
                        "content": "Monotonic means the elements in the array are either consistently increasing or consistently decreasing. \n\n[1,1,1,2,2,2,3,3,34,4,4,4,4] at this time you have to consider dupicates also."
                    },
                    {
                        "username": "adish_ct",
                        "content": "Sort method is enough to solve the problem but time comlexity will be high. \\nThe array contains either increasing or decreasing order ."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "Easy \\uD83D\\uDE0C"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Sort the array, reverse sort it then enjoy the weekend !"
                    },
                    {
                        "username": "Rahul_108",
                        "content": "No need to sort just iterate!"
                    },
                    {
                        "username": "verma1vedansh1",
                        "content": "Didn\\'t have anything to enjoy weekend hell for me doing House hold work of mom"
                    },
                    {
                        "username": "halfengineer",
                        "content": "That\\'s Suspicious\\uD83D\\uDE12\\uD83D\\uDE12,Something coming on weekend."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "good easy days, enjoy as they last"
                    }
                ]
            },
            {
                "id": 2076556,
                "content": [
                    {
                        "username": "swnsma",
                        "content": "Thank you Leet Code for nice Friday!\\nThat\\'s what we all need after last few exhausting weeks of not-ordinary Medium questions.\\nStay tuned for weekend + End of the Month challenge!"
                    },
                    {
                        "username": "reassurance",
                        "content": "Wish our life would be this monotonically easy"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "Have a good day!"
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Again easy-peasy."
                    },
                    {
                        "username": "Musfik41",
                        "content": "is monotonic means we have to check duplicate elements?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Duplicate elements will be together if the array is monotonic. No need to check for that - just move on."
                    },
                    {
                        "username": "adish_ct",
                        "content": "Monotonic means the elements in the array are either consistently increasing or consistently decreasing. \n\n[1,1,1,2,2,2,3,3,34,4,4,4,4] at this time you have to consider dupicates also."
                    },
                    {
                        "username": "adish_ct",
                        "content": "Sort method is enough to solve the problem but time comlexity will be high. \\nThe array contains either increasing or decreasing order ."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "Easy \\uD83D\\uDE0C"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Sort the array, reverse sort it then enjoy the weekend !"
                    },
                    {
                        "username": "Rahul_108",
                        "content": "No need to sort just iterate!"
                    },
                    {
                        "username": "verma1vedansh1",
                        "content": "Didn\\'t have anything to enjoy weekend hell for me doing House hold work of mom"
                    },
                    {
                        "username": "halfengineer",
                        "content": "That\\'s Suspicious\\uD83D\\uDE12\\uD83D\\uDE12,Something coming on weekend."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "good easy days, enjoy as they last"
                    }
                ]
            },
            {
                "id": 2076545,
                "content": [
                    {
                        "username": "swnsma",
                        "content": "Thank you Leet Code for nice Friday!\\nThat\\'s what we all need after last few exhausting weeks of not-ordinary Medium questions.\\nStay tuned for weekend + End of the Month challenge!"
                    },
                    {
                        "username": "reassurance",
                        "content": "Wish our life would be this monotonically easy"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "Have a good day!"
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Again easy-peasy."
                    },
                    {
                        "username": "Musfik41",
                        "content": "is monotonic means we have to check duplicate elements?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Duplicate elements will be together if the array is monotonic. No need to check for that - just move on."
                    },
                    {
                        "username": "adish_ct",
                        "content": "Monotonic means the elements in the array are either consistently increasing or consistently decreasing. \n\n[1,1,1,2,2,2,3,3,34,4,4,4,4] at this time you have to consider dupicates also."
                    },
                    {
                        "username": "adish_ct",
                        "content": "Sort method is enough to solve the problem but time comlexity will be high. \\nThe array contains either increasing or decreasing order ."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "Easy \\uD83D\\uDE0C"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Sort the array, reverse sort it then enjoy the weekend !"
                    },
                    {
                        "username": "Rahul_108",
                        "content": "No need to sort just iterate!"
                    },
                    {
                        "username": "verma1vedansh1",
                        "content": "Didn\\'t have anything to enjoy weekend hell for me doing House hold work of mom"
                    },
                    {
                        "username": "halfengineer",
                        "content": "That\\'s Suspicious\\uD83D\\uDE12\\uD83D\\uDE12,Something coming on weekend."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "good easy days, enjoy as they last"
                    }
                ]
            },
            {
                "id": 2076489,
                "content": [
                    {
                        "username": "swnsma",
                        "content": "Thank you Leet Code for nice Friday!\\nThat\\'s what we all need after last few exhausting weeks of not-ordinary Medium questions.\\nStay tuned for weekend + End of the Month challenge!"
                    },
                    {
                        "username": "reassurance",
                        "content": "Wish our life would be this monotonically easy"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "Have a good day!"
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Again easy-peasy."
                    },
                    {
                        "username": "Musfik41",
                        "content": "is monotonic means we have to check duplicate elements?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Duplicate elements will be together if the array is monotonic. No need to check for that - just move on."
                    },
                    {
                        "username": "adish_ct",
                        "content": "Monotonic means the elements in the array are either consistently increasing or consistently decreasing. \n\n[1,1,1,2,2,2,3,3,34,4,4,4,4] at this time you have to consider dupicates also."
                    },
                    {
                        "username": "adish_ct",
                        "content": "Sort method is enough to solve the problem but time comlexity will be high. \\nThe array contains either increasing or decreasing order ."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "Easy \\uD83D\\uDE0C"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Sort the array, reverse sort it then enjoy the weekend !"
                    },
                    {
                        "username": "Rahul_108",
                        "content": "No need to sort just iterate!"
                    },
                    {
                        "username": "verma1vedansh1",
                        "content": "Didn\\'t have anything to enjoy weekend hell for me doing House hold work of mom"
                    },
                    {
                        "username": "halfengineer",
                        "content": "That\\'s Suspicious\\uD83D\\uDE12\\uD83D\\uDE12,Something coming on weekend."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "good easy days, enjoy as they last"
                    }
                ]
            },
            {
                "id": 2076485,
                "content": [
                    {
                        "username": "swnsma",
                        "content": "Thank you Leet Code for nice Friday!\\nThat\\'s what we all need after last few exhausting weeks of not-ordinary Medium questions.\\nStay tuned for weekend + End of the Month challenge!"
                    },
                    {
                        "username": "reassurance",
                        "content": "Wish our life would be this monotonically easy"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "Have a good day!"
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Again easy-peasy."
                    },
                    {
                        "username": "Musfik41",
                        "content": "is monotonic means we have to check duplicate elements?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Duplicate elements will be together if the array is monotonic. No need to check for that - just move on."
                    },
                    {
                        "username": "adish_ct",
                        "content": "Monotonic means the elements in the array are either consistently increasing or consistently decreasing. \n\n[1,1,1,2,2,2,3,3,34,4,4,4,4] at this time you have to consider dupicates also."
                    },
                    {
                        "username": "adish_ct",
                        "content": "Sort method is enough to solve the problem but time comlexity will be high. \\nThe array contains either increasing or decreasing order ."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "Easy \\uD83D\\uDE0C"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Sort the array, reverse sort it then enjoy the weekend !"
                    },
                    {
                        "username": "Rahul_108",
                        "content": "No need to sort just iterate!"
                    },
                    {
                        "username": "verma1vedansh1",
                        "content": "Didn\\'t have anything to enjoy weekend hell for me doing House hold work of mom"
                    },
                    {
                        "username": "halfengineer",
                        "content": "That\\'s Suspicious\\uD83D\\uDE12\\uD83D\\uDE12,Something coming on weekend."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "good easy days, enjoy as they last"
                    }
                ]
            },
            {
                "id": 2076478,
                "content": [
                    {
                        "username": "swnsma",
                        "content": "Thank you Leet Code for nice Friday!\\nThat\\'s what we all need after last few exhausting weeks of not-ordinary Medium questions.\\nStay tuned for weekend + End of the Month challenge!"
                    },
                    {
                        "username": "reassurance",
                        "content": "Wish our life would be this monotonically easy"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "Have a good day!"
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Again easy-peasy."
                    },
                    {
                        "username": "Musfik41",
                        "content": "is monotonic means we have to check duplicate elements?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Duplicate elements will be together if the array is monotonic. No need to check for that - just move on."
                    },
                    {
                        "username": "adish_ct",
                        "content": "Monotonic means the elements in the array are either consistently increasing or consistently decreasing. \n\n[1,1,1,2,2,2,3,3,34,4,4,4,4] at this time you have to consider dupicates also."
                    },
                    {
                        "username": "adish_ct",
                        "content": "Sort method is enough to solve the problem but time comlexity will be high. \\nThe array contains either increasing or decreasing order ."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "Easy \\uD83D\\uDE0C"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Sort the array, reverse sort it then enjoy the weekend !"
                    },
                    {
                        "username": "Rahul_108",
                        "content": "No need to sort just iterate!"
                    },
                    {
                        "username": "verma1vedansh1",
                        "content": "Didn\\'t have anything to enjoy weekend hell for me doing House hold work of mom"
                    },
                    {
                        "username": "halfengineer",
                        "content": "That\\'s Suspicious\\uD83D\\uDE12\\uD83D\\uDE12,Something coming on weekend."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "good easy days, enjoy as they last"
                    }
                ]
            },
            {
                "id": 2076462,
                "content": [
                    {
                        "username": "swnsma",
                        "content": "Thank you Leet Code for nice Friday!\\nThat\\'s what we all need after last few exhausting weeks of not-ordinary Medium questions.\\nStay tuned for weekend + End of the Month challenge!"
                    },
                    {
                        "username": "reassurance",
                        "content": "Wish our life would be this monotonically easy"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "Have a good day!"
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Again easy-peasy."
                    },
                    {
                        "username": "Musfik41",
                        "content": "is monotonic means we have to check duplicate elements?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Duplicate elements will be together if the array is monotonic. No need to check for that - just move on."
                    },
                    {
                        "username": "adish_ct",
                        "content": "Monotonic means the elements in the array are either consistently increasing or consistently decreasing. \n\n[1,1,1,2,2,2,3,3,34,4,4,4,4] at this time you have to consider dupicates also."
                    },
                    {
                        "username": "adish_ct",
                        "content": "Sort method is enough to solve the problem but time comlexity will be high. \\nThe array contains either increasing or decreasing order ."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "Easy \\uD83D\\uDE0C"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Sort the array, reverse sort it then enjoy the weekend !"
                    },
                    {
                        "username": "Rahul_108",
                        "content": "No need to sort just iterate!"
                    },
                    {
                        "username": "verma1vedansh1",
                        "content": "Didn\\'t have anything to enjoy weekend hell for me doing House hold work of mom"
                    },
                    {
                        "username": "halfengineer",
                        "content": "That\\'s Suspicious\\uD83D\\uDE12\\uD83D\\uDE12,Something coming on weekend."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "good easy days, enjoy as they last"
                    }
                ]
            }
        ]
    }
]